#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82256410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256410);
		  /* 82256410h */ case    0:  		/* mfspr R12, LR */
		/* 82256410h case    0:*/		regs.R12 = regs.LR;
		/* 82256410h case    0:*/		return 0x82256414;
		  /* 82256414h */ case    1:  		/* bl -1855936 */
		/* 82256414h case    1:*/		regs.LR = 0x82256418; return 0x82091254;
		/* 82256414h case    1:*/		return 0x82256418;
	}
	return 0x82256418;
} // Block from 82256410h-82256418h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256418h
// Function '??0BaseAddr@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256418);
		  /* 82256418h */ case    0:  		/* stwu R1, <#[R1 - 176]> */
		/* 82256418h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82256418h case    0:*/		return 0x8225641C;
		  /* 8225641Ch */ case    1:  		/* std R6, <#[R1 + 216]> */
		/* 8225641Ch case    1:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225641Ch case    1:*/		return 0x82256420;
		  /* 82256420h */ case    2:  		/* lis R10, -32252 */
		/* 82256420h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82256420h case    2:*/		return 0x82256424;
		  /* 82256424h */ case    3:  		/* std R7, <#[R1 + 224]> */
		/* 82256424h case    3:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x000000E0) );
		/* 82256424h case    3:*/		return 0x82256428;
		  /* 82256428h */ case    4:  		/* addi R7, R1, 232 */
		/* 82256428h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xE8);
		/* 82256428h case    4:*/		return 0x8225642C;
		  /* 8225642Ch */ case    5:  		/* std R8, <#[R1 + 232]> */
		/* 8225642Ch case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x000000E8) );
		/* 8225642Ch case    5:*/		return 0x82256430;
		  /* 82256430h */ case    6:  		/* addi R11, R1, 96 */
		/* 82256430h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82256430h case    6:*/		return 0x82256434;
		  /* 82256434h */ case    7:  		/* std R9, <#[R1 + 240]> */
		/* 82256434h case    7:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x000000F0) );
		/* 82256434h case    7:*/		return 0x82256438;
		  /* 82256438h */ case    8:  		/* lis R9, -32252 */
		/* 82256438h case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82256438h case    8:*/		return 0x8225643C;
		  /* 8225643Ch */ case    9:  		/* mr R30, R3 */
		/* 8225643Ch case    9:*/		regs.R30 = regs.R3;
		/* 8225643Ch case    9:*/		return 0x82256440;
		  /* 82256440h */ case   10:  		/* stw R7, <#[R1 + 120]> */
		/* 82256440h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000078) );
		/* 82256440h case   10:*/		return 0x82256444;
		  /* 82256444h */ case   11:  		/* addi R8, R9, 27576 */
		/* 82256444h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x6BB8);
		/* 82256444h case   11:*/		return 0x82256448;
		  /* 82256448h */ case   12:  		/* lwz R31, <#[R10 + 28864]> */
		/* 82256448h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x000070C0) );
		/* 82256448h case   12:*/		return 0x8225644C;
		  /* 8225644Ch */ case   13:  		/* addi R9, R1, 216 */
		/* 8225644Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xD8);
		/* 8225644Ch case   13:*/		return 0x82256450;
		  /* 82256450h */ case   14:  		/* addi R10, R1, 224 */
		/* 82256450h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xE0);
		/* 82256450h case   14:*/		return 0x82256454;
		  /* 82256454h */ case   15:  		/* stw R8, <#[R1 + 96]> */
		/* 82256454h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82256454h case   15:*/		return 0x82256458;
	}
	return 0x82256458;
} // Block from 82256418h-82256458h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82256458h
// Function '??0AddrIndexedSet@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256458);
		  /* 82256458h */ case    0:  		/* stw R9, <#[R1 + 112]> */
		/* 82256458h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000070) );
		/* 82256458h case    0:*/		return 0x8225645C;
		  /* 8225645Ch */ case    1:  		/* addi R9, R1, 240 */
		/* 8225645Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xF0);
		/* 8225645Ch case    1:*/		return 0x82256460;
		  /* 82256460h */ case    2:  		/* mr R29, R5 */
		/* 82256460h case    2:*/		regs.R29 = regs.R5;
		/* 82256460h case    2:*/		return 0x82256464;
		  /* 82256464h */ case    3:  		/* stw R10, <#[R1 + 116]> */
		/* 82256464h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 82256464h case    3:*/		return 0x82256468;
		  /* 82256468h */ case    4:  		/* stw R9, <#[R1 + 124]> */
		/* 82256468h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 82256468h case    4:*/		return 0x8225646C;
		  /* 8225646Ch */ case    5:  		/* li R6, 0 */
		/* 8225646Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225646Ch case    5:*/		return 0x82256470;
		  /* 82256470h */ case    6:  		/* li R7, 0 */
		/* 82256470h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82256470h case    6:*/		return 0x82256474;
		  /* 82256474h */ case    7:  		/* stw R31, <#[R1 + 80]> */
		/* 82256474h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82256474h case    7:*/		return 0x82256478;
		  /* 82256478h */ case    8:  		/* addi R3, R11, -4 */
		/* 82256478h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82256478h case    8:*/		return 0x8225647C;
		  /* 8225647Ch */ case    9:  		/* stw R8, <#[R1 + 100]> */
		/* 8225647Ch case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 8225647Ch case    9:*/		return 0x82256480;
		  /* 82256480h */ case   10:  		/* addi R9, R1, 112 */
		/* 82256480h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 82256480h case   10:*/		return 0x82256484;
		  /* 82256484h */ case   11:  		/* stw R8, <#[R1 + 104]> */
		/* 82256484h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 82256484h case   11:*/		return 0x82256488;
		  /* 82256488h */ case   12:  		/* stw R8, <#[R1 + 108]> */
		/* 82256488h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 82256488h case   12:*/		return 0x8225648C;
		  /* 8225648Ch */ case   13:  		/* li R8, 0 */
		/* 8225648Ch case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8225648Ch case   13:*/		return 0x82256490;
		  /* 82256490h */ case   14:  		/* cmpwi CR6, R6, 0 */
		/* 82256490h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82256490h case   14:*/		return 0x82256494;
		  /* 82256494h */ case   15:  		/* bc 12, CR6_LT, 124 */
		/* 82256494h case   15:*/		if ( regs.CR[6].lt ) { return 0x82256510;  }
		/* 82256494h case   15:*/		return 0x82256498;
		  /* 82256498h */ case   16:  		/* addi R5, R1, 96 */
		/* 82256498h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82256498h case   16:*/		return 0x8225649C;
		  /* 8225649Ch */ case   17:  		/* lwz R11, <#[R9]> */
		/* 8225649Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8225649Ch case   17:*/		return 0x822564A0;
		  /* 822564A0h */ case   18:  		/* cmpw CR6, R8, R6 */
		/* 822564A0h case   18:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R6);
		/* 822564A0h case   18:*/		return 0x822564A4;
		  /* 822564A4h */ case   19:  		/* bc 12, CR6_EQ, 76 */
		/* 822564A4h case   19:*/		if ( regs.CR[6].eq ) { return 0x822564F0;  }
		/* 822564A4h case   19:*/		return 0x822564A8;
	}
	return 0x822564A8;
} // Block from 82256458h-822564A8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822564A8h
// Function '??0ExportAddress@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822564A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822564A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822564A8);
		  /* 822564A8h */ case    0:  		/* lwz R10, <#[R5]> */
		/* 822564A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 822564A8h case    0:*/		return 0x822564AC;
		  /* 822564ACh */ case    1:  		/* lwz R28, <#[R11]> */
		/* 822564ACh case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 822564ACh case    1:*/		return 0x822564B0;
		  /* 822564B0h */ case    2:  		/* lwz R27, <#[R10]> */
		/* 822564B0h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0x00000000) );
		/* 822564B0h case    2:*/		return 0x822564B4;
		  /* 822564B4h */ case    3:  		/* cmplw CR6, R27, R28 */
		/* 822564B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 822564B4h case    3:*/		return 0x822564B8;
		  /* 822564B8h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 822564B8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822564D0;  }
		/* 822564B8h case    4:*/		return 0x822564BC;
		  /* 822564BCh */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 822564BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822564BCh case    5:*/		return 0x822564C0;
		  /* 822564C0h */ case    6:  		/* lwz R10, <#[R10 + 4]> */
		/* 822564C0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 822564C0h case    6:*/		return 0x822564C4;
		  /* 822564C4h */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 822564C4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 822564C4h case    7:*/		return 0x822564C8;
		  /* 822564C8h */ case    8:  		/* li R11, 1 */
		/* 822564C8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822564C8h case    8:*/		return 0x822564CC;
		  /* 822564CCh */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 822564CCh case    9:*/		if ( regs.CR[6].eq ) { return 0x822564D4;  }
		/* 822564CCh case    9:*/		return 0x822564D0;
	}
	return 0x822564D0;
} // Block from 822564A8h-822564D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822564D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822564D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822564D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822564D0);
		  /* 822564D0h */ case    0:  		/* li R11, 0 */
		/* 822564D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822564D0h case    0:*/		return 0x822564D4;
	}
	return 0x822564D4;
} // Block from 822564D0h-822564D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822564D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822564D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822564D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822564D4);
		  /* 822564D4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822564D4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822564D4h case    0:*/		return 0x822564D8;
		  /* 822564D8h */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 822564D8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82256508;  }
		/* 822564D8h case    1:*/		return 0x822564DC;
		  /* 822564DCh */ case    2:  		/* addi R8, R8, 1 */
		/* 822564DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 822564DCh case    2:*/		return 0x822564E0;
		  /* 822564E0h */ case    3:  		/* addi R5, R5, 4 */
		/* 822564E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 822564E0h case    3:*/		return 0x822564E4;
		  /* 822564E4h */ case    4:  		/* cmpw CR6, R8, R6 */
		/* 822564E4h case    4:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R6);
		/* 822564E4h case    4:*/		return 0x822564E8;
		  /* 822564E8h */ case    5:  		/* bc 4, CR6_GT, -76 */
		/* 822564E8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8225649C;  }
		/* 822564E8h case    5:*/		return 0x822564EC;
		  /* 822564ECh */ case    6:  		/* b 36 */
		/* 822564ECh case    6:*/		return 0x82256510;
		/* 822564ECh case    6:*/		return 0x822564F0;
	}
	return 0x822564F0;
} // Block from 822564D4h-822564F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822564F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822564F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822564F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822564F0);
		  /* 822564F0h */ case    0:  		/* addi R10, R1, 80 */
		/* 822564F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 822564F0h case    0:*/		return 0x822564F4;
		  /* 822564F4h */ case    1:  		/* stwu R11, <#[R3 + 4]> */
		/* 822564F4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 822564F4h case    1:*/		return 0x822564F8;
		  /* 822564F8h */ case    2:  		/* rlwinm R8, R6, 0, 24, 31 */
		/* 822564F8h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R6);
		/* 822564F8h case    2:*/		return 0x822564FC;
		  /* 822564FCh */ case    3:  		/* addi R6, R6, 1 */
		/* 822564FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 822564FCh case    3:*/		return 0x82256500;
		  /* 82256500h */ case    4:  		/* stbx R8, <#[R7 + R10]> */
		/* 82256500h case    4:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82256500h case    4:*/		return 0x82256504;
		  /* 82256504h */ case    5:  		/* b 12 */
		/* 82256504h case    5:*/		return 0x82256510;
		/* 82256504h case    5:*/		return 0x82256508;
	}
	return 0x82256508;
} // Block from 822564F0h-82256508h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82256508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256508);
		  /* 82256508h */ case    0:  		/* addi R11, R1, 80 */
		/* 82256508h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82256508h case    0:*/		return 0x8225650C;
		  /* 8225650Ch */ case    1:  		/* stbx R8, <#[R7 + R11]> */
		/* 8225650Ch case    1:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8225650Ch case    1:*/		return 0x82256510;
	}
	return 0x82256510;
} // Block from 82256508h-82256510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256510);
		  /* 82256510h */ case    0:  		/* addi R7, R7, 1 */
		/* 82256510h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82256510h case    0:*/		return 0x82256514;
		  /* 82256514h */ case    1:  		/* addi R9, R9, 4 */
		/* 82256514h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82256514h case    1:*/		return 0x82256518;
		  /* 82256518h */ case    2:  		/* cmpwi CR6, R7, 4 */
		/* 82256518h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000004);
		/* 82256518h case    2:*/		return 0x8225651C;
		  /* 8225651Ch */ case    3:  		/* bc 12, CR6_LT, -144 */
		/* 8225651Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8225648C;  }
		/* 8225651Ch case    3:*/		return 0x82256520;
		  /* 82256520h */ case    4:  		/* stw R31, <#[R1 + 84]> */
		/* 82256520h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 82256520h case    4:*/		return 0x82256524;
		  /* 82256524h */ case    5:  		/* cmpwi CR6, R6, 0 */
		/* 82256524h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82256524h case    5:*/		return 0x82256528;
		  /* 82256528h */ case    6:  		/* bc 4, CR6_GT, 144 */
		/* 82256528h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822565B8;  }
		/* 82256528h case    6:*/		return 0x8225652C;
		  /* 8225652Ch */ case    7:  		/* addi R3, R6, -1 */
		/* 8225652Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R6,0xFFFFFFFF);
		/* 8225652Ch case    7:*/		return 0x82256530;
	}
	return 0x82256530;
} // Block from 82256510h-82256530h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82256530h
// Function '??0ExportSlot@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256530);
		  /* 82256530h */ case    0:  		/* mtspr CTR, R6 */
		/* 82256530h case    0:*/		regs.CTR = regs.R6;
		/* 82256530h case    0:*/		return 0x82256534;
		  /* 82256534h */ case    1:  		/* li R5, 0 */
		/* 82256534h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82256534h case    1:*/		return 0x82256538;
		  /* 82256538h */ case    2:  		/* cmpwi CR6, R3, 0 */
		/* 82256538h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82256538h case    2:*/		return 0x8225653C;
		  /* 8225653Ch */ case    3:  		/* bc 4, CR6_GT, 116 */
		/* 8225653Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x822565B0;  }
		/* 8225653Ch case    3:*/		return 0x82256540;
		  /* 82256540h */ case    4:  		/* addi R10, R1, 96 */
		/* 82256540h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82256540h case    4:*/		return 0x82256544;
		  /* 82256544h */ case    5:  		/* lwz R11, <#[R10 + 4]> */
		/* 82256544h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82256544h case    5:*/		return 0x82256548;
		  /* 82256548h */ case    6:  		/* lwz R9, <#[R10]> */
		/* 82256548h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82256548h case    6:*/		return 0x8225654C;
		  /* 8225654Ch */ case    7:  		/* lwz R8, <#[R11]> */
		/* 8225654Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8225654Ch case    7:*/		return 0x82256550;
		  /* 82256550h */ case    8:  		/* lwz R7, <#[R9]> */
		/* 82256550h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82256550h case    8:*/		return 0x82256554;
		  /* 82256554h */ case    9:  		/* cmplw CR6, R7, R8 */
		/* 82256554h case    9:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 82256554h case    9:*/		return 0x82256558;
		  /* 82256558h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82256558h case   10:*/		if ( regs.CR[6].eq ) { return 0x82256564;  }
		/* 82256558h case   10:*/		return 0x8225655C;
		  /* 8225655Ch */ case   11:  		/* subfc R8, R8, R7 */
		/* 8225655Ch case   11:*/		cpu::op::subfc<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8225655Ch case   11:*/		return 0x82256560;
		  /* 82256560h */ case   12:  		/* b 16 */
		/* 82256560h case   12:*/		return 0x82256570;
		/* 82256560h case   12:*/		return 0x82256564;
	}
	return 0x82256564;
} // Block from 82256530h-82256564h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82256564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256564);
		  /* 82256564h */ case    0:  		/* lwz R8, <#[R9 + 4]> */
		/* 82256564h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 82256564h case    0:*/		return 0x82256568;
		  /* 82256568h */ case    1:  		/* lwz R7, <#[R11 + 4]> */
		/* 82256568h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82256568h case    1:*/		return 0x8225656C;
		  /* 8225656Ch */ case    2:  		/* subfc R8, R7, R8 */
		/* 8225656Ch case    2:*/		cpu::op::subfc<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8225656Ch case    2:*/		return 0x82256570;
	}
	return 0x82256570;
} // Block from 82256564h-82256570h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82256570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256570);
		  /* 82256570h */ case    0:  		/* subfe R8, R8, R8 */
		/* 82256570h case    0:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 82256570h case    0:*/		return 0x82256574;
		  /* 82256574h */ case    1:  		/* rlwinm R8, R8, 0, 31, 31 */
		/* 82256574h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R8);
		/* 82256574h case    1:*/		return 0x82256578;
		  /* 82256578h */ case    2:  		/* rlwinm. R8, R8, 0, 24, 31 */
		/* 82256578h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R8);
		/* 82256578h case    2:*/		return 0x8225657C;
		  /* 8225657Ch */ case    3:  		/* bc 12, CR0_EQ, 36 */
		/* 8225657Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x822565A0;  }
		/* 8225657Ch case    3:*/		return 0x82256580;
		  /* 82256580h */ case    4:  		/* addi R8, R1, 84 */
		/* 82256580h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x54);
		/* 82256580h case    4:*/		return 0x82256584;
		  /* 82256584h */ case    5:  		/* stw R11, <#[R10]> */
		/* 82256584h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82256584h case    5:*/		return 0x82256588;
		  /* 82256588h */ case    6:  		/* stw R9, <#[R10 + 4]> */
		/* 82256588h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82256588h case    6:*/		return 0x8225658C;
		  /* 8225658Ch */ case    7:  		/* add R11, R5, R8 */
		/* 8225658Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R8);
		/* 8225658Ch case    7:*/		return 0x82256590;
		  /* 82256590h */ case    8:  		/* lbzx R9, <#[R5 + R8]> */
		/* 82256590h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 82256590h case    8:*/		return 0x82256594;
		  /* 82256594h */ case    9:  		/* lbz R7, <#[R11 + 1]> */
		/* 82256594h case    9:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000001) );
		/* 82256594h case    9:*/		return 0x82256598;
		  /* 82256598h */ case   10:  		/* stb R9, <#[R11 + 1]> */
		/* 82256598h case   10:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000001) );
		/* 82256598h case   10:*/		return 0x8225659C;
		  /* 8225659Ch */ case   11:  		/* stbx R7, <#[R5 + R8]> */
		/* 8225659Ch case   11:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 8225659Ch case   11:*/		return 0x822565A0;
	}
	return 0x822565A0;
} // Block from 82256570h-822565A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822565A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822565A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822565A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822565A0);
		  /* 822565A0h */ case    0:  		/* addi R5, R5, 1 */
		/* 822565A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 822565A0h case    0:*/		return 0x822565A4;
		  /* 822565A4h */ case    1:  		/* addi R10, R10, 4 */
		/* 822565A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 822565A4h case    1:*/		return 0x822565A8;
		  /* 822565A8h */ case    2:  		/* cmpw CR6, R5, R3 */
		/* 822565A8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R3);
		/* 822565A8h case    2:*/		return 0x822565AC;
		  /* 822565ACh */ case    3:  		/* bc 12, CR6_LT, -104 */
		/* 822565ACh case    3:*/		if ( regs.CR[6].lt ) { return 0x82256544;  }
		/* 822565ACh case    3:*/		return 0x822565B0;
	}
	return 0x822565B0;
} // Block from 822565A0h-822565B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822565B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822565B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822565B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822565B0);
		  /* 822565B0h */ case    0:  		/* addi R3, R3, -1 */
		/* 822565B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 822565B0h case    0:*/		return 0x822565B4;
		  /* 822565B4h */ case    1:  		/* bc 16, CR0_LT, -128 */
		/* 822565B4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82256534;  }
		/* 822565B4h case    1:*/		return 0x822565B8;
	}
	return 0x822565B8;
} // Block from 822565B0h-822565B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822565B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822565B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822565B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822565B8);
		  /* 822565B8h */ case    0:  		/* li R11, 0 */
		/* 822565B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822565B8h case    0:*/		return 0x822565BC;
		  /* 822565BCh */ case    1:  		/* cmpwi CR6, R6, 0 */
		/* 822565BCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 822565BCh case    1:*/		return 0x822565C0;
	}
	return 0x822565C0;
} // Block from 822565B8h-822565C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822565C0h
// Function '??_GLoopIndexedConstSet@XGRAPHICS@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822565C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822565C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822565C0);
		  /* 822565C0h */ case    0:  		/* bc 4, CR6_GT, 36 */
		/* 822565C0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x822565E4;  }
		/* 822565C0h case    0:*/		return 0x822565C4;
		  /* 822565C4h */ case    1:  		/* mtspr CTR, R6 */
		/* 822565C4h case    1:*/		regs.CTR = regs.R6;
		/* 822565C4h case    1:*/		return 0x822565C8;
		  /* 822565C8h */ case    2:  		/* addi R10, R1, 84 */
		/* 822565C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x54);
		/* 822565C8h case    2:*/		return 0x822565CC;
		  /* 822565CCh */ case    3:  		/* addi R9, R1, 88 */
		/* 822565CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 822565CCh case    3:*/		return 0x822565D0;
		  /* 822565D0h */ case    4:  		/* rlwinm R8, R11, 0, 24, 31 */
		/* 822565D0h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R11);
		/* 822565D0h case    4:*/		return 0x822565D4;
		  /* 822565D4h */ case    5:  		/* lbzx R10, <#[R11 + R10]> */
		/* 822565D4h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822565D4h case    5:*/		return 0x822565D8;
		  /* 822565D8h */ case    6:  		/* addi R11, R11, 1 */
		/* 822565D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822565D8h case    6:*/		return 0x822565DC;
		  /* 822565DCh */ case    7:  		/* stbx R8, <#[R10 + R9]> */
		/* 822565DCh case    7:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 822565DCh case    7:*/		return 0x822565E0;
		  /* 822565E0h */ case    8:  		/* bc 16, CR0_LT, -24 */
		/* 822565E0h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822565C8;  }
		/* 822565E0h case    8:*/		return 0x822565E4;
	}
	return 0x822565E4;
} // Block from 822565C0h-822565E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822565E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822565E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822565E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822565E4);
		  /* 822565E4h */ case    0:  		/* li R10, 4 */
		/* 822565E4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 822565E4h case    0:*/		return 0x822565E8;
		  /* 822565E8h */ case    1:  		/* li R11, 0 */
		/* 822565E8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822565E8h case    1:*/		return 0x822565EC;
		  /* 822565ECh */ case    2:  		/* mtspr CTR, R10 */
		/* 822565ECh case    2:*/		regs.CTR = regs.R10;
		/* 822565ECh case    2:*/		return 0x822565F0;
		  /* 822565F0h */ case    3:  		/* addi R10, R1, 80 */
		/* 822565F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 822565F0h case    3:*/		return 0x822565F4;
		  /* 822565F4h */ case    4:  		/* addi R9, R1, 88 */
		/* 822565F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 822565F4h case    4:*/		return 0x822565F8;
		  /* 822565F8h */ case    5:  		/* addi R8, R1, 84 */
		/* 822565F8h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x54);
		/* 822565F8h case    5:*/		return 0x822565FC;
		  /* 822565FCh */ case    6:  		/* lbzx R10, <#[R11 + R10]> */
		/* 822565FCh case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822565FCh case    6:*/		return 0x82256600;
		  /* 82256600h */ case    7:  		/* lbzx R10, <#[R10 + R9]> */
		/* 82256600h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82256600h case    7:*/		return 0x82256604;
		  /* 82256604h */ case    8:  		/* stbx R10, <#[R11 + R8]> */
		/* 82256604h case    8:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82256604h case    8:*/		return 0x82256608;
		  /* 82256608h */ case    9:  		/* addi R11, R11, 1 */
		/* 82256608h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82256608h case    9:*/		return 0x8225660C;
		  /* 8225660Ch */ case   10:  		/* bc 16, CR0_LT, -28 */
		/* 8225660Ch case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822565F0;  }
		/* 8225660Ch case   10:*/		return 0x82256610;
		  /* 82256610h */ case   11:  		/* lwz R11, <#[R30 + 952]> */
		/* 82256610h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000003B8) );
		/* 82256610h case   11:*/		return 0x82256614;
		  /* 82256614h */ case   12:  		/* li R31, 0 */
		/* 82256614h case   12:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82256614h case   12:*/		return 0x82256618;
	}
	return 0x82256618;
} // Block from 822565E4h-82256618h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82256618h
// Function '??0LoopIndexedConstSet@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256618);
		  /* 82256618h */ case    0:  		/* cmpwi CR6, R6, 1 */
		/* 82256618h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000001);
		/* 82256618h case    0:*/		return 0x8225661C;
		  /* 8225661Ch */ case    1:  		/* lbz R11, <#[R11 + 1393]> */
		/* 8225661Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000571) );
		/* 8225661Ch case    1:*/		return 0x82256620;
		  /* 82256620h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82256620h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82256620h case    2:*/		return 0x82256624;
		  /* 82256624h */ case    3:  		/* bc 12, CR0_EQ, 220 */
		/* 82256624h case    3:*/		if ( regs.CR[0].eq ) { return 0x82256700;  }
		/* 82256624h case    3:*/		return 0x82256628;
		  /* 82256628h */ case    4:  		/* bc 12, CR6_EQ, 176 */
		/* 82256628h case    4:*/		if ( regs.CR[6].eq ) { return 0x822566D8;  }
		/* 82256628h case    4:*/		return 0x8225662C;
		  /* 8225662Ch */ case    5:  		/* cmpwi CR6, R6, 2 */
		/* 8225662Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000002);
		/* 8225662Ch case    5:*/		return 0x82256630;
		  /* 82256630h */ case    6:  		/* bc 12, CR6_EQ, 140 */
		/* 82256630h case    6:*/		if ( regs.CR[6].eq ) { return 0x822566BC;  }
		/* 82256630h case    6:*/		return 0x82256634;
		  /* 82256634h */ case    7:  		/* cmpwi CR6, R6, 3 */
		/* 82256634h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000003);
		/* 82256634h case    7:*/		return 0x82256638;
		  /* 82256638h */ case    8:  		/* bc 12, CR6_EQ, 96 */
		/* 82256638h case    8:*/		if ( regs.CR[6].eq ) { return 0x82256698;  }
		/* 82256638h case    8:*/		return 0x8225663C;
		  /* 8225663Ch */ case    9:  		/* cmpwi CR6, R6, 4 */
		/* 8225663Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000004);
		/* 8225663Ch case    9:*/		return 0x82256640;
		  /* 82256640h */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 82256640h case   10:*/		if ( regs.CR[6].eq ) { return 0x8225666C;  }
		/* 82256640h case   10:*/		return 0x82256644;
		  /* 82256644h */ case   11:  		/* lis R11, -32252 */
		/* 82256644h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256644h case   11:*/		return 0x82256648;
		  /* 82256648h */ case   12:  		/* lis R10, -32255 */
		/* 82256648h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82256648h case   12:*/		return 0x8225664C;
		  /* 8225664Ch */ case   13:  		/* lis R9, -32253 */
		/* 8225664Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225664Ch case   13:*/		return 0x82256650;
		  /* 82256650h */ case   14:  		/* addi R6, R11, 28888 */
		/* 82256650h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x70D8);
		/* 82256650h case   14:*/		return 0x82256654;
		  /* 82256654h */ case   15:  		/* addi R5, R10, 5216 */
		/* 82256654h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 82256654h case   15:*/		return 0x82256658;
		  /* 82256658h */ case   16:  		/* addi R4, R9, 27460 */
		/* 82256658h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82256658h case   16:*/		return 0x8225665C;
		  /* 8225665Ch */ case   17:  		/* li R7, 385 */
		/* 8225665Ch case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x181);
		/* 8225665Ch case   17:*/		return 0x82256660;
		  /* 82256660h */ case   18:  		/* li R3, 0 */
		/* 82256660h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256660h case   18:*/		return 0x82256664;
		  /* 82256664h */ case   19:  		/* bl -1043036 */
		/* 82256664h case   19:*/		regs.LR = 0x82256668; return 0x82157C08;
		/* 82256664h case   19:*/		return 0x82256668;
		  /* 82256668h */ case   20:  		/* b 132 */
		/* 82256668h case   20:*/		return 0x822566EC;
		/* 82256668h case   20:*/		return 0x8225666C;
	}
	return 0x8225666C;
} // Block from 82256618h-8225666Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225666Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225666C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225666C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225666C);
		  /* 8225666Ch */ case    0:  		/* lwz R11, <#[R1 + 108]> */
		/* 8225666Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8225666Ch case    0:*/		return 0x82256670;
		  /* 82256670h */ case    1:  		/* lwz R10, <#[R1 + 104]> */
		/* 82256670h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82256670h case    1:*/		return 0x82256674;
		  /* 82256674h */ case    2:  		/* lwz R9, <#[R1 + 100]> */
		/* 82256674h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 82256674h case    2:*/		return 0x82256678;
		  /* 82256678h */ case    3:  		/* lwz R8, <#[R1 + 96]> */
		/* 82256678h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82256678h case    3:*/		return 0x8225667C;
		  /* 8225667Ch */ case    4:  		/* lwz R3, <#[R4 + 172]> */
		/* 8225667Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 8225667Ch case    4:*/		return 0x82256680;
	}
	return 0x82256680;
} // Block from 8225666Ch-82256680h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82256680h
// Function '??0LoopIndexedInputSet@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256680);
		  /* 82256680h */ case    0:  		/* ld R7, <#[R11]> */
		/* 82256680h case    0:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82256680h case    0:*/		return 0x82256684;
		  /* 82256684h */ case    1:  		/* ld R6, <#[R10]> */
		/* 82256684h case    1:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 82256684h case    1:*/		return 0x82256688;
		  /* 82256688h */ case    2:  		/* ld R5, <#[R9]> */
		/* 82256688h case    2:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 82256688h case    2:*/		return 0x8225668C;
		  /* 8225668Ch */ case    3:  		/* ld R4, <#[R8]> */
		/* 8225668Ch case    3:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R8 + 0x00000000) );
		/* 8225668Ch case    3:*/		return 0x82256690;
		  /* 82256690h */ case    4:  		/* bl -68376 */
		/* 82256690h case    4:*/		regs.LR = 0x82256694; return 0x82245B78;
		/* 82256690h case    4:*/		return 0x82256694;
		  /* 82256694h */ case    5:  		/* b 84 */
		/* 82256694h case    5:*/		return 0x822566E8;
		/* 82256694h case    5:*/		return 0x82256698;
	}
	return 0x82256698;
} // Block from 82256680h-82256698h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82256698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256698);
		  /* 82256698h */ case    0:  		/* lwz R11, <#[R1 + 104]> */
		/* 82256698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82256698h case    0:*/		return 0x8225669C;
		  /* 8225669Ch */ case    1:  		/* lwz R10, <#[R1 + 100]> */
		/* 8225669Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8225669Ch case    1:*/		return 0x822566A0;
		  /* 822566A0h */ case    2:  		/* lwz R9, <#[R1 + 96]> */
		/* 822566A0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 822566A0h case    2:*/		return 0x822566A4;
		  /* 822566A4h */ case    3:  		/* lwz R3, <#[R4 + 172]> */
		/* 822566A4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 822566A4h case    3:*/		return 0x822566A8;
		  /* 822566A8h */ case    4:  		/* ld R6, <#[R11]> */
		/* 822566A8h case    4:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 822566A8h case    4:*/		return 0x822566AC;
		  /* 822566ACh */ case    5:  		/* ld R5, <#[R10]> */
		/* 822566ACh case    5:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 822566ACh case    5:*/		return 0x822566B0;
		  /* 822566B0h */ case    6:  		/* ld R4, <#[R9]> */
		/* 822566B0h case    6:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R9 + 0x00000000) );
		/* 822566B0h case    6:*/		return 0x822566B4;
		  /* 822566B4h */ case    7:  		/* bl -68444 */
		/* 822566B4h case    7:*/		regs.LR = 0x822566B8; return 0x82245B58;
		/* 822566B4h case    7:*/		return 0x822566B8;
		  /* 822566B8h */ case    8:  		/* b 48 */
		/* 822566B8h case    8:*/		return 0x822566E8;
		/* 822566B8h case    8:*/		return 0x822566BC;
	}
	return 0x822566BC;
} // Block from 82256698h-822566BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822566BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822566BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822566BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822566BC);
		  /* 822566BCh */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 822566BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 822566BCh case    0:*/		return 0x822566C0;
		  /* 822566C0h */ case    1:  		/* lwz R10, <#[R1 + 96]> */
		/* 822566C0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 822566C0h case    1:*/		return 0x822566C4;
		  /* 822566C4h */ case    2:  		/* lwz R3, <#[R4 + 172]> */
		/* 822566C4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 822566C4h case    2:*/		return 0x822566C8;
		  /* 822566C8h */ case    3:  		/* ld R5, <#[R11]> */
		/* 822566C8h case    3:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 822566C8h case    3:*/		return 0x822566CC;
		  /* 822566CCh */ case    4:  		/* ld R4, <#[R10]> */
		/* 822566CCh case    4:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 822566CCh case    4:*/		return 0x822566D0;
		  /* 822566D0h */ case    5:  		/* bl -68504 */
		/* 822566D0h case    5:*/		regs.LR = 0x822566D4; return 0x82245B38;
		/* 822566D0h case    5:*/		return 0x822566D4;
		  /* 822566D4h */ case    6:  		/* b 20 */
		/* 822566D4h case    6:*/		return 0x822566E8;
		/* 822566D4h case    6:*/		return 0x822566D8;
	}
	return 0x822566D8;
} // Block from 822566BCh-822566D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822566D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822566D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822566D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822566D8);
		  /* 822566D8h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 822566D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 822566D8h case    0:*/		return 0x822566DC;
		  /* 822566DCh */ case    1:  		/* lwz R3, <#[R4 + 172]> */
		/* 822566DCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 822566DCh case    1:*/		return 0x822566E0;
		  /* 822566E0h */ case    2:  		/* ld R4, <#[R11]> */
		/* 822566E0h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 822566E0h case    2:*/		return 0x822566E4;
		  /* 822566E4h */ case    3:  		/* bl -68556 */
		/* 822566E4h case    3:*/		regs.LR = 0x822566E8; return 0x82245B18;
		/* 822566E4h case    3:*/		return 0x822566E8;
	}
	return 0x822566E8;
} // Block from 822566D8h-822566E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822566E8h
// Function '??0LoopIndexedOutputSet@XGRAPHICS@@QAA@HW4RegType@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822566E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822566E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822566E8);
		  /* 822566E8h */ case    0:  		/* mr R31, R3 */
		/* 822566E8h case    0:*/		regs.R31 = regs.R3;
		/* 822566E8h case    0:*/		return 0x822566EC;
	}
	return 0x822566EC;
} // Block from 822566E8h-822566ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822566ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822566EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822566EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822566EC);
		  /* 822566ECh */ case    0:  		/* mr R5, R31 */
		/* 822566ECh case    0:*/		regs.R5 = regs.R31;
		/* 822566ECh case    0:*/		return 0x822566F0;
		  /* 822566F0h */ case    1:  		/* mr R4, R29 */
		/* 822566F0h case    1:*/		regs.R4 = regs.R29;
		/* 822566F0h case    1:*/		return 0x822566F4;
		  /* 822566F4h */ case    2:  		/* mr R3, R30 */
		/* 822566F4h case    2:*/		regs.R3 = regs.R30;
		/* 822566F4h case    2:*/		return 0x822566F8;
		  /* 822566F8h */ case    3:  		/* bl -133032 */
		/* 822566F8h case    3:*/		regs.LR = 0x822566FC; return 0x82235F50;
		/* 822566F8h case    3:*/		return 0x822566FC;
		  /* 822566FCh */ case    4:  		/* b 216 */
		/* 822566FCh case    4:*/		return 0x822567D4;
		/* 822566FCh case    4:*/		return 0x82256700;
	}
	return 0x82256700;
} // Block from 822566ECh-82256700h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82256700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256700);
		  /* 82256700h */ case    0:  		/* bc 12, CR6_EQ, 176 */
		/* 82256700h case    0:*/		if ( regs.CR[6].eq ) { return 0x822567B0;  }
		/* 82256700h case    0:*/		return 0x82256704;
		  /* 82256704h */ case    1:  		/* cmpwi CR6, R6, 2 */
		/* 82256704h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000002);
		/* 82256704h case    1:*/		return 0x82256708;
		  /* 82256708h */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 82256708h case    2:*/		if ( regs.CR[6].eq ) { return 0x82256794;  }
		/* 82256708h case    2:*/		return 0x8225670C;
		  /* 8225670Ch */ case    3:  		/* cmpwi CR6, R6, 3 */
		/* 8225670Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000003);
		/* 8225670Ch case    3:*/		return 0x82256710;
		  /* 82256710h */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 82256710h case    4:*/		if ( regs.CR[6].eq ) { return 0x82256770;  }
		/* 82256710h case    4:*/		return 0x82256714;
		  /* 82256714h */ case    5:  		/* cmpwi CR6, R6, 4 */
		/* 82256714h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000004);
		/* 82256714h case    5:*/		return 0x82256718;
		  /* 82256718h */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 82256718h case    6:*/		if ( regs.CR[6].eq ) { return 0x82256744;  }
		/* 82256718h case    6:*/		return 0x8225671C;
		  /* 8225671Ch */ case    7:  		/* lis R11, -32252 */
		/* 8225671Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225671Ch case    7:*/		return 0x82256720;
		  /* 82256720h */ case    8:  		/* lis R10, -32255 */
		/* 82256720h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82256720h case    8:*/		return 0x82256724;
		  /* 82256724h */ case    9:  		/* lis R9, -32253 */
		/* 82256724h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82256724h case    9:*/		return 0x82256728;
		  /* 82256728h */ case   10:  		/* addi R6, R11, 28888 */
		/* 82256728h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x70D8);
		/* 82256728h case   10:*/		return 0x8225672C;
		  /* 8225672Ch */ case   11:  		/* addi R5, R10, 5216 */
		/* 8225672Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8225672Ch case   11:*/		return 0x82256730;
		  /* 82256730h */ case   12:  		/* addi R4, R9, 27460 */
		/* 82256730h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82256730h case   12:*/		return 0x82256734;
		  /* 82256734h */ case   13:  		/* li R7, 410 */
		/* 82256734h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x19A);
		/* 82256734h case   13:*/		return 0x82256738;
		  /* 82256738h */ case   14:  		/* li R3, 0 */
		/* 82256738h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256738h case   14:*/		return 0x8225673C;
		  /* 8225673Ch */ case   15:  		/* bl -1043252 */
		/* 8225673Ch case   15:*/		regs.LR = 0x82256740; return 0x82157C08;
		/* 8225673Ch case   15:*/		return 0x82256740;
		  /* 82256740h */ case   16:  		/* b 132 */
		/* 82256740h case   16:*/		return 0x822567C4;
		/* 82256740h case   16:*/		return 0x82256744;
	}
	return 0x82256744;
} // Block from 82256700h-82256744h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82256744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256744);
		  /* 82256744h */ case    0:  		/* lwz R11, <#[R1 + 108]> */
		/* 82256744h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82256744h case    0:*/		return 0x82256748;
		  /* 82256748h */ case    1:  		/* lwz R10, <#[R1 + 104]> */
		/* 82256748h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82256748h case    1:*/		return 0x8225674C;
		  /* 8225674Ch */ case    2:  		/* lwz R9, <#[R1 + 100]> */
		/* 8225674Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 8225674Ch case    2:*/		return 0x82256750;
	}
	return 0x82256750;
} // Block from 82256744h-82256750h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82256750h
// Function '?FixedToFloat@XGRAPHICS@@YAMIHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256750);
		  /* 82256750h */ case    0:  		/* lwz R8, <#[R1 + 96]> */
		/* 82256750h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82256750h case    0:*/		return 0x82256754;
		  /* 82256754h */ case    1:  		/* lwz R3, <#[R4 + 172]> */
		/* 82256754h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 82256754h case    1:*/		return 0x82256758;
		  /* 82256758h */ case    2:  		/* ld R7, <#[R11]> */
		/* 82256758h case    2:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82256758h case    2:*/		return 0x8225675C;
		  /* 8225675Ch */ case    3:  		/* ld R6, <#[R10]> */
		/* 8225675Ch case    3:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8225675Ch case    3:*/		return 0x82256760;
	}
	return 0x82256760;
} // Block from 82256750h-82256760h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256760h
// Function '?ModifiersAreCompatible@IRInst@XGRAPHICS@@QBA_NPBV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256760);
		  /* 82256760h */ case    0:  		/* ld R5, <#[R9]> */
		/* 82256760h case    0:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 82256760h case    0:*/		return 0x82256764;
		  /* 82256764h */ case    1:  		/* ld R4, <#[R8]> */
		/* 82256764h case    1:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R8 + 0x00000000) );
		/* 82256764h case    1:*/		return 0x82256768;
		  /* 82256768h */ case    2:  		/* bl -62144 */
		/* 82256768h case    2:*/		regs.LR = 0x8225676C; return 0x822474A8;
		/* 82256768h case    2:*/		return 0x8225676C;
		  /* 8225676Ch */ case    3:  		/* b 84 */
		/* 8225676Ch case    3:*/		return 0x822567C0;
		/* 8225676Ch case    3:*/		return 0x82256770;
	}
	return 0x82256770;
} // Block from 82256760h-82256770h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256770);
		  /* 82256770h */ case    0:  		/* lwz R11, <#[R1 + 104]> */
		/* 82256770h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82256770h case    0:*/		return 0x82256774;
		  /* 82256774h */ case    1:  		/* lwz R10, <#[R1 + 100]> */
		/* 82256774h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 82256774h case    1:*/		return 0x82256778;
		  /* 82256778h */ case    2:  		/* lwz R9, <#[R1 + 96]> */
		/* 82256778h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82256778h case    2:*/		return 0x8225677C;
		  /* 8225677Ch */ case    3:  		/* lwz R3, <#[R4 + 172]> */
		/* 8225677Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 8225677Ch case    3:*/		return 0x82256780;
		  /* 82256780h */ case    4:  		/* ld R6, <#[R11]> */
		/* 82256780h case    4:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82256780h case    4:*/		return 0x82256784;
		  /* 82256784h */ case    5:  		/* ld R5, <#[R10]> */
		/* 82256784h case    5:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 82256784h case    5:*/		return 0x82256788;
		  /* 82256788h */ case    6:  		/* ld R4, <#[R9]> */
		/* 82256788h case    6:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R9 + 0x00000000) );
		/* 82256788h case    6:*/		return 0x8225678C;
		  /* 8225678Ch */ case    7:  		/* bl -62212 */
		/* 8225678Ch case    7:*/		regs.LR = 0x82256790; return 0x82247488;
		/* 8225678Ch case    7:*/		return 0x82256790;
		  /* 82256790h */ case    8:  		/* b 48 */
		/* 82256790h case    8:*/		return 0x822567C0;
		/* 82256790h case    8:*/		return 0x82256794;
	}
	return 0x82256794;
} // Block from 82256770h-82256794h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82256794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256794);
		  /* 82256794h */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 82256794h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82256794h case    0:*/		return 0x82256798;
		  /* 82256798h */ case    1:  		/* lwz R10, <#[R1 + 96]> */
		/* 82256798h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82256798h case    1:*/		return 0x8225679C;
		  /* 8225679Ch */ case    2:  		/* lwz R3, <#[R4 + 172]> */
		/* 8225679Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 8225679Ch case    2:*/		return 0x822567A0;
		  /* 822567A0h */ case    3:  		/* ld R5, <#[R11]> */
		/* 822567A0h case    3:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 822567A0h case    3:*/		return 0x822567A4;
		  /* 822567A4h */ case    4:  		/* ld R4, <#[R10]> */
		/* 822567A4h case    4:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 822567A4h case    4:*/		return 0x822567A8;
		  /* 822567A8h */ case    5:  		/* bl -62272 */
		/* 822567A8h case    5:*/		regs.LR = 0x822567AC; return 0x82247468;
		/* 822567A8h case    5:*/		return 0x822567AC;
		  /* 822567ACh */ case    6:  		/* b 20 */
		/* 822567ACh case    6:*/		return 0x822567C0;
		/* 822567ACh case    6:*/		return 0x822567B0;
	}
	return 0x822567B0;
} // Block from 82256794h-822567B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822567B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822567B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822567B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822567B0);
		  /* 822567B0h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 822567B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 822567B0h case    0:*/		return 0x822567B4;
		  /* 822567B4h */ case    1:  		/* lwz R3, <#[R4 + 172]> */
		/* 822567B4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x000000AC) );
		/* 822567B4h case    1:*/		return 0x822567B8;
		  /* 822567B8h */ case    2:  		/* ld R4, <#[R11]> */
		/* 822567B8h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 822567B8h case    2:*/		return 0x822567BC;
		  /* 822567BCh */ case    3:  		/* bl -62324 */
		/* 822567BCh case    3:*/		regs.LR = 0x822567C0; return 0x82247448;
		/* 822567BCh case    3:*/		return 0x822567C0;
	}
	return 0x822567C0;
} // Block from 822567B0h-822567C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822567C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822567C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822567C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822567C0);
		  /* 822567C0h */ case    0:  		/* mr R31, R3 */
		/* 822567C0h case    0:*/		regs.R31 = regs.R3;
		/* 822567C0h case    0:*/		return 0x822567C4;
	}
	return 0x822567C4;
} // Block from 822567C0h-822567C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822567C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822567C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822567C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822567C4);
		  /* 822567C4h */ case    0:  		/* mr R5, R31 */
		/* 822567C4h case    0:*/		regs.R5 = regs.R31;
		/* 822567C4h case    0:*/		return 0x822567C8;
		  /* 822567C8h */ case    1:  		/* mr R4, R29 */
		/* 822567C8h case    1:*/		regs.R4 = regs.R29;
		/* 822567C8h case    1:*/		return 0x822567CC;
		  /* 822567CCh */ case    2:  		/* mr R3, R30 */
		/* 822567CCh case    2:*/		regs.R3 = regs.R30;
		/* 822567CCh case    2:*/		return 0x822567D0;
		  /* 822567D0h */ case    3:  		/* bl -1080 */
		/* 822567D0h case    3:*/		regs.LR = 0x822567D4; return 0x82256398;
		/* 822567D0h case    3:*/		return 0x822567D4;
	}
	return 0x822567D4;
} // Block from 822567C4h-822567D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822567D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822567D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822567D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822567D4);
		  /* 822567D4h */ case    0:  		/* addi R11, R29, 32 */
		/* 822567D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x20);
		/* 822567D4h case    0:*/		return 0x822567D8;
		  /* 822567D8h */ case    1:  		/* lwz R10, <#[R1 + 84]> */
		/* 822567D8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 822567D8h case    1:*/		return 0x822567DC;
		  /* 822567DCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822567DCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822567DCh case    2:*/		return 0x822567E0;
		  /* 822567E0h */ case    3:  		/* stwx R10, <#[R11 + R30]> */
		/* 822567E0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 822567E0h case    3:*/		return 0x822567E4;
		  /* 822567E4h */ case    4:  		/* addi R1, R1, 176 */
		/* 822567E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 822567E4h case    4:*/		return 0x822567E8;
		  /* 822567E8h */ case    5:  		/* b -1856836 */
		/* 822567E8h case    5:*/		return 0x820912A4;
		/* 822567E8h case    5:*/		return 0x822567EC;
		  /* 822567ECh */ case    6:  		/* nop */
		/* 822567ECh case    6:*/		cpu::op::nop();
		/* 822567ECh case    6:*/		return 0x822567F0;
	}
	return 0x822567F0;
} // Block from 822567D4h-822567F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822567F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822567F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822567F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822567F0);
		  /* 822567F0h */ case    0:  		/* mfspr R12, LR */
		/* 822567F0h case    0:*/		regs.R12 = regs.LR;
		/* 822567F0h case    0:*/		return 0x822567F4;
		  /* 822567F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822567F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822567F4h case    1:*/		return 0x822567F8;
		  /* 822567F8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822567F8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822567F8h case    2:*/		return 0x822567FC;
		  /* 822567FCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822567FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822567FCh case    3:*/		return 0x82256800;
		  /* 82256800h */ case    4:  		/* lwz R11, <#[R3 + 80]> */
		/* 82256800h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82256800h case    4:*/		return 0x82256804;
		  /* 82256804h */ case    5:  		/* mr R31, R3 */
		/* 82256804h case    5:*/		regs.R31 = regs.R3;
		/* 82256804h case    5:*/		return 0x82256808;
	}
	return 0x82256808;
} // Block from 822567F0h-82256808h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82256808h
// Function '?WriteMasksAreDisjunct@IRInst@XGRAPHICS@@QBA_NPBV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256808);
		  /* 82256808h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 82256808h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 82256808h case    0:*/		return 0x8225680C;
		  /* 8225680Ch */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 8225680Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82256824;  }
		/* 8225680Ch case    1:*/		return 0x82256810;
		  /* 82256810h */ case    2:  		/* lwz R11, <#[R3 + 952]> */
		/* 82256810h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003B8) );
		/* 82256810h case    2:*/		return 0x82256814;
		  /* 82256814h */ case    3:  		/* mr R4, R3 */
		/* 82256814h case    3:*/		regs.R4 = regs.R3;
		/* 82256814h case    3:*/		return 0x82256818;
		  /* 82256818h */ case    4:  		/* lwz R11, <#[R11 + 2736]> */
		/* 82256818h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82256818h case    4:*/		return 0x8225681C;
		  /* 8225681Ch */ case    5:  		/* lwz R3, <#[R11 + 172]> */
		/* 8225681Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000000AC) );
		/* 8225681Ch case    5:*/		return 0x82256820;
		  /* 82256820h */ case    6:  		/* bl -70728 */
		/* 82256820h case    6:*/		regs.LR = 0x82256824; return 0x822453D8;
		/* 82256820h case    6:*/		return 0x82256824;
	}
	return 0x82256824;
} // Block from 82256808h-82256824h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82256824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256824);
		  /* 82256824h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82256824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82256824h case    0:*/		return 0x82256828;
		  /* 82256828h */ case    1:  		/* mr R3, R31 */
		/* 82256828h case    1:*/		regs.R3 = regs.R31;
		/* 82256828h case    1:*/		return 0x8225682C;
		  /* 8225682Ch */ case    2:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8225682Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8225682Ch case    2:*/		return 0x82256830;
		  /* 82256830h */ case    3:  		/* stw R11, <#[R31 + 228]> */
		/* 82256830h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82256830h case    3:*/		return 0x82256834;
		  /* 82256834h */ case    4:  		/* bl -12332 */
		/* 82256834h case    4:*/		regs.LR = 0x82256838; return 0x82253808;
		/* 82256834h case    4:*/		return 0x82256838;
		  /* 82256838h */ case    5:  		/* addi R1, R1, 96 */
		/* 82256838h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82256838h case    5:*/		return 0x8225683C;
		  /* 8225683Ch */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225683Ch case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225683Ch case    6:*/		return 0x82256840;
		  /* 82256840h */ case    7:  		/* mtspr LR, R12 */
		/* 82256840h case    7:*/		regs.LR = regs.R12;
		/* 82256840h case    7:*/		return 0x82256844;
		  /* 82256844h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82256844h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256844h case    8:*/		return 0x82256848;
		  /* 82256848h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82256848h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256848h case    9:*/		return 0x8225684C;
	}
	return 0x8225684C;
} // Block from 82256824h-8225684Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225684Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225684C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225684C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225684C);
		  /* 8225684Ch */ case    0:  		/* nop */
		/* 8225684Ch case    0:*/		cpu::op::nop();
		/* 8225684Ch case    0:*/		return 0x82256850;
	}
	return 0x82256850;
} // Block from 8225684Ch-82256850h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256850h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256850);
		  /* 82256850h */ case    0:  		/* mfspr R12, LR */
		/* 82256850h case    0:*/		regs.R12 = regs.LR;
		/* 82256850h case    0:*/		return 0x82256854;
		  /* 82256854h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82256854h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256854h case    1:*/		return 0x82256858;
		  /* 82256858h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82256858h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256858h case    2:*/		return 0x8225685C;
		  /* 8225685Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225685Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225685Ch case    3:*/		return 0x82256860;
		  /* 82256860h */ case    4:  		/* mr R31, R3 */
		/* 82256860h case    4:*/		regs.R31 = regs.R3;
		/* 82256860h case    4:*/		return 0x82256864;
		  /* 82256864h */ case    5:  		/* bl -12380 */
		/* 82256864h case    5:*/		regs.LR = 0x82256868; return 0x82253808;
		/* 82256864h case    5:*/		return 0x82256868;
		  /* 82256868h */ case    6:  		/* lwz R11, <#[R31 + 228]> */
		/* 82256868h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82256868h case    6:*/		return 0x8225686C;
		  /* 8225686Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8225686Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8225686Ch case    7:*/		return 0x82256870;
		  /* 82256870h */ case    8:  		/* stw R11, <#[R31 + 228]> */
		/* 82256870h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82256870h case    8:*/		return 0x82256874;
		  /* 82256874h */ case    9:  		/* addi R1, R1, 96 */
		/* 82256874h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82256874h case    9:*/		return 0x82256878;
		  /* 82256878h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 82256878h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256878h case   10:*/		return 0x8225687C;
		  /* 8225687Ch */ case   11:  		/* mtspr LR, R12 */
		/* 8225687Ch case   11:*/		regs.LR = regs.R12;
		/* 8225687Ch case   11:*/		return 0x82256880;
		  /* 82256880h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 82256880h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256880h case   12:*/		return 0x82256884;
		  /* 82256884h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82256884h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256884h case   13:*/		return 0x82256888;
	}
	return 0x82256888;
} // Block from 82256850h-82256888h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82256888h
// Function '?NumWrittenChannel@IRInst@XGRAPHICS@@QBAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256888);
		  /* 82256888h */ case    0:  		/* mfspr R12, LR */
		/* 82256888h case    0:*/		regs.R12 = regs.LR;
		/* 82256888h case    0:*/		return 0x8225688C;
		  /* 8225688Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225688Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225688Ch case    1:*/		return 0x82256890;
		  /* 82256890h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82256890h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82256890h case    2:*/		return 0x82256894;
		  /* 82256894h */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 82256894h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82256894h case    3:*/		return 0x82256898;
		  /* 82256898h */ case    4:  		/* cmpwi CR6, R11, 137 */
		/* 82256898h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000089);
		/* 82256898h case    4:*/		return 0x8225689C;
		  /* 8225689Ch */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 8225689Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x822568B0;  }
		/* 8225689Ch case    5:*/		return 0x822568A0;
		  /* 822568A0h */ case    6:  		/* bl -57928 */
		/* 822568A0h case    6:*/		regs.LR = 0x822568A4; return 0x82248658;
		/* 822568A0h case    6:*/		return 0x822568A4;
		  /* 822568A4h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822568A4h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822568A4h case    7:*/		return 0x822568A8;
		  /* 822568A8h */ case    8:  		/* li R11, 1 */
		/* 822568A8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822568A8h case    8:*/		return 0x822568AC;
		  /* 822568ACh */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 822568ACh case    9:*/		if ( !regs.CR[0].eq ) { return 0x822568B4;  }
		/* 822568ACh case    9:*/		return 0x822568B0;
	}
	return 0x822568B0;
} // Block from 82256888h-822568B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822568B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822568B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822568B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822568B0);
		  /* 822568B0h */ case    0:  		/* li R11, 0 */
		/* 822568B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822568B0h case    0:*/		return 0x822568B4;
	}
	return 0x822568B4;
} // Block from 822568B0h-822568B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822568B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822568B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822568B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822568B4);
		  /* 822568B4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 822568B4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 822568B4h case    0:*/		return 0x822568B8;
		  /* 822568B8h */ case    1:  		/* addi R1, R1, 96 */
		/* 822568B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822568B8h case    1:*/		return 0x822568BC;
		  /* 822568BCh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 822568BCh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822568BCh case    2:*/		return 0x822568C0;
		  /* 822568C0h */ case    3:  		/* mtspr LR, R12 */
		/* 822568C0h case    3:*/		regs.LR = regs.R12;
		/* 822568C0h case    3:*/		return 0x822568C4;
		  /* 822568C4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822568C4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822568C4h case    4:*/		return 0x822568C8;
	}
	return 0x822568C8;
} // Block from 822568B4h-822568C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822568C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822568C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822568C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822568C8);
		  /* 822568C8h */ case    0:  		/* lwz R11, <#[R3 + 956]> */
		/* 822568C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003BC) );
		/* 822568C8h case    0:*/		return 0x822568CC;
		  /* 822568CCh */ case    1:  		/* lwz R10, <#[R4 + 2152]> */
		/* 822568CCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000868) );
		/* 822568CCh case    1:*/		return 0x822568D0;
		  /* 822568D0h */ case    2:  		/* subf R10, R10, R11 */
		/* 822568D0h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 822568D0h case    2:*/		return 0x822568D4;
		  /* 822568D4h */ case    3:  		/* rlwinm R11, R10, 1, 31, 31 */
		/* 822568D4h case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R10);
		/* 822568D4h case    3:*/		return 0x822568D8;
		  /* 822568D8h */ case    4:  		/* addi R11, R11, -1 */
		/* 822568D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822568D8h case    4:*/		return 0x822568DC;
		  /* 822568DCh */ case    5:  		/* and R11, R11, R10 */
		/* 822568DCh case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822568DCh case    5:*/		return 0x822568E0;
	}
	return 0x822568E0;
} // Block from 822568C8h-822568E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822568E0h
// Function '?SetCompensationWriteMask@IRInst@XGRAPHICS@@QAAXPBV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822568E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822568E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822568E0);
		  /* 822568E0h */ case    0:  		/* addi R11, R11, -1 */
		/* 822568E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822568E0h case    0:*/		return 0x822568E4;
		  /* 822568E4h */ case    1:  		/* cntlzw R11, R11 */
		/* 822568E4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 822568E4h case    1:*/		return 0x822568E8;
		  /* 822568E8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 822568E8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 822568E8h case    2:*/		return 0x822568EC;
		  /* 822568ECh */ case    3:  		/* bclr 20, CR0_LT */
		/* 822568ECh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822568ECh case    3:*/		return 0x822568F0;
	}
	return 0x822568F0;
} // Block from 822568E0h-822568F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822568F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822568F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822568F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822568F0);
		  /* 822568F0h */ case    0:  		/* cmpwi CR6, R4, 0 */
		/* 822568F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 822568F0h case    0:*/		return 0x822568F4;
		  /* 822568F4h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 822568F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8225690C;  }
		/* 822568F4h case    1:*/		return 0x822568F8;
		  /* 822568F8h */ case    2:  		/* lis R11, -32252 */
		/* 822568F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822568F8h case    2:*/		return 0x822568FC;
		  /* 822568FCh */ case    3:  		/* lwz R10, <#[R3 + 128]> */
		/* 822568FCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000080) );
		/* 822568FCh case    3:*/		return 0x82256900;
		  /* 82256900h */ case    4:  		/* addi R11, R11, 28864 */
		/* 82256900h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x70C0);
		/* 82256900h case    4:*/		return 0x82256904;
		  /* 82256904h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 82256904h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82256904h case    5:*/		return 0x82256908;
		  /* 82256908h */ case    6:  		/* b 24 */
		/* 82256908h case    6:*/		return 0x82256920;
		/* 82256908h case    6:*/		return 0x8225690C;
	}
	return 0x8225690C;
} // Block from 822568F0h-8225690Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225690Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225690C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225690C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225690C);
		  /* 8225690Ch */ case    0:  		/* addi R11, R4, 32 */
		/* 8225690Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 8225690Ch case    0:*/		return 0x82256910;
		  /* 82256910h */ case    1:  		/* lis R10, -32252 */
		/* 82256910h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82256910h case    1:*/		return 0x82256914;
		  /* 82256914h */ case    2:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82256914h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82256914h case    2:*/		return 0x82256918;
		  /* 82256918h */ case    3:  		/* lwz R11, <#[R10 + 28864]> */
		/* 82256918h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000070C0) );
		/* 82256918h case    3:*/		return 0x8225691C;
		  /* 8225691Ch */ case    4:  		/* lwzx R10, <#[R9 + R3]> */
		/* 8225691Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8225691Ch case    4:*/		return 0x82256920;
	}
	return 0x82256920;
} // Block from 8225690Ch-82256920h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82256920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256920);
		  /* 82256920h */ case    0:  		/* subf R11, R10, R11 */
		/* 82256920h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82256920h case    0:*/		return 0x82256924;
		  /* 82256924h */ case    1:  		/* addic R10, R11, -1 */
		/* 82256924h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82256924h case    1:*/		return 0x82256928;
		  /* 82256928h */ case    2:  		/* subfe R3, R10, R11 */
		/* 82256928h case    2:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82256928h case    2:*/		return 0x8225692C;
		  /* 8225692Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8225692Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225692Ch case    3:*/		return 0x82256930;
	}
	return 0x82256930;
} // Block from 82256920h-82256930h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256930h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256930);
		  /* 82256930h */ case    0:  		/* lwz R11, <#[R4 + 2736]> */
		/* 82256930h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000AB0) );
		/* 82256930h case    0:*/		return 0x82256934;
		  /* 82256934h */ case    1:  		/* lbz R11, <#[R11 + 2144]> */
		/* 82256934h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000860) );
		/* 82256934h case    1:*/		return 0x82256938;
		  /* 82256938h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82256938h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82256938h case    2:*/		return 0x8225693C;
		  /* 8225693Ch */ case    3:  		/* bc 12, CR0_EQ, 140 */
		/* 8225693Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x822569C8;  }
		/* 8225693Ch case    3:*/		return 0x82256940;
		  /* 82256940h */ case    4:  		/* cmpwi CR6, R3, 20 */
		/* 82256940h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000014);
		/* 82256940h case    4:*/		return 0x82256944;
		  /* 82256944h */ case    5:  		/* bc 12, CR6_GT, 52 */
		/* 82256944h case    5:*/		if ( regs.CR[6].gt ) { return 0x82256978;  }
		/* 82256944h case    5:*/		return 0x82256948;
		  /* 82256948h */ case    6:  		/* cmpwi CR6, R3, 19 */
		/* 82256948h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000013);
		/* 82256948h case    6:*/		return 0x8225694C;
		  /* 8225694Ch */ case    7:  		/* bc 4, CR6_LT, 84 */
		/* 8225694Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x822569A0;  }
		/* 8225694Ch case    7:*/		return 0x82256950;
		  /* 82256950h */ case    8:  		/* cmpwi CR6, R3, 4 */
		/* 82256950h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 82256950h case    8:*/		return 0x82256954;
		  /* 82256954h */ case    9:  		/* bc 12, CR6_EQ, 76 */
		/* 82256954h case    9:*/		if ( regs.CR[6].eq ) { return 0x822569A0;  }
		/* 82256954h case    9:*/		return 0x82256958;
	}
	return 0x82256958;
} // Block from 82256930h-82256958h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82256958h
// Function '?DestHasMasks@IRInst@XGRAPHICS@@QBA?B_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256958);
		  /* 82256958h */ case    0:  		/* bc 4, CR6_GT, 104 */
		/* 82256958h case    0:*/		if ( !regs.CR[6].gt ) { return 0x822569C0;  }
		/* 82256958h case    0:*/		return 0x8225695C;
		  /* 8225695Ch */ case    1:  		/* cmpwi CR6, R3, 7 */
		/* 8225695Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000007);
		/* 8225695Ch case    1:*/		return 0x82256960;
		  /* 82256960h */ case    2:  		/* bclr 4, CR6_GT */
		/* 82256960h case    2:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82256960h case    2:*/		return 0x82256964;
	}
	return 0x82256964;
} // Block from 82256958h-82256964h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82256964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256964);
		  /* 82256964h */ case    0:  		/* cmpwi CR6, R3, 8 */
		/* 82256964h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 82256964h case    0:*/		return 0x82256968;
		  /* 82256968h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 82256968h case    1:*/		if ( regs.CR[6].eq ) { return 0x822569A8;  }
		/* 82256968h case    1:*/		return 0x8225696C;
		  /* 8225696Ch */ case    2:  		/* cmpwi CR6, R3, 9 */
		/* 8225696Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000009);
		/* 8225696Ch case    2:*/		return 0x82256970;
		  /* 82256970h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82256970h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82256970h case    3:*/		return 0x82256974;
	}
	return 0x82256974;
} // Block from 82256964h-82256974h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256974);
		  /* 82256974h */ case    0:  		/* b 76 */
		/* 82256974h case    0:*/		return 0x822569C0;
		/* 82256974h case    0:*/		return 0x82256978;
	}
	return 0x82256978;
} // Block from 82256974h-82256978h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256978);
		  /* 82256978h */ case    0:  		/* cmpwi CR6, R3, 33 */
		/* 82256978h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000021);
		/* 82256978h case    0:*/		return 0x8225697C;
		  /* 8225697Ch */ case    1:  		/* bc 12, CR6_GT, 52 */
		/* 8225697Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x822569B0;  }
		/* 8225697Ch case    1:*/		return 0x82256980;
		  /* 82256980h */ case    2:  		/* cmpwi CR6, R3, 32 */
		/* 82256980h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000020);
		/* 82256980h case    2:*/		return 0x82256984;
		  /* 82256984h */ case    3:  		/* bc 4, CR6_LT, 28 */
		/* 82256984h case    3:*/		if ( !regs.CR[6].lt ) { return 0x822569A0;  }
		/* 82256984h case    3:*/		return 0x82256988;
		  /* 82256988h */ case    4:  		/* cmpwi CR6, R3, 21 */
		/* 82256988h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000015);
		/* 82256988h case    4:*/		return 0x8225698C;
		  /* 8225698Ch */ case    5:  		/* bc 12, CR6_LT, 52 */
		/* 8225698Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x822569C0;  }
		/* 8225698Ch case    5:*/		return 0x82256990;
		  /* 82256990h */ case    6:  		/* cmpwi CR6, R3, 22 */
		/* 82256990h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000016);
		/* 82256990h case    6:*/		return 0x82256994;
		  /* 82256994h */ case    7:  		/* bc 4, CR6_GT, 20 */
		/* 82256994h case    7:*/		if ( !regs.CR[6].gt ) { return 0x822569A8;  }
		/* 82256994h case    7:*/		return 0x82256998;
	}
	return 0x82256998;
} // Block from 82256978h-82256998h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82256998h
// Function '?Make@IRInst@XGRAPHICS@@SAPAV12@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256998);
		  /* 82256998h */ case    0:  		/* cmpwi CR6, R3, 24 */
		/* 82256998h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000018);
		/* 82256998h case    0:*/		return 0x8225699C;
		  /* 8225699Ch */ case    1:  		/* bc 12, CR6_GT, 36 */
		/* 8225699Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x822569C0;  }
		/* 8225699Ch case    1:*/		return 0x822569A0;
	}
	return 0x822569A0;
} // Block from 82256998h-822569A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822569A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569A0);
		  /* 822569A0h */ case    0:  		/* li R3, 4 */
		/* 822569A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 822569A0h case    0:*/		return 0x822569A4;
		  /* 822569A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822569A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822569A4h case    1:*/		return 0x822569A8;
	}
	return 0x822569A8;
} // Block from 822569A0h-822569A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822569A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569A8);
		  /* 822569A8h */ case    0:  		/* li R3, 8 */
		/* 822569A8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 822569A8h case    0:*/		return 0x822569AC;
		  /* 822569ACh */ case    1:  		/* bclr 20, CR0_LT */
		/* 822569ACh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822569ACh case    1:*/		return 0x822569B0;
	}
	return 0x822569B0;
} // Block from 822569A8h-822569B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822569B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569B0);
		  /* 822569B0h */ case    0:  		/* cmpwi CR6, R3, 43 */
		/* 822569B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000002B);
		/* 822569B0h case    0:*/		return 0x822569B4;
		  /* 822569B4h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 822569B4h case    1:*/		if ( regs.CR[6].lt ) { return 0x822569C0;  }
		/* 822569B4h case    1:*/		return 0x822569B8;
		  /* 822569B8h */ case    2:  		/* cmpwi CR6, R3, 44 */
		/* 822569B8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000002C);
		/* 822569B8h case    2:*/		return 0x822569BC;
		  /* 822569BCh */ case    3:  		/* bclr 4, CR6_GT */
		/* 822569BCh case    3:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 822569BCh case    3:*/		return 0x822569C0;
	}
	return 0x822569C0;
} // Block from 822569B0h-822569C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822569C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569C0);
		  /* 822569C0h */ case    0:  		/* li R3, 48 */
		/* 822569C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 822569C0h case    0:*/		return 0x822569C4;
		  /* 822569C4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822569C4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822569C4h case    1:*/		return 0x822569C8;
	}
	return 0x822569C8;
} // Block from 822569C0h-822569C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822569C8h
// Function '?Clone@IRInst@XGRAPHICS@@QAAPAV12@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569C8);
		  /* 822569C8h */ case    0:  		/* cmpwi CR6, R3, 7 */
		/* 822569C8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000007);
		/* 822569C8h case    0:*/		return 0x822569CC;
		  /* 822569CCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822569CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x822569DC;  }
		/* 822569CCh case    1:*/		return 0x822569D0;
		  /* 822569D0h */ case    2:  		/* cmpwi CR6, R3, 8 */
		/* 822569D0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 822569D0h case    2:*/		return 0x822569D4;
		  /* 822569D4h */ case    3:  		/* bc 12, CR6_EQ, -44 */
		/* 822569D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x822569A8;  }
		/* 822569D4h case    3:*/		return 0x822569D8;
		  /* 822569D8h */ case    4:  		/* b -24 */
		/* 822569D8h case    4:*/		return 0x822569C0;
		/* 822569D8h case    4:*/		return 0x822569DC;
	}
	return 0x822569DC;
} // Block from 822569C8h-822569DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822569DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569DC);
		  /* 822569DCh */ case    0:  		/* li R3, 7 */
		/* 822569DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x7);
		/* 822569DCh case    0:*/		return 0x822569E0;
		  /* 822569E0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822569E0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822569E0h case    1:*/		return 0x822569E4;
	}
	return 0x822569E4;
} // Block from 822569DCh-822569E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822569E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569E4);
		  /* 822569E4h */ case    0:  		/* nop */
		/* 822569E4h case    0:*/		cpu::op::nop();
		/* 822569E4h case    0:*/		return 0x822569E8;
	}
	return 0x822569E8;
} // Block from 822569E4h-822569E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822569E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822569E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822569E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822569E8);
		  /* 822569E8h */ case    0:  		/* mfspr R12, LR */
		/* 822569E8h case    0:*/		regs.R12 = regs.LR;
		/* 822569E8h case    0:*/		return 0x822569EC;
		  /* 822569ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822569ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822569ECh case    1:*/		return 0x822569F0;
		  /* 822569F0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 822569F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822569F0h case    2:*/		return 0x822569F4;
		  /* 822569F4h */ case    3:  		/* addi R10, R4, 58 */
		/* 822569F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x3A);
		/* 822569F4h case    3:*/		return 0x822569F8;
		  /* 822569F8h */ case    4:  		/* mr R9, R3 */
		/* 822569F8h case    4:*/		regs.R9 = regs.R3;
		/* 822569F8h case    4:*/		return 0x822569FC;
		  /* 822569FCh */ case    5:  		/* rlwinm R8, R10, 2, 0, 29 */
		/* 822569FCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 822569FCh case    5:*/		return 0x82256A00;
		  /* 82256A00h */ case    6:  		/* mr R11, R5 */
		/* 82256A00h case    6:*/		regs.R11 = regs.R5;
		/* 82256A00h case    6:*/		return 0x82256A04;
		  /* 82256A04h */ case    7:  		/* li R10, 0 */
		/* 82256A04h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82256A04h case    7:*/		return 0x82256A08;
		  /* 82256A08h */ case    8:  		/* lwzx R3, <#[R8 + R3]> */
		/* 82256A08h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82256A08h case    8:*/		return 0x82256A0C;
		  /* 82256A0Ch */ case    9:  		/* b 44 */
		/* 82256A0Ch case    9:*/		return 0x82256A38;
		/* 82256A0Ch case    9:*/		return 0x82256A10;
		  /* 82256A10h */ case   10:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82256A10h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82256A10h case   10:*/		return 0x82256A14;
		  /* 82256A14h */ case   11:  		/* bc 4, CR0_EQ, 44 */
		/* 82256A14h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82256A40;  }
		/* 82256A14h case   11:*/		return 0x82256A18;
		  /* 82256A18h */ case   12:  		/* lwz R10, <#[R11 + 228]> */
		/* 82256A18h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82256A18h case   12:*/		return 0x82256A1C;
		  /* 82256A1Ch */ case   13:  		/* rlwinm. R8, R10, 0, 31, 31 */
		/* 82256A1Ch case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R10);
		/* 82256A1Ch case   13:*/		return 0x82256A20;
		  /* 82256A20h */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 82256A20h case   14:*/		if ( regs.CR[0].eq ) { return 0x82256A2C;  }
		/* 82256A20h case   14:*/		return 0x82256A24;
		  /* 82256A24h */ case   15:  		/* cmplw CR6, R3, R11 */
		/* 82256A24h case   15:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82256A24h case   15:*/		return 0x82256A28;
	}
	return 0x82256A28;
} // Block from 822569E8h-82256A28h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82256A28h
// Function '?Validate@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256A28);
		  /* 82256A28h */ case    0:  		/* bc 12, CR6_EQ, 44 */
		/* 82256A28h case    0:*/		if ( regs.CR[6].eq ) { return 0x82256A54;  }
		/* 82256A28h case    0:*/		return 0x82256A2C;
	}
	return 0x82256A2C;
} // Block from 82256A28h-82256A2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256A2C);
		  /* 82256A2Ch */ case    0:  		/* nor R10, R10, R10 */
		/* 82256A2Ch case    0:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82256A2Ch case    0:*/		return 0x82256A30;
		  /* 82256A30h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 82256A30h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82256A30h case    1:*/		return 0x82256A34;
		  /* 82256A34h */ case    2:  		/* rlwinm R10, R10, 30, 31, 31 */
		/* 82256A34h case    2:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R10,regs.R10);
		/* 82256A34h case    2:*/		return 0x82256A38;
	}
	return 0x82256A38;
} // Block from 82256A2Ch-82256A38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82256A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256A38);
		  /* 82256A38h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82256A38h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82256A38h case    0:*/		return 0x82256A3C;
		  /* 82256A3Ch */ case    1:  		/* bc 4, CR6_EQ, -44 */
		/* 82256A3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82256A10;  }
		/* 82256A3Ch case    1:*/		return 0x82256A40;
	}
	return 0x82256A40;
} // Block from 82256A38h-82256A40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256A40);
		  /* 82256A40h */ case    0:  		/* li R3, 0 */
		/* 82256A40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256A40h case    0:*/		return 0x82256A44;
		  /* 82256A44h */ case    1:  		/* addi R1, R1, 96 */
		/* 82256A44h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82256A44h case    1:*/		return 0x82256A48;
		  /* 82256A48h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82256A48h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256A48h case    2:*/		return 0x82256A4C;
		  /* 82256A4Ch */ case    3:  		/* mtspr LR, R12 */
		/* 82256A4Ch case    3:*/		regs.LR = regs.R12;
		/* 82256A4Ch case    3:*/		return 0x82256A50;
		  /* 82256A50h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82256A50h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256A50h case    4:*/		return 0x82256A54;
	}
	return 0x82256A54;
} // Block from 82256A40h-82256A54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82256A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256A54);
		  /* 82256A54h */ case    0:  		/* lwz R11, <#[R9 + 20]> */
		/* 82256A54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82256A54h case    0:*/		return 0x82256A58;
		  /* 82256A58h */ case    1:  		/* cmpw CR6, R4, R11 */
		/* 82256A58h case    1:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R11);
		/* 82256A58h case    1:*/		return 0x82256A5C;
		  /* 82256A5Ch */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82256A5Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82256A6C;  }
		/* 82256A5Ch case    2:*/		return 0x82256A60;
		  /* 82256A60h */ case    3:  		/* lwz R11, <#[R9 + 228]> */
		/* 82256A60h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x000000E4) );
		/* 82256A60h case    3:*/		return 0x82256A64;
		  /* 82256A64h */ case    4:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82256A64h case    4:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82256A64h case    4:*/		return 0x82256A68;
		  /* 82256A68h */ case    5:  		/* bc 4, CR0_EQ, 64 */
		/* 82256A68h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82256AA8;  }
		/* 82256A68h case    5:*/		return 0x82256A6C;
	}
	return 0x82256A6C;
} // Block from 82256A54h-82256A6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82256A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256A6C);
		  /* 82256A6Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82256A6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82256A6Ch case    0:*/		return 0x82256A70;
		  /* 82256A70h */ case    1:  		/* lwz R11, <#[R11 + 52]> */
		/* 82256A70h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82256A70h case    1:*/		return 0x82256A74;
		  /* 82256A74h */ case    2:  		/* mtspr CTR, R11 */
		/* 82256A74h case    2:*/		regs.CTR = regs.R11;
		/* 82256A74h case    2:*/		return 0x82256A78;
		  /* 82256A78h */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 82256A78h case    3:*/		if ( 1 ) { regs.LR = 0x82256A7C; return (uint32)regs.CTR; }
		/* 82256A78h case    3:*/		return 0x82256A7C;
		  /* 82256A7Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82256A7Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82256A7Ch case    4:*/		return 0x82256A80;
		  /* 82256A80h */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 82256A80h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82256AA8;  }
		/* 82256A80h case    5:*/		return 0x82256A84;
		  /* 82256A84h */ case    6:  		/* lis R11, -32252 */
		/* 82256A84h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256A84h case    6:*/		return 0x82256A88;
		  /* 82256A88h */ case    7:  		/* lis R10, -32252 */
		/* 82256A88h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82256A88h case    7:*/		return 0x82256A8C;
		  /* 82256A8Ch */ case    8:  		/* lis R9, -32253 */
		/* 82256A8Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82256A8Ch case    8:*/		return 0x82256A90;
		  /* 82256A90h */ case    9:  		/* addi R6, R11, 28888 */
		/* 82256A90h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x70D8);
		/* 82256A90h case    9:*/		return 0x82256A94;
		  /* 82256A94h */ case   10:  		/* addi R5, R10, 29160 */
		/* 82256A94h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x71E8);
		/* 82256A94h case   10:*/		return 0x82256A98;
		  /* 82256A98h */ case   11:  		/* addi R4, R9, 27460 */
		/* 82256A98h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82256A98h case   11:*/		return 0x82256A9C;
		  /* 82256A9Ch */ case   12:  		/* li R7, 647 */
		/* 82256A9Ch case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x287);
		/* 82256A9Ch case   12:*/		return 0x82256AA0;
		  /* 82256AA0h */ case   13:  		/* li R3, 0 */
		/* 82256AA0h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256AA0h case   13:*/		return 0x82256AA4;
		  /* 82256AA4h */ case   14:  		/* bl -1044124 */
		/* 82256AA4h case   14:*/		regs.LR = 0x82256AA8; return 0x82157C08;
		/* 82256AA4h case   14:*/		return 0x82256AA8;
	}
	return 0x82256AA8;
} // Block from 82256A6Ch-82256AA8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82256AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256AA8);
		  /* 82256AA8h */ case    0:  		/* li R3, 1 */
		/* 82256AA8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82256AA8h case    0:*/		return 0x82256AAC;
		  /* 82256AACh */ case    1:  		/* b -104 */
		/* 82256AACh case    1:*/		return 0x82256A44;
		/* 82256AACh case    1:*/		return 0x82256AB0;
	}
	return 0x82256AB0;
} // Block from 82256AA8h-82256AB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256AB0);
		  /* 82256AB0h */ case    0:  		/* lwz R10, <#[R3 + 228]> */
		/* 82256AB0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000E4) );
		/* 82256AB0h case    0:*/		return 0x82256AB4;
		  /* 82256AB4h */ case    1:  		/* mr R11, R3 */
		/* 82256AB4h case    1:*/		regs.R11 = regs.R3;
		/* 82256AB4h case    1:*/		return 0x82256AB8;
		  /* 82256AB8h */ case    2:  		/* li R9, 0 */
		/* 82256AB8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82256AB8h case    2:*/		return 0x82256ABC;
		  /* 82256ABCh */ case    3:  		/* stw R6, <#[R3 + 56]> */
		/* 82256ABCh case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000038) );
		/* 82256ABCh case    3:*/		return 0x82256AC0;
		  /* 82256AC0h */ case    4:  		/* ori R10, R10, 66 */
		/* 82256AC0h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x42);
		/* 82256AC0h case    4:*/		return 0x82256AC4;
		  /* 82256AC4h */ case    5:  		/* mr R3, R4 */
		/* 82256AC4h case    5:*/		regs.R3 = regs.R4;
		/* 82256AC4h case    5:*/		return 0x82256AC8;
		  /* 82256AC8h */ case    6:  		/* mr R4, R11 */
		/* 82256AC8h case    6:*/		regs.R4 = regs.R11;
		/* 82256AC8h case    6:*/		return 0x82256ACC;
		  /* 82256ACCh */ case    7:  		/* stw R5, <#[R11 + 80]> */
		/* 82256ACCh case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000050) );
		/* 82256ACCh case    7:*/		return 0x82256AD0;
		  /* 82256AD0h */ case    8:  		/* stw R9, <#[R11 + 16]> */
		/* 82256AD0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82256AD0h case    8:*/		return 0x82256AD4;
		  /* 82256AD4h */ case    9:  		/* stw R10, <#[R11 + 228]> */
		/* 82256AD4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82256AD4h case    9:*/		return 0x82256AD8;
		  /* 82256AD8h */ case   10:  		/* b -133856 */
		/* 82256AD8h case   10:*/		return 0x82235FF8;
		/* 82256AD8h case   10:*/		return 0x82256ADC;
		  /* 82256ADCh */ case   11:  		/* nop */
		/* 82256ADCh case   11:*/		cpu::op::nop();
		/* 82256ADCh case   11:*/		return 0x82256AE0;
		  /* 82256AE0h */ case   12:  		/* rlwinm R11, R4, 0, 24, 31 */
		/* 82256AE0h case   12:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82256AE0h case   12:*/		return 0x82256AE4;
		  /* 82256AE4h */ case   13:  		/* stw R4, <#[R3 + 168]> */
		/* 82256AE4h case   13:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x000000A8) );
		/* 82256AE4h case   13:*/		return 0x82256AE8;
		  /* 82256AE8h */ case   14:  		/* stb R11, <#[R3 + 132]> */
		/* 82256AE8h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000084) );
		/* 82256AE8h case   14:*/		return 0x82256AEC;
		  /* 82256AECh */ case   15:  		/* stb R11, <#[R3 + 133]> */
		/* 82256AECh case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000085) );
		/* 82256AECh case   15:*/		return 0x82256AF0;
		  /* 82256AF0h */ case   16:  		/* stb R11, <#[R3 + 134]> */
		/* 82256AF0h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000086) );
		/* 82256AF0h case   16:*/		return 0x82256AF4;
		  /* 82256AF4h */ case   17:  		/* stb R11, <#[R3 + 135]> */
		/* 82256AF4h case   17:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000087) );
		/* 82256AF4h case   17:*/		return 0x82256AF8;
		  /* 82256AF8h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82256AF8h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256AF8h case   18:*/		return 0x82256AFC;
	}
	return 0x82256AFC;
} // Block from 82256AB0h-82256AFCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82256AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256AFC);
		  /* 82256AFCh */ case    0:  		/* nop */
		/* 82256AFCh case    0:*/		cpu::op::nop();
		/* 82256AFCh case    0:*/		return 0x82256B00;
	}
	return 0x82256B00;
} // Block from 82256AFCh-82256B00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256B00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256B00);
		  /* 82256B00h */ case    0:  		/* mfspr R12, LR */
		/* 82256B00h case    0:*/		regs.R12 = regs.LR;
		/* 82256B00h case    0:*/		return 0x82256B04;
		  /* 82256B04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82256B04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256B04h case    1:*/		return 0x82256B08;
		  /* 82256B08h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82256B08h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82256B08h case    2:*/		return 0x82256B0C;
		  /* 82256B0Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82256B0Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256B0Ch case    3:*/		return 0x82256B10;
		  /* 82256B10h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82256B10h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82256B10h case    4:*/		return 0x82256B14;
		  /* 82256B14h */ case    5:  		/* mr R30, R3 */
		/* 82256B14h case    5:*/		regs.R30 = regs.R3;
		/* 82256B14h case    5:*/		return 0x82256B18;
		  /* 82256B18h */ case    6:  		/* lwz R3, <#[R3 + 180]> */
		/* 82256B18h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000000B4) );
		/* 82256B18h case    6:*/		return 0x82256B1C;
		  /* 82256B1Ch */ case    7:  		/* cmpwi CR6, R3, 0 */
		/* 82256B1Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82256B1Ch case    7:*/		return 0x82256B20;
		  /* 82256B20h */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 82256B20h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82256B60;  }
		/* 82256B20h case    8:*/		return 0x82256B24;
		  /* 82256B24h */ case    9:  		/* lwz R31, <#[R30 + 236]> */
		/* 82256B24h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x000000EC) );
		/* 82256B24h case    9:*/		return 0x82256B28;
		  /* 82256B28h */ case   10:  		/* b 36 */
		/* 82256B28h case   10:*/		return 0x82256B4C;
		/* 82256B28h case   10:*/		return 0x82256B2C;
		  /* 82256B2Ch */ case   11:  		/* lwz R11, <#[R3]> */
		/* 82256B2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82256B2Ch case   11:*/		return 0x82256B30;
		  /* 82256B30h */ case   12:  		/* lwz R11, <#[R11 + 68]> */
		/* 82256B30h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 82256B30h case   12:*/		return 0x82256B34;
		  /* 82256B34h */ case   13:  		/* mtspr CTR, R11 */
		/* 82256B34h case   13:*/		regs.CTR = regs.R11;
		/* 82256B34h case   13:*/		return 0x82256B38;
		  /* 82256B38h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 82256B38h case   14:*/		if ( 1 ) { regs.LR = 0x82256B3C; return (uint32)regs.CTR; }
		/* 82256B38h case   14:*/		return 0x82256B3C;
		  /* 82256B3Ch */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82256B3Ch case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82256B3Ch case   15:*/		return 0x82256B40;
		  /* 82256B40h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 82256B40h case   16:*/		if ( regs.CR[0].eq ) { return 0x82256B58;  }
		/* 82256B40h case   16:*/		return 0x82256B44;
		  /* 82256B44h */ case   17:  		/* lwz R11, <#[R31 + 236]> */
		/* 82256B44h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82256B44h case   17:*/		return 0x82256B48;
		  /* 82256B48h */ case   18:  		/* lwz R31, <#[R11 + 236]> */
		/* 82256B48h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x000000EC) );
		/* 82256B48h case   18:*/		return 0x82256B4C;
	}
	return 0x82256B4C;
} // Block from 82256B00h-82256B4Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82256B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256B4C);
		  /* 82256B4Ch */ case    0:  		/* lwz R3, <#[R31 + 236]> */
		/* 82256B4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000EC) );
		/* 82256B4Ch case    0:*/		return 0x82256B50;
		  /* 82256B50h */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 82256B50h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82256B50h case    1:*/		return 0x82256B54;
		  /* 82256B54h */ case    2:  		/* bc 4, CR6_EQ, -40 */
		/* 82256B54h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82256B2C;  }
		/* 82256B54h case    2:*/		return 0x82256B58;
	}
	return 0x82256B58;
} // Block from 82256B4Ch-82256B58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82256B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256B58);
		  /* 82256B58h */ case    0:  		/* stw R31, <#[R30 + 180]> */
		/* 82256B58h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000000B4) );
		/* 82256B58h case    0:*/		return 0x82256B5C;
		  /* 82256B5Ch */ case    1:  		/* mr R3, R31 */
		/* 82256B5Ch case    1:*/		regs.R3 = regs.R31;
		/* 82256B5Ch case    1:*/		return 0x82256B60;
	}
	return 0x82256B60;
} // Block from 82256B58h-82256B60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256B60);
		  /* 82256B60h */ case    0:  		/* addi R1, R1, 112 */
		/* 82256B60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82256B60h case    0:*/		return 0x82256B64;
		  /* 82256B64h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82256B64h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256B64h case    1:*/		return 0x82256B68;
		  /* 82256B68h */ case    2:  		/* mtspr LR, R12 */
		/* 82256B68h case    2:*/		regs.LR = regs.R12;
		/* 82256B68h case    2:*/		return 0x82256B6C;
		  /* 82256B6Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82256B6Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82256B6Ch case    3:*/		return 0x82256B70;
		  /* 82256B70h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82256B70h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256B70h case    4:*/		return 0x82256B74;
		  /* 82256B74h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82256B74h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256B74h case    5:*/		return 0x82256B78;
	}
	return 0x82256B78;
} // Block from 82256B60h-82256B78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82256B78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256B78);
		  /* 82256B78h */ case    0:  		/* mfspr R12, LR */
		/* 82256B78h case    0:*/		regs.R12 = regs.LR;
		/* 82256B78h case    0:*/		return 0x82256B7C;
		  /* 82256B7Ch */ case    1:  		/* bl -1857828 */
		/* 82256B7Ch case    1:*/		regs.LR = 0x82256B80; return 0x82091258;
		/* 82256B7Ch case    1:*/		return 0x82256B80;
		  /* 82256B80h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82256B80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82256B80h case    2:*/		return 0x82256B84;
		  /* 82256B84h */ case    3:  		/* lwz R11, <#[R3 + 952]> */
		/* 82256B84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003B8) );
		/* 82256B84h case    3:*/		return 0x82256B88;
		  /* 82256B88h */ case    4:  		/* lis R10, -32222 */
		/* 82256B88h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 82256B88h case    4:*/		return 0x82256B8C;
		  /* 82256B8Ch */ case    5:  		/* mr R29, R5 */
		/* 82256B8Ch case    5:*/		regs.R29 = regs.R5;
		/* 82256B8Ch case    5:*/		return 0x82256B90;
		  /* 82256B90h */ case    6:  		/* mr R30, R4 */
		/* 82256B90h case    6:*/		regs.R30 = regs.R4;
		/* 82256B90h case    6:*/		return 0x82256B94;
		  /* 82256B94h */ case    7:  		/* lwz R4, <#[R3 + 172]> */
		/* 82256B94h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x000000AC) );
		/* 82256B94h case    7:*/		return 0x82256B98;
		  /* 82256B98h */ case    8:  		/* addi R5, R1, 80 */
		/* 82256B98h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82256B98h case    8:*/		return 0x82256B9C;
		  /* 82256B9Ch */ case    9:  		/* mr R8, R11 */
		/* 82256B9Ch case    9:*/		regs.R8 = regs.R11;
		/* 82256B9Ch case    9:*/		return 0x82256BA0;
		  /* 82256BA0h */ case   10:  		/* addi R7, R10, -12392 */
		/* 82256BA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFCF98);
		/* 82256BA0h case   10:*/		return 0x82256BA4;
		  /* 82256BA4h */ case   11:  		/* mr R31, R3 */
		/* 82256BA4h case   11:*/		regs.R31 = regs.R3;
		/* 82256BA4h case   11:*/		return 0x82256BA8;
		  /* 82256BA8h */ case   12:  		/* lwz R3, <#[R11 + 1536]> */
		/* 82256BA8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000600) );
		/* 82256BA8h case   12:*/		return 0x82256BAC;
		  /* 82256BACh */ case   13:  		/* mr R28, R6 */
		/* 82256BACh case   13:*/		regs.R28 = regs.R6;
		/* 82256BACh case   13:*/		return 0x82256BB0;
		  /* 82256BB0h */ case   14:  		/* lwz R6, <#[R11 + 1384]> */
		/* 82256BB0h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000568) );
		/* 82256BB0h case   14:*/		return 0x82256BB4;
		  /* 82256BB4h */ case   15:  		/* bl -148172 */
		/* 82256BB4h case   15:*/		regs.LR = 0x82256BB8; return 0x822328E8;
		/* 82256BB4h case   15:*/		return 0x82256BB8;
		  /* 82256BB8h */ case   16:  		/* lis R11, -32222 */
		/* 82256BB8h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82256BB8h case   16:*/		return 0x82256BBC;
		  /* 82256BBCh */ case   17:  		/* mr R5, R28 */
		/* 82256BBCh case   17:*/		regs.R5 = regs.R28;
		/* 82256BBCh case   17:*/		return 0x82256BC0;
		  /* 82256BC0h */ case   18:  		/* lwz R4, <#[R31 + 172]> */
		/* 82256BC0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000AC) );
		/* 82256BC0h case   18:*/		return 0x82256BC4;
		  /* 82256BC4h */ case   19:  		/* addi R7, R11, -12392 */
		/* 82256BC4h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFCF98);
		/* 82256BC4h case   19:*/		return 0x82256BC8;
		  /* 82256BC8h */ case   20:  		/* lwz R11, <#[R31 + 952]> */
		/* 82256BC8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000003B8) );
		/* 82256BC8h case   20:*/		return 0x82256BCC;
		  /* 82256BCCh */ case   21:  		/* mr R8, R11 */
		/* 82256BCCh case   21:*/		regs.R8 = regs.R11;
		/* 82256BCCh case   21:*/		return 0x82256BD0;
		  /* 82256BD0h */ case   22:  		/* lwz R6, <#[R11 + 1384]> */
		/* 82256BD0h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000568) );
		/* 82256BD0h case   22:*/		return 0x82256BD4;
		  /* 82256BD4h */ case   23:  		/* lwz R3, <#[R11 + 1536]> */
		/* 82256BD4h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000600) );
		/* 82256BD4h case   23:*/		return 0x82256BD8;
		  /* 82256BD8h */ case   24:  		/* bl -147024 */
		/* 82256BD8h case   24:*/		regs.LR = 0x82256BDC; return 0x82232D88;
		/* 82256BD8h case   24:*/		return 0x82256BDC;
		  /* 82256BDCh */ case   25:  		/* lwz R11, <#[R1 + 112]> */
		/* 82256BDCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82256BDCh case   25:*/		return 0x82256BE0;
		  /* 82256BE0h */ case   26:  		/* lwz R10, <#[R1 + 116]> */
		/* 82256BE0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 82256BE0h case   26:*/		return 0x82256BE4;
		  /* 82256BE4h */ case   27:  		/* srawi R11, R11, 2 */
		/* 82256BE4h case   27:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 82256BE4h case   27:*/		return 0x82256BE8;
		  /* 82256BE8h */ case   28:  		/* addze R11, R11 */
		/* 82256BE8h case   28:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 82256BE8h case   28:*/		return 0x82256BEC;
		  /* 82256BECh */ case   29:  		/* stw R10, <#[R30]> */
		/* 82256BECh case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82256BECh case   29:*/		return 0x82256BF0;
		  /* 82256BF0h */ case   30:  		/* lwz R10, <#[R31 + 168]> */
		/* 82256BF0h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A8) );
		/* 82256BF0h case   30:*/		return 0x82256BF4;
		  /* 82256BF4h */ case   31:  		/* add R11, R10, R11 */
		/* 82256BF4h case   31:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82256BF4h case   31:*/		return 0x82256BF8;
		  /* 82256BF8h */ case   32:  		/* stw R11, <#[R29]> */
		/* 82256BF8h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82256BF8h case   32:*/		return 0x82256BFC;
		  /* 82256BFCh */ case   33:  		/* addi R1, R1, 160 */
		/* 82256BFCh case   33:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82256BFCh case   33:*/		return 0x82256C00;
		  /* 82256C00h */ case   34:  		/* b -1857880 */
		/* 82256C00h case   34:*/		return 0x820912A8;
		/* 82256C00h case   34:*/		return 0x82256C04;
		  /* 82256C04h */ case   35:  		/* nop */
		/* 82256C04h case   35:*/		cpu::op::nop();
		/* 82256C04h case   35:*/		return 0x82256C08;
	}
	return 0x82256C08;
} // Block from 82256B78h-82256C08h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82256C08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256C08);
		  /* 82256C08h */ case    0:  		/* mfspr R12, LR */
		/* 82256C08h case    0:*/		regs.R12 = regs.LR;
		/* 82256C08h case    0:*/		return 0x82256C0C;
		  /* 82256C0Ch */ case    1:  		/* bl -1857984 */
		/* 82256C0Ch case    1:*/		regs.LR = 0x82256C10; return 0x8209124C;
		/* 82256C0Ch case    1:*/		return 0x82256C10;
		  /* 82256C10h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82256C10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82256C10h case    2:*/		return 0x82256C14;
		  /* 82256C14h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82256C14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82256C14h case    3:*/		return 0x82256C18;
		  /* 82256C18h */ case    4:  		/* mr R31, R3 */
		/* 82256C18h case    4:*/		regs.R31 = regs.R3;
		/* 82256C18h case    4:*/		return 0x82256C1C;
		  /* 82256C1Ch */ case    5:  		/* mr R27, R4 */
		/* 82256C1Ch case    5:*/		regs.R27 = regs.R4;
		/* 82256C1Ch case    5:*/		return 0x82256C20;
		  /* 82256C20h */ case    6:  		/* mr R25, R5 */
		/* 82256C20h case    6:*/		regs.R25 = regs.R5;
		/* 82256C20h case    6:*/		return 0x82256C24;
		  /* 82256C24h */ case    7:  		/* mr R28, R6 */
		/* 82256C24h case    7:*/		regs.R28 = regs.R6;
		/* 82256C24h case    7:*/		return 0x82256C28;
		  /* 82256C28h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82256C28h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82256C28h case    8:*/		return 0x82256C2C;
		  /* 82256C2Ch */ case    9:  		/* mtspr CTR, R11 */
		/* 82256C2Ch case    9:*/		regs.CTR = regs.R11;
		/* 82256C2Ch case    9:*/		return 0x82256C30;
		  /* 82256C30h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 82256C30h case   10:*/		if ( 1 ) { regs.LR = 0x82256C34; return (uint32)regs.CTR; }
		/* 82256C30h case   10:*/		return 0x82256C34;
		  /* 82256C34h */ case   11:  		/* lis R11, -32216 */
		/* 82256C34h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82256C34h case   11:*/		return 0x82256C38;
		  /* 82256C38h */ case   12:  		/* lwz R9, <#[R31 + 24]> */
		/* 82256C38h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82256C38h case   12:*/		return 0x82256C3C;
		  /* 82256C3Ch */ case   13:  		/* lis R10, -32253 */
		/* 82256C3Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 82256C3Ch case   13:*/		return 0x82256C40;
		  /* 82256C40h */ case   14:  		/* addi R11, R11, 17992 */
		/* 82256C40h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4648);
		/* 82256C40h case   14:*/		return 0x82256C44;
		  /* 82256C44h */ case   15:  		/* mulli R8, R9, 52 */
		/* 82256C44h case   15:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R9,0x34);
		/* 82256C44h case   15:*/		return 0x82256C48;
	}
	return 0x82256C48;
} // Block from 82256C08h-82256C48h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82256C48h
// Function '?GetIndexingMode@IRInst@XGRAPHICS@@QBA?AW4IDX_MODE@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256C48);
		  /* 82256C48h */ case    0:  		/* addi R11, R11, 4 */
		/* 82256C48h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82256C48h case    0:*/		return 0x82256C4C;
		  /* 82256C4Ch */ case    1:  		/* lis R9, -32252 */
		/* 82256C4Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82256C4Ch case    1:*/		return 0x82256C50;
		  /* 82256C50h */ case    2:  		/* mr R26, R3 */
		/* 82256C50h case    2:*/		regs.R26 = regs.R3;
		/* 82256C50h case    2:*/		return 0x82256C54;
		  /* 82256C54h */ case    3:  		/* addi R30, R10, 27460 */
		/* 82256C54h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0x6B44);
		/* 82256C54h case    3:*/		return 0x82256C58;
		  /* 82256C58h */ case    4:  		/* addi R29, R9, 28888 */
		/* 82256C58h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R9,0x70D8);
		/* 82256C58h case    4:*/		return 0x82256C5C;
		  /* 82256C5Ch */ case    5:  		/* lwzx R11, <#[R8 + R11]> */
		/* 82256C5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82256C5Ch case    5:*/		return 0x82256C60;
		  /* 82256C60h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82256C60h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82256C60h case    6:*/		return 0x82256C64;
		  /* 82256C64h */ case    7:  		/* stw R11, <#[R31 + 24]> */
		/* 82256C64h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82256C64h case    7:*/		return 0x82256C68;
		  /* 82256C68h */ case    8:  		/* bc 4, CR6_EQ, 32 */
		/* 82256C68h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82256C88;  }
		/* 82256C68h case    8:*/		return 0x82256C6C;
		  /* 82256C6Ch */ case    9:  		/* lis R11, -32252 */
		/* 82256C6Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256C6Ch case    9:*/		return 0x82256C70;
		  /* 82256C70h */ case   10:  		/* mr R6, R29 */
		/* 82256C70h case   10:*/		regs.R6 = regs.R29;
		/* 82256C70h case   10:*/		return 0x82256C74;
		  /* 82256C74h */ case   11:  		/* addi R5, R11, 29288 */
		/* 82256C74h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x7268);
		/* 82256C74h case   11:*/		return 0x82256C78;
		  /* 82256C78h */ case   12:  		/* mr R4, R30 */
		/* 82256C78h case   12:*/		regs.R4 = regs.R30;
		/* 82256C78h case   12:*/		return 0x82256C7C;
		  /* 82256C7Ch */ case   13:  		/* li R7, 1432 */
		/* 82256C7Ch case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x598);
		/* 82256C7Ch case   13:*/		return 0x82256C80;
		  /* 82256C80h */ case   14:  		/* li R3, 0 */
		/* 82256C80h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256C80h case   14:*/		return 0x82256C84;
		  /* 82256C84h */ case   15:  		/* bl -1044604 */
		/* 82256C84h case   15:*/		regs.LR = 0x82256C88; return 0x82157C08;
		/* 82256C84h case   15:*/		return 0x82256C88;
	}
	return 0x82256C88;
} // Block from 82256C48h-82256C88h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82256C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256C88);
		  /* 82256C88h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82256C88h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82256C88h case    0:*/		return 0x82256C8C;
		  /* 82256C8Ch */ case    1:  		/* bc 12, CR0_EQ, 108 */
		/* 82256C8Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82256CF8;  }
		/* 82256C8Ch case    1:*/		return 0x82256C90;
		  /* 82256C90h */ case    2:  		/* lwz R11, <#[R31 + 24]> */
		/* 82256C90h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82256C90h case    2:*/		return 0x82256C94;
		  /* 82256C94h */ case    3:  		/* cmpwi CR6, R11, 52 */
		/* 82256C94h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000034);
		/* 82256C94h case    3:*/		return 0x82256C98;
		  /* 82256C98h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82256C98h case    4:*/		if ( regs.CR[6].eq ) { return 0x82256CB8;  }
		/* 82256C98h case    4:*/		return 0x82256C9C;
		  /* 82256C9Ch */ case    5:  		/* lis R11, -32252 */
		/* 82256C9Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256C9Ch case    5:*/		return 0x82256CA0;
		  /* 82256CA0h */ case    6:  		/* mr R6, R29 */
		/* 82256CA0h case    6:*/		regs.R6 = regs.R29;
		/* 82256CA0h case    6:*/		return 0x82256CA4;
		  /* 82256CA4h */ case    7:  		/* addi R5, R11, 29264 */
		/* 82256CA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x7250);
		/* 82256CA4h case    7:*/		return 0x82256CA8;
	}
	return 0x82256CA8;
} // Block from 82256C88h-82256CA8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82256CA8h
// Function '?Init@IRInst@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256CA8);
		  /* 82256CA8h */ case    0:  		/* mr R4, R30 */
		/* 82256CA8h case    0:*/		regs.R4 = regs.R30;
		/* 82256CA8h case    0:*/		return 0x82256CAC;
		  /* 82256CACh */ case    1:  		/* li R7, 1434 */
		/* 82256CACh case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x59A);
		/* 82256CACh case    1:*/		return 0x82256CB0;
		  /* 82256CB0h */ case    2:  		/* li R3, 0 */
		/* 82256CB0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256CB0h case    2:*/		return 0x82256CB4;
		  /* 82256CB4h */ case    3:  		/* bl -1044652 */
		/* 82256CB4h case    3:*/		regs.LR = 0x82256CB8; return 0x82157C08;
		/* 82256CB4h case    3:*/		return 0x82256CB8;
	}
	return 0x82256CB8;
} // Block from 82256CA8h-82256CB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256CB8);
		  /* 82256CB8h */ case    0:  		/* lbz R11, <#[R31 + 154]> */
		/* 82256CB8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000009A) );
		/* 82256CB8h case    0:*/		return 0x82256CBC;
		  /* 82256CBCh */ case    1:  		/* li R10, 53 */
		/* 82256CBCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x35);
		/* 82256CBCh case    1:*/		return 0x82256CC0;
		  /* 82256CC0h */ case    2:  		/* lbz R9, <#[R31 + 153]> */
		/* 82256CC0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000099) );
		/* 82256CC0h case    2:*/		return 0x82256CC4;
		  /* 82256CC4h */ case    3:  		/* cntlzw R11, R11 */
		/* 82256CC4h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82256CC4h case    3:*/		return 0x82256CC8;
		  /* 82256CC8h */ case    4:  		/* stw R10, <#[R31 + 24]> */
		/* 82256CC8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82256CC8h case    4:*/		return 0x82256CCC;
		  /* 82256CCCh */ case    5:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82256CCCh case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82256CCCh case    5:*/		return 0x82256CD0;
		  /* 82256CD0h */ case    6:  		/* stb R11, <#[R31 + 154]> */
		/* 82256CD0h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000009A) );
		/* 82256CD0h case    6:*/		return 0x82256CD4;
		  /* 82256CD4h */ case    7:  		/* cmplw CR6, R9, R11 */
		/* 82256CD4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82256CD4h case    7:*/		return 0x82256CD8;
		  /* 82256CD8h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82256CD8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82256CF8;  }
		/* 82256CD8h case    8:*/		return 0x82256CDC;
		  /* 82256CDCh */ case    9:  		/* lis R11, -32252 */
		/* 82256CDCh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256CDCh case    9:*/		return 0x82256CE0;
		  /* 82256CE0h */ case   10:  		/* mr R6, R29 */
		/* 82256CE0h case   10:*/		regs.R6 = regs.R29;
		/* 82256CE0h case   10:*/		return 0x82256CE4;
		  /* 82256CE4h */ case   11:  		/* addi R5, R11, 29228 */
		/* 82256CE4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x722C);
		/* 82256CE4h case   11:*/		return 0x82256CE8;
		  /* 82256CE8h */ case   12:  		/* mr R4, R30 */
		/* 82256CE8h case   12:*/		regs.R4 = regs.R30;
		/* 82256CE8h case   12:*/		return 0x82256CEC;
		  /* 82256CECh */ case   13:  		/* li R7, 1438 */
		/* 82256CECh case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x59E);
		/* 82256CECh case   13:*/		return 0x82256CF0;
		  /* 82256CF0h */ case   14:  		/* li R3, 0 */
		/* 82256CF0h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256CF0h case   14:*/		return 0x82256CF4;
		  /* 82256CF4h */ case   15:  		/* bl -1044716 */
		/* 82256CF4h case   15:*/		regs.LR = 0x82256CF8; return 0x82157C08;
		/* 82256CF4h case   15:*/		return 0x82256CF8;
	}
	return 0x82256CF8;
} // Block from 82256CB8h-82256CF8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82256CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256CF8);
		  /* 82256CF8h */ case    0:  		/* rlwinm R11, R27, 0, 24, 31 */
		/* 82256CF8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82256CF8h case    0:*/		return 0x82256CFC;
		  /* 82256CFCh */ case    1:  		/* cmpwi CR6, R26, 2 */
		/* 82256CFCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000002);
		/* 82256CFCh case    1:*/		return 0x82256D00;
		  /* 82256D00h */ case    2:  		/* stb R11, <#[R31 + 132]> */
		/* 82256D00h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 82256D00h case    2:*/		return 0x82256D04;
		  /* 82256D04h */ case    3:  		/* stb R11, <#[R31 + 133]> */
		/* 82256D04h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000085) );
		/* 82256D04h case    3:*/		return 0x82256D08;
		  /* 82256D08h */ case    4:  		/* stb R11, <#[R31 + 134]> */
		/* 82256D08h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000086) );
		/* 82256D08h case    4:*/		return 0x82256D0C;
		  /* 82256D0Ch */ case    5:  		/* stb R11, <#[R31 + 135]> */
		/* 82256D0Ch case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000087) );
		/* 82256D0Ch case    5:*/		return 0x82256D10;
		  /* 82256D10h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 82256D10h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82256D28;  }
		/* 82256D10h case    6:*/		return 0x82256D14;
		  /* 82256D14h */ case    7:  		/* rlwinm R11, R25, 0, 24, 31 */
		/* 82256D14h case    7:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R25);
		/* 82256D14h case    7:*/		return 0x82256D18;
		  /* 82256D18h */ case    8:  		/* stb R11, <#[R31 + 136]> */
		/* 82256D18h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82256D18h case    8:*/		return 0x82256D1C;
		  /* 82256D1Ch */ case    9:  		/* stb R11, <#[R31 + 137]> */
		/* 82256D1Ch case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000089) );
		/* 82256D1Ch case    9:*/		return 0x82256D20;
		  /* 82256D20h */ case   10:  		/* stb R11, <#[R31 + 138]> */
		/* 82256D20h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000008A) );
		/* 82256D20h case   10:*/		return 0x82256D24;
		  /* 82256D24h */ case   11:  		/* stb R11, <#[R31 + 139]> */
		/* 82256D24h case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000008B) );
		/* 82256D24h case   11:*/		return 0x82256D28;
	}
	return 0x82256D28;
} // Block from 82256CF8h-82256D28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82256D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256D28);
		  /* 82256D28h */ case    0:  		/* addi R1, R1, 144 */
		/* 82256D28h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82256D28h case    0:*/		return 0x82256D2C;
		  /* 82256D2Ch */ case    1:  		/* b -1858192 */
		/* 82256D2Ch case    1:*/		return 0x8209129C;
		/* 82256D2Ch case    1:*/		return 0x82256D30;
	}
	return 0x82256D30;
} // Block from 82256D28h-82256D30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256D30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256D30);
		  /* 82256D30h */ case    0:  		/* mfspr R12, LR */
		/* 82256D30h case    0:*/		regs.R12 = regs.LR;
		/* 82256D30h case    0:*/		return 0x82256D34;
		  /* 82256D34h */ case    1:  		/* bl -1858268 */
		/* 82256D34h case    1:*/		regs.LR = 0x82256D38; return 0x82091258;
		/* 82256D34h case    1:*/		return 0x82256D38;
		  /* 82256D38h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82256D38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82256D38h case    2:*/		return 0x82256D3C;
		  /* 82256D3Ch */ case    3:  		/* lis R10, -32216 */
		/* 82256D3Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 82256D3Ch case    3:*/		return 0x82256D40;
		  /* 82256D40h */ case    4:  		/* lwz R11, <#[R3 + 24]> */
		/* 82256D40h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82256D40h case    4:*/		return 0x82256D44;
		  /* 82256D44h */ case    5:  		/* lis R9, -32253 */
		/* 82256D44h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82256D44h case    5:*/		return 0x82256D48;
		  /* 82256D48h */ case    6:  		/* addi R10, R10, 17992 */
		/* 82256D48h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4648);
		/* 82256D48h case    6:*/		return 0x82256D4C;
		  /* 82256D4Ch */ case    7:  		/* mulli R8, R11, 52 */
		/* 82256D4Ch case    7:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R11,0x34);
		/* 82256D4Ch case    7:*/		return 0x82256D50;
		  /* 82256D50h */ case    8:  		/* addi R10, R10, 4 */
		/* 82256D50h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82256D50h case    8:*/		return 0x82256D54;
		  /* 82256D54h */ case    9:  		/* addi R7, R11, -53 */
		/* 82256D54h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFCB);
		/* 82256D54h case    9:*/		return 0x82256D58;
		  /* 82256D58h */ case   10:  		/* lis R11, -32252 */
		/* 82256D58h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256D58h case   10:*/		return 0x82256D5C;
		  /* 82256D5Ch */ case   11:  		/* cntlzw R7, R7 */
		/* 82256D5Ch case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R7,regs.R7);
		/* 82256D5Ch case   11:*/		return 0x82256D60;
		  /* 82256D60h */ case   12:  		/* mr R31, R3 */
		/* 82256D60h case   12:*/		regs.R31 = regs.R3;
		/* 82256D60h case   12:*/		return 0x82256D64;
		  /* 82256D64h */ case   13:  		/* lwzx R10, <#[R8 + R10]> */
		/* 82256D64h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82256D64h case   13:*/		return 0x82256D68;
		  /* 82256D68h */ case   14:  		/* addi R30, R9, 27460 */
		/* 82256D68h case   14:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R9,0x6B44);
		/* 82256D68h case   14:*/		return 0x82256D6C;
		  /* 82256D6Ch */ case   15:  		/* rlwinm R28, R7, 27, 31, 31 */
		/* 82256D6Ch case   15:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R28,regs.R7);
		/* 82256D6Ch case   15:*/		return 0x82256D70;
		  /* 82256D70h */ case   16:  		/* addi R29, R11, 28888 */
		/* 82256D70h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x70D8);
		/* 82256D70h case   16:*/		return 0x82256D74;
		  /* 82256D74h */ case   17:  		/* cmpwi CR6, R10, 0 */
		/* 82256D74h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82256D74h case   17:*/		return 0x82256D78;
		  /* 82256D78h */ case   18:  		/* stw R10, <#[R3 + 24]> */
		/* 82256D78h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82256D78h case   18:*/		return 0x82256D7C;
		  /* 82256D7Ch */ case   19:  		/* bc 4, CR6_EQ, 32 */
		/* 82256D7Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x82256D9C;  }
		/* 82256D7Ch case   19:*/		return 0x82256D80;
		  /* 82256D80h */ case   20:  		/* lis R11, -32252 */
		/* 82256D80h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256D80h case   20:*/		return 0x82256D84;
		  /* 82256D84h */ case   21:  		/* mr R6, R29 */
		/* 82256D84h case   21:*/		regs.R6 = regs.R29;
		/* 82256D84h case   21:*/		return 0x82256D88;
		  /* 82256D88h */ case   22:  		/* addi R5, R11, 29288 */
		/* 82256D88h case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x7268);
		/* 82256D88h case   22:*/		return 0x82256D8C;
		  /* 82256D8Ch */ case   23:  		/* mr R4, R30 */
		/* 82256D8Ch case   23:*/		regs.R4 = regs.R30;
		/* 82256D8Ch case   23:*/		return 0x82256D90;
		  /* 82256D90h */ case   24:  		/* li R7, 1465 */
		/* 82256D90h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x5B9);
		/* 82256D90h case   24:*/		return 0x82256D94;
		  /* 82256D94h */ case   25:  		/* li R3, 0 */
		/* 82256D94h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256D94h case   25:*/		return 0x82256D98;
		  /* 82256D98h */ case   26:  		/* bl -1044880 */
		/* 82256D98h case   26:*/		regs.LR = 0x82256D9C; return 0x82157C08;
		/* 82256D98h case   26:*/		return 0x82256D9C;
	}
	return 0x82256D9C;
} // Block from 82256D30h-82256D9Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82256D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256D9C);
		  /* 82256D9Ch */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82256D9Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82256D9Ch case    0:*/		return 0x82256DA0;
		  /* 82256DA0h */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 82256DA0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82256DE0;  }
		/* 82256DA0h case    1:*/		return 0x82256DA4;
		  /* 82256DA4h */ case    2:  		/* lbz R11, <#[R31 + 153]> */
		/* 82256DA4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000099) );
		/* 82256DA4h case    2:*/		return 0x82256DA8;
		  /* 82256DA8h */ case    3:  		/* lbz R10, <#[R31 + 154]> */
		/* 82256DA8h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000009A) );
		/* 82256DA8h case    3:*/		return 0x82256DAC;
		  /* 82256DACh */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 82256DACh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82256DACh case    4:*/		return 0x82256DB0;
		  /* 82256DB0h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82256DB0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82256DD0;  }
		/* 82256DB0h case    5:*/		return 0x82256DB4;
		  /* 82256DB4h */ case    6:  		/* lis R11, -32252 */
		/* 82256DB4h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256DB4h case    6:*/		return 0x82256DB8;
		  /* 82256DB8h */ case    7:  		/* mr R6, R29 */
		/* 82256DB8h case    7:*/		regs.R6 = regs.R29;
		/* 82256DB8h case    7:*/		return 0x82256DBC;
		  /* 82256DBCh */ case    8:  		/* addi R5, R11, 29228 */
		/* 82256DBCh case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x722C);
		/* 82256DBCh case    8:*/		return 0x82256DC0;
		  /* 82256DC0h */ case    9:  		/* mr R4, R30 */
		/* 82256DC0h case    9:*/		regs.R4 = regs.R30;
		/* 82256DC0h case    9:*/		return 0x82256DC4;
		  /* 82256DC4h */ case   10:  		/* li R7, 1468 */
		/* 82256DC4h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x5BC);
		/* 82256DC4h case   10:*/		return 0x82256DC8;
		  /* 82256DC8h */ case   11:  		/* li R3, 0 */
		/* 82256DC8h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256DC8h case   11:*/		return 0x82256DCC;
		  /* 82256DCCh */ case   12:  		/* bl -1044932 */
		/* 82256DCCh case   12:*/		regs.LR = 0x82256DD0; return 0x82157C08;
		/* 82256DCCh case   12:*/		return 0x82256DD0;
	}
	return 0x82256DD0;
} // Block from 82256D9Ch-82256DD0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82256DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256DD0);
		  /* 82256DD0h */ case    0:  		/* lbz R11, <#[R31 + 154]> */
		/* 82256DD0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000009A) );
		/* 82256DD0h case    0:*/		return 0x82256DD4;
		  /* 82256DD4h */ case    1:  		/* cntlzw R11, R11 */
		/* 82256DD4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82256DD4h case    1:*/		return 0x82256DD8;
		  /* 82256DD8h */ case    2:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82256DD8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82256DD8h case    2:*/		return 0x82256DDC;
		  /* 82256DDCh */ case    3:  		/* stb R11, <#[R31 + 154]> */
		/* 82256DDCh case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000009A) );
		/* 82256DDCh case    3:*/		return 0x82256DE0;
	}
	return 0x82256DE0;
} // Block from 82256DD0h-82256DE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256DE0);
		  /* 82256DE0h */ case    0:  		/* mr R3, R28 */
		/* 82256DE0h case    0:*/		regs.R3 = regs.R28;
		/* 82256DE0h case    0:*/		return 0x82256DE4;
		  /* 82256DE4h */ case    1:  		/* addi R1, R1, 128 */
		/* 82256DE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82256DE4h case    1:*/		return 0x82256DE8;
		  /* 82256DE8h */ case    2:  		/* b -1858368 */
		/* 82256DE8h case    2:*/		return 0x820912A8;
		/* 82256DE8h case    2:*/		return 0x82256DEC;
		  /* 82256DECh */ case    3:  		/* nop */
		/* 82256DECh case    3:*/		cpu::op::nop();
		/* 82256DECh case    3:*/		return 0x82256DF0;
	}
	return 0x82256DF0;
} // Block from 82256DE0h-82256DF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256DF0);
		  /* 82256DF0h */ case    0:  		/* mfspr R12, LR */
		/* 82256DF0h case    0:*/		regs.R12 = regs.LR;
		/* 82256DF0h case    0:*/		return 0x82256DF4;
		  /* 82256DF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82256DF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256DF4h case    1:*/		return 0x82256DF8;
		  /* 82256DF8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82256DF8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256DF8h case    2:*/		return 0x82256DFC;
		  /* 82256DFCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82256DFCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82256DFCh case    3:*/		return 0x82256E00;
	}
	return 0x82256E00;
} // Block from 82256DF0h-82256E00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256E00h
// Function '?SetOperandWithVReg@IRInst@XGRAPHICS@@QAAXHPAVVRegInfo@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256E00);
		  /* 82256E00h */ case    0:  		/* lis R10, -32252 */
		/* 82256E00h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82256E00h case    0:*/		return 0x82256E04;
		  /* 82256E04h */ case    1:  		/* stw R4, <#[R3 + 24]> */
		/* 82256E04h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000018) );
		/* 82256E04h case    1:*/		return 0x82256E08;
		  /* 82256E08h */ case    2:  		/* li R11, 0 */
		/* 82256E08h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82256E08h case    2:*/		return 0x82256E0C;
		  /* 82256E0Ch */ case    3:  		/* addi R10, R10, 15944 */
		/* 82256E0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3E48);
		/* 82256E0Ch case    3:*/		return 0x82256E10;
		  /* 82256E10h */ case    4:  		/* stw R11, <#[R3 + 4]> */
		/* 82256E10h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82256E10h case    4:*/		return 0x82256E14;
		  /* 82256E14h */ case    5:  		/* li R9, 1 */
		/* 82256E14h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82256E14h case    5:*/		return 0x82256E18;
		  /* 82256E18h */ case    6:  		/* stw R10, <#[R3]> */
		/* 82256E18h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82256E18h case    6:*/		return 0x82256E1C;
		  /* 82256E1Ch */ case    7:  		/* mr R31, R3 */
		/* 82256E1Ch case    7:*/		regs.R31 = regs.R3;
		/* 82256E1Ch case    7:*/		return 0x82256E20;
		  /* 82256E20h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 82256E20h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82256E20h case    8:*/		return 0x82256E24;
		  /* 82256E24h */ case    9:  		/* lwz R10, <#[R5 + 1376]> */
		/* 82256E24h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000560) );
		/* 82256E24h case    9:*/		return 0x82256E28;
		  /* 82256E28h */ case   10:  		/* stw R10, <#[R3 + 224]> */
		/* 82256E28h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x000000E0) );
		/* 82256E28h case   10:*/		return 0x82256E2C;
		  /* 82256E2Ch */ case   11:  		/* lwz R10, <#[R5 + 1376]> */
		/* 82256E2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000560) );
		/* 82256E2Ch case   11:*/		return 0x82256E30;
		  /* 82256E30h */ case   12:  		/* addi R10, R10, 1 */
		/* 82256E30h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82256E30h case   12:*/		return 0x82256E34;
		  /* 82256E34h */ case   13:  		/* stw R10, <#[R5 + 1376]> */
		/* 82256E34h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000560) );
		/* 82256E34h case   13:*/		return 0x82256E38;
		  /* 82256E38h */ case   14:  		/* stw R11, <#[R3 + 892]> */
		/* 82256E38h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000037C) );
		/* 82256E38h case   14:*/		return 0x82256E3C;
		  /* 82256E3Ch */ case   15:  		/* stw R11, <#[R3 + 948]> */
		/* 82256E3Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000003B4) );
		/* 82256E3Ch case   15:*/		return 0x82256E40;
		  /* 82256E40h */ case   16:  		/* stw R5, <#[R3 + 952]> */
		/* 82256E40h case   16:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x000003B8) );
		/* 82256E40h case   16:*/		return 0x82256E44;
		  /* 82256E44h */ case   17:  		/* stw R11, <#[R3 + 956]> */
		/* 82256E44h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000003BC) );
		/* 82256E44h case   17:*/		return 0x82256E48;
		  /* 82256E48h */ case   18:  		/* stw R9, <#[R3 + 228]> */
		/* 82256E48h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x000000E4) );
		/* 82256E48h case   18:*/		return 0x82256E4C;
		  /* 82256E4Ch */ case   19:  		/* bl -3084 */
		/* 82256E4Ch case   19:*/		regs.LR = 0x82256E50; return 0x82256240;
		/* 82256E4Ch case   19:*/		return 0x82256E50;
		  /* 82256E50h */ case   20:  		/* addi R1, R1, 96 */
		/* 82256E50h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82256E50h case   20:*/		return 0x82256E54;
		  /* 82256E54h */ case   21:  		/* lwz R12, <#[R1 - 8]> */
		/* 82256E54h case   21:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256E54h case   21:*/		return 0x82256E58;
		  /* 82256E58h */ case   22:  		/* mtspr LR, R12 */
		/* 82256E58h case   22:*/		regs.LR = regs.R12;
		/* 82256E58h case   22:*/		return 0x82256E5C;
		  /* 82256E5Ch */ case   23:  		/* ld R31, <#[R1 - 16]> */
		/* 82256E5Ch case   23:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82256E5Ch case   23:*/		return 0x82256E60;
		  /* 82256E60h */ case   24:  		/* bclr 20, CR0_LT */
		/* 82256E60h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256E60h case   24:*/		return 0x82256E64;
	}
	return 0x82256E64;
} // Block from 82256E00h-82256E64h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82256E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256E64);
		  /* 82256E64h */ case    0:  		/* nop */
		/* 82256E64h case    0:*/		cpu::op::nop();
		/* 82256E64h case    0:*/		return 0x82256E68;
	}
	return 0x82256E68;
} // Block from 82256E64h-82256E68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256E68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256E68);
		  /* 82256E68h */ case    0:  		/* mfspr R12, LR */
		/* 82256E68h case    0:*/		regs.R12 = regs.LR;
		/* 82256E68h case    0:*/		return 0x82256E6C;
		  /* 82256E6Ch */ case    1:  		/* bl -1858576 */
		/* 82256E6Ch case    1:*/		regs.LR = 0x82256E70; return 0x8209125C;
		/* 82256E6Ch case    1:*/		return 0x82256E70;
		  /* 82256E70h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82256E70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82256E70h case    2:*/		return 0x82256E74;
		  /* 82256E74h */ case    3:  		/* lwz R11, <#[R3 + 952]> */
		/* 82256E74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000003B8) );
		/* 82256E74h case    3:*/		return 0x82256E78;
	}
	return 0x82256E78;
} // Block from 82256E68h-82256E78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82256E78h
// Function '?SetConstArg@IRInst@XGRAPHICS@@AAAXPAVCFG@2@HUkonst@2@111@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256E78);
		  /* 82256E78h */ case    0:  		/* mr R31, R3 */
		/* 82256E78h case    0:*/		regs.R31 = regs.R3;
		/* 82256E78h case    0:*/		return 0x82256E7C;
		  /* 82256E7Ch */ case    1:  		/* mr R29, R4 */
		/* 82256E7Ch case    1:*/		regs.R29 = regs.R4;
		/* 82256E7Ch case    1:*/		return 0x82256E80;
		  /* 82256E80h */ case    2:  		/* lbz R11, <#[R11 + 1393]> */
		/* 82256E80h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000571) );
		/* 82256E80h case    2:*/		return 0x82256E84;
		  /* 82256E84h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82256E84h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82256E84h case    3:*/		return 0x82256E88;
		  /* 82256E88h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 82256E88h case    4:*/		if ( regs.CR[0].eq ) { return 0x82256EB0;  }
		/* 82256E88h case    4:*/		return 0x82256E8C;
		  /* 82256E8Ch */ case    5:  		/* lis R11, -32252 */
		/* 82256E8Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82256E8Ch case    5:*/		return 0x82256E90;
		  /* 82256E90h */ case    6:  		/* lis R10, -32252 */
		/* 82256E90h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82256E90h case    6:*/		return 0x82256E94;
		  /* 82256E94h */ case    7:  		/* lis R9, -32253 */
		/* 82256E94h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82256E94h case    7:*/		return 0x82256E98;
		  /* 82256E98h */ case    8:  		/* addi R6, R11, 28888 */
		/* 82256E98h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x70D8);
		/* 82256E98h case    8:*/		return 0x82256E9C;
		  /* 82256E9Ch */ case    9:  		/* addi R5, R10, 12708 */
		/* 82256E9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x31A4);
		/* 82256E9Ch case    9:*/		return 0x82256EA0;
		  /* 82256EA0h */ case   10:  		/* addi R4, R9, 27460 */
		/* 82256EA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82256EA0h case   10:*/		return 0x82256EA4;
		  /* 82256EA4h */ case   11:  		/* li R7, 184 */
		/* 82256EA4h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xB8);
		/* 82256EA4h case   11:*/		return 0x82256EA8;
		  /* 82256EA8h */ case   12:  		/* li R3, 0 */
		/* 82256EA8h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82256EA8h case   12:*/		return 0x82256EAC;
		  /* 82256EACh */ case   13:  		/* bl -1045156 */
		/* 82256EACh case   13:*/		regs.LR = 0x82256EB0; return 0x82157C08;
		/* 82256EACh case   13:*/		return 0x82256EB0;
	}
	return 0x82256EB0;
} // Block from 82256E78h-82256EB0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82256EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256EB0);
		  /* 82256EB0h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82256EB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82256EB0h case    0:*/		return 0x82256EB4;
		  /* 82256EB4h */ case    1:  		/* mr R5, R29 */
		/* 82256EB4h case    1:*/		regs.R5 = regs.R29;
		/* 82256EB4h case    1:*/		return 0x82256EB8;
		  /* 82256EB8h */ case    2:  		/* mr R3, R31 */
		/* 82256EB8h case    2:*/		regs.R3 = regs.R31;
		/* 82256EB8h case    2:*/		return 0x82256EBC;
		  /* 82256EBCh */ case    3:  		/* addi R4, R11, 1 */
		/* 82256EBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 82256EBCh case    3:*/		return 0x82256EC0;
		  /* 82256EC0h */ case    4:  		/* bl -2856 */
		/* 82256EC0h case    4:*/		regs.LR = 0x82256EC4; return 0x82256398;
		/* 82256EC0h case    4:*/		return 0x82256EC4;
		  /* 82256EC4h */ case    5:  		/* lwz R11, <#[R31 + 20]> */
		/* 82256EC4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82256EC4h case    5:*/		return 0x82256EC8;
		  /* 82256EC8h */ case    6:  		/* addi R30, R11, 1 */
		/* 82256EC8h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 82256EC8h case    6:*/		return 0x82256ECC;
		  /* 82256ECCh */ case    7:  		/* stw R30, <#[R31 + 20]> */
		/* 82256ECCh case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 82256ECCh case    7:*/		return 0x82256ED0;
		  /* 82256ED0h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 82256ED0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82256ED0h case    8:*/		return 0x82256ED4;
		  /* 82256ED4h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 82256ED4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82256ED4h case    9:*/		return 0x82256ED8;
		  /* 82256ED8h */ case   10:  		/* bc 4, CR6_GT, 56 */
		/* 82256ED8h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82256F10;  }
		/* 82256ED8h case   10:*/		return 0x82256EDC;
		  /* 82256EDCh */ case   11:  		/* lwz R11, <#[R31 + 28]> */
		/* 82256EDCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82256EDCh case   11:*/		return 0x82256EE0;
		  /* 82256EE0h */ case   12:  		/* cmplw CR6, R29, R11 */
		/* 82256EE0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82256EE0h case   12:*/		return 0x82256EE4;
		  /* 82256EE4h */ case   13:  		/* bc 4, CR6_EQ, 44 */
		/* 82256EE4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82256F10;  }
		/* 82256EE4h case   13:*/		return 0x82256EE8;
		  /* 82256EE8h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 82256EE8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82256EE8h case   14:*/		return 0x82256EEC;
		  /* 82256EECh */ case   15:  		/* mr R3, R31 */
		/* 82256EECh case   15:*/		regs.R3 = regs.R31;
		/* 82256EECh case   15:*/		return 0x82256EF0;
		  /* 82256EF0h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 82256EF0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82256EF0h case   16:*/		return 0x82256EF4;
		  /* 82256EF4h */ case   17:  		/* mtspr CTR, R11 */
		/* 82256EF4h case   17:*/		regs.CTR = regs.R11;
		/* 82256EF4h case   17:*/		return 0x82256EF8;
		  /* 82256EF8h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 82256EF8h case   18:*/		if ( 1 ) { regs.LR = 0x82256EFC; return (uint32)regs.CTR; }
		/* 82256EF8h case   18:*/		return 0x82256EFC;
		  /* 82256EFCh */ case   19:  		/* cmpw CR6, R30, R3 */
		/* 82256EFCh case   19:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R3);
		/* 82256EFCh case   19:*/		return 0x82256F00;
		  /* 82256F00h */ case   20:  		/* bc 4, CR6_GT, 16 */
		/* 82256F00h case   20:*/		if ( !regs.CR[6].gt ) { return 0x82256F10;  }
		/* 82256F00h case   20:*/		return 0x82256F04;
		  /* 82256F04h */ case   21:  		/* lwz R11, <#[R31 + 228]> */
		/* 82256F04h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82256F04h case   21:*/		return 0x82256F08;
		  /* 82256F08h */ case   22:  		/* ori R11, R11, 512 */
		/* 82256F08h case   22:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82256F08h case   22:*/		return 0x82256F0C;
		  /* 82256F0Ch */ case   23:  		/* stw R11, <#[R31 + 228]> */
		/* 82256F0Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82256F0Ch case   23:*/		return 0x82256F10;
	}
	return 0x82256F10;
} // Block from 82256EB0h-82256F10h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82256F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256F10);
		  /* 82256F10h */ case    0:  		/* addi R1, R1, 112 */
		/* 82256F10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82256F10h case    0:*/		return 0x82256F14;
		  /* 82256F14h */ case    1:  		/* b -1858664 */
		/* 82256F14h case    1:*/		return 0x820912AC;
		/* 82256F14h case    1:*/		return 0x82256F18;
	}
	return 0x82256F18;
} // Block from 82256F10h-82256F18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82256F18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256F18);
		  /* 82256F18h */ case    0:  		/* mfspr R12, LR */
		/* 82256F18h case    0:*/		regs.R12 = regs.LR;
		/* 82256F18h case    0:*/		return 0x82256F1C;
		  /* 82256F1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82256F1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256F1Ch case    1:*/		return 0x82256F20;
		  /* 82256F20h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82256F20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82256F20h case    2:*/		return 0x82256F24;
		  /* 82256F24h */ case    3:  		/* li R11, 0 */
		/* 82256F24h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82256F24h case    3:*/		return 0x82256F28;
		  /* 82256F28h */ case    4:  		/* stfs FR1, <#[R1 + 84]> */
		/* 82256F28h case    4:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000054) );
		/* 82256F28h case    4:*/		return 0x82256F2C;
		  /* 82256F2Ch */ case    5:  		/* stfs FR2, <#[R1 + 92]> */
		/* 82256F2Ch case    5:*/		cpu::mem::store32f( regs, regs.FR2, (uint32)(regs.R1 + 0x0000005C) );
		/* 82256F2Ch case    5:*/		return 0x82256F30;
		  /* 82256F30h */ case    6:  		/* stfs FR3, <#[R1 + 100]> */
		/* 82256F30h case    6:*/		cpu::mem::store32f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000064) );
		/* 82256F30h case    6:*/		return 0x82256F34;
		  /* 82256F34h */ case    7:  		/* stw R11, <#[R1 + 80]> */
		/* 82256F34h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82256F34h case    7:*/		return 0x82256F38;
		  /* 82256F38h */ case    8:  		/* stfs FR4, <#[R1 + 108]> */
		/* 82256F38h case    8:*/		cpu::mem::store32f( regs, regs.FR4, (uint32)(regs.R1 + 0x0000006C) );
		/* 82256F38h case    8:*/		return 0x82256F3C;
		  /* 82256F3Ch */ case    9:  		/* stw R11, <#[R1 + 88]> */
		/* 82256F3Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82256F3Ch case    9:*/		return 0x82256F40;
		  /* 82256F40h */ case   10:  		/* stw R11, <#[R1 + 96]> */
		/* 82256F40h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82256F40h case   10:*/		return 0x82256F44;
		  /* 82256F44h */ case   11:  		/* stw R11, <#[R1 + 104]> */
		/* 82256F44h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82256F44h case   11:*/		return 0x82256F48;
		  /* 82256F48h */ case   12:  		/* ld R6, <#[R1 + 80]> */
		/* 82256F48h case   12:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82256F48h case   12:*/		return 0x82256F4C;
		  /* 82256F4Ch */ case   13:  		/* ld R7, <#[R1 + 88]> */
		/* 82256F4Ch case   13:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 82256F4Ch case   13:*/		return 0x82256F50;
		  /* 82256F50h */ case   14:  		/* ld R8, <#[R1 + 96]> */
		/* 82256F50h case   14:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82256F50h case   14:*/		return 0x82256F54;
		  /* 82256F54h */ case   15:  		/* ld R9, <#[R1 + 104]> */
		/* 82256F54h case   15:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000068) );
		/* 82256F54h case   15:*/		return 0x82256F58;
		  /* 82256F58h */ case   16:  		/* bl -2888 */
		/* 82256F58h case   16:*/		regs.LR = 0x82256F5C; return 0x82256410;
		/* 82256F58h case   16:*/		return 0x82256F5C;
		  /* 82256F5Ch */ case   17:  		/* addi R1, R1, 128 */
		/* 82256F5Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82256F5Ch case   17:*/		return 0x82256F60;
		  /* 82256F60h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82256F60h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256F60h case   18:*/		return 0x82256F64;
		  /* 82256F64h */ case   19:  		/* mtspr LR, R12 */
		/* 82256F64h case   19:*/		regs.LR = regs.R12;
		/* 82256F64h case   19:*/		return 0x82256F68;
		  /* 82256F68h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82256F68h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256F68h case   20:*/		return 0x82256F6C;
	}
	return 0x82256F6C;
} // Block from 82256F18h-82256F6Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 82256F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256F6C);
		  /* 82256F6Ch */ case    0:  		/* nop */
		/* 82256F6Ch case    0:*/		cpu::op::nop();
		/* 82256F6Ch case    0:*/		return 0x82256F70;
	}
	return 0x82256F70;
} // Block from 82256F6Ch-82256F70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256F70);
		  /* 82256F70h */ case    0:  		/* mfspr R12, LR */
		/* 82256F70h case    0:*/		regs.R12 = regs.LR;
		/* 82256F70h case    0:*/		return 0x82256F74;
		  /* 82256F74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82256F74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256F74h case    1:*/		return 0x82256F78;
		  /* 82256F78h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82256F78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82256F78h case    2:*/		return 0x82256F7C;
		  /* 82256F7Ch */ case    3:  		/* li R11, 1 */
		/* 82256F7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82256F7Ch case    3:*/		return 0x82256F80;
		  /* 82256F80h */ case    4:  		/* stw R6, <#[R1 + 84]> */
		/* 82256F80h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82256F80h case    4:*/		return 0x82256F84;
		  /* 82256F84h */ case    5:  		/* stw R7, <#[R1 + 92]> */
		/* 82256F84h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000005C) );
		/* 82256F84h case    5:*/		return 0x82256F88;
		  /* 82256F88h */ case    6:  		/* stw R8, <#[R1 + 100]> */
		/* 82256F88h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 82256F88h case    6:*/		return 0x82256F8C;
		  /* 82256F8Ch */ case    7:  		/* stw R9, <#[R1 + 108]> */
		/* 82256F8Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 82256F8Ch case    7:*/		return 0x82256F90;
		  /* 82256F90h */ case    8:  		/* stw R11, <#[R1 + 80]> */
		/* 82256F90h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82256F90h case    8:*/		return 0x82256F94;
		  /* 82256F94h */ case    9:  		/* stw R11, <#[R1 + 88]> */
		/* 82256F94h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82256F94h case    9:*/		return 0x82256F98;
		  /* 82256F98h */ case   10:  		/* stw R11, <#[R1 + 96]> */
		/* 82256F98h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82256F98h case   10:*/		return 0x82256F9C;
		  /* 82256F9Ch */ case   11:  		/* stw R11, <#[R1 + 104]> */
		/* 82256F9Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82256F9Ch case   11:*/		return 0x82256FA0;
		  /* 82256FA0h */ case   12:  		/* ld R6, <#[R1 + 80]> */
		/* 82256FA0h case   12:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82256FA0h case   12:*/		return 0x82256FA4;
		  /* 82256FA4h */ case   13:  		/* ld R7, <#[R1 + 88]> */
		/* 82256FA4h case   13:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 82256FA4h case   13:*/		return 0x82256FA8;
		  /* 82256FA8h */ case   14:  		/* ld R8, <#[R1 + 96]> */
		/* 82256FA8h case   14:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82256FA8h case   14:*/		return 0x82256FAC;
		  /* 82256FACh */ case   15:  		/* ld R9, <#[R1 + 104]> */
		/* 82256FACh case   15:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000068) );
		/* 82256FACh case   15:*/		return 0x82256FB0;
		  /* 82256FB0h */ case   16:  		/* bl -2976 */
		/* 82256FB0h case   16:*/		regs.LR = 0x82256FB4; return 0x82256410;
		/* 82256FB0h case   16:*/		return 0x82256FB4;
		  /* 82256FB4h */ case   17:  		/* addi R1, R1, 128 */
		/* 82256FB4h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82256FB4h case   17:*/		return 0x82256FB8;
		  /* 82256FB8h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82256FB8h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82256FB8h case   18:*/		return 0x82256FBC;
		  /* 82256FBCh */ case   19:  		/* mtspr LR, R12 */
		/* 82256FBCh case   19:*/		regs.LR = regs.R12;
		/* 82256FBCh case   19:*/		return 0x82256FC0;
		  /* 82256FC0h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82256FC0h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82256FC0h case   20:*/		return 0x82256FC4;
	}
	return 0x82256FC4;
} // Block from 82256F70h-82256FC4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82256FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256FC4);
		  /* 82256FC4h */ case    0:  		/* nop */
		/* 82256FC4h case    0:*/		cpu::op::nop();
		/* 82256FC4h case    0:*/		return 0x82256FC8;
	}
	return 0x82256FC8;
} // Block from 82256FC4h-82256FC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82256FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82256FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82256FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82256FC8);
		  /* 82256FC8h */ case    0:  		/* mfspr R12, LR */
		/* 82256FC8h case    0:*/		regs.R12 = regs.LR;
		/* 82256FC8h case    0:*/		return 0x82256FCC;
		  /* 82256FCCh */ case    1:  		/* bl -1858932 */
		/* 82256FCCh case    1:*/		regs.LR = 0x82256FD0; return 0x82091258;
		/* 82256FCCh case    1:*/		return 0x82256FD0;
		  /* 82256FD0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82256FD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82256FD0h case    2:*/		return 0x82256FD4;
		  /* 82256FD4h */ case    3:  		/* lwz R11, <#[R3 + 228]> */
		/* 82256FD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82256FD4h case    3:*/		return 0x82256FD8;
		  /* 82256FD8h */ case    4:  		/* mr R28, R3 */
		/* 82256FD8h case    4:*/		regs.R28 = regs.R3;
		/* 82256FD8h case    4:*/		return 0x82256FDC;
		  /* 82256FDCh */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82256FDCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82256FDCh case    5:*/		return 0x82256FE0;
		  /* 82256FE0h */ case    6:  		/* stw R11, <#[R3 + 228]> */
		/* 82256FE0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82256FE0h case    6:*/		return 0x82256FE4;
		  /* 82256FE4h */ case    7:  		/* bl -14300 */
		/* 82256FE4h case    7:*/		regs.LR = 0x82256FE8; return 0x82253808;
		/* 82256FE4h case    7:*/		return 0x82256FE8;
		  /* 82256FE8h */ case    8:  		/* lwz R11, <#[R28 + 228]> */
		/* 82256FE8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 82256FE8h case    8:*/		return 0x82256FEC;
		  /* 82256FECh */ case    9:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82256FECh case    9:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82256FECh case    9:*/		return 0x82256FF0;
		  /* 82256FF0h */ case   10:  		/* bc 12, CR0_EQ, 112 */
		/* 82256FF0h case   10:*/		if ( regs.CR[0].eq ) { return 0x82257060;  }
		/* 82256FF0h case   10:*/		return 0x82256FF4;
		  /* 82256FF4h */ case   11:  		/* lwz R11, <#[R28 + 952]> */
		/* 82256FF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000003B8) );
		/* 82256FF4h case   11:*/		return 0x82256FF8;
		  /* 82256FF8h */ case   12:  		/* li R30, 0 */
		/* 82256FF8h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82256FF8h case   12:*/		return 0x82256FFC;
		  /* 82256FFCh */ case   13:  		/* lwz R11, <#[R11 + 2736]> */
		/* 82256FFCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000AB0) );
		/* 82256FFCh case   13:*/		return 0x82257000;
		  /* 82257000h */ case   14:  		/* lwz R31, <#[R11 + 96]> */
		/* 82257000h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000060) );
		/* 82257000h case   14:*/		return 0x82257004;
		  /* 82257004h */ case   15:  		/* lwz R11, <#[R31 + 4]> */
		/* 82257004h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82257004h case   15:*/		return 0x82257008;
		  /* 82257008h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82257008h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82257008h case   16:*/		return 0x8225700C;
		  /* 8225700Ch */ case   17:  		/* bc 12, CR6_EQ, 84 */
		/* 8225700Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82257060;  }
		/* 8225700Ch case   17:*/		return 0x82257010;
		  /* 82257010h */ case   18:  		/* li R29, 0 */
		/* 82257010h case   18:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82257010h case   18:*/		return 0x82257014;
		  /* 82257014h */ case   19:  		/* cmplw CR6, R30, R11 */
		/* 82257014h case   19:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82257014h case   19:*/		return 0x82257018;
		  /* 82257018h */ case   20:  		/* bc 4, CR6_LT, 16 */
		/* 82257018h case   20:*/		if ( !regs.CR[6].lt ) { return 0x82257028;  }
		/* 82257018h case   20:*/		return 0x8225701C;
		  /* 8225701Ch */ case   21:  		/* lwz R11, <#[R31 + 8]> */
		/* 8225701Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8225701Ch case   21:*/		return 0x82257020;
		  /* 82257020h */ case   22:  		/* add R3, R11, R29 */
		/* 82257020h case   22:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82257020h case   22:*/		return 0x82257024;
		  /* 82257024h */ case   23:  		/* b 16 */
		/* 82257024h case   23:*/		return 0x82257034;
		/* 82257024h case   23:*/		return 0x82257028;
	}
	return 0x82257028;
} // Block from 82256FC8h-82257028h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82257028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257028);
		  /* 82257028h */ case    0:  		/* mr R4, R30 */
		/* 82257028h case    0:*/		regs.R4 = regs.R30;
		/* 82257028h case    0:*/		return 0x8225702C;
		  /* 8225702Ch */ case    1:  		/* mr R3, R31 */
		/* 8225702Ch case    1:*/		regs.R3 = regs.R31;
		/* 8225702Ch case    1:*/		return 0x82257030;
		  /* 82257030h */ case    2:  		/* bl -13680 */
		/* 82257030h case    2:*/		regs.LR = 0x82257034; return 0x82253AC0;
		/* 82257030h case    2:*/		return 0x82257034;
	}
	return 0x82257034;
} // Block from 82257028h-82257034h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257034);
		  /* 82257034h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82257034h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257034h case    0:*/		return 0x82257038;
		  /* 82257038h */ case    1:  		/* cmplw CR6, R11, R28 */
		/* 82257038h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82257038h case    1:*/		return 0x8225703C;
		  /* 8225703Ch */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8225703Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8225704C;  }
		/* 8225703Ch case    2:*/		return 0x82257040;
		  /* 82257040h */ case    3:  		/* mr R4, R30 */
		/* 82257040h case    3:*/		regs.R4 = regs.R30;
		/* 82257040h case    3:*/		return 0x82257044;
		  /* 82257044h */ case    4:  		/* mr R3, R31 */
		/* 82257044h case    4:*/		regs.R3 = regs.R31;
		/* 82257044h case    4:*/		return 0x82257048;
		  /* 82257048h */ case    5:  		/* bl -13896 */
		/* 82257048h case    5:*/		regs.LR = 0x8225704C; return 0x82253A00;
		/* 82257048h case    5:*/		return 0x8225704C;
	}
	return 0x8225704C;
} // Block from 82257034h-8225704Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225704Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225704C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225704C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225704C);
		  /* 8225704Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8225704Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8225704Ch case    0:*/		return 0x82257050;
		  /* 82257050h */ case    1:  		/* addi R30, R30, 1 */
		/* 82257050h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82257050h case    1:*/		return 0x82257054;
		  /* 82257054h */ case    2:  		/* addi R29, R29, 4 */
		/* 82257054h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82257054h case    2:*/		return 0x82257058;
		  /* 82257058h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 82257058h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82257058h case    3:*/		return 0x8225705C;
		  /* 8225705Ch */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8225705Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8225701C;  }
		/* 8225705Ch case    4:*/		return 0x82257060;
	}
	return 0x82257060;
} // Block from 8225704Ch-82257060h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82257060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257060);
		  /* 82257060h */ case    0:  		/* addi R1, R1, 128 */
		/* 82257060h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82257060h case    0:*/		return 0x82257064;
		  /* 82257064h */ case    1:  		/* b -1859004 */
		/* 82257064h case    1:*/		return 0x820912A8;
		/* 82257064h case    1:*/		return 0x82257068;
	}
	return 0x82257068;
} // Block from 82257060h-82257068h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257068);
		  /* 82257068h */ case    0:  		/* mfspr R12, LR */
		/* 82257068h case    0:*/		regs.R12 = regs.LR;
		/* 82257068h case    0:*/		return 0x8225706C;
		  /* 8225706Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225706Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225706Ch case    1:*/		return 0x82257070;
		  /* 82257070h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82257070h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82257070h case    2:*/		return 0x82257074;
		  /* 82257074h */ case    3:  		/* bl -644 */
		/* 82257074h case    3:*/		regs.LR = 0x82257078; return 0x82256DF0;
		/* 82257074h case    3:*/		return 0x82257078;
		  /* 82257078h */ case    4:  		/* lis R9, -32252 */
		/* 82257078h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82257078h case    4:*/		return 0x8225707C;
		  /* 8225707Ch */ case    5:  		/* li R11, 2 */
		/* 8225707Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225707Ch case    5:*/		return 0x82257080;
		  /* 82257080h */ case    6:  		/* li R10, 1 */
		/* 82257080h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82257080h case    6:*/		return 0x82257084;
		  /* 82257084h */ case    7:  		/* addi R8, R9, 29624 */
		/* 82257084h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x73B8);
		/* 82257084h case    7:*/		return 0x82257088;
		  /* 82257088h */ case    8:  		/* stw R10, <#[R3 + 20]> */
		/* 82257088h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82257088h case    8:*/		return 0x8225708C;
		  /* 8225708Ch */ case    9:  		/* addi R9, R3, 76 */
		/* 8225708Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x4C);
		/* 8225708Ch case    9:*/		return 0x82257090;
		  /* 82257090h */ case   10:  		/* stw R8, <#[R3]> */
		/* 82257090h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 82257090h case   10:*/		return 0x82257094;
		  /* 82257094h */ case   11:  		/* stw R10, <#[R3 + 16]> */
		/* 82257094h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257094h case   11:*/		return 0x82257098;
		  /* 82257098h */ case   12:  		/* mtspr CTR, R11 */
		/* 82257098h case   12:*/		regs.CTR = regs.R11;
		/* 82257098h case   12:*/		return 0x8225709C;
		  /* 8225709Ch */ case   13:  		/* li R11, -1 */
		/* 8225709Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8225709Ch case   13:*/		return 0x822570A0;
		  /* 822570A0h */ case   14:  		/* li R10, 0 */
		/* 822570A0h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822570A0h case   14:*/		return 0x822570A4;
		  /* 822570A4h */ case   15:  		/* stw R11, <#[R9 - 20]> */
		/* 822570A4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0xFFFFFFEC) );
		/* 822570A4h case   15:*/		return 0x822570A8;
		  /* 822570A8h */ case   16:  		/* stwu R10, <#[R9 + 4]> */
		/* 822570A8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 822570A8h case   16:*/		return 0x822570AC;
		  /* 822570ACh */ case   17:  		/* bc 16, CR0_LT, -16 */
		/* 822570ACh case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8225709C;  }
		/* 822570ACh case   17:*/		return 0x822570B0;
		  /* 822570B0h */ case   18:  		/* addi R1, R1, 96 */
		/* 822570B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822570B0h case   18:*/		return 0x822570B4;
		  /* 822570B4h */ case   19:  		/* lwz R12, <#[R1 - 8]> */
		/* 822570B4h case   19:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822570B4h case   19:*/		return 0x822570B8;
		  /* 822570B8h */ case   20:  		/* mtspr LR, R12 */
		/* 822570B8h case   20:*/		regs.LR = regs.R12;
		/* 822570B8h case   20:*/		return 0x822570BC;
		  /* 822570BCh */ case   21:  		/* bclr 20, CR0_LT */
		/* 822570BCh case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822570BCh case   21:*/		return 0x822570C0;
	}
	return 0x822570C0;
} // Block from 82257068h-822570C0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822570C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822570C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822570C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822570C0);
		  /* 822570C0h */ case    0:  		/* mfspr R12, LR */
		/* 822570C0h case    0:*/		regs.R12 = regs.LR;
		/* 822570C0h case    0:*/		return 0x822570C4;
		  /* 822570C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822570C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822570C4h case    1:*/		return 0x822570C8;
		  /* 822570C8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822570C8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822570C8h case    2:*/		return 0x822570CC;
		  /* 822570CCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822570CCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822570CCh case    3:*/		return 0x822570D0;
		  /* 822570D0h */ case    4:  		/* mr R5, R4 */
		/* 822570D0h case    4:*/		regs.R5 = regs.R4;
		/* 822570D0h case    4:*/		return 0x822570D4;
		  /* 822570D4h */ case    5:  		/* li R4, 49 */
		/* 822570D4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x31);
		/* 822570D4h case    5:*/		return 0x822570D8;
		  /* 822570D8h */ case    6:  		/* mr R31, R3 */
		/* 822570D8h case    6:*/		regs.R31 = regs.R3;
		/* 822570D8h case    6:*/		return 0x822570DC;
		  /* 822570DCh */ case    7:  		/* bl -116 */
		/* 822570DCh case    7:*/		regs.LR = 0x822570E0; return 0x82257068;
		/* 822570DCh case    7:*/		return 0x822570E0;
		  /* 822570E0h */ case    8:  		/* lis R10, -32252 */
		/* 822570E0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822570E0h case    8:*/		return 0x822570E4;
		  /* 822570E4h */ case    9:  		/* li R11, 1 */
		/* 822570E4h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822570E4h case    9:*/		return 0x822570E8;
		  /* 822570E8h */ case   10:  		/* addi R10, R10, 29624 */
		/* 822570E8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x73B8);
		/* 822570E8h case   10:*/		return 0x822570EC;
		  /* 822570ECh */ case   11:  		/* stw R11, <#[R3 + 20]> */
		/* 822570ECh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 822570ECh case   11:*/		return 0x822570F0;
		  /* 822570F0h */ case   12:  		/* stw R10, <#[R3]> */
		/* 822570F0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822570F0h case   12:*/		return 0x822570F4;
		  /* 822570F4h */ case   13:  		/* stw R11, <#[R3 + 16]> */
		/* 822570F4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822570F4h case   13:*/		return 0x822570F8;
		  /* 822570F8h */ case   14:  		/* addi R1, R1, 96 */
		/* 822570F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822570F8h case   14:*/		return 0x822570FC;
		  /* 822570FCh */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 822570FCh case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822570FCh case   15:*/		return 0x82257100;
		  /* 82257100h */ case   16:  		/* mtspr LR, R12 */
		/* 82257100h case   16:*/		regs.LR = regs.R12;
		/* 82257100h case   16:*/		return 0x82257104;
		  /* 82257104h */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 82257104h case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257104h case   17:*/		return 0x82257108;
		  /* 82257108h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82257108h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257108h case   18:*/		return 0x8225710C;
	}
	return 0x8225710C;
} // Block from 822570C0h-8225710Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225710Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225710C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225710C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225710C);
		  /* 8225710Ch */ case    0:  		/* nop */
		/* 8225710Ch case    0:*/		cpu::op::nop();
		/* 8225710Ch case    0:*/		return 0x82257110;
	}
	return 0x82257110;
} // Block from 8225710Ch-82257110h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257110);
		  /* 82257110h */ case    0:  		/* mfspr R12, LR */
		/* 82257110h case    0:*/		regs.R12 = regs.LR;
		/* 82257110h case    0:*/		return 0x82257114;
		  /* 82257114h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257114h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257114h case    1:*/		return 0x82257118;
		  /* 82257118h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257118h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257118h case    2:*/		return 0x8225711C;
		  /* 8225711Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225711Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225711Ch case    3:*/		return 0x82257120;
		  /* 82257120h */ case    4:  		/* mr R31, R3 */
		/* 82257120h case    4:*/		regs.R31 = regs.R3;
		/* 82257120h case    4:*/		return 0x82257124;
		  /* 82257124h */ case    5:  		/* bl -820 */
		/* 82257124h case    5:*/		regs.LR = 0x82257128; return 0x82256DF0;
		/* 82257124h case    5:*/		return 0x82257128;
		  /* 82257128h */ case    6:  		/* lis R9, -32252 */
		/* 82257128h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82257128h case    6:*/		return 0x8225712C;
		  /* 8225712Ch */ case    7:  		/* li R11, 0 */
		/* 8225712Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225712Ch case    7:*/		return 0x82257130;
		  /* 82257130h */ case    8:  		/* li R10, 1 */
		/* 82257130h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82257130h case    8:*/		return 0x82257134;
		  /* 82257134h */ case    9:  		/* addi R9, R9, 29728 */
		/* 82257134h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x7420);
		/* 82257134h case    9:*/		return 0x82257138;
		  /* 82257138h */ case   10:  		/* stw R11, <#[R3 + 172]> */
		/* 82257138h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000AC) );
		/* 82257138h case   10:*/		return 0x8225713C;
		  /* 8225713Ch */ case   11:  		/* stw R10, <#[R3 + 20]> */
		/* 8225713Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 8225713Ch case   11:*/		return 0x82257140;
		  /* 82257140h */ case   12:  		/* stw R9, <#[R3]> */
		/* 82257140h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82257140h case   12:*/		return 0x82257144;
		  /* 82257144h */ case   13:  		/* stw R11, <#[R3 + 176]> */
		/* 82257144h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000B0) );
		/* 82257144h case   13:*/		return 0x82257148;
		  /* 82257148h */ case   14:  		/* stw R11, <#[R3 + 180]> */
		/* 82257148h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000B4) );
		/* 82257148h case   14:*/		return 0x8225714C;
		  /* 8225714Ch */ case   15:  		/* stw R10, <#[R3 + 16]> */
		/* 8225714Ch case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8225714Ch case   15:*/		return 0x82257150;
		  /* 82257150h */ case   16:  		/* addi R1, R1, 96 */
		/* 82257150h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257150h case   16:*/		return 0x82257154;
		  /* 82257154h */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257154h case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257154h case   17:*/		return 0x82257158;
		  /* 82257158h */ case   18:  		/* mtspr LR, R12 */
		/* 82257158h case   18:*/		regs.LR = regs.R12;
		/* 82257158h case   18:*/		return 0x8225715C;
		  /* 8225715Ch */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 8225715Ch case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225715Ch case   19:*/		return 0x82257160;
		  /* 82257160h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82257160h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257160h case   20:*/		return 0x82257164;
	}
	return 0x82257164;
} // Block from 82257110h-82257164h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82257164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257164);
		  /* 82257164h */ case    0:  		/* nop */
		/* 82257164h case    0:*/		cpu::op::nop();
		/* 82257164h case    0:*/		return 0x82257168;
	}
	return 0x82257168;
} // Block from 82257164h-82257168h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257168);
		  /* 82257168h */ case    0:  		/* lis R11, -32252 */
		/* 82257168h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257168h case    0:*/		return 0x8225716C;
		  /* 8225716Ch */ case    1:  		/* addi R3, R11, 29832 */
		/* 8225716Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7488);
		/* 8225716Ch case    1:*/		return 0x82257170;
		  /* 82257170h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257170h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257170h case    2:*/		return 0x82257174;
	}
	return 0x82257174;
} // Block from 82257168h-82257174h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257174);
		  /* 82257174h */ case    0:  		/* nop */
		/* 82257174h case    0:*/		cpu::op::nop();
		/* 82257174h case    0:*/		return 0x82257178;
	}
	return 0x82257178;
} // Block from 82257174h-82257178h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257178h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257178);
		  /* 82257178h */ case    0:  		/* mfspr R12, LR */
		/* 82257178h case    0:*/		regs.R12 = regs.LR;
		/* 82257178h case    0:*/		return 0x8225717C;
		  /* 8225717Ch */ case    1:  		/* bl -1859360 */
		/* 8225717Ch case    1:*/		regs.LR = 0x82257180; return 0x8209125C;
		/* 8225717Ch case    1:*/		return 0x82257180;
		  /* 82257180h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257180h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257180h case    2:*/		return 0x82257184;
		  /* 82257184h */ case    3:  		/* mr R29, R4 */
		/* 82257184h case    3:*/		regs.R29 = regs.R4;
		/* 82257184h case    3:*/		return 0x82257188;
		  /* 82257188h */ case    4:  		/* mr R5, R4 */
		/* 82257188h case    4:*/		regs.R5 = regs.R4;
		/* 82257188h case    4:*/		return 0x8225718C;
		  /* 8225718Ch */ case    5:  		/* li R4, 48 */
		/* 8225718Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 8225718Ch case    5:*/		return 0x82257190;
		  /* 82257190h */ case    6:  		/* mr R30, R3 */
		/* 82257190h case    6:*/		regs.R30 = regs.R3;
		/* 82257190h case    6:*/		return 0x82257194;
		  /* 82257194h */ case    7:  		/* bl -932 */
		/* 82257194h case    7:*/		regs.LR = 0x82257198; return 0x82256DF0;
		/* 82257194h case    7:*/		return 0x82257198;
		  /* 82257198h */ case    8:  		/* lis R11, -32252 */
		/* 82257198h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257198h case    8:*/		return 0x8225719C;
		  /* 8225719Ch */ case    9:  		/* li R31, 1 */
		/* 8225719Ch case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 8225719Ch case    9:*/		return 0x822571A0;
		  /* 822571A0h */ case   10:  		/* addi R11, R11, 29840 */
		/* 822571A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7490);
		/* 822571A0h case   10:*/		return 0x822571A4;
		  /* 822571A4h */ case   11:  		/* stw R31, <#[R3 + 16]> */
		/* 822571A4h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000010) );
		/* 822571A4h case   11:*/		return 0x822571A8;
		  /* 822571A8h */ case   12:  		/* mr R4, R3 */
		/* 822571A8h case   12:*/		regs.R4 = regs.R3;
		/* 822571A8h case   12:*/		return 0x822571AC;
		  /* 822571ACh */ case   13:  		/* stw R11, <#[R3]> */
		/* 822571ACh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822571ACh case   13:*/		return 0x822571B0;
		  /* 822571B0h */ case   14:  		/* lwz R11, <#[R3 + 228]> */
		/* 822571B0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 822571B0h case   14:*/		return 0x822571B4;
		  /* 822571B4h */ case   15:  		/* ori R11, R11, 18 */
		/* 822571B4h case   15:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x12);
		/* 822571B4h case   15:*/		return 0x822571B8;
		  /* 822571B8h */ case   16:  		/* stw R11, <#[R3 + 228]> */
		/* 822571B8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 822571B8h case   16:*/		return 0x822571BC;
		  /* 822571BCh */ case   17:  		/* lwz R3, <#[R29 + 2736]> */
		/* 822571BCh case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000AB0) );
		/* 822571BCh case   17:*/		return 0x822571C0;
		  /* 822571C0h */ case   18:  		/* bl -135624 */
		/* 822571C0h case   18:*/		regs.LR = 0x822571C4; return 0x82235FF8;
		/* 822571C0h case   18:*/		return 0x822571C4;
		  /* 822571C4h */ case   19:  		/* li R11, 48 */
		/* 822571C4h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x30);
		/* 822571C4h case   19:*/		return 0x822571C8;
		  /* 822571C8h */ case   20:  		/* li R10, 0 */
		/* 822571C8h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822571C8h case   20:*/		return 0x822571CC;
		  /* 822571CCh */ case   21:  		/* stw R11, <#[R30 + 24]> */
		/* 822571CCh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 822571CCh case   21:*/		return 0x822571D0;
		  /* 822571D0h */ case   22:  		/* stw R31, <#[R30 + 20]> */
		/* 822571D0h case   22:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000014) );
		/* 822571D0h case   22:*/		return 0x822571D4;
		  /* 822571D4h */ case   23:  		/* mr R3, R30 */
		/* 822571D4h case   23:*/		regs.R3 = regs.R30;
		/* 822571D4h case   23:*/		return 0x822571D8;
		  /* 822571D8h */ case   24:  		/* stw R10, <#[R30 + 16]> */
		/* 822571D8h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 822571D8h case   24:*/		return 0x822571DC;
		  /* 822571DCh */ case   25:  		/* addi R1, R1, 112 */
		/* 822571DCh case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822571DCh case   25:*/		return 0x822571E0;
		  /* 822571E0h */ case   26:  		/* b -1859380 */
		/* 822571E0h case   26:*/		return 0x820912AC;
		/* 822571E0h case   26:*/		return 0x822571E4;
		  /* 822571E4h */ case   27:  		/* nop */
		/* 822571E4h case   27:*/		cpu::op::nop();
		/* 822571E4h case   27:*/		return 0x822571E8;
	}
	return 0x822571E8;
} // Block from 82257178h-822571E8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822571E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822571E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822571E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822571E8);
		  /* 822571E8h */ case    0:  		/* lis R11, -32255 */
		/* 822571E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 822571E8h case    0:*/		return 0x822571EC;
		  /* 822571ECh */ case    1:  		/* addi R3, R11, 26220 */
		/* 822571ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x666C);
		/* 822571ECh case    1:*/		return 0x822571F0;
		  /* 822571F0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822571F0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822571F0h case    2:*/		return 0x822571F4;
	}
	return 0x822571F4;
} // Block from 822571E8h-822571F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822571F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822571F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822571F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822571F4);
		  /* 822571F4h */ case    0:  		/* nop */
		/* 822571F4h case    0:*/		cpu::op::nop();
		/* 822571F4h case    0:*/		return 0x822571F8;
	}
	return 0x822571F8;
} // Block from 822571F4h-822571F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822571F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822571F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822571F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822571F8);
		  /* 822571F8h */ case    0:  		/* mfspr R12, LR */
		/* 822571F8h case    0:*/		regs.R12 = regs.LR;
		/* 822571F8h case    0:*/		return 0x822571FC;
		  /* 822571FCh */ case    1:  		/* bl -1859488 */
		/* 822571FCh case    1:*/		regs.LR = 0x82257200; return 0x8209125C;
		/* 822571FCh case    1:*/		return 0x82257200;
		  /* 82257200h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257200h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257200h case    2:*/		return 0x82257204;
		  /* 82257204h */ case    3:  		/* mr R30, R4 */
		/* 82257204h case    3:*/		regs.R30 = regs.R4;
		/* 82257204h case    3:*/		return 0x82257208;
		  /* 82257208h */ case    4:  		/* mr R4, R6 */
		/* 82257208h case    4:*/		regs.R4 = regs.R6;
		/* 82257208h case    4:*/		return 0x8225720C;
		  /* 8225720Ch */ case    5:  		/* mr R31, R3 */
		/* 8225720Ch case    5:*/		regs.R31 = regs.R3;
		/* 8225720Ch case    5:*/		return 0x82257210;
		  /* 82257210h */ case    6:  		/* mr R29, R5 */
		/* 82257210h case    6:*/		regs.R29 = regs.R5;
		/* 82257210h case    6:*/		return 0x82257214;
		  /* 82257214h */ case    7:  		/* bl -156 */
		/* 82257214h case    7:*/		regs.LR = 0x82257218; return 0x82257178;
		/* 82257214h case    7:*/		return 0x82257218;
		  /* 82257218h */ case    8:  		/* lis R11, -32252 */
		/* 82257218h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257218h case    8:*/		return 0x8225721C;
		  /* 8225721Ch */ case    9:  		/* mr R3, R31 */
		/* 8225721Ch case    9:*/		regs.R3 = regs.R31;
		/* 8225721Ch case    9:*/		return 0x82257220;
		  /* 82257220h */ case   10:  		/* addi R11, R11, 29944 */
		/* 82257220h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x74F8);
		/* 82257220h case   10:*/		return 0x82257224;
		  /* 82257224h */ case   11:  		/* mr R5, R30 */
		/* 82257224h case   11:*/		regs.R5 = regs.R30;
		/* 82257224h case   11:*/		return 0x82257228;
		  /* 82257228h */ case   12:  		/* stw R11, <#[R31]> */
		/* 82257228h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82257228h case   12:*/		return 0x8225722C;
		  /* 8225722Ch */ case   13:  		/* li R4, 0 */
		/* 8225722Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225722Ch case   13:*/		return 0x82257230;
		  /* 82257230h */ case   14:  		/* bl -3736 */
		/* 82257230h case   14:*/		regs.LR = 0x82257234; return 0x82256398;
		/* 82257230h case   14:*/		return 0x82257234;
		  /* 82257234h */ case   15:  		/* li R11, 0 */
		/* 82257234h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82257234h case   15:*/		return 0x82257238;
		  /* 82257238h */ case   16:  		/* stw R29, <#[R31 + 128]> */
		/* 82257238h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000080) );
		/* 82257238h case   16:*/		return 0x8225723C;
		  /* 8225723Ch */ case   17:  		/* mr R3, R31 */
		/* 8225723Ch case   17:*/		regs.R3 = regs.R31;
		/* 8225723Ch case   17:*/		return 0x82257240;
		  /* 82257240h */ case   18:  		/* stw R11, <#[R31 + 20]> */
		/* 82257240h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82257240h case   18:*/		return 0x82257244;
		  /* 82257244h */ case   19:  		/* addi R1, R1, 112 */
		/* 82257244h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257244h case   19:*/		return 0x82257248;
		  /* 82257248h */ case   20:  		/* b -1859484 */
		/* 82257248h case   20:*/		return 0x820912AC;
		/* 82257248h case   20:*/		return 0x8225724C;
		  /* 8225724Ch */ case   21:  		/* nop */
		/* 8225724Ch case   21:*/		cpu::op::nop();
		/* 8225724Ch case   21:*/		return 0x82257250;
	}
	return 0x82257250;
} // Block from 822571F8h-82257250h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82257250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257250);
		  /* 82257250h */ case    0:  		/* lis R11, -32252 */
		/* 82257250h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257250h case    0:*/		return 0x82257254;
		  /* 82257254h */ case    1:  		/* addi R3, R11, 30048 */
		/* 82257254h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7560);
		/* 82257254h case    1:*/		return 0x82257258;
	}
	return 0x82257258;
} // Block from 82257250h-82257258h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257258h
// Function '?Kill@IRLoadConst@XGRAPHICS@@UAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257258);
		  /* 82257258h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82257258h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257258h case    0:*/		return 0x8225725C;
	}
	return 0x8225725C;
} // Block from 82257258h-8225725Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225725Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225725C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225725C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225725C);
		  /* 8225725Ch */ case    0:  		/* nop */
		/* 8225725Ch case    0:*/		cpu::op::nop();
		/* 8225725Ch case    0:*/		return 0x82257260;
	}
	return 0x82257260;
} // Block from 8225725Ch-82257260h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257260);
		  /* 82257260h */ case    0:  		/* lis R11, -32252 */
		/* 82257260h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257260h case    0:*/		return 0x82257264;
		  /* 82257264h */ case    1:  		/* addi R3, R11, 30060 */
		/* 82257264h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x756C);
		/* 82257264h case    1:*/		return 0x82257268;
		  /* 82257268h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257268h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257268h case    2:*/		return 0x8225726C;
	}
	return 0x8225726C;
} // Block from 82257260h-8225726Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225726Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225726C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225726C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225726C);
		  /* 8225726Ch */ case    0:  		/* nop */
		/* 8225726Ch case    0:*/		cpu::op::nop();
		/* 8225726Ch case    0:*/		return 0x82257270;
	}
	return 0x82257270;
} // Block from 8225726Ch-82257270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257270);
		  /* 82257270h */ case    0:  		/* mfspr R12, LR */
		/* 82257270h case    0:*/		regs.R12 = regs.LR;
		/* 82257270h case    0:*/		return 0x82257274;
		  /* 82257274h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257274h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257274h case    1:*/		return 0x82257278;
		  /* 82257278h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257278h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257278h case    2:*/		return 0x8225727C;
		  /* 8225727Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225727Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225727Ch case    3:*/		return 0x82257280;
		  /* 82257280h */ case    4:  		/* mr R5, R4 */
		/* 82257280h case    4:*/		regs.R5 = regs.R4;
		/* 82257280h case    4:*/		return 0x82257284;
		  /* 82257284h */ case    5:  		/* li R4, 130 */
		/* 82257284h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x82);
		/* 82257284h case    5:*/		return 0x82257288;
		  /* 82257288h */ case    6:  		/* mr R31, R3 */
		/* 82257288h case    6:*/		regs.R31 = regs.R3;
		/* 82257288h case    6:*/		return 0x8225728C;
		  /* 8225728Ch */ case    7:  		/* bl -1180 */
		/* 8225728Ch case    7:*/		regs.LR = 0x82257290; return 0x82256DF0;
		/* 8225728Ch case    7:*/		return 0x82257290;
		  /* 82257290h */ case    8:  		/* lis R11, -32252 */
		/* 82257290h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257290h case    8:*/		return 0x82257294;
		  /* 82257294h */ case    9:  		/* li R10, 0 */
		/* 82257294h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257294h case    9:*/		return 0x82257298;
		  /* 82257298h */ case   10:  		/* addi R11, R11, 30072 */
		/* 82257298h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7578);
		/* 82257298h case   10:*/		return 0x8225729C;
		  /* 8225729Ch */ case   11:  		/* stw R10, <#[R3 + 16]> */
		/* 8225729Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8225729Ch case   11:*/		return 0x822572A0;
		  /* 822572A0h */ case   12:  		/* stw R11, <#[R3]> */
		/* 822572A0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822572A0h case   12:*/		return 0x822572A4;
		  /* 822572A4h */ case   13:  		/* addi R1, R1, 96 */
		/* 822572A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822572A4h case   13:*/		return 0x822572A8;
		  /* 822572A8h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 822572A8h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822572A8h case   14:*/		return 0x822572AC;
		  /* 822572ACh */ case   15:  		/* mtspr LR, R12 */
		/* 822572ACh case   15:*/		regs.LR = regs.R12;
		/* 822572ACh case   15:*/		return 0x822572B0;
		  /* 822572B0h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 822572B0h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822572B0h case   16:*/		return 0x822572B4;
		  /* 822572B4h */ case   17:  		/* bclr 20, CR0_LT */
		/* 822572B4h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822572B4h case   17:*/		return 0x822572B8;
	}
	return 0x822572B8;
} // Block from 82257270h-822572B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822572B8h
// Function '?RemoveFromBlock@IRInst@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822572B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822572B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822572B8);
		  /* 822572B8h */ case    0:  		/* lis R11, -32253 */
		/* 822572B8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822572B8h case    0:*/		return 0x822572BC;
		  /* 822572BCh */ case    1:  		/* addi R3, R11, 26040 */
		/* 822572BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x65B8);
		/* 822572BCh case    1:*/		return 0x822572C0;
		  /* 822572C0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822572C0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822572C0h case    2:*/		return 0x822572C4;
	}
	return 0x822572C4;
} // Block from 822572B8h-822572C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822572C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822572C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822572C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822572C4);
		  /* 822572C4h */ case    0:  		/* nop */
		/* 822572C4h case    0:*/		cpu::op::nop();
		/* 822572C4h case    0:*/		return 0x822572C8;
	}
	return 0x822572C8;
} // Block from 822572C4h-822572C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822572C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822572C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822572C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822572C8);
		  /* 822572C8h */ case    0:  		/* mfspr R12, LR */
		/* 822572C8h case    0:*/		regs.R12 = regs.LR;
		/* 822572C8h case    0:*/		return 0x822572CC;
		  /* 822572CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822572CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822572CCh case    1:*/		return 0x822572D0;
		  /* 822572D0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822572D0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822572D0h case    2:*/		return 0x822572D4;
		  /* 822572D4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822572D4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822572D4h case    3:*/		return 0x822572D8;
		  /* 822572D8h */ case    4:  		/* mr R5, R4 */
		/* 822572D8h case    4:*/		regs.R5 = regs.R4;
		/* 822572D8h case    4:*/		return 0x822572DC;
		  /* 822572DCh */ case    5:  		/* li R4, 131 */
		/* 822572DCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x83);
		/* 822572DCh case    5:*/		return 0x822572E0;
		  /* 822572E0h */ case    6:  		/* mr R31, R3 */
		/* 822572E0h case    6:*/		regs.R31 = regs.R3;
		/* 822572E0h case    6:*/		return 0x822572E4;
		  /* 822572E4h */ case    7:  		/* bl -1268 */
		/* 822572E4h case    7:*/		regs.LR = 0x822572E8; return 0x82256DF0;
		/* 822572E4h case    7:*/		return 0x822572E8;
		  /* 822572E8h */ case    8:  		/* lis R11, -32252 */
		/* 822572E8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822572E8h case    8:*/		return 0x822572EC;
		  /* 822572ECh */ case    9:  		/* li R10, 0 */
		/* 822572ECh case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822572ECh case    9:*/		return 0x822572F0;
	}
	return 0x822572F0;
} // Block from 822572C8h-822572F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822572F0h
// Function '?IsUselessPhi@IRInst@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822572F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822572F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822572F0);
		  /* 822572F0h */ case    0:  		/* addi R11, R11, 30176 */
		/* 822572F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x75E0);
		/* 822572F0h case    0:*/		return 0x822572F4;
		  /* 822572F4h */ case    1:  		/* stw R10, <#[R3 + 16]> */
		/* 822572F4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 822572F4h case    1:*/		return 0x822572F8;
		  /* 822572F8h */ case    2:  		/* stw R11, <#[R3]> */
		/* 822572F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822572F8h case    2:*/		return 0x822572FC;
		  /* 822572FCh */ case    3:  		/* addi R1, R1, 96 */
		/* 822572FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822572FCh case    3:*/		return 0x82257300;
		  /* 82257300h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257300h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257300h case    4:*/		return 0x82257304;
		  /* 82257304h */ case    5:  		/* mtspr LR, R12 */
		/* 82257304h case    5:*/		regs.LR = regs.R12;
		/* 82257304h case    5:*/		return 0x82257308;
		  /* 82257308h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82257308h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257308h case    6:*/		return 0x8225730C;
		  /* 8225730Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 8225730Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225730Ch case    7:*/		return 0x82257310;
	}
	return 0x82257310;
} // Block from 822572F0h-82257310h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82257310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257310);
		  /* 82257310h */ case    0:  		/* lis R11, -32252 */
		/* 82257310h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257310h case    0:*/		return 0x82257314;
		  /* 82257314h */ case    1:  		/* addi R3, R11, 30280 */
		/* 82257314h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7648);
		/* 82257314h case    1:*/		return 0x82257318;
		  /* 82257318h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257318h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257318h case    2:*/		return 0x8225731C;
	}
	return 0x8225731C;
} // Block from 82257310h-8225731Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225731Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225731C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225731C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225731C);
		  /* 8225731Ch */ case    0:  		/* nop */
		/* 8225731Ch case    0:*/		cpu::op::nop();
		/* 8225731Ch case    0:*/		return 0x82257320;
	}
	return 0x82257320;
} // Block from 8225731Ch-82257320h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257320h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257320);
		  /* 82257320h */ case    0:  		/* mfspr R12, LR */
		/* 82257320h case    0:*/		regs.R12 = regs.LR;
		/* 82257320h case    0:*/		return 0x82257324;
		  /* 82257324h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257324h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257324h case    1:*/		return 0x82257328;
		  /* 82257328h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257328h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257328h case    2:*/		return 0x8225732C;
		  /* 8225732Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225732Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225732Ch case    3:*/		return 0x82257330;
	}
	return 0x82257330;
} // Block from 82257320h-82257330h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257330h
// Function '?HasSingleUse@IRInst@XGRAPHICS@@QBA?B_NPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257330);
		  /* 82257330h */ case    0:  		/* mr R5, R4 */
		/* 82257330h case    0:*/		regs.R5 = regs.R4;
		/* 82257330h case    0:*/		return 0x82257334;
		  /* 82257334h */ case    1:  		/* li R4, 117 */
		/* 82257334h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 82257334h case    1:*/		return 0x82257338;
		  /* 82257338h */ case    2:  		/* mr R31, R3 */
		/* 82257338h case    2:*/		regs.R31 = regs.R3;
		/* 82257338h case    2:*/		return 0x8225733C;
		  /* 8225733Ch */ case    3:  		/* bl -1356 */
		/* 8225733Ch case    3:*/		regs.LR = 0x82257340; return 0x82256DF0;
		/* 8225733Ch case    3:*/		return 0x82257340;
		  /* 82257340h */ case    4:  		/* lis R10, -32252 */
		/* 82257340h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82257340h case    4:*/		return 0x82257344;
		  /* 82257344h */ case    5:  		/* li R11, 1 */
		/* 82257344h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82257344h case    5:*/		return 0x82257348;
		  /* 82257348h */ case    6:  		/* addi R10, R10, 30288 */
		/* 82257348h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7650);
		/* 82257348h case    6:*/		return 0x8225734C;
		  /* 8225734Ch */ case    7:  		/* li R9, 0 */
		/* 8225734Ch case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225734Ch case    7:*/		return 0x82257350;
		  /* 82257350h */ case    8:  		/* stw R11, <#[R3 + 80]> */
		/* 82257350h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82257350h case    8:*/		return 0x82257354;
		  /* 82257354h */ case    9:  		/* stw R10, <#[R3]> */
		/* 82257354h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82257354h case    9:*/		return 0x82257358;
	}
	return 0x82257358;
} // Block from 82257330h-82257358h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82257358h
// Function '?HasModifiers@IRInst@XGRAPHICS@@QBA?B_NH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257358);
		  /* 82257358h */ case    0:  		/* stw R11, <#[R3 + 16]> */
		/* 82257358h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82257358h case    0:*/		return 0x8225735C;
		  /* 8225735Ch */ case    1:  		/* stw R9, <#[R3 + 20]> */
		/* 8225735Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 8225735Ch case    1:*/		return 0x82257360;
		  /* 82257360h */ case    2:  		/* addi R1, R1, 96 */
		/* 82257360h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257360h case    2:*/		return 0x82257364;
		  /* 82257364h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257364h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257364h case    3:*/		return 0x82257368;
		  /* 82257368h */ case    4:  		/* mtspr LR, R12 */
		/* 82257368h case    4:*/		regs.LR = regs.R12;
		/* 82257368h case    4:*/		return 0x8225736C;
		  /* 8225736Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8225736Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225736Ch case    5:*/		return 0x82257370;
		  /* 82257370h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82257370h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257370h case    6:*/		return 0x82257374;
	}
	return 0x82257374;
} // Block from 82257358h-82257374h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82257374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257374);
		  /* 82257374h */ case    0:  		/* nop */
		/* 82257374h case    0:*/		cpu::op::nop();
		/* 82257374h case    0:*/		return 0x82257378;
	}
	return 0x82257378;
} // Block from 82257374h-82257378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257378);
		  /* 82257378h */ case    0:  		/* lis R11, -32252 */
		/* 82257378h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257378h case    0:*/		return 0x8225737C;
		  /* 8225737Ch */ case    1:  		/* addi R3, R11, 30392 */
		/* 8225737Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x76B8);
		/* 8225737Ch case    1:*/		return 0x82257380;
		  /* 82257380h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257380h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257380h case    2:*/		return 0x82257384;
	}
	return 0x82257384;
} // Block from 82257378h-82257384h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257384);
		  /* 82257384h */ case    0:  		/* nop */
		/* 82257384h case    0:*/		cpu::op::nop();
		/* 82257384h case    0:*/		return 0x82257388;
	}
	return 0x82257388;
} // Block from 82257384h-82257388h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257388h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257388);
		  /* 82257388h */ case    0:  		/* mfspr R12, LR */
		/* 82257388h case    0:*/		regs.R12 = regs.LR;
		/* 82257388h case    0:*/		return 0x8225738C;
		  /* 8225738Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225738Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225738Ch case    1:*/		return 0x82257390;
		  /* 82257390h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257390h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257390h case    2:*/		return 0x82257394;
		  /* 82257394h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82257394h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257394h case    3:*/		return 0x82257398;
	}
	return 0x82257398;
} // Block from 82257388h-82257398h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257398h
// Function '?ExportType@IRInst@XGRAPHICS@@SA?AW4RegType@R400Tables@@W434@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257398);
		  /* 82257398h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257398h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257398h case    0:*/		return 0x8225739C;
		  /* 8225739Ch */ case    1:  		/* mr R30, R4 */
		/* 8225739Ch case    1:*/		regs.R30 = regs.R4;
		/* 8225739Ch case    1:*/		return 0x822573A0;
		  /* 822573A0h */ case    2:  		/* li R4, 117 */
		/* 822573A0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 822573A0h case    2:*/		return 0x822573A4;
		  /* 822573A4h */ case    3:  		/* mr R31, R3 */
		/* 822573A4h case    3:*/		regs.R31 = regs.R3;
		/* 822573A4h case    3:*/		return 0x822573A8;
		  /* 822573A8h */ case    4:  		/* bl -1464 */
		/* 822573A8h case    4:*/		regs.LR = 0x822573AC; return 0x82256DF0;
		/* 822573A8h case    4:*/		return 0x822573AC;
		  /* 822573ACh */ case    5:  		/* lis R11, -32252 */
		/* 822573ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822573ACh case    5:*/		return 0x822573B0;
		  /* 822573B0h */ case    6:  		/* li R10, 0 */
		/* 822573B0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822573B0h case    6:*/		return 0x822573B4;
		  /* 822573B4h */ case    7:  		/* addi R9, R11, 30288 */
		/* 822573B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x7650);
		/* 822573B4h case    7:*/		return 0x822573B8;
		  /* 822573B8h */ case    8:  		/* stw R10, <#[R3 + 16]> */
		/* 822573B8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 822573B8h case    8:*/		return 0x822573BC;
		  /* 822573BCh */ case    9:  		/* li R11, 1 */
		/* 822573BCh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822573BCh case    9:*/		return 0x822573C0;
		  /* 822573C0h */ case   10:  		/* stw R9, <#[R3]> */
		/* 822573C0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 822573C0h case   10:*/		return 0x822573C4;
		  /* 822573C4h */ case   11:  		/* lwz R9, <#[R30 + 32]> */
		/* 822573C4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000020) );
		/* 822573C4h case   11:*/		return 0x822573C8;
		  /* 822573C8h */ case   12:  		/* stw R9, <#[R3 + 80]> */
		/* 822573C8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000050) );
		/* 822573C8h case   12:*/		return 0x822573CC;
		  /* 822573CCh */ case   13:  		/* lwz R9, <#[R30 + 12]> */
		/* 822573CCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 822573CCh case   13:*/		return 0x822573D0;
		  /* 822573D0h */ case   14:  		/* stw R9, <#[R3 + 56]> */
		/* 822573D0h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000038) );
		/* 822573D0h case   14:*/		return 0x822573D4;
		  /* 822573D4h */ case   15:  		/* stw R30, <#[R3 + 28]> */
		/* 822573D4h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000001C) );
		/* 822573D4h case   15:*/		return 0x822573D8;
		  /* 822573D8h */ case   16:  		/* stb R11, <#[R30 + 28]> */
		/* 822573D8h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 822573D8h case   16:*/		return 0x822573DC;
		  /* 822573DCh */ case   17:  		/* stw R11, <#[R3 + 16]> */
		/* 822573DCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822573DCh case   17:*/		return 0x822573E0;
		  /* 822573E0h */ case   18:  		/* stw R10, <#[R3 + 20]> */
		/* 822573E0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 822573E0h case   18:*/		return 0x822573E4;
		  /* 822573E4h */ case   19:  		/* addi R1, R1, 112 */
		/* 822573E4h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822573E4h case   19:*/		return 0x822573E8;
		  /* 822573E8h */ case   20:  		/* lwz R12, <#[R1 - 8]> */
		/* 822573E8h case   20:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822573E8h case   20:*/		return 0x822573EC;
		  /* 822573ECh */ case   21:  		/* mtspr LR, R12 */
		/* 822573ECh case   21:*/		regs.LR = regs.R12;
		/* 822573ECh case   21:*/		return 0x822573F0;
		  /* 822573F0h */ case   22:  		/* ld R30, <#[R1 - 24]> */
		/* 822573F0h case   22:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822573F0h case   22:*/		return 0x822573F4;
		  /* 822573F4h */ case   23:  		/* ld R31, <#[R1 - 16]> */
		/* 822573F4h case   23:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822573F4h case   23:*/		return 0x822573F8;
		  /* 822573F8h */ case   24:  		/* bclr 20, CR0_LT */
		/* 822573F8h case   24:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822573F8h case   24:*/		return 0x822573FC;
	}
	return 0x822573FC;
} // Block from 82257398h-822573FCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 822573FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822573FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822573FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822573FC);
		  /* 822573FCh */ case    0:  		/* nop */
		/* 822573FCh case    0:*/		cpu::op::nop();
		/* 822573FCh case    0:*/		return 0x82257400;
	}
	return 0x82257400;
} // Block from 822573FCh-82257400h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257400h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257400);
		  /* 82257400h */ case    0:  		/* mfspr R12, LR */
		/* 82257400h case    0:*/		regs.R12 = regs.LR;
		/* 82257400h case    0:*/		return 0x82257404;
		  /* 82257404h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257404h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257404h case    1:*/		return 0x82257408;
		  /* 82257408h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257408h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257408h case    2:*/		return 0x8225740C;
		  /* 8225740Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225740Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225740Ch case    3:*/		return 0x82257410;
		  /* 82257410h */ case    4:  		/* mr R5, R4 */
		/* 82257410h case    4:*/		regs.R5 = regs.R4;
		/* 82257410h case    4:*/		return 0x82257414;
		  /* 82257414h */ case    5:  		/* li R4, 118 */
		/* 82257414h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x76);
		/* 82257414h case    5:*/		return 0x82257418;
		  /* 82257418h */ case    6:  		/* mr R31, R3 */
		/* 82257418h case    6:*/		regs.R31 = regs.R3;
		/* 82257418h case    6:*/		return 0x8225741C;
		  /* 8225741Ch */ case    7:  		/* bl -1580 */
		/* 8225741Ch case    7:*/		regs.LR = 0x82257420; return 0x82256DF0;
		/* 8225741Ch case    7:*/		return 0x82257420;
		  /* 82257420h */ case    8:  		/* lis R10, -32252 */
		/* 82257420h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82257420h case    8:*/		return 0x82257424;
		  /* 82257424h */ case    9:  		/* li R11, 0 */
		/* 82257424h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82257424h case    9:*/		return 0x82257428;
		  /* 82257428h */ case   10:  		/* addi R10, R10, 30408 */
		/* 82257428h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x76C8);
		/* 82257428h case   10:*/		return 0x8225742C;
		  /* 8225742Ch */ case   11:  		/* li R9, 1 */
		/* 8225742Ch case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225742Ch case   11:*/		return 0x82257430;
		  /* 82257430h */ case   12:  		/* stw R11, <#[R3 + 80]> */
		/* 82257430h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82257430h case   12:*/		return 0x82257434;
		  /* 82257434h */ case   13:  		/* stw R10, <#[R3]> */
		/* 82257434h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82257434h case   13:*/		return 0x82257438;
		  /* 82257438h */ case   14:  		/* stw R9, <#[R3 + 16]> */
		/* 82257438h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82257438h case   14:*/		return 0x8225743C;
		  /* 8225743Ch */ case   15:  		/* stw R11, <#[R3 + 20]> */
		/* 8225743Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8225743Ch case   15:*/		return 0x82257440;
		  /* 82257440h */ case   16:  		/* addi R1, R1, 96 */
		/* 82257440h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257440h case   16:*/		return 0x82257444;
		  /* 82257444h */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257444h case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257444h case   17:*/		return 0x82257448;
		  /* 82257448h */ case   18:  		/* mtspr LR, R12 */
		/* 82257448h case   18:*/		regs.LR = regs.R12;
		/* 82257448h case   18:*/		return 0x8225744C;
		  /* 8225744Ch */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 8225744Ch case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225744Ch case   19:*/		return 0x82257450;
	}
	return 0x82257450;
} // Block from 82257400h-82257450h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82257450h
// Function '?InputEdgeIsZeroLength@IRInst@XGRAPHICS@@QBA_NHPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257450);
		  /* 82257450h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82257450h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257450h case    0:*/		return 0x82257454;
	}
	return 0x82257454;
} // Block from 82257450h-82257454h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257454);
		  /* 82257454h */ case    0:  		/* nop */
		/* 82257454h case    0:*/		cpu::op::nop();
		/* 82257454h case    0:*/		return 0x82257458;
	}
	return 0x82257458;
} // Block from 82257454h-82257458h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257458);
		  /* 82257458h */ case    0:  		/* lis R11, -32252 */
		/* 82257458h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257458h case    0:*/		return 0x8225745C;
		  /* 8225745Ch */ case    1:  		/* addi R3, R11, 30512 */
		/* 8225745Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7730);
		/* 8225745Ch case    1:*/		return 0x82257460;
		  /* 82257460h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257460h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257460h case    2:*/		return 0x82257464;
	}
	return 0x82257464;
} // Block from 82257458h-82257464h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257464);
		  /* 82257464h */ case    0:  		/* nop */
		/* 82257464h case    0:*/		cpu::op::nop();
		/* 82257464h case    0:*/		return 0x82257468;
	}
	return 0x82257468;
} // Block from 82257464h-82257468h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257468h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257468);
		  /* 82257468h */ case    0:  		/* mfspr R12, LR */
		/* 82257468h case    0:*/		regs.R12 = regs.LR;
		/* 82257468h case    0:*/		return 0x8225746C;
		  /* 8225746Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225746Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225746Ch case    1:*/		return 0x82257470;
		  /* 82257470h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257470h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257470h case    2:*/		return 0x82257474;
		  /* 82257474h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82257474h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257474h case    3:*/		return 0x82257478;
		  /* 82257478h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257478h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257478h case    4:*/		return 0x8225747C;
		  /* 8225747Ch */ case    5:  		/* mr R30, R4 */
		/* 8225747Ch case    5:*/		regs.R30 = regs.R4;
		/* 8225747Ch case    5:*/		return 0x82257480;
		  /* 82257480h */ case    6:  		/* li R4, 118 */
		/* 82257480h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x76);
		/* 82257480h case    6:*/		return 0x82257484;
		  /* 82257484h */ case    7:  		/* mr R31, R3 */
		/* 82257484h case    7:*/		regs.R31 = regs.R3;
		/* 82257484h case    7:*/		return 0x82257488;
		  /* 82257488h */ case    8:  		/* bl -1688 */
		/* 82257488h case    8:*/		regs.LR = 0x8225748C; return 0x82256DF0;
		/* 82257488h case    8:*/		return 0x8225748C;
		  /* 8225748Ch */ case    9:  		/* lis R10, -32252 */
		/* 8225748Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225748Ch case    9:*/		return 0x82257490;
		  /* 82257490h */ case   10:  		/* li R11, 1 */
		/* 82257490h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82257490h case   10:*/		return 0x82257494;
		  /* 82257494h */ case   11:  		/* addi R10, R10, 30408 */
		/* 82257494h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x76C8);
		/* 82257494h case   11:*/		return 0x82257498;
		  /* 82257498h */ case   12:  		/* stw R11, <#[R3 + 16]> */
		/* 82257498h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82257498h case   12:*/		return 0x8225749C;
		  /* 8225749Ch */ case   13:  		/* li R9, 0 */
		/* 8225749Ch case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225749Ch case   13:*/		return 0x822574A0;
		  /* 822574A0h */ case   14:  		/* stw R10, <#[R3]> */
		/* 822574A0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822574A0h case   14:*/		return 0x822574A4;
		  /* 822574A4h */ case   15:  		/* lwz R10, <#[R30 + 32]> */
		/* 822574A4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000020) );
		/* 822574A4h case   15:*/		return 0x822574A8;
		  /* 822574A8h */ case   16:  		/* stw R10, <#[R3 + 80]> */
		/* 822574A8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 822574A8h case   16:*/		return 0x822574AC;
		  /* 822574ACh */ case   17:  		/* lwz R10, <#[R30 + 12]> */
		/* 822574ACh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 822574ACh case   17:*/		return 0x822574B0;
		  /* 822574B0h */ case   18:  		/* stw R10, <#[R3 + 56]> */
		/* 822574B0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 822574B0h case   18:*/		return 0x822574B4;
		  /* 822574B4h */ case   19:  		/* stw R30, <#[R3 + 28]> */
		/* 822574B4h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000001C) );
		/* 822574B4h case   19:*/		return 0x822574B8;
		  /* 822574B8h */ case   20:  		/* stb R11, <#[R30 + 28]> */
		/* 822574B8h case   20:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 822574B8h case   20:*/		return 0x822574BC;
		  /* 822574BCh */ case   21:  		/* stw R9, <#[R3 + 20]> */
		/* 822574BCh case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 822574BCh case   21:*/		return 0x822574C0;
		  /* 822574C0h */ case   22:  		/* addi R1, R1, 112 */
		/* 822574C0h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822574C0h case   22:*/		return 0x822574C4;
		  /* 822574C4h */ case   23:  		/* lwz R12, <#[R1 - 8]> */
		/* 822574C4h case   23:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822574C4h case   23:*/		return 0x822574C8;
		  /* 822574C8h */ case   24:  		/* mtspr LR, R12 */
		/* 822574C8h case   24:*/		regs.LR = regs.R12;
		/* 822574C8h case   24:*/		return 0x822574CC;
		  /* 822574CCh */ case   25:  		/* ld R30, <#[R1 - 24]> */
		/* 822574CCh case   25:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822574CCh case   25:*/		return 0x822574D0;
		  /* 822574D0h */ case   26:  		/* ld R31, <#[R1 - 16]> */
		/* 822574D0h case   26:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822574D0h case   26:*/		return 0x822574D4;
		  /* 822574D4h */ case   27:  		/* bclr 20, CR0_LT */
		/* 822574D4h case   27:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822574D4h case   27:*/		return 0x822574D8;
	}
	return 0x822574D8;
} // Block from 82257468h-822574D8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822574D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822574D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822574D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822574D8);
		  /* 822574D8h */ case    0:  		/* mfspr R12, LR */
		/* 822574D8h case    0:*/		regs.R12 = regs.LR;
		/* 822574D8h case    0:*/		return 0x822574DC;
		  /* 822574DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822574DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822574DCh case    1:*/		return 0x822574E0;
		  /* 822574E0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822574E0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822574E0h case    2:*/		return 0x822574E4;
		  /* 822574E4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822574E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822574E4h case    3:*/		return 0x822574E8;
		  /* 822574E8h */ case    4:  		/* mr R5, R4 */
		/* 822574E8h case    4:*/		regs.R5 = regs.R4;
		/* 822574E8h case    4:*/		return 0x822574EC;
		  /* 822574ECh */ case    5:  		/* li R4, 122 */
		/* 822574ECh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x7A);
		/* 822574ECh case    5:*/		return 0x822574F0;
		  /* 822574F0h */ case    6:  		/* mr R31, R3 */
		/* 822574F0h case    6:*/		regs.R31 = regs.R3;
		/* 822574F0h case    6:*/		return 0x822574F4;
		  /* 822574F4h */ case    7:  		/* bl -1796 */
		/* 822574F4h case    7:*/		regs.LR = 0x822574F8; return 0x82256DF0;
		/* 822574F4h case    7:*/		return 0x822574F8;
		  /* 822574F8h */ case    8:  		/* lis R11, -32252 */
		/* 822574F8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822574F8h case    8:*/		return 0x822574FC;
		  /* 822574FCh */ case    9:  		/* li R10, 1 */
		/* 822574FCh case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822574FCh case    9:*/		return 0x82257500;
		  /* 82257500h */ case   10:  		/* addi R11, R11, 30528 */
		/* 82257500h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7740);
		/* 82257500h case   10:*/		return 0x82257504;
		  /* 82257504h */ case   11:  		/* li R9, 0 */
		/* 82257504h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82257504h case   11:*/		return 0x82257508;
		  /* 82257508h */ case   12:  		/* stw R10, <#[R3 + 16]> */
		/* 82257508h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257508h case   12:*/		return 0x8225750C;
		  /* 8225750Ch */ case   13:  		/* stw R11, <#[R3]> */
		/* 8225750Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225750Ch case   13:*/		return 0x82257510;
		  /* 82257510h */ case   14:  		/* stw R9, <#[R3 + 20]> */
		/* 82257510h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82257510h case   14:*/		return 0x82257514;
		  /* 82257514h */ case   15:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257514h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257514h case   15:*/		return 0x82257518;
	}
	return 0x82257518;
} // Block from 822574D8h-82257518h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82257518h
// Function '?MarkInstructionAsExport@IRAlu@XGRAPHICS@@UAAXPAVCFG@2@W4RegType@R400Tables@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257518);
		  /* 82257518h */ case    0:  		/* ori R11, R11, 64 */
		/* 82257518h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82257518h case    0:*/		return 0x8225751C;
		  /* 8225751Ch */ case    1:  		/* stw R11, <#[R3 + 228]> */
		/* 8225751Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 8225751Ch case    1:*/		return 0x82257520;
		  /* 82257520h */ case    2:  		/* addi R1, R1, 96 */
		/* 82257520h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257520h case    2:*/		return 0x82257524;
		  /* 82257524h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257524h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257524h case    3:*/		return 0x82257528;
		  /* 82257528h */ case    4:  		/* mtspr LR, R12 */
		/* 82257528h case    4:*/		regs.LR = regs.R12;
		/* 82257528h case    4:*/		return 0x8225752C;
		  /* 8225752Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8225752Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225752Ch case    5:*/		return 0x82257530;
		  /* 82257530h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82257530h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257530h case    6:*/		return 0x82257534;
	}
	return 0x82257534;
} // Block from 82257518h-82257534h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82257534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257534);
		  /* 82257534h */ case    0:  		/* nop */
		/* 82257534h case    0:*/		cpu::op::nop();
		/* 82257534h case    0:*/		return 0x82257538;
	}
	return 0x82257538;
} // Block from 82257534h-82257538h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257538);
		  /* 82257538h */ case    0:  		/* lis R11, -32252 */
		/* 82257538h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257538h case    0:*/		return 0x8225753C;
		  /* 8225753Ch */ case    1:  		/* addi R3, R11, 30632 */
		/* 8225753Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x77A8);
		/* 8225753Ch case    1:*/		return 0x82257540;
		  /* 82257540h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257540h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257540h case    2:*/		return 0x82257544;
	}
	return 0x82257544;
} // Block from 82257538h-82257544h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257544);
		  /* 82257544h */ case    0:  		/* nop */
		/* 82257544h case    0:*/		cpu::op::nop();
		/* 82257544h case    0:*/		return 0x82257548;
	}
	return 0x82257548;
} // Block from 82257544h-82257548h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257548h
// Function '?SetComponent@IRMovBase@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257548);
		  /* 82257548h */ case    0:  		/* mfspr R12, LR */
		/* 82257548h case    0:*/		regs.R12 = regs.LR;
		/* 82257548h case    0:*/		return 0x8225754C;
		  /* 8225754Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225754Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225754Ch case    1:*/		return 0x82257550;
		  /* 82257550h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257550h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257550h case    2:*/		return 0x82257554;
		  /* 82257554h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82257554h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82257554h case    3:*/		return 0x82257558;
		  /* 82257558h */ case    4:  		/* li R4, 128 */
		/* 82257558h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 82257558h case    4:*/		return 0x8225755C;
		  /* 8225755Ch */ case    5:  		/* mr R31, R3 */
		/* 8225755Ch case    5:*/		regs.R31 = regs.R3;
		/* 8225755Ch case    5:*/		return 0x82257560;
		  /* 82257560h */ case    6:  		/* bl -1904 */
		/* 82257560h case    6:*/		regs.LR = 0x82257564; return 0x82256DF0;
		/* 82257560h case    6:*/		return 0x82257564;
		  /* 82257564h */ case    7:  		/* lis R10, -32252 */
		/* 82257564h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82257564h case    7:*/		return 0x82257568;
	}
	return 0x82257568;
} // Block from 82257548h-82257568h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82257568h
// Function '?FindInitialMova@IRMovBase@XGRAPHICS@@QAAPAVIRInst@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257568);
		  /* 82257568h */ case    0:  		/* li R11, 1 */
		/* 82257568h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82257568h case    0:*/		return 0x8225756C;
		  /* 8225756Ch */ case    1:  		/* addi R10, R10, 30648 */
		/* 8225756Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x77B8);
		/* 8225756Ch case    1:*/		return 0x82257570;
		  /* 82257570h */ case    2:  		/* stw R11, <#[R3 + 16]> */
		/* 82257570h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82257570h case    2:*/		return 0x82257574;
		  /* 82257574h */ case    3:  		/* stw R10, <#[R3]> */
		/* 82257574h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82257574h case    3:*/		return 0x82257578;
		  /* 82257578h */ case    4:  		/* stw R11, <#[R3 + 20]> */
		/* 82257578h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82257578h case    4:*/		return 0x8225757C;
		  /* 8225757Ch */ case    5:  		/* addi R1, R1, 96 */
		/* 8225757Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225757Ch case    5:*/		return 0x82257580;
		  /* 82257580h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257580h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257580h case    6:*/		return 0x82257584;
		  /* 82257584h */ case    7:  		/* mtspr LR, R12 */
		/* 82257584h case    7:*/		regs.LR = regs.R12;
		/* 82257584h case    7:*/		return 0x82257588;
		  /* 82257588h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82257588h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257588h case    8:*/		return 0x8225758C;
		  /* 8225758Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 8225758Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225758Ch case    9:*/		return 0x82257590;
	}
	return 0x82257590;
} // Block from 82257568h-82257590h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82257590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257590);
		  /* 82257590h */ case    0:  		/* lis R11, -32252 */
		/* 82257590h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257590h case    0:*/		return 0x82257594;
		  /* 82257594h */ case    1:  		/* addi R3, R11, 30752 */
		/* 82257594h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7820);
		/* 82257594h case    1:*/		return 0x82257598;
		  /* 82257598h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257598h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257598h case    2:*/		return 0x8225759C;
	}
	return 0x8225759C;
} // Block from 82257590h-8225759Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225759Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225759C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225759C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225759C);
		  /* 8225759Ch */ case    0:  		/* nop */
		/* 8225759Ch case    0:*/		cpu::op::nop();
		/* 8225759Ch case    0:*/		return 0x822575A0;
	}
	return 0x822575A0;
} // Block from 8225759Ch-822575A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822575A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822575A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822575A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822575A0);
		  /* 822575A0h */ case    0:  		/* mfspr R12, LR */
		/* 822575A0h case    0:*/		regs.R12 = regs.LR;
		/* 822575A0h case    0:*/		return 0x822575A4;
		  /* 822575A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822575A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822575A4h case    1:*/		return 0x822575A8;
		  /* 822575A8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822575A8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822575A8h case    2:*/		return 0x822575AC;
		  /* 822575ACh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822575ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822575ACh case    3:*/		return 0x822575B0;
		  /* 822575B0h */ case    4:  		/* mr R5, R4 */
		/* 822575B0h case    4:*/		regs.R5 = regs.R4;
		/* 822575B0h case    4:*/		return 0x822575B4;
		  /* 822575B4h */ case    5:  		/* li R4, 137 */
		/* 822575B4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x89);
		/* 822575B4h case    5:*/		return 0x822575B8;
		  /* 822575B8h */ case    6:  		/* mr R31, R3 */
		/* 822575B8h case    6:*/		regs.R31 = regs.R3;
		/* 822575B8h case    6:*/		return 0x822575BC;
		  /* 822575BCh */ case    7:  		/* bl -1996 */
		/* 822575BCh case    7:*/		regs.LR = 0x822575C0; return 0x82256DF0;
		/* 822575BCh case    7:*/		return 0x822575C0;
		  /* 822575C0h */ case    8:  		/* lis R11, -32252 */
		/* 822575C0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822575C0h case    8:*/		return 0x822575C4;
		  /* 822575C4h */ case    9:  		/* li R10, 1 */
		/* 822575C4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822575C4h case    9:*/		return 0x822575C8;
		  /* 822575C8h */ case   10:  		/* addi R11, R11, 30768 */
		/* 822575C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7830);
		/* 822575C8h case   10:*/		return 0x822575CC;
		  /* 822575CCh */ case   11:  		/* stw R10, <#[R3 + 16]> */
		/* 822575CCh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 822575CCh case   11:*/		return 0x822575D0;
		  /* 822575D0h */ case   12:  		/* stw R11, <#[R3]> */
		/* 822575D0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822575D0h case   12:*/		return 0x822575D4;
		  /* 822575D4h */ case   13:  		/* addi R1, R1, 96 */
		/* 822575D4h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822575D4h case   13:*/		return 0x822575D8;
		  /* 822575D8h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 822575D8h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822575D8h case   14:*/		return 0x822575DC;
		  /* 822575DCh */ case   15:  		/* mtspr LR, R12 */
		/* 822575DCh case   15:*/		regs.LR = regs.R12;
		/* 822575DCh case   15:*/		return 0x822575E0;
	}
	return 0x822575E0;
} // Block from 822575A0h-822575E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822575E0h
// Function '?GetStreamNumAndEtc@IRVertexFetch@XGRAPHICS@@QAAXPAIPAH1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822575E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822575E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822575E0);
		  /* 822575E0h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 822575E0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822575E0h case    0:*/		return 0x822575E4;
		  /* 822575E4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822575E4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822575E4h case    1:*/		return 0x822575E8;
	}
	return 0x822575E8;
} // Block from 822575E0h-822575E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822575E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822575E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822575E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822575E8);
		  /* 822575E8h */ case    0:  		/* lis R11, -32252 */
		/* 822575E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822575E8h case    0:*/		return 0x822575EC;
		  /* 822575ECh */ case    1:  		/* addi R3, R11, 30872 */
		/* 822575ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7898);
		/* 822575ECh case    1:*/		return 0x822575F0;
		  /* 822575F0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822575F0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822575F0h case    2:*/		return 0x822575F4;
	}
	return 0x822575F4;
} // Block from 822575E8h-822575F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822575F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822575F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822575F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822575F4);
		  /* 822575F4h */ case    0:  		/* nop */
		/* 822575F4h case    0:*/		cpu::op::nop();
		/* 822575F4h case    0:*/		return 0x822575F8;
	}
	return 0x822575F8;
} // Block from 822575F4h-822575F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822575F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822575F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822575F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822575F8);
		  /* 822575F8h */ case    0:  		/* mfspr R12, LR */
		/* 822575F8h case    0:*/		regs.R12 = regs.LR;
		/* 822575F8h case    0:*/		return 0x822575FC;
		  /* 822575FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822575FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822575FCh case    1:*/		return 0x82257600;
		  /* 82257600h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257600h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257600h case    2:*/		return 0x82257604;
		  /* 82257604h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82257604h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257604h case    3:*/		return 0x82257608;
		  /* 82257608h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257608h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257608h case    4:*/		return 0x8225760C;
		  /* 8225760Ch */ case    5:  		/* li R4, 125 */
		/* 8225760Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x7D);
		/* 8225760Ch case    5:*/		return 0x82257610;
		  /* 82257610h */ case    6:  		/* mr R31, R3 */
		/* 82257610h case    6:*/		regs.R31 = regs.R3;
		/* 82257610h case    6:*/		return 0x82257614;
		  /* 82257614h */ case    7:  		/* mr R30, R5 */
		/* 82257614h case    7:*/		regs.R30 = regs.R5;
		/* 82257614h case    7:*/		return 0x82257618;
		  /* 82257618h */ case    8:  		/* bl -2088 */
		/* 82257618h case    8:*/		regs.LR = 0x8225761C; return 0x82256DF0;
		/* 82257618h case    8:*/		return 0x8225761C;
		  /* 8225761Ch */ case    9:  		/* lis R11, -32252 */
		/* 8225761Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225761Ch case    9:*/		return 0x82257620;
		  /* 82257620h */ case   10:  		/* li R10, 1 */
		/* 82257620h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82257620h case   10:*/		return 0x82257624;
		  /* 82257624h */ case   11:  		/* addi R11, R11, 30880 */
		/* 82257624h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x78A0);
		/* 82257624h case   11:*/		return 0x82257628;
		  /* 82257628h */ case   12:  		/* stw R10, <#[R3 + 16]> */
		/* 82257628h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257628h case   12:*/		return 0x8225762C;
		  /* 8225762Ch */ case   13:  		/* mr R4, R3 */
		/* 8225762Ch case   13:*/		regs.R4 = regs.R3;
		/* 8225762Ch case   13:*/		return 0x82257630;
		  /* 82257630h */ case   14:  		/* stw R11, <#[R3]> */
		/* 82257630h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257630h case   14:*/		return 0x82257634;
		  /* 82257634h */ case   15:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257634h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257634h case   15:*/		return 0x82257638;
		  /* 82257638h */ case   16:  		/* ori R11, R11, 24 */
		/* 82257638h case   16:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82257638h case   16:*/		return 0x8225763C;
		  /* 8225763Ch */ case   17:  		/* stw R11, <#[R3 + 228]> */
		/* 8225763Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 8225763Ch case   17:*/		return 0x82257640;
		  /* 82257640h */ case   18:  		/* lwz R3, <#[R30 + 2736]> */
		/* 82257640h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82257640h case   18:*/		return 0x82257644;
		  /* 82257644h */ case   19:  		/* bl -136780 */
		/* 82257644h case   19:*/		regs.LR = 0x82257648; return 0x82235FF8;
		/* 82257644h case   19:*/		return 0x82257648;
		  /* 82257648h */ case   20:  		/* mr R3, R31 */
		/* 82257648h case   20:*/		regs.R3 = regs.R31;
		/* 82257648h case   20:*/		return 0x8225764C;
		  /* 8225764Ch */ case   21:  		/* addi R1, R1, 112 */
		/* 8225764Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225764Ch case   21:*/		return 0x82257650;
		  /* 82257650h */ case   22:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257650h case   22:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257650h case   22:*/		return 0x82257654;
		  /* 82257654h */ case   23:  		/* mtspr LR, R12 */
		/* 82257654h case   23:*/		regs.LR = regs.R12;
		/* 82257654h case   23:*/		return 0x82257658;
		  /* 82257658h */ case   24:  		/* ld R30, <#[R1 - 24]> */
		/* 82257658h case   24:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257658h case   24:*/		return 0x8225765C;
		  /* 8225765Ch */ case   25:  		/* ld R31, <#[R1 - 16]> */
		/* 8225765Ch case   25:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225765Ch case   25:*/		return 0x82257660;
		  /* 82257660h */ case   26:  		/* bclr 20, CR0_LT */
		/* 82257660h case   26:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257660h case   26:*/		return 0x82257664;
	}
	return 0x82257664;
} // Block from 822575F8h-82257664h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82257664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257664);
		  /* 82257664h */ case    0:  		/* nop */
		/* 82257664h case    0:*/		cpu::op::nop();
		/* 82257664h case    0:*/		return 0x82257668;
	}
	return 0x82257668;
} // Block from 82257664h-82257668h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257668);
		  /* 82257668h */ case    0:  		/* lis R11, -32252 */
		/* 82257668h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257668h case    0:*/		return 0x8225766C;
		  /* 8225766Ch */ case    1:  		/* addi R3, R11, 30984 */
		/* 8225766Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7908);
		/* 8225766Ch case    1:*/		return 0x82257670;
	}
	return 0x82257670;
} // Block from 82257668h-82257670h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257670h
// Function '?ChangeToScalar@IRInst@XGRAPHICS@@QAAXHH_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257670);
		  /* 82257670h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82257670h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257670h case    0:*/		return 0x82257674;
	}
	return 0x82257674;
} // Block from 82257670h-82257674h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257674);
		  /* 82257674h */ case    0:  		/* nop */
		/* 82257674h case    0:*/		cpu::op::nop();
		/* 82257674h case    0:*/		return 0x82257678;
	}
	return 0x82257678;
} // Block from 82257674h-82257678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257678);
		  /* 82257678h */ case    0:  		/* mfspr R12, LR */
		/* 82257678h case    0:*/		regs.R12 = regs.LR;
		/* 82257678h case    0:*/		return 0x8225767C;
		  /* 8225767Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225767Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225767Ch case    1:*/		return 0x82257680;
		  /* 82257680h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257680h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257680h case    2:*/		return 0x82257684;
		  /* 82257684h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82257684h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82257684h case    3:*/		return 0x82257688;
		  /* 82257688h */ case    4:  		/* li R4, 126 */
		/* 82257688h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x7E);
		/* 82257688h case    4:*/		return 0x8225768C;
		  /* 8225768Ch */ case    5:  		/* mr R31, R3 */
		/* 8225768Ch case    5:*/		regs.R31 = regs.R3;
		/* 8225768Ch case    5:*/		return 0x82257690;
		  /* 82257690h */ case    6:  		/* bl -2208 */
		/* 82257690h case    6:*/		regs.LR = 0x82257694; return 0x82256DF0;
		/* 82257690h case    6:*/		return 0x82257694;
		  /* 82257694h */ case    7:  		/* lis R10, -32252 */
		/* 82257694h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82257694h case    7:*/		return 0x82257698;
		  /* 82257698h */ case    8:  		/* li R11, 1 */
		/* 82257698h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82257698h case    8:*/		return 0x8225769C;
		  /* 8225769Ch */ case    9:  		/* addi R10, R10, 30992 */
		/* 8225769Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7910);
		/* 8225769Ch case    9:*/		return 0x822576A0;
		  /* 822576A0h */ case   10:  		/* stw R11, <#[R3 + 16]> */
		/* 822576A0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822576A0h case   10:*/		return 0x822576A4;
		  /* 822576A4h */ case   11:  		/* stw R10, <#[R3]> */
		/* 822576A4h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822576A4h case   11:*/		return 0x822576A8;
		  /* 822576A8h */ case   12:  		/* stw R11, <#[R3 + 20]> */
		/* 822576A8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 822576A8h case   12:*/		return 0x822576AC;
		  /* 822576ACh */ case   13:  		/* addi R1, R1, 96 */
		/* 822576ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822576ACh case   13:*/		return 0x822576B0;
		  /* 822576B0h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 822576B0h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822576B0h case   14:*/		return 0x822576B4;
		  /* 822576B4h */ case   15:  		/* mtspr LR, R12 */
		/* 822576B4h case   15:*/		regs.LR = regs.R12;
		/* 822576B4h case   15:*/		return 0x822576B8;
		  /* 822576B8h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 822576B8h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822576B8h case   16:*/		return 0x822576BC;
		  /* 822576BCh */ case   17:  		/* bclr 20, CR0_LT */
		/* 822576BCh case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822576BCh case   17:*/		return 0x822576C0;
	}
	return 0x822576C0;
} // Block from 82257678h-822576C0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822576C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822576C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822576C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822576C0);
		  /* 822576C0h */ case    0:  		/* lis R11, -32252 */
		/* 822576C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822576C0h case    0:*/		return 0x822576C4;
		  /* 822576C4h */ case    1:  		/* addi R3, R11, 31096 */
		/* 822576C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7978);
		/* 822576C4h case    1:*/		return 0x822576C8;
		  /* 822576C8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822576C8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822576C8h case    2:*/		return 0x822576CC;
	}
	return 0x822576CC;
} // Block from 822576C0h-822576CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822576CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822576CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822576CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822576CC);
		  /* 822576CCh */ case    0:  		/* nop */
		/* 822576CCh case    0:*/		cpu::op::nop();
		/* 822576CCh case    0:*/		return 0x822576D0;
	}
	return 0x822576D0;
} // Block from 822576CCh-822576D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822576D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822576D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822576D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822576D0);
		  /* 822576D0h */ case    0:  		/* mfspr R12, LR */
		/* 822576D0h case    0:*/		regs.R12 = regs.LR;
		/* 822576D0h case    0:*/		return 0x822576D4;
		  /* 822576D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822576D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822576D4h case    1:*/		return 0x822576D8;
		  /* 822576D8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822576D8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822576D8h case    2:*/		return 0x822576DC;
		  /* 822576DCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822576DCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822576DCh case    3:*/		return 0x822576E0;
		  /* 822576E0h */ case    4:  		/* mr R31, R3 */
		/* 822576E0h case    4:*/		regs.R31 = regs.R3;
		/* 822576E0h case    4:*/		return 0x822576E4;
		  /* 822576E4h */ case    5:  		/* bl -2292 */
		/* 822576E4h case    5:*/		regs.LR = 0x822576E8; return 0x82256DF0;
		/* 822576E4h case    5:*/		return 0x822576E8;
		  /* 822576E8h */ case    6:  		/* lis R10, -32252 */
		/* 822576E8h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822576E8h case    6:*/		return 0x822576EC;
		  /* 822576ECh */ case    7:  		/* li R11, 0 */
		/* 822576ECh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822576ECh case    7:*/		return 0x822576F0;
		  /* 822576F0h */ case    8:  		/* addi R10, R10, 31112 */
		/* 822576F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7988);
		/* 822576F0h case    8:*/		return 0x822576F4;
		  /* 822576F4h */ case    9:  		/* li R9, 1 */
		/* 822576F4h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822576F4h case    9:*/		return 0x822576F8;
		  /* 822576F8h */ case   10:  		/* stw R11, <#[R3 + 168]> */
		/* 822576F8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000A8) );
		/* 822576F8h case   10:*/		return 0x822576FC;
		  /* 822576FCh */ case   11:  		/* stw R10, <#[R3]> */
		/* 822576FCh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822576FCh case   11:*/		return 0x82257700;
		  /* 82257700h */ case   12:  		/* stw R9, <#[R3 + 16]> */
		/* 82257700h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82257700h case   12:*/		return 0x82257704;
		  /* 82257704h */ case   13:  		/* stw R11, <#[R3 + 20]> */
		/* 82257704h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82257704h case   13:*/		return 0x82257708;
		  /* 82257708h */ case   14:  		/* addi R1, R1, 96 */
		/* 82257708h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257708h case   14:*/		return 0x8225770C;
		  /* 8225770Ch */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225770Ch case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225770Ch case   15:*/		return 0x82257710;
		  /* 82257710h */ case   16:  		/* mtspr LR, R12 */
		/* 82257710h case   16:*/		regs.LR = regs.R12;
		/* 82257710h case   16:*/		return 0x82257714;
		  /* 82257714h */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 82257714h case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257714h case   17:*/		return 0x82257718;
		  /* 82257718h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82257718h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257718h case   18:*/		return 0x8225771C;
	}
	return 0x8225771C;
} // Block from 822576D0h-8225771Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225771Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225771C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225771C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225771C);
		  /* 8225771Ch */ case    0:  		/* nop */
		/* 8225771Ch case    0:*/		cpu::op::nop();
		/* 8225771Ch case    0:*/		return 0x82257720;
	}
	return 0x82257720;
} // Block from 8225771Ch-82257720h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257720);
		  /* 82257720h */ case    0:  		/* lis R11, -32252 */
		/* 82257720h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257720h case    0:*/		return 0x82257724;
		  /* 82257724h */ case    1:  		/* addi R3, R11, 31320 */
		/* 82257724h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7A58);
		/* 82257724h case    1:*/		return 0x82257728;
		  /* 82257728h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257728h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257728h case    2:*/		return 0x8225772C;
	}
	return 0x8225772C;
} // Block from 82257720h-8225772Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225772Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225772C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225772C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225772C);
		  /* 8225772Ch */ case    0:  		/* nop */
		/* 8225772Ch case    0:*/		cpu::op::nop();
		/* 8225772Ch case    0:*/		return 0x82257730;
	}
	return 0x82257730;
} // Block from 8225772Ch-82257730h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257730);
		  /* 82257730h */ case    0:  		/* lis R11, -32252 */
		/* 82257730h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257730h case    0:*/		return 0x82257734;
		  /* 82257734h */ case    1:  		/* addi R3, R11, 31440 */
		/* 82257734h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7AD0);
		/* 82257734h case    1:*/		return 0x82257738;
		  /* 82257738h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257738h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257738h case    2:*/		return 0x8225773C;
	}
	return 0x8225773C;
} // Block from 82257730h-8225773Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225773Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225773C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225773C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225773C);
		  /* 8225773Ch */ case    0:  		/* nop */
		/* 8225773Ch case    0:*/		cpu::op::nop();
		/* 8225773Ch case    0:*/		return 0x82257740;
	}
	return 0x82257740;
} // Block from 8225773Ch-82257740h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257740);
		  /* 82257740h */ case    0:  		/* lis R11, -32252 */
		/* 82257740h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257740h case    0:*/		return 0x82257744;
		  /* 82257744h */ case    1:  		/* addi R3, R11, 31560 */
		/* 82257744h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7B48);
		/* 82257744h case    1:*/		return 0x82257748;
		  /* 82257748h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257748h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257748h case    2:*/		return 0x8225774C;
	}
	return 0x8225774C;
} // Block from 82257740h-8225774Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225774Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225774C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225774C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225774C);
		  /* 8225774Ch */ case    0:  		/* nop */
		/* 8225774Ch case    0:*/		cpu::op::nop();
		/* 8225774Ch case    0:*/		return 0x82257750;
	}
	return 0x82257750;
} // Block from 8225774Ch-82257750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257750);
		  /* 82257750h */ case    0:  		/* lis R11, -32252 */
		/* 82257750h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257750h case    0:*/		return 0x82257754;
		  /* 82257754h */ case    1:  		/* addi R3, R11, 31680 */
		/* 82257754h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7BC0);
		/* 82257754h case    1:*/		return 0x82257758;
		  /* 82257758h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257758h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257758h case    2:*/		return 0x8225775C;
	}
	return 0x8225775C;
} // Block from 82257750h-8225775Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225775Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225775C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225775C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225775C);
		  /* 8225775Ch */ case    0:  		/* nop */
		/* 8225775Ch case    0:*/		cpu::op::nop();
		/* 8225775Ch case    0:*/		return 0x82257760;
	}
	return 0x82257760;
} // Block from 8225775Ch-82257760h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257760);
		  /* 82257760h */ case    0:  		/* lis R11, -32252 */
		/* 82257760h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257760h case    0:*/		return 0x82257764;
		  /* 82257764h */ case    1:  		/* addi R3, R11, -14604 */
		/* 82257764h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC6F4);
		/* 82257764h case    1:*/		return 0x82257768;
		  /* 82257768h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257768h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257768h case    2:*/		return 0x8225776C;
	}
	return 0x8225776C;
} // Block from 82257760h-8225776Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225776Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225776C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225776C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225776C);
		  /* 8225776Ch */ case    0:  		/* nop */
		/* 8225776Ch case    0:*/		cpu::op::nop();
		/* 8225776Ch case    0:*/		return 0x82257770;
	}
	return 0x82257770;
} // Block from 8225776Ch-82257770h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257770);
		  /* 82257770h */ case    0:  		/* cmpwi CR6, R6, 4 */
		/* 82257770h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000004);
		/* 82257770h case    0:*/		return 0x82257774;
		  /* 82257774h */ case    1:  		/* bc 12, CR6_LT, 48 */
		/* 82257774h case    1:*/		if ( regs.CR[6].lt ) { return 0x822577A4;  }
		/* 82257774h case    1:*/		return 0x82257778;
		  /* 82257778h */ case    2:  		/* cmpwi CR6, R6, 5 */
		/* 82257778h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000005);
		/* 82257778h case    2:*/		return 0x8225777C;
		  /* 8225777Ch */ case    3:  		/* bc 12, CR6_GT, 40 */
		/* 8225777Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x822577A4;  }
		/* 8225777Ch case    3:*/		return 0x82257780;
		  /* 82257780h */ case    4:  		/* lis R11, -32252 */
		/* 82257780h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257780h case    4:*/		return 0x82257784;
		  /* 82257784h */ case    5:  		/* lis R10, -32255 */
		/* 82257784h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82257784h case    5:*/		return 0x82257788;
		  /* 82257788h */ case    6:  		/* lis R9, -32253 */
		/* 82257788h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82257788h case    6:*/		return 0x8225778C;
		  /* 8225778Ch */ case    7:  		/* addi R6, R11, 8704 */
		/* 8225778Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2200);
		/* 8225778Ch case    7:*/		return 0x82257790;
		  /* 82257790h */ case    8:  		/* addi R5, R10, 5216 */
		/* 82257790h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 82257790h case    8:*/		return 0x82257794;
		  /* 82257794h */ case    9:  		/* addi R4, R9, 27460 */
		/* 82257794h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82257794h case    9:*/		return 0x82257798;
	}
	return 0x82257798;
} // Block from 82257770h-82257798h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82257798h
// Function '?ChangeToVector@IRInst@XGRAPHICS@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257798);
		  /* 82257798h */ case    0:  		/* li R7, 1712 */
		/* 82257798h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x6B0);
		/* 82257798h case    0:*/		return 0x8225779C;
		  /* 8225779Ch */ case    1:  		/* li R3, 0 */
		/* 8225779Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225779Ch case    1:*/		return 0x822577A0;
		  /* 822577A0h */ case    2:  		/* b -1047448 */
		/* 822577A0h case    2:*/		return 0x82157C08;
		/* 822577A0h case    2:*/		return 0x822577A4;
	}
	return 0x822577A4;
} // Block from 82257798h-822577A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822577A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822577A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822577A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822577A4);
		  /* 822577A4h */ case    0:  		/* addi R11, R4, 32 */
		/* 822577A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 822577A4h case    0:*/		return 0x822577A8;
		  /* 822577A8h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822577A8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822577A8h case    1:*/		return 0x822577AC;
		  /* 822577ACh */ case    2:  		/* add R11, R11, R5 */
		/* 822577ACh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 822577ACh case    2:*/		return 0x822577B0;
		  /* 822577B0h */ case    3:  		/* stbx R6, <#[R11 + R3]> */
		/* 822577B0h case    3:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822577B0h case    3:*/		return 0x822577B4;
		  /* 822577B4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822577B4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822577B4h case    4:*/		return 0x822577B8;
	}
	return 0x822577B8;
} // Block from 822577A4h-822577B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822577B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822577B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822577B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822577B8);
		  /* 822577B8h */ case    0:  		/* mfspr R12, LR */
		/* 822577B8h case    0:*/		regs.R12 = regs.LR;
		/* 822577B8h case    0:*/		return 0x822577BC;
		  /* 822577BCh */ case    1:  		/* bl -1860960 */
		/* 822577BCh case    1:*/		regs.LR = 0x822577C0; return 0x8209125C;
		/* 822577BCh case    1:*/		return 0x822577C0;
		  /* 822577C0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822577C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822577C0h case    2:*/		return 0x822577C4;
		  /* 822577C4h */ case    3:  		/* mr R31, R3 */
		/* 822577C4h case    3:*/		regs.R31 = regs.R3;
		/* 822577C4h case    3:*/		return 0x822577C8;
		  /* 822577C8h */ case    4:  		/* mr R30, R6 */
		/* 822577C8h case    4:*/		regs.R30 = regs.R6;
		/* 822577C8h case    4:*/		return 0x822577CC;
		  /* 822577CCh */ case    5:  		/* mr R29, R7 */
		/* 822577CCh case    5:*/		regs.R29 = regs.R7;
		/* 822577CCh case    5:*/		return 0x822577D0;
		  /* 822577D0h */ case    6:  		/* bl -2528 */
		/* 822577D0h case    6:*/		regs.LR = 0x822577D4; return 0x82256DF0;
		/* 822577D0h case    6:*/		return 0x822577D4;
		  /* 822577D4h */ case    7:  		/* lis R10, -32252 */
		/* 822577D4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822577D4h case    7:*/		return 0x822577D8;
		  /* 822577D8h */ case    8:  		/* stw R29, <#[R3 + 168]> */
		/* 822577D8h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x000000A8) );
		/* 822577D8h case    8:*/		return 0x822577DC;
		  /* 822577DCh */ case    9:  		/* lis R8, -32252 */
		/* 822577DCh case    9:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 822577DCh case    9:*/		return 0x822577E0;
		  /* 822577E0h */ case   10:  		/* stw R30, <#[R3 + 172]> */
		/* 822577E0h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x000000AC) );
		/* 822577E0h case   10:*/		return 0x822577E4;
		  /* 822577E4h */ case   11:  		/* li R11, 0 */
		/* 822577E4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822577E4h case   11:*/		return 0x822577E8;
		  /* 822577E8h */ case   12:  		/* li R9, 1 */
		/* 822577E8h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822577E8h case   12:*/		return 0x822577EC;
		  /* 822577ECh */ case   13:  		/* addi R8, R8, 31696 */
		/* 822577ECh case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x7BD0);
		/* 822577ECh case   13:*/		return 0x822577F0;
		  /* 822577F0h */ case   14:  		/* stb R11, <#[R3 + 176]> */
		/* 822577F0h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x000000B0) );
		/* 822577F0h case   14:*/		return 0x822577F4;
		  /* 822577F4h */ case   15:  		/* lwz R10, <#[R10 + 28868]> */
		/* 822577F4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x000070C4) );
		/* 822577F4h case   15:*/		return 0x822577F8;
		  /* 822577F8h */ case   16:  		/* li R7, 30 */
		/* 822577F8h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x1E);
		/* 822577F8h case   16:*/		return 0x822577FC;
		  /* 822577FCh */ case   17:  		/* stw R9, <#[R3 + 20]> */
		/* 822577FCh case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 822577FCh case   17:*/		return 0x82257800;
		  /* 82257800h */ case   18:  		/* stw R9, <#[R3 + 16]> */
		/* 82257800h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82257800h case   18:*/		return 0x82257804;
		  /* 82257804h */ case   19:  		/* stw R8, <#[R3]> */
		/* 82257804h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 82257804h case   19:*/		return 0x82257808;
		  /* 82257808h */ case   20:  		/* stw R11, <#[R3 + 180]> */
		/* 82257808h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000B4) );
		/* 82257808h case   20:*/		return 0x8225780C;
		  /* 8225780Ch */ case   21:  		/* stw R11, <#[R3 + 184]> */
		/* 8225780Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225780Ch case   21:*/		return 0x82257810;
		  /* 82257810h */ case   22:  		/* stw R11, <#[R3 + 80]> */
		/* 82257810h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82257810h case   22:*/		return 0x82257814;
		  /* 82257814h */ case   23:  		/* stw R7, <#[R3 + 84]> */
		/* 82257814h case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000054) );
		/* 82257814h case   23:*/		return 0x82257818;
		  /* 82257818h */ case   24:  		/* stw R11, <#[R3 + 60]> */
		/* 82257818h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 82257818h case   24:*/		return 0x8225781C;
		  /* 8225781Ch */ case   25:  		/* stw R10, <#[R3 + 128]> */
		/* 8225781Ch case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000080) );
		/* 8225781Ch case   25:*/		return 0x82257820;
		  /* 82257820h */ case   26:  		/* addi R1, R1, 112 */
		/* 82257820h case   26:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257820h case   26:*/		return 0x82257824;
		  /* 82257824h */ case   27:  		/* b -1860984 */
		/* 82257824h case   27:*/		return 0x820912AC;
		/* 82257824h case   27:*/		return 0x82257828;
	}
	return 0x82257828;
} // Block from 822577B8h-82257828h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82257828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257828);
		  /* 82257828h */ case    0:  		/* mfspr R12, LR */
		/* 82257828h case    0:*/		regs.R12 = regs.LR;
		/* 82257828h case    0:*/		return 0x8225782C;
		  /* 8225782Ch */ case    1:  		/* bl -1861076 */
		/* 8225782Ch case    1:*/		regs.LR = 0x82257830; return 0x82091258;
		/* 8225782Ch case    1:*/		return 0x82257830;
		  /* 82257830h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82257830h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82257830h case    2:*/		return 0x82257834;
		  /* 82257834h */ case    3:  		/* mr R29, R3 */
		/* 82257834h case    3:*/		regs.R29 = regs.R3;
		/* 82257834h case    3:*/		return 0x82257838;
		  /* 82257838h */ case    4:  		/* mr R28, R5 */
		/* 82257838h case    4:*/		regs.R28 = regs.R5;
		/* 82257838h case    4:*/		return 0x8225783C;
		  /* 8225783Ch */ case    5:  		/* bl -2636 */
		/* 8225783Ch case    5:*/		regs.LR = 0x82257840; return 0x82256DF0;
		/* 8225783Ch case    5:*/		return 0x82257840;
		  /* 82257840h */ case    6:  		/* lis R11, -32252 */
		/* 82257840h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257840h case    6:*/		return 0x82257844;
		  /* 82257844h */ case    7:  		/* li R31, 0 */
		/* 82257844h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82257844h case    7:*/		return 0x82257848;
		  /* 82257848h */ case    8:  		/* li R30, 1 */
		/* 82257848h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82257848h case    8:*/		return 0x8225784C;
		  /* 8225784Ch */ case    9:  		/* addi R11, R11, 31800 */
		/* 8225784Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7C38);
		/* 8225784Ch case    9:*/		return 0x82257850;
		  /* 82257850h */ case   10:  		/* stw R31, <#[R3 + 172]> */
		/* 82257850h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x000000AC) );
		/* 82257850h case   10:*/		return 0x82257854;
		  /* 82257854h */ case   11:  		/* li R10, -1 */
		/* 82257854h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82257854h case   11:*/		return 0x82257858;
	}
	return 0x82257858;
} // Block from 82257828h-82257858h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82257858h
// Function '??0IRInst@XGRAPHICS@@IAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257858);
		  /* 82257858h */ case    0:  		/* stw R30, <#[R3 + 20]> */
		/* 82257858h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000014) );
		/* 82257858h case    0:*/		return 0x8225785C;
		  /* 8225785Ch */ case    1:  		/* stw R11, <#[R3]> */
		/* 8225785Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225785Ch case    1:*/		return 0x82257860;
		  /* 82257860h */ case    2:  		/* li R4, 30 */
		/* 82257860h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1E);
		/* 82257860h case    2:*/		return 0x82257864;
		  /* 82257864h */ case    3:  		/* stw R30, <#[R3 + 16]> */
		/* 82257864h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 82257864h case    3:*/		return 0x82257868;
		  /* 82257868h */ case    4:  		/* stw R10, <#[R3 + 176]> */
		/* 82257868h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x000000B0) );
		/* 82257868h case    4:*/		return 0x8225786C;
		  /* 8225786Ch */ case    5:  		/* stw R31, <#[R3 + 80]> */
		/* 8225786Ch case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000050) );
		/* 8225786Ch case    5:*/		return 0x82257870;
		  /* 82257870h */ case    6:  		/* stw R31, <#[R3 + 84]> */
		/* 82257870h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000054) );
		/* 82257870h case    6:*/		return 0x82257874;
		  /* 82257874h */ case    7:  		/* stw R31, <#[R3 + 108]> */
		/* 82257874h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x0000006C) );
		/* 82257874h case    7:*/		return 0x82257878;
		  /* 82257878h */ case    8:  		/* stw R31, <#[R3 + 104]> */
		/* 82257878h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000068) );
		/* 82257878h case    8:*/		return 0x8225787C;
		  /* 8225787Ch */ case    9:  		/* lwz R3, <#[R28 + 1452]> */
		/* 8225787Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x000005AC) );
		/* 8225787Ch case    9:*/		return 0x82257880;
		  /* 82257880h */ case   10:  		/* bl -242632 */
		/* 82257880h case   10:*/		regs.LR = 0x82257884; return 0x8221C4B8;
		/* 82257880h case   10:*/		return 0x82257884;
		  /* 82257884h */ case   11:  		/* li R5, 30 */
		/* 82257884h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1E);
		/* 82257884h case   11:*/		return 0x82257888;
		  /* 82257888h */ case   12:  		/* li R4, 0 */
		/* 82257888h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82257888h case   12:*/		return 0x8225788C;
		  /* 8225788Ch */ case   13:  		/* mr R28, R3 */
		/* 8225788Ch case   13:*/		regs.R28 = regs.R3;
		/* 8225788Ch case   13:*/		return 0x82257890;
		  /* 82257890h */ case   14:  		/* bl -1860944 */
		/* 82257890h case   14:*/		regs.LR = 0x82257894; return 0x82091340;
		/* 82257890h case   14:*/		return 0x82257894;
		  /* 82257894h */ case   15:  		/* li R11, 3 */
		/* 82257894h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82257894h case   15:*/		return 0x82257898;
		  /* 82257898h */ case   16:  		/* li R10, 7 */
		/* 82257898h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 82257898h case   16:*/		return 0x8225789C;
		  /* 8225789Ch */ case   17:  		/* sth R30, <#[R28 + 14]> */
		/* 8225789Ch case   17:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R28 + 0x0000000E) );
		/* 8225789Ch case   17:*/		return 0x822578A0;
		  /* 822578A0h */ case   18:  		/* sth R11, <#[R28]> */
		/* 822578A0h case   18:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 822578A0h case   18:*/		return 0x822578A4;
		  /* 822578A4h */ case   19:  		/* mr R3, R29 */
		/* 822578A4h case   19:*/		regs.R3 = regs.R29;
		/* 822578A4h case   19:*/		return 0x822578A8;
		  /* 822578A8h */ case   20:  		/* sth R11, <#[R28 + 2]> */
		/* 822578A8h case   20:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R28 + 0x00000002) );
		/* 822578A8h case   20:*/		return 0x822578AC;
		  /* 822578ACh */ case   21:  		/* sth R11, <#[R28 + 4]> */
		/* 822578ACh case   21:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 822578ACh case   21:*/		return 0x822578B0;
		  /* 822578B0h */ case   22:  		/* sth R10, <#[R28 + 6]> */
		/* 822578B0h case   22:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R28 + 0x00000006) );
		/* 822578B0h case   22:*/		return 0x822578B4;
		  /* 822578B4h */ case   23:  		/* sth R10, <#[R28 + 8]> */
		/* 822578B4h case   23:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 822578B4h case   23:*/		return 0x822578B8;
		  /* 822578B8h */ case   24:  		/* sth R11, <#[R28 + 10]> */
		/* 822578B8h case   24:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R28 + 0x0000000A) );
		/* 822578B8h case   24:*/		return 0x822578BC;
		  /* 822578BCh */ case   25:  		/* sth R11, <#[R28 + 12]> */
		/* 822578BCh case   25:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 822578BCh case   25:*/		return 0x822578C0;
		  /* 822578C0h */ case   26:  		/* sth R31, <#[R28 + 16]> */
		/* 822578C0h case   26:*/		cpu::mem::store16( regs, regs.R31, (uint32)(regs.R28 + 0x00000010) );
		/* 822578C0h case   26:*/		return 0x822578C4;
		  /* 822578C4h */ case   27:  		/* sth R30, <#[R28 + 18]> */
		/* 822578C4h case   27:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R28 + 0x00000012) );
		/* 822578C4h case   27:*/		return 0x822578C8;
		  /* 822578C8h */ case   28:  		/* sth R31, <#[R28 + 22]> */
		/* 822578C8h case   28:*/		cpu::mem::store16( regs, regs.R31, (uint32)(regs.R28 + 0x00000016) );
		/* 822578C8h case   28:*/		return 0x822578CC;
		  /* 822578CCh */ case   29:  		/* sth R31, <#[R28 + 24]> */
		/* 822578CCh case   29:*/		cpu::mem::store16( regs, regs.R31, (uint32)(regs.R28 + 0x00000018) );
		/* 822578CCh case   29:*/		return 0x822578D0;
	}
	return 0x822578D0;
} // Block from 82257858h-822578D0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 822578D0h
// Function '?AddAnInput@IRInst@XGRAPHICS@@QAAXPAVVRegInfo@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822578D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822578D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822578D0);
		  /* 822578D0h */ case    0:  		/* sth R31, <#[R28 + 26]> */
		/* 822578D0h case    0:*/		cpu::mem::store16( regs, regs.R31, (uint32)(regs.R28 + 0x0000001A) );
		/* 822578D0h case    0:*/		return 0x822578D4;
		  /* 822578D4h */ case    1:  		/* sth R31, <#[R28 + 28]> */
		/* 822578D4h case    1:*/		cpu::mem::store16( regs, regs.R31, (uint32)(regs.R28 + 0x0000001C) );
		/* 822578D4h case    1:*/		return 0x822578D8;
		  /* 822578D8h */ case    2:  		/* sth R31, <#[R28 + 20]> */
		/* 822578D8h case    2:*/		cpu::mem::store16( regs, regs.R31, (uint32)(regs.R28 + 0x00000014) );
		/* 822578D8h case    2:*/		return 0x822578DC;
		  /* 822578DCh */ case    3:  		/* stw R28, <#[R29 + 184]> */
		/* 822578DCh case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + 0x000000B8) );
		/* 822578DCh case    3:*/		return 0x822578E0;
		  /* 822578E0h */ case    4:  		/* addi R1, R1, 128 */
		/* 822578E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822578E0h case    4:*/		return 0x822578E4;
		  /* 822578E4h */ case    5:  		/* b -1861180 */
		/* 822578E4h case    5:*/		return 0x820912A8;
		/* 822578E4h case    5:*/		return 0x822578E8;
	}
	return 0x822578E8;
} // Block from 822578D0h-822578E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822578E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822578E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822578E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822578E8);
		  /* 822578E8h */ case    0:  		/* mfspr R12, LR */
		/* 822578E8h case    0:*/		regs.R12 = regs.LR;
		/* 822578E8h case    0:*/		return 0x822578EC;
		  /* 822578ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822578ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822578ECh case    1:*/		return 0x822578F0;
		  /* 822578F0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822578F0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822578F0h case    2:*/		return 0x822578F4;
		  /* 822578F4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822578F4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822578F4h case    3:*/		return 0x822578F8;
		  /* 822578F8h */ case    4:  		/* mr R31, R3 */
		/* 822578F8h case    4:*/		regs.R31 = regs.R3;
		/* 822578F8h case    4:*/		return 0x822578FC;
		  /* 822578FCh */ case    5:  		/* bl -1924 */
		/* 822578FCh case    5:*/		regs.LR = 0x82257900; return 0x82257178;
		/* 822578FCh case    5:*/		return 0x82257900;
		  /* 82257900h */ case    6:  		/* lis R11, -32252 */
		/* 82257900h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257900h case    6:*/		return 0x82257904;
		  /* 82257904h */ case    7:  		/* li R10, 21 */
		/* 82257904h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x15);
		/* 82257904h case    7:*/		return 0x82257908;
		  /* 82257908h */ case    8:  		/* addi R11, R11, 31904 */
		/* 82257908h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7CA0);
		/* 82257908h case    8:*/		return 0x8225790C;
		  /* 8225790Ch */ case    9:  		/* li R9, 2 */
		/* 8225790Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8225790Ch case    9:*/		return 0x82257910;
		  /* 82257910h */ case   10:  		/* stw R10, <#[R31 + 80]> */
		/* 82257910h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000050) );
		/* 82257910h case   10:*/		return 0x82257914;
		  /* 82257914h */ case   11:  		/* stw R11, <#[R31]> */
		/* 82257914h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82257914h case   11:*/		return 0x82257918;
		  /* 82257918h */ case   12:  		/* mr R3, R31 */
		/* 82257918h case   12:*/		regs.R3 = regs.R31;
		/* 82257918h case   12:*/		return 0x8225791C;
		  /* 8225791Ch */ case   13:  		/* stw R9, <#[R31 + 20]> */
		/* 8225791Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8225791Ch case   13:*/		return 0x82257920;
		  /* 82257920h */ case   14:  		/* addi R1, R1, 96 */
		/* 82257920h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257920h case   14:*/		return 0x82257924;
		  /* 82257924h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257924h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257924h case   15:*/		return 0x82257928;
		  /* 82257928h */ case   16:  		/* mtspr LR, R12 */
		/* 82257928h case   16:*/		regs.LR = regs.R12;
		/* 82257928h case   16:*/		return 0x8225792C;
		  /* 8225792Ch */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 8225792Ch case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225792Ch case   17:*/		return 0x82257930;
		  /* 82257930h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82257930h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257930h case   18:*/		return 0x82257934;
	}
	return 0x82257934;
} // Block from 822578E8h-82257934h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82257934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257934);
		  /* 82257934h */ case    0:  		/* nop */
		/* 82257934h case    0:*/		cpu::op::nop();
		/* 82257934h case    0:*/		return 0x82257938;
	}
	return 0x82257938;
} // Block from 82257934h-82257938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257938);
		  /* 82257938h */ case    0:  		/* li R3, 2 */
		/* 82257938h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82257938h case    0:*/		return 0x8225793C;
		  /* 8225793Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8225793Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225793Ch case    1:*/		return 0x82257940;
	}
	return 0x82257940;
} // Block from 82257938h-82257940h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257940);
		  /* 82257940h */ case    0:  		/* lis R11, -32252 */
		/* 82257940h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257940h case    0:*/		return 0x82257944;
		  /* 82257944h */ case    1:  		/* addi R3, R11, 32008 */
		/* 82257944h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7D08);
		/* 82257944h case    1:*/		return 0x82257948;
		  /* 82257948h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257948h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257948h case    2:*/		return 0x8225794C;
	}
	return 0x8225794C;
} // Block from 82257940h-8225794Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225794Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225794C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225794C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225794C);
		  /* 8225794Ch */ case    0:  		/* nop */
		/* 8225794Ch case    0:*/		cpu::op::nop();
		/* 8225794Ch case    0:*/		return 0x82257950;
	}
	return 0x82257950;
} // Block from 8225794Ch-82257950h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257950);
		  /* 82257950h */ case    0:  		/* mfspr R12, LR */
		/* 82257950h case    0:*/		regs.R12 = regs.LR;
		/* 82257950h case    0:*/		return 0x82257954;
		  /* 82257954h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257954h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257954h case    1:*/		return 0x82257958;
		  /* 82257958h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257958h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257958h case    2:*/		return 0x8225795C;
		  /* 8225795Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225795Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225795Ch case    3:*/		return 0x82257960;
		  /* 82257960h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257960h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257960h case    4:*/		return 0x82257964;
		  /* 82257964h */ case    5:  		/* li R4, 134 */
		/* 82257964h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x86);
		/* 82257964h case    5:*/		return 0x82257968;
		  /* 82257968h */ case    6:  		/* mr R31, R3 */
		/* 82257968h case    6:*/		regs.R31 = regs.R3;
		/* 82257968h case    6:*/		return 0x8225796C;
		  /* 8225796Ch */ case    7:  		/* mr R30, R5 */
		/* 8225796Ch case    7:*/		regs.R30 = regs.R5;
		/* 8225796Ch case    7:*/		return 0x82257970;
		  /* 82257970h */ case    8:  		/* bl -2944 */
		/* 82257970h case    8:*/		regs.LR = 0x82257974; return 0x82256DF0;
		/* 82257970h case    8:*/		return 0x82257974;
		  /* 82257974h */ case    9:  		/* lis R11, -32252 */
		/* 82257974h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257974h case    9:*/		return 0x82257978;
		  /* 82257978h */ case   10:  		/* lis R10, -32252 */
		/* 82257978h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82257978h case   10:*/		return 0x8225797C;
		  /* 8225797Ch */ case   11:  		/* addi R11, R11, 32032 */
		/* 8225797Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7D20);
		/* 8225797Ch case   11:*/		return 0x82257980;
	}
	return 0x82257980;
} // Block from 82257950h-82257980h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82257980h
// Function '?SetConstArg@IRInst@XGRAPHICS@@QAAXPAVCFG@2@HMMMM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257980);
		  /* 82257980h */ case    0:  		/* li R9, 1 */
		/* 82257980h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82257980h case    0:*/		return 0x82257984;
		  /* 82257984h */ case    1:  		/* li R8, 2 */
		/* 82257984h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82257984h case    1:*/		return 0x82257988;
		  /* 82257988h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82257988h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257988h case    2:*/		return 0x8225798C;
		  /* 8225798Ch */ case    3:  		/* stw R9, <#[R3 + 16]> */
		/* 8225798Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 8225798Ch case    3:*/		return 0x82257990;
		  /* 82257990h */ case    4:  		/* li R7, 0 */
		/* 82257990h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82257990h case    4:*/		return 0x82257994;
		  /* 82257994h */ case    5:  		/* stw R8, <#[R3 + 20]> */
		/* 82257994h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 82257994h case    5:*/		return 0x82257998;
		  /* 82257998h */ case    6:  		/* mr R4, R3 */
		/* 82257998h case    6:*/		regs.R4 = regs.R3;
		/* 82257998h case    6:*/		return 0x8225799C;
		  /* 8225799Ch */ case    7:  		/* lwz R11, <#[R10 + 28876]> */
		/* 8225799Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000070CC) );
		/* 8225799Ch case    7:*/		return 0x822579A0;
		  /* 822579A0h */ case    8:  		/* stw R11, <#[R3 + 128]> */
		/* 822579A0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 822579A0h case    8:*/		return 0x822579A4;
		  /* 822579A4h */ case    9:  		/* lwz R11, <#[R3 + 228]> */
		/* 822579A4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 822579A4h case    9:*/		return 0x822579A8;
		  /* 822579A8h */ case   10:  		/* stw R7, <#[R3 + 16]> */
		/* 822579A8h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 822579A8h case   10:*/		return 0x822579AC;
		  /* 822579ACh */ case   11:  		/* ori R11, R11, 24 */
		/* 822579ACh case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x18);
		/* 822579ACh case   11:*/		return 0x822579B0;
		  /* 822579B0h */ case   12:  		/* stw R11, <#[R3 + 228]> */
		/* 822579B0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 822579B0h case   12:*/		return 0x822579B4;
		  /* 822579B4h */ case   13:  		/* lwz R3, <#[R30 + 2736]> */
		/* 822579B4h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000AB0) );
		/* 822579B4h case   13:*/		return 0x822579B8;
		  /* 822579B8h */ case   14:  		/* bl -137664 */
		/* 822579B8h case   14:*/		regs.LR = 0x822579BC; return 0x82235FF8;
		/* 822579B8h case   14:*/		return 0x822579BC;
		  /* 822579BCh */ case   15:  		/* mr R3, R31 */
		/* 822579BCh case   15:*/		regs.R3 = regs.R31;
		/* 822579BCh case   15:*/		return 0x822579C0;
		  /* 822579C0h */ case   16:  		/* addi R1, R1, 112 */
		/* 822579C0h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822579C0h case   16:*/		return 0x822579C4;
		  /* 822579C4h */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 822579C4h case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822579C4h case   17:*/		return 0x822579C8;
		  /* 822579C8h */ case   18:  		/* mtspr LR, R12 */
		/* 822579C8h case   18:*/		regs.LR = regs.R12;
		/* 822579C8h case   18:*/		return 0x822579CC;
		  /* 822579CCh */ case   19:  		/* ld R30, <#[R1 - 24]> */
		/* 822579CCh case   19:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822579CCh case   19:*/		return 0x822579D0;
		  /* 822579D0h */ case   20:  		/* ld R31, <#[R1 - 16]> */
		/* 822579D0h case   20:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822579D0h case   20:*/		return 0x822579D4;
		  /* 822579D4h */ case   21:  		/* bclr 20, CR0_LT */
		/* 822579D4h case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822579D4h case   21:*/		return 0x822579D8;
	}
	return 0x822579D8;
} // Block from 82257980h-822579D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822579D8h
// Function '?SetConstArg@IRInst@XGRAPHICS@@QAAXPAVCFG@2@HUnamed_value@2@111@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822579D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822579D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822579D8);
		  /* 822579D8h */ case    0:  		/* lis R11, -32252 */
		/* 822579D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822579D8h case    0:*/		return 0x822579DC;
		  /* 822579DCh */ case    1:  		/* addi R3, R11, 32136 */
		/* 822579DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7D88);
		/* 822579DCh case    1:*/		return 0x822579E0;
		  /* 822579E0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822579E0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822579E0h case    2:*/		return 0x822579E4;
	}
	return 0x822579E4;
} // Block from 822579D8h-822579E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822579E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822579E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822579E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822579E4);
		  /* 822579E4h */ case    0:  		/* nop */
		/* 822579E4h case    0:*/		cpu::op::nop();
		/* 822579E4h case    0:*/		return 0x822579E8;
	}
	return 0x822579E8;
} // Block from 822579E4h-822579E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822579E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822579E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822579E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822579E8);
		  /* 822579E8h */ case    0:  		/* mfspr R12, LR */
		/* 822579E8h case    0:*/		regs.R12 = regs.LR;
		/* 822579E8h case    0:*/		return 0x822579EC;
		  /* 822579ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822579ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822579ECh case    1:*/		return 0x822579F0;
		  /* 822579F0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822579F0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822579F0h case    2:*/		return 0x822579F4;
		  /* 822579F4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822579F4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822579F4h case    3:*/		return 0x822579F8;
		  /* 822579F8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822579F8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822579F8h case    4:*/		return 0x822579FC;
		  /* 822579FCh */ case    5:  		/* mr R31, R3 */
		/* 822579FCh case    5:*/		regs.R31 = regs.R3;
		/* 822579FCh case    5:*/		return 0x82257A00;
		  /* 82257A00h */ case    6:  		/* mr R30, R5 */
		/* 82257A00h case    6:*/		regs.R30 = regs.R5;
		/* 82257A00h case    6:*/		return 0x82257A04;
		  /* 82257A04h */ case    7:  		/* bl -3092 */
		/* 82257A04h case    7:*/		regs.LR = 0x82257A08; return 0x82256DF0;
		/* 82257A04h case    7:*/		return 0x82257A08;
		  /* 82257A08h */ case    8:  		/* li R11, 1 */
		/* 82257A08h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82257A08h case    8:*/		return 0x82257A0C;
		  /* 82257A0Ch */ case    9:  		/* lis R10, -32252 */
		/* 82257A0Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82257A0Ch case    9:*/		return 0x82257A10;
		  /* 82257A10h */ case   10:  		/* stw R11, <#[R3 + 20]> */
		/* 82257A10h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82257A10h case   10:*/		return 0x82257A14;
		  /* 82257A14h */ case   11:  		/* li R9, 0 */
		/* 82257A14h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82257A14h case   11:*/		return 0x82257A18;
		  /* 82257A18h */ case   12:  		/* stw R11, <#[R3 + 16]> */
		/* 82257A18h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82257A18h case   12:*/		return 0x82257A1C;
		  /* 82257A1Ch */ case   13:  		/* addi R10, R10, 32144 */
		/* 82257A1Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7D90);
		/* 82257A1Ch case   13:*/		return 0x82257A20;
		  /* 82257A20h */ case   14:  		/* stw R9, <#[R3 + 168]> */
		/* 82257A20h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x000000A8) );
		/* 82257A20h case   14:*/		return 0x82257A24;
		  /* 82257A24h */ case   15:  		/* mr R4, R3 */
		/* 82257A24h case   15:*/		regs.R4 = regs.R3;
		/* 82257A24h case   15:*/		return 0x82257A28;
		  /* 82257A28h */ case   16:  		/* stw R10, <#[R3]> */
		/* 82257A28h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82257A28h case   16:*/		return 0x82257A2C;
		  /* 82257A2Ch */ case   17:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257A2Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257A2Ch case   17:*/		return 0x82257A30;
	}
	return 0x82257A30;
} // Block from 822579E8h-82257A30h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82257A30h
// Function '?Kill@IRInst@XGRAPHICS@@UAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257A30);
		  /* 82257A30h */ case    0:  		/* ori R11, R11, 24 */
		/* 82257A30h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82257A30h case    0:*/		return 0x82257A34;
		  /* 82257A34h */ case    1:  		/* stw R11, <#[R3 + 228]> */
		/* 82257A34h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257A34h case    1:*/		return 0x82257A38;
		  /* 82257A38h */ case    2:  		/* lwz R3, <#[R30 + 2736]> */
		/* 82257A38h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82257A38h case    2:*/		return 0x82257A3C;
		  /* 82257A3Ch */ case    3:  		/* bl -137796 */
		/* 82257A3Ch case    3:*/		regs.LR = 0x82257A40; return 0x82235FF8;
		/* 82257A3Ch case    3:*/		return 0x82257A40;
		  /* 82257A40h */ case    4:  		/* mr R3, R31 */
		/* 82257A40h case    4:*/		regs.R3 = regs.R31;
		/* 82257A40h case    4:*/		return 0x82257A44;
		  /* 82257A44h */ case    5:  		/* addi R1, R1, 112 */
		/* 82257A44h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257A44h case    5:*/		return 0x82257A48;
		  /* 82257A48h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257A48h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257A48h case    6:*/		return 0x82257A4C;
		  /* 82257A4Ch */ case    7:  		/* mtspr LR, R12 */
		/* 82257A4Ch case    7:*/		regs.LR = regs.R12;
		/* 82257A4Ch case    7:*/		return 0x82257A50;
		  /* 82257A50h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 82257A50h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257A50h case    8:*/		return 0x82257A54;
		  /* 82257A54h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82257A54h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257A54h case    9:*/		return 0x82257A58;
		  /* 82257A58h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82257A58h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257A58h case   10:*/		return 0x82257A5C;
	}
	return 0x82257A5C;
} // Block from 82257A30h-82257A5Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82257A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257A5C);
		  /* 82257A5Ch */ case    0:  		/* nop */
		/* 82257A5Ch case    0:*/		cpu::op::nop();
		/* 82257A5Ch case    0:*/		return 0x82257A60;
	}
	return 0x82257A60;
} // Block from 82257A5Ch-82257A60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257A60);
		  /* 82257A60h */ case    0:  		/* lis R11, -32252 */
		/* 82257A60h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257A60h case    0:*/		return 0x82257A64;
		  /* 82257A64h */ case    1:  		/* addi R3, R11, 32248 */
		/* 82257A64h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7DF8);
		/* 82257A64h case    1:*/		return 0x82257A68;
		  /* 82257A68h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257A68h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257A68h case    2:*/		return 0x82257A6C;
	}
	return 0x82257A6C;
} // Block from 82257A60h-82257A6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257A6C);
		  /* 82257A6Ch */ case    0:  		/* nop */
		/* 82257A6Ch case    0:*/		cpu::op::nop();
		/* 82257A6Ch case    0:*/		return 0x82257A70;
	}
	return 0x82257A70;
} // Block from 82257A6Ch-82257A70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257A70);
		  /* 82257A70h */ case    0:  		/* mfspr R12, LR */
		/* 82257A70h case    0:*/		regs.R12 = regs.LR;
		/* 82257A70h case    0:*/		return 0x82257A74;
		  /* 82257A74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257A74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257A74h case    1:*/		return 0x82257A78;
		  /* 82257A78h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257A78h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257A78h case    2:*/		return 0x82257A7C;
		  /* 82257A7Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82257A7Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257A7Ch case    3:*/		return 0x82257A80;
		  /* 82257A80h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257A80h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257A80h case    4:*/		return 0x82257A84;
		  /* 82257A84h */ case    5:  		/* mr R31, R3 */
		/* 82257A84h case    5:*/		regs.R31 = regs.R3;
		/* 82257A84h case    5:*/		return 0x82257A88;
		  /* 82257A88h */ case    6:  		/* mr R30, R5 */
		/* 82257A88h case    6:*/		regs.R30 = regs.R5;
		/* 82257A88h case    6:*/		return 0x82257A8C;
		  /* 82257A8Ch */ case    7:  		/* bl -3228 */
		/* 82257A8Ch case    7:*/		regs.LR = 0x82257A90; return 0x82256DF0;
		/* 82257A8Ch case    7:*/		return 0x82257A90;
		  /* 82257A90h */ case    8:  		/* lis R11, -32252 */
		/* 82257A90h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257A90h case    8:*/		return 0x82257A94;
		  /* 82257A94h */ case    9:  		/* li R10, 2 */
		/* 82257A94h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82257A94h case    9:*/		return 0x82257A98;
		  /* 82257A98h */ case   10:  		/* addi R11, R11, 32256 */
		/* 82257A98h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7E00);
		/* 82257A98h case   10:*/		return 0x82257A9C;
		  /* 82257A9Ch */ case   11:  		/* stw R10, <#[R3 + 20]> */
		/* 82257A9Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82257A9Ch case   11:*/		return 0x82257AA0;
		  /* 82257AA0h */ case   12:  		/* li R9, 1 */
		/* 82257AA0h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82257AA0h case   12:*/		return 0x82257AA4;
		  /* 82257AA4h */ case   13:  		/* stw R11, <#[R3]> */
		/* 82257AA4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257AA4h case   13:*/		return 0x82257AA8;
		  /* 82257AA8h */ case   14:  		/* li R10, 0 */
		/* 82257AA8h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257AA8h case   14:*/		return 0x82257AAC;
		  /* 82257AACh */ case   15:  		/* stw R9, <#[R3 + 16]> */
		/* 82257AACh case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82257AACh case   15:*/		return 0x82257AB0;
		  /* 82257AB0h */ case   16:  		/* mr R4, R3 */
		/* 82257AB0h case   16:*/		regs.R4 = regs.R3;
		/* 82257AB0h case   16:*/		return 0x82257AB4;
		  /* 82257AB4h */ case   17:  		/* stw R10, <#[R3 + 168]> */
		/* 82257AB4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x000000A8) );
		/* 82257AB4h case   17:*/		return 0x82257AB8;
		  /* 82257AB8h */ case   18:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257AB8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257AB8h case   18:*/		return 0x82257ABC;
		  /* 82257ABCh */ case   19:  		/* ori R11, R11, 24 */
		/* 82257ABCh case   19:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82257ABCh case   19:*/		return 0x82257AC0;
		  /* 82257AC0h */ case   20:  		/* stw R11, <#[R3 + 228]> */
		/* 82257AC0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257AC0h case   20:*/		return 0x82257AC4;
		  /* 82257AC4h */ case   21:  		/* lwz R3, <#[R30 + 2736]> */
		/* 82257AC4h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82257AC4h case   21:*/		return 0x82257AC8;
		  /* 82257AC8h */ case   22:  		/* bl -137936 */
		/* 82257AC8h case   22:*/		regs.LR = 0x82257ACC; return 0x82235FF8;
		/* 82257AC8h case   22:*/		return 0x82257ACC;
		  /* 82257ACCh */ case   23:  		/* mr R3, R31 */
		/* 82257ACCh case   23:*/		regs.R3 = regs.R31;
		/* 82257ACCh case   23:*/		return 0x82257AD0;
	}
	return 0x82257AD0;
} // Block from 82257A70h-82257AD0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82257AD0h
// Function '??0IRMov@XGRAPHICS@@IAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257AD0);
		  /* 82257AD0h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257AD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257AD0h case    0:*/		return 0x82257AD4;
		  /* 82257AD4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257AD4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257AD4h case    1:*/		return 0x82257AD8;
		  /* 82257AD8h */ case    2:  		/* mtspr LR, R12 */
		/* 82257AD8h case    2:*/		regs.LR = regs.R12;
		/* 82257AD8h case    2:*/		return 0x82257ADC;
		  /* 82257ADCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82257ADCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257ADCh case    3:*/		return 0x82257AE0;
		  /* 82257AE0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82257AE0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257AE0h case    4:*/		return 0x82257AE4;
		  /* 82257AE4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82257AE4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257AE4h case    5:*/		return 0x82257AE8;
	}
	return 0x82257AE8;
} // Block from 82257AD0h-82257AE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82257AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257AE8);
		  /* 82257AE8h */ case    0:  		/* lis R11, -32252 */
		/* 82257AE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257AE8h case    0:*/		return 0x82257AEC;
		  /* 82257AECh */ case    1:  		/* addi R3, R11, 32360 */
		/* 82257AECh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7E68);
		/* 82257AECh case    1:*/		return 0x82257AF0;
		  /* 82257AF0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257AF0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257AF0h case    2:*/		return 0x82257AF4;
	}
	return 0x82257AF4;
} // Block from 82257AE8h-82257AF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257AF4);
		  /* 82257AF4h */ case    0:  		/* nop */
		/* 82257AF4h case    0:*/		cpu::op::nop();
		/* 82257AF4h case    0:*/		return 0x82257AF8;
	}
	return 0x82257AF8;
} // Block from 82257AF4h-82257AF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257AF8);
		  /* 82257AF8h */ case    0:  		/* mfspr R12, LR */
		/* 82257AF8h case    0:*/		regs.R12 = regs.LR;
		/* 82257AF8h case    0:*/		return 0x82257AFC;
		  /* 82257AFCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257AFCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257AFCh case    1:*/		return 0x82257B00;
		  /* 82257B00h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257B00h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257B00h case    2:*/		return 0x82257B04;
		  /* 82257B04h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82257B04h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257B04h case    3:*/		return 0x82257B08;
		  /* 82257B08h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257B08h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257B08h case    4:*/		return 0x82257B0C;
		  /* 82257B0Ch */ case    5:  		/* li R4, 136 */
		/* 82257B0Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x88);
		/* 82257B0Ch case    5:*/		return 0x82257B10;
		  /* 82257B10h */ case    6:  		/* mr R31, R3 */
		/* 82257B10h case    6:*/		regs.R31 = regs.R3;
		/* 82257B10h case    6:*/		return 0x82257B14;
		  /* 82257B14h */ case    7:  		/* mr R30, R5 */
		/* 82257B14h case    7:*/		regs.R30 = regs.R5;
		/* 82257B14h case    7:*/		return 0x82257B18;
		  /* 82257B18h */ case    8:  		/* bl -3368 */
		/* 82257B18h case    8:*/		regs.LR = 0x82257B1C; return 0x82256DF0;
		/* 82257B18h case    8:*/		return 0x82257B1C;
		  /* 82257B1Ch */ case    9:  		/* lis R11, -32252 */
		/* 82257B1Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257B1Ch case    9:*/		return 0x82257B20;
		  /* 82257B20h */ case   10:  		/* li R10, 0 */
		/* 82257B20h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257B20h case   10:*/		return 0x82257B24;
		  /* 82257B24h */ case   11:  		/* addi R11, R11, 32376 */
		/* 82257B24h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7E78);
		/* 82257B24h case   11:*/		return 0x82257B28;
	}
	return 0x82257B28;
} // Block from 82257AF8h-82257B28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82257B28h
// Function '??0IRCopy@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257B28);
		  /* 82257B28h */ case    0:  		/* li R9, 1 */
		/* 82257B28h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82257B28h case    0:*/		return 0x82257B2C;
		  /* 82257B2Ch */ case    1:  		/* stw R10, <#[R3 + 16]> */
		/* 82257B2Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257B2Ch case    1:*/		return 0x82257B30;
		  /* 82257B30h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82257B30h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257B30h case    2:*/		return 0x82257B34;
		  /* 82257B34h */ case    3:  		/* mr R4, R3 */
		/* 82257B34h case    3:*/		regs.R4 = regs.R3;
		/* 82257B34h case    3:*/		return 0x82257B38;
		  /* 82257B38h */ case    4:  		/* stw R9, <#[R3 + 20]> */
		/* 82257B38h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82257B38h case    4:*/		return 0x82257B3C;
		  /* 82257B3Ch */ case    5:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257B3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257B3Ch case    5:*/		return 0x82257B40;
		  /* 82257B40h */ case    6:  		/* ori R11, R11, 24 */
		/* 82257B40h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82257B40h case    6:*/		return 0x82257B44;
		  /* 82257B44h */ case    7:  		/* stw R11, <#[R3 + 228]> */
		/* 82257B44h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257B44h case    7:*/		return 0x82257B48;
		  /* 82257B48h */ case    8:  		/* lwz R3, <#[R30 + 2736]> */
		/* 82257B48h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82257B48h case    8:*/		return 0x82257B4C;
		  /* 82257B4Ch */ case    9:  		/* bl -138068 */
		/* 82257B4Ch case    9:*/		regs.LR = 0x82257B50; return 0x82235FF8;
		/* 82257B4Ch case    9:*/		return 0x82257B50;
		  /* 82257B50h */ case   10:  		/* mr R3, R31 */
		/* 82257B50h case   10:*/		regs.R3 = regs.R31;
		/* 82257B50h case   10:*/		return 0x82257B54;
		  /* 82257B54h */ case   11:  		/* addi R1, R1, 112 */
		/* 82257B54h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257B54h case   11:*/		return 0x82257B58;
		  /* 82257B58h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257B58h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257B58h case   12:*/		return 0x82257B5C;
		  /* 82257B5Ch */ case   13:  		/* mtspr LR, R12 */
		/* 82257B5Ch case   13:*/		regs.LR = regs.R12;
		/* 82257B5Ch case   13:*/		return 0x82257B60;
		  /* 82257B60h */ case   14:  		/* ld R30, <#[R1 - 24]> */
		/* 82257B60h case   14:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257B60h case   14:*/		return 0x82257B64;
		  /* 82257B64h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82257B64h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257B64h case   15:*/		return 0x82257B68;
		  /* 82257B68h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82257B68h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257B68h case   16:*/		return 0x82257B6C;
	}
	return 0x82257B6C;
} // Block from 82257B28h-82257B6Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82257B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257B6C);
		  /* 82257B6Ch */ case    0:  		/* nop */
		/* 82257B6Ch case    0:*/		cpu::op::nop();
		/* 82257B6Ch case    0:*/		return 0x82257B70;
	}
	return 0x82257B70;
} // Block from 82257B6Ch-82257B70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257B70);
		  /* 82257B70h */ case    0:  		/* lis R11, -32252 */
		/* 82257B70h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257B70h case    0:*/		return 0x82257B74;
		  /* 82257B74h */ case    1:  		/* addi R3, R11, 32480 */
		/* 82257B74h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7EE0);
		/* 82257B74h case    1:*/		return 0x82257B78;
	}
	return 0x82257B78;
} // Block from 82257B70h-82257B78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257B78h
// Function '??0IRMovBase@XGRAPHICS@@QAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257B78);
		  /* 82257B78h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82257B78h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257B78h case    0:*/		return 0x82257B7C;
	}
	return 0x82257B7C;
} // Block from 82257B78h-82257B7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257B7C);
		  /* 82257B7Ch */ case    0:  		/* nop */
		/* 82257B7Ch case    0:*/		cpu::op::nop();
		/* 82257B7Ch case    0:*/		return 0x82257B80;
	}
	return 0x82257B80;
} // Block from 82257B7Ch-82257B80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257B80);
		  /* 82257B80h */ case    0:  		/* mfspr R12, LR */
		/* 82257B80h case    0:*/		regs.R12 = regs.LR;
		/* 82257B80h case    0:*/		return 0x82257B84;
		  /* 82257B84h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257B84h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257B84h case    1:*/		return 0x82257B88;
		  /* 82257B88h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82257B88h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257B88h case    2:*/		return 0x82257B8C;
		  /* 82257B8Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82257B8Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257B8Ch case    3:*/		return 0x82257B90;
		  /* 82257B90h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257B90h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257B90h case    4:*/		return 0x82257B94;
		  /* 82257B94h */ case    5:  		/* li R4, 135 */
		/* 82257B94h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x87);
		/* 82257B94h case    5:*/		return 0x82257B98;
		  /* 82257B98h */ case    6:  		/* mr R31, R3 */
		/* 82257B98h case    6:*/		regs.R31 = regs.R3;
		/* 82257B98h case    6:*/		return 0x82257B9C;
		  /* 82257B9Ch */ case    7:  		/* mr R30, R5 */
		/* 82257B9Ch case    7:*/		regs.R30 = regs.R5;
		/* 82257B9Ch case    7:*/		return 0x82257BA0;
		  /* 82257BA0h */ case    8:  		/* bl -3504 */
		/* 82257BA0h case    8:*/		regs.LR = 0x82257BA4; return 0x82256DF0;
		/* 82257BA0h case    8:*/		return 0x82257BA4;
		  /* 82257BA4h */ case    9:  		/* lis R11, -32252 */
		/* 82257BA4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257BA4h case    9:*/		return 0x82257BA8;
		  /* 82257BA8h */ case   10:  		/* li R10, 0 */
		/* 82257BA8h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257BA8h case   10:*/		return 0x82257BAC;
		  /* 82257BACh */ case   11:  		/* addi R11, R11, 32496 */
		/* 82257BACh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7EF0);
		/* 82257BACh case   11:*/		return 0x82257BB0;
		  /* 82257BB0h */ case   12:  		/* li R9, 1 */
		/* 82257BB0h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82257BB0h case   12:*/		return 0x82257BB4;
		  /* 82257BB4h */ case   13:  		/* stw R10, <#[R3 + 16]> */
		/* 82257BB4h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257BB4h case   13:*/		return 0x82257BB8;
		  /* 82257BB8h */ case   14:  		/* stw R11, <#[R3]> */
		/* 82257BB8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257BB8h case   14:*/		return 0x82257BBC;
		  /* 82257BBCh */ case   15:  		/* mr R4, R3 */
		/* 82257BBCh case   15:*/		regs.R4 = regs.R3;
		/* 82257BBCh case   15:*/		return 0x82257BC0;
		  /* 82257BC0h */ case   16:  		/* stw R9, <#[R3 + 20]> */
		/* 82257BC0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82257BC0h case   16:*/		return 0x82257BC4;
		  /* 82257BC4h */ case   17:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257BC4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257BC4h case   17:*/		return 0x82257BC8;
		  /* 82257BC8h */ case   18:  		/* ori R11, R11, 24 */
		/* 82257BC8h case   18:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82257BC8h case   18:*/		return 0x82257BCC;
		  /* 82257BCCh */ case   19:  		/* stw R11, <#[R3 + 228]> */
		/* 82257BCCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257BCCh case   19:*/		return 0x82257BD0;
	}
	return 0x82257BD0;
} // Block from 82257B80h-82257BD0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82257BD0h
// Function '?InstType@IRMovBase@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257BD0);
		  /* 82257BD0h */ case    0:  		/* lwz R3, <#[R30 + 2736]> */
		/* 82257BD0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000AB0) );
		/* 82257BD0h case    0:*/		return 0x82257BD4;
		  /* 82257BD4h */ case    1:  		/* bl -138204 */
		/* 82257BD4h case    1:*/		regs.LR = 0x82257BD8; return 0x82235FF8;
		/* 82257BD4h case    1:*/		return 0x82257BD8;
		  /* 82257BD8h */ case    2:  		/* mr R3, R31 */
		/* 82257BD8h case    2:*/		regs.R3 = regs.R31;
		/* 82257BD8h case    2:*/		return 0x82257BDC;
		  /* 82257BDCh */ case    3:  		/* addi R1, R1, 112 */
		/* 82257BDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257BDCh case    3:*/		return 0x82257BE0;
	}
	return 0x82257BE0;
} // Block from 82257BD0h-82257BE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257BE0h
// Function '??0IRExport@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257BE0);
		  /* 82257BE0h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257BE0h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257BE0h case    0:*/		return 0x82257BE4;
		  /* 82257BE4h */ case    1:  		/* mtspr LR, R12 */
		/* 82257BE4h case    1:*/		regs.LR = regs.R12;
		/* 82257BE4h case    1:*/		return 0x82257BE8;
		  /* 82257BE8h */ case    2:  		/* ld R30, <#[R1 - 24]> */
		/* 82257BE8h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82257BE8h case    2:*/		return 0x82257BEC;
		  /* 82257BECh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82257BECh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257BECh case    3:*/		return 0x82257BF0;
		  /* 82257BF0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82257BF0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257BF0h case    4:*/		return 0x82257BF4;
	}
	return 0x82257BF4;
} // Block from 82257BE0h-82257BF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82257BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257BF4);
		  /* 82257BF4h */ case    0:  		/* nop */
		/* 82257BF4h case    0:*/		cpu::op::nop();
		/* 82257BF4h case    0:*/		return 0x82257BF8;
	}
	return 0x82257BF8;
} // Block from 82257BF4h-82257BF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257BF8);
		  /* 82257BF8h */ case    0:  		/* lis R11, -32252 */
		/* 82257BF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257BF8h case    0:*/		return 0x82257BFC;
		  /* 82257BFCh */ case    1:  		/* addi R3, R11, 32600 */
		/* 82257BFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7F58);
		/* 82257BFCh case    1:*/		return 0x82257C00;
		  /* 82257C00h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82257C00h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257C00h case    2:*/		return 0x82257C04;
	}
	return 0x82257C04;
} // Block from 82257BF8h-82257C04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257C04);
		  /* 82257C04h */ case    0:  		/* nop */
		/* 82257C04h case    0:*/		cpu::op::nop();
		/* 82257C04h case    0:*/		return 0x82257C08;
	}
	return 0x82257C08;
} // Block from 82257C04h-82257C08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257C08);
		  /* 82257C08h */ case    0:  		/* mfspr R12, LR */
		/* 82257C08h case    0:*/		regs.R12 = regs.LR;
		/* 82257C08h case    0:*/		return 0x82257C0C;
		  /* 82257C0Ch */ case    1:  		/* bl -1862064 */
		/* 82257C0Ch case    1:*/		regs.LR = 0x82257C10; return 0x8209125C;
		/* 82257C0Ch case    1:*/		return 0x82257C10;
		  /* 82257C10h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257C10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257C10h case    2:*/		return 0x82257C14;
		  /* 82257C14h */ case    3:  		/* mr R30, R4 */
		/* 82257C14h case    3:*/		regs.R30 = regs.R4;
		/* 82257C14h case    3:*/		return 0x82257C18;
		  /* 82257C18h */ case    4:  		/* mr R29, R5 */
		/* 82257C18h case    4:*/		regs.R29 = regs.R5;
		/* 82257C18h case    4:*/		return 0x82257C1C;
		  /* 82257C1Ch */ case    5:  		/* mr R5, R6 */
		/* 82257C1Ch case    5:*/		regs.R5 = regs.R6;
		/* 82257C1Ch case    5:*/		return 0x82257C20;
		  /* 82257C20h */ case    6:  		/* li R4, 139 */
		/* 82257C20h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x8B);
		/* 82257C20h case    6:*/		return 0x82257C24;
		  /* 82257C24h */ case    7:  		/* mr R31, R3 */
		/* 82257C24h case    7:*/		regs.R31 = regs.R3;
		/* 82257C24h case    7:*/		return 0x82257C28;
		  /* 82257C28h */ case    8:  		/* bl -3640 */
		/* 82257C28h case    8:*/		regs.LR = 0x82257C2C; return 0x82256DF0;
		/* 82257C28h case    8:*/		return 0x82257C2C;
		  /* 82257C2Ch */ case    9:  		/* lis R11, -32252 */
		/* 82257C2Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257C2Ch case    9:*/		return 0x82257C30;
		  /* 82257C30h */ case   10:  		/* li R10, 0 */
		/* 82257C30h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257C30h case   10:*/		return 0x82257C34;
		  /* 82257C34h */ case   11:  		/* stw R30, <#[R3 + 168]> */
		/* 82257C34h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x000000A8) );
		/* 82257C34h case   11:*/		return 0x82257C38;
		  /* 82257C38h */ case   12:  		/* addi R11, R11, 32616 */
		/* 82257C38h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7F68);
		/* 82257C38h case   12:*/		return 0x82257C3C;
		  /* 82257C3Ch */ case   13:  		/* stw R29, <#[R3 + 172]> */
		/* 82257C3Ch case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x000000AC) );
		/* 82257C3Ch case   13:*/		return 0x82257C40;
		  /* 82257C40h */ case   14:  		/* stw R10, <#[R3 + 16]> */
		/* 82257C40h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257C40h case   14:*/		return 0x82257C44;
		  /* 82257C44h */ case   15:  		/* stw R11, <#[R3]> */
		/* 82257C44h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257C44h case   15:*/		return 0x82257C48;
		  /* 82257C48h */ case   16:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257C48h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257C48h case   16:*/		return 0x82257C4C;
		  /* 82257C4Ch */ case   17:  		/* ori R11, R11, 256 */
		/* 82257C4Ch case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82257C4Ch case   17:*/		return 0x82257C50;
	}
	return 0x82257C50;
} // Block from 82257C08h-82257C50h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82257C50h
// Function '?InstType@IRExport@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257C50);
		  /* 82257C50h */ case    0:  		/* stw R11, <#[R3 + 228]> */
		/* 82257C50h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257C50h case    0:*/		return 0x82257C54;
		  /* 82257C54h */ case    1:  		/* addi R1, R1, 112 */
		/* 82257C54h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257C54h case    1:*/		return 0x82257C58;
		  /* 82257C58h */ case    2:  		/* b -1862060 */
		/* 82257C58h case    2:*/		return 0x820912AC;
		/* 82257C58h case    2:*/		return 0x82257C5C;
		  /* 82257C5Ch */ case    3:  		/* nop */
		/* 82257C5Ch case    3:*/		cpu::op::nop();
		/* 82257C5Ch case    3:*/		return 0x82257C60;
	}
	return 0x82257C60;
} // Block from 82257C50h-82257C60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257C60h
// Function '??0IRExportZeroOne@XGRAPHICS@@QAA@PAVVRegInfo@1@TSwizzleOrMaskInfo@1@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257C60);
		  /* 82257C60h */ case    0:  		/* mfspr R12, LR */
		/* 82257C60h case    0:*/		regs.R12 = regs.LR;
		/* 82257C60h case    0:*/		return 0x82257C64;
		  /* 82257C64h */ case    1:  		/* bl -1862152 */
		/* 82257C64h case    1:*/		regs.LR = 0x82257C68; return 0x8209125C;
		/* 82257C64h case    1:*/		return 0x82257C68;
		  /* 82257C68h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257C68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257C68h case    2:*/		return 0x82257C6C;
		  /* 82257C6Ch */ case    3:  		/* mr R30, R4 */
		/* 82257C6Ch case    3:*/		regs.R30 = regs.R4;
		/* 82257C6Ch case    3:*/		return 0x82257C70;
		  /* 82257C70h */ case    4:  		/* mr R29, R5 */
		/* 82257C70h case    4:*/		regs.R29 = regs.R5;
		/* 82257C70h case    4:*/		return 0x82257C74;
		  /* 82257C74h */ case    5:  		/* mr R5, R6 */
		/* 82257C74h case    5:*/		regs.R5 = regs.R6;
		/* 82257C74h case    5:*/		return 0x82257C78;
		  /* 82257C78h */ case    6:  		/* li R4, 138 */
		/* 82257C78h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x8A);
		/* 82257C78h case    6:*/		return 0x82257C7C;
		  /* 82257C7Ch */ case    7:  		/* mr R31, R3 */
		/* 82257C7Ch case    7:*/		regs.R31 = regs.R3;
		/* 82257C7Ch case    7:*/		return 0x82257C80;
		  /* 82257C80h */ case    8:  		/* bl -3728 */
		/* 82257C80h case    8:*/		regs.LR = 0x82257C84; return 0x82256DF0;
		/* 82257C80h case    8:*/		return 0x82257C84;
		  /* 82257C84h */ case    9:  		/* lis R11, -32252 */
		/* 82257C84h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257C84h case    9:*/		return 0x82257C88;
		  /* 82257C88h */ case   10:  		/* li R10, 0 */
		/* 82257C88h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257C88h case   10:*/		return 0x82257C8C;
		  /* 82257C8Ch */ case   11:  		/* stw R30, <#[R3 + 168]> */
		/* 82257C8Ch case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x000000A8) );
		/* 82257C8Ch case   11:*/		return 0x82257C90;
		  /* 82257C90h */ case   12:  		/* addi R11, R11, 32720 */
		/* 82257C90h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7FD0);
		/* 82257C90h case   12:*/		return 0x82257C94;
		  /* 82257C94h */ case   13:  		/* stw R29, <#[R3 + 172]> */
		/* 82257C94h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x000000AC) );
		/* 82257C94h case   13:*/		return 0x82257C98;
		  /* 82257C98h */ case   14:  		/* stw R10, <#[R3 + 16]> */
		/* 82257C98h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257C98h case   14:*/		return 0x82257C9C;
		  /* 82257C9Ch */ case   15:  		/* stw R11, <#[R3]> */
		/* 82257C9Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257C9Ch case   15:*/		return 0x82257CA0;
		  /* 82257CA0h */ case   16:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257CA0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257CA0h case   16:*/		return 0x82257CA4;
		  /* 82257CA4h */ case   17:  		/* ori R11, R11, 256 */
		/* 82257CA4h case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82257CA4h case   17:*/		return 0x82257CA8;
		  /* 82257CA8h */ case   18:  		/* stw R11, <#[R3 + 228]> */
		/* 82257CA8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257CA8h case   18:*/		return 0x82257CAC;
		  /* 82257CACh */ case   19:  		/* addi R1, R1, 112 */
		/* 82257CACh case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257CACh case   19:*/		return 0x82257CB0;
		  /* 82257CB0h */ case   20:  		/* b -1862148 */
		/* 82257CB0h case   20:*/		return 0x820912AC;
		/* 82257CB0h case   20:*/		return 0x82257CB4;
		  /* 82257CB4h */ case   21:  		/* nop */
		/* 82257CB4h case   21:*/		cpu::op::nop();
		/* 82257CB4h case   21:*/		return 0x82257CB8;
	}
	return 0x82257CB8;
} // Block from 82257C60h-82257CB8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82257CB8h
// Function '?InstType@IRExportZeroOne@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257CB8);
		  /* 82257CB8h */ case    0:  		/* mfspr R12, LR */
		/* 82257CB8h case    0:*/		regs.R12 = regs.LR;
		/* 82257CB8h case    0:*/		return 0x82257CBC;
		  /* 82257CBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257CBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257CBCh case    1:*/		return 0x82257CC0;
		  /* 82257CC0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257CC0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257CC0h case    2:*/		return 0x82257CC4;
		  /* 82257CC4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82257CC4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82257CC4h case    3:*/		return 0x82257CC8;
	}
	return 0x82257CC8;
} // Block from 82257CB8h-82257CC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257CC8h
// Function '?InstType@IRPseudo@XGRAPHICS@@MBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257CC8);
		  /* 82257CC8h */ case    0:  		/* mr R5, R4 */
		/* 82257CC8h case    0:*/		regs.R5 = regs.R4;
		/* 82257CC8h case    0:*/		return 0x82257CCC;
		  /* 82257CCCh */ case    1:  		/* li R4, 141 */
		/* 82257CCCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x8D);
		/* 82257CCCh case    1:*/		return 0x82257CD0;
		  /* 82257CD0h */ case    2:  		/* mr R31, R3 */
		/* 82257CD0h case    2:*/		regs.R31 = regs.R3;
		/* 82257CD0h case    2:*/		return 0x82257CD4;
		  /* 82257CD4h */ case    3:  		/* bl -3812 */
		/* 82257CD4h case    3:*/		regs.LR = 0x82257CD8; return 0x82256DF0;
		/* 82257CD4h case    3:*/		return 0x82257CD8;
	}
	return 0x82257CD8;
} // Block from 82257CC8h-82257CD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257CD8h
// Function '??0IREntry@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257CD8);
		  /* 82257CD8h */ case    0:  		/* lis R11, -32251 */
		/* 82257CD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82257CD8h case    0:*/		return 0x82257CDC;
		  /* 82257CDCh */ case    1:  		/* li R10, 0 */
		/* 82257CDCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257CDCh case    1:*/		return 0x82257CE0;
		  /* 82257CE0h */ case    2:  		/* addi R11, R11, -32712 */
		/* 82257CE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8038);
		/* 82257CE0h case    2:*/		return 0x82257CE4;
		  /* 82257CE4h */ case    3:  		/* stw R10, <#[R3 + 16]> */
		/* 82257CE4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257CE4h case    3:*/		return 0x82257CE8;
		  /* 82257CE8h */ case    4:  		/* stw R11, <#[R3]> */
		/* 82257CE8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257CE8h case    4:*/		return 0x82257CEC;
		  /* 82257CECh */ case    5:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257CECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257CECh case    5:*/		return 0x82257CF0;
		  /* 82257CF0h */ case    6:  		/* ori R11, R11, 256 */
		/* 82257CF0h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82257CF0h case    6:*/		return 0x82257CF4;
		  /* 82257CF4h */ case    7:  		/* stw R11, <#[R3 + 228]> */
		/* 82257CF4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257CF4h case    7:*/		return 0x82257CF8;
		  /* 82257CF8h */ case    8:  		/* addi R1, R1, 96 */
		/* 82257CF8h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257CF8h case    8:*/		return 0x82257CFC;
		  /* 82257CFCh */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257CFCh case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257CFCh case    9:*/		return 0x82257D00;
		  /* 82257D00h */ case   10:  		/* mtspr LR, R12 */
		/* 82257D00h case   10:*/		regs.LR = regs.R12;
		/* 82257D00h case   10:*/		return 0x82257D04;
		  /* 82257D04h */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 82257D04h case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257D04h case   11:*/		return 0x82257D08;
		  /* 82257D08h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82257D08h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257D08h case   12:*/		return 0x82257D0C;
	}
	return 0x82257D0C;
} // Block from 82257CD8h-82257D0Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82257D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D0C);
		  /* 82257D0Ch */ case    0:  		/* nop */
		/* 82257D0Ch case    0:*/		cpu::op::nop();
		/* 82257D0Ch case    0:*/		return 0x82257D10;
	}
	return 0x82257D10;
} // Block from 82257D0Ch-82257D10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D10);
		  /* 82257D10h */ case    0:  		/* mfspr R12, LR */
		/* 82257D10h case    0:*/		regs.R12 = regs.LR;
		/* 82257D10h case    0:*/		return 0x82257D14;
		  /* 82257D14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82257D14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257D14h case    1:*/		return 0x82257D18;
		  /* 82257D18h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82257D18h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257D18h case    2:*/		return 0x82257D1C;
		  /* 82257D1Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82257D1Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82257D1Ch case    3:*/		return 0x82257D20;
	}
	return 0x82257D20;
} // Block from 82257D10h-82257D20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257D20h
// Function '?InstType@IREntry@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D20);
		  /* 82257D20h */ case    0:  		/* mr R5, R4 */
		/* 82257D20h case    0:*/		regs.R5 = regs.R4;
		/* 82257D20h case    0:*/		return 0x82257D24;
		  /* 82257D24h */ case    1:  		/* li R4, 140 */
		/* 82257D24h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x8C);
		/* 82257D24h case    1:*/		return 0x82257D28;
		  /* 82257D28h */ case    2:  		/* mr R31, R3 */
		/* 82257D28h case    2:*/		regs.R31 = regs.R3;
		/* 82257D28h case    2:*/		return 0x82257D2C;
		  /* 82257D2Ch */ case    3:  		/* bl -3900 */
		/* 82257D2Ch case    3:*/		regs.LR = 0x82257D30; return 0x82256DF0;
		/* 82257D2Ch case    3:*/		return 0x82257D30;
	}
	return 0x82257D30;
} // Block from 82257D20h-82257D30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257D30h
// Function '??0IRExit@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D30);
		  /* 82257D30h */ case    0:  		/* lis R11, -32251 */
		/* 82257D30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82257D30h case    0:*/		return 0x82257D34;
		  /* 82257D34h */ case    1:  		/* li R10, 0 */
		/* 82257D34h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257D34h case    1:*/		return 0x82257D38;
		  /* 82257D38h */ case    2:  		/* addi R11, R11, -32608 */
		/* 82257D38h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF80A0);
		/* 82257D38h case    2:*/		return 0x82257D3C;
		  /* 82257D3Ch */ case    3:  		/* stw R10, <#[R3 + 16]> */
		/* 82257D3Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257D3Ch case    3:*/		return 0x82257D40;
		  /* 82257D40h */ case    4:  		/* stw R11, <#[R3]> */
		/* 82257D40h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257D40h case    4:*/		return 0x82257D44;
		  /* 82257D44h */ case    5:  		/* lwz R11, <#[R3 + 228]> */
		/* 82257D44h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257D44h case    5:*/		return 0x82257D48;
		  /* 82257D48h */ case    6:  		/* ori R11, R11, 256 */
		/* 82257D48h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82257D48h case    6:*/		return 0x82257D4C;
		  /* 82257D4Ch */ case    7:  		/* stw R11, <#[R3 + 228]> */
		/* 82257D4Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82257D4Ch case    7:*/		return 0x82257D50;
		  /* 82257D50h */ case    8:  		/* addi R1, R1, 96 */
		/* 82257D50h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82257D50h case    8:*/		return 0x82257D54;
		  /* 82257D54h */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82257D54h case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82257D54h case    9:*/		return 0x82257D58;
		  /* 82257D58h */ case   10:  		/* mtspr LR, R12 */
		/* 82257D58h case   10:*/		regs.LR = regs.R12;
		/* 82257D58h case   10:*/		return 0x82257D5C;
		  /* 82257D5Ch */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 82257D5Ch case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82257D5Ch case   11:*/		return 0x82257D60;
		  /* 82257D60h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82257D60h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82257D60h case   12:*/		return 0x82257D64;
	}
	return 0x82257D64;
} // Block from 82257D30h-82257D64h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82257D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D64);
		  /* 82257D64h */ case    0:  		/* nop */
		/* 82257D64h case    0:*/		cpu::op::nop();
		/* 82257D64h case    0:*/		return 0x82257D68;
	}
	return 0x82257D68;
} // Block from 82257D64h-82257D68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257D68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D68);
		  /* 82257D68h */ case    0:  		/* mfspr R12, LR */
		/* 82257D68h case    0:*/		regs.R12 = regs.LR;
		/* 82257D68h case    0:*/		return 0x82257D6C;
		  /* 82257D6Ch */ case    1:  		/* bl -1862416 */
		/* 82257D6Ch case    1:*/		regs.LR = 0x82257D70; return 0x8209125C;
		/* 82257D6Ch case    1:*/		return 0x82257D70;
		  /* 82257D70h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257D70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257D70h case    2:*/		return 0x82257D74;
		  /* 82257D74h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257D74h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257D74h case    3:*/		return 0x82257D78;
	}
	return 0x82257D78;
} // Block from 82257D68h-82257D78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257D78h
// Function '?InstType@IRExit@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D78);
		  /* 82257D78h */ case    0:  		/* mr R30, R3 */
		/* 82257D78h case    0:*/		regs.R30 = regs.R3;
		/* 82257D78h case    0:*/		return 0x82257D7C;
		  /* 82257D7Ch */ case    1:  		/* mr R31, R4 */
		/* 82257D7Ch case    1:*/		regs.R31 = regs.R4;
		/* 82257D7Ch case    1:*/		return 0x82257D80;
		  /* 82257D80h */ case    2:  		/* li R4, 964 */
		/* 82257D80h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257D80h case    2:*/		return 0x82257D84;
		  /* 82257D84h */ case    3:  		/* mr R3, R29 */
		/* 82257D84h case    3:*/		regs.R3 = regs.R29;
		/* 82257D84h case    3:*/		return 0x82257D88;
	}
	return 0x82257D88;
} // Block from 82257D78h-82257D88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257D88h
// Function '??0IRLoadConst@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257D88);
		  /* 82257D88h */ case    0:  		/* bl -243920 */
		/* 82257D88h case    0:*/		regs.LR = 0x82257D8C; return 0x8221C4B8;
		/* 82257D88h case    0:*/		return 0x82257D8C;
		  /* 82257D8Ch */ case    1:  		/* mr R11, R3 */
		/* 82257D8Ch case    1:*/		regs.R11 = regs.R3;
		/* 82257D8Ch case    1:*/		return 0x82257D90;
		  /* 82257D90h */ case    2:  		/* addic. R3, R3, 4 */
		/* 82257D90h case    2:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257D90h case    2:*/		return 0x82257D94;
		  /* 82257D94h */ case    3:  		/* stw R29, <#[R11]> */
		/* 82257D94h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257D94h case    3:*/		return 0x82257D98;
		  /* 82257D98h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82257D98h case    4:*/		if ( regs.CR[0].eq ) { return 0x82257DAC;  }
		/* 82257D98h case    4:*/		return 0x82257D9C;
		  /* 82257D9Ch */ case    5:  		/* mr R5, R31 */
		/* 82257D9Ch case    5:*/		regs.R5 = regs.R31;
		/* 82257D9Ch case    5:*/		return 0x82257DA0;
		  /* 82257DA0h */ case    6:  		/* mr R4, R30 */
		/* 82257DA0h case    6:*/		regs.R4 = regs.R30;
		/* 82257DA0h case    6:*/		return 0x82257DA4;
		  /* 82257DA4h */ case    7:  		/* bl -3388 */
		/* 82257DA4h case    7:*/		regs.LR = 0x82257DA8; return 0x82257068;
		/* 82257DA4h case    7:*/		return 0x82257DA8;
		  /* 82257DA8h */ case    8:  		/* b 8 */
		/* 82257DA8h case    8:*/		return 0x82257DB0;
		/* 82257DA8h case    8:*/		return 0x82257DAC;
	}
	return 0x82257DAC;
} // Block from 82257D88h-82257DACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82257DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257DAC);
		  /* 82257DACh */ case    0:  		/* li R3, 0 */
		/* 82257DACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257DACh case    0:*/		return 0x82257DB0;
	}
	return 0x82257DB0;
} // Block from 82257DACh-82257DB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257DB0);
		  /* 82257DB0h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257DB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257DB0h case    0:*/		return 0x82257DB4;
		  /* 82257DB4h */ case    1:  		/* b -1862408 */
		/* 82257DB4h case    1:*/		return 0x820912AC;
		/* 82257DB4h case    1:*/		return 0x82257DB8;
	}
	return 0x82257DB8;
} // Block from 82257DB0h-82257DB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257DB8);
		  /* 82257DB8h */ case    0:  		/* mfspr R12, LR */
		/* 82257DB8h case    0:*/		regs.R12 = regs.LR;
		/* 82257DB8h case    0:*/		return 0x82257DBC;
		  /* 82257DBCh */ case    1:  		/* bl -1862496 */
		/* 82257DBCh case    1:*/		regs.LR = 0x82257DC0; return 0x8209125C;
		/* 82257DBCh case    1:*/		return 0x82257DC0;
		  /* 82257DC0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257DC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257DC0h case    2:*/		return 0x82257DC4;
		  /* 82257DC4h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257DC4h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257DC4h case    3:*/		return 0x82257DC8;
		  /* 82257DC8h */ case    4:  		/* mr R30, R3 */
		/* 82257DC8h case    4:*/		regs.R30 = regs.R3;
		/* 82257DC8h case    4:*/		return 0x82257DCC;
		  /* 82257DCCh */ case    5:  		/* mr R31, R4 */
		/* 82257DCCh case    5:*/		regs.R31 = regs.R4;
		/* 82257DCCh case    5:*/		return 0x82257DD0;
		  /* 82257DD0h */ case    6:  		/* li R4, 964 */
		/* 82257DD0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257DD0h case    6:*/		return 0x82257DD4;
		  /* 82257DD4h */ case    7:  		/* mr R3, R29 */
		/* 82257DD4h case    7:*/		regs.R3 = regs.R29;
		/* 82257DD4h case    7:*/		return 0x82257DD8;
		  /* 82257DD8h */ case    8:  		/* bl -244000 */
		/* 82257DD8h case    8:*/		regs.LR = 0x82257DDC; return 0x8221C4B8;
		/* 82257DD8h case    8:*/		return 0x82257DDC;
		  /* 82257DDCh */ case    9:  		/* mr R11, R3 */
		/* 82257DDCh case    9:*/		regs.R11 = regs.R3;
		/* 82257DDCh case    9:*/		return 0x82257DE0;
	}
	return 0x82257DE0;
} // Block from 82257DB8h-82257DE0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82257DE0h
// Function '?InstType@IRLoadConst@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257DE0);
		  /* 82257DE0h */ case    0:  		/* addic. R3, R3, 4 */
		/* 82257DE0h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257DE0h case    0:*/		return 0x82257DE4;
		  /* 82257DE4h */ case    1:  		/* stw R29, <#[R11]> */
		/* 82257DE4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257DE4h case    1:*/		return 0x82257DE8;
		  /* 82257DE8h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 82257DE8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82257DFC;  }
		/* 82257DE8h case    2:*/		return 0x82257DEC;
		  /* 82257DECh */ case    3:  		/* mr R5, R31 */
		/* 82257DECh case    3:*/		regs.R5 = regs.R31;
		/* 82257DECh case    3:*/		return 0x82257DF0;
	}
	return 0x82257DF0;
} // Block from 82257DE0h-82257DF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82257DF0h
// Function '??0IRLoadConst@XGRAPHICS@@QAA@PAVVRegInfo@1@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257DF0);
		  /* 82257DF0h */ case    0:  		/* mr R4, R30 */
		/* 82257DF0h case    0:*/		regs.R4 = regs.R30;
		/* 82257DF0h case    0:*/		return 0x82257DF4;
		  /* 82257DF4h */ case    1:  		/* bl -3300 */
		/* 82257DF4h case    1:*/		regs.LR = 0x82257DF8; return 0x82257110;
		/* 82257DF4h case    1:*/		return 0x82257DF8;
		  /* 82257DF8h */ case    2:  		/* b 8 */
		/* 82257DF8h case    2:*/		return 0x82257E00;
		/* 82257DF8h case    2:*/		return 0x82257DFC;
	}
	return 0x82257DFC;
} // Block from 82257DF0h-82257DFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257DFC);
		  /* 82257DFCh */ case    0:  		/* li R3, 0 */
		/* 82257DFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257DFCh case    0:*/		return 0x82257E00;
	}
	return 0x82257E00;
} // Block from 82257DFCh-82257E00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257E00);
		  /* 82257E00h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257E00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257E00h case    0:*/		return 0x82257E04;
		  /* 82257E04h */ case    1:  		/* b -1862488 */
		/* 82257E04h case    1:*/		return 0x820912AC;
		/* 82257E04h case    1:*/		return 0x82257E08;
	}
	return 0x82257E08;
} // Block from 82257E00h-82257E08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257E08);
		  /* 82257E08h */ case    0:  		/* mfspr R12, LR */
		/* 82257E08h case    0:*/		regs.R12 = regs.LR;
		/* 82257E08h case    0:*/		return 0x82257E0C;
		  /* 82257E0Ch */ case    1:  		/* bl -1862576 */
		/* 82257E0Ch case    1:*/		regs.LR = 0x82257E10; return 0x8209125C;
		/* 82257E0Ch case    1:*/		return 0x82257E10;
		  /* 82257E10h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257E10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257E10h case    2:*/		return 0x82257E14;
		  /* 82257E14h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257E14h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257E14h case    3:*/		return 0x82257E18;
		  /* 82257E18h */ case    4:  		/* mr R30, R3 */
		/* 82257E18h case    4:*/		regs.R30 = regs.R3;
		/* 82257E18h case    4:*/		return 0x82257E1C;
		  /* 82257E1Ch */ case    5:  		/* mr R31, R4 */
		/* 82257E1Ch case    5:*/		regs.R31 = regs.R4;
		/* 82257E1Ch case    5:*/		return 0x82257E20;
		  /* 82257E20h */ case    6:  		/* li R4, 964 */
		/* 82257E20h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257E20h case    6:*/		return 0x82257E24;
		  /* 82257E24h */ case    7:  		/* mr R3, R29 */
		/* 82257E24h case    7:*/		regs.R3 = regs.R29;
		/* 82257E24h case    7:*/		return 0x82257E28;
		  /* 82257E28h */ case    8:  		/* bl -244080 */
		/* 82257E28h case    8:*/		regs.LR = 0x82257E2C; return 0x8221C4B8;
		/* 82257E28h case    8:*/		return 0x82257E2C;
		  /* 82257E2Ch */ case    9:  		/* mr R11, R3 */
		/* 82257E2Ch case    9:*/		regs.R11 = regs.R3;
		/* 82257E2Ch case    9:*/		return 0x82257E30;
		  /* 82257E30h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82257E30h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257E30h case   10:*/		return 0x82257E34;
		  /* 82257E34h */ case   11:  		/* stw R29, <#[R11]> */
		/* 82257E34h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257E34h case   11:*/		return 0x82257E38;
		  /* 82257E38h */ case   12:  		/* bc 12, CR0_EQ, 48 */
		/* 82257E38h case   12:*/		if ( regs.CR[0].eq ) { return 0x82257E68;  }
		/* 82257E38h case   12:*/		return 0x82257E3C;
		  /* 82257E3Ch */ case   13:  		/* mr R5, R31 */
		/* 82257E3Ch case   13:*/		regs.R5 = regs.R31;
		/* 82257E3Ch case   13:*/		return 0x82257E40;
		  /* 82257E40h */ case   14:  		/* mr R4, R30 */
		/* 82257E40h case   14:*/		regs.R4 = regs.R30;
		/* 82257E40h case   14:*/		return 0x82257E44;
		  /* 82257E44h */ case   15:  		/* bl -4180 */
		/* 82257E44h case   15:*/		regs.LR = 0x82257E48; return 0x82256DF0;
		/* 82257E44h case   15:*/		return 0x82257E48;
		  /* 82257E48h */ case   16:  		/* li R10, 1 */
		/* 82257E48h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82257E48h case   16:*/		return 0x82257E4C;
		  /* 82257E4Ch */ case   17:  		/* lis R11, -32252 */
		/* 82257E4Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82257E4Ch case   17:*/		return 0x82257E50;
		  /* 82257E50h */ case   18:  		/* stw R10, <#[R3 + 16]> */
		/* 82257E50h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82257E50h case   18:*/		return 0x82257E54;
		  /* 82257E54h */ case   19:  		/* li R10, 0 */
		/* 82257E54h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82257E54h case   19:*/		return 0x82257E58;
		  /* 82257E58h */ case   20:  		/* addi R11, R11, 29312 */
		/* 82257E58h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7280);
		/* 82257E58h case   20:*/		return 0x82257E5C;
		  /* 82257E5Ch */ case   21:  		/* stw R10, <#[R3 + 20]> */
		/* 82257E5Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82257E5Ch case   21:*/		return 0x82257E60;
		  /* 82257E60h */ case   22:  		/* stw R11, <#[R3]> */
		/* 82257E60h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82257E60h case   22:*/		return 0x82257E64;
		  /* 82257E64h */ case   23:  		/* b 8 */
		/* 82257E64h case   23:*/		return 0x82257E6C;
		/* 82257E64h case   23:*/		return 0x82257E68;
	}
	return 0x82257E68;
} // Block from 82257E08h-82257E68h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82257E68h
// Function '??0IRLoadTemp@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257E68);
		  /* 82257E68h */ case    0:  		/* li R3, 0 */
		/* 82257E68h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257E68h case    0:*/		return 0x82257E6C;
	}
	return 0x82257E6C;
} // Block from 82257E68h-82257E6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257E6C);
		  /* 82257E6Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 82257E6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257E6Ch case    0:*/		return 0x82257E70;
		  /* 82257E70h */ case    1:  		/* b -1862596 */
		/* 82257E70h case    1:*/		return 0x820912AC;
		/* 82257E70h case    1:*/		return 0x82257E74;
		  /* 82257E74h */ case    2:  		/* nop */
		/* 82257E74h case    2:*/		cpu::op::nop();
		/* 82257E74h case    2:*/		return 0x82257E78;
	}
	return 0x82257E78;
} // Block from 82257E6Ch-82257E78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257E78);
		  /* 82257E78h */ case    0:  		/* mfspr R12, LR */
		/* 82257E78h case    0:*/		regs.R12 = regs.LR;
		/* 82257E78h case    0:*/		return 0x82257E7C;
		  /* 82257E7Ch */ case    1:  		/* bl -1862688 */
		/* 82257E7Ch case    1:*/		regs.LR = 0x82257E80; return 0x8209125C;
		/* 82257E7Ch case    1:*/		return 0x82257E80;
		  /* 82257E80h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257E80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257E80h case    2:*/		return 0x82257E84;
		  /* 82257E84h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257E84h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257E84h case    3:*/		return 0x82257E88;
		  /* 82257E88h */ case    4:  		/* mr R30, R3 */
		/* 82257E88h case    4:*/		regs.R30 = regs.R3;
		/* 82257E88h case    4:*/		return 0x82257E8C;
		  /* 82257E8Ch */ case    5:  		/* mr R31, R4 */
		/* 82257E8Ch case    5:*/		regs.R31 = regs.R4;
		/* 82257E8Ch case    5:*/		return 0x82257E90;
		  /* 82257E90h */ case    6:  		/* li R4, 964 */
		/* 82257E90h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257E90h case    6:*/		return 0x82257E94;
		  /* 82257E94h */ case    7:  		/* mr R3, R29 */
		/* 82257E94h case    7:*/		regs.R3 = regs.R29;
		/* 82257E94h case    7:*/		return 0x82257E98;
		  /* 82257E98h */ case    8:  		/* bl -244192 */
		/* 82257E98h case    8:*/		regs.LR = 0x82257E9C; return 0x8221C4B8;
		/* 82257E98h case    8:*/		return 0x82257E9C;
		  /* 82257E9Ch */ case    9:  		/* mr R11, R3 */
		/* 82257E9Ch case    9:*/		regs.R11 = regs.R3;
		/* 82257E9Ch case    9:*/		return 0x82257EA0;
		  /* 82257EA0h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82257EA0h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257EA0h case   10:*/		return 0x82257EA4;
		  /* 82257EA4h */ case   11:  		/* stw R29, <#[R11]> */
		/* 82257EA4h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257EA4h case   11:*/		return 0x82257EA8;
		  /* 82257EA8h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 82257EA8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82257EBC;  }
		/* 82257EA8h case   12:*/		return 0x82257EAC;
		  /* 82257EACh */ case   13:  		/* mr R5, R31 */
		/* 82257EACh case   13:*/		regs.R5 = regs.R31;
		/* 82257EACh case   13:*/		return 0x82257EB0;
		  /* 82257EB0h */ case   14:  		/* mr R4, R30 */
		/* 82257EB0h case   14:*/		regs.R4 = regs.R30;
		/* 82257EB0h case   14:*/		return 0x82257EB4;
		  /* 82257EB4h */ case   15:  		/* bl -1228 */
		/* 82257EB4h case   15:*/		regs.LR = 0x82257EB8; return 0x822579E8;
		/* 82257EB4h case   15:*/		return 0x82257EB8;
		  /* 82257EB8h */ case   16:  		/* b 8 */
		/* 82257EB8h case   16:*/		return 0x82257EC0;
		/* 82257EB8h case   16:*/		return 0x82257EBC;
	}
	return 0x82257EBC;
} // Block from 82257E78h-82257EBCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82257EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257EBC);
		  /* 82257EBCh */ case    0:  		/* li R3, 0 */
		/* 82257EBCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257EBCh case    0:*/		return 0x82257EC0;
	}
	return 0x82257EC0;
} // Block from 82257EBCh-82257EC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257EC0h
// Function '?InstType@IRLoadTemp@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257EC0);
		  /* 82257EC0h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257EC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257EC0h case    0:*/		return 0x82257EC4;
		  /* 82257EC4h */ case    1:  		/* b -1862680 */
		/* 82257EC4h case    1:*/		return 0x820912AC;
		/* 82257EC4h case    1:*/		return 0x82257EC8;
	}
	return 0x82257EC8;
} // Block from 82257EC0h-82257EC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257EC8);
		  /* 82257EC8h */ case    0:  		/* mfspr R12, LR */
		/* 82257EC8h case    0:*/		regs.R12 = regs.LR;
		/* 82257EC8h case    0:*/		return 0x82257ECC;
		  /* 82257ECCh */ case    1:  		/* bl -1862768 */
		/* 82257ECCh case    1:*/		regs.LR = 0x82257ED0; return 0x8209125C;
		/* 82257ECCh case    1:*/		return 0x82257ED0;
	}
	return 0x82257ED0;
} // Block from 82257EC8h-82257ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257ED0h
// Function '??0IRLoadTemp@XGRAPHICS@@QAA@PAVVRegInfo@1@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257ED0);
		  /* 82257ED0h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257ED0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257ED0h case    0:*/		return 0x82257ED4;
		  /* 82257ED4h */ case    1:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257ED4h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257ED4h case    1:*/		return 0x82257ED8;
		  /* 82257ED8h */ case    2:  		/* mr R30, R3 */
		/* 82257ED8h case    2:*/		regs.R30 = regs.R3;
		/* 82257ED8h case    2:*/		return 0x82257EDC;
		  /* 82257EDCh */ case    3:  		/* mr R31, R4 */
		/* 82257EDCh case    3:*/		regs.R31 = regs.R4;
		/* 82257EDCh case    3:*/		return 0x82257EE0;
		  /* 82257EE0h */ case    4:  		/* li R4, 964 */
		/* 82257EE0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257EE0h case    4:*/		return 0x82257EE4;
		  /* 82257EE4h */ case    5:  		/* mr R3, R29 */
		/* 82257EE4h case    5:*/		regs.R3 = regs.R29;
		/* 82257EE4h case    5:*/		return 0x82257EE8;
		  /* 82257EE8h */ case    6:  		/* bl -244272 */
		/* 82257EE8h case    6:*/		regs.LR = 0x82257EEC; return 0x8221C4B8;
		/* 82257EE8h case    6:*/		return 0x82257EEC;
		  /* 82257EECh */ case    7:  		/* mr R11, R3 */
		/* 82257EECh case    7:*/		regs.R11 = regs.R3;
		/* 82257EECh case    7:*/		return 0x82257EF0;
		  /* 82257EF0h */ case    8:  		/* addic. R3, R3, 4 */
		/* 82257EF0h case    8:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257EF0h case    8:*/		return 0x82257EF4;
		  /* 82257EF4h */ case    9:  		/* stw R29, <#[R11]> */
		/* 82257EF4h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257EF4h case    9:*/		return 0x82257EF8;
		  /* 82257EF8h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 82257EF8h case   10:*/		if ( regs.CR[0].eq ) { return 0x82257F0C;  }
		/* 82257EF8h case   10:*/		return 0x82257EFC;
		  /* 82257EFCh */ case   11:  		/* mr R5, R31 */
		/* 82257EFCh case   11:*/		regs.R5 = regs.R31;
		/* 82257EFCh case   11:*/		return 0x82257F00;
		  /* 82257F00h */ case   12:  		/* mr R4, R30 */
		/* 82257F00h case   12:*/		regs.R4 = regs.R30;
		/* 82257F00h case   12:*/		return 0x82257F04;
		  /* 82257F04h */ case   13:  		/* bl -1172 */
		/* 82257F04h case   13:*/		regs.LR = 0x82257F08; return 0x82257A70;
		/* 82257F04h case   13:*/		return 0x82257F08;
		  /* 82257F08h */ case   14:  		/* b 8 */
		/* 82257F08h case   14:*/		return 0x82257F10;
		/* 82257F08h case   14:*/		return 0x82257F0C;
	}
	return 0x82257F0C;
} // Block from 82257ED0h-82257F0Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82257F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F0C);
		  /* 82257F0Ch */ case    0:  		/* li R3, 0 */
		/* 82257F0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257F0Ch case    0:*/		return 0x82257F10;
	}
	return 0x82257F10;
} // Block from 82257F0Ch-82257F10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F10);
		  /* 82257F10h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257F10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257F10h case    0:*/		return 0x82257F14;
		  /* 82257F14h */ case    1:  		/* b -1862760 */
		/* 82257F14h case    1:*/		return 0x820912AC;
		/* 82257F14h case    1:*/		return 0x82257F18;
	}
	return 0x82257F18;
} // Block from 82257F10h-82257F18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F18);
		  /* 82257F18h */ case    0:  		/* mfspr R12, LR */
		/* 82257F18h case    0:*/		regs.R12 = regs.LR;
		/* 82257F18h case    0:*/		return 0x82257F1C;
		  /* 82257F1Ch */ case    1:  		/* bl -1862848 */
		/* 82257F1Ch case    1:*/		regs.LR = 0x82257F20; return 0x8209125C;
		/* 82257F1Ch case    1:*/		return 0x82257F20;
		  /* 82257F20h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257F20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257F20h case    2:*/		return 0x82257F24;
		  /* 82257F24h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257F24h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257F24h case    3:*/		return 0x82257F28;
		  /* 82257F28h */ case    4:  		/* mr R30, R3 */
		/* 82257F28h case    4:*/		regs.R30 = regs.R3;
		/* 82257F28h case    4:*/		return 0x82257F2C;
		  /* 82257F2Ch */ case    5:  		/* mr R31, R4 */
		/* 82257F2Ch case    5:*/		regs.R31 = regs.R4;
		/* 82257F2Ch case    5:*/		return 0x82257F30;
		  /* 82257F30h */ case    6:  		/* li R4, 964 */
		/* 82257F30h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257F30h case    6:*/		return 0x82257F34;
		  /* 82257F34h */ case    7:  		/* mr R3, R29 */
		/* 82257F34h case    7:*/		regs.R3 = regs.R29;
		/* 82257F34h case    7:*/		return 0x82257F38;
		  /* 82257F38h */ case    8:  		/* bl -244352 */
		/* 82257F38h case    8:*/		regs.LR = 0x82257F3C; return 0x8221C4B8;
		/* 82257F38h case    8:*/		return 0x82257F3C;
		  /* 82257F3Ch */ case    9:  		/* mr R11, R3 */
		/* 82257F3Ch case    9:*/		regs.R11 = regs.R3;
		/* 82257F3Ch case    9:*/		return 0x82257F40;
	}
	return 0x82257F40;
} // Block from 82257F18h-82257F40h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82257F40h
// Function '??0IRLoadInterp@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F40);
		  /* 82257F40h */ case    0:  		/* addic. R3, R3, 4 */
		/* 82257F40h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257F40h case    0:*/		return 0x82257F44;
		  /* 82257F44h */ case    1:  		/* stw R29, <#[R11]> */
		/* 82257F44h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257F44h case    1:*/		return 0x82257F48;
		  /* 82257F48h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 82257F48h case    2:*/		if ( regs.CR[0].eq ) { return 0x82257F5C;  }
		/* 82257F48h case    2:*/		return 0x82257F4C;
		  /* 82257F4Ch */ case    3:  		/* mr R5, R31 */
		/* 82257F4Ch case    3:*/		regs.R5 = regs.R31;
		/* 82257F4Ch case    3:*/		return 0x82257F50;
		  /* 82257F50h */ case    4:  		/* mr R4, R30 */
		/* 82257F50h case    4:*/		regs.R4 = regs.R30;
		/* 82257F50h case    4:*/		return 0x82257F54;
		  /* 82257F54h */ case    5:  		/* bl -1540 */
		/* 82257F54h case    5:*/		regs.LR = 0x82257F58; return 0x82257950;
		/* 82257F54h case    5:*/		return 0x82257F58;
		  /* 82257F58h */ case    6:  		/* b 8 */
		/* 82257F58h case    6:*/		return 0x82257F60;
		/* 82257F58h case    6:*/		return 0x82257F5C;
	}
	return 0x82257F5C;
} // Block from 82257F40h-82257F5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82257F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F5C);
		  /* 82257F5Ch */ case    0:  		/* li R3, 0 */
		/* 82257F5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257F5Ch case    0:*/		return 0x82257F60;
	}
	return 0x82257F60;
} // Block from 82257F5Ch-82257F60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F60);
		  /* 82257F60h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257F60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257F60h case    0:*/		return 0x82257F64;
		  /* 82257F64h */ case    1:  		/* b -1862840 */
		/* 82257F64h case    1:*/		return 0x820912AC;
		/* 82257F64h case    1:*/		return 0x82257F68;
	}
	return 0x82257F68;
} // Block from 82257F60h-82257F68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257F68);
		  /* 82257F68h */ case    0:  		/* mfspr R12, LR */
		/* 82257F68h case    0:*/		regs.R12 = regs.LR;
		/* 82257F68h case    0:*/		return 0x82257F6C;
		  /* 82257F6Ch */ case    1:  		/* bl -1862928 */
		/* 82257F6Ch case    1:*/		regs.LR = 0x82257F70; return 0x8209125C;
		/* 82257F6Ch case    1:*/		return 0x82257F70;
		  /* 82257F70h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257F70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257F70h case    2:*/		return 0x82257F74;
		  /* 82257F74h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257F74h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257F74h case    3:*/		return 0x82257F78;
		  /* 82257F78h */ case    4:  		/* mr R30, R3 */
		/* 82257F78h case    4:*/		regs.R30 = regs.R3;
		/* 82257F78h case    4:*/		return 0x82257F7C;
		  /* 82257F7Ch */ case    5:  		/* mr R31, R4 */
		/* 82257F7Ch case    5:*/		regs.R31 = regs.R4;
		/* 82257F7Ch case    5:*/		return 0x82257F80;
		  /* 82257F80h */ case    6:  		/* li R4, 964 */
		/* 82257F80h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257F80h case    6:*/		return 0x82257F84;
		  /* 82257F84h */ case    7:  		/* mr R3, R29 */
		/* 82257F84h case    7:*/		regs.R3 = regs.R29;
		/* 82257F84h case    7:*/		return 0x82257F88;
		  /* 82257F88h */ case    8:  		/* bl -244432 */
		/* 82257F88h case    8:*/		regs.LR = 0x82257F8C; return 0x8221C4B8;
		/* 82257F88h case    8:*/		return 0x82257F8C;
		  /* 82257F8Ch */ case    9:  		/* mr R11, R3 */
		/* 82257F8Ch case    9:*/		regs.R11 = regs.R3;
		/* 82257F8Ch case    9:*/		return 0x82257F90;
		  /* 82257F90h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82257F90h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257F90h case   10:*/		return 0x82257F94;
		  /* 82257F94h */ case   11:  		/* stw R29, <#[R11]> */
		/* 82257F94h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257F94h case   11:*/		return 0x82257F98;
		  /* 82257F98h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 82257F98h case   12:*/		if ( regs.CR[0].eq ) { return 0x82257FAC;  }
		/* 82257F98h case   12:*/		return 0x82257F9C;
		  /* 82257F9Ch */ case   13:  		/* mr R5, R31 */
		/* 82257F9Ch case   13:*/		regs.R5 = regs.R31;
		/* 82257F9Ch case   13:*/		return 0x82257FA0;
	}
	return 0x82257FA0;
} // Block from 82257F68h-82257FA0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82257FA0h
// Function '?InstType@IRLoadInterp@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257FA0);
		  /* 82257FA0h */ case    0:  		/* mr R4, R30 */
		/* 82257FA0h case    0:*/		regs.R4 = regs.R30;
		/* 82257FA0h case    0:*/		return 0x82257FA4;
		  /* 82257FA4h */ case    1:  		/* bl -1196 */
		/* 82257FA4h case    1:*/		regs.LR = 0x82257FA8; return 0x82257AF8;
		/* 82257FA4h case    1:*/		return 0x82257FA8;
		  /* 82257FA8h */ case    2:  		/* b 8 */
		/* 82257FA8h case    2:*/		return 0x82257FB0;
		/* 82257FA8h case    2:*/		return 0x82257FAC;
	}
	return 0x82257FAC;
} // Block from 82257FA0h-82257FACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82257FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257FAC);
		  /* 82257FACh */ case    0:  		/* li R3, 0 */
		/* 82257FACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257FACh case    0:*/		return 0x82257FB0;
	}
	return 0x82257FB0;
} // Block from 82257FACh-82257FB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82257FB0h
// Function '?Print@CNodeType@D3DXShader@@UAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257FB0);
		  /* 82257FB0h */ case    0:  		/* addi R1, R1, 112 */
		/* 82257FB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82257FB0h case    0:*/		return 0x82257FB4;
		  /* 82257FB4h */ case    1:  		/* b -1862920 */
		/* 82257FB4h case    1:*/		return 0x820912AC;
		/* 82257FB4h case    1:*/		return 0x82257FB8;
	}
	return 0x82257FB8;
} // Block from 82257FB0h-82257FB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82257FB8h
// Function '??0IRProjection@XGRAPHICS@@QAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257FB8);
		  /* 82257FB8h */ case    0:  		/* mfspr R12, LR */
		/* 82257FB8h case    0:*/		regs.R12 = regs.LR;
		/* 82257FB8h case    0:*/		return 0x82257FBC;
		  /* 82257FBCh */ case    1:  		/* bl -1863008 */
		/* 82257FBCh case    1:*/		regs.LR = 0x82257FC0; return 0x8209125C;
		/* 82257FBCh case    1:*/		return 0x82257FC0;
		  /* 82257FC0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82257FC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82257FC0h case    2:*/		return 0x82257FC4;
		  /* 82257FC4h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82257FC4h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82257FC4h case    3:*/		return 0x82257FC8;
		  /* 82257FC8h */ case    4:  		/* mr R30, R3 */
		/* 82257FC8h case    4:*/		regs.R30 = regs.R3;
		/* 82257FC8h case    4:*/		return 0x82257FCC;
		  /* 82257FCCh */ case    5:  		/* mr R31, R4 */
		/* 82257FCCh case    5:*/		regs.R31 = regs.R4;
		/* 82257FCCh case    5:*/		return 0x82257FD0;
		  /* 82257FD0h */ case    6:  		/* li R4, 964 */
		/* 82257FD0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82257FD0h case    6:*/		return 0x82257FD4;
		  /* 82257FD4h */ case    7:  		/* mr R3, R29 */
		/* 82257FD4h case    7:*/		regs.R3 = regs.R29;
		/* 82257FD4h case    7:*/		return 0x82257FD8;
		  /* 82257FD8h */ case    8:  		/* bl -244512 */
		/* 82257FD8h case    8:*/		regs.LR = 0x82257FDC; return 0x8221C4B8;
		/* 82257FD8h case    8:*/		return 0x82257FDC;
		  /* 82257FDCh */ case    9:  		/* mr R11, R3 */
		/* 82257FDCh case    9:*/		regs.R11 = regs.R3;
		/* 82257FDCh case    9:*/		return 0x82257FE0;
		  /* 82257FE0h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82257FE0h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82257FE0h case   10:*/		return 0x82257FE4;
		  /* 82257FE4h */ case   11:  		/* stw R29, <#[R11]> */
		/* 82257FE4h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82257FE4h case   11:*/		return 0x82257FE8;
		  /* 82257FE8h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 82257FE8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82257FFC;  }
		/* 82257FE8h case   12:*/		return 0x82257FEC;
		  /* 82257FECh */ case   13:  		/* mr R5, R31 */
		/* 82257FECh case   13:*/		regs.R5 = regs.R31;
		/* 82257FECh case   13:*/		return 0x82257FF0;
		  /* 82257FF0h */ case   14:  		/* mr R4, R30 */
		/* 82257FF0h case   14:*/		regs.R4 = regs.R30;
		/* 82257FF0h case   14:*/		return 0x82257FF4;
		  /* 82257FF4h */ case   15:  		/* bl -1140 */
		/* 82257FF4h case   15:*/		regs.LR = 0x82257FF8; return 0x82257B80;
		/* 82257FF4h case   15:*/		return 0x82257FF8;
		  /* 82257FF8h */ case   16:  		/* b 8 */
		/* 82257FF8h case   16:*/		return 0x82258000;
		/* 82257FF8h case   16:*/		return 0x82257FFC;
	}
	return 0x82257FFC;
} // Block from 82257FB8h-82257FFCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82257FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82257FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82257FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82257FFC);
		  /* 82257FFCh */ case    0:  		/* li R3, 0 */
		/* 82257FFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82257FFCh case    0:*/		return 0x82258000;
	}
	return 0x82258000;
} // Block from 82257FFCh-82258000h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258000h
// Function '?InstType@IRProjection@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258000);
		  /* 82258000h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258000h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258000h case    0:*/		return 0x82258004;
		  /* 82258004h */ case    1:  		/* b -1863000 */
		/* 82258004h case    1:*/		return 0x820912AC;
		/* 82258004h case    1:*/		return 0x82258008;
	}
	return 0x82258008;
} // Block from 82258000h-82258008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258008);
		  /* 82258008h */ case    0:  		/* mfspr R12, LR */
		/* 82258008h case    0:*/		regs.R12 = regs.LR;
		/* 82258008h case    0:*/		return 0x8225800C;
		  /* 8225800Ch */ case    1:  		/* bl -1863088 */
		/* 8225800Ch case    1:*/		regs.LR = 0x82258010; return 0x8209125C;
		/* 8225800Ch case    1:*/		return 0x82258010;
	}
	return 0x82258010;
} // Block from 82258008h-82258010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258010h
// Function '??0IRPhiNode@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258010);
		  /* 82258010h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258010h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258010h case    0:*/		return 0x82258014;
		  /* 82258014h */ case    1:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82258014h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82258014h case    1:*/		return 0x82258018;
		  /* 82258018h */ case    2:  		/* mr R30, R3 */
		/* 82258018h case    2:*/		regs.R30 = regs.R3;
		/* 82258018h case    2:*/		return 0x8225801C;
		  /* 8225801Ch */ case    3:  		/* mr R31, R4 */
		/* 8225801Ch case    3:*/		regs.R31 = regs.R4;
		/* 8225801Ch case    3:*/		return 0x82258020;
		  /* 82258020h */ case    4:  		/* li R4, 964 */
		/* 82258020h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258020h case    4:*/		return 0x82258024;
		  /* 82258024h */ case    5:  		/* mr R3, R29 */
		/* 82258024h case    5:*/		regs.R3 = regs.R29;
		/* 82258024h case    5:*/		return 0x82258028;
		  /* 82258028h */ case    6:  		/* bl -244592 */
		/* 82258028h case    6:*/		regs.LR = 0x8225802C; return 0x8221C4B8;
		/* 82258028h case    6:*/		return 0x8225802C;
		  /* 8225802Ch */ case    7:  		/* mr R11, R3 */
		/* 8225802Ch case    7:*/		regs.R11 = regs.R3;
		/* 8225802Ch case    7:*/		return 0x82258030;
		  /* 82258030h */ case    8:  		/* addic. R3, R3, 4 */
		/* 82258030h case    8:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258030h case    8:*/		return 0x82258034;
		  /* 82258034h */ case    9:  		/* stw R29, <#[R11]> */
		/* 82258034h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82258034h case    9:*/		return 0x82258038;
		  /* 82258038h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 82258038h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225804C;  }
		/* 82258038h case   10:*/		return 0x8225803C;
		  /* 8225803Ch */ case   11:  		/* mr R5, R31 */
		/* 8225803Ch case   11:*/		regs.R5 = regs.R31;
		/* 8225803Ch case   11:*/		return 0x82258040;
		  /* 82258040h */ case   12:  		/* mr R4, R30 */
		/* 82258040h case   12:*/		regs.R4 = regs.R30;
		/* 82258040h case   12:*/		return 0x82258044;
		  /* 82258044h */ case   13:  		/* bl -2076 */
		/* 82258044h case   13:*/		regs.LR = 0x82258048; return 0x82257828;
		/* 82258044h case   13:*/		return 0x82258048;
		  /* 82258048h */ case   14:  		/* b 8 */
		/* 82258048h case   14:*/		return 0x82258050;
		/* 82258048h case   14:*/		return 0x8225804C;
	}
	return 0x8225804C;
} // Block from 82258010h-8225804Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225804Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225804C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225804C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225804C);
		  /* 8225804Ch */ case    0:  		/* li R3, 0 */
		/* 8225804Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225804Ch case    0:*/		return 0x82258050;
	}
	return 0x82258050;
} // Block from 8225804Ch-82258050h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258050);
		  /* 82258050h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258050h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258050h case    0:*/		return 0x82258054;
		  /* 82258054h */ case    1:  		/* b -1863080 */
		/* 82258054h case    1:*/		return 0x820912AC;
		/* 82258054h case    1:*/		return 0x82258058;
	}
	return 0x82258058;
} // Block from 82258050h-82258058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258058h
// Function '?InstType@IRPhiNode@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258058);
		  /* 82258058h */ case    0:  		/* mfspr R12, LR */
		/* 82258058h case    0:*/		regs.R12 = regs.LR;
		/* 82258058h case    0:*/		return 0x8225805C;
		  /* 8225805Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225805Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225805Ch case    1:*/		return 0x82258060;
		  /* 82258060h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82258060h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258060h case    2:*/		return 0x82258064;
		  /* 82258064h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82258064h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258064h case    3:*/		return 0x82258068;
	}
	return 0x82258068;
} // Block from 82258058h-82258068h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258068h
// Function '??0IRLoopStart@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258068);
		  /* 82258068h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258068h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258068h case    0:*/		return 0x8225806C;
		  /* 8225806Ch */ case    1:  		/* lwz R30, <#[R4 + 1452]> */
		/* 8225806Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x000005AC) );
		/* 8225806Ch case    1:*/		return 0x82258070;
		  /* 82258070h */ case    2:  		/* mr R31, R4 */
		/* 82258070h case    2:*/		regs.R31 = regs.R4;
		/* 82258070h case    2:*/		return 0x82258074;
		  /* 82258074h */ case    3:  		/* li R4, 964 */
		/* 82258074h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258074h case    3:*/		return 0x82258078;
		  /* 82258078h */ case    4:  		/* mr R3, R30 */
		/* 82258078h case    4:*/		regs.R3 = regs.R30;
		/* 82258078h case    4:*/		return 0x8225807C;
		  /* 8225807Ch */ case    5:  		/* bl -244676 */
		/* 8225807Ch case    5:*/		regs.LR = 0x82258080; return 0x8221C4B8;
		/* 8225807Ch case    5:*/		return 0x82258080;
		  /* 82258080h */ case    6:  		/* mr R11, R3 */
		/* 82258080h case    6:*/		regs.R11 = regs.R3;
		/* 82258080h case    6:*/		return 0x82258084;
		  /* 82258084h */ case    7:  		/* addic. R3, R3, 4 */
		/* 82258084h case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258084h case    7:*/		return 0x82258088;
		  /* 82258088h */ case    8:  		/* stw R30, <#[R11]> */
		/* 82258088h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82258088h case    8:*/		return 0x8225808C;
		  /* 8225808Ch */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 8225808Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x822580B8;  }
		/* 8225808Ch case    9:*/		return 0x82258090;
		  /* 82258090h */ case   10:  		/* mr R5, R31 */
		/* 82258090h case   10:*/		regs.R5 = regs.R31;
		/* 82258090h case   10:*/		return 0x82258094;
		  /* 82258094h */ case   11:  		/* li R4, 128 */
		/* 82258094h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 82258094h case   11:*/		return 0x82258098;
		  /* 82258098h */ case   12:  		/* bl -4776 */
		/* 82258098h case   12:*/		regs.LR = 0x8225809C; return 0x82256DF0;
		/* 82258098h case   12:*/		return 0x8225809C;
		  /* 8225809Ch */ case   13:  		/* lis R10, -32252 */
		/* 8225809Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225809Ch case   13:*/		return 0x822580A0;
		  /* 822580A0h */ case   14:  		/* li R11, 1 */
		/* 822580A0h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822580A0h case   14:*/		return 0x822580A4;
		  /* 822580A4h */ case   15:  		/* addi R10, R10, 30648 */
		/* 822580A4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x77B8);
		/* 822580A4h case   15:*/		return 0x822580A8;
		  /* 822580A8h */ case   16:  		/* stw R11, <#[R3 + 16]> */
		/* 822580A8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822580A8h case   16:*/		return 0x822580AC;
		  /* 822580ACh */ case   17:  		/* stw R10, <#[R3]> */
		/* 822580ACh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822580ACh case   17:*/		return 0x822580B0;
		  /* 822580B0h */ case   18:  		/* stw R11, <#[R3 + 20]> */
		/* 822580B0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 822580B0h case   18:*/		return 0x822580B4;
		  /* 822580B4h */ case   19:  		/* b 8 */
		/* 822580B4h case   19:*/		return 0x822580BC;
		/* 822580B4h case   19:*/		return 0x822580B8;
	}
	return 0x822580B8;
} // Block from 82258068h-822580B8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822580B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822580B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822580B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822580B8);
		  /* 822580B8h */ case    0:  		/* li R3, 0 */
		/* 822580B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822580B8h case    0:*/		return 0x822580BC;
	}
	return 0x822580BC;
} // Block from 822580B8h-822580BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822580BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822580BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822580BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822580BC);
		  /* 822580BCh */ case    0:  		/* addi R1, R1, 112 */
		/* 822580BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822580BCh case    0:*/		return 0x822580C0;
		  /* 822580C0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822580C0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822580C0h case    1:*/		return 0x822580C4;
		  /* 822580C4h */ case    2:  		/* mtspr LR, R12 */
		/* 822580C4h case    2:*/		regs.LR = regs.R12;
		/* 822580C4h case    2:*/		return 0x822580C8;
		  /* 822580C8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 822580C8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822580C8h case    3:*/		return 0x822580CC;
		  /* 822580CCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 822580CCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822580CCh case    4:*/		return 0x822580D0;
		  /* 822580D0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822580D0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822580D0h case    5:*/		return 0x822580D4;
	}
	return 0x822580D4;
} // Block from 822580BCh-822580D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822580D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822580D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822580D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822580D4);
		  /* 822580D4h */ case    0:  		/* nop */
		/* 822580D4h case    0:*/		cpu::op::nop();
		/* 822580D4h case    0:*/		return 0x822580D8;
	}
	return 0x822580D8;
} // Block from 822580D4h-822580D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822580D8h
// Function '?InstType@IRLoopStart@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822580D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822580D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822580D8);
		  /* 822580D8h */ case    0:  		/* mfspr R12, LR */
		/* 822580D8h case    0:*/		regs.R12 = regs.LR;
		/* 822580D8h case    0:*/		return 0x822580DC;
		  /* 822580DCh */ case    1:  		/* bl -1863296 */
		/* 822580DCh case    1:*/		regs.LR = 0x822580E0; return 0x8209125C;
		/* 822580DCh case    1:*/		return 0x822580E0;
		  /* 822580E0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822580E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822580E0h case    2:*/		return 0x822580E4;
		  /* 822580E4h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 822580E4h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 822580E4h case    3:*/		return 0x822580E8;
	}
	return 0x822580E8;
} // Block from 822580D8h-822580E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822580E8h
// Function '??0IRLoopIndex@XGRAPHICS@@QAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822580E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822580E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822580E8);
		  /* 822580E8h */ case    0:  		/* mr R30, R3 */
		/* 822580E8h case    0:*/		regs.R30 = regs.R3;
		/* 822580E8h case    0:*/		return 0x822580EC;
		  /* 822580ECh */ case    1:  		/* mr R31, R4 */
		/* 822580ECh case    1:*/		regs.R31 = regs.R4;
		/* 822580ECh case    1:*/		return 0x822580F0;
		  /* 822580F0h */ case    2:  		/* li R4, 964 */
		/* 822580F0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822580F0h case    2:*/		return 0x822580F4;
		  /* 822580F4h */ case    3:  		/* mr R3, R29 */
		/* 822580F4h case    3:*/		regs.R3 = regs.R29;
		/* 822580F4h case    3:*/		return 0x822580F8;
		  /* 822580F8h */ case    4:  		/* bl -244800 */
		/* 822580F8h case    4:*/		regs.LR = 0x822580FC; return 0x8221C4B8;
		/* 822580F8h case    4:*/		return 0x822580FC;
		  /* 822580FCh */ case    5:  		/* mr R11, R3 */
		/* 822580FCh case    5:*/		regs.R11 = regs.R3;
		/* 822580FCh case    5:*/		return 0x82258100;
		  /* 82258100h */ case    6:  		/* addic. R3, R3, 4 */
		/* 82258100h case    6:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258100h case    6:*/		return 0x82258104;
		  /* 82258104h */ case    7:  		/* stw R29, <#[R11]> */
		/* 82258104h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82258104h case    7:*/		return 0x82258108;
		  /* 82258108h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 82258108h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225811C;  }
		/* 82258108h case    8:*/		return 0x8225810C;
		  /* 8225810Ch */ case    9:  		/* mr R5, R31 */
		/* 8225810Ch case    9:*/		regs.R5 = regs.R31;
		/* 8225810Ch case    9:*/		return 0x82258110;
		  /* 82258110h */ case   10:  		/* mr R4, R30 */
		/* 82258110h case   10:*/		regs.R4 = regs.R30;
		/* 82258110h case   10:*/		return 0x82258114;
		  /* 82258114h */ case   11:  		/* bl -2844 */
		/* 82258114h case   11:*/		regs.LR = 0x82258118; return 0x822575F8;
		/* 82258114h case   11:*/		return 0x82258118;
		  /* 82258118h */ case   12:  		/* b 8 */
		/* 82258118h case   12:*/		return 0x82258120;
		/* 82258118h case   12:*/		return 0x8225811C;
	}
	return 0x8225811C;
} // Block from 822580E8h-8225811Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225811Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225811C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225811C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225811C);
		  /* 8225811Ch */ case    0:  		/* li R3, 0 */
		/* 8225811Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225811Ch case    0:*/		return 0x82258120;
	}
	return 0x82258120;
} // Block from 8225811Ch-82258120h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258120);
		  /* 82258120h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258120h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258120h case    0:*/		return 0x82258124;
		  /* 82258124h */ case    1:  		/* b -1863288 */
		/* 82258124h case    1:*/		return 0x820912AC;
		/* 82258124h case    1:*/		return 0x82258128;
	}
	return 0x82258128;
} // Block from 82258120h-82258128h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258128);
		  /* 82258128h */ case    0:  		/* mfspr R12, LR */
		/* 82258128h case    0:*/		regs.R12 = regs.LR;
		/* 82258128h case    0:*/		return 0x8225812C;
		  /* 8225812Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225812Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225812Ch case    1:*/		return 0x82258130;
	}
	return 0x82258130;
} // Block from 82258128h-82258130h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258130h
// Function '?InstType@IRLoopIndex@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258130);
		  /* 82258130h */ case    0:  		/* std R30, <#[R1 - 24]> */
		/* 82258130h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258130h case    0:*/		return 0x82258134;
		  /* 82258134h */ case    1:  		/* std R31, <#[R1 - 16]> */
		/* 82258134h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258134h case    1:*/		return 0x82258138;
		  /* 82258138h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258138h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258138h case    2:*/		return 0x8225813C;
		  /* 8225813Ch */ case    3:  		/* lwz R30, <#[R4 + 1452]> */
		/* 8225813Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x000005AC) );
		/* 8225813Ch case    3:*/		return 0x82258140;
	}
	return 0x82258140;
} // Block from 82258130h-82258140h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258140h
// Function '??0IRAlloc@XGRAPHICS@@QAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258140);
		  /* 82258140h */ case    0:  		/* mr R31, R4 */
		/* 82258140h case    0:*/		regs.R31 = regs.R4;
		/* 82258140h case    0:*/		return 0x82258144;
		  /* 82258144h */ case    1:  		/* li R4, 964 */
		/* 82258144h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258144h case    1:*/		return 0x82258148;
		  /* 82258148h */ case    2:  		/* mr R3, R30 */
		/* 82258148h case    2:*/		regs.R3 = regs.R30;
		/* 82258148h case    2:*/		return 0x8225814C;
		  /* 8225814Ch */ case    3:  		/* bl -244884 */
		/* 8225814Ch case    3:*/		regs.LR = 0x82258150; return 0x8221C4B8;
		/* 8225814Ch case    3:*/		return 0x82258150;
		  /* 82258150h */ case    4:  		/* mr R11, R3 */
		/* 82258150h case    4:*/		regs.R11 = regs.R3;
		/* 82258150h case    4:*/		return 0x82258154;
		  /* 82258154h */ case    5:  		/* addic. R3, R3, 4 */
		/* 82258154h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258154h case    5:*/		return 0x82258158;
		  /* 82258158h */ case    6:  		/* stw R30, <#[R11]> */
		/* 82258158h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82258158h case    6:*/		return 0x8225815C;
		  /* 8225815Ch */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 8225815Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82258188;  }
		/* 8225815Ch case    7:*/		return 0x82258160;
		  /* 82258160h */ case    8:  		/* mr R5, R31 */
		/* 82258160h case    8:*/		regs.R5 = regs.R31;
		/* 82258160h case    8:*/		return 0x82258164;
		  /* 82258164h */ case    9:  		/* li R4, 126 */
		/* 82258164h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x7E);
		/* 82258164h case    9:*/		return 0x82258168;
		  /* 82258168h */ case   10:  		/* bl -4984 */
		/* 82258168h case   10:*/		regs.LR = 0x8225816C; return 0x82256DF0;
		/* 82258168h case   10:*/		return 0x8225816C;
		  /* 8225816Ch */ case   11:  		/* lis R10, -32252 */
		/* 8225816Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225816Ch case   11:*/		return 0x82258170;
		  /* 82258170h */ case   12:  		/* li R11, 1 */
		/* 82258170h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82258170h case   12:*/		return 0x82258174;
		  /* 82258174h */ case   13:  		/* addi R10, R10, 30992 */
		/* 82258174h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7910);
		/* 82258174h case   13:*/		return 0x82258178;
		  /* 82258178h */ case   14:  		/* stw R11, <#[R3 + 16]> */
		/* 82258178h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82258178h case   14:*/		return 0x8225817C;
		  /* 8225817Ch */ case   15:  		/* stw R10, <#[R3]> */
		/* 8225817Ch case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8225817Ch case   15:*/		return 0x82258180;
		  /* 82258180h */ case   16:  		/* stw R11, <#[R3 + 20]> */
		/* 82258180h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82258180h case   16:*/		return 0x82258184;
		  /* 82258184h */ case   17:  		/* b 8 */
		/* 82258184h case   17:*/		return 0x8225818C;
		/* 82258184h case   17:*/		return 0x82258188;
	}
	return 0x82258188;
} // Block from 82258140h-82258188h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82258188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258188);
		  /* 82258188h */ case    0:  		/* li R3, 0 */
		/* 82258188h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82258188h case    0:*/		return 0x8225818C;
	}
	return 0x8225818C;
} // Block from 82258188h-8225818Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225818Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225818C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225818C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225818C);
		  /* 8225818Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8225818Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225818Ch case    0:*/		return 0x82258190;
	}
	return 0x82258190;
} // Block from 8225818Ch-82258190h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258190h
// Function '??_EIRUnary@XGRAPHICS@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258190);
		  /* 82258190h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258190h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258190h case    0:*/		return 0x82258194;
		  /* 82258194h */ case    1:  		/* mtspr LR, R12 */
		/* 82258194h case    1:*/		regs.LR = regs.R12;
		/* 82258194h case    1:*/		return 0x82258198;
		  /* 82258198h */ case    2:  		/* ld R30, <#[R1 - 24]> */
		/* 82258198h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258198h case    2:*/		return 0x8225819C;
		  /* 8225819Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8225819Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225819Ch case    3:*/		return 0x822581A0;
		  /* 822581A0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822581A0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822581A0h case    4:*/		return 0x822581A4;
	}
	return 0x822581A4;
} // Block from 82258190h-822581A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822581A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822581A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822581A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822581A4);
		  /* 822581A4h */ case    0:  		/* nop */
		/* 822581A4h case    0:*/		cpu::op::nop();
		/* 822581A4h case    0:*/		return 0x822581A8;
	}
	return 0x822581A8;
} // Block from 822581A4h-822581A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822581A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822581A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822581A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822581A8);
		  /* 822581A8h */ case    0:  		/* mfspr R12, LR */
		/* 822581A8h case    0:*/		regs.R12 = regs.LR;
		/* 822581A8h case    0:*/		return 0x822581AC;
		  /* 822581ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822581ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822581ACh case    1:*/		return 0x822581B0;
		  /* 822581B0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822581B0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822581B0h case    2:*/		return 0x822581B4;
		  /* 822581B4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822581B4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822581B4h case    3:*/		return 0x822581B8;
		  /* 822581B8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822581B8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822581B8h case    4:*/		return 0x822581BC;
		  /* 822581BCh */ case    5:  		/* lwz R30, <#[R4 + 1452]> */
		/* 822581BCh case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x000005AC) );
		/* 822581BCh case    5:*/		return 0x822581C0;
		  /* 822581C0h */ case    6:  		/* mr R31, R4 */
		/* 822581C0h case    6:*/		regs.R31 = regs.R4;
		/* 822581C0h case    6:*/		return 0x822581C4;
		  /* 822581C4h */ case    7:  		/* li R4, 964 */
		/* 822581C4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822581C4h case    7:*/		return 0x822581C8;
		  /* 822581C8h */ case    8:  		/* mr R3, R30 */
		/* 822581C8h case    8:*/		regs.R3 = regs.R30;
		/* 822581C8h case    8:*/		return 0x822581CC;
		  /* 822581CCh */ case    9:  		/* bl -245012 */
		/* 822581CCh case    9:*/		regs.LR = 0x822581D0; return 0x8221C4B8;
		/* 822581CCh case    9:*/		return 0x822581D0;
		  /* 822581D0h */ case   10:  		/* mr R11, R3 */
		/* 822581D0h case   10:*/		regs.R11 = regs.R3;
		/* 822581D0h case   10:*/		return 0x822581D4;
		  /* 822581D4h */ case   11:  		/* addic. R3, R3, 4 */
		/* 822581D4h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822581D4h case   11:*/		return 0x822581D8;
		  /* 822581D8h */ case   12:  		/* stw R30, <#[R11]> */
		/* 822581D8h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822581D8h case   12:*/		return 0x822581DC;
		  /* 822581DCh */ case   13:  		/* bc 12, CR0_EQ, 32 */
		/* 822581DCh case   13:*/		if ( regs.CR[0].eq ) { return 0x822581FC;  }
		/* 822581DCh case   13:*/		return 0x822581E0;
	}
	return 0x822581E0;
} // Block from 822581A8h-822581E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822581E0h
// Function '?InstType@IRAllocInterp@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822581E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822581E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822581E0);
		  /* 822581E0h */ case    0:  		/* mr R5, R31 */
		/* 822581E0h case    0:*/		regs.R5 = regs.R31;
		/* 822581E0h case    0:*/		return 0x822581E4;
		  /* 822581E4h */ case    1:  		/* li R4, 142 */
		/* 822581E4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x8E);
		/* 822581E4h case    1:*/		return 0x822581E8;
		  /* 822581E8h */ case    2:  		/* bl -2840 */
		/* 822581E8h case    2:*/		regs.LR = 0x822581EC; return 0x822576D0;
		/* 822581E8h case    2:*/		return 0x822581EC;
		  /* 822581ECh */ case    3:  		/* lis R11, -32252 */
		/* 822581ECh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822581ECh case    3:*/		return 0x822581F0;
	}
	return 0x822581F0;
} // Block from 822581E0h-822581F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822581F0h
// Function '?InstType@IRAllocPos@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822581F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822581F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822581F0);
		  /* 822581F0h */ case    0:  		/* addi R11, R11, 31336 */
		/* 822581F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7A68);
		/* 822581F0h case    0:*/		return 0x822581F4;
		  /* 822581F4h */ case    1:  		/* stw R11, <#[R3]> */
		/* 822581F4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822581F4h case    1:*/		return 0x822581F8;
		  /* 822581F8h */ case    2:  		/* b 8 */
		/* 822581F8h case    2:*/		return 0x82258200;
		/* 822581F8h case    2:*/		return 0x822581FC;
	}
	return 0x822581FC;
} // Block from 822581F0h-822581FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822581FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822581FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822581FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822581FC);
		  /* 822581FCh */ case    0:  		/* li R3, 0 */
		/* 822581FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822581FCh case    0:*/		return 0x82258200;
	}
	return 0x82258200;
} // Block from 822581FCh-82258200h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258200h
// Function '?InstType@IRAllocMem@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258200);
		  /* 82258200h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258200h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258200h case    0:*/		return 0x82258204;
		  /* 82258204h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258204h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258204h case    1:*/		return 0x82258208;
		  /* 82258208h */ case    2:  		/* mtspr LR, R12 */
		/* 82258208h case    2:*/		regs.LR = regs.R12;
		/* 82258208h case    2:*/		return 0x8225820C;
		  /* 8225820Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8225820Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225820Ch case    3:*/		return 0x82258210;
	}
	return 0x82258210;
} // Block from 82258200h-82258210h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258210h
// Function '?InstType@IRAllocColor@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258210);
		  /* 82258210h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 82258210h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258210h case    0:*/		return 0x82258214;
		  /* 82258214h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82258214h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258214h case    1:*/		return 0x82258218;
	}
	return 0x82258218;
} // Block from 82258210h-82258218h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258218);
		  /* 82258218h */ case    0:  		/* mfspr R12, LR */
		/* 82258218h case    0:*/		regs.R12 = regs.LR;
		/* 82258218h case    0:*/		return 0x8225821C;
		  /* 8225821Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225821Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225821Ch case    1:*/		return 0x82258220;
	}
	return 0x82258220;
} // Block from 82258218h-82258220h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258220h
// Function '?InstType@IRFetch@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258220);
		  /* 82258220h */ case    0:  		/* std R30, <#[R1 - 24]> */
		/* 82258220h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258220h case    0:*/		return 0x82258224;
		  /* 82258224h */ case    1:  		/* std R31, <#[R1 - 16]> */
		/* 82258224h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258224h case    1:*/		return 0x82258228;
		  /* 82258228h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258228h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258228h case    2:*/		return 0x8225822C;
		  /* 8225822Ch */ case    3:  		/* lwz R30, <#[R4 + 1452]> */
		/* 8225822Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x000005AC) );
		/* 8225822Ch case    3:*/		return 0x82258230;
	}
	return 0x82258230;
} // Block from 82258220h-82258230h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258230h
// Function '?SetSwizzle@IRFetch@XGRAPHICS@@UAAXHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258230);
		  /* 82258230h */ case    0:  		/* mr R31, R4 */
		/* 82258230h case    0:*/		regs.R31 = regs.R4;
		/* 82258230h case    0:*/		return 0x82258234;
		  /* 82258234h */ case    1:  		/* li R4, 964 */
		/* 82258234h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258234h case    1:*/		return 0x82258238;
		  /* 82258238h */ case    2:  		/* mr R3, R30 */
		/* 82258238h case    2:*/		regs.R3 = regs.R30;
		/* 82258238h case    2:*/		return 0x8225823C;
		  /* 8225823Ch */ case    3:  		/* bl -245124 */
		/* 8225823Ch case    3:*/		regs.LR = 0x82258240; return 0x8221C4B8;
		/* 8225823Ch case    3:*/		return 0x82258240;
		  /* 82258240h */ case    4:  		/* mr R11, R3 */
		/* 82258240h case    4:*/		regs.R11 = regs.R3;
		/* 82258240h case    4:*/		return 0x82258244;
		  /* 82258244h */ case    5:  		/* addic. R3, R3, 4 */
		/* 82258244h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258244h case    5:*/		return 0x82258248;
		  /* 82258248h */ case    6:  		/* stw R30, <#[R11]> */
		/* 82258248h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82258248h case    6:*/		return 0x8225824C;
		  /* 8225824Ch */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 8225824Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8225826C;  }
		/* 8225824Ch case    7:*/		return 0x82258250;
		  /* 82258250h */ case    8:  		/* mr R5, R31 */
		/* 82258250h case    8:*/		regs.R5 = regs.R31;
		/* 82258250h case    8:*/		return 0x82258254;
		  /* 82258254h */ case    9:  		/* li R4, 143 */
		/* 82258254h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x8F);
		/* 82258254h case    9:*/		return 0x82258258;
		  /* 82258258h */ case   10:  		/* bl -2952 */
		/* 82258258h case   10:*/		regs.LR = 0x8225825C; return 0x822576D0;
		/* 82258258h case   10:*/		return 0x8225825C;
		  /* 8225825Ch */ case   11:  		/* lis R11, -32252 */
		/* 8225825Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225825Ch case   11:*/		return 0x82258260;
		  /* 82258260h */ case   12:  		/* addi R11, R11, 31456 */
		/* 82258260h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7AE0);
		/* 82258260h case   12:*/		return 0x82258264;
		  /* 82258264h */ case   13:  		/* stw R11, <#[R3]> */
		/* 82258264h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82258264h case   13:*/		return 0x82258268;
		  /* 82258268h */ case   14:  		/* b 8 */
		/* 82258268h case   14:*/		return 0x82258270;
		/* 82258268h case   14:*/		return 0x8225826C;
	}
	return 0x8225826C;
} // Block from 82258230h-8225826Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225826Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225826C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225826C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225826C);
		  /* 8225826Ch */ case    0:  		/* li R3, 0 */
		/* 8225826Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225826Ch case    0:*/		return 0x82258270;
	}
	return 0x82258270;
} // Block from 8225826Ch-82258270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258270);
		  /* 82258270h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258270h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258270h case    0:*/		return 0x82258274;
		  /* 82258274h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258274h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258274h case    1:*/		return 0x82258278;
	}
	return 0x82258278;
} // Block from 82258270h-82258278h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258278h
// Function '??0IRVertexFetch@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258278);
		  /* 82258278h */ case    0:  		/* mtspr LR, R12 */
		/* 82258278h case    0:*/		regs.LR = regs.R12;
		/* 82258278h case    0:*/		return 0x8225827C;
		  /* 8225827Ch */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 8225827Ch case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225827Ch case    1:*/		return 0x82258280;
		  /* 82258280h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 82258280h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258280h case    2:*/		return 0x82258284;
		  /* 82258284h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82258284h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258284h case    3:*/		return 0x82258288;
	}
	return 0x82258288;
} // Block from 82258278h-82258288h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258288);
		  /* 82258288h */ case    0:  		/* mfspr R12, LR */
		/* 82258288h case    0:*/		regs.R12 = regs.LR;
		/* 82258288h case    0:*/		return 0x8225828C;
		  /* 8225828Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225828Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225828Ch case    1:*/		return 0x82258290;
		  /* 82258290h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82258290h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258290h case    2:*/		return 0x82258294;
		  /* 82258294h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82258294h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258294h case    3:*/		return 0x82258298;
		  /* 82258298h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258298h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258298h case    4:*/		return 0x8225829C;
		  /* 8225829Ch */ case    5:  		/* lwz R30, <#[R4 + 1452]> */
		/* 8225829Ch case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x000005AC) );
		/* 8225829Ch case    5:*/		return 0x822582A0;
		  /* 822582A0h */ case    6:  		/* mr R31, R4 */
		/* 822582A0h case    6:*/		regs.R31 = regs.R4;
		/* 822582A0h case    6:*/		return 0x822582A4;
		  /* 822582A4h */ case    7:  		/* li R4, 964 */
		/* 822582A4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822582A4h case    7:*/		return 0x822582A8;
		  /* 822582A8h */ case    8:  		/* mr R3, R30 */
		/* 822582A8h case    8:*/		regs.R3 = regs.R30;
		/* 822582A8h case    8:*/		return 0x822582AC;
		  /* 822582ACh */ case    9:  		/* bl -245236 */
		/* 822582ACh case    9:*/		regs.LR = 0x822582B0; return 0x8221C4B8;
		/* 822582ACh case    9:*/		return 0x822582B0;
		  /* 822582B0h */ case   10:  		/* mr R11, R3 */
		/* 822582B0h case   10:*/		regs.R11 = regs.R3;
		/* 822582B0h case   10:*/		return 0x822582B4;
		  /* 822582B4h */ case   11:  		/* addic. R3, R3, 4 */
		/* 822582B4h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822582B4h case   11:*/		return 0x822582B8;
		  /* 822582B8h */ case   12:  		/* stw R30, <#[R11]> */
		/* 822582B8h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822582B8h case   12:*/		return 0x822582BC;
		  /* 822582BCh */ case   13:  		/* bc 12, CR0_EQ, 32 */
		/* 822582BCh case   13:*/		if ( regs.CR[0].eq ) { return 0x822582DC;  }
		/* 822582BCh case   13:*/		return 0x822582C0;
		  /* 822582C0h */ case   14:  		/* mr R5, R31 */
		/* 822582C0h case   14:*/		regs.R5 = regs.R31;
		/* 822582C0h case   14:*/		return 0x822582C4;
		  /* 822582C4h */ case   15:  		/* li R4, 144 */
		/* 822582C4h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x90);
		/* 822582C4h case   15:*/		return 0x822582C8;
		  /* 822582C8h */ case   16:  		/* bl -3064 */
		/* 822582C8h case   16:*/		regs.LR = 0x822582CC; return 0x822576D0;
		/* 822582C8h case   16:*/		return 0x822582CC;
		  /* 822582CCh */ case   17:  		/* lis R11, -32252 */
		/* 822582CCh case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822582CCh case   17:*/		return 0x822582D0;
		  /* 822582D0h */ case   18:  		/* addi R11, R11, 31576 */
		/* 822582D0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7B58);
		/* 822582D0h case   18:*/		return 0x822582D4;
		  /* 822582D4h */ case   19:  		/* stw R11, <#[R3]> */
		/* 822582D4h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822582D4h case   19:*/		return 0x822582D8;
		  /* 822582D8h */ case   20:  		/* b 8 */
		/* 822582D8h case   20:*/		return 0x822582E0;
		/* 822582D8h case   20:*/		return 0x822582DC;
	}
	return 0x822582DC;
} // Block from 82258288h-822582DCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 822582DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822582DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822582DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822582DC);
		  /* 822582DCh */ case    0:  		/* li R3, 0 */
		/* 822582DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822582DCh case    0:*/		return 0x822582E0;
	}
	return 0x822582E0;
} // Block from 822582DCh-822582E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822582E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822582E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822582E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822582E0);
		  /* 822582E0h */ case    0:  		/* addi R1, R1, 112 */
		/* 822582E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822582E0h case    0:*/		return 0x822582E4;
		  /* 822582E4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822582E4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822582E4h case    1:*/		return 0x822582E8;
	}
	return 0x822582E8;
} // Block from 822582E0h-822582E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822582E8h
// Function '??0IRTextureFetch@XGRAPHICS@@IAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822582E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822582E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822582E8);
		  /* 822582E8h */ case    0:  		/* mtspr LR, R12 */
		/* 822582E8h case    0:*/		regs.LR = regs.R12;
		/* 822582E8h case    0:*/		return 0x822582EC;
		  /* 822582ECh */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 822582ECh case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822582ECh case    1:*/		return 0x822582F0;
		  /* 822582F0h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 822582F0h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822582F0h case    2:*/		return 0x822582F4;
		  /* 822582F4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 822582F4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822582F4h case    3:*/		return 0x822582F8;
	}
	return 0x822582F8;
} // Block from 822582E8h-822582F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822582F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822582F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822582F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822582F8);
		  /* 822582F8h */ case    0:  		/* mfspr R12, LR */
		/* 822582F8h case    0:*/		regs.R12 = regs.LR;
		/* 822582F8h case    0:*/		return 0x822582FC;
		  /* 822582FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822582FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822582FCh case    1:*/		return 0x82258300;
		  /* 82258300h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82258300h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258300h case    2:*/		return 0x82258304;
		  /* 82258304h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82258304h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258304h case    3:*/		return 0x82258308;
		  /* 82258308h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258308h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258308h case    4:*/		return 0x8225830C;
		  /* 8225830Ch */ case    5:  		/* lwz R30, <#[R4 + 1452]> */
		/* 8225830Ch case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x000005AC) );
		/* 8225830Ch case    5:*/		return 0x82258310;
		  /* 82258310h */ case    6:  		/* mr R31, R4 */
		/* 82258310h case    6:*/		regs.R31 = regs.R4;
		/* 82258310h case    6:*/		return 0x82258314;
		  /* 82258314h */ case    7:  		/* li R4, 964 */
		/* 82258314h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258314h case    7:*/		return 0x82258318;
		  /* 82258318h */ case    8:  		/* mr R3, R30 */
		/* 82258318h case    8:*/		regs.R3 = regs.R30;
		/* 82258318h case    8:*/		return 0x8225831C;
		  /* 8225831Ch */ case    9:  		/* bl -245348 */
		/* 8225831Ch case    9:*/		regs.LR = 0x82258320; return 0x8221C4B8;
		/* 8225831Ch case    9:*/		return 0x82258320;
		  /* 82258320h */ case   10:  		/* mr R11, R3 */
		/* 82258320h case   10:*/		regs.R11 = regs.R3;
		/* 82258320h case   10:*/		return 0x82258324;
		  /* 82258324h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82258324h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258324h case   11:*/		return 0x82258328;
		  /* 82258328h */ case   12:  		/* stw R30, <#[R11]> */
		/* 82258328h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82258328h case   12:*/		return 0x8225832C;
		  /* 8225832Ch */ case   13:  		/* bc 12, CR0_EQ, 32 */
		/* 8225832Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8225834C;  }
		/* 8225832Ch case   13:*/		return 0x82258330;
		  /* 82258330h */ case   14:  		/* mr R5, R31 */
		/* 82258330h case   14:*/		regs.R5 = regs.R31;
		/* 82258330h case   14:*/		return 0x82258334;
		  /* 82258334h */ case   15:  		/* li R4, 145 */
		/* 82258334h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x91);
		/* 82258334h case   15:*/		return 0x82258338;
		  /* 82258338h */ case   16:  		/* bl -3176 */
		/* 82258338h case   16:*/		regs.LR = 0x8225833C; return 0x822576D0;
		/* 82258338h case   16:*/		return 0x8225833C;
		  /* 8225833Ch */ case   17:  		/* lis R11, -32252 */
		/* 8225833Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225833Ch case   17:*/		return 0x82258340;
		  /* 82258340h */ case   18:  		/* addi R11, R11, 31216 */
		/* 82258340h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x79F0);
		/* 82258340h case   18:*/		return 0x82258344;
		  /* 82258344h */ case   19:  		/* stw R11, <#[R3]> */
		/* 82258344h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82258344h case   19:*/		return 0x82258348;
		  /* 82258348h */ case   20:  		/* b 8 */
		/* 82258348h case   20:*/		return 0x82258350;
		/* 82258348h case   20:*/		return 0x8225834C;
	}
	return 0x8225834C;
} // Block from 822582F8h-8225834Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225834Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225834C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225834C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225834C);
		  /* 8225834Ch */ case    0:  		/* li R3, 0 */
		/* 8225834Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225834Ch case    0:*/		return 0x82258350;
	}
	return 0x82258350;
} // Block from 8225834Ch-82258350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258350);
		  /* 82258350h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258350h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258350h case    0:*/		return 0x82258354;
		  /* 82258354h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258354h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258354h case    1:*/		return 0x82258358;
		  /* 82258358h */ case    2:  		/* mtspr LR, R12 */
		/* 82258358h case    2:*/		regs.LR = regs.R12;
		/* 82258358h case    2:*/		return 0x8225835C;
		  /* 8225835Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8225835Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225835Ch case    3:*/		return 0x82258360;
		  /* 82258360h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82258360h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258360h case    4:*/		return 0x82258364;
		  /* 82258364h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82258364h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258364h case    5:*/		return 0x82258368;
	}
	return 0x82258368;
} // Block from 82258350h-82258368h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82258368h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258368);
		  /* 82258368h */ case    0:  		/* mfspr R12, LR */
		/* 82258368h case    0:*/		regs.R12 = regs.LR;
		/* 82258368h case    0:*/		return 0x8225836C;
		  /* 8225836Ch */ case    1:  		/* bl -1863952 */
		/* 8225836Ch case    1:*/		regs.LR = 0x82258370; return 0x8209125C;
		/* 8225836Ch case    1:*/		return 0x82258370;
		  /* 82258370h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258370h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258370h case    2:*/		return 0x82258374;
		  /* 82258374h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82258374h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82258374h case    3:*/		return 0x82258378;
		  /* 82258378h */ case    4:  		/* mr R30, R3 */
		/* 82258378h case    4:*/		regs.R30 = regs.R3;
		/* 82258378h case    4:*/		return 0x8225837C;
		  /* 8225837Ch */ case    5:  		/* mr R31, R4 */
		/* 8225837Ch case    5:*/		regs.R31 = regs.R4;
		/* 8225837Ch case    5:*/		return 0x82258380;
		  /* 82258380h */ case    6:  		/* li R4, 964 */
		/* 82258380h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258380h case    6:*/		return 0x82258384;
		  /* 82258384h */ case    7:  		/* mr R3, R29 */
		/* 82258384h case    7:*/		regs.R3 = regs.R29;
		/* 82258384h case    7:*/		return 0x82258388;
		  /* 82258388h */ case    8:  		/* bl -245456 */
		/* 82258388h case    8:*/		regs.LR = 0x8225838C; return 0x8221C4B8;
		/* 82258388h case    8:*/		return 0x8225838C;
		  /* 8225838Ch */ case    9:  		/* mr R11, R3 */
		/* 8225838Ch case    9:*/		regs.R11 = regs.R3;
		/* 8225838Ch case    9:*/		return 0x82258390;
		  /* 82258390h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82258390h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258390h case   10:*/		return 0x82258394;
		  /* 82258394h */ case   11:  		/* stw R29, <#[R11]> */
		/* 82258394h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82258394h case   11:*/		return 0x82258398;
		  /* 82258398h */ case   12:  		/* bc 12, CR0_EQ, 44 */
		/* 82258398h case   12:*/		if ( regs.CR[0].eq ) { return 0x822583C4;  }
		/* 82258398h case   12:*/		return 0x8225839C;
		  /* 8225839Ch */ case   13:  		/* mr R5, R31 */
		/* 8225839Ch case   13:*/		regs.R5 = regs.R31;
		/* 8225839Ch case   13:*/		return 0x822583A0;
		  /* 822583A0h */ case   14:  		/* mr R4, R30 */
		/* 822583A0h case   14:*/		regs.R4 = regs.R30;
		/* 822583A0h case   14:*/		return 0x822583A4;
		  /* 822583A4h */ case   15:  		/* bl -5556 */
		/* 822583A4h case   15:*/		regs.LR = 0x822583A8; return 0x82256DF0;
		/* 822583A4h case   15:*/		return 0x822583A8;
	}
	return 0x822583A8;
} // Block from 82258368h-822583A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822583A8h
// Function '??0IRExportColorAndFog@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822583A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822583A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822583A8);
		  /* 822583A8h */ case    0:  		/* lis R10, -32252 */
		/* 822583A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822583A8h case    0:*/		return 0x822583AC;
		  /* 822583ACh */ case    1:  		/* li R11, 1 */
		/* 822583ACh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822583ACh case    1:*/		return 0x822583B0;
		  /* 822583B0h */ case    2:  		/* addi R10, R10, 29416 */
		/* 822583B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x72E8);
		/* 822583B0h case    2:*/		return 0x822583B4;
		  /* 822583B4h */ case    3:  		/* stw R11, <#[R3 + 16]> */
		/* 822583B4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822583B4h case    3:*/		return 0x822583B8;
		  /* 822583B8h */ case    4:  		/* stw R10, <#[R3]> */
		/* 822583B8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822583B8h case    4:*/		return 0x822583BC;
		  /* 822583BCh */ case    5:  		/* stw R11, <#[R3 + 20]> */
		/* 822583BCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 822583BCh case    5:*/		return 0x822583C0;
		  /* 822583C0h */ case    6:  		/* b 8 */
		/* 822583C0h case    6:*/		return 0x822583C8;
		/* 822583C0h case    6:*/		return 0x822583C4;
	}
	return 0x822583C4;
} // Block from 822583A8h-822583C4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822583C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822583C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822583C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822583C4);
		  /* 822583C4h */ case    0:  		/* li R3, 0 */
		/* 822583C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822583C4h case    0:*/		return 0x822583C8;
	}
	return 0x822583C8;
} // Block from 822583C4h-822583C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822583C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822583C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822583C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822583C8);
		  /* 822583C8h */ case    0:  		/* addi R1, R1, 112 */
		/* 822583C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822583C8h case    0:*/		return 0x822583CC;
		  /* 822583CCh */ case    1:  		/* b -1863968 */
		/* 822583CCh case    1:*/		return 0x820912AC;
		/* 822583CCh case    1:*/		return 0x822583D0;
	}
	return 0x822583D0;
} // Block from 822583C8h-822583D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822583D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822583D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822583D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822583D0);
		  /* 822583D0h */ case    0:  		/* mfspr R12, LR */
		/* 822583D0h case    0:*/		regs.R12 = regs.LR;
		/* 822583D0h case    0:*/		return 0x822583D4;
		  /* 822583D4h */ case    1:  		/* bl -1864056 */
		/* 822583D4h case    1:*/		regs.LR = 0x822583D8; return 0x8209125C;
		/* 822583D4h case    1:*/		return 0x822583D8;
		  /* 822583D8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822583D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822583D8h case    2:*/		return 0x822583DC;
		  /* 822583DCh */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 822583DCh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 822583DCh case    3:*/		return 0x822583E0;
		  /* 822583E0h */ case    4:  		/* mr R30, R3 */
		/* 822583E0h case    4:*/		regs.R30 = regs.R3;
		/* 822583E0h case    4:*/		return 0x822583E4;
		  /* 822583E4h */ case    5:  		/* mr R31, R4 */
		/* 822583E4h case    5:*/		regs.R31 = regs.R4;
		/* 822583E4h case    5:*/		return 0x822583E8;
		  /* 822583E8h */ case    6:  		/* li R4, 964 */
		/* 822583E8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822583E8h case    6:*/		return 0x822583EC;
		  /* 822583ECh */ case    7:  		/* mr R3, R29 */
		/* 822583ECh case    7:*/		regs.R3 = regs.R29;
		/* 822583ECh case    7:*/		return 0x822583F0;
		  /* 822583F0h */ case    8:  		/* bl -245560 */
		/* 822583F0h case    8:*/		regs.LR = 0x822583F4; return 0x8221C4B8;
		/* 822583F0h case    8:*/		return 0x822583F4;
		  /* 822583F4h */ case    9:  		/* mr R11, R3 */
		/* 822583F4h case    9:*/		regs.R11 = regs.R3;
		/* 822583F4h case    9:*/		return 0x822583F8;
	}
	return 0x822583F8;
} // Block from 822583D0h-822583F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822583F8h
// Function '?InstType@IRExportColorAndFog@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822583F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822583F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822583F8);
		  /* 822583F8h */ case    0:  		/* addic. R3, R3, 4 */
		/* 822583F8h case    0:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822583F8h case    0:*/		return 0x822583FC;
		  /* 822583FCh */ case    1:  		/* stw R29, <#[R11]> */
		/* 822583FCh case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 822583FCh case    1:*/		return 0x82258400;
		  /* 82258400h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 82258400h case    2:*/		if ( regs.CR[0].eq ) { return 0x82258430;  }
		/* 82258400h case    2:*/		return 0x82258404;
		  /* 82258404h */ case    3:  		/* mr R5, R31 */
		/* 82258404h case    3:*/		regs.R5 = regs.R31;
		/* 82258404h case    3:*/		return 0x82258408;
	}
	return 0x82258408;
} // Block from 822583F8h-82258408h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258408h
// Function '??0IRCmp2@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258408);
		  /* 82258408h */ case    0:  		/* mr R4, R30 */
		/* 82258408h case    0:*/		regs.R4 = regs.R30;
		/* 82258408h case    0:*/		return 0x8225840C;
		  /* 8225840Ch */ case    1:  		/* bl -5660 */
		/* 8225840Ch case    1:*/		regs.LR = 0x82258410; return 0x82256DF0;
		/* 8225840Ch case    1:*/		return 0x82258410;
		  /* 82258410h */ case    2:  		/* li R10, 1 */
		/* 82258410h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82258410h case    2:*/		return 0x82258414;
		  /* 82258414h */ case    3:  		/* lis R11, -32252 */
		/* 82258414h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82258414h case    3:*/		return 0x82258418;
		  /* 82258418h */ case    4:  		/* stw R10, <#[R3 + 16]> */
		/* 82258418h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82258418h case    4:*/		return 0x8225841C;
		  /* 8225841Ch */ case    5:  		/* li R10, 2 */
		/* 8225841Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8225841Ch case    5:*/		return 0x82258420;
		  /* 82258420h */ case    6:  		/* addi R11, R11, 29520 */
		/* 82258420h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7350);
		/* 82258420h case    6:*/		return 0x82258424;
		  /* 82258424h */ case    7:  		/* stw R10, <#[R3 + 20]> */
		/* 82258424h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82258424h case    7:*/		return 0x82258428;
		  /* 82258428h */ case    8:  		/* stw R11, <#[R3]> */
		/* 82258428h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82258428h case    8:*/		return 0x8225842C;
		  /* 8225842Ch */ case    9:  		/* b 8 */
		/* 8225842Ch case    9:*/		return 0x82258434;
		/* 8225842Ch case    9:*/		return 0x82258430;
	}
	return 0x82258430;
} // Block from 82258408h-82258430h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82258430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258430);
		  /* 82258430h */ case    0:  		/* li R3, 0 */
		/* 82258430h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82258430h case    0:*/		return 0x82258434;
	}
	return 0x82258434;
} // Block from 82258430h-82258434h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258434);
		  /* 82258434h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258434h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258434h case    0:*/		return 0x82258438;
		  /* 82258438h */ case    1:  		/* b -1864076 */
		/* 82258438h case    1:*/		return 0x820912AC;
		/* 82258438h case    1:*/		return 0x8225843C;
		  /* 8225843Ch */ case    2:  		/* nop */
		/* 8225843Ch case    2:*/		cpu::op::nop();
		/* 8225843Ch case    2:*/		return 0x82258440;
	}
	return 0x82258440;
} // Block from 82258434h-82258440h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258440h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258440);
		  /* 82258440h */ case    0:  		/* mfspr R12, LR */
		/* 82258440h case    0:*/		regs.R12 = regs.LR;
		/* 82258440h case    0:*/		return 0x82258444;
		  /* 82258444h */ case    1:  		/* bl -1864168 */
		/* 82258444h case    1:*/		regs.LR = 0x82258448; return 0x8209125C;
		/* 82258444h case    1:*/		return 0x82258448;
		  /* 82258448h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258448h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258448h case    2:*/		return 0x8225844C;
		  /* 8225844Ch */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 8225844Ch case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 8225844Ch case    3:*/		return 0x82258450;
		  /* 82258450h */ case    4:  		/* mr R30, R3 */
		/* 82258450h case    4:*/		regs.R30 = regs.R3;
		/* 82258450h case    4:*/		return 0x82258454;
		  /* 82258454h */ case    5:  		/* mr R31, R4 */
		/* 82258454h case    5:*/		regs.R31 = regs.R4;
		/* 82258454h case    5:*/		return 0x82258458;
		  /* 82258458h */ case    6:  		/* li R4, 964 */
		/* 82258458h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258458h case    6:*/		return 0x8225845C;
		  /* 8225845Ch */ case    7:  		/* mr R3, R29 */
		/* 8225845Ch case    7:*/		regs.R3 = regs.R29;
		/* 8225845Ch case    7:*/		return 0x82258460;
		  /* 82258460h */ case    8:  		/* bl -245672 */
		/* 82258460h case    8:*/		regs.LR = 0x82258464; return 0x8221C4B8;
		/* 82258460h case    8:*/		return 0x82258464;
		  /* 82258464h */ case    9:  		/* mr R11, R3 */
		/* 82258464h case    9:*/		regs.R11 = regs.R3;
		/* 82258464h case    9:*/		return 0x82258468;
		  /* 82258468h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82258468h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258468h case   10:*/		return 0x8225846C;
		  /* 8225846Ch */ case   11:  		/* stw R29, <#[R11]> */
		/* 8225846Ch case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 8225846Ch case   11:*/		return 0x82258470;
		  /* 82258470h */ case   12:  		/* bc 12, CR0_EQ, 48 */
		/* 82258470h case   12:*/		if ( regs.CR[0].eq ) { return 0x822584A0;  }
		/* 82258470h case   12:*/		return 0x82258474;
		  /* 82258474h */ case   13:  		/* mr R5, R31 */
		/* 82258474h case   13:*/		regs.R5 = regs.R31;
		/* 82258474h case   13:*/		return 0x82258478;
		  /* 82258478h */ case   14:  		/* mr R4, R30 */
		/* 82258478h case   14:*/		regs.R4 = regs.R30;
		/* 82258478h case   14:*/		return 0x8225847C;
		  /* 8225847Ch */ case   15:  		/* bl -5772 */
		/* 8225847Ch case   15:*/		regs.LR = 0x82258480; return 0x82256DF0;
		/* 8225847Ch case   15:*/		return 0x82258480;
		  /* 82258480h */ case   16:  		/* li R10, 1 */
		/* 82258480h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82258480h case   16:*/		return 0x82258484;
		  /* 82258484h */ case   17:  		/* lis R11, -32252 */
		/* 82258484h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82258484h case   17:*/		return 0x82258488;
		  /* 82258488h */ case   18:  		/* stw R10, <#[R3 + 16]> */
		/* 82258488h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82258488h case   18:*/		return 0x8225848C;
		  /* 8225848Ch */ case   19:  		/* li R10, 3 */
		/* 8225848Ch case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8225848Ch case   19:*/		return 0x82258490;
	}
	return 0x82258490;
} // Block from 82258440h-82258490h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82258490h
// Function '?InstType@IRCmp2@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258490);
		  /* 82258490h */ case    0:  		/* addi R11, R11, 16056 */
		/* 82258490h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3EB8);
		/* 82258490h case    0:*/		return 0x82258494;
		  /* 82258494h */ case    1:  		/* stw R10, <#[R3 + 20]> */
		/* 82258494h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82258494h case    1:*/		return 0x82258498;
		  /* 82258498h */ case    2:  		/* stw R11, <#[R3]> */
		/* 82258498h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82258498h case    2:*/		return 0x8225849C;
		  /* 8225849Ch */ case    3:  		/* b 8 */
		/* 8225849Ch case    3:*/		return 0x822584A4;
		/* 8225849Ch case    3:*/		return 0x822584A0;
	}
	return 0x822584A0;
} // Block from 82258490h-822584A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822584A0h
// Function '??0IRKill@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822584A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822584A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822584A0);
		  /* 822584A0h */ case    0:  		/* li R3, 0 */
		/* 822584A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822584A0h case    0:*/		return 0x822584A4;
	}
	return 0x822584A4;
} // Block from 822584A0h-822584A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822584A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822584A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822584A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822584A4);
		  /* 822584A4h */ case    0:  		/* addi R1, R1, 112 */
		/* 822584A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822584A4h case    0:*/		return 0x822584A8;
		  /* 822584A8h */ case    1:  		/* b -1864188 */
		/* 822584A8h case    1:*/		return 0x820912AC;
		/* 822584A8h case    1:*/		return 0x822584AC;
		  /* 822584ACh */ case    2:  		/* nop */
		/* 822584ACh case    2:*/		cpu::op::nop();
		/* 822584ACh case    2:*/		return 0x822584B0;
	}
	return 0x822584B0;
} // Block from 822584A4h-822584B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822584B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822584B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822584B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822584B0);
		  /* 822584B0h */ case    0:  		/* mfspr R12, LR */
		/* 822584B0h case    0:*/		regs.R12 = regs.LR;
		/* 822584B0h case    0:*/		return 0x822584B4;
		  /* 822584B4h */ case    1:  		/* bl -1864288 */
		/* 822584B4h case    1:*/		regs.LR = 0x822584B8; return 0x82091254;
		/* 822584B4h case    1:*/		return 0x822584B8;
		  /* 822584B8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822584B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822584B8h case    2:*/		return 0x822584BC;
		  /* 822584BCh */ case    3:  		/* lwz R27, <#[R4 + 1452]> */
		/* 822584BCh case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R4 + 0x000005AC) );
		/* 822584BCh case    3:*/		return 0x822584C0;
		  /* 822584C0h */ case    4:  		/* mr R30, R3 */
		/* 822584C0h case    4:*/		regs.R30 = regs.R3;
		/* 822584C0h case    4:*/		return 0x822584C4;
		  /* 822584C4h */ case    5:  		/* mr R31, R4 */
		/* 822584C4h case    5:*/		regs.R31 = regs.R4;
		/* 822584C4h case    5:*/		return 0x822584C8;
		  /* 822584C8h */ case    6:  		/* li R4, 964 */
		/* 822584C8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822584C8h case    6:*/		return 0x822584CC;
		  /* 822584CCh */ case    7:  		/* mr R3, R27 */
		/* 822584CCh case    7:*/		regs.R3 = regs.R27;
		/* 822584CCh case    7:*/		return 0x822584D0;
		  /* 822584D0h */ case    8:  		/* mr R29, R5 */
		/* 822584D0h case    8:*/		regs.R29 = regs.R5;
		/* 822584D0h case    8:*/		return 0x822584D4;
		  /* 822584D4h */ case    9:  		/* mr R28, R6 */
		/* 822584D4h case    9:*/		regs.R28 = regs.R6;
		/* 822584D4h case    9:*/		return 0x822584D8;
		  /* 822584D8h */ case   10:  		/* bl -245792 */
		/* 822584D8h case   10:*/		regs.LR = 0x822584DC; return 0x8221C4B8;
		/* 822584D8h case   10:*/		return 0x822584DC;
		  /* 822584DCh */ case   11:  		/* mr R11, R3 */
		/* 822584DCh case   11:*/		regs.R11 = regs.R3;
		/* 822584DCh case   11:*/		return 0x822584E0;
		  /* 822584E0h */ case   12:  		/* addic. R3, R3, 4 */
		/* 822584E0h case   12:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822584E0h case   12:*/		return 0x822584E4;
		  /* 822584E4h */ case   13:  		/* stw R27, <#[R11]> */
		/* 822584E4h case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 822584E4h case   13:*/		return 0x822584E8;
		  /* 822584E8h */ case   14:  		/* bc 12, CR0_EQ, 28 */
		/* 822584E8h case   14:*/		if ( regs.CR[0].eq ) { return 0x82258504;  }
		/* 822584E8h case   14:*/		return 0x822584EC;
		  /* 822584ECh */ case   15:  		/* mr R7, R28 */
		/* 822584ECh case   15:*/		regs.R7 = regs.R28;
		/* 822584ECh case   15:*/		return 0x822584F0;
		  /* 822584F0h */ case   16:  		/* mr R6, R29 */
		/* 822584F0h case   16:*/		regs.R6 = regs.R29;
		/* 822584F0h case   16:*/		return 0x822584F4;
		  /* 822584F4h */ case   17:  		/* mr R5, R31 */
		/* 822584F4h case   17:*/		regs.R5 = regs.R31;
		/* 822584F4h case   17:*/		return 0x822584F8;
		  /* 822584F8h */ case   18:  		/* mr R4, R30 */
		/* 822584F8h case   18:*/		regs.R4 = regs.R30;
		/* 822584F8h case   18:*/		return 0x822584FC;
		  /* 822584FCh */ case   19:  		/* bl -3396 */
		/* 822584FCh case   19:*/		regs.LR = 0x82258500; return 0x822577B8;
		/* 822584FCh case   19:*/		return 0x82258500;
		  /* 82258500h */ case   20:  		/* b 8 */
		/* 82258500h case   20:*/		return 0x82258508;
		/* 82258500h case   20:*/		return 0x82258504;
	}
	return 0x82258504;
} // Block from 822584B0h-82258504h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82258504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258504);
		  /* 82258504h */ case    0:  		/* li R3, 0 */
		/* 82258504h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82258504h case    0:*/		return 0x82258508;
	}
	return 0x82258508;
} // Block from 82258504h-82258508h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258508);
		  /* 82258508h */ case    0:  		/* addi R1, R1, 128 */
		/* 82258508h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82258508h case    0:*/		return 0x8225850C;
		  /* 8225850Ch */ case    1:  		/* b -1864296 */
		/* 8225850Ch case    1:*/		return 0x820912A4;
		/* 8225850Ch case    1:*/		return 0x82258510;
	}
	return 0x82258510;
} // Block from 82258508h-82258510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258510);
		  /* 82258510h */ case    0:  		/* mfspr R12, LR */
		/* 82258510h case    0:*/		regs.R12 = regs.LR;
		/* 82258510h case    0:*/		return 0x82258514;
		  /* 82258514h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82258514h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258514h case    1:*/		return 0x82258518;
	}
	return 0x82258518;
} // Block from 82258510h-82258518h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258518h
// Function '?InstType@IRKill@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258518);
		  /* 82258518h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 82258518h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258518h case    0:*/		return 0x8225851C;
		  /* 8225851Ch */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225851Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225851Ch case    1:*/		return 0x82258520;
		  /* 82258520h */ case    2:  		/* mr R31, R3 */
		/* 82258520h case    2:*/		regs.R31 = regs.R3;
		/* 82258520h case    2:*/		return 0x82258524;
		  /* 82258524h */ case    3:  		/* bl -5940 */
		/* 82258524h case    3:*/		regs.LR = 0x82258528; return 0x82256DF0;
		/* 82258524h case    3:*/		return 0x82258528;
	}
	return 0x82258528;
} // Block from 82258518h-82258528h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258528h
// Function '??0IRKill2@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258528);
		  /* 82258528h */ case    0:  		/* lis R10, -32252 */
		/* 82258528h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82258528h case    0:*/		return 0x8225852C;
		  /* 8225852Ch */ case    1:  		/* lis R9, -32252 */
		/* 8225852Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8225852Ch case    1:*/		return 0x82258530;
		  /* 82258530h */ case    2:  		/* li R11, 0 */
		/* 82258530h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82258530h case    2:*/		return 0x82258534;
		  /* 82258534h */ case    3:  		/* addi R10, R10, 29312 */
		/* 82258534h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7280);
		/* 82258534h case    3:*/		return 0x82258538;
		  /* 82258538h */ case    4:  		/* stw R11, <#[R3 + 20]> */
		/* 82258538h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82258538h case    4:*/		return 0x8225853C;
		  /* 8225853Ch */ case    5:  		/* stw R11, <#[R3 + 16]> */
		/* 8225853Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8225853Ch case    5:*/		return 0x82258540;
		  /* 82258540h */ case    6:  		/* stw R10, <#[R3]> */
		/* 82258540h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82258540h case    6:*/		return 0x82258544;
		  /* 82258544h */ case    7:  		/* lwz R10, <#[R9 + 28876]> */
		/* 82258544h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x000070CC) );
		/* 82258544h case    7:*/		return 0x82258548;
		  /* 82258548h */ case    8:  		/* stw R11, <#[R3 + 20]> */
		/* 82258548h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82258548h case    8:*/		return 0x8225854C;
		  /* 8225854Ch */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 8225854Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8225854Ch case    9:*/		return 0x82258550;
		  /* 82258550h */ case   10:  		/* stw R10, <#[R3 + 128]> */
		/* 82258550h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000080) );
		/* 82258550h case   10:*/		return 0x82258554;
		  /* 82258554h */ case   11:  		/* addi R1, R1, 96 */
		/* 82258554h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82258554h case   11:*/		return 0x82258558;
		  /* 82258558h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258558h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258558h case   12:*/		return 0x8225855C;
		  /* 8225855Ch */ case   13:  		/* mtspr LR, R12 */
		/* 8225855Ch case   13:*/		regs.LR = regs.R12;
		/* 8225855Ch case   13:*/		return 0x82258560;
		  /* 82258560h */ case   14:  		/* ld R31, <#[R1 - 16]> */
		/* 82258560h case   14:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258560h case   14:*/		return 0x82258564;
		  /* 82258564h */ case   15:  		/* bclr 20, CR0_LT */
		/* 82258564h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258564h case   15:*/		return 0x82258568;
	}
	return 0x82258568;
} // Block from 82258528h-82258568h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82258568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258568);
		  /* 82258568h */ case    0:  		/* mfspr R12, LR */
		/* 82258568h case    0:*/		regs.R12 = regs.LR;
		/* 82258568h case    0:*/		return 0x8225856C;
		  /* 8225856Ch */ case    1:  		/* bl -1864464 */
		/* 8225856Ch case    1:*/		regs.LR = 0x82258570; return 0x8209125C;
		/* 8225856Ch case    1:*/		return 0x82258570;
		  /* 82258570h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258570h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258570h case    2:*/		return 0x82258574;
		  /* 82258574h */ case    3:  		/* lwz R29, <#[R4 + 1452]> */
		/* 82258574h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x000005AC) );
		/* 82258574h case    3:*/		return 0x82258578;
		  /* 82258578h */ case    4:  		/* mr R30, R3 */
		/* 82258578h case    4:*/		regs.R30 = regs.R3;
		/* 82258578h case    4:*/		return 0x8225857C;
		  /* 8225857Ch */ case    5:  		/* mr R31, R4 */
		/* 8225857Ch case    5:*/		regs.R31 = regs.R4;
		/* 8225857Ch case    5:*/		return 0x82258580;
		  /* 82258580h */ case    6:  		/* li R4, 964 */
		/* 82258580h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82258580h case    6:*/		return 0x82258584;
		  /* 82258584h */ case    7:  		/* mr R3, R29 */
		/* 82258584h case    7:*/		regs.R3 = regs.R29;
		/* 82258584h case    7:*/		return 0x82258588;
		  /* 82258588h */ case    8:  		/* bl -245968 */
		/* 82258588h case    8:*/		regs.LR = 0x8225858C; return 0x8221C4B8;
		/* 82258588h case    8:*/		return 0x8225858C;
		  /* 8225858Ch */ case    9:  		/* mr R11, R3 */
		/* 8225858Ch case    9:*/		regs.R11 = regs.R3;
		/* 8225858Ch case    9:*/		return 0x82258590;
		  /* 82258590h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82258590h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258590h case   10:*/		return 0x82258594;
		  /* 82258594h */ case   11:  		/* stw R29, <#[R11]> */
		/* 82258594h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82258594h case   11:*/		return 0x82258598;
		  /* 82258598h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 82258598h case   12:*/		if ( regs.CR[0].eq ) { return 0x822585AC;  }
		/* 82258598h case   12:*/		return 0x8225859C;
		  /* 8225859Ch */ case   13:  		/* mr R5, R31 */
		/* 8225859Ch case   13:*/		regs.R5 = regs.R31;
		/* 8225859Ch case   13:*/		return 0x822585A0;
	}
	return 0x822585A0;
} // Block from 82258568h-822585A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822585A0h
// Function '?OperationInputs@IRBinary@XGRAPHICS@@UBA?BHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822585A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822585A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822585A0);
		  /* 822585A0h */ case    0:  		/* mr R4, R30 */
		/* 822585A0h case    0:*/		regs.R4 = regs.R30;
		/* 822585A0h case    0:*/		return 0x822585A4;
		  /* 822585A4h */ case    1:  		/* bl -148 */
		/* 822585A4h case    1:*/		regs.LR = 0x822585A8; return 0x82258510;
		/* 822585A4h case    1:*/		return 0x822585A8;
	}
	return 0x822585A8;
} // Block from 822585A0h-822585A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822585A8h
// Function '?InstType@IRKill2@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822585A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822585A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822585A8);
		  /* 822585A8h */ case    0:  		/* b 8 */
		/* 822585A8h case    0:*/		return 0x822585B0;
		/* 822585A8h case    0:*/		return 0x822585AC;
	}
	return 0x822585AC;
} // Block from 822585A8h-822585ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822585ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822585AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822585AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822585AC);
		  /* 822585ACh */ case    0:  		/* li R3, 0 */
		/* 822585ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822585ACh case    0:*/		return 0x822585B0;
	}
	return 0x822585B0;
} // Block from 822585ACh-822585B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822585B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822585B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822585B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822585B0);
		  /* 822585B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 822585B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822585B0h case    0:*/		return 0x822585B4;
		  /* 822585B4h */ case    1:  		/* b -1864456 */
		/* 822585B4h case    1:*/		return 0x820912AC;
		/* 822585B4h case    1:*/		return 0x822585B8;
	}
	return 0x822585B8;
} // Block from 822585B0h-822585B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822585B8h
// Function '??0IRCmp1S@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822585B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822585B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822585B8);
		  /* 822585B8h */ case    0:  		/* mfspr R12, LR */
		/* 822585B8h case    0:*/		regs.R12 = regs.LR;
		/* 822585B8h case    0:*/		return 0x822585BC;
		  /* 822585BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822585BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822585BCh case    1:*/		return 0x822585C0;
		  /* 822585C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822585C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822585C0h case    2:*/		return 0x822585C4;
		  /* 822585C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822585C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822585C4h case    3:*/		return 0x822585C8;
		  /* 822585C8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822585C8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822585C8h case    4:*/		return 0x822585CC;
		  /* 822585CCh */ case    5:  		/* stw R4, <#[R3 + 32]> */
		/* 822585CCh case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000020) );
		/* 822585CCh case    5:*/		return 0x822585D0;
		  /* 822585D0h */ case    6:  		/* mr R31, R3 */
		/* 822585D0h case    6:*/		regs.R31 = regs.R3;
		/* 822585D0h case    6:*/		return 0x822585D4;
		  /* 822585D4h */ case    7:  		/* addi R3, R4, 128 */
		/* 822585D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R4,0x80);
		/* 822585D4h case    7:*/		return 0x822585D8;
		  /* 822585D8h */ case    8:  		/* bl -19832 */
		/* 822585D8h case    8:*/		regs.LR = 0x822585DC; return 0x82253860;
		/* 822585D8h case    8:*/		return 0x822585DC;
		  /* 822585DCh */ case    9:  		/* lwz R11, <#[R31 + 32]> */
		/* 822585DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 822585DCh case    9:*/		return 0x822585E0;
		  /* 822585E0h */ case   10:  		/* stw R3, <#[R31 + 28]> */
		/* 822585E0h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 822585E0h case   10:*/		return 0x822585E4;
		  /* 822585E4h */ case   11:  		/* addi R10, R3, 1 */
		/* 822585E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x1);
		/* 822585E4h case   11:*/		return 0x822585E8;
		  /* 822585E8h */ case   12:  		/* rlwinm R30, R10, 2, 0, 29 */
		/* 822585E8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R10);
		/* 822585E8h case   12:*/		return 0x822585EC;
		  /* 822585ECh */ case   13:  		/* lwz R11, <#[R11 + 12]> */
		/* 822585ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822585ECh case   13:*/		return 0x822585F0;
		  /* 822585F0h */ case   14:  		/* mr R4, R30 */
		/* 822585F0h case   14:*/		regs.R4 = regs.R30;
		/* 822585F0h case   14:*/		return 0x822585F4;
		  /* 822585F4h */ case   15:  		/* stw R11, <#[R31 + 36]> */
		/* 822585F4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 822585F4h case   15:*/		return 0x822585F8;
		  /* 822585F8h */ case   16:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822585F8h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822585F8h case   16:*/		return 0x822585FC;
		  /* 822585FCh */ case   17:  		/* bl -246084 */
		/* 822585FCh case   17:*/		regs.LR = 0x82258600; return 0x8221C4B8;
		/* 822585FCh case   17:*/		return 0x82258600;
		  /* 82258600h */ case   18:  		/* stw R3, <#[R31 + 8]> */
		/* 82258600h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82258600h case   18:*/		return 0x82258604;
		  /* 82258604h */ case   19:  		/* mr R4, R30 */
		/* 82258604h case   19:*/		regs.R4 = regs.R30;
		/* 82258604h case   19:*/		return 0x82258608;
		  /* 82258608h */ case   20:  		/* lwz R11, <#[R31 + 36]> */
		/* 82258608h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82258608h case   20:*/		return 0x8225860C;
		  /* 8225860Ch */ case   21:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225860Ch case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225860Ch case   21:*/		return 0x82258610;
		  /* 82258610h */ case   22:  		/* bl -246104 */
		/* 82258610h case   22:*/		regs.LR = 0x82258614; return 0x8221C4B8;
		/* 82258610h case   22:*/		return 0x82258614;
		  /* 82258614h */ case   23:  		/* stw R3, <#[R31 + 4]> */
		/* 82258614h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 82258614h case   23:*/		return 0x82258618;
		  /* 82258618h */ case   24:  		/* lwz R11, <#[R31 + 36]> */
		/* 82258618h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82258618h case   24:*/		return 0x8225861C;
		  /* 8225861Ch */ case   25:  		/* mr R4, R30 */
		/* 8225861Ch case   25:*/		regs.R4 = regs.R30;
		/* 8225861Ch case   25:*/		return 0x82258620;
		  /* 82258620h */ case   26:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258620h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258620h case   26:*/		return 0x82258624;
		  /* 82258624h */ case   27:  		/* bl -246124 */
		/* 82258624h case   27:*/		regs.LR = 0x82258628; return 0x8221C4B8;
		/* 82258624h case   27:*/		return 0x82258628;
		  /* 82258628h */ case   28:  		/* stw R3, <#[R31 + 16]> */
		/* 82258628h case   28:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82258628h case   28:*/		return 0x8225862C;
		  /* 8225862Ch */ case   29:  		/* mr R4, R30 */
		/* 8225862Ch case   29:*/		regs.R4 = regs.R30;
		/* 8225862Ch case   29:*/		return 0x82258630;
	}
	return 0x82258630;
} // Block from 822585B8h-82258630h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82258630h
// Function '?InstType@IRCmp1S@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258630);
		  /* 82258630h */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 82258630h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82258630h case    0:*/		return 0x82258634;
		  /* 82258634h */ case    1:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258634h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258634h case    1:*/		return 0x82258638;
		  /* 82258638h */ case    2:  		/* bl -246144 */
		/* 82258638h case    2:*/		regs.LR = 0x8225863C; return 0x8221C4B8;
		/* 82258638h case    2:*/		return 0x8225863C;
		  /* 8225863Ch */ case    3:  		/* stw R3, <#[R31 + 12]> */
		/* 8225863Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225863Ch case    3:*/		return 0x82258640;
	}
	return 0x82258640;
} // Block from 82258630h-82258640h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258640h
// Function '??0IRCmp1D@XGRAPHICS@@AAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258640);
		  /* 82258640h */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 82258640h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82258640h case    0:*/		return 0x82258644;
		  /* 82258644h */ case    1:  		/* mr R4, R30 */
		/* 82258644h case    1:*/		regs.R4 = regs.R30;
		/* 82258644h case    1:*/		return 0x82258648;
		  /* 82258648h */ case    2:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258648h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258648h case    2:*/		return 0x8225864C;
		  /* 8225864Ch */ case    3:  		/* bl -246164 */
		/* 8225864Ch case    3:*/		regs.LR = 0x82258650; return 0x8221C4B8;
		/* 8225864Ch case    3:*/		return 0x82258650;
		  /* 82258650h */ case    4:  		/* stw R3, <#[R31]> */
		/* 82258650h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82258650h case    4:*/		return 0x82258654;
		  /* 82258654h */ case    5:  		/* lwz R11, <#[R31 + 28]> */
		/* 82258654h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258654h case    5:*/		return 0x82258658;
		  /* 82258658h */ case    6:  		/* lwz R10, <#[R31 + 36]> */
		/* 82258658h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 82258658h case    6:*/		return 0x8225865C;
		  /* 8225865Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 8225865Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225865Ch case    7:*/		return 0x82258660;
		  /* 82258660h */ case    8:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82258660h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82258660h case    8:*/		return 0x82258664;
		  /* 82258664h */ case    9:  		/* lwz R3, <#[R10 + 1456]> */
		/* 82258664h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x000005B0) );
		/* 82258664h case    9:*/		return 0x82258668;
		  /* 82258668h */ case   10:  		/* bl -246192 */
		/* 82258668h case   10:*/		regs.LR = 0x8225866C; return 0x8221C4B8;
		/* 82258668h case   10:*/		return 0x8225866C;
		  /* 8225866Ch */ case   11:  		/* stw R3, <#[R31 + 24]> */
		/* 8225866Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 8225866Ch case   11:*/		return 0x82258670;
		  /* 82258670h */ case   12:  		/* lwz R11, <#[R31 + 28]> */
		/* 82258670h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258670h case   12:*/		return 0x82258674;
		  /* 82258674h */ case   13:  		/* lwz R10, <#[R31 + 36]> */
		/* 82258674h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 82258674h case   13:*/		return 0x82258678;
		  /* 82258678h */ case   14:  		/* addi R11, R11, 1 */
		/* 82258678h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82258678h case   14:*/		return 0x8225867C;
		  /* 8225867Ch */ case   15:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 8225867Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 8225867Ch case   15:*/		return 0x82258680;
		  /* 82258680h */ case   16:  		/* lwz R3, <#[R10 + 1456]> */
		/* 82258680h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x000005B0) );
		/* 82258680h case   16:*/		return 0x82258684;
		  /* 82258684h */ case   17:  		/* bl -246220 */
		/* 82258684h case   17:*/		regs.LR = 0x82258688; return 0x8221C4B8;
		/* 82258684h case   17:*/		return 0x82258688;
		  /* 82258688h */ case   18:  		/* stw R3, <#[R31 + 20]> */
		/* 82258688h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 82258688h case   18:*/		return 0x8225868C;
		  /* 8225868Ch */ case   19:  		/* mr R3, R31 */
		/* 8225868Ch case   19:*/		regs.R3 = regs.R31;
		/* 8225868Ch case   19:*/		return 0x82258690;
		  /* 82258690h */ case   20:  		/* addi R1, R1, 112 */
		/* 82258690h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258690h case   20:*/		return 0x82258694;
		  /* 82258694h */ case   21:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258694h case   21:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258694h case   21:*/		return 0x82258698;
		  /* 82258698h */ case   22:  		/* mtspr LR, R12 */
		/* 82258698h case   22:*/		regs.LR = regs.R12;
		/* 82258698h case   22:*/		return 0x8225869C;
		  /* 8225869Ch */ case   23:  		/* ld R30, <#[R1 - 24]> */
		/* 8225869Ch case   23:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225869Ch case   23:*/		return 0x822586A0;
		  /* 822586A0h */ case   24:  		/* ld R31, <#[R1 - 16]> */
		/* 822586A0h case   24:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822586A0h case   24:*/		return 0x822586A4;
		  /* 822586A4h */ case   25:  		/* bclr 20, CR0_LT */
		/* 822586A4h case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822586A4h case   25:*/		return 0x822586A8;
	}
	return 0x822586A8;
} // Block from 82258640h-822586A8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822586A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822586A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822586A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822586A8);
		  /* 822586A8h */ case    0:  		/* mfspr R12, LR */
		/* 822586A8h case    0:*/		regs.R12 = regs.LR;
		/* 822586A8h case    0:*/		return 0x822586AC;
		  /* 822586ACh */ case    1:  		/* bl -1864788 */
		/* 822586ACh case    1:*/		regs.LR = 0x822586B0; return 0x82091258;
		/* 822586ACh case    1:*/		return 0x822586B0;
		  /* 822586B0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822586B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822586B0h case    2:*/		return 0x822586B4;
		  /* 822586B4h */ case    3:  		/* mr R31, R3 */
		/* 822586B4h case    3:*/		regs.R31 = regs.R3;
		/* 822586B4h case    3:*/		return 0x822586B8;
	}
	return 0x822586B8;
} // Block from 822586A8h-822586B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822586B8h
// Function '?InstType@IRCmp1D@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822586B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822586B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822586B8);
		  /* 822586B8h */ case    0:  		/* li R28, 0 */
		/* 822586B8h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 822586B8h case    0:*/		return 0x822586BC;
		  /* 822586BCh */ case    1:  		/* li R30, 0 */
		/* 822586BCh case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822586BCh case    1:*/		return 0x822586C0;
		  /* 822586C0h */ case    2:  		/* b 60 */
		/* 822586C0h case    2:*/		return 0x822586FC;
		/* 822586C0h case    2:*/		return 0x822586C4;
		  /* 822586C4h */ case    3:  		/* lwz R11, <#[R31 + 20]> */
		/* 822586C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 822586C4h case    3:*/		return 0x822586C8;
	}
	return 0x822586C8;
} // Block from 822586B8h-822586C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822586C8h
// Function '??0IRStartMakeCall@XGRAPHICS@@QAA@HHPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822586C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822586C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822586C8);
		  /* 822586C8h */ case    0:  		/* lwzx R10, <#[R30 + R11]> */
		/* 822586C8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 822586C8h case    0:*/		return 0x822586CC;
		  /* 822586CCh */ case    1:  		/* lwz R10, <#[R10 + 4]> */
		/* 822586CCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 822586CCh case    1:*/		return 0x822586D0;
		  /* 822586D0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 822586D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822586D0h case    2:*/		return 0x822586D4;
		  /* 822586D4h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 822586D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225870C;  }
		/* 822586D4h case    3:*/		return 0x822586D8;
		  /* 822586D8h */ case    4:  		/* lwzx R11, <#[R30 + R11]> */
		/* 822586D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 822586D8h case    4:*/		return 0x822586DC;
		  /* 822586DCh */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 822586DCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822586DCh case    5:*/		return 0x822586E0;
		  /* 822586E0h */ case    6:  		/* lwz R29, <#[R11 + 4]> */
		/* 822586E0h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 822586E0h case    6:*/		return 0x822586E4;
		  /* 822586E4h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 822586E4h case    7:*/		if ( regs.CR[0].eq ) { return 0x822586F4;  }
		/* 822586E4h case    7:*/		return 0x822586E8;
		  /* 822586E8h */ case    8:  		/* addi R4, R11, -4 */
		/* 822586E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 822586E8h case    8:*/		return 0x822586EC;
		  /* 822586ECh */ case    9:  		/* lwz R3, <#[R11 - 4]> */
		/* 822586ECh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 822586ECh case    9:*/		return 0x822586F0;
		  /* 822586F0h */ case   10:  		/* bl -245936 */
		/* 822586F0h case   10:*/		regs.LR = 0x822586F4; return 0x8221C640;
		/* 822586F0h case   10:*/		return 0x822586F4;
	}
	return 0x822586F4;
} // Block from 822586C8h-822586F4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822586F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822586F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822586F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822586F4);
		  /* 822586F4h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 822586F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 822586F4h case    0:*/		return 0x822586F8;
		  /* 822586F8h */ case    1:  		/* stwx R29, <#[R30 + R11]> */
		/* 822586F8h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 822586F8h case    1:*/		return 0x822586FC;
	}
	return 0x822586FC;
} // Block from 822586F4h-822586FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822586FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822586FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822586FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822586FC);
		  /* 822586FCh */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 822586FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 822586FCh case    0:*/		return 0x82258700;
		  /* 82258700h */ case    1:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82258700h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82258700h case    1:*/		return 0x82258704;
		  /* 82258704h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82258704h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82258704h case    2:*/		return 0x82258708;
		  /* 82258708h */ case    3:  		/* bc 4, CR6_EQ, -68 */
		/* 82258708h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822586C4;  }
		/* 82258708h case    3:*/		return 0x8225870C;
	}
	return 0x8225870C;
} // Block from 822586FCh-8225870Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225870Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225870C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225870C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225870C);
		  /* 8225870Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8225870Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8225870Ch case    0:*/		return 0x82258710;
		  /* 82258710h */ case    1:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82258710h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82258710h case    1:*/		return 0x82258714;
		  /* 82258714h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82258714h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82258714h case    2:*/		return 0x82258718;
		  /* 82258718h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82258718h case    3:*/		if ( regs.CR[6].eq ) { return 0x82258728;  }
		/* 82258718h case    3:*/		return 0x8225871C;
		  /* 8225871Ch */ case    4:  		/* addi R4, R11, -4 */
		/* 8225871Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8225871Ch case    4:*/		return 0x82258720;
	}
	return 0x82258720;
} // Block from 8225870Ch-82258720h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82258720h
// Function '??0IRStartCallRoutine@XGRAPHICS@@QAA@HHPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258720);
		  /* 82258720h */ case    0:  		/* lwz R3, <#[R11 - 4]> */
		/* 82258720h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82258720h case    0:*/		return 0x82258724;
		  /* 82258724h */ case    1:  		/* bl -245988 */
		/* 82258724h case    1:*/		regs.LR = 0x82258728; return 0x8221C640;
		/* 82258724h case    1:*/		return 0x82258728;
	}
	return 0x82258728;
} // Block from 82258720h-82258728h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258728);
		  /* 82258728h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 82258728h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258728h case    0:*/		return 0x8225872C;
		  /* 8225872Ch */ case    1:  		/* addi R28, R28, 1 */
		/* 8225872Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8225872Ch case    1:*/		return 0x82258730;
		  /* 82258730h */ case    2:  		/* addi R30, R30, 4 */
		/* 82258730h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82258730h case    2:*/		return 0x82258734;
		  /* 82258734h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82258734h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82258734h case    3:*/		return 0x82258738;
		  /* 82258738h */ case    4:  		/* bc 4, CR6_GT, -60 */
		/* 82258738h case    4:*/		if ( !regs.CR[6].gt ) { return 0x822586FC;  }
		/* 82258738h case    4:*/		return 0x8225873C;
		  /* 8225873Ch */ case    5:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225873Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225873Ch case    5:*/		return 0x82258740;
		  /* 82258740h */ case    6:  		/* lwz R4, <#[R31 + 20]> */
		/* 82258740h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 82258740h case    6:*/		return 0x82258744;
		  /* 82258744h */ case    7:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258744h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258744h case    7:*/		return 0x82258748;
		  /* 82258748h */ case    8:  		/* bl -246024 */
		/* 82258748h case    8:*/		regs.LR = 0x8225874C; return 0x8221C640;
		/* 82258748h case    8:*/		return 0x8225874C;
		  /* 8225874Ch */ case    9:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225874Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225874Ch case    9:*/		return 0x82258750;
		  /* 82258750h */ case   10:  		/* lwz R4, <#[R31 + 24]> */
		/* 82258750h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 82258750h case   10:*/		return 0x82258754;
		  /* 82258754h */ case   11:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258754h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258754h case   11:*/		return 0x82258758;
		  /* 82258758h */ case   12:  		/* bl -246040 */
		/* 82258758h case   12:*/		regs.LR = 0x8225875C; return 0x8221C640;
		/* 82258758h case   12:*/		return 0x8225875C;
		  /* 8225875Ch */ case   13:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225875Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225875Ch case   13:*/		return 0x82258760;
		  /* 82258760h */ case   14:  		/* lwz R4, <#[R31]> */
		/* 82258760h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82258760h case   14:*/		return 0x82258764;
		  /* 82258764h */ case   15:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258764h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258764h case   15:*/		return 0x82258768;
		  /* 82258768h */ case   16:  		/* bl -246056 */
		/* 82258768h case   16:*/		regs.LR = 0x8225876C; return 0x8221C640;
		/* 82258768h case   16:*/		return 0x8225876C;
		  /* 8225876Ch */ case   17:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225876Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225876Ch case   17:*/		return 0x82258770;
		  /* 82258770h */ case   18:  		/* lwz R4, <#[R31 + 12]> */
		/* 82258770h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82258770h case   18:*/		return 0x82258774;
		  /* 82258774h */ case   19:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258774h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258774h case   19:*/		return 0x82258778;
	}
	return 0x82258778;
} // Block from 82258728h-82258778h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82258778h
// Function '??0IREndMakeCall@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258778);
		  /* 82258778h */ case    0:  		/* bl -246072 */
		/* 82258778h case    0:*/		regs.LR = 0x8225877C; return 0x8221C640;
		/* 82258778h case    0:*/		return 0x8225877C;
		  /* 8225877Ch */ case    1:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225877Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225877Ch case    1:*/		return 0x82258780;
		  /* 82258780h */ case    2:  		/* lwz R4, <#[R31 + 16]> */
		/* 82258780h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82258780h case    2:*/		return 0x82258784;
		  /* 82258784h */ case    3:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258784h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258784h case    3:*/		return 0x82258788;
		  /* 82258788h */ case    4:  		/* bl -246088 */
		/* 82258788h case    4:*/		regs.LR = 0x8225878C; return 0x8221C640;
		/* 82258788h case    4:*/		return 0x8225878C;
		  /* 8225878Ch */ case    5:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225878Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225878Ch case    5:*/		return 0x82258790;
		  /* 82258790h */ case    6:  		/* lwz R4, <#[R31 + 4]> */
		/* 82258790h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 82258790h case    6:*/		return 0x82258794;
		  /* 82258794h */ case    7:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82258794h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258794h case    7:*/		return 0x82258798;
		  /* 82258798h */ case    8:  		/* bl -246104 */
		/* 82258798h case    8:*/		regs.LR = 0x8225879C; return 0x8221C640;
		/* 82258798h case    8:*/		return 0x8225879C;
		  /* 8225879Ch */ case    9:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225879Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225879Ch case    9:*/		return 0x822587A0;
		  /* 822587A0h */ case   10:  		/* lwz R4, <#[R31 + 8]> */
		/* 822587A0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 822587A0h case   10:*/		return 0x822587A4;
		  /* 822587A4h */ case   11:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822587A4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822587A4h case   11:*/		return 0x822587A8;
		  /* 822587A8h */ case   12:  		/* bl -246120 */
		/* 822587A8h case   12:*/		regs.LR = 0x822587AC; return 0x8221C640;
		/* 822587A8h case   12:*/		return 0x822587AC;
		  /* 822587ACh */ case   13:  		/* li R11, 0 */
		/* 822587ACh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822587ACh case   13:*/		return 0x822587B0;
		  /* 822587B0h */ case   14:  		/* stw R11, <#[R31 + 24]> */
		/* 822587B0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822587B0h case   14:*/		return 0x822587B4;
		  /* 822587B4h */ case   15:  		/* addi R1, R1, 128 */
		/* 822587B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822587B4h case   15:*/		return 0x822587B8;
		  /* 822587B8h */ case   16:  		/* b -1864976 */
		/* 822587B8h case   16:*/		return 0x820912A8;
		/* 822587B8h case   16:*/		return 0x822587BC;
		  /* 822587BCh */ case   17:  		/* nop */
		/* 822587BCh case   17:*/		cpu::op::nop();
		/* 822587BCh case   17:*/		return 0x822587C0;
	}
	return 0x822587C0;
} // Block from 82258778h-822587C0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822587C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822587C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822587C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822587C0);
		  /* 822587C0h */ case    0:  		/* mfspr R12, LR */
		/* 822587C0h case    0:*/		regs.R12 = regs.LR;
		/* 822587C0h case    0:*/		return 0x822587C4;
		  /* 822587C4h */ case    1:  		/* bl -1865096 */
		/* 822587C4h case    1:*/		regs.LR = 0x822587C8; return 0x8209123C;
		/* 822587C4h case    1:*/		return 0x822587C8;
		  /* 822587C8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 822587C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 822587C8h case    2:*/		return 0x822587CC;
		  /* 822587CCh */ case    3:  		/* mr R23, R3 */
		/* 822587CCh case    3:*/		regs.R23 = regs.R3;
		/* 822587CCh case    3:*/		return 0x822587D0;
	}
	return 0x822587D0;
} // Block from 822587C0h-822587D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822587D0h
// Function '??0IREndCallRoutine@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822587D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822587D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822587D0);
		  /* 822587D0h */ case    0:  		/* lwz R3, <#[R3 + 32]> */
		/* 822587D0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000020) );
		/* 822587D0h case    0:*/		return 0x822587D4;
		  /* 822587D4h */ case    1:  		/* bl -126484 */
		/* 822587D4h case    1:*/		regs.LR = 0x822587D8; return 0x822399C0;
		/* 822587D4h case    1:*/		return 0x822587D8;
		  /* 822587D8h */ case    2:  		/* lwz R11, <#[R23 + 28]> */
		/* 822587D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000001C) );
		/* 822587D8h case    2:*/		return 0x822587DC;
		  /* 822587DCh */ case    3:  		/* li R21, 1 */
		/* 822587DCh case    3:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 822587DCh case    3:*/		return 0x822587E0;
		  /* 822587E0h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 822587E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822587E0h case    4:*/		return 0x822587E4;
		  /* 822587E4h */ case    5:  		/* bc 12, CR6_LT, 312 */
		/* 822587E4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8225891C;  }
		/* 822587E4h case    5:*/		return 0x822587E8;
		  /* 822587E8h */ case    6:  		/* addi R22, R3, 4 */
		/* 822587E8h case    6:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R3,0x4);
		/* 822587E8h case    6:*/		return 0x822587EC;
		  /* 822587ECh */ case    7:  		/* lwz R25, <#[R22]> */
		/* 822587ECh case    7:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R22 + 0x00000000) );
		/* 822587ECh case    7:*/		return 0x822587F0;
		  /* 822587F0h */ case    8:  		/* li R31, 0 */
		/* 822587F0h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822587F0h case    8:*/		return 0x822587F4;
		  /* 822587F4h */ case    9:  		/* li R30, 0 */
		/* 822587F4h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822587F4h case    9:*/		return 0x822587F8;
		  /* 822587F8h */ case   10:  		/* li R29, 1 */
		/* 822587F8h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 822587F8h case   10:*/		return 0x822587FC;
		  /* 822587FCh */ case   11:  		/* lwz R24, <#[R25 + 72]> */
		/* 822587FCh case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R25 + 0x00000048) );
		/* 822587FCh case   11:*/		return 0x82258800;
		  /* 82258800h */ case   12:  		/* lwz R11, <#[R25 + 56]> */
		/* 82258800h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 82258800h case   12:*/		return 0x82258804;
		  /* 82258804h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 82258804h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82258804h case   13:*/		return 0x82258808;
		  /* 82258808h */ case   14:  		/* cmplw CR6, R29, R10 */
		/* 82258808h case   14:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82258808h case   14:*/		return 0x8225880C;
		  /* 8225880Ch */ case   15:  		/* bc 4, CR6_GT, 12 */
		/* 8225880Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x82258818;  }
		/* 8225880Ch case   15:*/		return 0x82258810;
		  /* 82258810h */ case   16:  		/* li R11, 0 */
		/* 82258810h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82258810h case   16:*/		return 0x82258814;
		  /* 82258814h */ case   17:  		/* b 16 */
		/* 82258814h case   17:*/		return 0x82258824;
		/* 82258814h case   17:*/		return 0x82258818;
	}
	return 0x82258818;
} // Block from 822587D0h-82258818h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82258818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258818);
		  /* 82258818h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82258818h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82258818h case    0:*/		return 0x8225881C;
		  /* 8225881Ch */ case    1:  		/* li R11, 1 */
		/* 8225881Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225881Ch case    1:*/		return 0x82258820;
		  /* 82258820h */ case    2:  		/* lwzx R31, <#[R10 + R30]> */
		/* 82258820h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82258820h case    2:*/		return 0x82258824;
	}
	return 0x82258824;
} // Block from 82258818h-82258824h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258824);
		  /* 82258824h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82258824h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82258824h case    0:*/		return 0x82258828;
	}
	return 0x82258828;
} // Block from 82258824h-82258828h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258828h
// Function '?NewInst@IRMov@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258828);
		  /* 82258828h */ case    0:  		/* bc 12, CR0_EQ, 52 */
		/* 82258828h case    0:*/		if ( regs.CR[0].eq ) { return 0x8225885C;  }
		/* 82258828h case    0:*/		return 0x8225882C;
		  /* 8225882Ch */ case    1:  		/* lwz R11, <#[R31 + 72]> */
		/* 8225882Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 8225882Ch case    1:*/		return 0x82258830;
		  /* 82258830h */ case    2:  		/* lwz R10, <#[R23 + 8]> */
		/* 82258830h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 82258830h case    2:*/		return 0x82258834;
		  /* 82258834h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82258834h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82258834h case    3:*/		return 0x82258838;
		  /* 82258838h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82258838h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82258838h case    4:*/		return 0x8225883C;
		  /* 8225883Ch */ case    5:  		/* cmplw CR6, R11, R24 */
		/* 8225883Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 8225883Ch case    5:*/		return 0x82258840;
		  /* 82258840h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82258840h case    6:*/		if ( regs.CR[6].eq ) { return 0x82258850;  }
		/* 82258840h case    6:*/		return 0x82258844;
		  /* 82258844h */ case    7:  		/* mr R4, R31 */
		/* 82258844h case    7:*/		regs.R4 = regs.R31;
		/* 82258844h case    7:*/		return 0x82258848;
		  /* 82258848h */ case    8:  		/* mr R3, R25 */
		/* 82258848h case    8:*/		regs.R3 = regs.R25;
		/* 82258848h case    8:*/		return 0x8225884C;
		  /* 8225884Ch */ case    9:  		/* bl 3300 */
		/* 8225884Ch case    9:*/		regs.LR = 0x82258850; return 0x82259530;
		/* 8225884Ch case    9:*/		return 0x82258850;
	}
	return 0x82258850;
} // Block from 82258828h-82258850h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82258850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258850);
		  /* 82258850h */ case    0:  		/* addi R29, R29, 1 */
		/* 82258850h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82258850h case    0:*/		return 0x82258854;
		  /* 82258854h */ case    1:  		/* addi R30, R30, 4 */
		/* 82258854h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82258854h case    1:*/		return 0x82258858;
		  /* 82258858h */ case    2:  		/* b -88 */
		/* 82258858h case    2:*/		return 0x82258800;
		/* 82258858h case    2:*/		return 0x8225885C;
	}
	return 0x8225885C;
} // Block from 82258850h-8225885Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225885Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225885C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225885C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225885C);
		  /* 8225885Ch */ case    0:  		/* li R27, 0 */
		/* 8225885Ch case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8225885Ch case    0:*/		return 0x82258860;
		  /* 82258860h */ case    1:  		/* li R28, 0 */
		/* 82258860h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82258860h case    1:*/		return 0x82258864;
		  /* 82258864h */ case    2:  		/* li R26, 1 */
		/* 82258864h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82258864h case    2:*/		return 0x82258868;
		  /* 82258868h */ case    3:  		/* lwz R11, <#[R25 + 88]> */
		/* 82258868h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000058) );
		/* 82258868h case    3:*/		return 0x8225886C;
		  /* 8225886Ch */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 8225886Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8225886Ch case    4:*/		return 0x82258870;
		  /* 82258870h */ case    5:  		/* cmplw CR6, R26, R10 */
		/* 82258870h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82258870h case    5:*/		return 0x82258874;
		  /* 82258874h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 82258874h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82258880;  }
		/* 82258874h case    6:*/		return 0x82258878;
	}
	return 0x82258878;
} // Block from 8225885Ch-82258878h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82258878h
// Function '?NewInst@IRMovBase@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258878);
		  /* 82258878h */ case    0:  		/* li R11, 0 */
		/* 82258878h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82258878h case    0:*/		return 0x8225887C;
		  /* 8225887Ch */ case    1:  		/* b 16 */
		/* 8225887Ch case    1:*/		return 0x8225888C;
		/* 8225887Ch case    1:*/		return 0x82258880;
	}
	return 0x82258880;
} // Block from 82258878h-82258880h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258880);
		  /* 82258880h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82258880h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82258880h case    0:*/		return 0x82258884;
		  /* 82258884h */ case    1:  		/* li R11, 1 */
		/* 82258884h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82258884h case    1:*/		return 0x82258888;
		  /* 82258888h */ case    2:  		/* lwzx R27, <#[R10 + R28]> */
		/* 82258888h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 82258888h case    2:*/		return 0x8225888C;
	}
	return 0x8225888C;
} // Block from 82258880h-8225888Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225888Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225888C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225888C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225888C);
		  /* 8225888Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225888Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225888Ch case    0:*/		return 0x82258890;
		  /* 82258890h */ case    1:  		/* bc 12, CR0_EQ, 120 */
		/* 82258890h case    1:*/		if ( regs.CR[0].eq ) { return 0x82258908;  }
		/* 82258890h case    1:*/		return 0x82258894;
		  /* 82258894h */ case    2:  		/* li R31, 0 */
		/* 82258894h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82258894h case    2:*/		return 0x82258898;
		  /* 82258898h */ case    3:  		/* li R30, 0 */
		/* 82258898h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82258898h case    3:*/		return 0x8225889C;
		  /* 8225889Ch */ case    4:  		/* li R29, 1 */
		/* 8225889Ch case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8225889Ch case    4:*/		return 0x822588A0;
		  /* 822588A0h */ case    5:  		/* lwz R11, <#[R27 + 92]> */
		/* 822588A0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000005C) );
		/* 822588A0h case    5:*/		return 0x822588A4;
		  /* 822588A4h */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 822588A4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822588A4h case    6:*/		return 0x822588A8;
		  /* 822588A8h */ case    7:  		/* cmplw CR6, R29, R10 */
		/* 822588A8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 822588A8h case    7:*/		return 0x822588AC;
		  /* 822588ACh */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 822588ACh case    8:*/		if ( !regs.CR[6].gt ) { return 0x822588B8;  }
		/* 822588ACh case    8:*/		return 0x822588B0;
		  /* 822588B0h */ case    9:  		/* li R11, 0 */
		/* 822588B0h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822588B0h case    9:*/		return 0x822588B4;
		  /* 822588B4h */ case   10:  		/* b 16 */
		/* 822588B4h case   10:*/		return 0x822588C4;
		/* 822588B4h case   10:*/		return 0x822588B8;
	}
	return 0x822588B8;
} // Block from 8225888Ch-822588B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822588B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822588B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822588B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822588B8);
		  /* 822588B8h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 822588B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822588B8h case    0:*/		return 0x822588BC;
		  /* 822588BCh */ case    1:  		/* li R11, 1 */
		/* 822588BCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822588BCh case    1:*/		return 0x822588C0;
		  /* 822588C0h */ case    2:  		/* lwzx R31, <#[R10 + R30]> */
		/* 822588C0h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 822588C0h case    2:*/		return 0x822588C4;
	}
	return 0x822588C4;
} // Block from 822588B8h-822588C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822588C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822588C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822588C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822588C4);
		  /* 822588C4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822588C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822588C4h case    0:*/		return 0x822588C8;
	}
	return 0x822588C8;
} // Block from 822588C4h-822588C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822588C8h
// Function '?NewInst@IRKill@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822588C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822588C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822588C8);
		  /* 822588C8h */ case    0:  		/* bc 12, CR0_EQ, 52 */
		/* 822588C8h case    0:*/		if ( regs.CR[0].eq ) { return 0x822588FC;  }
		/* 822588C8h case    0:*/		return 0x822588CC;
		  /* 822588CCh */ case    1:  		/* lwz R11, <#[R31 + 72]> */
		/* 822588CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000048) );
		/* 822588CCh case    1:*/		return 0x822588D0;
		  /* 822588D0h */ case    2:  		/* lwz R10, <#[R23 + 8]> */
		/* 822588D0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 822588D0h case    2:*/		return 0x822588D4;
		  /* 822588D4h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822588D4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822588D4h case    3:*/		return 0x822588D8;
		  /* 822588D8h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822588D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822588D8h case    4:*/		return 0x822588DC;
		  /* 822588DCh */ case    5:  		/* cmplw CR6, R11, R24 */
		/* 822588DCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 822588DCh case    5:*/		return 0x822588E0;
		  /* 822588E0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 822588E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x822588F0;  }
		/* 822588E0h case    6:*/		return 0x822588E4;
		  /* 822588E4h */ case    7:  		/* mr R4, R31 */
		/* 822588E4h case    7:*/		regs.R4 = regs.R31;
		/* 822588E4h case    7:*/		return 0x822588E8;
		  /* 822588E8h */ case    8:  		/* mr R3, R25 */
		/* 822588E8h case    8:*/		regs.R3 = regs.R25;
		/* 822588E8h case    8:*/		return 0x822588EC;
		  /* 822588ECh */ case    9:  		/* bl 3140 */
		/* 822588ECh case    9:*/		regs.LR = 0x822588F0; return 0x82259530;
		/* 822588ECh case    9:*/		return 0x822588F0;
	}
	return 0x822588F0;
} // Block from 822588C8h-822588F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822588F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822588F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822588F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822588F0);
		  /* 822588F0h */ case    0:  		/* addi R29, R29, 1 */
		/* 822588F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 822588F0h case    0:*/		return 0x822588F4;
		  /* 822588F4h */ case    1:  		/* addi R30, R30, 4 */
		/* 822588F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 822588F4h case    1:*/		return 0x822588F8;
		  /* 822588F8h */ case    2:  		/* b -88 */
		/* 822588F8h case    2:*/		return 0x822588A0;
		/* 822588F8h case    2:*/		return 0x822588FC;
	}
	return 0x822588FC;
} // Block from 822588F0h-822588FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822588FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822588FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822588FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822588FC);
		  /* 822588FCh */ case    0:  		/* addi R26, R26, 1 */
		/* 822588FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 822588FCh case    0:*/		return 0x82258900;
		  /* 82258900h */ case    1:  		/* addi R28, R28, 4 */
		/* 82258900h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82258900h case    1:*/		return 0x82258904;
		  /* 82258904h */ case    2:  		/* b -156 */
		/* 82258904h case    2:*/		return 0x82258868;
		/* 82258904h case    2:*/		return 0x82258908;
	}
	return 0x82258908;
} // Block from 822588FCh-82258908h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258908);
		  /* 82258908h */ case    0:  		/* lwz R11, <#[R23 + 28]> */
		/* 82258908h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000001C) );
		/* 82258908h case    0:*/		return 0x8225890C;
		  /* 8225890Ch */ case    1:  		/* addi R21, R21, 1 */
		/* 8225890Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 8225890Ch case    1:*/		return 0x82258910;
		  /* 82258910h */ case    2:  		/* addi R22, R22, 4 */
		/* 82258910h case    2:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 82258910h case    2:*/		return 0x82258914;
		  /* 82258914h */ case    3:  		/* cmplw CR6, R21, R11 */
		/* 82258914h case    3:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 82258914h case    3:*/		return 0x82258918;
	}
	return 0x82258918;
} // Block from 82258908h-82258918h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258918h
// Function '?NewInst@IRKill2@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258918);
		  /* 82258918h */ case    0:  		/* bc 4, CR6_GT, -300 */
		/* 82258918h case    0:*/		if ( !regs.CR[6].gt ) { return 0x822587EC;  }
		/* 82258918h case    0:*/		return 0x8225891C;
	}
	return 0x8225891C;
} // Block from 82258918h-8225891Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225891Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225891C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225891C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225891C);
		  /* 8225891Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 8225891Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8225891Ch case    0:*/		return 0x82258920;
		  /* 82258920h */ case    1:  		/* b -1865364 */
		/* 82258920h case    1:*/		return 0x8209128C;
		/* 82258920h case    1:*/		return 0x82258924;
		  /* 82258924h */ case    2:  		/* nop */
		/* 82258924h case    2:*/		cpu::op::nop();
		/* 82258924h case    2:*/		return 0x82258928;
	}
	return 0x82258928;
} // Block from 8225891Ch-82258928h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258928);
		  /* 82258928h */ case    0:  		/* mfspr R12, LR */
		/* 82258928h case    0:*/		regs.R12 = regs.LR;
		/* 82258928h case    0:*/		return 0x8225892C;
		  /* 8225892Ch */ case    1:  		/* bl -1865428 */
		/* 8225892Ch case    1:*/		regs.LR = 0x82258930; return 0x82091258;
		/* 8225892Ch case    1:*/		return 0x82258930;
		  /* 82258930h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82258930h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82258930h case    2:*/		return 0x82258934;
		  /* 82258934h */ case    3:  		/* lwz R11, <#[R3 + 36]> */
		/* 82258934h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 82258934h case    3:*/		return 0x82258938;
		  /* 82258938h */ case    4:  		/* mr R31, R3 */
		/* 82258938h case    4:*/		regs.R31 = regs.R3;
		/* 82258938h case    4:*/		return 0x8225893C;
		  /* 8225893Ch */ case    5:  		/* mr R28, R4 */
		/* 8225893Ch case    5:*/		regs.R28 = regs.R4;
		/* 8225893Ch case    5:*/		return 0x82258940;
		  /* 82258940h */ case    6:  		/* li R4, 20 */
		/* 82258940h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82258940h case    6:*/		return 0x82258944;
		  /* 82258944h */ case    7:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82258944h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258944h case    7:*/		return 0x82258948;
		  /* 82258948h */ case    8:  		/* mr R3, R30 */
		/* 82258948h case    8:*/		regs.R3 = regs.R30;
		/* 82258948h case    8:*/		return 0x8225894C;
		  /* 8225894Ch */ case    9:  		/* bl -246932 */
		/* 8225894Ch case    9:*/		regs.LR = 0x82258950; return 0x8221C4B8;
		/* 8225894Ch case    9:*/		return 0x82258950;
		  /* 82258950h */ case   10:  		/* addic. R29, R3, 4 */
		/* 82258950h case   10:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R3,0x4);
		/* 82258950h case   10:*/		return 0x82258954;
		  /* 82258954h */ case   11:  		/* stw R30, <#[R3]> */
		/* 82258954h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82258954h case   11:*/		return 0x82258958;
		  /* 82258958h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 82258958h case   12:*/		if ( regs.CR[0].eq ) { return 0x82258970;  }
		/* 82258958h case   12:*/		return 0x8225895C;
		  /* 8225895Ch */ case   13:  		/* lwz R11, <#[R31 + 36]> */
		/* 8225895Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 8225895Ch case   13:*/		return 0x82258960;
		  /* 82258960h */ case   14:  		/* mr R3, R29 */
		/* 82258960h case   14:*/		regs.R3 = regs.R29;
		/* 82258960h case   14:*/		return 0x82258964;
		  /* 82258964h */ case   15:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82258964h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258964h case   15:*/		return 0x82258968;
	}
	return 0x82258968;
} // Block from 82258928h-82258968h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82258968h
// Function '?NewInst@IRCmp2@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258968);
		  /* 82258968h */ case    0:  		/* bl -142344 */
		/* 82258968h case    0:*/		regs.LR = 0x8225896C; return 0x82235D60;
		/* 82258968h case    0:*/		return 0x8225896C;
		  /* 8225896Ch */ case    1:  		/* b 8 */
		/* 8225896Ch case    1:*/		return 0x82258974;
		/* 8225896Ch case    1:*/		return 0x82258970;
	}
	return 0x82258970;
} // Block from 82258968h-82258970h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258970);
		  /* 82258970h */ case    0:  		/* li R29, 0 */
		/* 82258970h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82258970h case    0:*/		return 0x82258974;
	}
	return 0x82258974;
} // Block from 82258970h-82258974h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258974);
		  /* 82258974h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82258974h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82258974h case    0:*/		return 0x82258978;
		  /* 82258978h */ case    1:  		/* b 28 */
		/* 82258978h case    1:*/		return 0x82258994;
		/* 82258978h case    1:*/		return 0x8225897C;
		  /* 8225897Ch */ case    2:  		/* mr R3, R29 */
		/* 8225897Ch case    2:*/		regs.R3 = regs.R29;
		/* 8225897Ch case    2:*/		return 0x82258980;
		  /* 82258980h */ case    3:  		/* lwz R4, <#[R29 + 4]> */
		/* 82258980h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 82258980h case    3:*/		return 0x82258984;
		  /* 82258984h */ case    4:  		/* bl -20164 */
		/* 82258984h case    4:*/		regs.LR = 0x82258988; return 0x82253AC0;
		/* 82258984h case    4:*/		return 0x82258988;
		  /* 82258988h */ case    5:  		/* stw R28, <#[R3]> */
		/* 82258988h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82258988h case    5:*/		return 0x8225898C;
		  /* 8225898Ch */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225898Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225898Ch case    6:*/		return 0x82258990;
		  /* 82258990h */ case    7:  		/* lwzx R28, <#[R11 + R30]> */
		/* 82258990h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82258990h case    7:*/		return 0x82258994;
	}
	return 0x82258994;
} // Block from 82258974h-82258994h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82258994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258994);
		  /* 82258994h */ case    0:  		/* rlwinm R30, R28, 2, 0, 29 */
		/* 82258994h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R28);
		/* 82258994h case    0:*/		return 0x82258998;
		  /* 82258998h */ case    1:  		/* lwzx R10, <#[R11 + R30]> */
		/* 82258998h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82258998h case    1:*/		return 0x8225899C;
		  /* 8225899Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8225899Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8225899Ch case    2:*/		return 0x822589A0;
		  /* 822589A0h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822589A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822589A0h case    3:*/		return 0x822589A4;
		  /* 822589A4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 822589A4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822589A4h case    4:*/		return 0x822589A8;
		  /* 822589A8h */ case    5:  		/* bc 4, CR6_EQ, -44 */
		/* 822589A8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8225897C;  }
		/* 822589A8h case    5:*/		return 0x822589AC;
		  /* 822589ACh */ case    6:  		/* b 88 */
		/* 822589ACh case    6:*/		return 0x82258A04;
		/* 822589ACh case    6:*/		return 0x822589B0;
		  /* 822589B0h */ case    7:  		/* bl 9120 */
		/* 822589B0h case    7:*/		regs.LR = 0x822589B4; return 0x8225AD50;
		/* 822589B0h case    7:*/		return 0x822589B4;
		  /* 822589B4h */ case    8:  		/* lwz R10, <#[R31 + 12]> */
		/* 822589B4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 822589B4h case    8:*/		return 0x822589B8;
	}
	return 0x822589B8;
} // Block from 82258994h-822589B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822589B8h
// Function '?NewInst@IRCmp1S@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822589B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822589B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822589B8);
		  /* 822589B8h */ case    0:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 822589B8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 822589B8h case    0:*/		return 0x822589BC;
		  /* 822589BCh */ case    1:  		/* lwz R9, <#[R31 + 16]> */
		/* 822589BCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 822589BCh case    1:*/		return 0x822589C0;
		  /* 822589C0h */ case    2:  		/* lwz R8, <#[R31 + 4]> */
		/* 822589C0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 822589C0h case    2:*/		return 0x822589C4;
		  /* 822589C4h */ case    3:  		/* lwzx R10, <#[R10 + R11]> */
		/* 822589C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822589C4h case    3:*/		return 0x822589C8;
		  /* 822589C8h */ case    4:  		/* lwzx R7, <#[R9 + R11]> */
		/* 822589C8h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822589C8h case    4:*/		return 0x822589CC;
		  /* 822589CCh */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822589CCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822589CCh case    5:*/		return 0x822589D0;
		  /* 822589D0h */ case    6:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 822589D0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 822589D0h case    6:*/		return 0x822589D4;
		  /* 822589D4h */ case    7:  		/* lwzx R9, <#[R9 + R10]> */
		/* 822589D4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822589D4h case    7:*/		return 0x822589D8;
		  /* 822589D8h */ case    8:  		/* lwzx R7, <#[R7 + R8]> */
		/* 822589D8h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 822589D8h case    8:*/		return 0x822589DC;
		  /* 822589DCh */ case    9:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 822589DCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 822589DCh case    9:*/		return 0x822589E0;
		  /* 822589E0h */ case   10:  		/* lwzx R9, <#[R9 + R8]> */
		/* 822589E0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 822589E0h case   10:*/		return 0x822589E4;
		  /* 822589E4h */ case   11:  		/* cmplw CR6, R9, R7 */
		/* 822589E4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 822589E4h case   11:*/		return 0x822589E8;
		  /* 822589E8h */ case   12:  		/* bc 4, CR6_LT, 16 */
		/* 822589E8h case   12:*/		if ( !regs.CR[6].lt ) { return 0x822589F8;  }
		/* 822589E8h case   12:*/		return 0x822589EC;
		  /* 822589ECh */ case   13:  		/* lwz R9, <#[R31 + 16]> */
		/* 822589ECh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 822589ECh case   13:*/		return 0x822589F0;
		  /* 822589F0h */ case   14:  		/* lwzx R8, <#[R9 + R10]> */
		/* 822589F0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822589F0h case   14:*/		return 0x822589F4;
		  /* 822589F4h */ case   15:  		/* stwx R8, <#[R9 + R11]> */
		/* 822589F4h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822589F4h case   15:*/		return 0x822589F8;
	}
	return 0x822589F8;
} // Block from 822589B8h-822589F8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822589F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822589F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822589F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822589F8);
		  /* 822589F8h */ case    0:  		/* lwz R9, <#[R31 + 12]> */
		/* 822589F8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 822589F8h case    0:*/		return 0x822589FC;
		  /* 822589FCh */ case    1:  		/* lwzx R10, <#[R9 + R10]> */
		/* 822589FCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822589FCh case    1:*/		return 0x82258A00;
		  /* 82258A00h */ case    2:  		/* stwx R10, <#[R9 + R11]> */
		/* 82258A00h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82258A00h case    2:*/		return 0x82258A04;
	}
	return 0x82258A04;
} // Block from 822589F8h-82258A04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258A04);
		  /* 82258A04h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82258A04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82258A04h case    0:*/		return 0x82258A08;
	}
	return 0x82258A08;
} // Block from 82258A04h-82258A08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258A08h
// Function '?NewInst@IRCmp1D@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258A08);
		  /* 82258A08h */ case    0:  		/* mr R3, R29 */
		/* 82258A08h case    0:*/		regs.R3 = regs.R29;
		/* 82258A08h case    0:*/		return 0x82258A0C;
		  /* 82258A0Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82258A0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82258A0Ch case    1:*/		return 0x82258A10;
		  /* 82258A10h */ case    2:  		/* bc 4, CR6_EQ, -96 */
		/* 82258A10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822589B0;  }
		/* 82258A10h case    2:*/		return 0x82258A14;
		  /* 82258A14h */ case    3:  		/* li R4, 1 */
		/* 82258A14h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82258A14h case    3:*/		return 0x82258A18;
		  /* 82258A18h */ case    4:  		/* bl -102016 */
		/* 82258A18h case    4:*/		regs.LR = 0x82258A1C; return 0x8223FB98;
		/* 82258A18h case    4:*/		return 0x82258A1C;
		  /* 82258A1Ch */ case    5:  		/* addi R1, R1, 128 */
		/* 82258A1Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82258A1Ch case    5:*/		return 0x82258A20;
		  /* 82258A20h */ case    6:  		/* b -1865592 */
		/* 82258A20h case    6:*/		return 0x820912A8;
		/* 82258A20h case    6:*/		return 0x82258A24;
		  /* 82258A24h */ case    7:  		/* nop */
		/* 82258A24h case    7:*/		cpu::op::nop();
		/* 82258A24h case    7:*/		return 0x82258A28;
	}
	return 0x82258A28;
} // Block from 82258A08h-82258A28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82258A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258A28);
		  /* 82258A28h */ case    0:  		/* mfspr R12, LR */
		/* 82258A28h case    0:*/		regs.R12 = regs.LR;
		/* 82258A28h case    0:*/		return 0x82258A2C;
		  /* 82258A2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82258A2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258A2Ch case    1:*/		return 0x82258A30;
		  /* 82258A30h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82258A30h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258A30h case    2:*/		return 0x82258A34;
		  /* 82258A34h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82258A34h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258A34h case    3:*/		return 0x82258A38;
		  /* 82258A38h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258A38h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258A38h case    4:*/		return 0x82258A3C;
		  /* 82258A3Ch */ case    5:  		/* lwz R11, <#[R3 + 12]> */
		/* 82258A3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82258A3Ch case    5:*/		return 0x82258A40;
		  /* 82258A40h */ case    6:  		/* rlwinm R30, R4, 2, 0, 29 */
		/* 82258A40h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R4);
		/* 82258A40h case    6:*/		return 0x82258A44;
		  /* 82258A44h */ case    7:  		/* mr R31, R3 */
		/* 82258A44h case    7:*/		regs.R31 = regs.R3;
		/* 82258A44h case    7:*/		return 0x82258A48;
		  /* 82258A48h */ case    8:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82258A48h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82258A48h case    8:*/		return 0x82258A4C;
		  /* 82258A4Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82258A4Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82258A4Ch case    9:*/		return 0x82258A50;
		  /* 82258A50h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 82258A50h case   10:*/		if ( regs.CR[6].eq ) { return 0x82258A58;  }
		/* 82258A50h case   10:*/		return 0x82258A54;
		  /* 82258A54h */ case   11:  		/* bl -300 */
		/* 82258A54h case   11:*/		regs.LR = 0x82258A58; return 0x82258928;
		/* 82258A54h case   11:*/		return 0x82258A58;
	}
	return 0x82258A58;
} // Block from 82258A28h-82258A58h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82258A58h
// Function '?NewInst@IRProjection@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258A58);
		  /* 82258A58h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82258A58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82258A58h case    0:*/		return 0x82258A5C;
		  /* 82258A5Ch */ case    1:  		/* lwzx R3, <#[R11 + R30]> */
		/* 82258A5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82258A5Ch case    1:*/		return 0x82258A60;
		  /* 82258A60h */ case    2:  		/* addi R1, R1, 112 */
		/* 82258A60h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258A60h case    2:*/		return 0x82258A64;
		  /* 82258A64h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258A64h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258A64h case    3:*/		return 0x82258A68;
		  /* 82258A68h */ case    4:  		/* mtspr LR, R12 */
		/* 82258A68h case    4:*/		regs.LR = regs.R12;
		/* 82258A68h case    4:*/		return 0x82258A6C;
		  /* 82258A6Ch */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 82258A6Ch case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258A6Ch case    5:*/		return 0x82258A70;
		  /* 82258A70h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82258A70h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258A70h case    6:*/		return 0x82258A74;
		  /* 82258A74h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82258A74h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258A74h case    7:*/		return 0x82258A78;
	}
	return 0x82258A78;
} // Block from 82258A58h-82258A78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82258A78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258A78);
		  /* 82258A78h */ case    0:  		/* mfspr R12, LR */
		/* 82258A78h case    0:*/		regs.R12 = regs.LR;
		/* 82258A78h case    0:*/		return 0x82258A7C;
		  /* 82258A7Ch */ case    1:  		/* bl -1865768 */
		/* 82258A7Ch case    1:*/		regs.LR = 0x82258A80; return 0x82091254;
		/* 82258A7Ch case    1:*/		return 0x82258A80;
		  /* 82258A80h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82258A80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82258A80h case    2:*/		return 0x82258A84;
		  /* 82258A84h */ case    3:  		/* lwz R11, <#[R3 + 32]> */
		/* 82258A84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82258A84h case    3:*/		return 0x82258A88;
		  /* 82258A88h */ case    4:  		/* mr R31, R3 */
		/* 82258A88h case    4:*/		regs.R31 = regs.R3;
		/* 82258A88h case    4:*/		return 0x82258A8C;
		  /* 82258A8Ch */ case    5:  		/* mr R29, R4 */
		/* 82258A8Ch case    5:*/		regs.R29 = regs.R4;
		/* 82258A8Ch case    5:*/		return 0x82258A90;
		  /* 82258A90h */ case    6:  		/* li R4, 20 */
		/* 82258A90h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82258A90h case    6:*/		return 0x82258A94;
		  /* 82258A94h */ case    7:  		/* lwz R10, <#[R11 + 2148]> */
		/* 82258A94h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000864) );
		/* 82258A94h case    7:*/		return 0x82258A98;
		  /* 82258A98h */ case    8:  		/* addi R10, R10, 1 */
		/* 82258A98h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82258A98h case    8:*/		return 0x82258A9C;
		  /* 82258A9Ch */ case    9:  		/* stw R10, <#[R11 + 2148]> */
		/* 82258A9Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000864) );
		/* 82258A9Ch case    9:*/		return 0x82258AA0;
		  /* 82258AA0h */ case   10:  		/* lwz R11, <#[R3 + 36]> */
		/* 82258AA0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 82258AA0h case   10:*/		return 0x82258AA4;
		  /* 82258AA4h */ case   11:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82258AA4h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258AA4h case   11:*/		return 0x82258AA8;
		  /* 82258AA8h */ case   12:  		/* mr R3, R30 */
		/* 82258AA8h case   12:*/		regs.R3 = regs.R30;
		/* 82258AA8h case   12:*/		return 0x82258AAC;
		  /* 82258AACh */ case   13:  		/* bl -247284 */
		/* 82258AACh case   13:*/		regs.LR = 0x82258AB0; return 0x8221C4B8;
		/* 82258AACh case   13:*/		return 0x82258AB0;
		  /* 82258AB0h */ case   14:  		/* addic. R28, R3, 4 */
		/* 82258AB0h case   14:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R3,0x4);
		/* 82258AB0h case   14:*/		return 0x82258AB4;
		  /* 82258AB4h */ case   15:  		/* stw R30, <#[R3]> */
		/* 82258AB4h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82258AB4h case   15:*/		return 0x82258AB8;
		  /* 82258AB8h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 82258AB8h case   16:*/		if ( regs.CR[0].eq ) { return 0x82258AD0;  }
		/* 82258AB8h case   16:*/		return 0x82258ABC;
		  /* 82258ABCh */ case   17:  		/* lwz R11, <#[R31 + 36]> */
		/* 82258ABCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82258ABCh case   17:*/		return 0x82258AC0;
		  /* 82258AC0h */ case   18:  		/* mr R3, R28 */
		/* 82258AC0h case   18:*/		regs.R3 = regs.R28;
		/* 82258AC0h case   18:*/		return 0x82258AC4;
		  /* 82258AC4h */ case   19:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82258AC4h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258AC4h case   19:*/		return 0x82258AC8;
		  /* 82258AC8h */ case   20:  		/* bl -142696 */
		/* 82258AC8h case   20:*/		regs.LR = 0x82258ACC; return 0x82235D60;
		/* 82258AC8h case   20:*/		return 0x82258ACC;
		  /* 82258ACCh */ case   21:  		/* b 8 */
		/* 82258ACCh case   21:*/		return 0x82258AD4;
		/* 82258ACCh case   21:*/		return 0x82258AD0;
	}
	return 0x82258AD0;
} // Block from 82258A78h-82258AD0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82258AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258AD0);
		  /* 82258AD0h */ case    0:  		/* li R28, 0 */
		/* 82258AD0h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82258AD0h case    0:*/		return 0x82258AD4;
	}
	return 0x82258AD4;
} // Block from 82258AD0h-82258AD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258AD4);
		  /* 82258AD4h */ case    0:  		/* li R11, 1 */
		/* 82258AD4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82258AD4h case    0:*/		return 0x82258AD8;
	}
	return 0x82258AD8;
} // Block from 82258AD4h-82258AD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258AD8h
// Function '?NewInst@IRLoopStart@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258AD8);
		  /* 82258AD8h */ case    0:  		/* li R10, 0 */
		/* 82258AD8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82258AD8h case    0:*/		return 0x82258ADC;
		  /* 82258ADCh */ case    1:  		/* stw R11, <#[R29 + 72]> */
		/* 82258ADCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000048) );
		/* 82258ADCh case    1:*/		return 0x82258AE0;
		  /* 82258AE0h */ case    2:  		/* mr R3, R28 */
		/* 82258AE0h case    2:*/		regs.R3 = regs.R28;
		/* 82258AE0h case    2:*/		return 0x82258AE4;
		  /* 82258AE4h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82258AE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82258AE4h case    3:*/		return 0x82258AE8;
		  /* 82258AE8h */ case    4:  		/* stw R10, <#[R11 + 4]> */
		/* 82258AE8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82258AE8h case    4:*/		return 0x82258AEC;
		  /* 82258AECh */ case    5:  		/* lwz R11, <#[R31 + 24]> */
		/* 82258AECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82258AECh case    5:*/		return 0x82258AF0;
		  /* 82258AF0h */ case    6:  		/* lwz R10, <#[R29 + 72]> */
		/* 82258AF0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000048) );
		/* 82258AF0h case    6:*/		return 0x82258AF4;
		  /* 82258AF4h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82258AF4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82258AF4h case    7:*/		return 0x82258AF8;
		  /* 82258AF8h */ case    8:  		/* stwx R29, <#[R10 + R11]> */
		/* 82258AF8h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258AF8h case    8:*/		return 0x82258AFC;
		  /* 82258AFCh */ case    9:  		/* lwz R4, <#[R28 + 4]> */
		/* 82258AFCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000004) );
		/* 82258AFCh case    9:*/		return 0x82258B00;
		  /* 82258B00h */ case   10:  		/* bl -20544 */
		/* 82258B00h case   10:*/		regs.LR = 0x82258B04; return 0x82253AC0;
		/* 82258B00h case   10:*/		return 0x82258B04;
		  /* 82258B04h */ case   11:  		/* stw R29, <#[R3]> */
		/* 82258B04h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82258B04h case   11:*/		return 0x82258B08;
		  /* 82258B08h */ case   12:  		/* lwz R11, <#[R29 + 72]> */
		/* 82258B08h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000048) );
		/* 82258B08h case   12:*/		return 0x82258B0C;
		  /* 82258B0Ch */ case   13:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82258B0Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82258B0Ch case   13:*/		return 0x82258B10;
		  /* 82258B10h */ case   14:  		/* lwz R9, <#[R31 + 4]> */
		/* 82258B10h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82258B10h case   14:*/		return 0x82258B14;
		  /* 82258B14h */ case   15:  		/* li R27, 2 */
		/* 82258B14h case   15:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82258B14h case   15:*/		return 0x82258B18;
		  /* 82258B18h */ case   16:  		/* stwx R11, <#[R10 + R9]> */
		/* 82258B18h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82258B18h case   16:*/		return 0x82258B1C;
		  /* 82258B1Ch */ case   17:  		/* lwz R10, <#[R29 + 72]> */
		/* 82258B1Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000048) );
		/* 82258B1Ch case   17:*/		return 0x82258B20;
		  /* 82258B20h */ case   18:  		/* lwz R11, <#[R31 + 16]> */
		/* 82258B20h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82258B20h case   18:*/		return 0x82258B24;
		  /* 82258B24h */ case   19:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82258B24h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82258B24h case   19:*/		return 0x82258B28;
	}
	return 0x82258B28;
} // Block from 82258AD8h-82258B28h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82258B28h
// Function '?NewInst@IRLoopIndex@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258B28);
		  /* 82258B28h */ case    0:  		/* stwx R10, <#[R9 + R11]> */
		/* 82258B28h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82258B28h case    0:*/		return 0x82258B2C;
		  /* 82258B2Ch */ case    1:  		/* lwz R11, <#[R31 + 32]> */
		/* 82258B2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82258B2Ch case    1:*/		return 0x82258B30;
		  /* 82258B30h */ case    2:  		/* mr R3, R29 */
		/* 82258B30h case    2:*/		regs.R3 = regs.R29;
		/* 82258B30h case    2:*/		return 0x82258B34;
		  /* 82258B34h */ case    3:  		/* lwz R4, <#[R11 + 2148]> */
		/* 82258B34h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000864) );
		/* 82258B34h case    3:*/		return 0x82258B38;
		  /* 82258B38h */ case    4:  		/* bl 2280 */
		/* 82258B38h case    4:*/		regs.LR = 0x82258B3C; return 0x82259420;
		/* 82258B38h case    4:*/		return 0x82258B3C;
		  /* 82258B3Ch */ case    5:  		/* or. R30, R3, R3 */
		/* 82258B3Ch case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82258B3Ch case    5:*/		return 0x82258B40;
		  /* 82258B40h */ case    6:  		/* bc 12, CR0_EQ, 100 */
		/* 82258B40h case    6:*/		if ( regs.CR[0].eq ) { return 0x82258BA4;  }
		/* 82258B40h case    6:*/		return 0x82258B44;
		  /* 82258B44h */ case    7:  		/* mr R3, R28 */
		/* 82258B44h case    7:*/		regs.R3 = regs.R28;
		/* 82258B44h case    7:*/		return 0x82258B48;
		  /* 82258B48h */ case    8:  		/* lwz R4, <#[R28 + 4]> */
		/* 82258B48h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000004) );
		/* 82258B48h case    8:*/		return 0x82258B4C;
		  /* 82258B4Ch */ case    9:  		/* bl -20620 */
		/* 82258B4Ch case    9:*/		regs.LR = 0x82258B50; return 0x82253AC0;
		/* 82258B4Ch case    9:*/		return 0x82258B50;
		  /* 82258B50h */ case   10:  		/* stw R30, <#[R3]> */
		/* 82258B50h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82258B50h case   10:*/		return 0x82258B54;
		  /* 82258B54h */ case   11:  		/* stw R27, <#[R30 + 72]> */
		/* 82258B54h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000048) );
		/* 82258B54h case   11:*/		return 0x82258B58;
		  /* 82258B58h */ case   12:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 82258B58h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 82258B58h case   12:*/		return 0x82258B5C;
		  /* 82258B5Ch */ case   13:  		/* addi R27, R27, 1 */
		/* 82258B5Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82258B5Ch case   13:*/		return 0x82258B60;
		  /* 82258B60h */ case   14:  		/* lwz R10, <#[R29 + 72]> */
		/* 82258B60h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000048) );
		/* 82258B60h case   14:*/		return 0x82258B64;
		  /* 82258B64h */ case   15:  		/* mr R29, R30 */
		/* 82258B64h case   15:*/		regs.R29 = regs.R30;
		/* 82258B64h case   15:*/		return 0x82258B68;
		  /* 82258B68h */ case   16:  		/* lwz R9, <#[R31]> */
		/* 82258B68h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82258B68h case   16:*/		return 0x82258B6C;
		  /* 82258B6Ch */ case   17:  		/* stwx R10, <#[R11 + R9]> */
		/* 82258B6Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82258B6Ch case   17:*/		return 0x82258B70;
		  /* 82258B70h */ case   18:  		/* lwz R11, <#[R30 + 72]> */
		/* 82258B70h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 82258B70h case   18:*/		return 0x82258B74;
		  /* 82258B74h */ case   19:  		/* lwz R10, <#[R31 + 24]> */
		/* 82258B74h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82258B74h case   19:*/		return 0x82258B78;
		  /* 82258B78h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82258B78h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82258B78h case   20:*/		return 0x82258B7C;
		  /* 82258B7Ch */ case   21:  		/* stwx R30, <#[R11 + R10]> */
		/* 82258B7Ch case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82258B7Ch case   21:*/		return 0x82258B80;
		  /* 82258B80h */ case   22:  		/* lwz R11, <#[R30 + 72]> */
		/* 82258B80h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 82258B80h case   22:*/		return 0x82258B84;
		  /* 82258B84h */ case   23:  		/* lwz R10, <#[R31 + 32]> */
		/* 82258B84h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82258B84h case   23:*/		return 0x82258B88;
		  /* 82258B88h */ case   24:  		/* lwz R10, <#[R10 + 2148]> */
		/* 82258B88h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000864) );
		/* 82258B88h case   24:*/		return 0x82258B8C;
		  /* 82258B8Ch */ case   25:  		/* stw R10, <#[R30 + 128]> */
		/* 82258B8Ch case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000080) );
		/* 82258B8Ch case   25:*/		return 0x82258B90;
		  /* 82258B90h */ case   26:  		/* lwz R10, <#[R31 + 4]> */
		/* 82258B90h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82258B90h case   26:*/		return 0x82258B94;
		  /* 82258B94h */ case   27:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82258B94h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82258B94h case   27:*/		return 0x82258B98;
		  /* 82258B98h */ case   28:  		/* stwx R11, <#[R9 + R10]> */
		/* 82258B98h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82258B98h case   28:*/		return 0x82258B9C;
		  /* 82258B9Ch */ case   29:  		/* lwz R10, <#[R30 + 72]> */
		/* 82258B9Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000048) );
		/* 82258B9Ch case   29:*/		return 0x82258BA0;
		  /* 82258BA0h */ case   30:  		/* b -128 */
		/* 82258BA0h case   30:*/		return 0x82258B20;
		/* 82258BA0h case   30:*/		return 0x82258BA4;
	}
	return 0x82258BA4;
} // Block from 82258B28h-82258BA4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82258BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258BA4);
		  /* 82258BA4h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82258BA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82258BA4h case    0:*/		return 0x82258BA8;
	}
	return 0x82258BA8;
} // Block from 82258BA4h-82258BA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258BA8h
// Function '?NewInst@IRAllocPos@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258BA8);
		  /* 82258BA8h */ case    0:  		/* mr R3, R28 */
		/* 82258BA8h case    0:*/		regs.R3 = regs.R28;
		/* 82258BA8h case    0:*/		return 0x82258BAC;
		  /* 82258BACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82258BACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82258BACh case    1:*/		return 0x82258BB0;
		  /* 82258BB0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 82258BB0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82258BC0;  }
		/* 82258BB0h case    2:*/		return 0x82258BB4;
		  /* 82258BB4h */ case    3:  		/* bl 8604 */
		/* 82258BB4h case    3:*/		regs.LR = 0x82258BB8; return 0x8225AD50;
		/* 82258BB4h case    3:*/		return 0x82258BB8;
		  /* 82258BB8h */ case    4:  		/* mr R29, R3 */
		/* 82258BB8h case    4:*/		regs.R29 = regs.R3;
		/* 82258BB8h case    4:*/		return 0x82258BBC;
		  /* 82258BBCh */ case    5:  		/* b -144 */
		/* 82258BBCh case    5:*/		return 0x82258B2C;
		/* 82258BBCh case    5:*/		return 0x82258BC0;
	}
	return 0x82258BC0;
} // Block from 82258BA8h-82258BC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82258BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258BC0);
		  /* 82258BC0h */ case    0:  		/* li R4, 1 */
		/* 82258BC0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82258BC0h case    0:*/		return 0x82258BC4;
		  /* 82258BC4h */ case    1:  		/* bl -102444 */
		/* 82258BC4h case    1:*/		regs.LR = 0x82258BC8; return 0x8223FB98;
		/* 82258BC4h case    1:*/		return 0x82258BC8;
		  /* 82258BC8h */ case    2:  		/* addi R1, R1, 128 */
		/* 82258BC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82258BC8h case    2:*/		return 0x82258BCC;
		  /* 82258BCCh */ case    3:  		/* b -1866024 */
		/* 82258BCCh case    3:*/		return 0x820912A4;
		/* 82258BCCh case    3:*/		return 0x82258BD0;
	}
	return 0x82258BD0;
} // Block from 82258BC0h-82258BD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258BD0);
		  /* 82258BD0h */ case    0:  		/* mfspr R12, LR */
		/* 82258BD0h case    0:*/		regs.R12 = regs.LR;
		/* 82258BD0h case    0:*/		return 0x82258BD4;
		  /* 82258BD4h */ case    1:  		/* bl -1866132 */
		/* 82258BD4h case    1:*/		regs.LR = 0x82258BD8; return 0x82091240;
		/* 82258BD4h case    1:*/		return 0x82258BD8;
		  /* 82258BD8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82258BD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82258BD8h case    2:*/		return 0x82258BDC;
		  /* 82258BDCh */ case    3:  		/* lwz R11, <#[R3 + 32]> */
		/* 82258BDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82258BDCh case    3:*/		return 0x82258BE0;
		  /* 82258BE0h */ case    4:  		/* mr R31, R3 */
		/* 82258BE0h case    4:*/		regs.R31 = regs.R3;
		/* 82258BE0h case    4:*/		return 0x82258BE4;
		  /* 82258BE4h */ case    5:  		/* lwz R22, <#[R11 + 164]> */
		/* 82258BE4h case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x000000A4) );
		/* 82258BE4h case    5:*/		return 0x82258BE8;
		  /* 82258BE8h */ case    6:  		/* lwz R10, <#[R22 + 72]> */
		/* 82258BE8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000048) );
		/* 82258BE8h case    6:*/		return 0x82258BEC;
		  /* 82258BECh */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82258BECh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82258BECh case    7:*/		return 0x82258BF0;
		  /* 82258BF0h */ case    8:  		/* bc 4, CR6_EQ, 36 */
		/* 82258BF0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82258C14;  }
		/* 82258BF0h case    8:*/		return 0x82258BF4;
		  /* 82258BF4h */ case    9:  		/* lwz R11, <#[R11 + 136]> */
		/* 82258BF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000088) );
		/* 82258BF4h case    9:*/		return 0x82258BF8;
		  /* 82258BF8h */ case   10:  		/* b 16 */
		/* 82258BF8h case   10:*/		return 0x82258C08;
		/* 82258BF8h case   10:*/		return 0x82258BFC;
		  /* 82258BFCh */ case   11:  		/* lwz R10, <#[R11 + 72]> */
		/* 82258BFCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 82258BFCh case   11:*/		return 0x82258C00;
		  /* 82258C00h */ case   12:  		/* stw R10, <#[R11 + 76]> */
		/* 82258C00h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 82258C00h case   12:*/		return 0x82258C04;
		  /* 82258C04h */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 82258C04h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82258C04h case   13:*/		return 0x82258C08;
	}
	return 0x82258C08;
} // Block from 82258BD0h-82258C08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82258C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258C08);
		  /* 82258C08h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82258C08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82258C08h case    0:*/		return 0x82258C0C;
		  /* 82258C0Ch */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82258C0Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82258C0Ch case    1:*/		return 0x82258C10;
		  /* 82258C10h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82258C10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82258BFC;  }
		/* 82258C10h case    2:*/		return 0x82258C14;
	}
	return 0x82258C14;
} // Block from 82258C08h-82258C14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258C14);
		  /* 82258C14h */ case    0:  		/* mr R4, R22 */
		/* 82258C14h case    0:*/		regs.R4 = regs.R22;
		/* 82258C14h case    0:*/		return 0x82258C18;
	}
	return 0x82258C18;
} // Block from 82258C14h-82258C18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258C18h
// Function '?NewInst@IRAllocMem@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258C18);
		  /* 82258C18h */ case    0:  		/* mr R3, R31 */
		/* 82258C18h case    0:*/		regs.R3 = regs.R31;
		/* 82258C18h case    0:*/		return 0x82258C1C;
		  /* 82258C1Ch */ case    1:  		/* bl -420 */
		/* 82258C1Ch case    1:*/		regs.LR = 0x82258C20; return 0x82258A78;
		/* 82258C1Ch case    1:*/		return 0x82258C20;
		  /* 82258C20h */ case    2:  		/* lwz R3, <#[R31 + 32]> */
		/* 82258C20h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 82258C20h case    2:*/		return 0x82258C24;
		  /* 82258C24h */ case    3:  		/* lwz R5, <#[R31 + 28]> */
		/* 82258C24h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258C24h case    3:*/		return 0x82258C28;
		  /* 82258C28h */ case    4:  		/* lwz R4, <#[R31 + 24]> */
		/* 82258C28h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 82258C28h case    4:*/		return 0x82258C2C;
		  /* 82258C2Ch */ case    5:  		/* bl -141772 */
		/* 82258C2Ch case    5:*/		regs.LR = 0x82258C30; return 0x82236260;
		/* 82258C2Ch case    5:*/		return 0x82258C30;
		  /* 82258C30h */ case    6:  		/* li R23, 0 */
		/* 82258C30h case    6:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82258C30h case    6:*/		return 0x82258C34;
		  /* 82258C34h */ case    7:  		/* lwz R24, <#[R31 + 28]> */
		/* 82258C34h case    7:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258C34h case    7:*/		return 0x82258C38;
		  /* 82258C38h */ case    8:  		/* cmplwi CR6, R24, 1 */
		/* 82258C38h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000001);
		/* 82258C38h case    8:*/		return 0x82258C3C;
		  /* 82258C3Ch */ case    9:  		/* bc 4, CR6_GT, 360 */
		/* 82258C3Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x82258DA4;  }
		/* 82258C3Ch case    9:*/		return 0x82258C40;
		  /* 82258C40h */ case   10:  		/* rlwinm R29, R24, 2, 0, 29 */
		/* 82258C40h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R24);
		/* 82258C40h case   10:*/		return 0x82258C44;
		  /* 82258C44h */ case   11:  		/* lwz R11, <#[R31 + 24]> */
		/* 82258C44h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82258C44h case   11:*/		return 0x82258C48;
		  /* 82258C48h */ case   12:  		/* mr R28, R23 */
		/* 82258C48h case   12:*/		regs.R28 = regs.R23;
		/* 82258C48h case   12:*/		return 0x82258C4C;
		  /* 82258C4Ch */ case   13:  		/* mr R27, R23 */
		/* 82258C4Ch case   13:*/		regs.R27 = regs.R23;
		/* 82258C4Ch case   13:*/		return 0x82258C50;
		  /* 82258C50h */ case   14:  		/* li R26, 1 */
		/* 82258C50h case   14:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82258C50h case   14:*/		return 0x82258C54;
		  /* 82258C54h */ case   15:  		/* lwzx R25, <#[R29 + R11]> */
		/* 82258C54h case   15:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82258C54h case   15:*/		return 0x82258C58;
		  /* 82258C58h */ case   16:  		/* lwz R11, <#[R25 + 60]> */
		/* 82258C58h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000003C) );
		/* 82258C58h case   16:*/		return 0x82258C5C;
		  /* 82258C5Ch */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 82258C5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82258C5Ch case   17:*/		return 0x82258C60;
		  /* 82258C60h */ case   18:  		/* cmplw CR6, R26, R10 */
		/* 82258C60h case   18:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 82258C60h case   18:*/		return 0x82258C64;
		  /* 82258C64h */ case   19:  		/* bc 4, CR6_GT, 12 */
		/* 82258C64h case   19:*/		if ( !regs.CR[6].gt ) { return 0x82258C70;  }
		/* 82258C64h case   19:*/		return 0x82258C68;
		  /* 82258C68h */ case   20:  		/* mr R11, R23 */
		/* 82258C68h case   20:*/		regs.R11 = regs.R23;
		/* 82258C68h case   20:*/		return 0x82258C6C;
		  /* 82258C6Ch */ case   21:  		/* b 16 */
		/* 82258C6Ch case   21:*/		return 0x82258C7C;
		/* 82258C6Ch case   21:*/		return 0x82258C70;
	}
	return 0x82258C70;
} // Block from 82258C18h-82258C70h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82258C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258C70);
		  /* 82258C70h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82258C70h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82258C70h case    0:*/		return 0x82258C74;
		  /* 82258C74h */ case    1:  		/* li R11, 1 */
		/* 82258C74h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82258C74h case    1:*/		return 0x82258C78;
		  /* 82258C78h */ case    2:  		/* lwzx R28, <#[R10 + R27]> */
		/* 82258C78h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82258C78h case    2:*/		return 0x82258C7C;
	}
	return 0x82258C7C;
} // Block from 82258C70h-82258C7Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258C7C);
		  /* 82258C7Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82258C7Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82258C7Ch case    0:*/		return 0x82258C80;
		  /* 82258C80h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 82258C80h case    1:*/		if ( regs.CR[0].eq ) { return 0x82258CB8;  }
		/* 82258C80h case    1:*/		return 0x82258C84;
		  /* 82258C84h */ case    2:  		/* mr R3, R31 */
		/* 82258C84h case    2:*/		regs.R3 = regs.R31;
		/* 82258C84h case    2:*/		return 0x82258C88;
	}
	return 0x82258C88;
} // Block from 82258C7Ch-82258C88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258C88h
// Function '?NewInst@IRAllocColor@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258C88);
		  /* 82258C88h */ case    0:  		/* lwz R30, <#[R31 + 4]> */
		/* 82258C88h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 82258C88h case    0:*/		return 0x82258C8C;
		  /* 82258C8Ch */ case    1:  		/* lwz R4, <#[R28 + 72]> */
		/* 82258C8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000048) );
		/* 82258C8Ch case    1:*/		return 0x82258C90;
		  /* 82258C90h */ case    2:  		/* bl -616 */
		/* 82258C90h case    2:*/		regs.LR = 0x82258C94; return 0x82258A28;
		/* 82258C90h case    2:*/		return 0x82258C94;
		  /* 82258C94h */ case    3:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82258C94h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82258C94h case    3:*/		return 0x82258C98;
		  /* 82258C98h */ case    4:  		/* lwzx R10, <#[R29 + R30]> */
		/* 82258C98h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 82258C98h case    4:*/		return 0x82258C9C;
		  /* 82258C9Ch */ case    5:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82258C9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82258C9Ch case    5:*/		return 0x82258CA0;
		  /* 82258CA0h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82258CA0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82258CA0h case    6:*/		return 0x82258CA4;
		  /* 82258CA4h */ case    7:  		/* bc 4, CR6_LT, 8 */
		/* 82258CA4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82258CAC;  }
		/* 82258CA4h case    7:*/		return 0x82258CA8;
		  /* 82258CA8h */ case    8:  		/* stwx R11, <#[R29 + R30]> */
		/* 82258CA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 82258CA8h case    8:*/		return 0x82258CAC;
	}
	return 0x82258CAC;
} // Block from 82258C88h-82258CACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82258CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258CAC);
		  /* 82258CACh */ case    0:  		/* addi R26, R26, 1 */
		/* 82258CACh case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82258CACh case    0:*/		return 0x82258CB0;
		  /* 82258CB0h */ case    1:  		/* addi R27, R27, 4 */
		/* 82258CB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82258CB0h case    1:*/		return 0x82258CB4;
		  /* 82258CB4h */ case    2:  		/* b -92 */
		/* 82258CB4h case    2:*/		return 0x82258C58;
		/* 82258CB4h case    2:*/		return 0x82258CB8;
	}
	return 0x82258CB8;
} // Block from 82258CACh-82258CB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258CB8);
		  /* 82258CB8h */ case    0:  		/* lwz R11, <#[R31 + 36]> */
		/* 82258CB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82258CB8h case    0:*/		return 0x82258CBC;
		  /* 82258CBCh */ case    1:  		/* li R4, 12 */
		/* 82258CBCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 82258CBCh case    1:*/		return 0x82258CC0;
		  /* 82258CC0h */ case    2:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82258CC0h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258CC0h case    2:*/		return 0x82258CC4;
		  /* 82258CC4h */ case    3:  		/* mr R3, R30 */
		/* 82258CC4h case    3:*/		regs.R3 = regs.R30;
		/* 82258CC4h case    3:*/		return 0x82258CC8;
		  /* 82258CC8h */ case    4:  		/* bl -247824 */
		/* 82258CC8h case    4:*/		regs.LR = 0x82258CCC; return 0x8221C4B8;
		/* 82258CC8h case    4:*/		return 0x82258CCC;
		  /* 82258CCCh */ case    5:  		/* addic. R11, R3, 4 */
		/* 82258CCCh case    5:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 82258CCCh case    5:*/		return 0x82258CD0;
		  /* 82258CD0h */ case    6:  		/* stw R30, <#[R3]> */
		/* 82258CD0h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82258CD0h case    6:*/		return 0x82258CD4;
		  /* 82258CD4h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82258CD4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82258CE4;  }
		/* 82258CD4h case    7:*/		return 0x82258CD8;
		  /* 82258CD8h */ case    8:  		/* stw R23, <#[R11]> */
		/* 82258CD8h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82258CD8h case    8:*/		return 0x82258CDC;
		  /* 82258CDCh */ case    9:  		/* stw R23, <#[R11 + 4]> */
		/* 82258CDCh case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 82258CDCh case    9:*/		return 0x82258CE0;
		  /* 82258CE0h */ case   10:  		/* b 8 */
		/* 82258CE0h case   10:*/		return 0x82258CE8;
		/* 82258CE0h case   10:*/		return 0x82258CE4;
	}
	return 0x82258CE4;
} // Block from 82258CB8h-82258CE4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82258CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258CE4);
		  /* 82258CE4h */ case    0:  		/* mr R11, R23 */
		/* 82258CE4h case    0:*/		regs.R11 = regs.R23;
		/* 82258CE4h case    0:*/		return 0x82258CE8;
	}
	return 0x82258CE8;
} // Block from 82258CE4h-82258CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258CE8);
		  /* 82258CE8h */ case    0:  		/* stw R24, <#[R11]> */
		/* 82258CE8h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 82258CE8h case    0:*/		return 0x82258CEC;
		  /* 82258CECh */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 82258CECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82258CECh case    1:*/		return 0x82258CF0;
		  /* 82258CF0h */ case    2:  		/* lwz R9, <#[R31 + 20]> */
		/* 82258CF0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82258CF0h case    2:*/		return 0x82258CF4;
		  /* 82258CF4h */ case    3:  		/* lwzx R10, <#[R29 + R10]> */
		/* 82258CF4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 82258CF4h case    3:*/		return 0x82258CF8;
	}
	return 0x82258CF8;
} // Block from 82258CE8h-82258CF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258CF8h
// Function '?NewInst@IRAllocInterp@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258CF8);
		  /* 82258CF8h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82258CF8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82258CF8h case    0:*/		return 0x82258CFC;
		  /* 82258CFCh */ case    1:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82258CFCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82258CFCh case    1:*/		return 0x82258D00;
		  /* 82258D00h */ case    2:  		/* stw R10, <#[R11 + 4]> */
		/* 82258D00h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82258D00h case    2:*/		return 0x82258D04;
		  /* 82258D04h */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 82258D04h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82258D04h case    3:*/		return 0x82258D08;
		  /* 82258D08h */ case    4:  		/* lwz R9, <#[R31 + 20]> */
		/* 82258D08h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82258D08h case    4:*/		return 0x82258D0C;
		  /* 82258D0Ch */ case    5:  		/* lwzx R10, <#[R29 + R10]> */
		/* 82258D0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 82258D0Ch case    5:*/		return 0x82258D10;
		  /* 82258D10h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82258D10h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82258D10h case    6:*/		return 0x82258D14;
		  /* 82258D14h */ case    7:  		/* stwx R11, <#[R10 + R9]> */
		/* 82258D14h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82258D14h case    7:*/		return 0x82258D18;
		  /* 82258D18h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82258D18h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82258D18h case    8:*/		return 0x82258D1C;
		  /* 82258D1Ch */ case    9:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82258D1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82258D1Ch case    9:*/		return 0x82258D20;
		  /* 82258D20h */ case   10:  		/* lwz R10, <#[R31 + 12]> */
		/* 82258D20h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82258D20h case   10:*/		return 0x82258D24;
		  /* 82258D24h */ case   11:  		/* stwx R11, <#[R29 + R10]> */
		/* 82258D24h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 82258D24h case   11:*/		return 0x82258D28;
		  /* 82258D28h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 82258D28h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82258D28h case   12:*/		return 0x82258D2C;
		  /* 82258D2Ch */ case   13:  		/* lwz R10, <#[R31 + 20]> */
		/* 82258D2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82258D2Ch case   13:*/		return 0x82258D30;
		  /* 82258D30h */ case   14:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82258D30h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82258D30h case   14:*/		return 0x82258D34;
		  /* 82258D34h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82258D34h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82258D34h case   15:*/		return 0x82258D38;
		  /* 82258D38h */ case   16:  		/* lwzx R30, <#[R11 + R10]> */
		/* 82258D38h case   16:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82258D38h case   16:*/		return 0x82258D3C;
		  /* 82258D3Ch */ case   17:  		/* b 80 */
		/* 82258D3Ch case   17:*/		return 0x82258D8C;
		/* 82258D3Ch case   17:*/		return 0x82258D40;
		  /* 82258D40h */ case   18:  		/* lwz R28, <#[R30]> */
		/* 82258D40h case   18:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 82258D40h case   18:*/		return 0x82258D44;
		  /* 82258D44h */ case   19:  		/* mr R3, R31 */
		/* 82258D44h case   19:*/		regs.R3 = regs.R31;
		/* 82258D44h case   19:*/		return 0x82258D48;
		  /* 82258D48h */ case   20:  		/* mr R4, R28 */
		/* 82258D48h case   20:*/		regs.R4 = regs.R28;
		/* 82258D48h case   20:*/		return 0x82258D4C;
		  /* 82258D4Ch */ case   21:  		/* bl -804 */
		/* 82258D4Ch case   21:*/		regs.LR = 0x82258D50; return 0x82258A28;
		/* 82258D4Ch case   21:*/		return 0x82258D50;
		  /* 82258D50h */ case   22:  		/* lwz R10, <#[R31 + 4]> */
		/* 82258D50h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82258D50h case   22:*/		return 0x82258D54;
		  /* 82258D54h */ case   23:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 82258D54h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 82258D54h case   23:*/		return 0x82258D58;
		  /* 82258D58h */ case   24:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 82258D58h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 82258D58h case   24:*/		return 0x82258D5C;
		  /* 82258D5Ch */ case   25:  		/* lwzx R8, <#[R11 + R10]> */
		/* 82258D5Ch case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82258D5Ch case   25:*/		return 0x82258D60;
		  /* 82258D60h */ case   26:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82258D60h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82258D60h case   26:*/		return 0x82258D64;
		  /* 82258D64h */ case   27:  		/* cmplw CR6, R8, R10 */
		/* 82258D64h case   27:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82258D64h case   27:*/		return 0x82258D68;
	}
	return 0x82258D68;
} // Block from 82258CF8h-82258D68h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82258D68h
// Function '?NewInst@IRZeroary@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258D68);
		  /* 82258D68h */ case    0:  		/* bc 4, CR6_EQ, 24 */
		/* 82258D68h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82258D80;  }
		/* 82258D68h case    0:*/		return 0x82258D6C;
		  /* 82258D6Ch */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 82258D6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82258D6Ch case    1:*/		return 0x82258D70;
		  /* 82258D70h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 82258D70h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82258D70h case    2:*/		return 0x82258D74;
		  /* 82258D74h */ case    3:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82258D74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82258D74h case    3:*/		return 0x82258D78;
		  /* 82258D78h */ case    4:  		/* stwx R10, <#[R9 + R11]> */
		/* 82258D78h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82258D78h case    4:*/		return 0x82258D7C;
		  /* 82258D7Ch */ case    5:  		/* b 12 */
		/* 82258D7Ch case    5:*/		return 0x82258D88;
		/* 82258D7Ch case    5:*/		return 0x82258D80;
	}
	return 0x82258D80;
} // Block from 82258D68h-82258D80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82258D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258D80);
		  /* 82258D80h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 82258D80h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82258D80h case    0:*/		return 0x82258D84;
		  /* 82258D84h */ case    1:  		/* stwx R3, <#[R10 + R11]> */
		/* 82258D84h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258D84h case    1:*/		return 0x82258D88;
	}
	return 0x82258D88;
} // Block from 82258D80h-82258D88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258D88);
		  /* 82258D88h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82258D88h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82258D88h case    0:*/		return 0x82258D8C;
	}
	return 0x82258D8C;
} // Block from 82258D88h-82258D8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258D8C);
		  /* 82258D8Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82258D8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82258D8Ch case    0:*/		return 0x82258D90;
		  /* 82258D90h */ case    1:  		/* bc 4, CR6_EQ, -80 */
		/* 82258D90h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82258D40;  }
		/* 82258D90h case    1:*/		return 0x82258D94;
		  /* 82258D94h */ case    2:  		/* addi R24, R24, -1 */
		/* 82258D94h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 82258D94h case    2:*/		return 0x82258D98;
		  /* 82258D98h */ case    3:  		/* addi R29, R29, -4 */
		/* 82258D98h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFC);
		/* 82258D98h case    3:*/		return 0x82258D9C;
		  /* 82258D9Ch */ case    4:  		/* cmplwi CR6, R24, 1 */
		/* 82258D9Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000001);
		/* 82258D9Ch case    4:*/		return 0x82258DA0;
		  /* 82258DA0h */ case    5:  		/* bc 12, CR6_GT, -348 */
		/* 82258DA0h case    5:*/		if ( regs.CR[6].gt ) { return 0x82258C44;  }
		/* 82258DA0h case    5:*/		return 0x82258DA4;
	}
	return 0x82258DA4;
} // Block from 82258D8Ch-82258DA4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82258DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258DA4);
		  /* 82258DA4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82258DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82258DA4h case    0:*/		return 0x82258DA8;
		  /* 82258DA8h */ case    1:  		/* li R9, 2 */
		/* 82258DA8h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82258DA8h case    1:*/		return 0x82258DAC;
		  /* 82258DACh */ case    2:  		/* stw R23, <#[R11 + 4]> */
		/* 82258DACh case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		/* 82258DACh case    2:*/		return 0x82258DB0;
		  /* 82258DB0h */ case    3:  		/* lwz R11, <#[R31 + 28]> */
		/* 82258DB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258DB0h case    3:*/		return 0x82258DB4;
		  /* 82258DB4h */ case    4:  		/* cmplwi CR6, R11, 2 */
		/* 82258DB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82258DB4h case    4:*/		return 0x82258DB8;
		  /* 82258DB8h */ case    5:  		/* bc 12, CR6_LT, 72 */
		/* 82258DB8h case    5:*/		if ( regs.CR[6].lt ) { return 0x82258E00;  }
		/* 82258DB8h case    5:*/		return 0x82258DBC;
		  /* 82258DBCh */ case    6:  		/* li R10, 8 */
		/* 82258DBCh case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 82258DBCh case    6:*/		return 0x82258DC0;
		  /* 82258DC0h */ case    7:  		/* lwz R11, <#[R31 + 4]> */
		/* 82258DC0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82258DC0h case    7:*/		return 0x82258DC4;
		  /* 82258DC4h */ case    8:  		/* lwz R8, <#[R31 + 8]> */
		/* 82258DC4h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82258DC4h case    8:*/		return 0x82258DC8;
		  /* 82258DC8h */ case    9:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82258DC8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258DC8h case    9:*/		return 0x82258DCC;
		  /* 82258DCCh */ case   10:  		/* lwzx R8, <#[R8 + R10]> */
		/* 82258DCCh case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82258DCCh case   10:*/		return 0x82258DD0;
		  /* 82258DD0h */ case   11:  		/* cmplw CR6, R8, R11 */
		/* 82258DD0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82258DD0h case   11:*/		return 0x82258DD4;
		  /* 82258DD4h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 82258DD4h case   12:*/		if ( regs.CR[6].eq ) { return 0x82258DEC;  }
		/* 82258DD4h case   12:*/		return 0x82258DD8;
	}
	return 0x82258DD8;
} // Block from 82258DA4h-82258DD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82258DD8h
// Function '?NewInst@IRUnary@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258DD8);
		  /* 82258DD8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82258DD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82258DD8h case    0:*/		return 0x82258DDC;
		  /* 82258DDCh */ case    1:  		/* lwzx R8, <#[R10 + R11]> */
		/* 82258DDCh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258DDCh case    1:*/		return 0x82258DE0;
		  /* 82258DE0h */ case    2:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82258DE0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82258DE0h case    2:*/		return 0x82258DE4;
		  /* 82258DE4h */ case    3:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82258DE4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82258DE4h case    3:*/		return 0x82258DE8;
		  /* 82258DE8h */ case    4:  		/* stwx R8, <#[R10 + R11]> */
		/* 82258DE8h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258DE8h case    4:*/		return 0x82258DEC;
	}
	return 0x82258DEC;
} // Block from 82258DD8h-82258DECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82258DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258DEC);
		  /* 82258DECh */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 82258DECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258DECh case    0:*/		return 0x82258DF0;
		  /* 82258DF0h */ case    1:  		/* addi R9, R9, 1 */
		/* 82258DF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82258DF0h case    1:*/		return 0x82258DF4;
		  /* 82258DF4h */ case    2:  		/* addi R10, R10, 4 */
		/* 82258DF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82258DF4h case    2:*/		return 0x82258DF8;
		  /* 82258DF8h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 82258DF8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82258DF8h case    3:*/		return 0x82258DFC;
		  /* 82258DFCh */ case    4:  		/* bc 4, CR6_GT, -60 */
		/* 82258DFCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x82258DC0;  }
		/* 82258DFCh case    4:*/		return 0x82258E00;
	}
	return 0x82258E00;
} // Block from 82258DECh-82258E00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82258E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E00);
		  /* 82258E00h */ case    0:  		/* li R30, 1 */
		/* 82258E00h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82258E00h case    0:*/		return 0x82258E04;
		  /* 82258E04h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 82258E04h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82258E04h case    1:*/		return 0x82258E08;
		  /* 82258E08h */ case    2:  		/* bc 12, CR6_LT, 88 */
		/* 82258E08h case    2:*/		if ( regs.CR[6].lt ) { return 0x82258E60;  }
		/* 82258E08h case    2:*/		return 0x82258E0C;
		  /* 82258E0Ch */ case    3:  		/* cmplwi CR6, R30, 1 */
		/* 82258E0Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 82258E0Ch case    3:*/		return 0x82258E10;
		  /* 82258E10h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82258E10h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82258E1C;  }
		/* 82258E10h case    4:*/		return 0x82258E14;
		  /* 82258E14h */ case    5:  		/* mr R3, R23 */
		/* 82258E14h case    5:*/		regs.R3 = regs.R23;
		/* 82258E14h case    5:*/		return 0x82258E18;
		  /* 82258E18h */ case    6:  		/* b 28 */
		/* 82258E18h case    6:*/		return 0x82258E34;
		/* 82258E18h case    6:*/		return 0x82258E1C;
	}
	return 0x82258E1C;
} // Block from 82258E00h-82258E1Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82258E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E1C);
		  /* 82258E1Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82258E1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82258E1Ch case    0:*/		return 0x82258E20;
		  /* 82258E20h */ case    1:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82258E20h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82258E20h case    1:*/		return 0x82258E24;
		  /* 82258E24h */ case    2:  		/* lwz R9, <#[R31 + 24]> */
		/* 82258E24h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82258E24h case    2:*/		return 0x82258E28;
		  /* 82258E28h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82258E28h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258E28h case    3:*/		return 0x82258E2C;
		  /* 82258E2Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82258E2Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82258E2Ch case    4:*/		return 0x82258E30;
		  /* 82258E30h */ case    5:  		/* lwzx R3, <#[R11 + R9]> */
		/* 82258E30h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82258E30h case    5:*/		return 0x82258E34;
	}
	return 0x82258E34;
} // Block from 82258E1Ch-82258E34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82258E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E34);
		  /* 82258E34h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 82258E34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82258E34h case    0:*/		return 0x82258E38;
		  /* 82258E38h */ case    1:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82258E38h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82258E38h case    1:*/		return 0x82258E3C;
		  /* 82258E3Ch */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 82258E3Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82258E3Ch case    2:*/		return 0x82258E40;
	}
	return 0x82258E40;
} // Block from 82258E34h-82258E40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258E40h
// Function '?NewInst@IRBinary@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E40);
		  /* 82258E40h */ case    0:  		/* lwzx R4, <#[R10 + R11]> */
		/* 82258E40h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82258E40h case    0:*/		return 0x82258E44;
		  /* 82258E44h */ case    1:  		/* stw R3, <#[R4 + 84]> */
		/* 82258E44h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000054) );
		/* 82258E44h case    1:*/		return 0x82258E48;
		  /* 82258E48h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 82258E48h case    2:*/		if ( regs.CR[6].eq ) { return 0x82258E50;  }
		/* 82258E48h case    2:*/		return 0x82258E4C;
		  /* 82258E4Ch */ case    3:  		/* bl 1708 */
		/* 82258E4Ch case    3:*/		regs.LR = 0x82258E50; return 0x822594F8;
		/* 82258E4Ch case    3:*/		return 0x82258E50;
	}
	return 0x82258E50;
} // Block from 82258E40h-82258E50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E50);
		  /* 82258E50h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 82258E50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82258E50h case    0:*/		return 0x82258E54;
		  /* 82258E54h */ case    1:  		/* addi R30, R30, 1 */
		/* 82258E54h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82258E54h case    1:*/		return 0x82258E58;
		  /* 82258E58h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 82258E58h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82258E58h case    2:*/		return 0x82258E5C;
		  /* 82258E5Ch */ case    3:  		/* bc 4, CR6_GT, -80 */
		/* 82258E5Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82258E0C;  }
		/* 82258E5Ch case    3:*/		return 0x82258E60;
	}
	return 0x82258E60;
} // Block from 82258E50h-82258E60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E60);
		  /* 82258E60h */ case    0:  		/* mr R3, R31 */
		/* 82258E60h case    0:*/		regs.R3 = regs.R31;
		/* 82258E60h case    0:*/		return 0x82258E64;
		  /* 82258E64h */ case    1:  		/* bl -1700 */
		/* 82258E64h case    1:*/		regs.LR = 0x82258E68; return 0x822587C0;
		/* 82258E64h case    1:*/		return 0x82258E68;
		  /* 82258E68h */ case    2:  		/* lwz R11, <#[R22 + 76]> */
		/* 82258E68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000004C) );
		/* 82258E68h case    2:*/		return 0x82258E6C;
		  /* 82258E6Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82258E6Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82258E6Ch case    3:*/		return 0x82258E70;
		  /* 82258E70h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 82258E70h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82258E98;  }
		/* 82258E70h case    4:*/		return 0x82258E74;
		  /* 82258E74h */ case    5:  		/* lwz R11, <#[R31 + 32]> */
		/* 82258E74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82258E74h case    5:*/		return 0x82258E78;
		  /* 82258E78h */ case    6:  		/* lwz R11, <#[R11 + 136]> */
		/* 82258E78h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000088) );
		/* 82258E78h case    6:*/		return 0x82258E7C;
		  /* 82258E7Ch */ case    7:  		/* b 16 */
		/* 82258E7Ch case    7:*/		return 0x82258E8C;
		/* 82258E7Ch case    7:*/		return 0x82258E80;
		  /* 82258E80h */ case    8:  		/* lwz R10, <#[R11 + 76]> */
		/* 82258E80h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 82258E80h case    8:*/		return 0x82258E84;
		  /* 82258E84h */ case    9:  		/* stw R10, <#[R11 + 72]> */
		/* 82258E84h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 82258E84h case    9:*/		return 0x82258E88;
		  /* 82258E88h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 82258E88h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82258E88h case   10:*/		return 0x82258E8C;
	}
	return 0x82258E8C;
} // Block from 82258E60h-82258E8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82258E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E8C);
		  /* 82258E8Ch */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82258E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82258E8Ch case    0:*/		return 0x82258E90;
		  /* 82258E90h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82258E90h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82258E90h case    1:*/		return 0x82258E94;
		  /* 82258E94h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82258E94h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82258E80;  }
		/* 82258E94h case    2:*/		return 0x82258E98;
	}
	return 0x82258E98;
} // Block from 82258E8Ch-82258E98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258E98);
		  /* 82258E98h */ case    0:  		/* addi R1, R1, 176 */
		/* 82258E98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82258E98h case    0:*/		return 0x82258E9C;
		  /* 82258E9Ch */ case    1:  		/* b -1866764 */
		/* 82258E9Ch case    1:*/		return 0x82091290;
		/* 82258E9Ch case    1:*/		return 0x82258EA0;
	}
	return 0x82258EA0;
} // Block from 82258E98h-82258EA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258EA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258EA0);
		  /* 82258EA0h */ case    0:  		/* mfspr R12, LR */
		/* 82258EA0h case    0:*/		regs.R12 = regs.LR;
		/* 82258EA0h case    0:*/		return 0x82258EA4;
		  /* 82258EA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82258EA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258EA4h case    1:*/		return 0x82258EA8;
		  /* 82258EA8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82258EA8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258EA8h case    2:*/		return 0x82258EAC;
		  /* 82258EACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82258EACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258EACh case    3:*/		return 0x82258EB0;
	}
	return 0x82258EB0;
} // Block from 82258EA0h-82258EB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258EB0h
// Function '?MakeIRTrinary@IRTrinary@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258EB0);
		  /* 82258EB0h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258EB0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258EB0h case    0:*/		return 0x82258EB4;
		  /* 82258EB4h */ case    1:  		/* lwz R11, <#[R3 + 12]> */
		/* 82258EB4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82258EB4h case    1:*/		return 0x82258EB8;
		  /* 82258EB8h */ case    2:  		/* mr R31, R3 */
		/* 82258EB8h case    2:*/		regs.R31 = regs.R3;
		/* 82258EB8h case    2:*/		return 0x82258EBC;
		  /* 82258EBCh */ case    3:  		/* li R4, 44 */
		/* 82258EBCh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 82258EBCh case    3:*/		return 0x82258EC0;
		  /* 82258EC0h */ case    4:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82258EC0h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82258EC0h case    4:*/		return 0x82258EC4;
		  /* 82258EC4h */ case    5:  		/* mr R3, R30 */
		/* 82258EC4h case    5:*/		regs.R3 = regs.R30;
		/* 82258EC4h case    5:*/		return 0x82258EC8;
		  /* 82258EC8h */ case    6:  		/* bl -248336 */
		/* 82258EC8h case    6:*/		regs.LR = 0x82258ECC; return 0x8221C4B8;
		/* 82258EC8h case    6:*/		return 0x82258ECC;
		  /* 82258ECCh */ case    7:  		/* mr R11, R3 */
		/* 82258ECCh case    7:*/		regs.R11 = regs.R3;
		/* 82258ECCh case    7:*/		return 0x82258ED0;
		  /* 82258ED0h */ case    8:  		/* addic. R3, R3, 4 */
		/* 82258ED0h case    8:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82258ED0h case    8:*/		return 0x82258ED4;
		  /* 82258ED4h */ case    9:  		/* stw R30, <#[R11]> */
		/* 82258ED4h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82258ED4h case    9:*/		return 0x82258ED8;
		  /* 82258ED8h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 82258ED8h case   10:*/		if ( regs.CR[0].eq ) { return 0x82258EEC;  }
		/* 82258ED8h case   10:*/		return 0x82258EDC;
		  /* 82258EDCh */ case   11:  		/* mr R4, R31 */
		/* 82258EDCh case   11:*/		regs.R4 = regs.R31;
		/* 82258EDCh case   11:*/		return 0x82258EE0;
		  /* 82258EE0h */ case   12:  		/* bl -2344 */
		/* 82258EE0h case   12:*/		regs.LR = 0x82258EE4; return 0x822585B8;
		/* 82258EE0h case   12:*/		return 0x82258EE4;
		  /* 82258EE4h */ case   13:  		/* mr R31, R3 */
		/* 82258EE4h case   13:*/		regs.R31 = regs.R3;
		/* 82258EE4h case   13:*/		return 0x82258EE8;
		  /* 82258EE8h */ case   14:  		/* b 8 */
		/* 82258EE8h case   14:*/		return 0x82258EF0;
		/* 82258EE8h case   14:*/		return 0x82258EEC;
	}
	return 0x82258EEC;
} // Block from 82258EB0h-82258EECh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82258EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258EEC);
		  /* 82258EECh */ case    0:  		/* li R31, 0 */
		/* 82258EECh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82258EECh case    0:*/		return 0x82258EF0;
	}
	return 0x82258EF0;
} // Block from 82258EECh-82258EF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258EF0);
		  /* 82258EF0h */ case    0:  		/* mr R3, R31 */
		/* 82258EF0h case    0:*/		regs.R3 = regs.R31;
		/* 82258EF0h case    0:*/		return 0x82258EF4;
		  /* 82258EF4h */ case    1:  		/* bl -804 */
		/* 82258EF4h case    1:*/		regs.LR = 0x82258EF8; return 0x82258BD0;
		/* 82258EF4h case    1:*/		return 0x82258EF8;
		  /* 82258EF8h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82258EF8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82258EF8h case    2:*/		return 0x82258EFC;
		  /* 82258EFCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82258EFCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82258F14;  }
		/* 82258EFCh case    3:*/		return 0x82258F00;
		  /* 82258F00h */ case    4:  		/* mr R3, R31 */
		/* 82258F00h case    4:*/		regs.R3 = regs.R31;
		/* 82258F00h case    4:*/		return 0x82258F04;
		  /* 82258F04h */ case    5:  		/* bl -2140 */
		/* 82258F04h case    5:*/		regs.LR = 0x82258F08; return 0x822586A8;
		/* 82258F04h case    5:*/		return 0x82258F08;
		  /* 82258F08h */ case    6:  		/* addi R4, R31, -4 */
		/* 82258F08h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 82258F08h case    6:*/		return 0x82258F0C;
		  /* 82258F0Ch */ case    7:  		/* lwz R3, <#[R31 - 4]> */
		/* 82258F0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82258F0Ch case    7:*/		return 0x82258F10;
		  /* 82258F10h */ case    8:  		/* bl -248016 */
		/* 82258F10h case    8:*/		regs.LR = 0x82258F14; return 0x8221C640;
		/* 82258F10h case    8:*/		return 0x82258F14;
	}
	return 0x82258F14;
} // Block from 82258EF0h-82258F14h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82258F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F14);
		  /* 82258F14h */ case    0:  		/* addi R1, R1, 112 */
		/* 82258F14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258F14h case    0:*/		return 0x82258F18;
		  /* 82258F18h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258F18h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258F18h case    1:*/		return 0x82258F1C;
		  /* 82258F1Ch */ case    2:  		/* mtspr LR, R12 */
		/* 82258F1Ch case    2:*/		regs.LR = regs.R12;
		/* 82258F1Ch case    2:*/		return 0x82258F20;
	}
	return 0x82258F20;
} // Block from 82258F14h-82258F20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258F20h
// Function '?MakeIRVertexFetch@IRVertexFetch@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F20);
		  /* 82258F20h */ case    0:  		/* ld R30, <#[R1 - 24]> */
		/* 82258F20h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258F20h case    0:*/		return 0x82258F24;
		  /* 82258F24h */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 82258F24h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258F24h case    1:*/		return 0x82258F28;
		  /* 82258F28h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82258F28h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258F28h case    2:*/		return 0x82258F2C;
	}
	return 0x82258F2C;
} // Block from 82258F20h-82258F2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82258F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F2C);
		  /* 82258F2Ch */ case    0:  		/* nop */
		/* 82258F2Ch case    0:*/		cpu::op::nop();
		/* 82258F2Ch case    0:*/		return 0x82258F30;
	}
	return 0x82258F30;
} // Block from 82258F2Ch-82258F30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258F30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F30);
		  /* 82258F30h */ case    0:  		/* mfspr R12, LR */
		/* 82258F30h case    0:*/		regs.R12 = regs.LR;
		/* 82258F30h case    0:*/		return 0x82258F34;
		  /* 82258F34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82258F34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258F34h case    1:*/		return 0x82258F38;
		  /* 82258F38h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82258F38h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258F38h case    2:*/		return 0x82258F3C;
		  /* 82258F3Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82258F3Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258F3Ch case    3:*/		return 0x82258F40;
		  /* 82258F40h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258F40h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258F40h case    4:*/		return 0x82258F44;
		  /* 82258F44h */ case    5:  		/* mr R31, R3 */
		/* 82258F44h case    5:*/		regs.R31 = regs.R3;
		/* 82258F44h case    5:*/		return 0x82258F48;
		  /* 82258F48h */ case    6:  		/* mr R3, R4 */
		/* 82258F48h case    6:*/		regs.R3 = regs.R4;
		/* 82258F48h case    6:*/		return 0x82258F4C;
		  /* 82258F4Ch */ case    7:  		/* mr R30, R4 */
		/* 82258F4Ch case    7:*/		regs.R30 = regs.R4;
		/* 82258F4Ch case    7:*/		return 0x82258F50;
		  /* 82258F50h */ case    8:  		/* lwz R4, <#[R31 + 116]> */
		/* 82258F50h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 82258F50h case    8:*/		return 0x82258F54;
		  /* 82258F54h */ case    9:  		/* bl -22412 */
		/* 82258F54h case    9:*/		regs.LR = 0x82258F58; return 0x822537C8;
		/* 82258F54h case    9:*/		return 0x82258F58;
		  /* 82258F58h */ case   10:  		/* stw R31, <#[R30 + 948]> */
		/* 82258F58h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000003B4) );
		/* 82258F58h case   10:*/		return 0x82258F5C;
		  /* 82258F5Ch */ case   11:  		/* addi R1, R1, 112 */
		/* 82258F5Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258F5Ch case   11:*/		return 0x82258F60;
		  /* 82258F60h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258F60h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258F60h case   12:*/		return 0x82258F64;
		  /* 82258F64h */ case   13:  		/* mtspr LR, R12 */
		/* 82258F64h case   13:*/		regs.LR = regs.R12;
		/* 82258F64h case   13:*/		return 0x82258F68;
		  /* 82258F68h */ case   14:  		/* ld R30, <#[R1 - 24]> */
		/* 82258F68h case   14:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258F68h case   14:*/		return 0x82258F6C;
		  /* 82258F6Ch */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82258F6Ch case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258F6Ch case   15:*/		return 0x82258F70;
		  /* 82258F70h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82258F70h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258F70h case   16:*/		return 0x82258F74;
	}
	return 0x82258F74;
} // Block from 82258F30h-82258F74h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82258F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F74);
		  /* 82258F74h */ case    0:  		/* nop */
		/* 82258F74h case    0:*/		cpu::op::nop();
		/* 82258F74h case    0:*/		return 0x82258F78;
	}
	return 0x82258F78;
} // Block from 82258F74h-82258F78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258F78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F78);
		  /* 82258F78h */ case    0:  		/* mfspr R12, LR */
		/* 82258F78h case    0:*/		regs.R12 = regs.LR;
		/* 82258F78h case    0:*/		return 0x82258F7C;
		  /* 82258F7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82258F7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258F7Ch case    1:*/		return 0x82258F80;
	}
	return 0x82258F80;
} // Block from 82258F78h-82258F80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82258F80h
// Function '?MakeIRTextureFetch@IRTextureFetch@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258F80);
		  /* 82258F80h */ case    0:  		/* std R30, <#[R1 - 24]> */
		/* 82258F80h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258F80h case    0:*/		return 0x82258F84;
		  /* 82258F84h */ case    1:  		/* std R31, <#[R1 - 16]> */
		/* 82258F84h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258F84h case    1:*/		return 0x82258F88;
		  /* 82258F88h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258F88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258F88h case    2:*/		return 0x82258F8C;
		  /* 82258F8Ch */ case    3:  		/* mr R31, R3 */
		/* 82258F8Ch case    3:*/		regs.R31 = regs.R3;
		/* 82258F8Ch case    3:*/		return 0x82258F90;
		  /* 82258F90h */ case    4:  		/* mr R3, R4 */
		/* 82258F90h case    4:*/		regs.R3 = regs.R4;
		/* 82258F90h case    4:*/		return 0x82258F94;
		  /* 82258F94h */ case    5:  		/* mr R30, R4 */
		/* 82258F94h case    5:*/		regs.R30 = regs.R4;
		/* 82258F94h case    5:*/		return 0x82258F98;
		  /* 82258F98h */ case    6:  		/* lwz R4, <#[R31 + 112]> */
		/* 82258F98h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000070) );
		/* 82258F98h case    6:*/		return 0x82258F9C;
		  /* 82258F9Ch */ case    7:  		/* bl -22452 */
		/* 82258F9Ch case    7:*/		regs.LR = 0x82258FA0; return 0x822537E8;
		/* 82258F9Ch case    7:*/		return 0x82258FA0;
		  /* 82258FA0h */ case    8:  		/* stw R31, <#[R30 + 948]> */
		/* 82258FA0h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000003B4) );
		/* 82258FA0h case    8:*/		return 0x82258FA4;
		  /* 82258FA4h */ case    9:  		/* addi R1, R1, 112 */
		/* 82258FA4h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82258FA4h case    9:*/		return 0x82258FA8;
		  /* 82258FA8h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 82258FA8h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82258FA8h case   10:*/		return 0x82258FAC;
		  /* 82258FACh */ case   11:  		/* mtspr LR, R12 */
		/* 82258FACh case   11:*/		regs.LR = regs.R12;
		/* 82258FACh case   11:*/		return 0x82258FB0;
		  /* 82258FB0h */ case   12:  		/* ld R30, <#[R1 - 24]> */
		/* 82258FB0h case   12:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82258FB0h case   12:*/		return 0x82258FB4;
		  /* 82258FB4h */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 82258FB4h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82258FB4h case   13:*/		return 0x82258FB8;
		  /* 82258FB8h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82258FB8h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82258FB8h case   14:*/		return 0x82258FBC;
	}
	return 0x82258FBC;
} // Block from 82258F80h-82258FBCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 82258FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258FBC);
		  /* 82258FBCh */ case    0:  		/* nop */
		/* 82258FBCh case    0:*/		cpu::op::nop();
		/* 82258FBCh case    0:*/		return 0x82258FC0;
	}
	return 0x82258FC0;
} // Block from 82258FBCh-82258FC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82258FC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258FC0);
		  /* 82258FC0h */ case    0:  		/* mfspr R12, LR */
		/* 82258FC0h case    0:*/		regs.R12 = regs.LR;
		/* 82258FC0h case    0:*/		return 0x82258FC4;
		  /* 82258FC4h */ case    1:  		/* bl -1867112 */
		/* 82258FC4h case    1:*/		regs.LR = 0x82258FC8; return 0x8209125C;
		/* 82258FC4h case    1:*/		return 0x82258FC8;
		  /* 82258FC8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82258FC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82258FC8h case    2:*/		return 0x82258FCC;
		  /* 82258FCCh */ case    3:  		/* lwz R11, <#[R4 + 948]> */
		/* 82258FCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x000003B4) );
		/* 82258FCCh case    3:*/		return 0x82258FD0;
	}
	return 0x82258FD0;
} // Block from 82258FC0h-82258FD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82258FD0h
// Function '??0IRNop@XGRAPHICS@@QAA@W4Op@R400Tables@@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82258FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82258FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82258FD0);
		  /* 82258FD0h */ case    0:  		/* mr R29, R3 */
		/* 82258FD0h case    0:*/		regs.R29 = regs.R3;
		/* 82258FD0h case    0:*/		return 0x82258FD4;
		  /* 82258FD4h */ case    1:  		/* mr R31, R4 */
		/* 82258FD4h case    1:*/		regs.R31 = regs.R4;
		/* 82258FD4h case    1:*/		return 0x82258FD8;
		  /* 82258FD8h */ case    2:  		/* mr R30, R5 */
		/* 82258FD8h case    2:*/		regs.R30 = regs.R5;
		/* 82258FD8h case    2:*/		return 0x82258FDC;
		  /* 82258FDCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82258FDCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82258FDCh case    3:*/		return 0x82258FE0;
		  /* 82258FE0h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 82258FE0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82259008;  }
		/* 82258FE0h case    4:*/		return 0x82258FE4;
		  /* 82258FE4h */ case    5:  		/* lis R11, -32251 */
		/* 82258FE4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82258FE4h case    5:*/		return 0x82258FE8;
		  /* 82258FE8h */ case    6:  		/* lis R10, -32251 */
		/* 82258FE8h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82258FE8h case    6:*/		return 0x82258FEC;
		  /* 82258FECh */ case    7:  		/* lis R9, -32253 */
		/* 82258FECh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82258FECh case    7:*/		return 0x82258FF0;
		  /* 82258FF0h */ case    8:  		/* addi R6, R11, -32472 */
		/* 82258FF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFF8128);
		/* 82258FF0h case    8:*/		return 0x82258FF4;
		  /* 82258FF4h */ case    9:  		/* addi R5, R10, -32504 */
		/* 82258FF4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFF8108);
		/* 82258FF4h case    9:*/		return 0x82258FF8;
		  /* 82258FF8h */ case   10:  		/* addi R4, R9, 27460 */
		/* 82258FF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82258FF8h case   10:*/		return 0x82258FFC;
		  /* 82258FFCh */ case   11:  		/* li R7, 181 */
		/* 82258FFCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xB5);
		/* 82258FFCh case   11:*/		return 0x82259000;
		  /* 82259000h */ case   12:  		/* li R3, 0 */
		/* 82259000h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259000h case   12:*/		return 0x82259004;
		  /* 82259004h */ case   13:  		/* bl -1053692 */
		/* 82259004h case   13:*/		regs.LR = 0x82259008; return 0x82157C08;
		/* 82259004h case   13:*/		return 0x82259008;
	}
	return 0x82259008;
} // Block from 82258FD0h-82259008h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82259008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259008);
		  /* 82259008h */ case    0:  		/* mr R4, R31 */
		/* 82259008h case    0:*/		regs.R4 = regs.R31;
		/* 82259008h case    0:*/		return 0x8225900C;
		  /* 8225900Ch */ case    1:  		/* mr R3, R30 */
		/* 8225900Ch case    1:*/		regs.R3 = regs.R30;
		/* 8225900Ch case    1:*/		return 0x82259010;
		  /* 82259010h */ case    2:  		/* bl -22568 */
		/* 82259010h case    2:*/		regs.LR = 0x82259014; return 0x822537E8;
		/* 82259010h case    2:*/		return 0x82259014;
		  /* 82259014h */ case    3:  		/* stw R29, <#[R30 + 948]> */
		/* 82259014h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x000003B4) );
		/* 82259014h case    3:*/		return 0x82259018;
		  /* 82259018h */ case    4:  		/* addi R1, R1, 112 */
		/* 82259018h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259018h case    4:*/		return 0x8225901C;
		  /* 8225901Ch */ case    5:  		/* b -1867120 */
		/* 8225901Ch case    5:*/		return 0x820912AC;
		/* 8225901Ch case    5:*/		return 0x82259020;
	}
	return 0x82259020;
} // Block from 82259008h-82259020h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259020h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259020);
		  /* 82259020h */ case    0:  		/* mfspr R12, LR */
		/* 82259020h case    0:*/		regs.R12 = regs.LR;
		/* 82259020h case    0:*/		return 0x82259024;
		  /* 82259024h */ case    1:  		/* bl -1867208 */
		/* 82259024h case    1:*/		regs.LR = 0x82259028; return 0x8209125C;
		/* 82259024h case    1:*/		return 0x82259028;
	}
	return 0x82259028;
} // Block from 82259020h-82259028h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259028h
// Function '?NewInst@IRNop@XGRAPHICS@@SAPAVIRInst@2@W4Op@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259028);
		  /* 82259028h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82259028h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82259028h case    0:*/		return 0x8225902C;
		  /* 8225902Ch */ case    1:  		/* lwz R11, <#[R4 + 948]> */
		/* 8225902Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x000003B4) );
		/* 8225902Ch case    1:*/		return 0x82259030;
		  /* 82259030h */ case    2:  		/* mr R29, R3 */
		/* 82259030h case    2:*/		regs.R29 = regs.R3;
		/* 82259030h case    2:*/		return 0x82259034;
		  /* 82259034h */ case    3:  		/* mr R31, R4 */
		/* 82259034h case    3:*/		regs.R31 = regs.R4;
		/* 82259034h case    3:*/		return 0x82259038;
		  /* 82259038h */ case    4:  		/* mr R30, R5 */
		/* 82259038h case    4:*/		regs.R30 = regs.R5;
		/* 82259038h case    4:*/		return 0x8225903C;
		  /* 8225903Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8225903Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225903Ch case    5:*/		return 0x82259040;
		  /* 82259040h */ case    6:  		/* bc 4, CR6_EQ, 40 */
		/* 82259040h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82259068;  }
		/* 82259040h case    6:*/		return 0x82259044;
		  /* 82259044h */ case    7:  		/* lis R11, -32251 */
		/* 82259044h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259044h case    7:*/		return 0x82259048;
		  /* 82259048h */ case    8:  		/* lis R10, -32251 */
		/* 82259048h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82259048h case    8:*/		return 0x8225904C;
		  /* 8225904Ch */ case    9:  		/* lis R9, -32253 */
		/* 8225904Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225904Ch case    9:*/		return 0x82259050;
		  /* 82259050h */ case   10:  		/* addi R6, R11, -32472 */
		/* 82259050h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFF8128);
		/* 82259050h case   10:*/		return 0x82259054;
		  /* 82259054h */ case   11:  		/* addi R5, R10, -32380 */
		/* 82259054h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFF8184);
		/* 82259054h case   11:*/		return 0x82259058;
		  /* 82259058h */ case   12:  		/* addi R4, R9, 27460 */
		/* 82259058h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82259058h case   12:*/		return 0x8225905C;
		  /* 8225905Ch */ case   13:  		/* li R7, 193 */
		/* 8225905Ch case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xC1);
		/* 8225905Ch case   13:*/		return 0x82259060;
		  /* 82259060h */ case   14:  		/* li R3, 0 */
		/* 82259060h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259060h case   14:*/		return 0x82259064;
		  /* 82259064h */ case   15:  		/* bl -1053788 */
		/* 82259064h case   15:*/		regs.LR = 0x82259068; return 0x82157C08;
		/* 82259064h case   15:*/		return 0x82259068;
	}
	return 0x82259068;
} // Block from 82259028h-82259068h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82259068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259068);
		  /* 82259068h */ case    0:  		/* mr R4, R31 */
		/* 82259068h case    0:*/		regs.R4 = regs.R31;
		/* 82259068h case    0:*/		return 0x8225906C;
		  /* 8225906Ch */ case    1:  		/* mr R3, R30 */
		/* 8225906Ch case    1:*/		regs.R3 = regs.R30;
		/* 8225906Ch case    1:*/		return 0x82259070;
		  /* 82259070h */ case    2:  		/* bl -22696 */
		/* 82259070h case    2:*/		regs.LR = 0x82259074; return 0x822537C8;
		/* 82259070h case    2:*/		return 0x82259074;
		  /* 82259074h */ case    3:  		/* stw R29, <#[R30 + 948]> */
		/* 82259074h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x000003B4) );
		/* 82259074h case    3:*/		return 0x82259078;
	}
	return 0x82259078;
} // Block from 82259068h-82259078h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82259078h
// Function '??0Dominator@XGRAPHICS@@QAA@PAVCFG@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259078);
		  /* 82259078h */ case    0:  		/* addi R1, R1, 112 */
		/* 82259078h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259078h case    0:*/		return 0x8225907C;
		  /* 8225907Ch */ case    1:  		/* b -1867216 */
		/* 8225907Ch case    1:*/		return 0x820912AC;
		/* 8225907Ch case    1:*/		return 0x82259080;
	}
	return 0x82259080;
} // Block from 82259078h-82259080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259080);
		  /* 82259080h */ case    0:  		/* mfspr R12, LR */
		/* 82259080h case    0:*/		regs.R12 = regs.LR;
		/* 82259080h case    0:*/		return 0x82259084;
		  /* 82259084h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259084h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259084h case    1:*/		return 0x82259088;
		  /* 82259088h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82259088h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259088h case    2:*/		return 0x8225908C;
		  /* 8225908Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225908Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225908Ch case    3:*/		return 0x82259090;
		  /* 82259090h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82259090h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82259090h case    4:*/		return 0x82259094;
		  /* 82259094h */ case    5:  		/* mr R31, R3 */
		/* 82259094h case    5:*/		regs.R31 = regs.R3;
		/* 82259094h case    5:*/		return 0x82259098;
		  /* 82259098h */ case    6:  		/* mr R3, R4 */
		/* 82259098h case    6:*/		regs.R3 = regs.R4;
		/* 82259098h case    6:*/		return 0x8225909C;
		  /* 8225909Ch */ case    7:  		/* mr R30, R4 */
		/* 8225909Ch case    7:*/		regs.R30 = regs.R4;
		/* 8225909Ch case    7:*/		return 0x822590A0;
		  /* 822590A0h */ case    8:  		/* lwz R4, <#[R31 + 136]> */
		/* 822590A0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000088) );
		/* 822590A0h case    8:*/		return 0x822590A4;
		  /* 822590A4h */ case    9:  		/* bl -22716 */
		/* 822590A4h case    9:*/		regs.LR = 0x822590A8; return 0x822537E8;
		/* 822590A4h case    9:*/		return 0x822590A8;
		  /* 822590A8h */ case   10:  		/* stw R30, <#[R31 + 136]> */
		/* 822590A8h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 822590A8h case   10:*/		return 0x822590AC;
		  /* 822590ACh */ case   11:  		/* stw R31, <#[R30 + 948]> */
		/* 822590ACh case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000003B4) );
		/* 822590ACh case   11:*/		return 0x822590B0;
		  /* 822590B0h */ case   12:  		/* addi R1, R1, 112 */
		/* 822590B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822590B0h case   12:*/		return 0x822590B4;
		  /* 822590B4h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 822590B4h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822590B4h case   13:*/		return 0x822590B8;
		  /* 822590B8h */ case   14:  		/* mtspr LR, R12 */
		/* 822590B8h case   14:*/		regs.LR = regs.R12;
		/* 822590B8h case   14:*/		return 0x822590BC;
		  /* 822590BCh */ case   15:  		/* ld R30, <#[R1 - 24]> */
		/* 822590BCh case   15:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822590BCh case   15:*/		return 0x822590C0;
		  /* 822590C0h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 822590C0h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822590C0h case   16:*/		return 0x822590C4;
		  /* 822590C4h */ case   17:  		/* bclr 20, CR0_LT */
		/* 822590C4h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822590C4h case   17:*/		return 0x822590C8;
	}
	return 0x822590C8;
} // Block from 82259080h-822590C8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822590C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822590C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822590C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822590C8);
		  /* 822590C8h */ case    0:  		/* mfspr R12, LR */
		/* 822590C8h case    0:*/		regs.R12 = regs.LR;
		/* 822590C8h case    0:*/		return 0x822590CC;
		  /* 822590CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822590CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822590CCh case    1:*/		return 0x822590D0;
		  /* 822590D0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822590D0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822590D0h case    2:*/		return 0x822590D4;
		  /* 822590D4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822590D4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822590D4h case    3:*/		return 0x822590D8;
		  /* 822590D8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822590D8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822590D8h case    4:*/		return 0x822590DC;
		  /* 822590DCh */ case    5:  		/* lwz R31, <#[R3 + 28]> */
		/* 822590DCh case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000001C) );
		/* 822590DCh case    5:*/		return 0x822590E0;
		  /* 822590E0h */ case    6:  		/* li R30, 0 */
		/* 822590E0h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822590E0h case    6:*/		return 0x822590E4;
		  /* 822590E4h */ case    7:  		/* b 60 */
		/* 822590E4h case    7:*/		return 0x82259120;
		/* 822590E4h case    7:*/		return 0x822590E8;
		  /* 822590E8h */ case    8:  		/* lwz R11, <#[R31 + 228]> */
		/* 822590E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822590E8h case    8:*/		return 0x822590EC;
		  /* 822590ECh */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822590ECh case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822590ECh case    9:*/		return 0x822590F0;
		  /* 822590F0h */ case   10:  		/* bc 12, CR0_EQ, 44 */
		/* 822590F0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225911C;  }
		/* 822590F0h case   10:*/		return 0x822590F4;
		  /* 822590F4h */ case   11:  		/* addi R30, R30, 1 */
		/* 822590F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822590F4h case   11:*/		return 0x822590F8;
		  /* 822590F8h */ case   12:  		/* cmpwi CR6, R30, 1 */
		/* 822590F8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000001);
		/* 822590F8h case   12:*/		return 0x822590FC;
		  /* 822590FCh */ case   13:  		/* bc 4, CR6_EQ, 32 */
		/* 822590FCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x8225911C;  }
		/* 822590FCh case   13:*/		return 0x82259100;
		  /* 82259100h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 82259100h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259100h case   14:*/		return 0x82259104;
		  /* 82259104h */ case   15:  		/* mr R3, R31 */
		/* 82259104h case   15:*/		regs.R3 = regs.R31;
		/* 82259104h case   15:*/		return 0x82259108;
		  /* 82259108h */ case   16:  		/* lwz R11, <#[R11 + 36]> */
		/* 82259108h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82259108h case   16:*/		return 0x8225910C;
		  /* 8225910Ch */ case   17:  		/* mtspr CTR, R11 */
		/* 8225910Ch case   17:*/		regs.CTR = regs.R11;
		/* 8225910Ch case   17:*/		return 0x82259110;
		  /* 82259110h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 82259110h case   18:*/		if ( 1 ) { regs.LR = 0x82259114; return (uint32)regs.CTR; }
		/* 82259110h case   18:*/		return 0x82259114;
		  /* 82259114h */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82259114h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82259114h case   19:*/		return 0x82259118;
		  /* 82259118h */ case   20:  		/* bc 12, CR0_EQ, 48 */
		/* 82259118h case   20:*/		if ( regs.CR[0].eq ) { return 0x82259148;  }
		/* 82259118h case   20:*/		return 0x8225911C;
	}
	return 0x8225911C;
} // Block from 822590C8h-8225911Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225911Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225911C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225911C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225911C);
		  /* 8225911Ch */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8225911Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8225911Ch case    0:*/		return 0x82259120;
	}
	return 0x82259120;
} // Block from 8225911Ch-82259120h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259120);
		  /* 82259120h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82259120h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82259120h case    0:*/		return 0x82259124;
		  /* 82259124h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82259124h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82259124h case    1:*/		return 0x82259128;
		  /* 82259128h */ case    2:  		/* bc 4, CR6_EQ, -64 */
		/* 82259128h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822590E8;  }
		/* 82259128h case    2:*/		return 0x8225912C;
		  /* 8225912Ch */ case    3:  		/* li R3, 1 */
		/* 8225912Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8225912Ch case    3:*/		return 0x82259130;
		  /* 82259130h */ case    4:  		/* addi R1, R1, 112 */
		/* 82259130h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259130h case    4:*/		return 0x82259134;
		  /* 82259134h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259134h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259134h case    5:*/		return 0x82259138;
		  /* 82259138h */ case    6:  		/* mtspr LR, R12 */
		/* 82259138h case    6:*/		regs.LR = regs.R12;
		/* 82259138h case    6:*/		return 0x8225913C;
		  /* 8225913Ch */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 8225913Ch case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225913Ch case    7:*/		return 0x82259140;
		  /* 82259140h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82259140h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259140h case    8:*/		return 0x82259144;
		  /* 82259144h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82259144h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259144h case    9:*/		return 0x82259148;
	}
	return 0x82259148;
} // Block from 82259120h-82259148h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82259148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259148);
		  /* 82259148h */ case    0:  		/* li R3, 0 */
		/* 82259148h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259148h case    0:*/		return 0x8225914C;
		  /* 8225914Ch */ case    1:  		/* b -28 */
		/* 8225914Ch case    1:*/		return 0x82259130;
		/* 8225914Ch case    1:*/		return 0x82259150;
	}
	return 0x82259150;
} // Block from 82259148h-82259150h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259150h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259150);
		  /* 82259150h */ case    0:  		/* mfspr R12, LR */
		/* 82259150h case    0:*/		regs.R12 = regs.LR;
		/* 82259150h case    0:*/		return 0x82259154;
		  /* 82259154h */ case    1:  		/* bl -1867520 */
		/* 82259154h case    1:*/		regs.LR = 0x82259158; return 0x82091254;
		/* 82259154h case    1:*/		return 0x82259158;
		  /* 82259158h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82259158h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82259158h case    2:*/		return 0x8225915C;
		  /* 8225915Ch */ case    3:  		/* mr R31, R3 */
		/* 8225915Ch case    3:*/		regs.R31 = regs.R3;
		/* 8225915Ch case    3:*/		return 0x82259160;
		  /* 82259160h */ case    4:  		/* stw R4, <#[R3 + 12]> */
		/* 82259160h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000000C) );
		/* 82259160h case    4:*/		return 0x82259164;
		  /* 82259164h */ case    5:  		/* lis R11, -32251 */
		/* 82259164h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259164h case    5:*/		return 0x82259168;
	}
	return 0x82259168;
} // Block from 82259150h-82259168h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259168h
// Function '??1Dominator@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259168);
		  /* 82259168h */ case    0:  		/* li R30, 0 */
		/* 82259168h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82259168h case    0:*/		return 0x8225916C;
		  /* 8225916Ch */ case    1:  		/* addi R11, R11, -32352 */
		/* 8225916Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF81A0);
		/* 8225916Ch case    1:*/		return 0x82259170;
		  /* 82259170h */ case    2:  		/* stw R30, <#[R3 + 4]> */
		/* 82259170h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 82259170h case    2:*/		return 0x82259174;
		  /* 82259174h */ case    3:  		/* addi R28, R3, 20 */
		/* 82259174h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R3,0x14);
		/* 82259174h case    3:*/		return 0x82259178;
		  /* 82259178h */ case    4:  		/* stw R11, <#[R3]> */
		/* 82259178h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82259178h case    4:*/		return 0x8225917C;
		  /* 8225917Ch */ case    5:  		/* stw R30, <#[R3 + 8]> */
		/* 8225917Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 8225917Ch case    5:*/		return 0x82259180;
		  /* 82259180h */ case    6:  		/* mr R3, R28 */
		/* 82259180h case    6:*/		regs.R3 = regs.R28;
		/* 82259180h case    6:*/		return 0x82259184;
		  /* 82259184h */ case    7:  		/* stw R30, <#[R31 + 16]> */
		/* 82259184h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 82259184h case    7:*/		return 0x82259188;
		  /* 82259188h */ case    8:  		/* bl -22880 */
		/* 82259188h case    8:*/		regs.LR = 0x8225918C; return 0x82253828;
		/* 82259188h case    8:*/		return 0x8225918C;
		  /* 8225918Ch */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225918Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225918Ch case    9:*/		return 0x82259190;
		  /* 82259190h */ case   10:  		/* li R9, 1024 */
		/* 82259190h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x400);
		/* 82259190h case   10:*/		return 0x82259194;
		  /* 82259194h */ case   11:  		/* li R8, -1 */
		/* 82259194h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82259194h case   11:*/		return 0x82259198;
		  /* 82259198h */ case   12:  		/* li R4, 20 */
		/* 82259198h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82259198h case   12:*/		return 0x8225919C;
		  /* 8225919Ch */ case   13:  		/* lwz R10, <#[R11 + 1388]> */
		/* 8225919Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000056C) );
		/* 8225919Ch case   13:*/		return 0x822591A0;
		  /* 822591A0h */ case   14:  		/* stw R10, <#[R31 + 48]> */
		/* 822591A0h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 822591A0h case   14:*/		return 0x822591A4;
		  /* 822591A4h */ case   15:  		/* lwz R10, <#[R11 + 1388]> */
		/* 822591A4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000056C) );
		/* 822591A4h case   15:*/		return 0x822591A8;
		  /* 822591A8h */ case   16:  		/* addi R10, R10, 1 */
		/* 822591A8h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822591A8h case   16:*/		return 0x822591AC;
		  /* 822591ACh */ case   17:  		/* stw R10, <#[R11 + 1388]> */
		/* 822591ACh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000056C) );
		/* 822591ACh case   17:*/		return 0x822591B0;
		  /* 822591B0h */ case   18:  		/* lwz R11, <#[R31 + 12]> */
		/* 822591B0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822591B0h case   18:*/		return 0x822591B4;
		  /* 822591B4h */ case   19:  		/* stw R30, <#[R31 + 52]> */
		/* 822591B4h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000034) );
		/* 822591B4h case   19:*/		return 0x822591B8;
		  /* 822591B8h */ case   20:  		/* stw R9, <#[R31 + 72]> */
		/* 822591B8h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000048) );
		/* 822591B8h case   20:*/		return 0x822591BC;
		  /* 822591BCh */ case   21:  		/* stw R9, <#[R31 + 76]> */
		/* 822591BCh case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000004C) );
		/* 822591BCh case   21:*/		return 0x822591C0;
		  /* 822591C0h */ case   22:  		/* stw R30, <#[R31 + 80]> */
		/* 822591C0h case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 822591C0h case   22:*/		return 0x822591C4;
		  /* 822591C4h */ case   23:  		/* stw R30, <#[R31 + 84]> */
		/* 822591C4h case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000054) );
		/* 822591C4h case   23:*/		return 0x822591C8;
		  /* 822591C8h */ case   24:  		/* stw R30, <#[R31 + 96]> */
		/* 822591C8h case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000060) );
		/* 822591C8h case   24:*/		return 0x822591CC;
		  /* 822591CCh */ case   25:  		/* stw R30, <#[R31 + 100]> */
		/* 822591CCh case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000064) );
		/* 822591CCh case   25:*/		return 0x822591D0;
		  /* 822591D0h */ case   26:  		/* stw R30, <#[R31 + 104]> */
		/* 822591D0h case   26:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000068) );
		/* 822591D0h case   26:*/		return 0x822591D4;
		  /* 822591D4h */ case   27:  		/* stw R30, <#[R31 + 108]> */
		/* 822591D4h case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000006C) );
		/* 822591D4h case   27:*/		return 0x822591D8;
		  /* 822591D8h */ case   28:  		/* stw R30, <#[R31 + 120]> */
		/* 822591D8h case   28:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000078) );
		/* 822591D8h case   28:*/		return 0x822591DC;
		  /* 822591DCh */ case   29:  		/* stb R30, <#[R31 + 124]> */
		/* 822591DCh case   29:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x0000007C) );
		/* 822591DCh case   29:*/		return 0x822591E0;
		  /* 822591E0h */ case   30:  		/* stw R8, <#[R31 + 128]> */
		/* 822591E0h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000080) );
		/* 822591E0h case   30:*/		return 0x822591E4;
		  /* 822591E4h */ case   31:  		/* stw R30, <#[R31 + 132]> */
		/* 822591E4h case   31:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000084) );
		/* 822591E4h case   31:*/		return 0x822591E8;
		  /* 822591E8h */ case   32:  		/* lwz R27, <#[R11 + 1452]> */
		/* 822591E8h case   32:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005AC) );
		/* 822591E8h case   32:*/		return 0x822591EC;
		  /* 822591ECh */ case   33:  		/* mr R3, R27 */
		/* 822591ECh case   33:*/		regs.R3 = regs.R27;
		/* 822591ECh case   33:*/		return 0x822591F0;
		  /* 822591F0h */ case   34:  		/* bl -249144 */
		/* 822591F0h case   34:*/		regs.LR = 0x822591F4; return 0x8221C4B8;
		/* 822591F0h case   34:*/		return 0x822591F4;
		  /* 822591F4h */ case   35:  		/* addic. R29, R3, 4 */
		/* 822591F4h case   35:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R3,0x4);
		/* 822591F4h case   35:*/		return 0x822591F8;
		  /* 822591F8h */ case   36:  		/* stw R27, <#[R3]> */
		/* 822591F8h case   36:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 822591F8h case   36:*/		return 0x822591FC;
		  /* 822591FCh */ case   37:  		/* bc 12, CR0_EQ, 24 */
		/* 822591FCh case   37:*/		if ( regs.CR[0].eq ) { return 0x82259214;  }
		/* 822591FCh case   37:*/		return 0x82259200;
		  /* 82259200h */ case   38:  		/* lwz R11, <#[R31 + 12]> */
		/* 82259200h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259200h case   38:*/		return 0x82259204;
		  /* 82259204h */ case   39:  		/* mr R3, R29 */
		/* 82259204h case   39:*/		regs.R3 = regs.R29;
		/* 82259204h case   39:*/		return 0x82259208;
		  /* 82259208h */ case   40:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82259208h case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82259208h case   40:*/		return 0x8225920C;
		  /* 8225920Ch */ case   41:  		/* bl -144556 */
		/* 8225920Ch case   41:*/		regs.LR = 0x82259210; return 0x82235D60;
		/* 8225920Ch case   41:*/		return 0x82259210;
		  /* 82259210h */ case   42:  		/* b 8 */
		/* 82259210h case   42:*/		return 0x82259218;
		/* 82259210h case   42:*/		return 0x82259214;
	}
	return 0x82259214;
} // Block from 82259168h-82259214h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82259214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259214);
		  /* 82259214h */ case    0:  		/* mr R29, R30 */
		/* 82259214h case    0:*/		regs.R29 = regs.R30;
		/* 82259214h case    0:*/		return 0x82259218;
	}
	return 0x82259218;
} // Block from 82259214h-82259218h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259218);
		  /* 82259218h */ case    0:  		/* stw R29, <#[R31 + 44]> */
		/* 82259218h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000002C) );
		/* 82259218h case    0:*/		return 0x8225921C;
		  /* 8225921Ch */ case    1:  		/* li R4, 20 */
		/* 8225921Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8225921Ch case    1:*/		return 0x82259220;
		  /* 82259220h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82259220h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259220h case    2:*/		return 0x82259224;
		  /* 82259224h */ case    3:  		/* lwz R27, <#[R11 + 1452]> */
		/* 82259224h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005AC) );
		/* 82259224h case    3:*/		return 0x82259228;
		  /* 82259228h */ case    4:  		/* mr R3, R27 */
		/* 82259228h case    4:*/		regs.R3 = regs.R27;
		/* 82259228h case    4:*/		return 0x8225922C;
		  /* 8225922Ch */ case    5:  		/* bl -249204 */
		/* 8225922Ch case    5:*/		regs.LR = 0x82259230; return 0x8221C4B8;
		/* 8225922Ch case    5:*/		return 0x82259230;
		  /* 82259230h */ case    6:  		/* addic. R29, R3, 4 */
		/* 82259230h case    6:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R3,0x4);
		/* 82259230h case    6:*/		return 0x82259234;
		  /* 82259234h */ case    7:  		/* stw R27, <#[R3]> */
		/* 82259234h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82259234h case    7:*/		return 0x82259238;
		  /* 82259238h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 82259238h case    8:*/		if ( regs.CR[0].eq ) { return 0x82259250;  }
		/* 82259238h case    8:*/		return 0x8225923C;
		  /* 8225923Ch */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225923Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225923Ch case    9:*/		return 0x82259240;
		  /* 82259240h */ case   10:  		/* mr R3, R29 */
		/* 82259240h case   10:*/		regs.R3 = regs.R29;
		/* 82259240h case   10:*/		return 0x82259244;
		  /* 82259244h */ case   11:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82259244h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82259244h case   11:*/		return 0x82259248;
		  /* 82259248h */ case   12:  		/* bl -144616 */
		/* 82259248h case   12:*/		regs.LR = 0x8225924C; return 0x82235D60;
		/* 82259248h case   12:*/		return 0x8225924C;
		  /* 8225924Ch */ case   13:  		/* b 8 */
		/* 8225924Ch case   13:*/		return 0x82259254;
		/* 8225924Ch case   13:*/		return 0x82259250;
	}
	return 0x82259250;
} // Block from 82259218h-82259250h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82259250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259250);
		  /* 82259250h */ case    0:  		/* mr R29, R30 */
		/* 82259250h case    0:*/		regs.R29 = regs.R30;
		/* 82259250h case    0:*/		return 0x82259254;
	}
	return 0x82259254;
} // Block from 82259250h-82259254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259254);
		  /* 82259254h */ case    0:  		/* stw R29, <#[R31 + 92]> */
		/* 82259254h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000005C) );
		/* 82259254h case    0:*/		return 0x82259258;
		  /* 82259258h */ case    1:  		/* li R4, 20 */
		/* 82259258h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82259258h case    1:*/		return 0x8225925C;
		  /* 8225925Ch */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225925Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225925Ch case    2:*/		return 0x82259260;
		  /* 82259260h */ case    3:  		/* lwz R27, <#[R11 + 1452]> */
		/* 82259260h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005AC) );
		/* 82259260h case    3:*/		return 0x82259264;
		  /* 82259264h */ case    4:  		/* mr R3, R27 */
		/* 82259264h case    4:*/		regs.R3 = regs.R27;
		/* 82259264h case    4:*/		return 0x82259268;
		  /* 82259268h */ case    5:  		/* bl -249264 */
		/* 82259268h case    5:*/		regs.LR = 0x8225926C; return 0x8221C4B8;
		/* 82259268h case    5:*/		return 0x8225926C;
		  /* 8225926Ch */ case    6:  		/* addic. R29, R3, 4 */
		/* 8225926Ch case    6:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R3,0x4);
		/* 8225926Ch case    6:*/		return 0x82259270;
		  /* 82259270h */ case    7:  		/* stw R27, <#[R3]> */
		/* 82259270h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82259270h case    7:*/		return 0x82259274;
		  /* 82259274h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 82259274h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225928C;  }
		/* 82259274h case    8:*/		return 0x82259278;
		  /* 82259278h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 82259278h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259278h case    9:*/		return 0x8225927C;
		  /* 8225927Ch */ case   10:  		/* mr R3, R29 */
		/* 8225927Ch case   10:*/		regs.R3 = regs.R29;
		/* 8225927Ch case   10:*/		return 0x82259280;
	}
	return 0x82259280;
} // Block from 82259254h-82259280h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82259280h
// Function '?CalcDomFrontiers@Dominator@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259280);
		  /* 82259280h */ case    0:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82259280h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82259280h case    0:*/		return 0x82259284;
		  /* 82259284h */ case    1:  		/* bl -144676 */
		/* 82259284h case    1:*/		regs.LR = 0x82259288; return 0x82235D60;
		/* 82259284h case    1:*/		return 0x82259288;
		  /* 82259288h */ case    2:  		/* b 8 */
		/* 82259288h case    2:*/		return 0x82259290;
		/* 82259288h case    2:*/		return 0x8225928C;
	}
	return 0x8225928C;
} // Block from 82259280h-8225928Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225928Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225928C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225928C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225928C);
		  /* 8225928Ch */ case    0:  		/* mr R29, R30 */
		/* 8225928Ch case    0:*/		regs.R29 = regs.R30;
		/* 8225928Ch case    0:*/		return 0x82259290;
	}
	return 0x82259290;
} // Block from 8225928Ch-82259290h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259290);
		  /* 82259290h */ case    0:  		/* stw R29, <#[R31 + 88]> */
		/* 82259290h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000058) );
		/* 82259290h case    0:*/		return 0x82259294;
		  /* 82259294h */ case    1:  		/* li R4, 20 */
		/* 82259294h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82259294h case    1:*/		return 0x82259298;
		  /* 82259298h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82259298h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259298h case    2:*/		return 0x8225929C;
		  /* 8225929Ch */ case    3:  		/* lwz R27, <#[R11 + 1452]> */
		/* 8225929Ch case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225929Ch case    3:*/		return 0x822592A0;
		  /* 822592A0h */ case    4:  		/* mr R3, R27 */
		/* 822592A0h case    4:*/		regs.R3 = regs.R27;
		/* 822592A0h case    4:*/		return 0x822592A4;
		  /* 822592A4h */ case    5:  		/* bl -249324 */
		/* 822592A4h case    5:*/		regs.LR = 0x822592A8; return 0x8221C4B8;
		/* 822592A4h case    5:*/		return 0x822592A8;
		  /* 822592A8h */ case    6:  		/* addic. R29, R3, 4 */
		/* 822592A8h case    6:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R3,0x4);
		/* 822592A8h case    6:*/		return 0x822592AC;
		  /* 822592ACh */ case    7:  		/* stw R27, <#[R3]> */
		/* 822592ACh case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 822592ACh case    7:*/		return 0x822592B0;
		  /* 822592B0h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 822592B0h case    8:*/		if ( regs.CR[0].eq ) { return 0x822592C8;  }
		/* 822592B0h case    8:*/		return 0x822592B4;
		  /* 822592B4h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 822592B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822592B4h case    9:*/		return 0x822592B8;
		  /* 822592B8h */ case   10:  		/* mr R3, R29 */
		/* 822592B8h case   10:*/		regs.R3 = regs.R29;
		/* 822592B8h case   10:*/		return 0x822592BC;
		  /* 822592BCh */ case   11:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822592BCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822592BCh case   11:*/		return 0x822592C0;
		  /* 822592C0h */ case   12:  		/* bl -144736 */
		/* 822592C0h case   12:*/		regs.LR = 0x822592C4; return 0x82235D60;
		/* 822592C0h case   12:*/		return 0x822592C4;
		  /* 822592C4h */ case   13:  		/* b 8 */
		/* 822592C4h case   13:*/		return 0x822592CC;
		/* 822592C4h case   13:*/		return 0x822592C8;
	}
	return 0x822592C8;
} // Block from 82259290h-822592C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822592C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822592C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822592C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822592C8);
		  /* 822592C8h */ case    0:  		/* mr R29, R30 */
		/* 822592C8h case    0:*/		regs.R29 = regs.R30;
		/* 822592C8h case    0:*/		return 0x822592CC;
	}
	return 0x822592CC;
} // Block from 822592C8h-822592CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822592CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822592CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822592CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822592CC);
		  /* 822592CCh */ case    0:  		/* stw R29, <#[R31 + 56]> */
		/* 822592CCh case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000038) );
		/* 822592CCh case    0:*/		return 0x822592D0;
		  /* 822592D0h */ case    1:  		/* li R4, 20 */
		/* 822592D0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 822592D0h case    1:*/		return 0x822592D4;
		  /* 822592D4h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 822592D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822592D4h case    2:*/		return 0x822592D8;
		  /* 822592D8h */ case    3:  		/* lwz R27, <#[R11 + 1452]> */
		/* 822592D8h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005AC) );
		/* 822592D8h case    3:*/		return 0x822592DC;
		  /* 822592DCh */ case    4:  		/* mr R3, R27 */
		/* 822592DCh case    4:*/		regs.R3 = regs.R27;
		/* 822592DCh case    4:*/		return 0x822592E0;
		  /* 822592E0h */ case    5:  		/* bl -249384 */
		/* 822592E0h case    5:*/		regs.LR = 0x822592E4; return 0x8221C4B8;
		/* 822592E0h case    5:*/		return 0x822592E4;
		  /* 822592E4h */ case    6:  		/* addic. R29, R3, 4 */
		/* 822592E4h case    6:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R3,0x4);
		/* 822592E4h case    6:*/		return 0x822592E8;
		  /* 822592E8h */ case    7:  		/* stw R27, <#[R3]> */
		/* 822592E8h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 822592E8h case    7:*/		return 0x822592EC;
		  /* 822592ECh */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 822592ECh case    8:*/		if ( regs.CR[0].eq ) { return 0x82259304;  }
		/* 822592ECh case    8:*/		return 0x822592F0;
		  /* 822592F0h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 822592F0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822592F0h case    9:*/		return 0x822592F4;
		  /* 822592F4h */ case   10:  		/* mr R3, R29 */
		/* 822592F4h case   10:*/		regs.R3 = regs.R29;
		/* 822592F4h case   10:*/		return 0x822592F8;
		  /* 822592F8h */ case   11:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822592F8h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822592F8h case   11:*/		return 0x822592FC;
		  /* 822592FCh */ case   12:  		/* bl -144796 */
		/* 822592FCh case   12:*/		regs.LR = 0x82259300; return 0x82235D60;
		/* 822592FCh case   12:*/		return 0x82259300;
		  /* 82259300h */ case   13:  		/* b 8 */
		/* 82259300h case   13:*/		return 0x82259308;
		/* 82259300h case   13:*/		return 0x82259304;
	}
	return 0x82259304;
} // Block from 822592CCh-82259304h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82259304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259304);
		  /* 82259304h */ case    0:  		/* mr R29, R30 */
		/* 82259304h case    0:*/		regs.R29 = regs.R30;
		/* 82259304h case    0:*/		return 0x82259308;
	}
	return 0x82259308;
} // Block from 82259304h-82259308h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259308);
		  /* 82259308h */ case    0:  		/* stw R29, <#[R31 + 60]> */
		/* 82259308h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000003C) );
		/* 82259308h case    0:*/		return 0x8225930C;
		  /* 8225930Ch */ case    1:  		/* li R4, 964 */
		/* 8225930Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225930Ch case    1:*/		return 0x82259310;
		  /* 82259310h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82259310h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259310h case    2:*/		return 0x82259314;
		  /* 82259314h */ case    3:  		/* lwz R29, <#[R11 + 1452]> */
		/* 82259314h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005AC) );
		/* 82259314h case    3:*/		return 0x82259318;
		  /* 82259318h */ case    4:  		/* mr R3, R29 */
		/* 82259318h case    4:*/		regs.R3 = regs.R29;
		/* 82259318h case    4:*/		return 0x8225931C;
		  /* 8225931Ch */ case    5:  		/* bl -249444 */
		/* 8225931Ch case    5:*/		regs.LR = 0x82259320; return 0x8221C4B8;
		/* 8225931Ch case    5:*/		return 0x82259320;
		  /* 82259320h */ case    6:  		/* mr R11, R3 */
		/* 82259320h case    6:*/		regs.R11 = regs.R3;
		/* 82259320h case    6:*/		return 0x82259324;
		  /* 82259324h */ case    7:  		/* addic. R3, R3, 4 */
		/* 82259324h case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82259324h case    7:*/		return 0x82259328;
		  /* 82259328h */ case    8:  		/* stw R29, <#[R11]> */
		/* 82259328h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82259328h case    8:*/		return 0x8225932C;
		  /* 8225932Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8225932Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8225933C;  }
		/* 8225932Ch case    9:*/		return 0x82259330;
		  /* 82259330h */ case   10:  		/* lwz R4, <#[R31 + 12]> */
		/* 82259330h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259330h case   10:*/		return 0x82259334;
		  /* 82259334h */ case   11:  		/* bl -8388 */
		/* 82259334h case   11:*/		regs.LR = 0x82259338; return 0x82257270;
		/* 82259334h case   11:*/		return 0x82259338;
		  /* 82259338h */ case   12:  		/* b 8 */
		/* 82259338h case   12:*/		return 0x82259340;
		/* 82259338h case   12:*/		return 0x8225933C;
	}
	return 0x8225933C;
} // Block from 82259308h-8225933Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225933Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225933C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225933C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225933C);
		  /* 8225933Ch */ case    0:  		/* mr R3, R30 */
		/* 8225933Ch case    0:*/		regs.R3 = regs.R30;
		/* 8225933Ch case    0:*/		return 0x82259340;
	}
	return 0x82259340;
} // Block from 8225933Ch-82259340h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259340);
		  /* 82259340h */ case    0:  		/* stw R3, <#[R31 + 112]> */
		/* 82259340h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000070) );
		/* 82259340h case    0:*/		return 0x82259344;
		  /* 82259344h */ case    1:  		/* li R4, 964 */
		/* 82259344h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82259344h case    1:*/		return 0x82259348;
		  /* 82259348h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82259348h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259348h case    2:*/		return 0x8225934C;
		  /* 8225934Ch */ case    3:  		/* lwz R29, <#[R11 + 1452]> */
		/* 8225934Ch case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225934Ch case    3:*/		return 0x82259350;
		  /* 82259350h */ case    4:  		/* mr R3, R29 */
		/* 82259350h case    4:*/		regs.R3 = regs.R29;
		/* 82259350h case    4:*/		return 0x82259354;
		  /* 82259354h */ case    5:  		/* bl -249500 */
		/* 82259354h case    5:*/		regs.LR = 0x82259358; return 0x8221C4B8;
		/* 82259354h case    5:*/		return 0x82259358;
		  /* 82259358h */ case    6:  		/* mr R11, R3 */
		/* 82259358h case    6:*/		regs.R11 = regs.R3;
		/* 82259358h case    6:*/		return 0x8225935C;
		  /* 8225935Ch */ case    7:  		/* addic. R3, R3, 4 */
		/* 8225935Ch case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225935Ch case    7:*/		return 0x82259360;
		  /* 82259360h */ case    8:  		/* stw R29, <#[R11]> */
		/* 82259360h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82259360h case    8:*/		return 0x82259364;
		  /* 82259364h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 82259364h case    9:*/		if ( regs.CR[0].eq ) { return 0x82259374;  }
		/* 82259364h case    9:*/		return 0x82259368;
		  /* 82259368h */ case   10:  		/* lwz R4, <#[R31 + 12]> */
		/* 82259368h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82259368h case   10:*/		return 0x8225936C;
		  /* 8225936Ch */ case   11:  		/* bl -8356 */
		/* 8225936Ch case   11:*/		regs.LR = 0x82259370; return 0x822572C8;
		/* 8225936Ch case   11:*/		return 0x82259370;
		  /* 82259370h */ case   12:  		/* b 8 */
		/* 82259370h case   12:*/		return 0x82259378;
		/* 82259370h case   12:*/		return 0x82259374;
	}
	return 0x82259374;
} // Block from 82259340h-82259374h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82259374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259374);
		  /* 82259374h */ case    0:  		/* mr R3, R30 */
		/* 82259374h case    0:*/		regs.R3 = regs.R30;
		/* 82259374h case    0:*/		return 0x82259378;
	}
	return 0x82259378;
} // Block from 82259374h-82259378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259378);
		  /* 82259378h */ case    0:  		/* stw R3, <#[R31 + 116]> */
		/* 82259378h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000074) );
		/* 82259378h case    0:*/		return 0x8225937C;
		  /* 8225937Ch */ case    1:  		/* mr R3, R28 */
		/* 8225937Ch case    1:*/		regs.R3 = regs.R28;
		/* 8225937Ch case    1:*/		return 0x82259380;
		  /* 82259380h */ case    2:  		/* lwz R4, <#[R31 + 112]> */
		/* 82259380h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000070) );
		/* 82259380h case    2:*/		return 0x82259384;
		  /* 82259384h */ case    3:  		/* bl -23252 */
		/* 82259384h case    3:*/		regs.LR = 0x82259388; return 0x822538B0;
		/* 82259384h case    3:*/		return 0x82259388;
		  /* 82259388h */ case    4:  		/* mr R3, R28 */
		/* 82259388h case    4:*/		regs.R3 = regs.R28;
		/* 82259388h case    4:*/		return 0x8225938C;
		  /* 8225938Ch */ case    5:  		/* lwz R4, <#[R31 + 116]> */
		/* 8225938Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8225938Ch case    5:*/		return 0x82259390;
		  /* 82259390h */ case    6:  		/* bl -23304 */
		/* 82259390h case    6:*/		regs.LR = 0x82259394; return 0x82253888;
		/* 82259390h case    6:*/		return 0x82259394;
		  /* 82259394h */ case    7:  		/* lwz R11, <#[R31 + 112]> */
		/* 82259394h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 82259394h case    7:*/		return 0x82259398;
		  /* 82259398h */ case    8:  		/* mr R3, R31 */
		/* 82259398h case    8:*/		regs.R3 = regs.R31;
		/* 82259398h case    8:*/		return 0x8225939C;
		  /* 8225939Ch */ case    9:  		/* stw R31, <#[R11 + 948]> */
		/* 8225939Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x000003B4) );
		/* 8225939Ch case    9:*/		return 0x822593A0;
		  /* 822593A0h */ case   10:  		/* lwz R11, <#[R31 + 116]> */
		/* 822593A0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 822593A0h case   10:*/		return 0x822593A4;
		  /* 822593A4h */ case   11:  		/* stw R31, <#[R11 + 948]> */
		/* 822593A4h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x000003B4) );
		/* 822593A4h case   11:*/		return 0x822593A8;
		  /* 822593A8h */ case   12:  		/* addi R1, R1, 128 */
		/* 822593A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822593A8h case   12:*/		return 0x822593AC;
		  /* 822593ACh */ case   13:  		/* b -1868040 */
		/* 822593ACh case   13:*/		return 0x820912A4;
		/* 822593ACh case   13:*/		return 0x822593B0;
	}
	return 0x822593B0;
} // Block from 82259378h-822593B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822593B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822593B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822593B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822593B0);
		  /* 822593B0h */ case    0:  		/* lis R11, -32251 */
		/* 822593B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822593B0h case    0:*/		return 0x822593B4;
		  /* 822593B4h */ case    1:  		/* addi R3, R11, -32304 */
		/* 822593B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF81D0);
		/* 822593B4h case    1:*/		return 0x822593B8;
		  /* 822593B8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822593B8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822593B8h case    2:*/		return 0x822593BC;
	}
	return 0x822593BC;
} // Block from 822593B0h-822593BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822593BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822593BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822593BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822593BC);
		  /* 822593BCh */ case    0:  		/* nop */
		/* 822593BCh case    0:*/		cpu::op::nop();
		/* 822593BCh case    0:*/		return 0x822593C0;
	}
	return 0x822593C0;
} // Block from 822593BCh-822593C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822593C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822593C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822593C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822593C0);
		  /* 822593C0h */ case    0:  		/* lwz R10, <#[R3 + 60]> */
		/* 822593C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000003C) );
		/* 822593C0h case    0:*/		return 0x822593C4;
		  /* 822593C4h */ case    1:  		/* li R3, 1 */
		/* 822593C4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822593C4h case    1:*/		return 0x822593C8;
		  /* 822593C8h */ case    2:  		/* li R8, 0 */
		/* 822593C8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822593C8h case    2:*/		return 0x822593CC;
		  /* 822593CCh */ case    3:  		/* li R11, 0 */
		/* 822593CCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822593CCh case    3:*/		return 0x822593D0;
		  /* 822593D0h */ case    4:  		/* li R7, 1 */
		/* 822593D0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 822593D0h case    4:*/		return 0x822593D4;
		  /* 822593D4h */ case    5:  		/* lwz R6, <#[R10 + 4]> */
		/* 822593D4h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 822593D4h case    5:*/		return 0x822593D8;
		  /* 822593D8h */ case    6:  		/* cmplw CR6, R7, R6 */
		/* 822593D8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 822593D8h case    6:*/		return 0x822593DC;
		  /* 822593DCh */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 822593DCh case    7:*/		if ( !regs.CR[6].gt ) { return 0x822593E8;  }
		/* 822593DCh case    7:*/		return 0x822593E0;
		  /* 822593E0h */ case    8:  		/* li R9, 0 */
		/* 822593E0h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822593E0h case    8:*/		return 0x822593E4;
		  /* 822593E4h */ case    9:  		/* b 16 */
		/* 822593E4h case    9:*/		return 0x822593F4;
		/* 822593E4h case    9:*/		return 0x822593E8;
	}
	return 0x822593E8;
} // Block from 822593C0h-822593E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822593E8h
// Function '?Compress@Dominator@XGRAPHICS@@AAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822593E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822593E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822593E8);
		  /* 822593E8h */ case    0:  		/* lwz R8, <#[R10 + 8]> */
		/* 822593E8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 822593E8h case    0:*/		return 0x822593EC;
		  /* 822593ECh */ case    1:  		/* li R9, 1 */
		/* 822593ECh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822593ECh case    1:*/		return 0x822593F0;
		  /* 822593F0h */ case    2:  		/* lwzx R8, <#[R8 + R11]> */
		/* 822593F0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 822593F0h case    2:*/		return 0x822593F4;
	}
	return 0x822593F4;
} // Block from 822593E8h-822593F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822593F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822593F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822593F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822593F4);
		  /* 822593F4h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 822593F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 822593F4h case    0:*/		return 0x822593F8;
		  /* 822593F8h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 822593F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82259414;  }
		/* 822593F8h case    1:*/		return 0x822593FC;
		  /* 822593FCh */ case    2:  		/* cmplw CR6, R4, R8 */
		/* 822593FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 822593FCh case    2:*/		return 0x82259400;
		  /* 82259400h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82259400h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82259400h case    3:*/		return 0x82259404;
	}
	return 0x82259404;
} // Block from 822593F4h-82259404h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82259404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259404);
		  /* 82259404h */ case    0:  		/* addi R3, R3, 1 */
		/* 82259404h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82259404h case    0:*/		return 0x82259408;
		  /* 82259408h */ case    1:  		/* addi R7, R7, 1 */
		/* 82259408h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82259408h case    1:*/		return 0x8225940C;
		  /* 8225940Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8225940Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225940Ch case    2:*/		return 0x82259410;
		  /* 82259410h */ case    3:  		/* b -56 */
		/* 82259410h case    3:*/		return 0x822593D8;
		/* 82259410h case    3:*/		return 0x82259414;
	}
	return 0x82259414;
} // Block from 82259404h-82259414h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82259414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259414);
		  /* 82259414h */ case    0:  		/* li R3, -1 */
		/* 82259414h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82259414h case    0:*/		return 0x82259418;
		  /* 82259418h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82259418h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259418h case    1:*/		return 0x8225941C;
	}
	return 0x8225941C;
} // Block from 82259414h-8225941Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225941Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225941C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225941C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225941C);
		  /* 8225941Ch */ case    0:  		/* nop */
		/* 8225941Ch case    0:*/		cpu::op::nop();
		/* 8225941Ch case    0:*/		return 0x82259420;
	}
	return 0x82259420;
} // Block from 8225941Ch-82259420h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259420h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259420);
		  /* 82259420h */ case    0:  		/* lwz R11, <#[R3 + 56]> */
		/* 82259420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82259420h case    0:*/		return 0x82259424;
		  /* 82259424h */ case    1:  		/* li R3, 0 */
		/* 82259424h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259424h case    1:*/		return 0x82259428;
		  /* 82259428h */ case    2:  		/* li R10, 0 */
		/* 82259428h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82259428h case    2:*/		return 0x8225942C;
		  /* 8225942Ch */ case    3:  		/* li R8, 1 */
		/* 8225942Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8225942Ch case    3:*/		return 0x82259430;
		  /* 82259430h */ case    4:  		/* lwz R7, <#[R11 + 4]> */
		/* 82259430h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82259430h case    4:*/		return 0x82259434;
		  /* 82259434h */ case    5:  		/* cmplw CR6, R8, R7 */
		/* 82259434h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82259434h case    5:*/		return 0x82259438;
		  /* 82259438h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 82259438h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82259444;  }
		/* 82259438h case    6:*/		return 0x8225943C;
		  /* 8225943Ch */ case    7:  		/* li R9, 0 */
		/* 8225943Ch case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225943Ch case    7:*/		return 0x82259440;
		  /* 82259440h */ case    8:  		/* b 16 */
		/* 82259440h case    8:*/		return 0x82259450;
		/* 82259440h case    8:*/		return 0x82259444;
	}
	return 0x82259444;
} // Block from 82259420h-82259444h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82259444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259444);
		  /* 82259444h */ case    0:  		/* lwz R6, <#[R11 + 8]> */
		/* 82259444h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 82259444h case    0:*/		return 0x82259448;
		  /* 82259448h */ case    1:  		/* li R9, 1 */
		/* 82259448h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82259448h case    1:*/		return 0x8225944C;
		  /* 8225944Ch */ case    2:  		/* lwzx R3, <#[R6 + R10]> */
		/* 8225944Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 8225944Ch case    2:*/		return 0x82259450;
	}
	return 0x82259450;
} // Block from 82259444h-82259450h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259450);
		  /* 82259450h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82259450h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82259450h case    0:*/		return 0x82259454;
		  /* 82259454h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82259454h case    1:*/		if ( regs.CR[0].eq ) { return 0x82259470;  }
		/* 82259454h case    1:*/		return 0x82259458;
		  /* 82259458h */ case    2:  		/* lwz R9, <#[R3 + 128]> */
		/* 82259458h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000080) );
		/* 82259458h case    2:*/		return 0x8225945C;
		  /* 8225945Ch */ case    3:  		/* cmpw CR6, R9, R4 */
		/* 8225945Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R4);
		/* 8225945Ch case    3:*/		return 0x82259460;
		  /* 82259460h */ case    4:  		/* bclr 4, CR6_EQ */
		/* 82259460h case    4:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82259460h case    4:*/		return 0x82259464;
	}
	return 0x82259464;
} // Block from 82259450h-82259464h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82259464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259464);
		  /* 82259464h */ case    0:  		/* addi R8, R8, 1 */
		/* 82259464h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82259464h case    0:*/		return 0x82259468;
		  /* 82259468h */ case    1:  		/* addi R10, R10, 4 */
		/* 82259468h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82259468h case    1:*/		return 0x8225946C;
		  /* 8225946Ch */ case    2:  		/* b -56 */
		/* 8225946Ch case    2:*/		return 0x82259434;
		/* 8225946Ch case    2:*/		return 0x82259470;
	}
	return 0x82259470;
} // Block from 82259464h-82259470h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259470);
		  /* 82259470h */ case    0:  		/* li R3, 0 */
		/* 82259470h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259470h case    0:*/		return 0x82259474;
		  /* 82259474h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82259474h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259474h case    1:*/		return 0x82259478;
	}
	return 0x82259478;
} // Block from 82259470h-82259478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259478h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259478);
		  /* 82259478h */ case    0:  		/* lwz R11, <#[R3 + 56]> */
		/* 82259478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82259478h case    0:*/		return 0x8225947C;
		  /* 8225947Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225947Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225947Ch case    1:*/		return 0x82259480;
		  /* 82259480h */ case    2:  		/* subfic R11, R11, 1 */
		/* 82259480h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82259480h case    2:*/		return 0x82259484;
		  /* 82259484h */ case    3:  		/* subfe R11, R11, R11 */
		/* 82259484h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82259484h case    3:*/		return 0x82259488;
		  /* 82259488h */ case    4:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82259488h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82259488h case    4:*/		return 0x8225948C;
		  /* 8225948Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8225948Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225948Ch case    5:*/		return 0x82259490;
	}
	return 0x82259490;
} // Block from 82259478h-82259490h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259490h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259490);
		  /* 82259490h */ case    0:  		/* lwz R11, <#[R3 + 60]> */
		/* 82259490h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 82259490h case    0:*/		return 0x82259494;
		  /* 82259494h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82259494h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82259494h case    1:*/		return 0x82259498;
		  /* 82259498h */ case    2:  		/* subfic R11, R11, 1 */
		/* 82259498h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82259498h case    2:*/		return 0x8225949C;
		  /* 8225949Ch */ case    3:  		/* subfe R11, R11, R11 */
		/* 8225949Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8225949Ch case    3:*/		return 0x822594A0;
		  /* 822594A0h */ case    4:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 822594A0h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 822594A0h case    4:*/		return 0x822594A4;
		  /* 822594A4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822594A4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822594A4h case    5:*/		return 0x822594A8;
	}
	return 0x822594A8;
} // Block from 82259490h-822594A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822594A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594A8);
		  /* 822594A8h */ case    0:  		/* lwz R11, <#[R3 + 56]> */
		/* 822594A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 822594A8h case    0:*/		return 0x822594AC;
		  /* 822594ACh */ case    1:  		/* lwz R3, <#[R11 + 4]> */
		/* 822594ACh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 822594ACh case    1:*/		return 0x822594B0;
		  /* 822594B0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822594B0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822594B0h case    2:*/		return 0x822594B4;
	}
	return 0x822594B4;
} // Block from 822594A8h-822594B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822594B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594B4);
		  /* 822594B4h */ case    0:  		/* nop */
		/* 822594B4h case    0:*/		cpu::op::nop();
		/* 822594B4h case    0:*/		return 0x822594B8;
	}
	return 0x822594B8;
} // Block from 822594B4h-822594B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822594B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594B8);
		  /* 822594B8h */ case    0:  		/* lwz R11, <#[R3 + 60]> */
		/* 822594B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000003C) );
		/* 822594B8h case    0:*/		return 0x822594BC;
		  /* 822594BCh */ case    1:  		/* lwz R3, <#[R11 + 4]> */
		/* 822594BCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 822594BCh case    1:*/		return 0x822594C0;
		  /* 822594C0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822594C0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822594C0h case    2:*/		return 0x822594C4;
	}
	return 0x822594C4;
} // Block from 822594B8h-822594C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822594C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594C4);
		  /* 822594C4h */ case    0:  		/* nop */
		/* 822594C4h case    0:*/		cpu::op::nop();
		/* 822594C4h case    0:*/		return 0x822594C8;
	}
	return 0x822594C8;
} // Block from 822594C4h-822594C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822594C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594C8);
		  /* 822594C8h */ case    0:  		/* lwz R11, <#[R3 + 56]> */
		/* 822594C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 822594C8h case    0:*/		return 0x822594CC;
		  /* 822594CCh */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 822594CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822594CCh case    1:*/		return 0x822594D0;
		  /* 822594D0h */ case    2:  		/* addic R10, R11, -1 */
		/* 822594D0h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 822594D0h case    2:*/		return 0x822594D4;
		  /* 822594D4h */ case    3:  		/* subfe R3, R10, R11 */
		/* 822594D4h case    3:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822594D4h case    3:*/		return 0x822594D8;
		  /* 822594D8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822594D8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822594D8h case    4:*/		return 0x822594DC;
	}
	return 0x822594DC;
} // Block from 822594C8h-822594DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822594DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594DC);
		  /* 822594DCh */ case    0:  		/* nop */
		/* 822594DCh case    0:*/		cpu::op::nop();
		/* 822594DCh case    0:*/		return 0x822594E0;
	}
	return 0x822594E0;
} // Block from 822594DCh-822594E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822594E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594E0);
		  /* 822594E0h */ case    0:  		/* lwz R11, <#[R3 + 88]> */
		/* 822594E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000058) );
		/* 822594E0h case    0:*/		return 0x822594E4;
		  /* 822594E4h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 822594E4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822594E4h case    1:*/		return 0x822594E8;
	}
	return 0x822594E8;
} // Block from 822594E0h-822594E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822594E8h
// Function '?EVAL@Dominator@XGRAPHICS@@AAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594E8);
		  /* 822594E8h */ case    0:  		/* addic R10, R11, -1 */
		/* 822594E8h case    0:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 822594E8h case    0:*/		return 0x822594EC;
		  /* 822594ECh */ case    1:  		/* subfe R3, R10, R11 */
		/* 822594ECh case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822594ECh case    1:*/		return 0x822594F0;
		  /* 822594F0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822594F0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822594F0h case    2:*/		return 0x822594F4;
	}
	return 0x822594F4;
} // Block from 822594E8h-822594F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822594F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594F4);
		  /* 822594F4h */ case    0:  		/* nop */
		/* 822594F4h case    0:*/		cpu::op::nop();
		/* 822594F4h case    0:*/		return 0x822594F8;
	}
	return 0x822594F8;
} // Block from 822594F4h-822594F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822594F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822594F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822594F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822594F8);
		  /* 822594F8h */ case    0:  		/* mfspr R12, LR */
		/* 822594F8h case    0:*/		regs.R12 = regs.LR;
		/* 822594F8h case    0:*/		return 0x822594FC;
		  /* 822594FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822594FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822594FCh case    1:*/		return 0x82259500;
		  /* 82259500h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82259500h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259500h case    2:*/		return 0x82259504;
		  /* 82259504h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82259504h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82259504h case    3:*/		return 0x82259508;
		  /* 82259508h */ case    4:  		/* lwz R3, <#[R3 + 88]> */
		/* 82259508h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000058) );
		/* 82259508h case    4:*/		return 0x8225950C;
		  /* 8225950Ch */ case    5:  		/* mr R31, R4 */
		/* 8225950Ch case    5:*/		regs.R31 = regs.R4;
		/* 8225950Ch case    5:*/		return 0x82259510;
		  /* 82259510h */ case    6:  		/* lwz R4, <#[R3 + 4]> */
		/* 82259510h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82259510h case    6:*/		return 0x82259514;
		  /* 82259514h */ case    7:  		/* bl -23124 */
		/* 82259514h case    7:*/		regs.LR = 0x82259518; return 0x82253AC0;
		/* 82259514h case    7:*/		return 0x82259518;
		  /* 82259518h */ case    8:  		/* stw R31, <#[R3]> */
		/* 82259518h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82259518h case    8:*/		return 0x8225951C;
		  /* 8225951Ch */ case    9:  		/* addi R1, R1, 96 */
		/* 8225951Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225951Ch case    9:*/		return 0x82259520;
		  /* 82259520h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259520h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259520h case   10:*/		return 0x82259524;
		  /* 82259524h */ case   11:  		/* mtspr LR, R12 */
		/* 82259524h case   11:*/		regs.LR = regs.R12;
		/* 82259524h case   11:*/		return 0x82259528;
		  /* 82259528h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 82259528h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259528h case   12:*/		return 0x8225952C;
		  /* 8225952Ch */ case   13:  		/* bclr 20, CR0_LT */
		/* 8225952Ch case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225952Ch case   13:*/		return 0x82259530;
	}
	return 0x82259530;
} // Block from 822594F8h-82259530h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82259530h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259530);
		  /* 82259530h */ case    0:  		/* mfspr R12, LR */
		/* 82259530h case    0:*/		regs.R12 = regs.LR;
		/* 82259530h case    0:*/		return 0x82259534;
		  /* 82259534h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259534h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259534h case    1:*/		return 0x82259538;
	}
	return 0x82259538;
} // Block from 82259530h-82259538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259538h
// Function '?BuildDFSTree@Dominator@XGRAPHICS@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259538);
		  /* 82259538h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 82259538h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259538h case    0:*/		return 0x8225953C;
		  /* 8225953Ch */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225953Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225953Ch case    1:*/		return 0x82259540;
		  /* 82259540h */ case    2:  		/* lwz R3, <#[R3 + 92]> */
		/* 82259540h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000005C) );
		/* 82259540h case    2:*/		return 0x82259544;
		  /* 82259544h */ case    3:  		/* mr R31, R4 */
		/* 82259544h case    3:*/		regs.R31 = regs.R4;
		/* 82259544h case    3:*/		return 0x82259548;
		  /* 82259548h */ case    4:  		/* lwz R4, <#[R3 + 4]> */
		/* 82259548h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82259548h case    4:*/		return 0x8225954C;
		  /* 8225954Ch */ case    5:  		/* bl -23180 */
		/* 8225954Ch case    5:*/		regs.LR = 0x82259550; return 0x82253AC0;
		/* 8225954Ch case    5:*/		return 0x82259550;
		  /* 82259550h */ case    6:  		/* stw R31, <#[R3]> */
		/* 82259550h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82259550h case    6:*/		return 0x82259554;
		  /* 82259554h */ case    7:  		/* addi R1, R1, 96 */
		/* 82259554h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82259554h case    7:*/		return 0x82259558;
		  /* 82259558h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259558h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259558h case    8:*/		return 0x8225955C;
		  /* 8225955Ch */ case    9:  		/* mtspr LR, R12 */
		/* 8225955Ch case    9:*/		regs.LR = regs.R12;
		/* 8225955Ch case    9:*/		return 0x82259560;
		  /* 82259560h */ case   10:  		/* ld R31, <#[R1 - 16]> */
		/* 82259560h case   10:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259560h case   10:*/		return 0x82259564;
		  /* 82259564h */ case   11:  		/* bclr 20, CR0_LT */
		/* 82259564h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259564h case   11:*/		return 0x82259568;
	}
	return 0x82259568;
} // Block from 82259538h-82259568h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82259568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259568);
		  /* 82259568h */ case    0:  		/* mfspr R12, LR */
		/* 82259568h case    0:*/		regs.R12 = regs.LR;
		/* 82259568h case    0:*/		return 0x8225956C;
		  /* 8225956Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225956Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225956Ch case    1:*/		return 0x82259570;
		  /* 82259570h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82259570h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259570h case    2:*/		return 0x82259574;
		  /* 82259574h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82259574h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82259574h case    3:*/		return 0x82259578;
		  /* 82259578h */ case    4:  		/* lwz R31, <#[R3 + 144]> */
		/* 82259578h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000090) );
		/* 82259578h case    4:*/		return 0x8225957C;
		  /* 8225957Ch */ case    5:  		/* b 180 */
		/* 8225957Ch case    5:*/		return 0x82259630;
		/* 8225957Ch case    5:*/		return 0x82259580;
		  /* 82259580h */ case    6:  		/* lwz R11, <#[R31 + 56]> */
		/* 82259580h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82259580h case    6:*/		return 0x82259584;
		  /* 82259584h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 82259584h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82259584h case    7:*/		return 0x82259588;
		  /* 82259588h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82259588h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82259588h case    8:*/		return 0x8225958C;
		  /* 8225958Ch */ case    9:  		/* bc 4, CR6_GT, 172 */
		/* 8225958Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x82259638;  }
		/* 8225958Ch case    9:*/		return 0x82259590;
		  /* 82259590h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 82259590h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259590h case   10:*/		return 0x82259594;
		  /* 82259594h */ case   11:  		/* mr R3, R31 */
		/* 82259594h case   11:*/		regs.R3 = regs.R31;
		/* 82259594h case   11:*/		return 0x82259598;
		  /* 82259598h */ case   12:  		/* lwz R11, <#[R11 + 28]> */
		/* 82259598h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82259598h case   12:*/		return 0x8225959C;
		  /* 8225959Ch */ case   13:  		/* mtspr CTR, R11 */
		/* 8225959Ch case   13:*/		regs.CTR = regs.R11;
		/* 8225959Ch case   13:*/		return 0x822595A0;
		  /* 822595A0h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 822595A0h case   14:*/		if ( 1 ) { regs.LR = 0x822595A4; return (uint32)regs.CTR; }
		/* 822595A0h case   14:*/		return 0x822595A4;
		  /* 822595A4h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822595A4h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822595A4h case   15:*/		return 0x822595A8;
		  /* 822595A8h */ case   16:  		/* bc 4, CR0_EQ, 144 */
		/* 822595A8h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82259638;  }
		/* 822595A8h case   16:*/		return 0x822595AC;
		  /* 822595ACh */ case   17:  		/* lwz R11, <#[R31]> */
		/* 822595ACh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822595ACh case   17:*/		return 0x822595B0;
		  /* 822595B0h */ case   18:  		/* mr R3, R31 */
		/* 822595B0h case   18:*/		regs.R3 = regs.R31;
		/* 822595B0h case   18:*/		return 0x822595B4;
		  /* 822595B4h */ case   19:  		/* lwz R11, <#[R11 + 32]> */
		/* 822595B4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 822595B4h case   19:*/		return 0x822595B8;
		  /* 822595B8h */ case   20:  		/* mtspr CTR, R11 */
		/* 822595B8h case   20:*/		regs.CTR = regs.R11;
		/* 822595B8h case   20:*/		return 0x822595BC;
		  /* 822595BCh */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 822595BCh case   21:*/		if ( 1 ) { regs.LR = 0x822595C0; return (uint32)regs.CTR; }
		/* 822595BCh case   21:*/		return 0x822595C0;
		  /* 822595C0h */ case   22:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822595C0h case   22:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822595C0h case   22:*/		return 0x822595C4;
		  /* 822595C4h */ case   23:  		/* bc 4, CR0_EQ, 116 */
		/* 822595C4h case   23:*/		if ( !regs.CR[0].eq ) { return 0x82259638;  }
		/* 822595C4h case   23:*/		return 0x822595C8;
		  /* 822595C8h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 822595C8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822595C8h case   24:*/		return 0x822595CC;
		  /* 822595CCh */ case   25:  		/* mr R3, R31 */
		/* 822595CCh case   25:*/		regs.R3 = regs.R31;
		/* 822595CCh case   25:*/		return 0x822595D0;
		  /* 822595D0h */ case   26:  		/* lwz R11, <#[R11 + 20]> */
		/* 822595D0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 822595D0h case   26:*/		return 0x822595D4;
		  /* 822595D4h */ case   27:  		/* mtspr CTR, R11 */
		/* 822595D4h case   27:*/		regs.CTR = regs.R11;
		/* 822595D4h case   27:*/		return 0x822595D8;
		  /* 822595D8h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 822595D8h case   28:*/		if ( 1 ) { regs.LR = 0x822595DC; return (uint32)regs.CTR; }
		/* 822595D8h case   28:*/		return 0x822595DC;
		  /* 822595DCh */ case   29:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822595DCh case   29:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822595DCh case   29:*/		return 0x822595E0;
		  /* 822595E0h */ case   30:  		/* bc 12, CR0_EQ, 12 */
		/* 822595E0h case   30:*/		if ( regs.CR[0].eq ) { return 0x822595EC;  }
		/* 822595E0h case   30:*/		return 0x822595E4;
		  /* 822595E4h */ case   31:  		/* lwz R31, <#[R31 + 156]> */
		/* 822595E4h case   31:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000009C) );
		/* 822595E4h case   31:*/		return 0x822595E8;
		  /* 822595E8h */ case   32:  		/* b 72 */
		/* 822595E8h case   32:*/		return 0x82259630;
		/* 822595E8h case   32:*/		return 0x822595EC;
	}
	return 0x822595EC;
} // Block from 82259568h-822595ECh (33 instructions)

//////////////////////////////////////////////////////
// Block at 822595ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822595EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822595EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822595EC);
		  /* 822595ECh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822595ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822595ECh case    0:*/		return 0x822595F0;
		  /* 822595F0h */ case    1:  		/* mr R3, R31 */
		/* 822595F0h case    1:*/		regs.R3 = regs.R31;
		/* 822595F0h case    1:*/		return 0x822595F4;
		  /* 822595F4h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 822595F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822595F4h case    2:*/		return 0x822595F8;
		  /* 822595F8h */ case    3:  		/* mtspr CTR, R11 */
		/* 822595F8h case    3:*/		regs.CTR = regs.R11;
		/* 822595F8h case    3:*/		return 0x822595FC;
		  /* 822595FCh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822595FCh case    4:*/		if ( 1 ) { regs.LR = 0x82259600; return (uint32)regs.CTR; }
		/* 822595FCh case    4:*/		return 0x82259600;
		  /* 82259600h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82259600h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82259600h case    5:*/		return 0x82259604;
		  /* 82259604h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82259604h case    6:*/		if ( regs.CR[0].eq ) { return 0x82259610;  }
		/* 82259604h case    6:*/		return 0x82259608;
		  /* 82259608h */ case    7:  		/* lwz R31, <#[R31 + 152]> */
		/* 82259608h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000098) );
		/* 82259608h case    7:*/		return 0x8225960C;
		  /* 8225960Ch */ case    8:  		/* b 36 */
		/* 8225960Ch case    8:*/		return 0x82259630;
		/* 8225960Ch case    8:*/		return 0x82259610;
	}
	return 0x82259610;
} // Block from 822595ECh-82259610h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82259610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259610);
		  /* 82259610h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 82259610h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82259610h case    0:*/		return 0x82259614;
		  /* 82259614h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 82259614h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82259614h case    1:*/		return 0x82259618;
		  /* 82259618h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82259618h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82259618h case    2:*/		return 0x8225961C;
		  /* 8225961Ch */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 8225961Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82259628;  }
		/* 8225961Ch case    3:*/		return 0x82259620;
		  /* 82259620h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 82259620h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82259620h case    4:*/		return 0x82259624;
		  /* 82259624h */ case    5:  		/* b 8 */
		/* 82259624h case    5:*/		return 0x8225962C;
		/* 82259624h case    5:*/		return 0x82259628;
	}
	return 0x82259628;
} // Block from 82259610h-82259628h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259628);
		  /* 82259628h */ case    0:  		/* li R11, 0 */
		/* 82259628h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82259628h case    0:*/		return 0x8225962C;
	}
	return 0x8225962C;
} // Block from 82259628h-8225962Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225962Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225962C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225962C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225962C);
		  /* 8225962Ch */ case    0:  		/* lwz R31, <#[R11]> */
		/* 8225962Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8225962Ch case    0:*/		return 0x82259630;
	}
	return 0x82259630;
} // Block from 8225962Ch-82259630h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259630);
		  /* 82259630h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82259630h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82259630h case    0:*/		return 0x82259634;
		  /* 82259634h */ case    1:  		/* bc 4, CR6_EQ, -180 */
		/* 82259634h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82259580;  }
		/* 82259634h case    1:*/		return 0x82259638;
	}
	return 0x82259638;
} // Block from 82259630h-82259638h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259638);
		  /* 82259638h */ case    0:  		/* mr R3, R31 */
		/* 82259638h case    0:*/		regs.R3 = regs.R31;
		/* 82259638h case    0:*/		return 0x8225963C;
		  /* 8225963Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 8225963Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225963Ch case    1:*/		return 0x82259640;
		  /* 82259640h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259640h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259640h case    2:*/		return 0x82259644;
		  /* 82259644h */ case    3:  		/* mtspr LR, R12 */
		/* 82259644h case    3:*/		regs.LR = regs.R12;
		/* 82259644h case    3:*/		return 0x82259648;
		  /* 82259648h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82259648h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259648h case    4:*/		return 0x8225964C;
		  /* 8225964Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8225964Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225964Ch case    5:*/		return 0x82259650;
	}
	return 0x82259650;
} // Block from 82259638h-82259650h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259650);
		  /* 82259650h */ case    0:  		/* mfspr R12, LR */
		/* 82259650h case    0:*/		regs.R12 = regs.LR;
		/* 82259650h case    0:*/		return 0x82259654;
		  /* 82259654h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259654h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259654h case    1:*/		return 0x82259658;
		  /* 82259658h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82259658h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259658h case    2:*/		return 0x8225965C;
		  /* 8225965Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225965Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225965Ch case    3:*/		return 0x82259660;
		  /* 82259660h */ case    4:  		/* lwz R31, <#[R3 + 148]> */
		/* 82259660h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000094) );
		/* 82259660h case    4:*/		return 0x82259664;
		  /* 82259664h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 82259664h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82259664h case    5:*/		return 0x82259668;
		  /* 82259668h */ case    6:  		/* bc 12, CR6_EQ, 192 */
		/* 82259668h case    6:*/		if ( regs.CR[6].eq ) { return 0x82259728;  }
		/* 82259668h case    6:*/		return 0x8225966C;
		  /* 8225966Ch */ case    7:  		/* lwz R11, <#[R31 + 56]> */
		/* 8225966Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8225966Ch case    7:*/		return 0x82259670;
		  /* 82259670h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82259670h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82259670h case    8:*/		return 0x82259674;
		  /* 82259674h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82259674h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82259674h case    9:*/		return 0x82259678;
		  /* 82259678h */ case   10:  		/* bc 4, CR6_GT, 172 */
		/* 82259678h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82259724;  }
		/* 82259678h case   10:*/		return 0x8225967C;
		  /* 8225967Ch */ case   11:  		/* lwz R11, <#[R31]> */
		/* 8225967Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225967Ch case   11:*/		return 0x82259680;
		  /* 82259680h */ case   12:  		/* mr R3, R31 */
		/* 82259680h case   12:*/		regs.R3 = regs.R31;
		/* 82259680h case   12:*/		return 0x82259684;
		  /* 82259684h */ case   13:  		/* lwz R11, <#[R11 + 28]> */
		/* 82259684h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82259684h case   13:*/		return 0x82259688;
		  /* 82259688h */ case   14:  		/* mtspr CTR, R11 */
		/* 82259688h case   14:*/		regs.CTR = regs.R11;
		/* 82259688h case   14:*/		return 0x8225968C;
		  /* 8225968Ch */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8225968Ch case   15:*/		if ( 1 ) { regs.LR = 0x82259690; return (uint32)regs.CTR; }
		/* 8225968Ch case   15:*/		return 0x82259690;
	}
	return 0x82259690;
} // Block from 82259650h-82259690h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82259690h
// Function '?CalcDom@Dominator@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259690);
		  /* 82259690h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82259690h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82259690h case    0:*/		return 0x82259694;
		  /* 82259694h */ case    1:  		/* bc 4, CR0_EQ, 144 */
		/* 82259694h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82259724;  }
		/* 82259694h case    1:*/		return 0x82259698;
		  /* 82259698h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82259698h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259698h case    2:*/		return 0x8225969C;
		  /* 8225969Ch */ case    3:  		/* mr R3, R31 */
		/* 8225969Ch case    3:*/		regs.R3 = regs.R31;
		/* 8225969Ch case    3:*/		return 0x822596A0;
		  /* 822596A0h */ case    4:  		/* lwz R11, <#[R11 + 32]> */
		/* 822596A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 822596A0h case    4:*/		return 0x822596A4;
		  /* 822596A4h */ case    5:  		/* mtspr CTR, R11 */
		/* 822596A4h case    5:*/		regs.CTR = regs.R11;
		/* 822596A4h case    5:*/		return 0x822596A8;
		  /* 822596A8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 822596A8h case    6:*/		if ( 1 ) { regs.LR = 0x822596AC; return (uint32)regs.CTR; }
		/* 822596A8h case    6:*/		return 0x822596AC;
		  /* 822596ACh */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822596ACh case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822596ACh case    7:*/		return 0x822596B0;
		  /* 822596B0h */ case    8:  		/* bc 4, CR0_EQ, 116 */
		/* 822596B0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82259724;  }
		/* 822596B0h case    8:*/		return 0x822596B4;
		  /* 822596B4h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 822596B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822596B4h case    9:*/		return 0x822596B8;
		  /* 822596B8h */ case   10:  		/* mr R3, R31 */
		/* 822596B8h case   10:*/		regs.R3 = regs.R31;
		/* 822596B8h case   10:*/		return 0x822596BC;
		  /* 822596BCh */ case   11:  		/* lwz R11, <#[R11 + 20]> */
		/* 822596BCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 822596BCh case   11:*/		return 0x822596C0;
		  /* 822596C0h */ case   12:  		/* mtspr CTR, R11 */
		/* 822596C0h case   12:*/		regs.CTR = regs.R11;
		/* 822596C0h case   12:*/		return 0x822596C4;
		  /* 822596C4h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 822596C4h case   13:*/		if ( 1 ) { regs.LR = 0x822596C8; return (uint32)regs.CTR; }
		/* 822596C4h case   13:*/		return 0x822596C8;
		  /* 822596C8h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822596C8h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822596C8h case   14:*/		return 0x822596CC;
		  /* 822596CCh */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 822596CCh case   15:*/		if ( regs.CR[0].eq ) { return 0x822596D8;  }
		/* 822596CCh case   15:*/		return 0x822596D0;
		  /* 822596D0h */ case   16:  		/* lwz R31, <#[R31 + 156]> */
		/* 822596D0h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000009C) );
		/* 822596D0h case   16:*/		return 0x822596D4;
		  /* 822596D4h */ case   17:  		/* b 72 */
		/* 822596D4h case   17:*/		return 0x8225971C;
		/* 822596D4h case   17:*/		return 0x822596D8;
	}
	return 0x822596D8;
} // Block from 82259690h-822596D8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822596D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822596D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822596D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822596D8);
		  /* 822596D8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822596D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822596D8h case    0:*/		return 0x822596DC;
		  /* 822596DCh */ case    1:  		/* mr R3, R31 */
		/* 822596DCh case    1:*/		regs.R3 = regs.R31;
		/* 822596DCh case    1:*/		return 0x822596E0;
		  /* 822596E0h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 822596E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822596E0h case    2:*/		return 0x822596E4;
		  /* 822596E4h */ case    3:  		/* mtspr CTR, R11 */
		/* 822596E4h case    3:*/		regs.CTR = regs.R11;
		/* 822596E4h case    3:*/		return 0x822596E8;
		  /* 822596E8h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822596E8h case    4:*/		if ( 1 ) { regs.LR = 0x822596EC; return (uint32)regs.CTR; }
		/* 822596E8h case    4:*/		return 0x822596EC;
		  /* 822596ECh */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822596ECh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822596ECh case    5:*/		return 0x822596F0;
		  /* 822596F0h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 822596F0h case    6:*/		if ( regs.CR[0].eq ) { return 0x822596FC;  }
		/* 822596F0h case    6:*/		return 0x822596F4;
		  /* 822596F4h */ case    7:  		/* lwz R31, <#[R31 + 152]> */
		/* 822596F4h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000098) );
		/* 822596F4h case    7:*/		return 0x822596F8;
		  /* 822596F8h */ case    8:  		/* b 36 */
		/* 822596F8h case    8:*/		return 0x8225971C;
		/* 822596F8h case    8:*/		return 0x822596FC;
	}
	return 0x822596FC;
} // Block from 822596D8h-822596FCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822596FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822596FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822596FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822596FC);
		  /* 822596FCh */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 822596FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 822596FCh case    0:*/		return 0x82259700;
		  /* 82259700h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 82259700h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82259700h case    1:*/		return 0x82259704;
		  /* 82259704h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82259704h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82259704h case    2:*/		return 0x82259708;
		  /* 82259708h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82259708h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82259714;  }
		/* 82259708h case    3:*/		return 0x8225970C;
		  /* 8225970Ch */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8225970Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8225970Ch case    4:*/		return 0x82259710;
		  /* 82259710h */ case    5:  		/* b 8 */
		/* 82259710h case    5:*/		return 0x82259718;
		/* 82259710h case    5:*/		return 0x82259714;
	}
	return 0x82259714;
} // Block from 822596FCh-82259714h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259714);
		  /* 82259714h */ case    0:  		/* li R11, 0 */
		/* 82259714h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82259714h case    0:*/		return 0x82259718;
	}
	return 0x82259718;
} // Block from 82259714h-82259718h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259718);
		  /* 82259718h */ case    0:  		/* lwz R31, <#[R11]> */
		/* 82259718h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82259718h case    0:*/		return 0x8225971C;
	}
	return 0x8225971C;
} // Block from 82259718h-8225971Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225971Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225971C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225971C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225971C);
		  /* 8225971Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8225971Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225971Ch case    0:*/		return 0x82259720;
		  /* 82259720h */ case    1:  		/* bc 4, CR6_EQ, -180 */
		/* 82259720h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8225966C;  }
		/* 82259720h case    1:*/		return 0x82259724;
	}
	return 0x82259724;
} // Block from 8225971Ch-82259724h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259724);
		  /* 82259724h */ case    0:  		/* mr R3, R31 */
		/* 82259724h case    0:*/		regs.R3 = regs.R31;
		/* 82259724h case    0:*/		return 0x82259728;
	}
	return 0x82259728;
} // Block from 82259724h-82259728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259728);
		  /* 82259728h */ case    0:  		/* addi R1, R1, 96 */
		/* 82259728h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82259728h case    0:*/		return 0x8225972C;
		  /* 8225972Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225972Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225972Ch case    1:*/		return 0x82259730;
		  /* 82259730h */ case    2:  		/* mtspr LR, R12 */
		/* 82259730h case    2:*/		regs.LR = regs.R12;
		/* 82259730h case    2:*/		return 0x82259734;
		  /* 82259734h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82259734h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259734h case    3:*/		return 0x82259738;
		  /* 82259738h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82259738h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259738h case    4:*/		return 0x8225973C;
	}
	return 0x8225973C;
} // Block from 82259728h-8225973Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225973Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225973C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225973C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225973C);
		  /* 8225973Ch */ case    0:  		/* nop */
		/* 8225973Ch case    0:*/		cpu::op::nop();
		/* 8225973Ch case    0:*/		return 0x82259740;
	}
	return 0x82259740;
} // Block from 8225973Ch-82259740h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259740h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259740);
		  /* 82259740h */ case    0:  		/* mfspr R12, LR */
		/* 82259740h case    0:*/		regs.R12 = regs.LR;
		/* 82259740h case    0:*/		return 0x82259744;
		  /* 82259744h */ case    1:  		/* bl -1869064 */
		/* 82259744h case    1:*/		regs.LR = 0x82259748; return 0x8209123C;
		/* 82259744h case    1:*/		return 0x82259748;
		  /* 82259748h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82259748h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82259748h case    2:*/		return 0x8225974C;
		  /* 8225974Ch */ case    3:  		/* lis R10, -32253 */
		/* 8225974Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 8225974Ch case    3:*/		return 0x82259750;
		  /* 82259750h */ case    4:  		/* lwz R21, <#[R3 + 164]> */
		/* 82259750h case    4:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R3 + 0x000000A4) );
		/* 82259750h case    4:*/		return 0x82259754;
		  /* 82259754h */ case    5:  		/* lis R9, -32255 */
		/* 82259754h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 82259754h case    5:*/		return 0x82259758;
		  /* 82259758h */ case    6:  		/* lis R11, -32251 */
		/* 82259758h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259758h case    6:*/		return 0x8225975C;
		  /* 8225975Ch */ case    7:  		/* mr R22, R3 */
		/* 8225975Ch case    7:*/		regs.R22 = regs.R3;
		/* 8225975Ch case    7:*/		return 0x82259760;
		  /* 82259760h */ case    8:  		/* addi R26, R10, 27460 */
		/* 82259760h case    8:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R10,0x6B44);
		/* 82259760h case    8:*/		return 0x82259764;
		  /* 82259764h */ case    9:  		/* addi R25, R9, 5216 */
		/* 82259764h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R9,0x1460);
		/* 82259764h case    9:*/		return 0x82259768;
		  /* 82259768h */ case   10:  		/* addi R24, R11, -32472 */
		/* 82259768h case   10:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0xFFFF8128);
		/* 82259768h case   10:*/		return 0x8225976C;
		  /* 8225976Ch */ case   11:  		/* lwz R28, <#[R22 + 136]> */
		/* 8225976Ch case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R22 + 0x00000088) );
		/* 8225976Ch case   11:*/		return 0x82259770;
		  /* 82259770h */ case   12:  		/* li R23, 0 */
		/* 82259770h case   12:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82259770h case   12:*/		return 0x82259774;
		  /* 82259774h */ case   13:  		/* lwz R27, <#[R28 + 8]> */
		/* 82259774h case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R28 + 0x00000008) );
		/* 82259774h case   13:*/		return 0x82259778;
		  /* 82259778h */ case   14:  		/* b 220 */
		/* 82259778h case   14:*/		return 0x82259854;
		/* 82259778h case   14:*/		return 0x8225977C;
		  /* 8225977Ch */ case   15:  		/* cmplw CR6, R28, R21 */
		/* 8225977Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R21);
		/* 8225977Ch case   15:*/		return 0x82259780;
		  /* 82259780h */ case   16:  		/* bc 12, CR6_EQ, 204 */
		/* 82259780h case   16:*/		if ( regs.CR[6].eq ) { return 0x8225984C;  }
		/* 82259780h case   16:*/		return 0x82259784;
		  /* 82259784h */ case   17:  		/* lwz R11, <#[R28 + 60]> */
		/* 82259784h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000003C) );
		/* 82259784h case   17:*/		return 0x82259788;
		  /* 82259788h */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 82259788h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82259788h case   18:*/		return 0x8225978C;
		  /* 8225978Ch */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 8225978Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225978Ch case   19:*/		return 0x82259790;
		  /* 82259790h */ case   20:  		/* bc 4, CR6_EQ, 188 */
		/* 82259790h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8225984C;  }
		/* 82259790h case   20:*/		return 0x82259794;
		  /* 82259794h */ case   21:  		/* mr R6, R24 */
		/* 82259794h case   21:*/		regs.R6 = regs.R24;
		/* 82259794h case   21:*/		return 0x82259798;
		  /* 82259798h */ case   22:  		/* mr R5, R25 */
		/* 82259798h case   22:*/		regs.R5 = regs.R25;
		/* 82259798h case   22:*/		return 0x8225979C;
		  /* 8225979Ch */ case   23:  		/* mr R4, R26 */
		/* 8225979Ch case   23:*/		regs.R4 = regs.R26;
		/* 8225979Ch case   23:*/		return 0x822597A0;
		  /* 822597A0h */ case   24:  		/* li R7, 559 */
		/* 822597A0h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x22F);
		/* 822597A0h case   24:*/		return 0x822597A4;
		  /* 822597A4h */ case   25:  		/* li R3, 0 */
		/* 822597A4h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822597A4h case   25:*/		return 0x822597A8;
		  /* 822597A8h */ case   26:  		/* bl -1055648 */
		/* 822597A8h case   26:*/		regs.LR = 0x822597AC; return 0x82157C08;
		/* 822597A8h case   26:*/		return 0x822597AC;
		  /* 822597ACh */ case   27:  		/* li R30, 0 */
		/* 822597ACh case   27:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822597ACh case   27:*/		return 0x822597B0;
		  /* 822597B0h */ case   28:  		/* li R31, 0 */
		/* 822597B0h case   28:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822597B0h case   28:*/		return 0x822597B4;
		  /* 822597B4h */ case   29:  		/* li R29, 1 */
		/* 822597B4h case   29:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 822597B4h case   29:*/		return 0x822597B8;
		  /* 822597B8h */ case   30:  		/* lwz R11, <#[R28 + 56]> */
		/* 822597B8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000038) );
		/* 822597B8h case   30:*/		return 0x822597BC;
		  /* 822597BCh */ case   31:  		/* lwz R10, <#[R11 + 4]> */
		/* 822597BCh case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822597BCh case   31:*/		return 0x822597C0;
		  /* 822597C0h */ case   32:  		/* cmplw CR6, R29, R10 */
		/* 822597C0h case   32:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 822597C0h case   32:*/		return 0x822597C4;
		  /* 822597C4h */ case   33:  		/* bc 4, CR6_GT, 12 */
		/* 822597C4h case   33:*/		if ( !regs.CR[6].gt ) { return 0x822597D0;  }
		/* 822597C4h case   33:*/		return 0x822597C8;
		  /* 822597C8h */ case   34:  		/* li R11, 0 */
		/* 822597C8h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822597C8h case   34:*/		return 0x822597CC;
		  /* 822597CCh */ case   35:  		/* b 16 */
		/* 822597CCh case   35:*/		return 0x822597DC;
		/* 822597CCh case   35:*/		return 0x822597D0;
	}
	return 0x822597D0;
} // Block from 82259740h-822597D0h (36 instructions)

//////////////////////////////////////////////////////
// Block at 822597D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822597D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822597D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822597D0);
		  /* 822597D0h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 822597D0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822597D0h case    0:*/		return 0x822597D4;
		  /* 822597D4h */ case    1:  		/* li R11, 1 */
		/* 822597D4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822597D4h case    1:*/		return 0x822597D8;
		  /* 822597D8h */ case    2:  		/* lwzx R30, <#[R10 + R31]> */
		/* 822597D8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 822597D8h case    2:*/		return 0x822597DC;
	}
	return 0x822597DC;
} // Block from 822597D0h-822597DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822597DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822597DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822597DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822597DC);
		  /* 822597DCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822597DCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822597DCh case    0:*/		return 0x822597E0;
		  /* 822597E0h */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 822597E0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82259844;  }
		/* 822597E0h case    1:*/		return 0x822597E4;
		  /* 822597E4h */ case    2:  		/* lwz R11, <#[R30 + 60]> */
		/* 822597E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 822597E4h case    2:*/		return 0x822597E8;
		  /* 822597E8h */ case    3:  		/* addi R10, R1, 80 */
		/* 822597E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 822597E8h case    3:*/		return 0x822597EC;
		  /* 822597ECh */ case    4:  		/* mr R4, R28 */
		/* 822597ECh case    4:*/		regs.R4 = regs.R28;
		/* 822597ECh case    4:*/		return 0x822597F0;
		  /* 822597F0h */ case    5:  		/* addi R3, R1, 80 */
		/* 822597F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822597F0h case    5:*/		return 0x822597F4;
		  /* 822597F4h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 822597F4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822597F4h case    6:*/		return 0x822597F8;
		  /* 822597F8h */ case    7:  		/* stw R9, <#[R10]> */
		/* 822597F8h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 822597F8h case    7:*/		return 0x822597FC;
		  /* 822597FCh */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 822597FCh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 822597FCh case    8:*/		return 0x82259800;
		  /* 82259800h */ case    9:  		/* stw R9, <#[R10 + 4]> */
		/* 82259800h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82259800h case    9:*/		return 0x82259804;
		  /* 82259804h */ case   10:  		/* lwz R9, <#[R11 + 8]> */
		/* 82259804h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82259804h case   10:*/		return 0x82259808;
		  /* 82259808h */ case   11:  		/* stw R9, <#[R10 + 8]> */
		/* 82259808h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82259808h case   11:*/		return 0x8225980C;
		  /* 8225980Ch */ case   12:  		/* lwz R11, <#[R11 + 12]> */
		/* 8225980Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8225980Ch case   12:*/		return 0x82259810;
		  /* 82259810h */ case   13:  		/* stw R11, <#[R10 + 12]> */
		/* 82259810h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82259810h case   13:*/		return 0x82259814;
		  /* 82259814h */ case   14:  		/* bl -24028 */
		/* 82259814h case   14:*/		regs.LR = 0x82259818; return 0x82253A38;
		/* 82259814h case   14:*/		return 0x82259818;
		  /* 82259818h */ case   15:  		/* lwz R11, <#[R30 + 60]> */
		/* 82259818h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 82259818h case   15:*/		return 0x8225981C;
		  /* 8225981Ch */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225981Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225981Ch case   16:*/		return 0x82259820;
		  /* 82259820h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 82259820h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82259820h case   17:*/		return 0x82259824;
		  /* 82259824h */ case   18:  		/* bc 4, CR6_EQ, 8 */
		/* 82259824h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8225982C;  }
		/* 82259824h case   18:*/		return 0x82259828;
		  /* 82259828h */ case   19:  		/* li R23, 1 */
		/* 82259828h case   19:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 82259828h case   19:*/		return 0x8225982C;
	}
	return 0x8225982C;
} // Block from 822597DCh-8225982Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8225982Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225982C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225982C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225982C);
		  /* 8225982Ch */ case    0:  		/* lwz R4, <#[R1 + 88]> */
		/* 8225982Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8225982Ch case    0:*/		return 0x82259830;
		  /* 82259830h */ case    1:  		/* lwz R3, <#[R1 + 92]> */
		/* 82259830h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82259830h case    1:*/		return 0x82259834;
		  /* 82259834h */ case    2:  		/* bl -250356 */
		/* 82259834h case    2:*/		regs.LR = 0x82259838; return 0x8221C640;
		/* 82259834h case    2:*/		return 0x82259838;
		  /* 82259838h */ case    3:  		/* addi R29, R29, 1 */
		/* 82259838h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82259838h case    3:*/		return 0x8225983C;
		  /* 8225983Ch */ case    4:  		/* addi R31, R31, 4 */
		/* 8225983Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8225983Ch case    4:*/		return 0x82259840;
		  /* 82259840h */ case    5:  		/* b -136 */
		/* 82259840h case    5:*/		return 0x822597B8;
		/* 82259840h case    5:*/		return 0x82259844;
	}
	return 0x82259844;
} // Block from 8225982Ch-82259844h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259844);
		  /* 82259844h */ case    0:  		/* mr R3, R28 */
		/* 82259844h case    0:*/		regs.R3 = regs.R28;
		/* 82259844h case    0:*/		return 0x82259848;
		  /* 82259848h */ case    1:  		/* bl -24752 */
		/* 82259848h case    1:*/		regs.LR = 0x8225984C; return 0x82253798;
		/* 82259848h case    1:*/		return 0x8225984C;
	}
	return 0x8225984C;
} // Block from 82259844h-8225984Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225984Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225984C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225984C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225984C);
		  /* 8225984Ch */ case    0:  		/* mr R28, R27 */
		/* 8225984Ch case    0:*/		regs.R28 = regs.R27;
		/* 8225984Ch case    0:*/		return 0x82259850;
		  /* 82259850h */ case    1:  		/* lwz R27, <#[R27 + 8]> */
		/* 82259850h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000008) );
		/* 82259850h case    1:*/		return 0x82259854;
	}
	return 0x82259854;
} // Block from 8225984Ch-82259854h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259854);
		  /* 82259854h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82259854h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82259854h case    0:*/		return 0x82259858;
		  /* 82259858h */ case    1:  		/* bc 4, CR6_EQ, -220 */
		/* 82259858h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8225977C;  }
		/* 82259858h case    1:*/		return 0x8225985C;
		  /* 8225985Ch */ case    2:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225985Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225985Ch case    2:*/		return 0x82259860;
		  /* 82259860h */ case    3:  		/* bc 4, CR0_EQ, -244 */
		/* 82259860h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8225976C;  }
		/* 82259860h case    3:*/		return 0x82259864;
		  /* 82259864h */ case    4:  		/* addi R1, R1, 192 */
		/* 82259864h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82259864h case    4:*/		return 0x82259868;
		  /* 82259868h */ case    5:  		/* b -1869276 */
		/* 82259868h case    5:*/		return 0x8209128C;
		/* 82259868h case    5:*/		return 0x8225986C;
		  /* 8225986Ch */ case    6:  		/* nop */
		/* 8225986Ch case    6:*/		cpu::op::nop();
		/* 8225986Ch case    6:*/		return 0x82259870;
		  /* 82259870h */ case    7:  		/* lwz R8, <#[R3 + 4]> */
		/* 82259870h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 82259870h case    7:*/		return 0x82259874;
		  /* 82259874h */ case    8:  		/* li R9, 0 */
		/* 82259874h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82259874h case    8:*/		return 0x82259878;
		  /* 82259878h */ case    9:  		/* cmpwi CR6, R8, 0 */
		/* 82259878h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82259878h case    9:*/		return 0x8225987C;
		  /* 8225987Ch */ case   10:  		/* bc 4, CR6_GT, 64 */
		/* 8225987Ch case   10:*/		if ( !regs.CR[6].gt ) { return 0x822598BC;  }
		/* 8225987Ch case   10:*/		return 0x82259880;
		  /* 82259880h */ case   11:  		/* lwz R7, <#[R4]> */
		/* 82259880h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 82259880h case   11:*/		return 0x82259884;
		  /* 82259884h */ case   12:  		/* li R11, 0 */
		/* 82259884h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82259884h case   12:*/		return 0x82259888;
		  /* 82259888h */ case   13:  		/* cmplw CR6, R9, R8 */
		/* 82259888h case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82259888h case   13:*/		return 0x8225988C;
		  /* 8225988Ch */ case   14:  		/* bc 4, CR6_LT, 16 */
		/* 8225988Ch case   14:*/		if ( !regs.CR[6].lt ) { return 0x8225989C;  }
		/* 8225988Ch case   14:*/		return 0x82259890;
		  /* 82259890h */ case   15:  		/* lwz R10, <#[R3 + 8]> */
		/* 82259890h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82259890h case   15:*/		return 0x82259894;
		  /* 82259894h */ case   16:  		/* add R10, R10, R11 */
		/* 82259894h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82259894h case   16:*/		return 0x82259898;
		  /* 82259898h */ case   17:  		/* b 8 */
		/* 82259898h case   17:*/		return 0x822598A0;
		/* 82259898h case   17:*/		return 0x8225989C;
	}
	return 0x8225989C;
} // Block from 82259854h-8225989Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225989Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225989C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225989C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225989C);
		  /* 8225989Ch */ case    0:  		/* li R10, 0 */
		/* 8225989Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8225989Ch case    0:*/		return 0x822598A0;
	}
	return 0x822598A0;
} // Block from 8225989Ch-822598A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822598A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822598A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822598A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822598A0);
		  /* 822598A0h */ case    0:  		/* lwz R10, <#[R10]> */
		/* 822598A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 822598A0h case    0:*/		return 0x822598A4;
		  /* 822598A4h */ case    1:  		/* cmplw CR6, R10, R7 */
		/* 822598A4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 822598A4h case    1:*/		return 0x822598A8;
		  /* 822598A8h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 822598A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x822598C4;  }
		/* 822598A8h case    2:*/		return 0x822598AC;
		  /* 822598ACh */ case    3:  		/* addi R9, R9, 1 */
		/* 822598ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 822598ACh case    3:*/		return 0x822598B0;
		  /* 822598B0h */ case    4:  		/* addi R11, R11, 4 */
		/* 822598B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822598B0h case    4:*/		return 0x822598B4;
		  /* 822598B4h */ case    5:  		/* cmpw CR6, R9, R8 */
		/* 822598B4h case    5:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 822598B4h case    5:*/		return 0x822598B8;
		  /* 822598B8h */ case    6:  		/* bc 12, CR6_LT, -48 */
		/* 822598B8h case    6:*/		if ( regs.CR[6].lt ) { return 0x82259888;  }
		/* 822598B8h case    6:*/		return 0x822598BC;
	}
	return 0x822598BC;
} // Block from 822598A0h-822598BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822598BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822598BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822598BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822598BC);
		  /* 822598BCh */ case    0:  		/* li R3, 0 */
		/* 822598BCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822598BCh case    0:*/		return 0x822598C0;
		  /* 822598C0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822598C0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822598C0h case    1:*/		return 0x822598C4;
	}
	return 0x822598C4;
} // Block from 822598BCh-822598C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822598C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822598C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822598C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822598C4);
		  /* 822598C4h */ case    0:  		/* li R3, 1 */
		/* 822598C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822598C4h case    0:*/		return 0x822598C8;
		  /* 822598C8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822598C8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822598C8h case    1:*/		return 0x822598CC;
	}
	return 0x822598CC;
} // Block from 822598C4h-822598CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822598CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822598CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822598CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822598CC);
		  /* 822598CCh */ case    0:  		/* nop */
		/* 822598CCh case    0:*/		cpu::op::nop();
		/* 822598CCh case    0:*/		return 0x822598D0;
	}
	return 0x822598D0;
} // Block from 822598CCh-822598D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822598D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822598D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822598D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822598D0);
		  /* 822598D0h */ case    0:  		/* mfspr R12, LR */
		/* 822598D0h case    0:*/		regs.R12 = regs.LR;
		/* 822598D0h case    0:*/		return 0x822598D4;
		  /* 822598D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822598D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822598D4h case    1:*/		return 0x822598D8;
		  /* 822598D8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822598D8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822598D8h case    2:*/		return 0x822598DC;
		  /* 822598DCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822598DCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822598DCh case    3:*/		return 0x822598E0;
		  /* 822598E0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822598E0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822598E0h case    4:*/		return 0x822598E4;
		  /* 822598E4h */ case    5:  		/* mr R31, R3 */
		/* 822598E4h case    5:*/		regs.R31 = regs.R3;
		/* 822598E4h case    5:*/		return 0x822598E8;
		  /* 822598E8h */ case    6:  		/* mr R30, R4 */
		/* 822598E8h case    6:*/		regs.R30 = regs.R4;
		/* 822598E8h case    6:*/		return 0x822598EC;
		  /* 822598ECh */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 822598ECh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822598ECh case    7:*/		return 0x822598F0;
		  /* 822598F0h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 822598F0h case    8:*/		if ( regs.CR[6].eq ) { return 0x822598FC;  }
		/* 822598F0h case    8:*/		return 0x822598F4;
		  /* 822598F4h */ case    9:  		/* cmplwi CR6, R4, 0 */
		/* 822598F4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 822598F4h case    9:*/		return 0x822598F8;
		  /* 822598F8h */ case   10:  		/* bc 4, CR6_EQ, 40 */
		/* 822598F8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82259920;  }
		/* 822598F8h case   10:*/		return 0x822598FC;
	}
	return 0x822598FC;
} // Block from 822598D0h-822598FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 822598FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822598FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822598FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822598FC);
		  /* 822598FCh */ case    0:  		/* lis R11, -32251 */
		/* 822598FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822598FCh case    0:*/		return 0x82259900;
		  /* 82259900h */ case    1:  		/* lis R10, -32251 */
		/* 82259900h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82259900h case    1:*/		return 0x82259904;
		  /* 82259904h */ case    2:  		/* lis R9, -32253 */
		/* 82259904h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82259904h case    2:*/		return 0x82259908;
		  /* 82259908h */ case    3:  		/* addi R6, R11, -32472 */
		/* 82259908h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFF8128);
		/* 82259908h case    3:*/		return 0x8225990C;
		  /* 8225990Ch */ case    4:  		/* addi R5, R10, -32296 */
		/* 8225990Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFF81D8);
		/* 8225990Ch case    4:*/		return 0x82259910;
		  /* 82259910h */ case    5:  		/* addi R4, R9, 27460 */
		/* 82259910h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82259910h case    5:*/		return 0x82259914;
		  /* 82259914h */ case    6:  		/* li R7, 40 */
		/* 82259914h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x28);
		/* 82259914h case    6:*/		return 0x82259918;
		  /* 82259918h */ case    7:  		/* li R3, 0 */
		/* 82259918h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259918h case    7:*/		return 0x8225991C;
		  /* 8225991Ch */ case    8:  		/* bl -1056020 */
		/* 8225991Ch case    8:*/		regs.LR = 0x82259920; return 0x82157C08;
		/* 8225991Ch case    8:*/		return 0x82259920;
	}
	return 0x82259920;
} // Block from 822598FCh-82259920h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82259920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259920);
		  /* 82259920h */ case    0:  		/* lwz R3, <#[R31 + 56]> */
		/* 82259920h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82259920h case    0:*/		return 0x82259924;
		  /* 82259924h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82259924h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82259924h case    1:*/		return 0x82259928;
		  /* 82259928h */ case    2:  		/* bl -24168 */
		/* 82259928h case    2:*/		regs.LR = 0x8225992C; return 0x82253AC0;
		/* 82259928h case    2:*/		return 0x8225992C;
		  /* 8225992Ch */ case    3:  		/* stw R30, <#[R3]> */
		/* 8225992Ch case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8225992Ch case    3:*/		return 0x82259930;
		  /* 82259930h */ case    4:  		/* lwz R3, <#[R30 + 60]> */
		/* 82259930h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 82259930h case    4:*/		return 0x82259934;
		  /* 82259934h */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 82259934h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82259934h case    5:*/		return 0x82259938;
		  /* 82259938h */ case    6:  		/* bl -24184 */
		/* 82259938h case    6:*/		regs.LR = 0x8225993C; return 0x82253AC0;
		/* 82259938h case    6:*/		return 0x8225993C;
		  /* 8225993Ch */ case    7:  		/* stw R31, <#[R3]> */
		/* 8225993Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8225993Ch case    7:*/		return 0x82259940;
		  /* 82259940h */ case    8:  		/* addi R1, R1, 112 */
		/* 82259940h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259940h case    8:*/		return 0x82259944;
		  /* 82259944h */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259944h case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259944h case    9:*/		return 0x82259948;
		  /* 82259948h */ case   10:  		/* mtspr LR, R12 */
		/* 82259948h case   10:*/		regs.LR = regs.R12;
		/* 82259948h case   10:*/		return 0x8225994C;
		  /* 8225994Ch */ case   11:  		/* ld R30, <#[R1 - 24]> */
		/* 8225994Ch case   11:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225994Ch case   11:*/		return 0x82259950;
		  /* 82259950h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 82259950h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259950h case   12:*/		return 0x82259954;
		  /* 82259954h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82259954h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259954h case   13:*/		return 0x82259958;
	}
	return 0x82259958;
} // Block from 82259920h-82259958h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82259958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259958);
		  /* 82259958h */ case    0:  		/* mfspr R12, LR */
		/* 82259958h case    0:*/		regs.R12 = regs.LR;
		/* 82259958h case    0:*/		return 0x8225995C;
		  /* 8225995Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225995Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225995Ch case    1:*/		return 0x82259960;
	}
	return 0x82259960;
} // Block from 82259958h-82259960h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259960h
// Function '?Run@Dominator@XGRAPHICS@@SAXPAVCFG@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259960);
		  /* 82259960h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 82259960h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259960h case    0:*/		return 0x82259964;
		  /* 82259964h */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 82259964h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82259964h case    1:*/		return 0x82259968;
		  /* 82259968h */ case    2:  		/* mr R31, R3 */
		/* 82259968h case    2:*/		regs.R31 = regs.R3;
		/* 82259968h case    2:*/		return 0x8225996C;
		  /* 8225996Ch */ case    3:  		/* lwz R3, <#[R3 + 60]> */
		/* 8225996Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225996Ch case    3:*/		return 0x82259970;
		  /* 82259970h */ case    4:  		/* lis R11, -32251 */
		/* 82259970h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259970h case    4:*/		return 0x82259974;
		  /* 82259974h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 82259974h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82259974h case    5:*/		return 0x82259978;
		  /* 82259978h */ case    6:  		/* addi R11, R11, -32352 */
		/* 82259978h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF81A0);
		/* 82259978h case    6:*/		return 0x8225997C;
		  /* 8225997Ch */ case    7:  		/* stw R11, <#[R31]> */
		/* 8225997Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225997Ch case    7:*/		return 0x82259980;
		  /* 82259980h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82259980h case    8:*/		if ( regs.CR[6].eq ) { return 0x8225998C;  }
		/* 82259980h case    8:*/		return 0x82259984;
		  /* 82259984h */ case    9:  		/* li R4, 1 */
		/* 82259984h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82259984h case    9:*/		return 0x82259988;
		  /* 82259988h */ case   10:  		/* bl -105968 */
		/* 82259988h case   10:*/		regs.LR = 0x8225998C; return 0x8223FB98;
		/* 82259988h case   10:*/		return 0x8225998C;
	}
	return 0x8225998C;
} // Block from 82259960h-8225998Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225998Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225998C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225998C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225998C);
		  /* 8225998Ch */ case    0:  		/* lwz R3, <#[R31 + 56]> */
		/* 8225998Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 8225998Ch case    0:*/		return 0x82259990;
		  /* 82259990h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82259990h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82259990h case    1:*/		return 0x82259994;
		  /* 82259994h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82259994h case    2:*/		if ( regs.CR[6].eq ) { return 0x822599A0;  }
		/* 82259994h case    2:*/		return 0x82259998;
		  /* 82259998h */ case    3:  		/* li R4, 1 */
		/* 82259998h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82259998h case    3:*/		return 0x8225999C;
		  /* 8225999Ch */ case    4:  		/* bl -105988 */
		/* 8225999Ch case    4:*/		regs.LR = 0x822599A0; return 0x8223FB98;
		/* 8225999Ch case    4:*/		return 0x822599A0;
	}
	return 0x822599A0;
} // Block from 8225998Ch-822599A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822599A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822599A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822599A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822599A0);
		  /* 822599A0h */ case    0:  		/* lwz R3, <#[R31 + 88]> */
		/* 822599A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000058) );
		/* 822599A0h case    0:*/		return 0x822599A4;
		  /* 822599A4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 822599A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822599A4h case    1:*/		return 0x822599A8;
		  /* 822599A8h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 822599A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x822599B4;  }
		/* 822599A8h case    2:*/		return 0x822599AC;
		  /* 822599ACh */ case    3:  		/* li R4, 1 */
		/* 822599ACh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822599ACh case    3:*/		return 0x822599B0;
		  /* 822599B0h */ case    4:  		/* bl -106008 */
		/* 822599B0h case    4:*/		regs.LR = 0x822599B4; return 0x8223FB98;
		/* 822599B0h case    4:*/		return 0x822599B4;
	}
	return 0x822599B4;
} // Block from 822599A0h-822599B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822599B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822599B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822599B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822599B4);
		  /* 822599B4h */ case    0:  		/* lwz R3, <#[R31 + 92]> */
		/* 822599B4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000005C) );
		/* 822599B4h case    0:*/		return 0x822599B8;
		  /* 822599B8h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 822599B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822599B8h case    1:*/		return 0x822599BC;
		  /* 822599BCh */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 822599BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x822599C8;  }
		/* 822599BCh case    2:*/		return 0x822599C0;
		  /* 822599C0h */ case    3:  		/* li R4, 1 */
		/* 822599C0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822599C0h case    3:*/		return 0x822599C4;
		  /* 822599C4h */ case    4:  		/* bl -106028 */
		/* 822599C4h case    4:*/		regs.LR = 0x822599C8; return 0x8223FB98;
		/* 822599C4h case    4:*/		return 0x822599C8;
	}
	return 0x822599C8;
} // Block from 822599B4h-822599C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822599C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822599C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822599C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822599C8);
		  /* 822599C8h */ case    0:  		/* lwz R3, <#[R31 + 44]> */
		/* 822599C8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 822599C8h case    0:*/		return 0x822599CC;
		  /* 822599CCh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 822599CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822599CCh case    1:*/		return 0x822599D0;
		  /* 822599D0h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 822599D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x822599DC;  }
		/* 822599D0h case    2:*/		return 0x822599D4;
		  /* 822599D4h */ case    3:  		/* li R4, 1 */
		/* 822599D4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822599D4h case    3:*/		return 0x822599D8;
		  /* 822599D8h */ case    4:  		/* bl -106048 */
		/* 822599D8h case    4:*/		regs.LR = 0x822599DC; return 0x8223FB98;
		/* 822599D8h case    4:*/		return 0x822599DC;
	}
	return 0x822599DC;
} // Block from 822599C8h-822599DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822599DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822599DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822599DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822599DC);
		  /* 822599DCh */ case    0:  		/* addi R3, R31, 20 */
		/* 822599DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x14);
		/* 822599DCh case    0:*/		return 0x822599E0;
		  /* 822599E0h */ case    1:  		/* bl -24848 */
		/* 822599E0h case    1:*/		regs.LR = 0x822599E4; return 0x822538D0;
		/* 822599E0h case    1:*/		return 0x822599E4;
		  /* 822599E4h */ case    2:  		/* lis R11, -32252 */
		/* 822599E4h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822599E4h case    2:*/		return 0x822599E8;
		  /* 822599E8h */ case    3:  		/* addi R11, R11, 14380 */
		/* 822599E8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x382C);
		/* 822599E8h case    3:*/		return 0x822599EC;
		  /* 822599ECh */ case    4:  		/* stw R11, <#[R31 + 32]> */
		/* 822599ECh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 822599ECh case    4:*/		return 0x822599F0;
	}
	return 0x822599F0;
} // Block from 822599DCh-822599F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822599F0h
// Function '?Append@Block@XGRAPHICS@@QAAXAAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822599F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822599F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822599F0);
		  /* 822599F0h */ case    0:  		/* stw R11, <#[R31 + 20]> */
		/* 822599F0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 822599F0h case    0:*/		return 0x822599F4;
		  /* 822599F4h */ case    1:  		/* stw R11, <#[R31]> */
		/* 822599F4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822599F4h case    1:*/		return 0x822599F8;
		  /* 822599F8h */ case    2:  		/* addi R1, R1, 96 */
		/* 822599F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822599F8h case    2:*/		return 0x822599FC;
		  /* 822599FCh */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 822599FCh case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822599FCh case    3:*/		return 0x82259A00;
		  /* 82259A00h */ case    4:  		/* mtspr LR, R12 */
		/* 82259A00h case    4:*/		regs.LR = regs.R12;
		/* 82259A00h case    4:*/		return 0x82259A04;
		  /* 82259A04h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82259A04h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259A04h case    5:*/		return 0x82259A08;
		  /* 82259A08h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82259A08h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259A08h case    6:*/		return 0x82259A0C;
	}
	return 0x82259A0C;
} // Block from 822599F0h-82259A0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82259A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A0C);
		  /* 82259A0Ch */ case    0:  		/* nop */
		/* 82259A0Ch case    0:*/		cpu::op::nop();
		/* 82259A0Ch case    0:*/		return 0x82259A10;
	}
	return 0x82259A10;
} // Block from 82259A0Ch-82259A10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A10);
		  /* 82259A10h */ case    0:  		/* mfspr R12, LR */
		/* 82259A10h case    0:*/		regs.R12 = regs.LR;
		/* 82259A10h case    0:*/		return 0x82259A14;
		  /* 82259A14h */ case    1:  		/* bl -1869752 */
		/* 82259A14h case    1:*/		regs.LR = 0x82259A18; return 0x8209125C;
		/* 82259A14h case    1:*/		return 0x82259A18;
		  /* 82259A18h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82259A18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82259A18h case    2:*/		return 0x82259A1C;
		  /* 82259A1Ch */ case    3:  		/* mr R30, R3 */
		/* 82259A1Ch case    3:*/		regs.R30 = regs.R3;
		/* 82259A1Ch case    3:*/		return 0x82259A20;
		  /* 82259A20h */ case    4:  		/* lwz R3, <#[R3 + 56]> */
		/* 82259A20h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000038) );
		/* 82259A20h case    4:*/		return 0x82259A24;
		  /* 82259A24h */ case    5:  		/* mr R31, R4 */
		/* 82259A24h case    5:*/		regs.R31 = regs.R4;
		/* 82259A24h case    5:*/		return 0x82259A28;
		  /* 82259A28h */ case    6:  		/* mr R29, R5 */
		/* 82259A28h case    6:*/		regs.R29 = regs.R5;
		/* 82259A28h case    6:*/		return 0x82259A2C;
		  /* 82259A2Ch */ case    7:  		/* li R4, 0 */
		/* 82259A2Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82259A2Ch case    7:*/		return 0x82259A30;
		  /* 82259A30h */ case    8:  		/* li R10, 0 */
		/* 82259A30h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82259A30h case    8:*/		return 0x82259A34;
		  /* 82259A34h */ case    9:  		/* lwz R7, <#[R3 + 4]> */
		/* 82259A34h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 82259A34h case    9:*/		return 0x82259A38;
	}
	return 0x82259A38;
} // Block from 82259A10h-82259A38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82259A38h
// Function '?Insert@Block@XGRAPHICS@@QAAXAAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A38);
		  /* 82259A38h */ case    0:  		/* li R11, 0 */
		/* 82259A38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82259A38h case    0:*/		return 0x82259A3C;
		  /* 82259A3Ch */ case    1:  		/* li R9, 1 */
		/* 82259A3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82259A3Ch case    1:*/		return 0x82259A40;
		  /* 82259A40h */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 82259A40h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82259A40h case    2:*/		return 0x82259A44;
		  /* 82259A44h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82259A44h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82259A50;  }
		/* 82259A44h case    3:*/		return 0x82259A48;
		  /* 82259A48h */ case    4:  		/* li R8, 0 */
		/* 82259A48h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82259A48h case    4:*/		return 0x82259A4C;
		  /* 82259A4Ch */ case    5:  		/* b 16 */
		/* 82259A4Ch case    5:*/		return 0x82259A5C;
		/* 82259A4Ch case    5:*/		return 0x82259A50;
	}
	return 0x82259A50;
} // Block from 82259A38h-82259A50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A50);
		  /* 82259A50h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 82259A50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82259A50h case    0:*/		return 0x82259A54;
		  /* 82259A54h */ case    1:  		/* li R8, 1 */
		/* 82259A54h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82259A54h case    1:*/		return 0x82259A58;
		  /* 82259A58h */ case    2:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82259A58h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82259A58h case    2:*/		return 0x82259A5C;
	}
	return 0x82259A5C;
} // Block from 82259A50h-82259A5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A5C);
		  /* 82259A5Ch */ case    0:  		/* rlwinm. R8, R8, 0, 24, 31 */
		/* 82259A5Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R8);
		/* 82259A5Ch case    0:*/		return 0x82259A60;
		  /* 82259A60h */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 82259A60h case    1:*/		if ( regs.CR[0].eq ) { return 0x82259AA0;  }
		/* 82259A60h case    1:*/		return 0x82259A64;
		  /* 82259A64h */ case    2:  		/* cmplw CR6, R10, R31 */
		/* 82259A64h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82259A64h case    2:*/		return 0x82259A68;
		  /* 82259A68h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82259A68h case    3:*/		if ( regs.CR[6].eq ) { return 0x82259A7C;  }
		/* 82259A68h case    3:*/		return 0x82259A6C;
		  /* 82259A6Ch */ case    4:  		/* addi R4, R4, 1 */
		/* 82259A6Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82259A6Ch case    4:*/		return 0x82259A70;
		  /* 82259A70h */ case    5:  		/* addi R9, R9, 1 */
		/* 82259A70h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82259A70h case    5:*/		return 0x82259A74;
		  /* 82259A74h */ case    6:  		/* addi R11, R11, 4 */
		/* 82259A74h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82259A74h case    6:*/		return 0x82259A78;
		  /* 82259A78h */ case    7:  		/* b -56 */
		/* 82259A78h case    7:*/		return 0x82259A40;
		/* 82259A78h case    7:*/		return 0x82259A7C;
	}
	return 0x82259A7C;
} // Block from 82259A5Ch-82259A7Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82259A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A7C);
		  /* 82259A7Ch */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82259A7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82259A7Ch case    0:*/		return 0x82259A80;
	}
	return 0x82259A80;
} // Block from 82259A7Ch-82259A80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259A80h
// Function '?InsertAfter@Block@XGRAPHICS@@QAAXAAVIRInst@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A80);
		  /* 82259A80h */ case    0:  		/* cmplw CR6, R4, R11 */
		/* 82259A80h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82259A80h case    0:*/		return 0x82259A84;
		  /* 82259A84h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 82259A84h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82259A98;  }
		/* 82259A84h case    1:*/		return 0x82259A88;
		  /* 82259A88h */ case    2:  		/* lwz R10, <#[R3 + 8]> */
		/* 82259A88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82259A88h case    2:*/		return 0x82259A8C;
		  /* 82259A8Ch */ case    3:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82259A8Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82259A8Ch case    3:*/		return 0x82259A90;
		  /* 82259A90h */ case    4:  		/* add R3, R10, R11 */
		/* 82259A90h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82259A90h case    4:*/		return 0x82259A94;
		  /* 82259A94h */ case    5:  		/* b 8 */
		/* 82259A94h case    5:*/		return 0x82259A9C;
		/* 82259A94h case    5:*/		return 0x82259A98;
	}
	return 0x82259A98;
} // Block from 82259A80h-82259A98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A98);
		  /* 82259A98h */ case    0:  		/* bl -24536 */
		/* 82259A98h case    0:*/		regs.LR = 0x82259A9C; return 0x82253AC0;
		/* 82259A98h case    0:*/		return 0x82259A9C;
	}
	return 0x82259A9C;
} // Block from 82259A98h-82259A9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259A9C);
		  /* 82259A9Ch */ case    0:  		/* stw R29, <#[R3]> */
		/* 82259A9Ch case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82259A9Ch case    0:*/		return 0x82259AA0;
	}
	return 0x82259AA0;
} // Block from 82259A9Ch-82259AA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259AA0);
		  /* 82259AA0h */ case    0:  		/* lwz R3, <#[R31 + 60]> */
		/* 82259AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 82259AA0h case    0:*/		return 0x82259AA4;
		  /* 82259AA4h */ case    1:  		/* li R4, 0 */
		/* 82259AA4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82259AA4h case    1:*/		return 0x82259AA8;
		  /* 82259AA8h */ case    2:  		/* li R9, 0 */
		/* 82259AA8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82259AA8h case    2:*/		return 0x82259AAC;
		  /* 82259AACh */ case    3:  		/* li R11, 0 */
		/* 82259AACh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82259AACh case    3:*/		return 0x82259AB0;
		  /* 82259AB0h */ case    4:  		/* li R8, 1 */
		/* 82259AB0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82259AB0h case    4:*/		return 0x82259AB4;
		  /* 82259AB4h */ case    5:  		/* lwz R7, <#[R3 + 4]> */
		/* 82259AB4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 82259AB4h case    5:*/		return 0x82259AB8;
		  /* 82259AB8h */ case    6:  		/* cmplw CR6, R8, R7 */
		/* 82259AB8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82259AB8h case    6:*/		return 0x82259ABC;
		  /* 82259ABCh */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 82259ABCh case    7:*/		if ( !regs.CR[6].gt ) { return 0x82259AC8;  }
		/* 82259ABCh case    7:*/		return 0x82259AC0;
		  /* 82259AC0h */ case    8:  		/* li R10, 0 */
		/* 82259AC0h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82259AC0h case    8:*/		return 0x82259AC4;
		  /* 82259AC4h */ case    9:  		/* b 16 */
		/* 82259AC4h case    9:*/		return 0x82259AD4;
		/* 82259AC4h case    9:*/		return 0x82259AC8;
	}
	return 0x82259AC8;
} // Block from 82259AA0h-82259AC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82259AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259AC8);
		  /* 82259AC8h */ case    0:  		/* lwz R9, <#[R3 + 8]> */
		/* 82259AC8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82259AC8h case    0:*/		return 0x82259ACC;
		  /* 82259ACCh */ case    1:  		/* li R10, 1 */
		/* 82259ACCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82259ACCh case    1:*/		return 0x82259AD0;
		  /* 82259AD0h */ case    2:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82259AD0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82259AD0h case    2:*/		return 0x82259AD4;
	}
	return 0x82259AD4;
} // Block from 82259AC8h-82259AD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259AD4);
		  /* 82259AD4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82259AD4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82259AD4h case    0:*/		return 0x82259AD8;
		  /* 82259AD8h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 82259AD8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82259AF8;  }
		/* 82259AD8h case    1:*/		return 0x82259ADC;
		  /* 82259ADCh */ case    2:  		/* cmplw CR6, R9, R30 */
		/* 82259ADCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 82259ADCh case    2:*/		return 0x82259AE0;
	}
	return 0x82259AE0;
} // Block from 82259AD4h-82259AE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259AE0h
// Function '?InsertBefore@Block@XGRAPHICS@@QAAXAAVIRInst@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259AE0);
		  /* 82259AE0h */ case    0:  		/* bc 12, CR6_EQ, 20 */
		/* 82259AE0h case    0:*/		if ( regs.CR[6].eq ) { return 0x82259AF4;  }
		/* 82259AE0h case    0:*/		return 0x82259AE4;
		  /* 82259AE4h */ case    1:  		/* addi R4, R4, 1 */
		/* 82259AE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82259AE4h case    1:*/		return 0x82259AE8;
		  /* 82259AE8h */ case    2:  		/* addi R8, R8, 1 */
		/* 82259AE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82259AE8h case    2:*/		return 0x82259AEC;
		  /* 82259AECh */ case    3:  		/* addi R11, R11, 4 */
		/* 82259AECh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82259AECh case    3:*/		return 0x82259AF0;
		  /* 82259AF0h */ case    4:  		/* b -56 */
		/* 82259AF0h case    4:*/		return 0x82259AB8;
		/* 82259AF0h case    4:*/		return 0x82259AF4;
	}
	return 0x82259AF4;
} // Block from 82259AE0h-82259AF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82259AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259AF4);
		  /* 82259AF4h */ case    0:  		/* bl -24820 */
		/* 82259AF4h case    0:*/		regs.LR = 0x82259AF8; return 0x82253A00;
		/* 82259AF4h case    0:*/		return 0x82259AF8;
	}
	return 0x82259AF8;
} // Block from 82259AF4h-82259AF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259AF8);
		  /* 82259AF8h */ case    0:  		/* lwz R3, <#[R29 + 60]> */
		/* 82259AF8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000003C) );
		/* 82259AF8h case    0:*/		return 0x82259AFC;
		  /* 82259AFCh */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82259AFCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82259AFCh case    1:*/		return 0x82259B00;
		  /* 82259B00h */ case    2:  		/* bl -24640 */
		/* 82259B00h case    2:*/		regs.LR = 0x82259B04; return 0x82253AC0;
		/* 82259B00h case    2:*/		return 0x82259B04;
		  /* 82259B04h */ case    3:  		/* stw R30, <#[R3]> */
		/* 82259B04h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82259B04h case    3:*/		return 0x82259B08;
		  /* 82259B08h */ case    4:  		/* addi R1, R1, 112 */
		/* 82259B08h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259B08h case    4:*/		return 0x82259B0C;
		  /* 82259B0Ch */ case    5:  		/* b -1869920 */
		/* 82259B0Ch case    5:*/		return 0x820912AC;
		/* 82259B0Ch case    5:*/		return 0x82259B10;
	}
	return 0x82259B10;
} // Block from 82259AF8h-82259B10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259B10h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B10);
		  /* 82259B10h */ case    0:  		/* mfspr R12, LR */
		/* 82259B10h case    0:*/		regs.R12 = regs.LR;
		/* 82259B10h case    0:*/		return 0x82259B14;
		  /* 82259B14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259B14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259B14h case    1:*/		return 0x82259B18;
		  /* 82259B18h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82259B18h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259B18h case    2:*/		return 0x82259B1C;
		  /* 82259B1Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82259B1Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82259B1Ch case    3:*/		return 0x82259B20;
		  /* 82259B20h */ case    4:  		/* mr R31, R3 */
		/* 82259B20h case    4:*/		regs.R31 = regs.R3;
		/* 82259B20h case    4:*/		return 0x82259B24;
		  /* 82259B24h */ case    5:  		/* b 12 */
		/* 82259B24h case    5:*/		return 0x82259B30;
		/* 82259B24h case    5:*/		return 0x82259B28;
		  /* 82259B28h */ case    6:  		/* bl 4648 */
		/* 82259B28h case    6:*/		regs.LR = 0x82259B2C; return 0x8225AD50;
		/* 82259B28h case    6:*/		return 0x82259B2C;
		  /* 82259B2Ch */ case    7:  		/* bl -22652 */
		/* 82259B2Ch case    7:*/		regs.LR = 0x82259B30; return 0x822542B0;
		/* 82259B2Ch case    7:*/		return 0x82259B30;
	}
	return 0x82259B30;
} // Block from 82259B10h-82259B30h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82259B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B30);
		  /* 82259B30h */ case    0:  		/* lwz R3, <#[R31 + 44]> */
		/* 82259B30h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82259B30h case    0:*/		return 0x82259B34;
		  /* 82259B34h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 82259B34h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82259B34h case    1:*/		return 0x82259B38;
		  /* 82259B38h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82259B38h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82259B38h case    2:*/		return 0x82259B3C;
		  /* 82259B3Ch */ case    3:  		/* bc 4, CR6_EQ, -20 */
		/* 82259B3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82259B28;  }
		/* 82259B3Ch case    3:*/		return 0x82259B40;
	}
	return 0x82259B40;
} // Block from 82259B30h-82259B40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82259B40h
// Function '?InsertLoad@EntryBlock@XGRAPHICS@@UAAXAAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B40);
		  /* 82259B40h */ case    0:  		/* addi R1, R1, 96 */
		/* 82259B40h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82259B40h case    0:*/		return 0x82259B44;
		  /* 82259B44h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259B44h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259B44h case    1:*/		return 0x82259B48;
		  /* 82259B48h */ case    2:  		/* mtspr LR, R12 */
		/* 82259B48h case    2:*/		regs.LR = regs.R12;
		/* 82259B48h case    2:*/		return 0x82259B4C;
		  /* 82259B4Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82259B4Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259B4Ch case    3:*/		return 0x82259B50;
		  /* 82259B50h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82259B50h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259B50h case    4:*/		return 0x82259B54;
	}
	return 0x82259B54;
} // Block from 82259B40h-82259B54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82259B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B54);
		  /* 82259B54h */ case    0:  		/* nop */
		/* 82259B54h case    0:*/		cpu::op::nop();
		/* 82259B54h case    0:*/		return 0x82259B58;
	}
	return 0x82259B58;
} // Block from 82259B54h-82259B58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259B58h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B58);
		  /* 82259B58h */ case    0:  		/* mfspr R12, LR */
		/* 82259B58h case    0:*/		regs.R12 = regs.LR;
		/* 82259B58h case    0:*/		return 0x82259B5C;
		  /* 82259B5Ch */ case    1:  		/* bl -1870084 */
		/* 82259B5Ch case    1:*/		regs.LR = 0x82259B60; return 0x82091258;
		/* 82259B5Ch case    1:*/		return 0x82259B60;
		  /* 82259B60h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82259B60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82259B60h case    2:*/		return 0x82259B64;
		  /* 82259B64h */ case    3:  		/* stw R4, <#[R1 + 156]> */
		/* 82259B64h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000009C) );
		/* 82259B64h case    3:*/		return 0x82259B68;
		  /* 82259B68h */ case    4:  		/* mr R30, R3 */
		/* 82259B68h case    4:*/		regs.R30 = regs.R3;
		/* 82259B68h case    4:*/		return 0x82259B6C;
		  /* 82259B6Ch */ case    5:  		/* lwz R31, <#[R3 + 44]> */
		/* 82259B6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000002C) );
		/* 82259B6Ch case    5:*/		return 0x82259B70;
		  /* 82259B70h */ case    6:  		/* mr R29, R4 */
		/* 82259B70h case    6:*/		regs.R29 = regs.R4;
		/* 82259B70h case    6:*/		return 0x82259B74;
		  /* 82259B74h */ case    7:  		/* addi R4, R1, 156 */
		/* 82259B74h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x9C);
		/* 82259B74h case    7:*/		return 0x82259B78;
		  /* 82259B78h */ case    8:  		/* mr R3, R31 */
		/* 82259B78h case    8:*/		regs.R3 = regs.R31;
		/* 82259B78h case    8:*/		return 0x82259B7C;
		  /* 82259B7Ch */ case    9:  		/* mr R28, R5 */
		/* 82259B7Ch case    9:*/		regs.R28 = regs.R5;
		/* 82259B7Ch case    9:*/		return 0x82259B80;
		  /* 82259B80h */ case   10:  		/* bl -784 */
		/* 82259B80h case   10:*/		regs.LR = 0x82259B84; return 0x82259870;
		/* 82259B80h case   10:*/		return 0x82259B84;
		  /* 82259B84h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82259B84h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82259B84h case   11:*/		return 0x82259B88;
	}
	return 0x82259B88;
} // Block from 82259B58h-82259B88h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82259B88h
// Function '?Validate@Block@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B88);
		  /* 82259B88h */ case    0:  		/* bc 4, CR0_EQ, 20 */
		/* 82259B88h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82259B9C;  }
		/* 82259B88h case    0:*/		return 0x82259B8C;
		  /* 82259B8Ch */ case    1:  		/* mr R3, R31 */
		/* 82259B8Ch case    1:*/		regs.R3 = regs.R31;
		/* 82259B8Ch case    1:*/		return 0x82259B90;
		  /* 82259B90h */ case    2:  		/* lwz R4, <#[R31 + 4]> */
		/* 82259B90h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 82259B90h case    2:*/		return 0x82259B94;
		  /* 82259B94h */ case    3:  		/* bl -24788 */
		/* 82259B94h case    3:*/		regs.LR = 0x82259B98; return 0x82253AC0;
		/* 82259B94h case    3:*/		return 0x82259B98;
		  /* 82259B98h */ case    4:  		/* stw R29, <#[R3]> */
		/* 82259B98h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82259B98h case    4:*/		return 0x82259B9C;
	}
	return 0x82259B9C;
} // Block from 82259B88h-82259B9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82259B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259B9C);
		  /* 82259B9Ch */ case    0:  		/* mr R5, R28 */
		/* 82259B9Ch case    0:*/		regs.R5 = regs.R28;
		/* 82259B9Ch case    0:*/		return 0x82259BA0;
		  /* 82259BA0h */ case    1:  		/* lwz R4, <#[R30 + 48]> */
		/* 82259BA0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 82259BA0h case    1:*/		return 0x82259BA4;
		  /* 82259BA4h */ case    2:  		/* mr R3, R29 */
		/* 82259BA4h case    2:*/		regs.R3 = regs.R29;
		/* 82259BA4h case    2:*/		return 0x82259BA8;
		  /* 82259BA8h */ case    3:  		/* bl -22736 */
		/* 82259BA8h case    3:*/		regs.LR = 0x82259BAC; return 0x822542D8;
		/* 82259BA8h case    3:*/		return 0x82259BAC;
		  /* 82259BACh */ case    4:  		/* addi R1, R1, 128 */
		/* 82259BACh case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82259BACh case    4:*/		return 0x82259BB0;
		  /* 82259BB0h */ case    5:  		/* b -1870088 */
		/* 82259BB0h case    5:*/		return 0x820912A8;
		/* 82259BB0h case    5:*/		return 0x82259BB4;
		  /* 82259BB4h */ case    6:  		/* nop */
		/* 82259BB4h case    6:*/		cpu::op::nop();
		/* 82259BB4h case    6:*/		return 0x82259BB8;
	}
	return 0x82259BB8;
} // Block from 82259B9Ch-82259BB8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82259BB8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259BB8);
		  /* 82259BB8h */ case    0:  		/* mfspr R12, LR */
		/* 82259BB8h case    0:*/		regs.R12 = regs.LR;
		/* 82259BB8h case    0:*/		return 0x82259BBC;
		  /* 82259BBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259BBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259BBCh case    1:*/		return 0x82259BC0;
		  /* 82259BC0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82259BC0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259BC0h case    2:*/		return 0x82259BC4;
		  /* 82259BC4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82259BC4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82259BC4h case    3:*/		return 0x82259BC8;
		  /* 82259BC8h */ case    4:  		/* mr R31, R3 */
		/* 82259BC8h case    4:*/		regs.R31 = regs.R3;
		/* 82259BC8h case    4:*/		return 0x82259BCC;
		  /* 82259BCCh */ case    5:  		/* bl -2684 */
		/* 82259BCCh case    5:*/		regs.LR = 0x82259BD0; return 0x82259150;
		/* 82259BCCh case    5:*/		return 0x82259BD0;
		  /* 82259BD0h */ case    6:  		/* lis R11, -32251 */
		/* 82259BD0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259BD0h case    6:*/		return 0x82259BD4;
		  /* 82259BD4h */ case    7:  		/* mr R3, R31 */
		/* 82259BD4h case    7:*/		regs.R3 = regs.R31;
		/* 82259BD4h case    7:*/		return 0x82259BD8;
		  /* 82259BD8h */ case    8:  		/* addi R11, R11, -32268 */
		/* 82259BD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF81F4);
		/* 82259BD8h case    8:*/		return 0x82259BDC;
		  /* 82259BDCh */ case    9:  		/* stw R11, <#[R31]> */
		/* 82259BDCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259BDCh case    9:*/		return 0x82259BE0;
		  /* 82259BE0h */ case   10:  		/* lwz R11, <#[R31 + 112]> */
		/* 82259BE0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 82259BE0h case   10:*/		return 0x82259BE4;
		  /* 82259BE4h */ case   11:  		/* stw R11, <#[R31 + 136]> */
		/* 82259BE4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82259BE4h case   11:*/		return 0x82259BE8;
		  /* 82259BE8h */ case   12:  		/* addi R1, R1, 96 */
		/* 82259BE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82259BE8h case   12:*/		return 0x82259BEC;
		  /* 82259BECh */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259BECh case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259BECh case   13:*/		return 0x82259BF0;
		  /* 82259BF0h */ case   14:  		/* mtspr LR, R12 */
		/* 82259BF0h case   14:*/		regs.LR = regs.R12;
		/* 82259BF0h case   14:*/		return 0x82259BF4;
		  /* 82259BF4h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82259BF4h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259BF4h case   15:*/		return 0x82259BF8;
		  /* 82259BF8h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82259BF8h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259BF8h case   16:*/		return 0x82259BFC;
	}
	return 0x82259BFC;
} // Block from 82259BB8h-82259BFCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82259BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259BFC);
		  /* 82259BFCh */ case    0:  		/* nop */
		/* 82259BFCh case    0:*/		cpu::op::nop();
		/* 82259BFCh case    0:*/		return 0x82259C00;
	}
	return 0x82259C00;
} // Block from 82259BFCh-82259C00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C00);
		  /* 82259C00h */ case    0:  		/* lis R11, -32251 */
		/* 82259C00h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259C00h case    0:*/		return 0x82259C04;
		  /* 82259C04h */ case    1:  		/* addi R3, R11, -32220 */
		/* 82259C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8224);
		/* 82259C04h case    1:*/		return 0x82259C08;
		  /* 82259C08h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259C08h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259C08h case    2:*/		return 0x82259C0C;
	}
	return 0x82259C0C;
} // Block from 82259C00h-82259C0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C0C);
		  /* 82259C0Ch */ case    0:  		/* nop */
		/* 82259C0Ch case    0:*/		cpu::op::nop();
		/* 82259C0Ch case    0:*/		return 0x82259C10;
	}
	return 0x82259C10;
} // Block from 82259C0Ch-82259C10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259C10h
// Function '??0Block@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C10);
		  /* 82259C10h */ case    0:  		/* mfspr R12, LR */
		/* 82259C10h case    0:*/		regs.R12 = regs.LR;
		/* 82259C10h case    0:*/		return 0x82259C14;
		  /* 82259C14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259C14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259C14h case    1:*/		return 0x82259C18;
		  /* 82259C18h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82259C18h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259C18h case    2:*/		return 0x82259C1C;
		  /* 82259C1Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82259C1Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82259C1Ch case    3:*/		return 0x82259C20;
		  /* 82259C20h */ case    4:  		/* mr R31, R3 */
		/* 82259C20h case    4:*/		regs.R31 = regs.R3;
		/* 82259C20h case    4:*/		return 0x82259C24;
		  /* 82259C24h */ case    5:  		/* bl -2772 */
		/* 82259C24h case    5:*/		regs.LR = 0x82259C28; return 0x82259150;
		/* 82259C24h case    5:*/		return 0x82259C28;
		  /* 82259C28h */ case    6:  		/* lis R11, -32251 */
		/* 82259C28h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259C28h case    6:*/		return 0x82259C2C;
		  /* 82259C2Ch */ case    7:  		/* mr R3, R31 */
		/* 82259C2Ch case    7:*/		regs.R3 = regs.R31;
		/* 82259C2Ch case    7:*/		return 0x82259C30;
		  /* 82259C30h */ case    8:  		/* addi R11, R11, -32212 */
		/* 82259C30h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF822C);
		/* 82259C30h case    8:*/		return 0x82259C34;
		  /* 82259C34h */ case    9:  		/* stw R11, <#[R31]> */
		/* 82259C34h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259C34h case    9:*/		return 0x82259C38;
		  /* 82259C38h */ case   10:  		/* addi R1, R1, 96 */
		/* 82259C38h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82259C38h case   10:*/		return 0x82259C3C;
		  /* 82259C3Ch */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259C3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259C3Ch case   11:*/		return 0x82259C40;
		  /* 82259C40h */ case   12:  		/* mtspr LR, R12 */
		/* 82259C40h case   12:*/		regs.LR = regs.R12;
		/* 82259C40h case   12:*/		return 0x82259C44;
		  /* 82259C44h */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 82259C44h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259C44h case   13:*/		return 0x82259C48;
		  /* 82259C48h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82259C48h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259C48h case   14:*/		return 0x82259C4C;
	}
	return 0x82259C4C;
} // Block from 82259C10h-82259C4Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82259C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C4C);
		  /* 82259C4Ch */ case    0:  		/* nop */
		/* 82259C4Ch case    0:*/		cpu::op::nop();
		/* 82259C4Ch case    0:*/		return 0x82259C50;
	}
	return 0x82259C50;
} // Block from 82259C4Ch-82259C50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C50);
		  /* 82259C50h */ case    0:  		/* lis R11, -32251 */
		/* 82259C50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259C50h case    0:*/		return 0x82259C54;
		  /* 82259C54h */ case    1:  		/* addi R3, R11, -32164 */
		/* 82259C54h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF825C);
		/* 82259C54h case    1:*/		return 0x82259C58;
		  /* 82259C58h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259C58h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259C58h case    2:*/		return 0x82259C5C;
	}
	return 0x82259C5C;
} // Block from 82259C50h-82259C5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C5C);
		  /* 82259C5Ch */ case    0:  		/* nop */
		/* 82259C5Ch case    0:*/		cpu::op::nop();
		/* 82259C5Ch case    0:*/		return 0x82259C60;
	}
	return 0x82259C60;
} // Block from 82259C5Ch-82259C60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259C60);
		  /* 82259C60h */ case    0:  		/* mfspr R12, LR */
		/* 82259C60h case    0:*/		regs.R12 = regs.LR;
		/* 82259C60h case    0:*/		return 0x82259C64;
		  /* 82259C64h */ case    1:  		/* bl -1870348 */
		/* 82259C64h case    1:*/		regs.LR = 0x82259C68; return 0x82091258;
		/* 82259C64h case    1:*/		return 0x82259C68;
		  /* 82259C68h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82259C68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82259C68h case    2:*/		return 0x82259C6C;
		  /* 82259C6Ch */ case    3:  		/* mr R31, R3 */
		/* 82259C6Ch case    3:*/		regs.R31 = regs.R3;
		/* 82259C6Ch case    3:*/		return 0x82259C70;
		  /* 82259C70h */ case    4:  		/* mr R29, R4 */
		/* 82259C70h case    4:*/		regs.R29 = regs.R4;
		/* 82259C70h case    4:*/		return 0x82259C74;
		  /* 82259C74h */ case    5:  		/* bl -2852 */
		/* 82259C74h case    5:*/		regs.LR = 0x82259C78; return 0x82259150;
		/* 82259C74h case    5:*/		return 0x82259C78;
		  /* 82259C78h */ case    6:  		/* lis R11, -32251 */
		/* 82259C78h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259C78h case    6:*/		return 0x82259C7C;
		  /* 82259C7Ch */ case    7:  		/* li R30, 0 */
		/* 82259C7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82259C7Ch case    7:*/		return 0x82259C80;
		  /* 82259C80h */ case    8:  		/* addi R11, R11, -32156 */
		/* 82259C80h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8264);
		/* 82259C80h case    8:*/		return 0x82259C84;
		  /* 82259C84h */ case    9:  		/* li R10, 1 */
		/* 82259C84h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82259C84h case    9:*/		return 0x82259C88;
		  /* 82259C88h */ case   10:  		/* stw R30, <#[R31 + 136]> */
		/* 82259C88h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 82259C88h case   10:*/		return 0x82259C8C;
		  /* 82259C8Ch */ case   11:  		/* stw R11, <#[R31]> */
		/* 82259C8Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259C8Ch case   11:*/		return 0x82259C90;
		  /* 82259C90h */ case   12:  		/* li R4, 140 */
		/* 82259C90h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x8C);
		/* 82259C90h case   12:*/		return 0x82259C94;
		  /* 82259C94h */ case   13:  		/* stb R10, <#[R31 + 140]> */
		/* 82259C94h case   13:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 82259C94h case   13:*/		return 0x82259C98;
		  /* 82259C98h */ case   14:  		/* stw R30, <#[R31 + 144]> */
		/* 82259C98h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000090) );
		/* 82259C98h case   14:*/		return 0x82259C9C;
		  /* 82259C9Ch */ case   15:  		/* stw R30, <#[R31 + 148]> */
		/* 82259C9Ch case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000094) );
		/* 82259C9Ch case   15:*/		return 0x82259CA0;
		  /* 82259CA0h */ case   16:  		/* stw R30, <#[R31 + 156]> */
		/* 82259CA0h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000009C) );
		/* 82259CA0h case   16:*/		return 0x82259CA4;
		  /* 82259CA4h */ case   17:  		/* lwz R28, <#[R29 + 1452]> */
		/* 82259CA4h case   17:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x000005AC) );
		/* 82259CA4h case   17:*/		return 0x82259CA8;
		  /* 82259CA8h */ case   18:  		/* mr R3, R28 */
		/* 82259CA8h case   18:*/		regs.R3 = regs.R28;
		/* 82259CA8h case   18:*/		return 0x82259CAC;
		  /* 82259CACh */ case   19:  		/* bl -251892 */
		/* 82259CACh case   19:*/		regs.LR = 0x82259CB0; return 0x8221C4B8;
		/* 82259CACh case   19:*/		return 0x82259CB0;
		  /* 82259CB0h */ case   20:  		/* mr R11, R3 */
		/* 82259CB0h case   20:*/		regs.R11 = regs.R3;
		/* 82259CB0h case   20:*/		return 0x82259CB4;
		  /* 82259CB4h */ case   21:  		/* addic. R3, R3, 4 */
		/* 82259CB4h case   21:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82259CB4h case   21:*/		return 0x82259CB8;
		  /* 82259CB8h */ case   22:  		/* stw R28, <#[R11]> */
		/* 82259CB8h case   22:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82259CB8h case   22:*/		return 0x82259CBC;
		  /* 82259CBCh */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 82259CBCh case   23:*/		if ( regs.CR[0].eq ) { return 0x82259CD0;  }
		/* 82259CBCh case   23:*/		return 0x82259CC0;
		  /* 82259CC0h */ case   24:  		/* mr R4, R29 */
		/* 82259CC0h case   24:*/		regs.R4 = regs.R29;
		/* 82259CC0h case   24:*/		return 0x82259CC4;
		  /* 82259CC4h */ case   25:  		/* bl -2932 */
		/* 82259CC4h case   25:*/		regs.LR = 0x82259CC8; return 0x82259150;
		/* 82259CC4h case   25:*/		return 0x82259CC8;
		  /* 82259CC8h */ case   26:  		/* mr R4, R3 */
		/* 82259CC8h case   26:*/		regs.R4 = regs.R3;
		/* 82259CC8h case   26:*/		return 0x82259CCC;
		  /* 82259CCCh */ case   27:  		/* b 8 */
		/* 82259CCCh case   27:*/		return 0x82259CD4;
		/* 82259CCCh case   27:*/		return 0x82259CD0;
	}
	return 0x82259CD0;
} // Block from 82259C60h-82259CD0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82259CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259CD0);
		  /* 82259CD0h */ case    0:  		/* mr R4, R30 */
		/* 82259CD0h case    0:*/		regs.R4 = regs.R30;
		/* 82259CD0h case    0:*/		return 0x82259CD4;
	}
	return 0x82259CD4;
} // Block from 82259CD0h-82259CD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259CD4);
		  /* 82259CD4h */ case    0:  		/* stw R4, <#[R31 + 144]> */
		/* 82259CD4h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000090) );
		/* 82259CD4h case    0:*/		return 0x82259CD8;
		  /* 82259CD8h */ case    1:  		/* mr R3, R31 */
		/* 82259CD8h case    1:*/		regs.R3 = regs.R31;
		/* 82259CD8h case    1:*/		return 0x82259CDC;
		  /* 82259CDCh */ case    2:  		/* bl -1036 */
		/* 82259CDCh case    2:*/		regs.LR = 0x82259CE0; return 0x822598D0;
		/* 82259CDCh case    2:*/		return 0x82259CE0;
		  /* 82259CE0h */ case    3:  		/* mr R3, R31 */
		/* 82259CE0h case    3:*/		regs.R3 = regs.R31;
		/* 82259CE0h case    3:*/		return 0x82259CE4;
		  /* 82259CE4h */ case    4:  		/* addi R1, R1, 128 */
		/* 82259CE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82259CE4h case    4:*/		return 0x82259CE8;
		  /* 82259CE8h */ case    5:  		/* b -1870400 */
		/* 82259CE8h case    5:*/		return 0x820912A8;
		/* 82259CE8h case    5:*/		return 0x82259CEC;
		  /* 82259CECh */ case    6:  		/* nop */
		/* 82259CECh case    6:*/		cpu::op::nop();
		/* 82259CECh case    6:*/		return 0x82259CF0;
	}
	return 0x82259CF0;
} // Block from 82259CD4h-82259CF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82259CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259CF0);
		  /* 82259CF0h */ case    0:  		/* lis R11, -32251 */
		/* 82259CF0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259CF0h case    0:*/		return 0x82259CF4;
		  /* 82259CF4h */ case    1:  		/* addi R3, R11, -32104 */
		/* 82259CF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8298);
		/* 82259CF4h case    1:*/		return 0x82259CF8;
		  /* 82259CF8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259CF8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259CF8h case    2:*/		return 0x82259CFC;
	}
	return 0x82259CFC;
} // Block from 82259CF0h-82259CFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259CFC);
		  /* 82259CFCh */ case    0:  		/* nop */
		/* 82259CFCh case    0:*/		cpu::op::nop();
		/* 82259CFCh case    0:*/		return 0x82259D00;
	}
	return 0x82259D00;
} // Block from 82259CFCh-82259D00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259D00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259D00);
		  /* 82259D00h */ case    0:  		/* li R3, 0 */
		/* 82259D00h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82259D00h case    0:*/		return 0x82259D04;
		  /* 82259D04h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82259D04h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259D04h case    1:*/		return 0x82259D08;
	}
	return 0x82259D08;
} // Block from 82259D00h-82259D08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259D08);
		  /* 82259D08h */ case    0:  		/* mfspr R12, LR */
		/* 82259D08h case    0:*/		regs.R12 = regs.LR;
		/* 82259D08h case    0:*/		return 0x82259D0C;
		  /* 82259D0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259D0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259D0Ch case    1:*/		return 0x82259D10;
		  /* 82259D10h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82259D10h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259D10h case    2:*/		return 0x82259D14;
		  /* 82259D14h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82259D14h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259D14h case    3:*/		return 0x82259D18;
		  /* 82259D18h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82259D18h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82259D18h case    4:*/		return 0x82259D1C;
		  /* 82259D1Ch */ case    5:  		/* mr R30, R4 */
		/* 82259D1Ch case    5:*/		regs.R30 = regs.R4;
		/* 82259D1Ch case    5:*/		return 0x82259D20;
		  /* 82259D20h */ case    6:  		/* mr R4, R5 */
		/* 82259D20h case    6:*/		regs.R4 = regs.R5;
		/* 82259D20h case    6:*/		return 0x82259D24;
		  /* 82259D24h */ case    7:  		/* mr R31, R3 */
		/* 82259D24h case    7:*/		regs.R31 = regs.R3;
		/* 82259D24h case    7:*/		return 0x82259D28;
		  /* 82259D28h */ case    8:  		/* bl -3032 */
		/* 82259D28h case    8:*/		regs.LR = 0x82259D2C; return 0x82259150;
		/* 82259D28h case    8:*/		return 0x82259D2C;
		  /* 82259D2Ch */ case    9:  		/* lis R11, -32251 */
		/* 82259D2Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259D2Ch case    9:*/		return 0x82259D30;
		  /* 82259D30h */ case   10:  		/* stw R30, <#[R31 + 136]> */
		/* 82259D30h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 82259D30h case   10:*/		return 0x82259D34;
		  /* 82259D34h */ case   11:  		/* mr R3, R31 */
		/* 82259D34h case   11:*/		regs.R3 = regs.R31;
		/* 82259D34h case   11:*/		return 0x82259D38;
		  /* 82259D38h */ case   12:  		/* addi R11, R11, -32092 */
		/* 82259D38h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF82A4);
		/* 82259D38h case   12:*/		return 0x82259D3C;
		  /* 82259D3Ch */ case   13:  		/* stw R11, <#[R31]> */
		/* 82259D3Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259D3Ch case   13:*/		return 0x82259D40;
		  /* 82259D40h */ case   14:  		/* addi R1, R1, 112 */
		/* 82259D40h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259D40h case   14:*/		return 0x82259D44;
		  /* 82259D44h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259D44h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259D44h case   15:*/		return 0x82259D48;
		  /* 82259D48h */ case   16:  		/* mtspr LR, R12 */
		/* 82259D48h case   16:*/		regs.LR = regs.R12;
		/* 82259D48h case   16:*/		return 0x82259D4C;
		  /* 82259D4Ch */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 82259D4Ch case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259D4Ch case   17:*/		return 0x82259D50;
		  /* 82259D50h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 82259D50h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259D50h case   18:*/		return 0x82259D54;
		  /* 82259D54h */ case   19:  		/* bclr 20, CR0_LT */
		/* 82259D54h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259D54h case   19:*/		return 0x82259D58;
	}
	return 0x82259D58;
} // Block from 82259D08h-82259D58h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82259D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259D58);
		  /* 82259D58h */ case    0:  		/* lis R11, -32251 */
		/* 82259D58h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259D58h case    0:*/		return 0x82259D5C;
		  /* 82259D5Ch */ case    1:  		/* addi R3, R11, -32044 */
		/* 82259D5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF82D4);
		/* 82259D5Ch case    1:*/		return 0x82259D60;
		  /* 82259D60h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259D60h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259D60h case    2:*/		return 0x82259D64;
	}
	return 0x82259D64;
} // Block from 82259D58h-82259D64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259D64);
		  /* 82259D64h */ case    0:  		/* nop */
		/* 82259D64h case    0:*/		cpu::op::nop();
		/* 82259D64h case    0:*/		return 0x82259D68;
	}
	return 0x82259D68;
} // Block from 82259D64h-82259D68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259D68);
		  /* 82259D68h */ case    0:  		/* mfspr R12, LR */
		/* 82259D68h case    0:*/		regs.R12 = regs.LR;
		/* 82259D68h case    0:*/		return 0x82259D6C;
		  /* 82259D6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259D6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259D6Ch case    1:*/		return 0x82259D70;
		  /* 82259D70h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82259D70h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259D70h case    2:*/		return 0x82259D74;
		  /* 82259D74h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82259D74h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259D74h case    3:*/		return 0x82259D78;
		  /* 82259D78h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82259D78h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82259D78h case    4:*/		return 0x82259D7C;
		  /* 82259D7Ch */ case    5:  		/* mr R30, R4 */
		/* 82259D7Ch case    5:*/		regs.R30 = regs.R4;
		/* 82259D7Ch case    5:*/		return 0x82259D80;
		  /* 82259D80h */ case    6:  		/* mr R4, R5 */
		/* 82259D80h case    6:*/		regs.R4 = regs.R5;
		/* 82259D80h case    6:*/		return 0x82259D84;
		  /* 82259D84h */ case    7:  		/* mr R31, R3 */
		/* 82259D84h case    7:*/		regs.R31 = regs.R3;
		/* 82259D84h case    7:*/		return 0x82259D88;
		  /* 82259D88h */ case    8:  		/* bl -3128 */
		/* 82259D88h case    8:*/		regs.LR = 0x82259D8C; return 0x82259150;
		/* 82259D88h case    8:*/		return 0x82259D8C;
		  /* 82259D8Ch */ case    9:  		/* lis R11, -32251 */
		/* 82259D8Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259D8Ch case    9:*/		return 0x82259D90;
		  /* 82259D90h */ case   10:  		/* stw R30, <#[R31 + 136]> */
		/* 82259D90h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 82259D90h case   10:*/		return 0x82259D94;
		  /* 82259D94h */ case   11:  		/* mr R3, R31 */
		/* 82259D94h case   11:*/		regs.R3 = regs.R31;
		/* 82259D94h case   11:*/		return 0x82259D98;
		  /* 82259D98h */ case   12:  		/* addi R11, R11, -32036 */
		/* 82259D98h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF82DC);
		/* 82259D98h case   12:*/		return 0x82259D9C;
		  /* 82259D9Ch */ case   13:  		/* stw R11, <#[R31]> */
		/* 82259D9Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259D9Ch case   13:*/		return 0x82259DA0;
		  /* 82259DA0h */ case   14:  		/* addi R1, R1, 112 */
		/* 82259DA0h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259DA0h case   14:*/		return 0x82259DA4;
		  /* 82259DA4h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259DA4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259DA4h case   15:*/		return 0x82259DA8;
		  /* 82259DA8h */ case   16:  		/* mtspr LR, R12 */
		/* 82259DA8h case   16:*/		regs.LR = regs.R12;
		/* 82259DA8h case   16:*/		return 0x82259DAC;
		  /* 82259DACh */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 82259DACh case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259DACh case   17:*/		return 0x82259DB0;
		  /* 82259DB0h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 82259DB0h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259DB0h case   18:*/		return 0x82259DB4;
		  /* 82259DB4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 82259DB4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259DB4h case   19:*/		return 0x82259DB8;
	}
	return 0x82259DB8;
} // Block from 82259D68h-82259DB8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82259DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DB8);
		  /* 82259DB8h */ case    0:  		/* lis R11, -32251 */
		/* 82259DB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259DB8h case    0:*/		return 0x82259DBC;
		  /* 82259DBCh */ case    1:  		/* addi R3, R11, -31988 */
		/* 82259DBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF830C);
		/* 82259DBCh case    1:*/		return 0x82259DC0;
		  /* 82259DC0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259DC0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259DC0h case    2:*/		return 0x82259DC4;
	}
	return 0x82259DC4;
} // Block from 82259DB8h-82259DC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DC4);
		  /* 82259DC4h */ case    0:  		/* nop */
		/* 82259DC4h case    0:*/		cpu::op::nop();
		/* 82259DC4h case    0:*/		return 0x82259DC8;
	}
	return 0x82259DC8;
} // Block from 82259DC4h-82259DC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DC8);
		  /* 82259DC8h */ case    0:  		/* lis R11, -32251 */
		/* 82259DC8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259DC8h case    0:*/		return 0x82259DCC;
		  /* 82259DCCh */ case    1:  		/* addi R3, R11, -31928 */
		/* 82259DCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8348);
		/* 82259DCCh case    1:*/		return 0x82259DD0;
		  /* 82259DD0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259DD0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259DD0h case    2:*/		return 0x82259DD4;
	}
	return 0x82259DD4;
} // Block from 82259DC8h-82259DD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DD4);
		  /* 82259DD4h */ case    0:  		/* nop */
		/* 82259DD4h case    0:*/		cpu::op::nop();
		/* 82259DD4h case    0:*/		return 0x82259DD8;
	}
	return 0x82259DD8;
} // Block from 82259DD4h-82259DD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DD8);
		  /* 82259DD8h */ case    0:  		/* lis R11, -32251 */
		/* 82259DD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259DD8h case    0:*/		return 0x82259DDC;
		  /* 82259DDCh */ case    1:  		/* addi R3, R11, -31868 */
		/* 82259DDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8384);
		/* 82259DDCh case    1:*/		return 0x82259DE0;
		  /* 82259DE0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259DE0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259DE0h case    2:*/		return 0x82259DE4;
	}
	return 0x82259DE4;
} // Block from 82259DD8h-82259DE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DE4);
		  /* 82259DE4h */ case    0:  		/* nop */
		/* 82259DE4h case    0:*/		cpu::op::nop();
		/* 82259DE4h case    0:*/		return 0x82259DE8;
	}
	return 0x82259DE8;
} // Block from 82259DE4h-82259DE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DE8);
		  /* 82259DE8h */ case    0:  		/* lis R11, -32251 */
		/* 82259DE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259DE8h case    0:*/		return 0x82259DEC;
		  /* 82259DECh */ case    1:  		/* addi R3, R11, -31800 */
		/* 82259DECh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF83C8);
		/* 82259DECh case    1:*/		return 0x82259DF0;
		  /* 82259DF0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259DF0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259DF0h case    2:*/		return 0x82259DF4;
	}
	return 0x82259DF4;
} // Block from 82259DE8h-82259DF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DF4);
		  /* 82259DF4h */ case    0:  		/* nop */
		/* 82259DF4h case    0:*/		cpu::op::nop();
		/* 82259DF4h case    0:*/		return 0x82259DF8;
	}
	return 0x82259DF8;
} // Block from 82259DF4h-82259DF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259DF8);
		  /* 82259DF8h */ case    0:  		/* lis R11, -32251 */
		/* 82259DF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259DF8h case    0:*/		return 0x82259DFC;
		  /* 82259DFCh */ case    1:  		/* addi R3, R11, -31740 */
		/* 82259DFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8404);
		/* 82259DFCh case    1:*/		return 0x82259E00;
		  /* 82259E00h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82259E00h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259E00h case    2:*/		return 0x82259E04;
	}
	return 0x82259E04;
} // Block from 82259DF8h-82259E04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259E04);
		  /* 82259E04h */ case    0:  		/* nop */
		/* 82259E04h case    0:*/		cpu::op::nop();
		/* 82259E04h case    0:*/		return 0x82259E08;
	}
	return 0x82259E08;
} // Block from 82259E04h-82259E08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259E08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259E08);
		  /* 82259E08h */ case    0:  		/* mfspr R12, LR */
		/* 82259E08h case    0:*/		regs.R12 = regs.LR;
		/* 82259E08h case    0:*/		return 0x82259E0C;
		  /* 82259E0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82259E0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259E0Ch case    1:*/		return 0x82259E10;
		  /* 82259E10h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82259E10h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259E10h case    2:*/		return 0x82259E14;
		  /* 82259E14h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82259E14h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259E14h case    3:*/		return 0x82259E18;
		  /* 82259E18h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82259E18h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82259E18h case    4:*/		return 0x82259E1C;
		  /* 82259E1Ch */ case    5:  		/* mr R31, R4 */
		/* 82259E1Ch case    5:*/		regs.R31 = regs.R4;
		/* 82259E1Ch case    5:*/		return 0x82259E20;
		  /* 82259E20h */ case    6:  		/* mr R30, R6 */
		/* 82259E20h case    6:*/		regs.R30 = regs.R6;
		/* 82259E20h case    6:*/		return 0x82259E24;
		  /* 82259E24h */ case    7:  		/* bl -1044 */
		/* 82259E24h case    7:*/		regs.LR = 0x82259E28; return 0x82259A10;
		/* 82259E24h case    7:*/		return 0x82259E28;
		  /* 82259E28h */ case    8:  		/* mr R4, R31 */
		/* 82259E28h case    8:*/		regs.R4 = regs.R31;
		/* 82259E28h case    8:*/		return 0x82259E2C;
		  /* 82259E2Ch */ case    9:  		/* mr R3, R30 */
		/* 82259E2Ch case    9:*/		regs.R3 = regs.R30;
		/* 82259E2Ch case    9:*/		return 0x82259E30;
		  /* 82259E30h */ case   10:  		/* bl -1376 */
		/* 82259E30h case   10:*/		regs.LR = 0x82259E34; return 0x822598D0;
		/* 82259E30h case   10:*/		return 0x82259E34;
		  /* 82259E34h */ case   11:  		/* addi R1, R1, 112 */
		/* 82259E34h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82259E34h case   11:*/		return 0x82259E38;
		  /* 82259E38h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 82259E38h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82259E38h case   12:*/		return 0x82259E3C;
		  /* 82259E3Ch */ case   13:  		/* mtspr LR, R12 */
		/* 82259E3Ch case   13:*/		regs.LR = regs.R12;
		/* 82259E3Ch case   13:*/		return 0x82259E40;
		  /* 82259E40h */ case   14:  		/* ld R30, <#[R1 - 24]> */
		/* 82259E40h case   14:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82259E40h case   14:*/		return 0x82259E44;
		  /* 82259E44h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82259E44h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82259E44h case   15:*/		return 0x82259E48;
		  /* 82259E48h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82259E48h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259E48h case   16:*/		return 0x82259E4C;
	}
	return 0x82259E4C;
} // Block from 82259E08h-82259E4Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82259E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259E4C);
		  /* 82259E4Ch */ case    0:  		/* nop */
		/* 82259E4Ch case    0:*/		cpu::op::nop();
		/* 82259E4Ch case    0:*/		return 0x82259E50;
	}
	return 0x82259E50;
} // Block from 82259E4Ch-82259E50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259E50);
		  /* 82259E50h */ case    0:  		/* mfspr R12, LR */
		/* 82259E50h case    0:*/		regs.R12 = regs.LR;
		/* 82259E50h case    0:*/		return 0x82259E54;
		  /* 82259E54h */ case    1:  		/* bl -1870848 */
		/* 82259E54h case    1:*/		regs.LR = 0x82259E58; return 0x82091254;
		/* 82259E54h case    1:*/		return 0x82259E58;
		  /* 82259E58h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82259E58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82259E58h case    2:*/		return 0x82259E5C;
		  /* 82259E5Ch */ case    3:  		/* mr R30, R4 */
		/* 82259E5Ch case    3:*/		regs.R30 = regs.R4;
		/* 82259E5Ch case    3:*/		return 0x82259E60;
		  /* 82259E60h */ case    4:  		/* mr R4, R6 */
		/* 82259E60h case    4:*/		regs.R4 = regs.R6;
		/* 82259E60h case    4:*/		return 0x82259E64;
		  /* 82259E64h */ case    5:  		/* mr R31, R3 */
		/* 82259E64h case    5:*/		regs.R31 = regs.R3;
		/* 82259E64h case    5:*/		return 0x82259E68;
		  /* 82259E68h */ case    6:  		/* mr R27, R5 */
		/* 82259E68h case    6:*/		regs.R27 = regs.R5;
		/* 82259E68h case    6:*/		return 0x82259E6C;
		  /* 82259E6Ch */ case    7:  		/* mr R29, R6 */
		/* 82259E6Ch case    7:*/		regs.R29 = regs.R6;
		/* 82259E6Ch case    7:*/		return 0x82259E70;
	}
	return 0x82259E70;
} // Block from 82259E50h-82259E70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82259E70h
// Function '?TypeName@Block@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259E70);
		  /* 82259E70h */ case    0:  		/* bl -3360 */
		/* 82259E70h case    0:*/		regs.LR = 0x82259E74; return 0x82259150;
		/* 82259E70h case    0:*/		return 0x82259E74;
		  /* 82259E74h */ case    1:  		/* lis R11, -32251 */
		/* 82259E74h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259E74h case    1:*/		return 0x82259E78;
		  /* 82259E78h */ case    2:  		/* stw R27, <#[R31 + 148]> */
		/* 82259E78h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000094) );
		/* 82259E78h case    2:*/		return 0x82259E7C;
		  /* 82259E7Ch */ case    3:  		/* li R28, 0 */
		/* 82259E7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82259E7Ch case    3:*/		return 0x82259E80;
	}
	return 0x82259E80;
} // Block from 82259E70h-82259E80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82259E80h
// Function '?WhichPredecessor@Block@XGRAPHICS@@QAAHPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259E80);
		  /* 82259E80h */ case    0:  		/* stw R30, <#[R31 + 136]> */
		/* 82259E80h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 82259E80h case    0:*/		return 0x82259E84;
		  /* 82259E84h */ case    1:  		/* addi R11, R11, -31728 */
		/* 82259E84h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8410);
		/* 82259E84h case    1:*/		return 0x82259E88;
		  /* 82259E88h */ case    2:  		/* stb R28, <#[R31 + 140]> */
		/* 82259E88h case    2:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x0000008C) );
		/* 82259E88h case    2:*/		return 0x82259E8C;
		  /* 82259E8Ch */ case    3:  		/* li R4, 144 */
		/* 82259E8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x90);
		/* 82259E8Ch case    3:*/		return 0x82259E90;
		  /* 82259E90h */ case    4:  		/* stw R11, <#[R31]> */
		/* 82259E90h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259E90h case    4:*/		return 0x82259E94;
		  /* 82259E94h */ case    5:  		/* stb R28, <#[R31 + 141]> */
		/* 82259E94h case    5:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R31 + 0x0000008D) );
		/* 82259E94h case    5:*/		return 0x82259E98;
		  /* 82259E98h */ case    6:  		/* lwz R27, <#[R29 + 1452]> */
		/* 82259E98h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x000005AC) );
		/* 82259E98h case    6:*/		return 0x82259E9C;
		  /* 82259E9Ch */ case    7:  		/* mr R3, R27 */
		/* 82259E9Ch case    7:*/		regs.R3 = regs.R27;
		/* 82259E9Ch case    7:*/		return 0x82259EA0;
		  /* 82259EA0h */ case    8:  		/* bl -252392 */
		/* 82259EA0h case    8:*/		regs.LR = 0x82259EA4; return 0x8221C4B8;
		/* 82259EA0h case    8:*/		return 0x82259EA4;
		  /* 82259EA4h */ case    9:  		/* addic. R30, R3, 4 */
		/* 82259EA4h case    9:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82259EA4h case    9:*/		return 0x82259EA8;
		  /* 82259EA8h */ case   10:  		/* stw R27, <#[R3]> */
		/* 82259EA8h case   10:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82259EA8h case   10:*/		return 0x82259EAC;
		  /* 82259EACh */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 82259EACh case   11:*/		if ( regs.CR[0].eq ) { return 0x82259ED4;  }
		/* 82259EACh case   11:*/		return 0x82259EB0;
		  /* 82259EB0h */ case   12:  		/* mr R4, R29 */
		/* 82259EB0h case   12:*/		regs.R4 = regs.R29;
		/* 82259EB0h case   12:*/		return 0x82259EB4;
		  /* 82259EB4h */ case   13:  		/* mr R3, R30 */
		/* 82259EB4h case   13:*/		regs.R3 = regs.R30;
		/* 82259EB4h case   13:*/		return 0x82259EB8;
		  /* 82259EB8h */ case   14:  		/* bl -3432 */
		/* 82259EB8h case   14:*/		regs.LR = 0x82259EBC; return 0x82259150;
		/* 82259EB8h case   14:*/		return 0x82259EBC;
		  /* 82259EBCh */ case   15:  		/* lis R10, -32251 */
		/* 82259EBCh case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82259EBCh case   15:*/		return 0x82259EC0;
		  /* 82259EC0h */ case   16:  		/* stw R31, <#[R30 + 136]> */
		/* 82259EC0h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000088) );
		/* 82259EC0h case   16:*/		return 0x82259EC4;
		  /* 82259EC4h */ case   17:  		/* mr R11, R30 */
		/* 82259EC4h case   17:*/		regs.R11 = regs.R30;
		/* 82259EC4h case   17:*/		return 0x82259EC8;
		  /* 82259EC8h */ case   18:  		/* addi R10, R10, -31976 */
		/* 82259EC8h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF8318);
		/* 82259EC8h case   18:*/		return 0x82259ECC;
		  /* 82259ECCh */ case   19:  		/* stw R10, <#[R30]> */
		/* 82259ECCh case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82259ECCh case   19:*/		return 0x82259ED0;
		  /* 82259ED0h */ case   20:  		/* b 8 */
		/* 82259ED0h case   20:*/		return 0x82259ED8;
		/* 82259ED0h case   20:*/		return 0x82259ED4;
	}
	return 0x82259ED4;
} // Block from 82259E80h-82259ED4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82259ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259ED4);
		  /* 82259ED4h */ case    0:  		/* mr R11, R28 */
		/* 82259ED4h case    0:*/		regs.R11 = regs.R28;
		/* 82259ED4h case    0:*/		return 0x82259ED8;
	}
	return 0x82259ED8;
} // Block from 82259ED4h-82259ED8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259ED8);
		  /* 82259ED8h */ case    0:  		/* stw R11, <#[R31 + 152]> */
		/* 82259ED8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 82259ED8h case    0:*/		return 0x82259EDC;
		  /* 82259EDCh */ case    1:  		/* li R4, 144 */
		/* 82259EDCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x90);
		/* 82259EDCh case    1:*/		return 0x82259EE0;
	}
	return 0x82259EE0;
} // Block from 82259ED8h-82259EE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259EE0h
// Function '?NextUnvisitedSuccessor@Block@XGRAPHICS@@QBAPAV12@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259EE0);
		  /* 82259EE0h */ case    0:  		/* lwz R27, <#[R29 + 1452]> */
		/* 82259EE0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x000005AC) );
		/* 82259EE0h case    0:*/		return 0x82259EE4;
		  /* 82259EE4h */ case    1:  		/* mr R3, R27 */
		/* 82259EE4h case    1:*/		regs.R3 = regs.R27;
		/* 82259EE4h case    1:*/		return 0x82259EE8;
		  /* 82259EE8h */ case    2:  		/* bl -252464 */
		/* 82259EE8h case    2:*/		regs.LR = 0x82259EEC; return 0x8221C4B8;
		/* 82259EE8h case    2:*/		return 0x82259EEC;
		  /* 82259EECh */ case    3:  		/* addic. R30, R3, 4 */
		/* 82259EECh case    3:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82259EECh case    3:*/		return 0x82259EF0;
		  /* 82259EF0h */ case    4:  		/* stw R27, <#[R3]> */
		/* 82259EF0h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82259EF0h case    4:*/		return 0x82259EF4;
		  /* 82259EF4h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 82259EF4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82259F1C;  }
		/* 82259EF4h case    5:*/		return 0x82259EF8;
		  /* 82259EF8h */ case    6:  		/* mr R4, R29 */
		/* 82259EF8h case    6:*/		regs.R4 = regs.R29;
		/* 82259EF8h case    6:*/		return 0x82259EFC;
		  /* 82259EFCh */ case    7:  		/* mr R3, R30 */
		/* 82259EFCh case    7:*/		regs.R3 = regs.R30;
		/* 82259EFCh case    7:*/		return 0x82259F00;
		  /* 82259F00h */ case    8:  		/* bl -3504 */
		/* 82259F00h case    8:*/		regs.LR = 0x82259F04; return 0x82259150;
		/* 82259F00h case    8:*/		return 0x82259F04;
		  /* 82259F04h */ case    9:  		/* lis R10, -32251 */
		/* 82259F04h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82259F04h case    9:*/		return 0x82259F08;
		  /* 82259F08h */ case   10:  		/* stw R31, <#[R30 + 136]> */
		/* 82259F08h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000088) );
		/* 82259F08h case   10:*/		return 0x82259F0C;
		  /* 82259F0Ch */ case   11:  		/* mr R11, R30 */
		/* 82259F0Ch case   11:*/		regs.R11 = regs.R30;
		/* 82259F0Ch case   11:*/		return 0x82259F10;
		  /* 82259F10h */ case   12:  		/* addi R10, R10, -31916 */
		/* 82259F10h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF8354);
		/* 82259F10h case   12:*/		return 0x82259F14;
		  /* 82259F14h */ case   13:  		/* stw R10, <#[R30]> */
		/* 82259F14h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82259F14h case   13:*/		return 0x82259F18;
		  /* 82259F18h */ case   14:  		/* b 8 */
		/* 82259F18h case   14:*/		return 0x82259F20;
		/* 82259F18h case   14:*/		return 0x82259F1C;
	}
	return 0x82259F1C;
} // Block from 82259EE0h-82259F1Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82259F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F1C);
		  /* 82259F1Ch */ case    0:  		/* mr R11, R28 */
		/* 82259F1Ch case    0:*/		regs.R11 = regs.R28;
		/* 82259F1Ch case    0:*/		return 0x82259F20;
	}
	return 0x82259F20;
} // Block from 82259F1Ch-82259F20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F20);
		  /* 82259F20h */ case    0:  		/* stw R11, <#[R31 + 156]> */
		/* 82259F20h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000009C) );
		/* 82259F20h case    0:*/		return 0x82259F24;
		  /* 82259F24h */ case    1:  		/* mr R4, R31 */
		/* 82259F24h case    1:*/		regs.R4 = regs.R31;
		/* 82259F24h case    1:*/		return 0x82259F28;
		  /* 82259F28h */ case    2:  		/* lwz R3, <#[R31 + 152]> */
		/* 82259F28h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000098) );
		/* 82259F28h case    2:*/		return 0x82259F2C;
		  /* 82259F2Ch */ case    3:  		/* bl -1628 */
		/* 82259F2Ch case    3:*/		regs.LR = 0x82259F30; return 0x822598D0;
		/* 82259F2Ch case    3:*/		return 0x82259F30;
		  /* 82259F30h */ case    4:  		/* mr R4, R29 */
		/* 82259F30h case    4:*/		regs.R4 = regs.R29;
		/* 82259F30h case    4:*/		return 0x82259F34;
		  /* 82259F34h */ case    5:  		/* li R3, 125 */
		/* 82259F34h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x7D);
		/* 82259F34h case    5:*/		return 0x82259F38;
	}
	return 0x82259F38;
} // Block from 82259F20h-82259F38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259F38h
// Function '?HasMultiCFGSucc@Block@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F38);
		  /* 82259F38h */ case    0:  		/* bl -16392 */
		/* 82259F38h case    0:*/		regs.LR = 0x82259F3C; return 0x82255F30;
		/* 82259F38h case    0:*/		return 0x82259F3C;
		  /* 82259F3Ch */ case    1:  		/* lwz R11, <#[R31 + 136]> */
		/* 82259F3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82259F3Ch case    1:*/		return 0x82259F40;
		  /* 82259F40h */ case    2:  		/* li R10, 39 */
		/* 82259F40h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x27);
		/* 82259F40h case    2:*/		return 0x82259F44;
		  /* 82259F44h */ case    3:  		/* stw R3, <#[R31 + 144]> */
		/* 82259F44h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000090) );
		/* 82259F44h case    3:*/		return 0x82259F48;
		  /* 82259F48h */ case    4:  		/* stw R10, <#[R3 + 80]> */
		/* 82259F48h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 82259F48h case    4:*/		return 0x82259F4C;
		  /* 82259F4Ch */ case    5:  		/* stw R11, <#[R3 + 56]> */
		/* 82259F4Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82259F4Ch case    5:*/		return 0x82259F50;
	}
	return 0x82259F50;
} // Block from 82259F38h-82259F50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259F50h
// Function '?HasMultiCFGPred@Block@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F50);
		  /* 82259F50h */ case    0:  		/* lwz R4, <#[R31 + 116]> */
		/* 82259F50h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 82259F50h case    0:*/		return 0x82259F54;
		  /* 82259F54h */ case    1:  		/* lwz R30, <#[R31 + 144]> */
		/* 82259F54h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000090) );
		/* 82259F54h case    1:*/		return 0x82259F58;
		  /* 82259F58h */ case    2:  		/* mr R3, R30 */
		/* 82259F58h case    2:*/		regs.R3 = regs.R30;
		/* 82259F58h case    2:*/		return 0x82259F5C;
		  /* 82259F5Ch */ case    3:  		/* bl -26516 */
		/* 82259F5Ch case    3:*/		regs.LR = 0x82259F60; return 0x822537C8;
		/* 82259F5Ch case    3:*/		return 0x82259F60;
		  /* 82259F60h */ case    4:  		/* stw R31, <#[R30 + 948]> */
		/* 82259F60h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000003B4) );
		/* 82259F60h case    4:*/		return 0x82259F64;
		  /* 82259F64h */ case    5:  		/* mr R3, R31 */
		/* 82259F64h case    5:*/		regs.R3 = regs.R31;
		/* 82259F64h case    5:*/		return 0x82259F68;
	}
	return 0x82259F68;
} // Block from 82259F50h-82259F68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259F68h
// Function '?NumSuccessors@Block@XGRAPHICS@@QBAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F68);
		  /* 82259F68h */ case    0:  		/* addi R1, R1, 128 */
		/* 82259F68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82259F68h case    0:*/		return 0x82259F6C;
		  /* 82259F6Ch */ case    1:  		/* b -1871048 */
		/* 82259F6Ch case    1:*/		return 0x820912A4;
		/* 82259F6Ch case    1:*/		return 0x82259F70;
	}
	return 0x82259F70;
} // Block from 82259F68h-82259F70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F70);
		  /* 82259F70h */ case    0:  		/* lis R11, -32251 */
		/* 82259F70h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259F70h case    0:*/		return 0x82259F74;
		  /* 82259F74h */ case    1:  		/* addi R3, R11, -31680 */
		/* 82259F74h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8440);
		/* 82259F74h case    1:*/		return 0x82259F78;
	}
	return 0x82259F78;
} // Block from 82259F70h-82259F78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259F78h
// Function '?NumPredecessors@Block@XGRAPHICS@@QBAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F78);
		  /* 82259F78h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82259F78h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82259F78h case    0:*/		return 0x82259F7C;
	}
	return 0x82259F7C;
} // Block from 82259F78h-82259F7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F7C);
		  /* 82259F7Ch */ case    0:  		/* nop */
		/* 82259F7Ch case    0:*/		cpu::op::nop();
		/* 82259F7Ch case    0:*/		return 0x82259F80;
	}
	return 0x82259F80;
} // Block from 82259F7Ch-82259F80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82259F80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F80);
		  /* 82259F80h */ case    0:  		/* mfspr R12, LR */
		/* 82259F80h case    0:*/		regs.R12 = regs.LR;
		/* 82259F80h case    0:*/		return 0x82259F84;
		  /* 82259F84h */ case    1:  		/* bl -1871152 */
		/* 82259F84h case    1:*/		regs.LR = 0x82259F88; return 0x82091254;
		/* 82259F84h case    1:*/		return 0x82259F88;
	}
	return 0x82259F88;
} // Block from 82259F80h-82259F88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82259F88h
// Function '?HasSuccessors@Block@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259F88);
		  /* 82259F88h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82259F88h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82259F88h case    0:*/		return 0x82259F8C;
		  /* 82259F8Ch */ case    1:  		/* mr R30, R4 */
		/* 82259F8Ch case    1:*/		regs.R30 = regs.R4;
		/* 82259F8Ch case    1:*/		return 0x82259F90;
		  /* 82259F90h */ case    2:  		/* mr R4, R6 */
		/* 82259F90h case    2:*/		regs.R4 = regs.R6;
		/* 82259F90h case    2:*/		return 0x82259F94;
		  /* 82259F94h */ case    3:  		/* mr R31, R3 */
		/* 82259F94h case    3:*/		regs.R31 = regs.R3;
		/* 82259F94h case    3:*/		return 0x82259F98;
		  /* 82259F98h */ case    4:  		/* mr R27, R5 */
		/* 82259F98h case    4:*/		regs.R27 = regs.R5;
		/* 82259F98h case    4:*/		return 0x82259F9C;
		  /* 82259F9Ch */ case    5:  		/* mr R29, R6 */
		/* 82259F9Ch case    5:*/		regs.R29 = regs.R6;
		/* 82259F9Ch case    5:*/		return 0x82259FA0;
	}
	return 0x82259FA0;
} // Block from 82259F88h-82259FA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259FA0h
// Function '?HasDomChildren@Block@XGRAPHICS@@QBA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259FA0);
		  /* 82259FA0h */ case    0:  		/* bl -3664 */
		/* 82259FA0h case    0:*/		regs.LR = 0x82259FA4; return 0x82259150;
		/* 82259FA0h case    0:*/		return 0x82259FA4;
		  /* 82259FA4h */ case    1:  		/* lis R11, -32251 */
		/* 82259FA4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82259FA4h case    1:*/		return 0x82259FA8;
		  /* 82259FA8h */ case    2:  		/* stw R27, <#[R31 + 156]> */
		/* 82259FA8h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000009C) );
		/* 82259FA8h case    2:*/		return 0x82259FAC;
		  /* 82259FACh */ case    3:  		/* li R28, 0 */
		/* 82259FACh case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82259FACh case    3:*/		return 0x82259FB0;
		  /* 82259FB0h */ case    4:  		/* stw R30, <#[R31 + 136]> */
		/* 82259FB0h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 82259FB0h case    4:*/		return 0x82259FB4;
		  /* 82259FB4h */ case    5:  		/* addi R11, R11, -32156 */
		/* 82259FB4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8264);
		/* 82259FB4h case    5:*/		return 0x82259FB8;
	}
	return 0x82259FB8;
} // Block from 82259FA0h-82259FB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82259FB8h
// Function '?AddDomChild@Block@XGRAPHICS@@IAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259FB8);
		  /* 82259FB8h */ case    0:  		/* li R10, 1 */
		/* 82259FB8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82259FB8h case    0:*/		return 0x82259FBC;
		  /* 82259FBCh */ case    1:  		/* stw R28, <#[R31 + 144]> */
		/* 82259FBCh case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000090) );
		/* 82259FBCh case    1:*/		return 0x82259FC0;
		  /* 82259FC0h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82259FC0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82259FC0h case    2:*/		return 0x82259FC4;
		  /* 82259FC4h */ case    3:  		/* li R4, 140 */
		/* 82259FC4h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x8C);
		/* 82259FC4h case    3:*/		return 0x82259FC8;
		  /* 82259FC8h */ case    4:  		/* stb R10, <#[R31 + 140]> */
		/* 82259FC8h case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 82259FC8h case    4:*/		return 0x82259FCC;
		  /* 82259FCCh */ case    5:  		/* stw R28, <#[R31 + 148]> */
		/* 82259FCCh case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000094) );
		/* 82259FCCh case    5:*/		return 0x82259FD0;
		  /* 82259FD0h */ case    6:  		/* lwz R30, <#[R29 + 1452]> */
		/* 82259FD0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x000005AC) );
		/* 82259FD0h case    6:*/		return 0x82259FD4;
		  /* 82259FD4h */ case    7:  		/* mr R3, R30 */
		/* 82259FD4h case    7:*/		regs.R3 = regs.R30;
		/* 82259FD4h case    7:*/		return 0x82259FD8;
		  /* 82259FD8h */ case    8:  		/* bl -252704 */
		/* 82259FD8h case    8:*/		regs.LR = 0x82259FDC; return 0x8221C4B8;
		/* 82259FD8h case    8:*/		return 0x82259FDC;
		  /* 82259FDCh */ case    9:  		/* mr R11, R3 */
		/* 82259FDCh case    9:*/		regs.R11 = regs.R3;
		/* 82259FDCh case    9:*/		return 0x82259FE0;
		  /* 82259FE0h */ case   10:  		/* addic. R3, R3, 4 */
		/* 82259FE0h case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82259FE0h case   10:*/		return 0x82259FE4;
		  /* 82259FE4h */ case   11:  		/* stw R30, <#[R11]> */
		/* 82259FE4h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82259FE4h case   11:*/		return 0x82259FE8;
		  /* 82259FE8h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 82259FE8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82259FFC;  }
		/* 82259FE8h case   12:*/		return 0x82259FEC;
		  /* 82259FECh */ case   13:  		/* mr R4, R29 */
		/* 82259FECh case   13:*/		regs.R4 = regs.R29;
		/* 82259FECh case   13:*/		return 0x82259FF0;
	}
	return 0x82259FF0;
} // Block from 82259FB8h-82259FF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82259FF0h
// Function '?AddDomFrontier@Block@XGRAPHICS@@IAAXPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259FF0);
		  /* 82259FF0h */ case    0:  		/* bl -3744 */
		/* 82259FF0h case    0:*/		regs.LR = 0x82259FF4; return 0x82259150;
		/* 82259FF0h case    0:*/		return 0x82259FF4;
		  /* 82259FF4h */ case    1:  		/* mr R4, R3 */
		/* 82259FF4h case    1:*/		regs.R4 = regs.R3;
		/* 82259FF4h case    1:*/		return 0x82259FF8;
		  /* 82259FF8h */ case    2:  		/* b 8 */
		/* 82259FF8h case    2:*/		return 0x8225A000;
		/* 82259FF8h case    2:*/		return 0x82259FFC;
	}
	return 0x82259FFC;
} // Block from 82259FF0h-82259FFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82259FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82259FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82259FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82259FFC);
		  /* 82259FFCh */ case    0:  		/* mr R4, R28 */
		/* 82259FFCh case    0:*/		regs.R4 = regs.R28;
		/* 82259FFCh case    0:*/		return 0x8225A000;
	}
	return 0x8225A000;
} // Block from 82259FFCh-8225A000h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A000);
		  /* 8225A000h */ case    0:  		/* stw R4, <#[R31 + 144]> */
		/* 8225A000h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000090) );
		/* 8225A000h case    0:*/		return 0x8225A004;
		  /* 8225A004h */ case    1:  		/* mr R3, R31 */
		/* 8225A004h case    1:*/		regs.R3 = regs.R31;
		/* 8225A004h case    1:*/		return 0x8225A008;
		  /* 8225A008h */ case    2:  		/* bl -1848 */
		/* 8225A008h case    2:*/		regs.LR = 0x8225A00C; return 0x822598D0;
		/* 8225A008h case    2:*/		return 0x8225A00C;
		  /* 8225A00Ch */ case    3:  		/* lwz R4, <#[R31 + 116]> */
		/* 8225A00Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8225A00Ch case    3:*/		return 0x8225A010;
		  /* 8225A010h */ case    4:  		/* lwz R30, <#[R31 + 136]> */
		/* 8225A010h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 8225A010h case    4:*/		return 0x8225A014;
		  /* 8225A014h */ case    5:  		/* mr R3, R30 */
		/* 8225A014h case    5:*/		regs.R3 = regs.R30;
		/* 8225A014h case    5:*/		return 0x8225A018;
		  /* 8225A018h */ case    6:  		/* bl -26704 */
		/* 8225A018h case    6:*/		regs.LR = 0x8225A01C; return 0x822537C8;
		/* 8225A018h case    6:*/		return 0x8225A01C;
		  /* 8225A01Ch */ case    7:  		/* stw R31, <#[R30 + 948]> */
		/* 8225A01Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000003B4) );
		/* 8225A01Ch case    7:*/		return 0x8225A020;
		  /* 8225A020h */ case    8:  		/* li R4, 144 */
		/* 8225A020h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x90);
		/* 8225A020h case    8:*/		return 0x8225A024;
		  /* 8225A024h */ case    9:  		/* lwz R27, <#[R29 + 1452]> */
		/* 8225A024h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x000005AC) );
		/* 8225A024h case    9:*/		return 0x8225A028;
	}
	return 0x8225A028;
} // Block from 8225A000h-8225A028h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225A028h
// Function '?GetEndThen@IfHeader@XGRAPHICS@@QBAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A028);
		  /* 8225A028h */ case    0:  		/* mr R3, R27 */
		/* 8225A028h case    0:*/		regs.R3 = regs.R27;
		/* 8225A028h case    0:*/		return 0x8225A02C;
		  /* 8225A02Ch */ case    1:  		/* bl -252788 */
		/* 8225A02Ch case    1:*/		regs.LR = 0x8225A030; return 0x8221C4B8;
		/* 8225A02Ch case    1:*/		return 0x8225A030;
		  /* 8225A030h */ case    2:  		/* addic. R30, R3, 4 */
		/* 8225A030h case    2:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8225A030h case    2:*/		return 0x8225A034;
		  /* 8225A034h */ case    3:  		/* stw R27, <#[R3]> */
		/* 8225A034h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8225A034h case    3:*/		return 0x8225A038;
		  /* 8225A038h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 8225A038h case    4:*/		if ( regs.CR[0].eq ) { return 0x8225A060;  }
		/* 8225A038h case    4:*/		return 0x8225A03C;
		  /* 8225A03Ch */ case    5:  		/* mr R4, R29 */
		/* 8225A03Ch case    5:*/		regs.R4 = regs.R29;
		/* 8225A03Ch case    5:*/		return 0x8225A040;
		  /* 8225A040h */ case    6:  		/* mr R3, R30 */
		/* 8225A040h case    6:*/		regs.R3 = regs.R30;
		/* 8225A040h case    6:*/		return 0x8225A044;
		  /* 8225A044h */ case    7:  		/* bl -3828 */
		/* 8225A044h case    7:*/		regs.LR = 0x8225A048; return 0x82259150;
		/* 8225A044h case    7:*/		return 0x8225A048;
		  /* 8225A048h */ case    8:  		/* lis R10, -32251 */
		/* 8225A048h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A048h case    8:*/		return 0x8225A04C;
		  /* 8225A04Ch */ case    9:  		/* stw R31, <#[R30 + 136]> */
		/* 8225A04Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000088) );
		/* 8225A04Ch case    9:*/		return 0x8225A050;
		  /* 8225A050h */ case   10:  		/* mr R11, R30 */
		/* 8225A050h case   10:*/		regs.R11 = regs.R30;
		/* 8225A050h case   10:*/		return 0x8225A054;
		  /* 8225A054h */ case   11:  		/* addi R10, R10, -31848 */
		/* 8225A054h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF8398);
		/* 8225A054h case   11:*/		return 0x8225A058;
		  /* 8225A058h */ case   12:  		/* stw R10, <#[R30]> */
		/* 8225A058h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8225A058h case   12:*/		return 0x8225A05C;
		  /* 8225A05Ch */ case   13:  		/* b 8 */
		/* 8225A05Ch case   13:*/		return 0x8225A064;
		/* 8225A05Ch case   13:*/		return 0x8225A060;
	}
	return 0x8225A060;
} // Block from 8225A028h-8225A060h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225A060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A060);
		  /* 8225A060h */ case    0:  		/* mr R11, R28 */
		/* 8225A060h case    0:*/		regs.R11 = regs.R28;
		/* 8225A060h case    0:*/		return 0x8225A064;
	}
	return 0x8225A064;
} // Block from 8225A060h-8225A064h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A064);
		  /* 8225A064h */ case    0:  		/* stw R11, <#[R31 + 152]> */
		/* 8225A064h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 8225A064h case    0:*/		return 0x8225A068;
		  /* 8225A068h */ case    1:  		/* mr R3, R31 */
		/* 8225A068h case    1:*/		regs.R3 = regs.R31;
		/* 8225A068h case    1:*/		return 0x8225A06C;
		  /* 8225A06Ch */ case    2:  		/* addi R1, R1, 128 */
		/* 8225A06Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8225A06Ch case    2:*/		return 0x8225A070;
		  /* 8225A070h */ case    3:  		/* b -1871308 */
		/* 8225A070h case    3:*/		return 0x820912A4;
		/* 8225A070h case    3:*/		return 0x8225A074;
		  /* 8225A074h */ case    4:  		/* nop */
		/* 8225A074h case    4:*/		cpu::op::nop();
		/* 8225A074h case    4:*/		return 0x8225A078;
	}
	return 0x8225A078;
} // Block from 8225A064h-8225A078h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225A078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A078);
		  /* 8225A078h */ case    0:  		/* mfspr R12, LR */
		/* 8225A078h case    0:*/		regs.R12 = regs.LR;
		/* 8225A078h case    0:*/		return 0x8225A07C;
		  /* 8225A07Ch */ case    1:  		/* bl -1871396 */
		/* 8225A07Ch case    1:*/		regs.LR = 0x8225A080; return 0x82091258;
		/* 8225A07Ch case    1:*/		return 0x8225A080;
		  /* 8225A080h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8225A080h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8225A080h case    2:*/		return 0x8225A084;
		  /* 8225A084h */ case    3:  		/* mr R30, R4 */
		/* 8225A084h case    3:*/		regs.R30 = regs.R4;
		/* 8225A084h case    3:*/		return 0x8225A088;
		  /* 8225A088h */ case    4:  		/* mr R4, R6 */
		/* 8225A088h case    4:*/		regs.R4 = regs.R6;
		/* 8225A088h case    4:*/		return 0x8225A08C;
		  /* 8225A08Ch */ case    5:  		/* mr R31, R3 */
		/* 8225A08Ch case    5:*/		regs.R31 = regs.R3;
		/* 8225A08Ch case    5:*/		return 0x8225A090;
		  /* 8225A090h */ case    6:  		/* mr R28, R5 */
		/* 8225A090h case    6:*/		regs.R28 = regs.R5;
		/* 8225A090h case    6:*/		return 0x8225A094;
		  /* 8225A094h */ case    7:  		/* mr R29, R6 */
		/* 8225A094h case    7:*/		regs.R29 = regs.R6;
		/* 8225A094h case    7:*/		return 0x8225A098;
		  /* 8225A098h */ case    8:  		/* bl -1080 */
		/* 8225A098h case    8:*/		regs.LR = 0x8225A09C; return 0x82259C60;
		/* 8225A098h case    8:*/		return 0x8225A09C;
		  /* 8225A09Ch */ case    9:  		/* lis R11, -32251 */
		/* 8225A09Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A09Ch case    9:*/		return 0x8225A0A0;
		  /* 8225A0A0h */ case   10:  		/* stw R30, <#[R31 + 136]> */
		/* 8225A0A0h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000088) );
		/* 8225A0A0h case   10:*/		return 0x8225A0A4;
		  /* 8225A0A4h */ case   11:  		/* mr R3, R30 */
		/* 8225A0A4h case   11:*/		regs.R3 = regs.R30;
		/* 8225A0A4h case   11:*/		return 0x8225A0A8;
		  /* 8225A0A8h */ case   12:  		/* lwz R4, <#[R31 + 116]> */
		/* 8225A0A8h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000074) );
		/* 8225A0A8h case   12:*/		return 0x8225A0AC;
		  /* 8225A0ACh */ case   13:  		/* addi R11, R11, -31668 */
		/* 8225A0ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF844C);
		/* 8225A0ACh case   13:*/		return 0x8225A0B0;
		  /* 8225A0B0h */ case   14:  		/* stw R11, <#[R31]> */
		/* 8225A0B0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225A0B0h case   14:*/		return 0x8225A0B4;
		  /* 8225A0B4h */ case   15:  		/* bl -26860 */
		/* 8225A0B4h case   15:*/		regs.LR = 0x8225A0B8; return 0x822537C8;
		/* 8225A0B4h case   15:*/		return 0x8225A0B8;
		  /* 8225A0B8h */ case   16:  		/* stw R31, <#[R30 + 948]> */
		/* 8225A0B8h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x000003B4) );
		/* 8225A0B8h case   16:*/		return 0x8225A0BC;
		  /* 8225A0BCh */ case   17:  		/* stw R28, <#[R31 + 156]> */
		/* 8225A0BCh case   17:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000009C) );
		/* 8225A0BCh case   17:*/		return 0x8225A0C0;
		  /* 8225A0C0h */ case   18:  		/* li R4, 144 */
		/* 8225A0C0h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x90);
		/* 8225A0C0h case   18:*/		return 0x8225A0C4;
		  /* 8225A0C4h */ case   19:  		/* lwz R28, <#[R29 + 1452]> */
		/* 8225A0C4h case   19:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x000005AC) );
		/* 8225A0C4h case   19:*/		return 0x8225A0C8;
		  /* 8225A0C8h */ case   20:  		/* mr R3, R28 */
		/* 8225A0C8h case   20:*/		regs.R3 = regs.R28;
		/* 8225A0C8h case   20:*/		return 0x8225A0CC;
		  /* 8225A0CCh */ case   21:  		/* bl -252948 */
		/* 8225A0CCh case   21:*/		regs.LR = 0x8225A0D0; return 0x8221C4B8;
		/* 8225A0CCh case   21:*/		return 0x8225A0D0;
		  /* 8225A0D0h */ case   22:  		/* addic. R30, R3, 4 */
		/* 8225A0D0h case   22:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8225A0D0h case   22:*/		return 0x8225A0D4;
		  /* 8225A0D4h */ case   23:  		/* stw R28, <#[R3]> */
		/* 8225A0D4h case   23:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 8225A0D4h case   23:*/		return 0x8225A0D8;
		  /* 8225A0D8h */ case   24:  		/* bc 12, CR0_EQ, 40 */
		/* 8225A0D8h case   24:*/		if ( regs.CR[0].eq ) { return 0x8225A100;  }
		/* 8225A0D8h case   24:*/		return 0x8225A0DC;
		  /* 8225A0DCh */ case   25:  		/* mr R4, R29 */
		/* 8225A0DCh case   25:*/		regs.R4 = regs.R29;
		/* 8225A0DCh case   25:*/		return 0x8225A0E0;
		  /* 8225A0E0h */ case   26:  		/* mr R3, R30 */
		/* 8225A0E0h case   26:*/		regs.R3 = regs.R30;
		/* 8225A0E0h case   26:*/		return 0x8225A0E4;
		  /* 8225A0E4h */ case   27:  		/* bl -3988 */
		/* 8225A0E4h case   27:*/		regs.LR = 0x8225A0E8; return 0x82259150;
		/* 8225A0E4h case   27:*/		return 0x8225A0E8;
		  /* 8225A0E8h */ case   28:  		/* lis R10, -32251 */
		/* 8225A0E8h case   28:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A0E8h case   28:*/		return 0x8225A0EC;
		  /* 8225A0ECh */ case   29:  		/* stw R31, <#[R30 + 136]> */
		/* 8225A0ECh case   29:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000088) );
		/* 8225A0ECh case   29:*/		return 0x8225A0F0;
		  /* 8225A0F0h */ case   30:  		/* mr R11, R30 */
		/* 8225A0F0h case   30:*/		regs.R11 = regs.R30;
		/* 8225A0F0h case   30:*/		return 0x8225A0F4;
		  /* 8225A0F4h */ case   31:  		/* addi R10, R10, -31788 */
		/* 8225A0F4h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFF83D4);
		/* 8225A0F4h case   31:*/		return 0x8225A0F8;
		  /* 8225A0F8h */ case   32:  		/* stw R10, <#[R30]> */
		/* 8225A0F8h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8225A0F8h case   32:*/		return 0x8225A0FC;
		  /* 8225A0FCh */ case   33:  		/* b 8 */
		/* 8225A0FCh case   33:*/		return 0x8225A104;
		/* 8225A0FCh case   33:*/		return 0x8225A100;
	}
	return 0x8225A100;
} // Block from 8225A078h-8225A100h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8225A100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A100);
		  /* 8225A100h */ case    0:  		/* li R11, 0 */
		/* 8225A100h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225A100h case    0:*/		return 0x8225A104;
	}
	return 0x8225A104;
} // Block from 8225A100h-8225A104h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A104);
		  /* 8225A104h */ case    0:  		/* stw R11, <#[R31 + 152]> */
		/* 8225A104h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 8225A104h case    0:*/		return 0x8225A108;
		  /* 8225A108h */ case    1:  		/* mr R3, R31 */
		/* 8225A108h case    1:*/		regs.R3 = regs.R31;
		/* 8225A108h case    1:*/		return 0x8225A10C;
		  /* 8225A10Ch */ case    2:  		/* addi R1, R1, 128 */
		/* 8225A10Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8225A10Ch case    2:*/		return 0x8225A110;
	}
	return 0x8225A110;
} // Block from 8225A104h-8225A110h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225A110h
// Function '?GetEndElse@IfHeader@XGRAPHICS@@QBAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A110);
		  /* 8225A110h */ case    0:  		/* b -1871464 */
		/* 8225A110h case    0:*/		return 0x820912A8;
		/* 8225A110h case    0:*/		return 0x8225A114;
		  /* 8225A114h */ case    1:  		/* nop */
		/* 8225A114h case    1:*/		cpu::op::nop();
		/* 8225A114h case    1:*/		return 0x8225A118;
	}
	return 0x8225A118;
} // Block from 8225A110h-8225A118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A118);
		  /* 8225A118h */ case    0:  		/* lis R11, -32251 */
		/* 8225A118h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A118h case    0:*/		return 0x8225A11C;
		  /* 8225A11Ch */ case    1:  		/* addi R3, R11, -31616 */
		/* 8225A11Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFF8480);
		/* 8225A11Ch case    1:*/		return 0x8225A120;
		  /* 8225A120h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8225A120h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A120h case    2:*/		return 0x8225A124;
	}
	return 0x8225A124;
} // Block from 8225A118h-8225A124h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225A124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A124);
		  /* 8225A124h */ case    0:  		/* nop */
		/* 8225A124h case    0:*/		cpu::op::nop();
		/* 8225A124h case    0:*/		return 0x8225A128;
	}
	return 0x8225A128;
} // Block from 8225A124h-8225A128h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A128);
		  /* 8225A128h */ case    0:  		/* mfspr R12, LR */
		/* 8225A128h case    0:*/		regs.R12 = regs.LR;
		/* 8225A128h case    0:*/		return 0x8225A12C;
		  /* 8225A12Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A12Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A12Ch case    1:*/		return 0x8225A130;
		  /* 8225A130h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8225A130h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225A130h case    2:*/		return 0x8225A134;
		  /* 8225A134h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225A134h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A134h case    3:*/		return 0x8225A138;
		  /* 8225A138h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8225A138h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8225A138h case    4:*/		return 0x8225A13C;
		  /* 8225A13Ch */ case    5:  		/* mr R31, R3 */
		/* 8225A13Ch case    5:*/		regs.R31 = regs.R3;
		/* 8225A13Ch case    5:*/		return 0x8225A140;
		  /* 8225A140h */ case    6:  		/* mr R30, R4 */
		/* 8225A140h case    6:*/		regs.R30 = regs.R4;
		/* 8225A140h case    6:*/		return 0x8225A144;
		  /* 8225A144h */ case    7:  		/* bl -2028 */
		/* 8225A144h case    7:*/		regs.LR = 0x8225A148; return 0x82259958;
		/* 8225A144h case    7:*/		return 0x8225A148;
		  /* 8225A148h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8225A148h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8225A148h case    8:*/		return 0x8225A14C;
		  /* 8225A14Ch */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 8225A14Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8225A164;  }
		/* 8225A14Ch case    9:*/		return 0x8225A150;
		  /* 8225A150h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 8225A150h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225A150h case   10:*/		return 0x8225A154;
		  /* 8225A154h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 8225A154h case   11:*/		if ( regs.CR[6].eq ) { return 0x8225A164;  }
		/* 8225A154h case   11:*/		return 0x8225A158;
		  /* 8225A158h */ case   12:  		/* addi R4, R31, -4 */
		/* 8225A158h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 8225A158h case   12:*/		return 0x8225A15C;
		  /* 8225A15Ch */ case   13:  		/* lwz R3, <#[R31 - 4]> */
		/* 8225A15Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 8225A15Ch case   13:*/		return 0x8225A160;
		  /* 8225A160h */ case   14:  		/* bl -252704 */
		/* 8225A160h case   14:*/		regs.LR = 0x8225A164; return 0x8221C640;
		/* 8225A160h case   14:*/		return 0x8225A164;
	}
	return 0x8225A164;
} // Block from 8225A128h-8225A164h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225A164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A164);
		  /* 8225A164h */ case    0:  		/* mr R3, R31 */
		/* 8225A164h case    0:*/		regs.R3 = regs.R31;
		/* 8225A164h case    0:*/		return 0x8225A168;
		  /* 8225A168h */ case    1:  		/* addi R1, R1, 112 */
		/* 8225A168h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225A168h case    1:*/		return 0x8225A16C;
		  /* 8225A16Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A16Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A16Ch case    2:*/		return 0x8225A170;
		  /* 8225A170h */ case    3:  		/* mtspr LR, R12 */
		/* 8225A170h case    3:*/		regs.LR = regs.R12;
		/* 8225A170h case    3:*/		return 0x8225A174;
		  /* 8225A174h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8225A174h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225A174h case    4:*/		return 0x8225A178;
		  /* 8225A178h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A178h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A178h case    5:*/		return 0x8225A17C;
		  /* 8225A17Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 8225A17Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A17Ch case    6:*/		return 0x8225A180;
	}
	return 0x8225A180;
} // Block from 8225A164h-8225A180h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225A180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A180);
		  /* 8225A180h */ case    0:  		/* mfspr R12, LR */
		/* 8225A180h case    0:*/		regs.R12 = regs.LR;
		/* 8225A180h case    0:*/		return 0x8225A184;
		  /* 8225A184h */ case    1:  		/* bl -1871668 */
		/* 8225A184h case    1:*/		regs.LR = 0x8225A188; return 0x82091250;
		/* 8225A184h case    1:*/		return 0x8225A188;
		  /* 8225A188h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8225A188h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8225A188h case    2:*/		return 0x8225A18C;
		  /* 8225A18Ch */ case    3:  		/* lis R11, -32253 */
		/* 8225A18Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8225A18Ch case    3:*/		return 0x8225A190;
		  /* 8225A190h */ case    4:  		/* lis R10, -32251 */
		/* 8225A190h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A190h case    4:*/		return 0x8225A194;
		  /* 8225A194h */ case    5:  		/* mr R26, R3 */
		/* 8225A194h case    5:*/		regs.R26 = regs.R3;
		/* 8225A194h case    5:*/		return 0x8225A198;
		  /* 8225A198h */ case    6:  		/* mr R31, R4 */
		/* 8225A198h case    6:*/		regs.R31 = regs.R4;
		/* 8225A198h case    6:*/		return 0x8225A19C;
		  /* 8225A19Ch */ case    7:  		/* cmpwi CR6, R4, 0 */
		/* 8225A19Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8225A19Ch case    7:*/		return 0x8225A1A0;
		  /* 8225A1A0h */ case    8:  		/* addi R28, R11, 27460 */
		/* 8225A1A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 8225A1A0h case    8:*/		return 0x8225A1A4;
		  /* 8225A1A4h */ case    9:  		/* addi R27, R10, -21904 */
		/* 8225A1A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0xFFFFAA70);
		/* 8225A1A4h case    9:*/		return 0x8225A1A8;
		  /* 8225A1A8h */ case   10:  		/* bc 12, CR6_LT, 12 */
		/* 8225A1A8h case   10:*/		if ( regs.CR[6].lt ) { return 0x8225A1B4;  }
		/* 8225A1A8h case   10:*/		return 0x8225A1AC;
		  /* 8225A1ACh */ case   11:  		/* cmpwi CR6, R4, 136 */
		/* 8225A1ACh case   11:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000088);
		/* 8225A1ACh case   11:*/		return 0x8225A1B0;
		  /* 8225A1B0h */ case   12:  		/* bc 12, CR6_LT, 32 */
		/* 8225A1B0h case   12:*/		if ( regs.CR[6].lt ) { return 0x8225A1D0;  }
		/* 8225A1B0h case   12:*/		return 0x8225A1B4;
	}
	return 0x8225A1B4;
} // Block from 8225A180h-8225A1B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225A1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A1B4);
		  /* 8225A1B4h */ case    0:  		/* lis R11, -32251 */
		/* 8225A1B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A1B4h case    0:*/		return 0x8225A1B8;
		  /* 8225A1B8h */ case    1:  		/* mr R6, R27 */
		/* 8225A1B8h case    1:*/		regs.R6 = regs.R27;
		/* 8225A1B8h case    1:*/		return 0x8225A1BC;
		  /* 8225A1BCh */ case    2:  		/* addi R5, R11, -21956 */
		/* 8225A1BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAA3C);
		/* 8225A1BCh case    2:*/		return 0x8225A1C0;
		  /* 8225A1C0h */ case    3:  		/* mr R4, R28 */
		/* 8225A1C0h case    3:*/		regs.R4 = regs.R28;
		/* 8225A1C0h case    3:*/		return 0x8225A1C4;
		  /* 8225A1C4h */ case    4:  		/* li R7, 68 */
		/* 8225A1C4h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x44);
		/* 8225A1C4h case    4:*/		return 0x8225A1C8;
		  /* 8225A1C8h */ case    5:  		/* li R3, 0 */
		/* 8225A1C8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A1C8h case    5:*/		return 0x8225A1CC;
		  /* 8225A1CCh */ case    6:  		/* bl -1058244 */
		/* 8225A1CCh case    6:*/		regs.LR = 0x8225A1D0; return 0x82157C08;
		/* 8225A1CCh case    6:*/		return 0x8225A1D0;
	}
	return 0x8225A1D0;
} // Block from 8225A1B4h-8225A1D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225A1D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A1D0);
		  /* 8225A1D0h */ case    0:  		/* lis R11, -32216 */
		/* 8225A1D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225A1D0h case    0:*/		return 0x8225A1D4;
		  /* 8225A1D4h */ case    1:  		/* mulli R30, R31, 36 */
		/* 8225A1D4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R30,regs.R31,0x24);
		/* 8225A1D4h case    1:*/		return 0x8225A1D8;
		  /* 8225A1D8h */ case    2:  		/* addi R31, R11, 12984 */
		/* 8225A1D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x32B8);
		/* 8225A1D8h case    2:*/		return 0x8225A1DC;
		  /* 8225A1DCh */ case    3:  		/* addi R11, R31, 20 */
		/* 8225A1DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x14);
		/* 8225A1DCh case    3:*/		return 0x8225A1E0;
		  /* 8225A1E0h */ case    4:  		/* lwzx R29, <#[R30 + R11]> */
		/* 8225A1E0h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8225A1E0h case    4:*/		return 0x8225A1E4;
		  /* 8225A1E4h */ case    5:  		/* cmplwi CR6, R29, 0 */
		/* 8225A1E4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8225A1E4h case    5:*/		return 0x8225A1E8;
		  /* 8225A1E8h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 8225A1E8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8225A208;  }
		/* 8225A1E8h case    6:*/		return 0x8225A1EC;
		  /* 8225A1ECh */ case    7:  		/* lis R11, -32251 */
		/* 8225A1ECh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A1ECh case    7:*/		return 0x8225A1F0;
		  /* 8225A1F0h */ case    8:  		/* mr R6, R27 */
		/* 8225A1F0h case    8:*/		regs.R6 = regs.R27;
		/* 8225A1F0h case    8:*/		return 0x8225A1F4;
		  /* 8225A1F4h */ case    9:  		/* addi R5, R11, -21968 */
		/* 8225A1F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAA30);
		/* 8225A1F4h case    9:*/		return 0x8225A1F8;
		  /* 8225A1F8h */ case   10:  		/* mr R4, R28 */
		/* 8225A1F8h case   10:*/		regs.R4 = regs.R28;
		/* 8225A1F8h case   10:*/		return 0x8225A1FC;
		  /* 8225A1FCh */ case   11:  		/* li R7, 71 */
		/* 8225A1FCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x47);
		/* 8225A1FCh case   11:*/		return 0x8225A200;
	}
	return 0x8225A200;
} // Block from 8225A1D0h-8225A200h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225A200h
// Function '?RemoveUnreachableBlocks@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A200);
		  /* 8225A200h */ case    0:  		/* li R3, 0 */
		/* 8225A200h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A200h case    0:*/		return 0x8225A204;
		  /* 8225A204h */ case    1:  		/* bl -1058300 */
		/* 8225A204h case    1:*/		regs.LR = 0x8225A208; return 0x82157C08;
		/* 8225A204h case    1:*/		return 0x8225A208;
	}
	return 0x8225A208;
} // Block from 8225A200h-8225A208h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A208);
		  /* 8225A208h */ case    0:  		/* lwz R4, <#[R26 + 12]> */
		/* 8225A208h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x0000000C) );
		/* 8225A208h case    0:*/		return 0x8225A20C;
		  /* 8225A20Ch */ case    1:  		/* mtspr CTR, R29 */
		/* 8225A20Ch case    1:*/		regs.CTR = regs.R29;
		/* 8225A20Ch case    1:*/		return 0x8225A210;
		  /* 8225A210h */ case    2:  		/* lwzx R3, <#[R30 + R31]> */
		/* 8225A210h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 8225A210h case    2:*/		return 0x8225A214;
		  /* 8225A214h */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 8225A214h case    3:*/		if ( 1 ) { regs.LR = 0x8225A218; return (uint32)regs.CTR; }
		/* 8225A214h case    3:*/		return 0x8225A218;
		  /* 8225A218h */ case    4:  		/* addi R1, R1, 144 */
		/* 8225A218h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8225A218h case    4:*/		return 0x8225A21C;
		  /* 8225A21Ch */ case    5:  		/* b -1871740 */
		/* 8225A21Ch case    5:*/		return 0x820912A0;
		/* 8225A21Ch case    5:*/		return 0x8225A220;
	}
	return 0x8225A220;
} // Block from 8225A208h-8225A220h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225A220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A220);
		  /* 8225A220h */ case    0:  		/* mfspr R12, LR */
		/* 8225A220h case    0:*/		regs.R12 = regs.LR;
		/* 8225A220h case    0:*/		return 0x8225A224;
		  /* 8225A224h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A224h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A224h case    1:*/		return 0x8225A228;
		  /* 8225A228h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225A228h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A228h case    2:*/		return 0x8225A22C;
		  /* 8225A22Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A22Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A22Ch case    3:*/		return 0x8225A230;
		  /* 8225A230h */ case    4:  		/* extsb R11, R3 */
		/* 8225A230h case    4:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R3);
		/* 8225A230h case    4:*/		return 0x8225A234;
		  /* 8225A234h */ case    5:  		/* addi R31, R11, -48 */
		/* 8225A234h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD0);
		/* 8225A234h case    5:*/		return 0x8225A238;
		  /* 8225A238h */ case    6:  		/* cmpwi CR6, R31, 1 */
		/* 8225A238h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000001);
		/* 8225A238h case    6:*/		return 0x8225A23C;
		  /* 8225A23Ch */ case    7:  		/* bc 4, CR6_GT, 24 */
		/* 8225A23Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8225A254;  }
		/* 8225A23Ch case    7:*/		return 0x8225A240;
		  /* 8225A240h */ case    8:  		/* cmpwi CR6, R11, 95 */
		/* 8225A240h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 8225A240h case    8:*/		return 0x8225A244;
		  /* 8225A244h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 8225A244h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8225A250;  }
		/* 8225A244h case    9:*/		return 0x8225A248;
		  /* 8225A248h */ case   10:  		/* li R31, 2 */
		/* 8225A248h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 8225A248h case   10:*/		return 0x8225A24C;
		  /* 8225A24Ch */ case   11:  		/* b 60 */
		/* 8225A24Ch case   11:*/		return 0x8225A288;
		/* 8225A24Ch case   11:*/		return 0x8225A250;
	}
	return 0x8225A250;
} // Block from 8225A220h-8225A250h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225A250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A250);
		  /* 8225A250h */ case    0:  		/* addi R31, R11, -116 */
		/* 8225A250h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFF8C);
		/* 8225A250h case    0:*/		return 0x8225A254;
	}
	return 0x8225A254;
} // Block from 8225A250h-8225A254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A254);
		  /* 8225A254h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 8225A254h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8225A254h case    0:*/		return 0x8225A258;
		  /* 8225A258h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 8225A258h case    1:*/		if ( regs.CR[6].lt ) { return 0x8225A264;  }
		/* 8225A258h case    1:*/		return 0x8225A25C;
		  /* 8225A25Ch */ case    2:  		/* cmpwi CR6, R31, 6 */
		/* 8225A25Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000006);
		/* 8225A25Ch case    2:*/		return 0x8225A260;
		  /* 8225A260h */ case    3:  		/* bc 4, CR6_GT, 40 */
		/* 8225A260h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8225A288;  }
		/* 8225A260h case    3:*/		return 0x8225A264;
	}
	return 0x8225A264;
} // Block from 8225A254h-8225A264h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A264);
		  /* 8225A264h */ case    0:  		/* lis R11, -32251 */
		/* 8225A264h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A264h case    0:*/		return 0x8225A268;
		  /* 8225A268h */ case    1:  		/* lis R10, -32251 */
		/* 8225A268h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A268h case    1:*/		return 0x8225A26C;
		  /* 8225A26Ch */ case    2:  		/* lis R9, -32253 */
		/* 8225A26Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A26Ch case    2:*/		return 0x8225A270;
		  /* 8225A270h */ case    3:  		/* addi R6, R11, -21904 */
		/* 8225A270h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAA70);
		/* 8225A270h case    3:*/		return 0x8225A274;
		  /* 8225A274h */ case    4:  		/* addi R5, R10, -21808 */
		/* 8225A274h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAAD0);
		/* 8225A274h case    4:*/		return 0x8225A278;
		  /* 8225A278h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A278h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A278h case    5:*/		return 0x8225A27C;
		  /* 8225A27Ch */ case    6:  		/* li R7, 1015 */
		/* 8225A27Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3F7);
		/* 8225A27Ch case    6:*/		return 0x8225A280;
		  /* 8225A280h */ case    7:  		/* li R3, 0 */
		/* 8225A280h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A280h case    7:*/		return 0x8225A284;
		  /* 8225A284h */ case    8:  		/* bl -1058428 */
		/* 8225A284h case    8:*/		regs.LR = 0x8225A288; return 0x82157C08;
		/* 8225A284h case    8:*/		return 0x8225A288;
	}
	return 0x8225A288;
} // Block from 8225A264h-8225A288h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A288);
		  /* 8225A288h */ case    0:  		/* lis R11, -32251 */
		/* 8225A288h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A288h case    0:*/		return 0x8225A28C;
		  /* 8225A28Ch */ case    1:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8225A28Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8225A28Ch case    1:*/		return 0x8225A290;
		  /* 8225A290h */ case    2:  		/* addi R11, R11, -31536 */
		/* 8225A290h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF84D0);
		/* 8225A290h case    2:*/		return 0x8225A294;
		  /* 8225A294h */ case    3:  		/* lwzx R3, <#[R10 + R11]> */
		/* 8225A294h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8225A294h case    3:*/		return 0x8225A298;
		  /* 8225A298h */ case    4:  		/* addi R1, R1, 96 */
		/* 8225A298h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A298h case    4:*/		return 0x8225A29C;
		  /* 8225A29Ch */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A29Ch case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A29Ch case    5:*/		return 0x8225A2A0;
		  /* 8225A2A0h */ case    6:  		/* mtspr LR, R12 */
		/* 8225A2A0h case    6:*/		regs.LR = regs.R12;
		/* 8225A2A0h case    6:*/		return 0x8225A2A4;
		  /* 8225A2A4h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A2A4h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A2A4h case    7:*/		return 0x8225A2A8;
		  /* 8225A2A8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8225A2A8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A2A8h case    8:*/		return 0x8225A2AC;
	}
	return 0x8225A2AC;
} // Block from 8225A288h-8225A2ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A2AC);
		  /* 8225A2ACh */ case    0:  		/* nop */
		/* 8225A2ACh case    0:*/		cpu::op::nop();
		/* 8225A2ACh case    0:*/		return 0x8225A2B0;
	}
	return 0x8225A2B0;
} // Block from 8225A2ACh-8225A2B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A2B0);
		  /* 8225A2B0h */ case    0:  		/* mfspr R12, LR */
		/* 8225A2B0h case    0:*/		regs.R12 = regs.LR;
		/* 8225A2B0h case    0:*/		return 0x8225A2B4;
		  /* 8225A2B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A2B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A2B4h case    1:*/		return 0x8225A2B8;
		  /* 8225A2B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8225A2B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225A2B8h case    2:*/		return 0x8225A2BC;
		  /* 8225A2BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225A2BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A2BCh case    3:*/		return 0x8225A2C0;
		  /* 8225A2C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8225A2C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8225A2C0h case    4:*/		return 0x8225A2C4;
		  /* 8225A2C4h */ case    5:  		/* mr R31, R3 */
		/* 8225A2C4h case    5:*/		regs.R31 = regs.R3;
		/* 8225A2C4h case    5:*/		return 0x8225A2C8;
		  /* 8225A2C8h */ case    6:  		/* mr R30, R4 */
		/* 8225A2C8h case    6:*/		regs.R30 = regs.R4;
		/* 8225A2C8h case    6:*/		return 0x8225A2CC;
		  /* 8225A2CCh */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 8225A2CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8225A2CCh case    7:*/		return 0x8225A2D0;
		  /* 8225A2D0h */ case    8:  		/* bc 4, CR6_EQ, 40 */
		/* 8225A2D0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8225A2F8;  }
		/* 8225A2D0h case    8:*/		return 0x8225A2D4;
		  /* 8225A2D4h */ case    9:  		/* lis R11, -32252 */
		/* 8225A2D4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225A2D4h case    9:*/		return 0x8225A2D8;
		  /* 8225A2D8h */ case   10:  		/* lis R10, -32252 */
		/* 8225A2D8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225A2D8h case   10:*/		return 0x8225A2DC;
		  /* 8225A2DCh */ case   11:  		/* lis R9, -32253 */
		/* 8225A2DCh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A2DCh case   11:*/		return 0x8225A2E0;
		  /* 8225A2E0h */ case   12:  		/* addi R6, R11, 8704 */
		/* 8225A2E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2200);
		/* 8225A2E0h case   12:*/		return 0x8225A2E4;
		  /* 8225A2E4h */ case   13:  		/* addi R5, R10, 8796 */
		/* 8225A2E4h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x225C);
		/* 8225A2E4h case   13:*/		return 0x8225A2E8;
		  /* 8225A2E8h */ case   14:  		/* addi R4, R9, 27460 */
		/* 8225A2E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A2E8h case   14:*/		return 0x8225A2EC;
		  /* 8225A2ECh */ case   15:  		/* li R7, 1932 */
		/* 8225A2ECh case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x78C);
		/* 8225A2ECh case   15:*/		return 0x8225A2F0;
		  /* 8225A2F0h */ case   16:  		/* li R3, 0 */
		/* 8225A2F0h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A2F0h case   16:*/		return 0x8225A2F4;
		  /* 8225A2F4h */ case   17:  		/* bl -1058540 */
		/* 8225A2F4h case   17:*/		regs.LR = 0x8225A2F8; return 0x82157C08;
		/* 8225A2F4h case   17:*/		return 0x8225A2F8;
	}
	return 0x8225A2F8;
} // Block from 8225A2B0h-8225A2F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225A2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A2F8);
		  /* 8225A2F8h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8225A2F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8225A2F8h case    0:*/		return 0x8225A2FC;
		  /* 8225A2FCh */ case    1:  		/* mr R5, R30 */
		/* 8225A2FCh case    1:*/		regs.R5 = regs.R30;
		/* 8225A2FCh case    1:*/		return 0x8225A300;
		  /* 8225A300h */ case    2:  		/* mr R3, R31 */
		/* 8225A300h case    2:*/		regs.R3 = regs.R31;
		/* 8225A300h case    2:*/		return 0x8225A304;
		  /* 8225A304h */ case    3:  		/* addi R4, R11, 1 */
		/* 8225A304h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8225A304h case    3:*/		return 0x8225A308;
		  /* 8225A308h */ case    4:  		/* stw R4, <#[R31 + 20]> */
		/* 8225A308h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 8225A308h case    4:*/		return 0x8225A30C;
		  /* 8225A30Ch */ case    5:  		/* bl -16244 */
		/* 8225A30Ch case    5:*/		regs.LR = 0x8225A310; return 0x82256398;
		/* 8225A30Ch case    5:*/		return 0x8225A310;
		  /* 8225A310h */ case    6:  		/* addi R1, R1, 112 */
		/* 8225A310h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225A310h case    6:*/		return 0x8225A314;
		  /* 8225A314h */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A314h case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A314h case    7:*/		return 0x8225A318;
		  /* 8225A318h */ case    8:  		/* mtspr LR, R12 */
		/* 8225A318h case    8:*/		regs.LR = regs.R12;
		/* 8225A318h case    8:*/		return 0x8225A31C;
		  /* 8225A31Ch */ case    9:  		/* ld R30, <#[R1 - 24]> */
		/* 8225A31Ch case    9:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225A31Ch case    9:*/		return 0x8225A320;
		  /* 8225A320h */ case   10:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A320h case   10:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A320h case   10:*/		return 0x8225A324;
		  /* 8225A324h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8225A324h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A324h case   11:*/		return 0x8225A328;
	}
	return 0x8225A328;
} // Block from 8225A2F8h-8225A328h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225A328h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A328);
		  /* 8225A328h */ case    0:  		/* mfspr R12, LR */
		/* 8225A328h case    0:*/		regs.R12 = regs.LR;
		/* 8225A328h case    0:*/		return 0x8225A32C;
		  /* 8225A32Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A32Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A32Ch case    1:*/		return 0x8225A330;
	}
	return 0x8225A330;
} // Block from 8225A328h-8225A330h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A330h
// Function '?Find@?$stack@PAVVRegInfo@XGRAPHICS@@@XGRAPHICS@@QBA_NAAPAVVRegInfo@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A330);
		  /* 8225A330h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 8225A330h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A330h case    0:*/		return 0x8225A334;
		  /* 8225A334h */ case    1:  		/* stwu R1, <#[R1 - 144]> */
		/* 8225A334h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8225A334h case    1:*/		return 0x8225A338;
		  /* 8225A338h */ case    2:  		/* mr R31, R3 */
		/* 8225A338h case    2:*/		regs.R31 = regs.R3;
		/* 8225A338h case    2:*/		return 0x8225A33C;
		  /* 8225A33Ch */ case    3:  		/* cmpwi CR6, R3, 0 */
		/* 8225A33Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225A33Ch case    3:*/		return 0x8225A340;
		  /* 8225A340h */ case    4:  		/* bc 12, CR6_LT, 12 */
		/* 8225A340h case    4:*/		if ( regs.CR[6].lt ) { return 0x8225A34C;  }
		/* 8225A340h case    4:*/		return 0x8225A344;
		  /* 8225A344h */ case    5:  		/* cmpwi CR6, R3, 136 */
		/* 8225A344h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000088);
		/* 8225A344h case    5:*/		return 0x8225A348;
		  /* 8225A348h */ case    6:  		/* bc 12, CR6_LT, 40 */
		/* 8225A348h case    6:*/		if ( regs.CR[6].lt ) { return 0x8225A370;  }
		/* 8225A348h case    6:*/		return 0x8225A34C;
	}
	return 0x8225A34C;
} // Block from 8225A330h-8225A34Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225A34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A34C);
		  /* 8225A34Ch */ case    0:  		/* lis R11, -32251 */
		/* 8225A34Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A34Ch case    0:*/		return 0x8225A350;
		  /* 8225A350h */ case    1:  		/* lis R10, -32251 */
		/* 8225A350h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A350h case    1:*/		return 0x8225A354;
		  /* 8225A354h */ case    2:  		/* lis R9, -32253 */
		/* 8225A354h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A354h case    2:*/		return 0x8225A358;
		  /* 8225A358h */ case    3:  		/* addi R6, R11, -21728 */
		/* 8225A358h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A358h case    3:*/		return 0x8225A35C;
		  /* 8225A35Ch */ case    4:  		/* addi R5, R10, -21788 */
		/* 8225A35Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAAE4);
		/* 8225A35Ch case    4:*/		return 0x8225A360;
		  /* 8225A360h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A360h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A360h case    5:*/		return 0x8225A364;
		  /* 8225A364h */ case    6:  		/* li R7, 5226 */
		/* 8225A364h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x146A);
		/* 8225A364h case    6:*/		return 0x8225A368;
		  /* 8225A368h */ case    7:  		/* li R3, 0 */
		/* 8225A368h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A368h case    7:*/		return 0x8225A36C;
		  /* 8225A36Ch */ case    8:  		/* bl -1058660 */
		/* 8225A36Ch case    8:*/		regs.LR = 0x8225A370; return 0x82157C08;
		/* 8225A36Ch case    8:*/		return 0x8225A370;
	}
	return 0x8225A370;
} // Block from 8225A34Ch-8225A370h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A370);
		  /* 8225A370h */ case    0:  		/* lis R11, -32216 */
		/* 8225A370h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225A370h case    0:*/		return 0x8225A374;
		  /* 8225A374h */ case    1:  		/* mulli R10, R31, 36 */
		/* 8225A374h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x24);
		/* 8225A374h case    1:*/		return 0x8225A378;
		  /* 8225A378h */ case    2:  		/* addi R11, R11, 12984 */
		/* 8225A378h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x32B8);
		/* 8225A378h case    2:*/		return 0x8225A37C;
		  /* 8225A37Ch */ case    3:  		/* addi R3, R1, 80 */
		/* 8225A37Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8225A37Ch case    3:*/		return 0x8225A380;
		  /* 8225A380h */ case    4:  		/* add R4, R10, R11 */
		/* 8225A380h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8225A380h case    4:*/		return 0x8225A384;
		  /* 8225A384h */ case    5:  		/* li R5, 36 */
		/* 8225A384h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 8225A384h case    5:*/		return 0x8225A388;
		  /* 8225A388h */ case    6:  		/* bl -1870296 */
		/* 8225A388h case    6:*/		regs.LR = 0x8225A38C; return 0x820919B0;
		/* 8225A388h case    6:*/		return 0x8225A38C;
		  /* 8225A38Ch */ case    7:  		/* lwz R3, <#[R1 + 88]> */
		/* 8225A38Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 8225A38Ch case    7:*/		return 0x8225A390;
	}
	return 0x8225A390;
} // Block from 8225A370h-8225A390h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225A390h
// Function '?MakePredAndSuccEdge@Block@XGRAPHICS@@SAXPAV12@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A390);
		  /* 8225A390h */ case    0:  		/* addi R1, R1, 144 */
		/* 8225A390h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8225A390h case    0:*/		return 0x8225A394;
		  /* 8225A394h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A394h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A394h case    1:*/		return 0x8225A398;
		  /* 8225A398h */ case    2:  		/* mtspr LR, R12 */
		/* 8225A398h case    2:*/		regs.LR = regs.R12;
		/* 8225A398h case    2:*/		return 0x8225A39C;
		  /* 8225A39Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A39Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A39Ch case    3:*/		return 0x8225A3A0;
		  /* 8225A3A0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8225A3A0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A3A0h case    4:*/		return 0x8225A3A4;
	}
	return 0x8225A3A4;
} // Block from 8225A390h-8225A3A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225A3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A3A4);
		  /* 8225A3A4h */ case    0:  		/* nop */
		/* 8225A3A4h case    0:*/		cpu::op::nop();
		/* 8225A3A4h case    0:*/		return 0x8225A3A8;
	}
	return 0x8225A3A8;
} // Block from 8225A3A4h-8225A3A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A3A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A3A8);
		  /* 8225A3A8h */ case    0:  		/* mfspr R12, LR */
		/* 8225A3A8h case    0:*/		regs.R12 = regs.LR;
		/* 8225A3A8h case    0:*/		return 0x8225A3AC;
		  /* 8225A3ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A3ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A3ACh case    1:*/		return 0x8225A3B0;
		  /* 8225A3B0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225A3B0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A3B0h case    2:*/		return 0x8225A3B4;
		  /* 8225A3B4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A3B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A3B4h case    3:*/		return 0x8225A3B8;
		  /* 8225A3B8h */ case    4:  		/* mr R31, R3 */
		/* 8225A3B8h case    4:*/		regs.R31 = regs.R3;
		/* 8225A3B8h case    4:*/		return 0x8225A3BC;
		  /* 8225A3BCh */ case    5:  		/* cmpwi CR6, R3, 0 */
		/* 8225A3BCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225A3BCh case    5:*/		return 0x8225A3C0;
		  /* 8225A3C0h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8225A3C0h case    6:*/		if ( regs.CR[6].lt ) { return 0x8225A3CC;  }
		/* 8225A3C0h case    6:*/		return 0x8225A3C4;
		  /* 8225A3C4h */ case    7:  		/* cmpwi CR6, R3, 136 */
		/* 8225A3C4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000088);
		/* 8225A3C4h case    7:*/		return 0x8225A3C8;
		  /* 8225A3C8h */ case    8:  		/* bc 12, CR6_LT, 40 */
		/* 8225A3C8h case    8:*/		if ( regs.CR[6].lt ) { return 0x8225A3F0;  }
		/* 8225A3C8h case    8:*/		return 0x8225A3CC;
	}
	return 0x8225A3CC;
} // Block from 8225A3A8h-8225A3CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A3CC);
		  /* 8225A3CCh */ case    0:  		/* lis R11, -32251 */
		/* 8225A3CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A3CCh case    0:*/		return 0x8225A3D0;
		  /* 8225A3D0h */ case    1:  		/* lis R10, -32251 */
		/* 8225A3D0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A3D0h case    1:*/		return 0x8225A3D4;
		  /* 8225A3D4h */ case    2:  		/* lis R9, -32253 */
		/* 8225A3D4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A3D4h case    2:*/		return 0x8225A3D8;
		  /* 8225A3D8h */ case    3:  		/* addi R6, R11, -21728 */
		/* 8225A3D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A3D8h case    3:*/		return 0x8225A3DC;
		  /* 8225A3DCh */ case    4:  		/* addi R5, R10, -21788 */
		/* 8225A3DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAAE4);
		/* 8225A3DCh case    4:*/		return 0x8225A3E0;
		  /* 8225A3E0h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A3E0h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A3E0h case    5:*/		return 0x8225A3E4;
		  /* 8225A3E4h */ case    6:  		/* li R7, 5239 */
		/* 8225A3E4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1477);
		/* 8225A3E4h case    6:*/		return 0x8225A3E8;
		  /* 8225A3E8h */ case    7:  		/* li R3, 0 */
		/* 8225A3E8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A3E8h case    7:*/		return 0x8225A3EC;
		  /* 8225A3ECh */ case    8:  		/* bl -1058788 */
		/* 8225A3ECh case    8:*/		regs.LR = 0x8225A3F0; return 0x82157C08;
		/* 8225A3ECh case    8:*/		return 0x8225A3F0;
	}
	return 0x8225A3F0;
} // Block from 8225A3CCh-8225A3F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A3F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A3F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A3F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A3F0);
		  /* 8225A3F0h */ case    0:  		/* lis R11, -32216 */
		/* 8225A3F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225A3F0h case    0:*/		return 0x8225A3F4;
		  /* 8225A3F4h */ case    1:  		/* mulli R10, R31, 36 */
		/* 8225A3F4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x24);
		/* 8225A3F4h case    1:*/		return 0x8225A3F8;
		  /* 8225A3F8h */ case    2:  		/* addi R11, R11, 12984 */
		/* 8225A3F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x32B8);
		/* 8225A3F8h case    2:*/		return 0x8225A3FC;
		  /* 8225A3FCh */ case    3:  		/* addi R11, R11, 4 */
		/* 8225A3FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225A3FCh case    3:*/		return 0x8225A400;
		  /* 8225A400h */ case    4:  		/* lwzx R3, <#[R10 + R11]> */
		/* 8225A400h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8225A400h case    4:*/		return 0x8225A404;
		  /* 8225A404h */ case    5:  		/* addi R1, R1, 96 */
		/* 8225A404h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A404h case    5:*/		return 0x8225A408;
		  /* 8225A408h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A408h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A408h case    6:*/		return 0x8225A40C;
		  /* 8225A40Ch */ case    7:  		/* mtspr LR, R12 */
		/* 8225A40Ch case    7:*/		regs.LR = regs.R12;
		/* 8225A40Ch case    7:*/		return 0x8225A410;
		  /* 8225A410h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A410h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A410h case    8:*/		return 0x8225A414;
		  /* 8225A414h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8225A414h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A414h case    9:*/		return 0x8225A418;
	}
	return 0x8225A418;
} // Block from 8225A3F0h-8225A418h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225A418h
// Function '??1Block@XGRAPHICS@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A418);
		  /* 8225A418h */ case    0:  		/* mfspr R12, LR */
		/* 8225A418h case    0:*/		regs.R12 = regs.LR;
		/* 8225A418h case    0:*/		return 0x8225A41C;
		  /* 8225A41Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A41Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A41Ch case    1:*/		return 0x8225A420;
		  /* 8225A420h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225A420h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A420h case    2:*/		return 0x8225A424;
		  /* 8225A424h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A424h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A424h case    3:*/		return 0x8225A428;
		  /* 8225A428h */ case    4:  		/* mr R31, R3 */
		/* 8225A428h case    4:*/		regs.R31 = regs.R3;
		/* 8225A428h case    4:*/		return 0x8225A42C;
		  /* 8225A42Ch */ case    5:  		/* cmpwi CR6, R3, 0 */
		/* 8225A42Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225A42Ch case    5:*/		return 0x8225A430;
		  /* 8225A430h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8225A430h case    6:*/		if ( regs.CR[6].lt ) { return 0x8225A43C;  }
		/* 8225A430h case    6:*/		return 0x8225A434;
		  /* 8225A434h */ case    7:  		/* cmpwi CR6, R3, 136 */
		/* 8225A434h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000088);
		/* 8225A434h case    7:*/		return 0x8225A438;
		  /* 8225A438h */ case    8:  		/* bc 12, CR6_LT, 40 */
		/* 8225A438h case    8:*/		if ( regs.CR[6].lt ) { return 0x8225A460;  }
		/* 8225A438h case    8:*/		return 0x8225A43C;
	}
	return 0x8225A43C;
} // Block from 8225A418h-8225A43Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A43C);
		  /* 8225A43Ch */ case    0:  		/* lis R11, -32251 */
		/* 8225A43Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A43Ch case    0:*/		return 0x8225A440;
		  /* 8225A440h */ case    1:  		/* lis R10, -32251 */
		/* 8225A440h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A440h case    1:*/		return 0x8225A444;
		  /* 8225A444h */ case    2:  		/* lis R9, -32253 */
		/* 8225A444h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A444h case    2:*/		return 0x8225A448;
		  /* 8225A448h */ case    3:  		/* addi R6, R11, -21728 */
		/* 8225A448h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A448h case    3:*/		return 0x8225A44C;
		  /* 8225A44Ch */ case    4:  		/* addi R5, R10, -21788 */
		/* 8225A44Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAAE4);
		/* 8225A44Ch case    4:*/		return 0x8225A450;
		  /* 8225A450h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A450h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A450h case    5:*/		return 0x8225A454;
		  /* 8225A454h */ case    6:  		/* li R7, 5319 */
		/* 8225A454h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x14C7);
		/* 8225A454h case    6:*/		return 0x8225A458;
		  /* 8225A458h */ case    7:  		/* li R3, 0 */
		/* 8225A458h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A458h case    7:*/		return 0x8225A45C;
		  /* 8225A45Ch */ case    8:  		/* bl -1058900 */
		/* 8225A45Ch case    8:*/		regs.LR = 0x8225A460; return 0x82157C08;
		/* 8225A45Ch case    8:*/		return 0x8225A460;
	}
	return 0x8225A460;
} // Block from 8225A43Ch-8225A460h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A460);
		  /* 8225A460h */ case    0:  		/* lis R11, -32216 */
		/* 8225A460h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225A460h case    0:*/		return 0x8225A464;
		  /* 8225A464h */ case    1:  		/* mulli R10, R31, 36 */
		/* 8225A464h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x24);
		/* 8225A464h case    1:*/		return 0x8225A468;
		  /* 8225A468h */ case    2:  		/* addi R11, R11, 12984 */
		/* 8225A468h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x32B8);
		/* 8225A468h case    2:*/		return 0x8225A46C;
		  /* 8225A46Ch */ case    3:  		/* addi R11, R11, 12 */
		/* 8225A46Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8225A46Ch case    3:*/		return 0x8225A470;
		  /* 8225A470h */ case    4:  		/* lwzx R3, <#[R10 + R11]> */
		/* 8225A470h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8225A470h case    4:*/		return 0x8225A474;
		  /* 8225A474h */ case    5:  		/* addi R1, R1, 96 */
		/* 8225A474h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A474h case    5:*/		return 0x8225A478;
		  /* 8225A478h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A478h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A478h case    6:*/		return 0x8225A47C;
		  /* 8225A47Ch */ case    7:  		/* mtspr LR, R12 */
		/* 8225A47Ch case    7:*/		regs.LR = regs.R12;
		/* 8225A47Ch case    7:*/		return 0x8225A480;
		  /* 8225A480h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A480h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A480h case    8:*/		return 0x8225A484;
		  /* 8225A484h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8225A484h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A484h case    9:*/		return 0x8225A488;
	}
	return 0x8225A488;
} // Block from 8225A460h-8225A488h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225A488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A488);
		  /* 8225A488h */ case    0:  		/* mfspr R12, LR */
		/* 8225A488h case    0:*/		regs.R12 = regs.LR;
		/* 8225A488h case    0:*/		return 0x8225A48C;
		  /* 8225A48Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A48Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A48Ch case    1:*/		return 0x8225A490;
		  /* 8225A490h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225A490h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A490h case    2:*/		return 0x8225A494;
		  /* 8225A494h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A494h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A494h case    3:*/		return 0x8225A498;
		  /* 8225A498h */ case    4:  		/* mr R31, R3 */
		/* 8225A498h case    4:*/		regs.R31 = regs.R3;
		/* 8225A498h case    4:*/		return 0x8225A49C;
		  /* 8225A49Ch */ case    5:  		/* cmpwi CR6, R3, 0 */
		/* 8225A49Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225A49Ch case    5:*/		return 0x8225A4A0;
		  /* 8225A4A0h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8225A4A0h case    6:*/		if ( regs.CR[6].lt ) { return 0x8225A4AC;  }
		/* 8225A4A0h case    6:*/		return 0x8225A4A4;
		  /* 8225A4A4h */ case    7:  		/* cmpwi CR6, R3, 136 */
		/* 8225A4A4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000088);
		/* 8225A4A4h case    7:*/		return 0x8225A4A8;
		  /* 8225A4A8h */ case    8:  		/* bc 12, CR6_LT, 40 */
		/* 8225A4A8h case    8:*/		if ( regs.CR[6].lt ) { return 0x8225A4D0;  }
		/* 8225A4A8h case    8:*/		return 0x8225A4AC;
	}
	return 0x8225A4AC;
} // Block from 8225A488h-8225A4ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A4ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A4AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A4AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A4AC);
		  /* 8225A4ACh */ case    0:  		/* lis R11, -32251 */
		/* 8225A4ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A4ACh case    0:*/		return 0x8225A4B0;
		  /* 8225A4B0h */ case    1:  		/* lis R10, -32251 */
		/* 8225A4B0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A4B0h case    1:*/		return 0x8225A4B4;
		  /* 8225A4B4h */ case    2:  		/* lis R9, -32253 */
		/* 8225A4B4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A4B4h case    2:*/		return 0x8225A4B8;
		  /* 8225A4B8h */ case    3:  		/* addi R6, R11, -21728 */
		/* 8225A4B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A4B8h case    3:*/		return 0x8225A4BC;
		  /* 8225A4BCh */ case    4:  		/* addi R5, R10, -21788 */
		/* 8225A4BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAAE4);
		/* 8225A4BCh case    4:*/		return 0x8225A4C0;
		  /* 8225A4C0h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A4C0h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A4C0h case    5:*/		return 0x8225A4C4;
		  /* 8225A4C4h */ case    6:  		/* li R7, 5351 */
		/* 8225A4C4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x14E7);
		/* 8225A4C4h case    6:*/		return 0x8225A4C8;
		  /* 8225A4C8h */ case    7:  		/* li R3, 0 */
		/* 8225A4C8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A4C8h case    7:*/		return 0x8225A4CC;
		  /* 8225A4CCh */ case    8:  		/* bl -1059012 */
		/* 8225A4CCh case    8:*/		regs.LR = 0x8225A4D0; return 0x82157C08;
		/* 8225A4CCh case    8:*/		return 0x8225A4D0;
	}
	return 0x8225A4D0;
} // Block from 8225A4ACh-8225A4D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A4D0h
// Function '?ReplaceSuccessor@Block@XGRAPHICS@@IAAXPAV12@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A4D0);
		  /* 8225A4D0h */ case    0:  		/* lis R11, -32216 */
		/* 8225A4D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225A4D0h case    0:*/		return 0x8225A4D4;
		  /* 8225A4D4h */ case    1:  		/* mulli R10, R31, 36 */
		/* 8225A4D4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x24);
		/* 8225A4D4h case    1:*/		return 0x8225A4D8;
		  /* 8225A4D8h */ case    2:  		/* addi R11, R11, 12984 */
		/* 8225A4D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x32B8);
		/* 8225A4D8h case    2:*/		return 0x8225A4DC;
		  /* 8225A4DCh */ case    3:  		/* addi R11, R11, 24 */
		/* 8225A4DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8225A4DCh case    3:*/		return 0x8225A4E0;
		  /* 8225A4E0h */ case    4:  		/* lwzx R3, <#[R10 + R11]> */
		/* 8225A4E0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8225A4E0h case    4:*/		return 0x8225A4E4;
		  /* 8225A4E4h */ case    5:  		/* addi R1, R1, 96 */
		/* 8225A4E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A4E4h case    5:*/		return 0x8225A4E8;
		  /* 8225A4E8h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A4E8h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A4E8h case    6:*/		return 0x8225A4EC;
		  /* 8225A4ECh */ case    7:  		/* mtspr LR, R12 */
		/* 8225A4ECh case    7:*/		regs.LR = regs.R12;
		/* 8225A4ECh case    7:*/		return 0x8225A4F0;
		  /* 8225A4F0h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A4F0h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A4F0h case    8:*/		return 0x8225A4F4;
		  /* 8225A4F4h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8225A4F4h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A4F4h case    9:*/		return 0x8225A4F8;
	}
	return 0x8225A4F8;
} // Block from 8225A4D0h-8225A4F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225A4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A4F8);
		  /* 8225A4F8h */ case    0:  		/* mfspr R12, LR */
		/* 8225A4F8h case    0:*/		regs.R12 = regs.LR;
		/* 8225A4F8h case    0:*/		return 0x8225A4FC;
		  /* 8225A4FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A4FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A4FCh case    1:*/		return 0x8225A500;
		  /* 8225A500h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225A500h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A500h case    2:*/		return 0x8225A504;
		  /* 8225A504h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A504h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A504h case    3:*/		return 0x8225A508;
		  /* 8225A508h */ case    4:  		/* mr R31, R3 */
		/* 8225A508h case    4:*/		regs.R31 = regs.R3;
		/* 8225A508h case    4:*/		return 0x8225A50C;
		  /* 8225A50Ch */ case    5:  		/* cmpwi CR6, R3, 0 */
		/* 8225A50Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8225A50Ch case    5:*/		return 0x8225A510;
		  /* 8225A510h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 8225A510h case    6:*/		if ( regs.CR[6].lt ) { return 0x8225A51C;  }
		/* 8225A510h case    6:*/		return 0x8225A514;
		  /* 8225A514h */ case    7:  		/* cmpwi CR6, R3, 136 */
		/* 8225A514h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000088);
		/* 8225A514h case    7:*/		return 0x8225A518;
		  /* 8225A518h */ case    8:  		/* bc 12, CR6_LT, 40 */
		/* 8225A518h case    8:*/		if ( regs.CR[6].lt ) { return 0x8225A540;  }
		/* 8225A518h case    8:*/		return 0x8225A51C;
	}
	return 0x8225A51C;
} // Block from 8225A4F8h-8225A51Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A51C);
		  /* 8225A51Ch */ case    0:  		/* lis R11, -32251 */
		/* 8225A51Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A51Ch case    0:*/		return 0x8225A520;
		  /* 8225A520h */ case    1:  		/* lis R10, -32251 */
		/* 8225A520h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A520h case    1:*/		return 0x8225A524;
		  /* 8225A524h */ case    2:  		/* lis R9, -32253 */
		/* 8225A524h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A524h case    2:*/		return 0x8225A528;
		  /* 8225A528h */ case    3:  		/* addi R6, R11, -21728 */
		/* 8225A528h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A528h case    3:*/		return 0x8225A52C;
		  /* 8225A52Ch */ case    4:  		/* addi R5, R10, -21788 */
		/* 8225A52Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAAE4);
		/* 8225A52Ch case    4:*/		return 0x8225A530;
		  /* 8225A530h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A530h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A530h case    5:*/		return 0x8225A534;
		  /* 8225A534h */ case    6:  		/* li R7, 5363 */
		/* 8225A534h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x14F3);
		/* 8225A534h case    6:*/		return 0x8225A538;
		  /* 8225A538h */ case    7:  		/* li R3, 0 */
		/* 8225A538h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A538h case    7:*/		return 0x8225A53C;
		  /* 8225A53Ch */ case    8:  		/* bl -1059124 */
		/* 8225A53Ch case    8:*/		regs.LR = 0x8225A540; return 0x82157C08;
		/* 8225A53Ch case    8:*/		return 0x8225A540;
	}
	return 0x8225A540;
} // Block from 8225A51Ch-8225A540h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A540);
		  /* 8225A540h */ case    0:  		/* lis R11, -32216 */
		/* 8225A540h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225A540h case    0:*/		return 0x8225A544;
		  /* 8225A544h */ case    1:  		/* mulli R10, R31, 36 */
		/* 8225A544h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x24);
		/* 8225A544h case    1:*/		return 0x8225A548;
		  /* 8225A548h */ case    2:  		/* addi R11, R11, 12984 */
		/* 8225A548h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x32B8);
		/* 8225A548h case    2:*/		return 0x8225A54C;
		  /* 8225A54Ch */ case    3:  		/* addi R11, R11, 16 */
		/* 8225A54Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8225A54Ch case    3:*/		return 0x8225A550;
		  /* 8225A550h */ case    4:  		/* lwzx R3, <#[R10 + R11]> */
		/* 8225A550h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8225A550h case    4:*/		return 0x8225A554;
		  /* 8225A554h */ case    5:  		/* addi R1, R1, 96 */
		/* 8225A554h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A554h case    5:*/		return 0x8225A558;
		  /* 8225A558h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A558h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A558h case    6:*/		return 0x8225A55C;
		  /* 8225A55Ch */ case    7:  		/* mtspr LR, R12 */
		/* 8225A55Ch case    7:*/		regs.LR = regs.R12;
		/* 8225A55Ch case    7:*/		return 0x8225A560;
		  /* 8225A560h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A560h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A560h case    8:*/		return 0x8225A564;
		  /* 8225A564h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8225A564h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A564h case    9:*/		return 0x8225A568;
	}
	return 0x8225A568;
} // Block from 8225A540h-8225A568h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225A568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A568);
		  /* 8225A568h */ case    0:  		/* mfspr R12, LR */
		/* 8225A568h case    0:*/		regs.R12 = regs.LR;
		/* 8225A568h case    0:*/		return 0x8225A56C;
		  /* 8225A56Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A56Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A56Ch case    1:*/		return 0x8225A570;
		  /* 8225A570h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A570h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A570h case    2:*/		return 0x8225A574;
		  /* 8225A574h */ case    3:  		/* cmplwi CR6, R3, 1 */
		/* 8225A574h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8225A574h case    3:*/		return 0x8225A578;
		  /* 8225A578h */ case    4:  		/* bc 12, CR6_LT, 88 */
		/* 8225A578h case    4:*/		if ( regs.CR[6].lt ) { return 0x8225A5D0;  }
		/* 8225A578h case    4:*/		return 0x8225A57C;
		  /* 8225A57Ch */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 8225A57Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8225A5C8;  }
		/* 8225A57Ch case    5:*/		return 0x8225A580;
		  /* 8225A580h */ case    6:  		/* cmplwi CR6, R3, 3 */
		/* 8225A580h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000003);
		/* 8225A580h case    6:*/		return 0x8225A584;
		  /* 8225A584h */ case    7:  		/* bc 12, CR6_LT, 60 */
		/* 8225A584h case    7:*/		if ( regs.CR[6].lt ) { return 0x8225A5C0;  }
		/* 8225A584h case    7:*/		return 0x8225A588;
		  /* 8225A588h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8225A588h case    8:*/		if ( regs.CR[6].eq ) { return 0x8225A5B8;  }
		/* 8225A588h case    8:*/		return 0x8225A58C;
		  /* 8225A58Ch */ case    9:  		/* lis R11, -32251 */
		/* 8225A58Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A58Ch case    9:*/		return 0x8225A590;
		  /* 8225A590h */ case   10:  		/* lis R10, -32255 */
		/* 8225A590h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8225A590h case   10:*/		return 0x8225A594;
		  /* 8225A594h */ case   11:  		/* lis R9, -32253 */
		/* 8225A594h case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A594h case   11:*/		return 0x8225A598;
		  /* 8225A598h */ case   12:  		/* addi R6, R11, -21728 */
		/* 8225A598h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A598h case   12:*/		return 0x8225A59C;
		  /* 8225A59Ch */ case   13:  		/* addi R5, R10, 5216 */
		/* 8225A59Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8225A59Ch case   13:*/		return 0x8225A5A0;
		  /* 8225A5A0h */ case   14:  		/* addi R4, R9, 27460 */
		/* 8225A5A0h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A5A0h case   14:*/		return 0x8225A5A4;
		  /* 8225A5A4h */ case   15:  		/* li R7, 5399 */
		/* 8225A5A4h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x1517);
		/* 8225A5A4h case   15:*/		return 0x8225A5A8;
		  /* 8225A5A8h */ case   16:  		/* li R3, 0 */
		/* 8225A5A8h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A5A8h case   16:*/		return 0x8225A5AC;
		  /* 8225A5ACh */ case   17:  		/* bl -1059236 */
		/* 8225A5ACh case   17:*/		regs.LR = 0x8225A5B0; return 0x82157C08;
		/* 8225A5ACh case   17:*/		return 0x8225A5B0;
		  /* 8225A5B0h */ case   18:  		/* li R3, 6 */
		/* 8225A5B0h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x6);
		/* 8225A5B0h case   18:*/		return 0x8225A5B4;
		  /* 8225A5B4h */ case   19:  		/* b 32 */
		/* 8225A5B4h case   19:*/		return 0x8225A5D4;
		/* 8225A5B4h case   19:*/		return 0x8225A5B8;
	}
	return 0x8225A5B8;
} // Block from 8225A568h-8225A5B8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5B8);
		  /* 8225A5B8h */ case    0:  		/* li R3, 5 */
		/* 8225A5B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x5);
		/* 8225A5B8h case    0:*/		return 0x8225A5BC;
		  /* 8225A5BCh */ case    1:  		/* b 24 */
		/* 8225A5BCh case    1:*/		return 0x8225A5D4;
		/* 8225A5BCh case    1:*/		return 0x8225A5C0;
	}
	return 0x8225A5C0;
} // Block from 8225A5B8h-8225A5C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5C0);
		  /* 8225A5C0h */ case    0:  		/* li R3, 4 */
		/* 8225A5C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 8225A5C0h case    0:*/		return 0x8225A5C4;
		  /* 8225A5C4h */ case    1:  		/* b 16 */
		/* 8225A5C4h case    1:*/		return 0x8225A5D4;
		/* 8225A5C4h case    1:*/		return 0x8225A5C8;
	}
	return 0x8225A5C8;
} // Block from 8225A5C0h-8225A5C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5C8);
		  /* 8225A5C8h */ case    0:  		/* li R3, 2 */
		/* 8225A5C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8225A5C8h case    0:*/		return 0x8225A5CC;
		  /* 8225A5CCh */ case    1:  		/* b 8 */
		/* 8225A5CCh case    1:*/		return 0x8225A5D4;
		/* 8225A5CCh case    1:*/		return 0x8225A5D0;
	}
	return 0x8225A5D0;
} // Block from 8225A5C8h-8225A5D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5D0h
// Function '?PopAllDefNodes@Block@XGRAPHICS@@IAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5D0);
		  /* 8225A5D0h */ case    0:  		/* li R3, 0 */
		/* 8225A5D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A5D0h case    0:*/		return 0x8225A5D4;
	}
	return 0x8225A5D4;
} // Block from 8225A5D0h-8225A5D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5D4);
		  /* 8225A5D4h */ case    0:  		/* addi R1, R1, 96 */
		/* 8225A5D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A5D4h case    0:*/		return 0x8225A5D8;
		  /* 8225A5D8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A5D8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A5D8h case    1:*/		return 0x8225A5DC;
		  /* 8225A5DCh */ case    2:  		/* mtspr LR, R12 */
		/* 8225A5DCh case    2:*/		regs.LR = regs.R12;
		/* 8225A5DCh case    2:*/		return 0x8225A5E0;
		  /* 8225A5E0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8225A5E0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A5E0h case    3:*/		return 0x8225A5E4;
	}
	return 0x8225A5E4;
} // Block from 8225A5D4h-8225A5E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5E4);
		  /* 8225A5E4h */ case    0:  		/* nop */
		/* 8225A5E4h case    0:*/		cpu::op::nop();
		/* 8225A5E4h case    0:*/		return 0x8225A5E8;
	}
	return 0x8225A5E8;
} // Block from 8225A5E4h-8225A5E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A5E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A5E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A5E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A5E8);
		  /* 8225A5E8h */ case    0:  		/* mfspr R12, LR */
		/* 8225A5E8h case    0:*/		regs.R12 = regs.LR;
		/* 8225A5E8h case    0:*/		return 0x8225A5EC;
		  /* 8225A5ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A5ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A5ECh case    1:*/		return 0x8225A5F0;
		  /* 8225A5F0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A5F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A5F0h case    2:*/		return 0x8225A5F4;
		  /* 8225A5F4h */ case    3:  		/* cmplwi CR6, R3, 1 */
		/* 8225A5F4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8225A5F4h case    3:*/		return 0x8225A5F8;
		  /* 8225A5F8h */ case    4:  		/* bc 12, CR6_LT, 116 */
		/* 8225A5F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8225A66C;  }
		/* 8225A5F8h case    4:*/		return 0x8225A5FC;
		  /* 8225A5FCh */ case    5:  		/* bc 12, CR6_EQ, 104 */
		/* 8225A5FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8225A664;  }
		/* 8225A5FCh case    5:*/		return 0x8225A600;
		  /* 8225A600h */ case    6:  		/* cmplwi CR6, R3, 3 */
		/* 8225A600h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000003);
		/* 8225A600h case    6:*/		return 0x8225A604;
		  /* 8225A604h */ case    7:  		/* bc 12, CR6_LT, 88 */
		/* 8225A604h case    7:*/		if ( regs.CR[6].lt ) { return 0x8225A65C;  }
		/* 8225A604h case    7:*/		return 0x8225A608;
		  /* 8225A608h */ case    8:  		/* bc 12, CR6_EQ, 76 */
		/* 8225A608h case    8:*/		if ( regs.CR[6].eq ) { return 0x8225A654;  }
		/* 8225A608h case    8:*/		return 0x8225A60C;
		  /* 8225A60Ch */ case    9:  		/* cmplwi CR6, R3, 5 */
		/* 8225A60Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000005);
		/* 8225A60Ch case    9:*/		return 0x8225A610;
		  /* 8225A610h */ case   10:  		/* bc 12, CR6_LT, 60 */
		/* 8225A610h case   10:*/		if ( regs.CR[6].lt ) { return 0x8225A64C;  }
		/* 8225A610h case   10:*/		return 0x8225A614;
		  /* 8225A614h */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 8225A614h case   11:*/		if ( regs.CR[6].eq ) { return 0x8225A644;  }
		/* 8225A614h case   11:*/		return 0x8225A618;
	}
	return 0x8225A618;
} // Block from 8225A5E8h-8225A618h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225A618h
// Function '?PushDefNode@Block@XGRAPHICS@@IAAXPAVVRegInfo@2@PAUCurrentValue@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A618);
		  /* 8225A618h */ case    0:  		/* lis R11, -32251 */
		/* 8225A618h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A618h case    0:*/		return 0x8225A61C;
		  /* 8225A61Ch */ case    1:  		/* lis R10, -32255 */
		/* 8225A61Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8225A61Ch case    1:*/		return 0x8225A620;
		  /* 8225A620h */ case    2:  		/* lis R9, -32253 */
		/* 8225A620h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A620h case    2:*/		return 0x8225A624;
		  /* 8225A624h */ case    3:  		/* addi R6, R11, -21728 */
		/* 8225A624h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A624h case    3:*/		return 0x8225A628;
		  /* 8225A628h */ case    4:  		/* addi R5, R10, 5216 */
		/* 8225A628h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8225A628h case    4:*/		return 0x8225A62C;
		  /* 8225A62Ch */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A62Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A62Ch case    5:*/		return 0x8225A630;
		  /* 8225A630h */ case    6:  		/* li R7, 5422 */
		/* 8225A630h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x152E);
		/* 8225A630h case    6:*/		return 0x8225A634;
		  /* 8225A634h */ case    7:  		/* li R3, 0 */
		/* 8225A634h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A634h case    7:*/		return 0x8225A638;
		  /* 8225A638h */ case    8:  		/* bl -1059376 */
		/* 8225A638h case    8:*/		regs.LR = 0x8225A63C; return 0x82157C08;
		/* 8225A638h case    8:*/		return 0x8225A63C;
		  /* 8225A63Ch */ case    9:  		/* li R3, 0 */
		/* 8225A63Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A63Ch case    9:*/		return 0x8225A640;
		  /* 8225A640h */ case   10:  		/* b 48 */
		/* 8225A640h case   10:*/		return 0x8225A670;
		/* 8225A640h case   10:*/		return 0x8225A644;
	}
	return 0x8225A644;
} // Block from 8225A618h-8225A644h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225A644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A644);
		  /* 8225A644h */ case    0:  		/* li R3, 19 */
		/* 8225A644h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 8225A644h case    0:*/		return 0x8225A648;
		  /* 8225A648h */ case    1:  		/* b 40 */
		/* 8225A648h case    1:*/		return 0x8225A670;
		/* 8225A648h case    1:*/		return 0x8225A64C;
	}
	return 0x8225A64C;
} // Block from 8225A644h-8225A64Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A64C);
		  /* 8225A64Ch */ case    0:  		/* li R3, 23 */
		/* 8225A64Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x17);
		/* 8225A64Ch case    0:*/		return 0x8225A650;
		  /* 8225A650h */ case    1:  		/* b 32 */
		/* 8225A650h case    1:*/		return 0x8225A670;
		/* 8225A650h case    1:*/		return 0x8225A654;
	}
	return 0x8225A654;
} // Block from 8225A64Ch-8225A654h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A654);
		  /* 8225A654h */ case    0:  		/* li R3, 22 */
		/* 8225A654h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x16);
		/* 8225A654h case    0:*/		return 0x8225A658;
		  /* 8225A658h */ case    1:  		/* b 24 */
		/* 8225A658h case    1:*/		return 0x8225A670;
		/* 8225A658h case    1:*/		return 0x8225A65C;
	}
	return 0x8225A65C;
} // Block from 8225A654h-8225A65Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A65C);
		  /* 8225A65Ch */ case    0:  		/* li R3, 21 */
		/* 8225A65Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x15);
		/* 8225A65Ch case    0:*/		return 0x8225A660;
		  /* 8225A660h */ case    1:  		/* b 16 */
		/* 8225A660h case    1:*/		return 0x8225A670;
		/* 8225A660h case    1:*/		return 0x8225A664;
	}
	return 0x8225A664;
} // Block from 8225A65Ch-8225A664h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A664);
		  /* 8225A664h */ case    0:  		/* li R3, 6 */
		/* 8225A664h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x6);
		/* 8225A664h case    0:*/		return 0x8225A668;
		  /* 8225A668h */ case    1:  		/* b 8 */
		/* 8225A668h case    1:*/		return 0x8225A670;
		/* 8225A668h case    1:*/		return 0x8225A66C;
	}
	return 0x8225A66C;
} // Block from 8225A664h-8225A66Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A66C);
		  /* 8225A66Ch */ case    0:  		/* li R3, 5 */
		/* 8225A66Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x5);
		/* 8225A66Ch case    0:*/		return 0x8225A670;
	}
	return 0x8225A670;
} // Block from 8225A66Ch-8225A670h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A670);
		  /* 8225A670h */ case    0:  		/* addi R1, R1, 96 */
		/* 8225A670h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A670h case    0:*/		return 0x8225A674;
		  /* 8225A674h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A674h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A674h case    1:*/		return 0x8225A678;
	}
	return 0x8225A678;
} // Block from 8225A670h-8225A678h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A678h
// Function '??0EntryBlock@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A678);
		  /* 8225A678h */ case    0:  		/* mtspr LR, R12 */
		/* 8225A678h case    0:*/		regs.LR = regs.R12;
		/* 8225A678h case    0:*/		return 0x8225A67C;
		  /* 8225A67Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8225A67Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A67Ch case    1:*/		return 0x8225A680;
	}
	return 0x8225A680;
} // Block from 8225A678h-8225A680h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A680);
		  /* 8225A680h */ case    0:  		/* mfspr R12, LR */
		/* 8225A680h case    0:*/		regs.R12 = regs.LR;
		/* 8225A680h case    0:*/		return 0x8225A684;
		  /* 8225A684h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A684h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A684h case    1:*/		return 0x8225A688;
		  /* 8225A688h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A688h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A688h case    2:*/		return 0x8225A68C;
		  /* 8225A68Ch */ case    3:  		/* cmplwi CR6, R3, 1 */
		/* 8225A68Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8225A68Ch case    3:*/		return 0x8225A690;
		  /* 8225A690h */ case    4:  		/* bc 12, CR6_LT, 56 */
		/* 8225A690h case    4:*/		if ( regs.CR[6].lt ) { return 0x8225A6C8;  }
		/* 8225A690h case    4:*/		return 0x8225A694;
		  /* 8225A694h */ case    5:  		/* bc 12, CR6_EQ, 80 */
		/* 8225A694h case    5:*/		if ( regs.CR[6].eq ) { return 0x8225A6E4;  }
		/* 8225A694h case    5:*/		return 0x8225A698;
		  /* 8225A698h */ case    6:  		/* cmplwi CR6, R3, 3 */
		/* 8225A698h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000003);
		/* 8225A698h case    6:*/		return 0x8225A69C;
		  /* 8225A69Ch */ case    7:  		/* bc 12, CR6_LT, 64 */
		/* 8225A69Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x8225A6DC;  }
		/* 8225A69Ch case    7:*/		return 0x8225A6A0;
		  /* 8225A6A0h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 8225A6A0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8225A6C8;  }
		/* 8225A6A0h case    8:*/		return 0x8225A6A4;
		  /* 8225A6A4h */ case    9:  		/* lis R11, -32251 */
		/* 8225A6A4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A6A4h case    9:*/		return 0x8225A6A8;
		  /* 8225A6A8h */ case   10:  		/* lis R10, -32255 */
		/* 8225A6A8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8225A6A8h case   10:*/		return 0x8225A6AC;
		  /* 8225A6ACh */ case   11:  		/* lis R9, -32253 */
		/* 8225A6ACh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A6ACh case   11:*/		return 0x8225A6B0;
		  /* 8225A6B0h */ case   12:  		/* addi R6, R11, -21728 */
		/* 8225A6B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAB20);
		/* 8225A6B0h case   12:*/		return 0x8225A6B4;
		  /* 8225A6B4h */ case   13:  		/* addi R5, R10, 5216 */
		/* 8225A6B4h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1460);
		/* 8225A6B4h case   13:*/		return 0x8225A6B8;
		  /* 8225A6B8h */ case   14:  		/* addi R4, R9, 27460 */
		/* 8225A6B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A6B8h case   14:*/		return 0x8225A6BC;
		  /* 8225A6BCh */ case   15:  		/* li R7, 5448 */
		/* 8225A6BCh case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x1548);
		/* 8225A6BCh case   15:*/		return 0x8225A6C0;
	}
	return 0x8225A6C0;
} // Block from 8225A680h-8225A6C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225A6C0h
// Function '?TypeName@EntryBlock@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A6C0);
		  /* 8225A6C0h */ case    0:  		/* li R3, 0 */
		/* 8225A6C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A6C0h case    0:*/		return 0x8225A6C4;
		  /* 8225A6C4h */ case    1:  		/* bl -1059516 */
		/* 8225A6C4h case    1:*/		regs.LR = 0x8225A6C8; return 0x82157C08;
		/* 8225A6C4h case    1:*/		return 0x8225A6C8;
	}
	return 0x8225A6C8;
} // Block from 8225A6C0h-8225A6C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A6C8);
		  /* 8225A6C8h */ case    0:  		/* li R3, 3 */
		/* 8225A6C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 8225A6C8h case    0:*/		return 0x8225A6CC;
		  /* 8225A6CCh */ case    1:  		/* addi R1, R1, 96 */
		/* 8225A6CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A6CCh case    1:*/		return 0x8225A6D0;
	}
	return 0x8225A6D0;
} // Block from 8225A6C8h-8225A6D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A6D0h
// Function '??0ExitBlock@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A6D0);
		  /* 8225A6D0h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A6D0h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A6D0h case    0:*/		return 0x8225A6D4;
		  /* 8225A6D4h */ case    1:  		/* mtspr LR, R12 */
		/* 8225A6D4h case    1:*/		regs.LR = regs.R12;
		/* 8225A6D4h case    1:*/		return 0x8225A6D8;
		  /* 8225A6D8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8225A6D8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A6D8h case    2:*/		return 0x8225A6DC;
	}
	return 0x8225A6DC;
} // Block from 8225A6D0h-8225A6DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225A6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A6DC);
		  /* 8225A6DCh */ case    0:  		/* li R3, 1 */
		/* 8225A6DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8225A6DCh case    0:*/		return 0x8225A6E0;
		  /* 8225A6E0h */ case    1:  		/* b -20 */
		/* 8225A6E0h case    1:*/		return 0x8225A6CC;
		/* 8225A6E0h case    1:*/		return 0x8225A6E4;
	}
	return 0x8225A6E4;
} // Block from 8225A6DCh-8225A6E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A6E4);
		  /* 8225A6E4h */ case    0:  		/* li R3, 0 */
		/* 8225A6E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A6E4h case    0:*/		return 0x8225A6E8;
		  /* 8225A6E8h */ case    1:  		/* b -28 */
		/* 8225A6E8h case    1:*/		return 0x8225A6CC;
		/* 8225A6E8h case    1:*/		return 0x8225A6EC;
		  /* 8225A6ECh */ case    2:  		/* nop */
		/* 8225A6ECh case    2:*/		cpu::op::nop();
		/* 8225A6ECh case    2:*/		return 0x8225A6F0;
	}
	return 0x8225A6F0;
} // Block from 8225A6E4h-8225A6F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225A6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A6F0);
		  /* 8225A6F0h */ case    0:  		/* mfspr R12, LR */
		/* 8225A6F0h case    0:*/		regs.R12 = regs.LR;
		/* 8225A6F0h case    0:*/		return 0x8225A6F4;
		  /* 8225A6F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A6F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A6F4h case    1:*/		return 0x8225A6F8;
		  /* 8225A6F8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225A6F8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A6F8h case    2:*/		return 0x8225A6FC;
		  /* 8225A6FCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225A6FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225A6FCh case    3:*/		return 0x8225A700;
		  /* 8225A700h */ case    4:  		/* mr R31, R4 */
		/* 8225A700h case    4:*/		regs.R31 = regs.R4;
		/* 8225A700h case    4:*/		return 0x8225A704;
		  /* 8225A704h */ case    5:  		/* addi R4, R3, 4 */
		/* 8225A704h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 8225A704h case    5:*/		return 0x8225A708;
		  /* 8225A708h */ case    6:  		/* mr R3, R31 */
		/* 8225A708h case    6:*/		regs.R3 = regs.R31;
		/* 8225A708h case    6:*/		return 0x8225A70C;
		  /* 8225A70Ch */ case    7:  		/* bl -254548 */
		/* 8225A70Ch case    7:*/		regs.LR = 0x8225A710; return 0x8221C4B8;
		/* 8225A70Ch case    7:*/		return 0x8225A710;
	}
	return 0x8225A710;
} // Block from 8225A6F0h-8225A710h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225A710h
// Function '?TypeName@ExitBlock@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A710);
		  /* 8225A710h */ case    0:  		/* mr R11, R3 */
		/* 8225A710h case    0:*/		regs.R11 = regs.R3;
		/* 8225A710h case    0:*/		return 0x8225A714;
		  /* 8225A714h */ case    1:  		/* addi R3, R3, 4 */
		/* 8225A714h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8225A714h case    1:*/		return 0x8225A718;
		  /* 8225A718h */ case    2:  		/* stw R31, <#[R11]> */
		/* 8225A718h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8225A718h case    2:*/		return 0x8225A71C;
		  /* 8225A71Ch */ case    3:  		/* addi R1, R1, 96 */
		/* 8225A71Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225A71Ch case    3:*/		return 0x8225A720;
	}
	return 0x8225A720;
} // Block from 8225A710h-8225A720h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A720h
// Function '??0IfHeader@XGRAPHICS@@IAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A720);
		  /* 8225A720h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A720h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A720h case    0:*/		return 0x8225A724;
		  /* 8225A724h */ case    1:  		/* mtspr LR, R12 */
		/* 8225A724h case    1:*/		regs.LR = regs.R12;
		/* 8225A724h case    1:*/		return 0x8225A728;
		  /* 8225A728h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A728h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A728h case    2:*/		return 0x8225A72C;
		  /* 8225A72Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8225A72Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A72Ch case    3:*/		return 0x8225A730;
	}
	return 0x8225A730;
} // Block from 8225A720h-8225A730h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A730);
		  /* 8225A730h */ case    0:  		/* mfspr R12, LR */
		/* 8225A730h case    0:*/		regs.R12 = regs.LR;
		/* 8225A730h case    0:*/		return 0x8225A734;
		  /* 8225A734h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225A734h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A734h case    1:*/		return 0x8225A738;
		  /* 8225A738h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8225A738h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225A738h case    2:*/		return 0x8225A73C;
		  /* 8225A73Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8225A73Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A73Ch case    3:*/		return 0x8225A740;
		  /* 8225A740h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8225A740h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8225A740h case    4:*/		return 0x8225A744;
		  /* 8225A744h */ case    5:  		/* lwz R31, <#[R3 + 20]> */
		/* 8225A744h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000014) );
		/* 8225A744h case    5:*/		return 0x8225A748;
		  /* 8225A748h */ case    6:  		/* mr R30, R3 */
		/* 8225A748h case    6:*/		regs.R30 = regs.R3;
		/* 8225A748h case    6:*/		return 0x8225A74C;
		  /* 8225A74Ch */ case    7:  		/* b 20 */
		/* 8225A74Ch case    7:*/		return 0x8225A760;
		/* 8225A74Ch case    7:*/		return 0x8225A750;
		  /* 8225A750h */ case    8:  		/* mr R3, R31 */
		/* 8225A750h case    8:*/		regs.R3 = regs.R31;
		/* 8225A750h case    8:*/		return 0x8225A754;
		  /* 8225A754h */ case    9:  		/* lwz R4, <#[R30]> */
		/* 8225A754h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 8225A754h case    9:*/		return 0x8225A758;
		  /* 8225A758h */ case   10:  		/* bl -3720 */
		/* 8225A758h case   10:*/		regs.LR = 0x8225A75C; return 0x822598D0;
		/* 8225A758h case   10:*/		return 0x8225A75C;
		  /* 8225A75Ch */ case   11:  		/* lwz R31, <#[R31 + 8]> */
		/* 8225A75Ch case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8225A75Ch case   11:*/		return 0x8225A760;
	}
	return 0x8225A760;
} // Block from 8225A730h-8225A760h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225A760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A760);
		  /* 8225A760h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8225A760h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8225A760h case    0:*/		return 0x8225A764;
		  /* 8225A764h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8225A764h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225A764h case    1:*/		return 0x8225A768;
		  /* 8225A768h */ case    2:  		/* bc 4, CR6_EQ, -24 */
		/* 8225A768h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8225A750;  }
		/* 8225A768h case    2:*/		return 0x8225A76C;
		  /* 8225A76Ch */ case    3:  		/* addi R1, R1, 112 */
		/* 8225A76Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225A76Ch case    3:*/		return 0x8225A770;
		  /* 8225A770h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225A770h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225A770h case    4:*/		return 0x8225A774;
		  /* 8225A774h */ case    5:  		/* mtspr LR, R12 */
		/* 8225A774h case    5:*/		regs.LR = regs.R12;
		/* 8225A774h case    5:*/		return 0x8225A778;
		  /* 8225A778h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 8225A778h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8225A778h case    6:*/		return 0x8225A77C;
		  /* 8225A77Ch */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 8225A77Ch case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225A77Ch case    7:*/		return 0x8225A780;
		  /* 8225A780h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8225A780h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225A780h case    8:*/		return 0x8225A784;
	}
	return 0x8225A784;
} // Block from 8225A760h-8225A784h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225A784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A784);
		  /* 8225A784h */ case    0:  		/* nop */
		/* 8225A784h case    0:*/		cpu::op::nop();
		/* 8225A784h case    0:*/		return 0x8225A788;
	}
	return 0x8225A788;
} // Block from 8225A784h-8225A788h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A788);
		  /* 8225A788h */ case    0:  		/* mfspr R12, LR */
		/* 8225A788h case    0:*/		regs.R12 = regs.LR;
		/* 8225A788h case    0:*/		return 0x8225A78C;
		  /* 8225A78Ch */ case    1:  		/* bl -1873200 */
		/* 8225A78Ch case    1:*/		regs.LR = 0x8225A790; return 0x8209125C;
		/* 8225A78Ch case    1:*/		return 0x8225A790;
		  /* 8225A790h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8225A790h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8225A790h case    2:*/		return 0x8225A794;
		  /* 8225A794h */ case    3:  		/* mr R30, R3 */
		/* 8225A794h case    3:*/		regs.R30 = regs.R3;
		/* 8225A794h case    3:*/		return 0x8225A798;
		  /* 8225A798h */ case    4:  		/* mr R29, R4 */
		/* 8225A798h case    4:*/		regs.R29 = regs.R4;
		/* 8225A798h case    4:*/		return 0x8225A79C;
		  /* 8225A79Ch */ case    5:  		/* li R31, 0 */
		/* 8225A79Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8225A79Ch case    5:*/		return 0x8225A7A0;
		  /* 8225A7A0h */ case    6:  		/* mr R4, R31 */
		/* 8225A7A0h case    6:*/		regs.R4 = regs.R31;
		/* 8225A7A0h case    6:*/		return 0x8225A7A4;
		  /* 8225A7A4h */ case    7:  		/* mr R3, R30 */
		/* 8225A7A4h case    7:*/		regs.R3 = regs.R30;
		/* 8225A7A4h case    7:*/		return 0x8225A7A8;
		  /* 8225A7A8h */ case    8:  		/* bl 51040 */
		/* 8225A7A8h case    8:*/		regs.LR = 0x8225A7AC; return 0x82266F08;
		/* 8225A7A8h case    8:*/		return 0x8225A7AC;
		  /* 8225A7ACh */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8225A7ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225A7ACh case    9:*/		return 0x8225A7B0;
	}
	return 0x8225A7B0;
} // Block from 8225A788h-8225A7B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225A7B0h
// Function '?TypeName@IfHeader@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A7B0);
		  /* 8225A7B0h */ case    0:  		/* mr R6, R3 */
		/* 8225A7B0h case    0:*/		regs.R6 = regs.R3;
		/* 8225A7B0h case    0:*/		return 0x8225A7B4;
		  /* 8225A7B4h */ case    1:  		/* mr R5, R31 */
		/* 8225A7B4h case    1:*/		regs.R5 = regs.R31;
		/* 8225A7B4h case    1:*/		return 0x8225A7B8;
		  /* 8225A7B8h */ case    2:  		/* li R4, 1 */
		/* 8225A7B8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225A7B8h case    2:*/		return 0x8225A7BC;
		  /* 8225A7BCh */ case    3:  		/* mr R3, R29 */
		/* 8225A7BCh case    3:*/		regs.R3 = regs.R29;
		/* 8225A7BCh case    3:*/		return 0x8225A7C0;
	}
	return 0x8225A7C0;
} // Block from 8225A7B0h-8225A7C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A7C0h
// Function '??0BreakBlock@XGRAPHICS@@QAA@PAVPostLoopFooter@1@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A7C0);
		  /* 8225A7C0h */ case    0:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225A7C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225A7C0h case    0:*/		return 0x8225A7C4;
		  /* 8225A7C4h */ case    1:  		/* mtspr CTR, R11 */
		/* 8225A7C4h case    1:*/		regs.CTR = regs.R11;
		/* 8225A7C4h case    1:*/		return 0x8225A7C8;
		  /* 8225A7C8h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8225A7C8h case    2:*/		if ( 1 ) { regs.LR = 0x8225A7CC; return (uint32)regs.CTR; }
		/* 8225A7C8h case    2:*/		return 0x8225A7CC;
		  /* 8225A7CCh */ case    3:  		/* addi R31, R31, 1 */
		/* 8225A7CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8225A7CCh case    3:*/		return 0x8225A7D0;
		  /* 8225A7D0h */ case    4:  		/* cmpwi CR6, R31, 4 */
		/* 8225A7D0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8225A7D0h case    4:*/		return 0x8225A7D4;
		  /* 8225A7D4h */ case    5:  		/* bc 12, CR6_LT, -52 */
		/* 8225A7D4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8225A7A0;  }
		/* 8225A7D4h case    5:*/		return 0x8225A7D8;
		  /* 8225A7D8h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 8225A7D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225A7D8h case    6:*/		return 0x8225A7DC;
		  /* 8225A7DCh */ case    7:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225A7DCh case    7:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225A7DCh case    7:*/		return 0x8225A7E0;
		  /* 8225A7E0h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8225A7E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225A7F8;  }
		/* 8225A7E0h case    8:*/		return 0x8225A7E4;
		  /* 8225A7E4h */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 8225A7E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8225A7E4h case    9:*/		return 0x8225A7E8;
		  /* 8225A7E8h */ case   10:  		/* li R12, -17768 */
		/* 8225A7E8h case   10:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFBA98);
		/* 8225A7E8h case   10:*/		return 0x8225A7EC;
		  /* 8225A7ECh */ case   11:  		/* and R11, R11, R12 */
		/* 8225A7ECh case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8225A7ECh case   11:*/		return 0x8225A7F0;
		  /* 8225A7F0h */ case   12:  		/* ori R11, R11, 12816 */
		/* 8225A7F0h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3210);
		/* 8225A7F0h case   12:*/		return 0x8225A7F4;
		  /* 8225A7F4h */ case   13:  		/* stw R11, <#[R30 + 4]> */
		/* 8225A7F4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8225A7F4h case   13:*/		return 0x8225A7F8;
	}
	return 0x8225A7F8;
} // Block from 8225A7C0h-8225A7F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225A7F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A7F8);
		  /* 8225A7F8h */ case    0:  		/* addi R1, R1, 112 */
		/* 8225A7F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8225A7F8h case    0:*/		return 0x8225A7FC;
		  /* 8225A7FCh */ case    1:  		/* b -1873232 */
		/* 8225A7FCh case    1:*/		return 0x820912AC;
		/* 8225A7FCh case    1:*/		return 0x8225A800;
	}
	return 0x8225A800;
} // Block from 8225A7F8h-8225A800h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A800);
		  /* 8225A800h */ case    0:  		/* mfspr R12, LR */
		/* 8225A800h case    0:*/		regs.R12 = regs.LR;
		/* 8225A800h case    0:*/		return 0x8225A804;
		  /* 8225A804h */ case    1:  		/* bl -1873328 */
		/* 8225A804h case    1:*/		regs.LR = 0x8225A808; return 0x82091254;
		/* 8225A804h case    1:*/		return 0x8225A808;
		  /* 8225A808h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8225A808h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8225A808h case    2:*/		return 0x8225A80C;
		  /* 8225A80Ch */ case    3:  		/* lwz R11, <#[R4]> */
		/* 8225A80Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8225A80Ch case    3:*/		return 0x8225A810;
	}
	return 0x8225A810;
} // Block from 8225A800h-8225A810h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A810h
// Function '?TypeName@BreakBlock@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A810);
		  /* 8225A810h */ case    0:  		/* li R27, 1 */
		/* 8225A810h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8225A810h case    0:*/		return 0x8225A814;
		  /* 8225A814h */ case    1:  		/* li R10, 2 */
		/* 8225A814h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8225A814h case    1:*/		return 0x8225A818;
		  /* 8225A818h */ case    2:  		/* li R9, 0 */
		/* 8225A818h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225A818h case    2:*/		return 0x8225A81C;
		  /* 8225A81Ch */ case    3:  		/* stb R27, <#[R1 + 81]> */
		/* 8225A81Ch case    3:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x00000051) );
		/* 8225A81Ch case    3:*/		return 0x8225A820;
	}
	return 0x8225A820;
} // Block from 8225A810h-8225A820h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A820h
// Function '??0ContinueBlock@XGRAPHICS@@QAA@PAVLoopFooter@1@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A820);
		  /* 8225A820h */ case    0:  		/* li R8, 3 */
		/* 8225A820h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 8225A820h case    0:*/		return 0x8225A824;
		  /* 8225A824h */ case    1:  		/* stb R10, <#[R1 + 82]> */
		/* 8225A824h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x00000052) );
		/* 8225A824h case    1:*/		return 0x8225A828;
		  /* 8225A828h */ case    2:  		/* mr R28, R4 */
		/* 8225A828h case    2:*/		regs.R28 = regs.R4;
		/* 8225A828h case    2:*/		return 0x8225A82C;
		  /* 8225A82Ch */ case    3:  		/* stb R9, <#[R1 + 80]> */
		/* 8225A82Ch case    3:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8225A82Ch case    3:*/		return 0x8225A830;
		  /* 8225A830h */ case    4:  		/* mr R29, R5 */
		/* 8225A830h case    4:*/		regs.R29 = regs.R5;
		/* 8225A830h case    4:*/		return 0x8225A834;
		  /* 8225A834h */ case    5:  		/* stw R11, <#[R1 + 84]> */
		/* 8225A834h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225A834h case    5:*/		return 0x8225A838;
		  /* 8225A838h */ case    6:  		/* mr R30, R6 */
		/* 8225A838h case    6:*/		regs.R30 = regs.R6;
		/* 8225A838h case    6:*/		return 0x8225A83C;
		  /* 8225A83Ch */ case    7:  		/* stb R8, <#[R1 + 83]> */
		/* 8225A83Ch case    7:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0x00000053) );
		/* 8225A83Ch case    7:*/		return 0x8225A840;
		  /* 8225A840h */ case    8:  		/* mr R31, R7 */
		/* 8225A840h case    8:*/		regs.R31 = regs.R7;
		/* 8225A840h case    8:*/		return 0x8225A844;
		  /* 8225A844h */ case    9:  		/* cmpwi CR6, R6, 0 */
		/* 8225A844h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8225A844h case    9:*/		return 0x8225A848;
		  /* 8225A848h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 8225A848h case   10:*/		if ( regs.CR[6].eq ) { return 0x8225A854;  }
		/* 8225A848h case   10:*/		return 0x8225A84C;
		  /* 8225A84Ch */ case   11:  		/* cmplwi CR6, R7, 0 */
		/* 8225A84Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8225A84Ch case   11:*/		return 0x8225A850;
		  /* 8225A850h */ case   12:  		/* bc 4, CR6_EQ, 40 */
		/* 8225A850h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8225A878;  }
		/* 8225A850h case   12:*/		return 0x8225A854;
	}
	return 0x8225A854;
} // Block from 8225A820h-8225A854h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225A854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A854);
		  /* 8225A854h */ case    0:  		/* lis R11, -32251 */
		/* 8225A854h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225A854h case    0:*/		return 0x8225A858;
		  /* 8225A858h */ case    1:  		/* lis R10, -32251 */
		/* 8225A858h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225A858h case    1:*/		return 0x8225A85C;
		  /* 8225A85Ch */ case    2:  		/* lis R9, -32253 */
		/* 8225A85Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225A85Ch case    2:*/		return 0x8225A860;
		  /* 8225A860h */ case    3:  		/* addi R6, R11, -21904 */
		/* 8225A860h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAA70);
		/* 8225A860h case    3:*/		return 0x8225A864;
		  /* 8225A864h */ case    4:  		/* addi R5, R10, -21632 */
		/* 8225A864h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFAB80);
		/* 8225A864h case    4:*/		return 0x8225A868;
		  /* 8225A868h */ case    5:  		/* addi R4, R9, 27460 */
		/* 8225A868h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225A868h case    5:*/		return 0x8225A86C;
		  /* 8225A86Ch */ case    6:  		/* li R7, 4319 */
		/* 8225A86Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x10DF);
		/* 8225A86Ch case    6:*/		return 0x8225A870;
	}
	return 0x8225A870;
} // Block from 8225A854h-8225A870h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225A870h
// Function '?TypeName@ContinueBlock@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A870);
		  /* 8225A870h */ case    0:  		/* li R3, 0 */
		/* 8225A870h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225A870h case    0:*/		return 0x8225A874;
		  /* 8225A874h */ case    1:  		/* bl -1059948 */
		/* 8225A874h case    1:*/		regs.LR = 0x8225A878; return 0x82157C08;
		/* 8225A874h case    1:*/		return 0x8225A878;
	}
	return 0x8225A878;
} // Block from 8225A870h-8225A878h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A878);
		  /* 8225A878h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8225A878h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8225A878h case    0:*/		return 0x8225A87C;
		  /* 8225A87Ch */ case    1:  		/* bc 12, CR6_EQ, 212 */
		/* 8225A87Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8225A950;  }
		/* 8225A87Ch case    1:*/		return 0x8225A880;
	}
	return 0x8225A880;
} // Block from 8225A878h-8225A880h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A880h
// Function '?TypeName@LoopFooter@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A880);
		  /* 8225A880h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8225A880h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225A880h case    0:*/		return 0x8225A884;
		  /* 8225A884h */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225A884h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225A884h case    1:*/		return 0x8225A888;
		  /* 8225A888h */ case    2:  		/* bc 12, CR0_EQ, 44 */
		/* 8225A888h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225A8B4;  }
		/* 8225A888h case    2:*/		return 0x8225A88C;
		  /* 8225A88Ch */ case    3:  		/* lwz R11, <#[R29 + 4]> */
		/* 8225A88Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8225A88Ch case    3:*/		return 0x8225A890;
	}
	return 0x8225A890;
} // Block from 8225A880h-8225A890h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A890h
// Function '?TypeName@PostLoopFooter@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A890);
		  /* 8225A890h */ case    0:  		/* rlwinm R10, R11, 17, 15, 31 */
		/* 8225A890h case    0:*/		cpu::op::rlwinm<0,17,15,31>(regs,&regs.R10,regs.R11);
		/* 8225A890h case    0:*/		return 0x8225A894;
		  /* 8225A894h */ case    1:  		/* rlwinm R9, R11, 21, 11, 31 */
		/* 8225A894h case    1:*/		cpu::op::rlwinm<0,21,11,31>(regs,&regs.R9,regs.R11);
		/* 8225A894h case    1:*/		return 0x8225A898;
		  /* 8225A898h */ case    2:  		/* rlwinm R8, R11, 25, 7, 31 */
		/* 8225A898h case    2:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R8,regs.R11);
		/* 8225A898h case    2:*/		return 0x8225A89C;
		  /* 8225A89Ch */ case    3:  		/* and R10, R10, R9 */
		/* 8225A89Ch case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8225A89Ch case    3:*/		return 0x8225A8A0;
	}
	return 0x8225A8A0;
} // Block from 8225A890h-8225A8A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8A0h
// Function '?TypeName@IfFooter@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8A0);
		  /* 8225A8A0h */ case    0:  		/* rlwinm R11, R11, 29, 3, 31 */
		/* 8225A8A0h case    0:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R11,regs.R11);
		/* 8225A8A0h case    0:*/		return 0x8225A8A4;
		  /* 8225A8A4h */ case    1:  		/* and R10, R10, R8 */
		/* 8225A8A4h case    1:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8225A8A4h case    1:*/		return 0x8225A8A8;
		  /* 8225A8A8h */ case    2:  		/* and R11, R10, R11 */
		/* 8225A8A8h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225A8A8h case    2:*/		return 0x8225A8AC;
		  /* 8225A8ACh */ case    3:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8225A8ACh case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8225A8ACh case    3:*/		return 0x8225A8B0;
	}
	return 0x8225A8B0;
} // Block from 8225A8A0h-8225A8B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8B0h
// Function '?TypeName@IfFooterStatic@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8B0);
		  /* 8225A8B0h */ case    0:  		/* b 8 */
		/* 8225A8B0h case    0:*/		return 0x8225A8B8;
		/* 8225A8B0h case    0:*/		return 0x8225A8B4;
	}
	return 0x8225A8B4;
} // Block from 8225A8B0h-8225A8B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8B4);
		  /* 8225A8B4h */ case    0:  		/* li R11, 0 */
		/* 8225A8B4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225A8B4h case    0:*/		return 0x8225A8B8;
	}
	return 0x8225A8B8;
} // Block from 8225A8B4h-8225A8B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8B8);
		  /* 8225A8B8h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225A8B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225A8B8h case    0:*/		return 0x8225A8BC;
		  /* 8225A8BCh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 8225A8BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8225A8D8;  }
		/* 8225A8BCh case    1:*/		return 0x8225A8C0;
	}
	return 0x8225A8C0;
} // Block from 8225A8B8h-8225A8C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8C0h
// Function '?ReplaceEdgeWithGraph@Block@XGRAPHICS@@QAAXPAV12@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8C0);
		  /* 8225A8C0h */ case    0:  		/* add R11, R30, R31 */
		/* 8225A8C0h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 8225A8C0h case    0:*/		return 0x8225A8C4;
		  /* 8225A8C4h */ case    1:  		/* addi R10, R11, 152 */
		/* 8225A8C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x98);
		/* 8225A8C4h case    1:*/		return 0x8225A8C8;
		  /* 8225A8C8h */ case    2:  		/* lbz R10, <#[R11 + 152]> */
		/* 8225A8C8h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000098) );
		/* 8225A8C8h case    2:*/		return 0x8225A8CC;
		  /* 8225A8CCh */ case    3:  		/* cntlzw R10, R10 */
		/* 8225A8CCh case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8225A8CCh case    3:*/		return 0x8225A8D0;
		  /* 8225A8D0h */ case    4:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 8225A8D0h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 8225A8D0h case    4:*/		return 0x8225A8D4;
		  /* 8225A8D4h */ case    5:  		/* stb R10, <#[R11 + 152]> */
		/* 8225A8D4h case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000098) );
		/* 8225A8D4h case    5:*/		return 0x8225A8D8;
	}
	return 0x8225A8D8;
} // Block from 8225A8C0h-8225A8D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8D8);
		  /* 8225A8D8h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8225A8D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225A8D8h case    0:*/		return 0x8225A8DC;
		  /* 8225A8DCh */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225A8DCh case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225A8DCh case    1:*/		return 0x8225A8E0;
		  /* 8225A8E0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225A8E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225A8F0;  }
		/* 8225A8E0h case    2:*/		return 0x8225A8E4;
		  /* 8225A8E4h */ case    3:  		/* lwz R11, <#[R29 + 4]> */
		/* 8225A8E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8225A8E4h case    3:*/		return 0x8225A8E8;
		  /* 8225A8E8h */ case    4:  		/* rlwinm R11, R11, 12, 31, 31 */
		/* 8225A8E8h case    4:*/		cpu::op::rlwinm<0,12,31,31>(regs,&regs.R11,regs.R11);
		/* 8225A8E8h case    4:*/		return 0x8225A8EC;
		  /* 8225A8ECh */ case    5:  		/* b 8 */
		/* 8225A8ECh case    5:*/		return 0x8225A8F4;
		/* 8225A8ECh case    5:*/		return 0x8225A8F0;
	}
	return 0x8225A8F0;
} // Block from 8225A8D8h-8225A8F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8F0);
		  /* 8225A8F0h */ case    0:  		/* li R11, 0 */
		/* 8225A8F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225A8F0h case    0:*/		return 0x8225A8F4;
	}
	return 0x8225A8F4;
} // Block from 8225A8F0h-8225A8F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A8F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A8F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A8F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A8F4);
		  /* 8225A8F4h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225A8F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225A8F4h case    0:*/		return 0x8225A8F8;
		  /* 8225A8F8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8225A8F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225A904;  }
		/* 8225A8F8h case    1:*/		return 0x8225A8FC;
		  /* 8225A8FCh */ case    2:  		/* add R11, R30, R31 */
		/* 8225A8FCh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 8225A8FCh case    2:*/		return 0x8225A900;
		  /* 8225A900h */ case    3:  		/* stb R27, <#[R11 + 158]> */
		/* 8225A900h case    3:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R11 + 0x0000009E) );
		/* 8225A900h case    3:*/		return 0x8225A904;
	}
	return 0x8225A904;
} // Block from 8225A8F4h-8225A904h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A904);
		  /* 8225A904h */ case    0:  		/* li R4, 0 */
		/* 8225A904h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225A904h case    0:*/		return 0x8225A908;
	}
	return 0x8225A908;
} // Block from 8225A904h-8225A908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225A908h
// Function '??_EExitBlock@XGRAPHICS@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A908);
		  /* 8225A908h */ case    0:  		/* mr R3, R29 */
		/* 8225A908h case    0:*/		regs.R3 = regs.R29;
		/* 8225A908h case    0:*/		return 0x8225A90C;
		  /* 8225A90Ch */ case    1:  		/* bl 50684 */
		/* 8225A90Ch case    1:*/		regs.LR = 0x8225A910; return 0x82266F08;
		/* 8225A90Ch case    1:*/		return 0x8225A910;
		  /* 8225A910h */ case    2:  		/* mr R11, R3 */
		/* 8225A910h case    2:*/		regs.R11 = regs.R3;
		/* 8225A910h case    2:*/		return 0x8225A914;
		  /* 8225A914h */ case    3:  		/* li R4, 1 */
		/* 8225A914h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225A914h case    3:*/		return 0x8225A918;
		  /* 8225A918h */ case    4:  		/* mr R3, R29 */
		/* 8225A918h case    4:*/		regs.R3 = regs.R29;
		/* 8225A918h case    4:*/		return 0x8225A91C;
		  /* 8225A91Ch */ case    5:  		/* stb R11, <#[R1 + 80]> */
		/* 8225A91Ch case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8225A91Ch case    5:*/		return 0x8225A920;
		  /* 8225A920h */ case    6:  		/* bl 50664 */
		/* 8225A920h case    6:*/		regs.LR = 0x8225A924; return 0x82266F08;
		/* 8225A920h case    6:*/		return 0x8225A924;
		  /* 8225A924h */ case    7:  		/* mr R11, R3 */
		/* 8225A924h case    7:*/		regs.R11 = regs.R3;
		/* 8225A924h case    7:*/		return 0x8225A928;
		  /* 8225A928h */ case    8:  		/* li R4, 2 */
		/* 8225A928h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225A928h case    8:*/		return 0x8225A92C;
		  /* 8225A92Ch */ case    9:  		/* mr R3, R29 */
		/* 8225A92Ch case    9:*/		regs.R3 = regs.R29;
		/* 8225A92Ch case    9:*/		return 0x8225A930;
		  /* 8225A930h */ case   10:  		/* stb R11, <#[R1 + 81]> */
		/* 8225A930h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000051) );
		/* 8225A930h case   10:*/		return 0x8225A934;
		  /* 8225A934h */ case   11:  		/* bl 50644 */
		/* 8225A934h case   11:*/		regs.LR = 0x8225A938; return 0x82266F08;
		/* 8225A934h case   11:*/		return 0x8225A938;
		  /* 8225A938h */ case   12:  		/* mr R11, R3 */
		/* 8225A938h case   12:*/		regs.R11 = regs.R3;
		/* 8225A938h case   12:*/		return 0x8225A93C;
		  /* 8225A93Ch */ case   13:  		/* li R4, 3 */
		/* 8225A93Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225A93Ch case   13:*/		return 0x8225A940;
		  /* 8225A940h */ case   14:  		/* mr R3, R29 */
		/* 8225A940h case   14:*/		regs.R3 = regs.R29;
		/* 8225A940h case   14:*/		return 0x8225A944;
		  /* 8225A944h */ case   15:  		/* stb R11, <#[R1 + 82]> */
		/* 8225A944h case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 8225A944h case   15:*/		return 0x8225A948;
		  /* 8225A948h */ case   16:  		/* bl 50624 */
		/* 8225A948h case   16:*/		regs.LR = 0x8225A94C; return 0x82266F08;
		/* 8225A948h case   16:*/		return 0x8225A94C;
		  /* 8225A94Ch */ case   17:  		/* stb R3, <#[R1 + 83]> */
		/* 8225A94Ch case   17:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R1 + 0x00000053) );
		/* 8225A94Ch case   17:*/		return 0x8225A950;
	}
	return 0x8225A950;
} // Block from 8225A908h-8225A950h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225A950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A950);
		  /* 8225A950h */ case    0:  		/* lwz R9, <#[R31]> */
		/* 8225A950h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8225A950h case    0:*/		return 0x8225A954;
		  /* 8225A954h */ case    1:  		/* addi R10, R1, 80 */
		/* 8225A954h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8225A954h case    1:*/		return 0x8225A958;
		  /* 8225A958h */ case    2:  		/* lbz R11, <#[R1 + 84]> */
		/* 8225A958h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225A958h case    2:*/		return 0x8225A95C;
		  /* 8225A95Ch */ case    3:  		/* li R5, 0 */
		/* 8225A95Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225A95Ch case    3:*/		return 0x8225A960;
	}
	return 0x8225A960;
} // Block from 8225A950h-8225A960h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225A960h
// Function '??0LoopHeader@XGRAPHICS@@QAA@HPAV01@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225A960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225A960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225A960);
		  /* 8225A960h */ case    0:  		/* mr R4, R30 */
		/* 8225A960h case    0:*/		regs.R4 = regs.R30;
		/* 8225A960h case    0:*/		return 0x8225A964;
		  /* 8225A964h */ case    1:  		/* mr R3, R31 */
		/* 8225A964h case    1:*/		regs.R3 = regs.R31;
		/* 8225A964h case    1:*/		return 0x8225A968;
		  /* 8225A968h */ case    2:  		/* lwz R9, <#[R9 + 88]> */
		/* 8225A968h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000058) );
		/* 8225A968h case    2:*/		return 0x8225A96C;
		  /* 8225A96Ch */ case    3:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8225A96Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225A96Ch case    3:*/		return 0x8225A970;
		  /* 8225A970h */ case    4:  		/* extsb R6, R11 */
		/* 8225A970h case    4:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R11);
		/* 8225A970h case    4:*/		return 0x8225A974;
		  /* 8225A974h */ case    5:  		/* mtspr CTR, R9 */
		/* 8225A974h case    5:*/		regs.CTR = regs.R9;
		/* 8225A974h case    5:*/		return 0x8225A978;
		  /* 8225A978h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8225A978h case    6:*/		if ( 1 ) { regs.LR = 0x8225A97C; return (uint32)regs.CTR; }
		/* 8225A978h case    6:*/		return 0x8225A97C;
		  /* 8225A97Ch */ case    7:  		/* lbz R11, <#[R1 + 85]> */
		/* 8225A97Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000055) );
		/* 8225A97Ch case    7:*/		return 0x8225A980;
		  /* 8225A980h */ case    8:  		/* addi R10, R1, 80 */
		/* 8225A980h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8225A980h case    8:*/		return 0x8225A984;
		  /* 8225A984h */ case    9:  		/* li R5, 1 */
		/* 8225A984h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225A984h case    9:*/		return 0x8225A988;
		  /* 8225A988h */ case   10:  		/* mr R4, R30 */
		/* 8225A988h case   10:*/		regs.R4 = regs.R30;
		/* 8225A988h case   10:*/		return 0x8225A98C;
		  /* 8225A98Ch */ case   11:  		/* mr R3, R31 */
		/* 8225A98Ch case   11:*/		regs.R3 = regs.R31;
		/* 8225A98Ch case   11:*/		return 0x8225A990;
		  /* 8225A990h */ case   12:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8225A990h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225A990h case   12:*/		return 0x8225A994;
		  /* 8225A994h */ case   13:  		/* extsb R6, R11 */
		/* 8225A994h case   13:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R11);
		/* 8225A994h case   13:*/		return 0x8225A998;
		  /* 8225A998h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 8225A998h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225A998h case   14:*/		return 0x8225A99C;
		  /* 8225A99Ch */ case   15:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225A99Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225A99Ch case   15:*/		return 0x8225A9A0;
		  /* 8225A9A0h */ case   16:  		/* mtspr CTR, R11 */
		/* 8225A9A0h case   16:*/		regs.CTR = regs.R11;
		/* 8225A9A0h case   16:*/		return 0x8225A9A4;
		  /* 8225A9A4h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 8225A9A4h case   17:*/		if ( 1 ) { regs.LR = 0x8225A9A8; return (uint32)regs.CTR; }
		/* 8225A9A4h case   17:*/		return 0x8225A9A8;
		  /* 8225A9A8h */ case   18:  		/* lbz R11, <#[R1 + 86]> */
		/* 8225A9A8h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000056) );
		/* 8225A9A8h case   18:*/		return 0x8225A9AC;
		  /* 8225A9ACh */ case   19:  		/* addi R10, R1, 80 */
		/* 8225A9ACh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8225A9ACh case   19:*/		return 0x8225A9B0;
		  /* 8225A9B0h */ case   20:  		/* li R5, 2 */
		/* 8225A9B0h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225A9B0h case   20:*/		return 0x8225A9B4;
		  /* 8225A9B4h */ case   21:  		/* mr R4, R30 */
		/* 8225A9B4h case   21:*/		regs.R4 = regs.R30;
		/* 8225A9B4h case   21:*/		return 0x8225A9B8;
		  /* 8225A9B8h */ case   22:  		/* mr R3, R31 */
		/* 8225A9B8h case   22:*/		regs.R3 = regs.R31;
		/* 8225A9B8h case   22:*/		return 0x8225A9BC;
		  /* 8225A9BCh */ case   23:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8225A9BCh case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225A9BCh case   23:*/		return 0x8225A9C0;
		  /* 8225A9C0h */ case   24:  		/* extsb R6, R11 */
		/* 8225A9C0h case   24:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R11);
		/* 8225A9C0h case   24:*/		return 0x8225A9C4;
		  /* 8225A9C4h */ case   25:  		/* lwz R11, <#[R31]> */
		/* 8225A9C4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225A9C4h case   25:*/		return 0x8225A9C8;
		  /* 8225A9C8h */ case   26:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225A9C8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225A9C8h case   26:*/		return 0x8225A9CC;
		  /* 8225A9CCh */ case   27:  		/* mtspr CTR, R11 */
		/* 8225A9CCh case   27:*/		regs.CTR = regs.R11;
		/* 8225A9CCh case   27:*/		return 0x8225A9D0;
		  /* 8225A9D0h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 8225A9D0h case   28:*/		if ( 1 ) { regs.LR = 0x8225A9D4; return (uint32)regs.CTR; }
		/* 8225A9D0h case   28:*/		return 0x8225A9D4;
		  /* 8225A9D4h */ case   29:  		/* lbz R11, <#[R1 + 87]> */
		/* 8225A9D4h case   29:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000057) );
		/* 8225A9D4h case   29:*/		return 0x8225A9D8;
		  /* 8225A9D8h */ case   30:  		/* addi R10, R1, 80 */
		/* 8225A9D8h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8225A9D8h case   30:*/		return 0x8225A9DC;
		  /* 8225A9DCh */ case   31:  		/* li R5, 3 */
		/* 8225A9DCh case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225A9DCh case   31:*/		return 0x8225A9E0;
		  /* 8225A9E0h */ case   32:  		/* mr R4, R30 */
		/* 8225A9E0h case   32:*/		regs.R4 = regs.R30;
		/* 8225A9E0h case   32:*/		return 0x8225A9E4;
		  /* 8225A9E4h */ case   33:  		/* mr R3, R31 */
		/* 8225A9E4h case   33:*/		regs.R3 = regs.R31;
		/* 8225A9E4h case   33:*/		return 0x8225A9E8;
		  /* 8225A9E8h */ case   34:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8225A9E8h case   34:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225A9E8h case   34:*/		return 0x8225A9EC;
		  /* 8225A9ECh */ case   35:  		/* extsb R6, R11 */
		/* 8225A9ECh case   35:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R11);
		/* 8225A9ECh case   35:*/		return 0x8225A9F0;
		  /* 8225A9F0h */ case   36:  		/* lwz R11, <#[R31]> */
		/* 8225A9F0h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225A9F0h case   36:*/		return 0x8225A9F4;
		  /* 8225A9F4h */ case   37:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225A9F4h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225A9F4h case   37:*/		return 0x8225A9F8;
		  /* 8225A9F8h */ case   38:  		/* mtspr CTR, R11 */
		/* 8225A9F8h case   38:*/		regs.CTR = regs.R11;
		/* 8225A9F8h case   38:*/		return 0x8225A9FC;
		  /* 8225A9FCh */ case   39:  		/* bcctrl 20, CR0_LT */
		/* 8225A9FCh case   39:*/		if ( 1 ) { regs.LR = 0x8225AA00; return (uint32)regs.CTR; }
		/* 8225A9FCh case   39:*/		return 0x8225AA00;
		  /* 8225AA00h */ case   40:  		/* lis R11, -32251 */
		/* 8225AA00h case   40:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225AA00h case   40:*/		return 0x8225AA04;
		  /* 8225AA04h */ case   41:  		/* lwz R11, <#[R11 - 31508]> */
		/* 8225AA04h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF84EC) );
		/* 8225AA04h case   41:*/		return 0x8225AA08;
		  /* 8225AA08h */ case   42:  		/* stw R11, <#[R28]> */
		/* 8225AA08h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8225AA08h case   42:*/		return 0x8225AA0C;
		  /* 8225AA0Ch */ case   43:  		/* addi R1, R1, 144 */
		/* 8225AA0Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8225AA0Ch case   43:*/		return 0x8225AA10;
		  /* 8225AA10h */ case   44:  		/* b -1873772 */
		/* 8225AA10h case   44:*/		return 0x820912A4;
		/* 8225AA10h case   44:*/		return 0x8225AA14;
		  /* 8225AA14h */ case   45:  		/* nop */
		/* 8225AA14h case   45:*/		cpu::op::nop();
		/* 8225AA14h case   45:*/		return 0x8225AA18;
	}
	return 0x8225AA18;
} // Block from 8225A960h-8225AA18h (46 instructions)

//////////////////////////////////////////////////////
// Block at 8225AA18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AA18);
		  /* 8225AA18h */ case    0:  		/* mfspr R12, LR */
		/* 8225AA18h case    0:*/		regs.R12 = regs.LR;
		/* 8225AA18h case    0:*/		return 0x8225AA1C;
		  /* 8225AA1Ch */ case    1:  		/* bl -1873880 */
		/* 8225AA1Ch case    1:*/		regs.LR = 0x8225AA20; return 0x82091244;
		/* 8225AA1Ch case    1:*/		return 0x8225AA20;
		  /* 8225AA20h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8225AA20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8225AA20h case    2:*/		return 0x8225AA24;
		  /* 8225AA24h */ case    3:  		/* mr R31, R3 */
		/* 8225AA24h case    3:*/		regs.R31 = regs.R3;
		/* 8225AA24h case    3:*/		return 0x8225AA28;
		  /* 8225AA28h */ case    4:  		/* bl -150896 */
		/* 8225AA28h case    4:*/		regs.LR = 0x8225AA2C; return 0x82235CB8;
		/* 8225AA28h case    4:*/		return 0x8225AA2C;
		  /* 8225AA2Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225AA2Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225AA2Ch case    5:*/		return 0x8225AA30;
		  /* 8225AA30h */ case    6:  		/* li R30, 0 */
		/* 8225AA30h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8225AA30h case    6:*/		return 0x8225AA34;
		  /* 8225AA34h */ case    7:  		/* bc 4, CR0_EQ, 196 */
		/* 8225AA34h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8225AAF8;  }
		/* 8225AA34h case    7:*/		return 0x8225AA38;
		  /* 8225AA38h */ case    8:  		/* lbz R11, <#[R31 + 2116]> */
		/* 8225AA38h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000844) );
		/* 8225AA38h case    8:*/		return 0x8225AA3C;
		  /* 8225AA3Ch */ case    9:  		/* addi R28, R31, 184 */
		/* 8225AA3Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xB8);
		/* 8225AA3Ch case    9:*/		return 0x8225AA40;
		  /* 8225AA40h */ case   10:  		/* mr R4, R31 */
		/* 8225AA40h case   10:*/		regs.R4 = regs.R31;
		/* 8225AA40h case   10:*/		return 0x8225AA44;
		  /* 8225AA44h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 8225AA44h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225AA44h case   11:*/		return 0x8225AA48;
		  /* 8225AA48h */ case   12:  		/* mr R3, R28 */
		/* 8225AA48h case   12:*/		regs.R3 = regs.R28;
		/* 8225AA48h case   12:*/		return 0x8225AA4C;
		  /* 8225AA4Ch */ case   13:  		/* bc 12, CR0_EQ, 32 */
		/* 8225AA4Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8225AA6C;  }
		/* 8225AA4Ch case   13:*/		return 0x8225AA50;
		  /* 8225AA50h */ case   14:  		/* lwz R6, <#[R31 + 2124]> */
		/* 8225AA50h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000084C) );
		/* 8225AA50h case   14:*/		return 0x8225AA54;
		  /* 8225AA54h */ case   15:  		/* lwz R7, <#[R31 + 2128]> */
		/* 8225AA54h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000850) );
		/* 8225AA54h case   15:*/		return 0x8225AA58;
		  /* 8225AA58h */ case   16:  		/* neg R11, R6 */
		/* 8225AA58h case   16:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R6);
		/* 8225AA58h case   16:*/		return 0x8225AA5C;
		  /* 8225AA5Ch */ case   17:  		/* lwz R5, <#[R31 + 2120]> */
		/* 8225AA5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000848) );
		/* 8225AA5Ch case   17:*/		return 0x8225AA60;
		  /* 8225AA60h */ case   18:  		/* stw R11, <#[R31 + 2132]> */
		/* 8225AA60h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000854) );
		/* 8225AA60h case   18:*/		return 0x8225AA64;
		  /* 8225AA64h */ case   19:  		/* bl -33988 */
		/* 8225AA64h case   19:*/		regs.LR = 0x8225AA68; return 0x822525A0;
		/* 8225AA64h case   19:*/		return 0x8225AA68;
		  /* 8225AA68h */ case   20:  		/* b 24 */
		/* 8225AA68h case   20:*/		return 0x8225AA80;
		/* 8225AA68h case   20:*/		return 0x8225AA6C;
	}
	return 0x8225AA6C;
} // Block from 8225AA18h-8225AA6Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225AA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AA6C);
		  /* 8225AA6Ch */ case    0:  		/* li R7, 0 */
		/* 8225AA6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8225AA6Ch case    0:*/		return 0x8225AA70;
		  /* 8225AA70h */ case    1:  		/* li R6, 0 */
		/* 8225AA70h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225AA70h case    1:*/		return 0x8225AA74;
		  /* 8225AA74h */ case    2:  		/* li R5, 0 */
		/* 8225AA74h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225AA74h case    2:*/		return 0x8225AA78;
		  /* 8225AA78h */ case    3:  		/* bl -34008 */
		/* 8225AA78h case    3:*/		regs.LR = 0x8225AA7C; return 0x822525A0;
		/* 8225AA78h case    3:*/		return 0x8225AA7C;
		  /* 8225AA7Ch */ case    4:  		/* stw R30, <#[R31 + 2132]> */
		/* 8225AA7Ch case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000854) );
		/* 8225AA7Ch case    4:*/		return 0x8225AA80;
	}
	return 0x8225AA80;
} // Block from 8225AA6Ch-8225AA80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225AA80h
// Function '?TypeName@LoopHeader@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AA80);
		  /* 8225AA80h */ case    0:  		/* addi R11, R3, 1 */
		/* 8225AA80h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8225AA80h case    0:*/		return 0x8225AA84;
		  /* 8225AA84h */ case    1:  		/* addi R29, R31, 1096 */
		/* 8225AA84h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x448);
		/* 8225AA84h case    1:*/		return 0x8225AA88;
		  /* 8225AA88h */ case    2:  		/* stw R11, <#[R31 + 2084]> */
		/* 8225AA88h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000824) );
		/* 8225AA88h case    2:*/		return 0x8225AA8C;
		  /* 8225AA8Ch */ case    3:  		/* lwz R11, <#[R29]> */
		/* 8225AA8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225AA8Ch case    3:*/		return 0x8225AA90;
	}
	return 0x8225AA90;
} // Block from 8225AA80h-8225AA90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225AA90h
// Function '??0IfHeader@XGRAPHICS@@QAA@PAVIRInst@1@PAV01@PAVCompiler@1@PAVCFG@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AA90);
		  /* 8225AA90h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8225AA90h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225AA90h case    0:*/		return 0x8225AA94;
		  /* 8225AA94h */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 8225AA94h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225AAE4;  }
		/* 8225AA94h case    1:*/		return 0x8225AA98;
		  /* 8225AA98h */ case    2:  		/* mr R4, R30 */
		/* 8225AA98h case    2:*/		regs.R4 = regs.R30;
		/* 8225AA98h case    2:*/		return 0x8225AA9C;
		  /* 8225AA9Ch */ case    3:  		/* mr R3, R31 */
		/* 8225AA9Ch case    3:*/		regs.R3 = regs.R31;
		/* 8225AA9Ch case    3:*/		return 0x8225AAA0;
		  /* 8225AAA0h */ case    4:  		/* bl -79088 */
		/* 8225AAA0h case    4:*/		regs.LR = 0x8225AAA4; return 0x822475B0;
		/* 8225AAA0h case    4:*/		return 0x8225AAA4;
		  /* 8225AAA4h */ case    5:  		/* lbz R11, <#[R31 + 2116]> */
		/* 8225AAA4h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000844) );
		/* 8225AAA4h case    5:*/		return 0x8225AAA8;
		  /* 8225AAA8h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 8225AAA8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225AAA8h case    6:*/		return 0x8225AAAC;
		  /* 8225AAACh */ case    7:  		/* bc 12, CR0_EQ, 56 */
		/* 8225AAACh case    7:*/		if ( regs.CR[0].eq ) { return 0x8225AAE4;  }
		/* 8225AAACh case    7:*/		return 0x8225AAB0;
		  /* 8225AAB0h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 8225AAB0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225AAB0h case    8:*/		return 0x8225AAB4;
		  /* 8225AAB4h */ case    9:  		/* lwz R10, <#[R31 + 2120]> */
		/* 8225AAB4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000848) );
		/* 8225AAB4h case    9:*/		return 0x8225AAB8;
		  /* 8225AAB8h */ case   10:  		/* lwz R11, <#[R11 + 32]> */
		/* 8225AAB8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 8225AAB8h case   10:*/		return 0x8225AABC;
		  /* 8225AABCh */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 8225AABCh case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8225AABCh case   11:*/		return 0x8225AAC0;
		  /* 8225AAC0h */ case   12:  		/* bc 4, CR6_EQ, 36 */
		/* 8225AAC0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8225AAE4;  }
		/* 8225AAC0h case   12:*/		return 0x8225AAC4;
		  /* 8225AAC4h */ case   13:  		/* lwz R11, <#[R31 + 2128]> */
		/* 8225AAC4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 8225AAC4h case   13:*/		return 0x8225AAC8;
		  /* 8225AAC8h */ case   14:  		/* lwz R10, <#[R31 + 2124]> */
		/* 8225AAC8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000084C) );
		/* 8225AAC8h case   14:*/		return 0x8225AACC;
		  /* 8225AACCh */ case   15:  		/* subf R11, R10, R11 */
		/* 8225AACCh case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225AACCh case   15:*/		return 0x8225AAD0;
		  /* 8225AAD0h */ case   16:  		/* cmpw CR6, R30, R11 */
		/* 8225AAD0h case   16:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8225AAD0h case   16:*/		return 0x8225AAD4;
		  /* 8225AAD4h */ case   17:  		/* bc 4, CR6_LT, 16 */
		/* 8225AAD4h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8225AAE4;  }
		/* 8225AAD4h case   17:*/		return 0x8225AAD8;
		  /* 8225AAD8h */ case   18:  		/* mr R4, R30 */
		/* 8225AAD8h case   18:*/		regs.R4 = regs.R30;
		/* 8225AAD8h case   18:*/		return 0x8225AADC;
		  /* 8225AADCh */ case   19:  		/* mr R3, R31 */
		/* 8225AADCh case   19:*/		regs.R3 = regs.R31;
		/* 8225AADCh case   19:*/		return 0x8225AAE0;
		  /* 8225AAE0h */ case   20:  		/* bl -79248 */
		/* 8225AAE0h case   20:*/		regs.LR = 0x8225AAE4; return 0x82247550;
		/* 8225AAE0h case   20:*/		return 0x8225AAE4;
	}
	return 0x8225AAE4;
} // Block from 8225AA90h-8225AAE4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225AAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AAE4);
		  /* 8225AAE4h */ case    0:  		/* addi R30, R30, 1 */
		/* 8225AAE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225AAE4h case    0:*/		return 0x8225AAE8;
		  /* 8225AAE8h */ case    1:  		/* addi R29, R29, 4 */
		/* 8225AAE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8225AAE8h case    1:*/		return 0x8225AAEC;
		  /* 8225AAECh */ case    2:  		/* cmpwi CR6, R30, 16 */
		/* 8225AAECh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 8225AAECh case    2:*/		return 0x8225AAF0;
		  /* 8225AAF0h */ case    3:  		/* bc 12, CR6_LT, -100 */
		/* 8225AAF0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225AA8C;  }
		/* 8225AAF0h case    3:*/		return 0x8225AAF4;
		  /* 8225AAF4h */ case    4:  		/* b 584 */
		/* 8225AAF4h case    4:*/		return 0x8225AD3C;
		/* 8225AAF4h case    4:*/		return 0x8225AAF8;
	}
	return 0x8225AAF8;
} // Block from 8225AAE4h-8225AAF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225AAF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AAF8);
		  /* 8225AAF8h */ case    0:  		/* lbz R11, <#[R31 + 2100]> */
		/* 8225AAF8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000834) );
		/* 8225AAF8h case    0:*/		return 0x8225AAFC;
		  /* 8225AAFCh */ case    1:  		/* li R23, 1 */
		/* 8225AAFCh case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 8225AAFCh case    1:*/		return 0x8225AB00;
		  /* 8225AB00h */ case    2:  		/* stw R30, <#[R31 + 2112]> */
		/* 8225AB00h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000840) );
		/* 8225AB00h case    2:*/		return 0x8225AB04;
		  /* 8225AB04h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8225AB04h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225AB04h case    3:*/		return 0x8225AB08;
		  /* 8225AB08h */ case    4:  		/* stw R30, <#[R31 + 2132]> */
		/* 8225AB08h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000854) );
		/* 8225AB08h case    4:*/		return 0x8225AB0C;
		  /* 8225AB0Ch */ case    5:  		/* mr R24, R23 */
		/* 8225AB0Ch case    5:*/		regs.R24 = regs.R23;
		/* 8225AB0Ch case    5:*/		return 0x8225AB10;
		  /* 8225AB10h */ case    6:  		/* bc 12, CR0_EQ, 232 */
		/* 8225AB10h case    6:*/		if ( regs.CR[0].eq ) { return 0x8225ABF8;  }
		/* 8225AB10h case    6:*/		return 0x8225AB14;
		  /* 8225AB14h */ case    7:  		/* lwz R11, <#[R31 + 2104]> */
		/* 8225AB14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000838) );
		/* 8225AB14h case    7:*/		return 0x8225AB18;
		  /* 8225AB18h */ case    8:  		/* lwz R9, <#[R31 + 2108]> */
		/* 8225AB18h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000083C) );
		/* 8225AB18h case    8:*/		return 0x8225AB1C;
		  /* 8225AB1Ch */ case    9:  		/* subfic R8, R11, 1 */
		/* 8225AB1Ch case    9:*/		cpu::op::subfic<0>(regs,&regs.R8,regs.R11,0x1);
		/* 8225AB1Ch case    9:*/		return 0x8225AB20;
		  /* 8225AB20h */ case   10:  		/* subf R10, R11, R9 */
		/* 8225AB20h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 8225AB20h case   10:*/		return 0x8225AB24;
		  /* 8225AB24h */ case   11:  		/* mr R29, R11 */
		/* 8225AB24h case   11:*/		regs.R29 = regs.R11;
		/* 8225AB24h case   11:*/		return 0x8225AB28;
		  /* 8225AB28h */ case   12:  		/* stw R8, <#[R31 + 2112]> */
		/* 8225AB28h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000840) );
		/* 8225AB28h case   12:*/		return 0x8225AB2C;
		  /* 8225AB2Ch */ case   13:  		/* cmpw CR6, R11, R9 */
		/* 8225AB2Ch case   13:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 8225AB2Ch case   13:*/		return 0x8225AB30;
		  /* 8225AB30h */ case   14:  		/* addi R24, R10, 1 */
		/* 8225AB30h case   14:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x1);
		/* 8225AB30h case   14:*/		return 0x8225AB34;
		  /* 8225AB34h */ case   15:  		/* bc 4, CR6_LT, 196 */
		/* 8225AB34h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8225ABF8;  }
		/* 8225AB34h case   15:*/		return 0x8225AB38;
		  /* 8225AB38h */ case   16:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225AB38h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225AB38h case   16:*/		return 0x8225AB3C;
		  /* 8225AB3Ch */ case   17:  		/* mr R5, R29 */
		/* 8225AB3Ch case   17:*/		regs.R5 = regs.R29;
		/* 8225AB3Ch case   17:*/		return 0x8225AB40;
		  /* 8225AB40h */ case   18:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225AB40h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225AB40h case   18:*/		return 0x8225AB44;
		  /* 8225AB44h */ case   19:  		/* lwz R4, <#[R11 + 44]> */
		/* 8225AB44h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000002C) );
		/* 8225AB44h case   19:*/		return 0x8225AB48;
		  /* 8225AB48h */ case   20:  		/* bl -89152 */
		/* 8225AB48h case   20:*/		regs.LR = 0x8225AB4C; return 0x82244F08;
		/* 8225AB48h case   20:*/		return 0x8225AB4C;
		  /* 8225AB4Ch */ case   21:  		/* or. R26, R3, R3 */
		/* 8225AB4Ch case   21:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 8225AB4Ch case   21:*/		return 0x8225AB50;
		  /* 8225AB50h */ case   22:  		/* bc 12, CR0_EQ, 152 */
		/* 8225AB50h case   22:*/		if ( regs.CR[0].eq ) { return 0x8225ABE8;  }
		/* 8225AB50h case   22:*/		return 0x8225AB54;
		  /* 8225AB54h */ case   23:  		/* mr R28, R30 */
		/* 8225AB54h case   23:*/		regs.R28 = regs.R30;
		/* 8225AB54h case   23:*/		return 0x8225AB58;
		  /* 8225AB58h */ case   24:  		/* mr R27, R30 */
		/* 8225AB58h case   24:*/		regs.R27 = regs.R30;
		/* 8225AB58h case   24:*/		return 0x8225AB5C;
		  /* 8225AB5Ch */ case   25:  		/* mr R25, R23 */
		/* 8225AB5Ch case   25:*/		regs.R25 = regs.R23;
		/* 8225AB5Ch case   25:*/		return 0x8225AB60;
		  /* 8225AB60h */ case   26:  		/* lwz R11, <#[R26 + 40]> */
		/* 8225AB60h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000028) );
		/* 8225AB60h case   26:*/		return 0x8225AB64;
		  /* 8225AB64h */ case   27:  		/* lwz R10, <#[R11 + 4]> */
		/* 8225AB64h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8225AB64h case   27:*/		return 0x8225AB68;
		  /* 8225AB68h */ case   28:  		/* cmplw CR6, R25, R10 */
		/* 8225AB68h case   28:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 8225AB68h case   28:*/		return 0x8225AB6C;
		  /* 8225AB6Ch */ case   29:  		/* bc 4, CR6_GT, 12 */
		/* 8225AB6Ch case   29:*/		if ( !regs.CR[6].gt ) { return 0x8225AB78;  }
		/* 8225AB6Ch case   29:*/		return 0x8225AB70;
		  /* 8225AB70h */ case   30:  		/* mr R11, R30 */
		/* 8225AB70h case   30:*/		regs.R11 = regs.R30;
		/* 8225AB70h case   30:*/		return 0x8225AB74;
		  /* 8225AB74h */ case   31:  		/* b 16 */
		/* 8225AB74h case   31:*/		return 0x8225AB84;
		/* 8225AB74h case   31:*/		return 0x8225AB78;
	}
	return 0x8225AB78;
} // Block from 8225AAF8h-8225AB78h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8225AB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AB78);
		  /* 8225AB78h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8225AB78h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8225AB78h case    0:*/		return 0x8225AB7C;
		  /* 8225AB7Ch */ case    1:  		/* mr R11, R23 */
		/* 8225AB7Ch case    1:*/		regs.R11 = regs.R23;
		/* 8225AB7Ch case    1:*/		return 0x8225AB80;
		  /* 8225AB80h */ case    2:  		/* lwzx R28, <#[R10 + R27]> */
		/* 8225AB80h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8225AB80h case    2:*/		return 0x8225AB84;
	}
	return 0x8225AB84;
} // Block from 8225AB78h-8225AB84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225AB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AB84);
		  /* 8225AB84h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225AB84h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225AB84h case    0:*/		return 0x8225AB88;
	}
	return 0x8225AB88;
} // Block from 8225AB84h-8225AB88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AB88h
// Function '??0IfHeaderStatic@XGRAPHICS@@QAA@PAVIRCmp1S@1@PAVIfHeader@1@PAVCompiler@1@PAVCFG@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AB88);
		  /* 8225AB88h */ case    0:  		/* bc 12, CR0_EQ, 48 */
		/* 8225AB88h case    0:*/		if ( regs.CR[0].eq ) { return 0x8225ABB8;  }
		/* 8225AB88h case    0:*/		return 0x8225AB8C;
		  /* 8225AB8Ch */ case    1:  		/* lwz R11, <#[R28 + 228]> */
		/* 8225AB8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 8225AB8Ch case    1:*/		return 0x8225AB90;
		  /* 8225AB90h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8225AB90h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8225AB90h case    2:*/		return 0x8225AB94;
		  /* 8225AB94h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 8225AB94h case    3:*/		if ( regs.CR[0].eq ) { return 0x8225ABAC;  }
		/* 8225AB94h case    3:*/		return 0x8225AB98;
		  /* 8225AB98h */ case    4:  		/* ori R11, R11, 16 */
		/* 8225AB98h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8225AB98h case    4:*/		return 0x8225AB9C;
		  /* 8225AB9Ch */ case    5:  		/* mr R4, R28 */
		/* 8225AB9Ch case    5:*/		regs.R4 = regs.R28;
		/* 8225AB9Ch case    5:*/		return 0x8225ABA0;
		  /* 8225ABA0h */ case    6:  		/* stw R11, <#[R28 + 228]> */
		/* 8225ABA0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x000000E4) );
		/* 8225ABA0h case    6:*/		return 0x8225ABA4;
		  /* 8225ABA4h */ case    7:  		/* mr R3, R31 */
		/* 8225ABA4h case    7:*/		regs.R3 = regs.R31;
		/* 8225ABA4h case    7:*/		return 0x8225ABA8;
		  /* 8225ABA8h */ case    8:  		/* bl -150448 */
		/* 8225ABA8h case    8:*/		regs.LR = 0x8225ABAC; return 0x82235FF8;
		/* 8225ABA8h case    8:*/		return 0x8225ABAC;
	}
	return 0x8225ABAC;
} // Block from 8225AB88h-8225ABACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225ABACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ABAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ABAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ABAC);
		  /* 8225ABACh */ case    0:  		/* addi R25, R25, 1 */
		/* 8225ABACh case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8225ABACh case    0:*/		return 0x8225ABB0;
		  /* 8225ABB0h */ case    1:  		/* addi R27, R27, 4 */
		/* 8225ABB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8225ABB0h case    1:*/		return 0x8225ABB4;
		  /* 8225ABB4h */ case    2:  		/* b -84 */
		/* 8225ABB4h case    2:*/		return 0x8225AB60;
		/* 8225ABB4h case    2:*/		return 0x8225ABB8;
	}
	return 0x8225ABB8;
} // Block from 8225ABACh-8225ABB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225ABB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ABB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ABB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ABB8);
		  /* 8225ABB8h */ case    0:  		/* lwz R11, <#[R31 + 2112]> */
		/* 8225ABB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000840) );
		/* 8225ABB8h case    0:*/		return 0x8225ABBC;
		  /* 8225ABBCh */ case    1:  		/* mr R3, R31 */
		/* 8225ABBCh case    1:*/		regs.R3 = regs.R31;
		/* 8225ABBCh case    1:*/		return 0x8225ABC0;
		  /* 8225ABC0h */ case    2:  		/* stb R23, <#[R26 + 5]> */
		/* 8225ABC0h case    2:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R26 + 0x00000005) );
		/* 8225ABC0h case    2:*/		return 0x8225ABC4;
		  /* 8225ABC4h */ case    3:  		/* add R11, R11, R29 */
		/* 8225ABC4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225ABC4h case    3:*/		return 0x8225ABC8;
		  /* 8225ABC8h */ case    4:  		/* stw R11, <#[R26 + 16]> */
		/* 8225ABC8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8225ABC8h case    4:*/		return 0x8225ABCC;
		  /* 8225ABCCh */ case    5:  		/* lwz R11, <#[R31 + 2112]> */
		/* 8225ABCCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000840) );
		/* 8225ABCCh case    5:*/		return 0x8225ABD0;
		  /* 8225ABD0h */ case    6:  		/* add R4, R11, R29 */
		/* 8225ABD0h case    6:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 8225ABD0h case    6:*/		return 0x8225ABD4;
		  /* 8225ABD4h */ case    7:  		/* bl -79396 */
		/* 8225ABD4h case    7:*/		regs.LR = 0x8225ABD8; return 0x822475B0;
		/* 8225ABD4h case    7:*/		return 0x8225ABD8;
		  /* 8225ABD8h */ case    8:  		/* lwz R11, <#[R31 + 2112]> */
		/* 8225ABD8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000840) );
		/* 8225ABD8h case    8:*/		return 0x8225ABDC;
		  /* 8225ABDCh */ case    9:  		/* mr R3, R31 */
		/* 8225ABDCh case    9:*/		regs.R3 = regs.R31;
		/* 8225ABDCh case    9:*/		return 0x8225ABE0;
		  /* 8225ABE0h */ case   10:  		/* add R4, R11, R29 */
		/* 8225ABE0h case   10:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 8225ABE0h case   10:*/		return 0x8225ABE4;
		  /* 8225ABE4h */ case   11:  		/* bl -79508 */
		/* 8225ABE4h case   11:*/		regs.LR = 0x8225ABE8; return 0x82247550;
		/* 8225ABE4h case   11:*/		return 0x8225ABE8;
	}
	return 0x8225ABE8;
} // Block from 8225ABB8h-8225ABE8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225ABE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ABE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ABE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ABE8);
		  /* 8225ABE8h */ case    0:  		/* lwz R11, <#[R31 + 2108]> */
		/* 8225ABE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000083C) );
		/* 8225ABE8h case    0:*/		return 0x8225ABEC;
		  /* 8225ABECh */ case    1:  		/* addi R29, R29, 1 */
		/* 8225ABECh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8225ABECh case    1:*/		return 0x8225ABF0;
		  /* 8225ABF0h */ case    2:  		/* cmpw CR6, R29, R11 */
		/* 8225ABF0h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 8225ABF0h case    2:*/		return 0x8225ABF4;
		  /* 8225ABF4h */ case    3:  		/* bc 12, CR6_LT, -188 */
		/* 8225ABF4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225AB38;  }
		/* 8225ABF4h case    3:*/		return 0x8225ABF8;
	}
	return 0x8225ABF8;
} // Block from 8225ABE8h-8225ABF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225ABF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ABF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ABF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ABF8);
		  /* 8225ABF8h */ case    0:  		/* lbz R11, <#[R31 + 2116]> */
		/* 8225ABF8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000844) );
		/* 8225ABF8h case    0:*/		return 0x8225ABFC;
		  /* 8225ABFCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8225ABFCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225ABFCh case    1:*/		return 0x8225AC00;
		  /* 8225AC00h */ case    2:  		/* bc 12, CR0_EQ, 280 */
		/* 8225AC00h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225AD18;  }
		/* 8225AC00h case    2:*/		return 0x8225AC04;
		  /* 8225AC04h */ case    3:  		/* lwz R11, <#[R31 + 2124]> */
		/* 8225AC04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000084C) );
		/* 8225AC04h case    3:*/		return 0x8225AC08;
		  /* 8225AC08h */ case    4:  		/* lwz R10, <#[R31 + 2128]> */
		/* 8225AC08h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000850) );
		/* 8225AC08h case    4:*/		return 0x8225AC0C;
		  /* 8225AC0Ch */ case    5:  		/* subf R9, R11, R24 */
		/* 8225AC0Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R24);
		/* 8225AC0Ch case    5:*/		return 0x8225AC10;
		  /* 8225AC10h */ case    6:  		/* mr R29, R11 */
		/* 8225AC10h case    6:*/		regs.R29 = regs.R11;
		/* 8225AC10h case    6:*/		return 0x8225AC14;
		  /* 8225AC14h */ case    7:  		/* stw R9, <#[R31 + 2132]> */
		/* 8225AC14h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000854) );
		/* 8225AC14h case    7:*/		return 0x8225AC18;
		  /* 8225AC18h */ case    8:  		/* cmpw CR6, R11, R10 */
		/* 8225AC18h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8225AC18h case    8:*/		return 0x8225AC1C;
		  /* 8225AC1Ch */ case    9:  		/* bc 4, CR6_LT, 252 */
		/* 8225AC1Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x8225AD18;  }
		/* 8225AC1Ch case    9:*/		return 0x8225AC20;
		  /* 8225AC20h */ case   10:  		/* lis R9, -32251 */
		/* 8225AC20h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8225AC20h case   10:*/		return 0x8225AC24;
		  /* 8225AC24h */ case   11:  		/* lis R8, -32253 */
		/* 8225AC24h case   11:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8203);
		/* 8225AC24h case   11:*/		return 0x8225AC28;
	}
	return 0x8225AC28;
} // Block from 8225ABF8h-8225AC28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225AC28h
// Function '?TypeName@IfHeaderStatic@XGRAPHICS@@UBAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AC28);
		  /* 8225AC28h */ case    0:  		/* lis R10, -32251 */
		/* 8225AC28h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225AC28h case    0:*/		return 0x8225AC2C;
		  /* 8225AC2Ch */ case    1:  		/* lis R11, -32251 */
		/* 8225AC2Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225AC2Ch case    1:*/		return 0x8225AC30;
		  /* 8225AC30h */ case    2:  		/* lis R26, -32251 */
		/* 8225AC30h case    2:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8205);
		/* 8225AC30h case    2:*/		return 0x8225AC34;
		  /* 8225AC34h */ case    3:  		/* addi R25, R9, -21588 */
		/* 8225AC34h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R9,0xFFFFABAC);
		/* 8225AC34h case    3:*/		return 0x8225AC38;
	}
	return 0x8225AC38;
} // Block from 8225AC28h-8225AC38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225AC38h
// Function '?MakeInst@CFG@XGRAPHICS@@AAAPAVIRInst@2@W4ILOpCode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AC38);
		  /* 8225AC38h */ case    0:  		/* addi R28, R8, 27460 */
		/* 8225AC38h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R8,0x6B44);
		/* 8225AC38h case    0:*/		return 0x8225AC3C;
		  /* 8225AC3Ch */ case    1:  		/* addi R24, R10, -21596 */
		/* 8225AC3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0xFFFFABA4);
		/* 8225AC3Ch case    1:*/		return 0x8225AC40;
		  /* 8225AC40h */ case    2:  		/* addi R27, R11, -21904 */
		/* 8225AC40h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFAA70);
		/* 8225AC40h case    2:*/		return 0x8225AC44;
		  /* 8225AC44h */ case    3:  		/* mr R5, R29 */
		/* 8225AC44h case    3:*/		regs.R5 = regs.R29;
		/* 8225AC44h case    3:*/		return 0x8225AC48;
		  /* 8225AC48h */ case    4:  		/* lwz R4, <#[R31 + 2120]> */
		/* 8225AC48h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000848) );
		/* 8225AC48h case    4:*/		return 0x8225AC4C;
		  /* 8225AC4Ch */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225AC4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225AC4Ch case    5:*/		return 0x8225AC50;
		  /* 8225AC50h */ case    6:  		/* bl -89416 */
		/* 8225AC50h case    6:*/		regs.LR = 0x8225AC54; return 0x82244F08;
		/* 8225AC50h case    6:*/		return 0x8225AC54;
		  /* 8225AC54h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 8225AC54h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8225AC54h case    7:*/		return 0x8225AC58;
		  /* 8225AC58h */ case    8:  		/* bc 12, CR0_EQ, 176 */
		/* 8225AC58h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225AD08;  }
		/* 8225AC58h case    8:*/		return 0x8225AC5C;
		  /* 8225AC5Ch */ case    9:  		/* lwz R11, <#[R3 + 56]> */
		/* 8225AC5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8225AC5Ch case    9:*/		return 0x8225AC60;
		  /* 8225AC60h */ case   10:  		/* mr R5, R31 */
		/* 8225AC60h case   10:*/		regs.R5 = regs.R31;
		/* 8225AC60h case   10:*/		return 0x8225AC64;
		  /* 8225AC64h */ case   11:  		/* lwz R10, <#[R11 + 228]> */
		/* 8225AC64h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8225AC64h case   11:*/		return 0x8225AC68;
		  /* 8225AC68h */ case   12:  		/* ori R10, R10, 8 */
		/* 8225AC68h case   12:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8);
		/* 8225AC68h case   12:*/		return 0x8225AC6C;
		  /* 8225AC6Ch */ case   13:  		/* stw R10, <#[R11 + 228]> */
		/* 8225AC6Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 8225AC6Ch case   13:*/		return 0x8225AC70;
		  /* 8225AC70h */ case   14:  		/* lwz R4, <#[R26 - 31496]> */
		/* 8225AC70h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0xFFFF84F8) );
		/* 8225AC70h case   14:*/		return 0x8225AC74;
		  /* 8225AC74h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 8225AC74h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225AC74h case   15:*/		return 0x8225AC78;
		  /* 8225AC78h */ case   16:  		/* lwz R11, <#[R11 + 32]> */
		/* 8225AC78h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 8225AC78h case   16:*/		return 0x8225AC7C;
		  /* 8225AC7Ch */ case   17:  		/* mtspr CTR, R11 */
		/* 8225AC7Ch case   17:*/		regs.CTR = regs.R11;
		/* 8225AC7Ch case   17:*/		return 0x8225AC80;
		  /* 8225AC80h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 8225AC80h case   18:*/		if ( 1 ) { regs.LR = 0x8225AC84; return (uint32)regs.CTR; }
		/* 8225AC80h case   18:*/		return 0x8225AC84;
		  /* 8225AC84h */ case   19:  		/* or. R30, R3, R3 */
		/* 8225AC84h case   19:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8225AC84h case   19:*/		return 0x8225AC88;
		  /* 8225AC88h */ case   20:  		/* bc 4, CR0_EQ, 28 */
		/* 8225AC88h case   20:*/		if ( !regs.CR[0].eq ) { return 0x8225ACA4;  }
		/* 8225AC88h case   20:*/		return 0x8225AC8C;
		  /* 8225AC8Ch */ case   21:  		/* mr R6, R27 */
		/* 8225AC8Ch case   21:*/		regs.R6 = regs.R27;
		/* 8225AC8Ch case   21:*/		return 0x8225AC90;
		  /* 8225AC90h */ case   22:  		/* mr R5, R24 */
		/* 8225AC90h case   22:*/		regs.R5 = regs.R24;
		/* 8225AC90h case   22:*/		return 0x8225AC94;
		  /* 8225AC94h */ case   23:  		/* mr R4, R28 */
		/* 8225AC94h case   23:*/		regs.R4 = regs.R28;
		/* 8225AC94h case   23:*/		return 0x8225AC98;
		  /* 8225AC98h */ case   24:  		/* li R7, 4505 */
		/* 8225AC98h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x1199);
		/* 8225AC98h case   24:*/		return 0x8225AC9C;
		  /* 8225AC9Ch */ case   25:  		/* li R3, 0 */
		/* 8225AC9Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225AC9Ch case   25:*/		return 0x8225ACA0;
		  /* 8225ACA0h */ case   26:  		/* bl -1061016 */
		/* 8225ACA0h case   26:*/		regs.LR = 0x8225ACA4; return 0x82157C08;
		/* 8225ACA0h case   26:*/		return 0x8225ACA4;
	}
	return 0x8225ACA4;
} // Block from 8225AC38h-8225ACA4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8225ACA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ACA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ACA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ACA4);
		  /* 8225ACA4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8225ACA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225ACA4h case    0:*/		return 0x8225ACA8;
		  /* 8225ACA8h */ case    1:  		/* mr R3, R30 */
		/* 8225ACA8h case    1:*/		regs.R3 = regs.R30;
		/* 8225ACA8h case    1:*/		return 0x8225ACAC;
		  /* 8225ACACh */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 8225ACACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8225ACACh case    2:*/		return 0x8225ACB0;
		  /* 8225ACB0h */ case    3:  		/* mtspr CTR, R11 */
		/* 8225ACB0h case    3:*/		regs.CTR = regs.R11;
		/* 8225ACB0h case    3:*/		return 0x8225ACB4;
		  /* 8225ACB4h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8225ACB4h case    4:*/		if ( 1 ) { regs.LR = 0x8225ACB8; return (uint32)regs.CTR; }
		/* 8225ACB4h case    4:*/		return 0x8225ACB8;
		  /* 8225ACB8h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225ACB8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225ACB8h case    5:*/		return 0x8225ACBC;
		  /* 8225ACBCh */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 8225ACBCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8225ACD8;  }
		/* 8225ACBCh case    6:*/		return 0x8225ACC0;
		  /* 8225ACC0h */ case    7:  		/* mr R6, R27 */
		/* 8225ACC0h case    7:*/		regs.R6 = regs.R27;
		/* 8225ACC0h case    7:*/		return 0x8225ACC4;
		  /* 8225ACC4h */ case    8:  		/* mr R5, R25 */
		/* 8225ACC4h case    8:*/		regs.R5 = regs.R25;
		/* 8225ACC4h case    8:*/		return 0x8225ACC8;
		  /* 8225ACC8h */ case    9:  		/* mr R4, R28 */
		/* 8225ACC8h case    9:*/		regs.R4 = regs.R28;
		/* 8225ACC8h case    9:*/		return 0x8225ACCC;
		  /* 8225ACCCh */ case   10:  		/* li R7, 4506 */
		/* 8225ACCCh case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x119A);
		/* 8225ACCCh case   10:*/		return 0x8225ACD0;
		  /* 8225ACD0h */ case   11:  		/* li R3, 0 */
		/* 8225ACD0h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225ACD0h case   11:*/		return 0x8225ACD4;
		  /* 8225ACD4h */ case   12:  		/* bl -1061068 */
		/* 8225ACD4h case   12:*/		regs.LR = 0x8225ACD8; return 0x82157C08;
		/* 8225ACD4h case   12:*/		return 0x8225ACD8;
	}
	return 0x8225ACD8;
} // Block from 8225ACA4h-8225ACD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225ACD8h
// Function '?GetChMask@XGRAPHICS@@YA?AW4ModDestChannel@R400Tables@@D@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ACD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ACD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ACD8);
		  /* 8225ACD8h */ case    0:  		/* lwz R11, <#[R31 + 2132]> */
		/* 8225ACD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000854) );
		/* 8225ACD8h case    0:*/		return 0x8225ACDC;
		  /* 8225ACDCh */ case    1:  		/* mr R3, R31 */
		/* 8225ACDCh case    1:*/		regs.R3 = regs.R31;
		/* 8225ACDCh case    1:*/		return 0x8225ACE0;
		  /* 8225ACE0h */ case    2:  		/* stb R23, <#[R30 + 5]> */
		/* 8225ACE0h case    2:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R30 + 0x00000005) );
		/* 8225ACE0h case    2:*/		return 0x8225ACE4;
		  /* 8225ACE4h */ case    3:  		/* add R11, R11, R29 */
		/* 8225ACE4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225ACE4h case    3:*/		return 0x8225ACE8;
		  /* 8225ACE8h */ case    4:  		/* stw R11, <#[R30 + 16]> */
		/* 8225ACE8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8225ACE8h case    4:*/		return 0x8225ACEC;
		  /* 8225ACECh */ case    5:  		/* lwz R11, <#[R31 + 2132]> */
		/* 8225ACECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000854) );
		/* 8225ACECh case    5:*/		return 0x8225ACF0;
		  /* 8225ACF0h */ case    6:  		/* add R4, R11, R29 */
		/* 8225ACF0h case    6:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 8225ACF0h case    6:*/		return 0x8225ACF4;
		  /* 8225ACF4h */ case    7:  		/* bl -79684 */
		/* 8225ACF4h case    7:*/		regs.LR = 0x8225ACF8; return 0x822475B0;
		/* 8225ACF4h case    7:*/		return 0x8225ACF8;
		  /* 8225ACF8h */ case    8:  		/* lwz R11, <#[R31 + 2132]> */
		/* 8225ACF8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000854) );
		/* 8225ACF8h case    8:*/		return 0x8225ACFC;
		  /* 8225ACFCh */ case    9:  		/* mr R3, R31 */
		/* 8225ACFCh case    9:*/		regs.R3 = regs.R31;
		/* 8225ACFCh case    9:*/		return 0x8225AD00;
		  /* 8225AD00h */ case   10:  		/* add R4, R11, R29 */
		/* 8225AD00h case   10:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R29);
		/* 8225AD00h case   10:*/		return 0x8225AD04;
		  /* 8225AD04h */ case   11:  		/* bl -79796 */
		/* 8225AD04h case   11:*/		regs.LR = 0x8225AD08; return 0x82247550;
		/* 8225AD04h case   11:*/		return 0x8225AD08;
	}
	return 0x8225AD08;
} // Block from 8225ACD8h-8225AD08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD08);
		  /* 8225AD08h */ case    0:  		/* lwz R11, <#[R31 + 2128]> */
		/* 8225AD08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 8225AD08h case    0:*/		return 0x8225AD0C;
		  /* 8225AD0Ch */ case    1:  		/* addi R29, R29, 1 */
		/* 8225AD0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8225AD0Ch case    1:*/		return 0x8225AD10;
		  /* 8225AD10h */ case    2:  		/* cmpw CR6, R29, R11 */
		/* 8225AD10h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 8225AD10h case    2:*/		return 0x8225AD14;
		  /* 8225AD14h */ case    3:  		/* bc 12, CR6_LT, -208 */
		/* 8225AD14h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225AC44;  }
		/* 8225AD14h case    3:*/		return 0x8225AD18;
	}
	return 0x8225AD18;
} // Block from 8225AD08h-8225AD18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD18);
		  /* 8225AD18h */ case    0:  		/* addi R28, R31, 184 */
		/* 8225AD18h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xB8);
		/* 8225AD18h case    0:*/		return 0x8225AD1C;
		  /* 8225AD1Ch */ case    1:  		/* li R7, 0 */
		/* 8225AD1Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8225AD1Ch case    1:*/		return 0x8225AD20;
		  /* 8225AD20h */ case    2:  		/* li R6, 0 */
		/* 8225AD20h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225AD20h case    2:*/		return 0x8225AD24;
		  /* 8225AD24h */ case    3:  		/* li R5, 0 */
		/* 8225AD24h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225AD24h case    3:*/		return 0x8225AD28;
		  /* 8225AD28h */ case    4:  		/* mr R4, R31 */
		/* 8225AD28h case    4:*/		regs.R4 = regs.R31;
		/* 8225AD28h case    4:*/		return 0x8225AD2C;
		  /* 8225AD2Ch */ case    5:  		/* mr R3, R28 */
		/* 8225AD2Ch case    5:*/		regs.R3 = regs.R28;
		/* 8225AD2Ch case    5:*/		return 0x8225AD30;
		  /* 8225AD30h */ case    6:  		/* bl -34704 */
		/* 8225AD30h case    6:*/		regs.LR = 0x8225AD34; return 0x822525A0;
		/* 8225AD30h case    6:*/		return 0x8225AD34;
		  /* 8225AD34h */ case    7:  		/* addi R11, R3, 1 */
		/* 8225AD34h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8225AD34h case    7:*/		return 0x8225AD38;
		  /* 8225AD38h */ case    8:  		/* stw R11, <#[R31 + 2084]> */
		/* 8225AD38h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000824) );
		/* 8225AD38h case    8:*/		return 0x8225AD3C;
	}
	return 0x8225AD3C;
} // Block from 8225AD18h-8225AD3Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD3C);
		  /* 8225AD3Ch */ case    0:  		/* mr R3, R28 */
		/* 8225AD3Ch case    0:*/		regs.R3 = regs.R28;
		/* 8225AD3Ch case    0:*/		return 0x8225AD40;
		  /* 8225AD40h */ case    1:  		/* bl -37672 */
		/* 8225AD40h case    1:*/		regs.LR = 0x8225AD44; return 0x82251A18;
		/* 8225AD40h case    1:*/		return 0x8225AD44;
		  /* 8225AD44h */ case    2:  		/* addi R1, R1, 160 */
		/* 8225AD44h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8225AD44h case    2:*/		return 0x8225AD48;
		  /* 8225AD48h */ case    3:  		/* b -1874612 */
		/* 8225AD48h case    3:*/		return 0x82091294;
		/* 8225AD48h case    3:*/		return 0x8225AD4C;
		  /* 8225AD4Ch */ case    4:  		/* nop */
		/* 8225AD4Ch case    4:*/		cpu::op::nop();
		/* 8225AD4Ch case    4:*/		return 0x8225AD50;
	}
	return 0x8225AD50;
} // Block from 8225AD3Ch-8225AD50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD50h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD50);
		  /* 8225AD50h */ case    0:  		/* mfspr R12, LR */
		/* 8225AD50h case    0:*/		regs.R12 = regs.LR;
		/* 8225AD50h case    0:*/		return 0x8225AD54;
		  /* 8225AD54h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8225AD54h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225AD54h case    1:*/		return 0x8225AD58;
		  /* 8225AD58h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8225AD58h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225AD58h case    2:*/		return 0x8225AD5C;
		  /* 8225AD5Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8225AD5Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8225AD5Ch case    3:*/		return 0x8225AD60;
		  /* 8225AD60h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 8225AD60h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8225AD60h case    4:*/		return 0x8225AD64;
		  /* 8225AD64h */ case    5:  		/* addi R11, R10, -1 */
		/* 8225AD64h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8225AD64h case    5:*/		return 0x8225AD68;
	}
	return 0x8225AD68;
} // Block from 8225AD50h-8225AD68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD68h
// Function '?AddResource@IRInst@XGRAPHICS@@QAAXPAVVRegInfo@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD68);
		  /* 8225AD68h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 8225AD68h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8225AD68h case    0:*/		return 0x8225AD6C;
		  /* 8225AD6Ch */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8225AD6Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8225AD80;  }
		/* 8225AD6Ch case    1:*/		return 0x8225AD70;
		  /* 8225AD70h */ case    2:  		/* lwz R10, <#[R3 + 8]> */
		/* 8225AD70h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8225AD70h case    2:*/		return 0x8225AD74;
		  /* 8225AD74h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225AD74h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225AD74h case    3:*/		return 0x8225AD78;
		  /* 8225AD78h */ case    4:  		/* add R11, R11, R10 */
		/* 8225AD78h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225AD78h case    4:*/		return 0x8225AD7C;
		  /* 8225AD7Ch */ case    5:  		/* b 8 */
		/* 8225AD7Ch case    5:*/		return 0x8225AD84;
		/* 8225AD7Ch case    5:*/		return 0x8225AD80;
	}
	return 0x8225AD80;
} // Block from 8225AD68h-8225AD80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD80);
		  /* 8225AD80h */ case    0:  		/* li R11, 0 */
		/* 8225AD80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225AD80h case    0:*/		return 0x8225AD84;
	}
	return 0x8225AD84;
} // Block from 8225AD80h-8225AD84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AD84);
		  /* 8225AD84h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 8225AD84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8225AD84h case    0:*/		return 0x8225AD88;
		  /* 8225AD88h */ case    1:  		/* lwz R31, <#[R11]> */
		/* 8225AD88h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8225AD88h case    1:*/		return 0x8225AD8C;
		  /* 8225AD8Ch */ case    2:  		/* addi R4, R10, -1 */
		/* 8225AD8Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFFFFF);
		/* 8225AD8Ch case    2:*/		return 0x8225AD90;
		  /* 8225AD90h */ case    3:  		/* bl -29584 */
		/* 8225AD90h case    3:*/		regs.LR = 0x8225AD94; return 0x82253A00;
		/* 8225AD90h case    3:*/		return 0x8225AD94;
		  /* 8225AD94h */ case    4:  		/* mr R3, R31 */
		/* 8225AD94h case    4:*/		regs.R3 = regs.R31;
		/* 8225AD94h case    4:*/		return 0x8225AD98;
		  /* 8225AD98h */ case    5:  		/* addi R1, R1, 96 */
		/* 8225AD98h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8225AD98h case    5:*/		return 0x8225AD9C;
		  /* 8225AD9Ch */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8225AD9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8225AD9Ch case    6:*/		return 0x8225ADA0;
		  /* 8225ADA0h */ case    7:  		/* mtspr LR, R12 */
		/* 8225ADA0h case    7:*/		regs.LR = regs.R12;
		/* 8225ADA0h case    7:*/		return 0x8225ADA4;
		  /* 8225ADA4h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 8225ADA4h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8225ADA4h case    8:*/		return 0x8225ADA8;
		  /* 8225ADA8h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8225ADA8h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8225ADA8h case    9:*/		return 0x8225ADAC;
	}
	return 0x8225ADAC;
} // Block from 8225AD84h-8225ADACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225ADACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ADAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ADAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ADAC);
		  /* 8225ADACh */ case    0:  		/* nop */
		/* 8225ADACh case    0:*/		cpu::op::nop();
		/* 8225ADACh case    0:*/		return 0x8225ADB0;
	}
	return 0x8225ADB0;
} // Block from 8225ADACh-8225ADB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225ADB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ADB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ADB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ADB0);
		  /* 8225ADB0h */ case    0:  		/* mfspr R12, LR */
		/* 8225ADB0h case    0:*/		regs.R12 = regs.LR;
		/* 8225ADB0h case    0:*/		return 0x8225ADB4;
		  /* 8225ADB4h */ case    1:  		/* bl -1874784 */
		/* 8225ADB4h case    1:*/		regs.LR = 0x8225ADB8; return 0x82091254;
		/* 8225ADB4h case    1:*/		return 0x8225ADB8;
		  /* 8225ADB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8225ADB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8225ADB8h case    2:*/		return 0x8225ADBC;
		  /* 8225ADBCh */ case    3:  		/* lwz R11, <#[R4 + 1400]> */
		/* 8225ADBCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000578) );
		/* 8225ADBCh case    3:*/		return 0x8225ADC0;
		  /* 8225ADC0h */ case    4:  		/* mr R30, R3 */
		/* 8225ADC0h case    4:*/		regs.R30 = regs.R3;
		/* 8225ADC0h case    4:*/		return 0x8225ADC4;
		  /* 8225ADC4h */ case    5:  		/* mr R28, R4 */
		/* 8225ADC4h case    5:*/		regs.R28 = regs.R4;
		/* 8225ADC4h case    5:*/		return 0x8225ADC8;
		  /* 8225ADC8h */ case    6:  		/* li R29, 0 */
		/* 8225ADC8h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8225ADC8h case    6:*/		return 0x8225ADCC;
		  /* 8225ADCCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8225ADCCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225ADCCh case    7:*/		return 0x8225ADD0;
		  /* 8225ADD0h */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 8225ADD0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8225AE10;  }
		/* 8225ADD0h case    8:*/		return 0x8225ADD4;
		  /* 8225ADD4h */ case    9:  		/* lwz R27, <#[R4 + 1456]> */
		/* 8225ADD4h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R4 + 0x000005B0) );
		/* 8225ADD4h case    9:*/		return 0x8225ADD8;
		  /* 8225ADD8h */ case   10:  		/* li R4, 40 */
		/* 8225ADD8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 8225ADD8h case   10:*/		return 0x8225ADDC;
		  /* 8225ADDCh */ case   11:  		/* mr R3, R27 */
		/* 8225ADDCh case   11:*/		regs.R3 = regs.R27;
		/* 8225ADDCh case   11:*/		return 0x8225ADE0;
	}
	return 0x8225ADE0;
} // Block from 8225ADB0h-8225ADE0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225ADE0h
// Function '?numDestinationRegisters@XGRAPHICS@@YA?BHW4ILOpCode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ADE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ADE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ADE0);
		  /* 8225ADE0h */ case    0:  		/* bl -256296 */
		/* 8225ADE0h case    0:*/		regs.LR = 0x8225ADE4; return 0x8221C4B8;
		/* 8225ADE0h case    0:*/		return 0x8225ADE4;
		  /* 8225ADE4h */ case    1:  		/* addic. R31, R3, 4 */
		/* 8225ADE4h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 8225ADE4h case    1:*/		return 0x8225ADE8;
		  /* 8225ADE8h */ case    2:  		/* stw R27, <#[R3]> */
		/* 8225ADE8h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8225ADE8h case    2:*/		return 0x8225ADEC;
		  /* 8225ADECh */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 8225ADECh case    3:*/		if ( regs.CR[0].eq ) { return 0x8225AE08;  }
		/* 8225ADECh case    3:*/		return 0x8225ADF0;
		  /* 8225ADF0h */ case    4:  		/* stw R30, <#[R31 + 4]> */
		/* 8225ADF0h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8225ADF0h case    4:*/		return 0x8225ADF4;
		  /* 8225ADF4h */ case    5:  		/* addi R3, R31, 12 */
		/* 8225ADF4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC);
		/* 8225ADF4h case    5:*/		return 0x8225ADF8;
		  /* 8225ADF8h */ case    6:  		/* stw R29, <#[R31]> */
		/* 8225ADF8h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8225ADF8h case    6:*/		return 0x8225ADFC;
		  /* 8225ADFCh */ case    7:  		/* stw R29, <#[R31 + 8]> */
		/* 8225ADFCh case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 8225ADFCh case    7:*/		return 0x8225AE00;
		  /* 8225AE00h */ case    8:  		/* bl -30168 */
		/* 8225AE00h case    8:*/		regs.LR = 0x8225AE04; return 0x82253828;
		/* 8225AE00h case    8:*/		return 0x8225AE04;
		  /* 8225AE04h */ case    9:  		/* b 8 */
		/* 8225AE04h case    9:*/		return 0x8225AE0C;
		/* 8225AE04h case    9:*/		return 0x8225AE08;
	}
	return 0x8225AE08;
} // Block from 8225ADE0h-8225AE08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE08);
		  /* 8225AE08h */ case    0:  		/* mr R31, R29 */
		/* 8225AE08h case    0:*/		regs.R31 = regs.R29;
		/* 8225AE08h case    0:*/		return 0x8225AE0C;
	}
	return 0x8225AE0C;
} // Block from 8225AE08h-8225AE0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE0C);
		  /* 8225AE0Ch */ case    0:  		/* stw R31, <#[R28 + 1400]> */
		/* 8225AE0Ch case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000578) );
		/* 8225AE0Ch case    0:*/		return 0x8225AE10;
	}
	return 0x8225AE10;
} // Block from 8225AE0Ch-8225AE10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE10);
		  /* 8225AE10h */ case    0:  		/* lwz R3, <#[R28 + 1400]> */
		/* 8225AE10h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000578) );
		/* 8225AE10h case    0:*/		return 0x8225AE14;
		  /* 8225AE14h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8225AE14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8225AE14h case    1:*/		return 0x8225AE18;
		  /* 8225AE18h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 8225AE18h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225AE6C;  }
		/* 8225AE18h case    2:*/		return 0x8225AE1C;
		  /* 8225AE1Ch */ case    3:  		/* lwz R10, <#[R30]> */
		/* 8225AE1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8225AE1Ch case    3:*/		return 0x8225AE20;
		  /* 8225AE20h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8225AE20h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8225AE20h case    4:*/		return 0x8225AE24;
		  /* 8225AE24h */ case    5:  		/* lwz R9, <#[R11]> */
		/* 8225AE24h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8225AE24h case    5:*/		return 0x8225AE28;
		  /* 8225AE28h */ case    6:  		/* cmpw CR6, R10, R9 */
		/* 8225AE28h case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8225AE28h case    6:*/		return 0x8225AE2C;
		  /* 8225AE2Ch */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 8225AE2Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8225AE54;  }
		/* 8225AE2Ch case    7:*/		return 0x8225AE30;
		  /* 8225AE30h */ case    8:  		/* lwz R9, <#[R30 + 4]> */
		/* 8225AE30h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8225AE30h case    8:*/		return 0x8225AE34;
		  /* 8225AE34h */ case    9:  		/* lwz R8, <#[R11 + 4]> */
		/* 8225AE34h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8225AE34h case    9:*/		return 0x8225AE38;
		  /* 8225AE38h */ case   10:  		/* cmpw CR6, R9, R8 */
		/* 8225AE38h case   10:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 8225AE38h case   10:*/		return 0x8225AE3C;
		  /* 8225AE3Ch */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 8225AE3Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8225AE54;  }
		/* 8225AE3Ch case   11:*/		return 0x8225AE40;
		  /* 8225AE40h */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 8225AE40h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8225AE40h case   12:*/		return 0x8225AE44;
		  /* 8225AE44h */ case   13:  		/* lwz R9, <#[R30 + 8]> */
		/* 8225AE44h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8225AE44h case   13:*/		return 0x8225AE48;
		  /* 8225AE48h */ case   14:  		/* cmpw CR6, R9, R11 */
		/* 8225AE48h case   14:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 8225AE48h case   14:*/		return 0x8225AE4C;
		  /* 8225AE4Ch */ case   15:  		/* li R11, 1 */
		/* 8225AE4Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225AE4Ch case   15:*/		return 0x8225AE50;
		  /* 8225AE50h */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 8225AE50h case   16:*/		if ( regs.CR[6].eq ) { return 0x8225AE58;  }
		/* 8225AE50h case   16:*/		return 0x8225AE54;
	}
	return 0x8225AE54;
} // Block from 8225AE10h-8225AE54h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE54);
		  /* 8225AE54h */ case    0:  		/* mr R11, R29 */
		/* 8225AE54h case    0:*/		regs.R11 = regs.R29;
		/* 8225AE54h case    0:*/		return 0x8225AE58;
	}
	return 0x8225AE58;
} // Block from 8225AE54h-8225AE58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE58);
		  /* 8225AE58h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225AE58h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225AE58h case    0:*/		return 0x8225AE5C;
		  /* 8225AE5Ch */ case    1:  		/* bc 4, CR0_EQ, 96 */
		/* 8225AE5Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8225AEBC;  }
		/* 8225AE5Ch case    1:*/		return 0x8225AE60;
	}
	return 0x8225AE60;
} // Block from 8225AE58h-8225AE60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE60h
// Function '?numSourceRegisters@XGRAPHICS@@YA?BHW4ILOpCode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE60);
		  /* 8225AE60h */ case    0:  		/* lwz R3, <#[R3 + 8]> */
		/* 8225AE60h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 8225AE60h case    0:*/		return 0x8225AE64;
		  /* 8225AE64h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8225AE64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8225AE64h case    1:*/		return 0x8225AE68;
		  /* 8225AE68h */ case    2:  		/* bc 4, CR6_EQ, -72 */
		/* 8225AE68h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8225AE20;  }
		/* 8225AE68h case    2:*/		return 0x8225AE6C;
	}
	return 0x8225AE6C;
} // Block from 8225AE60h-8225AE6Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225AE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AE6C);
		  /* 8225AE6Ch */ case    0:  		/* lwz R27, <#[R28 + 1456]> */
		/* 8225AE6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R28 + 0x000005B0) );
		/* 8225AE6Ch case    0:*/		return 0x8225AE70;
		  /* 8225AE70h */ case    1:  		/* li R4, 40 */
		/* 8225AE70h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 8225AE70h case    1:*/		return 0x8225AE74;
		  /* 8225AE74h */ case    2:  		/* mr R3, R27 */
		/* 8225AE74h case    2:*/		regs.R3 = regs.R27;
		/* 8225AE74h case    2:*/		return 0x8225AE78;
		  /* 8225AE78h */ case    3:  		/* bl -256448 */
		/* 8225AE78h case    3:*/		regs.LR = 0x8225AE7C; return 0x8221C4B8;
		/* 8225AE78h case    3:*/		return 0x8225AE7C;
		  /* 8225AE7Ch */ case    4:  		/* addic. R31, R3, 4 */
		/* 8225AE7Ch case    4:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 8225AE7Ch case    4:*/		return 0x8225AE80;
		  /* 8225AE80h */ case    5:  		/* stw R27, <#[R3]> */
		/* 8225AE80h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8225AE80h case    5:*/		return 0x8225AE84;
		  /* 8225AE84h */ case    6:  		/* bc 12, CR0_EQ, 32 */
		/* 8225AE84h case    6:*/		if ( regs.CR[0].eq ) { return 0x8225AEA4;  }
		/* 8225AE84h case    6:*/		return 0x8225AE88;
		  /* 8225AE88h */ case    7:  		/* stw R30, <#[R31 + 4]> */
		/* 8225AE88h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8225AE88h case    7:*/		return 0x8225AE8C;
		  /* 8225AE8Ch */ case    8:  		/* addi R3, R31, 12 */
		/* 8225AE8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC);
		/* 8225AE8Ch case    8:*/		return 0x8225AE90;
		  /* 8225AE90h */ case    9:  		/* stw R29, <#[R31]> */
		/* 8225AE90h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8225AE90h case    9:*/		return 0x8225AE94;
		  /* 8225AE94h */ case   10:  		/* stw R29, <#[R31 + 8]> */
		/* 8225AE94h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 8225AE94h case   10:*/		return 0x8225AE98;
		  /* 8225AE98h */ case   11:  		/* bl -30320 */
		/* 8225AE98h case   11:*/		regs.LR = 0x8225AE9C; return 0x82253828;
		/* 8225AE98h case   11:*/		return 0x8225AE9C;
		  /* 8225AE9Ch */ case   12:  		/* mr R3, R31 */
		/* 8225AE9Ch case   12:*/		regs.R3 = regs.R31;
		/* 8225AE9Ch case   12:*/		return 0x8225AEA0;
		  /* 8225AEA0h */ case   13:  		/* b 8 */
		/* 8225AEA0h case   13:*/		return 0x8225AEA8;
		/* 8225AEA0h case   13:*/		return 0x8225AEA4;
	}
	return 0x8225AEA4;
} // Block from 8225AE6Ch-8225AEA4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225AEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AEA4);
		  /* 8225AEA4h */ case    0:  		/* mr R3, R29 */
		/* 8225AEA4h case    0:*/		regs.R3 = regs.R29;
		/* 8225AEA4h case    0:*/		return 0x8225AEA8;
	}
	return 0x8225AEA8;
} // Block from 8225AEA4h-8225AEA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AEA8);
		  /* 8225AEA8h */ case    0:  		/* lwz R11, <#[R28 + 1400]> */
		/* 8225AEA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000578) );
		/* 8225AEA8h case    0:*/		return 0x8225AEAC;
		  /* 8225AEACh */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8225AEACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8225AEACh case    1:*/		return 0x8225AEB0;
		  /* 8225AEB0h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 8225AEB0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8225AEB0h case    2:*/		return 0x8225AEB4;
		  /* 8225AEB4h */ case    3:  		/* lwz R11, <#[R28 + 1400]> */
		/* 8225AEB4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000578) );
		/* 8225AEB4h case    3:*/		return 0x8225AEB8;
		  /* 8225AEB8h */ case    4:  		/* stw R3, <#[R11 + 8]> */
		/* 8225AEB8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 8225AEB8h case    4:*/		return 0x8225AEBC;
	}
	return 0x8225AEBC;
} // Block from 8225AEA8h-8225AEBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225AEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AEBC);
		  /* 8225AEBCh */ case    0:  		/* addi R1, R1, 128 */
		/* 8225AEBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8225AEBCh case    0:*/		return 0x8225AEC0;
		  /* 8225AEC0h */ case    1:  		/* b -1874972 */
		/* 8225AEC0h case    1:*/		return 0x820912A4;
		/* 8225AEC0h case    1:*/		return 0x8225AEC4;
		  /* 8225AEC4h */ case    2:  		/* nop */
		/* 8225AEC4h case    2:*/		cpu::op::nop();
		/* 8225AEC4h case    2:*/		return 0x8225AEC8;
	}
	return 0x8225AEC8;
} // Block from 8225AEBCh-8225AEC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225AEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AEC8);
		  /* 8225AEC8h */ case    0:  		/* mfspr R12, LR */
		/* 8225AEC8h case    0:*/		regs.R12 = regs.LR;
		/* 8225AEC8h case    0:*/		return 0x8225AECC;
		  /* 8225AECCh */ case    1:  		/* bl -1875116 */
		/* 8225AECCh case    1:*/		regs.LR = 0x8225AED0; return 0x82091220;
		/* 8225AECCh case    1:*/		return 0x8225AED0;
	}
	return 0x8225AED0;
} // Block from 8225AEC8h-8225AED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225AED0h
// Function '?numAdditionalTokens@XGRAPHICS@@YA?BHW4ILOpCode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AED0);
		  /* 8225AED0h */ case    0:  		/* addi R12, R1, -152 */
		/* 8225AED0h case    0:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 8225AED0h case    0:*/		return 0x8225AED4;
		  /* 8225AED4h */ case    1:  		/* bl -1874624 */
		/* 8225AED4h case    1:*/		regs.LR = 0x8225AED8; return 0x82091414;
		/* 8225AED4h case    1:*/		return 0x8225AED8;
		  /* 8225AED8h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 8225AED8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8225AED8h case    2:*/		return 0x8225AEDC;
		  /* 8225AEDCh */ case    3:  		/* mr R22, R9 */
		/* 8225AEDCh case    3:*/		regs.R22 = regs.R9;
		/* 8225AEDCh case    3:*/		return 0x8225AEE0;
		  /* 8225AEE0h */ case    4:  		/* stw R5, <#[R1 + 324]> */
		/* 8225AEE0h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000144) );
		/* 8225AEE0h case    4:*/		return 0x8225AEE4;
		  /* 8225AEE4h */ case    5:  		/* mr R30, R7 */
		/* 8225AEE4h case    5:*/		regs.R30 = regs.R7;
		/* 8225AEE4h case    5:*/		return 0x8225AEE8;
		  /* 8225AEE8h */ case    6:  		/* lwz R7, <#[R6]> */
		/* 8225AEE8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8225AEE8h case    6:*/		return 0x8225AEEC;
		  /* 8225AEECh */ case    7:  		/* lis R9, -32251 */
		/* 8225AEECh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8225AEECh case    7:*/		return 0x8225AEF0;
		  /* 8225AEF0h */ case    8:  		/* stb R8, <#[R1 + 351]> */
		/* 8225AEF0h case    8:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225AEF0h case    8:*/		return 0x8225AEF4;
		  /* 8225AEF4h */ case    9:  		/* li R20, 0 */
		/* 8225AEF4h case    9:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8225AEF4h case    9:*/		return 0x8225AEF8;
		  /* 8225AEF8h */ case   10:  		/* lis R11, -32253 */
		/* 8225AEF8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8225AEF8h case   10:*/		return 0x8225AEFC;
		  /* 8225AEFCh */ case   11:  		/* lis R10, -32251 */
		/* 8225AEFCh case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225AEFCh case   11:*/		return 0x8225AF00;
		  /* 8225AF00h */ case   12:  		/* extsh R26, R7 */
		/* 8225AF00h case   12:*/		cpu::op::extsh<0>(regs,&regs.R26,regs.R7);
		/* 8225AF00h case   12:*/		return 0x8225AF04;
		  /* 8225AF04h */ case   13:  		/* addi R9, R9, -31600 */
		/* 8225AF04h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFF8490);
		/* 8225AF04h case   13:*/		return 0x8225AF08;
		  /* 8225AF08h */ case   14:  		/* mr R31, R3 */
		/* 8225AF08h case   14:*/		regs.R31 = regs.R3;
		/* 8225AF08h case   14:*/		return 0x8225AF0C;
		  /* 8225AF0Ch */ case   15:  		/* mr R17, R4 */
		/* 8225AF0Ch case   15:*/		regs.R17 = regs.R4;
		/* 8225AF0Ch case   15:*/		return 0x8225AF10;
		  /* 8225AF10h */ case   16:  		/* stw R9, <#[R1 + 88]> */
		/* 8225AF10h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8225AF10h case   16:*/		return 0x8225AF14;
		  /* 8225AF14h */ case   17:  		/* mr R19, R6 */
		/* 8225AF14h case   17:*/		regs.R19 = regs.R6;
		/* 8225AF14h case   17:*/		return 0x8225AF18;
		  /* 8225AF18h */ case   18:  		/* rlwinm. R23, R8, 0, 24, 31 */
		/* 8225AF18h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R23,regs.R8);
		/* 8225AF18h case   18:*/		return 0x8225AF1C;
		  /* 8225AF1Ch */ case   19:  		/* mr R21, R20 */
		/* 8225AF1Ch case   19:*/		regs.R21 = regs.R20;
		/* 8225AF1Ch case   19:*/		return 0x8225AF20;
		  /* 8225AF20h */ case   20:  		/* rlwinm R27, R7, 16, 26, 31 */
		/* 8225AF20h case   20:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R27,regs.R7);
		/* 8225AF20h case   20:*/		return 0x8225AF24;
		  /* 8225AF24h */ case   21:  		/* mr R18, R20 */
		/* 8225AF24h case   21:*/		regs.R18 = regs.R20;
		/* 8225AF24h case   21:*/		return 0x8225AF28;
		  /* 8225AF28h */ case   22:  		/* mr R16, R26 */
		/* 8225AF28h case   22:*/		regs.R16 = regs.R26;
		/* 8225AF28h case   22:*/		return 0x8225AF2C;
		  /* 8225AF2Ch */ case   23:  		/* addi R15, R11, 27460 */
		/* 8225AF2Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R11,0x6B44);
		/* 8225AF2Ch case   23:*/		return 0x8225AF30;
		  /* 8225AF30h */ case   24:  		/* addi R14, R10, -21904 */
		/* 8225AF30h case   24:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R10,0xFFFFAA70);
		/* 8225AF30h case   24:*/		return 0x8225AF34;
		  /* 8225AF34h */ case   25:  		/* bc 12, CR0_EQ, 1376 */
		/* 8225AF34h case   25:*/		if ( regs.CR[0].eq ) { return 0x8225B494;  }
		/* 8225AF34h case   25:*/		return 0x8225AF38;
		  /* 8225AF38h */ case   26:  		/* rlwinm R11, R22, 0, 24, 31 */
		/* 8225AF38h case   26:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R22);
		/* 8225AF38h case   26:*/		return 0x8225AF3C;
		  /* 8225AF3Ch */ case   27:  		/* cntlzw R11, R11 */
		/* 8225AF3Ch case   27:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225AF3Ch case   27:*/		return 0x8225AF40;
	}
	return 0x8225AF40;
} // Block from 8225AED0h-8225AF40h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8225AF40h
// Function '?getExpansion@XGRAPHICS@@YAPBTexpansion_token@1@W4ILOpCode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AF40);
		  /* 8225AF40h */ case    0:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8225AF40h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8225AF40h case    0:*/		return 0x8225AF44;
		  /* 8225AF44h */ case    1:  		/* xori R11, R11, 1 */
		/* 8225AF44h case    1:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225AF44h case    1:*/		return 0x8225AF48;
		  /* 8225AF48h */ case    2:  		/* addi R11, R11, 1 */
		/* 8225AF48h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225AF48h case    2:*/		return 0x8225AF4C;
		  /* 8225AF4Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225AF4Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225AF4Ch case    3:*/		return 0x8225AF50;
		  /* 8225AF50h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8225AF50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8225AF50h case    4:*/		return 0x8225AF54;
		  /* 8225AF54h */ case    5:  		/* rlwinm. R10, R11, 16, 31, 31 */
		/* 8225AF54h case    5:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R10,regs.R11);
		/* 8225AF54h case    5:*/		return 0x8225AF58;
		  /* 8225AF58h */ case    6:  		/* rlwinm R24, R11, 15, 29, 31 */
		/* 8225AF58h case    6:*/		cpu::op::rlwinm<0,15,29,31>(regs,&regs.R24,regs.R11);
		/* 8225AF58h case    6:*/		return 0x8225AF5C;
		  /* 8225AF5Ch */ case    7:  		/* rlwinm R25, R11, 0, 16, 31 */
		/* 8225AF5Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R25,regs.R11);
		/* 8225AF5Ch case    7:*/		return 0x8225AF60;
		  /* 8225AF60h */ case    8:  		/* bc 12, CR0_EQ, 832 */
		/* 8225AF60h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225B2A0;  }
		/* 8225AF60h case    8:*/		return 0x8225AF64;
		  /* 8225AF64h */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 8225AF64h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8225AF64h case    9:*/		return 0x8225AF68;
		  /* 8225AF68h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8225AF68h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225AF68h case   10:*/		return 0x8225AF6C;
		  /* 8225AF6Ch */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8225AF6Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8225AF8C;  }
		/* 8225AF6Ch case   11:*/		return 0x8225AF70;
		  /* 8225AF70h */ case   12:  		/* lis R11, -32251 */
		/* 8225AF70h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225AF70h case   12:*/		return 0x8225AF74;
		  /* 8225AF74h */ case   13:  		/* mr R6, R14 */
		/* 8225AF74h case   13:*/		regs.R6 = regs.R14;
		/* 8225AF74h case   13:*/		return 0x8225AF78;
		  /* 8225AF78h */ case   14:  		/* addi R5, R11, -20744 */
		/* 8225AF78h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAEF8);
		/* 8225AF78h case   14:*/		return 0x8225AF7C;
		  /* 8225AF7Ch */ case   15:  		/* mr R4, R15 */
		/* 8225AF7Ch case   15:*/		regs.R4 = regs.R15;
		/* 8225AF7Ch case   15:*/		return 0x8225AF80;
		  /* 8225AF80h */ case   16:  		/* li R7, 384 */
		/* 8225AF80h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x180);
		/* 8225AF80h case   16:*/		return 0x8225AF84;
		  /* 8225AF84h */ case   17:  		/* li R3, 0 */
		/* 8225AF84h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225AF84h case   17:*/		return 0x8225AF88;
		  /* 8225AF88h */ case   18:  		/* bl -1061760 */
		/* 8225AF88h case   18:*/		regs.LR = 0x8225AF8C; return 0x82157C08;
		/* 8225AF88h case   18:*/		return 0x8225AF8C;
	}
	return 0x8225AF8C;
} // Block from 8225AF40h-8225AF8Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225AF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AF8C);
		  /* 8225AF8Ch */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8225AF8Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8225AF8Ch case    0:*/		return 0x8225AF90;
		  /* 8225AF90h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8225AF90h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225AFB0;  }
		/* 8225AF90h case    1:*/		return 0x8225AF94;
		  /* 8225AF94h */ case    2:  		/* lis R11, -32251 */
		/* 8225AF94h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225AF94h case    2:*/		return 0x8225AF98;
		  /* 8225AF98h */ case    3:  		/* mr R6, R14 */
		/* 8225AF98h case    3:*/		regs.R6 = regs.R14;
		/* 8225AF98h case    3:*/		return 0x8225AF9C;
		  /* 8225AF9Ch */ case    4:  		/* addi R5, R11, -20772 */
		/* 8225AF9Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAEDC);
		/* 8225AF9Ch case    4:*/		return 0x8225AFA0;
		  /* 8225AFA0h */ case    5:  		/* mr R4, R15 */
		/* 8225AFA0h case    5:*/		regs.R4 = regs.R15;
		/* 8225AFA0h case    5:*/		return 0x8225AFA4;
		  /* 8225AFA4h */ case    6:  		/* li R7, 385 */
		/* 8225AFA4h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x181);
		/* 8225AFA4h case    6:*/		return 0x8225AFA8;
		  /* 8225AFA8h */ case    7:  		/* li R3, 0 */
		/* 8225AFA8h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225AFA8h case    7:*/		return 0x8225AFAC;
		  /* 8225AFACh */ case    8:  		/* bl -1061796 */
		/* 8225AFACh case    8:*/		regs.LR = 0x8225AFB0; return 0x82157C08;
		/* 8225AFACh case    8:*/		return 0x8225AFB0;
	}
	return 0x8225AFB0;
} // Block from 8225AF8Ch-8225AFB0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225AFB0h
// Function '?getProcessing@XGRAPHICS@@YAHW4ILOpCode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AFB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AFB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AFB0);
		  /* 8225AFB0h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 8225AFB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8225AFB0h case    0:*/		return 0x8225AFB4;
		  /* 8225AFB4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8225AFB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225AFD4;  }
		/* 8225AFB4h case    1:*/		return 0x8225AFB8;
		  /* 8225AFB8h */ case    2:  		/* lis R11, -32251 */
		/* 8225AFB8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225AFB8h case    2:*/		return 0x8225AFBC;
		  /* 8225AFBCh */ case    3:  		/* mr R6, R14 */
		/* 8225AFBCh case    3:*/		regs.R6 = regs.R14;
		/* 8225AFBCh case    3:*/		return 0x8225AFC0;
		  /* 8225AFC0h */ case    4:  		/* addi R5, R11, -20788 */
		/* 8225AFC0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAECC);
		/* 8225AFC0h case    4:*/		return 0x8225AFC4;
		  /* 8225AFC4h */ case    5:  		/* mr R4, R15 */
		/* 8225AFC4h case    5:*/		regs.R4 = regs.R15;
		/* 8225AFC4h case    5:*/		return 0x8225AFC8;
		  /* 8225AFC8h */ case    6:  		/* li R7, 391 */
		/* 8225AFC8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x187);
		/* 8225AFC8h case    6:*/		return 0x8225AFCC;
		  /* 8225AFCCh */ case    7:  		/* li R3, 0 */
		/* 8225AFCCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225AFCCh case    7:*/		return 0x8225AFD0;
		  /* 8225AFD0h */ case    8:  		/* bl -1061832 */
		/* 8225AFD0h case    8:*/		regs.LR = 0x8225AFD4; return 0x82157C08;
		/* 8225AFD0h case    8:*/		return 0x8225AFD4;
	}
	return 0x8225AFD4;
} // Block from 8225AFB0h-8225AFD4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225AFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AFD4);
		  /* 8225AFD4h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 8225AFD4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8225AFD4h case    0:*/		return 0x8225AFD8;
		  /* 8225AFD8h */ case    1:  		/* addi R11, R10, -1 */
		/* 8225AFD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8225AFD8h case    1:*/		return 0x8225AFDC;
		  /* 8225AFDCh */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8225AFDCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8225AFDCh case    2:*/		return 0x8225AFE0;
		  /* 8225AFE0h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 8225AFE0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8225AFF4;  }
		/* 8225AFE0h case    3:*/		return 0x8225AFE4;
		  /* 8225AFE4h */ case    4:  		/* lwz R10, <#[R30 + 8]> */
		/* 8225AFE4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8225AFE4h case    4:*/		return 0x8225AFE8;
		  /* 8225AFE8h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225AFE8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225AFE8h case    5:*/		return 0x8225AFEC;
		  /* 8225AFECh */ case    6:  		/* add R11, R11, R10 */
		/* 8225AFECh case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225AFECh case    6:*/		return 0x8225AFF0;
		  /* 8225AFF0h */ case    7:  		/* b 8 */
		/* 8225AFF0h case    7:*/		return 0x8225AFF8;
		/* 8225AFF0h case    7:*/		return 0x8225AFF4;
	}
	return 0x8225AFF4;
} // Block from 8225AFD4h-8225AFF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225AFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AFF4);
		  /* 8225AFF4h */ case    0:  		/* mr R11, R20 */
		/* 8225AFF4h case    0:*/		regs.R11 = regs.R20;
		/* 8225AFF4h case    0:*/		return 0x8225AFF8;
	}
	return 0x8225AFF8;
} // Block from 8225AFF4h-8225AFF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225AFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225AFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225AFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225AFF8);
		  /* 8225AFF8h */ case    0:  		/* lwz R24, <#[R11]> */
		/* 8225AFF8h case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 8225AFF8h case    0:*/		return 0x8225AFFC;
		  /* 8225AFFCh */ case    1:  		/* li R4, 39 */
		/* 8225AFFCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x27);
		/* 8225AFFCh case    1:*/		return 0x8225B000;
		  /* 8225B000h */ case    2:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225B000h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225B000h case    2:*/		return 0x8225B004;
		  /* 8225B004h */ case    3:  		/* lwz R25, <#[R24 + 136]> */
		/* 8225B004h case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R24 + 0x00000088) );
		/* 8225B004h case    3:*/		return 0x8225B008;
		  /* 8225B008h */ case    4:  		/* mr R5, R25 */
		/* 8225B008h case    4:*/		regs.R5 = regs.R25;
		/* 8225B008h case    4:*/		return 0x8225B00C;
		  /* 8225B00Ch */ case    5:  		/* bl -88060 */
		/* 8225B00Ch case    5:*/		regs.LR = 0x8225B010; return 0x82245810;
		/* 8225B00Ch case    5:*/		return 0x8225B010;
		  /* 8225B010h */ case    6:  		/* mr R28, R3 */
		/* 8225B010h case    6:*/		regs.R28 = regs.R3;
		/* 8225B010h case    6:*/		return 0x8225B014;
		  /* 8225B014h */ case    7:  		/* cmpwi CR6, R27, 1 */
		/* 8225B014h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000001);
		/* 8225B014h case    7:*/		return 0x8225B018;
		  /* 8225B018h */ case    8:  		/* bc 4, CR6_EQ, 184 */
		/* 8225B018h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8225B0D0;  }
		/* 8225B018h case    8:*/		return 0x8225B01C;
		  /* 8225B01Ch */ case    9:  		/* mr R5, R25 */
		/* 8225B01Ch case    9:*/		regs.R5 = regs.R25;
		/* 8225B01Ch case    9:*/		return 0x8225B020;
	}
	return 0x8225B020;
} // Block from 8225AFF8h-8225B020h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225B020h
// Function '?IL2IR_ImportComponent@XGRAPHICS@@YAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B020);
		  /* 8225B020h */ case    0:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225B020h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225B020h case    0:*/		return 0x8225B024;
		  /* 8225B024h */ case    1:  		/* li R4, 40 */
		/* 8225B024h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 8225B024h case    1:*/		return 0x8225B028;
		  /* 8225B028h */ case    2:  		/* bl -88088 */
		/* 8225B028h case    2:*/		regs.LR = 0x8225B02C; return 0x82245810;
		/* 8225B028h case    2:*/		return 0x8225B02C;
		  /* 8225B02Ch */ case    3:  		/* lbz R11, <#[R3 + 29]> */
		/* 8225B02Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001D) );
		/* 8225B02Ch case    3:*/		return 0x8225B030;
		  /* 8225B030h */ case    4:  		/* mr R29, R3 */
		/* 8225B030h case    4:*/		regs.R29 = regs.R3;
		/* 8225B030h case    4:*/		return 0x8225B034;
		  /* 8225B034h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8225B034h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225B034h case    5:*/		return 0x8225B038;
		  /* 8225B038h */ case    6:  		/* bc 4, CR0_EQ, 144 */
		/* 8225B038h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8225B0C8;  }
		/* 8225B038h case    6:*/		return 0x8225B03C;
		  /* 8225B03Ch */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225B03Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B03Ch case    7:*/		return 0x8225B040;
		  /* 8225B040h */ case    8:  		/* li R4, 964 */
		/* 8225B040h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225B040h case    8:*/		return 0x8225B044;
		  /* 8225B044h */ case    9:  		/* lwz R30, <#[R11 + 1452]> */
		/* 8225B044h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225B044h case    9:*/		return 0x8225B048;
		  /* 8225B048h */ case   10:  		/* mr R3, R30 */
		/* 8225B048h case   10:*/		regs.R3 = regs.R30;
		/* 8225B048h case   10:*/		return 0x8225B04C;
		  /* 8225B04Ch */ case   11:  		/* bl -256916 */
		/* 8225B04Ch case   11:*/		regs.LR = 0x8225B050; return 0x8221C4B8;
		/* 8225B04Ch case   11:*/		return 0x8225B050;
		  /* 8225B050h */ case   12:  		/* mr R11, R3 */
		/* 8225B050h case   12:*/		regs.R11 = regs.R3;
		/* 8225B050h case   12:*/		return 0x8225B054;
		  /* 8225B054h */ case   13:  		/* addic. R3, R3, 4 */
		/* 8225B054h case   13:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225B054h case   13:*/		return 0x8225B058;
		  /* 8225B058h */ case   14:  		/* stw R30, <#[R11]> */
		/* 8225B058h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8225B058h case   14:*/		return 0x8225B05C;
		  /* 8225B05Ch */ case   15:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B05Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8225B074;  }
		/* 8225B05Ch case   15:*/		return 0x8225B060;
		  /* 8225B060h */ case   16:  		/* li R4, 126 */
		/* 8225B060h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x7E);
		/* 8225B060h case   16:*/		return 0x8225B064;
		  /* 8225B064h */ case   17:  		/* lwz R5, <#[R31 + 12]> */
		/* 8225B064h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B064h case   17:*/		return 0x8225B068;
		  /* 8225B068h */ case   18:  		/* bl -14832 */
		/* 8225B068h case   18:*/		regs.LR = 0x8225B06C; return 0x82257678;
		/* 8225B068h case   18:*/		return 0x8225B06C;
		  /* 8225B06Ch */ case   19:  		/* mr R30, R3 */
		/* 8225B06Ch case   19:*/		regs.R30 = regs.R3;
		/* 8225B06Ch case   19:*/		return 0x8225B070;
		  /* 8225B070h */ case   20:  		/* b 8 */
		/* 8225B070h case   20:*/		return 0x8225B078;
		/* 8225B070h case   20:*/		return 0x8225B074;
	}
	return 0x8225B074;
} // Block from 8225B020h-8225B074h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225B074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B074);
		  /* 8225B074h */ case    0:  		/* mr R30, R20 */
		/* 8225B074h case    0:*/		regs.R30 = regs.R20;
		/* 8225B074h case    0:*/		return 0x8225B078;
	}
	return 0x8225B078;
} // Block from 8225B074h-8225B078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B078);
		  /* 8225B078h */ case    0:  		/* mr R5, R29 */
		/* 8225B078h case    0:*/		regs.R5 = regs.R29;
		/* 8225B078h case    0:*/		return 0x8225B07C;
		  /* 8225B07Ch */ case    1:  		/* li R4, 0 */
		/* 8225B07Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225B07Ch case    1:*/		return 0x8225B080;
		  /* 8225B080h */ case    2:  		/* mr R3, R30 */
		/* 8225B080h case    2:*/		regs.R3 = regs.R30;
		/* 8225B080h case    2:*/		return 0x8225B084;
		  /* 8225B084h */ case    3:  		/* bl -19692 */
		/* 8225B084h case    3:*/		regs.LR = 0x8225B088; return 0x82256398;
		/* 8225B084h case    3:*/		return 0x8225B088;
		  /* 8225B088h */ case    4:  		/* mr R5, R28 */
		/* 8225B088h case    4:*/		regs.R5 = regs.R28;
		/* 8225B088h case    4:*/		return 0x8225B08C;
		  /* 8225B08Ch */ case    5:  		/* li R4, 1 */
		/* 8225B08Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225B08Ch case    5:*/		return 0x8225B090;
		  /* 8225B090h */ case    6:  		/* mr R3, R30 */
		/* 8225B090h case    6:*/		regs.R3 = regs.R30;
		/* 8225B090h case    6:*/		return 0x8225B094;
		  /* 8225B094h */ case    7:  		/* bl -19708 */
		/* 8225B094h case    7:*/		regs.LR = 0x8225B098; return 0x82256398;
		/* 8225B094h case    7:*/		return 0x8225B098;
		  /* 8225B098h */ case    8:  		/* mr R4, R30 */
		/* 8225B098h case    8:*/		regs.R4 = regs.R30;
		/* 8225B098h case    8:*/		return 0x8225B09C;
		  /* 8225B09Ch */ case    9:  		/* mr R3, R24 */
		/* 8225B09Ch case    9:*/		regs.R3 = regs.R24;
		/* 8225B09Ch case    9:*/		return 0x8225B0A0;
	}
	return 0x8225B0A0;
} // Block from 8225B078h-8225B0A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225B0A0h
// Function '?IL2IR_ImportUsage@XGRAPHICS@@YAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B0A0);
		  /* 8225B0A0h */ case    0:  		/* bl -8560 */
		/* 8225B0A0h case    0:*/		regs.LR = 0x8225B0A4; return 0x82258F30;
		/* 8225B0A0h case    0:*/		return 0x8225B0A4;
		  /* 8225B0A4h */ case    1:  		/* mr R4, R30 */
		/* 8225B0A4h case    1:*/		regs.R4 = regs.R30;
		/* 8225B0A4h case    1:*/		return 0x8225B0A8;
		  /* 8225B0A8h */ case    2:  		/* mr R3, R29 */
		/* 8225B0A8h case    2:*/		regs.R3 = regs.R29;
		/* 8225B0A8h case    2:*/		return 0x8225B0AC;
		  /* 8225B0ACh */ case    3:  		/* bl -27716 */
		/* 8225B0ACh case    3:*/		regs.LR = 0x8225B0B0; return 0x82254468;
		/* 8225B0ACh case    3:*/		return 0x8225B0B0;
		  /* 8225B0B0h */ case    4:  		/* li R11, 1 */
		/* 8225B0B0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225B0B0h case    4:*/		return 0x8225B0B4;
		  /* 8225B0B4h */ case    5:  		/* mr R5, R30 */
		/* 8225B0B4h case    5:*/		regs.R5 = regs.R30;
		/* 8225B0B4h case    5:*/		return 0x8225B0B8;
		  /* 8225B0B8h */ case    6:  		/* stb R11, <#[R29 + 29]> */
		/* 8225B0B8h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x0000001D) );
		/* 8225B0B8h case    6:*/		return 0x8225B0BC;
		  /* 8225B0BCh */ case    7:  		/* li R4, 1 */
		/* 8225B0BCh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225B0BCh case    7:*/		return 0x8225B0C0;
		  /* 8225B0C0h */ case    8:  		/* mr R3, R28 */
		/* 8225B0C0h case    8:*/		regs.R3 = regs.R28;
		/* 8225B0C0h case    8:*/		return 0x8225B0C4;
		  /* 8225B0C4h */ case    9:  		/* bl -27660 */
		/* 8225B0C4h case    9:*/		regs.LR = 0x8225B0C8; return 0x822544B8;
		/* 8225B0C4h case    9:*/		return 0x8225B0C8;
	}
	return 0x8225B0C8;
} // Block from 8225B0A0h-8225B0C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225B0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B0C8);
		  /* 8225B0C8h */ case    0:  		/* li R27, 30 */
		/* 8225B0C8h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1E);
		/* 8225B0C8h case    0:*/		return 0x8225B0CC;
		  /* 8225B0CCh */ case    1:  		/* b 960 */
		/* 8225B0CCh case    1:*/		return 0x8225B48C;
		/* 8225B0CCh case    1:*/		return 0x8225B0D0;
	}
	return 0x8225B0D0;
} // Block from 8225B0C8h-8225B0D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B0D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B0D0);
		  /* 8225B0D0h */ case    0:  		/* cmpwi CR6, R27, 5 */
		/* 8225B0D0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000005);
		/* 8225B0D0h case    0:*/		return 0x8225B0D4;
		  /* 8225B0D4h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 8225B0D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225B10C;  }
		/* 8225B0D4h case    1:*/		return 0x8225B0D8;
		  /* 8225B0D8h */ case    2:  		/* cmpwi CR6, R27, 15 */
		/* 8225B0D8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x0000000F);
		/* 8225B0D8h case    2:*/		return 0x8225B0DC;
		  /* 8225B0DCh */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8225B0DCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8225B10C;  }
		/* 8225B0DCh case    3:*/		return 0x8225B0E0;
		  /* 8225B0E0h */ case    4:  		/* cmpwi CR6, R27, 17 */
		/* 8225B0E0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000011);
		/* 8225B0E0h case    4:*/		return 0x8225B0E4;
		  /* 8225B0E4h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 8225B0E4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8225B10C;  }
		/* 8225B0E4h case    5:*/		return 0x8225B0E8;
		  /* 8225B0E8h */ case    6:  		/* cmpwi CR6, R27, 12 */
		/* 8225B0E8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x0000000C);
		/* 8225B0E8h case    6:*/		return 0x8225B0EC;
		  /* 8225B0ECh */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8225B0ECh case    7:*/		if ( regs.CR[6].eq ) { return 0x8225B10C;  }
		/* 8225B0ECh case    7:*/		return 0x8225B0F0;
		  /* 8225B0F0h */ case    8:  		/* lis R11, -32251 */
		/* 8225B0F0h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B0F0h case    8:*/		return 0x8225B0F4;
		  /* 8225B0F4h */ case    9:  		/* mr R6, R14 */
		/* 8225B0F4h case    9:*/		regs.R6 = regs.R14;
		/* 8225B0F4h case    9:*/		return 0x8225B0F8;
		  /* 8225B0F8h */ case   10:  		/* addi R5, R11, -20936 */
		/* 8225B0F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAE38);
		/* 8225B0F8h case   10:*/		return 0x8225B0FC;
		  /* 8225B0FCh */ case   11:  		/* mr R4, R15 */
		/* 8225B0FCh case   11:*/		regs.R4 = regs.R15;
		/* 8225B0FCh case   11:*/		return 0x8225B100;
		  /* 8225B100h */ case   12:  		/* li R7, 418 */
		/* 8225B100h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x1A2);
		/* 8225B100h case   12:*/		return 0x8225B104;
		  /* 8225B104h */ case   13:  		/* li R3, 0 */
		/* 8225B104h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B104h case   13:*/		return 0x8225B108;
		  /* 8225B108h */ case   14:  		/* bl -1062144 */
		/* 8225B108h case   14:*/		regs.LR = 0x8225B10C; return 0x82157C08;
		/* 8225B108h case   14:*/		return 0x8225B10C;
	}
	return 0x8225B10C;
} // Block from 8225B0D0h-8225B10Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225B10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B10C);
		  /* 8225B10Ch */ case    0:  		/* mr R3, R31 */
		/* 8225B10Ch case    0:*/		regs.R3 = regs.R31;
		/* 8225B10Ch case    0:*/		return 0x8225B110;
		  /* 8225B110h */ case    1:  		/* bl -152664 */
		/* 8225B110h case    1:*/		regs.LR = 0x8225B114; return 0x82235CB8;
		/* 8225B110h case    1:*/		return 0x8225B114;
		  /* 8225B114h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225B114h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225B114h case    2:*/		return 0x8225B118;
		  /* 8225B118h */ case    3:  		/* bc 12, CR0_EQ, 52 */
		/* 8225B118h case    3:*/		if ( regs.CR[0].eq ) { return 0x8225B14C;  }
		/* 8225B118h case    3:*/		return 0x8225B11C;
		  /* 8225B11Ch */ case    4:  		/* cmpwi CR6, R27, 5 */
		/* 8225B11Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000005);
		/* 8225B11Ch case    4:*/		return 0x8225B120;
		  /* 8225B120h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 8225B120h case    5:*/		if ( regs.CR[6].eq ) { return 0x8225B140;  }
		/* 8225B120h case    5:*/		return 0x8225B124;
		  /* 8225B124h */ case    6:  		/* lis R11, -32251 */
		/* 8225B124h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B124h case    6:*/		return 0x8225B128;
		  /* 8225B128h */ case    7:  		/* mr R6, R14 */
		/* 8225B128h case    7:*/		regs.R6 = regs.R14;
		/* 8225B128h case    7:*/		return 0x8225B12C;
		  /* 8225B12Ch */ case    8:  		/* addi R5, R11, -20972 */
		/* 8225B12Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAE14);
		/* 8225B12Ch case    8:*/		return 0x8225B130;
		  /* 8225B130h */ case    9:  		/* mr R4, R15 */
		/* 8225B130h case    9:*/		regs.R4 = regs.R15;
		/* 8225B130h case    9:*/		return 0x8225B134;
		  /* 8225B134h */ case   10:  		/* li R7, 422 */
		/* 8225B134h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x1A6);
		/* 8225B134h case   10:*/		return 0x8225B138;
	}
	return 0x8225B138;
} // Block from 8225B10Ch-8225B138h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225B138h
// Function '?IL2IR_TexFilterMode@XGRAPHICS@@YAHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B138);
		  /* 8225B138h */ case    0:  		/* li R3, 0 */
		/* 8225B138h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B138h case    0:*/		return 0x8225B13C;
		  /* 8225B13Ch */ case    1:  		/* bl -1062196 */
		/* 8225B13Ch case    1:*/		regs.LR = 0x8225B140; return 0x82157C08;
		/* 8225B13Ch case    1:*/		return 0x8225B140;
	}
	return 0x8225B140;
} // Block from 8225B138h-8225B140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B140);
		  /* 8225B140h */ case    0:  		/* li R11, 1 */
		/* 8225B140h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225B140h case    0:*/		return 0x8225B144;
		  /* 8225B144h */ case    1:  		/* stb R11, <#[R31 + 2100]> */
		/* 8225B144h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000834) );
		/* 8225B144h case    1:*/		return 0x8225B148;
		  /* 8225B148h */ case    2:  		/* b 156 */
		/* 8225B148h case    2:*/		return 0x8225B1E4;
		/* 8225B148h case    2:*/		return 0x8225B14C;
	}
	return 0x8225B14C;
} // Block from 8225B140h-8225B14Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225B14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B14C);
		  /* 8225B14Ch */ case    0:  		/* lbz R11, <#[R31 + 2116]> */
		/* 8225B14Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000844) );
		/* 8225B14Ch case    0:*/		return 0x8225B150;
		  /* 8225B150h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8225B150h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225B150h case    1:*/		return 0x8225B154;
		  /* 8225B154h */ case    2:  		/* bc 12, CR0_EQ, 64 */
		/* 8225B154h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225B194;  }
		/* 8225B154h case    2:*/		return 0x8225B158;
		  /* 8225B158h */ case    3:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B158h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B158h case    3:*/		return 0x8225B15C;
		  /* 8225B15Ch */ case    4:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B15Ch case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B15Ch case    4:*/		return 0x8225B160;
		  /* 8225B160h */ case    5:  		/* lwz R9, <#[R31 + 2120]> */
		/* 8225B160h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000848) );
		/* 8225B160h case    5:*/		return 0x8225B164;
		  /* 8225B164h */ case    6:  		/* add R11, R10, R11 */
		/* 8225B164h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B164h case    6:*/		return 0x8225B168;
		  /* 8225B168h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B168h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B168h case    7:*/		return 0x8225B16C;
		  /* 8225B16Ch */ case    8:  		/* cmpw CR6, R9, R11 */
		/* 8225B16Ch case    8:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 8225B16Ch case    8:*/		return 0x8225B170;
		  /* 8225B170h */ case    9:  		/* bc 12, CR6_EQ, 116 */
		/* 8225B170h case    9:*/		if ( regs.CR[6].eq ) { return 0x8225B1E4;  }
		/* 8225B170h case    9:*/		return 0x8225B174;
		  /* 8225B174h */ case   10:  		/* lis R11, -32251 */
		/* 8225B174h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B174h case   10:*/		return 0x8225B178;
		  /* 8225B178h */ case   11:  		/* mr R6, R14 */
		/* 8225B178h case   11:*/		regs.R6 = regs.R14;
		/* 8225B178h case   11:*/		return 0x8225B17C;
		  /* 8225B17Ch */ case   12:  		/* addi R5, R11, -21024 */
		/* 8225B17Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFADE0);
		/* 8225B17Ch case   12:*/		return 0x8225B180;
		  /* 8225B180h */ case   13:  		/* mr R4, R15 */
		/* 8225B180h case   13:*/		regs.R4 = regs.R15;
		/* 8225B180h case   13:*/		return 0x8225B184;
		  /* 8225B184h */ case   14:  		/* li R7, 426 */
		/* 8225B184h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x1AA);
		/* 8225B184h case   14:*/		return 0x8225B188;
		  /* 8225B188h */ case   15:  		/* li R3, 0 */
		/* 8225B188h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B188h case   15:*/		return 0x8225B18C;
		  /* 8225B18Ch */ case   16:  		/* bl -1062276 */
		/* 8225B18Ch case   16:*/		regs.LR = 0x8225B190; return 0x82157C08;
		/* 8225B18Ch case   16:*/		return 0x8225B190;
		  /* 8225B190h */ case   17:  		/* b 84 */
		/* 8225B190h case   17:*/		return 0x8225B1E4;
		/* 8225B190h case   17:*/		return 0x8225B194;
	}
	return 0x8225B194;
} // Block from 8225B14Ch-8225B194h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225B194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B194);
		  /* 8225B194h */ case    0:  		/* cmpwi CR6, R27, 15 */
		/* 8225B194h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x0000000F);
		/* 8225B194h case    0:*/		return 0x8225B198;
		  /* 8225B198h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8225B198h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225B1C8;  }
		/* 8225B198h case    1:*/		return 0x8225B19C;
		  /* 8225B19Ch */ case    2:  		/* cmpwi CR6, R27, 17 */
		/* 8225B19Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000011);
		/* 8225B19Ch case    2:*/		return 0x8225B1A0;
		  /* 8225B1A0h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8225B1A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225B1C8;  }
		/* 8225B1A0h case    3:*/		return 0x8225B1A4;
		  /* 8225B1A4h */ case    4:  		/* cmpwi CR6, R27, 12 */
		/* 8225B1A4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x0000000C);
		/* 8225B1A4h case    4:*/		return 0x8225B1A8;
	}
	return 0x8225B1A8;
} // Block from 8225B194h-8225B1A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225B1A8h
// Function '?FixUp@LabelInfo@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B1A8);
		  /* 8225B1A8h */ case    0:  		/* bc 12, CR6_EQ, 32 */
		/* 8225B1A8h case    0:*/		if ( regs.CR[6].eq ) { return 0x8225B1C8;  }
		/* 8225B1A8h case    0:*/		return 0x8225B1AC;
		  /* 8225B1ACh */ case    1:  		/* lis R11, -32251 */
		/* 8225B1ACh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B1ACh case    1:*/		return 0x8225B1B0;
		  /* 8225B1B0h */ case    2:  		/* mr R6, R14 */
		/* 8225B1B0h case    2:*/		regs.R6 = regs.R14;
		/* 8225B1B0h case    2:*/		return 0x8225B1B4;
		  /* 8225B1B4h */ case    3:  		/* addi R5, R11, -21136 */
		/* 8225B1B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAD70);
		/* 8225B1B4h case    3:*/		return 0x8225B1B8;
		  /* 8225B1B8h */ case    4:  		/* mr R4, R15 */
		/* 8225B1B8h case    4:*/		regs.R4 = regs.R15;
		/* 8225B1B8h case    4:*/		return 0x8225B1BC;
		  /* 8225B1BCh */ case    5:  		/* li R7, 430 */
		/* 8225B1BCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1AE);
		/* 8225B1BCh case    5:*/		return 0x8225B1C0;
		  /* 8225B1C0h */ case    6:  		/* li R3, 0 */
		/* 8225B1C0h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B1C0h case    6:*/		return 0x8225B1C4;
		  /* 8225B1C4h */ case    7:  		/* bl -1062332 */
		/* 8225B1C4h case    7:*/		regs.LR = 0x8225B1C8; return 0x82157C08;
		/* 8225B1C4h case    7:*/		return 0x8225B1C8;
	}
	return 0x8225B1C8;
} // Block from 8225B1A8h-8225B1C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225B1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B1C8);
		  /* 8225B1C8h */ case    0:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B1C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B1C8h case    0:*/		return 0x8225B1CC;
		  /* 8225B1CCh */ case    1:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B1CCh case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B1CCh case    1:*/		return 0x8225B1D0;
		  /* 8225B1D0h */ case    2:  		/* li R9, 1 */
		/* 8225B1D0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225B1D0h case    2:*/		return 0x8225B1D4;
		  /* 8225B1D4h */ case    3:  		/* add R11, R10, R11 */
		/* 8225B1D4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B1D4h case    3:*/		return 0x8225B1D8;
		  /* 8225B1D8h */ case    4:  		/* stb R9, <#[R31 + 2116]> */
		/* 8225B1D8h case    4:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000844) );
		/* 8225B1D8h case    4:*/		return 0x8225B1DC;
		  /* 8225B1DCh */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B1DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B1DCh case    5:*/		return 0x8225B1E0;
		  /* 8225B1E0h */ case    6:  		/* stw R11, <#[R31 + 2120]> */
		/* 8225B1E0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000848) );
		/* 8225B1E0h case    6:*/		return 0x8225B1E4;
	}
	return 0x8225B1E4;
} // Block from 8225B1C8h-8225B1E4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225B1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B1E4);
		  /* 8225B1E4h */ case    0:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B1E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B1E4h case    0:*/		return 0x8225B1E8;
		  /* 8225B1E8h */ case    1:  		/* mr R5, R25 */
		/* 8225B1E8h case    1:*/		regs.R5 = regs.R25;
		/* 8225B1E8h case    1:*/		return 0x8225B1EC;
		  /* 8225B1ECh */ case    2:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225B1ECh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225B1ECh case    2:*/		return 0x8225B1F0;
		  /* 8225B1F0h */ case    3:  		/* lwz R4, <#[R11 + 252]> */
		/* 8225B1F0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000000FC) );
		/* 8225B1F0h case    3:*/		return 0x8225B1F4;
		  /* 8225B1F4h */ case    4:  		/* bl -88548 */
		/* 8225B1F4h case    4:*/		regs.LR = 0x8225B1F8; return 0x82245810;
		/* 8225B1F4h case    4:*/		return 0x8225B1F8;
		  /* 8225B1F8h */ case    5:  		/* lbz R11, <#[R3 + 29]> */
		/* 8225B1F8h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001D) );
		/* 8225B1F8h case    5:*/		return 0x8225B1FC;
		  /* 8225B1FCh */ case    6:  		/* mr R29, R3 */
		/* 8225B1FCh case    6:*/		regs.R29 = regs.R3;
		/* 8225B1FCh case    6:*/		return 0x8225B200;
	}
	return 0x8225B200;
} // Block from 8225B1E4h-8225B200h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225B200h
// Function '?SetSwizzleFromToken@XGRAPHICS@@YAXPATIL_Src@1@PAVIRInst@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B200);
		  /* 8225B200h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8225B200h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225B200h case    0:*/		return 0x8225B204;
		  /* 8225B204h */ case    1:  		/* bc 4, CR0_EQ, 144 */
		/* 8225B204h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8225B294;  }
		/* 8225B204h case    1:*/		return 0x8225B208;
		  /* 8225B208h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225B208h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B208h case    2:*/		return 0x8225B20C;
		  /* 8225B20Ch */ case    3:  		/* li R4, 964 */
		/* 8225B20Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225B20Ch case    3:*/		return 0x8225B210;
		  /* 8225B210h */ case    4:  		/* lwz R30, <#[R11 + 1452]> */
		/* 8225B210h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225B210h case    4:*/		return 0x8225B214;
		  /* 8225B214h */ case    5:  		/* mr R3, R30 */
		/* 8225B214h case    5:*/		regs.R3 = regs.R30;
		/* 8225B214h case    5:*/		return 0x8225B218;
		  /* 8225B218h */ case    6:  		/* bl -257376 */
		/* 8225B218h case    6:*/		regs.LR = 0x8225B21C; return 0x8221C4B8;
		/* 8225B218h case    6:*/		return 0x8225B21C;
		  /* 8225B21Ch */ case    7:  		/* mr R11, R3 */
		/* 8225B21Ch case    7:*/		regs.R11 = regs.R3;
		/* 8225B21Ch case    7:*/		return 0x8225B220;
		  /* 8225B220h */ case    8:  		/* addic. R3, R3, 4 */
		/* 8225B220h case    8:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225B220h case    8:*/		return 0x8225B224;
		  /* 8225B224h */ case    9:  		/* stw R30, <#[R11]> */
		/* 8225B224h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8225B224h case    9:*/		return 0x8225B228;
		  /* 8225B228h */ case   10:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B228h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225B240;  }
		/* 8225B228h case   10:*/		return 0x8225B22C;
		  /* 8225B22Ch */ case   11:  		/* li R4, 126 */
		/* 8225B22Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x7E);
		/* 8225B22Ch case   11:*/		return 0x8225B230;
		  /* 8225B230h */ case   12:  		/* lwz R5, <#[R31 + 12]> */
		/* 8225B230h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B230h case   12:*/		return 0x8225B234;
		  /* 8225B234h */ case   13:  		/* bl -15292 */
		/* 8225B234h case   13:*/		regs.LR = 0x8225B238; return 0x82257678;
		/* 8225B234h case   13:*/		return 0x8225B238;
		  /* 8225B238h */ case   14:  		/* mr R30, R3 */
		/* 8225B238h case   14:*/		regs.R30 = regs.R3;
		/* 8225B238h case   14:*/		return 0x8225B23C;
		  /* 8225B23Ch */ case   15:  		/* b 8 */
		/* 8225B23Ch case   15:*/		return 0x8225B244;
		/* 8225B23Ch case   15:*/		return 0x8225B240;
	}
	return 0x8225B240;
} // Block from 8225B200h-8225B240h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225B240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B240);
		  /* 8225B240h */ case    0:  		/* mr R30, R20 */
		/* 8225B240h case    0:*/		regs.R30 = regs.R20;
		/* 8225B240h case    0:*/		return 0x8225B244;
	}
	return 0x8225B244;
} // Block from 8225B240h-8225B244h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B244);
		  /* 8225B244h */ case    0:  		/* mr R5, R29 */
		/* 8225B244h case    0:*/		regs.R5 = regs.R29;
		/* 8225B244h case    0:*/		return 0x8225B248;
		  /* 8225B248h */ case    1:  		/* li R4, 0 */
		/* 8225B248h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225B248h case    1:*/		return 0x8225B24C;
		  /* 8225B24Ch */ case    2:  		/* mr R3, R30 */
		/* 8225B24Ch case    2:*/		regs.R3 = regs.R30;
		/* 8225B24Ch case    2:*/		return 0x8225B250;
		  /* 8225B250h */ case    3:  		/* bl -20152 */
		/* 8225B250h case    3:*/		regs.LR = 0x8225B254; return 0x82256398;
		/* 8225B250h case    3:*/		return 0x8225B254;
		  /* 8225B254h */ case    4:  		/* mr R5, R28 */
		/* 8225B254h case    4:*/		regs.R5 = regs.R28;
		/* 8225B254h case    4:*/		return 0x8225B258;
		  /* 8225B258h */ case    5:  		/* li R4, 1 */
		/* 8225B258h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225B258h case    5:*/		return 0x8225B25C;
		  /* 8225B25Ch */ case    6:  		/* mr R3, R30 */
		/* 8225B25Ch case    6:*/		regs.R3 = regs.R30;
		/* 8225B25Ch case    6:*/		return 0x8225B260;
		  /* 8225B260h */ case    7:  		/* bl -20168 */
		/* 8225B260h case    7:*/		regs.LR = 0x8225B264; return 0x82256398;
		/* 8225B260h case    7:*/		return 0x8225B264;
		  /* 8225B264h */ case    8:  		/* mr R4, R30 */
		/* 8225B264h case    8:*/		regs.R4 = regs.R30;
		/* 8225B264h case    8:*/		return 0x8225B268;
		  /* 8225B268h */ case    9:  		/* mr R3, R24 */
		/* 8225B268h case    9:*/		regs.R3 = regs.R24;
		/* 8225B268h case    9:*/		return 0x8225B26C;
		  /* 8225B26Ch */ case   10:  		/* bl -9020 */
		/* 8225B26Ch case   10:*/		regs.LR = 0x8225B270; return 0x82258F30;
		/* 8225B26Ch case   10:*/		return 0x8225B270;
		  /* 8225B270h */ case   11:  		/* mr R4, R30 */
		/* 8225B270h case   11:*/		regs.R4 = regs.R30;
		/* 8225B270h case   11:*/		return 0x8225B274;
		  /* 8225B274h */ case   12:  		/* mr R3, R29 */
		/* 8225B274h case   12:*/		regs.R3 = regs.R29;
		/* 8225B274h case   12:*/		return 0x8225B278;
	}
	return 0x8225B278;
} // Block from 8225B244h-8225B278h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225B278h
// Function '?SetSrcModifiers@CFG@XGRAPHICS@@AAAXAATSwizzleOrMaskInfo@2@PATIL_Src@2@HPAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B278);
		  /* 8225B278h */ case    0:  		/* bl -28176 */
		/* 8225B278h case    0:*/		regs.LR = 0x8225B27C; return 0x82254468;
		/* 8225B278h case    0:*/		return 0x8225B27C;
		  /* 8225B27Ch */ case    1:  		/* li R11, 1 */
		/* 8225B27Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225B27Ch case    1:*/		return 0x8225B280;
		  /* 8225B280h */ case    2:  		/* mr R5, R30 */
		/* 8225B280h case    2:*/		regs.R5 = regs.R30;
		/* 8225B280h case    2:*/		return 0x8225B284;
		  /* 8225B284h */ case    3:  		/* stb R11, <#[R29 + 29]> */
		/* 8225B284h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x0000001D) );
		/* 8225B284h case    3:*/		return 0x8225B288;
		  /* 8225B288h */ case    4:  		/* li R4, 1 */
		/* 8225B288h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225B288h case    4:*/		return 0x8225B28C;
		  /* 8225B28Ch */ case    5:  		/* mr R3, R28 */
		/* 8225B28Ch case    5:*/		regs.R3 = regs.R28;
		/* 8225B28Ch case    5:*/		return 0x8225B290;
		  /* 8225B290h */ case    6:  		/* bl -28120 */
		/* 8225B290h case    6:*/		regs.LR = 0x8225B294; return 0x822544B8;
		/* 8225B290h case    6:*/		return 0x8225B294;
	}
	return 0x8225B294;
} // Block from 8225B278h-8225B294h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225B294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B294);
		  /* 8225B294h */ case    0:  		/* mr R18, R26 */
		/* 8225B294h case    0:*/		regs.R18 = regs.R26;
		/* 8225B294h case    0:*/		return 0x8225B298;
		  /* 8225B298h */ case    1:  		/* li R27, 31 */
		/* 8225B298h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x1F);
		/* 8225B298h case    1:*/		return 0x8225B29C;
		  /* 8225B29Ch */ case    2:  		/* b 500 */
		/* 8225B29Ch case    2:*/		return 0x8225B490;
		/* 8225B29Ch case    2:*/		return 0x8225B2A0;
	}
	return 0x8225B2A0;
} // Block from 8225B294h-8225B2A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225B2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B2A0);
		  /* 8225B2A0h */ case    0:  		/* cmpwi CR6, R27, 1 */
		/* 8225B2A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000001);
		/* 8225B2A0h case    0:*/		return 0x8225B2A4;
		  /* 8225B2A4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8225B2A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225B2C4;  }
		/* 8225B2A4h case    1:*/		return 0x8225B2A8;
		  /* 8225B2A8h */ case    2:  		/* lis R11, -32251 */
		/* 8225B2A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B2A8h case    2:*/		return 0x8225B2AC;
		  /* 8225B2ACh */ case    3:  		/* mr R6, R14 */
		/* 8225B2ACh case    3:*/		regs.R6 = regs.R14;
		/* 8225B2ACh case    3:*/		return 0x8225B2B0;
		  /* 8225B2B0h */ case    4:  		/* addi R5, R11, -21176 */
		/* 8225B2B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAD48);
		/* 8225B2B0h case    4:*/		return 0x8225B2B4;
		  /* 8225B2B4h */ case    5:  		/* mr R4, R15 */
		/* 8225B2B4h case    5:*/		regs.R4 = regs.R15;
		/* 8225B2B4h case    5:*/		return 0x8225B2B8;
		  /* 8225B2B8h */ case    6:  		/* li R7, 454 */
		/* 8225B2B8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1C6);
		/* 8225B2B8h case    6:*/		return 0x8225B2BC;
		  /* 8225B2BCh */ case    7:  		/* li R3, 0 */
		/* 8225B2BCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B2BCh case    7:*/		return 0x8225B2C0;
		  /* 8225B2C0h */ case    8:  		/* bl -1062584 */
		/* 8225B2C0h case    8:*/		regs.LR = 0x8225B2C4; return 0x82157C08;
		/* 8225B2C0h case    8:*/		return 0x8225B2C4;
	}
	return 0x8225B2C4;
} // Block from 8225B2A0h-8225B2C4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225B2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B2C4);
		  /* 8225B2C4h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 8225B2C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8225B2C4h case    0:*/		return 0x8225B2C8;
		  /* 8225B2C8h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 8225B2C8h case    1:*/		if ( regs.CR[6].lt ) { return 0x8225B2D4;  }
		/* 8225B2C8h case    1:*/		return 0x8225B2CC;
		  /* 8225B2CCh */ case    2:  		/* cmpwi CR6, R24, 6 */
		/* 8225B2CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000006);
		/* 8225B2CCh case    2:*/		return 0x8225B2D0;
		  /* 8225B2D0h */ case    3:  		/* bc 12, CR6_LT, 32 */
		/* 8225B2D0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225B2F0;  }
		/* 8225B2D0h case    3:*/		return 0x8225B2D4;
	}
	return 0x8225B2D4;
} // Block from 8225B2C4h-8225B2D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225B2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B2D4);
		  /* 8225B2D4h */ case    0:  		/* lis R11, -32251 */
		/* 8225B2D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B2D4h case    0:*/		return 0x8225B2D8;
		  /* 8225B2D8h */ case    1:  		/* mr R6, R14 */
		/* 8225B2D8h case    1:*/		regs.R6 = regs.R14;
		/* 8225B2D8h case    1:*/		return 0x8225B2DC;
		  /* 8225B2DCh */ case    2:  		/* addi R5, R11, -21236 */
		/* 8225B2DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAD0C);
		/* 8225B2DCh case    2:*/		return 0x8225B2E0;
		  /* 8225B2E0h */ case    3:  		/* mr R4, R15 */
		/* 8225B2E0h case    3:*/		regs.R4 = regs.R15;
		/* 8225B2E0h case    3:*/		return 0x8225B2E4;
		  /* 8225B2E4h */ case    4:  		/* li R7, 455 */
		/* 8225B2E4h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1C7);
		/* 8225B2E4h case    4:*/		return 0x8225B2E8;
		  /* 8225B2E8h */ case    5:  		/* li R3, 0 */
		/* 8225B2E8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B2E8h case    5:*/		return 0x8225B2EC;
		  /* 8225B2ECh */ case    6:  		/* bl -1062628 */
		/* 8225B2ECh case    6:*/		regs.LR = 0x8225B2F0; return 0x82157C08;
		/* 8225B2ECh case    6:*/		return 0x8225B2F0;
	}
	return 0x8225B2F0;
} // Block from 8225B2D4h-8225B2F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225B2F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B2F0);
		  /* 8225B2F0h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 8225B2F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8225B2F0h case    0:*/		return 0x8225B2F4;
		  /* 8225B2F4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8225B2F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225B314;  }
		/* 8225B2F4h case    1:*/		return 0x8225B2F8;
		  /* 8225B2F8h */ case    2:  		/* lis R11, -32251 */
		/* 8225B2F8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225B2F8h case    2:*/		return 0x8225B2FC;
		  /* 8225B2FCh */ case    3:  		/* mr R6, R14 */
		/* 8225B2FCh case    3:*/		regs.R6 = regs.R14;
		/* 8225B2FCh case    3:*/		return 0x8225B300;
		  /* 8225B300h */ case    4:  		/* addi R5, R11, -20788 */
		/* 8225B300h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAECC);
		/* 8225B300h case    4:*/		return 0x8225B304;
		  /* 8225B304h */ case    5:  		/* mr R4, R15 */
		/* 8225B304h case    5:*/		regs.R4 = regs.R15;
		/* 8225B304h case    5:*/		return 0x8225B308;
		  /* 8225B308h */ case    6:  		/* li R7, 462 */
		/* 8225B308h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1CE);
		/* 8225B308h case    6:*/		return 0x8225B30C;
		  /* 8225B30Ch */ case    7:  		/* li R3, 0 */
		/* 8225B30Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225B30Ch case    7:*/		return 0x8225B310;
		  /* 8225B310h */ case    8:  		/* bl -1062664 */
		/* 8225B310h case    8:*/		regs.LR = 0x8225B314; return 0x82157C08;
		/* 8225B310h case    8:*/		return 0x8225B314;
	}
	return 0x8225B314;
} // Block from 8225B2F0h-8225B314h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225B314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B314);
		  /* 8225B314h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225B314h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B314h case    0:*/		return 0x8225B318;
		  /* 8225B318h */ case    1:  		/* li R4, 964 */
		/* 8225B318h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225B318h case    1:*/		return 0x8225B31C;
		  /* 8225B31Ch */ case    2:  		/* lwz R30, <#[R11 + 1452]> */
		/* 8225B31Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225B31Ch case    2:*/		return 0x8225B320;
		  /* 8225B320h */ case    3:  		/* mr R3, R30 */
		/* 8225B320h case    3:*/		regs.R3 = regs.R30;
		/* 8225B320h case    3:*/		return 0x8225B324;
		  /* 8225B324h */ case    4:  		/* bl -257644 */
		/* 8225B324h case    4:*/		regs.LR = 0x8225B328; return 0x8221C4B8;
		/* 8225B324h case    4:*/		return 0x8225B328;
		  /* 8225B328h */ case    5:  		/* mr R11, R3 */
		/* 8225B328h case    5:*/		regs.R11 = regs.R3;
		/* 8225B328h case    5:*/		return 0x8225B32C;
		  /* 8225B32Ch */ case    6:  		/* addic. R3, R3, 4 */
		/* 8225B32Ch case    6:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225B32Ch case    6:*/		return 0x8225B330;
		  /* 8225B330h */ case    7:  		/* stw R30, <#[R11]> */
		/* 8225B330h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8225B330h case    7:*/		return 0x8225B334;
		  /* 8225B334h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B334h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225B34C;  }
		/* 8225B334h case    8:*/		return 0x8225B338;
		  /* 8225B338h */ case    9:  		/* li R4, 99 */
		/* 8225B338h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x63);
		/* 8225B338h case    9:*/		return 0x8225B33C;
		  /* 8225B33Ch */ case   10:  		/* lwz R5, <#[R31 + 12]> */
		/* 8225B33Ch case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B33Ch case   10:*/		return 0x8225B340;
		  /* 8225B340h */ case   11:  		/* bl -16944 */
		/* 8225B340h case   11:*/		regs.LR = 0x8225B344; return 0x82257110;
		/* 8225B340h case   11:*/		return 0x8225B344;
		  /* 8225B344h */ case   12:  		/* mr R28, R3 */
		/* 8225B344h case   12:*/		regs.R28 = regs.R3;
		/* 8225B344h case   12:*/		return 0x8225B348;
		  /* 8225B348h */ case   13:  		/* b 8 */
		/* 8225B348h case   13:*/		return 0x8225B350;
		/* 8225B348h case   13:*/		return 0x8225B34C;
	}
	return 0x8225B34C;
} // Block from 8225B314h-8225B34Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225B34Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B34C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B34C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B34C);
		  /* 8225B34Ch */ case    0:  		/* mr R28, R20 */
		/* 8225B34Ch case    0:*/		regs.R28 = regs.R20;
		/* 8225B34Ch case    0:*/		return 0x8225B350;
	}
	return 0x8225B350;
} // Block from 8225B34Ch-8225B350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B350);
		  /* 8225B350h */ case    0:  		/* li R26, 31 */
		/* 8225B350h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x1F);
		/* 8225B350h case    0:*/		return 0x8225B354;
		  /* 8225B354h */ case    1:  		/* stw R25, <#[R28 + 60]> */
		/* 8225B354h case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R28 + 0x0000003C) );
		/* 8225B354h case    1:*/		return 0x8225B358;
		  /* 8225B358h */ case    2:  		/* li R29, 34 */
		/* 8225B358h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x22);
		/* 8225B358h case    2:*/		return 0x8225B35C;
		  /* 8225B35Ch */ case    3:  		/* li R27, 1 */
		/* 8225B35Ch case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8225B35Ch case    3:*/		return 0x8225B360;
		  /* 8225B360h */ case    4:  		/* stw R26, <#[R28 + 80]> */
		/* 8225B360h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + 0x00000050) );
		/* 8225B360h case    4:*/		return 0x8225B364;
		  /* 8225B364h */ case    5:  		/* stw R29, <#[R28 + 84]> */
		/* 8225B364h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000054) );
		/* 8225B364h case    5:*/		return 0x8225B368;
		  /* 8225B368h */ case    6:  		/* mr R4, R24 */
		/* 8225B368h case    6:*/		regs.R4 = regs.R24;
		/* 8225B368h case    6:*/		return 0x8225B36C;
		  /* 8225B36Ch */ case    7:  		/* stw R27, <#[R28 + 56]> */
		/* 8225B36Ch case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + 0x00000038) );
		/* 8225B36Ch case    7:*/		return 0x8225B370;
		  /* 8225B370h */ case    8:  		/* mr R3, R28 */
		/* 8225B370h case    8:*/		regs.R3 = regs.R28;
		/* 8225B370h case    8:*/		return 0x8225B374;
		  /* 8225B374h */ case    9:  		/* bl -18580 */
		/* 8225B374h case    9:*/		regs.LR = 0x8225B378; return 0x82256AE0;
		/* 8225B374h case    9:*/		return 0x8225B378;
		  /* 8225B378h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225B378h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B378h case   10:*/		return 0x8225B37C;
		  /* 8225B37Ch */ case   11:  		/* li R4, 964 */
		/* 8225B37Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225B37Ch case   11:*/		return 0x8225B380;
		  /* 8225B380h */ case   12:  		/* lwz R30, <#[R11 + 1452]> */
		/* 8225B380h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225B380h case   12:*/		return 0x8225B384;
		  /* 8225B384h */ case   13:  		/* mr R3, R30 */
		/* 8225B384h case   13:*/		regs.R3 = regs.R30;
		/* 8225B384h case   13:*/		return 0x8225B388;
		  /* 8225B388h */ case   14:  		/* bl -257744 */
		/* 8225B388h case   14:*/		regs.LR = 0x8225B38C; return 0x8221C4B8;
		/* 8225B388h case   14:*/		return 0x8225B38C;
		  /* 8225B38Ch */ case   15:  		/* mr R11, R3 */
		/* 8225B38Ch case   15:*/		regs.R11 = regs.R3;
		/* 8225B38Ch case   15:*/		return 0x8225B390;
		  /* 8225B390h */ case   16:  		/* addic. R3, R3, 4 */
		/* 8225B390h case   16:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225B390h case   16:*/		return 0x8225B394;
		  /* 8225B394h */ case   17:  		/* stw R30, <#[R11]> */
		/* 8225B394h case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8225B394h case   17:*/		return 0x8225B398;
		  /* 8225B398h */ case   18:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B398h case   18:*/		if ( regs.CR[0].eq ) { return 0x8225B3B0;  }
		/* 8225B398h case   18:*/		return 0x8225B39C;
		  /* 8225B39Ch */ case   19:  		/* li R4, 128 */
		/* 8225B39Ch case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 8225B39Ch case   19:*/		return 0x8225B3A0;
		  /* 8225B3A0h */ case   20:  		/* lwz R5, <#[R31 + 12]> */
		/* 8225B3A0h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B3A0h case   20:*/		return 0x8225B3A4;
		  /* 8225B3A4h */ case   21:  		/* bl -15964 */
		/* 8225B3A4h case   21:*/		regs.LR = 0x8225B3A8; return 0x82257548;
		/* 8225B3A4h case   21:*/		return 0x8225B3A8;
		  /* 8225B3A8h */ case   22:  		/* mr R30, R3 */
		/* 8225B3A8h case   22:*/		regs.R30 = regs.R3;
		/* 8225B3A8h case   22:*/		return 0x8225B3AC;
		  /* 8225B3ACh */ case   23:  		/* b 8 */
		/* 8225B3ACh case   23:*/		return 0x8225B3B4;
		/* 8225B3ACh case   23:*/		return 0x8225B3B0;
	}
	return 0x8225B3B0;
} // Block from 8225B350h-8225B3B0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8225B3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B3B0);
		  /* 8225B3B0h */ case    0:  		/* mr R30, R20 */
		/* 8225B3B0h case    0:*/		regs.R30 = regs.R20;
		/* 8225B3B0h case    0:*/		return 0x8225B3B4;
	}
	return 0x8225B3B4;
} // Block from 8225B3B0h-8225B3B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B3B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B3B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B3B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B3B4);
		  /* 8225B3B4h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 8225B3B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8225B3B4h case    0:*/		return 0x8225B3B8;
		  /* 8225B3B8h */ case    1:  		/* li R6, 0 */
		/* 8225B3B8h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225B3B8h case    1:*/		return 0x8225B3BC;
		  /* 8225B3BCh */ case    2:  		/* stw R25, <#[R30 + 56]> */
		/* 8225B3BCh case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x00000038) );
		/* 8225B3BCh case    2:*/		return 0x8225B3C0;
		  /* 8225B3C0h */ case    3:  		/* mr R5, R24 */
		/* 8225B3C0h case    3:*/		regs.R5 = regs.R24;
		/* 8225B3C0h case    3:*/		return 0x8225B3C4;
		  /* 8225B3C4h */ case    4:  		/* stw R29, <#[R30 + 80]> */
		/* 8225B3C4h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000050) );
		/* 8225B3C4h case    4:*/		return 0x8225B3C8;
		  /* 8225B3C8h */ case    5:  		/* li R4, 0 */
		/* 8225B3C8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225B3C8h case    5:*/		return 0x8225B3CC;
		  /* 8225B3CCh */ case    6:  		/* lwz R10, <#[R30]> */
		/* 8225B3CCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8225B3CCh case    6:*/		return 0x8225B3D0;
		  /* 8225B3D0h */ case    7:  		/* mr R3, R30 */
		/* 8225B3D0h case    7:*/		regs.R3 = regs.R30;
		/* 8225B3D0h case    7:*/		return 0x8225B3D4;
		  /* 8225B3D4h */ case    8:  		/* lwz R11, <#[R11 + 104]> */
		/* 8225B3D4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000068) );
		/* 8225B3D4h case    8:*/		return 0x8225B3D8;
		  /* 8225B3D8h */ case    9:  		/* stw R11, <#[R30 + 128]> */
		/* 8225B3D8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225B3D8h case    9:*/		return 0x8225B3DC;
		  /* 8225B3DCh */ case   10:  		/* lwz R11, <#[R10 + 84]> */
		/* 8225B3DCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 8225B3DCh case   10:*/		return 0x8225B3E0;
		  /* 8225B3E0h */ case   11:  		/* mtspr CTR, R11 */
		/* 8225B3E0h case   11:*/		regs.CTR = regs.R11;
		/* 8225B3E0h case   11:*/		return 0x8225B3E4;
		  /* 8225B3E4h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8225B3E4h case   12:*/		if ( 1 ) { regs.LR = 0x8225B3E8; return (uint32)regs.CTR; }
		/* 8225B3E4h case   12:*/		return 0x8225B3E8;
		  /* 8225B3E8h */ case   13:  		/* stw R27, <#[R30 + 60]> */
		/* 8225B3E8h case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x0000003C) );
		/* 8225B3E8h case   13:*/		return 0x8225B3EC;
		  /* 8225B3ECh */ case   14:  		/* li R4, 964 */
		/* 8225B3ECh case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 8225B3ECh case   14:*/		return 0x8225B3F0;
		  /* 8225B3F0h */ case   15:  		/* stw R26, <#[R30 + 84]> */
		/* 8225B3F0h case   15:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000054) );
		/* 8225B3F0h case   15:*/		return 0x8225B3F4;
		  /* 8225B3F4h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225B3F4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B3F4h case   16:*/		return 0x8225B3F8;
		  /* 8225B3F8h */ case   17:  		/* lwz R29, <#[R11 + 1452]> */
		/* 8225B3F8h case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225B3F8h case   17:*/		return 0x8225B3FC;
		  /* 8225B3FCh */ case   18:  		/* mr R3, R29 */
		/* 8225B3FCh case   18:*/		regs.R3 = regs.R29;
		/* 8225B3FCh case   18:*/		return 0x8225B400;
		  /* 8225B400h */ case   19:  		/* bl -257864 */
		/* 8225B400h case   19:*/		regs.LR = 0x8225B404; return 0x8221C4B8;
		/* 8225B400h case   19:*/		return 0x8225B404;
		  /* 8225B404h */ case   20:  		/* mr R11, R3 */
		/* 8225B404h case   20:*/		regs.R11 = regs.R3;
		/* 8225B404h case   20:*/		return 0x8225B408;
		  /* 8225B408h */ case   21:  		/* addic. R3, R3, 4 */
		/* 8225B408h case   21:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225B408h case   21:*/		return 0x8225B40C;
		  /* 8225B40Ch */ case   22:  		/* stw R29, <#[R11]> */
		/* 8225B40Ch case   22:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 8225B40Ch case   22:*/		return 0x8225B410;
		  /* 8225B410h */ case   23:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B410h case   23:*/		if ( regs.CR[0].eq ) { return 0x8225B428;  }
		/* 8225B410h case   23:*/		return 0x8225B414;
		  /* 8225B414h */ case   24:  		/* li R4, 128 */
		/* 8225B414h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x80);
		/* 8225B414h case   24:*/		return 0x8225B418;
		  /* 8225B418h */ case   25:  		/* lwz R5, <#[R31 + 12]> */
		/* 8225B418h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B418h case   25:*/		return 0x8225B41C;
		  /* 8225B41Ch */ case   26:  		/* bl -16084 */
		/* 8225B41Ch case   26:*/		regs.LR = 0x8225B420; return 0x82257548;
		/* 8225B41Ch case   26:*/		return 0x8225B420;
		  /* 8225B420h */ case   27:  		/* mr R29, R3 */
		/* 8225B420h case   27:*/		regs.R29 = regs.R3;
		/* 8225B420h case   27:*/		return 0x8225B424;
		  /* 8225B424h */ case   28:  		/* b 8 */
		/* 8225B424h case   28:*/		return 0x8225B42C;
		/* 8225B424h case   28:*/		return 0x8225B428;
	}
	return 0x8225B428;
} // Block from 8225B3B4h-8225B428h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8225B428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B428);
		  /* 8225B428h */ case    0:  		/* mr R29, R20 */
		/* 8225B428h case    0:*/		regs.R29 = regs.R20;
		/* 8225B428h case    0:*/		return 0x8225B42C;
	}
	return 0x8225B42C;
} // Block from 8225B428h-8225B42Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B42C);
		  /* 8225B42Ch */ case    0:  		/* lwz R10, <#[R1 + 88]> */
		/* 8225B42Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8225B42Ch case    0:*/		return 0x8225B430;
		  /* 8225B430h */ case    1:  		/* rlwinm R9, R24, 2, 0, 29 */
		/* 8225B430h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R24);
		/* 8225B430h case    1:*/		return 0x8225B434;
		  /* 8225B434h */ case    2:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B434h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B434h case    2:*/		return 0x8225B438;
		  /* 8225B438h */ case    3:  		/* li R8, 1 */
		/* 8225B438h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8225B438h case    3:*/		return 0x8225B43C;
		  /* 8225B43Ch */ case    4:  		/* addi R10, R10, 9416 */
		/* 8225B43Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24C8);
		/* 8225B43Ch case    4:*/		return 0x8225B440;
		  /* 8225B440h */ case    5:  		/* mr R4, R28 */
		/* 8225B440h case    5:*/		regs.R4 = regs.R28;
		/* 8225B440h case    5:*/		return 0x8225B444;
		  /* 8225B444h */ case    6:  		/* mr R3, R17 */
		/* 8225B444h case    6:*/		regs.R3 = regs.R17;
		/* 8225B444h case    6:*/		return 0x8225B448;
		  /* 8225B448h */ case    7:  		/* lwzx R27, <#[R9 + R10]> */
		/* 8225B448h case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8225B448h case    7:*/		return 0x8225B44C;
		  /* 8225B44Ch */ case    8:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B44Ch case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B44Ch case    8:*/		return 0x8225B450;
		  /* 8225B450h */ case    9:  		/* add R11, R10, R11 */
		/* 8225B450h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B450h case    9:*/		return 0x8225B454;
		  /* 8225B454h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B454h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B454h case   10:*/		return 0x8225B458;
		  /* 8225B458h */ case   11:  		/* stw R25, <#[R29 + 56]> */
		/* 8225B458h case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R29 + 0x00000038) );
		/* 8225B458h case   11:*/		return 0x8225B45C;
		  /* 8225B45Ch */ case   12:  		/* stw R8, <#[R29 + 60]> */
		/* 8225B45Ch case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R29 + 0x0000003C) );
		/* 8225B45Ch case   12:*/		return 0x8225B460;
		  /* 8225B460h */ case   13:  		/* stw R26, <#[R29 + 84]> */
		/* 8225B460h case   13:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x00000054) );
		/* 8225B460h case   13:*/		return 0x8225B464;
		  /* 8225B464h */ case   14:  		/* stw R11, <#[R29 + 80]> */
		/* 8225B464h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000050) );
		/* 8225B464h case   14:*/		return 0x8225B468;
		  /* 8225B468h */ case   15:  		/* stw R30, <#[R28 + 172]> */
		/* 8225B468h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x000000AC) );
		/* 8225B468h case   15:*/		return 0x8225B46C;
		  /* 8225B46Ch */ case   16:  		/* stw R29, <#[R28 + 176]> */
		/* 8225B46Ch case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x000000B0) );
		/* 8225B46Ch case   16:*/		return 0x8225B470;
		  /* 8225B470h */ case   17:  		/* bl -31720 */
		/* 8225B470h case   17:*/		regs.LR = 0x8225B474; return 0x82253888;
		/* 8225B470h case   17:*/		return 0x8225B474;
		  /* 8225B474h */ case   18:  		/* mr R4, R30 */
		/* 8225B474h case   18:*/		regs.R4 = regs.R30;
		/* 8225B474h case   18:*/		return 0x8225B478;
		  /* 8225B478h */ case   19:  		/* mr R3, R17 */
		/* 8225B478h case   19:*/		regs.R3 = regs.R17;
		/* 8225B478h case   19:*/		return 0x8225B47C;
		  /* 8225B47Ch */ case   20:  		/* bl -31732 */
		/* 8225B47Ch case   20:*/		regs.LR = 0x8225B480; return 0x82253888;
		/* 8225B47Ch case   20:*/		return 0x8225B480;
		  /* 8225B480h */ case   21:  		/* mr R4, R29 */
		/* 8225B480h case   21:*/		regs.R4 = regs.R29;
		/* 8225B480h case   21:*/		return 0x8225B484;
		  /* 8225B484h */ case   22:  		/* mr R3, R17 */
		/* 8225B484h case   22:*/		regs.R3 = regs.R17;
		/* 8225B484h case   22:*/		return 0x8225B488;
		  /* 8225B488h */ case   23:  		/* bl -31744 */
		/* 8225B488h case   23:*/		regs.LR = 0x8225B48C; return 0x82253888;
		/* 8225B488h case   23:*/		return 0x8225B48C;
	}
	return 0x8225B48C;
} // Block from 8225B42Ch-8225B48Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8225B48Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B48C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B48C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B48C);
		  /* 8225B48Ch */ case    0:  		/* mr R18, R16 */
		/* 8225B48Ch case    0:*/		regs.R18 = regs.R16;
		/* 8225B48Ch case    0:*/		return 0x8225B490;
	}
	return 0x8225B490;
} // Block from 8225B48Ch-8225B490h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B490h
// Function '?PreAssignPhysicalRegisters@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B490);
		  /* 8225B490h */ case    0:  		/* mr R26, R25 */
		/* 8225B490h case    0:*/		regs.R26 = regs.R25;
		/* 8225B490h case    0:*/		return 0x8225B494;
	}
	return 0x8225B494;
} // Block from 8225B490h-8225B494h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B494);
		  /* 8225B494h */ case    0:  		/* rlwinm. R11, R22, 0, 24, 31 */
		/* 8225B494h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R22);
		/* 8225B494h case    0:*/		return 0x8225B498;
		  /* 8225B498h */ case    1:  		/* bc 12, CR0_EQ, 3080 */
		/* 8225B498h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225C0A0;  }
		/* 8225B498h case    1:*/		return 0x8225B49C;
		  /* 8225B49Ch */ case    2:  		/* lwz R11, <#[R19]> */
		/* 8225B49Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B49Ch case    2:*/		return 0x8225B4A0;
		  /* 8225B4A0h */ case    3:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225B4A0h case    3:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225B4A0h case    3:*/		return 0x8225B4A4;
		  /* 8225B4A4h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 8225B4A4h case    4:*/		if ( regs.CR[0].eq ) { return 0x8225B4C4;  }
		/* 8225B4A4h case    4:*/		return 0x8225B4A8;
		  /* 8225B4A8h */ case    5:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225B4A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B4A8h case    5:*/		return 0x8225B4AC;
		  /* 8225B4ACh */ case    6:  		/* andi. R11, R11, 17476 */
		/* 8225B4ACh case    6:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x4444);
		/* 8225B4ACh case    6:*/		return 0x8225B4B0;
		  /* 8225B4B0h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 8225B4B0h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225B4B0h case    7:*/		return 0x8225B4B4;
		  /* 8225B4B4h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8225B4B4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225B4C4;  }
		/* 8225B4B4h case    8:*/		return 0x8225B4B8;
		  /* 8225B4B8h */ case    9:  		/* li R24, 1 */
		/* 8225B4B8h case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8225B4B8h case    9:*/		return 0x8225B4BC;
		  /* 8225B4BCh */ case   10:  		/* mr R11, R24 */
		/* 8225B4BCh case   10:*/		regs.R11 = regs.R24;
		/* 8225B4BCh case   10:*/		return 0x8225B4C0;
		  /* 8225B4C0h */ case   11:  		/* b 12 */
		/* 8225B4C0h case   11:*/		return 0x8225B4CC;
		/* 8225B4C0h case   11:*/		return 0x8225B4C4;
	}
	return 0x8225B4C4;
} // Block from 8225B494h-8225B4C4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225B4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B4C4);
		  /* 8225B4C4h */ case    0:  		/* mr R11, R20 */
		/* 8225B4C4h case    0:*/		regs.R11 = regs.R20;
		/* 8225B4C4h case    0:*/		return 0x8225B4C8;
		  /* 8225B4C8h */ case    1:  		/* li R24, 1 */
		/* 8225B4C8h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8225B4C8h case    1:*/		return 0x8225B4CC;
	}
	return 0x8225B4CC;
} // Block from 8225B4C4h-8225B4CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B4CC);
		  /* 8225B4CCh */ case    0:  		/* lis R10, -32256 */
		/* 8225B4CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8225B4CCh case    0:*/		return 0x8225B4D0;
		  /* 8225B4D0h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225B4D0h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225B4D0h case    1:*/		return 0x8225B4D4;
		  /* 8225B4D4h */ case    2:  		/* lfs FR30, <#[R10 + 1792]> */
		/* 8225B4D4h case    2:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R10 + 0x00000700) );
		/* 8225B4D4h case    2:*/		return 0x8225B4D8;
		  /* 8225B4D8h */ case    3:  		/* bc 12, CR0_EQ, 484 */
		/* 8225B4D8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8225B6BC;  }
		/* 8225B4D8h case    3:*/		return 0x8225B4DC;
		  /* 8225B4DCh */ case    4:  		/* li R4, 0 */
		/* 8225B4DCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225B4DCh case    4:*/		return 0x8225B4E0;
		  /* 8225B4E0h */ case    5:  		/* mr R3, R19 */
		/* 8225B4E0h case    5:*/		regs.R3 = regs.R19;
		/* 8225B4E0h case    5:*/		return 0x8225B4E4;
		  /* 8225B4E4h */ case    6:  		/* bl 47652 */
		/* 8225B4E4h case    6:*/		regs.LR = 0x8225B4E8; return 0x82266F08;
		/* 8225B4E4h case    6:*/		return 0x8225B4E8;
		  /* 8225B4E8h */ case    7:  		/* mr R30, R3 */
		/* 8225B4E8h case    7:*/		regs.R30 = regs.R3;
		/* 8225B4E8h case    7:*/		return 0x8225B4EC;
		  /* 8225B4ECh */ case    8:  		/* li R4, 1 */
		/* 8225B4ECh case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225B4ECh case    8:*/		return 0x8225B4F0;
		  /* 8225B4F0h */ case    9:  		/* mr R3, R19 */
		/* 8225B4F0h case    9:*/		regs.R3 = regs.R19;
		/* 8225B4F0h case    9:*/		return 0x8225B4F4;
		  /* 8225B4F4h */ case   10:  		/* bl 47636 */
		/* 8225B4F4h case   10:*/		regs.LR = 0x8225B4F8; return 0x82266F08;
		/* 8225B4F4h case   10:*/		return 0x8225B4F8;
		  /* 8225B4F8h */ case   11:  		/* mr R29, R3 */
		/* 8225B4F8h case   11:*/		regs.R29 = regs.R3;
		/* 8225B4F8h case   11:*/		return 0x8225B4FC;
		  /* 8225B4FCh */ case   12:  		/* li R4, 2 */
		/* 8225B4FCh case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225B4FCh case   12:*/		return 0x8225B500;
		  /* 8225B500h */ case   13:  		/* mr R3, R19 */
		/* 8225B500h case   13:*/		regs.R3 = regs.R19;
		/* 8225B500h case   13:*/		return 0x8225B504;
		  /* 8225B504h */ case   14:  		/* bl 47620 */
		/* 8225B504h case   14:*/		regs.LR = 0x8225B508; return 0x82266F08;
		/* 8225B504h case   14:*/		return 0x8225B508;
		  /* 8225B508h */ case   15:  		/* mr R28, R3 */
		/* 8225B508h case   15:*/		regs.R28 = regs.R3;
		/* 8225B508h case   15:*/		return 0x8225B50C;
		  /* 8225B50Ch */ case   16:  		/* li R4, 3 */
		/* 8225B50Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225B50Ch case   16:*/		return 0x8225B510;
		  /* 8225B510h */ case   17:  		/* mr R3, R19 */
		/* 8225B510h case   17:*/		regs.R3 = regs.R19;
		/* 8225B510h case   17:*/		return 0x8225B514;
		  /* 8225B514h */ case   18:  		/* bl 47604 */
		/* 8225B514h case   18:*/		regs.LR = 0x8225B518; return 0x82266F08;
		/* 8225B514h case   18:*/		return 0x8225B518;
		  /* 8225B518h */ case   19:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225B518h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B518h case   19:*/		return 0x8225B51C;
		  /* 8225B51Ch */ case   20:  		/* mr R25, R3 */
		/* 8225B51Ch case   20:*/		regs.R25 = regs.R3;
		/* 8225B51Ch case   20:*/		return 0x8225B520;
		  /* 8225B520h */ case   21:  		/* li R3, 49 */
		/* 8225B520h case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225B520h case   21:*/		return 0x8225B524;
		  /* 8225B524h */ case   22:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225B524h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B524h case   22:*/		return 0x8225B528;
		  /* 8225B528h */ case   23:  		/* addi R11, R11, -1 */
		/* 8225B528h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225B528h case   23:*/		return 0x8225B52C;
		  /* 8225B52Ch */ case   24:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225B52Ch case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B52Ch case   24:*/		return 0x8225B530;
		  /* 8225B530h */ case   25:  		/* mr R21, R11 */
		/* 8225B530h case   25:*/		regs.R21 = regs.R11;
		/* 8225B530h case   25:*/		return 0x8225B534;
		  /* 8225B534h */ case   26:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225B534h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B534h case   26:*/		return 0x8225B538;
		  /* 8225B538h */ case   27:  		/* bl -22024 */
		/* 8225B538h case   27:*/		regs.LR = 0x8225B53C; return 0x82255F30;
		/* 8225B538h case   27:*/		return 0x8225B53C;
		  /* 8225B53Ch */ case   28:  		/* mr R4, R3 */
		/* 8225B53Ch case   28:*/		regs.R4 = regs.R3;
		/* 8225B53Ch case   28:*/		return 0x8225B540;
		  /* 8225B540h */ case   29:  		/* cmplwi CR6, R23, 0 */
		/* 8225B540h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8225B540h case   29:*/		return 0x8225B544;
		  /* 8225B544h */ case   30:  		/* bc 12, CR6_EQ, 32 */
		/* 8225B544h case   30:*/		if ( regs.CR[6].eq ) { return 0x8225B564;  }
		/* 8225B544h case   30:*/		return 0x8225B548;
		  /* 8225B548h */ case   31:  		/* stw R18, <#[R3 + 204]> */
		/* 8225B548h case   31:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225B548h case   31:*/		return 0x8225B54C;
		  /* 8225B54Ch */ case   32:  		/* mr R23, R20 */
		/* 8225B54Ch case   32:*/		regs.R23 = regs.R20;
		/* 8225B54Ch case   32:*/		return 0x8225B550;
		  /* 8225B550h */ case   33:  		/* lwz R11, <#[R19]> */
		/* 8225B550h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B550h case   33:*/		return 0x8225B554;
		  /* 8225B554h */ case   34:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225B554h case   34:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225B554h case   34:*/		return 0x8225B558;
		  /* 8225B558h */ case   35:  		/* stb R20, <#[R1 + 351]> */
		/* 8225B558h case   35:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225B558h case   35:*/		return 0x8225B55C;
		  /* 8225B55Ch */ case   36:  		/* stw R11, <#[R19]> */
		/* 8225B55Ch case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B55Ch case   36:*/		return 0x8225B560;
		  /* 8225B560h */ case   37:  		/* b 8 */
		/* 8225B560h case   37:*/		return 0x8225B568;
		/* 8225B560h case   37:*/		return 0x8225B564;
	}
	return 0x8225B564;
} // Block from 8225B4CCh-8225B564h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8225B564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B564);
		  /* 8225B564h */ case    0:  		/* lbz R23, <#[R1 + 351]> */
		/* 8225B564h case    0:*/		cpu::mem::load8z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225B564h case    0:*/		return 0x8225B568;
	}
	return 0x8225B568;
} // Block from 8225B564h-8225B568h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B568);
		  /* 8225B568h */ case    0:  		/* stw R20, <#[R4 + 80]> */
		/* 8225B568h case    0:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R4 + 0x00000050) );
		/* 8225B568h case    0:*/		return 0x8225B56C;
		  /* 8225B56Ch */ case    1:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B56Ch case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B56Ch case    1:*/		return 0x8225B570;
		  /* 8225B570h */ case    2:  		/* lwz R22, <#[R1 + 88]> */
		/* 8225B570h case    2:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8225B570h case    2:*/		return 0x8225B574;
		  /* 8225B574h */ case    3:  		/* lis R9, -32256 */
		/* 8225B574h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8225B574h case    3:*/		return 0x8225B578;
		  /* 8225B578h */ case    4:  		/* stw R21, <#[R4 + 56]> */
		/* 8225B578h case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R4 + 0x00000038) );
		/* 8225B578h case    4:*/		return 0x8225B57C;
		  /* 8225B57Ch */ case    5:  		/* cmpwi CR6, R30, 4 */
		/* 8225B57Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225B57Ch case    5:*/		return 0x8225B580;
		  /* 8225B580h */ case    6:  		/* lwz R11, <#[R22 + 92]> */
		/* 8225B580h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000005C) );
		/* 8225B580h case    6:*/		return 0x8225B584;
		  /* 8225B584h */ case    7:  		/* lfs FR31, <#[R9 + 1816]> */
		/* 8225B584h case    7:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000718) );
		/* 8225B584h case    7:*/		return 0x8225B588;
		  /* 8225B588h */ case    8:  		/* fmr FR27, FR31 */
		/* 8225B588h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR27,regs.FR31);
		/* 8225B588h case    8:*/		return 0x8225B58C;
		  /* 8225B58Ch */ case    9:  		/* stw R11, <#[R1 + 92]> */
		/* 8225B58Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225B58Ch case    9:*/		return 0x8225B590;
		  /* 8225B590h */ case   10:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B590h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B590h case   10:*/		return 0x8225B594;
		  /* 8225B594h */ case   11:  		/* add R11, R10, R11 */
		/* 8225B594h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B594h case   11:*/		return 0x8225B598;
		  /* 8225B598h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B598h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B598h case   12:*/		return 0x8225B59C;
		  /* 8225B59Ch */ case   13:  		/* stw R26, <#[R4 + 60]> */
		/* 8225B59Ch case   13:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R4 + 0x0000003C) );
		/* 8225B59Ch case   13:*/		return 0x8225B5A0;
		  /* 8225B5A0h */ case   14:  		/* stw R11, <#[R4 + 84]> */
		/* 8225B5A0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000054) );
		/* 8225B5A0h case   14:*/		return 0x8225B5A4;
		  /* 8225B5A4h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 8225B5A4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8225B5B4;  }
		/* 8225B5A4h case   15:*/		return 0x8225B5A8;
		  /* 8225B5A8h */ case   16:  		/* cmpwi CR6, R30, 5 */
		/* 8225B5A8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000005);
		/* 8225B5A8h case   16:*/		return 0x8225B5AC;
		  /* 8225B5ACh */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 8225B5ACh case   17:*/		if ( !regs.CR[6].eq ) { return 0x8225B5BC;  }
		/* 8225B5ACh case   17:*/		return 0x8225B5B0;
		  /* 8225B5B0h */ case   18:  		/* fmr FR27, FR30 */
		/* 8225B5B0h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR27,regs.FR30);
		/* 8225B5B0h case   18:*/		return 0x8225B5B4;
	}
	return 0x8225B5B4;
} // Block from 8225B568h-8225B5B4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225B5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B5B4);
		  /* 8225B5B4h */ case    0:  		/* stb R20, <#[R1 + 84]> */
		/* 8225B5B4h case    0:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 8225B5B4h case    0:*/		return 0x8225B5B8;
		  /* 8225B5B8h */ case    1:  		/* b 12 */
		/* 8225B5B8h case    1:*/		return 0x8225B5C4;
		/* 8225B5B8h case    1:*/		return 0x8225B5BC;
	}
	return 0x8225B5BC;
} // Block from 8225B5B4h-8225B5BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B5BC);
		  /* 8225B5BCh */ case    0:  		/* stb R24, <#[R1 + 84]> */
		/* 8225B5BCh case    0:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 8225B5BCh case    0:*/		return 0x8225B5C0;
		  /* 8225B5C0h */ case    1:  		/* stb R30, <#[R1 + 92]> */
		/* 8225B5C0h case    1:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225B5C0h case    1:*/		return 0x8225B5C4;
	}
	return 0x8225B5C4;
} // Block from 8225B5BCh-8225B5C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B5C4);
		  /* 8225B5C4h */ case    0:  		/* fmr FR28, FR31 */
		/* 8225B5C4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR28,regs.FR31);
		/* 8225B5C4h case    0:*/		return 0x8225B5C8;
		  /* 8225B5C8h */ case    1:  		/* cmpwi CR6, R29, 4 */
		/* 8225B5C8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 8225B5C8h case    1:*/		return 0x8225B5CC;
		  /* 8225B5CCh */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8225B5CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8225B5DC;  }
		/* 8225B5CCh case    2:*/		return 0x8225B5D0;
		  /* 8225B5D0h */ case    3:  		/* cmpwi CR6, R29, 5 */
		/* 8225B5D0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000005);
		/* 8225B5D0h case    3:*/		return 0x8225B5D4;
		  /* 8225B5D4h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 8225B5D4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8225B5E4;  }
		/* 8225B5D4h case    4:*/		return 0x8225B5D8;
		  /* 8225B5D8h */ case    5:  		/* fmr FR28, FR30 */
		/* 8225B5D8h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR28,regs.FR30);
		/* 8225B5D8h case    5:*/		return 0x8225B5DC;
	}
	return 0x8225B5DC;
} // Block from 8225B5C4h-8225B5DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225B5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B5DC);
		  /* 8225B5DCh */ case    0:  		/* stb R20, <#[R1 + 85]> */
		/* 8225B5DCh case    0:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x00000055) );
		/* 8225B5DCh case    0:*/		return 0x8225B5E0;
		  /* 8225B5E0h */ case    1:  		/* b 12 */
		/* 8225B5E0h case    1:*/		return 0x8225B5EC;
		/* 8225B5E0h case    1:*/		return 0x8225B5E4;
	}
	return 0x8225B5E4;
} // Block from 8225B5DCh-8225B5E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B5E4);
		  /* 8225B5E4h */ case    0:  		/* stb R24, <#[R1 + 85]> */
		/* 8225B5E4h case    0:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R1 + 0x00000055) );
		/* 8225B5E4h case    0:*/		return 0x8225B5E8;
		  /* 8225B5E8h */ case    1:  		/* stb R29, <#[R1 + 93]> */
		/* 8225B5E8h case    1:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x0000005D) );
		/* 8225B5E8h case    1:*/		return 0x8225B5EC;
	}
	return 0x8225B5EC;
} // Block from 8225B5E4h-8225B5ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B5ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B5EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B5EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B5EC);
		  /* 8225B5ECh */ case    0:  		/* fmr FR29, FR31 */
		/* 8225B5ECh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR31);
		/* 8225B5ECh case    0:*/		return 0x8225B5F0;
		  /* 8225B5F0h */ case    1:  		/* cmpwi CR6, R28, 4 */
		/* 8225B5F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000004);
		/* 8225B5F0h case    1:*/		return 0x8225B5F4;
		  /* 8225B5F4h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8225B5F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225B604;  }
		/* 8225B5F4h case    2:*/		return 0x8225B5F8;
		  /* 8225B5F8h */ case    3:  		/* cmpwi CR6, R28, 5 */
		/* 8225B5F8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000005);
		/* 8225B5F8h case    3:*/		return 0x8225B5FC;
		  /* 8225B5FCh */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 8225B5FCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x8225B60C;  }
		/* 8225B5FCh case    4:*/		return 0x8225B600;
		  /* 8225B600h */ case    5:  		/* fmr FR29, FR30 */
		/* 8225B600h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR30);
		/* 8225B600h case    5:*/		return 0x8225B604;
	}
	return 0x8225B604;
} // Block from 8225B5ECh-8225B604h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225B604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B604);
		  /* 8225B604h */ case    0:  		/* stb R20, <#[R1 + 86]> */
		/* 8225B604h case    0:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x00000056) );
		/* 8225B604h case    0:*/		return 0x8225B608;
		  /* 8225B608h */ case    1:  		/* b 12 */
		/* 8225B608h case    1:*/		return 0x8225B614;
		/* 8225B608h case    1:*/		return 0x8225B60C;
	}
	return 0x8225B60C;
} // Block from 8225B604h-8225B60Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B60C);
		  /* 8225B60Ch */ case    0:  		/* stb R24, <#[R1 + 86]> */
		/* 8225B60Ch case    0:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R1 + 0x00000056) );
		/* 8225B60Ch case    0:*/		return 0x8225B610;
		  /* 8225B610h */ case    1:  		/* stb R28, <#[R1 + 94]> */
		/* 8225B610h case    1:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R1 + 0x0000005E) );
		/* 8225B610h case    1:*/		return 0x8225B614;
	}
	return 0x8225B614;
} // Block from 8225B60Ch-8225B614h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B614);
		  /* 8225B614h */ case    0:  		/* cmpwi CR6, R25, 4 */
		/* 8225B614h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000004);
		/* 8225B614h case    0:*/		return 0x8225B618;
		  /* 8225B618h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8225B618h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225B628;  }
		/* 8225B618h case    1:*/		return 0x8225B61C;
		  /* 8225B61Ch */ case    2:  		/* cmpwi CR6, R25, 5 */
		/* 8225B61Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000005);
		/* 8225B61Ch case    2:*/		return 0x8225B620;
		  /* 8225B620h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8225B620h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225B630;  }
		/* 8225B620h case    3:*/		return 0x8225B624;
		  /* 8225B624h */ case    4:  		/* fmr FR31, FR30 */
		/* 8225B624h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR30);
		/* 8225B624h case    4:*/		return 0x8225B628;
	}
	return 0x8225B628;
} // Block from 8225B614h-8225B628h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225B628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B628);
		  /* 8225B628h */ case    0:  		/* stb R20, <#[R1 + 87]> */
		/* 8225B628h case    0:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x00000057) );
		/* 8225B628h case    0:*/		return 0x8225B62C;
		  /* 8225B62Ch */ case    1:  		/* b 12 */
		/* 8225B62Ch case    1:*/		return 0x8225B638;
		/* 8225B62Ch case    1:*/		return 0x8225B630;
	}
	return 0x8225B630;
} // Block from 8225B628h-8225B630h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B630);
		  /* 8225B630h */ case    0:  		/* stb R24, <#[R1 + 87]> */
		/* 8225B630h case    0:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R1 + 0x00000057) );
		/* 8225B630h case    0:*/		return 0x8225B634;
		  /* 8225B634h */ case    1:  		/* stb R25, <#[R1 + 95]> */
		/* 8225B634h case    1:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x0000005F) );
		/* 8225B634h case    1:*/		return 0x8225B638;
	}
	return 0x8225B638;
} // Block from 8225B630h-8225B638h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B638);
		  /* 8225B638h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 8225B638h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225B638h case    0:*/		return 0x8225B63C;
		  /* 8225B63Ch */ case    1:  		/* mr R3, R17 */
		/* 8225B63Ch case    1:*/		regs.R3 = regs.R17;
		/* 8225B63Ch case    1:*/		return 0x8225B640;
		  /* 8225B640h */ case    2:  		/* stw R11, <#[R4 + 132]> */
		/* 8225B640h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000084) );
		/* 8225B640h case    2:*/		return 0x8225B644;
		  /* 8225B644h */ case    3:  		/* bl -32188 */
		/* 8225B644h case    3:*/		regs.LR = 0x8225B648; return 0x82253888;
		/* 8225B644h case    3:*/		return 0x8225B648;
		  /* 8225B648h */ case    4:  		/* li R3, 49 */
		/* 8225B648h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225B648h case    4:*/		return 0x8225B64C;
		  /* 8225B64Ch */ case    5:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225B64Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B64Ch case    5:*/		return 0x8225B650;
		  /* 8225B650h */ case    6:  		/* bl -22304 */
		/* 8225B650h case    6:*/		regs.LR = 0x8225B654; return 0x82255F30;
		/* 8225B650h case    6:*/		return 0x8225B654;
		  /* 8225B654h */ case    7:  		/* stw R21, <#[R3 + 56]> */
		/* 8225B654h case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225B654h case    7:*/		return 0x8225B658;
		  /* 8225B658h */ case    8:  		/* stw R20, <#[R3 + 80]> */
		/* 8225B658h case    8:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225B658h case    8:*/		return 0x8225B65C;
		  /* 8225B65Ch */ case    9:  		/* li R5, 1 */
		/* 8225B65Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225B65Ch case    9:*/		return 0x8225B660;
		  /* 8225B660h */ case   10:  		/* mr R4, R31 */
		/* 8225B660h case   10:*/		regs.R4 = regs.R31;
		/* 8225B660h case   10:*/		return 0x8225B664;
		  /* 8225B664h */ case   11:  		/* fmr FR4, FR31 */
		/* 8225B664h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8225B664h case   11:*/		return 0x8225B668;
		  /* 8225B668h */ case   12:  		/* mr R30, R3 */
		/* 8225B668h case   12:*/		regs.R30 = regs.R3;
		/* 8225B668h case   12:*/		return 0x8225B66C;
		  /* 8225B66Ch */ case   13:  		/* fmr FR3, FR29 */
		/* 8225B66Ch case   13:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR29);
		/* 8225B66Ch case   13:*/		return 0x8225B670;
		  /* 8225B670h */ case   14:  		/* fmr FR2, FR28 */
		/* 8225B670h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR28);
		/* 8225B670h case   14:*/		return 0x8225B674;
		  /* 8225B674h */ case   15:  		/* fmr FR1, FR27 */
		/* 8225B674h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR27);
		/* 8225B674h case   15:*/		return 0x8225B678;
		  /* 8225B678h */ case   16:  		/* bl -18272 */
		/* 8225B678h case   16:*/		regs.LR = 0x8225B67C; return 0x82256F18;
		/* 8225B678h case   16:*/		return 0x8225B67C;
		  /* 8225B67Ch */ case   17:  		/* lwz R11, <#[R1 + 84]> */
		/* 8225B67Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225B67Ch case   17:*/		return 0x8225B680;
		  /* 8225B680h */ case   18:  		/* mr R3, R17 */
		/* 8225B680h case   18:*/		regs.R3 = regs.R17;
		/* 8225B680h case   18:*/		return 0x8225B684;
		  /* 8225B684h */ case   19:  		/* mr R4, R30 */
		/* 8225B684h case   19:*/		regs.R4 = regs.R30;
		/* 8225B684h case   19:*/		return 0x8225B688;
		  /* 8225B688h */ case   20:  		/* stw R11, <#[R30 + 128]> */
		/* 8225B688h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225B688h case   20:*/		return 0x8225B68C;
		  /* 8225B68Ch */ case   21:  		/* bl -32260 */
		/* 8225B68Ch case   21:*/		regs.LR = 0x8225B690; return 0x82253888;
		/* 8225B68Ch case   21:*/		return 0x8225B690;
		  /* 8225B690h */ case   22:  		/* lwz R11, <#[R19]> */
		/* 8225B690h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B690h case   22:*/		return 0x8225B694;
		  /* 8225B694h */ case   23:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225B694h case   23:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225B694h case   23:*/		return 0x8225B698;
		  /* 8225B698h */ case   24:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B698h case   24:*/		if ( regs.CR[0].eq ) { return 0x8225B6B0;  }
		/* 8225B698h case   24:*/		return 0x8225B69C;
		  /* 8225B69Ch */ case   25:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225B69Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B69Ch case   25:*/		return 0x8225B6A0;
		  /* 8225B6A0h */ case   26:  		/* li R12, -17768 */
		/* 8225B6A0h case   26:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFBA98);
		/* 8225B6A0h case   26:*/		return 0x8225B6A4;
		  /* 8225B6A4h */ case   27:  		/* and R11, R11, R12 */
		/* 8225B6A4h case   27:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8225B6A4h case   27:*/		return 0x8225B6A8;
		  /* 8225B6A8h */ case   28:  		/* ori R11, R11, 12816 */
		/* 8225B6A8h case   28:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3210);
		/* 8225B6A8h case   28:*/		return 0x8225B6AC;
		  /* 8225B6ACh */ case   29:  		/* stw R11, <#[R19 + 4]> */
		/* 8225B6ACh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B6ACh case   29:*/		return 0x8225B6B0;
	}
	return 0x8225B6B0;
} // Block from 8225B638h-8225B6B0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8225B6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B6B0);
		  /* 8225B6B0h */ case    0:  		/* mr R26, R21 */
		/* 8225B6B0h case    0:*/		regs.R26 = regs.R21;
		/* 8225B6B0h case    0:*/		return 0x8225B6B4;
		  /* 8225B6B4h */ case    1:  		/* li R27, 4 */
		/* 8225B6B4h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225B6B4h case    1:*/		return 0x8225B6B8;
		  /* 8225B6B8h */ case    2:  		/* b 12 */
		/* 8225B6B8h case    2:*/		return 0x8225B6C4;
		/* 8225B6B8h case    2:*/		return 0x8225B6BC;
	}
	return 0x8225B6BC;
} // Block from 8225B6B0h-8225B6BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225B6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B6BC);
		  /* 8225B6BCh */ case    0:  		/* lwz R22, <#[R1 + 88]> */
		/* 8225B6BCh case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8225B6BCh case    0:*/		return 0x8225B6C0;
		  /* 8225B6C0h */ case    1:  		/* lbz R23, <#[R1 + 351]> */
		/* 8225B6C0h case    1:*/		cpu::mem::load8z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225B6C0h case    1:*/		return 0x8225B6C4;
	}
	return 0x8225B6C4;
} // Block from 8225B6BCh-8225B6C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B6C4);
		  /* 8225B6C4h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225B6C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B6C4h case    0:*/		return 0x8225B6C8;
		  /* 8225B6C8h */ case    1:  		/* rlwinm. R10, R11, 10, 31, 31 */
		/* 8225B6C8h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R11);
		/* 8225B6C8h case    1:*/		return 0x8225B6CC;
		  /* 8225B6CCh */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 8225B6CCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8225B6E4;  }
		/* 8225B6CCh case    2:*/		return 0x8225B6D0;
		  /* 8225B6D0h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225B6D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B6D0h case    3:*/		return 0x8225B6D4;
		  /* 8225B6D4h */ case    4:  		/* li R12, -30584 */
		/* 8225B6D4h case    4:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFF8888);
		/* 8225B6D4h case    4:*/		return 0x8225B6D8;
		  /* 8225B6D8h */ case    5:  		/* and. R11, R11, R12 */
		/* 8225B6D8h case    5:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8225B6D8h case    5:*/		return 0x8225B6DC;
		  /* 8225B6DCh */ case    6:  		/* mr R11, R24 */
		/* 8225B6DCh case    6:*/		regs.R11 = regs.R24;
		/* 8225B6DCh case    6:*/		return 0x8225B6E0;
		  /* 8225B6E0h */ case    7:  		/* bc 4, CR0_EQ, 8 */
		/* 8225B6E0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8225B6E8;  }
		/* 8225B6E0h case    7:*/		return 0x8225B6E4;
	}
	return 0x8225B6E4;
} // Block from 8225B6C4h-8225B6E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225B6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B6E4);
		  /* 8225B6E4h */ case    0:  		/* mr R11, R20 */
		/* 8225B6E4h case    0:*/		regs.R11 = regs.R20;
		/* 8225B6E4h case    0:*/		return 0x8225B6E8;
	}
	return 0x8225B6E8;
} // Block from 8225B6E4h-8225B6E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B6E8);
		  /* 8225B6E8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225B6E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225B6E8h case    0:*/		return 0x8225B6EC;
		  /* 8225B6ECh */ case    1:  		/* bc 12, CR0_EQ, 2484 */
		/* 8225B6ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x8225C0A0;  }
		/* 8225B6ECh case    1:*/		return 0x8225B6F0;
		  /* 8225B6F0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8225B6F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8225B6F0h case    2:*/		return 0x8225B6F4;
		  /* 8225B6F4h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8225B6F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225B704;  }
		/* 8225B6F4h case    3:*/		return 0x8225B6F8;
		  /* 8225B6F8h */ case    4:  		/* lhz R11, <#[R19 + 4]> */
		/* 8225B6F8h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B6F8h case    4:*/		return 0x8225B6FC;
		  /* 8225B6FCh */ case    5:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8225B6FCh case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8225B6FCh case    5:*/		return 0x8225B700;
		  /* 8225B700h */ case    6:  		/* b 8 */
		/* 8225B700h case    6:*/		return 0x8225B708;
		/* 8225B700h case    6:*/		return 0x8225B704;
	}
	return 0x8225B704;
} // Block from 8225B6E8h-8225B704h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225B704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B704);
		  /* 8225B704h */ case    0:  		/* li R11, -1 */
		/* 8225B704h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8225B704h case    0:*/		return 0x8225B708;
	}
	return 0x8225B708;
} // Block from 8225B704h-8225B708h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B708);
		  /* 8225B708h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225B708h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225B708h case    0:*/		return 0x8225B70C;
		  /* 8225B70Ch */ case    1:  		/* bc 4, CR6_GT, 188 */
		/* 8225B70Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x8225B7C8;  }
		/* 8225B70Ch case    1:*/		return 0x8225B710;
		  /* 8225B710h */ case    2:  		/* cmpwi CR6, R21, 0 */
		/* 8225B710h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8225B710h case    2:*/		return 0x8225B714;
		  /* 8225B714h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8225B714h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225B72C;  }
		/* 8225B714h case    3:*/		return 0x8225B718;
		  /* 8225B718h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225B718h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B718h case    4:*/		return 0x8225B71C;
		  /* 8225B71Ch */ case    5:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225B71Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B71Ch case    5:*/		return 0x8225B720;
		  /* 8225B720h */ case    6:  		/* addi R11, R11, -1 */
		/* 8225B720h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225B720h case    6:*/		return 0x8225B724;
		  /* 8225B724h */ case    7:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225B724h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B724h case    7:*/		return 0x8225B728;
		  /* 8225B728h */ case    8:  		/* mr R21, R11 */
		/* 8225B728h case    8:*/		regs.R21 = regs.R11;
		/* 8225B728h case    8:*/		return 0x8225B72C;
	}
	return 0x8225B72C;
} // Block from 8225B708h-8225B72Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225B72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B72C);
		  /* 8225B72Ch */ case    0:  		/* li R3, 18 */
		/* 8225B72Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 8225B72Ch case    0:*/		return 0x8225B730;
		  /* 8225B730h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225B730h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B730h case    1:*/		return 0x8225B734;
		  /* 8225B734h */ case    2:  		/* bl -22532 */
		/* 8225B734h case    2:*/		regs.LR = 0x8225B738; return 0x82255F30;
		/* 8225B734h case    2:*/		return 0x8225B738;
		  /* 8225B738h */ case    3:  		/* stw R20, <#[R3 + 80]> */
		/* 8225B738h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225B738h case    3:*/		return 0x8225B73C;
		  /* 8225B73Ch */ case    4:  		/* stw R21, <#[R3 + 56]> */
		/* 8225B73Ch case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225B73Ch case    4:*/		return 0x8225B740;
		  /* 8225B740h */ case    5:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B740h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B740h case    5:*/		return 0x8225B744;
		  /* 8225B744h */ case    6:  		/* mr R30, R3 */
		/* 8225B744h case    6:*/		regs.R30 = regs.R3;
		/* 8225B744h case    6:*/		return 0x8225B748;
		  /* 8225B748h */ case    7:  		/* cmpw CR6, R16, R26 */
		/* 8225B748h case    7:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225B748h case    7:*/		return 0x8225B74C;
		  /* 8225B74Ch */ case    8:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B74Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B74Ch case    8:*/		return 0x8225B750;
		  /* 8225B750h */ case    9:  		/* add R11, R10, R11 */
		/* 8225B750h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B750h case    9:*/		return 0x8225B754;
		  /* 8225B754h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B754h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B754h case   10:*/		return 0x8225B758;
		  /* 8225B758h */ case   11:  		/* stw R26, <#[R3 + 60]> */
		/* 8225B758h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225B758h case   11:*/		return 0x8225B75C;
		  /* 8225B75Ch */ case   12:  		/* stb R24, <#[R3 + 153]> */
		/* 8225B75Ch case   12:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R3 + 0x00000099) );
		/* 8225B75Ch case   12:*/		return 0x8225B760;
		  /* 8225B760h */ case   13:  		/* stw R11, <#[R3 + 84]> */
		/* 8225B760h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225B760h case   13:*/		return 0x8225B764;
		  /* 8225B764h */ case   14:  		/* bc 4, CR6_EQ, 48 */
		/* 8225B764h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8225B794;  }
		/* 8225B764h case   14:*/		return 0x8225B768;
		  /* 8225B768h */ case   15:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225B768h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225B768h case   15:*/		return 0x8225B76C;
		  /* 8225B76Ch */ case   16:  		/* bc 12, CR0_EQ, 28 */
		/* 8225B76Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x8225B788;  }
		/* 8225B76Ch case   16:*/		return 0x8225B770;
		  /* 8225B770h */ case   17:  		/* stw R18, <#[R3 + 204]> */
		/* 8225B770h case   17:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225B770h case   17:*/		return 0x8225B774;
		  /* 8225B774h */ case   18:  		/* mr R23, R20 */
		/* 8225B774h case   18:*/		regs.R23 = regs.R20;
		/* 8225B774h case   18:*/		return 0x8225B778;
		  /* 8225B778h */ case   19:  		/* stb R20, <#[R1 + 351]> */
		/* 8225B778h case   19:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225B778h case   19:*/		return 0x8225B77C;
		  /* 8225B77Ch */ case   20:  		/* lwz R11, <#[R19]> */
		/* 8225B77Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B77Ch case   20:*/		return 0x8225B780;
		  /* 8225B780h */ case   21:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225B780h case   21:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225B780h case   21:*/		return 0x8225B784;
		  /* 8225B784h */ case   22:  		/* stw R11, <#[R19]> */
		/* 8225B784h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B784h case   22:*/		return 0x8225B788;
	}
	return 0x8225B788;
} // Block from 8225B72Ch-8225B788h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8225B788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B788);
		  /* 8225B788h */ case    0:  		/* mr R4, R30 */
		/* 8225B788h case    0:*/		regs.R4 = regs.R30;
		/* 8225B788h case    0:*/		return 0x8225B78C;
		  /* 8225B78Ch */ case    1:  		/* mr R3, R19 */
		/* 8225B78Ch case    1:*/		regs.R3 = regs.R19;
		/* 8225B78Ch case    1:*/		return 0x8225B790;
		  /* 8225B790h */ case    2:  		/* bl -4104 */
		/* 8225B790h case    2:*/		regs.LR = 0x8225B794; return 0x8225A788;
		/* 8225B790h case    2:*/		return 0x8225B794;
	}
	return 0x8225B794;
} // Block from 8225B788h-8225B794h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225B794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B794);
		  /* 8225B794h */ case    0:  		/* li R5, 2 */
		/* 8225B794h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225B794h case    0:*/		return 0x8225B798;
		  /* 8225B798h */ case    1:  		/* fmr FR4, FR30 */
		/* 8225B798h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR30);
		/* 8225B798h case    1:*/		return 0x8225B79C;
		  /* 8225B79Ch */ case    2:  		/* mr R4, R31 */
		/* 8225B79Ch case    2:*/		regs.R4 = regs.R31;
		/* 8225B79Ch case    2:*/		return 0x8225B7A0;
		  /* 8225B7A0h */ case    3:  		/* fmr FR3, FR30 */
		/* 8225B7A0h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR30);
		/* 8225B7A0h case    3:*/		return 0x8225B7A4;
		  /* 8225B7A4h */ case    4:  		/* mr R3, R30 */
		/* 8225B7A4h case    4:*/		regs.R3 = regs.R30;
		/* 8225B7A4h case    4:*/		return 0x8225B7A8;
		  /* 8225B7A8h */ case    5:  		/* fmr FR2, FR30 */
		/* 8225B7A8h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 8225B7A8h case    5:*/		return 0x8225B7AC;
		  /* 8225B7ACh */ case    6:  		/* fmr FR1, FR30 */
		/* 8225B7ACh case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8225B7ACh case    6:*/		return 0x8225B7B0;
		  /* 8225B7B0h */ case    7:  		/* bl -18584 */
		/* 8225B7B0h case    7:*/		regs.LR = 0x8225B7B4; return 0x82256F18;
		/* 8225B7B0h case    7:*/		return 0x8225B7B4;
		  /* 8225B7B4h */ case    8:  		/* mr R4, R30 */
		/* 8225B7B4h case    8:*/		regs.R4 = regs.R30;
		/* 8225B7B4h case    8:*/		return 0x8225B7B8;
		  /* 8225B7B8h */ case    9:  		/* mr R3, R17 */
		/* 8225B7B8h case    9:*/		regs.R3 = regs.R17;
		/* 8225B7B8h case    9:*/		return 0x8225B7BC;
		  /* 8225B7BCh */ case   10:  		/* bl -32564 */
		/* 8225B7BCh case   10:*/		regs.LR = 0x8225B7C0; return 0x82253888;
		/* 8225B7BCh case   10:*/		return 0x8225B7C0;
		  /* 8225B7C0h */ case   11:  		/* mr R26, R21 */
		/* 8225B7C0h case   11:*/		regs.R26 = regs.R21;
		/* 8225B7C0h case   11:*/		return 0x8225B7C4;
		  /* 8225B7C4h */ case   12:  		/* li R27, 4 */
		/* 8225B7C4h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225B7C4h case   12:*/		return 0x8225B7C8;
	}
	return 0x8225B7C8;
} // Block from 8225B794h-8225B7C8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225B7C8h
// Function '?FindOrCreate@LabelInfo@XGRAPHICS@@SAAAV12@ABVScopedLabel@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B7C8);
		  /* 8225B7C8h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225B7C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B7C8h case    0:*/		return 0x8225B7CC;
		  /* 8225B7CCh */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225B7CCh case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225B7CCh case    1:*/		return 0x8225B7D0;
		  /* 8225B7D0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225B7D0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225B7E0;  }
		/* 8225B7D0h case    2:*/		return 0x8225B7D4;
		  /* 8225B7D4h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225B7D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B7D4h case    3:*/		return 0x8225B7D8;
		  /* 8225B7D8h */ case    4:  		/* rlwinm R11, R11, 15, 31, 31 */
		/* 8225B7D8h case    4:*/		cpu::op::rlwinm<0,15,31,31>(regs,&regs.R11,regs.R11);
		/* 8225B7D8h case    4:*/		return 0x8225B7DC;
		  /* 8225B7DCh */ case    5:  		/* b 8 */
		/* 8225B7DCh case    5:*/		return 0x8225B7E4;
		/* 8225B7DCh case    5:*/		return 0x8225B7E0;
	}
	return 0x8225B7E0;
} // Block from 8225B7C8h-8225B7E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225B7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B7E0);
		  /* 8225B7E0h */ case    0:  		/* li R11, -1 */
		/* 8225B7E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8225B7E0h case    0:*/		return 0x8225B7E4;
	}
	return 0x8225B7E4;
} // Block from 8225B7E0h-8225B7E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B7E4);
		  /* 8225B7E4h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225B7E4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225B7E4h case    0:*/		return 0x8225B7E8;
		  /* 8225B7E8h */ case    1:  		/* bc 4, CR6_GT, 192 */
		/* 8225B7E8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8225B8A8;  }
		/* 8225B7E8h case    1:*/		return 0x8225B7EC;
		  /* 8225B7ECh */ case    2:  		/* cmpwi CR6, R21, 0 */
		/* 8225B7ECh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8225B7ECh case    2:*/		return 0x8225B7F0;
		  /* 8225B7F0h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8225B7F0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225B808;  }
		/* 8225B7F0h case    3:*/		return 0x8225B7F4;
		  /* 8225B7F4h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225B7F4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B7F4h case    4:*/		return 0x8225B7F8;
		  /* 8225B7F8h */ case    5:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225B7F8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B7F8h case    5:*/		return 0x8225B7FC;
		  /* 8225B7FCh */ case    6:  		/* addi R11, R11, -1 */
		/* 8225B7FCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225B7FCh case    6:*/		return 0x8225B800;
		  /* 8225B800h */ case    7:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225B800h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B800h case    7:*/		return 0x8225B804;
		  /* 8225B804h */ case    8:  		/* mr R21, R11 */
		/* 8225B804h case    8:*/		regs.R21 = regs.R11;
		/* 8225B804h case    8:*/		return 0x8225B808;
	}
	return 0x8225B808;
} // Block from 8225B7E4h-8225B808h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225B808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B808);
		  /* 8225B808h */ case    0:  		/* li R3, 18 */
		/* 8225B808h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 8225B808h case    0:*/		return 0x8225B80C;
		  /* 8225B80Ch */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225B80Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B80Ch case    1:*/		return 0x8225B810;
		  /* 8225B810h */ case    2:  		/* bl -22752 */
		/* 8225B810h case    2:*/		regs.LR = 0x8225B814; return 0x82255F30;
		/* 8225B810h case    2:*/		return 0x8225B814;
		  /* 8225B814h */ case    3:  		/* stw R21, <#[R3 + 56]> */
		/* 8225B814h case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225B814h case    3:*/		return 0x8225B818;
		  /* 8225B818h */ case    4:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B818h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B818h case    4:*/		return 0x8225B81C;
		  /* 8225B81Ch */ case    5:  		/* stw R20, <#[R3 + 80]> */
		/* 8225B81Ch case    5:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225B81Ch case    5:*/		return 0x8225B820;
		  /* 8225B820h */ case    6:  		/* mr R30, R3 */
		/* 8225B820h case    6:*/		regs.R30 = regs.R3;
		/* 8225B820h case    6:*/		return 0x8225B824;
		  /* 8225B824h */ case    7:  		/* cmpw CR6, R16, R26 */
		/* 8225B824h case    7:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225B824h case    7:*/		return 0x8225B828;
		  /* 8225B828h */ case    8:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B828h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B828h case    8:*/		return 0x8225B82C;
		  /* 8225B82Ch */ case    9:  		/* add R11, R10, R11 */
		/* 8225B82Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B82Ch case    9:*/		return 0x8225B830;
		  /* 8225B830h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B830h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B830h case   10:*/		return 0x8225B834;
		  /* 8225B834h */ case   11:  		/* stw R26, <#[R3 + 60]> */
		/* 8225B834h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225B834h case   11:*/		return 0x8225B838;
		  /* 8225B838h */ case   12:  		/* stw R11, <#[R3 + 84]> */
		/* 8225B838h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225B838h case   12:*/		return 0x8225B83C;
		  /* 8225B83Ch */ case   13:  		/* bc 4, CR6_EQ, 48 */
		/* 8225B83Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8225B86C;  }
		/* 8225B83Ch case   13:*/		return 0x8225B840;
		  /* 8225B840h */ case   14:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225B840h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225B840h case   14:*/		return 0x8225B844;
		  /* 8225B844h */ case   15:  		/* bc 12, CR0_EQ, 28 */
		/* 8225B844h case   15:*/		if ( regs.CR[0].eq ) { return 0x8225B860;  }
		/* 8225B844h case   15:*/		return 0x8225B848;
		  /* 8225B848h */ case   16:  		/* stw R18, <#[R3 + 204]> */
		/* 8225B848h case   16:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225B848h case   16:*/		return 0x8225B84C;
		  /* 8225B84Ch */ case   17:  		/* mr R23, R20 */
		/* 8225B84Ch case   17:*/		regs.R23 = regs.R20;
		/* 8225B84Ch case   17:*/		return 0x8225B850;
		  /* 8225B850h */ case   18:  		/* stb R20, <#[R1 + 351]> */
		/* 8225B850h case   18:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225B850h case   18:*/		return 0x8225B854;
		  /* 8225B854h */ case   19:  		/* lwz R11, <#[R19]> */
		/* 8225B854h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B854h case   19:*/		return 0x8225B858;
		  /* 8225B858h */ case   20:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225B858h case   20:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225B858h case   20:*/		return 0x8225B85C;
		  /* 8225B85Ch */ case   21:  		/* stw R11, <#[R19]> */
		/* 8225B85Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B85Ch case   21:*/		return 0x8225B860;
	}
	return 0x8225B860;
} // Block from 8225B808h-8225B860h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8225B860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B860);
		  /* 8225B860h */ case    0:  		/* mr R4, R30 */
		/* 8225B860h case    0:*/		regs.R4 = regs.R30;
		/* 8225B860h case    0:*/		return 0x8225B864;
		  /* 8225B864h */ case    1:  		/* mr R3, R19 */
		/* 8225B864h case    1:*/		regs.R3 = regs.R19;
		/* 8225B864h case    1:*/		return 0x8225B868;
		  /* 8225B868h */ case    2:  		/* bl -4320 */
		/* 8225B868h case    2:*/		regs.LR = 0x8225B86C; return 0x8225A788;
		/* 8225B868h case    2:*/		return 0x8225B86C;
	}
	return 0x8225B86C;
} // Block from 8225B860h-8225B86Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225B86Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B86C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B86C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B86C);
		  /* 8225B86Ch */ case    0:  		/* lis R11, -32256 */
		/* 8225B86Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225B86Ch case    0:*/		return 0x8225B870;
		  /* 8225B870h */ case    1:  		/* li R5, 2 */
		/* 8225B870h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225B870h case    1:*/		return 0x8225B874;
		  /* 8225B874h */ case    2:  		/* mr R4, R31 */
		/* 8225B874h case    2:*/		regs.R4 = regs.R31;
		/* 8225B874h case    2:*/		return 0x8225B878;
		  /* 8225B878h */ case    3:  		/* mr R3, R30 */
		/* 8225B878h case    3:*/		regs.R3 = regs.R30;
		/* 8225B878h case    3:*/		return 0x8225B87C;
		  /* 8225B87Ch */ case    4:  		/* lfs FR4, <#[R11 + 1820]> */
		/* 8225B87Ch case    4:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x0000071C) );
		/* 8225B87Ch case    4:*/		return 0x8225B880;
		  /* 8225B880h */ case    5:  		/* fmr FR3, FR4 */
		/* 8225B880h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225B880h case    5:*/		return 0x8225B884;
		  /* 8225B884h */ case    6:  		/* fmr FR2, FR4 */
		/* 8225B884h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225B884h case    6:*/		return 0x8225B888;
		  /* 8225B888h */ case    7:  		/* fmr FR1, FR4 */
		/* 8225B888h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225B888h case    7:*/		return 0x8225B88C;
		  /* 8225B88Ch */ case    8:  		/* bl -18804 */
		/* 8225B88Ch case    8:*/		regs.LR = 0x8225B890; return 0x82256F18;
		/* 8225B88Ch case    8:*/		return 0x8225B890;
		  /* 8225B890h */ case    9:  		/* stb R24, <#[R30 + 154]> */
		/* 8225B890h case    9:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R30 + 0x0000009A) );
		/* 8225B890h case    9:*/		return 0x8225B894;
		  /* 8225B894h */ case   10:  		/* mr R4, R30 */
		/* 8225B894h case   10:*/		regs.R4 = regs.R30;
		/* 8225B894h case   10:*/		return 0x8225B898;
		  /* 8225B898h */ case   11:  		/* mr R3, R17 */
		/* 8225B898h case   11:*/		regs.R3 = regs.R17;
		/* 8225B898h case   11:*/		return 0x8225B89C;
		  /* 8225B89Ch */ case   12:  		/* bl -32788 */
		/* 8225B89Ch case   12:*/		regs.LR = 0x8225B8A0; return 0x82253888;
		/* 8225B89Ch case   12:*/		return 0x8225B8A0;
		  /* 8225B8A0h */ case   13:  		/* mr R26, R21 */
		/* 8225B8A0h case   13:*/		regs.R26 = regs.R21;
		/* 8225B8A0h case   13:*/		return 0x8225B8A4;
		  /* 8225B8A4h */ case   14:  		/* li R27, 4 */
		/* 8225B8A4h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225B8A4h case   14:*/		return 0x8225B8A8;
	}
	return 0x8225B8A8;
} // Block from 8225B86Ch-8225B8A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225B8A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B8A8);
		  /* 8225B8A8h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225B8A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B8A8h case    0:*/		return 0x8225B8AC;
		  /* 8225B8ACh */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225B8ACh case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225B8ACh case    1:*/		return 0x8225B8B0;
		  /* 8225B8B0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225B8B0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225B8C0;  }
		/* 8225B8B0h case    2:*/		return 0x8225B8B4;
		  /* 8225B8B4h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225B8B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B8B4h case    3:*/		return 0x8225B8B8;
		  /* 8225B8B8h */ case    4:  		/* rlwinm R11, R11, 14, 31, 31 */
		/* 8225B8B8h case    4:*/		cpu::op::rlwinm<0,14,31,31>(regs,&regs.R11,regs.R11);
		/* 8225B8B8h case    4:*/		return 0x8225B8BC;
		  /* 8225B8BCh */ case    5:  		/* b 8 */
		/* 8225B8BCh case    5:*/		return 0x8225B8C4;
		/* 8225B8BCh case    5:*/		return 0x8225B8C0;
	}
	return 0x8225B8C0;
} // Block from 8225B8A8h-8225B8C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225B8C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B8C0);
		  /* 8225B8C0h */ case    0:  		/* li R11, -1 */
		/* 8225B8C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8225B8C0h case    0:*/		return 0x8225B8C4;
	}
	return 0x8225B8C4;
} // Block from 8225B8C0h-8225B8C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B8C4);
		  /* 8225B8C4h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225B8C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225B8C4h case    0:*/		return 0x8225B8C8;
		  /* 8225B8C8h */ case    1:  		/* bc 4, CR6_GT, 188 */
		/* 8225B8C8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8225B984;  }
		/* 8225B8C8h case    1:*/		return 0x8225B8CC;
		  /* 8225B8CCh */ case    2:  		/* cmpwi CR6, R21, 0 */
		/* 8225B8CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8225B8CCh case    2:*/		return 0x8225B8D0;
		  /* 8225B8D0h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8225B8D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225B8E8;  }
		/* 8225B8D0h case    3:*/		return 0x8225B8D4;
		  /* 8225B8D4h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225B8D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B8D4h case    4:*/		return 0x8225B8D8;
		  /* 8225B8D8h */ case    5:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225B8D8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B8D8h case    5:*/		return 0x8225B8DC;
		  /* 8225B8DCh */ case    6:  		/* addi R11, R11, -1 */
		/* 8225B8DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225B8DCh case    6:*/		return 0x8225B8E0;
	}
	return 0x8225B8E0;
} // Block from 8225B8C4h-8225B8E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225B8E0h
// Function '?ExpandSrcModifiers@CFG@XGRAPHICS@@AAAXPAVDList@2@PATIL_OpCode@2@PATIL_Src@2@PAV?$stack@PAVLoopHeader@XGRAPHICS@@@2@_N4@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B8E0);
		  /* 8225B8E0h */ case    0:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225B8E0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B8E0h case    0:*/		return 0x8225B8E4;
		  /* 8225B8E4h */ case    1:  		/* mr R21, R11 */
		/* 8225B8E4h case    1:*/		regs.R21 = regs.R11;
		/* 8225B8E4h case    1:*/		return 0x8225B8E8;
	}
	return 0x8225B8E8;
} // Block from 8225B8E0h-8225B8E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225B8E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B8E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B8E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B8E8);
		  /* 8225B8E8h */ case    0:  		/* li R3, 19 */
		/* 8225B8E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 8225B8E8h case    0:*/		return 0x8225B8EC;
		  /* 8225B8ECh */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225B8ECh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B8ECh case    1:*/		return 0x8225B8F0;
		  /* 8225B8F0h */ case    2:  		/* bl -22976 */
		/* 8225B8F0h case    2:*/		regs.LR = 0x8225B8F4; return 0x82255F30;
		/* 8225B8F0h case    2:*/		return 0x8225B8F4;
		  /* 8225B8F4h */ case    3:  		/* stw R21, <#[R3 + 56]> */
		/* 8225B8F4h case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225B8F4h case    3:*/		return 0x8225B8F8;
		  /* 8225B8F8h */ case    4:  		/* stw R20, <#[R3 + 80]> */
		/* 8225B8F8h case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225B8F8h case    4:*/		return 0x8225B8FC;
		  /* 8225B8FCh */ case    5:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 8225B8FCh case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 8225B8FCh case    5:*/		return 0x8225B900;
		  /* 8225B900h */ case    6:  		/* mr R30, R3 */
		/* 8225B900h case    6:*/		regs.R30 = regs.R3;
		/* 8225B900h case    6:*/		return 0x8225B904;
		  /* 8225B904h */ case    7:  		/* cmpw CR6, R16, R26 */
		/* 8225B904h case    7:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225B904h case    7:*/		return 0x8225B908;
		  /* 8225B908h */ case    8:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B908h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B908h case    8:*/		return 0x8225B90C;
		  /* 8225B90Ch */ case    9:  		/* add R11, R10, R11 */
		/* 8225B90Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225B90Ch case    9:*/		return 0x8225B910;
		  /* 8225B910h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B910h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B910h case   10:*/		return 0x8225B914;
		  /* 8225B914h */ case   11:  		/* stw R26, <#[R3 + 60]> */
		/* 8225B914h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225B914h case   11:*/		return 0x8225B918;
		  /* 8225B918h */ case   12:  		/* stw R11, <#[R3 + 84]> */
		/* 8225B918h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225B918h case   12:*/		return 0x8225B91C;
		  /* 8225B91Ch */ case   13:  		/* bc 4, CR6_EQ, 48 */
		/* 8225B91Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8225B94C;  }
		/* 8225B91Ch case   13:*/		return 0x8225B920;
		  /* 8225B920h */ case   14:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225B920h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225B920h case   14:*/		return 0x8225B924;
		  /* 8225B924h */ case   15:  		/* bc 12, CR0_EQ, 28 */
		/* 8225B924h case   15:*/		if ( regs.CR[0].eq ) { return 0x8225B940;  }
		/* 8225B924h case   15:*/		return 0x8225B928;
		  /* 8225B928h */ case   16:  		/* stw R18, <#[R3 + 204]> */
		/* 8225B928h case   16:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225B928h case   16:*/		return 0x8225B92C;
		  /* 8225B92Ch */ case   17:  		/* mr R23, R20 */
		/* 8225B92Ch case   17:*/		regs.R23 = regs.R20;
		/* 8225B92Ch case   17:*/		return 0x8225B930;
		  /* 8225B930h */ case   18:  		/* stb R20, <#[R1 + 351]> */
		/* 8225B930h case   18:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225B930h case   18:*/		return 0x8225B934;
		  /* 8225B934h */ case   19:  		/* lwz R11, <#[R19]> */
		/* 8225B934h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B934h case   19:*/		return 0x8225B938;
		  /* 8225B938h */ case   20:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225B938h case   20:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225B938h case   20:*/		return 0x8225B93C;
		  /* 8225B93Ch */ case   21:  		/* stw R11, <#[R19]> */
		/* 8225B93Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B93Ch case   21:*/		return 0x8225B940;
	}
	return 0x8225B940;
} // Block from 8225B8E8h-8225B940h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8225B940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B940);
		  /* 8225B940h */ case    0:  		/* mr R4, R30 */
		/* 8225B940h case    0:*/		regs.R4 = regs.R30;
		/* 8225B940h case    0:*/		return 0x8225B944;
		  /* 8225B944h */ case    1:  		/* mr R3, R19 */
		/* 8225B944h case    1:*/		regs.R3 = regs.R19;
		/* 8225B944h case    1:*/		return 0x8225B948;
		  /* 8225B948h */ case    2:  		/* bl -4544 */
		/* 8225B948h case    2:*/		regs.LR = 0x8225B94C; return 0x8225A788;
		/* 8225B948h case    2:*/		return 0x8225B94C;
	}
	return 0x8225B94C;
} // Block from 8225B940h-8225B94Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225B94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B94C);
		  /* 8225B94Ch */ case    0:  		/* lis R11, -32256 */
		/* 8225B94Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225B94Ch case    0:*/		return 0x8225B950;
		  /* 8225B950h */ case    1:  		/* li R5, 2 */
		/* 8225B950h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225B950h case    1:*/		return 0x8225B954;
		  /* 8225B954h */ case    2:  		/* mr R4, R31 */
		/* 8225B954h case    2:*/		regs.R4 = regs.R31;
		/* 8225B954h case    2:*/		return 0x8225B958;
		  /* 8225B958h */ case    3:  		/* mr R3, R30 */
		/* 8225B958h case    3:*/		regs.R3 = regs.R30;
		/* 8225B958h case    3:*/		return 0x8225B95C;
		  /* 8225B95Ch */ case    4:  		/* lfs FR4, <#[R11 + 2752]> */
		/* 8225B95Ch case    4:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000AC0) );
		/* 8225B95Ch case    4:*/		return 0x8225B960;
		  /* 8225B960h */ case    5:  		/* fmr FR3, FR4 */
		/* 8225B960h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225B960h case    5:*/		return 0x8225B964;
		  /* 8225B964h */ case    6:  		/* fmr FR2, FR4 */
		/* 8225B964h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225B964h case    6:*/		return 0x8225B968;
		  /* 8225B968h */ case    7:  		/* fmr FR1, FR4 */
		/* 8225B968h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225B968h case    7:*/		return 0x8225B96C;
		  /* 8225B96Ch */ case    8:  		/* bl -19028 */
		/* 8225B96Ch case    8:*/		regs.LR = 0x8225B970; return 0x82256F18;
		/* 8225B96Ch case    8:*/		return 0x8225B970;
		  /* 8225B970h */ case    9:  		/* mr R4, R30 */
		/* 8225B970h case    9:*/		regs.R4 = regs.R30;
		/* 8225B970h case    9:*/		return 0x8225B974;
		  /* 8225B974h */ case   10:  		/* mr R3, R17 */
		/* 8225B974h case   10:*/		regs.R3 = regs.R17;
		/* 8225B974h case   10:*/		return 0x8225B978;
		  /* 8225B978h */ case   11:  		/* bl -33008 */
		/* 8225B978h case   11:*/		regs.LR = 0x8225B97C; return 0x82253888;
		/* 8225B978h case   11:*/		return 0x8225B97C;
		  /* 8225B97Ch */ case   12:  		/* mr R26, R21 */
		/* 8225B97Ch case   12:*/		regs.R26 = regs.R21;
		/* 8225B97Ch case   12:*/		return 0x8225B980;
		  /* 8225B980h */ case   13:  		/* li R27, 4 */
		/* 8225B980h case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225B980h case   13:*/		return 0x8225B984;
	}
	return 0x8225B984;
} // Block from 8225B94Ch-8225B984h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225B984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B984);
		  /* 8225B984h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225B984h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225B984h case    0:*/		return 0x8225B988;
		  /* 8225B988h */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225B988h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225B988h case    1:*/		return 0x8225B98C;
		  /* 8225B98Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225B98Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8225B99C;  }
		/* 8225B98Ch case    2:*/		return 0x8225B990;
		  /* 8225B990h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225B990h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225B990h case    3:*/		return 0x8225B994;
		  /* 8225B994h */ case    4:  		/* rlwinm R11, R11, 13, 31, 31 */
		/* 8225B994h case    4:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R11,regs.R11);
		/* 8225B994h case    4:*/		return 0x8225B998;
		  /* 8225B998h */ case    5:  		/* b 8 */
		/* 8225B998h case    5:*/		return 0x8225B9A0;
		/* 8225B998h case    5:*/		return 0x8225B99C;
	}
	return 0x8225B99C;
} // Block from 8225B984h-8225B99Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225B99Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B99C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B99C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B99C);
		  /* 8225B99Ch */ case    0:  		/* li R11, -1 */
		/* 8225B99Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8225B99Ch case    0:*/		return 0x8225B9A0;
	}
	return 0x8225B9A0;
} // Block from 8225B99Ch-8225B9A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225B9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225B9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225B9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225B9A0);
		  /* 8225B9A0h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225B9A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225B9A0h case    0:*/		return 0x8225B9A4;
		  /* 8225B9A4h */ case    1:  		/* bc 4, CR6_GT, 296 */
		/* 8225B9A4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8225BACC;  }
		/* 8225B9A4h case    1:*/		return 0x8225B9A8;
		  /* 8225B9A8h */ case    2:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225B9A8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B9A8h case    2:*/		return 0x8225B9AC;
		  /* 8225B9ACh */ case    3:  		/* li R3, 38 */
		/* 8225B9ACh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x26);
		/* 8225B9ACh case    3:*/		return 0x8225B9B0;
		  /* 8225B9B0h */ case    4:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225B9B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B9B0h case    4:*/		return 0x8225B9B4;
		  /* 8225B9B4h */ case    5:  		/* addi R29, R11, -1 */
		/* 8225B9B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 8225B9B4h case    5:*/		return 0x8225B9B8;
		  /* 8225B9B8h */ case    6:  		/* stw R29, <#[R10 + 1508]> */
		/* 8225B9B8h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225B9B8h case    6:*/		return 0x8225B9BC;
		  /* 8225B9BCh */ case    7:  		/* mr R21, R29 */
		/* 8225B9BCh case    7:*/		regs.R21 = regs.R29;
		/* 8225B9BCh case    7:*/		return 0x8225B9C0;
		  /* 8225B9C0h */ case    8:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225B9C0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225B9C0h case    8:*/		return 0x8225B9C4;
		  /* 8225B9C4h */ case    9:  		/* bl -23188 */
		/* 8225B9C4h case    9:*/		regs.LR = 0x8225B9C8; return 0x82255F30;
		/* 8225B9C4h case    9:*/		return 0x8225B9C8;
		  /* 8225B9C8h */ case   10:  		/* stw R29, <#[R3 + 56]> */
		/* 8225B9C8h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000038) );
		/* 8225B9C8h case   10:*/		return 0x8225B9CC;
		  /* 8225B9CCh */ case   11:  		/* rlwinm R29, R27, 3, 0, 28 */
		/* 8225B9CCh case   11:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R29,regs.R27);
		/* 8225B9CCh case   11:*/		return 0x8225B9D0;
		  /* 8225B9D0h */ case   12:  		/* stw R20, <#[R3 + 80]> */
		/* 8225B9D0h case   12:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225B9D0h case   12:*/		return 0x8225B9D4;
		  /* 8225B9D4h */ case   13:  		/* li R5, 2 */
		/* 8225B9D4h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225B9D4h case   13:*/		return 0x8225B9D8;
		  /* 8225B9D8h */ case   14:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225B9D8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225B9D8h case   14:*/		return 0x8225B9DC;
		  /* 8225B9DCh */ case   15:  		/* add R11, R11, R29 */
		/* 8225B9DCh case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225B9DCh case   15:*/		return 0x8225B9E0;
		  /* 8225B9E0h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225B9E0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225B9E0h case   16:*/		return 0x8225B9E4;
		  /* 8225B9E4h */ case   17:  		/* mr R4, R31 */
		/* 8225B9E4h case   17:*/		regs.R4 = regs.R31;
		/* 8225B9E4h case   17:*/		return 0x8225B9E8;
		  /* 8225B9E8h */ case   18:  		/* stw R26, <#[R3 + 60]> */
		/* 8225B9E8h case   18:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225B9E8h case   18:*/		return 0x8225B9EC;
		  /* 8225B9ECh */ case   19:  		/* mr R30, R3 */
		/* 8225B9ECh case   19:*/		regs.R30 = regs.R3;
		/* 8225B9ECh case   19:*/		return 0x8225B9F0;
		  /* 8225B9F0h */ case   20:  		/* stw R11, <#[R3 + 84]> */
		/* 8225B9F0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225B9F0h case   20:*/		return 0x8225B9F4;
		  /* 8225B9F4h */ case   21:  		/* fmr FR4, FR30 */
		/* 8225B9F4h case   21:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR30);
		/* 8225B9F4h case   21:*/		return 0x8225B9F8;
		  /* 8225B9F8h */ case   22:  		/* fmr FR3, FR30 */
		/* 8225B9F8h case   22:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR30);
		/* 8225B9F8h case   22:*/		return 0x8225B9FC;
		  /* 8225B9FCh */ case   23:  		/* fmr FR2, FR30 */
		/* 8225B9FCh case   23:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 8225B9FCh case   23:*/		return 0x8225BA00;
		  /* 8225BA00h */ case   24:  		/* fmr FR1, FR30 */
		/* 8225BA00h case   24:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8225BA00h case   24:*/		return 0x8225BA04;
		  /* 8225BA04h */ case   25:  		/* bl -19180 */
		/* 8225BA04h case   25:*/		regs.LR = 0x8225BA08; return 0x82256F18;
		/* 8225BA04h case   25:*/		return 0x8225BA08;
		  /* 8225BA08h */ case   26:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225BA08h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225BA08h case   26:*/		return 0x8225BA0C;
		  /* 8225BA0Ch */ case   27:  		/* cmpw CR6, R16, R26 */
		/* 8225BA0Ch case   27:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225BA0Ch case   27:*/		return 0x8225BA10;
		  /* 8225BA10h */ case   28:  		/* add R11, R11, R29 */
		/* 8225BA10h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225BA10h case   28:*/		return 0x8225BA14;
		  /* 8225BA14h */ case   29:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225BA14h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225BA14h case   29:*/		return 0x8225BA18;
		  /* 8225BA18h */ case   30:  		/* stw R26, <#[R30 + 68]> */
		/* 8225BA18h case   30:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000044) );
		/* 8225BA18h case   30:*/		return 0x8225BA1C;
		  /* 8225BA1Ch */ case   31:  		/* stw R11, <#[R30 + 92]> */
		/* 8225BA1Ch case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000005C) );
		/* 8225BA1Ch case   31:*/		return 0x8225BA20;
		  /* 8225BA20h */ case   32:  		/* bc 4, CR6_EQ, 68 */
		/* 8225BA20h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8225BA64;  }
		/* 8225BA20h case   32:*/		return 0x8225BA24;
		  /* 8225BA24h */ case   33:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225BA24h case   33:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225BA24h case   33:*/		return 0x8225BA28;
		  /* 8225BA28h */ case   34:  		/* bc 12, CR0_EQ, 8 */
		/* 8225BA28h case   34:*/		if ( regs.CR[0].eq ) { return 0x8225BA30;  }
		/* 8225BA28h case   34:*/		return 0x8225BA2C;
		  /* 8225BA2Ch */ case   35:  		/* stw R18, <#[R30 + 212]> */
		/* 8225BA2Ch case   35:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R30 + 0x000000D4) );
		/* 8225BA2Ch case   35:*/		return 0x8225BA30;
	}
	return 0x8225BA30;
} // Block from 8225B9A0h-8225BA30h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8225BA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BA30);
		  /* 8225BA30h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8225BA30h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225BA30h case    0:*/		return 0x8225BA34;
		  /* 8225BA34h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 8225BA34h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225BA50;  }
		/* 8225BA34h case    1:*/		return 0x8225BA38;
		  /* 8225BA38h */ case    2:  		/* stw R18, <#[R30 + 204]> */
		/* 8225BA38h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R30 + 0x000000CC) );
		/* 8225BA38h case    2:*/		return 0x8225BA3C;
		  /* 8225BA3Ch */ case    3:  		/* mr R23, R20 */
		/* 8225BA3Ch case    3:*/		regs.R23 = regs.R20;
		/* 8225BA3Ch case    3:*/		return 0x8225BA40;
		  /* 8225BA40h */ case    4:  		/* stb R20, <#[R1 + 351]> */
		/* 8225BA40h case    4:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225BA40h case    4:*/		return 0x8225BA44;
		  /* 8225BA44h */ case    5:  		/* lwz R11, <#[R19]> */
		/* 8225BA44h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BA44h case    5:*/		return 0x8225BA48;
		  /* 8225BA48h */ case    6:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225BA48h case    6:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225BA48h case    6:*/		return 0x8225BA4C;
		  /* 8225BA4Ch */ case    7:  		/* stw R11, <#[R19]> */
		/* 8225BA4Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BA4Ch case    7:*/		return 0x8225BA50;
	}
	return 0x8225BA50;
} // Block from 8225BA30h-8225BA50h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225BA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BA50);
		  /* 8225BA50h */ case    0:  		/* mr R4, R30 */
		/* 8225BA50h case    0:*/		regs.R4 = regs.R30;
		/* 8225BA50h case    0:*/		return 0x8225BA54;
		  /* 8225BA54h */ case    1:  		/* mr R3, R19 */
		/* 8225BA54h case    1:*/		regs.R3 = regs.R19;
		/* 8225BA54h case    1:*/		return 0x8225BA58;
		  /* 8225BA58h */ case    2:  		/* bl -4816 */
		/* 8225BA58h case    2:*/		regs.LR = 0x8225BA5C; return 0x8225A788;
		/* 8225BA58h case    2:*/		return 0x8225BA5C;
		  /* 8225BA5Ch */ case    3:  		/* lwz R11, <#[R30 + 132]> */
		/* 8225BA5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225BA5Ch case    3:*/		return 0x8225BA60;
		  /* 8225BA60h */ case    4:  		/* stw R11, <#[R30 + 140]> */
		/* 8225BA60h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000008C) );
		/* 8225BA60h case    4:*/		return 0x8225BA64;
	}
	return 0x8225BA64;
} // Block from 8225BA50h-8225BA64h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225BA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BA64);
		  /* 8225BA64h */ case    0:  		/* mr R4, R30 */
		/* 8225BA64h case    0:*/		regs.R4 = regs.R30;
		/* 8225BA64h case    0:*/		return 0x8225BA68;
		  /* 8225BA68h */ case    1:  		/* mr R3, R17 */
		/* 8225BA68h case    1:*/		regs.R3 = regs.R17;
		/* 8225BA68h case    1:*/		return 0x8225BA6C;
		  /* 8225BA6Ch */ case    2:  		/* bl -33252 */
		/* 8225BA6Ch case    2:*/		regs.LR = 0x8225BA70; return 0x82253888;
		/* 8225BA6Ch case    2:*/		return 0x8225BA70;
		  /* 8225BA70h */ case    3:  		/* li R3, 37 */
		/* 8225BA70h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x25);
		/* 8225BA70h case    3:*/		return 0x8225BA74;
		  /* 8225BA74h */ case    4:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225BA74h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BA74h case    4:*/		return 0x8225BA78;
		  /* 8225BA78h */ case    5:  		/* bl -23368 */
		/* 8225BA78h case    5:*/		regs.LR = 0x8225BA7C; return 0x82255F30;
		/* 8225BA78h case    5:*/		return 0x8225BA7C;
		  /* 8225BA7Ch */ case    6:  		/* stw R21, <#[R3 + 56]> */
		/* 8225BA7Ch case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225BA7Ch case    6:*/		return 0x8225BA80;
		  /* 8225BA80h */ case    7:  		/* stw R20, <#[R3 + 80]> */
		/* 8225BA80h case    7:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225BA80h case    7:*/		return 0x8225BA84;
		  /* 8225BA84h */ case    8:  		/* li R5, 3 */
		/* 8225BA84h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225BA84h case    8:*/		return 0x8225BA88;
		  /* 8225BA88h */ case    9:  		/* stw R21, <#[R3 + 60]> */
		/* 8225BA88h case    9:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225BA88h case    9:*/		return 0x8225BA8C;
		  /* 8225BA8Ch */ case   10:  		/* mr R4, R31 */
		/* 8225BA8Ch case   10:*/		regs.R4 = regs.R31;
		/* 8225BA8Ch case   10:*/		return 0x8225BA90;
		  /* 8225BA90h */ case   11:  		/* stw R20, <#[R3 + 84]> */
		/* 8225BA90h case   11:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000054) );
		/* 8225BA90h case   11:*/		return 0x8225BA94;
		  /* 8225BA94h */ case   12:  		/* mr R30, R3 */
		/* 8225BA94h case   12:*/		regs.R30 = regs.R3;
		/* 8225BA94h case   12:*/		return 0x8225BA98;
		  /* 8225BA98h */ case   13:  		/* stw R21, <#[R3 + 64]> */
		/* 8225BA98h case   13:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000040) );
		/* 8225BA98h case   13:*/		return 0x8225BA9C;
		  /* 8225BA9Ch */ case   14:  		/* fmr FR4, FR30 */
		/* 8225BA9Ch case   14:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR30);
		/* 8225BA9Ch case   14:*/		return 0x8225BAA0;
		  /* 8225BAA0h */ case   15:  		/* stw R20, <#[R3 + 88]> */
		/* 8225BAA0h case   15:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000058) );
		/* 8225BAA0h case   15:*/		return 0x8225BAA4;
		  /* 8225BAA4h */ case   16:  		/* fmr FR3, FR30 */
		/* 8225BAA4h case   16:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR30);
		/* 8225BAA4h case   16:*/		return 0x8225BAA8;
		  /* 8225BAA8h */ case   17:  		/* fmr FR2, FR30 */
		/* 8225BAA8h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 8225BAA8h case   17:*/		return 0x8225BAAC;
		  /* 8225BAACh */ case   18:  		/* fmr FR1, FR30 */
		/* 8225BAACh case   18:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8225BAACh case   18:*/		return 0x8225BAB0;
		  /* 8225BAB0h */ case   19:  		/* bl -19352 */
		/* 8225BAB0h case   19:*/		regs.LR = 0x8225BAB4; return 0x82256F18;
		/* 8225BAB0h case   19:*/		return 0x8225BAB4;
		  /* 8225BAB4h */ case   20:  		/* stb R24, <#[R30 + 155]> */
		/* 8225BAB4h case   20:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R30 + 0x0000009B) );
		/* 8225BAB4h case   20:*/		return 0x8225BAB8;
		  /* 8225BAB8h */ case   21:  		/* mr R3, R17 */
		/* 8225BAB8h case   21:*/		regs.R3 = regs.R17;
		/* 8225BAB8h case   21:*/		return 0x8225BABC;
		  /* 8225BABCh */ case   22:  		/* mr R4, R30 */
		/* 8225BABCh case   22:*/		regs.R4 = regs.R30;
		/* 8225BABCh case   22:*/		return 0x8225BAC0;
		  /* 8225BAC0h */ case   23:  		/* bl -33336 */
		/* 8225BAC0h case   23:*/		regs.LR = 0x8225BAC4; return 0x82253888;
		/* 8225BAC0h case   23:*/		return 0x8225BAC4;
		  /* 8225BAC4h */ case   24:  		/* mr R26, R21 */
		/* 8225BAC4h case   24:*/		regs.R26 = regs.R21;
		/* 8225BAC4h case   24:*/		return 0x8225BAC8;
		  /* 8225BAC8h */ case   25:  		/* li R27, 4 */
		/* 8225BAC8h case   25:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225BAC8h case   25:*/		return 0x8225BACC;
	}
	return 0x8225BACC;
} // Block from 8225BA64h-8225BACCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225BACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BACC);
		  /* 8225BACCh */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225BACCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BACCh case    0:*/		return 0x8225BAD0;
		  /* 8225BAD0h */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225BAD0h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225BAD0h case    1:*/		return 0x8225BAD4;
		  /* 8225BAD4h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225BAD4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225BAE4;  }
		/* 8225BAD4h case    2:*/		return 0x8225BAD8;
		  /* 8225BAD8h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225BAD8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225BAD8h case    3:*/		return 0x8225BADC;
		  /* 8225BADCh */ case    4:  		/* rlwinm R30, R11, 11, 29, 31 */
		/* 8225BADCh case    4:*/		cpu::op::rlwinm<0,11,29,31>(regs,&regs.R30,regs.R11);
		/* 8225BADCh case    4:*/		return 0x8225BAE0;
		  /* 8225BAE0h */ case    5:  		/* b 8 */
		/* 8225BAE0h case    5:*/		return 0x8225BAE8;
		/* 8225BAE0h case    5:*/		return 0x8225BAE4;
	}
	return 0x8225BAE4;
} // Block from 8225BACCh-8225BAE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225BAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BAE4);
		  /* 8225BAE4h */ case    0:  		/* li R30, -1 */
		/* 8225BAE4h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 8225BAE4h case    0:*/		return 0x8225BAE8;
	}
	return 0x8225BAE8;
} // Block from 8225BAE4h-8225BAE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225BAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BAE8);
		  /* 8225BAE8h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8225BAE8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8225BAE8h case    0:*/		return 0x8225BAEC;
		  /* 8225BAECh */ case    1:  		/* bc 4, CR6_GT, 932 */
		/* 8225BAECh case    1:*/		if ( !regs.CR[6].gt ) { return 0x8225BE90;  }
		/* 8225BAECh case    1:*/		return 0x8225BAF0;
		  /* 8225BAF0h */ case    2:  		/* cmpwi CR6, R30, 4 */
		/* 8225BAF0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225BAF0h case    2:*/		return 0x8225BAF4;
		  /* 8225BAF4h */ case    3:  		/* bc 4, CR6_GT, 36 */
		/* 8225BAF4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8225BB18;  }
		/* 8225BAF4h case    3:*/		return 0x8225BAF8;
		  /* 8225BAF8h */ case    4:  		/* lis R11, -32251 */
		/* 8225BAF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225BAF8h case    4:*/		return 0x8225BAFC;
		  /* 8225BAFCh */ case    5:  		/* mr R6, R14 */
		/* 8225BAFCh case    5:*/		regs.R6 = regs.R14;
		/* 8225BAFCh case    5:*/		return 0x8225BB00;
		  /* 8225BB00h */ case    6:  		/* addi R5, R11, -21392 */
		/* 8225BB00h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAC70);
		/* 8225BB00h case    6:*/		return 0x8225BB04;
		  /* 8225BB04h */ case    7:  		/* mr R4, R15 */
		/* 8225BB04h case    7:*/		regs.R4 = regs.R15;
		/* 8225BB04h case    7:*/		return 0x8225BB08;
		  /* 8225BB08h */ case    8:  		/* li R7, 674 */
		/* 8225BB08h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x2A2);
		/* 8225BB08h case    8:*/		return 0x8225BB0C;
		  /* 8225BB0Ch */ case    9:  		/* li R3, 0 */
		/* 8225BB0Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225BB0Ch case    9:*/		return 0x8225BB10;
		  /* 8225BB10h */ case   10:  		/* bl -1064712 */
		/* 8225BB10h case   10:*/		regs.LR = 0x8225BB14; return 0x82157C08;
		/* 8225BB10h case   10:*/		return 0x8225BB14;
		  /* 8225BB14h */ case   11:  		/* cmpwi CR6, R30, 4 */
		/* 8225BB14h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225BB14h case   11:*/		return 0x8225BB18;
	}
	return 0x8225BB18;
} // Block from 8225BAE8h-8225BB18h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225BB18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BB18);
		  /* 8225BB18h */ case    0:  		/* bc 4, CR6_EQ, 388 */
		/* 8225BB18h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8225BC9C;  }
		/* 8225BB18h case    0:*/		return 0x8225BB1C;
		  /* 8225BB1Ch */ case    1:  		/* lwz R30, <#[R1 + 324]> */
		/* 8225BB1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 8225BB1Ch case    1:*/		return 0x8225BB20;
		  /* 8225BB20h */ case    2:  		/* li R10, 100 */
		/* 8225BB20h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x64);
		/* 8225BB20h case    2:*/		return 0x8225BB24;
		  /* 8225BB24h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 8225BB24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225BB24h case    3:*/		return 0x8225BB28;
		  /* 8225BB28h */ case    4:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8225BB28h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8225BB28h case    4:*/		return 0x8225BB2C;
		  /* 8225BB2Ch */ case    5:  		/* subfc R9, R10, R11 */
		/* 8225BB2Ch case    5:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8225BB2Ch case    5:*/		return 0x8225BB30;
		  /* 8225BB30h */ case    6:  		/* eqv R10, R10, R11 */
		/* 8225BB30h case    6:*/		cpu::op::eqv<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8225BB30h case    6:*/		return 0x8225BB34;
		  /* 8225BB34h */ case    7:  		/* rlwinm R10, R10, 1, 31, 31 */
		/* 8225BB34h case    7:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R10);
		/* 8225BB34h case    7:*/		return 0x8225BB38;
		  /* 8225BB38h */ case    8:  		/* addze R10, R10 */
		/* 8225BB38h case    8:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 8225BB38h case    8:*/		return 0x8225BB3C;
		  /* 8225BB3Ch */ case    9:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 8225BB3Ch case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8225BB3Ch case    9:*/		return 0x8225BB40;
		  /* 8225BB40h */ case   10:  		/* subfic R10, R10, 0 */
		/* 8225BB40h case   10:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 8225BB40h case   10:*/		return 0x8225BB44;
		  /* 8225BB44h */ case   11:  		/* subfe R10, R10, R10 */
		/* 8225BB44h case   11:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8225BB44h case   11:*/		return 0x8225BB48;
		  /* 8225BB48h */ case   12:  		/* and R10, R10, R11 */
		/* 8225BB48h case   12:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8225BB48h case   12:*/		return 0x8225BB4C;
		  /* 8225BB4Ch */ case   13:  		/* cmpwi CR6, R10, 93 */
		/* 8225BB4Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005D);
		/* 8225BB4Ch case   13:*/		return 0x8225BB50;
		  /* 8225BB50h */ case   14:  		/* bc 12, CR6_EQ, 120 */
		/* 8225BB50h case   14:*/		if ( regs.CR[6].eq ) { return 0x8225BBC8;  }
		/* 8225BB50h case   14:*/		return 0x8225BB54;
		  /* 8225BB54h */ case   15:  		/* li R10, 100 */
		/* 8225BB54h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x64);
		/* 8225BB54h case   15:*/		return 0x8225BB58;
		  /* 8225BB58h */ case   16:  		/* subfc R9, R10, R11 */
		/* 8225BB58h case   16:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8225BB58h case   16:*/		return 0x8225BB5C;
		  /* 8225BB5Ch */ case   17:  		/* eqv R10, R10, R11 */
		/* 8225BB5Ch case   17:*/		cpu::op::eqv<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8225BB5Ch case   17:*/		return 0x8225BB60;
		  /* 8225BB60h */ case   18:  		/* rlwinm R10, R10, 1, 31, 31 */
		/* 8225BB60h case   18:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R10);
		/* 8225BB60h case   18:*/		return 0x8225BB64;
		  /* 8225BB64h */ case   19:  		/* addze R10, R10 */
		/* 8225BB64h case   19:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 8225BB64h case   19:*/		return 0x8225BB68;
		  /* 8225BB68h */ case   20:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 8225BB68h case   20:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8225BB68h case   20:*/		return 0x8225BB6C;
		  /* 8225BB6Ch */ case   21:  		/* subfic R10, R10, 0 */
		/* 8225BB6Ch case   21:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 8225BB6Ch case   21:*/		return 0x8225BB70;
		  /* 8225BB70h */ case   22:  		/* subfe R10, R10, R10 */
		/* 8225BB70h case   22:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8225BB70h case   22:*/		return 0x8225BB74;
		  /* 8225BB74h */ case   23:  		/* and R10, R10, R11 */
		/* 8225BB74h case   23:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8225BB74h case   23:*/		return 0x8225BB78;
		  /* 8225BB78h */ case   24:  		/* cmpwi CR6, R10, 94 */
		/* 8225BB78h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005E);
		/* 8225BB78h case   24:*/		return 0x8225BB7C;
		  /* 8225BB7Ch */ case   25:  		/* bc 12, CR6_EQ, 76 */
		/* 8225BB7Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x8225BBC8;  }
		/* 8225BB7Ch case   25:*/		return 0x8225BB80;
		  /* 8225BB80h */ case   26:  		/* li R10, 100 */
		/* 8225BB80h case   26:*/		cpu::op::li<0>(regs,&regs.R10,0x64);
		/* 8225BB80h case   26:*/		return 0x8225BB84;
		  /* 8225BB84h */ case   27:  		/* subfc R9, R10, R11 */
		/* 8225BB84h case   27:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8225BB84h case   27:*/		return 0x8225BB88;
		  /* 8225BB88h */ case   28:  		/* eqv R10, R10, R11 */
		/* 8225BB88h case   28:*/		cpu::op::eqv<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8225BB88h case   28:*/		return 0x8225BB8C;
		  /* 8225BB8Ch */ case   29:  		/* rlwinm R10, R10, 1, 31, 31 */
		/* 8225BB8Ch case   29:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R10);
		/* 8225BB8Ch case   29:*/		return 0x8225BB90;
		  /* 8225BB90h */ case   30:  		/* addze R10, R10 */
		/* 8225BB90h case   30:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 8225BB90h case   30:*/		return 0x8225BB94;
		  /* 8225BB94h */ case   31:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 8225BB94h case   31:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8225BB94h case   31:*/		return 0x8225BB98;
		  /* 8225BB98h */ case   32:  		/* subfic R10, R10, 0 */
		/* 8225BB98h case   32:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 8225BB98h case   32:*/		return 0x8225BB9C;
		  /* 8225BB9Ch */ case   33:  		/* subfe R10, R10, R10 */
		/* 8225BB9Ch case   33:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8225BB9Ch case   33:*/		return 0x8225BBA0;
		  /* 8225BBA0h */ case   34:  		/* and R11, R10, R11 */
		/* 8225BBA0h case   34:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225BBA0h case   34:*/		return 0x8225BBA4;
		  /* 8225BBA4h */ case   35:  		/* cmpwi CR6, R11, 80 */
		/* 8225BBA4h case   35:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000050);
		/* 8225BBA4h case   35:*/		return 0x8225BBA8;
		  /* 8225BBA8h */ case   36:  		/* bc 12, CR6_EQ, 32 */
		/* 8225BBA8h case   36:*/		if ( regs.CR[6].eq ) { return 0x8225BBC8;  }
		/* 8225BBA8h case   36:*/		return 0x8225BBAC;
		  /* 8225BBACh */ case   37:  		/* lis R11, -32251 */
		/* 8225BBACh case   37:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225BBACh case   37:*/		return 0x8225BBB0;
		  /* 8225BBB0h */ case   38:  		/* mr R6, R14 */
		/* 8225BBB0h case   38:*/		regs.R6 = regs.R14;
		/* 8225BBB0h case   38:*/		return 0x8225BBB4;
		  /* 8225BBB4h */ case   39:  		/* addi R5, R11, -21568 */
		/* 8225BBB4h case   39:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFABC0);
		/* 8225BBB4h case   39:*/		return 0x8225BBB8;
		  /* 8225BBB8h */ case   40:  		/* mr R4, R15 */
		/* 8225BBB8h case   40:*/		regs.R4 = regs.R15;
		/* 8225BBB8h case   40:*/		return 0x8225BBBC;
		  /* 8225BBBCh */ case   41:  		/* li R7, 680 */
		/* 8225BBBCh case   41:*/		cpu::op::li<0>(regs,&regs.R7,0x2A8);
		/* 8225BBBCh case   41:*/		return 0x8225BBC0;
		  /* 8225BBC0h */ case   42:  		/* li R3, 0 */
		/* 8225BBC0h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225BBC0h case   42:*/		return 0x8225BBC4;
		  /* 8225BBC4h */ case   43:  		/* bl -1064892 */
		/* 8225BBC4h case   43:*/		regs.LR = 0x8225BBC8; return 0x82157C08;
		/* 8225BBC4h case   43:*/		return 0x8225BBC8;
	}
	return 0x8225BBC8;
} // Block from 8225BB18h-8225BBC8h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225BBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BBC8);
		  /* 8225BBC8h */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 8225BBC8h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BBC8h case    0:*/		return 0x8225BBCC;
		  /* 8225BBCCh */ case    1:  		/* lbz R28, <#[R30 + 1]> */
		/* 8225BBCCh case    1:*/		cpu::mem::load8z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000001) );
		/* 8225BBCCh case    1:*/		return 0x8225BBD0;
		  /* 8225BBD0h */ case    2:  		/* lwz R3, <#[R29 + 1488]> */
		/* 8225BBD0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 8225BBD0h case    2:*/		return 0x8225BBD4;
		  /* 8225BBD4h */ case    3:  		/* lwz R30, <#[R29 + 1536]> */
		/* 8225BBD4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000600) );
		/* 8225BBD4h case    3:*/		return 0x8225BBD8;
		  /* 8225BBD8h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8225BBD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225BBD8h case    4:*/		return 0x8225BBDC;
		  /* 8225BBDCh */ case    5:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225BBDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225BBDCh case    5:*/		return 0x8225BBE0;
		  /* 8225BBE0h */ case    6:  		/* mtspr CTR, R11 */
		/* 8225BBE0h case    6:*/		regs.CTR = regs.R11;
		/* 8225BBE0h case    6:*/		return 0x8225BBE4;
		  /* 8225BBE4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 8225BBE4h case    7:*/		if ( 1 ) { regs.LR = 0x8225BBE8; return (uint32)regs.CTR; }
		/* 8225BBE4h case    7:*/		return 0x8225BBE8;
		  /* 8225BBE8h */ case    8:  		/* lis R11, -32222 */
		/* 8225BBE8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225BBE8h case    8:*/		return 0x8225BBEC;
		  /* 8225BBECh */ case    9:  		/* mr R5, R3 */
		/* 8225BBECh case    9:*/		regs.R5 = regs.R3;
		/* 8225BBECh case    9:*/		return 0x8225BBF0;
		  /* 8225BBF0h */ case   10:  		/* mr R4, R28 */
		/* 8225BBF0h case   10:*/		regs.R4 = regs.R28;
		/* 8225BBF0h case   10:*/		return 0x8225BBF4;
		  /* 8225BBF4h */ case   11:  		/* mr R7, R29 */
		/* 8225BBF4h case   11:*/		regs.R7 = regs.R29;
		/* 8225BBF4h case   11:*/		return 0x8225BBF8;
		  /* 8225BBF8h */ case   12:  		/* mr R3, R30 */
		/* 8225BBF8h case   12:*/		regs.R3 = regs.R30;
		/* 8225BBF8h case   12:*/		return 0x8225BBFC;
		  /* 8225BBFCh */ case   13:  		/* addi R6, R11, -12392 */
		/* 8225BBFCh case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225BBFCh case   13:*/		return 0x8225BC00;
		  /* 8225BC00h */ case   14:  		/* bl -175016 */
		/* 8225BC00h case   14:*/		regs.LR = 0x8225BC04; return 0x82231058;
		/* 8225BC00h case   14:*/		return 0x8225BC04;
		  /* 8225BC04h */ case   15:  		/* lwz R29, <#[R31 + 12]> */
		/* 8225BC04h case   15:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BC04h case   15:*/		return 0x8225BC08;
		  /* 8225BC08h */ case   16:  		/* addi R11, R3, -1 */
		/* 8225BC08h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 8225BC08h case   16:*/		return 0x8225BC0C;
		  /* 8225BC0Ch */ case   17:  		/* cntlzw R11, R11 */
		/* 8225BC0Ch case   17:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225BC0Ch case   17:*/		return 0x8225BC10;
		  /* 8225BC10h */ case   18:  		/* lwz R3, <#[R29 + 1488]> */
		/* 8225BC10h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 8225BC10h case   18:*/		return 0x8225BC14;
		  /* 8225BC14h */ case   19:  		/* rlwinm R30, R11, 27, 31, 31 */
		/* 8225BC14h case   19:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R30,regs.R11);
		/* 8225BC14h case   19:*/		return 0x8225BC18;
		  /* 8225BC18h */ case   20:  		/* lwz R25, <#[R29 + 1536]> */
		/* 8225BC18h case   20:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R29 + 0x00000600) );
		/* 8225BC18h case   20:*/		return 0x8225BC1C;
		  /* 8225BC1Ch */ case   21:  		/* lwz R11, <#[R3]> */
		/* 8225BC1Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225BC1Ch case   21:*/		return 0x8225BC20;
		  /* 8225BC20h */ case   22:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225BC20h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225BC20h case   22:*/		return 0x8225BC24;
		  /* 8225BC24h */ case   23:  		/* mtspr CTR, R11 */
		/* 8225BC24h case   23:*/		regs.CTR = regs.R11;
		/* 8225BC24h case   23:*/		return 0x8225BC28;
		  /* 8225BC28h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 8225BC28h case   24:*/		if ( 1 ) { regs.LR = 0x8225BC2C; return (uint32)regs.CTR; }
		/* 8225BC28h case   24:*/		return 0x8225BC2C;
		  /* 8225BC2Ch */ case   25:  		/* lis R11, -32222 */
		/* 8225BC2Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225BC2Ch case   25:*/		return 0x8225BC30;
		  /* 8225BC30h */ case   26:  		/* mr R5, R3 */
		/* 8225BC30h case   26:*/		regs.R5 = regs.R3;
		/* 8225BC30h case   26:*/		return 0x8225BC34;
		  /* 8225BC34h */ case   27:  		/* mr R4, R28 */
		/* 8225BC34h case   27:*/		regs.R4 = regs.R28;
		/* 8225BC34h case   27:*/		return 0x8225BC38;
		  /* 8225BC38h */ case   28:  		/* mr R7, R29 */
		/* 8225BC38h case   28:*/		regs.R7 = regs.R29;
		/* 8225BC38h case   28:*/		return 0x8225BC3C;
		  /* 8225BC3Ch */ case   29:  		/* mr R3, R25 */
		/* 8225BC3Ch case   29:*/		regs.R3 = regs.R25;
		/* 8225BC3Ch case   29:*/		return 0x8225BC40;
		  /* 8225BC40h */ case   30:  		/* addi R6, R11, -12392 */
		/* 8225BC40h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225BC40h case   30:*/		return 0x8225BC44;
		  /* 8225BC44h */ case   31:  		/* bl -174788 */
		/* 8225BC44h case   31:*/		regs.LR = 0x8225BC48; return 0x82231180;
		/* 8225BC44h case   31:*/		return 0x8225BC48;
		  /* 8225BC48h */ case   32:  		/* lwz R25, <#[R31 + 12]> */
		/* 8225BC48h case   32:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BC48h case   32:*/		return 0x8225BC4C;
		  /* 8225BC4Ch */ case   33:  		/* addi R11, R3, -1 */
		/* 8225BC4Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 8225BC4Ch case   33:*/		return 0x8225BC50;
		  /* 8225BC50h */ case   34:  		/* cntlzw R11, R11 */
		/* 8225BC50h case   34:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225BC50h case   34:*/		return 0x8225BC54;
		  /* 8225BC54h */ case   35:  		/* lwz R3, <#[R25 + 1488]> */
		/* 8225BC54h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x000005D0) );
		/* 8225BC54h case   35:*/		return 0x8225BC58;
		  /* 8225BC58h */ case   36:  		/* rlwinm R29, R11, 27, 31, 31 */
		/* 8225BC58h case   36:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R29,regs.R11);
		/* 8225BC58h case   36:*/		return 0x8225BC5C;
		  /* 8225BC5Ch */ case   37:  		/* lwz R15, <#[R25 + 1536]> */
		/* 8225BC5Ch case   37:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R25 + 0x00000600) );
		/* 8225BC5Ch case   37:*/		return 0x8225BC60;
		  /* 8225BC60h */ case   38:  		/* lwz R11, <#[R3]> */
		/* 8225BC60h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225BC60h case   38:*/		return 0x8225BC64;
		  /* 8225BC64h */ case   39:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225BC64h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225BC64h case   39:*/		return 0x8225BC68;
		  /* 8225BC68h */ case   40:  		/* mtspr CTR, R11 */
		/* 8225BC68h case   40:*/		regs.CTR = regs.R11;
		/* 8225BC68h case   40:*/		return 0x8225BC6C;
		  /* 8225BC6Ch */ case   41:  		/* bcctrl 20, CR0_LT */
		/* 8225BC6Ch case   41:*/		if ( 1 ) { regs.LR = 0x8225BC70; return (uint32)regs.CTR; }
		/* 8225BC6Ch case   41:*/		return 0x8225BC70;
		  /* 8225BC70h */ case   42:  		/* lis R11, -32222 */
		/* 8225BC70h case   42:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225BC70h case   42:*/		return 0x8225BC74;
		  /* 8225BC74h */ case   43:  		/* mr R5, R3 */
		/* 8225BC74h case   43:*/		regs.R5 = regs.R3;
		/* 8225BC74h case   43:*/		return 0x8225BC78;
		  /* 8225BC78h */ case   44:  		/* mr R4, R28 */
		/* 8225BC78h case   44:*/		regs.R4 = regs.R28;
		/* 8225BC78h case   44:*/		return 0x8225BC7C;
		  /* 8225BC7Ch */ case   45:  		/* mr R3, R15 */
		/* 8225BC7Ch case   45:*/		regs.R3 = regs.R15;
		/* 8225BC7Ch case   45:*/		return 0x8225BC80;
		  /* 8225BC80h */ case   46:  		/* addi R6, R11, -12392 */
		/* 8225BC80h case   46:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225BC80h case   46:*/		return 0x8225BC84;
		  /* 8225BC84h */ case   47:  		/* mr R7, R25 */
		/* 8225BC84h case   47:*/		regs.R7 = regs.R25;
		/* 8225BC84h case   47:*/		return 0x8225BC88;
		  /* 8225BC88h */ case   48:  		/* bl -174560 */
		/* 8225BC88h case   48:*/		regs.LR = 0x8225BC8C; return 0x822312A8;
		/* 8225BC88h case   48:*/		return 0x8225BC8C;
		  /* 8225BC8Ch */ case   49:  		/* addi R11, R3, -1 */
		/* 8225BC8Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 8225BC8Ch case   49:*/		return 0x8225BC90;
		  /* 8225BC90h */ case   50:  		/* cntlzw R11, R11 */
		/* 8225BC90h case   50:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225BC90h case   50:*/		return 0x8225BC94;
		  /* 8225BC94h */ case   51:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8225BC94h case   51:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8225BC94h case   51:*/		return 0x8225BC98;
		  /* 8225BC98h */ case   52:  		/* b 40 */
		/* 8225BC98h case   52:*/		return 0x8225BCC0;
		/* 8225BC98h case   52:*/		return 0x8225BC9C;
	}
	return 0x8225BC9C;
} // Block from 8225BBC8h-8225BC9Ch (53 instructions)

//////////////////////////////////////////////////////
// Block at 8225BC9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BC9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BC9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BC9C);
		  /* 8225BC9Ch */ case    0:  		/* addi R11, R30, -1 */
		/* 8225BC9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 8225BC9Ch case    0:*/		return 0x8225BCA0;
		  /* 8225BCA0h */ case    1:  		/* addi R10, R30, -2 */
		/* 8225BCA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFFE);
		/* 8225BCA0h case    1:*/		return 0x8225BCA4;
		  /* 8225BCA4h */ case    2:  		/* addi R9, R30, -3 */
		/* 8225BCA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFFFFD);
		/* 8225BCA4h case    2:*/		return 0x8225BCA8;
		  /* 8225BCA8h */ case    3:  		/* cntlzw R11, R11 */
		/* 8225BCA8h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225BCA8h case    3:*/		return 0x8225BCAC;
		  /* 8225BCACh */ case    4:  		/* cntlzw R10, R10 */
		/* 8225BCACh case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8225BCACh case    4:*/		return 0x8225BCB0;
		  /* 8225BCB0h */ case    5:  		/* cntlzw R9, R9 */
		/* 8225BCB0h case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 8225BCB0h case    5:*/		return 0x8225BCB4;
		  /* 8225BCB4h */ case    6:  		/* rlwinm R30, R11, 27, 31, 31 */
		/* 8225BCB4h case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R30,regs.R11);
		/* 8225BCB4h case    6:*/		return 0x8225BCB8;
		  /* 8225BCB8h */ case    7:  		/* rlwinm R29, R10, 27, 31, 31 */
		/* 8225BCB8h case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R29,regs.R10);
		/* 8225BCB8h case    7:*/		return 0x8225BCBC;
		  /* 8225BCBCh */ case    8:  		/* rlwinm R11, R9, 27, 31, 31 */
		/* 8225BCBCh case    8:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R9);
		/* 8225BCBCh case    8:*/		return 0x8225BCC0;
	}
	return 0x8225BCC0;
} // Block from 8225BC9Ch-8225BCC0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225BCC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BCC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BCC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BCC0);
		  /* 8225BCC0h */ case    0:  		/* rlwinm. R10, R30, 0, 24, 31 */
		/* 8225BCC0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R30);
		/* 8225BCC0h case    0:*/		return 0x8225BCC4;
		  /* 8225BCC4h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 8225BCC4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8225BCD8;  }
		/* 8225BCC4h case    1:*/		return 0x8225BCC8;
		  /* 8225BCC8h */ case    2:  		/* rlwinm. R9, R29, 0, 24, 31 */
		/* 8225BCC8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R29);
		/* 8225BCC8h case    2:*/		return 0x8225BCCC;
		  /* 8225BCCCh */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8225BCCCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x8225BCD8;  }
		/* 8225BCCCh case    3:*/		return 0x8225BCD0;
		  /* 8225BCD0h */ case    4:  		/* rlwinm. R9, R11, 0, 24, 31 */
		/* 8225BCD0h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R11);
		/* 8225BCD0h case    4:*/		return 0x8225BCD4;
		  /* 8225BCD4h */ case    5:  		/* bc 12, CR0_EQ, 444 */
		/* 8225BCD4h case    5:*/		if ( regs.CR[0].eq ) { return 0x8225BE90;  }
		/* 8225BCD4h case    5:*/		return 0x8225BCD8;
	}
	return 0x8225BCD8;
} // Block from 8225BCC0h-8225BCD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225BCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BCD8);
		  /* 8225BCD8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8225BCD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8225BCD8h case    0:*/		return 0x8225BCDC;
		  /* 8225BCDCh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8225BCDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8225BCF4;  }
		/* 8225BCDCh case    1:*/		return 0x8225BCE0;
		  /* 8225BCE0h */ case    2:  		/* lwz R10, <#[R1 + 88]> */
		/* 8225BCE0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8225BCE0h case    2:*/		return 0x8225BCE4;
		  /* 8225BCE4h */ case    3:  		/* li R24, 1 */
		/* 8225BCE4h case    3:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8225BCE4h case    3:*/		return 0x8225BCE8;
		  /* 8225BCE8h */ case    4:  		/* lwz R23, <#[R10]> */
		/* 8225BCE8h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R10 + 0x00000000) );
		/* 8225BCE8h case    4:*/		return 0x8225BCEC;
		  /* 8225BCECh */ case    5:  		/* lwz R22, <#[R10 + 12]> */
		/* 8225BCECh case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R10 + 0x0000000C) );
		/* 8225BCECh case    5:*/		return 0x8225BCF0;
		  /* 8225BCF0h */ case    6:  		/* b 72 */
		/* 8225BCF0h case    6:*/		return 0x8225BD38;
		/* 8225BCF0h case    6:*/		return 0x8225BCF4;
	}
	return 0x8225BCF4;
} // Block from 8225BCD8h-8225BCF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225BCF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BCF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BCF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BCF4);
		  /* 8225BCF4h */ case    0:  		/* rlwinm. R10, R29, 0, 24, 31 */
		/* 8225BCF4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R29);
		/* 8225BCF4h case    0:*/		return 0x8225BCF8;
		  /* 8225BCF8h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8225BCF8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225BD10;  }
		/* 8225BCF8h case    1:*/		return 0x8225BCFC;
		  /* 8225BCFCh */ case    2:  		/* lwz R10, <#[R1 + 88]> */
		/* 8225BCFCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8225BCFCh case    2:*/		return 0x8225BD00;
		  /* 8225BD00h */ case    3:  		/* li R24, 2 */
		/* 8225BD00h case    3:*/		cpu::op::li<0>(regs,&regs.R24,0x2);
		/* 8225BD00h case    3:*/		return 0x8225BD04;
		  /* 8225BD04h */ case    4:  		/* lwz R23, <#[R10 + 4]> */
		/* 8225BD04h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R10 + 0x00000004) );
		/* 8225BD04h case    4:*/		return 0x8225BD08;
		  /* 8225BD08h */ case    5:  		/* lwz R22, <#[R10 + 16]> */
		/* 8225BD08h case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R10 + 0x00000010) );
		/* 8225BD08h case    5:*/		return 0x8225BD0C;
		  /* 8225BD0Ch */ case    6:  		/* b 44 */
		/* 8225BD0Ch case    6:*/		return 0x8225BD38;
		/* 8225BD0Ch case    6:*/		return 0x8225BD10;
	}
	return 0x8225BD10;
} // Block from 8225BCF4h-8225BD10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225BD10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BD10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BD10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BD10);
		  /* 8225BD10h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225BD10h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225BD10h case    0:*/		return 0x8225BD14;
		  /* 8225BD14h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8225BD14h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225BD2C;  }
		/* 8225BD14h case    1:*/		return 0x8225BD18;
		  /* 8225BD18h */ case    2:  		/* lwz R10, <#[R1 + 88]> */
		/* 8225BD18h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8225BD18h case    2:*/		return 0x8225BD1C;
		  /* 8225BD1Ch */ case    3:  		/* li R24, 3 */
		/* 8225BD1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R24,0x3);
		/* 8225BD1Ch case    3:*/		return 0x8225BD20;
		  /* 8225BD20h */ case    4:  		/* lwz R23, <#[R10 + 8]> */
		/* 8225BD20h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R10 + 0x00000008) );
		/* 8225BD20h case    4:*/		return 0x8225BD24;
		  /* 8225BD24h */ case    5:  		/* lwz R22, <#[R10 + 20]> */
		/* 8225BD24h case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R10 + 0x00000014) );
		/* 8225BD24h case    5:*/		return 0x8225BD28;
		  /* 8225BD28h */ case    6:  		/* b 16 */
		/* 8225BD28h case    6:*/		return 0x8225BD38;
		/* 8225BD28h case    6:*/		return 0x8225BD2C;
	}
	return 0x8225BD2C;
} // Block from 8225BD10h-8225BD2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225BD2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BD2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BD2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BD2C);
		  /* 8225BD2Ch */ case    0:  		/* lbz R24, <#[R1 + 80]> */
		/* 8225BD2Ch case    0:*/		cpu::mem::load8z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 8225BD2Ch case    0:*/		return 0x8225BD30;
		  /* 8225BD30h */ case    1:  		/* lwz R23, <#[R1 + 92]> */
		/* 8225BD30h case    1:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225BD30h case    1:*/		return 0x8225BD34;
		  /* 8225BD34h */ case    2:  		/* lwz R22, <#[R1 + 92]> */
		/* 8225BD34h case    2:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225BD34h case    2:*/		return 0x8225BD38;
	}
	return 0x8225BD38;
} // Block from 8225BD2Ch-8225BD38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225BD38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BD38);
		  /* 8225BD38h */ case    0:  		/* li R3, 62 */
		/* 8225BD38h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3E);
		/* 8225BD38h case    0:*/		return 0x8225BD3C;
		  /* 8225BD3Ch */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225BD3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BD3Ch case    1:*/		return 0x8225BD40;
		  /* 8225BD40h */ case    2:  		/* bl -24080 */
		/* 8225BD40h case    2:*/		regs.LR = 0x8225BD44; return 0x82255F30;
		/* 8225BD40h case    2:*/		return 0x8225BD44;
		  /* 8225BD44h */ case    3:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225BD44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BD44h case    3:*/		return 0x8225BD48;
		  /* 8225BD48h */ case    4:  		/* mr R28, R3 */
		/* 8225BD48h case    4:*/		regs.R28 = regs.R3;
		/* 8225BD48h case    4:*/		return 0x8225BD4C;
		  /* 8225BD4Ch */ case    5:  		/* rlwinm R25, R27, 3, 0, 28 */
		/* 8225BD4Ch case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R25,regs.R27);
		/* 8225BD4Ch case    5:*/		return 0x8225BD50;
		  /* 8225BD50h */ case    6:  		/* li R3, 19 */
		/* 8225BD50h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 8225BD50h case    6:*/		return 0x8225BD54;
		  /* 8225BD54h */ case    7:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225BD54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225BD54h case    7:*/		return 0x8225BD58;
		  /* 8225BD58h */ case    8:  		/* addi R27, R11, -1 */
		/* 8225BD58h case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFFFFF);
		/* 8225BD58h case    8:*/		return 0x8225BD5C;
		  /* 8225BD5Ch */ case    9:  		/* stw R27, <#[R10 + 1508]> */
		/* 8225BD5Ch case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225BD5Ch case    9:*/		return 0x8225BD60;
		  /* 8225BD60h */ case   10:  		/* mr R21, R27 */
		/* 8225BD60h case   10:*/		regs.R21 = regs.R27;
		/* 8225BD60h case   10:*/		return 0x8225BD64;
		  /* 8225BD64h */ case   11:  		/* stw R27, <#[R28 + 56]> */
		/* 8225BD64h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + 0x00000038) );
		/* 8225BD64h case   11:*/		return 0x8225BD68;
		  /* 8225BD68h */ case   12:  		/* stw R20, <#[R28 + 80]> */
		/* 8225BD68h case   12:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R28 + 0x00000050) );
		/* 8225BD68h case   12:*/		return 0x8225BD6C;
		  /* 8225BD6Ch */ case   13:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225BD6Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225BD6Ch case   13:*/		return 0x8225BD70;
		  /* 8225BD70h */ case   14:  		/* add R11, R11, R25 */
		/* 8225BD70h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8225BD70h case   14:*/		return 0x8225BD74;
		  /* 8225BD74h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225BD74h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225BD74h case   15:*/		return 0x8225BD78;
		  /* 8225BD78h */ case   16:  		/* stw R11, <#[R28 + 84]> */
		/* 8225BD78h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000054) );
		/* 8225BD78h case   16:*/		return 0x8225BD7C;
		  /* 8225BD7Ch */ case   17:  		/* stw R26, <#[R28 + 60]> */
		/* 8225BD7Ch case   17:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + 0x0000003C) );
		/* 8225BD7Ch case   17:*/		return 0x8225BD80;
		  /* 8225BD80h */ case   18:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225BD80h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BD80h case   18:*/		return 0x8225BD84;
		  /* 8225BD84h */ case   19:  		/* bl -24148 */
		/* 8225BD84h case   19:*/		regs.LR = 0x8225BD88; return 0x82255F30;
		/* 8225BD84h case   19:*/		return 0x8225BD88;
		  /* 8225BD88h */ case   20:  		/* mr R30, R3 */
		/* 8225BD88h case   20:*/		regs.R30 = regs.R3;
		/* 8225BD88h case   20:*/		return 0x8225BD8C;
		  /* 8225BD8Ch */ case   21:  		/* stw R27, <#[R3 + 56]> */
		/* 8225BD8Ch case   21:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000038) );
		/* 8225BD8Ch case   21:*/		return 0x8225BD90;
		  /* 8225BD90h */ case   22:  		/* li R3, 49 */
		/* 8225BD90h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225BD90h case   22:*/		return 0x8225BD94;
		  /* 8225BD94h */ case   23:  		/* stw R20, <#[R30 + 80]> */
		/* 8225BD94h case   23:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R30 + 0x00000050) );
		/* 8225BD94h case   23:*/		return 0x8225BD98;
		  /* 8225BD98h */ case   24:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225BD98h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225BD98h case   24:*/		return 0x8225BD9C;
		  /* 8225BD9Ch */ case   25:  		/* add R11, R11, R25 */
		/* 8225BD9Ch case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8225BD9Ch case   25:*/		return 0x8225BDA0;
		  /* 8225BDA0h */ case   26:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225BDA0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225BDA0h case   26:*/		return 0x8225BDA4;
		  /* 8225BDA4h */ case   27:  		/* stw R11, <#[R30 + 84]> */
		/* 8225BDA4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 8225BDA4h case   27:*/		return 0x8225BDA8;
		  /* 8225BDA8h */ case   28:  		/* stw R26, <#[R30 + 60]> */
		/* 8225BDA8h case   28:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000003C) );
		/* 8225BDA8h case   28:*/		return 0x8225BDAC;
		  /* 8225BDACh */ case   29:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225BDACh case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BDACh case   29:*/		return 0x8225BDB0;
		  /* 8225BDB0h */ case   30:  		/* bl -24192 */
		/* 8225BDB0h case   30:*/		regs.LR = 0x8225BDB4; return 0x82255F30;
		/* 8225BDB0h case   30:*/		return 0x8225BDB4;
		  /* 8225BDB4h */ case   31:  		/* stw R27, <#[R3 + 56]> */
		/* 8225BDB4h case   31:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000038) );
		/* 8225BDB4h case   31:*/		return 0x8225BDB8;
		  /* 8225BDB8h */ case   32:  		/* stw R20, <#[R3 + 80]> */
		/* 8225BDB8h case   32:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225BDB8h case   32:*/		return 0x8225BDBC;
		  /* 8225BDBCh */ case   33:  		/* mr R29, R3 */
		/* 8225BDBCh case   33:*/		regs.R29 = regs.R3;
		/* 8225BDBCh case   33:*/		return 0x8225BDC0;
		  /* 8225BDC0h */ case   34:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225BDC0h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225BDC0h case   34:*/		return 0x8225BDC4;
		  /* 8225BDC4h */ case   35:  		/* add R11, R11, R25 */
		/* 8225BDC4h case   35:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8225BDC4h case   35:*/		return 0x8225BDC8;
		  /* 8225BDC8h */ case   36:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225BDC8h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225BDC8h case   36:*/		return 0x8225BDCC;
		  /* 8225BDCCh */ case   37:  		/* cmpw CR6, R16, R26 */
		/* 8225BDCCh case   37:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225BDCCh case   37:*/		return 0x8225BDD0;
		  /* 8225BDD0h */ case   38:  		/* stw R26, <#[R3 + 60]> */
		/* 8225BDD0h case   38:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225BDD0h case   38:*/		return 0x8225BDD4;
		  /* 8225BDD4h */ case   39:  		/* stw R11, <#[R3 + 84]> */
		/* 8225BDD4h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225BDD4h case   39:*/		return 0x8225BDD8;
		  /* 8225BDD8h */ case   40:  		/* bc 4, CR6_EQ, 72 */
		/* 8225BDD8h case   40:*/		if ( !regs.CR[6].eq ) { return 0x8225BE20;  }
		/* 8225BDD8h case   40:*/		return 0x8225BDDC;
		  /* 8225BDDCh */ case   41:  		/* lbz R11, <#[R1 + 351]> */
		/* 8225BDDCh case   41:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225BDDCh case   41:*/		return 0x8225BDE0;
		  /* 8225BDE0h */ case   42:  		/* cmplwi CR0, R11, 0 */
		/* 8225BDE0h case   42:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225BDE0h case   42:*/		return 0x8225BDE4;
		  /* 8225BDE4h */ case   43:  		/* bc 12, CR0_EQ, 12 */
		/* 8225BDE4h case   43:*/		if ( regs.CR[0].eq ) { return 0x8225BDF0;  }
		/* 8225BDE4h case   43:*/		return 0x8225BDE8;
		  /* 8225BDE8h */ case   44:  		/* stw R18, <#[R30 + 204]> */
		/* 8225BDE8h case   44:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R30 + 0x000000CC) );
		/* 8225BDE8h case   44:*/		return 0x8225BDEC;
		  /* 8225BDECh */ case   45:  		/* stw R18, <#[R3 + 204]> */
		/* 8225BDECh case   45:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225BDECh case   45:*/		return 0x8225BDF0;
	}
	return 0x8225BDF0;
} // Block from 8225BD38h-8225BDF0h (46 instructions)

//////////////////////////////////////////////////////
// Block at 8225BDF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BDF0);
		  /* 8225BDF0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8225BDF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225BDF0h case    0:*/		return 0x8225BDF4;
		  /* 8225BDF4h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8225BDF4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225BE0C;  }
		/* 8225BDF4h case    1:*/		return 0x8225BDF8;
		  /* 8225BDF8h */ case    2:  		/* stw R18, <#[R28 + 204]> */
		/* 8225BDF8h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R28 + 0x000000CC) );
		/* 8225BDF8h case    2:*/		return 0x8225BDFC;
		  /* 8225BDFCh */ case    3:  		/* lwz R11, <#[R19]> */
		/* 8225BDFCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BDFCh case    3:*/		return 0x8225BE00;
		  /* 8225BE00h */ case    4:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225BE00h case    4:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225BE00h case    4:*/		return 0x8225BE04;
		  /* 8225BE04h */ case    5:  		/* stb R20, <#[R1 + 351]> */
		/* 8225BE04h case    5:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225BE04h case    5:*/		return 0x8225BE08;
		  /* 8225BE08h */ case    6:  		/* stw R11, <#[R19]> */
		/* 8225BE08h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BE08h case    6:*/		return 0x8225BE0C;
	}
	return 0x8225BE0C;
} // Block from 8225BDF0h-8225BE0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225BE0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BE0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BE0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BE0C);
		  /* 8225BE0Ch */ case    0:  		/* mr R4, R30 */
		/* 8225BE0Ch case    0:*/		regs.R4 = regs.R30;
		/* 8225BE0Ch case    0:*/		return 0x8225BE10;
		  /* 8225BE10h */ case    1:  		/* mr R3, R19 */
		/* 8225BE10h case    1:*/		regs.R3 = regs.R19;
		/* 8225BE10h case    1:*/		return 0x8225BE14;
		  /* 8225BE14h */ case    2:  		/* bl -5772 */
		/* 8225BE14h case    2:*/		regs.LR = 0x8225BE18; return 0x8225A788;
		/* 8225BE14h case    2:*/		return 0x8225BE18;
		  /* 8225BE18h */ case    3:  		/* lwz R11, <#[R30 + 132]> */
		/* 8225BE18h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225BE18h case    3:*/		return 0x8225BE1C;
		  /* 8225BE1Ch */ case    4:  		/* stw R11, <#[R29 + 132]> */
		/* 8225BE1Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 8225BE1Ch case    4:*/		return 0x8225BE20;
	}
	return 0x8225BE20;
} // Block from 8225BE0Ch-8225BE20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225BE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BE20);
		  /* 8225BE20h */ case    0:  		/* lwz R11, <#[R30 + 132]> */
		/* 8225BE20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225BE20h case    0:*/		return 0x8225BE24;
		  /* 8225BE24h */ case    1:  		/* rlwinm R10, R24, 0, 24, 31 */
		/* 8225BE24h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R24);
		/* 8225BE24h case    1:*/		return 0x8225BE28;
		  /* 8225BE28h */ case    2:  		/* stw R21, <#[R30 + 64]> */
		/* 8225BE28h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R30 + 0x00000040) );
		/* 8225BE28h case    2:*/		return 0x8225BE2C;
		  /* 8225BE2Ch */ case    3:  		/* addi R9, R1, 92 */
		/* 8225BE2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x5C);
		/* 8225BE2Ch case    3:*/		return 0x8225BE30;
		  /* 8225BE30h */ case    4:  		/* stw R20, <#[R30 + 88]> */
		/* 8225BE30h case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R30 + 0x00000058) );
		/* 8225BE30h case    4:*/		return 0x8225BE34;
		  /* 8225BE34h */ case    5:  		/* mr R4, R28 */
		/* 8225BE34h case    5:*/		regs.R4 = regs.R28;
		/* 8225BE34h case    5:*/		return 0x8225BE38;
		  /* 8225BE38h */ case    6:  		/* lwz R8, <#[R1 + 88]> */
		/* 8225BE38h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 8225BE38h case    6:*/		return 0x8225BE3C;
		  /* 8225BE3Ch */ case    7:  		/* mr R3, R17 */
		/* 8225BE3Ch case    7:*/		regs.R3 = regs.R17;
		/* 8225BE3Ch case    7:*/		return 0x8225BE40;
		  /* 8225BE40h */ case    8:  		/* stw R11, <#[R1 + 92]> */
		/* 8225BE40h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225BE40h case    8:*/		return 0x8225BE44;
		  /* 8225BE44h */ case    9:  		/* addi R8, R8, 24 */
		/* 8225BE44h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x18);
		/* 8225BE44h case    9:*/		return 0x8225BE48;
		  /* 8225BE48h */ case   10:  		/* lbzx R11, <#[R10 + R9]> */
		/* 8225BE48h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8225BE48h case   10:*/		return 0x8225BE4C;
		  /* 8225BE4Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 8225BE4Ch case   11:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 8225BE4Ch case   11:*/		return 0x8225BE50;
		  /* 8225BE50h */ case   12:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8225BE50h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8225BE50h case   12:*/		return 0x8225BE54;
		  /* 8225BE54h */ case   13:  		/* stw R11, <#[R28 + 132]> */
		/* 8225BE54h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000084) );
		/* 8225BE54h case   13:*/		return 0x8225BE58;
		  /* 8225BE58h */ case   14:  		/* stw R23, <#[R30 + 128]> */
		/* 8225BE58h case   14:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R30 + 0x00000080) );
		/* 8225BE58h case   14:*/		return 0x8225BE5C;
		  /* 8225BE5Ch */ case   15:  		/* stw R22, <#[R29 + 128]> */
		/* 8225BE5Ch case   15:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R29 + 0x00000080) );
		/* 8225BE5Ch case   15:*/		return 0x8225BE60;
		  /* 8225BE60h */ case   16:  		/* bl -34264 */
		/* 8225BE60h case   16:*/		regs.LR = 0x8225BE64; return 0x82253888;
		/* 8225BE60h case   16:*/		return 0x8225BE64;
		  /* 8225BE64h */ case   17:  		/* mr R4, R30 */
		/* 8225BE64h case   17:*/		regs.R4 = regs.R30;
		/* 8225BE64h case   17:*/		return 0x8225BE68;
		  /* 8225BE68h */ case   18:  		/* mr R3, R17 */
		/* 8225BE68h case   18:*/		regs.R3 = regs.R17;
		/* 8225BE68h case   18:*/		return 0x8225BE6C;
		  /* 8225BE6Ch */ case   19:  		/* bl -34276 */
		/* 8225BE6Ch case   19:*/		regs.LR = 0x8225BE70; return 0x82253888;
		/* 8225BE6Ch case   19:*/		return 0x8225BE70;
		  /* 8225BE70h */ case   20:  		/* mr R4, R29 */
		/* 8225BE70h case   20:*/		regs.R4 = regs.R29;
		/* 8225BE70h case   20:*/		return 0x8225BE74;
		  /* 8225BE74h */ case   21:  		/* mr R3, R17 */
		/* 8225BE74h case   21:*/		regs.R3 = regs.R17;
		/* 8225BE74h case   21:*/		return 0x8225BE78;
		  /* 8225BE78h */ case   22:  		/* bl -34288 */
		/* 8225BE78h case   22:*/		regs.LR = 0x8225BE7C; return 0x82253888;
		/* 8225BE78h case   22:*/		return 0x8225BE7C;
		  /* 8225BE7Ch */ case   23:  		/* lwz R22, <#[R1 + 88]> */
		/* 8225BE7Ch case   23:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8225BE7Ch case   23:*/		return 0x8225BE80;
		  /* 8225BE80h */ case   24:  		/* lbz R23, <#[R1 + 351]> */
		/* 8225BE80h case   24:*/		cpu::mem::load8z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000015F) );
		/* 8225BE80h case   24:*/		return 0x8225BE84;
		  /* 8225BE84h */ case   25:  		/* mr R26, R21 */
		/* 8225BE84h case   25:*/		regs.R26 = regs.R21;
		/* 8225BE84h case   25:*/		return 0x8225BE88;
		  /* 8225BE88h */ case   26:  		/* li R27, 4 */
		/* 8225BE88h case   26:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225BE88h case   26:*/		return 0x8225BE8C;
		  /* 8225BE8Ch */ case   27:  		/* li R24, 1 */
		/* 8225BE8Ch case   27:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8225BE8Ch case   27:*/		return 0x8225BE90;
	}
	return 0x8225BE90;
} // Block from 8225BE20h-8225BE90h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8225BE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BE90);
		  /* 8225BE90h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225BE90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BE90h case    0:*/		return 0x8225BE94;
		  /* 8225BE94h */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225BE94h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225BE94h case    1:*/		return 0x8225BE98;
		  /* 8225BE98h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 8225BE98h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225BEC8;  }
		/* 8225BE98h case    2:*/		return 0x8225BE9C;
		  /* 8225BE9Ch */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225BE9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225BE9Ch case    3:*/		return 0x8225BEA0;
		  /* 8225BEA0h */ case    4:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 8225BEA0h case    4:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 8225BEA0h case    4:*/		return 0x8225BEA4;
		  /* 8225BEA4h */ case    5:  		/* bc 4, CR0_EQ, 28 */
		/* 8225BEA4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8225BEC0;  }
		/* 8225BEA4h case    5:*/		return 0x8225BEA8;
		  /* 8225BEA8h */ case    6:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 8225BEA8h case    6:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 8225BEA8h case    6:*/		return 0x8225BEAC;
		  /* 8225BEACh */ case    7:  		/* bc 4, CR0_EQ, 20 */
		/* 8225BEACh case    7:*/		if ( !regs.CR[0].eq ) { return 0x8225BEC0;  }
		/* 8225BEACh case    7:*/		return 0x8225BEB0;
		  /* 8225BEB0h */ case    8:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 8225BEB0h case    8:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 8225BEB0h case    8:*/		return 0x8225BEB4;
		  /* 8225BEB4h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 8225BEB4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8225BEC0;  }
		/* 8225BEB4h case    9:*/		return 0x8225BEB8;
		  /* 8225BEB8h */ case   10:  		/* rlwinm. R11, R11, 0, 16, 16 */
		/* 8225BEB8h case   10:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R11);
		/* 8225BEB8h case   10:*/		return 0x8225BEBC;
		  /* 8225BEBCh */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 8225BEBCh case   11:*/		if ( regs.CR[0].eq ) { return 0x8225BEC8;  }
		/* 8225BEBCh case   11:*/		return 0x8225BEC0;
	}
	return 0x8225BEC0;
} // Block from 8225BE90h-8225BEC0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225BEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BEC0);
		  /* 8225BEC0h */ case    0:  		/* mr R11, R24 */
		/* 8225BEC0h case    0:*/		regs.R11 = regs.R24;
		/* 8225BEC0h case    0:*/		return 0x8225BEC4;
		  /* 8225BEC4h */ case    1:  		/* b 8 */
		/* 8225BEC4h case    1:*/		return 0x8225BECC;
		/* 8225BEC4h case    1:*/		return 0x8225BEC8;
	}
	return 0x8225BEC8;
} // Block from 8225BEC0h-8225BEC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225BEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BEC8);
		  /* 8225BEC8h */ case    0:  		/* mr R11, R20 */
		/* 8225BEC8h case    0:*/		regs.R11 = regs.R20;
		/* 8225BEC8h case    0:*/		return 0x8225BECC;
	}
	return 0x8225BECC;
} // Block from 8225BEC8h-8225BECCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225BECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BECC);
		  /* 8225BECCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8225BECCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8225BECCh case    0:*/		return 0x8225BED0;
		  /* 8225BED0h */ case    1:  		/* bc 12, CR0_EQ, 464 */
		/* 8225BED0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225C0A0;  }
		/* 8225BED0h case    1:*/		return 0x8225BED4;
		  /* 8225BED4h */ case    2:  		/* mr R3, R19 */
		/* 8225BED4h case    2:*/		regs.R3 = regs.R19;
		/* 8225BED4h case    2:*/		return 0x8225BED8;
		  /* 8225BED8h */ case    3:  		/* bl 45256 */
		/* 8225BED8h case    3:*/		regs.LR = 0x8225BEDC; return 0x82266FA0;
		/* 8225BED8h case    3:*/		return 0x8225BEDC;
		  /* 8225BEDCh */ case    4:  		/* or. R28, R3, R3 */
		/* 8225BEDCh case    4:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 8225BEDCh case    4:*/		return 0x8225BEE0;
		  /* 8225BEE0h */ case    5:  		/* bc 12, CR0_EQ, 448 */
		/* 8225BEE0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8225C0A0;  }
		/* 8225BEE0h case    5:*/		return 0x8225BEE4;
		  /* 8225BEE4h */ case    6:  		/* cmplwi CR6, R28, 34952 */
		/* 8225BEE4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00008888);
		/* 8225BEE4h case    6:*/		return 0x8225BEE8;
		  /* 8225BEE8h */ case    7:  		/* bc 12, CR6_EQ, 440 */
		/* 8225BEE8h case    7:*/		if ( regs.CR[6].eq ) { return 0x8225C0A0;  }
		/* 8225BEE8h case    7:*/		return 0x8225BEEC;
		  /* 8225BEECh */ case    8:  		/* cmpwi CR6, R21, 0 */
		/* 8225BEECh case    8:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8225BEECh case    8:*/		return 0x8225BEF0;
		  /* 8225BEF0h */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 8225BEF0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8225BF08;  }
		/* 8225BEF0h case    9:*/		return 0x8225BEF4;
		  /* 8225BEF4h */ case   10:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225BEF4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BEF4h case   10:*/		return 0x8225BEF8;
		  /* 8225BEF8h */ case   11:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225BEF8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225BEF8h case   11:*/		return 0x8225BEFC;
		  /* 8225BEFCh */ case   12:  		/* addi R11, R11, -1 */
		/* 8225BEFCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225BEFCh case   12:*/		return 0x8225BF00;
		  /* 8225BF00h */ case   13:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225BF00h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225BF00h case   13:*/		return 0x8225BF04;
		  /* 8225BF04h */ case   14:  		/* mr R21, R11 */
		/* 8225BF04h case   14:*/		regs.R21 = regs.R11;
		/* 8225BF04h case   14:*/		return 0x8225BF08;
	}
	return 0x8225BF08;
} // Block from 8225BECCh-8225BF08h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225BF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BF08);
		  /* 8225BF08h */ case    0:  		/* li R3, 49 */
		/* 8225BF08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225BF08h case    0:*/		return 0x8225BF0C;
		  /* 8225BF0Ch */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225BF0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BF0Ch case    1:*/		return 0x8225BF10;
		  /* 8225BF10h */ case    2:  		/* bl -24544 */
		/* 8225BF10h case    2:*/		regs.LR = 0x8225BF14; return 0x82255F30;
		/* 8225BF10h case    2:*/		return 0x8225BF14;
		  /* 8225BF14h */ case    3:  		/* stw R20, <#[R3 + 80]> */
		/* 8225BF14h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225BF14h case    3:*/		return 0x8225BF18;
		  /* 8225BF18h */ case    4:  		/* stw R21, <#[R3 + 56]> */
		/* 8225BF18h case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225BF18h case    4:*/		return 0x8225BF1C;
		  /* 8225BF1Ch */ case    5:  		/* rlwinm R29, R27, 3, 0, 28 */
		/* 8225BF1Ch case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R29,regs.R27);
		/* 8225BF1Ch case    5:*/		return 0x8225BF20;
		  /* 8225BF20h */ case    6:  		/* mr R30, R3 */
		/* 8225BF20h case    6:*/		regs.R30 = regs.R3;
		/* 8225BF20h case    6:*/		return 0x8225BF24;
		  /* 8225BF24h */ case    7:  		/* cmpw CR6, R16, R26 */
		/* 8225BF24h case    7:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225BF24h case    7:*/		return 0x8225BF28;
		  /* 8225BF28h */ case    8:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225BF28h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225BF28h case    8:*/		return 0x8225BF2C;
		  /* 8225BF2Ch */ case    9:  		/* add R11, R11, R29 */
		/* 8225BF2Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225BF2Ch case    9:*/		return 0x8225BF30;
		  /* 8225BF30h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225BF30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225BF30h case   10:*/		return 0x8225BF34;
		  /* 8225BF34h */ case   11:  		/* stw R26, <#[R3 + 60]> */
		/* 8225BF34h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225BF34h case   11:*/		return 0x8225BF38;
		  /* 8225BF38h */ case   12:  		/* stw R11, <#[R3 + 84]> */
		/* 8225BF38h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225BF38h case   12:*/		return 0x8225BF3C;
		  /* 8225BF3Ch */ case   13:  		/* bc 4, CR6_EQ, 40 */
		/* 8225BF3Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8225BF64;  }
		/* 8225BF3Ch case   13:*/		return 0x8225BF40;
		  /* 8225BF40h */ case   14:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225BF40h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225BF40h case   14:*/		return 0x8225BF44;
		  /* 8225BF44h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 8225BF44h case   15:*/		if ( regs.CR[0].eq ) { return 0x8225BF58;  }
		/* 8225BF44h case   15:*/		return 0x8225BF48;
		  /* 8225BF48h */ case   16:  		/* stw R18, <#[R3 + 204]> */
		/* 8225BF48h case   16:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225BF48h case   16:*/		return 0x8225BF4C;
		  /* 8225BF4Ch */ case   17:  		/* lwz R11, <#[R19]> */
		/* 8225BF4Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BF4Ch case   17:*/		return 0x8225BF50;
		  /* 8225BF50h */ case   18:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225BF50h case   18:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225BF50h case   18:*/		return 0x8225BF54;
		  /* 8225BF54h */ case   19:  		/* stw R11, <#[R19]> */
		/* 8225BF54h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BF54h case   19:*/		return 0x8225BF58;
	}
	return 0x8225BF58;
} // Block from 8225BF08h-8225BF58h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8225BF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BF58);
		  /* 8225BF58h */ case    0:  		/* mr R4, R30 */
		/* 8225BF58h case    0:*/		regs.R4 = regs.R30;
		/* 8225BF58h case    0:*/		return 0x8225BF5C;
		  /* 8225BF5Ch */ case    1:  		/* mr R3, R19 */
		/* 8225BF5Ch case    1:*/		regs.R3 = regs.R19;
		/* 8225BF5Ch case    1:*/		return 0x8225BF60;
		  /* 8225BF60h */ case    2:  		/* bl -6104 */
		/* 8225BF60h case    2:*/		regs.LR = 0x8225BF64; return 0x8225A788;
		/* 8225BF60h case    2:*/		return 0x8225BF64;
	}
	return 0x8225BF64;
} // Block from 8225BF58h-8225BF64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225BF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BF64);
		  /* 8225BF64h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8225BF64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BF64h case    0:*/		return 0x8225BF68;
		  /* 8225BF68h */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225BF68h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225BF68h case    1:*/		return 0x8225BF6C;
		  /* 8225BF6Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225BF6Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8225BF7C;  }
		/* 8225BF6Ch case    2:*/		return 0x8225BF70;
		  /* 8225BF70h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225BF70h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225BF70h case    3:*/		return 0x8225BF74;
		  /* 8225BF74h */ case    4:  		/* rlwinm R11, R11, 12, 31, 31 */
		/* 8225BF74h case    4:*/		cpu::op::rlwinm<0,12,31,31>(regs,&regs.R11,regs.R11);
		/* 8225BF74h case    4:*/		return 0x8225BF78;
		  /* 8225BF78h */ case    5:  		/* b 8 */
		/* 8225BF78h case    5:*/		return 0x8225BF80;
		/* 8225BF78h case    5:*/		return 0x8225BF7C;
	}
	return 0x8225BF7C;
} // Block from 8225BF64h-8225BF7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225BF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BF7C);
		  /* 8225BF7Ch */ case    0:  		/* mr R11, R20 */
		/* 8225BF7Ch case    0:*/		regs.R11 = regs.R20;
		/* 8225BF7Ch case    0:*/		return 0x8225BF80;
	}
	return 0x8225BF80;
} // Block from 8225BF7Ch-8225BF80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225BF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BF80);
		  /* 8225BF80h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225BF80h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225BF80h case    0:*/		return 0x8225BF84;
		  /* 8225BF84h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8225BF84h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225BF8C;  }
		/* 8225BF84h case    1:*/		return 0x8225BF88;
		  /* 8225BF88h */ case    2:  		/* stb R24, <#[R30 + 159]> */
		/* 8225BF88h case    2:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R30 + 0x0000009F) );
		/* 8225BF88h case    2:*/		return 0x8225BF8C;
	}
	return 0x8225BF8C;
} // Block from 8225BF80h-8225BF8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225BF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BF8C);
		  /* 8225BF8Ch */ case    0:  		/* mr R4, R30 */
		/* 8225BF8Ch case    0:*/		regs.R4 = regs.R30;
		/* 8225BF8Ch case    0:*/		return 0x8225BF90;
		  /* 8225BF90h */ case    1:  		/* mr R3, R17 */
		/* 8225BF90h case    1:*/		regs.R3 = regs.R17;
		/* 8225BF90h case    1:*/		return 0x8225BF94;
		  /* 8225BF94h */ case    2:  		/* bl -34572 */
		/* 8225BF94h case    2:*/		regs.LR = 0x8225BF98; return 0x82253888;
		/* 8225BF94h case    2:*/		return 0x8225BF98;
		  /* 8225BF98h */ case    3:  		/* li R3, 49 */
		/* 8225BF98h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225BF98h case    3:*/		return 0x8225BF9C;
		  /* 8225BF9Ch */ case    4:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225BF9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225BF9Ch case    4:*/		return 0x8225BFA0;
		  /* 8225BFA0h */ case    5:  		/* lwz R30, <#[R30 + 132]> */
		/* 8225BFA0h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000084) );
		/* 8225BFA0h case    5:*/		return 0x8225BFA4;
		  /* 8225BFA4h */ case    6:  		/* bl -24692 */
		/* 8225BFA4h case    6:*/		regs.LR = 0x8225BFA8; return 0x82255F30;
		/* 8225BFA4h case    6:*/		return 0x8225BFA8;
		  /* 8225BFA8h */ case    7:  		/* stw R21, <#[R3 + 56]> */
		/* 8225BFA8h case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000038) );
		/* 8225BFA8h case    7:*/		return 0x8225BFAC;
		  /* 8225BFACh */ case    8:  		/* mr R4, R3 */
		/* 8225BFACh case    8:*/		regs.R4 = regs.R3;
		/* 8225BFACh case    8:*/		return 0x8225BFB0;
		  /* 8225BFB0h */ case    9:  		/* stw R20, <#[R3 + 80]> */
		/* 8225BFB0h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000050) );
		/* 8225BFB0h case    9:*/		return 0x8225BFB4;
		  /* 8225BFB4h */ case   10:  		/* cmpw CR6, R16, R26 */
		/* 8225BFB4h case   10:*/		cpu::op::cmpw<6>(regs,regs.R16,regs.R26);
		/* 8225BFB4h case   10:*/		return 0x8225BFB8;
		  /* 8225BFB8h */ case   11:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225BFB8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225BFB8h case   11:*/		return 0x8225BFBC;
		  /* 8225BFBCh */ case   12:  		/* add R11, R11, R29 */
		/* 8225BFBCh case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8225BFBCh case   12:*/		return 0x8225BFC0;
		  /* 8225BFC0h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225BFC0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225BFC0h case   13:*/		return 0x8225BFC4;
		  /* 8225BFC4h */ case   14:  		/* stw R26, <#[R3 + 60]> */
		/* 8225BFC4h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225BFC4h case   14:*/		return 0x8225BFC8;
		  /* 8225BFC8h */ case   15:  		/* stw R11, <#[R3 + 84]> */
		/* 8225BFC8h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225BFC8h case   15:*/		return 0x8225BFCC;
		  /* 8225BFCCh */ case   16:  		/* bc 4, CR6_EQ, 32 */
		/* 8225BFCCh case   16:*/		if ( !regs.CR[6].eq ) { return 0x8225BFEC;  }
		/* 8225BFCCh case   16:*/		return 0x8225BFD0;
		  /* 8225BFD0h */ case   17:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225BFD0h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225BFD0h case   17:*/		return 0x8225BFD4;
		  /* 8225BFD4h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 8225BFD4h case   18:*/		if ( regs.CR[0].eq ) { return 0x8225BFE8;  }
		/* 8225BFD4h case   18:*/		return 0x8225BFD8;
		  /* 8225BFD8h */ case   19:  		/* stw R18, <#[R3 + 204]> */
		/* 8225BFD8h case   19:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225BFD8h case   19:*/		return 0x8225BFDC;
		  /* 8225BFDCh */ case   20:  		/* lwz R11, <#[R19]> */
		/* 8225BFDCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BFDCh case   20:*/		return 0x8225BFE0;
		  /* 8225BFE0h */ case   21:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225BFE0h case   21:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225BFE0h case   21:*/		return 0x8225BFE4;
		  /* 8225BFE4h */ case   22:  		/* stw R11, <#[R19]> */
		/* 8225BFE4h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BFE4h case   22:*/		return 0x8225BFE8;
	}
	return 0x8225BFE8;
} // Block from 8225BF8Ch-8225BFE8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8225BFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BFE8);
		  /* 8225BFE8h */ case    0:  		/* stw R30, <#[R4 + 132]> */
		/* 8225BFE8h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R4 + 0x00000084) );
		/* 8225BFE8h case    0:*/		return 0x8225BFEC;
	}
	return 0x8225BFEC;
} // Block from 8225BFE8h-8225BFECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225BFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225BFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225BFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225BFEC);
		  /* 8225BFECh */ case    0:  		/* stb R24, <#[R4 + 153]> */
		/* 8225BFECh case    0:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R4 + 0x00000099) );
		/* 8225BFECh case    0:*/		return 0x8225BFF0;
		  /* 8225BFF0h */ case    1:  		/* lwz R11, <#[R19]> */
		/* 8225BFF0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225BFF0h case    1:*/		return 0x8225BFF4;
		  /* 8225BFF4h */ case    2:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225BFF4h case    2:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225BFF4h case    2:*/		return 0x8225BFF8;
		  /* 8225BFF8h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8225BFF8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8225C008;  }
		/* 8225BFF8h case    3:*/		return 0x8225BFFC;
		  /* 8225BFFCh */ case    4:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225BFFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225BFFCh case    4:*/		return 0x8225C000;
		  /* 8225C000h */ case    5:  		/* rlwinm R11, R11, 12, 31, 31 */
		/* 8225C000h case    5:*/		cpu::op::rlwinm<0,12,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C000h case    5:*/		return 0x8225C004;
		  /* 8225C004h */ case    6:  		/* b 8 */
		/* 8225C004h case    6:*/		return 0x8225C00C;
		/* 8225C004h case    6:*/		return 0x8225C008;
	}
	return 0x8225C008;
} // Block from 8225BFECh-8225C008h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225C008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C008);
		  /* 8225C008h */ case    0:  		/* mr R11, R20 */
		/* 8225C008h case    0:*/		regs.R11 = regs.R20;
		/* 8225C008h case    0:*/		return 0x8225C00C;
	}
	return 0x8225C00C;
} // Block from 8225C008h-8225C00Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225C00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C00C);
		  /* 8225C00Ch */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225C00Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225C00Ch case    0:*/		return 0x8225C010;
		  /* 8225C010h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8225C010h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225C030;  }
		/* 8225C010h case    1:*/		return 0x8225C014;
		  /* 8225C014h */ case    2:  		/* stb R24, <#[R4 + 159]> */
		/* 8225C014h case    2:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R4 + 0x0000009F) );
		/* 8225C014h case    2:*/		return 0x8225C018;
		  /* 8225C018h */ case    3:  		/* lwz R11, <#[R19]> */
		/* 8225C018h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225C018h case    3:*/		return 0x8225C01C;
		  /* 8225C01Ch */ case    4:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225C01Ch case    4:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225C01Ch case    4:*/		return 0x8225C020;
		  /* 8225C020h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8225C020h case    5:*/		if ( regs.CR[0].eq ) { return 0x8225C030;  }
		/* 8225C020h case    5:*/		return 0x8225C024;
		  /* 8225C024h */ case    6:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225C024h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225C024h case    6:*/		return 0x8225C028;
		  /* 8225C028h */ case    7:  		/* rlwinm R11, R11, 0, 12, 10 */
		/* 8225C028h case    7:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R11,regs.R11);
		/* 8225C028h case    7:*/		return 0x8225C02C;
		  /* 8225C02Ch */ case    8:  		/* stw R11, <#[R19 + 4]> */
		/* 8225C02Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225C02Ch case    8:*/		return 0x8225C030;
	}
	return 0x8225C030;
} // Block from 8225C00Ch-8225C030h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225C030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C030);
		  /* 8225C030h */ case    0:  		/* lwz R11, <#[R22 + 100]> */
		/* 8225C030h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000064) );
		/* 8225C030h case    0:*/		return 0x8225C034;
		  /* 8225C034h */ case    1:  		/* nor R10, R28, R28 */
		/* 8225C034h case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R28,regs.R28);
		/* 8225C034h case    1:*/		return 0x8225C038;
		  /* 8225C038h */ case    2:  		/* nor R8, R28, R28 */
		/* 8225C038h case    2:*/		cpu::op::nor<0>(regs,&regs.R8,regs.R28,regs.R28);
		/* 8225C038h case    2:*/		return 0x8225C03C;
		  /* 8225C03Ch */ case    3:  		/* rlwinm R10, R10, 29, 31, 31 */
		/* 8225C03Ch case    3:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R10,regs.R10);
		/* 8225C03Ch case    3:*/		return 0x8225C040;
		  /* 8225C040h */ case    4:  		/* rlwinm R8, R8, 21, 31, 31 */
		/* 8225C040h case    4:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R8,regs.R8);
		/* 8225C040h case    4:*/		return 0x8225C044;
		  /* 8225C044h */ case    5:  		/* nor R9, R28, R28 */
		/* 8225C044h case    5:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R28,regs.R28);
		/* 8225C044h case    5:*/		return 0x8225C048;
		  /* 8225C048h */ case    6:  		/* stw R11, <#[R1 + 92]> */
		/* 8225C048h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225C048h case    6:*/		return 0x8225C04C;
		  /* 8225C04Ch */ case    7:  		/* nor R11, R28, R28 */
		/* 8225C04Ch case    7:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R28,regs.R28);
		/* 8225C04Ch case    7:*/		return 0x8225C050;
		  /* 8225C050h */ case    8:  		/* stb R10, <#[R1 + 92]> */
		/* 8225C050h case    8:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225C050h case    8:*/		return 0x8225C054;
		  /* 8225C054h */ case    9:  		/* rlwinm R9, R9, 25, 31, 31 */
		/* 8225C054h case    9:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R9,regs.R9);
		/* 8225C054h case    9:*/		return 0x8225C058;
		  /* 8225C058h */ case   10:  		/* rlwinm R11, R11, 17, 31, 31 */
		/* 8225C058h case   10:*/		cpu::op::rlwinm<0,17,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C058h case   10:*/		return 0x8225C05C;
		  /* 8225C05Ch */ case   11:  		/* stb R8, <#[R1 + 94]> */
		/* 8225C05Ch case   11:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R1 + 0x0000005E) );
		/* 8225C05Ch case   11:*/		return 0x8225C060;
		  /* 8225C060h */ case   12:  		/* stb R9, <#[R1 + 93]> */
		/* 8225C060h case   12:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x0000005D) );
		/* 8225C060h case   12:*/		return 0x8225C064;
		  /* 8225C064h */ case   13:  		/* mr R3, R17 */
		/* 8225C064h case   13:*/		regs.R3 = regs.R17;
		/* 8225C064h case   13:*/		return 0x8225C068;
		  /* 8225C068h */ case   14:  		/* stb R11, <#[R1 + 95]> */
		/* 8225C068h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000005F) );
		/* 8225C068h case   14:*/		return 0x8225C06C;
		  /* 8225C06Ch */ case   15:  		/* lwz R11, <#[R1 + 92]> */
		/* 8225C06Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225C06Ch case   15:*/		return 0x8225C070;
		  /* 8225C070h */ case   16:  		/* stw R11, <#[R4 + 128]> */
		/* 8225C070h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000080) );
		/* 8225C070h case   16:*/		return 0x8225C074;
		  /* 8225C074h */ case   17:  		/* bl -34796 */
		/* 8225C074h case   17:*/		regs.LR = 0x8225C078; return 0x82253888;
		/* 8225C074h case   17:*/		return 0x8225C078;
		  /* 8225C078h */ case   18:  		/* lwz R11, <#[R19]> */
		/* 8225C078h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225C078h case   18:*/		return 0x8225C07C;
		  /* 8225C07Ch */ case   19:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225C07Ch case   19:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225C07Ch case   19:*/		return 0x8225C080;
		  /* 8225C080h */ case   20:  		/* bc 12, CR0_EQ, 24 */
		/* 8225C080h case   20:*/		if ( regs.CR[0].eq ) { return 0x8225C098;  }
		/* 8225C080h case   20:*/		return 0x8225C084;
		  /* 8225C084h */ case   21:  		/* lis R12, -1 */
		/* 8225C084h case   21:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFFF);
		/* 8225C084h case   21:*/		return 0x8225C088;
		  /* 8225C088h */ case   22:  		/* lwz R11, <#[R19 + 4]> */
		/* 8225C088h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225C088h case   22:*/		return 0x8225C08C;
		  /* 8225C08Ch */ case   23:  		/* ori R12, R12, 30583 */
		/* 8225C08Ch case   23:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x7777);
		/* 8225C08Ch case   23:*/		return 0x8225C090;
		  /* 8225C090h */ case   24:  		/* and R11, R11, R12 */
		/* 8225C090h case   24:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8225C090h case   24:*/		return 0x8225C094;
		  /* 8225C094h */ case   25:  		/* stw R11, <#[R19 + 4]> */
		/* 8225C094h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8225C094h case   25:*/		return 0x8225C098;
	}
	return 0x8225C098;
} // Block from 8225C030h-8225C098h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225C098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C098);
		  /* 8225C098h */ case    0:  		/* mr R26, R21 */
		/* 8225C098h case    0:*/		regs.R26 = regs.R21;
		/* 8225C098h case    0:*/		return 0x8225C09C;
		  /* 8225C09Ch */ case    1:  		/* li R27, 4 */
		/* 8225C09Ch case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225C09Ch case    1:*/		return 0x8225C0A0;
	}
	return 0x8225C0A0;
} // Block from 8225C098h-8225C0A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225C0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C0A0);
		  /* 8225C0A0h */ case    0:  		/* sth R26, <#[R19 + 2]> */
		/* 8225C0A0h case    0:*/		cpu::mem::store16( regs, regs.R26, (uint32)(regs.R19 + 0x00000002) );
		/* 8225C0A0h case    0:*/		return 0x8225C0A4;
		  /* 8225C0A4h */ case    1:  		/* lwz R11, <#[R19]> */
		/* 8225C0A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225C0A4h case    1:*/		return 0x8225C0A8;
		  /* 8225C0A8h */ case    2:  		/* rlwimi R11, R27, 16, 10, 15 */
		/* 8225C0A8h case    2:*/		cpu::op::rlwimi<0,16,10,15>(regs,&regs.R11,regs.R27);
		/* 8225C0A8h case    2:*/		return 0x8225C0AC;
		  /* 8225C0ACh */ case    3:  		/* stw R11, <#[R19]> */
		/* 8225C0ACh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8225C0ACh case    3:*/		return 0x8225C0B0;
		  /* 8225C0B0h */ case    4:  		/* addi R1, R1, 288 */
		/* 8225C0B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8225C0B0h case    4:*/		return 0x8225C0B4;
		  /* 8225C0B4h */ case    5:  		/* addi R12, R1, -152 */
		/* 8225C0B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 8225C0B4h case    5:*/		return 0x8225C0B8;
		  /* 8225C0B8h */ case    6:  		/* bl -1879128 */
		/* 8225C0B8h case    6:*/		regs.LR = 0x8225C0BC; return 0x82091460;
		/* 8225C0B8h case    6:*/		return 0x8225C0BC;
		  /* 8225C0BCh */ case    7:  		/* b -1879628 */
		/* 8225C0BCh case    7:*/		return 0x82091270;
		/* 8225C0BCh case    7:*/		return 0x8225C0C0;
	}
	return 0x8225C0C0;
} // Block from 8225C0A0h-8225C0C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225C0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C0C0);
		  /* 8225C0C0h */ case    0:  		/* mfspr R12, LR */
		/* 8225C0C0h case    0:*/		regs.R12 = regs.LR;
		/* 8225C0C0h case    0:*/		return 0x8225C0C4;
		  /* 8225C0C4h */ case    1:  		/* bl -1879704 */
		/* 8225C0C4h case    1:*/		regs.LR = 0x8225C0C8; return 0x8209122C;
		/* 8225C0C4h case    1:*/		return 0x8225C0C8;
		  /* 8225C0C8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8225C0C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8225C0C8h case    2:*/		return 0x8225C0CC;
		  /* 8225C0CCh */ case    3:  		/* lwz R11, <#[R5]> */
		/* 8225C0CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8225C0CCh case    3:*/		return 0x8225C0D0;
		  /* 8225C0D0h */ case    4:  		/* li R23, 0 */
		/* 8225C0D0h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8225C0D0h case    4:*/		return 0x8225C0D4;
		  /* 8225C0D4h */ case    5:  		/* mr R29, R3 */
		/* 8225C0D4h case    5:*/		regs.R29 = regs.R3;
		/* 8225C0D4h case    5:*/		return 0x8225C0D8;
		  /* 8225C0D8h */ case    6:  		/* mr R24, R4 */
		/* 8225C0D8h case    6:*/		regs.R24 = regs.R4;
		/* 8225C0D8h case    6:*/		return 0x8225C0DC;
		  /* 8225C0DCh */ case    7:  		/* mr R26, R5 */
		/* 8225C0DCh case    7:*/		regs.R26 = regs.R5;
		/* 8225C0DCh case    7:*/		return 0x8225C0E0;
		  /* 8225C0E0h */ case    8:  		/* mr R17, R6 */
		/* 8225C0E0h case    8:*/		regs.R17 = regs.R6;
		/* 8225C0E0h case    8:*/		return 0x8225C0E4;
		  /* 8225C0E4h */ case    9:  		/* rlwinm. R9, R11, 0, 9, 9 */
		/* 8225C0E4h case    9:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R9,regs.R11);
		/* 8225C0E4h case    9:*/		return 0x8225C0E8;
		  /* 8225C0E8h */ case   10:  		/* mr R31, R23 */
		/* 8225C0E8h case   10:*/		regs.R31 = regs.R23;
		/* 8225C0E8h case   10:*/		return 0x8225C0EC;
		  /* 8225C0ECh */ case   11:  		/* mr R27, R23 */
		/* 8225C0ECh case   11:*/		regs.R27 = regs.R23;
		/* 8225C0ECh case   11:*/		return 0x8225C0F0;
		  /* 8225C0F0h */ case   12:  		/* extsh R18, R11 */
		/* 8225C0F0h case   12:*/		cpu::op::extsh<0>(regs,&regs.R18,regs.R11);
		/* 8225C0F0h case   12:*/		return 0x8225C0F4;
		  /* 8225C0F4h */ case   13:  		/* rlwinm R19, R11, 16, 26, 31 */
		/* 8225C0F4h case   13:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R19,regs.R11);
		/* 8225C0F4h case   13:*/		return 0x8225C0F8;
		  /* 8225C0F8h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 8225C0F8h case   14:*/		if ( regs.CR[0].eq ) { return 0x8225C108;  }
		/* 8225C0F8h case   14:*/		return 0x8225C0FC;
		  /* 8225C0FCh */ case   15:  		/* lwz R11, <#[R5 + 4]> */
		/* 8225C0FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 8225C0FCh case   15:*/		return 0x8225C100;
		  /* 8225C100h */ case   16:  		/* rlwinm R28, R11, 23, 28, 31 */
		/* 8225C100h case   16:*/		cpu::op::rlwinm<0,23,28,31>(regs,&regs.R28,regs.R11);
		/* 8225C100h case   16:*/		return 0x8225C104;
		  /* 8225C104h */ case   17:  		/* b 8 */
		/* 8225C104h case   17:*/		return 0x8225C10C;
		/* 8225C104h case   17:*/		return 0x8225C108;
	}
	return 0x8225C108;
} // Block from 8225C0C0h-8225C108h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225C108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C108);
		  /* 8225C108h */ case    0:  		/* mr R28, R23 */
		/* 8225C108h case    0:*/		regs.R28 = regs.R23;
		/* 8225C108h case    0:*/		return 0x8225C10C;
	}
	return 0x8225C10C;
} // Block from 8225C108h-8225C10Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225C10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C10C);
		  /* 8225C10Ch */ case    0:  		/* lis R11, -32253 */
		/* 8225C10Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8225C10Ch case    0:*/		return 0x8225C110;
		  /* 8225C110h */ case    1:  		/* lis R10, -32251 */
		/* 8225C110h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225C110h case    1:*/		return 0x8225C114;
		  /* 8225C114h */ case    2:  		/* li R20, 1 */
		/* 8225C114h case    2:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 8225C114h case    2:*/		return 0x8225C118;
		  /* 8225C118h */ case    3:  		/* cmpwi CR6, R28, 0 */
		/* 8225C118h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8225C118h case    3:*/		return 0x8225C11C;
		  /* 8225C11Ch */ case    4:  		/* addi R22, R11, 27460 */
		/* 8225C11Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R11,0x6B44);
		/* 8225C11Ch case    4:*/		return 0x8225C120;
		  /* 8225C120h */ case    5:  		/* addi R21, R10, -21904 */
		/* 8225C120h case    5:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R10,0xFFFFAA70);
		/* 8225C120h case    5:*/		return 0x8225C124;
		  /* 8225C124h */ case    6:  		/* bc 4, CR6_GT, 164 */
		/* 8225C124h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8225C1C8;  }
		/* 8225C124h case    6:*/		return 0x8225C128;
		  /* 8225C128h */ case    7:  		/* cmpwi CR6, R28, 6 */
		/* 8225C128h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000006);
		/* 8225C128h case    7:*/		return 0x8225C12C;
		  /* 8225C12Ch */ case    8:  		/* bc 4, CR6_GT, 32 */
		/* 8225C12Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x8225C14C;  }
		/* 8225C12Ch case    8:*/		return 0x8225C130;
		  /* 8225C130h */ case    9:  		/* lis R11, -32251 */
		/* 8225C130h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C130h case    9:*/		return 0x8225C134;
		  /* 8225C134h */ case   10:  		/* mr R6, R21 */
		/* 8225C134h case   10:*/		regs.R6 = regs.R21;
		/* 8225C134h case   10:*/		return 0x8225C138;
		  /* 8225C138h */ case   11:  		/* addi R5, R11, -20488 */
		/* 8225C138h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAFF8);
		/* 8225C138h case   11:*/		return 0x8225C13C;
		  /* 8225C13Ch */ case   12:  		/* mr R4, R22 */
		/* 8225C13Ch case   12:*/		regs.R4 = regs.R22;
		/* 8225C13Ch case   12:*/		return 0x8225C140;
		  /* 8225C140h */ case   13:  		/* li R7, 871 */
		/* 8225C140h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x367);
		/* 8225C140h case   13:*/		return 0x8225C144;
		  /* 8225C144h */ case   14:  		/* li R3, 0 */
		/* 8225C144h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C144h case   14:*/		return 0x8225C148;
		  /* 8225C148h */ case   15:  		/* bl -1066304 */
		/* 8225C148h case   15:*/		regs.LR = 0x8225C14C; return 0x82157C08;
		/* 8225C148h case   15:*/		return 0x8225C14C;
	}
	return 0x8225C14C;
} // Block from 8225C10Ch-8225C14Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225C14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C14C);
		  /* 8225C14Ch */ case    0:  		/* lwz R10, <#[R29 + 12]> */
		/* 8225C14Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C14Ch case    0:*/		return 0x8225C150;
		  /* 8225C150h */ case    1:  		/* li R3, 19 */
		/* 8225C150h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 8225C150h case    1:*/		return 0x8225C154;
		  /* 8225C154h */ case    2:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225C154h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C154h case    2:*/		return 0x8225C158;
		  /* 8225C158h */ case    3:  		/* addi R30, R11, -1 */
		/* 8225C158h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 8225C158h case    3:*/		return 0x8225C15C;
		  /* 8225C15Ch */ case    4:  		/* stw R30, <#[R10 + 1508]> */
		/* 8225C15Ch case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C15Ch case    4:*/		return 0x8225C160;
		  /* 8225C160h */ case    5:  		/* mr R27, R30 */
		/* 8225C160h case    5:*/		regs.R27 = regs.R30;
		/* 8225C160h case    5:*/		return 0x8225C164;
		  /* 8225C164h */ case    6:  		/* sth R30, <#[R26 + 2]> */
		/* 8225C164h case    6:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R26 + 0x00000002) );
		/* 8225C164h case    6:*/		return 0x8225C168;
		  /* 8225C168h */ case    7:  		/* lwz R11, <#[R26]> */
		/* 8225C168h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C168h case    7:*/		return 0x8225C16C;
		  /* 8225C16Ch */ case    8:  		/* rlwimi R11, R20, 18, 10, 15 */
		/* 8225C16Ch case    8:*/		cpu::op::rlwimi<0,18,10,15>(regs,&regs.R11,regs.R20);
		/* 8225C16Ch case    8:*/		return 0x8225C170;
		  /* 8225C170h */ case    9:  		/* stw R11, <#[R26]> */
		/* 8225C170h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C170h case    9:*/		return 0x8225C174;
		  /* 8225C174h */ case   10:  		/* lwz R4, <#[R29 + 12]> */
		/* 8225C174h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C174h case   10:*/		return 0x8225C178;
		  /* 8225C178h */ case   11:  		/* bl -25160 */
		/* 8225C178h case   11:*/		regs.LR = 0x8225C17C; return 0x82255F30;
		/* 8225C178h case   11:*/		return 0x8225C17C;
		  /* 8225C17Ch */ case   12:  		/* stw R30, <#[R3 + 56]> */
		/* 8225C17Ch case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000038) );
		/* 8225C17Ch case   12:*/		return 0x8225C180;
		  /* 8225C180h */ case   13:  		/* stw R30, <#[R3 + 60]> */
		/* 8225C180h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225C180h case   13:*/		return 0x8225C184;
		  /* 8225C184h */ case   14:  		/* lis R11, -32251 */
		/* 8225C184h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C184h case   14:*/		return 0x8225C188;
		  /* 8225C188h */ case   15:  		/* stw R23, <#[R3 + 80]> */
		/* 8225C188h case   15:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000050) );
		/* 8225C188h case   15:*/		return 0x8225C18C;
		  /* 8225C18Ch */ case   16:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 8225C18Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 8225C18Ch case   16:*/		return 0x8225C190;
		  /* 8225C190h */ case   17:  		/* stw R23, <#[R3 + 84]> */
		/* 8225C190h case   17:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000054) );
		/* 8225C190h case   17:*/		return 0x8225C194;
		  /* 8225C194h */ case   18:  		/* addi R11, R11, -31560 */
		/* 8225C194h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF84B8);
		/* 8225C194h case   18:*/		return 0x8225C198;
		  /* 8225C198h */ case   19:  		/* li R5, 2 */
		/* 8225C198h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225C198h case   19:*/		return 0x8225C19C;
		  /* 8225C19Ch */ case   20:  		/* add R11, R10, R11 */
		/* 8225C19Ch case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225C19Ch case   20:*/		return 0x8225C1A0;
		  /* 8225C1A0h */ case   21:  		/* mr R4, R29 */
		/* 8225C1A0h case   21:*/		regs.R4 = regs.R29;
		/* 8225C1A0h case   21:*/		return 0x8225C1A4;
		  /* 8225C1A4h */ case   22:  		/* mr R31, R3 */
		/* 8225C1A4h case   22:*/		regs.R31 = regs.R3;
		/* 8225C1A4h case   22:*/		return 0x8225C1A8;
		  /* 8225C1A8h */ case   23:  		/* lfs FR1, <#[R11 - 4]> */
		/* 8225C1A8h case   23:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8225C1A8h case   23:*/		return 0x8225C1AC;
		  /* 8225C1ACh */ case   24:  		/* fmr FR4, FR1 */
		/* 8225C1ACh case   24:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR1);
		/* 8225C1ACh case   24:*/		return 0x8225C1B0;
		  /* 8225C1B0h */ case   25:  		/* fmr FR3, FR1 */
		/* 8225C1B0h case   25:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR1);
		/* 8225C1B0h case   25:*/		return 0x8225C1B4;
		  /* 8225C1B4h */ case   26:  		/* fmr FR2, FR1 */
		/* 8225C1B4h case   26:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 8225C1B4h case   26:*/		return 0x8225C1B8;
		  /* 8225C1B8h */ case   27:  		/* bl -21152 */
		/* 8225C1B8h case   27:*/		regs.LR = 0x8225C1BC; return 0x82256F18;
		/* 8225C1B8h case   27:*/		return 0x8225C1BC;
		  /* 8225C1BCh */ case   28:  		/* mr R4, R31 */
		/* 8225C1BCh case   28:*/		regs.R4 = regs.R31;
		/* 8225C1BCh case   28:*/		return 0x8225C1C0;
		  /* 8225C1C0h */ case   29:  		/* mr R3, R24 */
		/* 8225C1C0h case   29:*/		regs.R3 = regs.R24;
		/* 8225C1C0h case   29:*/		return 0x8225C1C4;
		  /* 8225C1C4h */ case   30:  		/* bl -35132 */
		/* 8225C1C4h case   30:*/		regs.LR = 0x8225C1C8; return 0x82253888;
		/* 8225C1C4h case   30:*/		return 0x8225C1C8;
	}
	return 0x8225C1C8;
} // Block from 8225C14Ch-8225C1C8h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8225C1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C1C8);
		  /* 8225C1C8h */ case    0:  		/* mr R28, R23 */
		/* 8225C1C8h case    0:*/		regs.R28 = regs.R23;
		/* 8225C1C8h case    0:*/		return 0x8225C1CC;
		  /* 8225C1CCh */ case    1:  		/* mr R30, R23 */
		/* 8225C1CCh case    1:*/		regs.R30 = regs.R23;
		/* 8225C1CCh case    1:*/		return 0x8225C1D0;
		  /* 8225C1D0h */ case    2:  		/* mr R4, R30 */
		/* 8225C1D0h case    2:*/		regs.R4 = regs.R30;
		/* 8225C1D0h case    2:*/		return 0x8225C1D4;
		  /* 8225C1D4h */ case    3:  		/* mr R3, R26 */
		/* 8225C1D4h case    3:*/		regs.R3 = regs.R26;
		/* 8225C1D4h case    3:*/		return 0x8225C1D8;
		  /* 8225C1D8h */ case    4:  		/* bl 44240 */
		/* 8225C1D8h case    4:*/		regs.LR = 0x8225C1DC; return 0x82266EA8;
		/* 8225C1D8h case    4:*/		return 0x8225C1DC;
		  /* 8225C1DCh */ case    5:  		/* addi R11, R3, -2 */
		/* 8225C1DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFE);
		/* 8225C1DCh case    5:*/		return 0x8225C1E0;
		  /* 8225C1E0h */ case    6:  		/* cntlzw R11, R11 */
		/* 8225C1E0h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225C1E0h case    6:*/		return 0x8225C1E4;
		  /* 8225C1E4h */ case    7:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8225C1E4h case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C1E4h case    7:*/		return 0x8225C1E8;
		  /* 8225C1E8h */ case    8:  		/* slw R11, R11, R30 */
		/* 8225C1E8h case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8225C1E8h case    8:*/		return 0x8225C1EC;
		  /* 8225C1ECh */ case    9:  		/* addi R30, R30, 1 */
		/* 8225C1ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225C1ECh case    9:*/		return 0x8225C1F0;
		  /* 8225C1F0h */ case   10:  		/* or R28, R11, R28 */
		/* 8225C1F0h case   10:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 8225C1F0h case   10:*/		return 0x8225C1F4;
		  /* 8225C1F4h */ case   11:  		/* cmpwi CR6, R30, 4 */
		/* 8225C1F4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225C1F4h case   11:*/		return 0x8225C1F8;
		  /* 8225C1F8h */ case   12:  		/* bc 12, CR6_LT, -40 */
		/* 8225C1F8h case   12:*/		if ( regs.CR[6].lt ) { return 0x8225C1D0;  }
		/* 8225C1F8h case   12:*/		return 0x8225C1FC;
		  /* 8225C1FCh */ case   13:  		/* lis R11, -32251 */
		/* 8225C1FCh case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C1FCh case   13:*/		return 0x8225C200;
		  /* 8225C200h */ case   14:  		/* cmpwi CR6, R28, 0 */
		/* 8225C200h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8225C200h case   14:*/		return 0x8225C204;
		  /* 8225C204h */ case   15:  		/* addi R25, R11, -20508 */
		/* 8225C204h case   15:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFAFE4);
		/* 8225C204h case   15:*/		return 0x8225C208;
		  /* 8225C208h */ case   16:  		/* bc 12, CR6_EQ, 212 */
		/* 8225C208h case   16:*/		if ( regs.CR[6].eq ) { return 0x8225C2DC;  }
		/* 8225C208h case   16:*/		return 0x8225C20C;
		  /* 8225C20Ch */ case   17:  		/* cmplwi CR6, R31, 0 */
		/* 8225C20Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225C20Ch case   17:*/		return 0x8225C210;
		  /* 8225C210h */ case   18:  		/* bc 4, CR6_EQ, 72 */
		/* 8225C210h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8225C258;  }
		/* 8225C210h case   18:*/		return 0x8225C214;
		  /* 8225C214h */ case   19:  		/* cmpwi CR6, R27, 0 */
		/* 8225C214h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8225C214h case   19:*/		return 0x8225C218;
		  /* 8225C218h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 8225C218h case   20:*/		if ( regs.CR[6].eq ) { return 0x8225C234;  }
		/* 8225C218h case   20:*/		return 0x8225C21C;
		  /* 8225C21Ch */ case   21:  		/* mr R6, R21 */
		/* 8225C21Ch case   21:*/		regs.R6 = regs.R21;
		/* 8225C21Ch case   21:*/		return 0x8225C220;
		  /* 8225C220h */ case   22:  		/* mr R5, R25 */
		/* 8225C220h case   22:*/		regs.R5 = regs.R25;
		/* 8225C220h case   22:*/		return 0x8225C224;
		  /* 8225C224h */ case   23:  		/* mr R4, R22 */
		/* 8225C224h case   23:*/		regs.R4 = regs.R22;
		/* 8225C224h case   23:*/		return 0x8225C228;
		  /* 8225C228h */ case   24:  		/* li R7, 895 */
		/* 8225C228h case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x37F);
		/* 8225C228h case   24:*/		return 0x8225C22C;
		  /* 8225C22Ch */ case   25:  		/* li R3, 0 */
		/* 8225C22Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C22Ch case   25:*/		return 0x8225C230;
		  /* 8225C230h */ case   26:  		/* bl -1066536 */
		/* 8225C230h case   26:*/		regs.LR = 0x8225C234; return 0x82157C08;
		/* 8225C230h case   26:*/		return 0x8225C234;
	}
	return 0x8225C234;
} // Block from 8225C1C8h-8225C234h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8225C234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C234);
		  /* 8225C234h */ case    0:  		/* lwz R10, <#[R29 + 12]> */
		/* 8225C234h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C234h case    0:*/		return 0x8225C238;
		  /* 8225C238h */ case    1:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225C238h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C238h case    1:*/		return 0x8225C23C;
		  /* 8225C23Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 8225C23Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225C23Ch case    2:*/		return 0x8225C240;
		  /* 8225C240h */ case    3:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225C240h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C240h case    3:*/		return 0x8225C244;
		  /* 8225C244h */ case    4:  		/* mr R27, R11 */
		/* 8225C244h case    4:*/		regs.R27 = regs.R11;
		/* 8225C244h case    4:*/		return 0x8225C248;
		  /* 8225C248h */ case    5:  		/* sth R11, <#[R26 + 2]> */
		/* 8225C248h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R26 + 0x00000002) );
		/* 8225C248h case    5:*/		return 0x8225C24C;
		  /* 8225C24Ch */ case    6:  		/* lwz R11, <#[R26]> */
		/* 8225C24Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C24Ch case    6:*/		return 0x8225C250;
		  /* 8225C250h */ case    7:  		/* rlwimi R11, R20, 18, 10, 15 */
		/* 8225C250h case    7:*/		cpu::op::rlwimi<0,18,10,15>(regs,&regs.R11,regs.R20);
		/* 8225C250h case    7:*/		return 0x8225C254;
		  /* 8225C254h */ case    8:  		/* stw R11, <#[R26]> */
		/* 8225C254h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C254h case    8:*/		return 0x8225C258;
	}
	return 0x8225C258;
} // Block from 8225C234h-8225C258h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225C258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C258);
		  /* 8225C258h */ case    0:  		/* li R3, 49 */
		/* 8225C258h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225C258h case    0:*/		return 0x8225C25C;
		  /* 8225C25Ch */ case    1:  		/* lwz R4, <#[R29 + 12]> */
		/* 8225C25Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C25Ch case    1:*/		return 0x8225C260;
		  /* 8225C260h */ case    2:  		/* bl -25392 */
		/* 8225C260h case    2:*/		regs.LR = 0x8225C264; return 0x82255F30;
		/* 8225C260h case    2:*/		return 0x8225C264;
		  /* 8225C264h */ case    3:  		/* stw R27, <#[R3 + 56]> */
		/* 8225C264h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000038) );
		/* 8225C264h case    3:*/		return 0x8225C268;
		  /* 8225C268h */ case    4:  		/* stw R23, <#[R3 + 80]> */
		/* 8225C268h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000050) );
		/* 8225C268h case    4:*/		return 0x8225C26C;
		  /* 8225C26Ch */ case    5:  		/* lis R11, -32256 */
		/* 8225C26Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225C26Ch case    5:*/		return 0x8225C270;
		  /* 8225C270h */ case    6:  		/* li R5, 1 */
		/* 8225C270h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225C270h case    6:*/		return 0x8225C274;
		  /* 8225C274h */ case    7:  		/* mr R4, R29 */
		/* 8225C274h case    7:*/		regs.R4 = regs.R29;
		/* 8225C274h case    7:*/		return 0x8225C278;
		  /* 8225C278h */ case    8:  		/* mr R31, R3 */
		/* 8225C278h case    8:*/		regs.R31 = regs.R3;
		/* 8225C278h case    8:*/		return 0x8225C27C;
		  /* 8225C27Ch */ case    9:  		/* lfs FR4, <#[R11 + 1816]> */
		/* 8225C27Ch case    9:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000718) );
		/* 8225C27Ch case    9:*/		return 0x8225C280;
		  /* 8225C280h */ case   10:  		/* fmr FR3, FR4 */
		/* 8225C280h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225C280h case   10:*/		return 0x8225C284;
		  /* 8225C284h */ case   11:  		/* fmr FR2, FR4 */
		/* 8225C284h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225C284h case   11:*/		return 0x8225C288;
		  /* 8225C288h */ case   12:  		/* fmr FR1, FR4 */
		/* 8225C288h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225C288h case   12:*/		return 0x8225C28C;
		  /* 8225C28Ch */ case   13:  		/* bl -21364 */
		/* 8225C28Ch case   13:*/		regs.LR = 0x8225C290; return 0x82256F18;
		/* 8225C28Ch case   13:*/		return 0x8225C290;
		  /* 8225C290h */ case   14:  		/* mr R30, R23 */
		/* 8225C290h case   14:*/		regs.R30 = regs.R23;
		/* 8225C290h case   14:*/		return 0x8225C294;
		  /* 8225C294h */ case   15:  		/* sraw R11, R28, R30 */
		/* 8225C294h case   15:*/		cpu::op::sraw<0>(regs,&regs.R11,regs.R28,regs.R30);
		/* 8225C294h case   15:*/		return 0x8225C298;
		  /* 8225C298h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8225C298h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C298h case   16:*/		return 0x8225C29C;
		  /* 8225C29Ch */ case   17:  		/* lwz R11, <#[R31]> */
		/* 8225C29Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225C29Ch case   17:*/		return 0x8225C2A0;
		  /* 8225C2A0h */ case   18:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225C2A0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225C2A0h case   18:*/		return 0x8225C2A4;
		  /* 8225C2A4h */ case   19:  		/* mr R5, R30 */
		/* 8225C2A4h case   19:*/		regs.R5 = regs.R30;
		/* 8225C2A4h case   19:*/		return 0x8225C2A8;
		  /* 8225C2A8h */ case   20:  		/* li R4, 0 */
		/* 8225C2A8h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225C2A8h case   20:*/		return 0x8225C2AC;
		  /* 8225C2ACh */ case   21:  		/* mr R3, R31 */
		/* 8225C2ACh case   21:*/		regs.R3 = regs.R31;
		/* 8225C2ACh case   21:*/		return 0x8225C2B0;
		  /* 8225C2B0h */ case   22:  		/* li R6, 0 */
		/* 8225C2B0h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225C2B0h case   22:*/		return 0x8225C2B4;
		  /* 8225C2B4h */ case   23:  		/* mtspr CTR, R11 */
		/* 8225C2B4h case   23:*/		regs.CTR = regs.R11;
		/* 8225C2B4h case   23:*/		return 0x8225C2B8;
		  /* 8225C2B8h */ case   24:  		/* bc 4, CR0_EQ, 8 */
		/* 8225C2B8h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8225C2C0;  }
		/* 8225C2B8h case   24:*/		return 0x8225C2BC;
		  /* 8225C2BCh */ case   25:  		/* li R6, 1 */
		/* 8225C2BCh case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225C2BCh case   25:*/		return 0x8225C2C0;
	}
	return 0x8225C2C0;
} // Block from 8225C258h-8225C2C0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225C2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C2C0);
		  /* 8225C2C0h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 8225C2C0h case    0:*/		if ( 1 ) { regs.LR = 0x8225C2C4; return (uint32)regs.CTR; }
		/* 8225C2C0h case    0:*/		return 0x8225C2C4;
		  /* 8225C2C4h */ case    1:  		/* addi R30, R30, 1 */
		/* 8225C2C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225C2C4h case    1:*/		return 0x8225C2C8;
		  /* 8225C2C8h */ case    2:  		/* cmpwi CR6, R30, 4 */
		/* 8225C2C8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225C2C8h case    2:*/		return 0x8225C2CC;
		  /* 8225C2CCh */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 8225C2CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8225C294;  }
		/* 8225C2CCh case    3:*/		return 0x8225C2D0;
		  /* 8225C2D0h */ case    4:  		/* mr R4, R31 */
		/* 8225C2D0h case    4:*/		regs.R4 = regs.R31;
		/* 8225C2D0h case    4:*/		return 0x8225C2D4;
		  /* 8225C2D4h */ case    5:  		/* mr R3, R24 */
		/* 8225C2D4h case    5:*/		regs.R3 = regs.R24;
		/* 8225C2D4h case    5:*/		return 0x8225C2D8;
		  /* 8225C2D8h */ case    6:  		/* bl -35408 */
		/* 8225C2D8h case    6:*/		regs.LR = 0x8225C2DC; return 0x82253888;
		/* 8225C2D8h case    6:*/		return 0x8225C2DC;
	}
	return 0x8225C2DC;
} // Block from 8225C2C0h-8225C2DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225C2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C2DC);
		  /* 8225C2DCh */ case    0:  		/* mr R28, R23 */
		/* 8225C2DCh case    0:*/		regs.R28 = regs.R23;
		/* 8225C2DCh case    0:*/		return 0x8225C2E0;
		  /* 8225C2E0h */ case    1:  		/* mr R30, R23 */
		/* 8225C2E0h case    1:*/		regs.R30 = regs.R23;
		/* 8225C2E0h case    1:*/		return 0x8225C2E4;
		  /* 8225C2E4h */ case    2:  		/* mr R4, R30 */
		/* 8225C2E4h case    2:*/		regs.R4 = regs.R30;
		/* 8225C2E4h case    2:*/		return 0x8225C2E8;
		  /* 8225C2E8h */ case    3:  		/* mr R3, R26 */
		/* 8225C2E8h case    3:*/		regs.R3 = regs.R26;
		/* 8225C2E8h case    3:*/		return 0x8225C2EC;
		  /* 8225C2ECh */ case    4:  		/* bl 43964 */
		/* 8225C2ECh case    4:*/		regs.LR = 0x8225C2F0; return 0x82266EA8;
		/* 8225C2ECh case    4:*/		return 0x8225C2F0;
		  /* 8225C2F0h */ case    5:  		/* addi R11, R3, -3 */
		/* 8225C2F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFD);
		/* 8225C2F0h case    5:*/		return 0x8225C2F4;
		  /* 8225C2F4h */ case    6:  		/* cntlzw R11, R11 */
		/* 8225C2F4h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8225C2F4h case    6:*/		return 0x8225C2F8;
		  /* 8225C2F8h */ case    7:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8225C2F8h case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C2F8h case    7:*/		return 0x8225C2FC;
		  /* 8225C2FCh */ case    8:  		/* slw R11, R11, R30 */
		/* 8225C2FCh case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8225C2FCh case    8:*/		return 0x8225C300;
		  /* 8225C300h */ case    9:  		/* addi R30, R30, 1 */
		/* 8225C300h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225C300h case    9:*/		return 0x8225C304;
		  /* 8225C304h */ case   10:  		/* or R28, R11, R28 */
		/* 8225C304h case   10:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 8225C304h case   10:*/		return 0x8225C308;
		  /* 8225C308h */ case   11:  		/* cmpwi CR6, R30, 4 */
		/* 8225C308h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225C308h case   11:*/		return 0x8225C30C;
		  /* 8225C30Ch */ case   12:  		/* bc 12, CR6_LT, -40 */
		/* 8225C30Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x8225C2E4;  }
		/* 8225C30Ch case   12:*/		return 0x8225C310;
		  /* 8225C310h */ case   13:  		/* cmpwi CR6, R28, 0 */
		/* 8225C310h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8225C310h case   13:*/		return 0x8225C314;
		  /* 8225C314h */ case   14:  		/* bc 12, CR6_EQ, 212 */
		/* 8225C314h case   14:*/		if ( regs.CR[6].eq ) { return 0x8225C3E8;  }
		/* 8225C314h case   14:*/		return 0x8225C318;
		  /* 8225C318h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 8225C318h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225C318h case   15:*/		return 0x8225C31C;
		  /* 8225C31Ch */ case   16:  		/* bc 4, CR6_EQ, 72 */
		/* 8225C31Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x8225C364;  }
		/* 8225C31Ch case   16:*/		return 0x8225C320;
		  /* 8225C320h */ case   17:  		/* cmpwi CR6, R27, 0 */
		/* 8225C320h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8225C320h case   17:*/		return 0x8225C324;
		  /* 8225C324h */ case   18:  		/* bc 12, CR6_EQ, 28 */
		/* 8225C324h case   18:*/		if ( regs.CR[6].eq ) { return 0x8225C340;  }
		/* 8225C324h case   18:*/		return 0x8225C328;
		  /* 8225C328h */ case   19:  		/* mr R6, R21 */
		/* 8225C328h case   19:*/		regs.R6 = regs.R21;
		/* 8225C328h case   19:*/		return 0x8225C32C;
		  /* 8225C32Ch */ case   20:  		/* mr R5, R25 */
		/* 8225C32Ch case   20:*/		regs.R5 = regs.R25;
		/* 8225C32Ch case   20:*/		return 0x8225C330;
		  /* 8225C330h */ case   21:  		/* mr R4, R22 */
		/* 8225C330h case   21:*/		regs.R4 = regs.R22;
		/* 8225C330h case   21:*/		return 0x8225C334;
		  /* 8225C334h */ case   22:  		/* li R7, 922 */
		/* 8225C334h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x39A);
		/* 8225C334h case   22:*/		return 0x8225C338;
		  /* 8225C338h */ case   23:  		/* li R3, 0 */
		/* 8225C338h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C338h case   23:*/		return 0x8225C33C;
		  /* 8225C33Ch */ case   24:  		/* bl -1066804 */
		/* 8225C33Ch case   24:*/		regs.LR = 0x8225C340; return 0x82157C08;
		/* 8225C33Ch case   24:*/		return 0x8225C340;
	}
	return 0x8225C340;
} // Block from 8225C2DCh-8225C340h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225C340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C340);
		  /* 8225C340h */ case    0:  		/* lwz R10, <#[R29 + 12]> */
		/* 8225C340h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C340h case    0:*/		return 0x8225C344;
		  /* 8225C344h */ case    1:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225C344h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C344h case    1:*/		return 0x8225C348;
		  /* 8225C348h */ case    2:  		/* addi R11, R11, -1 */
		/* 8225C348h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8225C348h case    2:*/		return 0x8225C34C;
		  /* 8225C34Ch */ case    3:  		/* stw R11, <#[R10 + 1508]> */
		/* 8225C34Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C34Ch case    3:*/		return 0x8225C350;
		  /* 8225C350h */ case    4:  		/* mr R27, R11 */
		/* 8225C350h case    4:*/		regs.R27 = regs.R11;
		/* 8225C350h case    4:*/		return 0x8225C354;
		  /* 8225C354h */ case    5:  		/* sth R11, <#[R26 + 2]> */
		/* 8225C354h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R26 + 0x00000002) );
		/* 8225C354h case    5:*/		return 0x8225C358;
		  /* 8225C358h */ case    6:  		/* lwz R11, <#[R26]> */
		/* 8225C358h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C358h case    6:*/		return 0x8225C35C;
		  /* 8225C35Ch */ case    7:  		/* rlwimi R11, R20, 18, 10, 15 */
		/* 8225C35Ch case    7:*/		cpu::op::rlwimi<0,18,10,15>(regs,&regs.R11,regs.R20);
		/* 8225C35Ch case    7:*/		return 0x8225C360;
		  /* 8225C360h */ case    8:  		/* stw R11, <#[R26]> */
		/* 8225C360h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C360h case    8:*/		return 0x8225C364;
	}
	return 0x8225C364;
} // Block from 8225C340h-8225C364h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225C364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C364);
		  /* 8225C364h */ case    0:  		/* li R3, 49 */
		/* 8225C364h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225C364h case    0:*/		return 0x8225C368;
		  /* 8225C368h */ case    1:  		/* lwz R4, <#[R29 + 12]> */
		/* 8225C368h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C368h case    1:*/		return 0x8225C36C;
		  /* 8225C36Ch */ case    2:  		/* bl -25660 */
		/* 8225C36Ch case    2:*/		regs.LR = 0x8225C370; return 0x82255F30;
		/* 8225C36Ch case    2:*/		return 0x8225C370;
		  /* 8225C370h */ case    3:  		/* stw R27, <#[R3 + 56]> */
		/* 8225C370h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000038) );
		/* 8225C370h case    3:*/		return 0x8225C374;
		  /* 8225C374h */ case    4:  		/* stw R23, <#[R3 + 80]> */
		/* 8225C374h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000050) );
		/* 8225C374h case    4:*/		return 0x8225C378;
		  /* 8225C378h */ case    5:  		/* lis R11, -32256 */
		/* 8225C378h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225C378h case    5:*/		return 0x8225C37C;
		  /* 8225C37Ch */ case    6:  		/* li R5, 1 */
		/* 8225C37Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225C37Ch case    6:*/		return 0x8225C380;
		  /* 8225C380h */ case    7:  		/* mr R4, R29 */
		/* 8225C380h case    7:*/		regs.R4 = regs.R29;
		/* 8225C380h case    7:*/		return 0x8225C384;
		  /* 8225C384h */ case    8:  		/* mr R31, R3 */
		/* 8225C384h case    8:*/		regs.R31 = regs.R3;
		/* 8225C384h case    8:*/		return 0x8225C388;
		  /* 8225C388h */ case    9:  		/* lfs FR4, <#[R11 + 1792]> */
		/* 8225C388h case    9:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000700) );
		/* 8225C388h case    9:*/		return 0x8225C38C;
		  /* 8225C38Ch */ case   10:  		/* fmr FR3, FR4 */
		/* 8225C38Ch case   10:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225C38Ch case   10:*/		return 0x8225C390;
		  /* 8225C390h */ case   11:  		/* fmr FR2, FR4 */
		/* 8225C390h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225C390h case   11:*/		return 0x8225C394;
		  /* 8225C394h */ case   12:  		/* fmr FR1, FR4 */
		/* 8225C394h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225C394h case   12:*/		return 0x8225C398;
		  /* 8225C398h */ case   13:  		/* bl -21632 */
		/* 8225C398h case   13:*/		regs.LR = 0x8225C39C; return 0x82256F18;
		/* 8225C398h case   13:*/		return 0x8225C39C;
		  /* 8225C39Ch */ case   14:  		/* mr R30, R23 */
		/* 8225C39Ch case   14:*/		regs.R30 = regs.R23;
		/* 8225C39Ch case   14:*/		return 0x8225C3A0;
		  /* 8225C3A0h */ case   15:  		/* sraw R11, R28, R30 */
		/* 8225C3A0h case   15:*/		cpu::op::sraw<0>(regs,&regs.R11,regs.R28,regs.R30);
		/* 8225C3A0h case   15:*/		return 0x8225C3A4;
		  /* 8225C3A4h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8225C3A4h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C3A4h case   16:*/		return 0x8225C3A8;
		  /* 8225C3A8h */ case   17:  		/* lwz R11, <#[R31]> */
		/* 8225C3A8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225C3A8h case   17:*/		return 0x8225C3AC;
		  /* 8225C3ACh */ case   18:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225C3ACh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225C3ACh case   18:*/		return 0x8225C3B0;
		  /* 8225C3B0h */ case   19:  		/* mr R5, R30 */
		/* 8225C3B0h case   19:*/		regs.R5 = regs.R30;
		/* 8225C3B0h case   19:*/		return 0x8225C3B4;
		  /* 8225C3B4h */ case   20:  		/* li R4, 0 */
		/* 8225C3B4h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225C3B4h case   20:*/		return 0x8225C3B8;
		  /* 8225C3B8h */ case   21:  		/* mr R3, R31 */
		/* 8225C3B8h case   21:*/		regs.R3 = regs.R31;
		/* 8225C3B8h case   21:*/		return 0x8225C3BC;
		  /* 8225C3BCh */ case   22:  		/* li R6, 0 */
		/* 8225C3BCh case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225C3BCh case   22:*/		return 0x8225C3C0;
		  /* 8225C3C0h */ case   23:  		/* mtspr CTR, R11 */
		/* 8225C3C0h case   23:*/		regs.CTR = regs.R11;
		/* 8225C3C0h case   23:*/		return 0x8225C3C4;
		  /* 8225C3C4h */ case   24:  		/* bc 4, CR0_EQ, 8 */
		/* 8225C3C4h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8225C3CC;  }
		/* 8225C3C4h case   24:*/		return 0x8225C3C8;
		  /* 8225C3C8h */ case   25:  		/* li R6, 1 */
		/* 8225C3C8h case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225C3C8h case   25:*/		return 0x8225C3CC;
	}
	return 0x8225C3CC;
} // Block from 8225C364h-8225C3CCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225C3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C3CC);
		  /* 8225C3CCh */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 8225C3CCh case    0:*/		if ( 1 ) { regs.LR = 0x8225C3D0; return (uint32)regs.CTR; }
		/* 8225C3CCh case    0:*/		return 0x8225C3D0;
		  /* 8225C3D0h */ case    1:  		/* addi R30, R30, 1 */
		/* 8225C3D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225C3D0h case    1:*/		return 0x8225C3D4;
		  /* 8225C3D4h */ case    2:  		/* cmpwi CR6, R30, 4 */
		/* 8225C3D4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225C3D4h case    2:*/		return 0x8225C3D8;
		  /* 8225C3D8h */ case    3:  		/* bc 12, CR6_LT, -56 */
		/* 8225C3D8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225C3A0;  }
		/* 8225C3D8h case    3:*/		return 0x8225C3DC;
		  /* 8225C3DCh */ case    4:  		/* mr R4, R31 */
		/* 8225C3DCh case    4:*/		regs.R4 = regs.R31;
		/* 8225C3DCh case    4:*/		return 0x8225C3E0;
		  /* 8225C3E0h */ case    5:  		/* mr R3, R24 */
		/* 8225C3E0h case    5:*/		regs.R3 = regs.R24;
		/* 8225C3E0h case    5:*/		return 0x8225C3E4;
		  /* 8225C3E4h */ case    6:  		/* bl -35676 */
		/* 8225C3E4h case    6:*/		regs.LR = 0x8225C3E8; return 0x82253888;
		/* 8225C3E4h case    6:*/		return 0x8225C3E8;
	}
	return 0x8225C3E8;
} // Block from 8225C3CCh-8225C3E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225C3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C3E8);
		  /* 8225C3E8h */ case    0:  		/* mr R3, R26 */
		/* 8225C3E8h case    0:*/		regs.R3 = regs.R26;
		/* 8225C3E8h case    0:*/		return 0x8225C3EC;
		  /* 8225C3ECh */ case    1:  		/* bl 43988 */
		/* 8225C3ECh case    1:*/		regs.LR = 0x8225C3F0; return 0x82266FC0;
		/* 8225C3ECh case    1:*/		return 0x8225C3F0;
		  /* 8225C3F0h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225C3F0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225C3F0h case    2:*/		return 0x8225C3F4;
		  /* 8225C3F4h */ case    3:  		/* bc 12, CR0_EQ, 92 */
		/* 8225C3F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8225C450;  }
		/* 8225C3F4h case    3:*/		return 0x8225C3F8;
		  /* 8225C3F8h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8225C3F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225C3F8h case    4:*/		return 0x8225C3FC;
		  /* 8225C3FCh */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8225C3FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8225C408;  }
		/* 8225C3FCh case    5:*/		return 0x8225C400;
		  /* 8225C400h */ case    6:  		/* cmpwi CR6, R27, 0 */
		/* 8225C400h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8225C400h case    6:*/		return 0x8225C404;
		  /* 8225C404h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 8225C404h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8225C424;  }
		/* 8225C404h case    7:*/		return 0x8225C408;
	}
	return 0x8225C408;
} // Block from 8225C3E8h-8225C408h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225C408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C408);
		  /* 8225C408h */ case    0:  		/* lis R11, -32251 */
		/* 8225C408h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C408h case    0:*/		return 0x8225C40C;
		  /* 8225C40Ch */ case    1:  		/* mr R6, R21 */
		/* 8225C40Ch case    1:*/		regs.R6 = regs.R21;
		/* 8225C40Ch case    1:*/		return 0x8225C410;
		  /* 8225C410h */ case    2:  		/* addi R5, R11, -20540 */
		/* 8225C410h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAFC4);
		/* 8225C410h case    2:*/		return 0x8225C414;
		  /* 8225C414h */ case    3:  		/* mr R4, R22 */
		/* 8225C414h case    3:*/		regs.R4 = regs.R22;
		/* 8225C414h case    3:*/		return 0x8225C418;
		  /* 8225C418h */ case    4:  		/* li R7, 944 */
		/* 8225C418h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x3B0);
		/* 8225C418h case    4:*/		return 0x8225C41C;
		  /* 8225C41Ch */ case    5:  		/* li R3, 0 */
		/* 8225C41Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C41Ch case    5:*/		return 0x8225C420;
		  /* 8225C420h */ case    6:  		/* bl -1067032 */
		/* 8225C420h case    6:*/		regs.LR = 0x8225C424; return 0x82157C08;
		/* 8225C420h case    6:*/		return 0x8225C424;
	}
	return 0x8225C424;
} // Block from 8225C408h-8225C424h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225C424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C424);
		  /* 8225C424h */ case    0:  		/* li R3, 49 */
		/* 8225C424h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225C424h case    0:*/		return 0x8225C428;
		  /* 8225C428h */ case    1:  		/* lwz R4, <#[R29 + 12]> */
		/* 8225C428h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225C428h case    1:*/		return 0x8225C42C;
		  /* 8225C42Ch */ case    2:  		/* bl -25852 */
		/* 8225C42Ch case    2:*/		regs.LR = 0x8225C430; return 0x82255F30;
		/* 8225C42Ch case    2:*/		return 0x8225C430;
		  /* 8225C430h */ case    3:  		/* mr R31, R3 */
		/* 8225C430h case    3:*/		regs.R31 = regs.R3;
		/* 8225C430h case    3:*/		return 0x8225C434;
		  /* 8225C434h */ case    4:  		/* mr R3, R24 */
		/* 8225C434h case    4:*/		regs.R3 = regs.R24;
		/* 8225C434h case    4:*/		return 0x8225C438;
		  /* 8225C438h */ case    5:  		/* mr R4, R31 */
		/* 8225C438h case    5:*/		regs.R4 = regs.R31;
		/* 8225C438h case    5:*/		return 0x8225C43C;
		  /* 8225C43Ch */ case    6:  		/* stw R27, <#[R31 + 56]> */
		/* 8225C43Ch case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000038) );
		/* 8225C43Ch case    6:*/		return 0x8225C440;
		  /* 8225C440h */ case    7:  		/* stw R23, <#[R31 + 80]> */
		/* 8225C440h case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000050) );
		/* 8225C440h case    7:*/		return 0x8225C444;
		  /* 8225C444h */ case    8:  		/* stw R27, <#[R31 + 60]> */
		/* 8225C444h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000003C) );
		/* 8225C444h case    8:*/		return 0x8225C448;
		  /* 8225C448h */ case    9:  		/* stw R23, <#[R31 + 84]> */
		/* 8225C448h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000054) );
		/* 8225C448h case    9:*/		return 0x8225C44C;
		  /* 8225C44Ch */ case   10:  		/* bl -35780 */
		/* 8225C44Ch case   10:*/		regs.LR = 0x8225C450; return 0x82253888;
		/* 8225C44Ch case   10:*/		return 0x8225C450;
	}
	return 0x8225C450;
} // Block from 8225C424h-8225C450h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225C450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C450);
		  /* 8225C450h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8225C450h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8225C450h case    0:*/		return 0x8225C454;
		  /* 8225C454h */ case    1:  		/* bc 12, CR6_EQ, 512 */
		/* 8225C454h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225C654;  }
		/* 8225C454h case    1:*/		return 0x8225C458;
		  /* 8225C458h */ case    2:  		/* lwz R11, <#[R26]> */
		/* 8225C458h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C458h case    2:*/		return 0x8225C45C;
		  /* 8225C45Ch */ case    3:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8225C45Ch case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C45Ch case    3:*/		return 0x8225C460;
		  /* 8225C460h */ case    4:  		/* bc 12, CR0_EQ, 312 */
		/* 8225C460h case    4:*/		if ( regs.CR[0].eq ) { return 0x8225C598;  }
		/* 8225C460h case    4:*/		return 0x8225C464;
		  /* 8225C464h */ case    5:  		/* mr R3, R29 */
		/* 8225C464h case    5:*/		regs.R3 = regs.R29;
		/* 8225C464h case    5:*/		return 0x8225C468;
		  /* 8225C468h */ case    6:  		/* bl -157616 */
		/* 8225C468h case    6:*/		regs.LR = 0x8225C46C; return 0x82235CB8;
		/* 8225C468h case    6:*/		return 0x8225C46C;
		  /* 8225C46Ch */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225C46Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225C46Ch case    7:*/		return 0x8225C470;
		  /* 8225C470h */ case    8:  		/* bc 4, CR0_EQ, 32 */
		/* 8225C470h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8225C490;  }
		/* 8225C470h case    8:*/		return 0x8225C474;
		  /* 8225C474h */ case    9:  		/* lis R11, -32251 */
		/* 8225C474h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C474h case    9:*/		return 0x8225C478;
		  /* 8225C478h */ case   10:  		/* mr R6, R21 */
		/* 8225C478h case   10:*/		regs.R6 = regs.R21;
		/* 8225C478h case   10:*/		return 0x8225C47C;
		  /* 8225C47Ch */ case   11:  		/* addi R5, R11, -20560 */
		/* 8225C47Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAFB0);
		/* 8225C47Ch case   11:*/		return 0x8225C480;
		  /* 8225C480h */ case   12:  		/* mr R4, R22 */
		/* 8225C480h case   12:*/		regs.R4 = regs.R22;
		/* 8225C480h case   12:*/		return 0x8225C484;
		  /* 8225C484h */ case   13:  		/* li R7, 956 */
		/* 8225C484h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x3BC);
		/* 8225C484h case   13:*/		return 0x8225C488;
		  /* 8225C488h */ case   14:  		/* li R3, 0 */
		/* 8225C488h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C488h case   14:*/		return 0x8225C48C;
		  /* 8225C48Ch */ case   15:  		/* bl -1067140 */
		/* 8225C48Ch case   15:*/		regs.LR = 0x8225C490; return 0x82157C08;
		/* 8225C48Ch case   15:*/		return 0x8225C490;
	}
	return 0x8225C490;
} // Block from 8225C450h-8225C490h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225C490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C490);
		  /* 8225C490h */ case    0:  		/* cmpwi CR6, R19, 15 */
		/* 8225C490h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x0000000F);
		/* 8225C490h case    0:*/		return 0x8225C494;
		  /* 8225C494h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8225C494h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225C4C4;  }
		/* 8225C494h case    1:*/		return 0x8225C498;
		  /* 8225C498h */ case    2:  		/* cmpwi CR6, R19, 17 */
		/* 8225C498h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000011);
		/* 8225C498h case    2:*/		return 0x8225C49C;
		  /* 8225C49Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8225C49Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8225C4C4;  }
		/* 8225C49Ch case    3:*/		return 0x8225C4A0;
		  /* 8225C4A0h */ case    4:  		/* cmpwi CR6, R19, 11 */
		/* 8225C4A0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x0000000B);
		/* 8225C4A0h case    4:*/		return 0x8225C4A4;
		  /* 8225C4A4h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 8225C4A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8225C4C4;  }
		/* 8225C4A4h case    5:*/		return 0x8225C4A8;
		  /* 8225C4A8h */ case    6:  		/* lis R11, -32251 */
		/* 8225C4A8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C4A8h case    6:*/		return 0x8225C4AC;
		  /* 8225C4ACh */ case    7:  		/* mr R6, R21 */
		/* 8225C4ACh case    7:*/		regs.R6 = regs.R21;
		/* 8225C4ACh case    7:*/		return 0x8225C4B0;
		  /* 8225C4B0h */ case    8:  		/* addi R5, R11, -20672 */
		/* 8225C4B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAF40);
		/* 8225C4B0h case    8:*/		return 0x8225C4B4;
		  /* 8225C4B4h */ case    9:  		/* mr R4, R22 */
		/* 8225C4B4h case    9:*/		regs.R4 = regs.R22;
		/* 8225C4B4h case    9:*/		return 0x8225C4B8;
		  /* 8225C4B8h */ case   10:  		/* li R7, 959 */
		/* 8225C4B8h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3BF);
		/* 8225C4B8h case   10:*/		return 0x8225C4BC;
		  /* 8225C4BCh */ case   11:  		/* li R3, 0 */
		/* 8225C4BCh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C4BCh case   11:*/		return 0x8225C4C0;
		  /* 8225C4C0h */ case   12:  		/* bl -1067192 */
		/* 8225C4C0h case   12:*/		regs.LR = 0x8225C4C4; return 0x82157C08;
		/* 8225C4C0h case   12:*/		return 0x8225C4C4;
	}
	return 0x8225C4C4;
} // Block from 8225C490h-8225C4C4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225C4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C4C4);
		  /* 8225C4C4h */ case    0:  		/* lbz R11, <#[R29 + 2116]> */
		/* 8225C4C4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000844) );
		/* 8225C4C4h case    0:*/		return 0x8225C4C8;
		  /* 8225C4C8h */ case    1:  		/* rlwinm R10, R19, 3, 0, 28 */
		/* 8225C4C8h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R19);
		/* 8225C4C8h case    1:*/		return 0x8225C4CC;
		  /* 8225C4CCh */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 8225C4CCh case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225C4CCh case    2:*/		return 0x8225C4D0;
		  /* 8225C4D0h */ case    3:  		/* lwz R11, <#[R29 + 92]> */
		/* 8225C4D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000005C) );
		/* 8225C4D0h case    3:*/		return 0x8225C4D4;
		  /* 8225C4D4h */ case    4:  		/* add R11, R10, R11 */
		/* 8225C4D4h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225C4D4h case    4:*/		return 0x8225C4D8;
		  /* 8225C4D8h */ case    5:  		/* bc 4, CR0_EQ, 20 */
		/* 8225C4D8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8225C4EC;  }
		/* 8225C4D8h case    5:*/		return 0x8225C4DC;
		  /* 8225C4DCh */ case    6:  		/* stb R20, <#[R29 + 2116]> */
		/* 8225C4DCh case    6:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R29 + 0x00000844) );
		/* 8225C4DCh case    6:*/		return 0x8225C4E0;
		  /* 8225C4E0h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225C4E0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225C4E0h case    7:*/		return 0x8225C4E4;
		  /* 8225C4E4h */ case    8:  		/* stw R11, <#[R29 + 2120]> */
		/* 8225C4E4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000848) );
		/* 8225C4E4h case    8:*/		return 0x8225C4E8;
		  /* 8225C4E8h */ case    9:  		/* b 48 */
		/* 8225C4E8h case    9:*/		return 0x8225C518;
		/* 8225C4E8h case    9:*/		return 0x8225C4EC;
	}
	return 0x8225C4EC;
} // Block from 8225C4C4h-8225C4ECh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225C4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C4EC);
		  /* 8225C4ECh */ case    0:  		/* lwz R9, <#[R29 + 2120]> */
		/* 8225C4ECh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000848) );
		/* 8225C4ECh case    0:*/		return 0x8225C4F0;
		  /* 8225C4F0h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225C4F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225C4F0h case    1:*/		return 0x8225C4F4;
		  /* 8225C4F4h */ case    2:  		/* cmpw CR6, R9, R11 */
		/* 8225C4F4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 8225C4F4h case    2:*/		return 0x8225C4F8;
		  /* 8225C4F8h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8225C4F8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225C518;  }
		/* 8225C4F8h case    3:*/		return 0x8225C4FC;
		  /* 8225C4FCh */ case    4:  		/* lis R11, -32251 */
		/* 8225C4FCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C4FCh case    4:*/		return 0x8225C500;
		  /* 8225C500h */ case    5:  		/* mr R6, R21 */
		/* 8225C500h case    5:*/		regs.R6 = regs.R21;
		/* 8225C500h case    5:*/		return 0x8225C504;
		  /* 8225C504h */ case    6:  		/* addi R5, R11, -20724 */
		/* 8225C504h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAF0C);
		/* 8225C504h case    6:*/		return 0x8225C508;
		  /* 8225C508h */ case    7:  		/* mr R4, R22 */
		/* 8225C508h case    7:*/		regs.R4 = regs.R22;
		/* 8225C508h case    7:*/		return 0x8225C50C;
		  /* 8225C50Ch */ case    8:  		/* li R7, 964 */
		/* 8225C50Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x3C4);
		/* 8225C50Ch case    8:*/		return 0x8225C510;
		  /* 8225C510h */ case    9:  		/* li R3, 0 */
		/* 8225C510h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C510h case    9:*/		return 0x8225C514;
		  /* 8225C514h */ case   10:  		/* bl -1067276 */
		/* 8225C514h case   10:*/		regs.LR = 0x8225C518; return 0x82157C08;
		/* 8225C514h case   10:*/		return 0x8225C518;
	}
	return 0x8225C518;
} // Block from 8225C4ECh-8225C518h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225C518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C518);
		  /* 8225C518h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 8225C518h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8225C518h case    0:*/		return 0x8225C51C;
		  /* 8225C51Ch */ case    1:  		/* mr R4, R31 */
		/* 8225C51Ch case    1:*/		regs.R4 = regs.R31;
		/* 8225C51Ch case    1:*/		return 0x8225C520;
		  /* 8225C520h */ case    2:  		/* stw R18, <#[R31 + 200]> */
		/* 8225C520h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R31 + 0x000000C8) );
		/* 8225C520h case    2:*/		return 0x8225C524;
		  /* 8225C524h */ case    3:  		/* mr R3, R29 */
		/* 8225C524h case    3:*/		regs.R3 = regs.R29;
		/* 8225C524h case    3:*/		return 0x8225C528;
		  /* 8225C528h */ case    4:  		/* ori R11, R11, 16 */
		/* 8225C528h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8225C528h case    4:*/		return 0x8225C52C;
		  /* 8225C52Ch */ case    5:  		/* li R19, 32 */
		/* 8225C52Ch case    5:*/		cpu::op::li<0>(regs,&regs.R19,0x20);
		/* 8225C52Ch case    5:*/		return 0x8225C530;
		  /* 8225C530h */ case    6:  		/* stw R11, <#[R31 + 228]> */
		/* 8225C530h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 8225C530h case    6:*/		return 0x8225C534;
		  /* 8225C534h */ case    7:  		/* bl -156988 */
		/* 8225C534h case    7:*/		regs.LR = 0x8225C538; return 0x82235FF8;
		/* 8225C534h case    7:*/		return 0x8225C538;
		  /* 8225C538h */ case    8:  		/* lwz R11, <#[R17 + 4]> */
		/* 8225C538h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000004) );
		/* 8225C538h case    8:*/		return 0x8225C53C;
		  /* 8225C53Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8225C53Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225C53Ch case    9:*/		return 0x8225C540;
		  /* 8225C540h */ case   10:  		/* bc 4, CR6_EQ, 32 */
		/* 8225C540h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8225C560;  }
		/* 8225C540h case   10:*/		return 0x8225C544;
		  /* 8225C544h */ case   11:  		/* lis R11, -32251 */
		/* 8225C544h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C544h case   11:*/		return 0x8225C548;
		  /* 8225C548h */ case   12:  		/* mr R6, R21 */
		/* 8225C548h case   12:*/		regs.R6 = regs.R21;
		/* 8225C548h case   12:*/		return 0x8225C54C;
		  /* 8225C54Ch */ case   13:  		/* addi R5, R11, -20744 */
		/* 8225C54Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAEF8);
		/* 8225C54Ch case   13:*/		return 0x8225C550;
		  /* 8225C550h */ case   14:  		/* mr R4, R22 */
		/* 8225C550h case   14:*/		regs.R4 = regs.R22;
		/* 8225C550h case   14:*/		return 0x8225C554;
		  /* 8225C554h */ case   15:  		/* li R7, 971 */
		/* 8225C554h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x3CB);
		/* 8225C554h case   15:*/		return 0x8225C558;
		  /* 8225C558h */ case   16:  		/* li R3, 0 */
		/* 8225C558h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C558h case   16:*/		return 0x8225C55C;
		  /* 8225C55Ch */ case   17:  		/* bl -1067348 */
		/* 8225C55Ch case   17:*/		regs.LR = 0x8225C560; return 0x82157C08;
		/* 8225C55Ch case   17:*/		return 0x8225C560;
	}
	return 0x8225C560;
} // Block from 8225C518h-8225C560h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225C560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C560);
		  /* 8225C560h */ case    0:  		/* lwz R10, <#[R17 + 4]> */
		/* 8225C560h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000004) );
		/* 8225C560h case    0:*/		return 0x8225C564;
		  /* 8225C564h */ case    1:  		/* addi R11, R10, -1 */
		/* 8225C564h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8225C564h case    1:*/		return 0x8225C568;
		  /* 8225C568h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8225C568h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8225C568h case    2:*/		return 0x8225C56C;
		  /* 8225C56Ch */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 8225C56Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x8225C580;  }
		/* 8225C56Ch case    3:*/		return 0x8225C570;
		  /* 8225C570h */ case    4:  		/* lwz R10, <#[R17 + 8]> */
		/* 8225C570h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000008) );
		/* 8225C570h case    4:*/		return 0x8225C574;
		  /* 8225C574h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225C574h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225C574h case    5:*/		return 0x8225C578;
		  /* 8225C578h */ case    6:  		/* add R11, R11, R10 */
		/* 8225C578h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225C578h case    6:*/		return 0x8225C57C;
		  /* 8225C57Ch */ case    7:  		/* b 8 */
		/* 8225C57Ch case    7:*/		return 0x8225C584;
		/* 8225C57Ch case    7:*/		return 0x8225C580;
	}
	return 0x8225C580;
} // Block from 8225C560h-8225C580h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225C580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C580);
		  /* 8225C580h */ case    0:  		/* mr R11, R23 */
		/* 8225C580h case    0:*/		regs.R11 = regs.R23;
		/* 8225C580h case    0:*/		return 0x8225C584;
	}
	return 0x8225C584;
} // Block from 8225C580h-8225C584h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225C584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C584);
		  /* 8225C584h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8225C584h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225C584h case    0:*/		return 0x8225C588;
		  /* 8225C588h */ case    1:  		/* lwz R10, <#[R26]> */
		/* 8225C588h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C588h case    1:*/		return 0x8225C58C;
		  /* 8225C58Ch */ case    2:  		/* rlwinm R10, R10, 0, 9, 7 */
		/* 8225C58Ch case    2:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R10,regs.R10);
		/* 8225C58Ch case    2:*/		return 0x8225C590;
		  /* 8225C590h */ case    3:  		/* lwz R18, <#[R11 + 136]> */
		/* 8225C590h case    3:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R11 + 0x00000088) );
		/* 8225C590h case    3:*/		return 0x8225C594;
		  /* 8225C594h */ case    4:  		/* stw R10, <#[R26]> */
		/* 8225C594h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C594h case    4:*/		return 0x8225C598;
	}
	return 0x8225C598;
} // Block from 8225C584h-8225C598h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225C598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C598);
		  /* 8225C598h */ case    0:  		/* lwz R11, <#[R29 + 92]> */
		/* 8225C598h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000005C) );
		/* 8225C598h case    0:*/		return 0x8225C59C;
		  /* 8225C59Ch */ case    1:  		/* rlwinm R10, R19, 3, 0, 28 */
		/* 8225C59Ch case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R19);
		/* 8225C59Ch case    1:*/		return 0x8225C5A0;
		  /* 8225C5A0h */ case    2:  		/* add R11, R10, R11 */
		/* 8225C5A0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225C5A0h case    2:*/		return 0x8225C5A4;
		  /* 8225C5A4h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225C5A4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225C5A4h case    3:*/		return 0x8225C5A8;
		  /* 8225C5A8h */ case    4:  		/* stw R18, <#[R31 + 56]> */
		/* 8225C5A8h case    4:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R31 + 0x00000038) );
		/* 8225C5A8h case    4:*/		return 0x8225C5AC;
		  /* 8225C5ACh */ case    5:  		/* stw R11, <#[R31 + 80]> */
		/* 8225C5ACh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8225C5ACh case    5:*/		return 0x8225C5B0;
		  /* 8225C5B0h */ case    6:  		/* lwz R11, <#[R26]> */
		/* 8225C5B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C5B0h case    6:*/		return 0x8225C5B4;
		  /* 8225C5B4h */ case    7:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225C5B4h case    7:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225C5B4h case    7:*/		return 0x8225C5B8;
		  /* 8225C5B8h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8225C5B8h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225C5C8;  }
		/* 8225C5B8h case    8:*/		return 0x8225C5BC;
		  /* 8225C5BCh */ case    9:  		/* lwz R11, <#[R26 + 4]> */
		/* 8225C5BCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8225C5BCh case    9:*/		return 0x8225C5C0;
		  /* 8225C5C0h */ case   10:  		/* rlwinm R11, R11, 24, 31, 31 */
		/* 8225C5C0h case   10:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R11,regs.R11);
		/* 8225C5C0h case   10:*/		return 0x8225C5C4;
		  /* 8225C5C4h */ case   11:  		/* b 8 */
		/* 8225C5C4h case   11:*/		return 0x8225C5CC;
		/* 8225C5C4h case   11:*/		return 0x8225C5C8;
	}
	return 0x8225C5C8;
} // Block from 8225C598h-8225C5C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225C5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C5C8);
		  /* 8225C5C8h */ case    0:  		/* mr R11, R23 */
		/* 8225C5C8h case    0:*/		regs.R11 = regs.R23;
		/* 8225C5C8h case    0:*/		return 0x8225C5CC;
	}
	return 0x8225C5CC;
} // Block from 8225C5C8h-8225C5CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225C5CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C5CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C5CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C5CC);
		  /* 8225C5CCh */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225C5CCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225C5CCh case    0:*/		return 0x8225C5D0;
		  /* 8225C5D0h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8225C5D0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225C5D8;  }
		/* 8225C5D0h case    1:*/		return 0x8225C5D4;
		  /* 8225C5D4h */ case    2:  		/* stb R20, <#[R31 + 164]> */
		/* 8225C5D4h case    2:*/		cpu::mem::store8( regs, regs.R20, (uint32)(regs.R31 + 0x000000A4) );
		/* 8225C5D4h case    2:*/		return 0x8225C5D8;
	}
	return 0x8225C5D8;
} // Block from 8225C5CCh-8225C5D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225C5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C5D8);
		  /* 8225C5D8h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8225C5D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C5D8h case    0:*/		return 0x8225C5DC;
		  /* 8225C5DCh */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225C5DCh case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225C5DCh case    1:*/		return 0x8225C5E0;
		  /* 8225C5E0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225C5E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225C5F0;  }
		/* 8225C5E0h case    2:*/		return 0x8225C5E4;
		  /* 8225C5E4h */ case    3:  		/* lwz R11, <#[R26 + 4]> */
		/* 8225C5E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8225C5E4h case    3:*/		return 0x8225C5E8;
		  /* 8225C5E8h */ case    4:  		/* rlwinm R11, R11, 0, 24, 22 */
		/* 8225C5E8h case    4:*/		cpu::op::rlwinm<0,0,24,22>(regs,&regs.R11,regs.R11);
		/* 8225C5E8h case    4:*/		return 0x8225C5EC;
		  /* 8225C5ECh */ case    5:  		/* stw R11, <#[R26 + 4]> */
		/* 8225C5ECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8225C5ECh case    5:*/		return 0x8225C5F0;
	}
	return 0x8225C5F0;
} // Block from 8225C5D8h-8225C5F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225C5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C5F0);
		  /* 8225C5F0h */ case    0:  		/* mr R30, R23 */
		/* 8225C5F0h case    0:*/		regs.R30 = regs.R23;
		/* 8225C5F0h case    0:*/		return 0x8225C5F4;
		  /* 8225C5F4h */ case    1:  		/* mr R4, R30 */
		/* 8225C5F4h case    1:*/		regs.R4 = regs.R30;
		/* 8225C5F4h case    1:*/		return 0x8225C5F8;
		  /* 8225C5F8h */ case    2:  		/* mr R3, R26 */
		/* 8225C5F8h case    2:*/		regs.R3 = regs.R26;
		/* 8225C5F8h case    2:*/		return 0x8225C5FC;
		  /* 8225C5FCh */ case    3:  		/* bl 43180 */
		/* 8225C5FCh case    3:*/		regs.LR = 0x8225C600; return 0x82266EA8;
		/* 8225C5FCh case    3:*/		return 0x8225C600;
		  /* 8225C600h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 8225C600h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8225C600h case    4:*/		return 0x8225C604;
		  /* 8225C604h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8225C604h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8225C604h case    5:*/		return 0x8225C608;
		  /* 8225C608h */ case    6:  		/* mr R5, R30 */
		/* 8225C608h case    6:*/		regs.R5 = regs.R30;
		/* 8225C608h case    6:*/		return 0x8225C60C;
		  /* 8225C60Ch */ case    7:  		/* li R4, 0 */
		/* 8225C60Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225C60Ch case    7:*/		return 0x8225C610;
		  /* 8225C610h */ case    8:  		/* mr R3, R31 */
		/* 8225C610h case    8:*/		regs.R3 = regs.R31;
		/* 8225C610h case    8:*/		return 0x8225C614;
		  /* 8225C614h */ case    9:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225C614h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225C614h case    9:*/		return 0x8225C618;
		  /* 8225C618h */ case   10:  		/* li R6, 1 */
		/* 8225C618h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225C618h case   10:*/		return 0x8225C61C;
		  /* 8225C61Ch */ case   11:  		/* mtspr CTR, R11 */
		/* 8225C61Ch case   11:*/		regs.CTR = regs.R11;
		/* 8225C61Ch case   11:*/		return 0x8225C620;
		  /* 8225C620h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 8225C620h case   12:*/		if ( regs.CR[0].eq ) { return 0x8225C628;  }
		/* 8225C620h case   12:*/		return 0x8225C624;
		  /* 8225C624h */ case   13:  		/* li R6, 0 */
		/* 8225C624h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225C624h case   13:*/		return 0x8225C628;
	}
	return 0x8225C628;
} // Block from 8225C5F0h-8225C628h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225C628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C628);
		  /* 8225C628h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 8225C628h case    0:*/		if ( 1 ) { regs.LR = 0x8225C62C; return (uint32)regs.CTR; }
		/* 8225C628h case    0:*/		return 0x8225C62C;
		  /* 8225C62Ch */ case    1:  		/* addi R30, R30, 1 */
		/* 8225C62Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225C62Ch case    1:*/		return 0x8225C630;
		  /* 8225C630h */ case    2:  		/* cmpwi CR6, R30, 4 */
		/* 8225C630h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8225C630h case    2:*/		return 0x8225C634;
		  /* 8225C634h */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 8225C634h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225C5F4;  }
		/* 8225C634h case    3:*/		return 0x8225C638;
		  /* 8225C638h */ case    4:  		/* lwz R11, <#[R26]> */
		/* 8225C638h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8225C638h case    4:*/		return 0x8225C63C;
		  /* 8225C63Ch */ case    5:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225C63Ch case    5:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225C63Ch case    5:*/		return 0x8225C640;
		  /* 8225C640h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 8225C640h case    6:*/		if ( regs.CR[0].eq ) { return 0x8225C654;  }
		/* 8225C640h case    6:*/		return 0x8225C644;
		  /* 8225C644h */ case    7:  		/* lwz R11, <#[R26 + 4]> */
		/* 8225C644h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8225C644h case    7:*/		return 0x8225C648;
		  /* 8225C648h */ case    8:  		/* li R10, 85 */
		/* 8225C648h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x55);
		/* 8225C648h case    8:*/		return 0x8225C64C;
		  /* 8225C64Ch */ case    9:  		/* rlwimi R11, R10, 0, 24, 31 */
		/* 8225C64Ch case    9:*/		cpu::op::rlwimi<0,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8225C64Ch case    9:*/		return 0x8225C650;
		  /* 8225C650h */ case   10:  		/* stw R11, <#[R26 + 4]> */
		/* 8225C650h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 8225C650h case   10:*/		return 0x8225C654;
	}
	return 0x8225C654;
} // Block from 8225C628h-8225C654h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225C654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C654);
		  /* 8225C654h */ case    0:  		/* addi R1, R1, 208 */
		/* 8225C654h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8225C654h case    0:*/		return 0x8225C658;
		  /* 8225C658h */ case    1:  		/* b -1881052 */
		/* 8225C658h case    1:*/		return 0x8209127C;
		/* 8225C658h case    1:*/		return 0x8225C65C;
		  /* 8225C65Ch */ case    2:  		/* nop */
		/* 8225C65Ch case    2:*/		cpu::op::nop();
		/* 8225C65Ch case    2:*/		return 0x8225C660;
	}
	return 0x8225C660;
} // Block from 8225C654h-8225C660h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225C660h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C660);
		  /* 8225C660h */ case    0:  		/* mfspr R12, LR */
		/* 8225C660h case    0:*/		regs.R12 = regs.LR;
		/* 8225C660h case    0:*/		return 0x8225C664;
		  /* 8225C664h */ case    1:  		/* bl -1881148 */
		/* 8225C664h case    1:*/		regs.LR = 0x8225C668; return 0x82091228;
		/* 8225C664h case    1:*/		return 0x8225C668;
		  /* 8225C668h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 8225C668h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 8225C668h case    2:*/		return 0x8225C66C;
		  /* 8225C66Ch */ case    3:  		/* mr R17, R9 */
		/* 8225C66Ch case    3:*/		regs.R17 = regs.R9;
		/* 8225C66Ch case    3:*/		return 0x8225C670;
		  /* 8225C670h */ case    4:  		/* lwz R9, <#[R5]> */
		/* 8225C670h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8225C670h case    4:*/		return 0x8225C674;
		  /* 8225C674h */ case    5:  		/* lwz R11, <#[R3 + 92]> */
		/* 8225C674h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000005C) );
		/* 8225C674h case    5:*/		return 0x8225C678;
		  /* 8225C678h */ case    6:  		/* mr R24, R4 */
		/* 8225C678h case    6:*/		regs.R24 = regs.R4;
		/* 8225C678h case    6:*/		return 0x8225C67C;
		  /* 8225C67Ch */ case    7:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 8225C67Ch case    7:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 8225C67Ch case    7:*/		return 0x8225C680;
		  /* 8225C680h */ case    8:  		/* mr R31, R3 */
		/* 8225C680h case    8:*/		regs.R31 = regs.R3;
		/* 8225C680h case    8:*/		return 0x8225C684;
		  /* 8225C684h */ case    9:  		/* add R11, R10, R11 */
		/* 8225C684h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225C684h case    9:*/		return 0x8225C688;
		  /* 8225C688h */ case   10:  		/* mr R16, R6 */
		/* 8225C688h case   10:*/		regs.R16 = regs.R6;
		/* 8225C688h case   10:*/		return 0x8225C68C;
		  /* 8225C68Ch */ case   11:  		/* mr R18, R7 */
		/* 8225C68Ch case   11:*/		regs.R18 = regs.R7;
		/* 8225C68Ch case   11:*/		return 0x8225C690;
		  /* 8225C690h */ case   12:  		/* mr R30, R8 */
		/* 8225C690h case   12:*/		regs.R30 = regs.R8;
		/* 8225C690h case   12:*/		return 0x8225C694;
		  /* 8225C694h */ case   13:  		/* extsh R5, R9 */
		/* 8225C694h case   13:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R9);
		/* 8225C694h case   13:*/		return 0x8225C698;
		  /* 8225C698h */ case   14:  		/* lwz R4, <#[R11 + 4]> */
		/* 8225C698h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 8225C698h case   14:*/		return 0x8225C69C;
		  /* 8225C69Ch */ case   15:  		/* cmpwi CR6, R4, 25 */
		/* 8225C69Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000019);
		/* 8225C69Ch case   15:*/		return 0x8225C6A0;
		  /* 8225C6A0h */ case   16:  		/* bc 4, CR6_EQ, 44 */
		/* 8225C6A0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8225C6CC;  }
		/* 8225C6A0h case   16:*/		return 0x8225C6A4;
		  /* 8225C6A4h */ case   17:  		/* lwz R11, <#[R3 + 2104]> */
		/* 8225C6A4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000838) );
		/* 8225C6A4h case   17:*/		return 0x8225C6A8;
		  /* 8225C6A8h */ case   18:  		/* cmpw CR6, R11, R5 */
		/* 8225C6A8h case   18:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 8225C6A8h case   18:*/		return 0x8225C6AC;
		  /* 8225C6ACh */ case   19:  		/* bc 12, CR6_LT, 8 */
		/* 8225C6ACh case   19:*/		if ( regs.CR[6].lt ) { return 0x8225C6B4;  }
		/* 8225C6ACh case   19:*/		return 0x8225C6B0;
		  /* 8225C6B0h */ case   20:  		/* mr R11, R5 */
		/* 8225C6B0h case   20:*/		regs.R11 = regs.R5;
		/* 8225C6B0h case   20:*/		return 0x8225C6B4;
	}
	return 0x8225C6B4;
} // Block from 8225C660h-8225C6B4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225C6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C6B4);
		  /* 8225C6B4h */ case    0:  		/* stw R11, <#[R31 + 2104]> */
		/* 8225C6B4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000838) );
		/* 8225C6B4h case    0:*/		return 0x8225C6B8;
		  /* 8225C6B8h */ case    1:  		/* lwz R11, <#[R31 + 2108]> */
		/* 8225C6B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000083C) );
		/* 8225C6B8h case    1:*/		return 0x8225C6BC;
		  /* 8225C6BCh */ case    2:  		/* cmpw CR6, R11, R5 */
		/* 8225C6BCh case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 8225C6BCh case    2:*/		return 0x8225C6C0;
		  /* 8225C6C0h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 8225C6C0h case    3:*/		if ( regs.CR[6].gt ) { return 0x8225C6C8;  }
		/* 8225C6C0h case    3:*/		return 0x8225C6C4;
		  /* 8225C6C4h */ case    4:  		/* addi R11, R5, 1 */
		/* 8225C6C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x1);
		/* 8225C6C4h case    4:*/		return 0x8225C6C8;
	}
	return 0x8225C6C8;
} // Block from 8225C6B4h-8225C6C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225C6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C6C8);
		  /* 8225C6C8h */ case    0:  		/* stw R11, <#[R31 + 2108]> */
		/* 8225C6C8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000083C) );
		/* 8225C6C8h case    0:*/		return 0x8225C6CC;
	}
	return 0x8225C6CC;
} // Block from 8225C6C8h-8225C6CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225C6CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C6CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C6CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C6CC);
		  /* 8225C6CCh */ case    0:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225C6CCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225C6CCh case    0:*/		return 0x8225C6D0;
		  /* 8225C6D0h */ case    1:  		/* bl -93888 */
		/* 8225C6D0h case    1:*/		regs.LR = 0x8225C6D4; return 0x82245810;
		/* 8225C6D0h case    1:*/		return 0x8225C6D4;
		  /* 8225C6D4h */ case    2:  		/* mr R19, R3 */
		/* 8225C6D4h case    2:*/		regs.R19 = regs.R3;
		/* 8225C6D4h case    2:*/		return 0x8225C6D8;
		  /* 8225C6D8h */ case    3:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225C6D8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225C6D8h case    3:*/		return 0x8225C6DC;
		  /* 8225C6DCh */ case    4:  		/* rlwinm. R20, R30, 0, 24, 31 */
		/* 8225C6DCh case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R20,regs.R30);
		/* 8225C6DCh case    4:*/		return 0x8225C6E0;
		  /* 8225C6E0h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8225C6E0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8225C6F0;  }
		/* 8225C6E0h case    5:*/		return 0x8225C6E4;
		  /* 8225C6E4h */ case    6:  		/* li R5, 0 */
		/* 8225C6E4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225C6E4h case    6:*/		return 0x8225C6E8;
		  /* 8225C6E8h */ case    7:  		/* li R4, 30 */
		/* 8225C6E8h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1E);
		/* 8225C6E8h case    7:*/		return 0x8225C6EC;
		  /* 8225C6ECh */ case    8:  		/* b 28 */
		/* 8225C6ECh case    8:*/		return 0x8225C708;
		/* 8225C6ECh case    8:*/		return 0x8225C6F0;
	}
	return 0x8225C6F0;
} // Block from 8225C6CCh-8225C6F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225C6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C6F0);
		  /* 8225C6F0h */ case    0:  		/* lwz R9, <#[R17]> */
		/* 8225C6F0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000000) );
		/* 8225C6F0h case    0:*/		return 0x8225C6F4;
		  /* 8225C6F4h */ case    1:  		/* lwz R11, <#[R31 + 92]> */
		/* 8225C6F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8225C6F4h case    1:*/		return 0x8225C6F8;
		  /* 8225C6F8h */ case    2:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 8225C6F8h case    2:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 8225C6F8h case    2:*/		return 0x8225C6FC;
		  /* 8225C6FCh */ case    3:  		/* extsh R5, R9 */
		/* 8225C6FCh case    3:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R9);
		/* 8225C6FCh case    3:*/		return 0x8225C700;
		  /* 8225C700h */ case    4:  		/* add R11, R10, R11 */
		/* 8225C700h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225C700h case    4:*/		return 0x8225C704;
		  /* 8225C704h */ case    5:  		/* lwz R4, <#[R11 + 4]> */
		/* 8225C704h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 8225C704h case    5:*/		return 0x8225C708;
	}
	return 0x8225C708;
} // Block from 8225C6F0h-8225C708h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225C708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C708);
		  /* 8225C708h */ case    0:  		/* bl -93944 */
		/* 8225C708h case    0:*/		regs.LR = 0x8225C70C; return 0x82245810;
		/* 8225C708h case    0:*/		return 0x8225C70C;
		  /* 8225C70Ch */ case    1:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225C70Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C70Ch case    1:*/		return 0x8225C710;
		  /* 8225C710h */ case    2:  		/* lis R10, -32222 */
		/* 8225C710h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 8225C710h case    2:*/		return 0x8225C714;
		  /* 8225C714h */ case    3:  		/* addi R5, R1, 88 */
		/* 8225C714h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8225C714h case    3:*/		return 0x8225C718;
		  /* 8225C718h */ case    4:  		/* addi R7, R10, -12392 */
		/* 8225C718h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFCF98);
		/* 8225C718h case    4:*/		return 0x8225C71C;
		  /* 8225C71Ch */ case    5:  		/* mr R4, R24 */
		/* 8225C71Ch case    5:*/		regs.R4 = regs.R24;
		/* 8225C71Ch case    5:*/		return 0x8225C720;
		  /* 8225C720h */ case    6:  		/* mr R8, R11 */
		/* 8225C720h case    6:*/		regs.R8 = regs.R11;
		/* 8225C720h case    6:*/		return 0x8225C724;
		  /* 8225C724h */ case    7:  		/* lwz R6, <#[R11 + 1384]> */
		/* 8225C724h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000568) );
		/* 8225C724h case    7:*/		return 0x8225C728;
		  /* 8225C728h */ case    8:  		/* mr R25, R3 */
		/* 8225C728h case    8:*/		regs.R25 = regs.R3;
		/* 8225C728h case    8:*/		return 0x8225C72C;
		  /* 8225C72Ch */ case    9:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225C72Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225C72Ch case    9:*/		return 0x8225C730;
		  /* 8225C730h */ case   10:  		/* bl -169944 */
		/* 8225C730h case   10:*/		regs.LR = 0x8225C734; return 0x82232F58;
		/* 8225C730h case   10:*/		return 0x8225C734;
		  /* 8225C734h */ case   11:  		/* lis R11, -32253 */
		/* 8225C734h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8225C734h case   11:*/		return 0x8225C738;
		  /* 8225C738h */ case   12:  		/* lis R10, -32251 */
		/* 8225C738h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225C738h case   12:*/		return 0x8225C73C;
		  /* 8225C73Ch */ case   13:  		/* lis R9, -32251 */
		/* 8225C73Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8225C73Ch case   13:*/		return 0x8225C740;
		  /* 8225C740h */ case   14:  		/* cmpwi CR6, R3, 1 */
		/* 8225C740h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225C740h case   14:*/		return 0x8225C744;
		  /* 8225C744h */ case   15:  		/* addi R23, R11, 27460 */
		/* 8225C744h case   15:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R11,0x6B44);
		/* 8225C744h case   15:*/		return 0x8225C748;
		  /* 8225C748h */ case   16:  		/* addi R21, R10, -20440 */
		/* 8225C748h case   16:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R10,0xFFFFB028);
		/* 8225C748h case   16:*/		return 0x8225C74C;
		  /* 8225C74Ch */ case   17:  		/* addi R22, R9, -21904 */
		/* 8225C74Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R9,0xFFFFAA70);
		/* 8225C74Ch case   17:*/		return 0x8225C750;
		  /* 8225C750h */ case   18:  		/* bc 12, CR6_EQ, 28 */
		/* 8225C750h case   18:*/		if ( regs.CR[6].eq ) { return 0x8225C76C;  }
		/* 8225C750h case   18:*/		return 0x8225C754;
		  /* 8225C754h */ case   19:  		/* mr R6, R22 */
		/* 8225C754h case   19:*/		regs.R6 = regs.R22;
		/* 8225C754h case   19:*/		return 0x8225C758;
		  /* 8225C758h */ case   20:  		/* mr R5, R21 */
		/* 8225C758h case   20:*/		regs.R5 = regs.R21;
		/* 8225C758h case   20:*/		return 0x8225C75C;
		  /* 8225C75Ch */ case   21:  		/* mr R4, R23 */
		/* 8225C75Ch case   21:*/		regs.R4 = regs.R23;
		/* 8225C75Ch case   21:*/		return 0x8225C760;
		  /* 8225C760h */ case   22:  		/* li R7, 1077 */
		/* 8225C760h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x435);
		/* 8225C760h case   22:*/		return 0x8225C764;
		  /* 8225C764h */ case   23:  		/* li R3, 0 */
		/* 8225C764h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C764h case   23:*/		return 0x8225C768;
		  /* 8225C768h */ case   24:  		/* bl -1067872 */
		/* 8225C768h case   24:*/		regs.LR = 0x8225C76C; return 0x82157C08;
		/* 8225C768h case   24:*/		return 0x8225C76C;
	}
	return 0x8225C76C;
} // Block from 8225C708h-8225C76Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225C76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C76C);
		  /* 8225C76Ch */ case    0:  		/* li R26, 0 */
		/* 8225C76Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8225C76Ch case    0:*/		return 0x8225C770;
		  /* 8225C770h */ case    1:  		/* cmpwi CR6, R24, -1 */
		/* 8225C770h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 8225C770h case    1:*/		return 0x8225C774;
		  /* 8225C774h */ case    2:  		/* bc 12, CR6_EQ, 360 */
		/* 8225C774h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225C8DC;  }
		/* 8225C774h case    2:*/		return 0x8225C778;
		  /* 8225C778h */ case    3:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225C778h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C778h case    3:*/		return 0x8225C77C;
		  /* 8225C77Ch */ case    4:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225C77Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225C77Ch case    4:*/		return 0x8225C780;
		  /* 8225C780h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 8225C780h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225C780h case    5:*/		return 0x8225C784;
		  /* 8225C784h */ case    6:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225C784h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225C784h case    6:*/		return 0x8225C788;
		  /* 8225C788h */ case    7:  		/* mtspr CTR, R11 */
		/* 8225C788h case    7:*/		regs.CTR = regs.R11;
		/* 8225C788h case    7:*/		return 0x8225C78C;
		  /* 8225C78Ch */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8225C78Ch case    8:*/		if ( 1 ) { regs.LR = 0x8225C790; return (uint32)regs.CTR; }
		/* 8225C78Ch case    8:*/		return 0x8225C790;
		  /* 8225C790h */ case    9:  		/* lis R11, -32222 */
		/* 8225C790h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225C790h case    9:*/		return 0x8225C794;
		  /* 8225C794h */ case   10:  		/* mr R5, R3 */
		/* 8225C794h case   10:*/		regs.R5 = regs.R3;
		/* 8225C794h case   10:*/		return 0x8225C798;
		  /* 8225C798h */ case   11:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225C798h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225C798h case   11:*/		return 0x8225C79C;
		  /* 8225C79Ch */ case   12:  		/* mr R4, R24 */
		/* 8225C79Ch case   12:*/		regs.R4 = regs.R24;
		/* 8225C79Ch case   12:*/		return 0x8225C7A0;
		  /* 8225C7A0h */ case   13:  		/* addi R6, R11, -12392 */
		/* 8225C7A0h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225C7A0h case   13:*/		return 0x8225C7A4;
		  /* 8225C7A4h */ case   14:  		/* mr R7, R30 */
		/* 8225C7A4h case   14:*/		regs.R7 = regs.R30;
		/* 8225C7A4h case   14:*/		return 0x8225C7A8;
		  /* 8225C7A8h */ case   15:  		/* bl -173000 */
		/* 8225C7A8h case   15:*/		regs.LR = 0x8225C7AC; return 0x822323E0;
		/* 8225C7A8h case   15:*/		return 0x8225C7AC;
		  /* 8225C7ACh */ case   16:  		/* cmpwi CR6, R3, 1 */
		/* 8225C7ACh case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225C7ACh case   16:*/		return 0x8225C7B0;
		  /* 8225C7B0h */ case   17:  		/* bc 4, CR6_EQ, 300 */
		/* 8225C7B0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8225C8DC;  }
		/* 8225C7B0h case   17:*/		return 0x8225C7B4;
		  /* 8225C7B4h */ case   18:  		/* lis R11, -32222 */
		/* 8225C7B4h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225C7B4h case   18:*/		return 0x8225C7B8;
		  /* 8225C7B8h */ case   19:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225C7B8h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C7B8h case   19:*/		return 0x8225C7BC;
		  /* 8225C7BCh */ case   20:  		/* addi R5, R1, 92 */
		/* 8225C7BCh case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 8225C7BCh case   20:*/		return 0x8225C7C0;
		  /* 8225C7C0h */ case   21:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225C7C0h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225C7C0h case   21:*/		return 0x8225C7C4;
		  /* 8225C7C4h */ case   22:  		/* addi R6, R11, -12392 */
		/* 8225C7C4h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225C7C4h case   22:*/		return 0x8225C7C8;
		  /* 8225C7C8h */ case   23:  		/* mr R4, R24 */
		/* 8225C7C8h case   23:*/		regs.R4 = regs.R24;
		/* 8225C7C8h case   23:*/		return 0x8225C7CC;
		  /* 8225C7CCh */ case   24:  		/* bl -166396 */
		/* 8225C7CCh case   24:*/		regs.LR = 0x8225C7D0; return 0x82233DD0;
		/* 8225C7CCh case   24:*/		return 0x8225C7D0;
		  /* 8225C7D0h */ case   25:  		/* li R3, 19 */
		/* 8225C7D0h case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 8225C7D0h case   25:*/		return 0x8225C7D4;
		  /* 8225C7D4h */ case   26:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225C7D4h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C7D4h case   26:*/		return 0x8225C7D8;
		  /* 8225C7D8h */ case   27:  		/* bl -26792 */
		/* 8225C7D8h case   27:*/		regs.LR = 0x8225C7DC; return 0x82255F30;
		/* 8225C7D8h case   27:*/		return 0x8225C7DC;
		  /* 8225C7DCh */ case   28:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225C7DCh case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C7DCh case   28:*/		return 0x8225C7E0;
		  /* 8225C7E0h */ case   29:  		/* mr R5, R25 */
		/* 8225C7E0h case   29:*/		regs.R5 = regs.R25;
		/* 8225C7E0h case   29:*/		return 0x8225C7E4;
		  /* 8225C7E4h */ case   30:  		/* li R4, 1 */
		/* 8225C7E4h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225C7E4h case   30:*/		return 0x8225C7E8;
		  /* 8225C7E8h */ case   31:  		/* mr R30, R3 */
		/* 8225C7E8h case   31:*/		regs.R30 = regs.R3;
		/* 8225C7E8h case   31:*/		return 0x8225C7EC;
		  /* 8225C7ECh */ case   32:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225C7ECh case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C7ECh case   32:*/		return 0x8225C7F0;
		  /* 8225C7F0h */ case   33:  		/* addi R29, R11, -1 */
		/* 8225C7F0h case   33:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 8225C7F0h case   33:*/		return 0x8225C7F4;
		  /* 8225C7F4h */ case   34:  		/* stw R29, <#[R10 + 1508]> */
		/* 8225C7F4h case   34:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225C7F4h case   34:*/		return 0x8225C7F8;
		  /* 8225C7F8h */ case   35:  		/* stw R29, <#[R3 + 56]> */
		/* 8225C7F8h case   35:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000038) );
		/* 8225C7F8h case   35:*/		return 0x8225C7FC;
		  /* 8225C7FCh */ case   36:  		/* stw R26, <#[R3 + 80]> */
		/* 8225C7FCh case   36:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000050) );
		/* 8225C7FCh case   36:*/		return 0x8225C800;
		  /* 8225C800h */ case   37:  		/* bl -25704 */
		/* 8225C800h case   37:*/		regs.LR = 0x8225C804; return 0x82256398;
		/* 8225C800h case   37:*/		return 0x8225C804;
		  /* 8225C804h */ case   38:  		/* lis R11, -32256 */
		/* 8225C804h case   38:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8225C804h case   38:*/		return 0x8225C808;
		  /* 8225C808h */ case   39:  		/* lfs FR13, <#[R1 + 92]> */
		/* 8225C808h case   39:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225C808h case   39:*/		return 0x8225C80C;
		  /* 8225C80Ch */ case   40:  		/* mr R3, R30 */
		/* 8225C80Ch case   40:*/		regs.R3 = regs.R30;
		/* 8225C80Ch case   40:*/		return 0x8225C810;
		  /* 8225C810h */ case   41:  		/* li R5, 2 */
		/* 8225C810h case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225C810h case   41:*/		return 0x8225C814;
		  /* 8225C814h */ case   42:  		/* mr R4, R31 */
		/* 8225C814h case   42:*/		regs.R4 = regs.R31;
		/* 8225C814h case   42:*/		return 0x8225C818;
		  /* 8225C818h */ case   43:  		/* lfs FR0, <#[R11 + 1792]> */
		/* 8225C818h case   43:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000700) );
		/* 8225C818h case   43:*/		return 0x8225C81C;
		  /* 8225C81Ch */ case   44:  		/* fdivs FR1, FR0, FR13 */
		/* 8225C81Ch case   44:*/		cpu::op::fdivs<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 8225C81Ch case   44:*/		return 0x8225C820;
		  /* 8225C820h */ case   45:  		/* fmr FR4, FR1 */
		/* 8225C820h case   45:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR1);
		/* 8225C820h case   45:*/		return 0x8225C824;
		  /* 8225C824h */ case   46:  		/* fmr FR3, FR1 */
		/* 8225C824h case   46:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR1);
		/* 8225C824h case   46:*/		return 0x8225C828;
		  /* 8225C828h */ case   47:  		/* fmr FR2, FR1 */
		/* 8225C828h case   47:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 8225C828h case   47:*/		return 0x8225C82C;
		  /* 8225C82Ch */ case   48:  		/* bl -22804 */
		/* 8225C82Ch case   48:*/		regs.LR = 0x8225C830; return 0x82256F18;
		/* 8225C82Ch case   48:*/		return 0x8225C830;
		  /* 8225C830h */ case   49:  		/* mr R4, R30 */
		/* 8225C830h case   49:*/		regs.R4 = regs.R30;
		/* 8225C830h case   49:*/		return 0x8225C834;
		  /* 8225C834h */ case   50:  		/* mr R3, R31 */
		/* 8225C834h case   50:*/		regs.R3 = regs.R31;
		/* 8225C834h case   50:*/		return 0x8225C838;
		  /* 8225C838h */ case   51:  		/* bl -156304 */
		/* 8225C838h case   51:*/		regs.LR = 0x8225C83C; return 0x822365A8;
		/* 8225C838h case   51:*/		return 0x8225C83C;
		  /* 8225C83Ch */ case   52:  		/* mr R4, R30 */
		/* 8225C83Ch case   52:*/		regs.R4 = regs.R30;
		/* 8225C83Ch case   52:*/		return 0x8225C840;
		  /* 8225C840h */ case   53:  		/* mr R3, R18 */
		/* 8225C840h case   53:*/		regs.R3 = regs.R18;
		/* 8225C840h case   53:*/		return 0x8225C844;
		  /* 8225C844h */ case   54:  		/* bl -14612 */
		/* 8225C844h case   54:*/		regs.LR = 0x8225C848; return 0x82258F30;
		/* 8225C844h case   54:*/		return 0x8225C848;
		  /* 8225C848h */ case   55:  		/* mr R3, R30 */
		/* 8225C848h case   55:*/		regs.R3 = regs.R30;
		/* 8225C848h case   55:*/		return 0x8225C84C;
		  /* 8225C84Ch */ case   56:  		/* bl -26764 */
		/* 8225C84Ch case   56:*/		regs.LR = 0x8225C850; return 0x82255FC0;
		/* 8225C84Ch case   56:*/		return 0x8225C850;
		  /* 8225C850h */ case   57:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225C850h case   57:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225C850h case   57:*/		return 0x8225C854;
		  /* 8225C854h */ case   58:  		/* bc 4, CR0_EQ, 32 */
		/* 8225C854h case   58:*/		if ( !regs.CR[0].eq ) { return 0x8225C874;  }
		/* 8225C854h case   58:*/		return 0x8225C858;
		  /* 8225C858h */ case   59:  		/* lis R11, -32252 */
		/* 8225C858h case   59:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225C858h case   59:*/		return 0x8225C85C;
		  /* 8225C85Ch */ case   60:  		/* mr R6, R22 */
		/* 8225C85Ch case   60:*/		regs.R6 = regs.R22;
		/* 8225C85Ch case   60:*/		return 0x8225C860;
		  /* 8225C860h */ case   61:  		/* addi R5, R11, 8972 */
		/* 8225C860h case   61:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x230C);
		/* 8225C860h case   61:*/		return 0x8225C864;
		  /* 8225C864h */ case   62:  		/* mr R4, R23 */
		/* 8225C864h case   62:*/		regs.R4 = regs.R23;
		/* 8225C864h case   62:*/		return 0x8225C868;
		  /* 8225C868h */ case   63:  		/* li R7, 1102 */
		/* 8225C868h case   63:*/		cpu::op::li<0>(regs,&regs.R7,0x44E);
		/* 8225C868h case   63:*/		return 0x8225C86C;
		  /* 8225C86Ch */ case   64:  		/* li R3, 0 */
		/* 8225C86Ch case   64:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C86Ch case   64:*/		return 0x8225C870;
		  /* 8225C870h */ case   65:  		/* bl -1068136 */
		/* 8225C870h case   65:*/		regs.LR = 0x8225C874; return 0x82157C08;
		/* 8225C870h case   65:*/		return 0x8225C874;
	}
	return 0x8225C874;
} // Block from 8225C76Ch-8225C874h (66 instructions)

//////////////////////////////////////////////////////
// Block at 8225C874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C874);
		  /* 8225C874h */ case    0:  		/* li R3, 21 */
		/* 8225C874h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x15);
		/* 8225C874h case    0:*/		return 0x8225C878;
		  /* 8225C878h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225C878h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C878h case    1:*/		return 0x8225C87C;
		  /* 8225C87Ch */ case    2:  		/* bl -26956 */
		/* 8225C87Ch case    2:*/		regs.LR = 0x8225C880; return 0x82255F30;
		/* 8225C87Ch case    2:*/		return 0x8225C880;
		  /* 8225C880h */ case    3:  		/* mr R30, R3 */
		/* 8225C880h case    3:*/		regs.R30 = regs.R3;
		/* 8225C880h case    3:*/		return 0x8225C884;
		  /* 8225C884h */ case    4:  		/* mr R3, R31 */
		/* 8225C884h case    4:*/		regs.R3 = regs.R31;
		/* 8225C884h case    4:*/		return 0x8225C888;
		  /* 8225C888h */ case    5:  		/* mr R4, R30 */
		/* 8225C888h case    5:*/		regs.R4 = regs.R30;
		/* 8225C888h case    5:*/		return 0x8225C88C;
		  /* 8225C88Ch */ case    6:  		/* stw R29, <#[R30 + 56]> */
		/* 8225C88Ch case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000038) );
		/* 8225C88Ch case    6:*/		return 0x8225C890;
		  /* 8225C890h */ case    7:  		/* stw R26, <#[R30 + 80]> */
		/* 8225C890h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000050) );
		/* 8225C890h case    7:*/		return 0x8225C894;
		  /* 8225C894h */ case    8:  		/* stw R29, <#[R30 + 60]> */
		/* 8225C894h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x0000003C) );
		/* 8225C894h case    8:*/		return 0x8225C898;
		  /* 8225C898h */ case    9:  		/* stw R26, <#[R30 + 84]> */
		/* 8225C898h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000054) );
		/* 8225C898h case    9:*/		return 0x8225C89C;
		  /* 8225C89Ch */ case   10:  		/* bl -156404 */
		/* 8225C89Ch case   10:*/		regs.LR = 0x8225C8A0; return 0x822365A8;
		/* 8225C89Ch case   10:*/		return 0x8225C8A0;
		  /* 8225C8A0h */ case   11:  		/* mr R4, R30 */
		/* 8225C8A0h case   11:*/		regs.R4 = regs.R30;
		/* 8225C8A0h case   11:*/		return 0x8225C8A4;
		  /* 8225C8A4h */ case   12:  		/* mr R3, R18 */
		/* 8225C8A4h case   12:*/		regs.R3 = regs.R18;
		/* 8225C8A4h case   12:*/		return 0x8225C8A8;
		  /* 8225C8A8h */ case   13:  		/* bl -14712 */
		/* 8225C8A8h case   13:*/		regs.LR = 0x8225C8AC; return 0x82258F30;
		/* 8225C8A8h case   13:*/		return 0x8225C8AC;
		  /* 8225C8ACh */ case   14:  		/* mr R3, R30 */
		/* 8225C8ACh case   14:*/		regs.R3 = regs.R30;
		/* 8225C8ACh case   14:*/		return 0x8225C8B0;
		  /* 8225C8B0h */ case   15:  		/* bl -26864 */
		/* 8225C8B0h case   15:*/		regs.LR = 0x8225C8B4; return 0x82255FC0;
		/* 8225C8B0h case   15:*/		return 0x8225C8B4;
		  /* 8225C8B4h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225C8B4h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225C8B4h case   16:*/		return 0x8225C8B8;
		  /* 8225C8B8h */ case   17:  		/* bc 4, CR0_EQ, 32 */
		/* 8225C8B8h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8225C8D8;  }
		/* 8225C8B8h case   17:*/		return 0x8225C8BC;
		  /* 8225C8BCh */ case   18:  		/* lis R11, -32251 */
		/* 8225C8BCh case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C8BCh case   18:*/		return 0x8225C8C0;
		  /* 8225C8C0h */ case   19:  		/* mr R6, R22 */
		/* 8225C8C0h case   19:*/		regs.R6 = regs.R22;
		/* 8225C8C0h case   19:*/		return 0x8225C8C4;
		  /* 8225C8C4h */ case   20:  		/* addi R5, R11, -20460 */
		/* 8225C8C4h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB014);
		/* 8225C8C4h case   20:*/		return 0x8225C8C8;
		  /* 8225C8C8h */ case   21:  		/* mr R4, R23 */
		/* 8225C8C8h case   21:*/		regs.R4 = regs.R23;
		/* 8225C8C8h case   21:*/		return 0x8225C8CC;
		  /* 8225C8CCh */ case   22:  		/* li R7, 1113 */
		/* 8225C8CCh case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x459);
		/* 8225C8CCh case   22:*/		return 0x8225C8D0;
		  /* 8225C8D0h */ case   23:  		/* li R3, 0 */
		/* 8225C8D0h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C8D0h case   23:*/		return 0x8225C8D4;
		  /* 8225C8D4h */ case   24:  		/* bl -1068236 */
		/* 8225C8D4h case   24:*/		regs.LR = 0x8225C8D8; return 0x82157C08;
		/* 8225C8D4h case   24:*/		return 0x8225C8D8;
	}
	return 0x8225C8D8;
} // Block from 8225C874h-8225C8D8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225C8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C8D8);
		  /* 8225C8D8h */ case    0:  		/* lwz R25, <#[R30 + 28]> */
		/* 8225C8D8h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R30 + 0x0000001C) );
		/* 8225C8D8h case    0:*/		return 0x8225C8DC;
	}
	return 0x8225C8DC;
} // Block from 8225C8D8h-8225C8DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225C8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C8DC);
		  /* 8225C8DCh */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 8225C8DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8225C8DCh case    0:*/		return 0x8225C8E0;
		  /* 8225C8E0h */ case    1:  		/* mr R28, R26 */
		/* 8225C8E0h case    1:*/		regs.R28 = regs.R26;
		/* 8225C8E0h case    1:*/		return 0x8225C8E4;
		  /* 8225C8E4h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8225C8E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225C8E4h case    2:*/		return 0x8225C8E8;
		  /* 8225C8E8h */ case    3:  		/* bc 4, CR6_GT, 372 */
		/* 8225C8E8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8225CA5C;  }
		/* 8225C8E8h case    3:*/		return 0x8225C8EC;
		  /* 8225C8ECh */ case    4:  		/* lis R11, -32251 */
		/* 8225C8ECh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225C8ECh case    4:*/		return 0x8225C8F0;
		  /* 8225C8F0h */ case    5:  		/* addi R27, R11, -31472 */
		/* 8225C8F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFF8510);
		/* 8225C8F0h case    5:*/		return 0x8225C8F4;
		  /* 8225C8F4h */ case    6:  		/* mr R6, R28 */
		/* 8225C8F4h case    6:*/		regs.R6 = regs.R28;
		/* 8225C8F4h case    6:*/		return 0x8225C8F8;
		  /* 8225C8F8h */ case    7:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225C8F8h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C8F8h case    7:*/		return 0x8225C8FC;
		  /* 8225C8FCh */ case    8:  		/* mr R5, R24 */
		/* 8225C8FCh case    8:*/		regs.R5 = regs.R24;
		/* 8225C8FCh case    8:*/		return 0x8225C900;
		  /* 8225C900h */ case    9:  		/* li R3, 104 */
		/* 8225C900h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x68);
		/* 8225C900h case    9:*/		return 0x8225C904;
		  /* 8225C904h */ case   10:  		/* bl -17492 */
		/* 8225C904h case   10:*/		regs.LR = 0x8225C908; return 0x822584B0;
		/* 8225C904h case   10:*/		return 0x8225C908;
		  /* 8225C908h */ case   11:  		/* mr R5, R19 */
		/* 8225C908h case   11:*/		regs.R5 = regs.R19;
		/* 8225C908h case   11:*/		return 0x8225C90C;
		  /* 8225C90Ch */ case   12:  		/* li R4, 0 */
		/* 8225C90Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225C90Ch case   12:*/		return 0x8225C910;
		  /* 8225C910h */ case   13:  		/* mr R30, R3 */
		/* 8225C910h case   13:*/		regs.R30 = regs.R3;
		/* 8225C910h case   13:*/		return 0x8225C914;
		  /* 8225C914h */ case   14:  		/* bl -25980 */
		/* 8225C914h case   14:*/		regs.LR = 0x8225C918; return 0x82256398;
		/* 8225C914h case   14:*/		return 0x8225C918;
		  /* 8225C918h */ case   15:  		/* mr R5, R25 */
		/* 8225C918h case   15:*/		regs.R5 = regs.R25;
		/* 8225C918h case   15:*/		return 0x8225C91C;
		  /* 8225C91Ch */ case   16:  		/* li R4, 1 */
		/* 8225C91Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225C91Ch case   16:*/		return 0x8225C920;
		  /* 8225C920h */ case   17:  		/* mr R3, R30 */
		/* 8225C920h case   17:*/		regs.R3 = regs.R30;
		/* 8225C920h case   17:*/		return 0x8225C924;
		  /* 8225C924h */ case   18:  		/* bl -25996 */
		/* 8225C924h case   18:*/		regs.LR = 0x8225C928; return 0x82256398;
		/* 8225C924h case   18:*/		return 0x8225C928;
		  /* 8225C928h */ case   19:  		/* cmplwi CR6, R20, 0 */
		/* 8225C928h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8225C928h case   19:*/		return 0x8225C92C;
		  /* 8225C92Ch */ case   20:  		/* bc 4, CR6_EQ, 40 */
		/* 8225C92Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x8225C954;  }
		/* 8225C92Ch case   20:*/		return 0x8225C930;
		  /* 8225C930h */ case   21:  		/* lwz R11, <#[R27 - 36]> */
		/* 8225C930h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFFDC) );
		/* 8225C930h case   21:*/		return 0x8225C934;
		  /* 8225C934h */ case   22:  		/* mr R7, R30 */
		/* 8225C934h case   22:*/		regs.R7 = regs.R30;
		/* 8225C934h case   22:*/		return 0x8225C938;
		  /* 8225C938h */ case   23:  		/* li R6, 1 */
		/* 8225C938h case   23:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225C938h case   23:*/		return 0x8225C93C;
		  /* 8225C93Ch */ case   24:  		/* mr R5, R17 */
		/* 8225C93Ch case   24:*/		regs.R5 = regs.R17;
		/* 8225C93Ch case   24:*/		return 0x8225C940;
		  /* 8225C940h */ case   25:  		/* addi R4, R1, 84 */
		/* 8225C940h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8225C940h case   25:*/		return 0x8225C944;
		  /* 8225C944h */ case   26:  		/* mr R3, R31 */
		/* 8225C944h case   26:*/		regs.R3 = regs.R31;
		/* 8225C944h case   26:*/		return 0x8225C948;
		  /* 8225C948h */ case   27:  		/* stw R11, <#[R1 + 84]> */
		/* 8225C948h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225C948h case   27:*/		return 0x8225C94C;
		  /* 8225C94Ch */ case   28:  		/* bl -8524 */
		/* 8225C94Ch case   28:*/		regs.LR = 0x8225C950; return 0x8225A800;
		/* 8225C94Ch case   28:*/		return 0x8225C950;
		  /* 8225C950h */ case   29:  		/* b 12 */
		/* 8225C950h case   29:*/		return 0x8225C95C;
		/* 8225C950h case   29:*/		return 0x8225C954;
	}
	return 0x8225C954;
} // Block from 8225C8DCh-8225C954h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8225C954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C954);
		  /* 8225C954h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8225C954h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8225C954h case    0:*/		return 0x8225C958;
		  /* 8225C958h */ case    1:  		/* stw R11, <#[R30 + 132]> */
		/* 8225C958h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225C958h case    1:*/		return 0x8225C95C;
	}
	return 0x8225C95C;
} // Block from 8225C954h-8225C95Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225C95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C95C);
		  /* 8225C95Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225C95Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225C95Ch case    0:*/		return 0x8225C960;
		  /* 8225C960h */ case    1:  		/* lis R10, -32222 */
		/* 8225C960h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 8225C960h case    1:*/		return 0x8225C964;
		  /* 8225C964h */ case    2:  		/* addi R6, R1, 96 */
		/* 8225C964h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 8225C964h case    2:*/		return 0x8225C968;
		  /* 8225C968h */ case    3:  		/* mr R9, R11 */
		/* 8225C968h case    3:*/		regs.R9 = regs.R11;
		/* 8225C968h case    3:*/		return 0x8225C96C;
		  /* 8225C96Ch */ case    4:  		/* addi R8, R10, -12392 */
		/* 8225C96Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFCF98);
		/* 8225C96Ch case    4:*/		return 0x8225C970;
		  /* 8225C970h */ case    5:  		/* mr R5, R28 */
		/* 8225C970h case    5:*/		regs.R5 = regs.R28;
		/* 8225C970h case    5:*/		return 0x8225C974;
		  /* 8225C974h */ case    6:  		/* mr R4, R24 */
		/* 8225C974h case    6:*/		regs.R4 = regs.R24;
		/* 8225C974h case    6:*/		return 0x8225C978;
		  /* 8225C978h */ case    7:  		/* lwz R3, <#[R11 + 1536]> */
		/* 8225C978h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000600) );
		/* 8225C978h case    7:*/		return 0x8225C97C;
		  /* 8225C97Ch */ case    8:  		/* lwz R7, <#[R11 + 1384]> */
		/* 8225C97Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000568) );
		/* 8225C97Ch case    8:*/		return 0x8225C980;
		  /* 8225C980h */ case    9:  		/* bl -171512 */
		/* 8225C980h case    9:*/		regs.LR = 0x8225C984; return 0x82232B88;
		/* 8225C980h case    9:*/		return 0x8225C984;
		  /* 8225C984h */ case   10:  		/* cmpwi CR6, R3, 1 */
		/* 8225C984h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225C984h case   10:*/		return 0x8225C988;
		  /* 8225C988h */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 8225C988h case   11:*/		if ( regs.CR[6].eq ) { return 0x8225C9A4;  }
		/* 8225C988h case   11:*/		return 0x8225C98C;
		  /* 8225C98Ch */ case   12:  		/* mr R6, R22 */
		/* 8225C98Ch case   12:*/		regs.R6 = regs.R22;
		/* 8225C98Ch case   12:*/		return 0x8225C990;
		  /* 8225C990h */ case   13:  		/* mr R5, R21 */
		/* 8225C990h case   13:*/		regs.R5 = regs.R21;
		/* 8225C990h case   13:*/		return 0x8225C994;
		  /* 8225C994h */ case   14:  		/* mr R4, R23 */
		/* 8225C994h case   14:*/		regs.R4 = regs.R23;
		/* 8225C994h case   14:*/		return 0x8225C998;
		  /* 8225C998h */ case   15:  		/* li R7, 1146 */
		/* 8225C998h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x47A);
		/* 8225C998h case   15:*/		return 0x8225C99C;
		  /* 8225C99Ch */ case   16:  		/* li R3, 0 */
		/* 8225C99Ch case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225C99Ch case   16:*/		return 0x8225C9A0;
		  /* 8225C9A0h */ case   17:  		/* bl -1068440 */
		/* 8225C9A0h case   17:*/		regs.LR = 0x8225C9A4; return 0x82157C08;
		/* 8225C9A0h case   17:*/		return 0x8225C9A4;
	}
	return 0x8225C9A4;
} // Block from 8225C95Ch-8225C9A4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225C9A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225C9A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225C9A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225C9A4);
		  /* 8225C9A4h */ case    0:  		/* stw R16, <#[R1 + 84]> */
		/* 8225C9A4h case    0:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x00000054) );
		/* 8225C9A4h case    0:*/		return 0x8225C9A8;
		  /* 8225C9A8h */ case    1:  		/* mr R29, R26 */
		/* 8225C9A8h case    1:*/		regs.R29 = regs.R26;
		/* 8225C9A8h case    1:*/		return 0x8225C9AC;
		  /* 8225C9ACh */ case    2:  		/* lwz R11, <#[R1 + 96]> */
		/* 8225C9ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8225C9ACh case    2:*/		return 0x8225C9B0;
		  /* 8225C9B0h */ case    3:  		/* lbzx R3, <#[R29 + R11]> */
		/* 8225C9B0h case    3:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8225C9B0h case    3:*/		return 0x8225C9B4;
		  /* 8225C9B4h */ case    4:  		/* bl -10132 */
		/* 8225C9B4h case    4:*/		regs.LR = 0x8225C9B8; return 0x8225A220;
		/* 8225C9B4h case    4:*/		return 0x8225C9B8;
		  /* 8225C9B8h */ case    5:  		/* addi R11, R1, 80 */
		/* 8225C9B8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8225C9B8h case    5:*/		return 0x8225C9BC;
		  /* 8225C9BCh */ case    6:  		/* rlwinm R10, R3, 0, 24, 31 */
		/* 8225C9BCh case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R3);
		/* 8225C9BCh case    6:*/		return 0x8225C9C0;
		  /* 8225C9C0h */ case    7:  		/* stbx R10, <#[R29 + R11]> */
		/* 8225C9C0h case    7:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8225C9C0h case    7:*/		return 0x8225C9C4;
		  /* 8225C9C4h */ case    8:  		/* addi R29, R29, 1 */
		/* 8225C9C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8225C9C4h case    8:*/		return 0x8225C9C8;
		  /* 8225C9C8h */ case    9:  		/* cmpwi CR6, R29, 4 */
		/* 8225C9C8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 8225C9C8h case    9:*/		return 0x8225C9CC;
		  /* 8225C9CCh */ case   10:  		/* bc 12, CR6_LT, -32 */
		/* 8225C9CCh case   10:*/		if ( regs.CR[6].lt ) { return 0x8225C9AC;  }
		/* 8225C9CCh case   10:*/		return 0x8225C9D0;
		  /* 8225C9D0h */ case   11:  		/* li R10, 4 */
		/* 8225C9D0h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8225C9D0h case   11:*/		return 0x8225C9D4;
		  /* 8225C9D4h */ case   12:  		/* mr R11, R26 */
		/* 8225C9D4h case   12:*/		regs.R11 = regs.R26;
		/* 8225C9D4h case   12:*/		return 0x8225C9D8;
		  /* 8225C9D8h */ case   13:  		/* mtspr CTR, R10 */
		/* 8225C9D8h case   13:*/		regs.CTR = regs.R10;
		/* 8225C9D8h case   13:*/		return 0x8225C9DC;
		  /* 8225C9DCh */ case   14:  		/* addi R9, R1, 84 */
		/* 8225C9DCh case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 8225C9DCh case   14:*/		return 0x8225C9E0;
		  /* 8225C9E0h */ case   15:  		/* lbzx R10, <#[R11 + R9]> */
		/* 8225C9E0h case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8225C9E0h case   15:*/		return 0x8225C9E4;
		  /* 8225C9E4h */ case   16:  		/* cmpwi CR6, R10, 4 */
		/* 8225C9E4h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 8225C9E4h case   16:*/		return 0x8225C9E8;
		  /* 8225C9E8h */ case   17:  		/* bc 12, CR6_LT, 60 */
		/* 8225C9E8h case   17:*/		if ( regs.CR[6].lt ) { return 0x8225CA24;  }
		/* 8225C9E8h case   17:*/		return 0x8225C9EC;
		  /* 8225C9ECh */ case   18:  		/* cmpwi CR6, R10, 7 */
		/* 8225C9ECh case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000007);
		/* 8225C9ECh case   18:*/		return 0x8225C9F0;
		  /* 8225C9F0h */ case   19:  		/* bc 12, CR6_GT, 52 */
		/* 8225C9F0h case   19:*/		if ( regs.CR[6].gt ) { return 0x8225CA24;  }
		/* 8225C9F0h case   19:*/		return 0x8225C9F4;
		  /* 8225C9F4h */ case   20:  		/* addi R8, R1, 80 */
		/* 8225C9F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8225C9F4h case   20:*/		return 0x8225C9F8;
		  /* 8225C9F8h */ case   21:  		/* add R10, R10, R8 */
		/* 8225C9F8h case   21:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8225C9F8h case   21:*/		return 0x8225C9FC;
		  /* 8225C9FCh */ case   22:  		/* lbz R10, <#[R10 - 4]> */
		/* 8225C9FCh case   22:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8225C9FCh case   22:*/		return 0x8225CA00;
		  /* 8225CA00h */ case   23:  		/* cmpwi CR6, R10, 4 */
		/* 8225CA00h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 8225CA00h case   23:*/		return 0x8225CA04;
		  /* 8225CA04h */ case   24:  		/* bc 12, CR6_LT, 20 */
		/* 8225CA04h case   24:*/		if ( regs.CR[6].lt ) { return 0x8225CA18;  }
		/* 8225CA04h case   24:*/		return 0x8225CA08;
		  /* 8225CA08h */ case   25:  		/* cmpwi CR6, R10, 7 */
		/* 8225CA08h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000007);
		/* 8225CA08h case   25:*/		return 0x8225CA0C;
		  /* 8225CA0Ch */ case   26:  		/* bc 12, CR6_GT, 12 */
		/* 8225CA0Ch case   26:*/		if ( regs.CR[6].gt ) { return 0x8225CA18;  }
		/* 8225CA0Ch case   26:*/		return 0x8225CA10;
		  /* 8225CA10h */ case   27:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 8225CA10h case   27:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8225CA10h case   27:*/		return 0x8225CA14;
		  /* 8225CA14h */ case   28:  		/* b 12 */
		/* 8225CA14h case   28:*/		return 0x8225CA20;
		/* 8225CA14h case   28:*/		return 0x8225CA18;
	}
	return 0x8225CA18;
} // Block from 8225C9A4h-8225CA18h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8225CA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CA18);
		  /* 8225CA18h */ case    0:  		/* addi R10, R1, 80 */
		/* 8225CA18h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8225CA18h case    0:*/		return 0x8225CA1C;
		  /* 8225CA1Ch */ case    1:  		/* lbzx R10, <#[R11 + R10]> */
		/* 8225CA1Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225CA1Ch case    1:*/		return 0x8225CA20;
	}
	return 0x8225CA20;
} // Block from 8225CA18h-8225CA20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225CA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CA20);
		  /* 8225CA20h */ case    0:  		/* stbx R10, <#[R11 + R9]> */
		/* 8225CA20h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8225CA20h case    0:*/		return 0x8225CA24;
	}
	return 0x8225CA24;
} // Block from 8225CA20h-8225CA24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225CA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CA24);
		  /* 8225CA24h */ case    0:  		/* addi R11, R11, 1 */
		/* 8225CA24h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225CA24h case    0:*/		return 0x8225CA28;
		  /* 8225CA28h */ case    1:  		/* bc 16, CR0_LT, -76 */
		/* 8225CA28h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8225C9DC;  }
		/* 8225CA28h case    1:*/		return 0x8225CA2C;
		  /* 8225CA2Ch */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 8225CA2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225CA2Ch case    2:*/		return 0x8225CA30;
		  /* 8225CA30h */ case    3:  		/* mr R4, R30 */
		/* 8225CA30h case    3:*/		regs.R4 = regs.R30;
		/* 8225CA30h case    3:*/		return 0x8225CA34;
		  /* 8225CA34h */ case    4:  		/* mr R3, R31 */
		/* 8225CA34h case    4:*/		regs.R3 = regs.R31;
		/* 8225CA34h case    4:*/		return 0x8225CA38;
		  /* 8225CA38h */ case    5:  		/* stw R11, <#[R30 + 128]> */
		/* 8225CA38h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225CA38h case    5:*/		return 0x8225CA3C;
		  /* 8225CA3Ch */ case    6:  		/* bl -156820 */
		/* 8225CA3Ch case    6:*/		regs.LR = 0x8225CA40; return 0x822365A8;
		/* 8225CA3Ch case    6:*/		return 0x8225CA40;
		  /* 8225CA40h */ case    7:  		/* mr R4, R30 */
		/* 8225CA40h case    7:*/		regs.R4 = regs.R30;
		/* 8225CA40h case    7:*/		return 0x8225CA44;
		  /* 8225CA44h */ case    8:  		/* mr R3, R18 */
		/* 8225CA44h case    8:*/		regs.R3 = regs.R18;
		/* 8225CA44h case    8:*/		return 0x8225CA48;
		  /* 8225CA48h */ case    9:  		/* bl -15128 */
		/* 8225CA48h case    9:*/		regs.LR = 0x8225CA4C; return 0x82258F30;
		/* 8225CA48h case    9:*/		return 0x8225CA4C;
		  /* 8225CA4Ch */ case   10:  		/* lwz R11, <#[R1 + 88]> */
		/* 8225CA4Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8225CA4Ch case   10:*/		return 0x8225CA50;
		  /* 8225CA50h */ case   11:  		/* addi R28, R28, 1 */
		/* 8225CA50h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8225CA50h case   11:*/		return 0x8225CA54;
		  /* 8225CA54h */ case   12:  		/* cmpw CR6, R28, R11 */
		/* 8225CA54h case   12:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 8225CA54h case   12:*/		return 0x8225CA58;
		  /* 8225CA58h */ case   13:  		/* bc 12, CR6_LT, -356 */
		/* 8225CA58h case   13:*/		if ( regs.CR[6].lt ) { return 0x8225C8F4;  }
		/* 8225CA58h case   13:*/		return 0x8225CA5C;
	}
	return 0x8225CA5C;
} // Block from 8225CA24h-8225CA5Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225CA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CA5C);
		  /* 8225CA5Ch */ case    0:  		/* li R11, 1 */
		/* 8225CA5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225CA5Ch case    0:*/		return 0x8225CA60;
		  /* 8225CA60h */ case    1:  		/* stb R11, <#[R25 + 29]> */
		/* 8225CA60h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R25 + 0x0000001D) );
		/* 8225CA60h case    1:*/		return 0x8225CA64;
		  /* 8225CA64h */ case    2:  		/* addi R1, R1, 240 */
		/* 8225CA64h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8225CA64h case    2:*/		return 0x8225CA68;
		  /* 8225CA68h */ case    3:  		/* b -1882096 */
		/* 8225CA68h case    3:*/		return 0x82091278;
		/* 8225CA68h case    3:*/		return 0x8225CA6C;
		  /* 8225CA6Ch */ case    4:  		/* nop */
		/* 8225CA6Ch case    4:*/		cpu::op::nop();
		/* 8225CA6Ch case    4:*/		return 0x8225CA70;
	}
	return 0x8225CA70;
} // Block from 8225CA5Ch-8225CA70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225CA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CA70);
		  /* 8225CA70h */ case    0:  		/* mfspr R12, LR */
		/* 8225CA70h case    0:*/		regs.R12 = regs.LR;
		/* 8225CA70h case    0:*/		return 0x8225CA74;
		  /* 8225CA74h */ case    1:  		/* bl -1882152 */
		/* 8225CA74h case    1:*/		regs.LR = 0x8225CA78; return 0x8209124C;
		/* 8225CA74h case    1:*/		return 0x8225CA78;
		  /* 8225CA78h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8225CA78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8225CA78h case    2:*/		return 0x8225CA7C;
		  /* 8225CA7Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 8225CA7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8225CA7Ch case    3:*/		return 0x8225CA80;
		  /* 8225CA80h */ case    4:  		/* mr R30, R4 */
		/* 8225CA80h case    4:*/		regs.R30 = regs.R4;
		/* 8225CA80h case    4:*/		return 0x8225CA84;
		  /* 8225CA84h */ case    5:  		/* li R4, 16 */
		/* 8225CA84h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8225CA84h case    5:*/		return 0x8225CA88;
		  /* 8225CA88h */ case    6:  		/* mr R29, R5 */
		/* 8225CA88h case    6:*/		regs.R29 = regs.R5;
		/* 8225CA88h case    6:*/		return 0x8225CA8C;
		  /* 8225CA8Ch */ case    7:  		/* mr R28, R6 */
		/* 8225CA8Ch case    7:*/		regs.R28 = regs.R6;
		/* 8225CA8Ch case    7:*/		return 0x8225CA90;
		  /* 8225CA90h */ case    8:  		/* mr R27, R7 */
		/* 8225CA90h case    8:*/		regs.R27 = regs.R7;
		/* 8225CA90h case    8:*/		return 0x8225CA94;
		  /* 8225CA94h */ case    9:  		/* lwz R25, <#[R11 + 1456]> */
		/* 8225CA94h case    9:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225CA94h case    9:*/		return 0x8225CA98;
		  /* 8225CA98h */ case   10:  		/* mr R26, R8 */
		/* 8225CA98h case   10:*/		regs.R26 = regs.R8;
		/* 8225CA98h case   10:*/		return 0x8225CA9C;
		  /* 8225CA9Ch */ case   11:  		/* mr R3, R25 */
		/* 8225CA9Ch case   11:*/		regs.R3 = regs.R25;
		/* 8225CA9Ch case   11:*/		return 0x8225CAA0;
		  /* 8225CAA0h */ case   12:  		/* bl -263656 */
		/* 8225CAA0h case   12:*/		regs.LR = 0x8225CAA4; return 0x8221C4B8;
		/* 8225CAA0h case   12:*/		return 0x8225CAA4;
		  /* 8225CAA4h */ case   13:  		/* stw R25, <#[R3]> */
		/* 8225CAA4h case   13:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000000) );
		/* 8225CAA4h case   13:*/		return 0x8225CAA8;
		  /* 8225CAA8h */ case   14:  		/* stw R30, <#[R3 + 4]> */
		/* 8225CAA8h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 8225CAA8h case   14:*/		return 0x8225CAAC;
		  /* 8225CAACh */ case   15:  		/* addi R31, R3, 4 */
		/* 8225CAACh case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 8225CAACh case   15:*/		return 0x8225CAB0;
		  /* 8225CAB0h */ case   16:  		/* lwz R11, <#[R29]> */
		/* 8225CAB0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225CAB0h case   16:*/		return 0x8225CAB4;
		  /* 8225CAB4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 8225CAB4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8225CAB4h case   17:*/		return 0x8225CAB8;
		  /* 8225CAB8h */ case   18:  		/* stw R28, <#[R3 + 12]> */
		/* 8225CAB8h case   18:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x0000000C) );
		/* 8225CAB8h case   18:*/		return 0x8225CABC;
		  /* 8225CABCh */ case   19:  		/* mr R3, R26 */
		/* 8225CABCh case   19:*/		regs.R3 = regs.R26;
		/* 8225CABCh case   19:*/		return 0x8225CAC0;
		  /* 8225CAC0h */ case   20:  		/* lwz R4, <#[R26 + 4]> */
		/* 8225CAC0h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000004) );
		/* 8225CAC0h case   20:*/		return 0x8225CAC4;
		  /* 8225CAC4h */ case   21:  		/* bl -36868 */
		/* 8225CAC4h case   21:*/		regs.LR = 0x8225CAC8; return 0x82253AC0;
		/* 8225CAC4h case   21:*/		return 0x8225CAC8;
		  /* 8225CAC8h */ case   22:  		/* mr R11, R3 */
		/* 8225CAC8h case   22:*/		regs.R11 = regs.R3;
		/* 8225CAC8h case   22:*/		return 0x8225CACC;
		  /* 8225CACCh */ case   23:  		/* li R10, -1 */
		/* 8225CACCh case   23:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8225CACCh case   23:*/		return 0x8225CAD0;
		  /* 8225CAD0h */ case   24:  		/* stw R31, <#[R11]> */
		/* 8225CAD0h case   24:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8225CAD0h case   24:*/		return 0x8225CAD4;
		  /* 8225CAD4h */ case   25:  		/* mr R3, R27 */
		/* 8225CAD4h case   25:*/		regs.R3 = regs.R27;
		/* 8225CAD4h case   25:*/		return 0x8225CAD8;
	}
	return 0x8225CAD8;
} // Block from 8225CA70h-8225CAD8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225CAD8h
// Function '?ExpandDstModifiers@CFG@XGRAPHICS@@AAAXPAVDList@2@PATIL_Dst@2@PAV?$stack@PAVLoopHeader@XGRAPHICS@@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CAD8);
		  /* 8225CAD8h */ case    0:  		/* stw R10, <#[R29]> */
		/* 8225CAD8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8225CAD8h case    0:*/		return 0x8225CADC;
		  /* 8225CADCh */ case    1:  		/* addi R1, R1, 144 */
		/* 8225CADCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8225CADCh case    1:*/		return 0x8225CAE0;
		  /* 8225CAE0h */ case    2:  		/* b -1882180 */
		/* 8225CAE0h case    2:*/		return 0x8209129C;
		/* 8225CAE0h case    2:*/		return 0x8225CAE4;
		  /* 8225CAE4h */ case    3:  		/* nop */
		/* 8225CAE4h case    3:*/		cpu::op::nop();
		/* 8225CAE4h case    3:*/		return 0x8225CAE8;
	}
	return 0x8225CAE8;
} // Block from 8225CAD8h-8225CAE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225CAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CAE8);
		  /* 8225CAE8h */ case    0:  		/* mfspr R12, LR */
		/* 8225CAE8h case    0:*/		regs.R12 = regs.LR;
		/* 8225CAE8h case    0:*/		return 0x8225CAEC;
		  /* 8225CAECh */ case    1:  		/* bl -1882284 */
		/* 8225CAECh case    1:*/		regs.LR = 0x8225CAF0; return 0x82091240;
		/* 8225CAECh case    1:*/		return 0x8225CAF0;
		  /* 8225CAF0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8225CAF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8225CAF0h case    2:*/		return 0x8225CAF4;
		  /* 8225CAF4h */ case    3:  		/* lis R11, -32253 */
		/* 8225CAF4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8225CAF4h case    3:*/		return 0x8225CAF8;
		  /* 8225CAF8h */ case    4:  		/* stw R5, <#[R1 + 212]> */
		/* 8225CAF8h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225CAF8h case    4:*/		return 0x8225CAFC;
		  /* 8225CAFCh */ case    5:  		/* lis R10, -32251 */
		/* 8225CAFCh case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225CAFCh case    5:*/		return 0x8225CB00;
		  /* 8225CB00h */ case    6:  		/* mr R26, R3 */
		/* 8225CB00h case    6:*/		regs.R26 = regs.R3;
		/* 8225CB00h case    6:*/		return 0x8225CB04;
		  /* 8225CB04h */ case    7:  		/* mr R27, R4 */
		/* 8225CB04h case    7:*/		regs.R27 = regs.R4;
		/* 8225CB04h case    7:*/		return 0x8225CB08;
		  /* 8225CB08h */ case    8:  		/* mr R24, R6 */
		/* 8225CB08h case    8:*/		regs.R24 = regs.R6;
		/* 8225CB08h case    8:*/		return 0x8225CB0C;
		  /* 8225CB0Ch */ case    9:  		/* mr R25, R8 */
		/* 8225CB0Ch case    9:*/		regs.R25 = regs.R8;
		/* 8225CB0Ch case    9:*/		return 0x8225CB10;
		  /* 8225CB10h */ case   10:  		/* mr R23, R9 */
		/* 8225CB10h case   10:*/		regs.R23 = regs.R9;
		/* 8225CB10h case   10:*/		return 0x8225CB14;
		  /* 8225CB14h */ case   11:  		/* cmpwi CR6, R7, 0 */
		/* 8225CB14h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8225CB14h case   11:*/		return 0x8225CB18;
		  /* 8225CB18h */ case   12:  		/* addi R29, R11, 27460 */
		/* 8225CB18h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6B44);
		/* 8225CB18h case   12:*/		return 0x8225CB1C;
		  /* 8225CB1Ch */ case   13:  		/* addi R28, R10, -21904 */
		/* 8225CB1Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFFAA70);
		/* 8225CB1Ch case   13:*/		return 0x8225CB20;
		  /* 8225CB20h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 8225CB20h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8225CB2C;  }
		/* 8225CB20h case   14:*/		return 0x8225CB24;
		  /* 8225CB24h */ case   15:  		/* cmplwi CR6, R8, 0 */
		/* 8225CB24h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8225CB24h case   15:*/		return 0x8225CB28;
		  /* 8225CB28h */ case   16:  		/* bc 4, CR6_EQ, 32 */
		/* 8225CB28h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8225CB48;  }
		/* 8225CB28h case   16:*/		return 0x8225CB2C;
	}
	return 0x8225CB2C;
} // Block from 8225CAE8h-8225CB2Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8225CB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CB2C);
		  /* 8225CB2Ch */ case    0:  		/* lis R11, -32251 */
		/* 8225CB2Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CB2Ch case    0:*/		return 0x8225CB30;
		  /* 8225CB30h */ case    1:  		/* mr R6, R28 */
		/* 8225CB30h case    1:*/		regs.R6 = regs.R28;
		/* 8225CB30h case    1:*/		return 0x8225CB34;
		  /* 8225CB34h */ case    2:  		/* addi R5, R11, -20256 */
		/* 8225CB34h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB0E0);
		/* 8225CB34h case    2:*/		return 0x8225CB38;
		  /* 8225CB38h */ case    3:  		/* mr R4, R29 */
		/* 8225CB38h case    3:*/		regs.R4 = regs.R29;
		/* 8225CB38h case    3:*/		return 0x8225CB3C;
		  /* 8225CB3Ch */ case    4:  		/* li R7, 4355 */
		/* 8225CB3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1103);
		/* 8225CB3Ch case    4:*/		return 0x8225CB40;
		  /* 8225CB40h */ case    5:  		/* li R3, 0 */
		/* 8225CB40h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225CB40h case    5:*/		return 0x8225CB44;
		  /* 8225CB44h */ case    6:  		/* bl -1068860 */
		/* 8225CB44h case    6:*/		regs.LR = 0x8225CB48; return 0x82157C08;
		/* 8225CB44h case    6:*/		return 0x8225CB48;
	}
	return 0x8225CB48;
} // Block from 8225CB2Ch-8225CB48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225CB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CB48);
		  /* 8225CB48h */ case    0:  		/* li R31, 0 */
		/* 8225CB48h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8225CB48h case    0:*/		return 0x8225CB4C;
		  /* 8225CB4Ch */ case    1:  		/* li R22, 1 */
		/* 8225CB4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 8225CB4Ch case    1:*/		return 0x8225CB50;
		  /* 8225CB50h */ case    2:  		/* stb R31, <#[R1 + 80]> */
		/* 8225CB50h case    2:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8225CB50h case    2:*/		return 0x8225CB54;
		  /* 8225CB54h */ case    3:  		/* cmplwi CR6, R24, 0 */
		/* 8225CB54h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8225CB54h case    3:*/		return 0x8225CB58;
		  /* 8225CB58h */ case    4:  		/* stb R31, <#[R1 + 81]> */
		/* 8225CB58h case    4:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R1 + 0x00000051) );
		/* 8225CB58h case    4:*/		return 0x8225CB5C;
		  /* 8225CB5Ch */ case    5:  		/* stb R31, <#[R1 + 82]> */
		/* 8225CB5Ch case    5:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R1 + 0x00000052) );
		/* 8225CB5Ch case    5:*/		return 0x8225CB60;
		  /* 8225CB60h */ case    6:  		/* stb R31, <#[R1 + 83]> */
		/* 8225CB60h case    6:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R1 + 0x00000053) );
		/* 8225CB60h case    6:*/		return 0x8225CB64;
		  /* 8225CB64h */ case    7:  		/* bc 12, CR6_EQ, 452 */
		/* 8225CB64h case    7:*/		if ( regs.CR[6].eq ) { return 0x8225CD28;  }
		/* 8225CB64h case    7:*/		return 0x8225CB68;
		  /* 8225CB68h */ case    8:  		/* lwz R11, <#[R24]> */
		/* 8225CB68h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8225CB68h case    8:*/		return 0x8225CB6C;
		  /* 8225CB6Ch */ case    9:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8225CB6Ch case    9:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8225CB6Ch case    9:*/		return 0x8225CB70;
		  /* 8225CB70h */ case   10:  		/* bc 12, CR0_EQ, 296 */
		/* 8225CB70h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225CC98;  }
		/* 8225CB70h case   10:*/		return 0x8225CB74;
		  /* 8225CB74h */ case   11:  		/* mr R3, R26 */
		/* 8225CB74h case   11:*/		regs.R3 = regs.R26;
		/* 8225CB74h case   11:*/		return 0x8225CB78;
		  /* 8225CB78h */ case   12:  		/* bl -159424 */
		/* 8225CB78h case   12:*/		regs.LR = 0x8225CB7C; return 0x82235CB8;
		/* 8225CB78h case   12:*/		return 0x8225CB7C;
		  /* 8225CB7Ch */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225CB7Ch case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225CB7Ch case   13:*/		return 0x8225CB80;
		  /* 8225CB80h */ case   14:  		/* bc 4, CR0_EQ, 32 */
		/* 8225CB80h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8225CBA0;  }
		/* 8225CB80h case   14:*/		return 0x8225CB84;
		  /* 8225CB84h */ case   15:  		/* lis R11, -32251 */
		/* 8225CB84h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CB84h case   15:*/		return 0x8225CB88;
		  /* 8225CB88h */ case   16:  		/* mr R6, R28 */
		/* 8225CB88h case   16:*/		regs.R6 = regs.R28;
		/* 8225CB88h case   16:*/		return 0x8225CB8C;
		  /* 8225CB8Ch */ case   17:  		/* addi R5, R11, -20560 */
		/* 8225CB8Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAFB0);
		/* 8225CB8Ch case   17:*/		return 0x8225CB90;
		  /* 8225CB90h */ case   18:  		/* mr R4, R29 */
		/* 8225CB90h case   18:*/		regs.R4 = regs.R29;
		/* 8225CB90h case   18:*/		return 0x8225CB94;
		  /* 8225CB94h */ case   19:  		/* li R7, 4366 */
		/* 8225CB94h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x110E);
		/* 8225CB94h case   19:*/		return 0x8225CB98;
		  /* 8225CB98h */ case   20:  		/* li R3, 0 */
		/* 8225CB98h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225CB98h case   20:*/		return 0x8225CB9C;
		  /* 8225CB9Ch */ case   21:  		/* bl -1068948 */
		/* 8225CB9Ch case   21:*/		regs.LR = 0x8225CBA0; return 0x82157C08;
		/* 8225CB9Ch case   21:*/		return 0x8225CBA0;
	}
	return 0x8225CBA0;
} // Block from 8225CB48h-8225CBA0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8225CBA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CBA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CBA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CBA0);
		  /* 8225CBA0h */ case    0:  		/* lwz R30, <#[R25 + 80]> */
		/* 8225CBA0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000050) );
		/* 8225CBA0h case    0:*/		return 0x8225CBA4;
		  /* 8225CBA4h */ case    1:  		/* cmpwi CR6, R30, 19 */
		/* 8225CBA4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000013);
		/* 8225CBA4h case    1:*/		return 0x8225CBA8;
		  /* 8225CBA8h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8225CBA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225CBD8;  }
		/* 8225CBA8h case    2:*/		return 0x8225CBAC;
		  /* 8225CBACh */ case    3:  		/* cmpwi CR6, R30, 20 */
		/* 8225CBACh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000014);
		/* 8225CBACh case    3:*/		return 0x8225CBB0;
		  /* 8225CBB0h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 8225CBB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8225CBD8;  }
		/* 8225CBB0h case    4:*/		return 0x8225CBB4;
		  /* 8225CBB4h */ case    5:  		/* cmpwi CR6, R30, 33 */
		/* 8225CBB4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000021);
		/* 8225CBB4h case    5:*/		return 0x8225CBB8;
		  /* 8225CBB8h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 8225CBB8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8225CBD8;  }
		/* 8225CBB8h case    6:*/		return 0x8225CBBC;
		  /* 8225CBBCh */ case    7:  		/* lis R11, -32251 */
		/* 8225CBBCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CBBCh case    7:*/		return 0x8225CBC0;
		  /* 8225CBC0h */ case    8:  		/* mr R6, R28 */
		/* 8225CBC0h case    8:*/		regs.R6 = regs.R28;
		/* 8225CBC0h case    8:*/		return 0x8225CBC4;
		  /* 8225CBC4h */ case    9:  		/* addi R5, R11, -20376 */
		/* 8225CBC4h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB068);
		/* 8225CBC4h case    9:*/		return 0x8225CBC8;
		  /* 8225CBC8h */ case   10:  		/* mr R4, R29 */
		/* 8225CBC8h case   10:*/		regs.R4 = regs.R29;
		/* 8225CBC8h case   10:*/		return 0x8225CBCC;
		  /* 8225CBCCh */ case   11:  		/* li R7, 4370 */
		/* 8225CBCCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x1112);
		/* 8225CBCCh case   11:*/		return 0x8225CBD0;
		  /* 8225CBD0h */ case   12:  		/* li R3, 0 */
		/* 8225CBD0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225CBD0h case   12:*/		return 0x8225CBD4;
		  /* 8225CBD4h */ case   13:  		/* bl -1069004 */
		/* 8225CBD4h case   13:*/		regs.LR = 0x8225CBD8; return 0x82157C08;
		/* 8225CBD4h case   13:*/		return 0x8225CBD8;
	}
	return 0x8225CBD8;
} // Block from 8225CBA0h-8225CBD8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225CBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CBD8);
		  /* 8225CBD8h */ case    0:  		/* lbz R11, <#[R26 + 2116]> */
		/* 8225CBD8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000844) );
		/* 8225CBD8h case    0:*/		return 0x8225CBDC;
		  /* 8225CBDCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8225CBDCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225CBDCh case    1:*/		return 0x8225CBE0;
		  /* 8225CBE0h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 8225CBE0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8225CBF0;  }
		/* 8225CBE0h case    2:*/		return 0x8225CBE4;
		  /* 8225CBE4h */ case    3:  		/* stw R30, <#[R26 + 2120]> */
		/* 8225CBE4h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R26 + 0x00000848) );
		/* 8225CBE4h case    3:*/		return 0x8225CBE8;
		  /* 8225CBE8h */ case    4:  		/* stb R22, <#[R26 + 2116]> */
		/* 8225CBE8h case    4:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R26 + 0x00000844) );
		/* 8225CBE8h case    4:*/		return 0x8225CBEC;
		  /* 8225CBECh */ case    5:  		/* b 44 */
		/* 8225CBECh case    5:*/		return 0x8225CC18;
		/* 8225CBECh case    5:*/		return 0x8225CBF0;
	}
	return 0x8225CBF0;
} // Block from 8225CBD8h-8225CBF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225CBF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CBF0);
		  /* 8225CBF0h */ case    0:  		/* lwz R11, <#[R26 + 2120]> */
		/* 8225CBF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000848) );
		/* 8225CBF0h case    0:*/		return 0x8225CBF4;
		  /* 8225CBF4h */ case    1:  		/* cmpw CR6, R11, R30 */
		/* 8225CBF4h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R30);
		/* 8225CBF4h case    1:*/		return 0x8225CBF8;
		  /* 8225CBF8h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8225CBF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225CC18;  }
		/* 8225CBF8h case    2:*/		return 0x8225CBFC;
		  /* 8225CBFCh */ case    3:  		/* lis R11, -32251 */
		/* 8225CBFCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CBFCh case    3:*/		return 0x8225CC00;
		  /* 8225CC00h */ case    4:  		/* mr R6, R28 */
		/* 8225CC00h case    4:*/		regs.R6 = regs.R28;
		/* 8225CC00h case    4:*/		return 0x8225CC04;
		  /* 8225CC04h */ case    5:  		/* addi R5, R11, -20416 */
		/* 8225CC04h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB040);
		/* 8225CC04h case    5:*/		return 0x8225CC08;
		  /* 8225CC08h */ case    6:  		/* mr R4, R29 */
		/* 8225CC08h case    6:*/		regs.R4 = regs.R29;
		/* 8225CC08h case    6:*/		return 0x8225CC0C;
		  /* 8225CC0Ch */ case    7:  		/* li R7, 4375 */
		/* 8225CC0Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1117);
		/* 8225CC0Ch case    7:*/		return 0x8225CC10;
		  /* 8225CC10h */ case    8:  		/* li R3, 0 */
		/* 8225CC10h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225CC10h case    8:*/		return 0x8225CC14;
		  /* 8225CC14h */ case    9:  		/* bl -1069068 */
		/* 8225CC14h case    9:*/		regs.LR = 0x8225CC18; return 0x82157C08;
		/* 8225CC14h case    9:*/		return 0x8225CC18;
	}
	return 0x8225CC18;
} // Block from 8225CBF0h-8225CC18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225CC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CC18);
		  /* 8225CC18h */ case    0:  		/* lwz R11, <#[R25 + 56]> */
		/* 8225CC18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 8225CC18h case    0:*/		return 0x8225CC1C;
		  /* 8225CC1Ch */ case    1:  		/* stw R11, <#[R25 + 200]> */
		/* 8225CC1Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x000000C8) );
		/* 8225CC1Ch case    1:*/		return 0x8225CC20;
		  /* 8225CC20h */ case    2:  		/* lwz R11, <#[R27 + 4]> */
		/* 8225CC20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8225CC20h case    2:*/		return 0x8225CC24;
		  /* 8225CC24h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8225CC24h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225CC24h case    3:*/		return 0x8225CC28;
		  /* 8225CC28h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 8225CC28h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8225CC48;  }
		/* 8225CC28h case    4:*/		return 0x8225CC2C;
		  /* 8225CC2Ch */ case    5:  		/* lis R11, -32251 */
		/* 8225CC2Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CC2Ch case    5:*/		return 0x8225CC30;
		  /* 8225CC30h */ case    6:  		/* mr R6, R28 */
		/* 8225CC30h case    6:*/		regs.R6 = regs.R28;
		/* 8225CC30h case    6:*/		return 0x8225CC34;
		  /* 8225CC34h */ case    7:  		/* addi R5, R11, -20744 */
		/* 8225CC34h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAEF8);
		/* 8225CC34h case    7:*/		return 0x8225CC38;
		  /* 8225CC38h */ case    8:  		/* mr R4, R29 */
		/* 8225CC38h case    8:*/		regs.R4 = regs.R29;
		/* 8225CC38h case    8:*/		return 0x8225CC3C;
		  /* 8225CC3Ch */ case    9:  		/* li R7, 4380 */
		/* 8225CC3Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x111C);
		/* 8225CC3Ch case    9:*/		return 0x8225CC40;
		  /* 8225CC40h */ case   10:  		/* li R3, 0 */
		/* 8225CC40h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225CC40h case   10:*/		return 0x8225CC44;
		  /* 8225CC44h */ case   11:  		/* bl -1069116 */
		/* 8225CC44h case   11:*/		regs.LR = 0x8225CC48; return 0x82157C08;
		/* 8225CC44h case   11:*/		return 0x8225CC48;
	}
	return 0x8225CC48;
} // Block from 8225CC18h-8225CC48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225CC48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CC48);
		  /* 8225CC48h */ case    0:  		/* lwz R10, <#[R27 + 4]> */
		/* 8225CC48h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 8225CC48h case    0:*/		return 0x8225CC4C;
		  /* 8225CC4Ch */ case    1:  		/* addi R11, R10, -1 */
		/* 8225CC4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8225CC4Ch case    1:*/		return 0x8225CC50;
		  /* 8225CC50h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8225CC50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8225CC50h case    2:*/		return 0x8225CC54;
		  /* 8225CC54h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 8225CC54h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8225CC68;  }
		/* 8225CC54h case    3:*/		return 0x8225CC58;
		  /* 8225CC58h */ case    4:  		/* lwz R10, <#[R27 + 8]> */
		/* 8225CC58h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 8225CC58h case    4:*/		return 0x8225CC5C;
		  /* 8225CC5Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225CC5Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225CC5Ch case    5:*/		return 0x8225CC60;
		  /* 8225CC60h */ case    6:  		/* add R11, R11, R10 */
		/* 8225CC60h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8225CC60h case    6:*/		return 0x8225CC64;
		  /* 8225CC64h */ case    7:  		/* b 8 */
		/* 8225CC64h case    7:*/		return 0x8225CC6C;
		/* 8225CC64h case    7:*/		return 0x8225CC68;
	}
	return 0x8225CC68;
} // Block from 8225CC48h-8225CC68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225CC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CC68);
		  /* 8225CC68h */ case    0:  		/* mr R11, R31 */
		/* 8225CC68h case    0:*/		regs.R11 = regs.R31;
		/* 8225CC68h case    0:*/		return 0x8225CC6C;
	}
	return 0x8225CC6C;
} // Block from 8225CC68h-8225CC6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225CC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CC6C);
		  /* 8225CC6Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8225CC6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225CC6Ch case    0:*/		return 0x8225CC70;
		  /* 8225CC70h */ case    1:  		/* li R10, 42 */
		/* 8225CC70h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x2A);
		/* 8225CC70h case    1:*/		return 0x8225CC74;
		  /* 8225CC74h */ case    2:  		/* lwz R9, <#[R25 + 228]> */
		/* 8225CC74h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x000000E4) );
		/* 8225CC74h case    2:*/		return 0x8225CC78;
		  /* 8225CC78h */ case    3:  		/* mr R4, R25 */
		/* 8225CC78h case    3:*/		regs.R4 = regs.R25;
		/* 8225CC78h case    3:*/		return 0x8225CC7C;
		  /* 8225CC7Ch */ case    4:  		/* mr R3, R26 */
		/* 8225CC7Ch case    4:*/		regs.R3 = regs.R26;
		/* 8225CC7Ch case    4:*/		return 0x8225CC80;
		  /* 8225CC80h */ case    5:  		/* ori R9, R9, 16 */
		/* 8225CC80h case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x10);
		/* 8225CC80h case    5:*/		return 0x8225CC84;
		  /* 8225CC84h */ case    6:  		/* lwz R11, <#[R11 + 136]> */
		/* 8225CC84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000088) );
		/* 8225CC84h case    6:*/		return 0x8225CC88;
		  /* 8225CC88h */ case    7:  		/* stw R10, <#[R25 + 80]> */
		/* 8225CC88h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000050) );
		/* 8225CC88h case    7:*/		return 0x8225CC8C;
		  /* 8225CC8Ch */ case    8:  		/* stw R9, <#[R25 + 228]> */
		/* 8225CC8Ch case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R25 + 0x000000E4) );
		/* 8225CC8Ch case    8:*/		return 0x8225CC90;
		  /* 8225CC90h */ case    9:  		/* stw R11, <#[R25 + 56]> */
		/* 8225CC90h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000038) );
		/* 8225CC90h case    9:*/		return 0x8225CC94;
		  /* 8225CC94h */ case   10:  		/* bl -158876 */
		/* 8225CC94h case   10:*/		regs.LR = 0x8225CC98; return 0x82235FF8;
		/* 8225CC94h case   10:*/		return 0x8225CC98;
	}
	return 0x8225CC98;
} // Block from 8225CC6Ch-8225CC98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225CC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CC98);
		  /* 8225CC98h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 8225CC98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8225CC98h case    0:*/		return 0x8225CC9C;
		  /* 8225CC9Ch */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8225CC9Ch case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8225CC9Ch case    1:*/		return 0x8225CCA0;
		  /* 8225CCA0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8225CCA0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225CCB0;  }
		/* 8225CCA0h case    2:*/		return 0x8225CCA4;
		  /* 8225CCA4h */ case    3:  		/* lwz R11, <#[R24 + 4]> */
		/* 8225CCA4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8225CCA4h case    3:*/		return 0x8225CCA8;
		  /* 8225CCA8h */ case    4:  		/* rlwinm R11, R11, 24, 31, 31 */
		/* 8225CCA8h case    4:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R11,regs.R11);
		/* 8225CCA8h case    4:*/		return 0x8225CCAC;
		  /* 8225CCACh */ case    5:  		/* b 8 */
		/* 8225CCACh case    5:*/		return 0x8225CCB4;
		/* 8225CCACh case    5:*/		return 0x8225CCB0;
	}
	return 0x8225CCB0;
} // Block from 8225CC98h-8225CCB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225CCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CCB0);
		  /* 8225CCB0h */ case    0:  		/* mr R11, R31 */
		/* 8225CCB0h case    0:*/		regs.R11 = regs.R31;
		/* 8225CCB0h case    0:*/		return 0x8225CCB4;
	}
	return 0x8225CCB4;
} // Block from 8225CCB0h-8225CCB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225CCB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CCB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CCB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CCB4);
		  /* 8225CCB4h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8225CCB4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225CCB4h case    0:*/		return 0x8225CCB8;
		  /* 8225CCB8h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8225CCB8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225CCC0;  }
		/* 8225CCB8h case    1:*/		return 0x8225CCBC;
		  /* 8225CCBCh */ case    2:  		/* stb R22, <#[R25 + 164]> */
		/* 8225CCBCh case    2:*/		cpu::mem::store8( regs, regs.R22, (uint32)(regs.R25 + 0x000000A4) );
		/* 8225CCBCh case    2:*/		return 0x8225CCC0;
	}
	return 0x8225CCC0;
} // Block from 8225CCB4h-8225CCC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225CCC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CCC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CCC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CCC0);
		  /* 8225CCC0h */ case    0:  		/* li R4, 0 */
		/* 8225CCC0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225CCC0h case    0:*/		return 0x8225CCC4;
		  /* 8225CCC4h */ case    1:  		/* mr R3, R24 */
		/* 8225CCC4h case    1:*/		regs.R3 = regs.R24;
		/* 8225CCC4h case    1:*/		return 0x8225CCC8;
		  /* 8225CCC8h */ case    2:  		/* bl 41440 */
		/* 8225CCC8h case    2:*/		regs.LR = 0x8225CCCC; return 0x82266EA8;
		/* 8225CCC8h case    2:*/		return 0x8225CCCC;
		  /* 8225CCCCh */ case    3:  		/* lis R11, -32251 */
		/* 8225CCCCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CCCCh case    3:*/		return 0x8225CCD0;
		  /* 8225CCD0h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8225CCD0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8225CCD0h case    4:*/		return 0x8225CCD4;
		  /* 8225CCD4h */ case    5:  		/* addi R30, R11, -22224 */
		/* 8225CCD4h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFA930);
		/* 8225CCD4h case    5:*/		return 0x8225CCD8;
		  /* 8225CCD8h */ case    6:  		/* li R4, 1 */
		/* 8225CCD8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225CCD8h case    6:*/		return 0x8225CCDC;
		  /* 8225CCDCh */ case    7:  		/* mr R3, R24 */
		/* 8225CCDCh case    7:*/		regs.R3 = regs.R24;
		/* 8225CCDCh case    7:*/		return 0x8225CCE0;
		  /* 8225CCE0h */ case    8:  		/* lwzx R11, <#[R10 + R30]> */
		/* 8225CCE0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 8225CCE0h case    8:*/		return 0x8225CCE4;
		  /* 8225CCE4h */ case    9:  		/* stb R11, <#[R1 + 80]> */
		/* 8225CCE4h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8225CCE4h case    9:*/		return 0x8225CCE8;
		  /* 8225CCE8h */ case   10:  		/* bl 41408 */
		/* 8225CCE8h case   10:*/		regs.LR = 0x8225CCEC; return 0x82266EA8;
		/* 8225CCE8h case   10:*/		return 0x8225CCEC;
		  /* 8225CCECh */ case   11:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 8225CCECh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 8225CCECh case   11:*/		return 0x8225CCF0;
		  /* 8225CCF0h */ case   12:  		/* li R4, 2 */
		/* 8225CCF0h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225CCF0h case   12:*/		return 0x8225CCF4;
		  /* 8225CCF4h */ case   13:  		/* mr R3, R24 */
		/* 8225CCF4h case   13:*/		regs.R3 = regs.R24;
		/* 8225CCF4h case   13:*/		return 0x8225CCF8;
		  /* 8225CCF8h */ case   14:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8225CCF8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8225CCF8h case   14:*/		return 0x8225CCFC;
		  /* 8225CCFCh */ case   15:  		/* stb R11, <#[R1 + 81]> */
		/* 8225CCFCh case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000051) );
		/* 8225CCFCh case   15:*/		return 0x8225CD00;
		  /* 8225CD00h */ case   16:  		/* bl 41384 */
		/* 8225CD00h case   16:*/		regs.LR = 0x8225CD04; return 0x82266EA8;
		/* 8225CD00h case   16:*/		return 0x8225CD04;
		  /* 8225CD04h */ case   17:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 8225CD04h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 8225CD04h case   17:*/		return 0x8225CD08;
		  /* 8225CD08h */ case   18:  		/* li R4, 3 */
		/* 8225CD08h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225CD08h case   18:*/		return 0x8225CD0C;
		  /* 8225CD0Ch */ case   19:  		/* mr R3, R24 */
		/* 8225CD0Ch case   19:*/		regs.R3 = regs.R24;
		/* 8225CD0Ch case   19:*/		return 0x8225CD10;
		  /* 8225CD10h */ case   20:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8225CD10h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8225CD10h case   20:*/		return 0x8225CD14;
		  /* 8225CD14h */ case   21:  		/* stb R11, <#[R1 + 82]> */
		/* 8225CD14h case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000052) );
		/* 8225CD14h case   21:*/		return 0x8225CD18;
		  /* 8225CD18h */ case   22:  		/* bl 41360 */
		/* 8225CD18h case   22:*/		regs.LR = 0x8225CD1C; return 0x82266EA8;
		/* 8225CD18h case   22:*/		return 0x8225CD1C;
		  /* 8225CD1Ch */ case   23:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 8225CD1Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 8225CD1Ch case   23:*/		return 0x8225CD20;
		  /* 8225CD20h */ case   24:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8225CD20h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8225CD20h case   24:*/		return 0x8225CD24;
		  /* 8225CD24h */ case   25:  		/* stb R11, <#[R1 + 83]> */
		/* 8225CD24h case   25:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000053) );
		/* 8225CD24h case   25:*/		return 0x8225CD28;
	}
	return 0x8225CD28;
} // Block from 8225CCC0h-8225CD28h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225CD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CD28);
		  /* 8225CD28h */ case    0:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 8225CD28h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 8225CD28h case    0:*/		return 0x8225CD2C;
		  /* 8225CD2Ch */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 8225CD2Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8225CD80;  }
		/* 8225CD2Ch case    1:*/		return 0x8225CD30;
		  /* 8225CD30h */ case    2:  		/* mr R4, R31 */
		/* 8225CD30h case    2:*/		regs.R4 = regs.R31;
		/* 8225CD30h case    2:*/		return 0x8225CD34;
		  /* 8225CD34h */ case    3:  		/* addi R3, R1, 212 */
		/* 8225CD34h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD4);
		/* 8225CD34h case    3:*/		return 0x8225CD38;
		  /* 8225CD38h */ case    4:  		/* bl -83792 */
		/* 8225CD38h case    4:*/		regs.LR = 0x8225CD3C; return 0x822485E8;
		/* 8225CD38h case    4:*/		return 0x8225CD3C;
		  /* 8225CD3Ch */ case    5:  		/* addi R11, R1, 80 */
		/* 8225CD3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8225CD3Ch case    5:*/		return 0x8225CD40;
		  /* 8225CD40h */ case    6:  		/* mr R6, R3 */
		/* 8225CD40h case    6:*/		regs.R6 = regs.R3;
		/* 8225CD40h case    6:*/		return 0x8225CD44;
		  /* 8225CD44h */ case    7:  		/* lbzx R11, <#[R31 + R11]> */
		/* 8225CD44h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8225CD44h case    7:*/		return 0x8225CD48;
		  /* 8225CD48h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 8225CD48h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225CD48h case    8:*/		return 0x8225CD4C;
		  /* 8225CD4Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8225CD4Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8225CD54;  }
		/* 8225CD4Ch case    9:*/		return 0x8225CD50;
		  /* 8225CD50h */ case   10:  		/* mr R6, R22 */
		/* 8225CD50h case   10:*/		regs.R6 = regs.R22;
		/* 8225CD50h case   10:*/		return 0x8225CD54;
	}
	return 0x8225CD54;
} // Block from 8225CD28h-8225CD54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225CD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CD54);
		  /* 8225CD54h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 8225CD54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8225CD54h case    0:*/		return 0x8225CD58;
		  /* 8225CD58h */ case    1:  		/* mr R5, R31 */
		/* 8225CD58h case    1:*/		regs.R5 = regs.R31;
		/* 8225CD58h case    1:*/		return 0x8225CD5C;
		  /* 8225CD5Ch */ case    2:  		/* li R4, 0 */
		/* 8225CD5Ch case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225CD5Ch case    2:*/		return 0x8225CD60;
		  /* 8225CD60h */ case    3:  		/* mr R3, R25 */
		/* 8225CD60h case    3:*/		regs.R3 = regs.R25;
		/* 8225CD60h case    3:*/		return 0x8225CD64;
		  /* 8225CD64h */ case    4:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225CD64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225CD64h case    4:*/		return 0x8225CD68;
		  /* 8225CD68h */ case    5:  		/* mtspr CTR, R11 */
		/* 8225CD68h case    5:*/		regs.CTR = regs.R11;
		/* 8225CD68h case    5:*/		return 0x8225CD6C;
		  /* 8225CD6Ch */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8225CD6Ch case    6:*/		if ( 1 ) { regs.LR = 0x8225CD70; return (uint32)regs.CTR; }
		/* 8225CD6Ch case    6:*/		return 0x8225CD70;
		  /* 8225CD70h */ case    7:  		/* addi R31, R31, 1 */
		/* 8225CD70h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8225CD70h case    7:*/		return 0x8225CD74;
		  /* 8225CD74h */ case    8:  		/* cmpwi CR6, R31, 4 */
		/* 8225CD74h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8225CD74h case    8:*/		return 0x8225CD78;
		  /* 8225CD78h */ case    9:  		/* bc 12, CR6_LT, -72 */
		/* 8225CD78h case    9:*/		if ( regs.CR[6].lt ) { return 0x8225CD30;  }
		/* 8225CD78h case    9:*/		return 0x8225CD7C;
		  /* 8225CD7Ch */ case   10:  		/* b 76 */
		/* 8225CD7Ch case   10:*/		return 0x8225CDC8;
		/* 8225CD7Ch case   10:*/		return 0x8225CD80;
	}
	return 0x8225CD80;
} // Block from 8225CD54h-8225CD80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225CD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CD80);
		  /* 8225CD80h */ case    0:  		/* mr R4, R31 */
		/* 8225CD80h case    0:*/		regs.R4 = regs.R31;
		/* 8225CD80h case    0:*/		return 0x8225CD84;
		  /* 8225CD84h */ case    1:  		/* addi R3, R1, 212 */
		/* 8225CD84h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD4);
		/* 8225CD84h case    1:*/		return 0x8225CD88;
		  /* 8225CD88h */ case    2:  		/* bl -83872 */
		/* 8225CD88h case    2:*/		regs.LR = 0x8225CD8C; return 0x822485E8;
		/* 8225CD88h case    2:*/		return 0x8225CD8C;
		  /* 8225CD8Ch */ case    3:  		/* or. R6, R3, R3 */
		/* 8225CD8Ch case    3:*/		cpu::op::or<1>(regs,&regs.R6,regs.R3,regs.R3);
		/* 8225CD8Ch case    3:*/		return 0x8225CD90;
		  /* 8225CD90h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 8225CD90h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8225CDA0;  }
		/* 8225CD90h case    4:*/		return 0x8225CD94;
		  /* 8225CD94h */ case    5:  		/* addi R11, R1, 80 */
		/* 8225CD94h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8225CD94h case    5:*/		return 0x8225CD98;
		  /* 8225CD98h */ case    6:  		/* lbzx R11, <#[R31 + R11]> */
		/* 8225CD98h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8225CD98h case    6:*/		return 0x8225CD9C;
		  /* 8225CD9Ch */ case    7:  		/* extsb R6, R11 */
		/* 8225CD9Ch case    7:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R11);
		/* 8225CD9Ch case    7:*/		return 0x8225CDA0;
	}
	return 0x8225CDA0;
} // Block from 8225CD80h-8225CDA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225CDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CDA0);
		  /* 8225CDA0h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 8225CDA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8225CDA0h case    0:*/		return 0x8225CDA4;
		  /* 8225CDA4h */ case    1:  		/* mr R5, R31 */
		/* 8225CDA4h case    1:*/		regs.R5 = regs.R31;
		/* 8225CDA4h case    1:*/		return 0x8225CDA8;
		  /* 8225CDA8h */ case    2:  		/* li R4, 0 */
		/* 8225CDA8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225CDA8h case    2:*/		return 0x8225CDAC;
		  /* 8225CDACh */ case    3:  		/* mr R3, R25 */
		/* 8225CDACh case    3:*/		regs.R3 = regs.R25;
		/* 8225CDACh case    3:*/		return 0x8225CDB0;
		  /* 8225CDB0h */ case    4:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225CDB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225CDB0h case    4:*/		return 0x8225CDB4;
		  /* 8225CDB4h */ case    5:  		/* mtspr CTR, R11 */
		/* 8225CDB4h case    5:*/		regs.CTR = regs.R11;
		/* 8225CDB4h case    5:*/		return 0x8225CDB8;
		  /* 8225CDB8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8225CDB8h case    6:*/		if ( 1 ) { regs.LR = 0x8225CDBC; return (uint32)regs.CTR; }
		/* 8225CDB8h case    6:*/		return 0x8225CDBC;
		  /* 8225CDBCh */ case    7:  		/* addi R31, R31, 1 */
		/* 8225CDBCh case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8225CDBCh case    7:*/		return 0x8225CDC0;
		  /* 8225CDC0h */ case    8:  		/* cmpwi CR6, R31, 4 */
		/* 8225CDC0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8225CDC0h case    8:*/		return 0x8225CDC4;
		  /* 8225CDC4h */ case    9:  		/* bc 12, CR6_LT, -68 */
		/* 8225CDC4h case    9:*/		if ( regs.CR[6].lt ) { return 0x8225CD80;  }
		/* 8225CDC4h case    9:*/		return 0x8225CDC8;
	}
	return 0x8225CDC8;
} // Block from 8225CDA0h-8225CDC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225CDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CDC8);
		  /* 8225CDC8h */ case    0:  		/* addi R1, R1, 176 */
		/* 8225CDC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8225CDC8h case    0:*/		return 0x8225CDCC;
		  /* 8225CDCCh */ case    1:  		/* b -1882940 */
		/* 8225CDCCh case    1:*/		return 0x82091290;
		/* 8225CDCCh case    1:*/		return 0x8225CDD0;
	}
	return 0x8225CDD0;
} // Block from 8225CDC8h-8225CDD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225CDD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CDD0);
		  /* 8225CDD0h */ case    0:  		/* mfspr R12, LR */
		/* 8225CDD0h case    0:*/		regs.R12 = regs.LR;
		/* 8225CDD0h case    0:*/		return 0x8225CDD4;
		  /* 8225CDD4h */ case    1:  		/* bl -1883024 */
		/* 8225CDD4h case    1:*/		regs.LR = 0x8225CDD8; return 0x82091244;
		/* 8225CDD4h case    1:*/		return 0x8225CDD8;
		  /* 8225CDD8h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 8225CDD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8225CDD8h case    2:*/		return 0x8225CDDC;
		  /* 8225CDDCh */ case    3:  		/* lis R11, -32251 */
		/* 8225CDDCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CDDCh case    3:*/		return 0x8225CDE0;
		  /* 8225CDE0h */ case    4:  		/* mr R25, R8 */
		/* 8225CDE0h case    4:*/		regs.R25 = regs.R8;
		/* 8225CDE0h case    4:*/		return 0x8225CDE4;
		  /* 8225CDE4h */ case    5:  		/* rlwinm R8, R4, 4, 0, 27 */
		/* 8225CDE4h case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R8,regs.R4);
		/* 8225CDE4h case    5:*/		return 0x8225CDE8;
		  /* 8225CDE8h */ case    6:  		/* addi R11, R11, -31456 */
		/* 8225CDE8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFF8520);
		/* 8225CDE8h case    6:*/		return 0x8225CDEC;
		  /* 8225CDECh */ case    7:  		/* mr R29, R3 */
		/* 8225CDECh case    7:*/		regs.R29 = regs.R3;
		/* 8225CDECh case    7:*/		return 0x8225CDF0;
		  /* 8225CDF0h */ case    8:  		/* add R4, R8, R11 */
		/* 8225CDF0h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R8,regs.R11);
		/* 8225CDF0h case    8:*/		return 0x8225CDF4;
		  /* 8225CDF4h */ case    9:  		/* mr R23, R5 */
		/* 8225CDF4h case    9:*/		regs.R23 = regs.R5;
		/* 8225CDF4h case    9:*/		return 0x8225CDF8;
		  /* 8225CDF8h */ case   10:  		/* addi R5, R1, 96 */
		/* 8225CDF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8225CDF8h case   10:*/		return 0x8225CDFC;
		  /* 8225CDFCh */ case   11:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8225CDFCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8225CDFCh case   11:*/		return 0x8225CE00;
		  /* 8225CE00h */ case   12:  		/* cmpwi CR6, R23, 0 */
		/* 8225CE00h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8225CE00h case   12:*/		return 0x8225CE04;
		  /* 8225CE04h */ case   13:  		/* lwz R8, <#[R4 + 4]> */
		/* 8225CE04h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000004) );
		/* 8225CE04h case   13:*/		return 0x8225CE08;
		  /* 8225CE08h */ case   14:  		/* lwz R3, <#[R4 + 8]> */
		/* 8225CE08h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000008) );
		/* 8225CE08h case   14:*/		return 0x8225CE0C;
		  /* 8225CE0Ch */ case   15:  		/* lwz R4, <#[R4 + 12]> */
		/* 8225CE0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000000C) );
		/* 8225CE0Ch case   15:*/		return 0x8225CE10;
		  /* 8225CE10h */ case   16:  		/* stw R11, <#[R5]> */
		/* 8225CE10h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8225CE10h case   16:*/		return 0x8225CE14;
		  /* 8225CE14h */ case   17:  		/* stw R8, <#[R5 + 4]> */
		/* 8225CE14h case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R5 + 0x00000004) );
		/* 8225CE14h case   17:*/		return 0x8225CE18;
		  /* 8225CE18h */ case   18:  		/* stw R3, <#[R5 + 8]> */
		/* 8225CE18h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R5 + 0x00000008) );
		/* 8225CE18h case   18:*/		return 0x8225CE1C;
		  /* 8225CE1Ch */ case   19:  		/* stw R4, <#[R5 + 12]> */
		/* 8225CE1Ch case   19:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R5 + 0x0000000C) );
		/* 8225CE1Ch case   19:*/		return 0x8225CE20;
		  /* 8225CE20h */ case   20:  		/* lbz R11, <#[R1 + 100]> */
		/* 8225CE20h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8225CE20h case   20:*/		return 0x8225CE24;
		  /* 8225CE24h */ case   21:  		/* bc 4, CR6_EQ, 108 */
		/* 8225CE24h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8225CE90;  }
		/* 8225CE24h case   21:*/		return 0x8225CE28;
		  /* 8225CE28h */ case   22:  		/* rlwinm. R8, R11, 0, 24, 24 */
		/* 8225CE28h case   22:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R8,regs.R11);
		/* 8225CE28h case   22:*/		return 0x8225CE2C;
		  /* 8225CE2Ch */ case   23:  		/* bc 12, CR0_EQ, 100 */
		/* 8225CE2Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x8225CE90;  }
		/* 8225CE2Ch case   23:*/		return 0x8225CE30;
		  /* 8225CE30h */ case   24:  		/* lwz R11, <#[R1 + 104]> */
		/* 8225CE30h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8225CE30h case   24:*/		return 0x8225CE34;
		  /* 8225CE34h */ case   25:  		/* mr R8, R25 */
		/* 8225CE34h case   25:*/		regs.R8 = regs.R25;
		/* 8225CE34h case   25:*/		return 0x8225CE38;
		  /* 8225CE38h */ case   26:  		/* lwz R9, <#[R1 + 96]> */
		/* 8225CE38h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 8225CE38h case   26:*/		return 0x8225CE3C;
		  /* 8225CE3Ch */ case   27:  		/* li R7, 0 */
		/* 8225CE3Ch case   27:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8225CE3Ch case   27:*/		return 0x8225CE40;
		  /* 8225CE40h */ case   28:  		/* rlwinm R5, R11, 3, 29, 31 */
		/* 8225CE40h case   28:*/		cpu::op::rlwinm<0,3,29,31>(regs,&regs.R5,regs.R11);
		/* 8225CE40h case   28:*/		return 0x8225CE44;
		  /* 8225CE44h */ case   29:  		/* lwz R31, <#[R29 + 92]> */
		/* 8225CE44h case   29:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x0000005C) );
		/* 8225CE44h case   29:*/		return 0x8225CE48;
		  /* 8225CE48h */ case   30:  		/* rlwinm R11, R9, 3, 29, 31 */
		/* 8225CE48h case   30:*/		cpu::op::rlwinm<0,3,29,31>(regs,&regs.R11,regs.R9);
		/* 8225CE48h case   30:*/		return 0x8225CE4C;
		  /* 8225CE4Ch */ case   31:  		/* lbz R9, <#[R1 + 295]> */
		/* 8225CE4Ch case   31:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000127) );
		/* 8225CE4Ch case   31:*/		return 0x8225CE50;
		  /* 8225CE50h */ case   32:  		/* mulli R5, R5, 6 */
		/* 8225CE50h case   32:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R5,0x6);
		/* 8225CE50h case   32:*/		return 0x8225CE54;
		  /* 8225CE54h */ case   33:  		/* lwz R4, <#[R1 + 284]> */
		/* 8225CE54h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000011C) );
		/* 8225CE54h case   33:*/		return 0x8225CE58;
		  /* 8225CE58h */ case   34:  		/* add R11, R5, R11 */
		/* 8225CE58h case   34:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 8225CE58h case   34:*/		return 0x8225CE5C;
		  /* 8225CE5Ch */ case   35:  		/* mr R5, R10 */
		/* 8225CE5Ch case   35:*/		regs.R5 = regs.R10;
		/* 8225CE5Ch case   35:*/		return 0x8225CE60;
		  /* 8225CE60h */ case   36:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225CE60h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225CE60h case   36:*/		return 0x8225CE64;
		  /* 8225CE64h */ case   37:  		/* mr R3, R29 */
		/* 8225CE64h case   37:*/		regs.R3 = regs.R29;
		/* 8225CE64h case   37:*/		return 0x8225CE68;
		  /* 8225CE68h */ case   38:  		/* lwzx R6, <#[R11 + R6]> */
		/* 8225CE68h case   38:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8225CE68h case   38:*/		return 0x8225CE6C;
		  /* 8225CE6Ch */ case   39:  		/* lwz R10, <#[R6]> */
		/* 8225CE6Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 8225CE6Ch case   39:*/		return 0x8225CE70;
		  /* 8225CE70h */ case   40:  		/* rlwinm R11, R10, 19, 23, 28 */
		/* 8225CE70h case   40:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R11,regs.R10);
		/* 8225CE70h case   40:*/		return 0x8225CE74;
		  /* 8225CE74h */ case   41:  		/* extsh R10, R10 */
		/* 8225CE74h case   41:*/		cpu::op::extsh<0>(regs,&regs.R10,regs.R10);
		/* 8225CE74h case   41:*/		return 0x8225CE78;
		  /* 8225CE78h */ case   42:  		/* add R11, R11, R31 */
		/* 8225CE78h case   42:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8225CE78h case   42:*/		return 0x8225CE7C;
		  /* 8225CE7Ch */ case   43:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225CE7Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225CE7Ch case   43:*/		return 0x8225CE80;
		  /* 8225CE80h */ case   44:  		/* stw R10, <#[R25 + 56]> */
		/* 8225CE80h case   44:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000038) );
		/* 8225CE80h case   44:*/		return 0x8225CE84;
		  /* 8225CE84h */ case   45:  		/* stw R11, <#[R25 + 80]> */
		/* 8225CE84h case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000050) );
		/* 8225CE84h case   45:*/		return 0x8225CE88;
		  /* 8225CE88h */ case   46:  		/* bl -928 */
		/* 8225CE88h case   46:*/		regs.LR = 0x8225CE8C; return 0x8225CAE8;
		/* 8225CE88h case   46:*/		return 0x8225CE8C;
		  /* 8225CE8Ch */ case   47:  		/* b 480 */
		/* 8225CE8Ch case   47:*/		return 0x8225D06C;
		/* 8225CE8Ch case   47:*/		return 0x8225CE90;
	}
	return 0x8225CE90;
} // Block from 8225CDD0h-8225CE90h (48 instructions)

//////////////////////////////////////////////////////
// Block at 8225CE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CE90);
		  /* 8225CE90h */ case    0:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 8225CE90h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 8225CE90h case    0:*/		return 0x8225CE94;
		  /* 8225CE94h */ case    1:  		/* lwz R8, <#[R1 + 96]> */
		/* 8225CE94h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 8225CE94h case    1:*/		return 0x8225CE98;
		  /* 8225CE98h */ case    2:  		/* rlwinm R4, R11, 0, 24, 31 */
		/* 8225CE98h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R4,regs.R11);
		/* 8225CE98h case    2:*/		return 0x8225CE9C;
		  /* 8225CE9Ch */ case    3:  		/* lwz R11, <#[R1 + 104]> */
		/* 8225CE9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8225CE9Ch case    3:*/		return 0x8225CEA0;
		  /* 8225CEA0h */ case    4:  		/* rlwinm R8, R8, 3, 29, 31 */
		/* 8225CEA0h case    4:*/		cpu::op::rlwinm<0,3,29,31>(regs,&regs.R8,regs.R8);
		/* 8225CEA0h case    4:*/		return 0x8225CEA4;
		  /* 8225CEA4h */ case    5:  		/* rlwinm R10, R11, 3, 29, 31 */
		/* 8225CEA4h case    5:*/		cpu::op::rlwinm<0,3,29,31>(regs,&regs.R10,regs.R11);
		/* 8225CEA4h case    5:*/		return 0x8225CEA8;
		  /* 8225CEA8h */ case    6:  		/* li R5, 0 */
		/* 8225CEA8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225CEA8h case    6:*/		return 0x8225CEAC;
		  /* 8225CEACh */ case    7:  		/* mulli R11, R10, 6 */
		/* 8225CEACh case    7:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R10,0x6);
		/* 8225CEACh case    7:*/		return 0x8225CEB0;
		  /* 8225CEB0h */ case    8:  		/* add R11, R11, R8 */
		/* 8225CEB0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8225CEB0h case    8:*/		return 0x8225CEB4;
		  /* 8225CEB4h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225CEB4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225CEB4h case    9:*/		return 0x8225CEB8;
		  /* 8225CEB8h */ case   10:  		/* bc 12, CR0_EQ, 60 */
		/* 8225CEB8h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225CEF4;  }
		/* 8225CEB8h case   10:*/		return 0x8225CEBC;
		  /* 8225CEBCh */ case   11:  		/* lwzx R6, <#[R11 + R6]> */
		/* 8225CEBCh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8225CEBCh case   11:*/		return 0x8225CEC0;
		  /* 8225CEC0h */ case   12:  		/* addi R30, R1, 80 */
		/* 8225CEC0h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x50);
		/* 8225CEC0h case   12:*/		return 0x8225CEC4;
		  /* 8225CEC4h */ case   13:  		/* lwz R7, <#[R1 + 80]> */
		/* 8225CEC4h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8225CEC4h case   13:*/		return 0x8225CEC8;
		  /* 8225CEC8h */ case   14:  		/* rlwinm R7, R7, 0, 0, 15 */
		/* 8225CEC8h case   14:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R7,regs.R7);
		/* 8225CEC8h case   14:*/		return 0x8225CECC;
		  /* 8225CECCh */ case   15:  		/* lhz R11, <#[R6 + 2]> */
		/* 8225CECCh case   15:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000002) );
		/* 8225CECCh case   15:*/		return 0x8225CED0;
		  /* 8225CED0h */ case   16:  		/* or R7, R11, R7 */
		/* 8225CED0h case   16:*/		cpu::op::or<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 8225CED0h case   16:*/		return 0x8225CED4;
		  /* 8225CED4h */ case   17:  		/* stw R7, <#[R1 + 80]> */
		/* 8225CED4h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8225CED4h case   17:*/		return 0x8225CED8;
		  /* 8225CED8h */ case   18:  		/* lwz R11, <#[R6]> */
		/* 8225CED8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8225CED8h case   18:*/		return 0x8225CEDC;
		  /* 8225CEDCh */ case   19:  		/* rlwimi R11, R7, 0, 16, 9 */
		/* 8225CEDCh case   19:*/		cpu::op::rlwimi<0,0,16,9>(regs,&regs.R11,regs.R7);
		/* 8225CEDCh case   19:*/		return 0x8225CEE0;
		  /* 8225CEE0h */ case   20:  		/* stw R11, <#[R1 + 80]> */
		/* 8225CEE0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8225CEE0h case   20:*/		return 0x8225CEE4;
		  /* 8225CEE4h */ case   21:  		/* lwz R7, <#[R6]> */
		/* 8225CEE4h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8225CEE4h case   21:*/		return 0x8225CEE8;
		  /* 8225CEE8h */ case   22:  		/* rlwimi R7, R11, 0, 9, 7 */
		/* 8225CEE8h case   22:*/		cpu::op::rlwimi<0,0,9,7>(regs,&regs.R7,regs.R11);
		/* 8225CEE8h case   22:*/		return 0x8225CEEC;
		  /* 8225CEECh */ case   23:  		/* stw R7, <#[R1 + 80]> */
		/* 8225CEECh case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8225CEECh case   23:*/		return 0x8225CEF0;
		  /* 8225CEF0h */ case   24:  		/* b 12 */
		/* 8225CEF0h case   24:*/		return 0x8225CEFC;
		/* 8225CEF0h case   24:*/		return 0x8225CEF4;
	}
	return 0x8225CEF4;
} // Block from 8225CE90h-8225CEF4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225CEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CEF4);
		  /* 8225CEF4h */ case    0:  		/* lwzx R30, <#[R11 + R7]> */
		/* 8225CEF4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8225CEF4h case    0:*/		return 0x8225CEF8;
		  /* 8225CEF8h */ case    1:  		/* mr R5, R30 */
		/* 8225CEF8h case    1:*/		regs.R5 = regs.R30;
		/* 8225CEF8h case    1:*/		return 0x8225CEFC;
	}
	return 0x8225CEFC;
} // Block from 8225CEF4h-8225CEFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225CEFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CEFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CEFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CEFC);
		  /* 8225CEFCh */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8225CEFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225CEFCh case    0:*/		return 0x8225CF00;
		  /* 8225CF00h */ case    1:  		/* li R24, 0 */
		/* 8225CF00h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8225CF00h case    1:*/		return 0x8225CF04;
		  /* 8225CF04h */ case    2:  		/* li R27, 0 */
		/* 8225CF04h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8225CF04h case    2:*/		return 0x8225CF08;
		  /* 8225CF08h */ case    3:  		/* rlwinm. R6, R11, 9, 31, 31 */
		/* 8225CF08h case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R6,regs.R11);
		/* 8225CF08h case    3:*/		return 0x8225CF0C;
		  /* 8225CF0Ch */ case    4:  		/* rlwinm R31, R11, 16, 26, 31 */
		/* 8225CF0Ch case    4:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R31,regs.R11);
		/* 8225CF0Ch case    4:*/		return 0x8225CF10;
		  /* 8225CF10h */ case    5:  		/* extsh R26, R11 */
		/* 8225CF10h case    5:*/		cpu::op::extsh<0>(regs,&regs.R26,regs.R11);
		/* 8225CF10h case    5:*/		return 0x8225CF14;
		  /* 8225CF14h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 8225CF14h case    6:*/		if ( regs.CR[0].eq ) { return 0x8225CF30;  }
		/* 8225CF14h case    6:*/		return 0x8225CF18;
		  /* 8225CF18h */ case    7:  		/* add R11, R8, R9 */
		/* 8225CF18h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 8225CF18h case    7:*/		return 0x8225CF1C;
		  /* 8225CF1Ch */ case    8:  		/* lwz R9, <#[R1 + 300]> */
		/* 8225CF1Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000012C) );
		/* 8225CF1Ch case    8:*/		return 0x8225CF20;
		  /* 8225CF20h */ case    9:  		/* li R27, 1 */
		/* 8225CF20h case    9:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8225CF20h case    9:*/		return 0x8225CF24;
		  /* 8225CF24h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225CF24h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225CF24h case   10:*/		return 0x8225CF28;
		  /* 8225CF28h */ case   11:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8225CF28h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8225CF28h case   11:*/		return 0x8225CF2C;
		  /* 8225CF2Ch */ case   12:  		/* add R24, R11, R10 */
		/* 8225CF2Ch case   12:*/		cpu::op::add<0>(regs,&regs.R24,regs.R11,regs.R10);
		/* 8225CF2Ch case   12:*/		return 0x8225CF30;
	}
	return 0x8225CF30;
} // Block from 8225CEFCh-8225CF30h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225CF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CF30);
		  /* 8225CF30h */ case    0:  		/* rlwinm. R11, R4, 0, 25, 25 */
		/* 8225CF30h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R4);
		/* 8225CF30h case    0:*/		return 0x8225CF34;
		  /* 8225CF34h */ case    1:  		/* bc 4, CR0_EQ, 240 */
		/* 8225CF34h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8225D024;  }
		/* 8225CF34h case    1:*/		return 0x8225CF38;
		  /* 8225CF38h */ case    2:  		/* cmpwi CR6, R31, 1 */
		/* 8225CF38h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000001);
		/* 8225CF38h case    2:*/		return 0x8225CF3C;
		  /* 8225CF3Ch */ case    3:  		/* bc 4, CR6_EQ, 232 */
		/* 8225CF3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225D024;  }
		/* 8225CF3Ch case    3:*/		return 0x8225CF40;
		  /* 8225CF40h */ case    4:  		/* lwz R10, <#[R29 + 12]> */
		/* 8225CF40h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225CF40h case    4:*/		return 0x8225CF44;
		  /* 8225CF44h */ case    5:  		/* li R3, 49 */
		/* 8225CF44h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225CF44h case    5:*/		return 0x8225CF48;
		  /* 8225CF48h */ case    6:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225CF48h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225CF48h case    6:*/		return 0x8225CF4C;
		  /* 8225CF4Ch */ case    7:  		/* addi R28, R11, -1 */
		/* 8225CF4Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFFF);
		/* 8225CF4Ch case    7:*/		return 0x8225CF50;
		  /* 8225CF50h */ case    8:  		/* stw R28, <#[R10 + 1508]> */
		/* 8225CF50h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225CF50h case    8:*/		return 0x8225CF54;
		  /* 8225CF54h */ case    9:  		/* lwz R4, <#[R29 + 12]> */
		/* 8225CF54h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 8225CF54h case    9:*/		return 0x8225CF58;
		  /* 8225CF58h */ case   10:  		/* bl -28712 */
		/* 8225CF58h case   10:*/		regs.LR = 0x8225CF5C; return 0x82255F30;
		/* 8225CF58h case   10:*/		return 0x8225CF5C;
		  /* 8225CF5Ch */ case   11:  		/* li R11, 0 */
		/* 8225CF5Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225CF5Ch case   11:*/		return 0x8225CF60;
		  /* 8225CF60h */ case   12:  		/* stw R28, <#[R3 + 56]> */
		/* 8225CF60h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000038) );
		/* 8225CF60h case   12:*/		return 0x8225CF64;
		  /* 8225CF64h */ case   13:  		/* mr R31, R3 */
		/* 8225CF64h case   13:*/		regs.R31 = regs.R3;
		/* 8225CF64h case   13:*/		return 0x8225CF68;
		  /* 8225CF68h */ case   14:  		/* stw R11, <#[R3 + 80]> */
		/* 8225CF68h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 8225CF68h case   14:*/		return 0x8225CF6C;
		  /* 8225CF6Ch */ case   15:  		/* rlwinm. R10, R27, 0, 24, 31 */
		/* 8225CF6Ch case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R27);
		/* 8225CF6Ch case   15:*/		return 0x8225CF70;
		  /* 8225CF70h */ case   16:  		/* lwz R11, <#[R29 + 92]> */
		/* 8225CF70h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000005C) );
		/* 8225CF70h case   16:*/		return 0x8225CF74;
		  /* 8225CF74h */ case   17:  		/* lwz R11, <#[R11 + 12]> */
		/* 8225CF74h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8225CF74h case   17:*/		return 0x8225CF78;
		  /* 8225CF78h */ case   18:  		/* stw R26, <#[R3 + 60]> */
		/* 8225CF78h case   18:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x0000003C) );
		/* 8225CF78h case   18:*/		return 0x8225CF7C;
		  /* 8225CF7Ch */ case   19:  		/* stw R11, <#[R3 + 84]> */
		/* 8225CF7Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 8225CF7Ch case   19:*/		return 0x8225CF80;
		  /* 8225CF80h */ case   20:  		/* bc 12, CR0_EQ, 20 */
		/* 8225CF80h case   20:*/		if ( regs.CR[0].eq ) { return 0x8225CF94;  }
		/* 8225CF80h case   20:*/		return 0x8225CF84;
		  /* 8225CF84h */ case   21:  		/* stw R24, <#[R3 + 204]> */
		/* 8225CF84h case   21:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x000000CC) );
		/* 8225CF84h case   21:*/		return 0x8225CF88;
		  /* 8225CF88h */ case   22:  		/* lwz R11, <#[R30]> */
		/* 8225CF88h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225CF88h case   22:*/		return 0x8225CF8C;
		  /* 8225CF8Ch */ case   23:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 8225CF8Ch case   23:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 8225CF8Ch case   23:*/		return 0x8225CF90;
		  /* 8225CF90h */ case   24:  		/* stw R11, <#[R30]> */
		/* 8225CF90h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225CF90h case   24:*/		return 0x8225CF94;
	}
	return 0x8225CF94;
} // Block from 8225CF30h-8225CF94h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225CF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CF94);
		  /* 8225CF94h */ case    0:  		/* mr R7, R31 */
		/* 8225CF94h case    0:*/		regs.R7 = regs.R31;
		/* 8225CF94h case    0:*/		return 0x8225CF98;
		  /* 8225CF98h */ case    1:  		/* lwz R4, <#[R1 + 276]> */
		/* 8225CF98h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 8225CF98h case    1:*/		return 0x8225CF9C;
		  /* 8225CF9Ch */ case    2:  		/* mr R6, R23 */
		/* 8225CF9Ch case    2:*/		regs.R6 = regs.R23;
		/* 8225CF9Ch case    2:*/		return 0x8225CFA0;
		  /* 8225CFA0h */ case    3:  		/* mr R5, R30 */
		/* 8225CFA0h case    3:*/		regs.R5 = regs.R30;
		/* 8225CFA0h case    3:*/		return 0x8225CFA4;
		  /* 8225CFA4h */ case    4:  		/* mr R3, R29 */
		/* 8225CFA4h case    4:*/		regs.R3 = regs.R29;
		/* 8225CFA4h case    4:*/		return 0x8225CFA8;
		  /* 8225CFA8h */ case    5:  		/* bl -10152 */
		/* 8225CFA8h case    5:*/		regs.LR = 0x8225CFAC; return 0x8225A800;
		/* 8225CFA8h case    5:*/		return 0x8225CFAC;
		  /* 8225CFACh */ case    6:  		/* mr R4, R31 */
		/* 8225CFACh case    6:*/		regs.R4 = regs.R31;
		/* 8225CFACh case    6:*/		return 0x8225CFB0;
		  /* 8225CFB0h */ case    7:  		/* mr R3, R29 */
		/* 8225CFB0h case    7:*/		regs.R3 = regs.R29;
		/* 8225CFB0h case    7:*/		return 0x8225CFB4;
		  /* 8225CFB4h */ case    8:  		/* bl -158220 */
		/* 8225CFB4h case    8:*/		regs.LR = 0x8225CFB8; return 0x822365A8;
		/* 8225CFB4h case    8:*/		return 0x8225CFB8;
		  /* 8225CFB8h */ case    9:  		/* mr R4, R31 */
		/* 8225CFB8h case    9:*/		regs.R4 = regs.R31;
		/* 8225CFB8h case    9:*/		return 0x8225CFBC;
		  /* 8225CFBCh */ case   10:  		/* lwz R3, <#[R1 + 308]> */
		/* 8225CFBCh case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000134) );
		/* 8225CFBCh case   10:*/		return 0x8225CFC0;
		  /* 8225CFC0h */ case   11:  		/* bl -16528 */
		/* 8225CFC0h case   11:*/		regs.LR = 0x8225CFC4; return 0x82258F30;
		/* 8225CFC0h case   11:*/		return 0x8225CFC4;
		  /* 8225CFC4h */ case   12:  		/* mr R3, R31 */
		/* 8225CFC4h case   12:*/		regs.R3 = regs.R31;
		/* 8225CFC4h case   12:*/		return 0x8225CFC8;
		  /* 8225CFC8h */ case   13:  		/* bl -28680 */
		/* 8225CFC8h case   13:*/		regs.LR = 0x8225CFCC; return 0x82255FC0;
		/* 8225CFC8h case   13:*/		return 0x8225CFCC;
		  /* 8225CFCCh */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225CFCCh case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225CFCCh case   14:*/		return 0x8225CFD0;
		  /* 8225CFD0h */ case   15:  		/* bc 4, CR0_EQ, 40 */
		/* 8225CFD0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8225CFF8;  }
		/* 8225CFD0h case   15:*/		return 0x8225CFD4;
		  /* 8225CFD4h */ case   16:  		/* lis R11, -32251 */
		/* 8225CFD4h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225CFD4h case   16:*/		return 0x8225CFD8;
		  /* 8225CFD8h */ case   17:  		/* lis R10, -32252 */
		/* 8225CFD8h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8225CFD8h case   17:*/		return 0x8225CFDC;
		  /* 8225CFDCh */ case   18:  		/* lis R9, -32253 */
		/* 8225CFDCh case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8225CFDCh case   18:*/		return 0x8225CFE0;
		  /* 8225CFE0h */ case   19:  		/* addi R6, R11, -21904 */
		/* 8225CFE0h case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFAA70);
		/* 8225CFE0h case   19:*/		return 0x8225CFE4;
		  /* 8225CFE4h */ case   20:  		/* addi R5, R10, 8936 */
		/* 8225CFE4h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x22E8);
		/* 8225CFE4h case   20:*/		return 0x8225CFE8;
		  /* 8225CFE8h */ case   21:  		/* addi R4, R9, 27460 */
		/* 8225CFE8h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8225CFE8h case   21:*/		return 0x8225CFEC;
		  /* 8225CFECh */ case   22:  		/* li R7, 1261 */
		/* 8225CFECh case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x4ED);
		/* 8225CFECh case   22:*/		return 0x8225CFF0;
		  /* 8225CFF0h */ case   23:  		/* li R3, 0 */
		/* 8225CFF0h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225CFF0h case   23:*/		return 0x8225CFF4;
		  /* 8225CFF4h */ case   24:  		/* bl -1070060 */
		/* 8225CFF4h case   24:*/		regs.LR = 0x8225CFF8; return 0x82157C08;
		/* 8225CFF4h case   24:*/		return 0x8225CFF8;
	}
	return 0x8225CFF8;
} // Block from 8225CF94h-8225CFF8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225CFF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225CFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225CFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225CFF8);
		  /* 8225CFF8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8225CFF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225CFF8h case    0:*/		return 0x8225CFFC;
		  /* 8225CFFCh */ case    1:  		/* li R9, 1 */
		/* 8225CFFCh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225CFFCh case    1:*/		return 0x8225D000;
		  /* 8225D000h */ case    2:  		/* li R31, 4 */
		/* 8225D000h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x4);
		/* 8225D000h case    2:*/		return 0x8225D004;
		  /* 8225D004h */ case    3:  		/* rlwinm R11, R11, 0, 10, 7 */
		/* 8225D004h case    3:*/		cpu::op::rlwinm<0,0,10,7>(regs,&regs.R11,regs.R11);
		/* 8225D004h case    3:*/		return 0x8225D008;
		  /* 8225D008h */ case    4:  		/* mr R26, R28 */
		/* 8225D008h case    4:*/		regs.R26 = regs.R28;
		/* 8225D008h case    4:*/		return 0x8225D00C;
		  /* 8225D00Ch */ case    5:  		/* stw R11, <#[R30]> */
		/* 8225D00Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225D00Ch case    5:*/		return 0x8225D010;
		  /* 8225D010h */ case    6:  		/* sth R28, <#[R30 + 2]> */
		/* 8225D010h case    6:*/		cpu::mem::store16( regs, regs.R28, (uint32)(regs.R30 + 0x00000002) );
		/* 8225D010h case    6:*/		return 0x8225D014;
		  /* 8225D014h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 8225D014h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225D014h case    7:*/		return 0x8225D018;
		  /* 8225D018h */ case    8:  		/* rlwimi R11, R9, 18, 10, 15 */
		/* 8225D018h case    8:*/		cpu::op::rlwimi<0,18,10,15>(regs,&regs.R11,regs.R9);
		/* 8225D018h case    8:*/		return 0x8225D01C;
		  /* 8225D01Ch */ case    9:  		/* stw R11, <#[R30]> */
		/* 8225D01Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225D01Ch case    9:*/		return 0x8225D020;
		  /* 8225D020h */ case   10:  		/* b 24 */
		/* 8225D020h case   10:*/		return 0x8225D038;
		/* 8225D020h case   10:*/		return 0x8225D024;
	}
	return 0x8225D024;
} // Block from 8225CFF8h-8225D024h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225D024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D024);
		  /* 8225D024h */ case    0:  		/* mr R7, R25 */
		/* 8225D024h case    0:*/		regs.R7 = regs.R25;
		/* 8225D024h case    0:*/		return 0x8225D028;
		  /* 8225D028h */ case    1:  		/* lwz R4, <#[R1 + 276]> */
		/* 8225D028h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 8225D028h case    1:*/		return 0x8225D02C;
		  /* 8225D02Ch */ case    2:  		/* mr R6, R23 */
		/* 8225D02Ch case    2:*/		regs.R6 = regs.R23;
		/* 8225D02Ch case    2:*/		return 0x8225D030;
		  /* 8225D030h */ case    3:  		/* mr R3, R29 */
		/* 8225D030h case    3:*/		regs.R3 = regs.R29;
		/* 8225D030h case    3:*/		return 0x8225D034;
		  /* 8225D034h */ case    4:  		/* bl -10292 */
		/* 8225D034h case    4:*/		regs.LR = 0x8225D038; return 0x8225A800;
		/* 8225D034h case    4:*/		return 0x8225D038;
	}
	return 0x8225D038;
} // Block from 8225D024h-8225D038h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225D038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D038);
		  /* 8225D038h */ case    0:  		/* addi R11, R23, 50 */
		/* 8225D038h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x32);
		/* 8225D038h case    0:*/		return 0x8225D03C;
		  /* 8225D03Ch */ case    1:  		/* rlwinm R10, R31, 3, 0, 28 */
		/* 8225D03Ch case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R31);
		/* 8225D03Ch case    1:*/		return 0x8225D040;
		  /* 8225D040h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225D040h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225D040h case    2:*/		return 0x8225D044;
		  /* 8225D044h */ case    3:  		/* addi R9, R23, 14 */
		/* 8225D044h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R23,0xE);
		/* 8225D044h case    3:*/		return 0x8225D048;
		  /* 8225D048h */ case    4:  		/* addi R8, R23, 20 */
		/* 8225D048h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R23,0x14);
		/* 8225D048h case    4:*/		return 0x8225D04C;
		  /* 8225D04Ch */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8225D04Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8225D04Ch case    5:*/		return 0x8225D050;
		  /* 8225D050h */ case    6:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8225D050h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8225D050h case    6:*/		return 0x8225D054;
		  /* 8225D054h */ case    7:  		/* stwx R24, <#[R11 + R25]> */
		/* 8225D054h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8225D054h case    7:*/		return 0x8225D058;
		  /* 8225D058h */ case    8:  		/* lwz R11, <#[R29 + 92]> */
		/* 8225D058h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000005C) );
		/* 8225D058h case    8:*/		return 0x8225D05C;
		  /* 8225D05Ch */ case    9:  		/* add R11, R10, R11 */
		/* 8225D05Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8225D05Ch case    9:*/		return 0x8225D060;
		  /* 8225D060h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225D060h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225D060h case   10:*/		return 0x8225D064;
		  /* 8225D064h */ case   11:  		/* stwx R26, <#[R9 + R25]> */
		/* 8225D064h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R25 + 0x00000000) );
		/* 8225D064h case   11:*/		return 0x8225D068;
		  /* 8225D068h */ case   12:  		/* stwx R11, <#[R8 + R25]> */
		/* 8225D068h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R25 + 0x00000000) );
		/* 8225D068h case   12:*/		return 0x8225D06C;
	}
	return 0x8225D06C;
} // Block from 8225D038h-8225D06Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225D06Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D06C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D06C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D06C);
		  /* 8225D06Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 8225D06Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8225D06Ch case    0:*/		return 0x8225D070;
		  /* 8225D070h */ case    1:  		/* b -1883612 */
		/* 8225D070h case    1:*/		return 0x82091294;
		/* 8225D070h case    1:*/		return 0x8225D074;
		  /* 8225D074h */ case    2:  		/* nop */
		/* 8225D074h case    2:*/		cpu::op::nop();
		/* 8225D074h case    2:*/		return 0x8225D078;
	}
	return 0x8225D078;
} // Block from 8225D06Ch-8225D078h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225D078h
// Function '?ExpandDCLV@CFG@XGRAPHICS@@AAAXHPATIL_Dst@2@TSwizzleOrMaskInfo@2@PAVBlock@2@_NPATIL_Src@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D078);
		  /* 8225D078h */ case    0:  		/* mfspr R12, LR */
		/* 8225D078h case    0:*/		regs.R12 = regs.LR;
		/* 8225D078h case    0:*/		return 0x8225D07C;
		  /* 8225D07Ch */ case    1:  		/* bl -1883740 */
		/* 8225D07Ch case    1:*/		regs.LR = 0x8225D080; return 0x82091220;
		/* 8225D07Ch case    1:*/		return 0x8225D080;
		  /* 8225D080h */ case    2:  		/* addi R12, R1, -152 */
		/* 8225D080h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 8225D080h case    2:*/		return 0x8225D084;
		  /* 8225D084h */ case    3:  		/* bl -1883252 */
		/* 8225D084h case    3:*/		regs.LR = 0x8225D088; return 0x82091410;
		/* 8225D084h case    3:*/		return 0x8225D088;
		  /* 8225D088h */ case    4:  		/* stwu R1, <#[R1 - 912]> */
		/* 8225D088h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFC70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFC70);
		/* 8225D088h case    4:*/		return 0x8225D08C;
		  /* 8225D08Ch */ case    5:  		/* lwz R11, <#[R3 + 12]> */
		/* 8225D08Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8225D08Ch case    5:*/		return 0x8225D090;
		  /* 8225D090h */ case    6:  		/* mr R31, R3 */
		/* 8225D090h case    6:*/		regs.R31 = regs.R3;
		/* 8225D090h case    6:*/		return 0x8225D094;
		  /* 8225D094h */ case    7:  		/* mr R28, R4 */
		/* 8225D094h case    7:*/		regs.R28 = regs.R4;
		/* 8225D094h case    7:*/		return 0x8225D098;
		  /* 8225D098h */ case    8:  		/* stw R4, <#[R1 + 940]> */
		/* 8225D098h case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000003AC) );
		/* 8225D098h case    8:*/		return 0x8225D09C;
		  /* 8225D09Ch */ case    9:  		/* lwz R10, <#[R11 + 1360]> */
		/* 8225D09Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000550) );
		/* 8225D09Ch case    9:*/		return 0x8225D0A0;
		  /* 8225D0A0h */ case   10:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8225D0A0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D0A0h case   10:*/		return 0x8225D0A4;
		  /* 8225D0A4h */ case   11:  		/* lwz R3, <#[R10 + 24]> */
		/* 8225D0A4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000018) );
		/* 8225D0A4h case   11:*/		return 0x8225D0A8;
		  /* 8225D0A8h */ case   12:  		/* bl -157544 */
		/* 8225D0A8h case   12:*/		regs.LR = 0x8225D0AC; return 0x82236940;
		/* 8225D0A8h case   12:*/		return 0x8225D0AC;
		  /* 8225D0ACh */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D0ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D0ACh case   13:*/		return 0x8225D0B0;
		  /* 8225D0B0h */ case   14:  		/* li R4, 96 */
		/* 8225D0B0h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 8225D0B0h case   14:*/		return 0x8225D0B4;
		  /* 8225D0B4h */ case   15:  		/* mr R26, R3 */
		/* 8225D0B4h case   15:*/		regs.R26 = regs.R3;
		/* 8225D0B4h case   15:*/		return 0x8225D0B8;
		  /* 8225D0B8h */ case   16:  		/* stw R3, <#[R1 + 260]> */
		/* 8225D0B8h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000104) );
		/* 8225D0B8h case   16:*/		return 0x8225D0BC;
		  /* 8225D0BCh */ case   17:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225D0BCh case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D0BCh case   17:*/		return 0x8225D0C0;
		  /* 8225D0C0h */ case   18:  		/* bl -265224 */
		/* 8225D0C0h case   18:*/		regs.LR = 0x8225D0C4; return 0x8221C4B8;
		/* 8225D0C0h case   18:*/		return 0x8225D0C4;
		  /* 8225D0C4h */ case   19:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D0C4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D0C4h case   19:*/		return 0x8225D0C8;
		  /* 8225D0C8h */ case   20:  		/* li R4, 96 */
		/* 8225D0C8h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 8225D0C8h case   20:*/		return 0x8225D0CC;
		  /* 8225D0CCh */ case   21:  		/* stw R3, <#[R1 + 228]> */
		/* 8225D0CCh case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000E4) );
		/* 8225D0CCh case   21:*/		return 0x8225D0D0;
		  /* 8225D0D0h */ case   22:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225D0D0h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D0D0h case   22:*/		return 0x8225D0D4;
		  /* 8225D0D4h */ case   23:  		/* bl -265244 */
		/* 8225D0D4h case   23:*/		regs.LR = 0x8225D0D8; return 0x8221C4B8;
		/* 8225D0D4h case   23:*/		return 0x8225D0D8;
		  /* 8225D0D8h */ case   24:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D0D8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D0D8h case   24:*/		return 0x8225D0DC;
		  /* 8225D0DCh */ case   25:  		/* li R4, 96 */
		/* 8225D0DCh case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 8225D0DCh case   25:*/		return 0x8225D0E0;
		  /* 8225D0E0h */ case   26:  		/* stw R3, <#[R1 + 284]> */
		/* 8225D0E0h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000011C) );
		/* 8225D0E0h case   26:*/		return 0x8225D0E4;
		  /* 8225D0E4h */ case   27:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225D0E4h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D0E4h case   27:*/		return 0x8225D0E8;
		  /* 8225D0E8h */ case   28:  		/* bl -265264 */
		/* 8225D0E8h case   28:*/		regs.LR = 0x8225D0EC; return 0x8221C4B8;
		/* 8225D0E8h case   28:*/		return 0x8225D0EC;
		  /* 8225D0ECh */ case   29:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D0ECh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D0ECh case   29:*/		return 0x8225D0F0;
		  /* 8225D0F0h */ case   30:  		/* li R4, 288 */
		/* 8225D0F0h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x120);
		/* 8225D0F0h case   30:*/		return 0x8225D0F4;
		  /* 8225D0F4h */ case   31:  		/* stw R3, <#[R1 + 224]> */
		/* 8225D0F4h case   31:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000E0) );
		/* 8225D0F4h case   31:*/		return 0x8225D0F8;
		  /* 8225D0F8h */ case   32:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225D0F8h case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D0F8h case   32:*/		return 0x8225D0FC;
		  /* 8225D0FCh */ case   33:  		/* bl -265284 */
		/* 8225D0FCh case   33:*/		regs.LR = 0x8225D100; return 0x8221C4B8;
		/* 8225D0FCh case   33:*/		return 0x8225D100;
		  /* 8225D100h */ case   34:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D100h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D100h case   34:*/		return 0x8225D104;
		  /* 8225D104h */ case   35:  		/* li R4, 96 */
		/* 8225D104h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 8225D104h case   35:*/		return 0x8225D108;
		  /* 8225D108h */ case   36:  		/* stw R3, <#[R1 + 308]> */
		/* 8225D108h case   36:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000134) );
		/* 8225D108h case   36:*/		return 0x8225D10C;
		  /* 8225D10Ch */ case   37:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225D10Ch case   37:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D10Ch case   37:*/		return 0x8225D110;
		  /* 8225D110h */ case   38:  		/* bl -265304 */
		/* 8225D110h case   38:*/		regs.LR = 0x8225D114; return 0x8221C4B8;
		/* 8225D110h case   38:*/		return 0x8225D114;
		  /* 8225D114h */ case   39:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D114h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D114h case   39:*/		return 0x8225D118;
		  /* 8225D118h */ case   40:  		/* li R4, 288 */
		/* 8225D118h case   40:*/		cpu::op::li<0>(regs,&regs.R4,0x120);
		/* 8225D118h case   40:*/		return 0x8225D11C;
		  /* 8225D11Ch */ case   41:  		/* stw R3, <#[R1 + 180]> */
		/* 8225D11Ch case   41:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000B4) );
		/* 8225D11Ch case   41:*/		return 0x8225D120;
		  /* 8225D120h */ case   42:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8225D120h case   42:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D120h case   42:*/		return 0x8225D124;
		  /* 8225D124h */ case   43:  		/* bl -265324 */
		/* 8225D124h case   43:*/		regs.LR = 0x8225D128; return 0x8221C4B8;
		/* 8225D124h case   43:*/		return 0x8225D128;
		  /* 8225D128h */ case   44:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D128h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D128h case   44:*/		return 0x8225D12C;
		  /* 8225D12Ch */ case   45:  		/* li R4, 20 */
		/* 8225D12Ch case   45:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8225D12Ch case   45:*/		return 0x8225D130;
		  /* 8225D130h */ case   46:  		/* stw R3, <#[R1 + 276]> */
		/* 8225D130h case   46:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000114) );
		/* 8225D130h case   46:*/		return 0x8225D134;
		  /* 8225D134h */ case   47:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8225D134h case   47:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D134h case   47:*/		return 0x8225D138;
		  /* 8225D138h */ case   48:  		/* mr R3, R27 */
		/* 8225D138h case   48:*/		regs.R3 = regs.R27;
		/* 8225D138h case   48:*/		return 0x8225D13C;
		  /* 8225D13Ch */ case   49:  		/* bl -265348 */
		/* 8225D13Ch case   49:*/		regs.LR = 0x8225D140; return 0x8221C4B8;
		/* 8225D13Ch case   49:*/		return 0x8225D140;
		  /* 8225D140h */ case   50:  		/* li R29, 0 */
		/* 8225D140h case   50:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8225D140h case   50:*/		return 0x8225D144;
		  /* 8225D144h */ case   51:  		/* addic. R30, R3, 4 */
		/* 8225D144h case   51:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8225D144h case   51:*/		return 0x8225D148;
		  /* 8225D148h */ case   52:  		/* stw R27, <#[R3]> */
		/* 8225D148h case   52:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8225D148h case   52:*/		return 0x8225D14C;
		  /* 8225D14Ch */ case   53:  		/* bc 12, CR0_EQ, 28 */
		/* 8225D14Ch case   53:*/		if ( regs.CR[0].eq ) { return 0x8225D168;  }
		/* 8225D14Ch case   53:*/		return 0x8225D150;
		  /* 8225D150h */ case   54:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D150h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D150h case   54:*/		return 0x8225D154;
		  /* 8225D154h */ case   55:  		/* mr R3, R30 */
		/* 8225D154h case   55:*/		regs.R3 = regs.R30;
		/* 8225D154h case   55:*/		return 0x8225D158;
		  /* 8225D158h */ case   56:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8225D158h case   56:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D158h case   56:*/		return 0x8225D15C;
		  /* 8225D15Ch */ case   57:  		/* bl -160764 */
		/* 8225D15Ch case   57:*/		regs.LR = 0x8225D160; return 0x82235D60;
		/* 8225D15Ch case   57:*/		return 0x8225D160;
		  /* 8225D160h */ case   58:  		/* mr R25, R30 */
		/* 8225D160h case   58:*/		regs.R25 = regs.R30;
		/* 8225D160h case   58:*/		return 0x8225D164;
		  /* 8225D164h */ case   59:  		/* b 8 */
		/* 8225D164h case   59:*/		return 0x8225D16C;
		/* 8225D164h case   59:*/		return 0x8225D168;
	}
	return 0x8225D168;
} // Block from 8225D078h-8225D168h (60 instructions)

//////////////////////////////////////////////////////
// Block at 8225D168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D168);
		  /* 8225D168h */ case    0:  		/* mr R25, R29 */
		/* 8225D168h case    0:*/		regs.R25 = regs.R29;
		/* 8225D168h case    0:*/		return 0x8225D16C;
	}
	return 0x8225D16C;
} // Block from 8225D168h-8225D16Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225D16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D16C);
		  /* 8225D16Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D16Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D16Ch case    0:*/		return 0x8225D170;
		  /* 8225D170h */ case    1:  		/* li R4, 20 */
		/* 8225D170h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8225D170h case    1:*/		return 0x8225D174;
		  /* 8225D174h */ case    2:  		/* stw R25, <#[R1 + 164]> */
		/* 8225D174h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x000000A4) );
		/* 8225D174h case    2:*/		return 0x8225D178;
		  /* 8225D178h */ case    3:  		/* stw R29, <#[R1 + 188]> */
		/* 8225D178h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x000000BC) );
		/* 8225D178h case    3:*/		return 0x8225D17C;
		  /* 8225D17Ch */ case    4:  		/* lwz R27, <#[R11 + 1456]> */
		/* 8225D17Ch case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D17Ch case    4:*/		return 0x8225D180;
		  /* 8225D180h */ case    5:  		/* mr R3, R27 */
		/* 8225D180h case    5:*/		regs.R3 = regs.R27;
		/* 8225D180h case    5:*/		return 0x8225D184;
		  /* 8225D184h */ case    6:  		/* bl -265420 */
		/* 8225D184h case    6:*/		regs.LR = 0x8225D188; return 0x8221C4B8;
		/* 8225D184h case    6:*/		return 0x8225D188;
		  /* 8225D188h */ case    7:  		/* addic. R30, R3, 4 */
		/* 8225D188h case    7:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8225D188h case    7:*/		return 0x8225D18C;
		  /* 8225D18Ch */ case    8:  		/* stw R27, <#[R3]> */
		/* 8225D18Ch case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 8225D18Ch case    8:*/		return 0x8225D190;
		  /* 8225D190h */ case    9:  		/* bc 12, CR0_EQ, 28 */
		/* 8225D190h case    9:*/		if ( regs.CR[0].eq ) { return 0x8225D1AC;  }
		/* 8225D190h case    9:*/		return 0x8225D194;
		  /* 8225D194h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D194h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D194h case   10:*/		return 0x8225D198;
		  /* 8225D198h */ case   11:  		/* mr R3, R30 */
		/* 8225D198h case   11:*/		regs.R3 = regs.R30;
		/* 8225D198h case   11:*/		return 0x8225D19C;
		  /* 8225D19Ch */ case   12:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8225D19Ch case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D19Ch case   12:*/		return 0x8225D1A0;
		  /* 8225D1A0h */ case   13:  		/* bl -160832 */
		/* 8225D1A0h case   13:*/		regs.LR = 0x8225D1A4; return 0x82235D60;
		/* 8225D1A0h case   13:*/		return 0x8225D1A4;
		  /* 8225D1A4h */ case   14:  		/* mr R27, R30 */
		/* 8225D1A4h case   14:*/		regs.R27 = regs.R30;
		/* 8225D1A4h case   14:*/		return 0x8225D1A8;
		  /* 8225D1A8h */ case   15:  		/* b 8 */
		/* 8225D1A8h case   15:*/		return 0x8225D1B0;
		/* 8225D1A8h case   15:*/		return 0x8225D1AC;
	}
	return 0x8225D1AC;
} // Block from 8225D16Ch-8225D1ACh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225D1ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D1AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D1AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D1AC);
		  /* 8225D1ACh */ case    0:  		/* mr R27, R29 */
		/* 8225D1ACh case    0:*/		regs.R27 = regs.R29;
		/* 8225D1ACh case    0:*/		return 0x8225D1B0;
	}
	return 0x8225D1B0;
} // Block from 8225D1ACh-8225D1B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225D1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D1B0);
		  /* 8225D1B0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D1B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D1B0h case    0:*/		return 0x8225D1B4;
		  /* 8225D1B4h */ case    1:  		/* li R4, 140 */
		/* 8225D1B4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x8C);
		/* 8225D1B4h case    1:*/		return 0x8225D1B8;
		  /* 8225D1B8h */ case    2:  		/* lwz R30, <#[R31 + 164]> */
		/* 8225D1B8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000000A4) );
		/* 8225D1B8h case    2:*/		return 0x8225D1BC;
		  /* 8225D1BCh */ case    3:  		/* stw R27, <#[R1 + 220]> */
		/* 8225D1BCh case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x000000DC) );
		/* 8225D1BCh case    3:*/		return 0x8225D1C0;
		  /* 8225D1C0h */ case    4:  		/* lwz R24, <#[R11 + 1452]> */
		/* 8225D1C0h case    4:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225D1C0h case    4:*/		return 0x8225D1C4;
		  /* 8225D1C4h */ case    5:  		/* mr R3, R24 */
		/* 8225D1C4h case    5:*/		regs.R3 = regs.R24;
		/* 8225D1C4h case    5:*/		return 0x8225D1C8;
		  /* 8225D1C8h */ case    6:  		/* bl -265488 */
		/* 8225D1C8h case    6:*/		regs.LR = 0x8225D1CC; return 0x8221C4B8;
		/* 8225D1C8h case    6:*/		return 0x8225D1CC;
		  /* 8225D1CCh */ case    7:  		/* mr R11, R3 */
		/* 8225D1CCh case    7:*/		regs.R11 = regs.R3;
		/* 8225D1CCh case    7:*/		return 0x8225D1D0;
		  /* 8225D1D0h */ case    8:  		/* addic. R3, R3, 4 */
		/* 8225D1D0h case    8:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8225D1D0h case    8:*/		return 0x8225D1D4;
		  /* 8225D1D4h */ case    9:  		/* stw R24, <#[R11]> */
		/* 8225D1D4h case    9:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D1D4h case    9:*/		return 0x8225D1D8;
		  /* 8225D1D8h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 8225D1D8h case   10:*/		if ( regs.CR[0].eq ) { return 0x8225D1EC;  }
		/* 8225D1D8h case   10:*/		return 0x8225D1DC;
		  /* 8225D1DCh */ case   11:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225D1DCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D1DCh case   11:*/		return 0x8225D1E0;
		  /* 8225D1E0h */ case   12:  		/* bl -16528 */
		/* 8225D1E0h case   12:*/		regs.LR = 0x8225D1E4; return 0x82259150;
		/* 8225D1E0h case   12:*/		return 0x8225D1E4;
		  /* 8225D1E4h */ case   13:  		/* mr R14, R3 */
		/* 8225D1E4h case   13:*/		regs.R14 = regs.R3;
		/* 8225D1E4h case   13:*/		return 0x8225D1E8;
		  /* 8225D1E8h */ case   14:  		/* b 8 */
		/* 8225D1E8h case   14:*/		return 0x8225D1F0;
		/* 8225D1E8h case   14:*/		return 0x8225D1EC;
	}
	return 0x8225D1EC;
} // Block from 8225D1B0h-8225D1ECh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8225D1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D1EC);
		  /* 8225D1ECh */ case    0:  		/* mr R14, R29 */
		/* 8225D1ECh case    0:*/		regs.R14 = regs.R29;
		/* 8225D1ECh case    0:*/		return 0x8225D1F0;
	}
	return 0x8225D1F0;
} // Block from 8225D1ECh-8225D1F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225D1F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D1F0);
		  /* 8225D1F0h */ case    0:  		/* mr R5, R14 */
		/* 8225D1F0h case    0:*/		regs.R5 = regs.R14;
		/* 8225D1F0h case    0:*/		return 0x8225D1F4;
		  /* 8225D1F4h */ case    1:  		/* stw R14, <#[R1 + 244]> */
		/* 8225D1F4h case    1:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x000000F4) );
		/* 8225D1F4h case    1:*/		return 0x8225D1F8;
		  /* 8225D1F8h */ case    2:  		/* mr R4, R30 */
		/* 8225D1F8h case    2:*/		regs.R4 = regs.R30;
		/* 8225D1F8h case    2:*/		return 0x8225D1FC;
		  /* 8225D1FCh */ case    3:  		/* mr R3, R31 */
		/* 8225D1FCh case    3:*/		regs.R3 = regs.R31;
		/* 8225D1FCh case    3:*/		return 0x8225D200;
		  /* 8225D200h */ case    4:  		/* bl -161192 */
		/* 8225D200h case    4:*/		regs.LR = 0x8225D204; return 0x82235C58;
		/* 8225D200h case    4:*/		return 0x8225D204;
		  /* 8225D204h */ case    5:  		/* mr R4, R14 */
		/* 8225D204h case    5:*/		regs.R4 = regs.R14;
		/* 8225D204h case    5:*/		return 0x8225D208;
		  /* 8225D208h */ case    6:  		/* mr R3, R30 */
		/* 8225D208h case    6:*/		regs.R3 = regs.R30;
		/* 8225D208h case    6:*/		return 0x8225D20C;
		  /* 8225D20Ch */ case    7:  		/* bl -14652 */
		/* 8225D20Ch case    7:*/		regs.LR = 0x8225D210; return 0x822598D0;
		/* 8225D20Ch case    7:*/		return 0x8225D210;
		  /* 8225D210h */ case    8:  		/* addi R3, R1, 624 */
		/* 8225D210h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x270);
		/* 8225D210h case    8:*/		return 0x8225D214;
		  /* 8225D214h */ case    9:  		/* stw R14, <#[R1 + 160]> */
		/* 8225D214h case    9:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x000000A0) );
		/* 8225D214h case    9:*/		return 0x8225D218;
		  /* 8225D218h */ case   10:  		/* bl -39408 */
		/* 8225D218h case   10:*/		regs.LR = 0x8225D21C; return 0x82253828;
		/* 8225D218h case   10:*/		return 0x8225D21C;
		  /* 8225D21Ch */ case   11:  		/* addi R3, R1, 656 */
		/* 8225D21Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x290);
		/* 8225D21Ch case   11:*/		return 0x8225D220;
		  /* 8225D220h */ case   12:  		/* bl -39416 */
		/* 8225D220h case   12:*/		regs.LR = 0x8225D224; return 0x82253828;
		/* 8225D220h case   12:*/		return 0x8225D224;
		  /* 8225D224h */ case   13:  		/* stb R29, <#[R31 + 2100]> */
		/* 8225D224h case   13:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R31 + 0x00000834) );
		/* 8225D224h case   13:*/		return 0x8225D228;
		  /* 8225D228h */ case   14:  		/* stb R29, <#[R31 + 2116]> */
		/* 8225D228h case   14:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R31 + 0x00000844) );
		/* 8225D228h case   14:*/		return 0x8225D22C;
		  /* 8225D22Ch */ case   15:  		/* mr R3, R28 */
		/* 8225D22Ch case   15:*/		regs.R3 = regs.R28;
		/* 8225D22Ch case   15:*/		return 0x8225D230;
		  /* 8225D230h */ case   16:  		/* stb R29, <#[R1 + 201]> */
		/* 8225D230h case   16:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x000000C9) );
		/* 8225D230h case   16:*/		return 0x8225D234;
		  /* 8225D234h */ case   17:  		/* bl -130516 */
		/* 8225D234h case   17:*/		regs.LR = 0x8225D238; return 0x8223D460;
		/* 8225D234h case   17:*/		return 0x8225D238;
		  /* 8225D238h */ case   18:  		/* lis R11, -32253 */
		/* 8225D238h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8225D238h case   18:*/		return 0x8225D23C;
		  /* 8225D23Ch */ case   19:  		/* lis R10, -32251 */
		/* 8225D23Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225D23Ch case   19:*/		return 0x8225D240;
		  /* 8225D240h */ case   20:  		/* addi R11, R11, 27460 */
		/* 8225D240h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6B44);
		/* 8225D240h case   20:*/		return 0x8225D244;
		  /* 8225D244h */ case   21:  		/* addi R10, R10, -21904 */
		/* 8225D244h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFAA70);
		/* 8225D244h case   21:*/		return 0x8225D248;
		  /* 8225D248h */ case   22:  		/* rlwinm. R9, R3, 0, 24, 31 */
		/* 8225D248h case   22:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R3);
		/* 8225D248h case   22:*/		return 0x8225D24C;
		  /* 8225D24Ch */ case   23:  		/* stw R11, <#[R1 + 132]> */
		/* 8225D24Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 8225D24Ch case   23:*/		return 0x8225D250;
		  /* 8225D250h */ case   24:  		/* stw R10, <#[R1 + 128]> */
		/* 8225D250h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8225D250h case   24:*/		return 0x8225D254;
		  /* 8225D254h */ case   25:  		/* bc 12, CR0_EQ, 24688 */
		/* 8225D254h case   25:*/		if ( regs.CR[0].eq ) { return 0x822632C4;  }
		/* 8225D254h case   25:*/		return 0x8225D258;
		  /* 8225D258h */ case   26:  		/* lis R11, -32251 */
		/* 8225D258h case   26:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D258h case   26:*/		return 0x8225D25C;
		  /* 8225D25Ch */ case   27:  		/* lis R10, -32216 */
		/* 8225D25Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8225D25Ch case   27:*/		return 0x8225D260;
		  /* 8225D260h */ case   28:  		/* addi R8, R11, -30188 */
		/* 8225D260h case   28:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFF8A14);
		/* 8225D260h case   28:*/		return 0x8225D264;
		  /* 8225D264h */ case   29:  		/* lis R11, -32252 */
		/* 8225D264h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225D264h case   29:*/		return 0x8225D268;
		  /* 8225D268h */ case   30:  		/* stw R8, <#[R1 + 136]> */
		/* 8225D268h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000088) );
		/* 8225D268h case   30:*/		return 0x8225D26C;
		  /* 8225D26Ch */ case   31:  		/* lis R8, -32251 */
		/* 8225D26Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8205);
		/* 8225D26Ch case   31:*/		return 0x8225D270;
		  /* 8225D270h */ case   32:  		/* addi R7, R11, 8988 */
		/* 8225D270h case   32:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x231C);
		/* 8225D270h case   32:*/		return 0x8225D274;
		  /* 8225D274h */ case   33:  		/* lis R11, -32251 */
		/* 8225D274h case   33:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D274h case   33:*/		return 0x8225D278;
		  /* 8225D278h */ case   34:  		/* lis R9, -32252 */
		/* 8225D278h case   34:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 8225D278h case   34:*/		return 0x8225D27C;
		  /* 8225D27Ch */ case   35:  		/* stw R7, <#[R1 + 280]> */
		/* 8225D27Ch case   35:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000118) );
		/* 8225D27Ch case   35:*/		return 0x8225D280;
		  /* 8225D280h */ case   36:  		/* addi R6, R11, -19368 */
		/* 8225D280h case   36:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB458);
		/* 8225D280h case   36:*/		return 0x8225D284;
		  /* 8225D284h */ case   37:  		/* lis R11, -32251 */
		/* 8225D284h case   37:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D284h case   37:*/		return 0x8225D288;
		  /* 8225D288h */ case   38:  		/* stw R6, <#[R1 + 480]> */
		/* 8225D288h case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001E0) );
		/* 8225D288h case   38:*/		return 0x8225D28C;
		  /* 8225D28Ch */ case   39:  		/* lis R7, -32251 */
		/* 8225D28Ch case   39:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8205);
		/* 8225D28Ch case   39:*/		return 0x8225D290;
		  /* 8225D290h */ case   40:  		/* addi R11, R11, -19404 */
		/* 8225D290h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB434);
		/* 8225D290h case   40:*/		return 0x8225D294;
		  /* 8225D294h */ case   41:  		/* lis R6, -32251 */
		/* 8225D294h case   41:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8205);
		/* 8225D294h case   41:*/		return 0x8225D298;
		  /* 8225D298h */ case   42:  		/* stw R11, <#[R1 + 428]> */
		/* 8225D298h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000001AC) );
		/* 8225D298h case   42:*/		return 0x8225D29C;
		  /* 8225D29Ch */ case   43:  		/* addi R11, R8, -19344 */
		/* 8225D29Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFB470);
		/* 8225D29Ch case   43:*/		return 0x8225D2A0;
		  /* 8225D2A0h */ case   44:  		/* lis R5, -32251 */
		/* 8225D2A0h case   44:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8205);
		/* 8225D2A0h case   44:*/		return 0x8225D2A4;
		  /* 8225D2A4h */ case   45:  		/* addi R17, R10, 12984 */
		/* 8225D2A4h case   45:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R10,0x32B8);
		/* 8225D2A4h case   45:*/		return 0x8225D2A8;
		  /* 8225D2A8h */ case   46:  		/* stw R11, <#[R1 + 412]> */
		/* 8225D2A8h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000019C) );
		/* 8225D2A8h case   46:*/		return 0x8225D2AC;
		  /* 8225D2ACh */ case   47:  		/* addi R18, R9, 14380 */
		/* 8225D2ACh case   47:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R9,0x382C);
		/* 8225D2ACh case   47:*/		return 0x8225D2B0;
		  /* 8225D2B0h */ case   48:  		/* addi R10, R7, -19424 */
		/* 8225D2B0h case   48:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFB420);
		/* 8225D2B0h case   48:*/		return 0x8225D2B4;
		  /* 8225D2B4h */ case   49:  		/* stw R17, <#[R1 + 384]> */
		/* 8225D2B4h case   49:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000180) );
		/* 8225D2B4h case   49:*/		return 0x8225D2B8;
		  /* 8225D2B8h */ case   50:  		/* addi R9, R6, -19460 */
		/* 8225D2B8h case   50:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0xFFFFB3FC);
		/* 8225D2B8h case   50:*/		return 0x8225D2BC;
		  /* 8225D2BCh */ case   51:  		/* stw R18, <#[R1 + 548]> */
		/* 8225D2BCh case   51:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000224) );
		/* 8225D2BCh case   51:*/		return 0x8225D2C0;
		  /* 8225D2C0h */ case   52:  		/* addi R11, R5, -19480 */
		/* 8225D2C0h case   52:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFB3E8);
		/* 8225D2C0h case   52:*/		return 0x8225D2C4;
		  /* 8225D2C4h */ case   53:  		/* stw R10, <#[R1 + 356]> */
		/* 8225D2C4h case   53:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000164) );
		/* 8225D2C4h case   53:*/		return 0x8225D2C8;
		  /* 8225D2C8h */ case   54:  		/* lis R3, -32251 */
		/* 8225D2C8h case   54:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8205);
		/* 8225D2C8h case   54:*/		return 0x8225D2CC;
		  /* 8225D2CCh */ case   55:  		/* stw R9, <#[R1 + 396]> */
		/* 8225D2CCh case   55:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000018C) );
		/* 8225D2CCh case   55:*/		return 0x8225D2D0;
		  /* 8225D2D0h */ case   56:  		/* lis R4, -32251 */
		/* 8225D2D0h case   56:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8205);
		/* 8225D2D0h case   56:*/		return 0x8225D2D4;
		  /* 8225D2D4h */ case   57:  		/* stw R11, <#[R1 + 380]> */
		/* 8225D2D4h case   57:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000017C) );
		/* 8225D2D4h case   57:*/		return 0x8225D2D8;
		  /* 8225D2D8h */ case   58:  		/* lis R30, -32251 */
		/* 8225D2D8h case   58:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8205);
		/* 8225D2D8h case   58:*/		return 0x8225D2DC;
		  /* 8225D2DCh */ case   59:  		/* addi R9, R3, -19496 */
		/* 8225D2DCh case   59:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0xFFFFB3D8);
		/* 8225D2DCh case   59:*/		return 0x8225D2E0;
		  /* 8225D2E0h */ case   60:  		/* addi R10, R4, -19516 */
		/* 8225D2E0h case   60:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFB3C4);
		/* 8225D2E0h case   60:*/		return 0x8225D2E4;
		  /* 8225D2E4h */ case   61:  		/* addi R11, R30, -19532 */
		/* 8225D2E4h case   61:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFB3B4);
		/* 8225D2E4h case   61:*/		return 0x8225D2E8;
		  /* 8225D2E8h */ case   62:  		/* stw R9, <#[R1 + 528]> */
		/* 8225D2E8h case   62:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000210) );
		/* 8225D2E8h case   62:*/		return 0x8225D2EC;
		  /* 8225D2ECh */ case   63:  		/* lis R29, -32251 */
		/* 8225D2ECh case   63:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8205);
		/* 8225D2ECh case   63:*/		return 0x8225D2F0;
		  /* 8225D2F0h */ case   64:  		/* stw R10, <#[R1 + 376]> */
		/* 8225D2F0h case   64:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000178) );
		/* 8225D2F0h case   64:*/		return 0x8225D2F4;
		  /* 8225D2F4h */ case   65:  		/* lis R28, -32216 */
		/* 8225D2F4h case   65:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8228);
		/* 8225D2F4h case   65:*/		return 0x8225D2F8;
		  /* 8225D2F8h */ case   66:  		/* stw R11, <#[R1 + 340]> */
		/* 8225D2F8h case   66:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000154) );
		/* 8225D2F8h case   66:*/		return 0x8225D2FC;
		  /* 8225D2FCh */ case   67:  		/* lis R27, -32251 */
		/* 8225D2FCh case   67:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8205);
		/* 8225D2FCh case   67:*/		return 0x8225D300;
		  /* 8225D300h */ case   68:  		/* addi R10, R29, -19560 */
		/* 8225D300h case   68:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFB398);
		/* 8225D300h case   68:*/		return 0x8225D304;
		  /* 8225D304h */ case   69:  		/* addi R9, R28, 25584 */
		/* 8225D304h case   69:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0x63F0);
		/* 8225D304h case   69:*/		return 0x8225D308;
		  /* 8225D308h */ case   70:  		/* addi R11, R27, -19580 */
		/* 8225D308h case   70:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFB384);
		/* 8225D308h case   70:*/		return 0x8225D30C;
		  /* 8225D30Ch */ case   71:  		/* stw R10, <#[R1 + 300]> */
		/* 8225D30Ch case   71:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000012C) );
		/* 8225D30Ch case   71:*/		return 0x8225D310;
		  /* 8225D310h */ case   72:  		/* lis R26, -32251 */
		/* 8225D310h case   72:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8205);
		/* 8225D310h case   72:*/		return 0x8225D314;
		  /* 8225D314h */ case   73:  		/* stw R9, <#[R1 + 272]> */
		/* 8225D314h case   73:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000110) );
		/* 8225D314h case   73:*/		return 0x8225D318;
		  /* 8225D318h */ case   74:  		/* lis R25, -32251 */
		/* 8225D318h case   74:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFF8205);
		/* 8225D318h case   74:*/		return 0x8225D31C;
		  /* 8225D31Ch */ case   75:  		/* stw R11, <#[R1 + 464]> */
		/* 8225D31Ch case   75:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000001D0) );
		/* 8225D31Ch case   75:*/		return 0x8225D320;
		  /* 8225D320h */ case   76:  		/* lis R24, -32252 */
		/* 8225D320h case   76:*/		cpu::op::lis<0>(regs,&regs.R24,0xFFFF8204);
		/* 8225D320h case   76:*/		return 0x8225D324;
		  /* 8225D324h */ case   77:  		/* addi R10, R26, -19612 */
		/* 8225D324h case   77:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0xFFFFB364);
		/* 8225D324h case   77:*/		return 0x8225D328;
		  /* 8225D328h */ case   78:  		/* addi R9, R25, -19628 */
		/* 8225D328h case   78:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R25,0xFFFFB354);
		/* 8225D328h case   78:*/		return 0x8225D32C;
		  /* 8225D32Ch */ case   79:  		/* addi R11, R24, 8912 */
		/* 8225D32Ch case   79:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x22D0);
		/* 8225D32Ch case   79:*/		return 0x8225D330;
		  /* 8225D330h */ case   80:  		/* stw R10, <#[R1 + 520]> */
		/* 8225D330h case   80:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000208) );
		/* 8225D330h case   80:*/		return 0x8225D334;
		  /* 8225D334h */ case   81:  		/* lis R23, -32251 */
		/* 8225D334h case   81:*/		cpu::op::lis<0>(regs,&regs.R23,0xFFFF8205);
		/* 8225D334h case   81:*/		return 0x8225D338;
		  /* 8225D338h */ case   82:  		/* stw R9, <#[R1 + 324]> */
		/* 8225D338h case   82:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000144) );
		/* 8225D338h case   82:*/		return 0x8225D33C;
		  /* 8225D33Ch */ case   83:  		/* lis R22, -32251 */
		/* 8225D33Ch case   83:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFF8205);
		/* 8225D33Ch case   83:*/		return 0x8225D340;
		  /* 8225D340h */ case   84:  		/* stw R11, <#[R1 + 256]> */
		/* 8225D340h case   84:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000100) );
		/* 8225D340h case   84:*/		return 0x8225D344;
		  /* 8225D344h */ case   85:  		/* lis R21, -32252 */
		/* 8225D344h case   85:*/		cpu::op::lis<0>(regs,&regs.R21,0xFFFF8204);
		/* 8225D344h case   85:*/		return 0x8225D348;
		  /* 8225D348h */ case   86:  		/* addi R10, R23, -19652 */
		/* 8225D348h case   86:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R23,0xFFFFB33C);
		/* 8225D348h case   86:*/		return 0x8225D34C;
		  /* 8225D34Ch */ case   87:  		/* addi R9, R22, -19668 */
		/* 8225D34Ch case   87:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R22,0xFFFFB32C);
		/* 8225D34Ch case   87:*/		return 0x8225D350;
		  /* 8225D350h */ case   88:  		/* addi R11, R21, 9444 */
		/* 8225D350h case   88:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R21,0x24E4);
		/* 8225D350h case   88:*/		return 0x8225D354;
		  /* 8225D354h */ case   89:  		/* stw R10, <#[R1 + 392]> */
		/* 8225D354h case   89:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000188) );
		/* 8225D354h case   89:*/		return 0x8225D358;
		  /* 8225D358h */ case   90:  		/* lis R20, -32252 */
		/* 8225D358h case   90:*/		cpu::op::lis<0>(regs,&regs.R20,0xFFFF8204);
		/* 8225D358h case   90:*/		return 0x8225D35C;
		  /* 8225D35Ch */ case   91:  		/* stw R9, <#[R1 + 368]> */
		/* 8225D35Ch case   91:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000170) );
		/* 8225D35Ch case   91:*/		return 0x8225D360;
		  /* 8225D360h */ case   92:  		/* lis R19, -32252 */
		/* 8225D360h case   92:*/		cpu::op::lis<0>(regs,&regs.R19,0xFFFF8204);
		/* 8225D360h case   92:*/		return 0x8225D364;
		  /* 8225D364h */ case   93:  		/* stw R11, <#[R1 + 268]> */
		/* 8225D364h case   93:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000010C) );
		/* 8225D364h case   93:*/		return 0x8225D368;
		  /* 8225D368h */ case   94:  		/* lis R5, -32256 */
		/* 8225D368h case   94:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8200);
		/* 8225D368h case   94:*/		return 0x8225D36C;
		  /* 8225D36Ch */ case   95:  		/* addi R10, R20, 9204 */
		/* 8225D36Ch case   95:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R20,0x23F4);
		/* 8225D36Ch case   95:*/		return 0x8225D370;
		  /* 8225D370h */ case   96:  		/* addi R9, R19, 9188 */
		/* 8225D370h case   96:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R19,0x23E4);
		/* 8225D370h case   96:*/		return 0x8225D374;
		  /* 8225D374h */ case   97:  		/* lis R11, -32252 */
		/* 8225D374h case   97:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225D374h case   97:*/		return 0x8225D378;
		  /* 8225D378h */ case   98:  		/* stw R10, <#[R1 + 304]> */
		/* 8225D378h case   98:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000130) );
		/* 8225D378h case   98:*/		return 0x8225D37C;
		  /* 8225D37Ch */ case   99:  		/* stw R9, <#[R1 + 352]> */
		/* 8225D37Ch case   99:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000160) );
		/* 8225D37Ch case   99:*/		return 0x8225D380;
		  /* 8225D380h */ case  100:  		/* lis R8, -32256 */
		/* 8225D380h case  100:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8225D380h case  100:*/		return 0x8225D384;
		  /* 8225D384h */ case  101:  		/* lfs FR26, <#[R5 + 8732]> */
		/* 8225D384h case  101:*/		cpu::mem::load32f( regs, &regs.FR26, (uint32)(regs.R5 + 0x0000221C) );
		/* 8225D384h case  101:*/		return 0x8225D388;
		  /* 8225D388h */ case  102:  		/* lis R10, -32256 */
		/* 8225D388h case  102:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8225D388h case  102:*/		return 0x8225D38C;
		  /* 8225D38Ch */ case  103:  		/* lis R9, -32251 */
		/* 8225D38Ch case  103:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8225D38Ch case  103:*/		return 0x8225D390;
		  /* 8225D390h */ case  104:  		/* lis R7, -32251 */
		/* 8225D390h case  104:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8205);
		/* 8225D390h case  104:*/		return 0x8225D394;
		  /* 8225D394h */ case  105:  		/* lis R6, -32256 */
		/* 8225D394h case  105:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 8225D394h case  105:*/		return 0x8225D398;
		  /* 8225D398h */ case  106:  		/* addi R3, R11, 9328 */
		/* 8225D398h case  106:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2470);
		/* 8225D398h case  106:*/		return 0x8225D39C;
		  /* 8225D39Ch */ case  107:  		/* lis R11, -32251 */
		/* 8225D39Ch case  107:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D39Ch case  107:*/		return 0x8225D3A0;
		  /* 8225D3A0h */ case  108:  		/* lfs FR30, <#[R6 + 1816]> */
		/* 8225D3A0h case  108:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R6 + 0x00000718) );
		/* 8225D3A0h case  108:*/		return 0x8225D3A4;
		  /* 8225D3A4h */ case  109:  		/* lfs FR31, <#[R10 + 1792]> */
		/* 8225D3A4h case  109:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000700) );
		/* 8225D3A4h case  109:*/		return 0x8225D3A8;
		  /* 8225D3A8h */ case  110:  		/* lis R4, -32255 */
		/* 8225D3A8h case  110:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8201);
		/* 8225D3A8h case  110:*/		return 0x8225D3AC;
		  /* 8225D3ACh */ case  111:  		/* addi R6, R11, -19716 */
		/* 8225D3ACh case  111:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB2FC);
		/* 8225D3ACh case  111:*/		return 0x8225D3B0;
		  /* 8225D3B0h */ case  112:  		/* stw R3, <#[R1 + 184]> */
		/* 8225D3B0h case  112:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225D3B0h case  112:*/		return 0x8225D3B4;
		  /* 8225D3B4h */ case  113:  		/* lis R11, -32251 */
		/* 8225D3B4h case  113:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D3B4h case  113:*/		return 0x8225D3B8;
		  /* 8225D3B8h */ case  114:  		/* lfs FR28, <#[R9 - 19672]> */
		/* 8225D3B8h case  114:*/		cpu::mem::load32f( regs, &regs.FR28, (uint32)(regs.R9 + 0xFFFFB328) );
		/* 8225D3B8h case  114:*/		return 0x8225D3BC;
		  /* 8225D3BCh */ case  115:  		/* lis R10, -32251 */
		/* 8225D3BCh case  115:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8225D3BCh case  115:*/		return 0x8225D3C0;
		  /* 8225D3C0h */ case  116:  		/* lfs FR27, <#[R8 + 1820]> */
		/* 8225D3C0h case  116:*/		cpu::mem::load32f( regs, &regs.FR27, (uint32)(regs.R8 + 0x0000071C) );
		/* 8225D3C0h case  116:*/		return 0x8225D3C4;
		  /* 8225D3C4h */ case  117:  		/* addi R5, R11, -19740 */
		/* 8225D3C4h case  117:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB2E4);
		/* 8225D3C4h case  117:*/		return 0x8225D3C8;
		  /* 8225D3C8h */ case  118:  		/* lfs FR29, <#[R7 - 19676]> */
		/* 8225D3C8h case  118:*/		cpu::mem::load32f( regs, &regs.FR29, (uint32)(regs.R7 + 0xFFFFB324) );
		/* 8225D3C8h case  118:*/		return 0x8225D3CC;
		  /* 8225D3CCh */ case  119:  		/* lis R11, -32251 */
		/* 8225D3CCh case  119:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D3CCh case  119:*/		return 0x8225D3D0;
		  /* 8225D3D0h */ case  120:  		/* stw R6, <#[R1 + 420]> */
		/* 8225D3D0h case  120:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001A4) );
		/* 8225D3D0h case  120:*/		return 0x8225D3D4;
		  /* 8225D3D4h */ case  121:  		/* addi R10, R10, -19796 */
		/* 8225D3D4h case  121:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFB2AC);
		/* 8225D3D4h case  121:*/		return 0x8225D3D8;
		  /* 8225D3D8h */ case  122:  		/* stw R5, <#[R1 + 292]> */
		/* 8225D3D8h case  122:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000124) );
		/* 8225D3D8h case  122:*/		return 0x8225D3DC;
		  /* 8225D3DCh */ case  123:  		/* addi R28, R11, -19812 */
		/* 8225D3DCh case  123:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFB29C);
		/* 8225D3DCh case  123:*/		return 0x8225D3E0;
		  /* 8225D3E0h */ case  124:  		/* lwz R16, <#[R1 + 224]> */
		/* 8225D3E0h case  124:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x000000E0) );
		/* 8225D3E0h case  124:*/		return 0x8225D3E4;
		  /* 8225D3E4h */ case  125:  		/* lis R11, -32251 */
		/* 8225D3E4h case  125:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D3E4h case  125:*/		return 0x8225D3E8;
		  /* 8225D3E8h */ case  126:  		/* stw R10, <#[R1 + 476]> */
		/* 8225D3E8h case  126:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000001DC) );
		/* 8225D3E8h case  126:*/		return 0x8225D3EC;
		  /* 8225D3ECh */ case  127:  		/* addi R4, R4, 5216 */
		/* 8225D3ECh case  127:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1460);
		/* 8225D3ECh case  127:*/		return 0x8225D3F0;
		  /* 8225D3F0h */ case  128:  		/* lwz R29, <#[R1 + 260]> */
		/* 8225D3F0h case  128:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000104) );
		/* 8225D3F0h case  128:*/		return 0x8225D3F4;
		  /* 8225D3F4h */ case  129:  		/* addi R27, R11, -19828 */
		/* 8225D3F4h case  129:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFB28C);
		/* 8225D3F4h case  129:*/		return 0x8225D3F8;
		  /* 8225D3F8h */ case  130:  		/* lwz R19, <#[R1 + 940]> */
		/* 8225D3F8h case  130:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x000003AC) );
		/* 8225D3F8h case  130:*/		return 0x8225D3FC;
		  /* 8225D3FCh */ case  131:  		/* lis R11, -32251 */
		/* 8225D3FCh case  131:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D3FCh case  131:*/		return 0x8225D400;
		  /* 8225D400h */ case  132:  		/* stw R4, <#[R1 + 196]> */
		/* 8225D400h case  132:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000000C4) );
		/* 8225D400h case  132:*/		return 0x8225D404;
		  /* 8225D404h */ case  133:  		/* lis R9, -32251 */
		/* 8225D404h case  133:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8225D404h case  133:*/		return 0x8225D408;
		  /* 8225D408h */ case  134:  		/* lwz R20, <#[R1 + 228]> */
		/* 8225D408h case  134:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x000000E4) );
		/* 8225D408h case  134:*/		return 0x8225D40C;
		  /* 8225D40Ch */ case  135:  		/* addi R26, R11, -19852 */
		/* 8225D40Ch case  135:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0xFFFFB274);
		/* 8225D40Ch case  135:*/		return 0x8225D410;
		  /* 8225D410h */ case  136:  		/* lwz R25, <#[R1 + 308]> */
		/* 8225D410h case  136:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000134) );
		/* 8225D410h case  136:*/		return 0x8225D414;
		  /* 8225D414h */ case  137:  		/* lis R11, -32252 */
		/* 8225D414h case  137:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8225D414h case  137:*/		return 0x8225D418;
		  /* 8225D418h */ case  138:  		/* lwz R23, <#[R1 + 284]> */
		/* 8225D418h case  138:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000011C) );
		/* 8225D418h case  138:*/		return 0x8225D41C;
		  /* 8225D41Ch */ case  139:  		/* addi R10, R9, -19884 */
		/* 8225D41Ch case  139:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFB254);
		/* 8225D41Ch case  139:*/		return 0x8225D420;
		  /* 8225D420h */ case  140:  		/* lwz R21, <#[R1 + 164]> */
		/* 8225D420h case  140:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000A4) );
		/* 8225D420h case  140:*/		return 0x8225D424;
		  /* 8225D424h */ case  141:  		/* addi R30, R11, 28696 */
		/* 8225D424h case  141:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x7018);
		/* 8225D424h case  141:*/		return 0x8225D428;
		  /* 8225D428h */ case  142:  		/* lwz R22, <#[R1 + 276]> */
		/* 8225D428h case  142:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000114) );
		/* 8225D428h case  142:*/		return 0x8225D42C;
		  /* 8225D42Ch */ case  143:  		/* lis R11, -32216 */
		/* 8225D42Ch case  143:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8225D42Ch case  143:*/		return 0x8225D430;
		  /* 8225D430h */ case  144:  		/* stw R10, <#[R1 + 468]> */
		/* 8225D430h case  144:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000001D4) );
		/* 8225D430h case  144:*/		return 0x8225D434;
		  /* 8225D434h */ case  145:  		/* lis R8, -32251 */
		/* 8225D434h case  145:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8205);
		/* 8225D434h case  145:*/		return 0x8225D438;
		  /* 8225D438h */ case  146:  		/* stw R28, <#[R1 + 244]> */
		/* 8225D438h case  146:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x000000F4) );
		/* 8225D438h case  146:*/		return 0x8225D43C;
		  /* 8225D43Ch */ case  147:  		/* addi R24, R11, 17992 */
		/* 8225D43Ch case  147:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x4648);
		/* 8225D43Ch case  147:*/		return 0x8225D440;
		  /* 8225D440h */ case  148:  		/* stw R27, <#[R1 + 524]> */
		/* 8225D440h case  148:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000020C) );
		/* 8225D440h case  148:*/		return 0x8225D444;
		  /* 8225D444h */ case  149:  		/* lis R11, -32251 */
		/* 8225D444h case  149:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D444h case  149:*/		return 0x8225D448;
		  /* 8225D448h */ case  150:  		/* stw R26, <#[R1 + 516]> */
		/* 8225D448h case  150:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000204) );
		/* 8225D448h case  150:*/		return 0x8225D44C;
		  /* 8225D44Ch */ case  151:  		/* addi R10, R8, -19912 */
		/* 8225D44Ch case  151:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFB238);
		/* 8225D44Ch case  151:*/		return 0x8225D450;
		  /* 8225D450h */ case  152:  		/* stw R30, <#[R1 + 532]> */
		/* 8225D450h case  152:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000214) );
		/* 8225D450h case  152:*/		return 0x8225D454;
		  /* 8225D454h */ case  153:  		/* addi R3, R11, -19920 */
		/* 8225D454h case  153:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFB230);
		/* 8225D454h case  153:*/		return 0x8225D458;
		  /* 8225D458h */ case  154:  		/* stw R24, <#[R1 + 540]> */
		/* 8225D458h case  154:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x0000021C) );
		/* 8225D458h case  154:*/		return 0x8225D45C;
		  /* 8225D45Ch */ case  155:  		/* lis R11, -32251 */
		/* 8225D45Ch case  155:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D45Ch case  155:*/		return 0x8225D460;
		  /* 8225D460h */ case  156:  		/* stw R10, <#[R1 + 460]> */
		/* 8225D460h case  156:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000001CC) );
		/* 8225D460h case  156:*/		return 0x8225D464;
		  /* 8225D464h */ case  157:  		/* lis R7, -32251 */
		/* 8225D464h case  157:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8205);
		/* 8225D464h case  157:*/		return 0x8225D468;
		  /* 8225D468h */ case  158:  		/* stw R3, <#[R1 + 508]> */
		/* 8225D468h case  158:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000001FC) );
		/* 8225D468h case  158:*/		return 0x8225D46C;
		  /* 8225D46Ch */ case  159:  		/* addi R4, R11, -19940 */
		/* 8225D46Ch case  159:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFB21C);
		/* 8225D46Ch case  159:*/		return 0x8225D470;
		  /* 8225D470h */ case  160:  		/* lis R11, -32251 */
		/* 8225D470h case  160:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D470h case  160:*/		return 0x8225D474;
		  /* 8225D474h */ case  161:  		/* addi R10, R7, -19968 */
		/* 8225D474h case  161:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFB200);
		/* 8225D474h case  161:*/		return 0x8225D478;
		  /* 8225D478h */ case  162:  		/* stw R4, <#[R1 + 252]> */
		/* 8225D478h case  162:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000000FC) );
		/* 8225D478h case  162:*/		return 0x8225D47C;
		  /* 8225D47Ch */ case  163:  		/* addi R9, R11, -20028 */
		/* 8225D47Ch case  163:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFB1C4);
		/* 8225D47Ch case  163:*/		return 0x8225D480;
		  /* 8225D480h */ case  164:  		/* lis R11, -32251 */
		/* 8225D480h case  164:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D480h case  164:*/		return 0x8225D484;
		  /* 8225D484h */ case  165:  		/* stw R10, <#[R1 + 452]> */
		/* 8225D484h case  165:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000001C4) );
		/* 8225D484h case  165:*/		return 0x8225D488;
	}
	return 0x8225D488;
} // Block from 8225D1F0h-8225D488h (166 instructions)

//////////////////////////////////////////////////////
// Block at 8225D488h
// Function '?PushAndGo@CFG@XGRAPHICS@@AAAPBTexpansion_token@2@PBT32@AAHPAVBlock@2@0PAV?$stack@PAUEXP_DIR@XGRAPHICS@@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D488);
		  /* 8225D488h */ case    0:  		/* stw R9, <#[R1 + 500]> */
		/* 8225D488h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000001F4) );
		/* 8225D488h case    0:*/		return 0x8225D48C;
		  /* 8225D48Ch */ case    1:  		/* lis R6, -32251 */
		/* 8225D48Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8205);
		/* 8225D48Ch case    1:*/		return 0x8225D490;
		  /* 8225D490h */ case    2:  		/* addi R9, R11, -20060 */
		/* 8225D490h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFB1A4);
		/* 8225D490h case    2:*/		return 0x8225D494;
		  /* 8225D494h */ case    3:  		/* lis R5, -32251 */
		/* 8225D494h case    3:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8205);
		/* 8225D494h case    3:*/		return 0x8225D498;
		  /* 8225D498h */ case    4:  		/* lis R11, -32251 */
		/* 8225D498h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8225D498h case    4:*/		return 0x8225D49C;
		  /* 8225D49Ch */ case    5:  		/* stw R9, <#[R1 + 492]> */
		/* 8225D49Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000001EC) );
		/* 8225D49Ch case    5:*/		return 0x8225D4A0;
		  /* 8225D4A0h */ case    6:  		/* addi R9, R6, -20080 */
		/* 8225D4A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0xFFFFB190);
		/* 8225D4A0h case    6:*/		return 0x8225D4A4;
		  /* 8225D4A4h */ case    7:  		/* addi R11, R11, -20204 */
		/* 8225D4A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB114);
		/* 8225D4A4h case    7:*/		return 0x8225D4A8;
		  /* 8225D4A8h */ case    8:  		/* addi R10, R5, -20160 */
		/* 8225D4A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFFFB140);
		/* 8225D4A8h case    8:*/		return 0x8225D4AC;
		  /* 8225D4ACh */ case    9:  		/* stw R9, <#[R1 + 444]> */
		/* 8225D4ACh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000001BC) );
		/* 8225D4ACh case    9:*/		return 0x8225D4B0;
		  /* 8225D4B0h */ case   10:  		/* rlwinm R14, R14, 0, 0, 31 */
		/* 8225D4B0h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R14,regs.R14);
		/* 8225D4B0h case   10:*/		return 0x8225D4B4;
		  /* 8225D4B4h */ case   11:  		/* stw R11, <#[R1 + 484]> */
		/* 8225D4B4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000001E4) );
		/* 8225D4B4h case   11:*/		return 0x8225D4B8;
		  /* 8225D4B8h */ case   12:  		/* stw R10, <#[R1 + 436]> */
		/* 8225D4B8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000001B4) );
		/* 8225D4B8h case   12:*/		return 0x8225D4BC;
		  /* 8225D4BCh */ case   13:  		/* b 48 */
		/* 8225D4BCh case   13:*/		return 0x8225D4EC;
		/* 8225D4BCh case   13:*/		return 0x8225D4C0;
		  /* 8225D4C0h */ case   14:  		/* lwz R17, <#[R1 + 384]> */
		/* 8225D4C0h case   14:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000180) );
		/* 8225D4C0h case   14:*/		return 0x8225D4C4;
		  /* 8225D4C4h */ case   15:  		/* lwz R21, <#[R1 + 164]> */
		/* 8225D4C4h case   15:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000A4) );
		/* 8225D4C4h case   15:*/		return 0x8225D4C8;
		  /* 8225D4C8h */ case   16:  		/* lwz R18, <#[R1 + 548]> */
		/* 8225D4C8h case   16:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000224) );
		/* 8225D4C8h case   16:*/		return 0x8225D4CC;
		  /* 8225D4CCh */ case   17:  		/* lwz R24, <#[R1 + 540]> */
		/* 8225D4CCh case   17:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x0000021C) );
		/* 8225D4CCh case   17:*/		return 0x8225D4D0;
		  /* 8225D4D0h */ case   18:  		/* lwz R30, <#[R1 + 532]> */
		/* 8225D4D0h case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000214) );
		/* 8225D4D0h case   18:*/		return 0x8225D4D4;
		  /* 8225D4D4h */ case   19:  		/* lwz R16, <#[R1 + 224]> */
		/* 8225D4D4h case   19:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x000000E0) );
		/* 8225D4D4h case   19:*/		return 0x8225D4D8;
		  /* 8225D4D8h */ case   20:  		/* lwz R29, <#[R1 + 260]> */
		/* 8225D4D8h case   20:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000104) );
		/* 8225D4D8h case   20:*/		return 0x8225D4DC;
		  /* 8225D4DCh */ case   21:  		/* lwz R22, <#[R1 + 276]> */
		/* 8225D4DCh case   21:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000114) );
		/* 8225D4DCh case   21:*/		return 0x8225D4E0;
		  /* 8225D4E0h */ case   22:  		/* lwz R20, <#[R1 + 228]> */
		/* 8225D4E0h case   22:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x000000E4) );
		/* 8225D4E0h case   22:*/		return 0x8225D4E4;
		  /* 8225D4E4h */ case   23:  		/* lwz R25, <#[R1 + 308]> */
		/* 8225D4E4h case   23:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000134) );
		/* 8225D4E4h case   23:*/		return 0x8225D4E8;
		  /* 8225D4E8h */ case   24:  		/* lwz R23, <#[R1 + 284]> */
		/* 8225D4E8h case   24:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000011C) );
		/* 8225D4E8h case   24:*/		return 0x8225D4EC;
	}
	return 0x8225D4EC;
} // Block from 8225D488h-8225D4ECh (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225D4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D4EC);
		  /* 8225D4ECh */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D4ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D4ECh case    0:*/		return 0x8225D4F0;
		  /* 8225D4F0h */ case    1:  		/* li R9, 0 */
		/* 8225D4F0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225D4F0h case    1:*/		return 0x8225D4F4;
		  /* 8225D4F4h */ case    2:  		/* li R10, 100 */
		/* 8225D4F4h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x64);
		/* 8225D4F4h case    2:*/		return 0x8225D4F8;
		  /* 8225D4F8h */ case    3:  		/* lwz R28, <#[R1 + 196]> */
		/* 8225D4F8h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000C4) );
		/* 8225D4F8h case    3:*/		return 0x8225D4FC;
		  /* 8225D4FCh */ case    4:  		/* mr R15, R11 */
		/* 8225D4FCh case    4:*/		regs.R15 = regs.R11;
		/* 8225D4FCh case    4:*/		return 0x8225D500;
	}
	return 0x8225D500;
} // Block from 8225D4ECh-8225D500h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225D500h
// Function '?SetDstModifiers@CFG@XGRAPHICS@@AAAXPAV?$stack@PAVLoopHeader@XGRAPHICS@@@2@TSwizzleOrMaskInfo@2@PATIL_Dst@2@HPAVIRInst@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D500);
		  /* 8225D500h */ case    0:  		/* stb R9, <#[R1 + 200]> */
		/* 8225D500h case    0:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R1 + 0x000000C8) );
		/* 8225D500h case    0:*/		return 0x8225D504;
		  /* 8225D504h */ case    1:  		/* li R27, 4 */
		/* 8225D504h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 8225D504h case    1:*/		return 0x8225D508;
		  /* 8225D508h */ case    2:  		/* stw R11, <#[R1 + 176]> */
		/* 8225D508h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 8225D508h case    2:*/		return 0x8225D50C;
		  /* 8225D50Ch */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8225D50Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D50Ch case    3:*/		return 0x8225D510;
		  /* 8225D510h */ case    4:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8225D510h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8225D510h case    4:*/		return 0x8225D514;
		  /* 8225D514h */ case    5:  		/* subfc R9, R10, R11 */
		/* 8225D514h case    5:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8225D514h case    5:*/		return 0x8225D518;
		  /* 8225D518h */ case    6:  		/* eqv R10, R10, R11 */
		/* 8225D518h case    6:*/		cpu::op::eqv<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8225D518h case    6:*/		return 0x8225D51C;
		  /* 8225D51Ch */ case    7:  		/* rlwinm R10, R10, 1, 31, 31 */
		/* 8225D51Ch case    7:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R10);
		/* 8225D51Ch case    7:*/		return 0x8225D520;
		  /* 8225D520h */ case    8:  		/* addze R10, R10 */
		/* 8225D520h case    8:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 8225D520h case    8:*/		return 0x8225D524;
		  /* 8225D524h */ case    9:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 8225D524h case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8225D524h case    9:*/		return 0x8225D528;
		  /* 8225D528h */ case   10:  		/* subfic R10, R10, 0 */
		/* 8225D528h case   10:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 8225D528h case   10:*/		return 0x8225D52C;
		  /* 8225D52Ch */ case   11:  		/* subfe R10, R10, R10 */
		/* 8225D52Ch case   11:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8225D52Ch case   11:*/		return 0x8225D530;
		  /* 8225D530h */ case   12:  		/* and R26, R10, R11 */
		/* 8225D530h case   12:*/		cpu::op::and<0>(regs,&regs.R26,regs.R10,regs.R11);
		/* 8225D530h case   12:*/		return 0x8225D534;
		  /* 8225D534h */ case   13:  		/* mr R3, R26 */
		/* 8225D534h case   13:*/		regs.R3 = regs.R26;
		/* 8225D534h case   13:*/		return 0x8225D538;
		  /* 8225D538h */ case   14:  		/* stw R26, <#[R1 + 204]> */
		/* 8225D538h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225D538h case   14:*/		return 0x8225D53C;
		  /* 8225D53Ch */ case   15:  		/* bl -12356 */
		/* 8225D53Ch case   15:*/		regs.LR = 0x8225D540; return 0x8225A4F8;
		/* 8225D53Ch case   15:*/		return 0x8225D540;
		  /* 8225D540h */ case   16:  		/* cmplwi CR6, R3, 1 */
		/* 8225D540h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8225D540h case   16:*/		return 0x8225D544;
		  /* 8225D544h */ case   17:  		/* bc 12, CR6_LT, 19784 */
		/* 8225D544h case   17:*/		if ( regs.CR[6].lt ) { return 0x8226228C;  }
		/* 8225D544h case   17:*/		return 0x8225D548;
		  /* 8225D548h */ case   18:  		/* bc 12, CR6_EQ, 19816 */
		/* 8225D548h case   18:*/		if ( regs.CR[6].eq ) { return 0x822622B0;  }
		/* 8225D548h case   18:*/		return 0x8225D54C;
		  /* 8225D54Ch */ case   19:  		/* cmplwi CR6, R3, 3 */
		/* 8225D54Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000003);
		/* 8225D54Ch case   19:*/		return 0x8225D550;
		  /* 8225D550h */ case   20:  		/* bc 12, CR6_LT, 19764 */
		/* 8225D550h case   20:*/		if ( regs.CR[6].lt ) { return 0x82262284;  }
		/* 8225D550h case   20:*/		return 0x8225D554;
		  /* 8225D554h */ case   21:  		/* bc 12, CR6_EQ, 19752 */
		/* 8225D554h case   21:*/		if ( regs.CR[6].eq ) { return 0x8226227C;  }
		/* 8225D554h case   21:*/		return 0x8225D558;
		  /* 8225D558h */ case   22:  		/* cmplwi CR6, R3, 5 */
		/* 8225D558h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000005);
		/* 8225D558h case   22:*/		return 0x8225D55C;
		  /* 8225D55Ch */ case   23:  		/* bc 12, CR6_LT, 18844 */
		/* 8225D55Ch case   23:*/		if ( regs.CR[6].lt ) { return 0x82261EF8;  }
		/* 8225D55Ch case   23:*/		return 0x8225D560;
		  /* 8225D560h */ case   24:  		/* bc 12, CR6_EQ, 36 */
		/* 8225D560h case   24:*/		if ( regs.CR[6].eq ) { return 0x8225D584;  }
		/* 8225D560h case   24:*/		return 0x8225D564;
		  /* 8225D564h */ case   25:  		/* cmplwi CR6, R3, 7 */
		/* 8225D564h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000007);
		/* 8225D564h case   25:*/		return 0x8225D568;
		  /* 8225D568h */ case   26:  		/* bc 12, CR6_LT, 12 */
		/* 8225D568h case   26:*/		if ( regs.CR[6].lt ) { return 0x8225D574;  }
		/* 8225D568h case   26:*/		return 0x8225D56C;
		  /* 8225D56Ch */ case   27:  		/* li R7, 4278 */
		/* 8225D56Ch case   27:*/		cpu::op::li<0>(regs,&regs.R7,0x10B6);
		/* 8225D56Ch case   27:*/		return 0x8225D570;
		  /* 8225D570h */ case   28:  		/* b 22680 */
		/* 8225D570h case   28:*/		return 0x82262E08;
		/* 8225D570h case   28:*/		return 0x8225D574;
	}
	return 0x8225D574;
} // Block from 8225D500h-8225D574h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8225D574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D574);
		  /* 8225D574h */ case    0:  		/* lhz R11, <#[R15]> */
		/* 8225D574h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225D574h case    0:*/		return 0x8225D578;
		  /* 8225D578h */ case    1:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 8225D578h case    1:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 8225D578h case    1:*/		return 0x8225D57C;
		  /* 8225D57Ch */ case    2:  		/* addi R26, R11, 116 */
		/* 8225D57Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x74);
		/* 8225D57Ch case    2:*/		return 0x8225D580;
		  /* 8225D580h */ case    3:  		/* stw R26, <#[R1 + 204]> */
		/* 8225D580h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225D580h case    3:*/		return 0x8225D584;
	}
	return 0x8225D584;
} // Block from 8225D574h-8225D584h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225D584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D584);
		  /* 8225D584h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D584h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D584h case    0:*/		return 0x8225D588;
		  /* 8225D588h */ case    1:  		/* li R10, 0 */
		/* 8225D588h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8225D588h case    1:*/		return 0x8225D58C;
		  /* 8225D58Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8225D58Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D58Ch case    2:*/		return 0x8225D590;
		  /* 8225D590h */ case    3:  		/* stw R10, <#[R1 + 336]> */
		/* 8225D590h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000150) );
		/* 8225D590h case    3:*/		return 0x8225D594;
		  /* 8225D594h */ case    4:  		/* stw R10, <#[R1 + 264]> */
		/* 8225D594h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000108) );
		/* 8225D594h case    4:*/		return 0x8225D598;
		  /* 8225D598h */ case    5:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D598h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D598h case    5:*/		return 0x8225D59C;
		  /* 8225D59Ch */ case    6:  		/* lwz R10, <#[R15]> */
		/* 8225D59Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 8225D59Ch case    6:*/		return 0x8225D5A0;
		  /* 8225D5A0h */ case    7:  		/* rlwinm. R10, R10, 1, 31, 31 */
		/* 8225D5A0h case    7:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R10,regs.R10);
		/* 8225D5A0h case    7:*/		return 0x8225D5A4;
		  /* 8225D5A4h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8225D5A4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225D5B4;  }
		/* 8225D5A4h case    8:*/		return 0x8225D5A8;
		  /* 8225D5A8h */ case    9:  		/* addi R10, R11, 4 */
		/* 8225D5A8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8225D5A8h case    9:*/		return 0x8225D5AC;
		  /* 8225D5ACh */ case   10:  		/* stw R11, <#[R1 + 336]> */
		/* 8225D5ACh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000150) );
		/* 8225D5ACh case   10:*/		return 0x8225D5B0;
		  /* 8225D5B0h */ case   11:  		/* stw R10, <#[R19 + 20]> */
		/* 8225D5B0h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D5B0h case   11:*/		return 0x8225D5B4;
	}
	return 0x8225D5B4;
} // Block from 8225D584h-8225D5B4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225D5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D5B4);
		  /* 8225D5B4h */ case    0:  		/* lwz R11, <#[R15]> */
		/* 8225D5B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225D5B4h case    0:*/		return 0x8225D5B8;
		  /* 8225D5B8h */ case    1:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 8225D5B8h case    1:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 8225D5B8h case    1:*/		return 0x8225D5BC;
		  /* 8225D5BCh */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 8225D5BCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8225D5D0;  }
		/* 8225D5BCh case    2:*/		return 0x8225D5C0;
		  /* 8225D5C0h */ case    3:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D5C0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D5C0h case    3:*/		return 0x8225D5C4;
		  /* 8225D5C4h */ case    4:  		/* addi R10, R11, 4 */
		/* 8225D5C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8225D5C4h case    4:*/		return 0x8225D5C8;
		  /* 8225D5C8h */ case    5:  		/* stw R10, <#[R19 + 20]> */
		/* 8225D5C8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D5C8h case    5:*/		return 0x8225D5CC;
		  /* 8225D5CCh */ case    6:  		/* stw R11, <#[R1 + 264]> */
		/* 8225D5CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000108) );
		/* 8225D5CCh case    6:*/		return 0x8225D5D0;
	}
	return 0x8225D5D0;
} // Block from 8225D5B4h-8225D5D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225D5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D5D0);
		  /* 8225D5D0h */ case    0:  		/* mr R3, R26 */
		/* 8225D5D0h case    0:*/		regs.R3 = regs.R26;
		/* 8225D5D0h case    0:*/		return 0x8225D5D4;
		  /* 8225D5D4h */ case    1:  		/* bl -12972 */
		/* 8225D5D4h case    1:*/		regs.LR = 0x8225D5D8; return 0x8225A328;
		/* 8225D5D4h case    1:*/		return 0x8225D5D8;
		  /* 8225D5D8h */ case    2:  		/* or. R18, R3, R3 */
		/* 8225D5D8h case    2:*/		cpu::op::or<1>(regs,&regs.R18,regs.R3,regs.R3);
		/* 8225D5D8h case    2:*/		return 0x8225D5DC;
		  /* 8225D5DCh */ case    3:  		/* li R28, 0 */
		/* 8225D5DCh case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8225D5DCh case    3:*/		return 0x8225D5E0;
		  /* 8225D5E0h */ case    4:  		/* stw R18, <#[R1 + 312]> */
		/* 8225D5E0h case    4:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000138) );
		/* 8225D5E0h case    4:*/		return 0x8225D5E4;
		  /* 8225D5E4h */ case    5:  		/* bc 4, CR0_GT, 364 */
		/* 8225D5E4h case    5:*/		if ( !regs.CR[0].gt ) { return 0x8225D750;  }
		/* 8225D5E4h case    5:*/		return 0x8225D5E8;
		  /* 8225D5E8h */ case    6:  		/* lwz R10, <#[R1 + 204]> */
		/* 8225D5E8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225D5E8h case    6:*/		return 0x8225D5EC;
		  /* 8225D5ECh */ case    7:  		/* addi R11, R17, 28 */
		/* 8225D5ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x1C);
		/* 8225D5ECh case    7:*/		return 0x8225D5F0;
		  /* 8225D5F0h */ case    8:  		/* li R29, 0 */
		/* 8225D5F0h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8225D5F0h case    8:*/		return 0x8225D5F4;
		  /* 8225D5F4h */ case    9:  		/* mulli R9, R10, 36 */
		/* 8225D5F4h case    9:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R10,0x24);
		/* 8225D5F4h case    9:*/		return 0x8225D5F8;
		  /* 8225D5F8h */ case   10:  		/* mr R10, R16 */
		/* 8225D5F8h case   10:*/		regs.R10 = regs.R16;
		/* 8225D5F8h case   10:*/		return 0x8225D5FC;
		  /* 8225D5FCh */ case   11:  		/* mr R8, R25 */
		/* 8225D5FCh case   11:*/		regs.R8 = regs.R25;
		/* 8225D5FCh case   11:*/		return 0x8225D600;
		  /* 8225D600h */ case   12:  		/* subf R26, R23, R20 */
		/* 8225D600h case   12:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R23,regs.R20);
		/* 8225D600h case   12:*/		return 0x8225D604;
		  /* 8225D604h */ case   13:  		/* subf R4, R16, R23 */
		/* 8225D604h case   13:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R16,regs.R23);
		/* 8225D604h case   13:*/		return 0x8225D608;
		  /* 8225D608h */ case   14:  		/* add R27, R9, R11 */
		/* 8225D608h case   14:*/		cpu::op::add<0>(regs,&regs.R27,regs.R9,regs.R11);
		/* 8225D608h case   14:*/		return 0x8225D60C;
		  /* 8225D60Ch */ case   15:  		/* lwz R9, <#[R19 + 20]> */
		/* 8225D60Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D60Ch case   15:*/		return 0x8225D610;
		  /* 8225D610h */ case   16:  		/* add R11, R10, R4 */
		/* 8225D610h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R4);
		/* 8225D610h case   16:*/		return 0x8225D614;
		  /* 8225D614h */ case   17:  		/* li R3, 0 */
		/* 8225D614h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225D614h case   17:*/		return 0x8225D618;
		  /* 8225D618h */ case   18:  		/* lwz R9, <#[R9]> */
		/* 8225D618h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8225D618h case   18:*/		return 0x8225D61C;
		  /* 8225D61Ch */ case   19:  		/* stw R9, <#[R8]> */
		/* 8225D61Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8225D61Ch case   19:*/		return 0x8225D620;
		  /* 8225D620h */ case   20:  		/* stw R8, <#[R10]> */
		/* 8225D620h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8225D620h case   20:*/		return 0x8225D624;
		  /* 8225D624h */ case   21:  		/* lwz R9, <#[R8]> */
		/* 8225D624h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8225D624h case   21:*/		return 0x8225D628;
		  /* 8225D628h */ case   22:  		/* extsh R9, R9 */
		/* 8225D628h case   22:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R9);
		/* 8225D628h case   22:*/		return 0x8225D62C;
		  /* 8225D62Ch */ case   23:  		/* stwx R9, <#[R11 + R26]> */
		/* 8225D62Ch case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8225D62Ch case   23:*/		return 0x8225D630;
		  /* 8225D630h */ case   24:  		/* lwz R11, <#[R10]> */
		/* 8225D630h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8225D630h case   24:*/		return 0x8225D634;
		  /* 8225D634h */ case   25:  		/* lhz R11, <#[R11]> */
		/* 8225D634h case   25:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D634h case   25:*/		return 0x8225D638;
		  /* 8225D638h */ case   26:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 8225D638h case   26:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8225D638h case   26:*/		return 0x8225D63C;
		  /* 8225D63Ch */ case   27:  		/* stwx R11, <#[R10 + R4]> */
		/* 8225D63Ch case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8225D63Ch case   27:*/		return 0x8225D640;
		  /* 8225D640h */ case   28:  		/* lwz R11, <#[R10]> */
		/* 8225D640h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8225D640h case   28:*/		return 0x8225D644;
		  /* 8225D644h */ case   29:  		/* lwz R11, <#[R11]> */
		/* 8225D644h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D644h case   29:*/		return 0x8225D648;
		  /* 8225D648h */ case   30:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8225D648h case   30:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8225D648h case   30:*/		return 0x8225D64C;
		  /* 8225D64Ch */ case   31:  		/* bc 12, CR0_EQ, 20 */
		/* 8225D64Ch case   31:*/		if ( regs.CR[0].eq ) { return 0x8225D660;  }
		/* 8225D64Ch case   31:*/		return 0x8225D650;
		  /* 8225D650h */ case   32:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D650h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D650h case   32:*/		return 0x8225D654;
		  /* 8225D654h */ case   33:  		/* li R3, 1 */
		/* 8225D654h case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8225D654h case   33:*/		return 0x8225D658;
		  /* 8225D658h */ case   34:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225D658h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225D658h case   34:*/		return 0x8225D65C;
		  /* 8225D65Ch */ case   35:  		/* stw R11, <#[R8 + 4]> */
		/* 8225D65Ch case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 8225D65Ch case   35:*/		return 0x8225D660;
	}
	return 0x8225D660;
} // Block from 8225D5D0h-8225D660h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8225D660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D660);
		  /* 8225D660h */ case    0:  		/* lbzx R11, <#[R28 + R27]> */
		/* 8225D660h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + regs.R27 + 0x00000000) );
		/* 8225D660h case    0:*/		return 0x8225D664;
		  /* 8225D664h */ case    1:  		/* li R7, 0 */
		/* 8225D664h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8225D664h case    1:*/		return 0x8225D668;
		  /* 8225D668h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 8225D668h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225D668h case    2:*/		return 0x8225D66C;
		  /* 8225D66Ch */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 8225D66Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8225D6EC;  }
		/* 8225D66Ch case    3:*/		return 0x8225D670;
		  /* 8225D670h */ case    4:  		/* rlwinm R30, R3, 0, 24, 31 */
		/* 8225D670h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R30,regs.R3);
		/* 8225D670h case    4:*/		return 0x8225D674;
		  /* 8225D674h */ case    5:  		/* addi R11, R10, 24 */
		/* 8225D674h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x18);
		/* 8225D674h case    5:*/		return 0x8225D678;
		  /* 8225D678h */ case    6:  		/* addi R9, R8, 72 */
		/* 8225D678h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x48);
		/* 8225D678h case    6:*/		return 0x8225D67C;
		  /* 8225D67Ch */ case    7:  		/* subf R5, R16, R20 */
		/* 8225D67Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R16,regs.R20);
		/* 8225D67Ch case    7:*/		return 0x8225D680;
		  /* 8225D680h */ case    8:  		/* lwz R6, <#[R19 + 20]> */
		/* 8225D680h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D680h case    8:*/		return 0x8225D684;
		  /* 8225D684h */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 8225D684h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8225D684h case    9:*/		return 0x8225D688;
		  /* 8225D688h */ case   10:  		/* lwz R6, <#[R6]> */
		/* 8225D688h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000000) );
		/* 8225D688h case   10:*/		return 0x8225D68C;
		  /* 8225D68Ch */ case   11:  		/* stw R6, <#[R9]> */
		/* 8225D68Ch case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 8225D68Ch case   11:*/		return 0x8225D690;
		  /* 8225D690h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 8225D690h case   12:*/		if ( regs.CR[6].eq ) { return 0x8225D6A0;  }
		/* 8225D690h case   12:*/		return 0x8225D694;
		  /* 8225D694h */ case   13:  		/* lwz R6, <#[R19 + 20]> */
		/* 8225D694h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D694h case   13:*/		return 0x8225D698;
		  /* 8225D698h */ case   14:  		/* lwz R6, <#[R6 + 4]> */
		/* 8225D698h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 8225D698h case   14:*/		return 0x8225D69C;
		  /* 8225D69Ch */ case   15:  		/* stw R6, <#[R9 + 4]> */
		/* 8225D69Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000004) );
		/* 8225D69Ch case   15:*/		return 0x8225D6A0;
	}
	return 0x8225D6A0;
} // Block from 8225D660h-8225D6A0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225D6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D6A0);
		  /* 8225D6A0h */ case    0:  		/* stw R9, <#[R11]> */
		/* 8225D6A0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D6A0h case    0:*/		return 0x8225D6A4;
		  /* 8225D6A4h */ case    1:  		/* lwz R6, <#[R10]> */
		/* 8225D6A4h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8225D6A4h case    1:*/		return 0x8225D6A8;
		  /* 8225D6A8h */ case    2:  		/* lwz R6, <#[R6]> */
		/* 8225D6A8h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000000) );
		/* 8225D6A8h case    2:*/		return 0x8225D6AC;
		  /* 8225D6ACh */ case    3:  		/* extsh R6, R6 */
		/* 8225D6ACh case    3:*/		cpu::op::extsh<0>(regs,&regs.R6,regs.R6);
		/* 8225D6ACh case    3:*/		return 0x8225D6B0;
		  /* 8225D6B0h */ case    4:  		/* add R6, R6, R7 */
		/* 8225D6B0h case    4:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R7);
		/* 8225D6B0h case    4:*/		return 0x8225D6B4;
		  /* 8225D6B4h */ case    5:  		/* addi R7, R7, 1 */
		/* 8225D6B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8225D6B4h case    5:*/		return 0x8225D6B8;
		  /* 8225D6B8h */ case    6:  		/* addi R6, R6, 1 */
		/* 8225D6B8h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8225D6B8h case    6:*/		return 0x8225D6BC;
		  /* 8225D6BCh */ case    7:  		/* rlwinm R24, R6, 0, 16, 31 */
		/* 8225D6BCh case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R24,regs.R6);
		/* 8225D6BCh case    7:*/		return 0x8225D6C0;
		  /* 8225D6C0h */ case    8:  		/* sth R24, <#[R9 + 2]> */
		/* 8225D6C0h case    8:*/		cpu::mem::store16( regs, regs.R24, (uint32)(regs.R9 + 0x00000002) );
		/* 8225D6C0h case    8:*/		return 0x8225D6C4;
		  /* 8225D6C4h */ case    9:  		/* addi R9, R9, 72 */
		/* 8225D6C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x48);
		/* 8225D6C4h case    9:*/		return 0x8225D6C8;
		  /* 8225D6C8h */ case   10:  		/* stwx R6, <#[R5 + R11]> */
		/* 8225D6C8h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8225D6C8h case   10:*/		return 0x8225D6CC;
		  /* 8225D6CCh */ case   11:  		/* lwz R6, <#[R11]> */
		/* 8225D6CCh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D6CCh case   11:*/		return 0x8225D6D0;
		  /* 8225D6D0h */ case   12:  		/* lhz R6, <#[R6]> */
		/* 8225D6D0h case   12:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000000) );
		/* 8225D6D0h case   12:*/		return 0x8225D6D4;
		  /* 8225D6D4h */ case   13:  		/* rlwinm R6, R6, 0, 26, 31 */
		/* 8225D6D4h case   13:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R6,regs.R6);
		/* 8225D6D4h case   13:*/		return 0x8225D6D8;
		  /* 8225D6D8h */ case   14:  		/* stwx R6, <#[R4 + R11]> */
		/* 8225D6D8h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 8225D6D8h case   14:*/		return 0x8225D6DC;
		  /* 8225D6DCh */ case   15:  		/* addi R11, R11, 24 */
		/* 8225D6DCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8225D6DCh case   15:*/		return 0x8225D6E0;
		  /* 8225D6E0h */ case   16:  		/* lbzx R6, <#[R28 + R27]> */
		/* 8225D6E0h case   16:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R28 + regs.R27 + 0x00000000) );
		/* 8225D6E0h case   16:*/		return 0x8225D6E4;
		  /* 8225D6E4h */ case   17:  		/* cmpw CR6, R7, R6 */
		/* 8225D6E4h case   17:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R6);
		/* 8225D6E4h case   17:*/		return 0x8225D6E8;
		  /* 8225D6E8h */ case   18:  		/* bc 12, CR6_LT, -104 */
		/* 8225D6E8h case   18:*/		if ( regs.CR[6].lt ) { return 0x8225D680;  }
		/* 8225D6E8h case   18:*/		return 0x8225D6EC;
	}
	return 0x8225D6EC;
} // Block from 8225D6A0h-8225D6ECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225D6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D6EC);
		  /* 8225D6ECh */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225D6ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225D6ECh case    0:*/		return 0x8225D6F0;
		  /* 8225D6F0h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8225D6F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225D700;  }
		/* 8225D6F0h case    1:*/		return 0x8225D6F4;
		  /* 8225D6F4h */ case    2:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D6F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D6F4h case    2:*/		return 0x8225D6F8;
		  /* 8225D6F8h */ case    3:  		/* addi R11, R11, 4 */
		/* 8225D6F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D6F8h case    3:*/		return 0x8225D6FC;
		  /* 8225D6FCh */ case    4:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D6FCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D6FCh case    4:*/		return 0x8225D700;
	}
	return 0x8225D700;
} // Block from 8225D6ECh-8225D700h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225D700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D700);
		  /* 8225D700h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 8225D700h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8225D700h case    0:*/		return 0x8225D704;
		  /* 8225D704h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 8225D704h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D704h case    1:*/		return 0x8225D708;
		  /* 8225D708h */ case    2:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8225D708h case    2:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8225D708h case    2:*/		return 0x8225D70C;
		  /* 8225D70Ch */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 8225D70Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8225D72C;  }
		/* 8225D70Ch case    3:*/		return 0x8225D710;
		  /* 8225D710h */ case    4:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D710h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D710h case    4:*/		return 0x8225D714;
		  /* 8225D714h */ case    5:  		/* addi R9, R29, 2 */
		/* 8225D714h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x2);
		/* 8225D714h case    5:*/		return 0x8225D718;
		  /* 8225D718h */ case    6:  		/* addi R11, R11, 4 */
		/* 8225D718h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D718h case    6:*/		return 0x8225D71C;
		  /* 8225D71Ch */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8225D71Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8225D71Ch case    7:*/		return 0x8225D720;
		  /* 8225D720h */ case    8:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D720h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D720h case    8:*/		return 0x8225D724;
		  /* 8225D724h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8225D724h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D724h case    9:*/		return 0x8225D728;
		  /* 8225D728h */ case   10:  		/* stwx R11, <#[R9 + R25]> */
		/* 8225D728h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R25 + 0x00000000) );
		/* 8225D728h case   10:*/		return 0x8225D72C;
	}
	return 0x8225D72C;
} // Block from 8225D700h-8225D72Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225D72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D72C);
		  /* 8225D72Ch */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D72Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D72Ch case    0:*/		return 0x8225D730;
		  /* 8225D730h */ case    1:  		/* addi R28, R28, 1 */
		/* 8225D730h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8225D730h case    1:*/		return 0x8225D734;
		  /* 8225D734h */ case    2:  		/* addi R29, R29, 3 */
		/* 8225D734h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x3);
		/* 8225D734h case    2:*/		return 0x8225D738;
		  /* 8225D738h */ case    3:  		/* addi R11, R11, 4 */
		/* 8225D738h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D738h case    3:*/		return 0x8225D73C;
		  /* 8225D73Ch */ case    4:  		/* addi R8, R8, 12 */
		/* 8225D73Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xC);
		/* 8225D73Ch case    4:*/		return 0x8225D740;
		  /* 8225D740h */ case    5:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D740h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D740h case    5:*/		return 0x8225D744;
		  /* 8225D744h */ case    6:  		/* addi R10, R10, 4 */
		/* 8225D744h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8225D744h case    6:*/		return 0x8225D748;
		  /* 8225D748h */ case    7:  		/* cmpw CR6, R28, R18 */
		/* 8225D748h case    7:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R18);
		/* 8225D748h case    7:*/		return 0x8225D74C;
		  /* 8225D74Ch */ case    8:  		/* bc 12, CR6_LT, -320 */
		/* 8225D74Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x8225D60C;  }
		/* 8225D74Ch case    8:*/		return 0x8225D750;
	}
	return 0x8225D750;
} // Block from 8225D72Ch-8225D750h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8225D750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D750);
		  /* 8225D750h */ case    0:  		/* lwz R30, <#[R1 + 204]> */
		/* 8225D750h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225D750h case    0:*/		return 0x8225D754;
		  /* 8225D754h */ case    1:  		/* mr R3, R30 */
		/* 8225D754h case    1:*/		regs.R3 = regs.R30;
		/* 8225D754h case    1:*/		return 0x8225D758;
		  /* 8225D758h */ case    2:  		/* bl -13232 */
		/* 8225D758h case    2:*/		regs.LR = 0x8225D75C; return 0x8225A3A8;
		/* 8225D758h case    2:*/		return 0x8225D75C;
		  /* 8225D75Ch */ case    3:  		/* add R11, R3, R18 */
		/* 8225D75Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R18);
		/* 8225D75Ch case    3:*/		return 0x8225D760;
		  /* 8225D760h */ case    4:  		/* mr R21, R3 */
		/* 8225D760h case    4:*/		regs.R21 = regs.R3;
		/* 8225D760h case    4:*/		return 0x8225D764;
		  /* 8225D764h */ case    5:  		/* li R24, 0 */
		/* 8225D764h case    5:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8225D764h case    5:*/		return 0x8225D768;
		  /* 8225D768h */ case    6:  		/* subf. R22, R18, R11 */
		/* 8225D768h case    6:*/		cpu::op::subf<1>(regs,&regs.R22,regs.R18,regs.R11);
		/* 8225D768h case    6:*/		return 0x8225D76C;
		  /* 8225D76Ch */ case    7:  		/* bc 4, CR0_GT, 452 */
		/* 8225D76Ch case    7:*/		if ( !regs.CR[0].gt ) { return 0x8225D930;  }
		/* 8225D76Ch case    7:*/		return 0x8225D770;
		  /* 8225D770h */ case    8:  		/* mulli R11, R30, 36 */
		/* 8225D770h case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0x24);
		/* 8225D770h case    8:*/		return 0x8225D774;
		  /* 8225D774h */ case    9:  		/* lwz R15, <#[R1 + 276]> */
		/* 8225D774h case    9:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000114) );
		/* 8225D774h case    9:*/		return 0x8225D778;
		  /* 8225D778h */ case   10:  		/* lwz R8, <#[R1 + 180]> */
		/* 8225D778h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000B4) );
		/* 8225D778h case   10:*/		return 0x8225D77C;
		  /* 8225D77Ch */ case   11:  		/* add R9, R11, R18 */
		/* 8225D77Ch case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R18);
		/* 8225D77Ch case   11:*/		return 0x8225D780;
		  /* 8225D780h */ case   12:  		/* rlwinm R10, R18, 2, 0, 29 */
		/* 8225D780h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R18);
		/* 8225D780h case   12:*/		return 0x8225D784;
		  /* 8225D784h */ case   13:  		/* addi R11, R17, 28 */
		/* 8225D784h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x1C);
		/* 8225D784h case   13:*/		return 0x8225D788;
		  /* 8225D788h */ case   14:  		/* li R28, 0 */
		/* 8225D788h case   14:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8225D788h case   14:*/		return 0x8225D78C;
		  /* 8225D78Ch */ case   15:  		/* mr R4, R15 */
		/* 8225D78Ch case   15:*/		regs.R4 = regs.R15;
		/* 8225D78Ch case   15:*/		return 0x8225D790;
		  /* 8225D790h */ case   16:  		/* add R29, R10, R23 */
		/* 8225D790h case   16:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R23);
		/* 8225D790h case   16:*/		return 0x8225D794;
		  /* 8225D794h */ case   17:  		/* subf R26, R23, R20 */
		/* 8225D794h case   17:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R23,regs.R20);
		/* 8225D794h case   17:*/		return 0x8225D798;
		  /* 8225D798h */ case   18:  		/* add R25, R9, R11 */
		/* 8225D798h case   18:*/		cpu::op::add<0>(regs,&regs.R25,regs.R9,regs.R11);
		/* 8225D798h case   18:*/		return 0x8225D79C;
		  /* 8225D79Ch */ case   19:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D79Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D79Ch case   19:*/		return 0x8225D7A0;
		  /* 8225D7A0h */ case   20:  		/* li R10, 0 */
		/* 8225D7A0h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8225D7A0h case   20:*/		return 0x8225D7A4;
		  /* 8225D7A4h */ case   21:  		/* lwz R11, <#[R11]> */
		/* 8225D7A4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D7A4h case   21:*/		return 0x8225D7A8;
		  /* 8225D7A8h */ case   22:  		/* stw R11, <#[R4]> */
		/* 8225D7A8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8225D7A8h case   22:*/		return 0x8225D7AC;
		  /* 8225D7ACh */ case   23:  		/* stw R4, <#[R8]> */
		/* 8225D7ACh case   23:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R8 + 0x00000000) );
		/* 8225D7ACh case   23:*/		return 0x8225D7B0;
		  /* 8225D7B0h */ case   24:  		/* lwz R11, <#[R4]> */
		/* 8225D7B0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8225D7B0h case   24:*/		return 0x8225D7B4;
		  /* 8225D7B4h */ case   25:  		/* extsh R11, R11 */
		/* 8225D7B4h case   25:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R11);
		/* 8225D7B4h case   25:*/		return 0x8225D7B8;
		  /* 8225D7B8h */ case   26:  		/* stwx R11, <#[R26 + R29]> */
		/* 8225D7B8h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + regs.R29 + 0x00000000) );
		/* 8225D7B8h case   26:*/		return 0x8225D7BC;
		  /* 8225D7BCh */ case   27:  		/* lwz R11, <#[R8]> */
		/* 8225D7BCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8225D7BCh case   27:*/		return 0x8225D7C0;
		  /* 8225D7C0h */ case   28:  		/* lhz R11, <#[R11]> */
		/* 8225D7C0h case   28:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D7C0h case   28:*/		return 0x8225D7C4;
		  /* 8225D7C4h */ case   29:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 8225D7C4h case   29:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8225D7C4h case   29:*/		return 0x8225D7C8;
		  /* 8225D7C8h */ case   30:  		/* stw R11, <#[R29]> */
		/* 8225D7C8h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8225D7C8h case   30:*/		return 0x8225D7CC;
		  /* 8225D7CCh */ case   31:  		/* lwz R11, <#[R8]> */
		/* 8225D7CCh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8225D7CCh case   31:*/		return 0x8225D7D0;
		  /* 8225D7D0h */ case   32:  		/* lwz R9, <#[R11]> */
		/* 8225D7D0h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D7D0h case   32:*/		return 0x8225D7D4;
		  /* 8225D7D4h */ case   33:  		/* rlwinm. R11, R9, 10, 31, 31 */
		/* 8225D7D4h case   33:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R9);
		/* 8225D7D4h case   33:*/		return 0x8225D7D8;
		  /* 8225D7D8h */ case   34:  		/* rlwinm R9, R9, 9, 31, 31 */
		/* 8225D7D8h case   34:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R9,regs.R9);
		/* 8225D7D8h case   34:*/		return 0x8225D7DC;
		  /* 8225D7DCh */ case   35:  		/* mr R27, R11 */
		/* 8225D7DCh case   35:*/		regs.R27 = regs.R11;
		/* 8225D7DCh case   35:*/		return 0x8225D7E0;
		  /* 8225D7E0h */ case   36:  		/* bc 12, CR0_EQ, 20 */
		/* 8225D7E0h case   36:*/		if ( regs.CR[0].eq ) { return 0x8225D7F4;  }
		/* 8225D7E0h case   36:*/		return 0x8225D7E4;
		  /* 8225D7E4h */ case   37:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D7E4h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D7E4h case   37:*/		return 0x8225D7E8;
	}
	return 0x8225D7E8;
} // Block from 8225D750h-8225D7E8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8225D7E8h
// Function '?ExpandOperandForExpansion@CFG@XGRAPHICS@@AAAXHHPAPATIL_Dst@2@PAPATIL_Src@2@PAVIRInst@2@HTSwizzleOrMaskInfo@2@AAT62@PAV?$stack@PAVLoopHeader@XGRAPHICS@@@2@_NPAHPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D7E8);
		  /* 8225D7E8h */ case    0:  		/* li R10, 1 */
		/* 8225D7E8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8225D7E8h case    0:*/		return 0x8225D7EC;
		  /* 8225D7ECh */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225D7ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225D7ECh case    1:*/		return 0x8225D7F0;
		  /* 8225D7F0h */ case    2:  		/* stw R11, <#[R4 + 4]> */
		/* 8225D7F0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8225D7F0h case    2:*/		return 0x8225D7F4;
	}
	return 0x8225D7F4;
} // Block from 8225D7E8h-8225D7F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225D7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D7F4);
		  /* 8225D7F4h */ case    0:  		/* rlwinm. R23, R9, 0, 24, 31 */
		/* 8225D7F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R23,regs.R9);
		/* 8225D7F4h case    0:*/		return 0x8225D7F8;
		  /* 8225D7F8h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 8225D7F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225D81C;  }
		/* 8225D7F8h case    1:*/		return 0x8225D7FC;
		  /* 8225D7FCh */ case    2:  		/* addi R9, R10, 1 */
		/* 8225D7FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x1);
		/* 8225D7FCh case    2:*/		return 0x8225D800;
		  /* 8225D800h */ case    3:  		/* lwz R7, <#[R19 + 20]> */
		/* 8225D800h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D800h case    3:*/		return 0x8225D804;
		  /* 8225D804h */ case    4:  		/* add R11, R10, R28 */
		/* 8225D804h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R28);
		/* 8225D804h case    4:*/		return 0x8225D808;
		  /* 8225D808h */ case    5:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8225D808h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8225D808h case    5:*/		return 0x8225D80C;
		  /* 8225D80Ch */ case    6:  		/* addi R11, R11, 1 */
		/* 8225D80Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225D80Ch case    6:*/		return 0x8225D810;
		  /* 8225D810h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225D810h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225D810h case    7:*/		return 0x8225D814;
		  /* 8225D814h */ case    8:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8225D814h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8225D814h case    8:*/		return 0x8225D818;
		  /* 8225D818h */ case    9:  		/* stwx R10, <#[R11 + R15]> */
		/* 8225D818h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 8225D818h case    9:*/		return 0x8225D81C;
	}
	return 0x8225D81C;
} // Block from 8225D7F4h-8225D81Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225D81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D81C);
		  /* 8225D81Ch */ case    0:  		/* lbzx R11, <#[R24 + R25]> */
		/* 8225D81Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + regs.R25 + 0x00000000) );
		/* 8225D81Ch case    0:*/		return 0x8225D820;
		  /* 8225D820h */ case    1:  		/* li R9, 0 */
		/* 8225D820h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8225D820h case    1:*/		return 0x8225D824;
		  /* 8225D824h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 8225D824h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8225D824h case    2:*/		return 0x8225D828;
		  /* 8225D828h */ case    3:  		/* bc 12, CR0_EQ, 184 */
		/* 8225D828h case    3:*/		if ( regs.CR[0].eq ) { return 0x8225D8E0;  }
		/* 8225D828h case    3:*/		return 0x8225D82C;
		  /* 8225D82Ch */ case    4:  		/* addi R3, R28, 18 */
		/* 8225D82Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R28,0x12);
		/* 8225D82Ch case    4:*/		return 0x8225D830;
		  /* 8225D830h */ case    5:  		/* mr R10, R8 */
		/* 8225D830h case    5:*/		regs.R10 = regs.R8;
		/* 8225D830h case    5:*/		return 0x8225D834;
		  /* 8225D834h */ case    6:  		/* addi R11, R4, 72 */
		/* 8225D834h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x48);
		/* 8225D834h case    6:*/		return 0x8225D838;
		  /* 8225D838h */ case    7:  		/* addi R7, R29, 24 */
		/* 8225D838h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R29,0x18);
		/* 8225D838h case    7:*/		return 0x8225D83C;
		  /* 8225D83Ch */ case    8:  		/* lwz R5, <#[R19 + 20]> */
		/* 8225D83Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D83Ch case    8:*/		return 0x8225D840;
		  /* 8225D840h */ case    9:  		/* li R6, 0 */
		/* 8225D840h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225D840h case    9:*/		return 0x8225D844;
		  /* 8225D844h */ case   10:  		/* cmplwi CR6, R27, 0 */
		/* 8225D844h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8225D844h case   10:*/		return 0x8225D848;
		  /* 8225D848h */ case   11:  		/* lwz R5, <#[R5]> */
		/* 8225D848h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000000) );
		/* 8225D848h case   11:*/		return 0x8225D84C;
		  /* 8225D84Ch */ case   12:  		/* stw R5, <#[R11]> */
		/* 8225D84Ch case   12:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 8225D84Ch case   12:*/		return 0x8225D850;
		  /* 8225D850h */ case   13:  		/* stw R11, <#[R10 + 24]> */
		/* 8225D850h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 8225D850h case   13:*/		return 0x8225D854;
		  /* 8225D854h */ case   14:  		/* lwz R5, <#[R8]> */
		/* 8225D854h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000000) );
		/* 8225D854h case   14:*/		return 0x8225D858;
		  /* 8225D858h */ case   15:  		/* lwz R5, <#[R5]> */
		/* 8225D858h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000000) );
		/* 8225D858h case   15:*/		return 0x8225D85C;
		  /* 8225D85Ch */ case   16:  		/* extsh R5, R5 */
		/* 8225D85Ch case   16:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R5);
		/* 8225D85Ch case   16:*/		return 0x8225D860;
		  /* 8225D860h */ case   17:  		/* add R5, R5, R9 */
		/* 8225D860h case   17:*/		cpu::op::add<0>(regs,&regs.R5,regs.R5,regs.R9);
		/* 8225D860h case   17:*/		return 0x8225D864;
		  /* 8225D864h */ case   18:  		/* addi R5, R5, 1 */
		/* 8225D864h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8225D864h case   18:*/		return 0x8225D868;
		  /* 8225D868h */ case   19:  		/* sth R5, <#[R11 + 2]> */
		/* 8225D868h case   19:*/		cpu::mem::store16( regs, regs.R5, (uint32)(regs.R11 + 0x00000002) );
		/* 8225D868h case   19:*/		return 0x8225D86C;
		  /* 8225D86Ch */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 8225D86Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x8225D880;  }
		/* 8225D86Ch case   20:*/		return 0x8225D870;
		  /* 8225D870h */ case   21:  		/* lwz R30, <#[R19 + 20]> */
		/* 8225D870h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D870h case   21:*/		return 0x8225D874;
		  /* 8225D874h */ case   22:  		/* li R6, 1 */
		/* 8225D874h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225D874h case   22:*/		return 0x8225D878;
		  /* 8225D878h */ case   23:  		/* lwz R30, <#[R30 + 4]> */
		/* 8225D878h case   23:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8225D878h case   23:*/		return 0x8225D87C;
		  /* 8225D87Ch */ case   24:  		/* stw R30, <#[R11 + 4]> */
		/* 8225D87Ch case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 8225D87Ch case   24:*/		return 0x8225D880;
	}
	return 0x8225D880;
} // Block from 8225D81Ch-8225D880h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8225D880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D880);
		  /* 8225D880h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8225D880h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8225D880h case    0:*/		return 0x8225D884;
		  /* 8225D884h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 8225D884h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225D8B0;  }
		/* 8225D884h case    1:*/		return 0x8225D888;
		  /* 8225D888h */ case    2:  		/* lwz R30, <#[R19 + 20]> */
		/* 8225D888h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D888h case    2:*/		return 0x8225D88C;
		  /* 8225D88Ch */ case    3:  		/* addi R20, R6, 1 */
		/* 8225D88Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R6,0x1);
		/* 8225D88Ch case    3:*/		return 0x8225D890;
		  /* 8225D890h */ case    4:  		/* rlwinm R20, R20, 2, 0, 29 */
		/* 8225D890h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R20,regs.R20);
		/* 8225D890h case    4:*/		return 0x8225D894;
		  /* 8225D894h */ case    5:  		/* stw R30, <#[R1 + 156]> */
		/* 8225D894h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000009C) );
		/* 8225D894h case    5:*/		return 0x8225D898;
		  /* 8225D898h */ case    6:  		/* add R30, R6, R3 */
		/* 8225D898h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R6,regs.R3);
		/* 8225D898h case    6:*/		return 0x8225D89C;
		  /* 8225D89Ch */ case    7:  		/* addi R6, R30, 1 */
		/* 8225D89Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R30,0x1);
		/* 8225D89Ch case    7:*/		return 0x8225D8A0;
		  /* 8225D8A0h */ case    8:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8225D8A0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8225D8A0h case    8:*/		return 0x8225D8A4;
		  /* 8225D8A4h */ case    9:  		/* lwz R30, <#[R1 + 156]> */
		/* 8225D8A4h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000009C) );
		/* 8225D8A4h case    9:*/		return 0x8225D8A8;
		  /* 8225D8A8h */ case   10:  		/* lwzx R30, <#[R20 + R30]> */
		/* 8225D8A8h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R20 + regs.R30 + 0x00000000) );
		/* 8225D8A8h case   10:*/		return 0x8225D8AC;
		  /* 8225D8ACh */ case   11:  		/* stwx R30, <#[R6 + R15]> */
		/* 8225D8ACh case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R6 + regs.R15 + 0x00000000) );
		/* 8225D8ACh case   11:*/		return 0x8225D8B0;
	}
	return 0x8225D8B0;
} // Block from 8225D880h-8225D8B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225D8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D8B0);
		  /* 8225D8B0h */ case    0:  		/* stwx R5, <#[R26 + R7]> */
		/* 8225D8B0h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R26 + regs.R7 + 0x00000000) );
		/* 8225D8B0h case    0:*/		return 0x8225D8B4;
		  /* 8225D8B4h */ case    1:  		/* addi R9, R9, 1 */
		/* 8225D8B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8225D8B4h case    1:*/		return 0x8225D8B8;
		  /* 8225D8B8h */ case    2:  		/* addi R3, R3, 18 */
		/* 8225D8B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x12);
		/* 8225D8B8h case    2:*/		return 0x8225D8BC;
		  /* 8225D8BCh */ case    3:  		/* addi R11, R11, 72 */
		/* 8225D8BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x48);
		/* 8225D8BCh case    3:*/		return 0x8225D8C0;
		  /* 8225D8C0h */ case    4:  		/* lwzu R6, <#[R10 + 24]> */
		/* 8225D8C0h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000018) );
		regs.R10 = (uint32)(regs.R10 + 0x00000018);
		/* 8225D8C0h case    4:*/		return 0x8225D8C4;
		  /* 8225D8C4h */ case    5:  		/* lhz R6, <#[R6]> */
		/* 8225D8C4h case    5:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000000) );
		/* 8225D8C4h case    5:*/		return 0x8225D8C8;
		  /* 8225D8C8h */ case    6:  		/* rlwinm R6, R6, 0, 26, 31 */
		/* 8225D8C8h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R6,regs.R6);
		/* 8225D8C8h case    6:*/		return 0x8225D8CC;
		  /* 8225D8CCh */ case    7:  		/* stw R6, <#[R7]> */
		/* 8225D8CCh case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 8225D8CCh case    7:*/		return 0x8225D8D0;
		  /* 8225D8D0h */ case    8:  		/* addi R7, R7, 24 */
		/* 8225D8D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x18);
		/* 8225D8D0h case    8:*/		return 0x8225D8D4;
		  /* 8225D8D4h */ case    9:  		/* lbzx R6, <#[R24 + R25]> */
		/* 8225D8D4h case    9:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R24 + regs.R25 + 0x00000000) );
		/* 8225D8D4h case    9:*/		return 0x8225D8D8;
		  /* 8225D8D8h */ case   10:  		/* cmpw CR6, R9, R6 */
		/* 8225D8D8h case   10:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R6);
		/* 8225D8D8h case   10:*/		return 0x8225D8DC;
		  /* 8225D8DCh */ case   11:  		/* bc 12, CR6_LT, -160 */
		/* 8225D8DCh case   11:*/		if ( regs.CR[6].lt ) { return 0x8225D83C;  }
		/* 8225D8DCh case   11:*/		return 0x8225D8E0;
	}
	return 0x8225D8E0;
} // Block from 8225D8B0h-8225D8E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8225D8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D8E0);
		  /* 8225D8E0h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D8E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D8E0h case    0:*/		return 0x8225D8E4;
		  /* 8225D8E4h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 8225D8E4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8225D8E4h case    1:*/		return 0x8225D8E8;
		  /* 8225D8E8h */ case    2:  		/* addi R11, R11, 4 */
		/* 8225D8E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D8E8h case    2:*/		return 0x8225D8EC;
		  /* 8225D8ECh */ case    3:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D8ECh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D8ECh case    3:*/		return 0x8225D8F0;
		  /* 8225D8F0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 8225D8F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8225D8FC;  }
		/* 8225D8F0h case    4:*/		return 0x8225D8F4;
		  /* 8225D8F4h */ case    5:  		/* addi R11, R11, 4 */
		/* 8225D8F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D8F4h case    5:*/		return 0x8225D8F8;
		  /* 8225D8F8h */ case    6:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D8F8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D8F8h case    6:*/		return 0x8225D8FC;
	}
	return 0x8225D8FC;
} // Block from 8225D8E0h-8225D8FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225D8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D8FC);
		  /* 8225D8FCh */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8225D8FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8225D8FCh case    0:*/		return 0x8225D900;
		  /* 8225D900h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8225D900h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225D910;  }
		/* 8225D900h case    1:*/		return 0x8225D904;
		  /* 8225D904h */ case    2:  		/* lwz R11, <#[R19 + 20]> */
		/* 8225D904h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D904h case    2:*/		return 0x8225D908;
		  /* 8225D908h */ case    3:  		/* addi R11, R11, 4 */
		/* 8225D908h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8225D908h case    3:*/		return 0x8225D90C;
		  /* 8225D90Ch */ case    4:  		/* stw R11, <#[R19 + 20]> */
		/* 8225D90Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8225D90Ch case    4:*/		return 0x8225D910;
	}
	return 0x8225D910;
} // Block from 8225D8FCh-8225D910h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225D910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D910);
		  /* 8225D910h */ case    0:  		/* addi R24, R24, 1 */
		/* 8225D910h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8225D910h case    0:*/		return 0x8225D914;
		  /* 8225D914h */ case    1:  		/* addi R28, R28, 3 */
		/* 8225D914h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x3);
		/* 8225D914h case    1:*/		return 0x8225D918;
		  /* 8225D918h */ case    2:  		/* addi R4, R4, 12 */
		/* 8225D918h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xC);
		/* 8225D918h case    2:*/		return 0x8225D91C;
		  /* 8225D91Ch */ case    3:  		/* addi R8, R8, 4 */
		/* 8225D91Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8225D91Ch case    3:*/		return 0x8225D920;
		  /* 8225D920h */ case    4:  		/* addi R29, R29, 4 */
		/* 8225D920h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8225D920h case    4:*/		return 0x8225D924;
		  /* 8225D924h */ case    5:  		/* cmpw CR6, R24, R22 */
		/* 8225D924h case    5:*/		cpu::op::cmpw<6>(regs,regs.R24,regs.R22);
		/* 8225D924h case    5:*/		return 0x8225D928;
		  /* 8225D928h */ case    6:  		/* bc 12, CR6_LT, -396 */
		/* 8225D928h case    6:*/		if ( regs.CR[6].lt ) { return 0x8225D79C;  }
		/* 8225D928h case    6:*/		return 0x8225D92C;
		  /* 8225D92Ch */ case    7:  		/* lwz R30, <#[R1 + 204]> */
		/* 8225D92Ch case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225D92Ch case    7:*/		return 0x8225D930;
	}
	return 0x8225D930;
} // Block from 8225D910h-8225D930h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8225D930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D930);
		  /* 8225D930h */ case    0:  		/* mr R3, R30 */
		/* 8225D930h case    0:*/		regs.R3 = regs.R30;
		/* 8225D930h case    0:*/		return 0x8225D934;
		  /* 8225D934h */ case    1:  		/* bl -13484 */
		/* 8225D934h case    1:*/		regs.LR = 0x8225D938; return 0x8225A488;
		/* 8225D934h case    1:*/		return 0x8225D938;
		  /* 8225D938h */ case    2:  		/* lwz R11, <#[R1 + 136]> */
		/* 8225D938h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 8225D938h case    2:*/		return 0x8225D93C;
		  /* 8225D93Ch */ case    3:  		/* lwz R9, <#[R31 + 12]> */
		/* 8225D93Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D93Ch case    3:*/		return 0x8225D940;
		  /* 8225D940h */ case    4:  		/* li R4, 20 */
		/* 8225D940h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8225D940h case    4:*/		return 0x8225D944;
		  /* 8225D944h */ case    5:  		/* stw R3, <#[R1 + 144]> */
		/* 8225D944h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000090) );
		/* 8225D944h case    5:*/		return 0x8225D948;
		  /* 8225D948h */ case    6:  		/* lwz R10, <#[R11 - 1320]> */
		/* 8225D948h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFAD8) );
		/* 8225D948h case    6:*/		return 0x8225D94C;
		  /* 8225D94Ch */ case    7:  		/* lwz R11, <#[R11 - 1312]> */
		/* 8225D94Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFAE0) );
		/* 8225D94Ch case    7:*/		return 0x8225D950;
		  /* 8225D950h */ case    8:  		/* lwz R29, <#[R9 + 1456]> */
		/* 8225D950h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x000005B0) );
		/* 8225D950h case    8:*/		return 0x8225D954;
		  /* 8225D954h */ case    9:  		/* mr R3, R29 */
		/* 8225D954h case    9:*/		regs.R3 = regs.R29;
		/* 8225D954h case    9:*/		return 0x8225D958;
		  /* 8225D958h */ case   10:  		/* stw R10, <#[R1 + 152]> */
		/* 8225D958h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 8225D958h case   10:*/		return 0x8225D95C;
		  /* 8225D95Ch */ case   11:  		/* stw R11, <#[R1 + 236]> */
		/* 8225D95Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000EC) );
		/* 8225D95Ch case   11:*/		return 0x8225D960;
		  /* 8225D960h */ case   12:  		/* bl -267432 */
		/* 8225D960h case   12:*/		regs.LR = 0x8225D964; return 0x8221C4B8;
		/* 8225D960h case   12:*/		return 0x8225D964;
		  /* 8225D964h */ case   13:  		/* addic. R30, R3, 4 */
		/* 8225D964h case   13:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8225D964h case   13:*/		return 0x8225D968;
		  /* 8225D968h */ case   14:  		/* stw R29, <#[R3]> */
		/* 8225D968h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8225D968h case   14:*/		return 0x8225D96C;
		  /* 8225D96Ch */ case   15:  		/* bc 12, CR0_EQ, 28 */
		/* 8225D96Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8225D988;  }
		/* 8225D96Ch case   15:*/		return 0x8225D970;
		  /* 8225D970h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D970h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D970h case   16:*/		return 0x8225D974;
		  /* 8225D974h */ case   17:  		/* mr R3, R30 */
		/* 8225D974h case   17:*/		regs.R3 = regs.R30;
		/* 8225D974h case   17:*/		return 0x8225D978;
		  /* 8225D978h */ case   18:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8225D978h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D978h case   18:*/		return 0x8225D97C;
		  /* 8225D97Ch */ case   19:  		/* bl -162844 */
		/* 8225D97Ch case   19:*/		regs.LR = 0x8225D980; return 0x82235D60;
		/* 8225D97Ch case   19:*/		return 0x8225D980;
		  /* 8225D980h */ case   20:  		/* stw R30, <#[R1 + 156]> */
		/* 8225D980h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000009C) );
		/* 8225D980h case   20:*/		return 0x8225D984;
		  /* 8225D984h */ case   21:  		/* b 12 */
		/* 8225D984h case   21:*/		return 0x8225D990;
		/* 8225D984h case   21:*/		return 0x8225D988;
	}
	return 0x8225D988;
} // Block from 8225D930h-8225D988h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8225D988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D988);
		  /* 8225D988h */ case    0:  		/* li R11, 0 */
		/* 8225D988h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225D988h case    0:*/		return 0x8225D98C;
		  /* 8225D98Ch */ case    1:  		/* stw R11, <#[R1 + 156]> */
		/* 8225D98Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 8225D98Ch case    1:*/		return 0x8225D990;
	}
	return 0x8225D990;
} // Block from 8225D988h-8225D990h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225D990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D990);
		  /* 8225D990h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D990h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D990h case    0:*/		return 0x8225D994;
		  /* 8225D994h */ case    1:  		/* li R4, 20 */
		/* 8225D994h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 8225D994h case    1:*/		return 0x8225D998;
		  /* 8225D998h */ case    2:  		/* lwz R29, <#[R11 + 1456]> */
		/* 8225D998h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D998h case    2:*/		return 0x8225D99C;
		  /* 8225D99Ch */ case    3:  		/* mr R3, R29 */
		/* 8225D99Ch case    3:*/		regs.R3 = regs.R29;
		/* 8225D99Ch case    3:*/		return 0x8225D9A0;
		  /* 8225D9A0h */ case    4:  		/* bl -267496 */
		/* 8225D9A0h case    4:*/		regs.LR = 0x8225D9A4; return 0x8221C4B8;
		/* 8225D9A0h case    4:*/		return 0x8225D9A4;
		  /* 8225D9A4h */ case    5:  		/* addic. R30, R3, 4 */
		/* 8225D9A4h case    5:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8225D9A4h case    5:*/		return 0x8225D9A8;
		  /* 8225D9A8h */ case    6:  		/* stw R29, <#[R3]> */
		/* 8225D9A8h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8225D9A8h case    6:*/		return 0x8225D9AC;
		  /* 8225D9ACh */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 8225D9ACh case    7:*/		if ( regs.CR[0].eq ) { return 0x8225D9C8;  }
		/* 8225D9ACh case    7:*/		return 0x8225D9B0;
		  /* 8225D9B0h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225D9B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225D9B0h case    8:*/		return 0x8225D9B4;
		  /* 8225D9B4h */ case    9:  		/* mr R3, R30 */
		/* 8225D9B4h case    9:*/		regs.R3 = regs.R30;
		/* 8225D9B4h case    9:*/		return 0x8225D9B8;
		  /* 8225D9B8h */ case   10:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8225D9B8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8225D9B8h case   10:*/		return 0x8225D9BC;
		  /* 8225D9BCh */ case   11:  		/* bl -162908 */
		/* 8225D9BCh case   11:*/		regs.LR = 0x8225D9C0; return 0x82235D60;
		/* 8225D9BCh case   11:*/		return 0x8225D9C0;
		  /* 8225D9C0h */ case   12:  		/* stw R30, <#[R1 + 148]> */
		/* 8225D9C0h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000094) );
		/* 8225D9C0h case   12:*/		return 0x8225D9C4;
		  /* 8225D9C4h */ case   13:  		/* b 12 */
		/* 8225D9C4h case   13:*/		return 0x8225D9D0;
		/* 8225D9C4h case   13:*/		return 0x8225D9C8;
	}
	return 0x8225D9C8;
} // Block from 8225D990h-8225D9C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225D9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D9C8);
		  /* 8225D9C8h */ case    0:  		/* li R11, 0 */
		/* 8225D9C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225D9C8h case    0:*/		return 0x8225D9CC;
		  /* 8225D9CCh */ case    1:  		/* stw R11, <#[R1 + 148]> */
		/* 8225D9CCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 8225D9CCh case    1:*/		return 0x8225D9D0;
	}
	return 0x8225D9D0;
} // Block from 8225D9C8h-8225D9D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225D9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225D9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225D9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225D9D0);
		  /* 8225D9D0h */ case    0:  		/* li R15, 0 */
		/* 8225D9D0h case    0:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 8225D9D0h case    0:*/		return 0x8225D9D4;
		  /* 8225D9D4h */ case    1:  		/* cmpwi CR6, R18, 0 */
		/* 8225D9D4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 8225D9D4h case    1:*/		return 0x8225D9D8;
		  /* 8225D9D8h */ case    2:  		/* stw R15, <#[R1 + 560]> */
		/* 8225D9D8h case    2:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000230) );
		/* 8225D9D8h case    2:*/		return 0x8225D9DC;
		  /* 8225D9DCh */ case    3:  		/* mr R29, R15 */
		/* 8225D9DCh case    3:*/		regs.R29 = regs.R15;
		/* 8225D9DCh case    3:*/		return 0x8225D9E0;
		  /* 8225D9E0h */ case    4:  		/* stw R15, <#[R1 + 568]> */
		/* 8225D9E0h case    4:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000238) );
		/* 8225D9E0h case    4:*/		return 0x8225D9E4;
		  /* 8225D9E4h */ case    5:  		/* stw R15, <#[R1 + 572]> */
		/* 8225D9E4h case    5:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x0000023C) );
		/* 8225D9E4h case    5:*/		return 0x8225D9E8;
		  /* 8225D9E8h */ case    6:  		/* stw R15, <#[R1 + 576]> */
		/* 8225D9E8h case    6:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000240) );
		/* 8225D9E8h case    6:*/		return 0x8225D9EC;
		  /* 8225D9ECh */ case    7:  		/* stw R15, <#[R1 + 140]> */
		/* 8225D9ECh case    7:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x0000008C) );
		/* 8225D9ECh case    7:*/		return 0x8225D9F0;
		  /* 8225D9F0h */ case    8:  		/* stw R15, <#[R1 + 580]> */
		/* 8225D9F0h case    8:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000244) );
		/* 8225D9F0h case    8:*/		return 0x8225D9F4;
		  /* 8225D9F4h */ case    9:  		/* stw R15, <#[R1 + 564]> */
		/* 8225D9F4h case    9:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000234) );
		/* 8225D9F4h case    9:*/		return 0x8225D9F8;
		  /* 8225D9F8h */ case   10:  		/* stw R15, <#[R1 + 584]> */
		/* 8225D9F8h case   10:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000248) );
		/* 8225D9F8h case   10:*/		return 0x8225D9FC;
		  /* 8225D9FCh */ case   11:  		/* stw R15, <#[R1 + 168]> */
		/* 8225D9FCh case   11:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x000000A8) );
		/* 8225D9FCh case   11:*/		return 0x8225DA00;
		  /* 8225DA00h */ case   12:  		/* stb R15, <#[R1 + 172]> */
		/* 8225DA00h case   12:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R1 + 0x000000AC) );
		/* 8225DA00h case   12:*/		return 0x8225DA04;
		  /* 8225DA04h */ case   13:  		/* bc 4, CR6_GT, 96 */
		/* 8225DA04h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8225DA64;  }
		/* 8225DA04h case   13:*/		return 0x8225DA08;
		  /* 8225DA08h */ case   14:  		/* lwz R10, <#[R1 + 204]> */
		/* 8225DA08h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225DA08h case   14:*/		return 0x8225DA0C;
		  /* 8225DA0Ch */ case   15:  		/* addi R11, R17, 28 */
		/* 8225DA0Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x1C);
		/* 8225DA0Ch case   15:*/		return 0x8225DA10;
		  /* 8225DA10h */ case   16:  		/* mr R26, R16 */
		/* 8225DA10h case   16:*/		regs.R26 = regs.R16;
		/* 8225DA10h case   16:*/		return 0x8225DA14;
		  /* 8225DA14h */ case   17:  		/* mulli R10, R10, 36 */
		/* 8225DA14h case   17:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x24);
		/* 8225DA14h case   17:*/		return 0x8225DA18;
		  /* 8225DA18h */ case   18:  		/* add R27, R10, R11 */
		/* 8225DA18h case   18:*/		cpu::op::add<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 8225DA18h case   18:*/		return 0x8225DA1C;
		  /* 8225DA1Ch */ case   19:  		/* lbzx R11, <#[R27 + R29]> */
		/* 8225DA1Ch case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + regs.R29 + 0x00000000) );
		/* 8225DA1Ch case   19:*/		return 0x8225DA20;
		  /* 8225DA20h */ case   20:  		/* mr R30, R15 */
		/* 8225DA20h case   20:*/		regs.R30 = regs.R15;
		/* 8225DA20h case   20:*/		return 0x8225DA24;
		  /* 8225DA24h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 8225DA24h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225DA24h case   21:*/		return 0x8225DA28;
		  /* 8225DA28h */ case   22:  		/* bc 12, CR6_LT, 44 */
		/* 8225DA28h case   22:*/		if ( regs.CR[6].lt ) { return 0x8225DA54;  }
		/* 8225DA28h case   22:*/		return 0x8225DA2C;
		  /* 8225DA2Ch */ case   23:  		/* addi R28, R26, -24 */
		/* 8225DA2Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R26,0xFFFFFFE8);
		/* 8225DA2Ch case   23:*/		return 0x8225DA30;
		  /* 8225DA30h */ case   24:  		/* addi R4, R1, 624 */
		/* 8225DA30h case   24:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x270);
		/* 8225DA30h case   24:*/		return 0x8225DA34;
		  /* 8225DA34h */ case   25:  		/* lwzu R5, <#[R28 + 24]> */
		/* 8225DA34h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000018) );
		regs.R28 = (uint32)(regs.R28 + 0x00000018);
		/* 8225DA34h case   25:*/		return 0x8225DA38;
		  /* 8225DA38h */ case   26:  		/* mr R3, R31 */
		/* 8225DA38h case   26:*/		regs.R3 = regs.R31;
		/* 8225DA38h case   26:*/		return 0x8225DA3C;
		  /* 8225DA3Ch */ case   27:  		/* lwz R6, <#[R1 + 164]> */
		/* 8225DA3Ch case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000A4) );
		/* 8225DA3Ch case   27:*/		return 0x8225DA40;
		  /* 8225DA40h */ case   28:  		/* bl -6528 */
		/* 8225DA40h case   28:*/		regs.LR = 0x8225DA44; return 0x8225C0C0;
		/* 8225DA40h case   28:*/		return 0x8225DA44;
		  /* 8225DA44h */ case   29:  		/* lbzx R11, <#[R27 + R29]> */
		/* 8225DA44h case   29:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + regs.R29 + 0x00000000) );
		/* 8225DA44h case   29:*/		return 0x8225DA48;
		  /* 8225DA48h */ case   30:  		/* addi R30, R30, 1 */
		/* 8225DA48h case   30:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225DA48h case   30:*/		return 0x8225DA4C;
		  /* 8225DA4Ch */ case   31:  		/* cmpw CR6, R30, R11 */
		/* 8225DA4Ch case   31:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8225DA4Ch case   31:*/		return 0x8225DA50;
		  /* 8225DA50h */ case   32:  		/* bc 4, CR6_GT, -32 */
		/* 8225DA50h case   32:*/		if ( !regs.CR[6].gt ) { return 0x8225DA30;  }
		/* 8225DA50h case   32:*/		return 0x8225DA54;
	}
	return 0x8225DA54;
} // Block from 8225D9D0h-8225DA54h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8225DA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DA54);
		  /* 8225DA54h */ case    0:  		/* addi R29, R29, 1 */
		/* 8225DA54h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8225DA54h case    0:*/		return 0x8225DA58;
		  /* 8225DA58h */ case    1:  		/* addi R26, R26, 4 */
		/* 8225DA58h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8225DA58h case    1:*/		return 0x8225DA5C;
		  /* 8225DA5Ch */ case    2:  		/* cmpw CR6, R29, R18 */
		/* 8225DA5Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R18);
		/* 8225DA5Ch case    2:*/		return 0x8225DA60;
		  /* 8225DA60h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 8225DA60h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225DA1C;  }
		/* 8225DA60h case    3:*/		return 0x8225DA64;
	}
	return 0x8225DA64;
} // Block from 8225DA54h-8225DA64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225DA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DA64);
		  /* 8225DA64h */ case    0:  		/* stb R15, <#[R1 + 192]> */
		/* 8225DA64h case    0:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R1 + 0x000000C0) );
		/* 8225DA64h case    0:*/		return 0x8225DA68;
		  /* 8225DA68h */ case    1:  		/* mr R27, R15 */
		/* 8225DA68h case    1:*/		regs.R27 = regs.R15;
		/* 8225DA68h case    1:*/		return 0x8225DA6C;
		  /* 8225DA6Ch */ case    2:  		/* cmpwi CR6, R21, 0 */
		/* 8225DA6Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8225DA6Ch case    2:*/		return 0x8225DA70;
		  /* 8225DA70h */ case    3:  		/* bc 4, CR6_GT, 140 */
		/* 8225DA70h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8225DAFC;  }
		/* 8225DA70h case    3:*/		return 0x8225DA74;
		  /* 8225DA74h */ case    4:  		/* lwz R11, <#[R1 + 204]> */
		/* 8225DA74h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225DA74h case    4:*/		return 0x8225DA78;
		  /* 8225DA78h */ case    5:  		/* lwz R25, <#[R1 + 180]> */
		/* 8225DA78h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000B4) );
		/* 8225DA78h case    5:*/		return 0x8225DA7C;
		  /* 8225DA7Ch */ case    6:  		/* mulli R11, R11, 36 */
		/* 8225DA7Ch case    6:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8225DA7Ch case    6:*/		return 0x8225DA80;
		  /* 8225DA80h */ case    7:  		/* add R10, R11, R18 */
		/* 8225DA80h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R18);
		/* 8225DA80h case    7:*/		return 0x8225DA84;
		  /* 8225DA84h */ case    8:  		/* addi R11, R17, 28 */
		/* 8225DA84h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x1C);
		/* 8225DA84h case    8:*/		return 0x8225DA88;
		  /* 8225DA88h */ case    9:  		/* add R28, R10, R11 */
		/* 8225DA88h case    9:*/		cpu::op::add<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 8225DA88h case    9:*/		return 0x8225DA8C;
		  /* 8225DA8Ch */ case   10:  		/* lwz R11, <#[R25]> */
		/* 8225DA8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8225DA8Ch case   10:*/		return 0x8225DA90;
	}
	return 0x8225DA90;
} // Block from 8225DA64h-8225DA90h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8225DA90h
// Function '?IL2IR@CFG@XGRAPHICS@@AAAXAAVILInstIterator@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DA90);
		  /* 8225DA90h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8225DA90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8225DA90h case    0:*/		return 0x8225DA94;
		  /* 8225DA94h */ case    1:  		/* rlwinm. R26, R11, 10, 31, 31 */
		/* 8225DA94h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R26,regs.R11);
		/* 8225DA94h case    1:*/		return 0x8225DA98;
		  /* 8225DA98h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8225DA98h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225DAA4;  }
		/* 8225DA98h case    2:*/		return 0x8225DA9C;
		  /* 8225DA9Ch */ case    3:  		/* li R11, 1 */
		/* 8225DA9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225DA9Ch case    3:*/		return 0x8225DAA0;
		  /* 8225DAA0h */ case    4:  		/* stb R11, <#[R1 + 192]> */
		/* 8225DAA0h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 8225DAA0h case    4:*/		return 0x8225DAA4;
	}
	return 0x8225DAA4;
} // Block from 8225DA90h-8225DAA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225DAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DAA4);
		  /* 8225DAA4h */ case    0:  		/* lbzx R11, <#[R28 + R27]> */
		/* 8225DAA4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + regs.R27 + 0x00000000) );
		/* 8225DAA4h case    0:*/		return 0x8225DAA8;
		  /* 8225DAA8h */ case    1:  		/* mr R30, R15 */
		/* 8225DAA8h case    1:*/		regs.R30 = regs.R15;
		/* 8225DAA8h case    1:*/		return 0x8225DAAC;
		  /* 8225DAACh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8225DAACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8225DAACh case    2:*/		return 0x8225DAB0;
		  /* 8225DAB0h */ case    3:  		/* bc 12, CR6_LT, 60 */
		/* 8225DAB0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225DAEC;  }
		/* 8225DAB0h case    3:*/		return 0x8225DAB4;
		  /* 8225DAB4h */ case    4:  		/* addi R29, R25, -24 */
		/* 8225DAB4h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R25,0xFFFFFFE8);
		/* 8225DAB4h case    4:*/		return 0x8225DAB8;
		  /* 8225DAB8h */ case    5:  		/* lwzu R6, <#[R29 + 24]> */
		/* 8225DAB8h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000018) );
		regs.R29 = (uint32)(regs.R29 + 0x00000018);
		/* 8225DAB8h case    5:*/		return 0x8225DABC;
		  /* 8225DABCh */ case    6:  		/* mr R9, R26 */
		/* 8225DABCh case    6:*/		regs.R9 = regs.R26;
		/* 8225DABCh case    6:*/		return 0x8225DAC0;
		  /* 8225DAC0h */ case    7:  		/* addi R4, R1, 656 */
		/* 8225DAC0h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x290);
		/* 8225DAC0h case    7:*/		return 0x8225DAC4;
		  /* 8225DAC4h */ case    8:  		/* lwz R7, <#[R1 + 164]> */
		/* 8225DAC4h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000A4) );
		/* 8225DAC4h case    8:*/		return 0x8225DAC8;
		  /* 8225DAC8h */ case    9:  		/* mr R3, R31 */
		/* 8225DAC8h case    9:*/		regs.R3 = regs.R31;
		/* 8225DAC8h case    9:*/		return 0x8225DACC;
		  /* 8225DACCh */ case   10:  		/* lwz R5, <#[R1 + 176]> */
		/* 8225DACCh case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B0) );
		/* 8225DACCh case   10:*/		return 0x8225DAD0;
		  /* 8225DAD0h */ case   11:  		/* lwz R11, <#[R6]> */
		/* 8225DAD0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8225DAD0h case   11:*/		return 0x8225DAD4;
		  /* 8225DAD4h */ case   12:  		/* rlwinm R8, R11, 9, 31, 31 */
		/* 8225DAD4h case   12:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R8,regs.R11);
		/* 8225DAD4h case   12:*/		return 0x8225DAD8;
		  /* 8225DAD8h */ case   13:  		/* bl -11280 */
		/* 8225DAD8h case   13:*/		regs.LR = 0x8225DADC; return 0x8225AEC8;
		/* 8225DAD8h case   13:*/		return 0x8225DADC;
		  /* 8225DADCh */ case   14:  		/* lbzx R11, <#[R28 + R27]> */
		/* 8225DADCh case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + regs.R27 + 0x00000000) );
		/* 8225DADCh case   14:*/		return 0x8225DAE0;
		  /* 8225DAE0h */ case   15:  		/* addi R30, R30, 1 */
		/* 8225DAE0h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8225DAE0h case   15:*/		return 0x8225DAE4;
		  /* 8225DAE4h */ case   16:  		/* cmpw CR6, R30, R11 */
		/* 8225DAE4h case   16:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8225DAE4h case   16:*/		return 0x8225DAE8;
		  /* 8225DAE8h */ case   17:  		/* bc 4, CR6_GT, -48 */
		/* 8225DAE8h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8225DAB8;  }
		/* 8225DAE8h case   17:*/		return 0x8225DAEC;
	}
	return 0x8225DAEC;
} // Block from 8225DAA4h-8225DAECh (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225DAECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DAEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DAEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DAEC);
		  /* 8225DAECh */ case    0:  		/* addi R27, R27, 1 */
		/* 8225DAECh case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8225DAECh case    0:*/		return 0x8225DAF0;
		  /* 8225DAF0h */ case    1:  		/* addi R25, R25, 4 */
		/* 8225DAF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 8225DAF0h case    1:*/		return 0x8225DAF4;
		  /* 8225DAF4h */ case    2:  		/* cmpw CR6, R27, R21 */
		/* 8225DAF4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R21);
		/* 8225DAF4h case    2:*/		return 0x8225DAF8;
		  /* 8225DAF8h */ case    3:  		/* bc 12, CR6_LT, -108 */
		/* 8225DAF8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8225DA8C;  }
		/* 8225DAF8h case    3:*/		return 0x8225DAFC;
	}
	return 0x8225DAFC;
} // Block from 8225DAECh-8225DAFCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225DAFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DAFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DAFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DAFC);
		  /* 8225DAFCh */ case    0:  		/* lwz R30, <#[R1 + 664]> */
		/* 8225DAFCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000298) );
		/* 8225DAFCh case    0:*/		return 0x8225DB00;
		  /* 8225DB00h */ case    1:  		/* lwz R29, <#[R30 + 8]> */
		/* 8225DB00h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 8225DB00h case    1:*/		return 0x8225DB04;
		  /* 8225DB04h */ case    2:  		/* b 84 */
		/* 8225DB04h case    2:*/		return 0x8225DB58;
		/* 8225DB04h case    2:*/		return 0x8225DB08;
		  /* 8225DB08h */ case    3:  		/* mr R3, R30 */
		/* 8225DB08h case    3:*/		regs.R3 = regs.R30;
		/* 8225DB08h case    3:*/		return 0x8225DB0C;
		  /* 8225DB0Ch */ case    4:  		/* bl -41732 */
		/* 8225DB0Ch case    4:*/		regs.LR = 0x8225DB10; return 0x82253808;
		/* 8225DB0Ch case    4:*/		return 0x8225DB10;
		  /* 8225DB10h */ case    5:  		/* mr R4, R30 */
		/* 8225DB10h case    5:*/		regs.R4 = regs.R30;
		/* 8225DB10h case    5:*/		return 0x8225DB14;
		  /* 8225DB14h */ case    6:  		/* mr R3, R31 */
		/* 8225DB14h case    6:*/		regs.R3 = regs.R31;
		/* 8225DB14h case    6:*/		return 0x8225DB18;
		  /* 8225DB18h */ case    7:  		/* bl -161136 */
		/* 8225DB18h case    7:*/		regs.LR = 0x8225DB1C; return 0x822365A8;
		/* 8225DB18h case    7:*/		return 0x8225DB1C;
		  /* 8225DB1Ch */ case    8:  		/* mr R4, R30 */
		/* 8225DB1Ch case    8:*/		regs.R4 = regs.R30;
		/* 8225DB1Ch case    8:*/		return 0x8225DB20;
		  /* 8225DB20h */ case    9:  		/* mr R3, R14 */
		/* 8225DB20h case    9:*/		regs.R3 = regs.R14;
		/* 8225DB20h case    9:*/		return 0x8225DB24;
		  /* 8225DB24h */ case   10:  		/* bl -19444 */
		/* 8225DB24h case   10:*/		regs.LR = 0x8225DB28; return 0x82258F30;
		/* 8225DB24h case   10:*/		return 0x8225DB28;
		  /* 8225DB28h */ case   11:  		/* mr R3, R30 */
		/* 8225DB28h case   11:*/		regs.R3 = regs.R30;
		/* 8225DB28h case   11:*/		return 0x8225DB2C;
		  /* 8225DB2Ch */ case   12:  		/* bl -31596 */
		/* 8225DB2Ch case   12:*/		regs.LR = 0x8225DB30; return 0x82255FC0;
		/* 8225DB2Ch case   12:*/		return 0x8225DB30;
		  /* 8225DB30h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225DB30h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225DB30h case   13:*/		return 0x8225DB34;
		  /* 8225DB34h */ case   14:  		/* bc 4, CR0_EQ, 28 */
		/* 8225DB34h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8225DB50;  }
		/* 8225DB34h case   14:*/		return 0x8225DB38;
		  /* 8225DB38h */ case   15:  		/* li R7, 2243 */
		/* 8225DB38h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x8C3);
		/* 8225DB38h case   15:*/		return 0x8225DB3C;
		  /* 8225DB3Ch */ case   16:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225DB3Ch case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225DB3Ch case   16:*/		return 0x8225DB40;
		  /* 8225DB40h */ case   17:  		/* li R3, 0 */
		/* 8225DB40h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225DB40h case   17:*/		return 0x8225DB44;
		  /* 8225DB44h */ case   18:  		/* lwz R5, <#[R1 + 252]> */
		/* 8225DB44h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000FC) );
		/* 8225DB44h case   18:*/		return 0x8225DB48;
		  /* 8225DB48h */ case   19:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225DB48h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225DB48h case   19:*/		return 0x8225DB4C;
		  /* 8225DB4Ch */ case   20:  		/* bl -1072964 */
		/* 8225DB4Ch case   20:*/		regs.LR = 0x8225DB50; return 0x82157C08;
		/* 8225DB4Ch case   20:*/		return 0x8225DB50;
	}
	return 0x8225DB50;
} // Block from 8225DAFCh-8225DB50h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8225DB50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DB50);
		  /* 8225DB50h */ case    0:  		/* mr R30, R29 */
		/* 8225DB50h case    0:*/		regs.R30 = regs.R29;
		/* 8225DB50h case    0:*/		return 0x8225DB54;
		  /* 8225DB54h */ case    1:  		/* lwz R29, <#[R29 + 8]> */
		/* 8225DB54h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8225DB54h case    1:*/		return 0x8225DB58;
	}
	return 0x8225DB58;
} // Block from 8225DB50h-8225DB58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225DB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DB58);
		  /* 8225DB58h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8225DB58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8225DB58h case    0:*/		return 0x8225DB5C;
		  /* 8225DB5Ch */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 8225DB5Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8225DB08;  }
		/* 8225DB5Ch case    1:*/		return 0x8225DB60;
		  /* 8225DB60h */ case    2:  		/* lwz R11, <#[R1 + 140]> */
		/* 8225DB60h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 8225DB60h case    2:*/		return 0x8225DB64;
		  /* 8225DB64h */ case    3:  		/* lwz R10, <#[R1 + 144]> */
		/* 8225DB64h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 8225DB64h case    3:*/		return 0x8225DB68;
		  /* 8225DB68h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225DB68h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225DB68h case    4:*/		return 0x8225DB6C;
		  /* 8225DB6Ch */ case    5:  		/* add R9, R11, R10 */
		/* 8225DB6Ch case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 8225DB6Ch case    5:*/		return 0x8225DB70;
		  /* 8225DB70h */ case    6:  		/* lwz R11, <#[R9]> */
		/* 8225DB70h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8225DB70h case    6:*/		return 0x8225DB74;
		  /* 8225DB74h */ case    7:  		/* addi R10, R11, -1 */
		/* 8225DB74h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8225DB74h case    7:*/		return 0x8225DB78;
		  /* 8225DB78h */ case    8:  		/* cmplwi CR6, R10, 87 */
		/* 8225DB78h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000057);
		/* 8225DB78h case    8:*/		return 0x8225DB7C;
		  /* 8225DB7Ch */ case    9:  		/* bc 12, CR6_GT, 16932 */
		/* 8225DB7Ch case    9:*/		if ( regs.CR[6].gt ) { return 0x82261DA0;  }
		/* 8225DB7Ch case    9:*/		return 0x8225DB80;
		  /* 8225DB80h */ case   10:  		/* lis R12, -32251 */
		/* 8225DB80h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8205);
		/* 8225DB80h case   10:*/		return 0x8225DB84;
		  /* 8225DB84h */ case   11:  		/* rlwinm R0, R10, 1, 0, 30 */
		/* 8225DB84h case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R10);
		/* 8225DB84h case   11:*/		return 0x8225DB88;
		  /* 8225DB88h */ case   12:  		/* addi R12, R12, -22144 */
		/* 8225DB88h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFA980);
		/* 8225DB88h case   12:*/		return 0x8225DB8C;
		  /* 8225DB8Ch */ case   13:  		/* lhzx R0, <#[R12 + R0]> */
		/* 8225DB8Ch case   13:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 8225DB8Ch case   13:*/		return 0x8225DB90;
		  /* 8225DB90h */ case   14:  		/* lis R12, -32218 */
		/* 8225DB90h case   14:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8226);
		/* 8225DB90h case   14:*/		return 0x8225DB94;
		  /* 8225DB94h */ case   15:  		/* addi R12, R12, -9304 */
		/* 8225DB94h case   15:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFDBA8);
		/* 8225DB94h case   15:*/		return 0x8225DB98;
		  /* 8225DB98h */ case   16:  		/* ori R0, R0, 0 */
		/* 8225DB98h case   16:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8225DB98h case   16:*/		return 0x8225DB9C;
		  /* 8225DB9Ch */ case   17:  		/* add R12, R12, R0 */
		/* 8225DB9Ch case   17:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 8225DB9Ch case   17:*/		return 0x8225DBA0;
		  /* 8225DBA0h */ case   18:  		/* mtspr CTR, R12 */
		/* 8225DBA0h case   18:*/		regs.CTR = regs.R12;
		/* 8225DBA0h case   18:*/		return 0x8225DBA4;
		  /* 8225DBA4h */ case   19:  		/* bcctr 20, CR0_LT */
		/* 8225DBA4h case   19:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8225DBA4h case   19:*/		return 0x8225DBA8;
		  /* 8225DBA8h */ case   20:  		/* lwz R28, <#[R1 + 176]> */
		/* 8225DBA8h case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B0) );
		/* 8225DBA8h case   20:*/		return 0x8225DBAC;
		  /* 8225DBACh */ case   21:  		/* lwz R10, <#[R1 + 260]> */
		/* 8225DBACh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 8225DBACh case   21:*/		return 0x8225DBB0;
		  /* 8225DBB0h */ case   22:  		/* lbz R25, <#[R28 + 1]> */
		/* 8225DBB0h case   22:*/		cpu::mem::load8z( regs, &regs.R25, (uint32)(regs.R28 + 0x00000001) );
		/* 8225DBB0h case   22:*/		return 0x8225DBB4;
		  /* 8225DBB4h */ case   23:  		/* rlwinm R11, R25, 27, 5, 31 */
		/* 8225DBB4h case   23:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R25);
		/* 8225DBB4h case   23:*/		return 0x8225DBB8;
		  /* 8225DBB8h */ case   24:  		/* rlwinm R9, R25, 0, 27, 31 */
		/* 8225DBB8h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R25);
		/* 8225DBB8h case   24:*/		return 0x8225DBBC;
		  /* 8225DBBCh */ case   25:  		/* addi R11, R11, 2 */
		/* 8225DBBCh case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8225DBBCh case   25:*/		return 0x8225DBC0;
		  /* 8225DBC0h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8225DBC0h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8225DBC0h case   26:*/		return 0x8225DBC4;
		  /* 8225DBC4h */ case   27:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8225DBC4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8225DBC4h case   27:*/		return 0x8225DBC8;
		  /* 8225DBC8h */ case   28:  		/* srw R11, R11, R9 */
		/* 8225DBC8h case   28:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8225DBC8h case   28:*/		return 0x8225DBCC;
		  /* 8225DBCCh */ case   29:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8225DBCCh case   29:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8225DBCCh case   29:*/		return 0x8225DBD0;
		  /* 8225DBD0h */ case   30:  		/* bc 4, CR0_EQ, 28 */
		/* 8225DBD0h case   30:*/		if ( !regs.CR[0].eq ) { return 0x8225DBEC;  }
		/* 8225DBD0h case   30:*/		return 0x8225DBD4;
		  /* 8225DBD4h */ case   31:  		/* li R7, 2263 */
		/* 8225DBD4h case   31:*/		cpu::op::li<0>(regs,&regs.R7,0x8D7);
		/* 8225DBD4h case   31:*/		return 0x8225DBD8;
		  /* 8225DBD8h */ case   32:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225DBD8h case   32:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225DBD8h case   32:*/		return 0x8225DBDC;
		  /* 8225DBDCh */ case   33:  		/* li R3, 0 */
		/* 8225DBDCh case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225DBDCh case   33:*/		return 0x8225DBE0;
		  /* 8225DBE0h */ case   34:  		/* lwz R5, <#[R1 + 480]> */
		/* 8225DBE0h case   34:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001E0) );
		/* 8225DBE0h case   34:*/		return 0x8225DBE4;
		  /* 8225DBE4h */ case   35:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225DBE4h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225DBE4h case   35:*/		return 0x8225DBE8;
		  /* 8225DBE8h */ case   36:  		/* bl -1073120 */
		/* 8225DBE8h case   36:*/		regs.LR = 0x8225DBEC; return 0x82157C08;
		/* 8225DBE8h case   36:*/		return 0x8225DBEC;
	}
	return 0x8225DBEC;
} // Block from 8225DB58h-8225DBECh (37 instructions)

//////////////////////////////////////////////////////
// Block at 8225DBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DBEC);
		  /* 8225DBECh */ case    0:  		/* lwz R11, <#[R1 + 204]> */
		/* 8225DBECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000CC) );
		/* 8225DBECh case    0:*/		return 0x8225DBF0;
		  /* 8225DBF0h */ case    1:  		/* li R29, 0 */
		/* 8225DBF0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8225DBF0h case    1:*/		return 0x8225DBF4;
		  /* 8225DBF4h */ case    2:  		/* mr R22, R29 */
		/* 8225DBF4h case    2:*/		regs.R22 = regs.R29;
		/* 8225DBF4h case    2:*/		return 0x8225DBF8;
		  /* 8225DBF8h */ case    3:  		/* cmpwi CR6, R11, 93 */
		/* 8225DBF8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005D);
		/* 8225DBF8h case    3:*/		return 0x8225DBFC;
		  /* 8225DBFCh */ case    4:  		/* bc 12, CR6_EQ, 92 */
		/* 8225DBFCh case    4:*/		if ( regs.CR[6].eq ) { return 0x8225DC58;  }
		/* 8225DBFCh case    4:*/		return 0x8225DC00;
		  /* 8225DC00h */ case    5:  		/* cmpwi CR6, R11, 94 */
		/* 8225DC00h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005E);
		/* 8225DC00h case    5:*/		return 0x8225DC04;
		  /* 8225DC04h */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 8225DC04h case    6:*/		if ( regs.CR[6].eq ) { return 0x8225DC54;  }
		/* 8225DC04h case    6:*/		return 0x8225DC08;
		  /* 8225DC08h */ case    7:  		/* cmpwi CR6, R11, 95 */
		/* 8225DC08h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 8225DC08h case    7:*/		return 0x8225DC0C;
		  /* 8225DC0Ch */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 8225DC0Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8225DC4C;  }
		/* 8225DC0Ch case    8:*/		return 0x8225DC10;
		  /* 8225DC10h */ case    9:  		/* cmpwi CR6, R11, 96 */
		/* 8225DC10h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000060);
		/* 8225DC10h case    9:*/		return 0x8225DC14;
		  /* 8225DC14h */ case   10:  		/* bc 12, CR6_EQ, 48 */
		/* 8225DC14h case   10:*/		if ( regs.CR[6].eq ) { return 0x8225DC44;  }
		/* 8225DC14h case   10:*/		return 0x8225DC18;
		  /* 8225DC18h */ case   11:  		/* cmpwi CR6, R11, 97 */
		/* 8225DC18h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 8225DC18h case   11:*/		return 0x8225DC1C;
		  /* 8225DC1Ch */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 8225DC1Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8225DC3C;  }
		/* 8225DC1Ch case   12:*/		return 0x8225DC20;
		  /* 8225DC20h */ case   13:  		/* li R7, 2293 */
		/* 8225DC20h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x8F5);
		/* 8225DC20h case   13:*/		return 0x8225DC24;
		  /* 8225DC24h */ case   14:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225DC24h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225DC24h case   14:*/		return 0x8225DC28;
		  /* 8225DC28h */ case   15:  		/* li R3, 0 */
		/* 8225DC28h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225DC28h case   15:*/		return 0x8225DC2C;
		  /* 8225DC2Ch */ case   16:  		/* lwz R5, <#[R1 + 196]> */
		/* 8225DC2Ch case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 8225DC2Ch case   16:*/		return 0x8225DC30;
		  /* 8225DC30h */ case   17:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225DC30h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225DC30h case   17:*/		return 0x8225DC34;
		  /* 8225DC34h */ case   18:  		/* bl -1073196 */
		/* 8225DC34h case   18:*/		regs.LR = 0x8225DC38; return 0x82157C08;
		/* 8225DC34h case   18:*/		return 0x8225DC38;
		  /* 8225DC38h */ case   19:  		/* b 32 */
		/* 8225DC38h case   19:*/		return 0x8225DC58;
		/* 8225DC38h case   19:*/		return 0x8225DC3C;
	}
	return 0x8225DC3C;
} // Block from 8225DBECh-8225DC3Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8225DC3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DC3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DC3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DC3C);
		  /* 8225DC3Ch */ case    0:  		/* li R22, 32 */
		/* 8225DC3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x20);
		/* 8225DC3Ch case    0:*/		return 0x8225DC40;
		  /* 8225DC40h */ case    1:  		/* b 24 */
		/* 8225DC40h case    1:*/		return 0x8225DC58;
		/* 8225DC40h case    1:*/		return 0x8225DC44;
	}
	return 0x8225DC44;
} // Block from 8225DC3Ch-8225DC44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225DC44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DC44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DC44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DC44);
		  /* 8225DC44h */ case    0:  		/* li R22, 18 */
		/* 8225DC44h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x12);
		/* 8225DC44h case    0:*/		return 0x8225DC48;
		  /* 8225DC48h */ case    1:  		/* b 16 */
		/* 8225DC48h case    1:*/		return 0x8225DC58;
		/* 8225DC48h case    1:*/		return 0x8225DC4C;
	}
	return 0x8225DC4C;
} // Block from 8225DC44h-8225DC4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225DC4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DC4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DC4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DC4C);
		  /* 8225DC4Ch */ case    0:  		/* li R22, 9 */
		/* 8225DC4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x9);
		/* 8225DC4Ch case    0:*/		return 0x8225DC50;
		  /* 8225DC50h */ case    1:  		/* b 8 */
		/* 8225DC50h case    1:*/		return 0x8225DC58;
		/* 8225DC50h case    1:*/		return 0x8225DC54;
	}
	return 0x8225DC54;
} // Block from 8225DC4Ch-8225DC54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225DC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DC54);
		  /* 8225DC54h */ case    0:  		/* li R22, 5 */
		/* 8225DC54h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x5);
		/* 8225DC54h case    0:*/		return 0x8225DC58;
	}
	return 0x8225DC58;
} // Block from 8225DC54h-8225DC58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225DC58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DC58);
		  /* 8225DC58h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225DC58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DC58h case    0:*/		return 0x8225DC5C;
		  /* 8225DC5Ch */ case    1:  		/* li R4, 30 */
		/* 8225DC5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1E);
		/* 8225DC5Ch case    1:*/		return 0x8225DC60;
		  /* 8225DC60h */ case    2:  		/* lwz R3, <#[R11 + 1452]> */
		/* 8225DC60h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005AC) );
		/* 8225DC60h case    2:*/		return 0x8225DC64;
		  /* 8225DC64h */ case    3:  		/* bl -268204 */
		/* 8225DC64h case    3:*/		regs.LR = 0x8225DC68; return 0x8221C4B8;
		/* 8225DC64h case    3:*/		return 0x8225DC68;
		  /* 8225DC68h */ case    4:  		/* li R5, 30 */
		/* 8225DC68h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1E);
		/* 8225DC68h case    4:*/		return 0x8225DC6C;
		  /* 8225DC6Ch */ case    5:  		/* li R4, 0 */
		/* 8225DC6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DC6Ch case    5:*/		return 0x8225DC70;
		  /* 8225DC70h */ case    6:  		/* mr R23, R3 */
		/* 8225DC70h case    6:*/		regs.R23 = regs.R3;
		/* 8225DC70h case    6:*/		return 0x8225DC74;
		  /* 8225DC74h */ case    7:  		/* bl -1886516 */
		/* 8225DC74h case    7:*/		regs.LR = 0x8225DC78; return 0x82091340;
		/* 8225DC74h case    7:*/		return 0x8225DC78;
		  /* 8225DC78h */ case    8:  		/* li R11, 3 */
		/* 8225DC78h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8225DC78h case    8:*/		return 0x8225DC7C;
		  /* 8225DC7Ch */ case    9:  		/* lwz R30, <#[R1 + 336]> */
		/* 8225DC7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000150) );
		/* 8225DC7Ch case    9:*/		return 0x8225DC80;
		  /* 8225DC80h */ case   10:  		/* li R10, 7 */
		/* 8225DC80h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 8225DC80h case   10:*/		return 0x8225DC84;
		  /* 8225DC84h */ case   11:  		/* li R27, 1 */
		/* 8225DC84h case   11:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8225DC84h case   11:*/		return 0x8225DC88;
		  /* 8225DC88h */ case   12:  		/* sth R11, <#[R23]> */
		/* 8225DC88h case   12:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8225DC88h case   12:*/		return 0x8225DC8C;
		  /* 8225DC8Ch */ case   13:  		/* sth R11, <#[R23 + 2]> */
		/* 8225DC8Ch case   13:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000002) );
		/* 8225DC8Ch case   13:*/		return 0x8225DC90;
		  /* 8225DC90h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 8225DC90h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8225DC90h case   14:*/		return 0x8225DC94;
		  /* 8225DC94h */ case   15:  		/* sth R11, <#[R23 + 4]> */
		/* 8225DC94h case   15:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8225DC94h case   15:*/		return 0x8225DC98;
		  /* 8225DC98h */ case   16:  		/* sth R10, <#[R23 + 6]> */
		/* 8225DC98h case   16:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R23 + 0x00000006) );
		/* 8225DC98h case   16:*/		return 0x8225DC9C;
		  /* 8225DC9Ch */ case   17:  		/* sth R10, <#[R23 + 8]> */
		/* 8225DC9Ch case   17:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 8225DC9Ch case   17:*/		return 0x8225DCA0;
		  /* 8225DCA0h */ case   18:  		/* sth R11, <#[R23 + 10]> */
		/* 8225DCA0h case   18:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000000A) );
		/* 8225DCA0h case   18:*/		return 0x8225DCA4;
		  /* 8225DCA4h */ case   19:  		/* sth R11, <#[R23 + 12]> */
		/* 8225DCA4h case   19:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8225DCA4h case   19:*/		return 0x8225DCA8;
		  /* 8225DCA8h */ case   20:  		/* sth R27, <#[R23 + 14]> */
		/* 8225DCA8h case   20:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R23 + 0x0000000E) );
		/* 8225DCA8h case   20:*/		return 0x8225DCAC;
		  /* 8225DCACh */ case   21:  		/* sth R29, <#[R23 + 16]> */
		/* 8225DCACh case   21:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R23 + 0x00000010) );
		/* 8225DCACh case   21:*/		return 0x8225DCB0;
		  /* 8225DCB0h */ case   22:  		/* sth R27, <#[R23 + 18]> */
		/* 8225DCB0h case   22:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R23 + 0x00000012) );
		/* 8225DCB0h case   22:*/		return 0x8225DCB4;
		  /* 8225DCB4h */ case   23:  		/* sth R29, <#[R23 + 22]> */
		/* 8225DCB4h case   23:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R23 + 0x00000016) );
		/* 8225DCB4h case   23:*/		return 0x8225DCB8;
		  /* 8225DCB8h */ case   24:  		/* sth R29, <#[R23 + 24]> */
		/* 8225DCB8h case   24:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R23 + 0x00000018) );
		/* 8225DCB8h case   24:*/		return 0x8225DCBC;
		  /* 8225DCBCh */ case   25:  		/* sth R29, <#[R23 + 26]> */
		/* 8225DCBCh case   25:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R23 + 0x0000001A) );
		/* 8225DCBCh case   25:*/		return 0x8225DCC0;
		  /* 8225DCC0h */ case   26:  		/* sth R29, <#[R23 + 28]> */
		/* 8225DCC0h case   26:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R23 + 0x0000001C) );
		/* 8225DCC0h case   26:*/		return 0x8225DCC4;
		  /* 8225DCC4h */ case   27:  		/* sth R29, <#[R23 + 20]> */
		/* 8225DCC4h case   27:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R23 + 0x00000014) );
		/* 8225DCC4h case   27:*/		return 0x8225DCC8;
		  /* 8225DCC8h */ case   28:  		/* bc 12, CR6_EQ, 136 */
		/* 8225DCC8h case   28:*/		if ( regs.CR[6].eq ) { return 0x8225DD50;  }
		/* 8225DCC8h case   28:*/		return 0x8225DCCC;
		  /* 8225DCCCh */ case   29:  		/* lwz R11, <#[R30]> */
		/* 8225DCCCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DCCCh case   29:*/		return 0x8225DCD0;
		  /* 8225DCD0h */ case   30:  		/* rlwinm R3, R11, 0, 29, 31 */
		/* 8225DCD0h case   30:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R11);
		/* 8225DCD0h case   30:*/		return 0x8225DCD4;
		  /* 8225DCD4h */ case   31:  		/* bl -13908 */
		/* 8225DCD4h case   31:*/		regs.LR = 0x8225DCD8; return 0x8225A680;
		/* 8225DCD4h case   31:*/		return 0x8225DCD8;
		  /* 8225DCD8h */ case   32:  		/* sth R3, <#[R23]> */
		/* 8225DCD8h case   32:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000000) );
		/* 8225DCD8h case   32:*/		return 0x8225DCDC;
		  /* 8225DCDCh */ case   33:  		/* lwz R11, <#[R30]> */
		/* 8225DCDCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DCDCh case   33:*/		return 0x8225DCE0;
		  /* 8225DCE0h */ case   34:  		/* rlwinm R3, R11, 29, 29, 31 */
		/* 8225DCE0h case   34:*/		cpu::op::rlwinm<0,29,29,31>(regs,&regs.R3,regs.R11);
		/* 8225DCE0h case   34:*/		return 0x8225DCE4;
		  /* 8225DCE4h */ case   35:  		/* bl -13924 */
		/* 8225DCE4h case   35:*/		regs.LR = 0x8225DCE8; return 0x8225A680;
		/* 8225DCE4h case   35:*/		return 0x8225DCE8;
		  /* 8225DCE8h */ case   36:  		/* sth R3, <#[R23 + 2]> */
		/* 8225DCE8h case   36:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000002) );
		/* 8225DCE8h case   36:*/		return 0x8225DCEC;
		  /* 8225DCECh */ case   37:  		/* lwz R11, <#[R30]> */
		/* 8225DCECh case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DCECh case   37:*/		return 0x8225DCF0;
		  /* 8225DCF0h */ case   38:  		/* rlwinm R3, R11, 20, 29, 31 */
		/* 8225DCF0h case   38:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R3,regs.R11);
		/* 8225DCF0h case   38:*/		return 0x8225DCF4;
		  /* 8225DCF4h */ case   39:  		/* bl -13940 */
		/* 8225DCF4h case   39:*/		regs.LR = 0x8225DCF8; return 0x8225A680;
		/* 8225DCF4h case   39:*/		return 0x8225DCF8;
		  /* 8225DCF8h */ case   40:  		/* sth R3, <#[R23 + 4]> */
		/* 8225DCF8h case   40:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000004) );
		/* 8225DCF8h case   40:*/		return 0x8225DCFC;
		  /* 8225DCFCh */ case   41:  		/* lwz R11, <#[R30]> */
		/* 8225DCFCh case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DCFCh case   41:*/		return 0x8225DD00;
		  /* 8225DD00h */ case   42:  		/* rlwinm R3, R11, 26, 29, 31 */
		/* 8225DD00h case   42:*/		cpu::op::rlwinm<0,26,29,31>(regs,&regs.R3,regs.R11);
		/* 8225DD00h case   42:*/		return 0x8225DD04;
		  /* 8225DD04h */ case   43:  		/* bl -13956 */
		/* 8225DD04h case   43:*/		regs.LR = 0x8225DD08; return 0x8225A680;
		/* 8225DD04h case   43:*/		return 0x8225DD08;
		  /* 8225DD08h */ case   44:  		/* sth R3, <#[R23 + 10]> */
		/* 8225DD08h case   44:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x0000000A) );
		/* 8225DD08h case   44:*/		return 0x8225DD0C;
		  /* 8225DD0Ch */ case   45:  		/* lwz R11, <#[R30]> */
		/* 8225DD0Ch case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DD0Ch case   45:*/		return 0x8225DD10;
		  /* 8225DD10h */ case   46:  		/* rlwinm R3, R11, 23, 29, 31 */
		/* 8225DD10h case   46:*/		cpu::op::rlwinm<0,23,29,31>(regs,&regs.R3,regs.R11);
		/* 8225DD10h case   46:*/		return 0x8225DD14;
		  /* 8225DD14h */ case   47:  		/* bl -13972 */
		/* 8225DD14h case   47:*/		regs.LR = 0x8225DD18; return 0x8225A680;
		/* 8225DD14h case   47:*/		return 0x8225DD18;
		  /* 8225DD18h */ case   48:  		/* sth R3, <#[R23 + 12]> */
		/* 8225DD18h case   48:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x0000000C) );
		/* 8225DD18h case   48:*/		return 0x8225DD1C;
		  /* 8225DD1Ch */ case   49:  		/* lwz R11, <#[R30]> */
		/* 8225DD1Ch case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DD1Ch case   49:*/		return 0x8225DD20;
		  /* 8225DD20h */ case   50:  		/* rlwinm R3, R11, 17, 29, 31 */
		/* 8225DD20h case   50:*/		cpu::op::rlwinm<0,17,29,31>(regs,&regs.R3,regs.R11);
		/* 8225DD20h case   50:*/		return 0x8225DD24;
		  /* 8225DD24h */ case   51:  		/* bl -13988 */
		/* 8225DD24h case   51:*/		regs.LR = 0x8225DD28; return 0x8225A680;
		/* 8225DD24h case   51:*/		return 0x8225DD28;
		  /* 8225DD28h */ case   52:  		/* sth R3, <#[R23 + 6]> */
		/* 8225DD28h case   52:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000006) );
		/* 8225DD28h case   52:*/		return 0x8225DD2C;
		  /* 8225DD2Ch */ case   53:  		/* rlwinm. R10, R22, 0, 29, 29 */
		/* 8225DD2Ch case   53:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R22);
		/* 8225DD2Ch case   53:*/		return 0x8225DD30;
		  /* 8225DD30h */ case   54:  		/* lwz R11, <#[R30]> */
		/* 8225DD30h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DD30h case   54:*/		return 0x8225DD34;
		  /* 8225DD34h */ case   55:  		/* rlwinm R11, R11, 14, 25, 31 */
		/* 8225DD34h case   55:*/		cpu::op::rlwinm<0,14,25,31>(regs,&regs.R11,regs.R11);
		/* 8225DD34h case   55:*/		return 0x8225DD38;
		  /* 8225DD38h */ case   56:  		/* sth R11, <#[R23 + 22]> */
		/* 8225DD38h case   56:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000016) );
		/* 8225DD38h case   56:*/		return 0x8225DD3C;
		  /* 8225DD3Ch */ case   57:  		/* bc 12, CR0_EQ, 20 */
		/* 8225DD3Ch case   57:*/		if ( regs.CR[0].eq ) { return 0x8225DD50;  }
		/* 8225DD3Ch case   57:*/		return 0x8225DD40;
		  /* 8225DD40h */ case   58:  		/* lwz R11, <#[R30]> */
		/* 8225DD40h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DD40h case   58:*/		return 0x8225DD44;
		  /* 8225DD44h */ case   59:  		/* rlwinm R11, R11, 7, 31, 31 */
		/* 8225DD44h case   59:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R11,regs.R11);
		/* 8225DD44h case   59:*/		return 0x8225DD48;
		  /* 8225DD48h */ case   60:  		/* addi R11, R11, 1 */
		/* 8225DD48h case   60:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8225DD48h case   60:*/		return 0x8225DD4C;
		  /* 8225DD4Ch */ case   61:  		/* sth R11, <#[R23 + 16]> */
		/* 8225DD4Ch case   61:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 8225DD4Ch case   61:*/		return 0x8225DD50;
	}
	return 0x8225DD50;
} // Block from 8225DC58h-8225DD50h (62 instructions)

//////////////////////////////////////////////////////
// Block at 8225DD50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DD50);
		  /* 8225DD50h */ case    0:  		/* lwz R30, <#[R1 + 264]> */
		/* 8225DD50h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000108) );
		/* 8225DD50h case    0:*/		return 0x8225DD54;
		  /* 8225DD54h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 8225DD54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8225DD54h case    1:*/		return 0x8225DD58;
		  /* 8225DD58h */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 8225DD58h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225DDCC;  }
		/* 8225DD58h case    2:*/		return 0x8225DD5C;
		  /* 8225DD5Ch */ case    3:  		/* lbz R11, <#[R30 + 3]> */
		/* 8225DD5Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000003) );
		/* 8225DD5Ch case    3:*/		return 0x8225DD60;
		  /* 8225DD60h */ case    4:  		/* rlwinm. R10, R22, 0, 30, 30 */
		/* 8225DD60h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R22);
		/* 8225DD60h case    4:*/		return 0x8225DD64;
		  /* 8225DD64h */ case    5:  		/* sth R11, <#[R23 + 24]> */
		/* 8225DD64h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8225DD64h case    5:*/		return 0x8225DD68;
		  /* 8225DD68h */ case    6:  		/* lbz R11, <#[R30 + 2]> */
		/* 8225DD68h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 8225DD68h case    6:*/		return 0x8225DD6C;
		  /* 8225DD6Ch */ case    7:  		/* sth R11, <#[R23 + 26]> */
		/* 8225DD6Ch case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000001A) );
		/* 8225DD6Ch case    7:*/		return 0x8225DD70;
		  /* 8225DD70h */ case    8:  		/* bc 12, CR0_EQ, 84 */
		/* 8225DD70h case    8:*/		if ( regs.CR[0].eq ) { return 0x8225DDC4;  }
		/* 8225DD70h case    8:*/		return 0x8225DD74;
		  /* 8225DD74h */ case    9:  		/* lwz R26, <#[R31 + 12]> */
		/* 8225DD74h case    9:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DD74h case    9:*/		return 0x8225DD78;
		  /* 8225DD78h */ case   10:  		/* lwz R3, <#[R26 + 1488]> */
		/* 8225DD78h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x000005D0) );
		/* 8225DD78h case   10:*/		return 0x8225DD7C;
		  /* 8225DD7Ch */ case   11:  		/* lwz R11, <#[R3]> */
		/* 8225DD7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225DD7Ch case   11:*/		return 0x8225DD80;
		  /* 8225DD80h */ case   12:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225DD80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225DD80h case   12:*/		return 0x8225DD84;
		  /* 8225DD84h */ case   13:  		/* mtspr CTR, R11 */
		/* 8225DD84h case   13:*/		regs.CTR = regs.R11;
		/* 8225DD84h case   13:*/		return 0x8225DD88;
		  /* 8225DD88h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8225DD88h case   14:*/		if ( 1 ) { regs.LR = 0x8225DD8C; return (uint32)regs.CTR; }
		/* 8225DD88h case   14:*/		return 0x8225DD8C;
		  /* 8225DD8Ch */ case   15:  		/* lis R11, -32222 */
		/* 8225DD8Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225DD8Ch case   15:*/		return 0x8225DD90;
		  /* 8225DD90h */ case   16:  		/* mr R5, R3 */
		/* 8225DD90h case   16:*/		regs.R5 = regs.R3;
		/* 8225DD90h case   16:*/		return 0x8225DD94;
		  /* 8225DD94h */ case   17:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225DD94h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225DD94h case   17:*/		return 0x8225DD98;
		  /* 8225DD98h */ case   18:  		/* mr R4, R25 */
		/* 8225DD98h case   18:*/		regs.R4 = regs.R25;
		/* 8225DD98h case   18:*/		return 0x8225DD9C;
		  /* 8225DD9Ch */ case   19:  		/* addi R6, R11, -12392 */
		/* 8225DD9Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225DD9Ch case   19:*/		return 0x8225DDA0;
		  /* 8225DDA0h */ case   20:  		/* mr R7, R26 */
		/* 8225DDA0h case   20:*/		regs.R7 = regs.R26;
		/* 8225DDA0h case   20:*/		return 0x8225DDA4;
		  /* 8225DDA4h */ case   21:  		/* bl -1122476 */
		/* 8225DDA4h case   21:*/		regs.LR = 0x8225DDA8; return 0x8214BCF8;
		/* 8225DDA4h case   21:*/		return 0x8225DDA8;
		  /* 8225DDA8h */ case   22:  		/* cmpwi CR6, R3, 1 */
		/* 8225DDA8h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225DDA8h case   22:*/		return 0x8225DDAC;
		  /* 8225DDACh */ case   23:  		/* bc 4, CR6_EQ, 16 */
		/* 8225DDACh case   23:*/		if ( !regs.CR[6].eq ) { return 0x8225DDBC;  }
		/* 8225DDACh case   23:*/		return 0x8225DDB0;
		  /* 8225DDB0h */ case   24:  		/* lbz R11, <#[R30]> */
		/* 8225DDB0h case   24:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225DDB0h case   24:*/		return 0x8225DDB4;
		  /* 8225DDB4h */ case   25:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8225DDB4h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8225DDB4h case   25:*/		return 0x8225DDB8;
		  /* 8225DDB8h */ case   26:  		/* b 16 */
		/* 8225DDB8h case   26:*/		return 0x8225DDC8;
		/* 8225DDB8h case   26:*/		return 0x8225DDBC;
	}
	return 0x8225DDBC;
} // Block from 8225DD50h-8225DDBCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 8225DDBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DDBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DDBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DDBC);
		  /* 8225DDBCh */ case    0:  		/* mr R11, R29 */
		/* 8225DDBCh case    0:*/		regs.R11 = regs.R29;
		/* 8225DDBCh case    0:*/		return 0x8225DDC0;
		  /* 8225DDC0h */ case    1:  		/* b 8 */
		/* 8225DDC0h case    1:*/		return 0x8225DDC8;
		/* 8225DDC0h case    1:*/		return 0x8225DDC4;
	}
	return 0x8225DDC4;
} // Block from 8225DDBCh-8225DDC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225DDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DDC4);
		  /* 8225DDC4h */ case    0:  		/* lbz R11, <#[R30 + 1]> */
		/* 8225DDC4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		/* 8225DDC4h case    0:*/		return 0x8225DDC8;
	}
	return 0x8225DDC8;
} // Block from 8225DDC4h-8225DDC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225DDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DDC8);
		  /* 8225DDC8h */ case    0:  		/* sth R11, <#[R23 + 28]> */
		/* 8225DDC8h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000001C) );
		/* 8225DDC8h case    0:*/		return 0x8225DDCC;
	}
	return 0x8225DDCC;
} // Block from 8225DDC8h-8225DDCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225DDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DDCC);
		  /* 8225DDCCh */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8225DDCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8225DDCCh case    0:*/		return 0x8225DDD0;
		  /* 8225DDD0h */ case    1:  		/* rlwinm. R16, R22, 0, 31, 31 */
		/* 8225DDD0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R16,regs.R22);
		/* 8225DDD0h case    1:*/		return 0x8225DDD4;
		  /* 8225DDD4h */ case    2:  		/* rlwinm R20, R11, 8, 31, 31 */
		/* 8225DDD4h case    2:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R20,regs.R11);
		/* 8225DDD4h case    2:*/		return 0x8225DDD8;
		  /* 8225DDD8h */ case    3:  		/* rlwinm R21, R11, 6, 30, 31 */
		/* 8225DDD8h case    3:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R21,regs.R11);
		/* 8225DDD8h case    3:*/		return 0x8225DDDC;
		  /* 8225DDDCh */ case    4:  		/* cntlzw R11, R20 */
		/* 8225DDDCh case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R20);
		/* 8225DDDCh case    4:*/		return 0x8225DDE0;
		  /* 8225DDE0h */ case    5:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8225DDE0h case    5:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8225DDE0h case    5:*/		return 0x8225DDE4;
		  /* 8225DDE4h */ case    6:  		/* sth R11, <#[R23 + 18]> */
		/* 8225DDE4h case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000012) );
		/* 8225DDE4h case    6:*/		return 0x8225DDE8;
		  /* 8225DDE8h */ case    7:  		/* lwz R11, <#[R28]> */
		/* 8225DDE8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8225DDE8h case    7:*/		return 0x8225DDEC;
		  /* 8225DDECh */ case    8:  		/* rlwinm R28, R11, 7, 31, 31 */
		/* 8225DDECh case    8:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R28,regs.R11);
		/* 8225DDECh case    8:*/		return 0x8225DDF0;
		  /* 8225DDF0h */ case    9:  		/* cntlzw R11, R28 */
		/* 8225DDF0h case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R28);
		/* 8225DDF0h case    9:*/		return 0x8225DDF4;
		  /* 8225DDF4h */ case   10:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8225DDF4h case   10:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8225DDF4h case   10:*/		return 0x8225DDF8;
		  /* 8225DDF8h */ case   11:  		/* sth R11, <#[R23 + 14]> */
		/* 8225DDF8h case   11:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000000E) );
		/* 8225DDF8h case   11:*/		return 0x8225DDFC;
		  /* 8225DDFCh */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 8225DDFCh case   12:*/		if ( regs.CR[0].eq ) { return 0x8225DE14;  }
		/* 8225DDFCh case   12:*/		return 0x8225DE00;
		  /* 8225DE00h */ case   13:  		/* rlwinm. R11, R22, 0, 28, 28 */
		/* 8225DE00h case   13:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R22);
		/* 8225DE00h case   13:*/		return 0x8225DE04;
		  /* 8225DE04h */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 8225DE04h case   14:*/		if ( regs.CR[0].eq ) { return 0x8225DE10;  }
		/* 8225DE04h case   14:*/		return 0x8225DE08;
		  /* 8225DE08h */ case   15:  		/* sth R27, <#[R23 + 20]> */
		/* 8225DE08h case   15:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R23 + 0x00000014) );
		/* 8225DE08h case   15:*/		return 0x8225DE0C;
		  /* 8225DE0Ch */ case   16:  		/* b 8 */
		/* 8225DE0Ch case   16:*/		return 0x8225DE14;
		/* 8225DE0Ch case   16:*/		return 0x8225DE10;
	}
	return 0x8225DE10;
} // Block from 8225DDCCh-8225DE10h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8225DE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DE10);
		  /* 8225DE10h */ case    0:  		/* sth R27, <#[R23 + 16]> */
		/* 8225DE10h case    0:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R23 + 0x00000010) );
		/* 8225DE10h case    0:*/		return 0x8225DE14;
	}
	return 0x8225DE14;
} // Block from 8225DE10h-8225DE14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225DE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DE14);
		  /* 8225DE14h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225DE14h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DE14h case    0:*/		return 0x8225DE18;
		  /* 8225DE18h */ case    1:  		/* li R4, 0 */
		/* 8225DE18h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DE18h case    1:*/		return 0x8225DE1C;
		  /* 8225DE1Ch */ case    2:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225DE1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225DE1Ch case    2:*/		return 0x8225DE20;
		  /* 8225DE20h */ case    3:  		/* addi R5, R11, -1 */
		/* 8225DE20h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225DE20h case    3:*/		return 0x8225DE24;
		  /* 8225DE24h */ case    4:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225DE24h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225DE24h case    4:*/		return 0x8225DE28;
		  /* 8225DE28h */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225DE28h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225DE28h case    5:*/		return 0x8225DE2C;
		  /* 8225DE2Ch */ case    6:  		/* bl -99868 */
		/* 8225DE2Ch case    6:*/		regs.LR = 0x8225DE30; return 0x82245810;
		/* 8225DE2Ch case    6:*/		return 0x8225DE30;
		  /* 8225DE30h */ case    7:  		/* lwz R9, <#[R31 + 12]> */
		/* 8225DE30h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DE30h case    7:*/		return 0x8225DE34;
		  /* 8225DE34h */ case    8:  		/* li R4, 0 */
		/* 8225DE34h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DE34h case    8:*/		return 0x8225DE38;
		  /* 8225DE38h */ case    9:  		/* lwz R10, <#[R1 + 136]> */
		/* 8225DE38h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 8225DE38h case    9:*/		return 0x8225DE3C;
		  /* 8225DE3Ch */ case   10:  		/* mr R18, R3 */
		/* 8225DE3Ch case   10:*/		regs.R18 = regs.R3;
		/* 8225DE3Ch case   10:*/		return 0x8225DE40;
		  /* 8225DE40h */ case   11:  		/* lwz R11, <#[R9 + 1508]> */
		/* 8225DE40h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x000005E4) );
		/* 8225DE40h case   11:*/		return 0x8225DE44;
		  /* 8225DE44h */ case   12:  		/* lwz R30, <#[R10 - 1312]> */
		/* 8225DE44h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0xFFFFFAE0) );
		/* 8225DE44h case   12:*/		return 0x8225DE48;
		  /* 8225DE48h */ case   13:  		/* addi R5, R11, -1 */
		/* 8225DE48h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225DE48h case   13:*/		return 0x8225DE4C;
		  /* 8225DE4Ch */ case   14:  		/* lwz R10, <#[R10 - 1320]> */
		/* 8225DE4Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFAD8) );
		/* 8225DE4Ch case   14:*/		return 0x8225DE50;
		  /* 8225DE50h */ case   15:  		/* stw R5, <#[R9 + 1508]> */
		/* 8225DE50h case   15:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + 0x000005E4) );
		/* 8225DE50h case   15:*/		return 0x8225DE54;
		  /* 8225DE54h */ case   16:  		/* stw R30, <#[R1 + 236]> */
		/* 8225DE54h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x000000EC) );
		/* 8225DE54h case   16:*/		return 0x8225DE58;
		  /* 8225DE58h */ case   17:  		/* stw R10, <#[R1 + 152]> */
		/* 8225DE58h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000098) );
		/* 8225DE58h case   17:*/		return 0x8225DE5C;
		  /* 8225DE5Ch */ case   18:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225DE5Ch case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225DE5Ch case   18:*/		return 0x8225DE60;
		  /* 8225DE60h */ case   19:  		/* bl -99920 */
		/* 8225DE60h case   19:*/		regs.LR = 0x8225DE64; return 0x82245810;
		/* 8225DE60h case   19:*/		return 0x8225DE64;
		  /* 8225DE64h */ case   20:  		/* mr R19, R3 */
		/* 8225DE64h case   20:*/		regs.R19 = regs.R3;
		/* 8225DE64h case   20:*/		return 0x8225DE68;
		  /* 8225DE68h */ case   21:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225DE68h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DE68h case   21:*/		return 0x8225DE6C;
		  /* 8225DE6Ch */ case   22:  		/* li R3, 49 */
		/* 8225DE6Ch case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225DE6Ch case   22:*/		return 0x8225DE70;
		  /* 8225DE70h */ case   23:  		/* bl -32576 */
		/* 8225DE70h case   23:*/		regs.LR = 0x8225DE74; return 0x82255F30;
		/* 8225DE70h case   23:*/		return 0x8225DE74;
		  /* 8225DE74h */ case   24:  		/* mr R5, R19 */
		/* 8225DE74h case   24:*/		regs.R5 = regs.R19;
		/* 8225DE74h case   24:*/		return 0x8225DE78;
		  /* 8225DE78h */ case   25:  		/* li R4, 0 */
		/* 8225DE78h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DE78h case   25:*/		return 0x8225DE7C;
		  /* 8225DE7Ch */ case   26:  		/* mr R15, R3 */
		/* 8225DE7Ch case   26:*/		regs.R15 = regs.R3;
		/* 8225DE7Ch case   26:*/		return 0x8225DE80;
		  /* 8225DE80h */ case   27:  		/* bl -31464 */
		/* 8225DE80h case   27:*/		regs.LR = 0x8225DE84; return 0x82256398;
		/* 8225DE80h case   27:*/		return 0x8225DE84;
		  /* 8225DE84h */ case   28:  		/* lwz R17, <#[R1 + 228]> */
		/* 8225DE84h case   28:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x000000E4) );
		/* 8225DE84h case   28:*/		return 0x8225DE88;
		  /* 8225DE88h */ case   29:  		/* lwz R29, <#[R1 + 164]> */
		/* 8225DE88h case   29:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000A4) );
		/* 8225DE88h case   29:*/		return 0x8225DE8C;
		  /* 8225DE8Ch */ case   30:  		/* addi R11, R1, 152 */
		/* 8225DE8Ch case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x98);
		/* 8225DE8Ch case   30:*/		return 0x8225DE90;
		  /* 8225DE90h */ case   31:  		/* lwz R26, <#[R1 + 180]> */
		/* 8225DE90h case   31:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000B4) );
		/* 8225DE90h case   31:*/		return 0x8225DE94;
		  /* 8225DE94h */ case   32:  		/* mr R8, R15 */
		/* 8225DE94h case   32:*/		regs.R8 = regs.R15;
		/* 8225DE94h case   32:*/		return 0x8225DE98;
		  /* 8225DE98h */ case   33:  		/* lwz R24, <#[R1 + 224]> */
		/* 8225DE98h case   33:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x000000E0) );
		/* 8225DE98h case   33:*/		return 0x8225DE9C;
		  /* 8225DE9Ch */ case   34:  		/* mr R10, R30 */
		/* 8225DE9Ch case   34:*/		regs.R10 = regs.R30;
		/* 8225DE9Ch case   34:*/		return 0x8225DEA0;
		  /* 8225DEA0h */ case   35:  		/* li R9, 1 */
		/* 8225DEA0h case   35:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225DEA0h case   35:*/		return 0x8225DEA4;
		  /* 8225DEA4h */ case   36:  		/* stw R14, <#[R1 + 116]> */
		/* 8225DEA4h case   36:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000074) );
		/* 8225DEA4h case   36:*/		return 0x8225DEA8;
		  /* 8225DEA8h */ case   37:  		/* mr R7, R26 */
		/* 8225DEA8h case   37:*/		regs.R7 = regs.R26;
		/* 8225DEA8h case   37:*/		return 0x8225DEAC;
		  /* 8225DEACh */ case   38:  		/* stw R17, <#[R1 + 108]> */
		/* 8225DEACh case   38:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x0000006C) );
		/* 8225DEACh case   38:*/		return 0x8225DEB0;
		  /* 8225DEB0h */ case   39:  		/* mr R6, R24 */
		/* 8225DEB0h case   39:*/		regs.R6 = regs.R24;
		/* 8225DEB0h case   39:*/		return 0x8225DEB4;
		  /* 8225DEB4h */ case   40:  		/* stb R27, <#[R1 + 103]> */
		/* 8225DEB4h case   40:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x00000067) );
		/* 8225DEB4h case   40:*/		return 0x8225DEB8;
		  /* 8225DEB8h */ case   41:  		/* li R5, 1 */
		/* 8225DEB8h case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225DEB8h case   41:*/		return 0x8225DEBC;
		  /* 8225DEBCh */ case   42:  		/* stw R29, <#[R1 + 92]> */
		/* 8225DEBCh case   42:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225DEBCh case   42:*/		return 0x8225DEC0;
		  /* 8225DEC0h */ case   43:  		/* li R4, 4 */
		/* 8225DEC0h case   43:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8225DEC0h case   43:*/		return 0x8225DEC4;
		  /* 8225DEC4h */ case   44:  		/* stw R11, <#[R1 + 84]> */
		/* 8225DEC4h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225DEC4h case   44:*/		return 0x8225DEC8;
		  /* 8225DEC8h */ case   45:  		/* mr R3, R31 */
		/* 8225DEC8h case   45:*/		regs.R3 = regs.R31;
		/* 8225DEC8h case   45:*/		return 0x8225DECC;
		  /* 8225DECCh */ case   46:  		/* bl -4348 */
		/* 8225DECCh case   46:*/		regs.LR = 0x8225DED0; return 0x8225CDD0;
		/* 8225DECCh case   46:*/		return 0x8225DED0;
		  /* 8225DED0h */ case   47:  		/* mr R4, R15 */
		/* 8225DED0h case   47:*/		regs.R4 = regs.R15;
		/* 8225DED0h case   47:*/		return 0x8225DED4;
		  /* 8225DED4h */ case   48:  		/* mr R3, R31 */
		/* 8225DED4h case   48:*/		regs.R3 = regs.R31;
		/* 8225DED4h case   48:*/		return 0x8225DED8;
		  /* 8225DED8h */ case   49:  		/* bl -162096 */
		/* 8225DED8h case   49:*/		regs.LR = 0x8225DEDC; return 0x822365A8;
		/* 8225DED8h case   49:*/		return 0x8225DEDC;
		  /* 8225DEDCh */ case   50:  		/* mr R4, R15 */
		/* 8225DEDCh case   50:*/		regs.R4 = regs.R15;
		/* 8225DEDCh case   50:*/		return 0x8225DEE0;
		  /* 8225DEE0h */ case   51:  		/* mr R3, R14 */
		/* 8225DEE0h case   51:*/		regs.R3 = regs.R14;
		/* 8225DEE0h case   51:*/		return 0x8225DEE4;
		  /* 8225DEE4h */ case   52:  		/* bl -20404 */
		/* 8225DEE4h case   52:*/		regs.LR = 0x8225DEE8; return 0x82258F30;
		/* 8225DEE4h case   52:*/		return 0x8225DEE8;
		  /* 8225DEE8h */ case   53:  		/* mr R3, R15 */
		/* 8225DEE8h case   53:*/		regs.R3 = regs.R15;
		/* 8225DEE8h case   53:*/		return 0x8225DEEC;
		  /* 8225DEECh */ case   54:  		/* bl -32556 */
		/* 8225DEECh case   54:*/		regs.LR = 0x8225DEF0; return 0x82255FC0;
		/* 8225DEECh case   54:*/		return 0x8225DEF0;
		  /* 8225DEF0h */ case   55:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225DEF0h case   55:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225DEF0h case   55:*/		return 0x8225DEF4;
		  /* 8225DEF4h */ case   56:  		/* bc 4, CR0_EQ, 28 */
		/* 8225DEF4h case   56:*/		if ( !regs.CR[0].eq ) { return 0x8225DF10;  }
		/* 8225DEF4h case   56:*/		return 0x8225DEF8;
		  /* 8225DEF8h */ case   57:  		/* li R7, 2397 */
		/* 8225DEF8h case   57:*/		cpu::op::li<0>(regs,&regs.R7,0x95D);
		/* 8225DEF8h case   57:*/		return 0x8225DEFC;
		  /* 8225DEFCh */ case   58:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225DEFCh case   58:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225DEFCh case   58:*/		return 0x8225DF00;
		  /* 8225DF00h */ case   59:  		/* li R3, 0 */
		/* 8225DF00h case   59:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225DF00h case   59:*/		return 0x8225DF04;
		  /* 8225DF04h */ case   60:  		/* lwz R5, <#[R1 + 184]> */
		/* 8225DF04h case   60:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225DF04h case   60:*/		return 0x8225DF08;
		  /* 8225DF08h */ case   61:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225DF08h case   61:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225DF08h case   61:*/		return 0x8225DF0C;
		  /* 8225DF0Ch */ case   62:  		/* bl -1073924 */
		/* 8225DF0Ch case   62:*/		regs.LR = 0x8225DF10; return 0x82157C08;
		/* 8225DF0Ch case   62:*/		return 0x8225DF10;
	}
	return 0x8225DF10;
} // Block from 8225DE14h-8225DF10h (63 instructions)

//////////////////////////////////////////////////////
// Block at 8225DF10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DF10);
		  /* 8225DF10h */ case    0:  		/* li R27, 0 */
		/* 8225DF10h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8225DF10h case    0:*/		return 0x8225DF14;
		  /* 8225DF14h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225DF14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225DF14h case    1:*/		return 0x8225DF18;
		  /* 8225DF18h */ case    2:  		/* bc 12, CR6_EQ, 192 */
		/* 8225DF18h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225DFD8;  }
		/* 8225DF18h case    2:*/		return 0x8225DF1C;
		  /* 8225DF1Ch */ case    3:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225DF1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DF1Ch case    3:*/		return 0x8225DF20;
		  /* 8225DF20h */ case    4:  		/* li R4, 0 */
		/* 8225DF20h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DF20h case    4:*/		return 0x8225DF24;
		  /* 8225DF24h */ case    5:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225DF24h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225DF24h case    5:*/		return 0x8225DF28;
		  /* 8225DF28h */ case    6:  		/* addi R5, R11, -1 */
		/* 8225DF28h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225DF28h case    6:*/		return 0x8225DF2C;
		  /* 8225DF2Ch */ case    7:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225DF2Ch case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225DF2Ch case    7:*/		return 0x8225DF30;
		  /* 8225DF30h */ case    8:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225DF30h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225DF30h case    8:*/		return 0x8225DF34;
		  /* 8225DF34h */ case    9:  		/* bl -100132 */
		/* 8225DF34h case    9:*/		regs.LR = 0x8225DF38; return 0x82245810;
		/* 8225DF34h case    9:*/		return 0x8225DF38;
		  /* 8225DF38h */ case   10:  		/* mr R27, R3 */
		/* 8225DF38h case   10:*/		regs.R27 = regs.R3;
		/* 8225DF38h case   10:*/		return 0x8225DF3C;
		  /* 8225DF3Ch */ case   11:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225DF3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DF3Ch case   11:*/		return 0x8225DF40;
		  /* 8225DF40h */ case   12:  		/* li R3, 49 */
		/* 8225DF40h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225DF40h case   12:*/		return 0x8225DF44;
		  /* 8225DF44h */ case   13:  		/* bl -32788 */
		/* 8225DF44h case   13:*/		regs.LR = 0x8225DF48; return 0x82255F30;
		/* 8225DF44h case   13:*/		return 0x8225DF48;
		  /* 8225DF48h */ case   14:  		/* mr R5, R27 */
		/* 8225DF48h case   14:*/		regs.R5 = regs.R27;
		/* 8225DF48h case   14:*/		return 0x8225DF4C;
		  /* 8225DF4Ch */ case   15:  		/* li R4, 0 */
		/* 8225DF4Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DF4Ch case   15:*/		return 0x8225DF50;
		  /* 8225DF50h */ case   16:  		/* mr R15, R3 */
		/* 8225DF50h case   16:*/		regs.R15 = regs.R3;
		/* 8225DF50h case   16:*/		return 0x8225DF54;
		  /* 8225DF54h */ case   17:  		/* bl -31676 */
		/* 8225DF54h case   17:*/		regs.LR = 0x8225DF58; return 0x82256398;
		/* 8225DF54h case   17:*/		return 0x8225DF58;
		  /* 8225DF58h */ case   18:  		/* li R7, 1 */
		/* 8225DF58h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8225DF58h case   18:*/		return 0x8225DF5C;
		  /* 8225DF5Ch */ case   19:  		/* stw R17, <#[R1 + 108]> */
		/* 8225DF5Ch case   19:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x0000006C) );
		/* 8225DF5Ch case   19:*/		return 0x8225DF60;
		  /* 8225DF60h */ case   20:  		/* addi R11, R1, 152 */
		/* 8225DF60h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x98);
		/* 8225DF60h case   20:*/		return 0x8225DF64;
		  /* 8225DF64h */ case   21:  		/* stb R7, <#[R1 + 103]> */
		/* 8225DF64h case   21:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000067) );
		/* 8225DF64h case   21:*/		return 0x8225DF68;
		  /* 8225DF68h */ case   22:  		/* mr R8, R15 */
		/* 8225DF68h case   22:*/		regs.R8 = regs.R15;
		/* 8225DF68h case   22:*/		return 0x8225DF6C;
		  /* 8225DF6Ch */ case   23:  		/* stw R29, <#[R1 + 92]> */
		/* 8225DF6Ch case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225DF6Ch case   23:*/		return 0x8225DF70;
		  /* 8225DF70h */ case   24:  		/* mr R10, R30 */
		/* 8225DF70h case   24:*/		regs.R10 = regs.R30;
		/* 8225DF70h case   24:*/		return 0x8225DF74;
		  /* 8225DF74h */ case   25:  		/* li R9, 1 */
		/* 8225DF74h case   25:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225DF74h case   25:*/		return 0x8225DF78;
		  /* 8225DF78h */ case   26:  		/* stw R14, <#[R1 + 116]> */
		/* 8225DF78h case   26:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000074) );
		/* 8225DF78h case   26:*/		return 0x8225DF7C;
		  /* 8225DF7Ch */ case   27:  		/* mr R7, R26 */
		/* 8225DF7Ch case   27:*/		regs.R7 = regs.R26;
		/* 8225DF7Ch case   27:*/		return 0x8225DF80;
		  /* 8225DF80h */ case   28:  		/* stw R11, <#[R1 + 84]> */
		/* 8225DF80h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225DF80h case   28:*/		return 0x8225DF84;
		  /* 8225DF84h */ case   29:  		/* mr R6, R24 */
		/* 8225DF84h case   29:*/		regs.R6 = regs.R24;
		/* 8225DF84h case   29:*/		return 0x8225DF88;
		  /* 8225DF88h */ case   30:  		/* li R5, 1 */
		/* 8225DF88h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225DF88h case   30:*/		return 0x8225DF8C;
		  /* 8225DF8Ch */ case   31:  		/* li R4, 9 */
		/* 8225DF8Ch case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x9);
		/* 8225DF8Ch case   31:*/		return 0x8225DF90;
		  /* 8225DF90h */ case   32:  		/* mr R3, R31 */
		/* 8225DF90h case   32:*/		regs.R3 = regs.R31;
		/* 8225DF90h case   32:*/		return 0x8225DF94;
		  /* 8225DF94h */ case   33:  		/* bl -4548 */
		/* 8225DF94h case   33:*/		regs.LR = 0x8225DF98; return 0x8225CDD0;
		/* 8225DF94h case   33:*/		return 0x8225DF98;
		  /* 8225DF98h */ case   34:  		/* mr R4, R15 */
		/* 8225DF98h case   34:*/		regs.R4 = regs.R15;
		/* 8225DF98h case   34:*/		return 0x8225DF9C;
		  /* 8225DF9Ch */ case   35:  		/* mr R3, R31 */
		/* 8225DF9Ch case   35:*/		regs.R3 = regs.R31;
		/* 8225DF9Ch case   35:*/		return 0x8225DFA0;
		  /* 8225DFA0h */ case   36:  		/* bl -162296 */
		/* 8225DFA0h case   36:*/		regs.LR = 0x8225DFA4; return 0x822365A8;
		/* 8225DFA0h case   36:*/		return 0x8225DFA4;
		  /* 8225DFA4h */ case   37:  		/* mr R4, R15 */
		/* 8225DFA4h case   37:*/		regs.R4 = regs.R15;
		/* 8225DFA4h case   37:*/		return 0x8225DFA8;
		  /* 8225DFA8h */ case   38:  		/* mr R3, R14 */
		/* 8225DFA8h case   38:*/		regs.R3 = regs.R14;
		/* 8225DFA8h case   38:*/		return 0x8225DFAC;
		  /* 8225DFACh */ case   39:  		/* bl -20604 */
		/* 8225DFACh case   39:*/		regs.LR = 0x8225DFB0; return 0x82258F30;
		/* 8225DFACh case   39:*/		return 0x8225DFB0;
		  /* 8225DFB0h */ case   40:  		/* mr R3, R15 */
		/* 8225DFB0h case   40:*/		regs.R3 = regs.R15;
		/* 8225DFB0h case   40:*/		return 0x8225DFB4;
		  /* 8225DFB4h */ case   41:  		/* bl -32756 */
		/* 8225DFB4h case   41:*/		regs.LR = 0x8225DFB8; return 0x82255FC0;
		/* 8225DFB4h case   41:*/		return 0x8225DFB8;
		  /* 8225DFB8h */ case   42:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225DFB8h case   42:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225DFB8h case   42:*/		return 0x8225DFBC;
		  /* 8225DFBCh */ case   43:  		/* bc 4, CR0_EQ, 28 */
		/* 8225DFBCh case   43:*/		if ( !regs.CR[0].eq ) { return 0x8225DFD8;  }
		/* 8225DFBCh case   43:*/		return 0x8225DFC0;
		  /* 8225DFC0h */ case   44:  		/* li R7, 2413 */
		/* 8225DFC0h case   44:*/		cpu::op::li<0>(regs,&regs.R7,0x96D);
		/* 8225DFC0h case   44:*/		return 0x8225DFC4;
		  /* 8225DFC4h */ case   45:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225DFC4h case   45:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225DFC4h case   45:*/		return 0x8225DFC8;
		  /* 8225DFC8h */ case   46:  		/* li R3, 0 */
		/* 8225DFC8h case   46:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225DFC8h case   46:*/		return 0x8225DFCC;
		  /* 8225DFCCh */ case   47:  		/* lwz R5, <#[R1 + 184]> */
		/* 8225DFCCh case   47:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225DFCCh case   47:*/		return 0x8225DFD0;
		  /* 8225DFD0h */ case   48:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225DFD0h case   48:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225DFD0h case   48:*/		return 0x8225DFD4;
		  /* 8225DFD4h */ case   49:  		/* bl -1074124 */
		/* 8225DFD4h case   49:*/		regs.LR = 0x8225DFD8; return 0x82157C08;
		/* 8225DFD4h case   49:*/		return 0x8225DFD8;
	}
	return 0x8225DFD8;
} // Block from 8225DF10h-8225DFD8h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8225DFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225DFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225DFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225DFD8);
		  /* 8225DFD8h */ case    0:  		/* rlwinm. R24, R22, 0, 28, 28 */
		/* 8225DFD8h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R24,regs.R22);
		/* 8225DFD8h case    0:*/		return 0x8225DFDC;
		  /* 8225DFDCh */ case    1:  		/* li R26, 0 */
		/* 8225DFDCh case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8225DFDCh case    1:*/		return 0x8225DFE0;
		  /* 8225DFE0h */ case    2:  		/* bc 12, CR0_EQ, 192 */
		/* 8225DFE0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8225E0A0;  }
		/* 8225DFE0h case    2:*/		return 0x8225DFE4;
		  /* 8225DFE4h */ case    3:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225DFE4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225DFE4h case    3:*/		return 0x8225DFE8;
		  /* 8225DFE8h */ case    4:  		/* li R4, 0 */
		/* 8225DFE8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225DFE8h case    4:*/		return 0x8225DFEC;
		  /* 8225DFECh */ case    5:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225DFECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225DFECh case    5:*/		return 0x8225DFF0;
		  /* 8225DFF0h */ case    6:  		/* addi R5, R11, -1 */
		/* 8225DFF0h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225DFF0h case    6:*/		return 0x8225DFF4;
		  /* 8225DFF4h */ case    7:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225DFF4h case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225DFF4h case    7:*/		return 0x8225DFF8;
		  /* 8225DFF8h */ case    8:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225DFF8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225DFF8h case    8:*/		return 0x8225DFFC;
		  /* 8225DFFCh */ case    9:  		/* bl -100332 */
		/* 8225DFFCh case    9:*/		regs.LR = 0x8225E000; return 0x82245810;
		/* 8225DFFCh case    9:*/		return 0x8225E000;
		  /* 8225E000h */ case   10:  		/* mr R26, R3 */
		/* 8225E000h case   10:*/		regs.R26 = regs.R3;
		/* 8225E000h case   10:*/		return 0x8225E004;
		  /* 8225E004h */ case   11:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E004h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E004h case   11:*/		return 0x8225E008;
		  /* 8225E008h */ case   12:  		/* li R3, 49 */
		/* 8225E008h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225E008h case   12:*/		return 0x8225E00C;
		  /* 8225E00Ch */ case   13:  		/* bl -32988 */
		/* 8225E00Ch case   13:*/		regs.LR = 0x8225E010; return 0x82255F30;
		/* 8225E00Ch case   13:*/		return 0x8225E010;
		  /* 8225E010h */ case   14:  		/* mr R5, R26 */
		/* 8225E010h case   14:*/		regs.R5 = regs.R26;
		/* 8225E010h case   14:*/		return 0x8225E014;
		  /* 8225E014h */ case   15:  		/* li R4, 0 */
		/* 8225E014h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E014h case   15:*/		return 0x8225E018;
		  /* 8225E018h */ case   16:  		/* mr R15, R3 */
		/* 8225E018h case   16:*/		regs.R15 = regs.R3;
		/* 8225E018h case   16:*/		return 0x8225E01C;
		  /* 8225E01Ch */ case   17:  		/* bl -31876 */
		/* 8225E01Ch case   17:*/		regs.LR = 0x8225E020; return 0x82256398;
		/* 8225E01Ch case   17:*/		return 0x8225E020;
		  /* 8225E020h */ case   18:  		/* addi R11, R1, 152 */
		/* 8225E020h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x98);
		/* 8225E020h case   18:*/		return 0x8225E024;
		  /* 8225E024h */ case   19:  		/* li R3, 1 */
		/* 8225E024h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8225E024h case   19:*/		return 0x8225E028;
		  /* 8225E028h */ case   20:  		/* stw R17, <#[R1 + 108]> */
		/* 8225E028h case   20:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x0000006C) );
		/* 8225E028h case   20:*/		return 0x8225E02C;
		  /* 8225E02Ch */ case   21:  		/* stw R29, <#[R1 + 92]> */
		/* 8225E02Ch case   21:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8225E02Ch case   21:*/		return 0x8225E030;
		  /* 8225E030h */ case   22:  		/* mr R8, R15 */
		/* 8225E030h case   22:*/		regs.R8 = regs.R15;
		/* 8225E030h case   22:*/		return 0x8225E034;
		  /* 8225E034h */ case   23:  		/* stb R3, <#[R1 + 103]> */
		/* 8225E034h case   23:*/		cpu::mem::store8( regs, regs.R3, (uint32)(regs.R1 + 0x00000067) );
		/* 8225E034h case   23:*/		return 0x8225E038;
		  /* 8225E038h */ case   24:  		/* mr R10, R30 */
		/* 8225E038h case   24:*/		regs.R10 = regs.R30;
		/* 8225E038h case   24:*/		return 0x8225E03C;
		  /* 8225E03Ch */ case   25:  		/* stw R11, <#[R1 + 84]> */
		/* 8225E03Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8225E03Ch case   25:*/		return 0x8225E040;
		  /* 8225E040h */ case   26:  		/* li R9, 1 */
		/* 8225E040h case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8225E040h case   26:*/		return 0x8225E044;
		  /* 8225E044h */ case   27:  		/* li R5, 1 */
		/* 8225E044h case   27:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225E044h case   27:*/		return 0x8225E048;
		  /* 8225E048h */ case   28:  		/* lwz R7, <#[R1 + 180]> */
		/* 8225E048h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000B4) );
		/* 8225E048h case   28:*/		return 0x8225E04C;
		  /* 8225E04Ch */ case   29:  		/* li R4, 13 */
		/* 8225E04Ch case   29:*/		cpu::op::li<0>(regs,&regs.R4,0xD);
		/* 8225E04Ch case   29:*/		return 0x8225E050;
		  /* 8225E050h */ case   30:  		/* lwz R6, <#[R1 + 224]> */
		/* 8225E050h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000E0) );
		/* 8225E050h case   30:*/		return 0x8225E054;
		  /* 8225E054h */ case   31:  		/* mr R3, R31 */
		/* 8225E054h case   31:*/		regs.R3 = regs.R31;
		/* 8225E054h case   31:*/		return 0x8225E058;
		  /* 8225E058h */ case   32:  		/* stw R14, <#[R1 + 116]> */
		/* 8225E058h case   32:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000074) );
		/* 8225E058h case   32:*/		return 0x8225E05C;
		  /* 8225E05Ch */ case   33:  		/* bl -4748 */
		/* 8225E05Ch case   33:*/		regs.LR = 0x8225E060; return 0x8225CDD0;
		/* 8225E05Ch case   33:*/		return 0x8225E060;
		  /* 8225E060h */ case   34:  		/* mr R4, R15 */
		/* 8225E060h case   34:*/		regs.R4 = regs.R15;
		/* 8225E060h case   34:*/		return 0x8225E064;
		  /* 8225E064h */ case   35:  		/* mr R3, R31 */
		/* 8225E064h case   35:*/		regs.R3 = regs.R31;
		/* 8225E064h case   35:*/		return 0x8225E068;
		  /* 8225E068h */ case   36:  		/* bl -162496 */
		/* 8225E068h case   36:*/		regs.LR = 0x8225E06C; return 0x822365A8;
		/* 8225E068h case   36:*/		return 0x8225E06C;
		  /* 8225E06Ch */ case   37:  		/* mr R4, R15 */
		/* 8225E06Ch case   37:*/		regs.R4 = regs.R15;
		/* 8225E06Ch case   37:*/		return 0x8225E070;
		  /* 8225E070h */ case   38:  		/* mr R3, R14 */
		/* 8225E070h case   38:*/		regs.R3 = regs.R14;
		/* 8225E070h case   38:*/		return 0x8225E074;
		  /* 8225E074h */ case   39:  		/* bl -20804 */
		/* 8225E074h case   39:*/		regs.LR = 0x8225E078; return 0x82258F30;
		/* 8225E074h case   39:*/		return 0x8225E078;
		  /* 8225E078h */ case   40:  		/* mr R3, R15 */
		/* 8225E078h case   40:*/		regs.R3 = regs.R15;
		/* 8225E078h case   40:*/		return 0x8225E07C;
		  /* 8225E07Ch */ case   41:  		/* bl -32956 */
		/* 8225E07Ch case   41:*/		regs.LR = 0x8225E080; return 0x82255FC0;
		/* 8225E07Ch case   41:*/		return 0x8225E080;
		  /* 8225E080h */ case   42:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E080h case   42:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E080h case   42:*/		return 0x8225E084;
		  /* 8225E084h */ case   43:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E084h case   43:*/		if ( !regs.CR[0].eq ) { return 0x8225E0A0;  }
		/* 8225E084h case   43:*/		return 0x8225E088;
		  /* 8225E088h */ case   44:  		/* li R7, 2430 */
		/* 8225E088h case   44:*/		cpu::op::li<0>(regs,&regs.R7,0x97E);
		/* 8225E088h case   44:*/		return 0x8225E08C;
		  /* 8225E08Ch */ case   45:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E08Ch case   45:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E08Ch case   45:*/		return 0x8225E090;
		  /* 8225E090h */ case   46:  		/* li R3, 0 */
		/* 8225E090h case   46:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E090h case   46:*/		return 0x8225E094;
		  /* 8225E094h */ case   47:  		/* lwz R5, <#[R1 + 184]> */
		/* 8225E094h case   47:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225E094h case   47:*/		return 0x8225E098;
		  /* 8225E098h */ case   48:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E098h case   48:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E098h case   48:*/		return 0x8225E09C;
		  /* 8225E09Ch */ case   49:  		/* bl -1074324 */
		/* 8225E09Ch case   49:*/		regs.LR = 0x8225E0A0; return 0x82157C08;
		/* 8225E09Ch case   49:*/		return 0x8225E0A0;
	}
	return 0x8225E0A0;
} // Block from 8225DFD8h-8225E0A0h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8225E0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E0A0);
		  /* 8225E0A0h */ case    0:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225E0A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225E0A0h case    0:*/		return 0x8225E0A4;
		  /* 8225E0A4h */ case    1:  		/* rlwinm R17, R25, 3, 0, 28 */
		/* 8225E0A4h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R17,regs.R25);
		/* 8225E0A4h case    1:*/		return 0x8225E0A8;
		  /* 8225E0A8h */ case    2:  		/* add R11, R17, R11 */
		/* 8225E0A8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R17,regs.R11);
		/* 8225E0A8h case    2:*/		return 0x8225E0AC;
		  /* 8225E0ACh */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 8225E0ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8225E0ACh case    3:*/		return 0x8225E0B0;
		  /* 8225E0B0h */ case    4:  		/* cmpwi CR6, R11, 4 */
		/* 8225E0B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 8225E0B0h case    4:*/		return 0x8225E0B4;
		  /* 8225E0B4h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 8225E0B4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8225E0FC;  }
		/* 8225E0B4h case    5:*/		return 0x8225E0B8;
		  /* 8225E0B8h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 8225E0B8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8225E0B8h case    6:*/		return 0x8225E0BC;
		  /* 8225E0BCh */ case    7:  		/* bc 4, CR6_EQ, 992 */
		/* 8225E0BCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x8225E49C;  }
		/* 8225E0BCh case    7:*/		return 0x8225E0C0;
		  /* 8225E0C0h */ case    8:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225E0C0h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E0C0h case    8:*/		return 0x8225E0C4;
		  /* 8225E0C4h */ case    9:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225E0C4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225E0C4h case    9:*/		return 0x8225E0C8;
		  /* 8225E0C8h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 8225E0C8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225E0C8h case   10:*/		return 0x8225E0CC;
		  /* 8225E0CCh */ case   11:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225E0CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225E0CCh case   11:*/		return 0x8225E0D0;
		  /* 8225E0D0h */ case   12:  		/* mtspr CTR, R11 */
		/* 8225E0D0h case   12:*/		regs.CTR = regs.R11;
		/* 8225E0D0h case   12:*/		return 0x8225E0D4;
		  /* 8225E0D4h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 8225E0D4h case   13:*/		if ( 1 ) { regs.LR = 0x8225E0D8; return (uint32)regs.CTR; }
		/* 8225E0D4h case   13:*/		return 0x8225E0D8;
		  /* 8225E0D8h */ case   14:  		/* lis R11, -32222 */
		/* 8225E0D8h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225E0D8h case   14:*/		return 0x8225E0DC;
		  /* 8225E0DCh */ case   15:  		/* mr R5, R3 */
		/* 8225E0DCh case   15:*/		regs.R5 = regs.R3;
		/* 8225E0DCh case   15:*/		return 0x8225E0E0;
		  /* 8225E0E0h */ case   16:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225E0E0h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225E0E0h case   16:*/		return 0x8225E0E4;
		  /* 8225E0E4h */ case   17:  		/* mr R4, R25 */
		/* 8225E0E4h case   17:*/		regs.R4 = regs.R25;
		/* 8225E0E4h case   17:*/		return 0x8225E0E8;
		  /* 8225E0E8h */ case   18:  		/* addi R6, R11, -12392 */
		/* 8225E0E8h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225E0E8h case   18:*/		return 0x8225E0EC;
		  /* 8225E0ECh */ case   19:  		/* mr R7, R30 */
		/* 8225E0ECh case   19:*/		regs.R7 = regs.R30;
		/* 8225E0ECh case   19:*/		return 0x8225E0F0;
		  /* 8225E0F0h */ case   20:  		/* bl -187800 */
		/* 8225E0F0h case   20:*/		regs.LR = 0x8225E0F4; return 0x82230358;
		/* 8225E0F0h case   20:*/		return 0x8225E0F4;
		  /* 8225E0F4h */ case   21:  		/* cmpwi CR6, R3, 1 */
		/* 8225E0F4h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225E0F4h case   21:*/		return 0x8225E0F8;
		  /* 8225E0F8h */ case   22:  		/* bc 4, CR6_EQ, 932 */
		/* 8225E0F8h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8225E49C;  }
		/* 8225E0F8h case   22:*/		return 0x8225E0FC;
	}
	return 0x8225E0FC;
} // Block from 8225E0A0h-8225E0FCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 8225E0FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E0FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E0FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E0FC);
		  /* 8225E0FCh */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225E0FCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E0FCh case    0:*/		return 0x8225E100;
		  /* 8225E100h */ case    1:  		/* li R4, 0 */
		/* 8225E100h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E100h case    1:*/		return 0x8225E104;
		  /* 8225E104h */ case    2:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225E104h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225E104h case    2:*/		return 0x8225E108;
		  /* 8225E108h */ case    3:  		/* addi R5, R11, -1 */
		/* 8225E108h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225E108h case    3:*/		return 0x8225E10C;
		  /* 8225E10Ch */ case    4:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225E10Ch case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225E10Ch case    4:*/		return 0x8225E110;
		  /* 8225E110h */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225E110h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225E110h case    5:*/		return 0x8225E114;
		  /* 8225E114h */ case    6:  		/* bl -100612 */
		/* 8225E114h case    6:*/		regs.LR = 0x8225E118; return 0x82245810;
		/* 8225E114h case    6:*/		return 0x8225E118;
		  /* 8225E118h */ case    7:  		/* mr R30, R3 */
		/* 8225E118h case    7:*/		regs.R30 = regs.R3;
		/* 8225E118h case    7:*/		return 0x8225E11C;
		  /* 8225E11Ch */ case    8:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E11Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E11Ch case    8:*/		return 0x8225E120;
		  /* 8225E120h */ case    9:  		/* li R3, 27 */
		/* 8225E120h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1B);
		/* 8225E120h case    9:*/		return 0x8225E124;
		  /* 8225E124h */ case   10:  		/* bl -33268 */
		/* 8225E124h case   10:*/		regs.LR = 0x8225E128; return 0x82255F30;
		/* 8225E124h case   10:*/		return 0x8225E128;
		  /* 8225E128h */ case   11:  		/* mr R5, R30 */
		/* 8225E128h case   11:*/		regs.R5 = regs.R30;
		/* 8225E128h case   11:*/		return 0x8225E12C;
		  /* 8225E12Ch */ case   12:  		/* li R4, 0 */
		/* 8225E12Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E12Ch case   12:*/		return 0x8225E130;
		  /* 8225E130h */ case   13:  		/* stw R3, <#[R1 + 212]> */
		/* 8225E130h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E130h case   13:*/		return 0x8225E134;
		  /* 8225E134h */ case   14:  		/* mr R11, R3 */
		/* 8225E134h case   14:*/		regs.R11 = regs.R3;
		/* 8225E134h case   14:*/		return 0x8225E138;
		  /* 8225E138h */ case   15:  		/* bl -32160 */
		/* 8225E138h case   15:*/		regs.LR = 0x8225E13C; return 0x82256398;
		/* 8225E138h case   15:*/		return 0x8225E13C;
		  /* 8225E13Ch */ case   16:  		/* lwz R11, <#[R1 + 212]> */
		/* 8225E13Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E13Ch case   16:*/		return 0x8225E140;
		  /* 8225E140h */ case   17:  		/* mr R5, R19 */
		/* 8225E140h case   17:*/		regs.R5 = regs.R19;
		/* 8225E140h case   17:*/		return 0x8225E144;
		  /* 8225E144h */ case   18:  		/* mr R3, R11 */
		/* 8225E144h case   18:*/		regs.R3 = regs.R11;
		/* 8225E144h case   18:*/		return 0x8225E148;
		  /* 8225E148h */ case   19:  		/* li R4, 1 */
		/* 8225E148h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E148h case   19:*/		return 0x8225E14C;
		  /* 8225E14Ch */ case   20:  		/* stw R11, <#[R1 + 212]> */
		/* 8225E14Ch case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E14Ch case   20:*/		return 0x8225E150;
		  /* 8225E150h */ case   21:  		/* bl -32184 */
		/* 8225E150h case   21:*/		regs.LR = 0x8225E154; return 0x82256398;
		/* 8225E150h case   21:*/		return 0x8225E154;
		  /* 8225E154h */ case   22:  		/* li R29, 2 */
		/* 8225E154h case   22:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 8225E154h case   22:*/		return 0x8225E158;
		  /* 8225E158h */ case   23:  		/* lwz R10, <#[R1 + 212]> */
		/* 8225E158h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E158h case   23:*/		return 0x8225E15C;
		  /* 8225E15Ch */ case   24:  		/* li R11, 0 */
		/* 8225E15Ch case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225E15Ch case   24:*/		return 0x8225E160;
		  /* 8225E160h */ case   25:  		/* li R15, 1 */
		/* 8225E160h case   25:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 8225E160h case   25:*/		return 0x8225E164;
		  /* 8225E164h */ case   26:  		/* stb R29, <#[R1 + 152]> */
		/* 8225E164h case   26:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x00000098) );
		/* 8225E164h case   26:*/		return 0x8225E168;
		  /* 8225E168h */ case   27:  		/* stb R11, <#[R1 + 154]> */
		/* 8225E168h case   27:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000009A) );
		/* 8225E168h case   27:*/		return 0x8225E16C;
		  /* 8225E16Ch */ case   28:  		/* mr R3, R10 */
		/* 8225E16Ch case   28:*/		regs.R3 = regs.R10;
		/* 8225E16Ch case   28:*/		return 0x8225E170;
		  /* 8225E170h */ case   29:  		/* stb R29, <#[R1 + 153]> */
		/* 8225E170h case   29:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x00000099) );
		/* 8225E170h case   29:*/		return 0x8225E174;
		  /* 8225E174h */ case   30:  		/* mr R5, R19 */
		/* 8225E174h case   30:*/		regs.R5 = regs.R19;
		/* 8225E174h case   30:*/		return 0x8225E178;
		  /* 8225E178h */ case   31:  		/* stb R15, <#[R1 + 155]> */
		/* 8225E178h case   31:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R1 + 0x0000009B) );
		/* 8225E178h case   31:*/		return 0x8225E17C;
		  /* 8225E17Ch */ case   32:  		/* li R4, 2 */
		/* 8225E17Ch case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225E17Ch case   32:*/		return 0x8225E180;
		  /* 8225E180h */ case   33:  		/* stw R10, <#[R1 + 212]> */
		/* 8225E180h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E180h case   33:*/		return 0x8225E184;
		  /* 8225E184h */ case   34:  		/* lwz R11, <#[R1 + 152]> */
		/* 8225E184h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 8225E184h case   34:*/		return 0x8225E188;
		  /* 8225E188h */ case   35:  		/* stw R11, <#[R10 + 132]> */
		/* 8225E188h case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000084) );
		/* 8225E188h case   35:*/		return 0x8225E18C;
		  /* 8225E18Ch */ case   36:  		/* bl -32244 */
		/* 8225E18Ch case   36:*/		regs.LR = 0x8225E190; return 0x82256398;
		/* 8225E18Ch case   36:*/		return 0x8225E190;
		  /* 8225E190h */ case   37:  		/* lwz R10, <#[R1 + 212]> */
		/* 8225E190h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E190h case   37:*/		return 0x8225E194;
		  /* 8225E194h */ case   38:  		/* li R11, 0 */
		/* 8225E194h case   38:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225E194h case   38:*/		return 0x8225E198;
		  /* 8225E198h */ case   39:  		/* stb R15, <#[R1 + 152]> */
		/* 8225E198h case   39:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R1 + 0x00000098) );
		/* 8225E198h case   39:*/		return 0x8225E19C;
		  /* 8225E19Ch */ case   40:  		/* stb R29, <#[R1 + 154]> */
		/* 8225E19Ch case   40:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x0000009A) );
		/* 8225E19Ch case   40:*/		return 0x8225E1A0;
		  /* 8225E1A0h */ case   41:  		/* mr R4, R10 */
		/* 8225E1A0h case   41:*/		regs.R4 = regs.R10;
		/* 8225E1A0h case   41:*/		return 0x8225E1A4;
		  /* 8225E1A4h */ case   42:  		/* stb R11, <#[R1 + 153]> */
		/* 8225E1A4h case   42:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000099) );
		/* 8225E1A4h case   42:*/		return 0x8225E1A8;
		  /* 8225E1A8h */ case   43:  		/* mr R3, R31 */
		/* 8225E1A8h case   43:*/		regs.R3 = regs.R31;
		/* 8225E1A8h case   43:*/		return 0x8225E1AC;
		  /* 8225E1ACh */ case   44:  		/* stb R29, <#[R1 + 155]> */
		/* 8225E1ACh case   44:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R1 + 0x0000009B) );
		/* 8225E1ACh case   44:*/		return 0x8225E1B0;
		  /* 8225E1B0h */ case   45:  		/* lwz R11, <#[R1 + 152]> */
		/* 8225E1B0h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 8225E1B0h case   45:*/		return 0x8225E1B4;
		  /* 8225E1B4h */ case   46:  		/* stw R11, <#[R10 + 136]> */
		/* 8225E1B4h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000088) );
		/* 8225E1B4h case   46:*/		return 0x8225E1B8;
		  /* 8225E1B8h */ case   47:  		/* stw R10, <#[R1 + 212]> */
		/* 8225E1B8h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E1B8h case   47:*/		return 0x8225E1BC;
		  /* 8225E1BCh */ case   48:  		/* bl -162836 */
		/* 8225E1BCh case   48:*/		regs.LR = 0x8225E1C0; return 0x822365A8;
		/* 8225E1BCh case   48:*/		return 0x8225E1C0;
		  /* 8225E1C0h */ case   49:  		/* lwz R11, <#[R1 + 212]> */
		/* 8225E1C0h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E1C0h case   49:*/		return 0x8225E1C4;
		  /* 8225E1C4h */ case   50:  		/* mr R3, R14 */
		/* 8225E1C4h case   50:*/		regs.R3 = regs.R14;
		/* 8225E1C4h case   50:*/		return 0x8225E1C8;
		  /* 8225E1C8h */ case   51:  		/* mr R4, R11 */
		/* 8225E1C8h case   51:*/		regs.R4 = regs.R11;
		/* 8225E1C8h case   51:*/		return 0x8225E1CC;
		  /* 8225E1CCh */ case   52:  		/* stw R11, <#[R1 + 212]> */
		/* 8225E1CCh case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E1CCh case   52:*/		return 0x8225E1D0;
		  /* 8225E1D0h */ case   53:  		/* bl -21152 */
		/* 8225E1D0h case   53:*/		regs.LR = 0x8225E1D4; return 0x82258F30;
		/* 8225E1D0h case   53:*/		return 0x8225E1D4;
		  /* 8225E1D4h */ case   54:  		/* lwz R3, <#[R1 + 212]> */
		/* 8225E1D4h case   54:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000D4) );
		/* 8225E1D4h case   54:*/		return 0x8225E1D8;
		  /* 8225E1D8h */ case   55:  		/* bl -33304 */
		/* 8225E1D8h case   55:*/		regs.LR = 0x8225E1DC; return 0x82255FC0;
		/* 8225E1D8h case   55:*/		return 0x8225E1DC;
		  /* 8225E1DCh */ case   56:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E1DCh case   56:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E1DCh case   56:*/		return 0x8225E1E0;
		  /* 8225E1E0h */ case   57:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E1E0h case   57:*/		if ( !regs.CR[0].eq ) { return 0x8225E1FC;  }
		/* 8225E1E0h case   57:*/		return 0x8225E1E4;
		  /* 8225E1E4h */ case   58:  		/* li R7, 2467 */
		/* 8225E1E4h case   58:*/		cpu::op::li<0>(regs,&regs.R7,0x9A3);
		/* 8225E1E4h case   58:*/		return 0x8225E1E8;
		  /* 8225E1E8h */ case   59:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E1E8h case   59:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E1E8h case   59:*/		return 0x8225E1EC;
		  /* 8225E1ECh */ case   60:  		/* li R3, 0 */
		/* 8225E1ECh case   60:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E1ECh case   60:*/		return 0x8225E1F0;
		  /* 8225E1F0h */ case   61:  		/* lwz R5, <#[R1 + 184]> */
		/* 8225E1F0h case   61:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225E1F0h case   61:*/		return 0x8225E1F4;
		  /* 8225E1F4h */ case   62:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E1F4h case   62:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E1F4h case   62:*/		return 0x8225E1F8;
		  /* 8225E1F8h */ case   63:  		/* bl -1074672 */
		/* 8225E1F8h case   63:*/		regs.LR = 0x8225E1FC; return 0x82157C08;
		/* 8225E1F8h case   63:*/		return 0x8225E1FC;
	}
	return 0x8225E1FC;
} // Block from 8225E0FCh-8225E1FCh (64 instructions)

//////////////////////////////////////////////////////
// Block at 8225E1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E1FC);
		  /* 8225E1FCh */ case    0:  		/* li R3, 64 */
		/* 8225E1FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x40);
		/* 8225E1FCh case    0:*/		return 0x8225E200;
		  /* 8225E200h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E200h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E200h case    1:*/		return 0x8225E204;
		  /* 8225E204h */ case    2:  		/* bl -33492 */
		/* 8225E204h case    2:*/		regs.LR = 0x8225E208; return 0x82255F30;
		/* 8225E204h case    2:*/		return 0x8225E208;
		  /* 8225E208h */ case    3:  		/* mr R5, R30 */
		/* 8225E208h case    3:*/		regs.R5 = regs.R30;
		/* 8225E208h case    3:*/		return 0x8225E20C;
		  /* 8225E20Ch */ case    4:  		/* li R4, 0 */
		/* 8225E20Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E20Ch case    4:*/		return 0x8225E210;
		  /* 8225E210h */ case    5:  		/* mr R19, R3 */
		/* 8225E210h case    5:*/		regs.R19 = regs.R3;
		/* 8225E210h case    5:*/		return 0x8225E214;
		  /* 8225E214h */ case    6:  		/* bl -32380 */
		/* 8225E214h case    6:*/		regs.LR = 0x8225E218; return 0x82256398;
		/* 8225E214h case    6:*/		return 0x8225E218;
		  /* 8225E218h */ case    7:  		/* lwz R29, <#[R1 + 136]> */
		/* 8225E218h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 8225E218h case    7:*/		return 0x8225E21C;
		  /* 8225E21Ch */ case    8:  		/* mr R3, R19 */
		/* 8225E21Ch case    8:*/		regs.R3 = regs.R19;
		/* 8225E21Ch case    8:*/		return 0x8225E220;
		  /* 8225E220h */ case    9:  		/* mr R5, R30 */
		/* 8225E220h case    9:*/		regs.R5 = regs.R30;
		/* 8225E220h case    9:*/		return 0x8225E224;
		  /* 8225E224h */ case   10:  		/* li R4, 1 */
		/* 8225E224h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E224h case   10:*/		return 0x8225E228;
		  /* 8225E228h */ case   11:  		/* lwz R11, <#[R29 - 1296]> */
		/* 8225E228h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFAF0) );
		/* 8225E228h case   11:*/		return 0x8225E22C;
		  /* 8225E22Ch */ case   12:  		/* stw R11, <#[R19 + 128]> */
		/* 8225E22Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000080) );
		/* 8225E22Ch case   12:*/		return 0x8225E230;
		  /* 8225E230h */ case   13:  		/* bl -32408 */
		/* 8225E230h case   13:*/		regs.LR = 0x8225E234; return 0x82256398;
		/* 8225E230h case   13:*/		return 0x8225E234;
		  /* 8225E234h */ case   14:  		/* lwz R11, <#[R29 - 1276]> */
		/* 8225E234h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFB04) );
		/* 8225E234h case   14:*/		return 0x8225E238;
		  /* 8225E238h */ case   15:  		/* stb R15, <#[R19 + 159]> */
		/* 8225E238h case   15:*/		cpu::mem::store8( regs, regs.R15, (uint32)(regs.R19 + 0x0000009F) );
		/* 8225E238h case   15:*/		return 0x8225E23C;
		  /* 8225E23Ch */ case   16:  		/* mr R4, R19 */
		/* 8225E23Ch case   16:*/		regs.R4 = regs.R19;
		/* 8225E23Ch case   16:*/		return 0x8225E240;
		  /* 8225E240h */ case   17:  		/* mr R3, R31 */
		/* 8225E240h case   17:*/		regs.R3 = regs.R31;
		/* 8225E240h case   17:*/		return 0x8225E244;
		  /* 8225E244h */ case   18:  		/* stw R11, <#[R19 + 132]> */
		/* 8225E244h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000084) );
		/* 8225E244h case   18:*/		return 0x8225E248;
		  /* 8225E248h */ case   19:  		/* bl -162976 */
		/* 8225E248h case   19:*/		regs.LR = 0x8225E24C; return 0x822365A8;
		/* 8225E248h case   19:*/		return 0x8225E24C;
		  /* 8225E24Ch */ case   20:  		/* mr R4, R19 */
		/* 8225E24Ch case   20:*/		regs.R4 = regs.R19;
		/* 8225E24Ch case   20:*/		return 0x8225E250;
		  /* 8225E250h */ case   21:  		/* mr R3, R14 */
		/* 8225E250h case   21:*/		regs.R3 = regs.R14;
		/* 8225E250h case   21:*/		return 0x8225E254;
		  /* 8225E254h */ case   22:  		/* bl -21284 */
		/* 8225E254h case   22:*/		regs.LR = 0x8225E258; return 0x82258F30;
		/* 8225E254h case   22:*/		return 0x8225E258;
		  /* 8225E258h */ case   23:  		/* mr R3, R19 */
		/* 8225E258h case   23:*/		regs.R3 = regs.R19;
		/* 8225E258h case   23:*/		return 0x8225E25C;
		  /* 8225E25Ch */ case   24:  		/* bl -33436 */
		/* 8225E25Ch case   24:*/		regs.LR = 0x8225E260; return 0x82255FC0;
		/* 8225E25Ch case   24:*/		return 0x8225E260;
		  /* 8225E260h */ case   25:  		/* lwz R19, <#[R1 + 184]> */
		/* 8225E260h case   25:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225E260h case   25:*/		return 0x8225E264;
		  /* 8225E264h */ case   26:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E264h case   26:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E264h case   26:*/		return 0x8225E268;
		  /* 8225E268h */ case   27:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E268h case   27:*/		if ( !regs.CR[0].eq ) { return 0x8225E284;  }
		/* 8225E268h case   27:*/		return 0x8225E26C;
		  /* 8225E26Ch */ case   28:  		/* li R7, 2478 */
		/* 8225E26Ch case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x9AE);
		/* 8225E26Ch case   28:*/		return 0x8225E270;
		  /* 8225E270h */ case   29:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E270h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E270h case   29:*/		return 0x8225E274;
		  /* 8225E274h */ case   30:  		/* li R3, 0 */
		/* 8225E274h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E274h case   30:*/		return 0x8225E278;
		  /* 8225E278h */ case   31:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E278h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E278h case   31:*/		return 0x8225E27C;
		  /* 8225E27Ch */ case   32:  		/* mr R5, R19 */
		/* 8225E27Ch case   32:*/		regs.R5 = regs.R19;
		/* 8225E27Ch case   32:*/		return 0x8225E280;
		  /* 8225E280h */ case   33:  		/* bl -1074808 */
		/* 8225E280h case   33:*/		regs.LR = 0x8225E284; return 0x82157C08;
		/* 8225E280h case   33:*/		return 0x8225E284;
	}
	return 0x8225E284;
} // Block from 8225E1FCh-8225E284h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8225E284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E284);
		  /* 8225E284h */ case    0:  		/* li R3, 20 */
		/* 8225E284h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225E284h case    0:*/		return 0x8225E288;
		  /* 8225E288h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E288h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E288h case    1:*/		return 0x8225E28C;
		  /* 8225E28Ch */ case    2:  		/* bl -33628 */
		/* 8225E28Ch case    2:*/		regs.LR = 0x8225E290; return 0x82255F30;
		/* 8225E28Ch case    2:*/		return 0x8225E290;
		  /* 8225E290h */ case    3:  		/* mr R5, R30 */
		/* 8225E290h case    3:*/		regs.R5 = regs.R30;
		/* 8225E290h case    3:*/		return 0x8225E294;
		  /* 8225E294h */ case    4:  		/* li R4, 0 */
		/* 8225E294h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E294h case    4:*/		return 0x8225E298;
		  /* 8225E298h */ case    5:  		/* mr R15, R3 */
		/* 8225E298h case    5:*/		regs.R15 = regs.R3;
		/* 8225E298h case    5:*/		return 0x8225E29C;
		  /* 8225E29Ch */ case    6:  		/* bl -32516 */
		/* 8225E29Ch case    6:*/		regs.LR = 0x8225E2A0; return 0x82256398;
		/* 8225E29Ch case    6:*/		return 0x8225E2A0;
		  /* 8225E2A0h */ case    7:  		/* lwz R11, <#[R15]> */
		/* 8225E2A0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E2A0h case    7:*/		return 0x8225E2A4;
		  /* 8225E2A4h */ case    8:  		/* mr R3, R15 */
		/* 8225E2A4h case    8:*/		regs.R3 = regs.R15;
		/* 8225E2A4h case    8:*/		return 0x8225E2A8;
		  /* 8225E2A8h */ case    9:  		/* li R6, 0 */
		/* 8225E2A8h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225E2A8h case    9:*/		return 0x8225E2AC;
		  /* 8225E2ACh */ case   10:  		/* li R5, 0 */
		/* 8225E2ACh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225E2ACh case   10:*/		return 0x8225E2B0;
		  /* 8225E2B0h */ case   11:  		/* li R4, 0 */
		/* 8225E2B0h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E2B0h case   11:*/		return 0x8225E2B4;
		  /* 8225E2B4h */ case   12:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225E2B4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225E2B4h case   12:*/		return 0x8225E2B8;
		  /* 8225E2B8h */ case   13:  		/* mtspr CTR, R11 */
		/* 8225E2B8h case   13:*/		regs.CTR = regs.R11;
		/* 8225E2B8h case   13:*/		return 0x8225E2BC;
		  /* 8225E2BCh */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8225E2BCh case   14:*/		if ( 1 ) { regs.LR = 0x8225E2C0; return (uint32)regs.CTR; }
		/* 8225E2BCh case   14:*/		return 0x8225E2C0;
		  /* 8225E2C0h */ case   15:  		/* lwz R11, <#[R15]> */
		/* 8225E2C0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E2C0h case   15:*/		return 0x8225E2C4;
		  /* 8225E2C4h */ case   16:  		/* mr R3, R15 */
		/* 8225E2C4h case   16:*/		regs.R3 = regs.R15;
		/* 8225E2C4h case   16:*/		return 0x8225E2C8;
		  /* 8225E2C8h */ case   17:  		/* li R6, 0 */
		/* 8225E2C8h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225E2C8h case   17:*/		return 0x8225E2CC;
		  /* 8225E2CCh */ case   18:  		/* li R5, 1 */
		/* 8225E2CCh case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225E2CCh case   18:*/		return 0x8225E2D0;
		  /* 8225E2D0h */ case   19:  		/* li R4, 0 */
		/* 8225E2D0h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E2D0h case   19:*/		return 0x8225E2D4;
		  /* 8225E2D4h */ case   20:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225E2D4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225E2D4h case   20:*/		return 0x8225E2D8;
		  /* 8225E2D8h */ case   21:  		/* mtspr CTR, R11 */
		/* 8225E2D8h case   21:*/		regs.CTR = regs.R11;
		/* 8225E2D8h case   21:*/		return 0x8225E2DC;
		  /* 8225E2DCh */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 8225E2DCh case   22:*/		if ( 1 ) { regs.LR = 0x8225E2E0; return (uint32)regs.CTR; }
		/* 8225E2DCh case   22:*/		return 0x8225E2E0;
		  /* 8225E2E0h */ case   23:  		/* lwz R11, <#[R15]> */
		/* 8225E2E0h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E2E0h case   23:*/		return 0x8225E2E4;
		  /* 8225E2E4h */ case   24:  		/* mr R3, R15 */
		/* 8225E2E4h case   24:*/		regs.R3 = regs.R15;
		/* 8225E2E4h case   24:*/		return 0x8225E2E8;
		  /* 8225E2E8h */ case   25:  		/* li R6, 1 */
		/* 8225E2E8h case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225E2E8h case   25:*/		return 0x8225E2EC;
		  /* 8225E2ECh */ case   26:  		/* li R5, 2 */
		/* 8225E2ECh case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225E2ECh case   26:*/		return 0x8225E2F0;
		  /* 8225E2F0h */ case   27:  		/* li R4, 0 */
		/* 8225E2F0h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E2F0h case   27:*/		return 0x8225E2F4;
		  /* 8225E2F4h */ case   28:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225E2F4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225E2F4h case   28:*/		return 0x8225E2F8;
		  /* 8225E2F8h */ case   29:  		/* mtspr CTR, R11 */
		/* 8225E2F8h case   29:*/		regs.CTR = regs.R11;
		/* 8225E2F8h case   29:*/		return 0x8225E2FC;
		  /* 8225E2FCh */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 8225E2FCh case   30:*/		if ( 1 ) { regs.LR = 0x8225E300; return (uint32)regs.CTR; }
		/* 8225E2FCh case   30:*/		return 0x8225E300;
		  /* 8225E300h */ case   31:  		/* lwz R11, <#[R15]> */
		/* 8225E300h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E300h case   31:*/		return 0x8225E304;
		  /* 8225E304h */ case   32:  		/* mr R3, R15 */
		/* 8225E304h case   32:*/		regs.R3 = regs.R15;
		/* 8225E304h case   32:*/		return 0x8225E308;
		  /* 8225E308h */ case   33:  		/* li R6, 1 */
		/* 8225E308h case   33:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225E308h case   33:*/		return 0x8225E30C;
		  /* 8225E30Ch */ case   34:  		/* li R5, 3 */
		/* 8225E30Ch case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225E30Ch case   34:*/		return 0x8225E310;
		  /* 8225E310h */ case   35:  		/* li R4, 0 */
		/* 8225E310h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E310h case   35:*/		return 0x8225E314;
		  /* 8225E314h */ case   36:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225E314h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225E314h case   36:*/		return 0x8225E318;
		  /* 8225E318h */ case   37:  		/* mtspr CTR, R11 */
		/* 8225E318h case   37:*/		regs.CTR = regs.R11;
		/* 8225E318h case   37:*/		return 0x8225E31C;
		  /* 8225E31Ch */ case   38:  		/* bcctrl 20, CR0_LT */
		/* 8225E31Ch case   38:*/		if ( 1 ) { regs.LR = 0x8225E320; return (uint32)regs.CTR; }
		/* 8225E31Ch case   38:*/		return 0x8225E320;
		  /* 8225E320h */ case   39:  		/* mr R3, R15 */
		/* 8225E320h case   39:*/		regs.R3 = regs.R15;
		/* 8225E320h case   39:*/		return 0x8225E324;
		  /* 8225E324h */ case   40:  		/* mr R5, R30 */
		/* 8225E324h case   40:*/		regs.R5 = regs.R30;
		/* 8225E324h case   40:*/		return 0x8225E328;
		  /* 8225E328h */ case   41:  		/* li R4, 1 */
		/* 8225E328h case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E328h case   41:*/		return 0x8225E32C;
		  /* 8225E32Ch */ case   42:  		/* bl -32660 */
		/* 8225E32Ch case   42:*/		regs.LR = 0x8225E330; return 0x82256398;
		/* 8225E32Ch case   42:*/		return 0x8225E330;
		  /* 8225E330h */ case   43:  		/* mr R3, R15 */
		/* 8225E330h case   43:*/		regs.R3 = regs.R15;
		/* 8225E330h case   43:*/		return 0x8225E334;
		  /* 8225E334h */ case   44:  		/* mr R5, R30 */
		/* 8225E334h case   44:*/		regs.R5 = regs.R30;
		/* 8225E334h case   44:*/		return 0x8225E338;
		  /* 8225E338h */ case   45:  		/* li R4, 2 */
		/* 8225E338h case   45:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225E338h case   45:*/		return 0x8225E33C;
		  /* 8225E33Ch */ case   46:  		/* bl -32676 */
		/* 8225E33Ch case   46:*/		regs.LR = 0x8225E340; return 0x82256398;
		/* 8225E33Ch case   46:*/		return 0x8225E340;
		  /* 8225E340h */ case   47:  		/* lwz R11, <#[R29 - 1276]> */
		/* 8225E340h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFB04) );
		/* 8225E340h case   47:*/		return 0x8225E344;
		  /* 8225E344h */ case   48:  		/* mr R3, R15 */
		/* 8225E344h case   48:*/		regs.R3 = regs.R15;
		/* 8225E344h case   48:*/		return 0x8225E348;
		  /* 8225E348h */ case   49:  		/* fmr FR4, FR26 */
		/* 8225E348h case   49:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR26);
		/* 8225E348h case   49:*/		return 0x8225E34C;
		  /* 8225E34Ch */ case   50:  		/* li R5, 3 */
		/* 8225E34Ch case   50:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225E34Ch case   50:*/		return 0x8225E350;
		  /* 8225E350h */ case   51:  		/* fmr FR3, FR26 */
		/* 8225E350h case   51:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR26);
		/* 8225E350h case   51:*/		return 0x8225E354;
		  /* 8225E354h */ case   52:  		/* mr R4, R31 */
		/* 8225E354h case   52:*/		regs.R4 = regs.R31;
		/* 8225E354h case   52:*/		return 0x8225E358;
		  /* 8225E358h */ case   53:  		/* fmr FR2, FR26 */
		/* 8225E358h case   53:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR26);
		/* 8225E358h case   53:*/		return 0x8225E35C;
		  /* 8225E35Ch */ case   54:  		/* fmr FR1, FR26 */
		/* 8225E35Ch case   54:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR26);
		/* 8225E35Ch case   54:*/		return 0x8225E360;
		  /* 8225E360h */ case   55:  		/* stw R11, <#[R15 + 136]> */
		/* 8225E360h case   55:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000088) );
		/* 8225E360h case   55:*/		return 0x8225E364;
		  /* 8225E364h */ case   56:  		/* bl -29772 */
		/* 8225E364h case   56:*/		regs.LR = 0x8225E368; return 0x82256F18;
		/* 8225E364h case   56:*/		return 0x8225E368;
		  /* 8225E368h */ case   57:  		/* mr R4, R15 */
		/* 8225E368h case   57:*/		regs.R4 = regs.R15;
		/* 8225E368h case   57:*/		return 0x8225E36C;
		  /* 8225E36Ch */ case   58:  		/* mr R3, R31 */
		/* 8225E36Ch case   58:*/		regs.R3 = regs.R31;
		/* 8225E36Ch case   58:*/		return 0x8225E370;
		  /* 8225E370h */ case   59:  		/* bl -163272 */
		/* 8225E370h case   59:*/		regs.LR = 0x8225E374; return 0x822365A8;
		/* 8225E370h case   59:*/		return 0x8225E374;
		  /* 8225E374h */ case   60:  		/* mr R4, R15 */
		/* 8225E374h case   60:*/		regs.R4 = regs.R15;
		/* 8225E374h case   60:*/		return 0x8225E378;
		  /* 8225E378h */ case   61:  		/* mr R3, R14 */
		/* 8225E378h case   61:*/		regs.R3 = regs.R14;
		/* 8225E378h case   61:*/		return 0x8225E37C;
		  /* 8225E37Ch */ case   62:  		/* bl -21580 */
		/* 8225E37Ch case   62:*/		regs.LR = 0x8225E380; return 0x82258F30;
		/* 8225E37Ch case   62:*/		return 0x8225E380;
		  /* 8225E380h */ case   63:  		/* mr R3, R15 */
		/* 8225E380h case   63:*/		regs.R3 = regs.R15;
		/* 8225E380h case   63:*/		return 0x8225E384;
		  /* 8225E384h */ case   64:  		/* bl -33732 */
		/* 8225E384h case   64:*/		regs.LR = 0x8225E388; return 0x82255FC0;
		/* 8225E384h case   64:*/		return 0x8225E388;
		  /* 8225E388h */ case   65:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E388h case   65:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E388h case   65:*/		return 0x8225E38C;
		  /* 8225E38Ch */ case   66:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E38Ch case   66:*/		if ( !regs.CR[0].eq ) { return 0x8225E3A8;  }
		/* 8225E38Ch case   66:*/		return 0x8225E390;
		  /* 8225E390h */ case   67:  		/* mr R5, R19 */
		/* 8225E390h case   67:*/		regs.R5 = regs.R19;
		/* 8225E390h case   67:*/		return 0x8225E394;
		  /* 8225E394h */ case   68:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E394h case   68:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E394h case   68:*/		return 0x8225E398;
		  /* 8225E398h */ case   69:  		/* li R7, 2493 */
		/* 8225E398h case   69:*/		cpu::op::li<0>(regs,&regs.R7,0x9BD);
		/* 8225E398h case   69:*/		return 0x8225E39C;
		  /* 8225E39Ch */ case   70:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E39Ch case   70:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E39Ch case   70:*/		return 0x8225E3A0;
		  /* 8225E3A0h */ case   71:  		/* li R3, 0 */
		/* 8225E3A0h case   71:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E3A0h case   71:*/		return 0x8225E3A4;
		  /* 8225E3A4h */ case   72:  		/* bl -1075100 */
		/* 8225E3A4h case   72:*/		regs.LR = 0x8225E3A8; return 0x82157C08;
		/* 8225E3A4h case   72:*/		return 0x8225E3A8;
	}
	return 0x8225E3A8;
} // Block from 8225E284h-8225E3A8h (73 instructions)

//////////////////////////////////////////////////////
// Block at 8225E3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E3A8);
		  /* 8225E3A8h */ case    0:  		/* li R3, 49 */
		/* 8225E3A8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225E3A8h case    0:*/		return 0x8225E3AC;
		  /* 8225E3ACh */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E3ACh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E3ACh case    1:*/		return 0x8225E3B0;
		  /* 8225E3B0h */ case    2:  		/* bl -33920 */
		/* 8225E3B0h case    2:*/		regs.LR = 0x8225E3B4; return 0x82255F30;
		/* 8225E3B0h case    2:*/		return 0x8225E3B4;
		  /* 8225E3B4h */ case    3:  		/* mr R5, R30 */
		/* 8225E3B4h case    3:*/		regs.R5 = regs.R30;
		/* 8225E3B4h case    3:*/		return 0x8225E3B8;
		  /* 8225E3B8h */ case    4:  		/* li R4, 0 */
		/* 8225E3B8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E3B8h case    4:*/		return 0x8225E3BC;
		  /* 8225E3BCh */ case    5:  		/* mr R15, R3 */
		/* 8225E3BCh case    5:*/		regs.R15 = regs.R3;
		/* 8225E3BCh case    5:*/		return 0x8225E3C0;
		  /* 8225E3C0h */ case    6:  		/* bl -32808 */
		/* 8225E3C0h case    6:*/		regs.LR = 0x8225E3C4; return 0x82256398;
		/* 8225E3C0h case    6:*/		return 0x8225E3C4;
		  /* 8225E3C4h */ case    7:  		/* mr R3, R15 */
		/* 8225E3C4h case    7:*/		regs.R3 = regs.R15;
		/* 8225E3C4h case    7:*/		return 0x8225E3C8;
		  /* 8225E3C8h */ case    8:  		/* mr R5, R30 */
		/* 8225E3C8h case    8:*/		regs.R5 = regs.R30;
		/* 8225E3C8h case    8:*/		return 0x8225E3CC;
		  /* 8225E3CCh */ case    9:  		/* li R4, 1 */
		/* 8225E3CCh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E3CCh case    9:*/		return 0x8225E3D0;
		  /* 8225E3D0h */ case   10:  		/* bl -32824 */
		/* 8225E3D0h case   10:*/		regs.LR = 0x8225E3D4; return 0x82256398;
		/* 8225E3D0h case   10:*/		return 0x8225E3D4;
		  /* 8225E3D4h */ case   11:  		/* lwz R11, <#[R15]> */
		/* 8225E3D4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E3D4h case   11:*/		return 0x8225E3D8;
		  /* 8225E3D8h */ case   12:  		/* mr R3, R15 */
		/* 8225E3D8h case   12:*/		regs.R3 = regs.R15;
		/* 8225E3D8h case   12:*/		return 0x8225E3DC;
		  /* 8225E3DCh */ case   13:  		/* li R6, 1 */
		/* 8225E3DCh case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225E3DCh case   13:*/		return 0x8225E3E0;
		  /* 8225E3E0h */ case   14:  		/* li R5, 0 */
		/* 8225E3E0h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225E3E0h case   14:*/		return 0x8225E3E4;
		  /* 8225E3E4h */ case   15:  		/* li R4, 1 */
		/* 8225E3E4h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E3E4h case   15:*/		return 0x8225E3E8;
		  /* 8225E3E8h */ case   16:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225E3E8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225E3E8h case   16:*/		return 0x8225E3EC;
		  /* 8225E3ECh */ case   17:  		/* mtspr CTR, R11 */
		/* 8225E3ECh case   17:*/		regs.CTR = regs.R11;
		/* 8225E3ECh case   17:*/		return 0x8225E3F0;
		  /* 8225E3F0h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 8225E3F0h case   18:*/		if ( 1 ) { regs.LR = 0x8225E3F4; return (uint32)regs.CTR; }
		/* 8225E3F0h case   18:*/		return 0x8225E3F4;
		  /* 8225E3F4h */ case   19:  		/* lwz R11, <#[R15]> */
		/* 8225E3F4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E3F4h case   19:*/		return 0x8225E3F8;
		  /* 8225E3F8h */ case   20:  		/* mr R3, R15 */
		/* 8225E3F8h case   20:*/		regs.R3 = regs.R15;
		/* 8225E3F8h case   20:*/		return 0x8225E3FC;
		  /* 8225E3FCh */ case   21:  		/* li R6, 0 */
		/* 8225E3FCh case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8225E3FCh case   21:*/		return 0x8225E400;
		  /* 8225E400h */ case   22:  		/* li R5, 1 */
		/* 8225E400h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225E400h case   22:*/		return 0x8225E404;
		  /* 8225E404h */ case   23:  		/* li R4, 1 */
		/* 8225E404h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E404h case   23:*/		return 0x8225E408;
		  /* 8225E408h */ case   24:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225E408h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225E408h case   24:*/		return 0x8225E40C;
		  /* 8225E40Ch */ case   25:  		/* mtspr CTR, R11 */
		/* 8225E40Ch case   25:*/		regs.CTR = regs.R11;
		/* 8225E40Ch case   25:*/		return 0x8225E410;
		  /* 8225E410h */ case   26:  		/* bcctrl 20, CR0_LT */
		/* 8225E410h case   26:*/		if ( 1 ) { regs.LR = 0x8225E414; return (uint32)regs.CTR; }
		/* 8225E410h case   26:*/		return 0x8225E414;
		  /* 8225E414h */ case   27:  		/* lwz R11, <#[R15]> */
		/* 8225E414h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E414h case   27:*/		return 0x8225E418;
		  /* 8225E418h */ case   28:  		/* mr R3, R15 */
		/* 8225E418h case   28:*/		regs.R3 = regs.R15;
		/* 8225E418h case   28:*/		return 0x8225E41C;
		  /* 8225E41Ch */ case   29:  		/* li R6, 3 */
		/* 8225E41Ch case   29:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 8225E41Ch case   29:*/		return 0x8225E420;
		  /* 8225E420h */ case   30:  		/* li R5, 2 */
		/* 8225E420h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225E420h case   30:*/		return 0x8225E424;
		  /* 8225E424h */ case   31:  		/* li R4, 1 */
		/* 8225E424h case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E424h case   31:*/		return 0x8225E428;
		  /* 8225E428h */ case   32:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225E428h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225E428h case   32:*/		return 0x8225E42C;
		  /* 8225E42Ch */ case   33:  		/* mtspr CTR, R11 */
		/* 8225E42Ch case   33:*/		regs.CTR = regs.R11;
		/* 8225E42Ch case   33:*/		return 0x8225E430;
		  /* 8225E430h */ case   34:  		/* bcctrl 20, CR0_LT */
		/* 8225E430h case   34:*/		if ( 1 ) { regs.LR = 0x8225E434; return (uint32)regs.CTR; }
		/* 8225E430h case   34:*/		return 0x8225E434;
		  /* 8225E434h */ case   35:  		/* lwz R11, <#[R15]> */
		/* 8225E434h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8225E434h case   35:*/		return 0x8225E438;
		  /* 8225E438h */ case   36:  		/* mr R3, R15 */
		/* 8225E438h case   36:*/		regs.R3 = regs.R15;
		/* 8225E438h case   36:*/		return 0x8225E43C;
		  /* 8225E43Ch */ case   37:  		/* li R6, 3 */
		/* 8225E43Ch case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 8225E43Ch case   37:*/		return 0x8225E440;
		  /* 8225E440h */ case   38:  		/* li R5, 3 */
		/* 8225E440h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225E440h case   38:*/		return 0x8225E444;
		  /* 8225E444h */ case   39:  		/* li R4, 1 */
		/* 8225E444h case   39:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E444h case   39:*/		return 0x8225E448;
		  /* 8225E448h */ case   40:  		/* lwz R11, <#[R11 + 88]> */
		/* 8225E448h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000058) );
		/* 8225E448h case   40:*/		return 0x8225E44C;
		  /* 8225E44Ch */ case   41:  		/* mtspr CTR, R11 */
		/* 8225E44Ch case   41:*/		regs.CTR = regs.R11;
		/* 8225E44Ch case   41:*/		return 0x8225E450;
		  /* 8225E450h */ case   42:  		/* bcctrl 20, CR0_LT */
		/* 8225E450h case   42:*/		if ( 1 ) { regs.LR = 0x8225E454; return (uint32)regs.CTR; }
		/* 8225E450h case   42:*/		return 0x8225E454;
		  /* 8225E454h */ case   43:  		/* mr R4, R15 */
		/* 8225E454h case   43:*/		regs.R4 = regs.R15;
		/* 8225E454h case   43:*/		return 0x8225E458;
		  /* 8225E458h */ case   44:  		/* mr R3, R31 */
		/* 8225E458h case   44:*/		regs.R3 = regs.R31;
		/* 8225E458h case   44:*/		return 0x8225E45C;
		  /* 8225E45Ch */ case   45:  		/* bl -163508 */
		/* 8225E45Ch case   45:*/		regs.LR = 0x8225E460; return 0x822365A8;
		/* 8225E45Ch case   45:*/		return 0x8225E460;
		  /* 8225E460h */ case   46:  		/* mr R4, R15 */
		/* 8225E460h case   46:*/		regs.R4 = regs.R15;
		/* 8225E460h case   46:*/		return 0x8225E464;
		  /* 8225E464h */ case   47:  		/* mr R3, R14 */
		/* 8225E464h case   47:*/		regs.R3 = regs.R14;
		/* 8225E464h case   47:*/		return 0x8225E468;
		  /* 8225E468h */ case   48:  		/* bl -21816 */
		/* 8225E468h case   48:*/		regs.LR = 0x8225E46C; return 0x82258F30;
		/* 8225E468h case   48:*/		return 0x8225E46C;
		  /* 8225E46Ch */ case   49:  		/* mr R3, R15 */
		/* 8225E46Ch case   49:*/		regs.R3 = regs.R15;
		/* 8225E46Ch case   49:*/		return 0x8225E470;
		  /* 8225E470h */ case   50:  		/* bl -33968 */
		/* 8225E470h case   50:*/		regs.LR = 0x8225E474; return 0x82255FC0;
		/* 8225E470h case   50:*/		return 0x8225E474;
		  /* 8225E474h */ case   51:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E474h case   51:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E474h case   51:*/		return 0x8225E478;
		  /* 8225E478h */ case   52:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E478h case   52:*/		if ( !regs.CR[0].eq ) { return 0x8225E494;  }
		/* 8225E478h case   52:*/		return 0x8225E47C;
		  /* 8225E47Ch */ case   53:  		/* mr R5, R19 */
		/* 8225E47Ch case   53:*/		regs.R5 = regs.R19;
		/* 8225E47Ch case   53:*/		return 0x8225E480;
		  /* 8225E480h */ case   54:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E480h case   54:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E480h case   54:*/		return 0x8225E484;
		  /* 8225E484h */ case   55:  		/* li R7, 2504 */
		/* 8225E484h case   55:*/		cpu::op::li<0>(regs,&regs.R7,0x9C8);
		/* 8225E484h case   55:*/		return 0x8225E488;
		  /* 8225E488h */ case   56:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E488h case   56:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E488h case   56:*/		return 0x8225E48C;
		  /* 8225E48Ch */ case   57:  		/* li R3, 0 */
		/* 8225E48Ch case   57:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E48Ch case   57:*/		return 0x8225E490;
		  /* 8225E490h */ case   58:  		/* bl -1075336 */
		/* 8225E490h case   58:*/		regs.LR = 0x8225E494; return 0x82157C08;
		/* 8225E490h case   58:*/		return 0x8225E494;
	}
	return 0x8225E494;
} // Block from 8225E3A8h-8225E494h (59 instructions)

//////////////////////////////////////////////////////
// Block at 8225E494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E494);
		  /* 8225E494h */ case    0:  		/* mr R19, R30 */
		/* 8225E494h case    0:*/		regs.R19 = regs.R30;
		/* 8225E494h case    0:*/		return 0x8225E498;
		  /* 8225E498h */ case    1:  		/* b 8 */
		/* 8225E498h case    1:*/		return 0x8225E4A0;
		/* 8225E498h case    1:*/		return 0x8225E49C;
	}
	return 0x8225E49C;
} // Block from 8225E494h-8225E49Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225E49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E49C);
		  /* 8225E49Ch */ case    0:  		/* lwz R29, <#[R1 + 136]> */
		/* 8225E49Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 8225E49Ch case    0:*/		return 0x8225E4A0;
	}
	return 0x8225E4A0;
} // Block from 8225E49Ch-8225E4A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225E4A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E4A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E4A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E4A0);
		  /* 8225E4A0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225E4A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E4A0h case    0:*/		return 0x8225E4A4;
		  /* 8225E4A4h */ case    1:  		/* lis R10, -32222 */
		/* 8225E4A4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 8225E4A4h case    1:*/		return 0x8225E4A8;
		  /* 8225E4A8h */ case    2:  		/* addi R5, R1, 216 */
		/* 8225E4A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xD8);
		/* 8225E4A8h case    2:*/		return 0x8225E4AC;
		  /* 8225E4ACh */ case    3:  		/* mr R7, R11 */
		/* 8225E4ACh case    3:*/		regs.R7 = regs.R11;
		/* 8225E4ACh case    3:*/		return 0x8225E4B0;
		  /* 8225E4B0h */ case    4:  		/* addi R6, R10, -12392 */
		/* 8225E4B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFCF98);
		/* 8225E4B0h case    4:*/		return 0x8225E4B4;
		  /* 8225E4B4h */ case    5:  		/* mr R4, R25 */
		/* 8225E4B4h case    5:*/		regs.R4 = regs.R25;
		/* 8225E4B4h case    5:*/		return 0x8225E4B8;
		  /* 8225E4B8h */ case    6:  		/* lwz R3, <#[R11 + 1536]> */
		/* 8225E4B8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000600) );
		/* 8225E4B8h case    6:*/		return 0x8225E4BC;
		  /* 8225E4BCh */ case    7:  		/* bl -173132 */
		/* 8225E4BCh case    7:*/		regs.LR = 0x8225E4C0; return 0x82234070;
		/* 8225E4BCh case    7:*/		return 0x8225E4C0;
		  /* 8225E4C0h */ case    8:  		/* li R5, 4 */
		/* 8225E4C0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225E4C0h case    8:*/		return 0x8225E4C4;
		  /* 8225E4C4h */ case    9:  		/* li R4, 3 */
		/* 8225E4C4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225E4C4h case    9:*/		return 0x8225E4C8;
		  /* 8225E4C8h */ case   10:  		/* lhz R3, <#[R23 + 22]> */
		/* 8225E4C8h case   10:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000016) );
		/* 8225E4C8h case   10:*/		return 0x8225E4CC;
		  /* 8225E4CCh */ case   11:  		/* bl -34788 */
		/* 8225E4CCh case   11:*/		regs.LR = 0x8225E4D0; return 0x82255CE8;
		/* 8225E4CCh case   11:*/		return 0x8225E4D0;
		  /* 8225E4D0h */ case   12:  		/* lfs FR0, <#[R1 + 216]> */
		/* 8225E4D0h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225E4D0h case   12:*/		return 0x8225E4D4;
		  /* 8225E4D4h */ case   13:  		/* fadds FR0, FR1, FR0 */
		/* 8225E4D4h case   13:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR1,regs.FR0);
		/* 8225E4D4h case   13:*/		return 0x8225E4D8;
		  /* 8225E4D8h */ case   14:  		/* stfs FR0, <#[R1 + 216]> */
		/* 8225E4D8h case   14:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225E4D8h case   14:*/		return 0x8225E4DC;
		  /* 8225E4DCh */ case   15:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225E4DCh case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E4DCh case   15:*/		return 0x8225E4E0;
		  /* 8225E4E0h */ case   16:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225E4E0h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225E4E0h case   16:*/		return 0x8225E4E4;
		  /* 8225E4E4h */ case   17:  		/* lwz R11, <#[R3]> */
		/* 8225E4E4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225E4E4h case   17:*/		return 0x8225E4E8;
		  /* 8225E4E8h */ case   18:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225E4E8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225E4E8h case   18:*/		return 0x8225E4EC;
		  /* 8225E4ECh */ case   19:  		/* mtspr CTR, R11 */
		/* 8225E4ECh case   19:*/		regs.CTR = regs.R11;
		/* 8225E4ECh case   19:*/		return 0x8225E4F0;
		  /* 8225E4F0h */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 8225E4F0h case   20:*/		if ( 1 ) { regs.LR = 0x8225E4F4; return (uint32)regs.CTR; }
		/* 8225E4F0h case   20:*/		return 0x8225E4F4;
		  /* 8225E4F4h */ case   21:  		/* lis R11, -32222 */
		/* 8225E4F4h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225E4F4h case   21:*/		return 0x8225E4F8;
		  /* 8225E4F8h */ case   22:  		/* mr R5, R3 */
		/* 8225E4F8h case   22:*/		regs.R5 = regs.R3;
		/* 8225E4F8h case   22:*/		return 0x8225E4FC;
		  /* 8225E4FCh */ case   23:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225E4FCh case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225E4FCh case   23:*/		return 0x8225E500;
		  /* 8225E500h */ case   24:  		/* mr R4, R25 */
		/* 8225E500h case   24:*/		regs.R4 = regs.R25;
		/* 8225E500h case   24:*/		return 0x8225E504;
		  /* 8225E504h */ case   25:  		/* addi R6, R11, -12392 */
		/* 8225E504h case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225E504h case   25:*/		return 0x8225E508;
		  /* 8225E508h */ case   26:  		/* mr R7, R30 */
		/* 8225E508h case   26:*/		regs.R7 = regs.R30;
		/* 8225E508h case   26:*/		return 0x8225E50C;
		  /* 8225E50Ch */ case   27:  		/* bl -189020 */
		/* 8225E50Ch case   27:*/		regs.LR = 0x8225E510; return 0x822302B0;
		/* 8225E50Ch case   27:*/		return 0x8225E510;
		  /* 8225E510h */ case   28:  		/* cmpwi CR6, R3, 1 */
		/* 8225E510h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225E510h case   28:*/		return 0x8225E514;
		  /* 8225E514h */ case   29:  		/* bc 4, CR6_EQ, 1640 */
		/* 8225E514h case   29:*/		if ( !regs.CR[6].eq ) { return 0x8225EB7C;  }
		/* 8225E514h case   29:*/		return 0x8225E518;
		  /* 8225E518h */ case   30:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225E518h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E518h case   30:*/		return 0x8225E51C;
		  /* 8225E51Ch */ case   31:  		/* lis R10, -32222 */
		/* 8225E51Ch case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 8225E51Ch case   31:*/		return 0x8225E520;
		  /* 8225E520h */ case   32:  		/* addi R5, R1, 288 */
		/* 8225E520h case   32:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x120);
		/* 8225E520h case   32:*/		return 0x8225E524;
		  /* 8225E524h */ case   33:  		/* mr R7, R11 */
		/* 8225E524h case   33:*/		regs.R7 = regs.R11;
		/* 8225E524h case   33:*/		return 0x8225E528;
		  /* 8225E528h */ case   34:  		/* addi R6, R10, -12392 */
		/* 8225E528h case   34:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFCF98);
		/* 8225E528h case   34:*/		return 0x8225E52C;
		  /* 8225E52Ch */ case   35:  		/* mr R4, R25 */
		/* 8225E52Ch case   35:*/		regs.R4 = regs.R25;
		/* 8225E52Ch case   35:*/		return 0x8225E530;
		  /* 8225E530h */ case   36:  		/* lwz R3, <#[R11 + 1536]> */
		/* 8225E530h case   36:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000600) );
		/* 8225E530h case   36:*/		return 0x8225E534;
		  /* 8225E534h */ case   37:  		/* bl -173092 */
		/* 8225E534h case   37:*/		regs.LR = 0x8225E538; return 0x82234110;
		/* 8225E534h case   37:*/		return 0x8225E538;
		  /* 8225E538h */ case   38:  		/* lis R11, -32222 */
		/* 8225E538h case   38:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225E538h case   38:*/		return 0x8225E53C;
		  /* 8225E53Ch */ case   39:  		/* addi R5, R1, 296 */
		/* 8225E53Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x128);
		/* 8225E53Ch case   39:*/		return 0x8225E540;
		  /* 8225E540h */ case   40:  		/* addi R6, R11, -12392 */
		/* 8225E540h case   40:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225E540h case   40:*/		return 0x8225E544;
		  /* 8225E544h */ case   41:  		/* mr R4, R25 */
		/* 8225E544h case   41:*/		regs.R4 = regs.R25;
		/* 8225E544h case   41:*/		return 0x8225E548;
		  /* 8225E548h */ case   42:  		/* lwz R11, <#[R31 + 12]> */
		/* 8225E548h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E548h case   42:*/		return 0x8225E54C;
		  /* 8225E54Ch */ case   43:  		/* mr R7, R11 */
		/* 8225E54Ch case   43:*/		regs.R7 = regs.R11;
		/* 8225E54Ch case   43:*/		return 0x8225E550;
		  /* 8225E550h */ case   44:  		/* lwz R3, <#[R11 + 1536]> */
		/* 8225E550h case   44:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000600) );
		/* 8225E550h case   44:*/		return 0x8225E554;
		  /* 8225E554h */ case   45:  		/* bl -172948 */
		/* 8225E554h case   45:*/		regs.LR = 0x8225E558; return 0x822341C0;
		/* 8225E554h case   45:*/		return 0x8225E558;
		  /* 8225E558h */ case   46:  		/* cmplwi CR6, R16, 0 */
		/* 8225E558h case   46:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225E558h case   46:*/		return 0x8225E55C;
		  /* 8225E55Ch */ case   47:  		/* fmr FR1, FR30 */
		/* 8225E55Ch case   47:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8225E55Ch case   47:*/		return 0x8225E560;
		  /* 8225E560h */ case   48:  		/* li R5, 4 */
		/* 8225E560h case   48:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225E560h case   48:*/		return 0x8225E564;
		  /* 8225E564h */ case   49:  		/* li R4, 3 */
		/* 8225E564h case   49:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225E564h case   49:*/		return 0x8225E568;
		  /* 8225E568h */ case   50:  		/* bc 12, CR6_EQ, 872 */
		/* 8225E568h case   50:*/		if ( regs.CR[6].eq ) { return 0x8225E8D0;  }
		/* 8225E568h case   50:*/		return 0x8225E56C;
		  /* 8225E56Ch */ case   51:  		/* bl -35124 */
		/* 8225E56Ch case   51:*/		regs.LR = 0x8225E570; return 0x82255C38;
		/* 8225E56Ch case   51:*/		return 0x8225E570;
		  /* 8225E570h */ case   52:  		/* sth R3, <#[R23 + 22]> */
		/* 8225E570h case   52:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000016) );
		/* 8225E570h case   52:*/		return 0x8225E574;
		  /* 8225E574h */ case   53:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225E574h case   53:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E574h case   53:*/		return 0x8225E578;
		  /* 8225E578h */ case   54:  		/* li R4, 0 */
		/* 8225E578h case   54:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E578h case   54:*/		return 0x8225E57C;
		  /* 8225E57Ch */ case   55:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225E57Ch case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225E57Ch case   55:*/		return 0x8225E580;
		  /* 8225E580h */ case   56:  		/* addi R5, R11, -1 */
		/* 8225E580h case   56:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225E580h case   56:*/		return 0x8225E584;
		  /* 8225E584h */ case   57:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225E584h case   57:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225E584h case   57:*/		return 0x8225E588;
		  /* 8225E588h */ case   58:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225E588h case   58:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225E588h case   58:*/		return 0x8225E58C;
		  /* 8225E58Ch */ case   59:  		/* bl -101756 */
		/* 8225E58Ch case   59:*/		regs.LR = 0x8225E590; return 0x82245810;
		/* 8225E58Ch case   59:*/		return 0x8225E590;
		  /* 8225E590h */ case   60:  		/* mr R29, R3 */
		/* 8225E590h case   60:*/		regs.R29 = regs.R3;
		/* 8225E590h case   60:*/		return 0x8225E594;
		  /* 8225E594h */ case   61:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E594h case   61:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E594h case   61:*/		return 0x8225E598;
		  /* 8225E598h */ case   62:  		/* li R3, 18 */
		/* 8225E598h case   62:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 8225E598h case   62:*/		return 0x8225E59C;
		  /* 8225E59Ch */ case   63:  		/* bl -34412 */
		/* 8225E59Ch case   63:*/		regs.LR = 0x8225E5A0; return 0x82255F30;
		/* 8225E59Ch case   63:*/		return 0x8225E5A0;
		  /* 8225E5A0h */ case   64:  		/* mr R5, R29 */
		/* 8225E5A0h case   64:*/		regs.R5 = regs.R29;
		/* 8225E5A0h case   64:*/		return 0x8225E5A4;
		  /* 8225E5A4h */ case   65:  		/* li R4, 0 */
		/* 8225E5A4h case   65:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E5A4h case   65:*/		return 0x8225E5A8;
		  /* 8225E5A8h */ case   66:  		/* mr R30, R3 */
		/* 8225E5A8h case   66:*/		regs.R30 = regs.R3;
		/* 8225E5A8h case   66:*/		return 0x8225E5AC;
		  /* 8225E5ACh */ case   67:  		/* bl -33300 */
		/* 8225E5ACh case   67:*/		regs.LR = 0x8225E5B0; return 0x82256398;
		/* 8225E5ACh case   67:*/		return 0x8225E5B0;
		  /* 8225E5B0h */ case   68:  		/* mr R3, R30 */
		/* 8225E5B0h case   68:*/		regs.R3 = regs.R30;
		/* 8225E5B0h case   68:*/		return 0x8225E5B4;
		  /* 8225E5B4h */ case   69:  		/* mr R5, R27 */
		/* 8225E5B4h case   69:*/		regs.R5 = regs.R27;
		/* 8225E5B4h case   69:*/		return 0x8225E5B8;
		  /* 8225E5B8h */ case   70:  		/* li R4, 1 */
		/* 8225E5B8h case   70:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E5B8h case   70:*/		return 0x8225E5BC;
		  /* 8225E5BCh */ case   71:  		/* bl -33316 */
		/* 8225E5BCh case   71:*/		regs.LR = 0x8225E5C0; return 0x82256398;
		/* 8225E5BCh case   71:*/		return 0x8225E5C0;
		  /* 8225E5C0h */ case   72:  		/* lwz R11, <#[R1 + 136]> */
		/* 8225E5C0h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 8225E5C0h case   72:*/		return 0x8225E5C4;
		  /* 8225E5C4h */ case   73:  		/* mr R3, R30 */
		/* 8225E5C4h case   73:*/		regs.R3 = regs.R30;
		/* 8225E5C4h case   73:*/		return 0x8225E5C8;
		  /* 8225E5C8h */ case   74:  		/* li R5, 2 */
		/* 8225E5C8h case   74:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225E5C8h case   74:*/		return 0x8225E5CC;
		  /* 8225E5CCh */ case   75:  		/* mr R4, R31 */
		/* 8225E5CCh case   75:*/		regs.R4 = regs.R31;
		/* 8225E5CCh case   75:*/		return 0x8225E5D0;
		  /* 8225E5D0h */ case   76:  		/* lwz R11, <#[R11 - 1272]> */
		/* 8225E5D0h case   76:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFB08) );
		/* 8225E5D0h case   76:*/		return 0x8225E5D4;
		  /* 8225E5D4h */ case   77:  		/* stw R11, <#[R30 + 132]> */
		/* 8225E5D4h case   77:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225E5D4h case   77:*/		return 0x8225E5D8;
		  /* 8225E5D8h */ case   78:  		/* lfs FR4, <#[R1 + 216]> */
		/* 8225E5D8h case   78:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225E5D8h case   78:*/		return 0x8225E5DC;
		  /* 8225E5DCh */ case   79:  		/* fmr FR3, FR4 */
		/* 8225E5DCh case   79:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225E5DCh case   79:*/		return 0x8225E5E0;
		  /* 8225E5E0h */ case   80:  		/* fmr FR2, FR4 */
		/* 8225E5E0h case   80:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225E5E0h case   80:*/		return 0x8225E5E4;
		  /* 8225E5E4h */ case   81:  		/* fmr FR1, FR4 */
		/* 8225E5E4h case   81:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225E5E4h case   81:*/		return 0x8225E5E8;
		  /* 8225E5E8h */ case   82:  		/* bl -30416 */
		/* 8225E5E8h case   82:*/		regs.LR = 0x8225E5EC; return 0x82256F18;
		/* 8225E5E8h case   82:*/		return 0x8225E5EC;
		  /* 8225E5ECh */ case   83:  		/* mr R4, R30 */
		/* 8225E5ECh case   83:*/		regs.R4 = regs.R30;
		/* 8225E5ECh case   83:*/		return 0x8225E5F0;
		  /* 8225E5F0h */ case   84:  		/* mr R3, R31 */
		/* 8225E5F0h case   84:*/		regs.R3 = regs.R31;
		/* 8225E5F0h case   84:*/		return 0x8225E5F4;
		  /* 8225E5F4h */ case   85:  		/* bl -163916 */
		/* 8225E5F4h case   85:*/		regs.LR = 0x8225E5F8; return 0x822365A8;
		/* 8225E5F4h case   85:*/		return 0x8225E5F8;
		  /* 8225E5F8h */ case   86:  		/* mr R4, R30 */
		/* 8225E5F8h case   86:*/		regs.R4 = regs.R30;
		/* 8225E5F8h case   86:*/		return 0x8225E5FC;
		  /* 8225E5FCh */ case   87:  		/* mr R3, R14 */
		/* 8225E5FCh case   87:*/		regs.R3 = regs.R14;
		/* 8225E5FCh case   87:*/		return 0x8225E600;
		  /* 8225E600h */ case   88:  		/* bl -22224 */
		/* 8225E600h case   88:*/		regs.LR = 0x8225E604; return 0x82258F30;
		/* 8225E600h case   88:*/		return 0x8225E604;
		  /* 8225E604h */ case   89:  		/* mr R3, R30 */
		/* 8225E604h case   89:*/		regs.R3 = regs.R30;
		/* 8225E604h case   89:*/		return 0x8225E608;
		  /* 8225E608h */ case   90:  		/* bl -34376 */
		/* 8225E608h case   90:*/		regs.LR = 0x8225E60C; return 0x82255FC0;
		/* 8225E608h case   90:*/		return 0x8225E60C;
		  /* 8225E60Ch */ case   91:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E60Ch case   91:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E60Ch case   91:*/		return 0x8225E610;
		  /* 8225E610h */ case   92:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E610h case   92:*/		if ( !regs.CR[0].eq ) { return 0x8225E62C;  }
		/* 8225E610h case   92:*/		return 0x8225E614;
		  /* 8225E614h */ case   93:  		/* li R7, 2562 */
		/* 8225E614h case   93:*/		cpu::op::li<0>(regs,&regs.R7,0xA02);
		/* 8225E614h case   93:*/		return 0x8225E618;
		  /* 8225E618h */ case   94:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E618h case   94:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E618h case   94:*/		return 0x8225E61C;
		  /* 8225E61Ch */ case   95:  		/* li R3, 0 */
		/* 8225E61Ch case   95:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E61Ch case   95:*/		return 0x8225E620;
		  /* 8225E620h */ case   96:  		/* lwz R5, <#[R1 + 280]> */
		/* 8225E620h case   96:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000118) );
		/* 8225E620h case   96:*/		return 0x8225E624;
		  /* 8225E624h */ case   97:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E624h case   97:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E624h case   97:*/		return 0x8225E628;
		  /* 8225E628h */ case   98:  		/* bl -1075744 */
		/* 8225E628h case   98:*/		regs.LR = 0x8225E62C; return 0x82157C08;
		/* 8225E628h case   98:*/		return 0x8225E62C;
	}
	return 0x8225E62C;
} // Block from 8225E4A0h-8225E62Ch (99 instructions)

//////////////////////////////////////////////////////
// Block at 8225E62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E62C);
		  /* 8225E62Ch */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 8225E62Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8225E62Ch case    0:*/		return 0x8225E630;
		  /* 8225E630h */ case    1:  		/* bc 4, CR6_EQ, 304 */
		/* 8225E630h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8225E760;  }
		/* 8225E630h case    1:*/		return 0x8225E634;
		  /* 8225E634h */ case    2:  		/* li R3, 110 */
		/* 8225E634h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x6E);
		/* 8225E634h case    2:*/		return 0x8225E638;
		  /* 8225E638h */ case    3:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E638h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E638h case    3:*/		return 0x8225E63C;
		  /* 8225E63Ch */ case    4:  		/* bl -34572 */
		/* 8225E63Ch case    4:*/		regs.LR = 0x8225E640; return 0x82255F30;
		/* 8225E63Ch case    4:*/		return 0x8225E640;
		  /* 8225E640h */ case    5:  		/* mr R5, R29 */
		/* 8225E640h case    5:*/		regs.R5 = regs.R29;
		/* 8225E640h case    5:*/		return 0x8225E644;
		  /* 8225E644h */ case    6:  		/* li R4, 0 */
		/* 8225E644h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E644h case    6:*/		return 0x8225E648;
		  /* 8225E648h */ case    7:  		/* mr R30, R3 */
		/* 8225E648h case    7:*/		regs.R30 = regs.R3;
		/* 8225E648h case    7:*/		return 0x8225E64C;
		  /* 8225E64Ch */ case    8:  		/* bl -33460 */
		/* 8225E64Ch case    8:*/		regs.LR = 0x8225E650; return 0x82256398;
		/* 8225E64Ch case    8:*/		return 0x8225E650;
		  /* 8225E650h */ case    9:  		/* lwz R28, <#[R1 + 136]> */
		/* 8225E650h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000088) );
		/* 8225E650h case    9:*/		return 0x8225E654;
		  /* 8225E654h */ case   10:  		/* mr R5, R19 */
		/* 8225E654h case   10:*/		regs.R5 = regs.R19;
		/* 8225E654h case   10:*/		return 0x8225E658;
		  /* 8225E658h */ case   11:  		/* li R4, 1 */
		/* 8225E658h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E658h case   11:*/		return 0x8225E65C;
		  /* 8225E65Ch */ case   12:  		/* mr R3, R30 */
		/* 8225E65Ch case   12:*/		regs.R3 = regs.R30;
		/* 8225E65Ch case   12:*/		return 0x8225E660;
		  /* 8225E660h */ case   13:  		/* lwz R11, <#[R28 - 1292]> */
		/* 8225E660h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFAF4) );
		/* 8225E660h case   13:*/		return 0x8225E664;
		  /* 8225E664h */ case   14:  		/* stw R11, <#[R30 + 128]> */
		/* 8225E664h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225E664h case   14:*/		return 0x8225E668;
		  /* 8225E668h */ case   15:  		/* bl -33488 */
		/* 8225E668h case   15:*/		regs.LR = 0x8225E66C; return 0x82256398;
		/* 8225E668h case   15:*/		return 0x8225E66C;
		  /* 8225E66Ch */ case   16:  		/* stw R25, <#[R30 + 176]> */
		/* 8225E66Ch case   16:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x000000B0) );
		/* 8225E66Ch case   16:*/		return 0x8225E670;
		  /* 8225E670h */ case   17:  		/* mr R4, R25 */
		/* 8225E670h case   17:*/		regs.R4 = regs.R25;
		/* 8225E670h case   17:*/		return 0x8225E674;
		  /* 8225E674h */ case   18:  		/* lwz R3, <#[R31 + 12]> */
		/* 8225E674h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E674h case   18:*/		return 0x8225E678;
		  /* 8225E678h */ case   19:  		/* bl -270264 */
		/* 8225E678h case   19:*/		regs.LR = 0x8225E67C; return 0x8221C6C0;
		/* 8225E678h case   19:*/		return 0x8225E67C;
		  /* 8225E67Ch */ case   20:  		/* stw R3, <#[R30 + 172]> */
		/* 8225E67Ch case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 8225E67Ch case   20:*/		return 0x8225E680;
		  /* 8225E680h */ case   21:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225E680h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225E680h case   21:*/		return 0x8225E684;
		  /* 8225E684h */ case   22:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225E684h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225E684h case   22:*/		return 0x8225E688;
		  /* 8225E688h */ case   23:  		/* cmplwi CR6, R11, 1 */
		/* 8225E688h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225E688h case   23:*/		return 0x8225E68C;
		  /* 8225E68Ch */ case   24:  		/* bc 12, CR6_LT, 32 */
		/* 8225E68Ch case   24:*/		if ( regs.CR[6].lt ) { return 0x8225E6AC;  }
		/* 8225E68Ch case   24:*/		return 0x8225E690;
		  /* 8225E690h */ case   25:  		/* bc 12, CR6_EQ, 20 */
		/* 8225E690h case   25:*/		if ( regs.CR[6].eq ) { return 0x8225E6A4;  }
		/* 8225E690h case   25:*/		return 0x8225E694;
		  /* 8225E694h */ case   26:  		/* cmplwi CR6, R11, 3 */
		/* 8225E694h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225E694h case   26:*/		return 0x8225E698;
		  /* 8225E698h */ case   27:  		/* bc 4, CR6_LT, 20 */
		/* 8225E698h case   27:*/		if ( !regs.CR[6].lt ) { return 0x8225E6AC;  }
		/* 8225E698h case   27:*/		return 0x8225E69C;
		  /* 8225E69Ch */ case   28:  		/* li R11, 1 */
		/* 8225E69Ch case   28:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225E69Ch case   28:*/		return 0x8225E6A0;
		  /* 8225E6A0h */ case   29:  		/* b 16 */
		/* 8225E6A0h case   29:*/		return 0x8225E6B0;
		/* 8225E6A0h case   29:*/		return 0x8225E6A4;
	}
	return 0x8225E6A4;
} // Block from 8225E62Ch-8225E6A4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8225E6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E6A4);
		  /* 8225E6A4h */ case    0:  		/* li R11, 0 */
		/* 8225E6A4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225E6A4h case    0:*/		return 0x8225E6A8;
		  /* 8225E6A8h */ case    1:  		/* b 8 */
		/* 8225E6A8h case    1:*/		return 0x8225E6B0;
		/* 8225E6A8h case    1:*/		return 0x8225E6AC;
	}
	return 0x8225E6AC;
} // Block from 8225E6A4h-8225E6ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225E6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E6AC);
		  /* 8225E6ACh */ case    0:  		/* li R11, 2 */
		/* 8225E6ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225E6ACh case    0:*/		return 0x8225E6B0;
	}
	return 0x8225E6B0;
} // Block from 8225E6ACh-8225E6B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225E6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E6B0);
		  /* 8225E6B0h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225E6B0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225E6B0h case    0:*/		return 0x8225E6B4;
		  /* 8225E6B4h */ case    1:  		/* mr R4, R30 */
		/* 8225E6B4h case    1:*/		regs.R4 = regs.R30;
		/* 8225E6B4h case    1:*/		return 0x8225E6B8;
		  /* 8225E6B8h */ case    2:  		/* mr R3, R31 */
		/* 8225E6B8h case    2:*/		regs.R3 = regs.R31;
		/* 8225E6B8h case    2:*/		return 0x8225E6BC;
		  /* 8225E6BCh */ case    3:  		/* bl -164116 */
		/* 8225E6BCh case    3:*/		regs.LR = 0x8225E6C0; return 0x822365A8;
		/* 8225E6BCh case    3:*/		return 0x8225E6C0;
		  /* 8225E6C0h */ case    4:  		/* mr R4, R30 */
		/* 8225E6C0h case    4:*/		regs.R4 = regs.R30;
		/* 8225E6C0h case    4:*/		return 0x8225E6C4;
		  /* 8225E6C4h */ case    5:  		/* mr R3, R14 */
		/* 8225E6C4h case    5:*/		regs.R3 = regs.R14;
		/* 8225E6C4h case    5:*/		return 0x8225E6C8;
		  /* 8225E6C8h */ case    6:  		/* bl -22424 */
		/* 8225E6C8h case    6:*/		regs.LR = 0x8225E6CC; return 0x82258F30;
		/* 8225E6C8h case    6:*/		return 0x8225E6CC;
		  /* 8225E6CCh */ case    7:  		/* mr R3, R30 */
		/* 8225E6CCh case    7:*/		regs.R3 = regs.R30;
		/* 8225E6CCh case    7:*/		return 0x8225E6D0;
		  /* 8225E6D0h */ case    8:  		/* bl -34576 */
		/* 8225E6D0h case    8:*/		regs.LR = 0x8225E6D4; return 0x82255FC0;
		/* 8225E6D0h case    8:*/		return 0x8225E6D4;
		  /* 8225E6D4h */ case    9:  		/* li R3, 18 */
		/* 8225E6D4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 8225E6D4h case    9:*/		return 0x8225E6D8;
		  /* 8225E6D8h */ case   10:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E6D8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E6D8h case   10:*/		return 0x8225E6DC;
		  /* 8225E6DCh */ case   11:  		/* bl -34732 */
		/* 8225E6DCh case   11:*/		regs.LR = 0x8225E6E0; return 0x82255F30;
		/* 8225E6DCh case   11:*/		return 0x8225E6E0;
		  /* 8225E6E0h */ case   12:  		/* mr R5, R29 */
		/* 8225E6E0h case   12:*/		regs.R5 = regs.R29;
		/* 8225E6E0h case   12:*/		return 0x8225E6E4;
		  /* 8225E6E4h */ case   13:  		/* li R4, 0 */
		/* 8225E6E4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E6E4h case   13:*/		return 0x8225E6E8;
		  /* 8225E6E8h */ case   14:  		/* mr R30, R3 */
		/* 8225E6E8h case   14:*/		regs.R30 = regs.R3;
		/* 8225E6E8h case   14:*/		return 0x8225E6EC;
		  /* 8225E6ECh */ case   15:  		/* bl -33620 */
		/* 8225E6ECh case   15:*/		regs.LR = 0x8225E6F0; return 0x82256398;
		/* 8225E6ECh case   15:*/		return 0x8225E6F0;
		  /* 8225E6F0h */ case   16:  		/* mr R3, R30 */
		/* 8225E6F0h case   16:*/		regs.R3 = regs.R30;
		/* 8225E6F0h case   16:*/		return 0x8225E6F4;
		  /* 8225E6F4h */ case   17:  		/* mr R5, R29 */
		/* 8225E6F4h case   17:*/		regs.R5 = regs.R29;
		/* 8225E6F4h case   17:*/		return 0x8225E6F8;
		  /* 8225E6F8h */ case   18:  		/* li R4, 1 */
		/* 8225E6F8h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E6F8h case   18:*/		return 0x8225E6FC;
		  /* 8225E6FCh */ case   19:  		/* bl -33636 */
		/* 8225E6FCh case   19:*/		regs.LR = 0x8225E700; return 0x82256398;
		/* 8225E6FCh case   19:*/		return 0x8225E700;
		  /* 8225E700h */ case   20:  		/* lwz R11, <#[R28 - 1272]> */
		/* 8225E700h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFB08) );
		/* 8225E700h case   20:*/		return 0x8225E704;
		  /* 8225E704h */ case   21:  		/* mr R3, R30 */
		/* 8225E704h case   21:*/		regs.R3 = regs.R30;
		/* 8225E704h case   21:*/		return 0x8225E708;
		  /* 8225E708h */ case   22:  		/* mr R5, R29 */
		/* 8225E708h case   22:*/		regs.R5 = regs.R29;
		/* 8225E708h case   22:*/		return 0x8225E70C;
		  /* 8225E70Ch */ case   23:  		/* li R4, 2 */
		/* 8225E70Ch case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225E70Ch case   23:*/		return 0x8225E710;
		  /* 8225E710h */ case   24:  		/* stw R11, <#[R30 + 132]> */
		/* 8225E710h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225E710h case   24:*/		return 0x8225E714;
		  /* 8225E714h */ case   25:  		/* bl -33660 */
		/* 8225E714h case   25:*/		regs.LR = 0x8225E718; return 0x82256398;
		/* 8225E714h case   25:*/		return 0x8225E718;
		  /* 8225E718h */ case   26:  		/* lwz R11, <#[R28 - 1284]> */
		/* 8225E718h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFAFC) );
		/* 8225E718h case   26:*/		return 0x8225E71C;
		  /* 8225E71Ch */ case   27:  		/* mr R4, R30 */
		/* 8225E71Ch case   27:*/		regs.R4 = regs.R30;
		/* 8225E71Ch case   27:*/		return 0x8225E720;
		  /* 8225E720h */ case   28:  		/* mr R3, R31 */
		/* 8225E720h case   28:*/		regs.R3 = regs.R31;
		/* 8225E720h case   28:*/		return 0x8225E724;
		  /* 8225E724h */ case   29:  		/* stw R11, <#[R30 + 136]> */
		/* 8225E724h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 8225E724h case   29:*/		return 0x8225E728;
		  /* 8225E728h */ case   30:  		/* bl -164224 */
		/* 8225E728h case   30:*/		regs.LR = 0x8225E72C; return 0x822365A8;
		/* 8225E728h case   30:*/		return 0x8225E72C;
		  /* 8225E72Ch */ case   31:  		/* mr R4, R30 */
		/* 8225E72Ch case   31:*/		regs.R4 = regs.R30;
		/* 8225E72Ch case   31:*/		return 0x8225E730;
		  /* 8225E730h */ case   32:  		/* mr R3, R14 */
		/* 8225E730h case   32:*/		regs.R3 = regs.R14;
		/* 8225E730h case   32:*/		return 0x8225E734;
		  /* 8225E734h */ case   33:  		/* bl -22532 */
		/* 8225E734h case   33:*/		regs.LR = 0x8225E738; return 0x82258F30;
		/* 8225E734h case   33:*/		return 0x8225E738;
		  /* 8225E738h */ case   34:  		/* mr R3, R30 */
		/* 8225E738h case   34:*/		regs.R3 = regs.R30;
		/* 8225E738h case   34:*/		return 0x8225E73C;
		  /* 8225E73Ch */ case   35:  		/* bl -34684 */
		/* 8225E73Ch case   35:*/		regs.LR = 0x8225E740; return 0x82255FC0;
		/* 8225E73Ch case   35:*/		return 0x8225E740;
		  /* 8225E740h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E740h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E740h case   36:*/		return 0x8225E744;
		  /* 8225E744h */ case   37:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E744h case   37:*/		if ( !regs.CR[0].eq ) { return 0x8225E760;  }
		/* 8225E744h case   37:*/		return 0x8225E748;
		  /* 8225E748h */ case   38:  		/* li R7, 2588 */
		/* 8225E748h case   38:*/		cpu::op::li<0>(regs,&regs.R7,0xA1C);
		/* 8225E748h case   38:*/		return 0x8225E74C;
		  /* 8225E74Ch */ case   39:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E74Ch case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E74Ch case   39:*/		return 0x8225E750;
		  /* 8225E750h */ case   40:  		/* li R3, 0 */
		/* 8225E750h case   40:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E750h case   40:*/		return 0x8225E754;
		  /* 8225E754h */ case   41:  		/* lwz R5, <#[R1 + 280]> */
		/* 8225E754h case   41:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000118) );
		/* 8225E754h case   41:*/		return 0x8225E758;
		  /* 8225E758h */ case   42:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E758h case   42:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E758h case   42:*/		return 0x8225E75C;
		  /* 8225E75Ch */ case   43:  		/* bl -1076052 */
		/* 8225E75Ch case   43:*/		regs.LR = 0x8225E760; return 0x82157C08;
		/* 8225E75Ch case   43:*/		return 0x8225E760;
	}
	return 0x8225E760;
} // Block from 8225E6B0h-8225E760h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225E760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E760);
		  /* 8225E760h */ case    0:  		/* li R11, 0 */
		/* 8225E760h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225E760h case    0:*/		return 0x8225E764;
		  /* 8225E764h */ case    1:  		/* li R10, 1 */
		/* 8225E764h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8225E764h case    1:*/		return 0x8225E768;
		  /* 8225E768h */ case    2:  		/* sth R11, <#[R23 + 14]> */
		/* 8225E768h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000000E) );
		/* 8225E768h case    2:*/		return 0x8225E76C;
		  /* 8225E76Ch */ case    3:  		/* li R3, 25 */
		/* 8225E76Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x19);
		/* 8225E76Ch case    3:*/		return 0x8225E770;
		  /* 8225E770h */ case    4:  		/* sth R10, <#[R23 + 16]> */
		/* 8225E770h case    4:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8225E770h case    4:*/		return 0x8225E774;
		  /* 8225E774h */ case    5:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E774h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E774h case    5:*/		return 0x8225E778;
		  /* 8225E778h */ case    6:  		/* bl -34888 */
		/* 8225E778h case    6:*/		regs.LR = 0x8225E77C; return 0x82255F30;
		/* 8225E778h case    6:*/		return 0x8225E77C;
		  /* 8225E77Ch */ case    7:  		/* mr R5, R29 */
		/* 8225E77Ch case    7:*/		regs.R5 = regs.R29;
		/* 8225E77Ch case    7:*/		return 0x8225E780;
		  /* 8225E780h */ case    8:  		/* li R4, 0 */
		/* 8225E780h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E780h case    8:*/		return 0x8225E784;
		  /* 8225E784h */ case    9:  		/* mr R30, R3 */
		/* 8225E784h case    9:*/		regs.R30 = regs.R3;
		/* 8225E784h case    9:*/		return 0x8225E788;
		  /* 8225E788h */ case   10:  		/* bl -33776 */
		/* 8225E788h case   10:*/		regs.LR = 0x8225E78C; return 0x82256398;
		/* 8225E788h case   10:*/		return 0x8225E78C;
		  /* 8225E78Ch */ case   11:  		/* mr R3, R30 */
		/* 8225E78Ch case   11:*/		regs.R3 = regs.R30;
		/* 8225E78Ch case   11:*/		return 0x8225E790;
		  /* 8225E790h */ case   12:  		/* mr R5, R29 */
		/* 8225E790h case   12:*/		regs.R5 = regs.R29;
		/* 8225E790h case   12:*/		return 0x8225E794;
		  /* 8225E794h */ case   13:  		/* li R4, 1 */
		/* 8225E794h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E794h case   13:*/		return 0x8225E798;
		  /* 8225E798h */ case   14:  		/* bl -33792 */
		/* 8225E798h case   14:*/		regs.LR = 0x8225E79C; return 0x82256398;
		/* 8225E798h case   14:*/		return 0x8225E79C;
		  /* 8225E79Ch */ case   15:  		/* lfs FR4, <#[R1 + 288]> */
		/* 8225E79Ch case   15:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x00000120) );
		/* 8225E79Ch case   15:*/		return 0x8225E7A0;
		  /* 8225E7A0h */ case   16:  		/* mr R3, R30 */
		/* 8225E7A0h case   16:*/		regs.R3 = regs.R30;
		/* 8225E7A0h case   16:*/		return 0x8225E7A4;
		  /* 8225E7A4h */ case   17:  		/* fmr FR3, FR4 */
		/* 8225E7A4h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225E7A4h case   17:*/		return 0x8225E7A8;
		  /* 8225E7A8h */ case   18:  		/* li R5, 2 */
		/* 8225E7A8h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225E7A8h case   18:*/		return 0x8225E7AC;
		  /* 8225E7ACh */ case   19:  		/* fmr FR2, FR4 */
		/* 8225E7ACh case   19:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225E7ACh case   19:*/		return 0x8225E7B0;
		  /* 8225E7B0h */ case   20:  		/* mr R4, R31 */
		/* 8225E7B0h case   20:*/		regs.R4 = regs.R31;
		/* 8225E7B0h case   20:*/		return 0x8225E7B4;
		  /* 8225E7B4h */ case   21:  		/* fmr FR1, FR4 */
		/* 8225E7B4h case   21:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225E7B4h case   21:*/		return 0x8225E7B8;
		  /* 8225E7B8h */ case   22:  		/* bl -30880 */
		/* 8225E7B8h case   22:*/		regs.LR = 0x8225E7BC; return 0x82256F18;
		/* 8225E7B8h case   22:*/		return 0x8225E7BC;
		  /* 8225E7BCh */ case   23:  		/* mr R4, R30 */
		/* 8225E7BCh case   23:*/		regs.R4 = regs.R30;
		/* 8225E7BCh case   23:*/		return 0x8225E7C0;
		  /* 8225E7C0h */ case   24:  		/* mr R3, R31 */
		/* 8225E7C0h case   24:*/		regs.R3 = regs.R31;
		/* 8225E7C0h case   24:*/		return 0x8225E7C4;
		  /* 8225E7C4h */ case   25:  		/* bl -164380 */
		/* 8225E7C4h case   25:*/		regs.LR = 0x8225E7C8; return 0x822365A8;
		/* 8225E7C4h case   25:*/		return 0x8225E7C8;
		  /* 8225E7C8h */ case   26:  		/* mr R4, R30 */
		/* 8225E7C8h case   26:*/		regs.R4 = regs.R30;
		/* 8225E7C8h case   26:*/		return 0x8225E7CC;
		  /* 8225E7CCh */ case   27:  		/* mr R3, R14 */
		/* 8225E7CCh case   27:*/		regs.R3 = regs.R14;
		/* 8225E7CCh case   27:*/		return 0x8225E7D0;
		  /* 8225E7D0h */ case   28:  		/* bl -22688 */
		/* 8225E7D0h case   28:*/		regs.LR = 0x8225E7D4; return 0x82258F30;
		/* 8225E7D0h case   28:*/		return 0x8225E7D4;
		  /* 8225E7D4h */ case   29:  		/* mr R3, R30 */
		/* 8225E7D4h case   29:*/		regs.R3 = regs.R30;
		/* 8225E7D4h case   29:*/		return 0x8225E7D8;
		  /* 8225E7D8h */ case   30:  		/* bl -34840 */
		/* 8225E7D8h case   30:*/		regs.LR = 0x8225E7DC; return 0x82255FC0;
		/* 8225E7D8h case   30:*/		return 0x8225E7DC;
		  /* 8225E7DCh */ case   31:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E7DCh case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E7DCh case   31:*/		return 0x8225E7E0;
		  /* 8225E7E0h */ case   32:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E7E0h case   32:*/		if ( !regs.CR[0].eq ) { return 0x8225E7FC;  }
		/* 8225E7E0h case   32:*/		return 0x8225E7E4;
		  /* 8225E7E4h */ case   33:  		/* li R7, 2603 */
		/* 8225E7E4h case   33:*/		cpu::op::li<0>(regs,&regs.R7,0xA2B);
		/* 8225E7E4h case   33:*/		return 0x8225E7E8;
		  /* 8225E7E8h */ case   34:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E7E8h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E7E8h case   34:*/		return 0x8225E7EC;
		  /* 8225E7ECh */ case   35:  		/* li R3, 0 */
		/* 8225E7ECh case   35:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E7ECh case   35:*/		return 0x8225E7F0;
		  /* 8225E7F0h */ case   36:  		/* lwz R5, <#[R1 + 352]> */
		/* 8225E7F0h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000160) );
		/* 8225E7F0h case   36:*/		return 0x8225E7F4;
		  /* 8225E7F4h */ case   37:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E7F4h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E7F4h case   37:*/		return 0x8225E7F8;
		  /* 8225E7F8h */ case   38:  		/* bl -1076208 */
		/* 8225E7F8h case   38:*/		regs.LR = 0x8225E7FC; return 0x82157C08;
		/* 8225E7F8h case   38:*/		return 0x8225E7FC;
	}
	return 0x8225E7FC;
} // Block from 8225E760h-8225E7FCh (39 instructions)

//////////////////////////////////////////////////////
// Block at 8225E7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E7FC);
		  /* 8225E7FCh */ case    0:  		/* li R3, 23 */
		/* 8225E7FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x17);
		/* 8225E7FCh case    0:*/		return 0x8225E800;
		  /* 8225E800h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E800h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E800h case    1:*/		return 0x8225E804;
		  /* 8225E804h */ case    2:  		/* bl -35028 */
		/* 8225E804h case    2:*/		regs.LR = 0x8225E808; return 0x82255F30;
		/* 8225E804h case    2:*/		return 0x8225E808;
		  /* 8225E808h */ case    3:  		/* mr R5, R29 */
		/* 8225E808h case    3:*/		regs.R5 = regs.R29;
		/* 8225E808h case    3:*/		return 0x8225E80C;
		  /* 8225E80Ch */ case    4:  		/* li R4, 0 */
		/* 8225E80Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E80Ch case    4:*/		return 0x8225E810;
		  /* 8225E810h */ case    5:  		/* mr R30, R3 */
		/* 8225E810h case    5:*/		regs.R30 = regs.R3;
		/* 8225E810h case    5:*/		return 0x8225E814;
		  /* 8225E814h */ case    6:  		/* bl -33916 */
		/* 8225E814h case    6:*/		regs.LR = 0x8225E818; return 0x82256398;
		/* 8225E814h case    6:*/		return 0x8225E818;
		  /* 8225E818h */ case    7:  		/* mr R3, R30 */
		/* 8225E818h case    7:*/		regs.R3 = regs.R30;
		/* 8225E818h case    7:*/		return 0x8225E81C;
		  /* 8225E81Ch */ case    8:  		/* mr R5, R29 */
		/* 8225E81Ch case    8:*/		regs.R5 = regs.R29;
		/* 8225E81Ch case    8:*/		return 0x8225E820;
		  /* 8225E820h */ case    9:  		/* li R4, 1 */
		/* 8225E820h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E820h case    9:*/		return 0x8225E824;
		  /* 8225E824h */ case   10:  		/* bl -33932 */
		/* 8225E824h case   10:*/		regs.LR = 0x8225E828; return 0x82256398;
		/* 8225E824h case   10:*/		return 0x8225E828;
		  /* 8225E828h */ case   11:  		/* lfs FR4, <#[R1 + 296]> */
		/* 8225E828h case   11:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x00000128) );
		/* 8225E828h case   11:*/		return 0x8225E82C;
		  /* 8225E82Ch */ case   12:  		/* mr R3, R30 */
		/* 8225E82Ch case   12:*/		regs.R3 = regs.R30;
		/* 8225E82Ch case   12:*/		return 0x8225E830;
		  /* 8225E830h */ case   13:  		/* fmr FR3, FR4 */
		/* 8225E830h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225E830h case   13:*/		return 0x8225E834;
		  /* 8225E834h */ case   14:  		/* li R5, 2 */
		/* 8225E834h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225E834h case   14:*/		return 0x8225E838;
		  /* 8225E838h */ case   15:  		/* fmr FR2, FR4 */
		/* 8225E838h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225E838h case   15:*/		return 0x8225E83C;
		  /* 8225E83Ch */ case   16:  		/* mr R4, R31 */
		/* 8225E83Ch case   16:*/		regs.R4 = regs.R31;
		/* 8225E83Ch case   16:*/		return 0x8225E840;
		  /* 8225E840h */ case   17:  		/* fmr FR1, FR4 */
		/* 8225E840h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225E840h case   17:*/		return 0x8225E844;
		  /* 8225E844h */ case   18:  		/* bl -31020 */
		/* 8225E844h case   18:*/		regs.LR = 0x8225E848; return 0x82256F18;
		/* 8225E844h case   18:*/		return 0x8225E848;
		  /* 8225E848h */ case   19:  		/* mr R4, R30 */
		/* 8225E848h case   19:*/		regs.R4 = regs.R30;
		/* 8225E848h case   19:*/		return 0x8225E84C;
		  /* 8225E84Ch */ case   20:  		/* mr R3, R31 */
		/* 8225E84Ch case   20:*/		regs.R3 = regs.R31;
		/* 8225E84Ch case   20:*/		return 0x8225E850;
		  /* 8225E850h */ case   21:  		/* bl -164520 */
		/* 8225E850h case   21:*/		regs.LR = 0x8225E854; return 0x822365A8;
		/* 8225E850h case   21:*/		return 0x8225E854;
		  /* 8225E854h */ case   22:  		/* mr R4, R30 */
		/* 8225E854h case   22:*/		regs.R4 = regs.R30;
		/* 8225E854h case   22:*/		return 0x8225E858;
		  /* 8225E858h */ case   23:  		/* mr R3, R14 */
		/* 8225E858h case   23:*/		regs.R3 = regs.R14;
		/* 8225E858h case   23:*/		return 0x8225E85C;
		  /* 8225E85Ch */ case   24:  		/* bl -22828 */
		/* 8225E85Ch case   24:*/		regs.LR = 0x8225E860; return 0x82258F30;
		/* 8225E85Ch case   24:*/		return 0x8225E860;
		  /* 8225E860h */ case   25:  		/* mr R3, R30 */
		/* 8225E860h case   25:*/		regs.R3 = regs.R30;
		/* 8225E860h case   25:*/		return 0x8225E864;
		  /* 8225E864h */ case   26:  		/* bl -34980 */
		/* 8225E864h case   26:*/		regs.LR = 0x8225E868; return 0x82255FC0;
		/* 8225E864h case   26:*/		return 0x8225E868;
		  /* 8225E868h */ case   27:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225E868h case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225E868h case   27:*/		return 0x8225E86C;
		  /* 8225E86Ch */ case   28:  		/* bc 4, CR0_EQ, 28 */
		/* 8225E86Ch case   28:*/		if ( !regs.CR[0].eq ) { return 0x8225E888;  }
		/* 8225E86Ch case   28:*/		return 0x8225E870;
		  /* 8225E870h */ case   29:  		/* lwz R4, <#[R1 + 132]> */
		/* 8225E870h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8225E870h case   29:*/		return 0x8225E874;
		  /* 8225E874h */ case   30:  		/* li R7, 2612 */
		/* 8225E874h case   30:*/		cpu::op::li<0>(regs,&regs.R7,0xA34);
		/* 8225E874h case   30:*/		return 0x8225E878;
		  /* 8225E878h */ case   31:  		/* li R3, 0 */
		/* 8225E878h case   31:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225E878h case   31:*/		return 0x8225E87C;
		  /* 8225E87Ch */ case   32:  		/* lwz R5, <#[R1 + 304]> */
		/* 8225E87Ch case   32:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000130) );
		/* 8225E87Ch case   32:*/		return 0x8225E880;
		  /* 8225E880h */ case   33:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225E880h case   33:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225E880h case   33:*/		return 0x8225E884;
		  /* 8225E884h */ case   34:  		/* bl -1076348 */
		/* 8225E884h case   34:*/		regs.LR = 0x8225E888; return 0x82157C08;
		/* 8225E884h case   34:*/		return 0x8225E888;
	}
	return 0x8225E888;
} // Block from 8225E7FCh-8225E888h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8225E888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E888);
		  /* 8225E888h */ case    0:  		/* li R3, 113 */
		/* 8225E888h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x71);
		/* 8225E888h case    0:*/		return 0x8225E88C;
		  /* 8225E88Ch */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E88Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E88Ch case    1:*/		return 0x8225E890;
		  /* 8225E890h */ case    2:  		/* bl -35168 */
		/* 8225E890h case    2:*/		regs.LR = 0x8225E894; return 0x82255F30;
		/* 8225E890h case    2:*/		return 0x8225E894;
		  /* 8225E894h */ case    3:  		/* li R5, 0 */
		/* 8225E894h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225E894h case    3:*/		return 0x8225E898;
		  /* 8225E898h */ case    4:  		/* li R4, 28 */
		/* 8225E898h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 8225E898h case    4:*/		return 0x8225E89C;
		  /* 8225E89Ch */ case    5:  		/* mr R30, R3 */
		/* 8225E89Ch case    5:*/		regs.R30 = regs.R3;
		/* 8225E89Ch case    5:*/		return 0x8225E8A0;
		  /* 8225E8A0h */ case    6:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225E8A0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225E8A0h case    6:*/		return 0x8225E8A4;
		  /* 8225E8A4h */ case    7:  		/* bl -102548 */
		/* 8225E8A4h case    7:*/		regs.LR = 0x8225E8A8; return 0x82245810;
		/* 8225E8A4h case    7:*/		return 0x8225E8A8;
		  /* 8225E8A8h */ case    8:  		/* mr R5, R3 */
		/* 8225E8A8h case    8:*/		regs.R5 = regs.R3;
		/* 8225E8A8h case    8:*/		return 0x8225E8AC;
		  /* 8225E8ACh */ case    9:  		/* stw R3, <#[R1 + 208]> */
		/* 8225E8ACh case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000D0) );
		/* 8225E8ACh case    9:*/		return 0x8225E8B0;
		  /* 8225E8B0h */ case   10:  		/* li R4, 0 */
		/* 8225E8B0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E8B0h case   10:*/		return 0x8225E8B4;
		  /* 8225E8B4h */ case   11:  		/* mr R3, R30 */
		/* 8225E8B4h case   11:*/		regs.R3 = regs.R30;
		/* 8225E8B4h case   11:*/		return 0x8225E8B8;
		  /* 8225E8B8h */ case   12:  		/* bl -34080 */
		/* 8225E8B8h case   12:*/		regs.LR = 0x8225E8BC; return 0x82256398;
		/* 8225E8B8h case   12:*/		return 0x8225E8BC;
		  /* 8225E8BCh */ case   13:  		/* mr R5, R29 */
		/* 8225E8BCh case   13:*/		regs.R5 = regs.R29;
		/* 8225E8BCh case   13:*/		return 0x8225E8C0;
		  /* 8225E8C0h */ case   14:  		/* li R4, 1 */
		/* 8225E8C0h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E8C0h case   14:*/		return 0x8225E8C4;
		  /* 8225E8C4h */ case   15:  		/* mr R3, R30 */
		/* 8225E8C4h case   15:*/		regs.R3 = regs.R30;
		/* 8225E8C4h case   15:*/		return 0x8225E8C8;
		  /* 8225E8C8h */ case   16:  		/* bl -34096 */
		/* 8225E8C8h case   16:*/		regs.LR = 0x8225E8CC; return 0x82256398;
		/* 8225E8C8h case   16:*/		return 0x8225E8CC;
		  /* 8225E8CCh */ case   17:  		/* b 804 */
		/* 8225E8CCh case   17:*/		return 0x8225EBF0;
		/* 8225E8CCh case   17:*/		return 0x8225E8D0;
	}
	return 0x8225E8D0;
} // Block from 8225E888h-8225E8D0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225E8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E8D0);
		  /* 8225E8D0h */ case    0:  		/* bl -35992 */
		/* 8225E8D0h case    0:*/		regs.LR = 0x8225E8D4; return 0x82255C38;
		/* 8225E8D0h case    0:*/		return 0x8225E8D4;
		  /* 8225E8D4h */ case    1:  		/* sth R3, <#[R23 + 22]> */
		/* 8225E8D4h case    1:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000016) );
		/* 8225E8D4h case    1:*/		return 0x8225E8D8;
		  /* 8225E8D8h */ case    2:  		/* li R4, 0 */
		/* 8225E8D8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E8D8h case    2:*/		return 0x8225E8DC;
		  /* 8225E8DCh */ case    3:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225E8DCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E8DCh case    3:*/		return 0x8225E8E0;
		  /* 8225E8E0h */ case    4:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225E8E0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225E8E0h case    4:*/		return 0x8225E8E4;
		  /* 8225E8E4h */ case    5:  		/* addi R5, R11, -1 */
		/* 8225E8E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225E8E4h case    5:*/		return 0x8225E8E8;
		  /* 8225E8E8h */ case    6:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225E8E8h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225E8E8h case    6:*/		return 0x8225E8EC;
		  /* 8225E8ECh */ case    7:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225E8ECh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225E8ECh case    7:*/		return 0x8225E8F0;
		  /* 8225E8F0h */ case    8:  		/* bl -102624 */
		/* 8225E8F0h case    8:*/		regs.LR = 0x8225E8F4; return 0x82245810;
		/* 8225E8F0h case    8:*/		return 0x8225E8F4;
		  /* 8225E8F4h */ case    9:  		/* li R11, 0 */
		/* 8225E8F4h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225E8F4h case    9:*/		return 0x8225E8F8;
		  /* 8225E8F8h */ case   10:  		/* li R10, 1 */
		/* 8225E8F8h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8225E8F8h case   10:*/		return 0x8225E8FC;
		  /* 8225E8FCh */ case   11:  		/* mr R29, R3 */
		/* 8225E8FCh case   11:*/		regs.R29 = regs.R3;
		/* 8225E8FCh case   11:*/		return 0x8225E900;
		  /* 8225E900h */ case   12:  		/* sth R11, <#[R23 + 14]> */
		/* 8225E900h case   12:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x0000000E) );
		/* 8225E900h case   12:*/		return 0x8225E904;
		  /* 8225E904h */ case   13:  		/* sth R10, <#[R23 + 16]> */
		/* 8225E904h case   13:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 8225E904h case   13:*/		return 0x8225E908;
		  /* 8225E908h */ case   14:  		/* cmpwi CR6, R28, 0 */
		/* 8225E908h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8225E908h case   14:*/		return 0x8225E90C;
		  /* 8225E90Ch */ case   15:  		/* bc 4, CR6_EQ, 576 */
		/* 8225E90Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x8225EB4C;  }
		/* 8225E90Ch case   15:*/		return 0x8225E910;
		  /* 8225E910h */ case   16:  		/* li R3, 110 */
		/* 8225E910h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x6E);
		/* 8225E910h case   16:*/		return 0x8225E914;
		  /* 8225E914h */ case   17:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E914h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E914h case   17:*/		return 0x8225E918;
		  /* 8225E918h */ case   18:  		/* bl -35304 */
		/* 8225E918h case   18:*/		regs.LR = 0x8225E91C; return 0x82255F30;
		/* 8225E918h case   18:*/		return 0x8225E91C;
		  /* 8225E91Ch */ case   19:  		/* mr R5, R29 */
		/* 8225E91Ch case   19:*/		regs.R5 = regs.R29;
		/* 8225E91Ch case   19:*/		return 0x8225E920;
		  /* 8225E920h */ case   20:  		/* li R4, 0 */
		/* 8225E920h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E920h case   20:*/		return 0x8225E924;
		  /* 8225E924h */ case   21:  		/* mr R30, R3 */
		/* 8225E924h case   21:*/		regs.R30 = regs.R3;
		/* 8225E924h case   21:*/		return 0x8225E928;
		  /* 8225E928h */ case   22:  		/* bl -34192 */
		/* 8225E928h case   22:*/		regs.LR = 0x8225E92C; return 0x82256398;
		/* 8225E928h case   22:*/		return 0x8225E92C;
		  /* 8225E92Ch */ case   23:  		/* mr R5, R19 */
		/* 8225E92Ch case   23:*/		regs.R5 = regs.R19;
		/* 8225E92Ch case   23:*/		return 0x8225E930;
		  /* 8225E930h */ case   24:  		/* li R4, 1 */
		/* 8225E930h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E930h case   24:*/		return 0x8225E934;
		  /* 8225E934h */ case   25:  		/* mr R3, R30 */
		/* 8225E934h case   25:*/		regs.R3 = regs.R30;
		/* 8225E934h case   25:*/		return 0x8225E938;
		  /* 8225E938h */ case   26:  		/* bl -34208 */
		/* 8225E938h case   26:*/		regs.LR = 0x8225E93C; return 0x82256398;
		/* 8225E938h case   26:*/		return 0x8225E93C;
		  /* 8225E93Ch */ case   27:  		/* stw R25, <#[R30 + 176]> */
		/* 8225E93Ch case   27:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x000000B0) );
		/* 8225E93Ch case   27:*/		return 0x8225E940;
		  /* 8225E940h */ case   28:  		/* mr R4, R25 */
		/* 8225E940h case   28:*/		regs.R4 = regs.R25;
		/* 8225E940h case   28:*/		return 0x8225E944;
		  /* 8225E944h */ case   29:  		/* lwz R3, <#[R31 + 12]> */
		/* 8225E944h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E944h case   29:*/		return 0x8225E948;
		  /* 8225E948h */ case   30:  		/* bl -270984 */
		/* 8225E948h case   30:*/		regs.LR = 0x8225E94C; return 0x8221C6C0;
		/* 8225E948h case   30:*/		return 0x8225E94C;
		  /* 8225E94Ch */ case   31:  		/* stw R3, <#[R30 + 172]> */
		/* 8225E94Ch case   31:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 8225E94Ch case   31:*/		return 0x8225E950;
		  /* 8225E950h */ case   32:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225E950h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225E950h case   32:*/		return 0x8225E954;
		  /* 8225E954h */ case   33:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225E954h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225E954h case   33:*/		return 0x8225E958;
		  /* 8225E958h */ case   34:  		/* cmplwi CR6, R11, 1 */
		/* 8225E958h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225E958h case   34:*/		return 0x8225E95C;
		  /* 8225E95Ch */ case   35:  		/* bc 12, CR6_LT, 32 */
		/* 8225E95Ch case   35:*/		if ( regs.CR[6].lt ) { return 0x8225E97C;  }
		/* 8225E95Ch case   35:*/		return 0x8225E960;
		  /* 8225E960h */ case   36:  		/* bc 12, CR6_EQ, 20 */
		/* 8225E960h case   36:*/		if ( regs.CR[6].eq ) { return 0x8225E974;  }
		/* 8225E960h case   36:*/		return 0x8225E964;
		  /* 8225E964h */ case   37:  		/* cmplwi CR6, R11, 3 */
		/* 8225E964h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225E964h case   37:*/		return 0x8225E968;
		  /* 8225E968h */ case   38:  		/* bc 4, CR6_LT, 20 */
		/* 8225E968h case   38:*/		if ( !regs.CR[6].lt ) { return 0x8225E97C;  }
		/* 8225E968h case   38:*/		return 0x8225E96C;
		  /* 8225E96Ch */ case   39:  		/* li R11, 1 */
		/* 8225E96Ch case   39:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225E96Ch case   39:*/		return 0x8225E970;
		  /* 8225E970h */ case   40:  		/* b 16 */
		/* 8225E970h case   40:*/		return 0x8225E980;
		/* 8225E970h case   40:*/		return 0x8225E974;
	}
	return 0x8225E974;
} // Block from 8225E8D0h-8225E974h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8225E974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E974);
		  /* 8225E974h */ case    0:  		/* li R11, 0 */
		/* 8225E974h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225E974h case    0:*/		return 0x8225E978;
		  /* 8225E978h */ case    1:  		/* b 8 */
		/* 8225E978h case    1:*/		return 0x8225E980;
		/* 8225E978h case    1:*/		return 0x8225E97C;
	}
	return 0x8225E97C;
} // Block from 8225E974h-8225E97Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225E97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E97C);
		  /* 8225E97Ch */ case    0:  		/* li R11, 2 */
		/* 8225E97Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225E97Ch case    0:*/		return 0x8225E980;
	}
	return 0x8225E980;
} // Block from 8225E97Ch-8225E980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225E980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225E980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225E980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225E980);
		  /* 8225E980h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225E980h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225E980h case    0:*/		return 0x8225E984;
		  /* 8225E984h */ case    1:  		/* mr R4, R30 */
		/* 8225E984h case    1:*/		regs.R4 = regs.R30;
		/* 8225E984h case    1:*/		return 0x8225E988;
		  /* 8225E988h */ case    2:  		/* mr R3, R31 */
		/* 8225E988h case    2:*/		regs.R3 = regs.R31;
		/* 8225E988h case    2:*/		return 0x8225E98C;
		  /* 8225E98Ch */ case    3:  		/* bl -164836 */
		/* 8225E98Ch case    3:*/		regs.LR = 0x8225E990; return 0x822365A8;
		/* 8225E98Ch case    3:*/		return 0x8225E990;
		  /* 8225E990h */ case    4:  		/* mr R4, R30 */
		/* 8225E990h case    4:*/		regs.R4 = regs.R30;
		/* 8225E990h case    4:*/		return 0x8225E994;
		  /* 8225E994h */ case    5:  		/* mr R3, R14 */
		/* 8225E994h case    5:*/		regs.R3 = regs.R14;
		/* 8225E994h case    5:*/		return 0x8225E998;
		  /* 8225E998h */ case    6:  		/* bl -23144 */
		/* 8225E998h case    6:*/		regs.LR = 0x8225E99C; return 0x82258F30;
		/* 8225E998h case    6:*/		return 0x8225E99C;
		  /* 8225E99Ch */ case    7:  		/* mr R3, R30 */
		/* 8225E99Ch case    7:*/		regs.R3 = regs.R30;
		/* 8225E99Ch case    7:*/		return 0x8225E9A0;
		  /* 8225E9A0h */ case    8:  		/* bl -35296 */
		/* 8225E9A0h case    8:*/		regs.LR = 0x8225E9A4; return 0x82255FC0;
		/* 8225E9A0h case    8:*/		return 0x8225E9A4;
		  /* 8225E9A4h */ case    9:  		/* li R3, 18 */
		/* 8225E9A4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 8225E9A4h case    9:*/		return 0x8225E9A8;
		  /* 8225E9A8h */ case   10:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225E9A8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225E9A8h case   10:*/		return 0x8225E9AC;
		  /* 8225E9ACh */ case   11:  		/* bl -35452 */
		/* 8225E9ACh case   11:*/		regs.LR = 0x8225E9B0; return 0x82255F30;
		/* 8225E9ACh case   11:*/		return 0x8225E9B0;
		  /* 8225E9B0h */ case   12:  		/* mr R5, R29 */
		/* 8225E9B0h case   12:*/		regs.R5 = regs.R29;
		/* 8225E9B0h case   12:*/		return 0x8225E9B4;
		  /* 8225E9B4h */ case   13:  		/* li R4, 0 */
		/* 8225E9B4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225E9B4h case   13:*/		return 0x8225E9B8;
		  /* 8225E9B8h */ case   14:  		/* mr R30, R3 */
		/* 8225E9B8h case   14:*/		regs.R30 = regs.R3;
		/* 8225E9B8h case   14:*/		return 0x8225E9BC;
		  /* 8225E9BCh */ case   15:  		/* bl -34340 */
		/* 8225E9BCh case   15:*/		regs.LR = 0x8225E9C0; return 0x82256398;
		/* 8225E9BCh case   15:*/		return 0x8225E9C0;
		  /* 8225E9C0h */ case   16:  		/* mr R3, R30 */
		/* 8225E9C0h case   16:*/		regs.R3 = regs.R30;
		/* 8225E9C0h case   16:*/		return 0x8225E9C4;
		  /* 8225E9C4h */ case   17:  		/* mr R5, R29 */
		/* 8225E9C4h case   17:*/		regs.R5 = regs.R29;
		/* 8225E9C4h case   17:*/		return 0x8225E9C8;
		  /* 8225E9C8h */ case   18:  		/* li R4, 1 */
		/* 8225E9C8h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225E9C8h case   18:*/		return 0x8225E9CC;
		  /* 8225E9CCh */ case   19:  		/* bl -34356 */
		/* 8225E9CCh case   19:*/		regs.LR = 0x8225E9D0; return 0x82256398;
		/* 8225E9CCh case   19:*/		return 0x8225E9D0;
		  /* 8225E9D0h */ case   20:  		/* lwz R11, <#[R1 + 136]> */
		/* 8225E9D0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 8225E9D0h case   20:*/		return 0x8225E9D4;
		  /* 8225E9D4h */ case   21:  		/* mr R3, R30 */
		/* 8225E9D4h case   21:*/		regs.R3 = regs.R30;
		/* 8225E9D4h case   21:*/		return 0x8225E9D8;
		  /* 8225E9D8h */ case   22:  		/* li R5, 2 */
		/* 8225E9D8h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225E9D8h case   22:*/		return 0x8225E9DC;
		  /* 8225E9DCh */ case   23:  		/* mr R4, R31 */
		/* 8225E9DCh case   23:*/		regs.R4 = regs.R31;
		/* 8225E9DCh case   23:*/		return 0x8225E9E0;
		  /* 8225E9E0h */ case   24:  		/* lwz R11, <#[R11 - 1272]> */
		/* 8225E9E0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFB08) );
		/* 8225E9E0h case   24:*/		return 0x8225E9E4;
		  /* 8225E9E4h */ case   25:  		/* stw R11, <#[R30 + 132]> */
		/* 8225E9E4h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225E9E4h case   25:*/		return 0x8225E9E8;
		  /* 8225E9E8h */ case   26:  		/* lfs FR4, <#[R1 + 216]> */
		/* 8225E9E8h case   26:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225E9E8h case   26:*/		return 0x8225E9EC;
		  /* 8225E9ECh */ case   27:  		/* fmr FR3, FR4 */
		/* 8225E9ECh case   27:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225E9ECh case   27:*/		return 0x8225E9F0;
		  /* 8225E9F0h */ case   28:  		/* fmr FR2, FR4 */
		/* 8225E9F0h case   28:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225E9F0h case   28:*/		return 0x8225E9F4;
		  /* 8225E9F4h */ case   29:  		/* fmr FR1, FR4 */
		/* 8225E9F4h case   29:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225E9F4h case   29:*/		return 0x8225E9F8;
		  /* 8225E9F8h */ case   30:  		/* bl -31456 */
		/* 8225E9F8h case   30:*/		regs.LR = 0x8225E9FC; return 0x82256F18;
		/* 8225E9F8h case   30:*/		return 0x8225E9FC;
		  /* 8225E9FCh */ case   31:  		/* mr R4, R30 */
		/* 8225E9FCh case   31:*/		regs.R4 = regs.R30;
		/* 8225E9FCh case   31:*/		return 0x8225EA00;
		  /* 8225EA00h */ case   32:  		/* mr R3, R31 */
		/* 8225EA00h case   32:*/		regs.R3 = regs.R31;
		/* 8225EA00h case   32:*/		return 0x8225EA04;
		  /* 8225EA04h */ case   33:  		/* bl -164956 */
		/* 8225EA04h case   33:*/		regs.LR = 0x8225EA08; return 0x822365A8;
		/* 8225EA04h case   33:*/		return 0x8225EA08;
		  /* 8225EA08h */ case   34:  		/* mr R4, R30 */
		/* 8225EA08h case   34:*/		regs.R4 = regs.R30;
		/* 8225EA08h case   34:*/		return 0x8225EA0C;
		  /* 8225EA0Ch */ case   35:  		/* mr R3, R14 */
		/* 8225EA0Ch case   35:*/		regs.R3 = regs.R14;
		/* 8225EA0Ch case   35:*/		return 0x8225EA10;
		  /* 8225EA10h */ case   36:  		/* bl -23264 */
		/* 8225EA10h case   36:*/		regs.LR = 0x8225EA14; return 0x82258F30;
		/* 8225EA10h case   36:*/		return 0x8225EA14;
		  /* 8225EA14h */ case   37:  		/* mr R3, R30 */
		/* 8225EA14h case   37:*/		regs.R3 = regs.R30;
		/* 8225EA14h case   37:*/		return 0x8225EA18;
		  /* 8225EA18h */ case   38:  		/* bl -35416 */
		/* 8225EA18h case   38:*/		regs.LR = 0x8225EA1C; return 0x82255FC0;
		/* 8225EA18h case   38:*/		return 0x8225EA1C;
		  /* 8225EA1Ch */ case   39:  		/* lwz R30, <#[R1 + 132]> */
		/* 8225EA1Ch case   39:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000084) );
		/* 8225EA1Ch case   39:*/		return 0x8225EA20;
		  /* 8225EA20h */ case   40:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225EA20h case   40:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225EA20h case   40:*/		return 0x8225EA24;
		  /* 8225EA24h */ case   41:  		/* bc 4, CR0_EQ, 28 */
		/* 8225EA24h case   41:*/		if ( !regs.CR[0].eq ) { return 0x8225EA40;  }
		/* 8225EA24h case   41:*/		return 0x8225EA28;
		  /* 8225EA28h */ case   42:  		/* li R7, 2668 */
		/* 8225EA28h case   42:*/		cpu::op::li<0>(regs,&regs.R7,0xA6C);
		/* 8225EA28h case   42:*/		return 0x8225EA2C;
		  /* 8225EA2Ch */ case   43:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225EA2Ch case   43:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225EA2Ch case   43:*/		return 0x8225EA30;
		  /* 8225EA30h */ case   44:  		/* li R3, 0 */
		/* 8225EA30h case   44:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225EA30h case   44:*/		return 0x8225EA34;
		  /* 8225EA34h */ case   45:  		/* lwz R5, <#[R1 + 280]> */
		/* 8225EA34h case   45:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000118) );
		/* 8225EA34h case   45:*/		return 0x8225EA38;
		  /* 8225EA38h */ case   46:  		/* mr R4, R30 */
		/* 8225EA38h case   46:*/		regs.R4 = regs.R30;
		/* 8225EA38h case   46:*/		return 0x8225EA3C;
		  /* 8225EA3Ch */ case   47:  		/* bl -1076788 */
		/* 8225EA3Ch case   47:*/		regs.LR = 0x8225EA40; return 0x82157C08;
		/* 8225EA3Ch case   47:*/		return 0x8225EA40;
	}
	return 0x8225EA40;
} // Block from 8225E980h-8225EA40h (48 instructions)

//////////////////////////////////////////////////////
// Block at 8225EA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EA40);
		  /* 8225EA40h */ case    0:  		/* li R3, 25 */
		/* 8225EA40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x19);
		/* 8225EA40h case    0:*/		return 0x8225EA44;
		  /* 8225EA44h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225EA44h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EA44h case    1:*/		return 0x8225EA48;
		  /* 8225EA48h */ case    2:  		/* bl -35608 */
		/* 8225EA48h case    2:*/		regs.LR = 0x8225EA4C; return 0x82255F30;
		/* 8225EA48h case    2:*/		return 0x8225EA4C;
		  /* 8225EA4Ch */ case    3:  		/* mr R5, R29 */
		/* 8225EA4Ch case    3:*/		regs.R5 = regs.R29;
		/* 8225EA4Ch case    3:*/		return 0x8225EA50;
		  /* 8225EA50h */ case    4:  		/* li R4, 0 */
		/* 8225EA50h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225EA50h case    4:*/		return 0x8225EA54;
		  /* 8225EA54h */ case    5:  		/* mr R28, R3 */
		/* 8225EA54h case    5:*/		regs.R28 = regs.R3;
		/* 8225EA54h case    5:*/		return 0x8225EA58;
		  /* 8225EA58h */ case    6:  		/* bl -34496 */
		/* 8225EA58h case    6:*/		regs.LR = 0x8225EA5C; return 0x82256398;
		/* 8225EA58h case    6:*/		return 0x8225EA5C;
		  /* 8225EA5Ch */ case    7:  		/* mr R3, R28 */
		/* 8225EA5Ch case    7:*/		regs.R3 = regs.R28;
		/* 8225EA5Ch case    7:*/		return 0x8225EA60;
		  /* 8225EA60h */ case    8:  		/* mr R5, R29 */
		/* 8225EA60h case    8:*/		regs.R5 = regs.R29;
		/* 8225EA60h case    8:*/		return 0x8225EA64;
		  /* 8225EA64h */ case    9:  		/* li R4, 1 */
		/* 8225EA64h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225EA64h case    9:*/		return 0x8225EA68;
		  /* 8225EA68h */ case   10:  		/* bl -34512 */
		/* 8225EA68h case   10:*/		regs.LR = 0x8225EA6C; return 0x82256398;
		/* 8225EA68h case   10:*/		return 0x8225EA6C;
		  /* 8225EA6Ch */ case   11:  		/* lfs FR4, <#[R1 + 288]> */
		/* 8225EA6Ch case   11:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x00000120) );
		/* 8225EA6Ch case   11:*/		return 0x8225EA70;
		  /* 8225EA70h */ case   12:  		/* mr R3, R28 */
		/* 8225EA70h case   12:*/		regs.R3 = regs.R28;
		/* 8225EA70h case   12:*/		return 0x8225EA74;
		  /* 8225EA74h */ case   13:  		/* fmr FR3, FR4 */
		/* 8225EA74h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225EA74h case   13:*/		return 0x8225EA78;
		  /* 8225EA78h */ case   14:  		/* li R5, 2 */
		/* 8225EA78h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225EA78h case   14:*/		return 0x8225EA7C;
		  /* 8225EA7Ch */ case   15:  		/* fmr FR2, FR4 */
		/* 8225EA7Ch case   15:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225EA7Ch case   15:*/		return 0x8225EA80;
		  /* 8225EA80h */ case   16:  		/* mr R4, R31 */
		/* 8225EA80h case   16:*/		regs.R4 = regs.R31;
		/* 8225EA80h case   16:*/		return 0x8225EA84;
		  /* 8225EA84h */ case   17:  		/* fmr FR1, FR4 */
		/* 8225EA84h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225EA84h case   17:*/		return 0x8225EA88;
		  /* 8225EA88h */ case   18:  		/* bl -31600 */
		/* 8225EA88h case   18:*/		regs.LR = 0x8225EA8C; return 0x82256F18;
		/* 8225EA88h case   18:*/		return 0x8225EA8C;
		  /* 8225EA8Ch */ case   19:  		/* mr R4, R28 */
		/* 8225EA8Ch case   19:*/		regs.R4 = regs.R28;
		/* 8225EA8Ch case   19:*/		return 0x8225EA90;
		  /* 8225EA90h */ case   20:  		/* mr R3, R31 */
		/* 8225EA90h case   20:*/		regs.R3 = regs.R31;
		/* 8225EA90h case   20:*/		return 0x8225EA94;
		  /* 8225EA94h */ case   21:  		/* bl -165100 */
		/* 8225EA94h case   21:*/		regs.LR = 0x8225EA98; return 0x822365A8;
		/* 8225EA94h case   21:*/		return 0x8225EA98;
		  /* 8225EA98h */ case   22:  		/* mr R4, R28 */
		/* 8225EA98h case   22:*/		regs.R4 = regs.R28;
		/* 8225EA98h case   22:*/		return 0x8225EA9C;
		  /* 8225EA9Ch */ case   23:  		/* mr R3, R14 */
		/* 8225EA9Ch case   23:*/		regs.R3 = regs.R14;
		/* 8225EA9Ch case   23:*/		return 0x8225EAA0;
		  /* 8225EAA0h */ case   24:  		/* bl -23408 */
		/* 8225EAA0h case   24:*/		regs.LR = 0x8225EAA4; return 0x82258F30;
		/* 8225EAA0h case   24:*/		return 0x8225EAA4;
		  /* 8225EAA4h */ case   25:  		/* mr R3, R28 */
		/* 8225EAA4h case   25:*/		regs.R3 = regs.R28;
		/* 8225EAA4h case   25:*/		return 0x8225EAA8;
		  /* 8225EAA8h */ case   26:  		/* bl -35560 */
		/* 8225EAA8h case   26:*/		regs.LR = 0x8225EAAC; return 0x82255FC0;
		/* 8225EAA8h case   26:*/		return 0x8225EAAC;
		  /* 8225EAACh */ case   27:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225EAACh case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225EAACh case   27:*/		return 0x8225EAB0;
		  /* 8225EAB0h */ case   28:  		/* bc 4, CR0_EQ, 28 */
		/* 8225EAB0h case   28:*/		if ( !regs.CR[0].eq ) { return 0x8225EACC;  }
		/* 8225EAB0h case   28:*/		return 0x8225EAB4;
		  /* 8225EAB4h */ case   29:  		/* mr R4, R30 */
		/* 8225EAB4h case   29:*/		regs.R4 = regs.R30;
		/* 8225EAB4h case   29:*/		return 0x8225EAB8;
		  /* 8225EAB8h */ case   30:  		/* lwz R6, <#[R1 + 128]> */
		/* 8225EAB8h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8225EAB8h case   30:*/		return 0x8225EABC;
		  /* 8225EABCh */ case   31:  		/* li R7, 2677 */
		/* 8225EABCh case   31:*/		cpu::op::li<0>(regs,&regs.R7,0xA75);
		/* 8225EABCh case   31:*/		return 0x8225EAC0;
		  /* 8225EAC0h */ case   32:  		/* lwz R5, <#[R1 + 352]> */
		/* 8225EAC0h case   32:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000160) );
		/* 8225EAC0h case   32:*/		return 0x8225EAC4;
		  /* 8225EAC4h */ case   33:  		/* li R3, 0 */
		/* 8225EAC4h case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225EAC4h case   33:*/		return 0x8225EAC8;
		  /* 8225EAC8h */ case   34:  		/* bl -1076928 */
		/* 8225EAC8h case   34:*/		regs.LR = 0x8225EACC; return 0x82157C08;
		/* 8225EAC8h case   34:*/		return 0x8225EACC;
	}
	return 0x8225EACC;
} // Block from 8225EA40h-8225EACCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 8225EACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EACC);
		  /* 8225EACCh */ case    0:  		/* li R3, 23 */
		/* 8225EACCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x17);
		/* 8225EACCh case    0:*/		return 0x8225EAD0;
		  /* 8225EAD0h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225EAD0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EAD0h case    1:*/		return 0x8225EAD4;
		  /* 8225EAD4h */ case    2:  		/* bl -35748 */
		/* 8225EAD4h case    2:*/		regs.LR = 0x8225EAD8; return 0x82255F30;
		/* 8225EAD4h case    2:*/		return 0x8225EAD8;
		  /* 8225EAD8h */ case    3:  		/* mr R5, R29 */
		/* 8225EAD8h case    3:*/		regs.R5 = regs.R29;
		/* 8225EAD8h case    3:*/		return 0x8225EADC;
		  /* 8225EADCh */ case    4:  		/* li R4, 0 */
		/* 8225EADCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225EADCh case    4:*/		return 0x8225EAE0;
		  /* 8225EAE0h */ case    5:  		/* mr R28, R3 */
		/* 8225EAE0h case    5:*/		regs.R28 = regs.R3;
		/* 8225EAE0h case    5:*/		return 0x8225EAE4;
		  /* 8225EAE4h */ case    6:  		/* bl -34636 */
		/* 8225EAE4h case    6:*/		regs.LR = 0x8225EAE8; return 0x82256398;
		/* 8225EAE4h case    6:*/		return 0x8225EAE8;
		  /* 8225EAE8h */ case    7:  		/* mr R3, R28 */
		/* 8225EAE8h case    7:*/		regs.R3 = regs.R28;
		/* 8225EAE8h case    7:*/		return 0x8225EAEC;
		  /* 8225EAECh */ case    8:  		/* mr R5, R29 */
		/* 8225EAECh case    8:*/		regs.R5 = regs.R29;
		/* 8225EAECh case    8:*/		return 0x8225EAF0;
		  /* 8225EAF0h */ case    9:  		/* li R4, 1 */
		/* 8225EAF0h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225EAF0h case    9:*/		return 0x8225EAF4;
		  /* 8225EAF4h */ case   10:  		/* bl -34652 */
		/* 8225EAF4h case   10:*/		regs.LR = 0x8225EAF8; return 0x82256398;
		/* 8225EAF4h case   10:*/		return 0x8225EAF8;
		  /* 8225EAF8h */ case   11:  		/* lfs FR4, <#[R1 + 296]> */
		/* 8225EAF8h case   11:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x00000128) );
		/* 8225EAF8h case   11:*/		return 0x8225EAFC;
		  /* 8225EAFCh */ case   12:  		/* mr R3, R28 */
		/* 8225EAFCh case   12:*/		regs.R3 = regs.R28;
		/* 8225EAFCh case   12:*/		return 0x8225EB00;
		  /* 8225EB00h */ case   13:  		/* fmr FR3, FR4 */
		/* 8225EB00h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225EB00h case   13:*/		return 0x8225EB04;
		  /* 8225EB04h */ case   14:  		/* li R5, 2 */
		/* 8225EB04h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225EB04h case   14:*/		return 0x8225EB08;
		  /* 8225EB08h */ case   15:  		/* fmr FR2, FR4 */
		/* 8225EB08h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225EB08h case   15:*/		return 0x8225EB0C;
		  /* 8225EB0Ch */ case   16:  		/* mr R4, R31 */
		/* 8225EB0Ch case   16:*/		regs.R4 = regs.R31;
		/* 8225EB0Ch case   16:*/		return 0x8225EB10;
		  /* 8225EB10h */ case   17:  		/* fmr FR1, FR4 */
		/* 8225EB10h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225EB10h case   17:*/		return 0x8225EB14;
		  /* 8225EB14h */ case   18:  		/* bl -31740 */
		/* 8225EB14h case   18:*/		regs.LR = 0x8225EB18; return 0x82256F18;
		/* 8225EB14h case   18:*/		return 0x8225EB18;
		  /* 8225EB18h */ case   19:  		/* mr R4, R28 */
		/* 8225EB18h case   19:*/		regs.R4 = regs.R28;
		/* 8225EB18h case   19:*/		return 0x8225EB1C;
		  /* 8225EB1Ch */ case   20:  		/* mr R3, R31 */
		/* 8225EB1Ch case   20:*/		regs.R3 = regs.R31;
		/* 8225EB1Ch case   20:*/		return 0x8225EB20;
		  /* 8225EB20h */ case   21:  		/* bl -165240 */
		/* 8225EB20h case   21:*/		regs.LR = 0x8225EB24; return 0x822365A8;
		/* 8225EB20h case   21:*/		return 0x8225EB24;
		  /* 8225EB24h */ case   22:  		/* mr R4, R28 */
		/* 8225EB24h case   22:*/		regs.R4 = regs.R28;
		/* 8225EB24h case   22:*/		return 0x8225EB28;
		  /* 8225EB28h */ case   23:  		/* mr R3, R14 */
		/* 8225EB28h case   23:*/		regs.R3 = regs.R14;
		/* 8225EB28h case   23:*/		return 0x8225EB2C;
		  /* 8225EB2Ch */ case   24:  		/* bl -23548 */
		/* 8225EB2Ch case   24:*/		regs.LR = 0x8225EB30; return 0x82258F30;
		/* 8225EB2Ch case   24:*/		return 0x8225EB30;
		  /* 8225EB30h */ case   25:  		/* mr R3, R28 */
		/* 8225EB30h case   25:*/		regs.R3 = regs.R28;
		/* 8225EB30h case   25:*/		return 0x8225EB34;
		  /* 8225EB34h */ case   26:  		/* bl -35700 */
		/* 8225EB34h case   26:*/		regs.LR = 0x8225EB38; return 0x82255FC0;
		/* 8225EB34h case   26:*/		return 0x8225EB38;
		  /* 8225EB38h */ case   27:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225EB38h case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225EB38h case   27:*/		return 0x8225EB3C;
		  /* 8225EB3Ch */ case   28:  		/* bc 4, CR0_EQ, -692 */
		/* 8225EB3Ch case   28:*/		if ( !regs.CR[0].eq ) { return 0x8225E888;  }
		/* 8225EB3Ch case   28:*/		return 0x8225EB40;
		  /* 8225EB40h */ case   29:  		/* mr R4, R30 */
		/* 8225EB40h case   29:*/		regs.R4 = regs.R30;
		/* 8225EB40h case   29:*/		return 0x8225EB44;
		  /* 8225EB44h */ case   30:  		/* li R7, 2686 */
		/* 8225EB44h case   30:*/		cpu::op::li<0>(regs,&regs.R7,0xA7E);
		/* 8225EB44h case   30:*/		return 0x8225EB48;
		  /* 8225EB48h */ case   31:  		/* b -720 */
		/* 8225EB48h case   31:*/		return 0x8225E878;
		/* 8225EB48h case   31:*/		return 0x8225EB4C;
	}
	return 0x8225EB4C;
} // Block from 8225EACCh-8225EB4Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 8225EB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EB4C);
		  /* 8225EB4Ch */ case    0:  		/* lfs FR1, <#[R1 + 216]> */
		/* 8225EB4Ch case    0:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225EB4Ch case    0:*/		return 0x8225EB50;
		  /* 8225EB50h */ case    1:  		/* lfs FR0, <#[R1 + 288]> */
		/* 8225EB50h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000120) );
		/* 8225EB50h case    1:*/		return 0x8225EB54;
		  /* 8225EB54h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 8225EB54h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 8225EB54h case    2:*/		return 0x8225EB58;
		  /* 8225EB58h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 8225EB58h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8225EB64;  }
		/* 8225EB58h case    3:*/		return 0x8225EB5C;
		  /* 8225EB5Ch */ case    4:  		/* stfs FR0, <#[R1 + 216]> */
		/* 8225EB5Ch case    4:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225EB5Ch case    4:*/		return 0x8225EB60;
		  /* 8225EB60h */ case    5:  		/* fmr FR1, FR0 */
		/* 8225EB60h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR0);
		/* 8225EB60h case    5:*/		return 0x8225EB64;
	}
	return 0x8225EB64;
} // Block from 8225EB4Ch-8225EB64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225EB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EB64);
		  /* 8225EB64h */ case    0:  		/* lfs FR0, <#[R1 + 296]> */
		/* 8225EB64h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000128) );
		/* 8225EB64h case    0:*/		return 0x8225EB68;
		  /* 8225EB68h */ case    1:  		/* fcmpu CR6, FR1, FR0 */
		/* 8225EB68h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 8225EB68h case    1:*/		return 0x8225EB6C;
		  /* 8225EB6Ch */ case    2:  		/* bc 4, CR6_LT, 244 */
		/* 8225EB6Ch case    2:*/		if ( !regs.CR[6].lt ) { return 0x8225EC60;  }
		/* 8225EB6Ch case    2:*/		return 0x8225EB70;
		  /* 8225EB70h */ case    3:  		/* stfs FR0, <#[R1 + 216]> */
		/* 8225EB70h case    3:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225EB70h case    3:*/		return 0x8225EB74;
		  /* 8225EB74h */ case    4:  		/* fmr FR1, FR0 */
		/* 8225EB74h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR0);
		/* 8225EB74h case    4:*/		return 0x8225EB78;
		  /* 8225EB78h */ case    5:  		/* b 232 */
		/* 8225EB78h case    5:*/		return 0x8225EC60;
		/* 8225EB78h case    5:*/		return 0x8225EB7C;
	}
	return 0x8225EB7C;
} // Block from 8225EB64h-8225EB7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225EB7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EB7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EB7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EB7C);
		  /* 8225EB7Ch */ case    0:  		/* cmplwi CR6, R16, 0 */
		/* 8225EB7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225EB7Ch case    0:*/		return 0x8225EB80;
		  /* 8225EB80h */ case    1:  		/* bc 12, CR6_EQ, 220 */
		/* 8225EB80h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225EC5C;  }
		/* 8225EB80h case    1:*/		return 0x8225EB84;
		  /* 8225EB84h */ case    2:  		/* cmplwi CR6, R24, 0 */
		/* 8225EB84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8225EB84h case    2:*/		return 0x8225EB88;
		  /* 8225EB88h */ case    3:  		/* bc 4, CR6_EQ, 212 */
		/* 8225EB88h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225EC5C;  }
		/* 8225EB88h case    3:*/		return 0x8225EB8C;
		  /* 8225EB8Ch */ case    4:  		/* li R5, 4 */
		/* 8225EB8Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225EB8Ch case    4:*/		return 0x8225EB90;
		  /* 8225EB90h */ case    5:  		/* lfs FR1, <#[R1 + 216]> */
		/* 8225EB90h case    5:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225EB90h case    5:*/		return 0x8225EB94;
		  /* 8225EB94h */ case    6:  		/* li R4, 3 */
		/* 8225EB94h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225EB94h case    6:*/		return 0x8225EB98;
		  /* 8225EB98h */ case    7:  		/* bl -36704 */
		/* 8225EB98h case    7:*/		regs.LR = 0x8225EB9C; return 0x82255C38;
		/* 8225EB98h case    7:*/		return 0x8225EB9C;
		  /* 8225EB9Ch */ case    8:  		/* mr R11, R3 */
		/* 8225EB9Ch case    8:*/		regs.R11 = regs.R3;
		/* 8225EB9Ch case    8:*/		return 0x8225EBA0;
		  /* 8225EBA0h */ case    9:  		/* li R3, 113 */
		/* 8225EBA0h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x71);
		/* 8225EBA0h case    9:*/		return 0x8225EBA4;
		  /* 8225EBA4h */ case   10:  		/* sth R11, <#[R23 + 22]> */
		/* 8225EBA4h case   10:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R23 + 0x00000016) );
		/* 8225EBA4h case   10:*/		return 0x8225EBA8;
		  /* 8225EBA8h */ case   11:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225EBA8h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EBA8h case   11:*/		return 0x8225EBAC;
		  /* 8225EBACh */ case   12:  		/* bl -35964 */
		/* 8225EBACh case   12:*/		regs.LR = 0x8225EBB0; return 0x82255F30;
		/* 8225EBACh case   12:*/		return 0x8225EBB0;
		  /* 8225EBB0h */ case   13:  		/* li R5, 0 */
		/* 8225EBB0h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8225EBB0h case   13:*/		return 0x8225EBB4;
		  /* 8225EBB4h */ case   14:  		/* li R4, 28 */
		/* 8225EBB4h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 8225EBB4h case   14:*/		return 0x8225EBB8;
		  /* 8225EBB8h */ case   15:  		/* mr R30, R3 */
		/* 8225EBB8h case   15:*/		regs.R30 = regs.R3;
		/* 8225EBB8h case   15:*/		return 0x8225EBBC;
		  /* 8225EBBCh */ case   16:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225EBBCh case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225EBBCh case   16:*/		return 0x8225EBC0;
		  /* 8225EBC0h */ case   17:  		/* bl -103344 */
		/* 8225EBC0h case   17:*/		regs.LR = 0x8225EBC4; return 0x82245810;
		/* 8225EBC0h case   17:*/		return 0x8225EBC4;
		  /* 8225EBC4h */ case   18:  		/* mr R5, R3 */
		/* 8225EBC4h case   18:*/		regs.R5 = regs.R3;
		/* 8225EBC4h case   18:*/		return 0x8225EBC8;
		  /* 8225EBC8h */ case   19:  		/* stw R3, <#[R1 + 208]> */
		/* 8225EBC8h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000000D0) );
		/* 8225EBC8h case   19:*/		return 0x8225EBCC;
		  /* 8225EBCCh */ case   20:  		/* li R4, 0 */
		/* 8225EBCCh case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225EBCCh case   20:*/		return 0x8225EBD0;
		  /* 8225EBD0h */ case   21:  		/* mr R3, R30 */
		/* 8225EBD0h case   21:*/		regs.R3 = regs.R30;
		/* 8225EBD0h case   21:*/		return 0x8225EBD4;
		  /* 8225EBD4h */ case   22:  		/* bl -34876 */
		/* 8225EBD4h case   22:*/		regs.LR = 0x8225EBD8; return 0x82256398;
		/* 8225EBD4h case   22:*/		return 0x8225EBD8;
		  /* 8225EBD8h */ case   23:  		/* mr R5, R27 */
		/* 8225EBD8h case   23:*/		regs.R5 = regs.R27;
		/* 8225EBD8h case   23:*/		return 0x8225EBDC;
		  /* 8225EBDCh */ case   24:  		/* li R4, 1 */
		/* 8225EBDCh case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225EBDCh case   24:*/		return 0x8225EBE0;
		  /* 8225EBE0h */ case   25:  		/* mr R3, R30 */
		/* 8225EBE0h case   25:*/		regs.R3 = regs.R30;
		/* 8225EBE0h case   25:*/		return 0x8225EBE4;
		  /* 8225EBE4h */ case   26:  		/* bl -34892 */
		/* 8225EBE4h case   26:*/		regs.LR = 0x8225EBE8; return 0x82256398;
		/* 8225EBE4h case   26:*/		return 0x8225EBE8;
		  /* 8225EBE8h */ case   27:  		/* lwz R11, <#[R29 - 1272]> */
		/* 8225EBE8h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFB08) );
		/* 8225EBE8h case   27:*/		return 0x8225EBEC;
		  /* 8225EBECh */ case   28:  		/* stw R11, <#[R30 + 132]> */
		/* 8225EBECh case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225EBECh case   28:*/		return 0x8225EBF0;
	}
	return 0x8225EBF0;
} // Block from 8225EB7Ch-8225EBF0h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8225EBF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EBF0);
		  /* 8225EBF0h */ case    0:  		/* stw R25, <#[R30 + 176]> */
		/* 8225EBF0h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x000000B0) );
		/* 8225EBF0h case    0:*/		return 0x8225EBF4;
		  /* 8225EBF4h */ case    1:  		/* mr R4, R25 */
		/* 8225EBF4h case    1:*/		regs.R4 = regs.R25;
		/* 8225EBF4h case    1:*/		return 0x8225EBF8;
		  /* 8225EBF8h */ case    2:  		/* lwz R3, <#[R31 + 12]> */
		/* 8225EBF8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EBF8h case    2:*/		return 0x8225EBFC;
		  /* 8225EBFCh */ case    3:  		/* bl -271676 */
		/* 8225EBFCh case    3:*/		regs.LR = 0x8225EC00; return 0x8221C6C0;
		/* 8225EBFCh case    3:*/		return 0x8225EC00;
		  /* 8225EC00h */ case    4:  		/* stw R3, <#[R30 + 172]> */
		/* 8225EC00h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 8225EC00h case    4:*/		return 0x8225EC04;
		  /* 8225EC04h */ case    5:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225EC04h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225EC04h case    5:*/		return 0x8225EC08;
		  /* 8225EC08h */ case    6:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225EC08h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225EC08h case    6:*/		return 0x8225EC0C;
		  /* 8225EC0Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 8225EC0Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225EC0Ch case    7:*/		return 0x8225EC10;
		  /* 8225EC10h */ case    8:  		/* bc 12, CR6_LT, 32 */
		/* 8225EC10h case    8:*/		if ( regs.CR[6].lt ) { return 0x8225EC30;  }
		/* 8225EC10h case    8:*/		return 0x8225EC14;
		  /* 8225EC14h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 8225EC14h case    9:*/		if ( regs.CR[6].eq ) { return 0x8225EC28;  }
		/* 8225EC14h case    9:*/		return 0x8225EC18;
		  /* 8225EC18h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 8225EC18h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225EC18h case   10:*/		return 0x8225EC1C;
		  /* 8225EC1Ch */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 8225EC1Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x8225EC30;  }
		/* 8225EC1Ch case   11:*/		return 0x8225EC20;
		  /* 8225EC20h */ case   12:  		/* li R11, 1 */
		/* 8225EC20h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225EC20h case   12:*/		return 0x8225EC24;
		  /* 8225EC24h */ case   13:  		/* b 16 */
		/* 8225EC24h case   13:*/		return 0x8225EC34;
		/* 8225EC24h case   13:*/		return 0x8225EC28;
	}
	return 0x8225EC28;
} // Block from 8225EBF0h-8225EC28h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8225EC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EC28);
		  /* 8225EC28h */ case    0:  		/* li R11, 0 */
		/* 8225EC28h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225EC28h case    0:*/		return 0x8225EC2C;
		  /* 8225EC2Ch */ case    1:  		/* b 8 */
		/* 8225EC2Ch case    1:*/		return 0x8225EC34;
		/* 8225EC2Ch case    1:*/		return 0x8225EC30;
	}
	return 0x8225EC30;
} // Block from 8225EC28h-8225EC30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225EC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EC30);
		  /* 8225EC30h */ case    0:  		/* li R11, 2 */
		/* 8225EC30h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225EC30h case    0:*/		return 0x8225EC34;
	}
	return 0x8225EC34;
} // Block from 8225EC30h-8225EC34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225EC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EC34);
		  /* 8225EC34h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225EC34h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225EC34h case    0:*/		return 0x8225EC38;
		  /* 8225EC38h */ case    1:  		/* mr R4, R30 */
		/* 8225EC38h case    1:*/		regs.R4 = regs.R30;
		/* 8225EC38h case    1:*/		return 0x8225EC3C;
		  /* 8225EC3Ch */ case    2:  		/* mr R3, R31 */
		/* 8225EC3Ch case    2:*/		regs.R3 = regs.R31;
		/* 8225EC3Ch case    2:*/		return 0x8225EC40;
		  /* 8225EC40h */ case    3:  		/* bl -165528 */
		/* 8225EC40h case    3:*/		regs.LR = 0x8225EC44; return 0x822365A8;
		/* 8225EC40h case    3:*/		return 0x8225EC44;
		  /* 8225EC44h */ case    4:  		/* mr R4, R30 */
		/* 8225EC44h case    4:*/		regs.R4 = regs.R30;
		/* 8225EC44h case    4:*/		return 0x8225EC48;
		  /* 8225EC48h */ case    5:  		/* mr R3, R14 */
		/* 8225EC48h case    5:*/		regs.R3 = regs.R14;
		/* 8225EC48h case    5:*/		return 0x8225EC4C;
		  /* 8225EC4Ch */ case    6:  		/* bl -23836 */
		/* 8225EC4Ch case    6:*/		regs.LR = 0x8225EC50; return 0x82258F30;
		/* 8225EC4Ch case    6:*/		return 0x8225EC50;
		  /* 8225EC50h */ case    7:  		/* mr R3, R30 */
		/* 8225EC50h case    7:*/		regs.R3 = regs.R30;
		/* 8225EC50h case    7:*/		return 0x8225EC54;
		  /* 8225EC54h */ case    8:  		/* bl -35988 */
		/* 8225EC54h case    8:*/		regs.LR = 0x8225EC58; return 0x82255FC0;
		/* 8225EC54h case    8:*/		return 0x8225EC58;
		  /* 8225EC58h */ case    9:  		/* b 24 */
		/* 8225EC58h case    9:*/		return 0x8225EC70;
		/* 8225EC58h case    9:*/		return 0x8225EC5C;
	}
	return 0x8225EC5C;
} // Block from 8225EC34h-8225EC5Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8225EC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EC5C);
		  /* 8225EC5Ch */ case    0:  		/* lfs FR1, <#[R1 + 216]> */
		/* 8225EC5Ch case    0:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x000000D8) );
		/* 8225EC5Ch case    0:*/		return 0x8225EC60;
	}
	return 0x8225EC60;
} // Block from 8225EC5Ch-8225EC60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225EC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EC60);
		  /* 8225EC60h */ case    0:  		/* li R5, 4 */
		/* 8225EC60h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225EC60h case    0:*/		return 0x8225EC64;
		  /* 8225EC64h */ case    1:  		/* li R4, 3 */
		/* 8225EC64h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225EC64h case    1:*/		return 0x8225EC68;
		  /* 8225EC68h */ case    2:  		/* bl -36912 */
		/* 8225EC68h case    2:*/		regs.LR = 0x8225EC6C; return 0x82255C38;
		/* 8225EC68h case    2:*/		return 0x8225EC6C;
		  /* 8225EC6Ch */ case    3:  		/* sth R3, <#[R23 + 22]> */
		/* 8225EC6Ch case    3:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000016) );
		/* 8225EC6Ch case    3:*/		return 0x8225EC70;
	}
	return 0x8225EC70;
} // Block from 8225EC60h-8225EC70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225EC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EC70);
		  /* 8225EC70h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 8225EC70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8225EC70h case    0:*/		return 0x8225EC74;
		  /* 8225EC74h */ case    1:  		/* bc 12, CR6_EQ, 160 */
		/* 8225EC74h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225ED14;  }
		/* 8225EC74h case    1:*/		return 0x8225EC78;
		  /* 8225EC78h */ case    2:  		/* li R3, 114 */
		/* 8225EC78h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x72);
		/* 8225EC78h case    2:*/		return 0x8225EC7C;
		  /* 8225EC7Ch */ case    3:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225EC7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EC7Ch case    3:*/		return 0x8225EC80;
		  /* 8225EC80h */ case    4:  		/* bl -36176 */
		/* 8225EC80h case    4:*/		regs.LR = 0x8225EC84; return 0x82255F30;
		/* 8225EC80h case    4:*/		return 0x8225EC84;
		  /* 8225EC84h */ case    5:  		/* rlwinm R30, R25, 1, 0, 30 */
		/* 8225EC84h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R25);
		/* 8225EC84h case    5:*/		return 0x8225EC88;
		  /* 8225EC88h */ case    6:  		/* li R29, 29 */
		/* 8225EC88h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x1D);
		/* 8225EC88h case    6:*/		return 0x8225EC8C;
		  /* 8225EC8Ch */ case    7:  		/* stw R30, <#[R3 + 56]> */
		/* 8225EC8Ch case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000038) );
		/* 8225EC8Ch case    7:*/		return 0x8225EC90;
		  /* 8225EC90h */ case    8:  		/* mr R5, R27 */
		/* 8225EC90h case    8:*/		regs.R5 = regs.R27;
		/* 8225EC90h case    8:*/		return 0x8225EC94;
		  /* 8225EC94h */ case    9:  		/* stw R29, <#[R3 + 80]> */
		/* 8225EC94h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000050) );
		/* 8225EC94h case    9:*/		return 0x8225EC98;
		  /* 8225EC98h */ case   10:  		/* li R4, 1 */
		/* 8225EC98h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225EC98h case   10:*/		return 0x8225EC9C;
		  /* 8225EC9Ch */ case   11:  		/* mr R28, R3 */
		/* 8225EC9Ch case   11:*/		regs.R28 = regs.R3;
		/* 8225EC9Ch case   11:*/		return 0x8225ECA0;
		  /* 8225ECA0h */ case   12:  		/* bl -35080 */
		/* 8225ECA0h case   12:*/		regs.LR = 0x8225ECA4; return 0x82256398;
		/* 8225ECA0h case   12:*/		return 0x8225ECA4;
		  /* 8225ECA4h */ case   13:  		/* stw R23, <#[R28 + 184]> */
		/* 8225ECA4h case   13:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R28 + 0x000000B8) );
		/* 8225ECA4h case   13:*/		return 0x8225ECA8;
		  /* 8225ECA8h */ case   14:  		/* mr R4, R28 */
		/* 8225ECA8h case   14:*/		regs.R4 = regs.R28;
		/* 8225ECA8h case   14:*/		return 0x8225ECAC;
		  /* 8225ECACh */ case   15:  		/* mr R3, R31 */
		/* 8225ECACh case   15:*/		regs.R3 = regs.R31;
		/* 8225ECACh case   15:*/		return 0x8225ECB0;
		  /* 8225ECB0h */ case   16:  		/* bl -165640 */
		/* 8225ECB0h case   16:*/		regs.LR = 0x8225ECB4; return 0x822365A8;
		/* 8225ECB0h case   16:*/		return 0x8225ECB4;
		  /* 8225ECB4h */ case   17:  		/* mr R4, R28 */
		/* 8225ECB4h case   17:*/		regs.R4 = regs.R28;
		/* 8225ECB4h case   17:*/		return 0x8225ECB8;
		  /* 8225ECB8h */ case   18:  		/* mr R3, R14 */
		/* 8225ECB8h case   18:*/		regs.R3 = regs.R14;
		/* 8225ECB8h case   18:*/		return 0x8225ECBC;
		  /* 8225ECBCh */ case   19:  		/* bl -23948 */
		/* 8225ECBCh case   19:*/		regs.LR = 0x8225ECC0; return 0x82258F30;
		/* 8225ECBCh case   19:*/		return 0x8225ECC0;
		  /* 8225ECC0h */ case   20:  		/* mr R3, R28 */
		/* 8225ECC0h case   20:*/		regs.R3 = regs.R28;
		/* 8225ECC0h case   20:*/		return 0x8225ECC4;
		  /* 8225ECC4h */ case   21:  		/* bl -36100 */
		/* 8225ECC4h case   21:*/		regs.LR = 0x8225ECC8; return 0x82255FC0;
		/* 8225ECC4h case   21:*/		return 0x8225ECC8;
		  /* 8225ECC8h */ case   22:  		/* li R3, 115 */
		/* 8225ECC8h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x73);
		/* 8225ECC8h case   22:*/		return 0x8225ECCC;
		  /* 8225ECCCh */ case   23:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225ECCCh case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225ECCCh case   23:*/		return 0x8225ECD0;
		  /* 8225ECD0h */ case   24:  		/* bl -36256 */
		/* 8225ECD0h case   24:*/		regs.LR = 0x8225ECD4; return 0x82255F30;
		/* 8225ECD0h case   24:*/		return 0x8225ECD4;
		  /* 8225ECD4h */ case   25:  		/* addi R11, R30, 1 */
		/* 8225ECD4h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 8225ECD4h case   25:*/		return 0x8225ECD8;
		  /* 8225ECD8h */ case   26:  		/* stw R29, <#[R3 + 80]> */
		/* 8225ECD8h case   26:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000050) );
		/* 8225ECD8h case   26:*/		return 0x8225ECDC;
		  /* 8225ECDCh */ case   27:  		/* mr R5, R26 */
		/* 8225ECDCh case   27:*/		regs.R5 = regs.R26;
		/* 8225ECDCh case   27:*/		return 0x8225ECE0;
		  /* 8225ECE0h */ case   28:  		/* stw R11, <#[R3 + 56]> */
		/* 8225ECE0h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8225ECE0h case   28:*/		return 0x8225ECE4;
		  /* 8225ECE4h */ case   29:  		/* li R4, 1 */
		/* 8225ECE4h case   29:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225ECE4h case   29:*/		return 0x8225ECE8;
		  /* 8225ECE8h */ case   30:  		/* mr R28, R3 */
		/* 8225ECE8h case   30:*/		regs.R28 = regs.R3;
		/* 8225ECE8h case   30:*/		return 0x8225ECEC;
		  /* 8225ECECh */ case   31:  		/* bl -35156 */
		/* 8225ECECh case   31:*/		regs.LR = 0x8225ECF0; return 0x82256398;
		/* 8225ECECh case   31:*/		return 0x8225ECF0;
		  /* 8225ECF0h */ case   32:  		/* stw R23, <#[R28 + 184]> */
		/* 8225ECF0h case   32:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R28 + 0x000000B8) );
		/* 8225ECF0h case   32:*/		return 0x8225ECF4;
		  /* 8225ECF4h */ case   33:  		/* mr R4, R28 */
		/* 8225ECF4h case   33:*/		regs.R4 = regs.R28;
		/* 8225ECF4h case   33:*/		return 0x8225ECF8;
		  /* 8225ECF8h */ case   34:  		/* mr R3, R31 */
		/* 8225ECF8h case   34:*/		regs.R3 = regs.R31;
		/* 8225ECF8h case   34:*/		return 0x8225ECFC;
		  /* 8225ECFCh */ case   35:  		/* bl -165716 */
		/* 8225ECFCh case   35:*/		regs.LR = 0x8225ED00; return 0x822365A8;
		/* 8225ECFCh case   35:*/		return 0x8225ED00;
		  /* 8225ED00h */ case   36:  		/* mr R4, R28 */
		/* 8225ED00h case   36:*/		regs.R4 = regs.R28;
		/* 8225ED00h case   36:*/		return 0x8225ED04;
		  /* 8225ED04h */ case   37:  		/* mr R3, R14 */
		/* 8225ED04h case   37:*/		regs.R3 = regs.R14;
		/* 8225ED04h case   37:*/		return 0x8225ED08;
		  /* 8225ED08h */ case   38:  		/* bl -24024 */
		/* 8225ED08h case   38:*/		regs.LR = 0x8225ED0C; return 0x82258F30;
		/* 8225ED08h case   38:*/		return 0x8225ED0C;
		  /* 8225ED0Ch */ case   39:  		/* mr R3, R28 */
		/* 8225ED0Ch case   39:*/		regs.R3 = regs.R28;
		/* 8225ED0Ch case   39:*/		return 0x8225ED10;
		  /* 8225ED10h */ case   40:  		/* bl -36176 */
		/* 8225ED10h case   40:*/		regs.LR = 0x8225ED14; return 0x82255FC0;
		/* 8225ED10h case   40:*/		return 0x8225ED14;
	}
	return 0x8225ED14;
} // Block from 8225EC70h-8225ED14h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8225ED14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ED14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ED14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ED14);
		  /* 8225ED14h */ case    0:  		/* rlwinm. R11, R22, 0, 27, 27 */
		/* 8225ED14h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R22);
		/* 8225ED14h case    0:*/		return 0x8225ED18;
		  /* 8225ED18h */ case    1:  		/* li R29, 105 */
		/* 8225ED18h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x69);
		/* 8225ED18h case    1:*/		return 0x8225ED1C;
		  /* 8225ED1Ch */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8225ED1Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8225ED24;  }
		/* 8225ED1Ch case    2:*/		return 0x8225ED20;
		  /* 8225ED20h */ case    3:  		/* li R29, 108 */
		/* 8225ED20h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x6C);
		/* 8225ED20h case    3:*/		return 0x8225ED24;
	}
	return 0x8225ED24;
} // Block from 8225ED14h-8225ED24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225ED24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ED24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ED24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ED24);
		  /* 8225ED24h */ case    0:  		/* rlwinm. R11, R22, 0, 26, 26 */
		/* 8225ED24h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R22);
		/* 8225ED24h case    0:*/		return 0x8225ED28;
		  /* 8225ED28h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8225ED28h case    1:*/		if ( regs.CR[0].eq ) { return 0x8225ED30;  }
		/* 8225ED28h case    1:*/		return 0x8225ED2C;
		  /* 8225ED2Ch */ case    2:  		/* li R29, 112 */
		/* 8225ED2Ch case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x70);
		/* 8225ED2Ch case    2:*/		return 0x8225ED30;
	}
	return 0x8225ED30;
} // Block from 8225ED24h-8225ED30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8225ED30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ED30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ED30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ED30);
		  /* 8225ED30h */ case    0:  		/* cmpwi CR6, R21, 1 */
		/* 8225ED30h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000001);
		/* 8225ED30h case    0:*/		return 0x8225ED34;
		  /* 8225ED34h */ case    1:  		/* bc 12, CR6_EQ, 1432 */
		/* 8225ED34h case    1:*/		if ( regs.CR[6].eq ) { return 0x8225F2CC;  }
		/* 8225ED34h case    1:*/		return 0x8225ED38;
		  /* 8225ED38h */ case    2:  		/* cmpwi CR6, R21, 2 */
		/* 8225ED38h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000002);
		/* 8225ED38h case    2:*/		return 0x8225ED3C;
		  /* 8225ED3Ch */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 8225ED3Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8225ED7C;  }
		/* 8225ED3Ch case    3:*/		return 0x8225ED40;
		  /* 8225ED40h */ case    4:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225ED40h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225ED40h case    4:*/		return 0x8225ED44;
		  /* 8225ED44h */ case    5:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225ED44h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225ED44h case    5:*/		return 0x8225ED48;
		  /* 8225ED48h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8225ED48h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225ED48h case    6:*/		return 0x8225ED4C;
		  /* 8225ED4Ch */ case    7:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225ED4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225ED4Ch case    7:*/		return 0x8225ED50;
		  /* 8225ED50h */ case    8:  		/* mtspr CTR, R11 */
		/* 8225ED50h case    8:*/		regs.CTR = regs.R11;
		/* 8225ED50h case    8:*/		return 0x8225ED54;
		  /* 8225ED54h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8225ED54h case    9:*/		if ( 1 ) { regs.LR = 0x8225ED58; return (uint32)regs.CTR; }
		/* 8225ED54h case    9:*/		return 0x8225ED58;
		  /* 8225ED58h */ case   10:  		/* lis R11, -32222 */
		/* 8225ED58h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225ED58h case   10:*/		return 0x8225ED5C;
		  /* 8225ED5Ch */ case   11:  		/* mr R5, R3 */
		/* 8225ED5Ch case   11:*/		regs.R5 = regs.R3;
		/* 8225ED5Ch case   11:*/		return 0x8225ED60;
		  /* 8225ED60h */ case   12:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225ED60h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225ED60h case   12:*/		return 0x8225ED64;
		  /* 8225ED64h */ case   13:  		/* mr R4, R25 */
		/* 8225ED64h case   13:*/		regs.R4 = regs.R25;
		/* 8225ED64h case   13:*/		return 0x8225ED68;
		  /* 8225ED68h */ case   14:  		/* addi R6, R11, -12392 */
		/* 8225ED68h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225ED68h case   14:*/		return 0x8225ED6C;
		  /* 8225ED6Ch */ case   15:  		/* mr R7, R30 */
		/* 8225ED6Ch case   15:*/		regs.R7 = regs.R30;
		/* 8225ED6Ch case   15:*/		return 0x8225ED70;
		  /* 8225ED70h */ case   16:  		/* bl -182088 */
		/* 8225ED70h case   16:*/		regs.LR = 0x8225ED74; return 0x82232628;
		/* 8225ED70h case   16:*/		return 0x8225ED74;
		  /* 8225ED74h */ case   17:  		/* cmpwi CR6, R3, 1 */
		/* 8225ED74h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225ED74h case   17:*/		return 0x8225ED78;
		  /* 8225ED78h */ case   18:  		/* bc 12, CR6_EQ, 1364 */
		/* 8225ED78h case   18:*/		if ( regs.CR[6].eq ) { return 0x8225F2CC;  }
		/* 8225ED78h case   18:*/		return 0x8225ED7C;
	}
	return 0x8225ED7C;
} // Block from 8225ED30h-8225ED7Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225ED7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225ED7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225ED7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225ED7C);
		  /* 8225ED7Ch */ case    0:  		/* mr R3, R29 */
		/* 8225ED7Ch case    0:*/		regs.R3 = regs.R29;
		/* 8225ED7Ch case    0:*/		return 0x8225ED80;
		  /* 8225ED80h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225ED80h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225ED80h case    1:*/		return 0x8225ED84;
		  /* 8225ED84h */ case    2:  		/* bl -36436 */
		/* 8225ED84h case    2:*/		regs.LR = 0x8225ED88; return 0x82255F30;
		/* 8225ED84h case    2:*/		return 0x8225ED88;
		  /* 8225ED88h */ case    3:  		/* stw R25, <#[R3 + 176]> */
		/* 8225ED88h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x000000B0) );
		/* 8225ED88h case    3:*/		return 0x8225ED8C;
		  /* 8225ED8Ch */ case    4:  		/* stw R23, <#[R3 + 184]> */
		/* 8225ED8Ch case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225ED8Ch case    4:*/		return 0x8225ED90;
		  /* 8225ED90h */ case    5:  		/* mr R5, R18 */
		/* 8225ED90h case    5:*/		regs.R5 = regs.R18;
		/* 8225ED90h case    5:*/		return 0x8225ED94;
		  /* 8225ED94h */ case    6:  		/* li R4, 0 */
		/* 8225ED94h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225ED94h case    6:*/		return 0x8225ED98;
		  /* 8225ED98h */ case    7:  		/* mr R30, R3 */
		/* 8225ED98h case    7:*/		regs.R30 = regs.R3;
		/* 8225ED98h case    7:*/		return 0x8225ED9C;
		  /* 8225ED9Ch */ case    8:  		/* bl -35332 */
		/* 8225ED9Ch case    8:*/		regs.LR = 0x8225EDA0; return 0x82256398;
		/* 8225ED9Ch case    8:*/		return 0x8225EDA0;
		  /* 8225EDA0h */ case    9:  		/* mr R5, R19 */
		/* 8225EDA0h case    9:*/		regs.R5 = regs.R19;
		/* 8225EDA0h case    9:*/		return 0x8225EDA4;
		  /* 8225EDA4h */ case   10:  		/* li R4, 1 */
		/* 8225EDA4h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225EDA4h case   10:*/		return 0x8225EDA8;
		  /* 8225EDA8h */ case   11:  		/* mr R3, R30 */
		/* 8225EDA8h case   11:*/		regs.R3 = regs.R30;
		/* 8225EDA8h case   11:*/		return 0x8225EDAC;
		  /* 8225EDACh */ case   12:  		/* bl -35348 */
		/* 8225EDACh case   12:*/		regs.LR = 0x8225EDB0; return 0x82256398;
		/* 8225EDACh case   12:*/		return 0x8225EDB0;
		  /* 8225EDB0h */ case   13:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225EDB0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225EDB0h case   13:*/		return 0x8225EDB4;
		  /* 8225EDB4h */ case   14:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225EDB4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225EDB4h case   14:*/		return 0x8225EDB8;
		  /* 8225EDB8h */ case   15:  		/* cmplwi CR6, R11, 1 */
		/* 8225EDB8h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225EDB8h case   15:*/		return 0x8225EDBC;
		  /* 8225EDBCh */ case   16:  		/* bc 12, CR6_LT, 32 */
		/* 8225EDBCh case   16:*/		if ( regs.CR[6].lt ) { return 0x8225EDDC;  }
		/* 8225EDBCh case   16:*/		return 0x8225EDC0;
		  /* 8225EDC0h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 8225EDC0h case   17:*/		if ( regs.CR[6].eq ) { return 0x8225EDD4;  }
		/* 8225EDC0h case   17:*/		return 0x8225EDC4;
		  /* 8225EDC4h */ case   18:  		/* cmplwi CR6, R11, 3 */
		/* 8225EDC4h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225EDC4h case   18:*/		return 0x8225EDC8;
		  /* 8225EDC8h */ case   19:  		/* bc 4, CR6_LT, 20 */
		/* 8225EDC8h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8225EDDC;  }
		/* 8225EDC8h case   19:*/		return 0x8225EDCC;
		  /* 8225EDCCh */ case   20:  		/* li R11, 1 */
		/* 8225EDCCh case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225EDCCh case   20:*/		return 0x8225EDD0;
		  /* 8225EDD0h */ case   21:  		/* b 16 */
		/* 8225EDD0h case   21:*/		return 0x8225EDE0;
		/* 8225EDD0h case   21:*/		return 0x8225EDD4;
	}
	return 0x8225EDD4;
} // Block from 8225ED7Ch-8225EDD4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8225EDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EDD4);
		  /* 8225EDD4h */ case    0:  		/* li R11, 0 */
		/* 8225EDD4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225EDD4h case    0:*/		return 0x8225EDD8;
		  /* 8225EDD8h */ case    1:  		/* b 8 */
		/* 8225EDD8h case    1:*/		return 0x8225EDE0;
		/* 8225EDD8h case    1:*/		return 0x8225EDDC;
	}
	return 0x8225EDDC;
} // Block from 8225EDD4h-8225EDDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225EDDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EDDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EDDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EDDC);
		  /* 8225EDDCh */ case    0:  		/* li R11, 2 */
		/* 8225EDDCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225EDDCh case    0:*/		return 0x8225EDE0;
	}
	return 0x8225EDE0;
} // Block from 8225EDDCh-8225EDE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225EDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EDE0);
		  /* 8225EDE0h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225EDE0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225EDE0h case    0:*/		return 0x8225EDE4;
		  /* 8225EDE4h */ case    1:  		/* mr R4, R25 */
		/* 8225EDE4h case    1:*/		regs.R4 = regs.R25;
		/* 8225EDE4h case    1:*/		return 0x8225EDE8;
		  /* 8225EDE8h */ case    2:  		/* lwz R3, <#[R31 + 12]> */
		/* 8225EDE8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EDE8h case    2:*/		return 0x8225EDEC;
		  /* 8225EDECh */ case    3:  		/* bl -272172 */
		/* 8225EDECh case    3:*/		regs.LR = 0x8225EDF0; return 0x8221C6C0;
		/* 8225EDECh case    3:*/		return 0x8225EDF0;
		  /* 8225EDF0h */ case    4:  		/* lwz R11, <#[R30 + 184]> */
		/* 8225EDF0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B8) );
		/* 8225EDF0h case    4:*/		return 0x8225EDF4;
		  /* 8225EDF4h */ case    5:  		/* cmplwi CR6, R16, 0 */
		/* 8225EDF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225EDF4h case    5:*/		return 0x8225EDF8;
		  /* 8225EDF8h */ case    6:  		/* stw R3, <#[R30 + 172]> */
		/* 8225EDF8h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 8225EDF8h case    6:*/		return 0x8225EDFC;
		  /* 8225EDFCh */ case    7:  		/* sth R20, <#[R11 + 18]> */
		/* 8225EDFCh case    7:*/		cpu::mem::store16( regs, regs.R20, (uint32)(regs.R11 + 0x00000012) );
		/* 8225EDFCh case    7:*/		return 0x8225EE00;
		  /* 8225EE00h */ case    8:  		/* bc 12, CR6_EQ, 72 */
		/* 8225EE00h case    8:*/		if ( regs.CR[6].eq ) { return 0x8225EE48;  }
		/* 8225EE00h case    8:*/		return 0x8225EE04;
		  /* 8225EE04h */ case    9:  		/* cmplwi CR6, R24, 0 */
		/* 8225EE04h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8225EE04h case    9:*/		return 0x8225EE08;
		  /* 8225EE08h */ case   10:  		/* bc 12, CR6_EQ, 1200 */
		/* 8225EE08h case   10:*/		if ( regs.CR[6].eq ) { return 0x8225F2B8;  }
		/* 8225EE08h case   10:*/		return 0x8225EE0C;
		  /* 8225EE0Ch */ case   11:  		/* rlwinm R29, R25, 1, 0, 30 */
		/* 8225EE0Ch case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R25);
		/* 8225EE0Ch case   11:*/		return 0x8225EE10;
		  /* 8225EE10h */ case   12:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225EE10h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225EE10h case   12:*/		return 0x8225EE14;
		  /* 8225EE14h */ case   13:  		/* li R4, 29 */
		/* 8225EE14h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1D);
		/* 8225EE14h case   13:*/		return 0x8225EE18;
		  /* 8225EE18h */ case   14:  		/* mr R5, R29 */
		/* 8225EE18h case   14:*/		regs.R5 = regs.R29;
		/* 8225EE18h case   14:*/		return 0x8225EE1C;
		  /* 8225EE1Ch */ case   15:  		/* bl -103948 */
		/* 8225EE1Ch case   15:*/		regs.LR = 0x8225EE20; return 0x82245810;
		/* 8225EE1Ch case   15:*/		return 0x8225EE20;
		  /* 8225EE20h */ case   16:  		/* mr R4, R3 */
		/* 8225EE20h case   16:*/		regs.R4 = regs.R3;
		/* 8225EE20h case   16:*/		return 0x8225EE24;
		  /* 8225EE24h */ case   17:  		/* mr R3, R30 */
		/* 8225EE24h case   17:*/		regs.R3 = regs.R30;
		/* 8225EE24h case   17:*/		return 0x8225EE28;
		  /* 8225EE28h */ case   18:  		/* bl -19320 */
		/* 8225EE28h case   18:*/		regs.LR = 0x8225EE2C; return 0x8225A2B0;
		/* 8225EE28h case   18:*/		return 0x8225EE2C;
		  /* 8225EE2Ch */ case   19:  		/* addi R5, R29, 1 */
		/* 8225EE2Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x1);
		/* 8225EE2Ch case   19:*/		return 0x8225EE30;
		  /* 8225EE30h */ case   20:  		/* li R4, 29 */
		/* 8225EE30h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x1D);
		/* 8225EE30h case   20:*/		return 0x8225EE34;
		  /* 8225EE34h */ case   21:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225EE34h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225EE34h case   21:*/		return 0x8225EE38;
		  /* 8225EE38h */ case   22:  		/* bl -103976 */
		/* 8225EE38h case   22:*/		regs.LR = 0x8225EE3C; return 0x82245810;
		/* 8225EE38h case   22:*/		return 0x8225EE3C;
		  /* 8225EE3Ch */ case   23:  		/* mr R4, R3 */
		/* 8225EE3Ch case   23:*/		regs.R4 = regs.R3;
		/* 8225EE3Ch case   23:*/		return 0x8225EE40;
		  /* 8225EE40h */ case   24:  		/* mr R3, R30 */
		/* 8225EE40h case   24:*/		regs.R3 = regs.R30;
		/* 8225EE40h case   24:*/		return 0x8225EE44;
		  /* 8225EE44h */ case   25:  		/* bl -19348 */
		/* 8225EE44h case   25:*/		regs.LR = 0x8225EE48; return 0x8225A2B0;
		/* 8225EE44h case   25:*/		return 0x8225EE48;
	}
	return 0x8225EE48;
} // Block from 8225EDE0h-8225EE48h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8225EE48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EE48);
		  /* 8225EE48h */ case    0:  		/* lwz R21, <#[R1 + 208]> */
		/* 8225EE48h case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000D0) );
		/* 8225EE48h case    0:*/		return 0x8225EE4C;
		  /* 8225EE4Ch */ case    1:  		/* mr R4, R30 */
		/* 8225EE4Ch case    1:*/		regs.R4 = regs.R30;
		/* 8225EE4Ch case    1:*/		return 0x8225EE50;
		  /* 8225EE50h */ case    2:  		/* mr R3, R31 */
		/* 8225EE50h case    2:*/		regs.R3 = regs.R31;
		/* 8225EE50h case    2:*/		return 0x8225EE54;
		  /* 8225EE54h */ case    3:  		/* bl -166060 */
		/* 8225EE54h case    3:*/		regs.LR = 0x8225EE58; return 0x822365A8;
		/* 8225EE54h case    3:*/		return 0x8225EE58;
		  /* 8225EE58h */ case    4:  		/* mr R4, R30 */
		/* 8225EE58h case    4:*/		regs.R4 = regs.R30;
		/* 8225EE58h case    4:*/		return 0x8225EE5C;
		  /* 8225EE5Ch */ case    5:  		/* mr R3, R14 */
		/* 8225EE5Ch case    5:*/		regs.R3 = regs.R14;
		/* 8225EE5Ch case    5:*/		return 0x8225EE60;
		  /* 8225EE60h */ case    6:  		/* bl -24368 */
		/* 8225EE60h case    6:*/		regs.LR = 0x8225EE64; return 0x82258F30;
		/* 8225EE60h case    6:*/		return 0x8225EE64;
		  /* 8225EE64h */ case    7:  		/* mr R3, R30 */
		/* 8225EE64h case    7:*/		regs.R3 = regs.R30;
		/* 8225EE64h case    7:*/		return 0x8225EE68;
		  /* 8225EE68h */ case    8:  		/* bl -36520 */
		/* 8225EE68h case    8:*/		regs.LR = 0x8225EE6C; return 0x82255FC0;
		/* 8225EE68h case    8:*/		return 0x8225EE6C;
		  /* 8225EE6Ch */ case    9:  		/* lwz R22, <#[R1 + 128]> */
		/* 8225EE6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000080) );
		/* 8225EE6Ch case    9:*/		return 0x8225EE70;
		  /* 8225EE70h */ case   10:  		/* lwz R24, <#[R1 + 132]> */
		/* 8225EE70h case   10:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 8225EE70h case   10:*/		return 0x8225EE74;
		  /* 8225EE74h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225EE74h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225EE74h case   11:*/		return 0x8225EE78;
		  /* 8225EE78h */ case   12:  		/* bc 4, CR0_EQ, 28 */
		/* 8225EE78h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8225EE94;  }
		/* 8225EE78h case   12:*/		return 0x8225EE7C;
		  /* 8225EE7Ch */ case   13:  		/* li R7, 3070 */
		/* 8225EE7Ch case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xBFE);
		/* 8225EE7Ch case   13:*/		return 0x8225EE80;
		  /* 8225EE80h */ case   14:  		/* lwz R5, <#[R1 + 268]> */
		/* 8225EE80h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000010C) );
		/* 8225EE80h case   14:*/		return 0x8225EE84;
		  /* 8225EE84h */ case   15:  		/* li R3, 0 */
		/* 8225EE84h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225EE84h case   15:*/		return 0x8225EE88;
		  /* 8225EE88h */ case   16:  		/* mr R6, R22 */
		/* 8225EE88h case   16:*/		regs.R6 = regs.R22;
		/* 8225EE88h case   16:*/		return 0x8225EE8C;
		  /* 8225EE8Ch */ case   17:  		/* mr R4, R24 */
		/* 8225EE8Ch case   17:*/		regs.R4 = regs.R24;
		/* 8225EE8Ch case   17:*/		return 0x8225EE90;
		  /* 8225EE90h */ case   18:  		/* bl -1077896 */
		/* 8225EE90h case   18:*/		regs.LR = 0x8225EE94; return 0x82157C08;
		/* 8225EE90h case   18:*/		return 0x8225EE94;
	}
	return 0x8225EE94;
} // Block from 8225EE48h-8225EE94h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225EE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225EE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225EE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225EE94);
		  /* 8225EE94h */ case    0:  		/* lwz R27, <#[R1 + 136]> */
		/* 8225EE94h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000088) );
		/* 8225EE94h case    0:*/		return 0x8225EE98;
		  /* 8225EE98h */ case    1:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225EE98h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EE98h case    1:*/		return 0x8225EE9C;
		  /* 8225EE9Ch */ case    2:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225EE9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225EE9Ch case    2:*/		return 0x8225EEA0;
		  /* 8225EEA0h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8225EEA0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225EEA0h case    3:*/		return 0x8225EEA4;
		  /* 8225EEA4h */ case    4:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225EEA4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225EEA4h case    4:*/		return 0x8225EEA8;
		  /* 8225EEA8h */ case    5:  		/* mtspr CTR, R11 */
		/* 8225EEA8h case    5:*/		regs.CTR = regs.R11;
		/* 8225EEA8h case    5:*/		return 0x8225EEAC;
		  /* 8225EEACh */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 8225EEACh case    6:*/		if ( 1 ) { regs.LR = 0x8225EEB0; return (uint32)regs.CTR; }
		/* 8225EEACh case    6:*/		return 0x8225EEB0;
		  /* 8225EEB0h */ case    7:  		/* lis R11, -32222 */
		/* 8225EEB0h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EEB0h case    7:*/		return 0x8225EEB4;
		  /* 8225EEB4h */ case    8:  		/* mr R5, R3 */
		/* 8225EEB4h case    8:*/		regs.R5 = regs.R3;
		/* 8225EEB4h case    8:*/		return 0x8225EEB8;
		  /* 8225EEB8h */ case    9:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EEB8h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EEB8h case    9:*/		return 0x8225EEBC;
		  /* 8225EEBCh */ case   10:  		/* mr R4, R25 */
		/* 8225EEBCh case   10:*/		regs.R4 = regs.R25;
		/* 8225EEBCh case   10:*/		return 0x8225EEC0;
		  /* 8225EEC0h */ case   11:  		/* addi R6, R11, -12392 */
		/* 8225EEC0h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EEC0h case   11:*/		return 0x8225EEC4;
		  /* 8225EEC4h */ case   12:  		/* mr R7, R30 */
		/* 8225EEC4h case   12:*/		regs.R7 = regs.R30;
		/* 8225EEC4h case   12:*/		return 0x8225EEC8;
		  /* 8225EEC8h */ case   13:  		/* bl -186848 */
		/* 8225EEC8h case   13:*/		regs.LR = 0x8225EECC; return 0x822314E8;
		/* 8225EEC8h case   13:*/		return 0x8225EECC;
		  /* 8225EECCh */ case   14:  		/* cmpwi CR6, R3, 1 */
		/* 8225EECCh case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225EECCh case   14:*/		return 0x8225EED0;
		  /* 8225EED0h */ case   15:  		/* bc 4, CR6_EQ, 4440 */
		/* 8225EED0h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82260028;  }
		/* 8225EED0h case   15:*/		return 0x8225EED4;
		  /* 8225EED4h */ case   16:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225EED4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EED4h case   16:*/		return 0x8225EED8;
		  /* 8225EED8h */ case   17:  		/* li R4, 0 */
		/* 8225EED8h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225EED8h case   17:*/		return 0x8225EEDC;
		  /* 8225EEDCh */ case   18:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225EEDCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225EEDCh case   18:*/		return 0x8225EEE0;
		  /* 8225EEE0h */ case   19:  		/* addi R5, R11, -1 */
		/* 8225EEE0h case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225EEE0h case   19:*/		return 0x8225EEE4;
		  /* 8225EEE4h */ case   20:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225EEE4h case   20:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225EEE4h case   20:*/		return 0x8225EEE8;
		  /* 8225EEE8h */ case   21:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225EEE8h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225EEE8h case   21:*/		return 0x8225EEEC;
		  /* 8225EEECh */ case   22:  		/* bl -104156 */
		/* 8225EEECh case   22:*/		regs.LR = 0x8225EEF0; return 0x82245810;
		/* 8225EEECh case   22:*/		return 0x8225EEF0;
		  /* 8225EEF0h */ case   23:  		/* lis R11, -32222 */
		/* 8225EEF0h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EEF0h case   23:*/		return 0x8225EEF4;
		  /* 8225EEF4h */ case   24:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EEF4h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EEF4h case   24:*/		return 0x8225EEF8;
		  /* 8225EEF8h */ case   25:  		/* addi R5, R1, 424 */
		/* 8225EEF8h case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1A8);
		/* 8225EEF8h case   25:*/		return 0x8225EEFC;
		  /* 8225EEFCh */ case   26:  		/* addi R6, R11, -12392 */
		/* 8225EEFCh case   26:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EEFCh case   26:*/		return 0x8225EF00;
		  /* 8225EF00h */ case   27:  		/* mr R4, R25 */
		/* 8225EF00h case   27:*/		regs.R4 = regs.R25;
		/* 8225EF00h case   27:*/		return 0x8225EF04;
		  /* 8225EF04h */ case   28:  		/* mr R30, R3 */
		/* 8225EF04h case   28:*/		regs.R30 = regs.R3;
		/* 8225EF04h case   28:*/		return 0x8225EF08;
		  /* 8225EF08h */ case   29:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EF08h case   29:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EF08h case   29:*/		return 0x8225EF0C;
		  /* 8225EF0Ch */ case   30:  		/* bl -176836 */
		/* 8225EF0Ch case   30:*/		regs.LR = 0x8225EF10; return 0x82233C48;
		/* 8225EF0Ch case   30:*/		return 0x8225EF10;
		  /* 8225EF10h */ case   31:  		/* lis R11, -32222 */
		/* 8225EF10h case   31:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EF10h case   31:*/		return 0x8225EF14;
		  /* 8225EF14h */ case   32:  		/* addi R5, R1, 552 */
		/* 8225EF14h case   32:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x228);
		/* 8225EF14h case   32:*/		return 0x8225EF18;
		  /* 8225EF18h */ case   33:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EF18h case   33:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EF18h case   33:*/		return 0x8225EF1C;
		  /* 8225EF1Ch */ case   34:  		/* addi R6, R11, -12392 */
		/* 8225EF1Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EF1Ch case   34:*/		return 0x8225EF20;
		  /* 8225EF20h */ case   35:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EF20h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EF20h case   35:*/		return 0x8225EF24;
		  /* 8225EF24h */ case   36:  		/* mr R4, R25 */
		/* 8225EF24h case   36:*/		regs.R4 = regs.R25;
		/* 8225EF24h case   36:*/		return 0x8225EF28;
		  /* 8225EF28h */ case   37:  		/* bl -176840 */
		/* 8225EF28h case   37:*/		regs.LR = 0x8225EF2C; return 0x82233C60;
		/* 8225EF28h case   37:*/		return 0x8225EF2C;
		  /* 8225EF2Ch */ case   38:  		/* lis R11, -32222 */
		/* 8225EF2Ch case   38:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EF2Ch case   38:*/		return 0x8225EF30;
		  /* 8225EF30h */ case   39:  		/* addi R5, R1, 416 */
		/* 8225EF30h case   39:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1A0);
		/* 8225EF30h case   39:*/		return 0x8225EF34;
		  /* 8225EF34h */ case   40:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EF34h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EF34h case   40:*/		return 0x8225EF38;
		  /* 8225EF38h */ case   41:  		/* addi R6, R11, -12392 */
		/* 8225EF38h case   41:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EF38h case   41:*/		return 0x8225EF3C;
		  /* 8225EF3Ch */ case   42:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EF3Ch case   42:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EF3Ch case   42:*/		return 0x8225EF40;
		  /* 8225EF40h */ case   43:  		/* mr R4, R25 */
		/* 8225EF40h case   43:*/		regs.R4 = regs.R25;
		/* 8225EF40h case   43:*/		return 0x8225EF44;
		  /* 8225EF44h */ case   44:  		/* bl -176844 */
		/* 8225EF44h case   44:*/		regs.LR = 0x8225EF48; return 0x82233C78;
		/* 8225EF44h case   44:*/		return 0x8225EF48;
		  /* 8225EF48h */ case   45:  		/* lis R11, -32222 */
		/* 8225EF48h case   45:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EF48h case   45:*/		return 0x8225EF4C;
		  /* 8225EF4Ch */ case   46:  		/* addi R5, R1, 496 */
		/* 8225EF4Ch case   46:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1F0);
		/* 8225EF4Ch case   46:*/		return 0x8225EF50;
		  /* 8225EF50h */ case   47:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EF50h case   47:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EF50h case   47:*/		return 0x8225EF54;
		  /* 8225EF54h */ case   48:  		/* addi R6, R11, -12392 */
		/* 8225EF54h case   48:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EF54h case   48:*/		return 0x8225EF58;
		  /* 8225EF58h */ case   49:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EF58h case   49:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EF58h case   49:*/		return 0x8225EF5C;
		  /* 8225EF5Ch */ case   50:  		/* mr R4, R25 */
		/* 8225EF5Ch case   50:*/		regs.R4 = regs.R25;
		/* 8225EF5Ch case   50:*/		return 0x8225EF60;
		  /* 8225EF60h */ case   51:  		/* bl -178584 */
		/* 8225EF60h case   51:*/		regs.LR = 0x8225EF64; return 0x822335C8;
		/* 8225EF60h case   51:*/		return 0x8225EF64;
		  /* 8225EF64h */ case   52:  		/* lis R11, -32222 */
		/* 8225EF64h case   52:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EF64h case   52:*/		return 0x8225EF68;
		  /* 8225EF68h */ case   53:  		/* addi R5, R1, 408 */
		/* 8225EF68h case   53:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x198);
		/* 8225EF68h case   53:*/		return 0x8225EF6C;
		  /* 8225EF6Ch */ case   54:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EF6Ch case   54:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EF6Ch case   54:*/		return 0x8225EF70;
		  /* 8225EF70h */ case   55:  		/* addi R6, R11, -12392 */
		/* 8225EF70h case   55:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EF70h case   55:*/		return 0x8225EF74;
		  /* 8225EF74h */ case   56:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EF74h case   56:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EF74h case   56:*/		return 0x8225EF78;
		  /* 8225EF78h */ case   57:  		/* mr R4, R25 */
		/* 8225EF78h case   57:*/		regs.R4 = regs.R25;
		/* 8225EF78h case   57:*/		return 0x8225EF7C;
		  /* 8225EF7Ch */ case   58:  		/* bl -176876 */
		/* 8225EF7Ch case   58:*/		regs.LR = 0x8225EF80; return 0x82233C90;
		/* 8225EF7Ch case   58:*/		return 0x8225EF80;
		  /* 8225EF80h */ case   59:  		/* lis R11, -32222 */
		/* 8225EF80h case   59:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EF80h case   59:*/		return 0x8225EF84;
		  /* 8225EF84h */ case   60:  		/* addi R5, R1, 536 */
		/* 8225EF84h case   60:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x218);
		/* 8225EF84h case   60:*/		return 0x8225EF88;
		  /* 8225EF88h */ case   61:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EF88h case   61:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EF88h case   61:*/		return 0x8225EF8C;
		  /* 8225EF8Ch */ case   62:  		/* addi R6, R11, -12392 */
		/* 8225EF8Ch case   62:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EF8Ch case   62:*/		return 0x8225EF90;
		  /* 8225EF90h */ case   63:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EF90h case   63:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EF90h case   63:*/		return 0x8225EF94;
		  /* 8225EF94h */ case   64:  		/* mr R4, R25 */
		/* 8225EF94h case   64:*/		regs.R4 = regs.R25;
		/* 8225EF94h case   64:*/		return 0x8225EF98;
		  /* 8225EF98h */ case   65:  		/* bl -176904 */
		/* 8225EF98h case   65:*/		regs.LR = 0x8225EF9C; return 0x82233C90;
		/* 8225EF98h case   65:*/		return 0x8225EF9C;
		  /* 8225EF9Ch */ case   66:  		/* lis R11, -32222 */
		/* 8225EF9Ch case   66:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EF9Ch case   66:*/		return 0x8225EFA0;
		  /* 8225EFA0h */ case   67:  		/* addi R5, R1, 400 */
		/* 8225EFA0h case   67:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x190);
		/* 8225EFA0h case   67:*/		return 0x8225EFA4;
		  /* 8225EFA4h */ case   68:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EFA4h case   68:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EFA4h case   68:*/		return 0x8225EFA8;
		  /* 8225EFA8h */ case   69:  		/* addi R6, R11, -12392 */
		/* 8225EFA8h case   69:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EFA8h case   69:*/		return 0x8225EFAC;
		  /* 8225EFACh */ case   70:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EFACh case   70:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EFACh case   70:*/		return 0x8225EFB0;
		  /* 8225EFB0h */ case   71:  		/* mr R4, R25 */
		/* 8225EFB0h case   71:*/		regs.R4 = regs.R25;
		/* 8225EFB0h case   71:*/		return 0x8225EFB4;
		  /* 8225EFB4h */ case   72:  		/* bl -176932 */
		/* 8225EFB4h case   72:*/		regs.LR = 0x8225EFB8; return 0x82233C90;
		/* 8225EFB4h case   72:*/		return 0x8225EFB8;
		  /* 8225EFB8h */ case   73:  		/* lis R11, -32222 */
		/* 8225EFB8h case   73:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EFB8h case   73:*/		return 0x8225EFBC;
		  /* 8225EFBCh */ case   74:  		/* addi R5, R1, 488 */
		/* 8225EFBCh case   74:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1E8);
		/* 8225EFBCh case   74:*/		return 0x8225EFC0;
		  /* 8225EFC0h */ case   75:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EFC0h case   75:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EFC0h case   75:*/		return 0x8225EFC4;
		  /* 8225EFC4h */ case   76:  		/* addi R6, R11, -12392 */
		/* 8225EFC4h case   76:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EFC4h case   76:*/		return 0x8225EFC8;
		  /* 8225EFC8h */ case   77:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EFC8h case   77:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EFC8h case   77:*/		return 0x8225EFCC;
		  /* 8225EFCCh */ case   78:  		/* mr R4, R25 */
		/* 8225EFCCh case   78:*/		regs.R4 = regs.R25;
		/* 8225EFCCh case   78:*/		return 0x8225EFD0;
		  /* 8225EFD0h */ case   79:  		/* bl -176888 */
		/* 8225EFD0h case   79:*/		regs.LR = 0x8225EFD4; return 0x82233CD8;
		/* 8225EFD0h case   79:*/		return 0x8225EFD4;
		  /* 8225EFD4h */ case   80:  		/* lis R11, -32222 */
		/* 8225EFD4h case   80:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EFD4h case   80:*/		return 0x8225EFD8;
		  /* 8225EFD8h */ case   81:  		/* addi R5, R1, 432 */
		/* 8225EFD8h case   81:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1B0);
		/* 8225EFD8h case   81:*/		return 0x8225EFDC;
		  /* 8225EFDCh */ case   82:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EFDCh case   82:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EFDCh case   82:*/		return 0x8225EFE0;
		  /* 8225EFE0h */ case   83:  		/* addi R6, R11, -12392 */
		/* 8225EFE0h case   83:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EFE0h case   83:*/		return 0x8225EFE4;
		  /* 8225EFE4h */ case   84:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225EFE4h case   84:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225EFE4h case   84:*/		return 0x8225EFE8;
		  /* 8225EFE8h */ case   85:  		/* mr R4, R25 */
		/* 8225EFE8h case   85:*/		regs.R4 = regs.R25;
		/* 8225EFE8h case   85:*/		return 0x8225EFEC;
		  /* 8225EFECh */ case   86:  		/* bl -176916 */
		/* 8225EFECh case   86:*/		regs.LR = 0x8225EFF0; return 0x82233CD8;
		/* 8225EFECh case   86:*/		return 0x8225EFF0;
		  /* 8225EFF0h */ case   87:  		/* lis R11, -32222 */
		/* 8225EFF0h case   87:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225EFF0h case   87:*/		return 0x8225EFF4;
		  /* 8225EFF4h */ case   88:  		/* addi R5, R1, 440 */
		/* 8225EFF4h case   88:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1B8);
		/* 8225EFF4h case   88:*/		return 0x8225EFF8;
		  /* 8225EFF8h */ case   89:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225EFF8h case   89:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225EFF8h case   89:*/		return 0x8225EFFC;
		  /* 8225EFFCh */ case   90:  		/* addi R6, R11, -12392 */
		/* 8225EFFCh case   90:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225EFFCh case   90:*/		return 0x8225F000;
		  /* 8225F000h */ case   91:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F000h case   91:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F000h case   91:*/		return 0x8225F004;
		  /* 8225F004h */ case   92:  		/* mr R4, R25 */
		/* 8225F004h case   92:*/		regs.R4 = regs.R25;
		/* 8225F004h case   92:*/		return 0x8225F008;
		  /* 8225F008h */ case   93:  		/* bl -176992 */
		/* 8225F008h case   93:*/		regs.LR = 0x8225F00C; return 0x82233CA8;
		/* 8225F008h case   93:*/		return 0x8225F00C;
		  /* 8225F00Ch */ case   94:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F00Ch case   94:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F00Ch case   94:*/		return 0x8225F010;
		  /* 8225F010h */ case   95:  		/* lis R11, -32222 */
		/* 8225F010h case   95:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F010h case   95:*/		return 0x8225F014;
		  /* 8225F014h */ case   96:  		/* addi R5, R1, 556 */
		/* 8225F014h case   96:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x22C);
		/* 8225F014h case   96:*/		return 0x8225F018;
		  /* 8225F018h */ case   97:  		/* addi R6, R11, -12392 */
		/* 8225F018h case   97:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F018h case   97:*/		return 0x8225F01C;
		  /* 8225F01Ch */ case   98:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F01Ch case   98:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F01Ch case   98:*/		return 0x8225F020;
		  /* 8225F020h */ case   99:  		/* mr R4, R25 */
		/* 8225F020h case   99:*/		regs.R4 = regs.R25;
		/* 8225F020h case   99:*/		return 0x8225F024;
		  /* 8225F024h */ case  100:  		/* bl -176996 */
		/* 8225F024h case  100:*/		regs.LR = 0x8225F028; return 0x82233CC0;
		/* 8225F024h case  100:*/		return 0x8225F028;
		  /* 8225F028h */ case  101:  		/* lis R11, -32222 */
		/* 8225F028h case  101:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F028h case  101:*/		return 0x8225F02C;
		  /* 8225F02Ch */ case  102:  		/* addi R5, R1, 504 */
		/* 8225F02Ch case  102:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1F8);
		/* 8225F02Ch case  102:*/		return 0x8225F030;
		  /* 8225F030h */ case  103:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F030h case  103:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F030h case  103:*/		return 0x8225F034;
		  /* 8225F034h */ case  104:  		/* addi R6, R11, -12392 */
		/* 8225F034h case  104:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F034h case  104:*/		return 0x8225F038;
		  /* 8225F038h */ case  105:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F038h case  105:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F038h case  105:*/		return 0x8225F03C;
		  /* 8225F03Ch */ case  106:  		/* mr R4, R25 */
		/* 8225F03Ch case  106:*/		regs.R4 = regs.R25;
		/* 8225F03Ch case  106:*/		return 0x8225F040;
		  /* 8225F040h */ case  107:  		/* bl -177000 */
		/* 8225F040h case  107:*/		regs.LR = 0x8225F044; return 0x82233CD8;
		/* 8225F040h case  107:*/		return 0x8225F044;
		  /* 8225F044h */ case  108:  		/* lis R11, -32222 */
		/* 8225F044h case  108:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F044h case  108:*/		return 0x8225F048;
		  /* 8225F048h */ case  109:  		/* addi R5, R1, 448 */
		/* 8225F048h case  109:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1C0);
		/* 8225F048h case  109:*/		return 0x8225F04C;
		  /* 8225F04Ch */ case  110:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F04Ch case  110:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F04Ch case  110:*/		return 0x8225F050;
		  /* 8225F050h */ case  111:  		/* addi R6, R11, -12392 */
		/* 8225F050h case  111:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F050h case  111:*/		return 0x8225F054;
		  /* 8225F054h */ case  112:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F054h case  112:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F054h case  112:*/		return 0x8225F058;
		  /* 8225F058h */ case  113:  		/* mr R4, R25 */
		/* 8225F058h case  113:*/		regs.R4 = regs.R25;
		/* 8225F058h case  113:*/		return 0x8225F05C;
		  /* 8225F05Ch */ case  114:  		/* bl -177004 */
		/* 8225F05Ch case  114:*/		regs.LR = 0x8225F060; return 0x82233CF0;
		/* 8225F05Ch case  114:*/		return 0x8225F060;
		  /* 8225F060h */ case  115:  		/* lis R11, -32222 */
		/* 8225F060h case  115:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F060h case  115:*/		return 0x8225F064;
		  /* 8225F064h */ case  116:  		/* addi R5, R1, 512 */
		/* 8225F064h case  116:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x200);
		/* 8225F064h case  116:*/		return 0x8225F068;
		  /* 8225F068h */ case  117:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F068h case  117:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F068h case  117:*/		return 0x8225F06C;
		  /* 8225F06Ch */ case  118:  		/* addi R6, R11, -12392 */
		/* 8225F06Ch case  118:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F06Ch case  118:*/		return 0x8225F070;
		  /* 8225F070h */ case  119:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F070h case  119:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F070h case  119:*/		return 0x8225F074;
		  /* 8225F074h */ case  120:  		/* mr R4, R25 */
		/* 8225F074h case  120:*/		regs.R4 = regs.R25;
		/* 8225F074h case  120:*/		return 0x8225F078;
		  /* 8225F078h */ case  121:  		/* bl -177008 */
		/* 8225F078h case  121:*/		regs.LR = 0x8225F07C; return 0x82233D08;
		/* 8225F078h case  121:*/		return 0x8225F07C;
		  /* 8225F07Ch */ case  122:  		/* lis R11, -32222 */
		/* 8225F07Ch case  122:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F07Ch case  122:*/		return 0x8225F080;
		  /* 8225F080h */ case  123:  		/* addi R5, R1, 372 */
		/* 8225F080h case  123:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x174);
		/* 8225F080h case  123:*/		return 0x8225F084;
		  /* 8225F084h */ case  124:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F084h case  124:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F084h case  124:*/		return 0x8225F088;
		  /* 8225F088h */ case  125:  		/* addi R6, R11, -12392 */
		/* 8225F088h case  125:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F088h case  125:*/		return 0x8225F08C;
		  /* 8225F08Ch */ case  126:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F08Ch case  126:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F08Ch case  126:*/		return 0x8225F090;
		  /* 8225F090h */ case  127:  		/* mr R4, R25 */
		/* 8225F090h case  127:*/		regs.R4 = regs.R25;
		/* 8225F090h case  127:*/		return 0x8225F094;
		  /* 8225F094h */ case  128:  		/* bl -177084 */
		/* 8225F094h case  128:*/		regs.LR = 0x8225F098; return 0x82233CD8;
		/* 8225F094h case  128:*/		return 0x8225F098;
		  /* 8225F098h */ case  129:  		/* lis R11, -32222 */
		/* 8225F098h case  129:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F098h case  129:*/		return 0x8225F09C;
		  /* 8225F09Ch */ case  130:  		/* addi R5, R1, 456 */
		/* 8225F09Ch case  130:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1C8);
		/* 8225F09Ch case  130:*/		return 0x8225F0A0;
		  /* 8225F0A0h */ case  131:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F0A0h case  131:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F0A0h case  131:*/		return 0x8225F0A4;
		  /* 8225F0A4h */ case  132:  		/* addi R6, R11, -12392 */
		/* 8225F0A4h case  132:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F0A4h case  132:*/		return 0x8225F0A8;
		  /* 8225F0A8h */ case  133:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F0A8h case  133:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F0A8h case  133:*/		return 0x8225F0AC;
		  /* 8225F0ACh */ case  134:  		/* mr R4, R25 */
		/* 8225F0ACh case  134:*/		regs.R4 = regs.R25;
		/* 8225F0ACh case  134:*/		return 0x8225F0B0;
		  /* 8225F0B0h */ case  135:  		/* bl -177112 */
		/* 8225F0B0h case  135:*/		regs.LR = 0x8225F0B4; return 0x82233CD8;
		/* 8225F0B0h case  135:*/		return 0x8225F0B4;
		  /* 8225F0B4h */ case  136:  		/* li R3, 20 */
		/* 8225F0B4h case  136:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225F0B4h case  136:*/		return 0x8225F0B8;
		  /* 8225F0B8h */ case  137:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F0B8h case  137:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F0B8h case  137:*/		return 0x8225F0BC;
		  /* 8225F0BCh */ case  138:  		/* bl -37260 */
		/* 8225F0BCh case  138:*/		regs.LR = 0x8225F0C0; return 0x82255F30;
		/* 8225F0BCh case  138:*/		return 0x8225F0C0;
		  /* 8225F0C0h */ case  139:  		/* mr R5, R30 */
		/* 8225F0C0h case  139:*/		regs.R5 = regs.R30;
		/* 8225F0C0h case  139:*/		return 0x8225F0C4;
		  /* 8225F0C4h */ case  140:  		/* li R4, 0 */
		/* 8225F0C4h case  140:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F0C4h case  140:*/		return 0x8225F0C8;
		  /* 8225F0C8h */ case  141:  		/* mr R29, R3 */
		/* 8225F0C8h case  141:*/		regs.R29 = regs.R3;
		/* 8225F0C8h case  141:*/		return 0x8225F0CC;
		  /* 8225F0CCh */ case  142:  		/* bl -36148 */
		/* 8225F0CCh case  142:*/		regs.LR = 0x8225F0D0; return 0x82256398;
		/* 8225F0CCh case  142:*/		return 0x8225F0D0;
		  /* 8225F0D0h */ case  143:  		/* mr R3, R29 */
		/* 8225F0D0h case  143:*/		regs.R3 = regs.R29;
		/* 8225F0D0h case  143:*/		return 0x8225F0D4;
		  /* 8225F0D4h */ case  144:  		/* mr R5, R18 */
		/* 8225F0D4h case  144:*/		regs.R5 = regs.R18;
		/* 8225F0D4h case  144:*/		return 0x8225F0D8;
		  /* 8225F0D8h */ case  145:  		/* li R4, 1 */
		/* 8225F0D8h case  145:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F0D8h case  145:*/		return 0x8225F0DC;
		  /* 8225F0DCh */ case  146:  		/* bl -36164 */
		/* 8225F0DCh case  146:*/		regs.LR = 0x8225F0E0; return 0x82256398;
		/* 8225F0DCh case  146:*/		return 0x8225F0E0;
		  /* 8225F0E0h */ case  147:  		/* lwz R11, <#[R27 - 1280]> */
		/* 8225F0E0h case  147:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB00) );
		/* 8225F0E0h case  147:*/		return 0x8225F0E4;
		  /* 8225F0E4h */ case  148:  		/* mr R3, R29 */
		/* 8225F0E4h case  148:*/		regs.R3 = regs.R29;
		/* 8225F0E4h case  148:*/		return 0x8225F0E8;
		  /* 8225F0E8h */ case  149:  		/* li R5, 2 */
		/* 8225F0E8h case  149:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225F0E8h case  149:*/		return 0x8225F0EC;
		  /* 8225F0ECh */ case  150:  		/* mr R4, R31 */
		/* 8225F0ECh case  150:*/		regs.R4 = regs.R31;
		/* 8225F0ECh case  150:*/		return 0x8225F0F0;
		  /* 8225F0F0h */ case  151:  		/* stw R11, <#[R29 + 132]> */
		/* 8225F0F0h case  151:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 8225F0F0h case  151:*/		return 0x8225F0F4;
		  /* 8225F0F4h */ case  152:  		/* lfs FR4, <#[R1 + 488]> */
		/* 8225F0F4h case  152:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x000001E8) );
		/* 8225F0F4h case  152:*/		return 0x8225F0F8;
		  /* 8225F0F8h */ case  153:  		/* lfs FR3, <#[R1 + 400]> */
		/* 8225F0F8h case  153:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R1 + 0x00000190) );
		/* 8225F0F8h case  153:*/		return 0x8225F0FC;
		  /* 8225F0FCh */ case  154:  		/* lfs FR2, <#[R1 + 536]> */
		/* 8225F0FCh case  154:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000218) );
		/* 8225F0FCh case  154:*/		return 0x8225F100;
		  /* 8225F100h */ case  155:  		/* lfs FR1, <#[R1 + 408]> */
		/* 8225F100h case  155:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000198) );
		/* 8225F100h case  155:*/		return 0x8225F104;
		  /* 8225F104h */ case  156:  		/* bl -33260 */
		/* 8225F104h case  156:*/		regs.LR = 0x8225F108; return 0x82256F18;
		/* 8225F104h case  156:*/		return 0x8225F108;
		  /* 8225F108h */ case  157:  		/* mr R3, R29 */
		/* 8225F108h case  157:*/		regs.R3 = regs.R29;
		/* 8225F108h case  157:*/		return 0x8225F10C;
		  /* 8225F10Ch */ case  158:  		/* li R5, 3 */
		/* 8225F10Ch case  158:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225F10Ch case  158:*/		return 0x8225F110;
		  /* 8225F110h */ case  159:  		/* lfs FR4, <#[R1 + 496]> */
		/* 8225F110h case  159:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x000001F0) );
		/* 8225F110h case  159:*/		return 0x8225F114;
		  /* 8225F114h */ case  160:  		/* mr R4, R31 */
		/* 8225F114h case  160:*/		regs.R4 = regs.R31;
		/* 8225F114h case  160:*/		return 0x8225F118;
		  /* 8225F118h */ case  161:  		/* lfs FR3, <#[R1 + 416]> */
		/* 8225F118h case  161:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R1 + 0x000001A0) );
		/* 8225F118h case  161:*/		return 0x8225F11C;
		  /* 8225F11Ch */ case  162:  		/* lfs FR2, <#[R1 + 552]> */
		/* 8225F11Ch case  162:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000228) );
		/* 8225F11Ch case  162:*/		return 0x8225F120;
		  /* 8225F120h */ case  163:  		/* lfs FR1, <#[R1 + 424]> */
		/* 8225F120h case  163:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x000001A8) );
		/* 8225F120h case  163:*/		return 0x8225F124;
		  /* 8225F124h */ case  164:  		/* bl -33292 */
		/* 8225F124h case  164:*/		regs.LR = 0x8225F128; return 0x82256F18;
		/* 8225F124h case  164:*/		return 0x8225F128;
		  /* 8225F128h */ case  165:  		/* mr R4, R29 */
		/* 8225F128h case  165:*/		regs.R4 = regs.R29;
		/* 8225F128h case  165:*/		return 0x8225F12C;
		  /* 8225F12Ch */ case  166:  		/* mr R3, R31 */
		/* 8225F12Ch case  166:*/		regs.R3 = regs.R31;
		/* 8225F12Ch case  166:*/		return 0x8225F130;
		  /* 8225F130h */ case  167:  		/* bl -166792 */
		/* 8225F130h case  167:*/		regs.LR = 0x8225F134; return 0x822365A8;
		/* 8225F130h case  167:*/		return 0x8225F134;
		  /* 8225F134h */ case  168:  		/* mr R4, R29 */
		/* 8225F134h case  168:*/		regs.R4 = regs.R29;
		/* 8225F134h case  168:*/		return 0x8225F138;
		  /* 8225F138h */ case  169:  		/* mr R3, R14 */
		/* 8225F138h case  169:*/		regs.R3 = regs.R14;
		/* 8225F138h case  169:*/		return 0x8225F13C;
		  /* 8225F13Ch */ case  170:  		/* bl -25100 */
		/* 8225F13Ch case  170:*/		regs.LR = 0x8225F140; return 0x82258F30;
		/* 8225F13Ch case  170:*/		return 0x8225F140;
		  /* 8225F140h */ case  171:  		/* mr R3, R29 */
		/* 8225F140h case  171:*/		regs.R3 = regs.R29;
		/* 8225F140h case  171:*/		return 0x8225F144;
		  /* 8225F144h */ case  172:  		/* bl -37252 */
		/* 8225F144h case  172:*/		regs.LR = 0x8225F148; return 0x82255FC0;
		/* 8225F144h case  172:*/		return 0x8225F148;
		  /* 8225F148h */ case  173:  		/* lwz R28, <#[R1 + 184]> */
		/* 8225F148h case  173:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B8) );
		/* 8225F148h case  173:*/		return 0x8225F14C;
		  /* 8225F14Ch */ case  174:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F14Ch case  174:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F14Ch case  174:*/		return 0x8225F150;
		  /* 8225F150h */ case  175:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F150h case  175:*/		if ( !regs.CR[0].eq ) { return 0x8225F16C;  }
		/* 8225F150h case  175:*/		return 0x8225F154;
		  /* 8225F154h */ case  176:  		/* mr R6, R22 */
		/* 8225F154h case  176:*/		regs.R6 = regs.R22;
		/* 8225F154h case  176:*/		return 0x8225F158;
		  /* 8225F158h */ case  177:  		/* mr R4, R24 */
		/* 8225F158h case  177:*/		regs.R4 = regs.R24;
		/* 8225F158h case  177:*/		return 0x8225F15C;
		  /* 8225F15Ch */ case  178:  		/* mr R5, R28 */
		/* 8225F15Ch case  178:*/		regs.R5 = regs.R28;
		/* 8225F15Ch case  178:*/		return 0x8225F160;
		  /* 8225F160h */ case  179:  		/* li R7, 3161 */
		/* 8225F160h case  179:*/		cpu::op::li<0>(regs,&regs.R7,0xC59);
		/* 8225F160h case  179:*/		return 0x8225F164;
		  /* 8225F164h */ case  180:  		/* li R3, 0 */
		/* 8225F164h case  180:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F164h case  180:*/		return 0x8225F168;
		  /* 8225F168h */ case  181:  		/* bl -1078624 */
		/* 8225F168h case  181:*/		regs.LR = 0x8225F16C; return 0x82157C08;
		/* 8225F168h case  181:*/		return 0x8225F16C;
	}
	return 0x8225F16C;
} // Block from 8225EE94h-8225F16Ch (182 instructions)

//////////////////////////////////////////////////////
// Block at 8225F16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F16C);
		  /* 8225F16Ch */ case    0:  		/* li R3, 20 */
		/* 8225F16Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225F16Ch case    0:*/		return 0x8225F170;
		  /* 8225F170h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F170h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F170h case    1:*/		return 0x8225F174;
		  /* 8225F174h */ case    2:  		/* bl -37444 */
		/* 8225F174h case    2:*/		regs.LR = 0x8225F178; return 0x82255F30;
		/* 8225F174h case    2:*/		return 0x8225F178;
		  /* 8225F178h */ case    3:  		/* mr R5, R30 */
		/* 8225F178h case    3:*/		regs.R5 = regs.R30;
		/* 8225F178h case    3:*/		return 0x8225F17C;
		  /* 8225F17Ch */ case    4:  		/* li R4, 0 */
		/* 8225F17Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F17Ch case    4:*/		return 0x8225F180;
		  /* 8225F180h */ case    5:  		/* mr R29, R3 */
		/* 8225F180h case    5:*/		regs.R29 = regs.R3;
		/* 8225F180h case    5:*/		return 0x8225F184;
		  /* 8225F184h */ case    6:  		/* bl -36332 */
		/* 8225F184h case    6:*/		regs.LR = 0x8225F188; return 0x82256398;
		/* 8225F184h case    6:*/		return 0x8225F188;
		  /* 8225F188h */ case    7:  		/* mr R3, R29 */
		/* 8225F188h case    7:*/		regs.R3 = regs.R29;
		/* 8225F188h case    7:*/		return 0x8225F18C;
		  /* 8225F18Ch */ case    8:  		/* mr R5, R18 */
		/* 8225F18Ch case    8:*/		regs.R5 = regs.R18;
		/* 8225F18Ch case    8:*/		return 0x8225F190;
		  /* 8225F190h */ case    9:  		/* li R4, 1 */
		/* 8225F190h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F190h case    9:*/		return 0x8225F194;
		  /* 8225F194h */ case   10:  		/* bl -36348 */
		/* 8225F194h case   10:*/		regs.LR = 0x8225F198; return 0x82256398;
		/* 8225F194h case   10:*/		return 0x8225F198;
		  /* 8225F198h */ case   11:  		/* lwz R11, <#[R27 - 1276]> */
		/* 8225F198h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 8225F198h case   11:*/		return 0x8225F19C;
		  /* 8225F19Ch */ case   12:  		/* mr R3, R29 */
		/* 8225F19Ch case   12:*/		regs.R3 = regs.R29;
		/* 8225F19Ch case   12:*/		return 0x8225F1A0;
		  /* 8225F1A0h */ case   13:  		/* li R5, 2 */
		/* 8225F1A0h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225F1A0h case   13:*/		return 0x8225F1A4;
		  /* 8225F1A4h */ case   14:  		/* mr R4, R31 */
		/* 8225F1A4h case   14:*/		regs.R4 = regs.R31;
		/* 8225F1A4h case   14:*/		return 0x8225F1A8;
		  /* 8225F1A8h */ case   15:  		/* stw R11, <#[R29 + 132]> */
		/* 8225F1A8h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 8225F1A8h case   15:*/		return 0x8225F1AC;
		  /* 8225F1ACh */ case   16:  		/* lfs FR4, <#[R1 + 504]> */
		/* 8225F1ACh case   16:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x000001F8) );
		/* 8225F1ACh case   16:*/		return 0x8225F1B0;
		  /* 8225F1B0h */ case   17:  		/* lfs FR1, <#[R1 + 432]> */
		/* 8225F1B0h case   17:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x000001B0) );
		/* 8225F1B0h case   17:*/		return 0x8225F1B4;
		  /* 8225F1B4h */ case   18:  		/* lfs FR3, <#[R1 + 556]> */
		/* 8225F1B4h case   18:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R1 + 0x0000022C) );
		/* 8225F1B4h case   18:*/		return 0x8225F1B8;
		  /* 8225F1B8h */ case   19:  		/* lfs FR2, <#[R1 + 440]> */
		/* 8225F1B8h case   19:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x000001B8) );
		/* 8225F1B8h case   19:*/		return 0x8225F1BC;
		  /* 8225F1BCh */ case   20:  		/* bl -33444 */
		/* 8225F1BCh case   20:*/		regs.LR = 0x8225F1C0; return 0x82256F18;
		/* 8225F1BCh case   20:*/		return 0x8225F1C0;
		  /* 8225F1C0h */ case   21:  		/* mr R3, R29 */
		/* 8225F1C0h case   21:*/		regs.R3 = regs.R29;
		/* 8225F1C0h case   21:*/		return 0x8225F1C4;
		  /* 8225F1C4h */ case   22:  		/* mr R5, R30 */
		/* 8225F1C4h case   22:*/		regs.R5 = regs.R30;
		/* 8225F1C4h case   22:*/		return 0x8225F1C8;
		  /* 8225F1C8h */ case   23:  		/* li R4, 3 */
		/* 8225F1C8h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F1C8h case   23:*/		return 0x8225F1CC;
		  /* 8225F1CCh */ case   24:  		/* bl -36404 */
		/* 8225F1CCh case   24:*/		regs.LR = 0x8225F1D0; return 0x82256398;
		/* 8225F1CCh case   24:*/		return 0x8225F1D0;
		  /* 8225F1D0h */ case   25:  		/* mr R4, R29 */
		/* 8225F1D0h case   25:*/		regs.R4 = regs.R29;
		/* 8225F1D0h case   25:*/		return 0x8225F1D4;
		  /* 8225F1D4h */ case   26:  		/* mr R3, R31 */
		/* 8225F1D4h case   26:*/		regs.R3 = regs.R31;
		/* 8225F1D4h case   26:*/		return 0x8225F1D8;
		  /* 8225F1D8h */ case   27:  		/* bl -166960 */
		/* 8225F1D8h case   27:*/		regs.LR = 0x8225F1DC; return 0x822365A8;
		/* 8225F1D8h case   27:*/		return 0x8225F1DC;
		  /* 8225F1DCh */ case   28:  		/* mr R4, R29 */
		/* 8225F1DCh case   28:*/		regs.R4 = regs.R29;
		/* 8225F1DCh case   28:*/		return 0x8225F1E0;
		  /* 8225F1E0h */ case   29:  		/* mr R3, R14 */
		/* 8225F1E0h case   29:*/		regs.R3 = regs.R14;
		/* 8225F1E0h case   29:*/		return 0x8225F1E4;
		  /* 8225F1E4h */ case   30:  		/* bl -25268 */
		/* 8225F1E4h case   30:*/		regs.LR = 0x8225F1E8; return 0x82258F30;
		/* 8225F1E4h case   30:*/		return 0x8225F1E8;
		  /* 8225F1E8h */ case   31:  		/* mr R3, R29 */
		/* 8225F1E8h case   31:*/		regs.R3 = regs.R29;
		/* 8225F1E8h case   31:*/		return 0x8225F1EC;
		  /* 8225F1ECh */ case   32:  		/* bl -37420 */
		/* 8225F1ECh case   32:*/		regs.LR = 0x8225F1F0; return 0x82255FC0;
		/* 8225F1ECh case   32:*/		return 0x8225F1F0;
		  /* 8225F1F0h */ case   33:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F1F0h case   33:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F1F0h case   33:*/		return 0x8225F1F4;
		  /* 8225F1F4h */ case   34:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F1F4h case   34:*/		if ( !regs.CR[0].eq ) { return 0x8225F210;  }
		/* 8225F1F4h case   34:*/		return 0x8225F1F8;
		  /* 8225F1F8h */ case   35:  		/* mr R6, R22 */
		/* 8225F1F8h case   35:*/		regs.R6 = regs.R22;
		/* 8225F1F8h case   35:*/		return 0x8225F1FC;
		  /* 8225F1FCh */ case   36:  		/* mr R5, R28 */
		/* 8225F1FCh case   36:*/		regs.R5 = regs.R28;
		/* 8225F1FCh case   36:*/		return 0x8225F200;
		  /* 8225F200h */ case   37:  		/* mr R4, R24 */
		/* 8225F200h case   37:*/		regs.R4 = regs.R24;
		/* 8225F200h case   37:*/		return 0x8225F204;
		  /* 8225F204h */ case   38:  		/* li R7, 3171 */
		/* 8225F204h case   38:*/		cpu::op::li<0>(regs,&regs.R7,0xC63);
		/* 8225F204h case   38:*/		return 0x8225F208;
		  /* 8225F208h */ case   39:  		/* li R3, 0 */
		/* 8225F208h case   39:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F208h case   39:*/		return 0x8225F20C;
		  /* 8225F20Ch */ case   40:  		/* bl -1078788 */
		/* 8225F20Ch case   40:*/		regs.LR = 0x8225F210; return 0x82157C08;
		/* 8225F20Ch case   40:*/		return 0x8225F210;
	}
	return 0x8225F210;
} // Block from 8225F16Ch-8225F210h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8225F210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F210);
		  /* 8225F210h */ case    0:  		/* li R3, 20 */
		/* 8225F210h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225F210h case    0:*/		return 0x8225F214;
		  /* 8225F214h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F214h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F214h case    1:*/		return 0x8225F218;
		  /* 8225F218h */ case    2:  		/* bl -37608 */
		/* 8225F218h case    2:*/		regs.LR = 0x8225F21C; return 0x82255F30;
		/* 8225F218h case    2:*/		return 0x8225F21C;
		  /* 8225F21Ch */ case    3:  		/* mr R5, R18 */
		/* 8225F21Ch case    3:*/		regs.R5 = regs.R18;
		/* 8225F21Ch case    3:*/		return 0x8225F220;
		  /* 8225F220h */ case    4:  		/* li R4, 0 */
		/* 8225F220h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F220h case    4:*/		return 0x8225F224;
		  /* 8225F224h */ case    5:  		/* mr R15, R3 */
		/* 8225F224h case    5:*/		regs.R15 = regs.R3;
		/* 8225F224h case    5:*/		return 0x8225F228;
		  /* 8225F228h */ case    6:  		/* bl -36496 */
		/* 8225F228h case    6:*/		regs.LR = 0x8225F22C; return 0x82256398;
		/* 8225F228h case    6:*/		return 0x8225F22C;
		  /* 8225F22Ch */ case    7:  		/* mr R3, R15 */
		/* 8225F22Ch case    7:*/		regs.R3 = regs.R15;
		/* 8225F22Ch case    7:*/		return 0x8225F230;
		  /* 8225F230h */ case    8:  		/* mr R5, R18 */
		/* 8225F230h case    8:*/		regs.R5 = regs.R18;
		/* 8225F230h case    8:*/		return 0x8225F234;
		  /* 8225F234h */ case    9:  		/* li R4, 1 */
		/* 8225F234h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F234h case    9:*/		return 0x8225F238;
		  /* 8225F238h */ case   10:  		/* bl -36512 */
		/* 8225F238h case   10:*/		regs.LR = 0x8225F23C; return 0x82256398;
		/* 8225F238h case   10:*/		return 0x8225F23C;
		  /* 8225F23Ch */ case   11:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225F23Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225F23Ch case   11:*/		return 0x8225F240;
		  /* 8225F240h */ case   12:  		/* mr R3, R15 */
		/* 8225F240h case   12:*/		regs.R3 = regs.R15;
		/* 8225F240h case   12:*/		return 0x8225F244;
		  /* 8225F244h */ case   13:  		/* li R5, 2 */
		/* 8225F244h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225F244h case   13:*/		return 0x8225F248;
		  /* 8225F248h */ case   14:  		/* mr R4, R31 */
		/* 8225F248h case   14:*/		regs.R4 = regs.R31;
		/* 8225F248h case   14:*/		return 0x8225F24C;
		  /* 8225F24Ch */ case   15:  		/* stw R11, <#[R15 + 132]> */
		/* 8225F24Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000084) );
		/* 8225F24Ch case   15:*/		return 0x8225F250;
		  /* 8225F250h */ case   16:  		/* lfs FR4, <#[R1 + 456]> */
		/* 8225F250h case   16:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x000001C8) );
		/* 8225F250h case   16:*/		return 0x8225F254;
		  /* 8225F254h */ case   17:  		/* lfs FR2, <#[R1 + 512]> */
		/* 8225F254h case   17:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000200) );
		/* 8225F254h case   17:*/		return 0x8225F258;
		  /* 8225F258h */ case   18:  		/* lfs FR1, <#[R1 + 448]> */
		/* 8225F258h case   18:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x000001C0) );
		/* 8225F258h case   18:*/		return 0x8225F25C;
		  /* 8225F25Ch */ case   19:  		/* lfs FR3, <#[R1 + 372]> */
		/* 8225F25Ch case   19:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R1 + 0x00000174) );
		/* 8225F25Ch case   19:*/		return 0x8225F260;
		  /* 8225F260h */ case   20:  		/* bl -33608 */
		/* 8225F260h case   20:*/		regs.LR = 0x8225F264; return 0x82256F18;
		/* 8225F260h case   20:*/		return 0x8225F264;
		  /* 8225F264h */ case   21:  		/* mr R3, R15 */
		/* 8225F264h case   21:*/		regs.R3 = regs.R15;
		/* 8225F264h case   21:*/		return 0x8225F268;
		  /* 8225F268h */ case   22:  		/* mr R5, R30 */
		/* 8225F268h case   22:*/		regs.R5 = regs.R30;
		/* 8225F268h case   22:*/		return 0x8225F26C;
		  /* 8225F26Ch */ case   23:  		/* li R4, 3 */
		/* 8225F26Ch case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F26Ch case   23:*/		return 0x8225F270;
		  /* 8225F270h */ case   24:  		/* bl -36568 */
		/* 8225F270h case   24:*/		regs.LR = 0x8225F274; return 0x82256398;
		/* 8225F270h case   24:*/		return 0x8225F274;
		  /* 8225F274h */ case   25:  		/* mr R4, R15 */
		/* 8225F274h case   25:*/		regs.R4 = regs.R15;
		/* 8225F274h case   25:*/		return 0x8225F278;
		  /* 8225F278h */ case   26:  		/* mr R3, R31 */
		/* 8225F278h case   26:*/		regs.R3 = regs.R31;
		/* 8225F278h case   26:*/		return 0x8225F27C;
		  /* 8225F27Ch */ case   27:  		/* bl -167124 */
		/* 8225F27Ch case   27:*/		regs.LR = 0x8225F280; return 0x822365A8;
		/* 8225F27Ch case   27:*/		return 0x8225F280;
		  /* 8225F280h */ case   28:  		/* mr R4, R15 */
		/* 8225F280h case   28:*/		regs.R4 = regs.R15;
		/* 8225F280h case   28:*/		return 0x8225F284;
		  /* 8225F284h */ case   29:  		/* mr R3, R14 */
		/* 8225F284h case   29:*/		regs.R3 = regs.R14;
		/* 8225F284h case   29:*/		return 0x8225F288;
		  /* 8225F288h */ case   30:  		/* bl -25432 */
		/* 8225F288h case   30:*/		regs.LR = 0x8225F28C; return 0x82258F30;
		/* 8225F288h case   30:*/		return 0x8225F28C;
		  /* 8225F28Ch */ case   31:  		/* mr R3, R15 */
		/* 8225F28Ch case   31:*/		regs.R3 = regs.R15;
		/* 8225F28Ch case   31:*/		return 0x8225F290;
		  /* 8225F290h */ case   32:  		/* bl -37584 */
		/* 8225F290h case   32:*/		regs.LR = 0x8225F294; return 0x82255FC0;
		/* 8225F290h case   32:*/		return 0x8225F294;
		  /* 8225F294h */ case   33:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F294h case   33:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F294h case   33:*/		return 0x8225F298;
		  /* 8225F298h */ case   34:  		/* bc 4, CR0_EQ, 3476 */
		/* 8225F298h case   34:*/		if ( !regs.CR[0].eq ) { return 0x8226002C;  }
		/* 8225F298h case   34:*/		return 0x8225F29C;
		  /* 8225F29Ch */ case   35:  		/* mr R6, R22 */
		/* 8225F29Ch case   35:*/		regs.R6 = regs.R22;
		/* 8225F29Ch case   35:*/		return 0x8225F2A0;
		  /* 8225F2A0h */ case   36:  		/* mr R5, R28 */
		/* 8225F2A0h case   36:*/		regs.R5 = regs.R28;
		/* 8225F2A0h case   36:*/		return 0x8225F2A4;
		  /* 8225F2A4h */ case   37:  		/* mr R4, R24 */
		/* 8225F2A4h case   37:*/		regs.R4 = regs.R24;
		/* 8225F2A4h case   37:*/		return 0x8225F2A8;
		  /* 8225F2A8h */ case   38:  		/* li R7, 3181 */
		/* 8225F2A8h case   38:*/		cpu::op::li<0>(regs,&regs.R7,0xC6D);
		/* 8225F2A8h case   38:*/		return 0x8225F2AC;
		  /* 8225F2ACh */ case   39:  		/* li R3, 0 */
		/* 8225F2ACh case   39:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F2ACh case   39:*/		return 0x8225F2B0;
		  /* 8225F2B0h */ case   40:  		/* bl -1078952 */
		/* 8225F2B0h case   40:*/		regs.LR = 0x8225F2B4; return 0x82157C08;
		/* 8225F2B0h case   40:*/		return 0x8225F2B4;
		  /* 8225F2B4h */ case   41:  		/* b 3448 */
		/* 8225F2B4h case   41:*/		return 0x8226002C;
		/* 8225F2B4h case   41:*/		return 0x8225F2B8;
	}
	return 0x8225F2B8;
} // Block from 8225F210h-8225F2B8h (42 instructions)

//////////////////////////////////////////////////////
// Block at 8225F2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F2B8);
		  /* 8225F2B8h */ case    0:  		/* lwz R21, <#[R1 + 208]> */
		/* 8225F2B8h case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000D0) );
		/* 8225F2B8h case    0:*/		return 0x8225F2BC;
		  /* 8225F2BCh */ case    1:  		/* mr R3, R30 */
		/* 8225F2BCh case    1:*/		regs.R3 = regs.R30;
		/* 8225F2BCh case    1:*/		return 0x8225F2C0;
		  /* 8225F2C0h */ case    2:  		/* mr R4, R21 */
		/* 8225F2C0h case    2:*/		regs.R4 = regs.R21;
		/* 8225F2C0h case    2:*/		return 0x8225F2C4;
		  /* 8225F2C4h */ case    3:  		/* bl -20500 */
		/* 8225F2C4h case    3:*/		regs.LR = 0x8225F2C8; return 0x8225A2B0;
		/* 8225F2C4h case    3:*/		return 0x8225F2C8;
		  /* 8225F2C8h */ case    4:  		/* b -1148 */
		/* 8225F2C8h case    4:*/		return 0x8225EE4C;
		/* 8225F2C8h case    4:*/		return 0x8225F2CC;
	}
	return 0x8225F2CC;
} // Block from 8225F2B8h-8225F2CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225F2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F2CC);
		  /* 8225F2CCh */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225F2CCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F2CCh case    0:*/		return 0x8225F2D0;
		  /* 8225F2D0h */ case    1:  		/* li R4, 0 */
		/* 8225F2D0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F2D0h case    1:*/		return 0x8225F2D4;
		  /* 8225F2D4h */ case    2:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225F2D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225F2D4h case    2:*/		return 0x8225F2D8;
		  /* 8225F2D8h */ case    3:  		/* addi R5, R11, -1 */
		/* 8225F2D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225F2D8h case    3:*/		return 0x8225F2DC;
		  /* 8225F2DCh */ case    4:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225F2DCh case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225F2DCh case    4:*/		return 0x8225F2E0;
		  /* 8225F2E0h */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225F2E0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225F2E0h case    5:*/		return 0x8225F2E4;
		  /* 8225F2E4h */ case    6:  		/* bl -105172 */
		/* 8225F2E4h case    6:*/		regs.LR = 0x8225F2E8; return 0x82245810;
		/* 8225F2E4h case    6:*/		return 0x8225F2E8;
		  /* 8225F2E8h */ case    7:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225F2E8h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F2E8h case    7:*/		return 0x8225F2EC;
		  /* 8225F2ECh */ case    8:  		/* mr R28, R3 */
		/* 8225F2ECh case    8:*/		regs.R28 = regs.R3;
		/* 8225F2ECh case    8:*/		return 0x8225F2F0;
		  /* 8225F2F0h */ case    9:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225F2F0h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225F2F0h case    9:*/		return 0x8225F2F4;
		  /* 8225F2F4h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 8225F2F4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225F2F4h case   10:*/		return 0x8225F2F8;
		  /* 8225F2F8h */ case   11:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225F2F8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225F2F8h case   11:*/		return 0x8225F2FC;
		  /* 8225F2FCh */ case   12:  		/* mtspr CTR, R11 */
		/* 8225F2FCh case   12:*/		regs.CTR = regs.R11;
		/* 8225F2FCh case   12:*/		return 0x8225F300;
		  /* 8225F300h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 8225F300h case   13:*/		if ( 1 ) { regs.LR = 0x8225F304; return (uint32)regs.CTR; }
		/* 8225F300h case   13:*/		return 0x8225F304;
		  /* 8225F304h */ case   14:  		/* lis R11, -32222 */
		/* 8225F304h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F304h case   14:*/		return 0x8225F308;
		  /* 8225F308h */ case   15:  		/* mr R5, R3 */
		/* 8225F308h case   15:*/		regs.R5 = regs.R3;
		/* 8225F308h case   15:*/		return 0x8225F30C;
		  /* 8225F30Ch */ case   16:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F30Ch case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F30Ch case   16:*/		return 0x8225F310;
		  /* 8225F310h */ case   17:  		/* mr R4, R25 */
		/* 8225F310h case   17:*/		regs.R4 = regs.R25;
		/* 8225F310h case   17:*/		return 0x8225F314;
		  /* 8225F314h */ case   18:  		/* addi R6, R11, -12392 */
		/* 8225F314h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F314h case   18:*/		return 0x8225F318;
		  /* 8225F318h */ case   19:  		/* mr R7, R30 */
		/* 8225F318h case   19:*/		regs.R7 = regs.R30;
		/* 8225F318h case   19:*/		return 0x8225F31C;
		  /* 8225F31Ch */ case   20:  		/* bl -187468 */
		/* 8225F31Ch case   20:*/		regs.LR = 0x8225F320; return 0x822316D0;
		/* 8225F31Ch case   20:*/		return 0x8225F320;
		  /* 8225F320h */ case   21:  		/* cmpwi CR6, R3, 1 */
		/* 8225F320h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225F320h case   21:*/		return 0x8225F324;
		  /* 8225F324h */ case   22:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F324h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F324h case   22:*/		return 0x8225F328;
		  /* 8225F328h */ case   23:  		/* mr R3, R29 */
		/* 8225F328h case   23:*/		regs.R3 = regs.R29;
		/* 8225F328h case   23:*/		return 0x8225F32C;
		  /* 8225F32Ch */ case   24:  		/* bc 4, CR6_EQ, 996 */
		/* 8225F32Ch case   24:*/		if ( !regs.CR[6].eq ) { return 0x8225F710;  }
		/* 8225F32Ch case   24:*/		return 0x8225F330;
		  /* 8225F330h */ case   25:  		/* bl -37888 */
		/* 8225F330h case   25:*/		regs.LR = 0x8225F334; return 0x82255F30;
		/* 8225F330h case   25:*/		return 0x8225F334;
		  /* 8225F334h */ case   26:  		/* stw R25, <#[R3 + 176]> */
		/* 8225F334h case   26:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x000000B0) );
		/* 8225F334h case   26:*/		return 0x8225F338;
		  /* 8225F338h */ case   27:  		/* stw R23, <#[R3 + 184]> */
		/* 8225F338h case   27:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225F338h case   27:*/		return 0x8225F33C;
		  /* 8225F33Ch */ case   28:  		/* li R5, 4 */
		/* 8225F33Ch case   28:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F33Ch case   28:*/		return 0x8225F340;
		  /* 8225F340h */ case   29:  		/* li R4, 3 */
		/* 8225F340h case   29:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F340h case   29:*/		return 0x8225F344;
		  /* 8225F344h */ case   30:  		/* fmr FR1, FR29 */
		/* 8225F344h case   30:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 8225F344h case   30:*/		return 0x8225F348;
		  /* 8225F348h */ case   31:  		/* mr R30, R3 */
		/* 8225F348h case   31:*/		regs.R30 = regs.R3;
		/* 8225F348h case   31:*/		return 0x8225F34C;
		  /* 8225F34Ch */ case   32:  		/* bl -38676 */
		/* 8225F34Ch case   32:*/		regs.LR = 0x8225F350; return 0x82255C38;
		/* 8225F34Ch case   32:*/		return 0x8225F350;
		  /* 8225F350h */ case   33:  		/* sth R3, <#[R23 + 24]> */
		/* 8225F350h case   33:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8225F350h case   33:*/		return 0x8225F354;
		  /* 8225F354h */ case   34:  		/* li R5, 4 */
		/* 8225F354h case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F354h case   34:*/		return 0x8225F358;
		  /* 8225F358h */ case   35:  		/* fmr FR1, FR29 */
		/* 8225F358h case   35:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 8225F358h case   35:*/		return 0x8225F35C;
		  /* 8225F35Ch */ case   36:  		/* li R4, 3 */
		/* 8225F35Ch case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F35Ch case   36:*/		return 0x8225F360;
		  /* 8225F360h */ case   37:  		/* lwz R26, <#[R30 + 184]> */
		/* 8225F360h case   37:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R30 + 0x000000B8) );
		/* 8225F360h case   37:*/		return 0x8225F364;
		  /* 8225F364h */ case   38:  		/* bl -38700 */
		/* 8225F364h case   38:*/		regs.LR = 0x8225F368; return 0x82255C38;
		/* 8225F364h case   38:*/		return 0x8225F368;
		  /* 8225F368h */ case   39:  		/* lwz R27, <#[R1 + 136]> */
		/* 8225F368h case   39:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000088) );
		/* 8225F368h case   39:*/		return 0x8225F36C;
		  /* 8225F36Ch */ case   40:  		/* mr R11, R3 */
		/* 8225F36Ch case   40:*/		regs.R11 = regs.R3;
		/* 8225F36Ch case   40:*/		return 0x8225F370;
		  /* 8225F370h */ case   41:  		/* mr R3, R30 */
		/* 8225F370h case   41:*/		regs.R3 = regs.R30;
		/* 8225F370h case   41:*/		return 0x8225F374;
		  /* 8225F374h */ case   42:  		/* sth R11, <#[R26 + 24]> */
		/* 8225F374h case   42:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 8225F374h case   42:*/		return 0x8225F378;
		  /* 8225F378h */ case   43:  		/* mr R5, R28 */
		/* 8225F378h case   43:*/		regs.R5 = regs.R28;
		/* 8225F378h case   43:*/		return 0x8225F37C;
		  /* 8225F37Ch */ case   44:  		/* li R4, 0 */
		/* 8225F37Ch case   44:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F37Ch case   44:*/		return 0x8225F380;
		  /* 8225F380h */ case   45:  		/* lwz R11, <#[R27 - 1304]> */
		/* 8225F380h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAE8) );
		/* 8225F380h case   45:*/		return 0x8225F384;
		  /* 8225F384h */ case   46:  		/* stw R11, <#[R30 + 128]> */
		/* 8225F384h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225F384h case   46:*/		return 0x8225F388;
		  /* 8225F388h */ case   47:  		/* bl -36848 */
		/* 8225F388h case   47:*/		regs.LR = 0x8225F38C; return 0x82256398;
		/* 8225F388h case   47:*/		return 0x8225F38C;
		  /* 8225F38Ch */ case   48:  		/* mr R5, R19 */
		/* 8225F38Ch case   48:*/		regs.R5 = regs.R19;
		/* 8225F38Ch case   48:*/		return 0x8225F390;
		  /* 8225F390h */ case   49:  		/* li R4, 1 */
		/* 8225F390h case   49:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F390h case   49:*/		return 0x8225F394;
		  /* 8225F394h */ case   50:  		/* mr R3, R30 */
		/* 8225F394h case   50:*/		regs.R3 = regs.R30;
		/* 8225F394h case   50:*/		return 0x8225F398;
		  /* 8225F398h */ case   51:  		/* bl -36864 */
		/* 8225F398h case   51:*/		regs.LR = 0x8225F39C; return 0x82256398;
		/* 8225F398h case   51:*/		return 0x8225F39C;
		  /* 8225F39Ch */ case   52:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225F39Ch case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225F39Ch case   52:*/		return 0x8225F3A0;
		  /* 8225F3A0h */ case   53:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225F3A0h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225F3A0h case   53:*/		return 0x8225F3A4;
		  /* 8225F3A4h */ case   54:  		/* cmplwi CR6, R11, 1 */
		/* 8225F3A4h case   54:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225F3A4h case   54:*/		return 0x8225F3A8;
		  /* 8225F3A8h */ case   55:  		/* bc 12, CR6_LT, 32 */
		/* 8225F3A8h case   55:*/		if ( regs.CR[6].lt ) { return 0x8225F3C8;  }
		/* 8225F3A8h case   55:*/		return 0x8225F3AC;
		  /* 8225F3ACh */ case   56:  		/* bc 12, CR6_EQ, 20 */
		/* 8225F3ACh case   56:*/		if ( regs.CR[6].eq ) { return 0x8225F3C0;  }
		/* 8225F3ACh case   56:*/		return 0x8225F3B0;
		  /* 8225F3B0h */ case   57:  		/* cmplwi CR6, R11, 3 */
		/* 8225F3B0h case   57:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225F3B0h case   57:*/		return 0x8225F3B4;
		  /* 8225F3B4h */ case   58:  		/* bc 4, CR6_LT, 20 */
		/* 8225F3B4h case   58:*/		if ( !regs.CR[6].lt ) { return 0x8225F3C8;  }
		/* 8225F3B4h case   58:*/		return 0x8225F3B8;
		  /* 8225F3B8h */ case   59:  		/* li R11, 1 */
		/* 8225F3B8h case   59:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225F3B8h case   59:*/		return 0x8225F3BC;
		  /* 8225F3BCh */ case   60:  		/* b 16 */
		/* 8225F3BCh case   60:*/		return 0x8225F3CC;
		/* 8225F3BCh case   60:*/		return 0x8225F3C0;
	}
	return 0x8225F3C0;
} // Block from 8225F2CCh-8225F3C0h (61 instructions)

//////////////////////////////////////////////////////
// Block at 8225F3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F3C0);
		  /* 8225F3C0h */ case    0:  		/* li R11, 0 */
		/* 8225F3C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225F3C0h case    0:*/		return 0x8225F3C4;
		  /* 8225F3C4h */ case    1:  		/* b 8 */
		/* 8225F3C4h case    1:*/		return 0x8225F3CC;
		/* 8225F3C4h case    1:*/		return 0x8225F3C8;
	}
	return 0x8225F3C8;
} // Block from 8225F3C0h-8225F3C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225F3C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F3C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F3C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F3C8);
		  /* 8225F3C8h */ case    0:  		/* li R11, 2 */
		/* 8225F3C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225F3C8h case    0:*/		return 0x8225F3CC;
	}
	return 0x8225F3CC;
} // Block from 8225F3C8h-8225F3CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225F3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F3CC);
		  /* 8225F3CCh */ case    0:  		/* lwz R21, <#[R1 + 208]> */
		/* 8225F3CCh case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000D0) );
		/* 8225F3CCh case    0:*/		return 0x8225F3D0;
		  /* 8225F3D0h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225F3D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225F3D0h case    1:*/		return 0x8225F3D4;
		  /* 8225F3D4h */ case    2:  		/* stw R11, <#[R30 + 180]> */
		/* 8225F3D4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225F3D4h case    2:*/		return 0x8225F3D8;
		  /* 8225F3D8h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8225F3D8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225F3E8;  }
		/* 8225F3D8h case    3:*/		return 0x8225F3DC;
		  /* 8225F3DCh */ case    4:  		/* mr R3, R30 */
		/* 8225F3DCh case    4:*/		regs.R3 = regs.R30;
		/* 8225F3DCh case    4:*/		return 0x8225F3E0;
		  /* 8225F3E0h */ case    5:  		/* mr R4, R21 */
		/* 8225F3E0h case    5:*/		regs.R4 = regs.R21;
		/* 8225F3E0h case    5:*/		return 0x8225F3E4;
		  /* 8225F3E4h */ case    6:  		/* bl -20788 */
		/* 8225F3E4h case    6:*/		regs.LR = 0x8225F3E8; return 0x8225A2B0;
		/* 8225F3E4h case    6:*/		return 0x8225F3E8;
	}
	return 0x8225F3E8;
} // Block from 8225F3CCh-8225F3E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225F3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F3E8);
		  /* 8225F3E8h */ case    0:  		/* mr R4, R30 */
		/* 8225F3E8h case    0:*/		regs.R4 = regs.R30;
		/* 8225F3E8h case    0:*/		return 0x8225F3EC;
		  /* 8225F3ECh */ case    1:  		/* mr R3, R31 */
		/* 8225F3ECh case    1:*/		regs.R3 = regs.R31;
		/* 8225F3ECh case    1:*/		return 0x8225F3F0;
		  /* 8225F3F0h */ case    2:  		/* bl -167496 */
		/* 8225F3F0h case    2:*/		regs.LR = 0x8225F3F4; return 0x822365A8;
		/* 8225F3F0h case    2:*/		return 0x8225F3F4;
		  /* 8225F3F4h */ case    3:  		/* mr R4, R30 */
		/* 8225F3F4h case    3:*/		regs.R4 = regs.R30;
		/* 8225F3F4h case    3:*/		return 0x8225F3F8;
		  /* 8225F3F8h */ case    4:  		/* mr R3, R14 */
		/* 8225F3F8h case    4:*/		regs.R3 = regs.R14;
		/* 8225F3F8h case    4:*/		return 0x8225F3FC;
		  /* 8225F3FCh */ case    5:  		/* bl -25804 */
		/* 8225F3FCh case    5:*/		regs.LR = 0x8225F400; return 0x82258F30;
		/* 8225F3FCh case    5:*/		return 0x8225F400;
		  /* 8225F400h */ case    6:  		/* mr R3, R30 */
		/* 8225F400h case    6:*/		regs.R3 = regs.R30;
		/* 8225F400h case    6:*/		return 0x8225F404;
		  /* 8225F404h */ case    7:  		/* bl -37956 */
		/* 8225F404h case    7:*/		regs.LR = 0x8225F408; return 0x82255FC0;
		/* 8225F404h case    7:*/		return 0x8225F408;
		  /* 8225F408h */ case    8:  		/* lwz R22, <#[R1 + 128]> */
		/* 8225F408h case    8:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000080) );
		/* 8225F408h case    8:*/		return 0x8225F40C;
		  /* 8225F40Ch */ case    9:  		/* lwz R26, <#[R1 + 268]> */
		/* 8225F40Ch case    9:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x0000010C) );
		/* 8225F40Ch case    9:*/		return 0x8225F410;
		  /* 8225F410h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F410h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F410h case   10:*/		return 0x8225F414;
		  /* 8225F414h */ case   11:  		/* lwz R24, <#[R1 + 132]> */
		/* 8225F414h case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 8225F414h case   11:*/		return 0x8225F418;
		  /* 8225F418h */ case   12:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F418h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8225F434;  }
		/* 8225F418h case   12:*/		return 0x8225F41C;
		  /* 8225F41Ch */ case   13:  		/* li R7, 2812 */
		/* 8225F41Ch case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xAFC);
		/* 8225F41Ch case   13:*/		return 0x8225F420;
		  /* 8225F420h */ case   14:  		/* li R3, 0 */
		/* 8225F420h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F420h case   14:*/		return 0x8225F424;
		  /* 8225F424h */ case   15:  		/* mr R6, R22 */
		/* 8225F424h case   15:*/		regs.R6 = regs.R22;
		/* 8225F424h case   15:*/		return 0x8225F428;
		  /* 8225F428h */ case   16:  		/* mr R5, R26 */
		/* 8225F428h case   16:*/		regs.R5 = regs.R26;
		/* 8225F428h case   16:*/		return 0x8225F42C;
		  /* 8225F42Ch */ case   17:  		/* mr R4, R24 */
		/* 8225F42Ch case   17:*/		regs.R4 = regs.R24;
		/* 8225F42Ch case   17:*/		return 0x8225F430;
		  /* 8225F430h */ case   18:  		/* bl -1079336 */
		/* 8225F430h case   18:*/		regs.LR = 0x8225F434; return 0x82157C08;
		/* 8225F430h case   18:*/		return 0x8225F434;
	}
	return 0x8225F434;
} // Block from 8225F3E8h-8225F434h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8225F434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F434);
		  /* 8225F434h */ case    0:  		/* mr R3, R29 */
		/* 8225F434h case    0:*/		regs.R3 = regs.R29;
		/* 8225F434h case    0:*/		return 0x8225F438;
		  /* 8225F438h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F438h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F438h case    1:*/		return 0x8225F43C;
		  /* 8225F43Ch */ case    2:  		/* bl -38156 */
		/* 8225F43Ch case    2:*/		regs.LR = 0x8225F440; return 0x82255F30;
		/* 8225F43Ch case    2:*/		return 0x8225F440;
		  /* 8225F440h */ case    3:  		/* stw R25, <#[R3 + 176]> */
		/* 8225F440h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x000000B0) );
		/* 8225F440h case    3:*/		return 0x8225F444;
		  /* 8225F444h */ case    4:  		/* stw R23, <#[R3 + 184]> */
		/* 8225F444h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225F444h case    4:*/		return 0x8225F448;
		  /* 8225F448h */ case    5:  		/* li R5, 4 */
		/* 8225F448h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F448h case    5:*/		return 0x8225F44C;
		  /* 8225F44Ch */ case    6:  		/* li R4, 3 */
		/* 8225F44Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F44Ch case    6:*/		return 0x8225F450;
		  /* 8225F450h */ case    7:  		/* fmr FR1, FR28 */
		/* 8225F450h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 8225F450h case    7:*/		return 0x8225F454;
		  /* 8225F454h */ case    8:  		/* mr R30, R3 */
		/* 8225F454h case    8:*/		regs.R30 = regs.R3;
		/* 8225F454h case    8:*/		return 0x8225F458;
		  /* 8225F458h */ case    9:  		/* bl -38944 */
		/* 8225F458h case    9:*/		regs.LR = 0x8225F45C; return 0x82255C38;
		/* 8225F458h case    9:*/		return 0x8225F45C;
		  /* 8225F45Ch */ case   10:  		/* sth R3, <#[R23 + 24]> */
		/* 8225F45Ch case   10:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8225F45Ch case   10:*/		return 0x8225F460;
		  /* 8225F460h */ case   11:  		/* li R5, 4 */
		/* 8225F460h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F460h case   11:*/		return 0x8225F464;
		  /* 8225F464h */ case   12:  		/* fmr FR1, FR29 */
		/* 8225F464h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 8225F464h case   12:*/		return 0x8225F468;
		  /* 8225F468h */ case   13:  		/* li R4, 3 */
		/* 8225F468h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F468h case   13:*/		return 0x8225F46C;
		  /* 8225F46Ch */ case   14:  		/* lwz R20, <#[R30 + 184]> */
		/* 8225F46Ch case   14:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R30 + 0x000000B8) );
		/* 8225F46Ch case   14:*/		return 0x8225F470;
		  /* 8225F470h */ case   15:  		/* bl -38968 */
		/* 8225F470h case   15:*/		regs.LR = 0x8225F474; return 0x82255C38;
		/* 8225F470h case   15:*/		return 0x8225F474;
		  /* 8225F474h */ case   16:  		/* lwz R11, <#[R27 - 1300]> */
		/* 8225F474h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAEC) );
		/* 8225F474h case   16:*/		return 0x8225F478;
		  /* 8225F478h */ case   17:  		/* mr R10, R3 */
		/* 8225F478h case   17:*/		regs.R10 = regs.R3;
		/* 8225F478h case   17:*/		return 0x8225F47C;
		  /* 8225F47Ch */ case   18:  		/* mr R3, R30 */
		/* 8225F47Ch case   18:*/		regs.R3 = regs.R30;
		/* 8225F47Ch case   18:*/		return 0x8225F480;
		  /* 8225F480h */ case   19:  		/* sth R10, <#[R20 + 24]> */
		/* 8225F480h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R20 + 0x00000018) );
		/* 8225F480h case   19:*/		return 0x8225F484;
		  /* 8225F484h */ case   20:  		/* mr R5, R28 */
		/* 8225F484h case   20:*/		regs.R5 = regs.R28;
		/* 8225F484h case   20:*/		return 0x8225F488;
		  /* 8225F488h */ case   21:  		/* li R4, 0 */
		/* 8225F488h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F488h case   21:*/		return 0x8225F48C;
		  /* 8225F48Ch */ case   22:  		/* stw R11, <#[R30 + 128]> */
		/* 8225F48Ch case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225F48Ch case   22:*/		return 0x8225F490;
		  /* 8225F490h */ case   23:  		/* bl -37112 */
		/* 8225F490h case   23:*/		regs.LR = 0x8225F494; return 0x82256398;
		/* 8225F490h case   23:*/		return 0x8225F494;
		  /* 8225F494h */ case   24:  		/* mr R5, R19 */
		/* 8225F494h case   24:*/		regs.R5 = regs.R19;
		/* 8225F494h case   24:*/		return 0x8225F498;
		  /* 8225F498h */ case   25:  		/* li R4, 1 */
		/* 8225F498h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F498h case   25:*/		return 0x8225F49C;
		  /* 8225F49Ch */ case   26:  		/* mr R3, R30 */
		/* 8225F49Ch case   26:*/		regs.R3 = regs.R30;
		/* 8225F49Ch case   26:*/		return 0x8225F4A0;
		  /* 8225F4A0h */ case   27:  		/* bl -37128 */
		/* 8225F4A0h case   27:*/		regs.LR = 0x8225F4A4; return 0x82256398;
		/* 8225F4A0h case   27:*/		return 0x8225F4A4;
		  /* 8225F4A4h */ case   28:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225F4A4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225F4A4h case   28:*/		return 0x8225F4A8;
		  /* 8225F4A8h */ case   29:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225F4A8h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225F4A8h case   29:*/		return 0x8225F4AC;
		  /* 8225F4ACh */ case   30:  		/* cmplwi CR6, R11, 1 */
		/* 8225F4ACh case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225F4ACh case   30:*/		return 0x8225F4B0;
		  /* 8225F4B0h */ case   31:  		/* bc 12, CR6_LT, 32 */
		/* 8225F4B0h case   31:*/		if ( regs.CR[6].lt ) { return 0x8225F4D0;  }
		/* 8225F4B0h case   31:*/		return 0x8225F4B4;
		  /* 8225F4B4h */ case   32:  		/* bc 12, CR6_EQ, 20 */
		/* 8225F4B4h case   32:*/		if ( regs.CR[6].eq ) { return 0x8225F4C8;  }
		/* 8225F4B4h case   32:*/		return 0x8225F4B8;
		  /* 8225F4B8h */ case   33:  		/* cmplwi CR6, R11, 3 */
		/* 8225F4B8h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225F4B8h case   33:*/		return 0x8225F4BC;
		  /* 8225F4BCh */ case   34:  		/* bc 4, CR6_LT, 20 */
		/* 8225F4BCh case   34:*/		if ( !regs.CR[6].lt ) { return 0x8225F4D0;  }
		/* 8225F4BCh case   34:*/		return 0x8225F4C0;
		  /* 8225F4C0h */ case   35:  		/* li R11, 1 */
		/* 8225F4C0h case   35:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225F4C0h case   35:*/		return 0x8225F4C4;
		  /* 8225F4C4h */ case   36:  		/* b 16 */
		/* 8225F4C4h case   36:*/		return 0x8225F4D4;
		/* 8225F4C4h case   36:*/		return 0x8225F4C8;
	}
	return 0x8225F4C8;
} // Block from 8225F434h-8225F4C8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8225F4C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F4C8);
		  /* 8225F4C8h */ case    0:  		/* li R11, 0 */
		/* 8225F4C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225F4C8h case    0:*/		return 0x8225F4CC;
		  /* 8225F4CCh */ case    1:  		/* b 8 */
		/* 8225F4CCh case    1:*/		return 0x8225F4D4;
		/* 8225F4CCh case    1:*/		return 0x8225F4D0;
	}
	return 0x8225F4D0;
} // Block from 8225F4C8h-8225F4D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225F4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F4D0);
		  /* 8225F4D0h */ case    0:  		/* li R11, 2 */
		/* 8225F4D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225F4D0h case    0:*/		return 0x8225F4D4;
	}
	return 0x8225F4D4;
} // Block from 8225F4D0h-8225F4D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225F4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F4D4);
		  /* 8225F4D4h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225F4D4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225F4D4h case    0:*/		return 0x8225F4D8;
		  /* 8225F4D8h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225F4D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225F4D8h case    1:*/		return 0x8225F4DC;
		  /* 8225F4DCh */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8225F4DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8225F4EC;  }
		/* 8225F4DCh case    2:*/		return 0x8225F4E0;
		  /* 8225F4E0h */ case    3:  		/* mr R4, R21 */
		/* 8225F4E0h case    3:*/		regs.R4 = regs.R21;
		/* 8225F4E0h case    3:*/		return 0x8225F4E4;
		  /* 8225F4E4h */ case    4:  		/* mr R3, R30 */
		/* 8225F4E4h case    4:*/		regs.R3 = regs.R30;
		/* 8225F4E4h case    4:*/		return 0x8225F4E8;
		  /* 8225F4E8h */ case    5:  		/* bl -21048 */
		/* 8225F4E8h case    5:*/		regs.LR = 0x8225F4EC; return 0x8225A2B0;
		/* 8225F4E8h case    5:*/		return 0x8225F4EC;
	}
	return 0x8225F4EC;
} // Block from 8225F4D4h-8225F4ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225F4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F4EC);
		  /* 8225F4ECh */ case    0:  		/* mr R4, R30 */
		/* 8225F4ECh case    0:*/		regs.R4 = regs.R30;
		/* 8225F4ECh case    0:*/		return 0x8225F4F0;
		  /* 8225F4F0h */ case    1:  		/* mr R3, R31 */
		/* 8225F4F0h case    1:*/		regs.R3 = regs.R31;
		/* 8225F4F0h case    1:*/		return 0x8225F4F4;
		  /* 8225F4F4h */ case    2:  		/* bl -167756 */
		/* 8225F4F4h case    2:*/		regs.LR = 0x8225F4F8; return 0x822365A8;
		/* 8225F4F4h case    2:*/		return 0x8225F4F8;
		  /* 8225F4F8h */ case    3:  		/* mr R4, R30 */
		/* 8225F4F8h case    3:*/		regs.R4 = regs.R30;
		/* 8225F4F8h case    3:*/		return 0x8225F4FC;
		  /* 8225F4FCh */ case    4:  		/* mr R3, R14 */
		/* 8225F4FCh case    4:*/		regs.R3 = regs.R14;
		/* 8225F4FCh case    4:*/		return 0x8225F500;
		  /* 8225F500h */ case    5:  		/* bl -26064 */
		/* 8225F500h case    5:*/		regs.LR = 0x8225F504; return 0x82258F30;
		/* 8225F500h case    5:*/		return 0x8225F504;
		  /* 8225F504h */ case    6:  		/* mr R3, R30 */
		/* 8225F504h case    6:*/		regs.R3 = regs.R30;
		/* 8225F504h case    6:*/		return 0x8225F508;
		  /* 8225F508h */ case    7:  		/* bl -38216 */
		/* 8225F508h case    7:*/		regs.LR = 0x8225F50C; return 0x82255FC0;
		/* 8225F508h case    7:*/		return 0x8225F50C;
		  /* 8225F50Ch */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F50Ch case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F50Ch case    8:*/		return 0x8225F510;
		  /* 8225F510h */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F510h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8225F52C;  }
		/* 8225F510h case    9:*/		return 0x8225F514;
		  /* 8225F514h */ case   10:  		/* mr R6, R22 */
		/* 8225F514h case   10:*/		regs.R6 = regs.R22;
		/* 8225F514h case   10:*/		return 0x8225F518;
		  /* 8225F518h */ case   11:  		/* mr R5, R26 */
		/* 8225F518h case   11:*/		regs.R5 = regs.R26;
		/* 8225F518h case   11:*/		return 0x8225F51C;
		  /* 8225F51Ch */ case   12:  		/* mr R4, R24 */
		/* 8225F51Ch case   12:*/		regs.R4 = regs.R24;
		/* 8225F51Ch case   12:*/		return 0x8225F520;
		  /* 8225F520h */ case   13:  		/* li R7, 2829 */
		/* 8225F520h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xB0D);
		/* 8225F520h case   13:*/		return 0x8225F524;
		  /* 8225F524h */ case   14:  		/* li R3, 0 */
		/* 8225F524h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F524h case   14:*/		return 0x8225F528;
		  /* 8225F528h */ case   15:  		/* bl -1079584 */
		/* 8225F528h case   15:*/		regs.LR = 0x8225F52C; return 0x82157C08;
		/* 8225F528h case   15:*/		return 0x8225F52C;
	}
	return 0x8225F52C;
} // Block from 8225F4ECh-8225F52Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225F52Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F52C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F52C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F52C);
		  /* 8225F52Ch */ case    0:  		/* mr R3, R29 */
		/* 8225F52Ch case    0:*/		regs.R3 = regs.R29;
		/* 8225F52Ch case    0:*/		return 0x8225F530;
		  /* 8225F530h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F530h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F530h case    1:*/		return 0x8225F534;
		  /* 8225F534h */ case    2:  		/* bl -38404 */
		/* 8225F534h case    2:*/		regs.LR = 0x8225F538; return 0x82255F30;
		/* 8225F534h case    2:*/		return 0x8225F538;
		  /* 8225F538h */ case    3:  		/* stw R25, <#[R3 + 176]> */
		/* 8225F538h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x000000B0) );
		/* 8225F538h case    3:*/		return 0x8225F53C;
		  /* 8225F53Ch */ case    4:  		/* stw R23, <#[R3 + 184]> */
		/* 8225F53Ch case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225F53Ch case    4:*/		return 0x8225F540;
		  /* 8225F540h */ case    5:  		/* li R5, 4 */
		/* 8225F540h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F540h case    5:*/		return 0x8225F544;
		  /* 8225F544h */ case    6:  		/* li R4, 3 */
		/* 8225F544h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F544h case    6:*/		return 0x8225F548;
		  /* 8225F548h */ case    7:  		/* fmr FR1, FR29 */
		/* 8225F548h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 8225F548h case    7:*/		return 0x8225F54C;
		  /* 8225F54Ch */ case    8:  		/* mr R30, R3 */
		/* 8225F54Ch case    8:*/		regs.R30 = regs.R3;
		/* 8225F54Ch case    8:*/		return 0x8225F550;
		  /* 8225F550h */ case    9:  		/* bl -39192 */
		/* 8225F550h case    9:*/		regs.LR = 0x8225F554; return 0x82255C38;
		/* 8225F550h case    9:*/		return 0x8225F554;
		  /* 8225F554h */ case   10:  		/* sth R3, <#[R23 + 24]> */
		/* 8225F554h case   10:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8225F554h case   10:*/		return 0x8225F558;
		  /* 8225F558h */ case   11:  		/* li R5, 4 */
		/* 8225F558h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F558h case   11:*/		return 0x8225F55C;
		  /* 8225F55Ch */ case   12:  		/* lwz R20, <#[R30 + 184]> */
		/* 8225F55Ch case   12:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R30 + 0x000000B8) );
		/* 8225F55Ch case   12:*/		return 0x8225F560;
		  /* 8225F560h */ case   13:  		/* li R4, 3 */
		/* 8225F560h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F560h case   13:*/		return 0x8225F564;
		  /* 8225F564h */ case   14:  		/* fmr FR1, FR28 */
		/* 8225F564h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 8225F564h case   14:*/		return 0x8225F568;
		  /* 8225F568h */ case   15:  		/* bl -39216 */
		/* 8225F568h case   15:*/		regs.LR = 0x8225F56C; return 0x82255C38;
		/* 8225F568h case   15:*/		return 0x8225F56C;
		  /* 8225F56Ch */ case   16:  		/* lwz R11, <#[R27 - 1296]> */
		/* 8225F56Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF0) );
		/* 8225F56Ch case   16:*/		return 0x8225F570;
		  /* 8225F570h */ case   17:  		/* mr R10, R3 */
		/* 8225F570h case   17:*/		regs.R10 = regs.R3;
		/* 8225F570h case   17:*/		return 0x8225F574;
		  /* 8225F574h */ case   18:  		/* mr R3, R30 */
		/* 8225F574h case   18:*/		regs.R3 = regs.R30;
		/* 8225F574h case   18:*/		return 0x8225F578;
		  /* 8225F578h */ case   19:  		/* sth R10, <#[R20 + 24]> */
		/* 8225F578h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R20 + 0x00000018) );
		/* 8225F578h case   19:*/		return 0x8225F57C;
		  /* 8225F57Ch */ case   20:  		/* mr R5, R28 */
		/* 8225F57Ch case   20:*/		regs.R5 = regs.R28;
		/* 8225F57Ch case   20:*/		return 0x8225F580;
		  /* 8225F580h */ case   21:  		/* li R4, 0 */
		/* 8225F580h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F580h case   21:*/		return 0x8225F584;
		  /* 8225F584h */ case   22:  		/* stw R11, <#[R30 + 128]> */
		/* 8225F584h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225F584h case   22:*/		return 0x8225F588;
		  /* 8225F588h */ case   23:  		/* bl -37360 */
		/* 8225F588h case   23:*/		regs.LR = 0x8225F58C; return 0x82256398;
		/* 8225F588h case   23:*/		return 0x8225F58C;
		  /* 8225F58Ch */ case   24:  		/* mr R5, R19 */
		/* 8225F58Ch case   24:*/		regs.R5 = regs.R19;
		/* 8225F58Ch case   24:*/		return 0x8225F590;
		  /* 8225F590h */ case   25:  		/* li R4, 1 */
		/* 8225F590h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F590h case   25:*/		return 0x8225F594;
		  /* 8225F594h */ case   26:  		/* mr R3, R30 */
		/* 8225F594h case   26:*/		regs.R3 = regs.R30;
		/* 8225F594h case   26:*/		return 0x8225F598;
		  /* 8225F598h */ case   27:  		/* bl -37376 */
		/* 8225F598h case   27:*/		regs.LR = 0x8225F59C; return 0x82256398;
		/* 8225F598h case   27:*/		return 0x8225F59C;
		  /* 8225F59Ch */ case   28:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225F59Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225F59Ch case   28:*/		return 0x8225F5A0;
		  /* 8225F5A0h */ case   29:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225F5A0h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225F5A0h case   29:*/		return 0x8225F5A4;
		  /* 8225F5A4h */ case   30:  		/* cmplwi CR6, R11, 1 */
		/* 8225F5A4h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225F5A4h case   30:*/		return 0x8225F5A8;
		  /* 8225F5A8h */ case   31:  		/* bc 12, CR6_LT, 32 */
		/* 8225F5A8h case   31:*/		if ( regs.CR[6].lt ) { return 0x8225F5C8;  }
		/* 8225F5A8h case   31:*/		return 0x8225F5AC;
		  /* 8225F5ACh */ case   32:  		/* bc 12, CR6_EQ, 20 */
		/* 8225F5ACh case   32:*/		if ( regs.CR[6].eq ) { return 0x8225F5C0;  }
		/* 8225F5ACh case   32:*/		return 0x8225F5B0;
		  /* 8225F5B0h */ case   33:  		/* cmplwi CR6, R11, 3 */
		/* 8225F5B0h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225F5B0h case   33:*/		return 0x8225F5B4;
		  /* 8225F5B4h */ case   34:  		/* bc 4, CR6_LT, 20 */
		/* 8225F5B4h case   34:*/		if ( !regs.CR[6].lt ) { return 0x8225F5C8;  }
		/* 8225F5B4h case   34:*/		return 0x8225F5B8;
		  /* 8225F5B8h */ case   35:  		/* li R11, 1 */
		/* 8225F5B8h case   35:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225F5B8h case   35:*/		return 0x8225F5BC;
		  /* 8225F5BCh */ case   36:  		/* b 16 */
		/* 8225F5BCh case   36:*/		return 0x8225F5CC;
		/* 8225F5BCh case   36:*/		return 0x8225F5C0;
	}
	return 0x8225F5C0;
} // Block from 8225F52Ch-8225F5C0h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8225F5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F5C0);
		  /* 8225F5C0h */ case    0:  		/* li R11, 0 */
		/* 8225F5C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225F5C0h case    0:*/		return 0x8225F5C4;
		  /* 8225F5C4h */ case    1:  		/* b 8 */
		/* 8225F5C4h case    1:*/		return 0x8225F5CC;
		/* 8225F5C4h case    1:*/		return 0x8225F5C8;
	}
	return 0x8225F5C8;
} // Block from 8225F5C0h-8225F5C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225F5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F5C8);
		  /* 8225F5C8h */ case    0:  		/* li R11, 2 */
		/* 8225F5C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225F5C8h case    0:*/		return 0x8225F5CC;
	}
	return 0x8225F5CC;
} // Block from 8225F5C8h-8225F5CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225F5CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F5CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F5CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F5CC);
		  /* 8225F5CCh */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225F5CCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225F5CCh case    0:*/		return 0x8225F5D0;
		  /* 8225F5D0h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225F5D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225F5D0h case    1:*/		return 0x8225F5D4;
		  /* 8225F5D4h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8225F5D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8225F5E4;  }
		/* 8225F5D4h case    2:*/		return 0x8225F5D8;
		  /* 8225F5D8h */ case    3:  		/* mr R4, R21 */
		/* 8225F5D8h case    3:*/		regs.R4 = regs.R21;
		/* 8225F5D8h case    3:*/		return 0x8225F5DC;
		  /* 8225F5DCh */ case    4:  		/* mr R3, R30 */
		/* 8225F5DCh case    4:*/		regs.R3 = regs.R30;
		/* 8225F5DCh case    4:*/		return 0x8225F5E0;
		  /* 8225F5E0h */ case    5:  		/* bl -21296 */
		/* 8225F5E0h case    5:*/		regs.LR = 0x8225F5E4; return 0x8225A2B0;
		/* 8225F5E0h case    5:*/		return 0x8225F5E4;
	}
	return 0x8225F5E4;
} // Block from 8225F5CCh-8225F5E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225F5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F5E4);
		  /* 8225F5E4h */ case    0:  		/* mr R4, R30 */
		/* 8225F5E4h case    0:*/		regs.R4 = regs.R30;
		/* 8225F5E4h case    0:*/		return 0x8225F5E8;
		  /* 8225F5E8h */ case    1:  		/* mr R3, R31 */
		/* 8225F5E8h case    1:*/		regs.R3 = regs.R31;
		/* 8225F5E8h case    1:*/		return 0x8225F5EC;
		  /* 8225F5ECh */ case    2:  		/* bl -168004 */
		/* 8225F5ECh case    2:*/		regs.LR = 0x8225F5F0; return 0x822365A8;
		/* 8225F5ECh case    2:*/		return 0x8225F5F0;
		  /* 8225F5F0h */ case    3:  		/* mr R4, R30 */
		/* 8225F5F0h case    3:*/		regs.R4 = regs.R30;
		/* 8225F5F0h case    3:*/		return 0x8225F5F4;
		  /* 8225F5F4h */ case    4:  		/* mr R3, R14 */
		/* 8225F5F4h case    4:*/		regs.R3 = regs.R14;
		/* 8225F5F4h case    4:*/		return 0x8225F5F8;
		  /* 8225F5F8h */ case    5:  		/* bl -26312 */
		/* 8225F5F8h case    5:*/		regs.LR = 0x8225F5FC; return 0x82258F30;
		/* 8225F5F8h case    5:*/		return 0x8225F5FC;
		  /* 8225F5FCh */ case    6:  		/* mr R3, R30 */
		/* 8225F5FCh case    6:*/		regs.R3 = regs.R30;
		/* 8225F5FCh case    6:*/		return 0x8225F600;
		  /* 8225F600h */ case    7:  		/* bl -38464 */
		/* 8225F600h case    7:*/		regs.LR = 0x8225F604; return 0x82255FC0;
		/* 8225F600h case    7:*/		return 0x8225F604;
		  /* 8225F604h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F604h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F604h case    8:*/		return 0x8225F608;
		  /* 8225F608h */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F608h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8225F624;  }
		/* 8225F608h case    9:*/		return 0x8225F60C;
		  /* 8225F60Ch */ case   10:  		/* mr R6, R22 */
		/* 8225F60Ch case   10:*/		regs.R6 = regs.R22;
		/* 8225F60Ch case   10:*/		return 0x8225F610;
		  /* 8225F610h */ case   11:  		/* mr R5, R26 */
		/* 8225F610h case   11:*/		regs.R5 = regs.R26;
		/* 8225F610h case   11:*/		return 0x8225F614;
		  /* 8225F614h */ case   12:  		/* mr R4, R24 */
		/* 8225F614h case   12:*/		regs.R4 = regs.R24;
		/* 8225F614h case   12:*/		return 0x8225F618;
		  /* 8225F618h */ case   13:  		/* li R7, 2846 */
		/* 8225F618h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xB1E);
		/* 8225F618h case   13:*/		return 0x8225F61C;
		  /* 8225F61Ch */ case   14:  		/* li R3, 0 */
		/* 8225F61Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F61Ch case   14:*/		return 0x8225F620;
		  /* 8225F620h */ case   15:  		/* bl -1079832 */
		/* 8225F620h case   15:*/		regs.LR = 0x8225F624; return 0x82157C08;
		/* 8225F620h case   15:*/		return 0x8225F624;
	}
	return 0x8225F624;
} // Block from 8225F5E4h-8225F624h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8225F624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F624);
		  /* 8225F624h */ case    0:  		/* mr R3, R29 */
		/* 8225F624h case    0:*/		regs.R3 = regs.R29;
		/* 8225F624h case    0:*/		return 0x8225F628;
		  /* 8225F628h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F628h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F628h case    1:*/		return 0x8225F62C;
		  /* 8225F62Ch */ case    2:  		/* bl -38652 */
		/* 8225F62Ch case    2:*/		regs.LR = 0x8225F630; return 0x82255F30;
		/* 8225F62Ch case    2:*/		return 0x8225F630;
		  /* 8225F630h */ case    3:  		/* stw R25, <#[R3 + 176]> */
		/* 8225F630h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x000000B0) );
		/* 8225F630h case    3:*/		return 0x8225F634;
		  /* 8225F634h */ case    4:  		/* stw R23, <#[R3 + 184]> */
		/* 8225F634h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225F634h case    4:*/		return 0x8225F638;
		  /* 8225F638h */ case    5:  		/* li R5, 4 */
		/* 8225F638h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F638h case    5:*/		return 0x8225F63C;
		  /* 8225F63Ch */ case    6:  		/* li R4, 3 */
		/* 8225F63Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F63Ch case    6:*/		return 0x8225F640;
		  /* 8225F640h */ case    7:  		/* fmr FR1, FR28 */
		/* 8225F640h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 8225F640h case    7:*/		return 0x8225F644;
		  /* 8225F644h */ case    8:  		/* mr R30, R3 */
		/* 8225F644h case    8:*/		regs.R30 = regs.R3;
		/* 8225F644h case    8:*/		return 0x8225F648;
		  /* 8225F648h */ case    9:  		/* bl -39440 */
		/* 8225F648h case    9:*/		regs.LR = 0x8225F64C; return 0x82255C38;
		/* 8225F648h case    9:*/		return 0x8225F64C;
		  /* 8225F64Ch */ case   10:  		/* sth R3, <#[R23 + 24]> */
		/* 8225F64Ch case   10:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R23 + 0x00000018) );
		/* 8225F64Ch case   10:*/		return 0x8225F650;
		  /* 8225F650h */ case   11:  		/* li R5, 4 */
		/* 8225F650h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8225F650h case   11:*/		return 0x8225F654;
		  /* 8225F654h */ case   12:  		/* fmr FR1, FR28 */
		/* 8225F654h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 8225F654h case   12:*/		return 0x8225F658;
		  /* 8225F658h */ case   13:  		/* li R4, 3 */
		/* 8225F658h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225F658h case   13:*/		return 0x8225F65C;
		  /* 8225F65Ch */ case   14:  		/* lwz R29, <#[R30 + 184]> */
		/* 8225F65Ch case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x000000B8) );
		/* 8225F65Ch case   14:*/		return 0x8225F660;
		  /* 8225F660h */ case   15:  		/* bl -39464 */
		/* 8225F660h case   15:*/		regs.LR = 0x8225F664; return 0x82255C38;
		/* 8225F660h case   15:*/		return 0x8225F664;
		  /* 8225F664h */ case   16:  		/* lwz R11, <#[R27 - 1292]> */
		/* 8225F664h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF4) );
		/* 8225F664h case   16:*/		return 0x8225F668;
		  /* 8225F668h */ case   17:  		/* mr R10, R3 */
		/* 8225F668h case   17:*/		regs.R10 = regs.R3;
		/* 8225F668h case   17:*/		return 0x8225F66C;
		  /* 8225F66Ch */ case   18:  		/* mr R3, R30 */
		/* 8225F66Ch case   18:*/		regs.R3 = regs.R30;
		/* 8225F66Ch case   18:*/		return 0x8225F670;
		  /* 8225F670h */ case   19:  		/* sth R10, <#[R29 + 24]> */
		/* 8225F670h case   19:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R29 + 0x00000018) );
		/* 8225F670h case   19:*/		return 0x8225F674;
		  /* 8225F674h */ case   20:  		/* mr R5, R28 */
		/* 8225F674h case   20:*/		regs.R5 = regs.R28;
		/* 8225F674h case   20:*/		return 0x8225F678;
		  /* 8225F678h */ case   21:  		/* li R4, 0 */
		/* 8225F678h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F678h case   21:*/		return 0x8225F67C;
		  /* 8225F67Ch */ case   22:  		/* stw R11, <#[R30 + 128]> */
		/* 8225F67Ch case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225F67Ch case   22:*/		return 0x8225F680;
		  /* 8225F680h */ case   23:  		/* bl -37608 */
		/* 8225F680h case   23:*/		regs.LR = 0x8225F684; return 0x82256398;
		/* 8225F680h case   23:*/		return 0x8225F684;
		  /* 8225F684h */ case   24:  		/* mr R5, R19 */
		/* 8225F684h case   24:*/		regs.R5 = regs.R19;
		/* 8225F684h case   24:*/		return 0x8225F688;
		  /* 8225F688h */ case   25:  		/* li R4, 1 */
		/* 8225F688h case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F688h case   25:*/		return 0x8225F68C;
		  /* 8225F68Ch */ case   26:  		/* mr R3, R30 */
		/* 8225F68Ch case   26:*/		regs.R3 = regs.R30;
		/* 8225F68Ch case   26:*/		return 0x8225F690;
		  /* 8225F690h */ case   27:  		/* bl -37624 */
		/* 8225F690h case   27:*/		regs.LR = 0x8225F694; return 0x82256398;
		/* 8225F690h case   27:*/		return 0x8225F694;
		  /* 8225F694h */ case   28:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225F694h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225F694h case   28:*/		return 0x8225F698;
		  /* 8225F698h */ case   29:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225F698h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225F698h case   29:*/		return 0x8225F69C;
		  /* 8225F69Ch */ case   30:  		/* cmplwi CR6, R11, 1 */
		/* 8225F69Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225F69Ch case   30:*/		return 0x8225F6A0;
		  /* 8225F6A0h */ case   31:  		/* bc 12, CR6_LT, 32 */
		/* 8225F6A0h case   31:*/		if ( regs.CR[6].lt ) { return 0x8225F6C0;  }
		/* 8225F6A0h case   31:*/		return 0x8225F6A4;
		  /* 8225F6A4h */ case   32:  		/* bc 12, CR6_EQ, 20 */
		/* 8225F6A4h case   32:*/		if ( regs.CR[6].eq ) { return 0x8225F6B8;  }
		/* 8225F6A4h case   32:*/		return 0x8225F6A8;
		  /* 8225F6A8h */ case   33:  		/* cmplwi CR6, R11, 3 */
		/* 8225F6A8h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225F6A8h case   33:*/		return 0x8225F6AC;
		  /* 8225F6ACh */ case   34:  		/* bc 4, CR6_LT, 20 */
		/* 8225F6ACh case   34:*/		if ( !regs.CR[6].lt ) { return 0x8225F6C0;  }
		/* 8225F6ACh case   34:*/		return 0x8225F6B0;
		  /* 8225F6B0h */ case   35:  		/* li R11, 1 */
		/* 8225F6B0h case   35:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225F6B0h case   35:*/		return 0x8225F6B4;
		  /* 8225F6B4h */ case   36:  		/* b 16 */
		/* 8225F6B4h case   36:*/		return 0x8225F6C4;
		/* 8225F6B4h case   36:*/		return 0x8225F6B8;
	}
	return 0x8225F6B8;
} // Block from 8225F624h-8225F6B8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8225F6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F6B8);
		  /* 8225F6B8h */ case    0:  		/* li R11, 0 */
		/* 8225F6B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225F6B8h case    0:*/		return 0x8225F6BC;
		  /* 8225F6BCh */ case    1:  		/* b 8 */
		/* 8225F6BCh case    1:*/		return 0x8225F6C4;
		/* 8225F6BCh case    1:*/		return 0x8225F6C0;
	}
	return 0x8225F6C0;
} // Block from 8225F6B8h-8225F6C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225F6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F6C0);
		  /* 8225F6C0h */ case    0:  		/* li R11, 2 */
		/* 8225F6C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225F6C0h case    0:*/		return 0x8225F6C4;
	}
	return 0x8225F6C4;
} // Block from 8225F6C0h-8225F6C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225F6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F6C4);
		  /* 8225F6C4h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225F6C4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225F6C4h case    0:*/		return 0x8225F6C8;
		  /* 8225F6C8h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225F6C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225F6C8h case    1:*/		return 0x8225F6CC;
		  /* 8225F6CCh */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8225F6CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8225F6DC;  }
		/* 8225F6CCh case    2:*/		return 0x8225F6D0;
		  /* 8225F6D0h */ case    3:  		/* mr R4, R21 */
		/* 8225F6D0h case    3:*/		regs.R4 = regs.R21;
		/* 8225F6D0h case    3:*/		return 0x8225F6D4;
		  /* 8225F6D4h */ case    4:  		/* mr R3, R30 */
		/* 8225F6D4h case    4:*/		regs.R3 = regs.R30;
		/* 8225F6D4h case    4:*/		return 0x8225F6D8;
		  /* 8225F6D8h */ case    5:  		/* bl -21544 */
		/* 8225F6D8h case    5:*/		regs.LR = 0x8225F6DC; return 0x8225A2B0;
		/* 8225F6D8h case    5:*/		return 0x8225F6DC;
	}
	return 0x8225F6DC;
} // Block from 8225F6C4h-8225F6DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225F6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F6DC);
		  /* 8225F6DCh */ case    0:  		/* mr R4, R30 */
		/* 8225F6DCh case    0:*/		regs.R4 = regs.R30;
		/* 8225F6DCh case    0:*/		return 0x8225F6E0;
		  /* 8225F6E0h */ case    1:  		/* mr R3, R31 */
		/* 8225F6E0h case    1:*/		regs.R3 = regs.R31;
		/* 8225F6E0h case    1:*/		return 0x8225F6E4;
		  /* 8225F6E4h */ case    2:  		/* bl -168252 */
		/* 8225F6E4h case    2:*/		regs.LR = 0x8225F6E8; return 0x822365A8;
		/* 8225F6E4h case    2:*/		return 0x8225F6E8;
		  /* 8225F6E8h */ case    3:  		/* mr R4, R30 */
		/* 8225F6E8h case    3:*/		regs.R4 = regs.R30;
		/* 8225F6E8h case    3:*/		return 0x8225F6EC;
		  /* 8225F6ECh */ case    4:  		/* mr R3, R14 */
		/* 8225F6ECh case    4:*/		regs.R3 = regs.R14;
		/* 8225F6ECh case    4:*/		return 0x8225F6F0;
		  /* 8225F6F0h */ case    5:  		/* bl -26560 */
		/* 8225F6F0h case    5:*/		regs.LR = 0x8225F6F4; return 0x82258F30;
		/* 8225F6F0h case    5:*/		return 0x8225F6F4;
		  /* 8225F6F4h */ case    6:  		/* mr R3, R30 */
		/* 8225F6F4h case    6:*/		regs.R3 = regs.R30;
		/* 8225F6F4h case    6:*/		return 0x8225F6F8;
		  /* 8225F6F8h */ case    7:  		/* bl -38712 */
		/* 8225F6F8h case    7:*/		regs.LR = 0x8225F6FC; return 0x82255FC0;
		/* 8225F6F8h case    7:*/		return 0x8225F6FC;
		  /* 8225F6FCh */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F6FCh case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F6FCh case    8:*/		return 0x8225F700;
		  /* 8225F700h */ case    9:  		/* bc 4, CR0_EQ, 236 */
		/* 8225F700h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8225F7EC;  }
		/* 8225F700h case    9:*/		return 0x8225F704;
		  /* 8225F704h */ case   10:  		/* mr R5, R26 */
		/* 8225F704h case   10:*/		regs.R5 = regs.R26;
		/* 8225F704h case   10:*/		return 0x8225F708;
		  /* 8225F708h */ case   11:  		/* li R7, 2863 */
		/* 8225F708h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xB2F);
		/* 8225F708h case   11:*/		return 0x8225F70C;
		  /* 8225F70Ch */ case   12:  		/* b 208 */
		/* 8225F70Ch case   12:*/		return 0x8225F7DC;
		/* 8225F70Ch case   12:*/		return 0x8225F710;
	}
	return 0x8225F710;
} // Block from 8225F6DCh-8225F710h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8225F710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F710);
		  /* 8225F710h */ case    0:  		/* bl -38880 */
		/* 8225F710h case    0:*/		regs.LR = 0x8225F714; return 0x82255F30;
		/* 8225F710h case    0:*/		return 0x8225F714;
		  /* 8225F714h */ case    1:  		/* lwz R27, <#[R1 + 136]> */
		/* 8225F714h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000088) );
		/* 8225F714h case    1:*/		return 0x8225F718;
		  /* 8225F718h */ case    2:  		/* stw R23, <#[R3 + 184]> */
		/* 8225F718h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x000000B8) );
		/* 8225F718h case    2:*/		return 0x8225F71C;
		  /* 8225F71Ch */ case    3:  		/* mr R5, R28 */
		/* 8225F71Ch case    3:*/		regs.R5 = regs.R28;
		/* 8225F71Ch case    3:*/		return 0x8225F720;
		  /* 8225F720h */ case    4:  		/* stw R25, <#[R3 + 176]> */
		/* 8225F720h case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x000000B0) );
		/* 8225F720h case    4:*/		return 0x8225F724;
		  /* 8225F724h */ case    5:  		/* li R4, 0 */
		/* 8225F724h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F724h case    5:*/		return 0x8225F728;
		  /* 8225F728h */ case    6:  		/* mr R30, R3 */
		/* 8225F728h case    6:*/		regs.R30 = regs.R3;
		/* 8225F728h case    6:*/		return 0x8225F72C;
		  /* 8225F72Ch */ case    7:  		/* lwz R11, <#[R27 - 1304]> */
		/* 8225F72Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAE8) );
		/* 8225F72Ch case    7:*/		return 0x8225F730;
		  /* 8225F730h */ case    8:  		/* stw R11, <#[R3 + 128]> */
		/* 8225F730h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000080) );
		/* 8225F730h case    8:*/		return 0x8225F734;
		  /* 8225F734h */ case    9:  		/* bl -37788 */
		/* 8225F734h case    9:*/		regs.LR = 0x8225F738; return 0x82256398;
		/* 8225F734h case    9:*/		return 0x8225F738;
		  /* 8225F738h */ case   10:  		/* mr R5, R19 */
		/* 8225F738h case   10:*/		regs.R5 = regs.R19;
		/* 8225F738h case   10:*/		return 0x8225F73C;
		  /* 8225F73Ch */ case   11:  		/* li R4, 1 */
		/* 8225F73Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F73Ch case   11:*/		return 0x8225F740;
		  /* 8225F740h */ case   12:  		/* mr R3, R30 */
		/* 8225F740h case   12:*/		regs.R3 = regs.R30;
		/* 8225F740h case   12:*/		return 0x8225F744;
		  /* 8225F744h */ case   13:  		/* bl -37804 */
		/* 8225F744h case   13:*/		regs.LR = 0x8225F748; return 0x82256398;
		/* 8225F744h case   13:*/		return 0x8225F748;
		  /* 8225F748h */ case   14:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225F748h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225F748h case   14:*/		return 0x8225F74C;
		  /* 8225F74Ch */ case   15:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225F74Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225F74Ch case   15:*/		return 0x8225F750;
		  /* 8225F750h */ case   16:  		/* cmplwi CR6, R11, 1 */
		/* 8225F750h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225F750h case   16:*/		return 0x8225F754;
		  /* 8225F754h */ case   17:  		/* bc 12, CR6_LT, 32 */
		/* 8225F754h case   17:*/		if ( regs.CR[6].lt ) { return 0x8225F774;  }
		/* 8225F754h case   17:*/		return 0x8225F758;
		  /* 8225F758h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 8225F758h case   18:*/		if ( regs.CR[6].eq ) { return 0x8225F76C;  }
		/* 8225F758h case   18:*/		return 0x8225F75C;
		  /* 8225F75Ch */ case   19:  		/* cmplwi CR6, R11, 3 */
		/* 8225F75Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225F75Ch case   19:*/		return 0x8225F760;
		  /* 8225F760h */ case   20:  		/* bc 4, CR6_LT, 20 */
		/* 8225F760h case   20:*/		if ( !regs.CR[6].lt ) { return 0x8225F774;  }
		/* 8225F760h case   20:*/		return 0x8225F764;
		  /* 8225F764h */ case   21:  		/* li R11, 1 */
		/* 8225F764h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225F764h case   21:*/		return 0x8225F768;
		  /* 8225F768h */ case   22:  		/* b 16 */
		/* 8225F768h case   22:*/		return 0x8225F778;
		/* 8225F768h case   22:*/		return 0x8225F76C;
	}
	return 0x8225F76C;
} // Block from 8225F710h-8225F76Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8225F76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F76C);
		  /* 8225F76Ch */ case    0:  		/* li R11, 0 */
		/* 8225F76Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225F76Ch case    0:*/		return 0x8225F770;
		  /* 8225F770h */ case    1:  		/* b 8 */
		/* 8225F770h case    1:*/		return 0x8225F778;
		/* 8225F770h case    1:*/		return 0x8225F774;
	}
	return 0x8225F774;
} // Block from 8225F76Ch-8225F774h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225F774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F774);
		  /* 8225F774h */ case    0:  		/* li R11, 2 */
		/* 8225F774h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225F774h case    0:*/		return 0x8225F778;
	}
	return 0x8225F778;
} // Block from 8225F774h-8225F778h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225F778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F778);
		  /* 8225F778h */ case    0:  		/* lwz R21, <#[R1 + 208]> */
		/* 8225F778h case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000D0) );
		/* 8225F778h case    0:*/		return 0x8225F77C;
		  /* 8225F77Ch */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225F77Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225F77Ch case    1:*/		return 0x8225F780;
		  /* 8225F780h */ case    2:  		/* stw R11, <#[R30 + 180]> */
		/* 8225F780h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225F780h case    2:*/		return 0x8225F784;
		  /* 8225F784h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8225F784h case    3:*/		if ( regs.CR[6].eq ) { return 0x8225F794;  }
		/* 8225F784h case    3:*/		return 0x8225F788;
		  /* 8225F788h */ case    4:  		/* mr R3, R30 */
		/* 8225F788h case    4:*/		regs.R3 = regs.R30;
		/* 8225F788h case    4:*/		return 0x8225F78C;
		  /* 8225F78Ch */ case    5:  		/* mr R4, R21 */
		/* 8225F78Ch case    5:*/		regs.R4 = regs.R21;
		/* 8225F78Ch case    5:*/		return 0x8225F790;
		  /* 8225F790h */ case    6:  		/* bl -21728 */
		/* 8225F790h case    6:*/		regs.LR = 0x8225F794; return 0x8225A2B0;
		/* 8225F790h case    6:*/		return 0x8225F794;
	}
	return 0x8225F794;
} // Block from 8225F778h-8225F794h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8225F794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F794);
		  /* 8225F794h */ case    0:  		/* mr R4, R25 */
		/* 8225F794h case    0:*/		regs.R4 = regs.R25;
		/* 8225F794h case    0:*/		return 0x8225F798;
		  /* 8225F798h */ case    1:  		/* lwz R3, <#[R31 + 12]> */
		/* 8225F798h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F798h case    1:*/		return 0x8225F79C;
		  /* 8225F79Ch */ case    2:  		/* bl -274652 */
		/* 8225F79Ch case    2:*/		regs.LR = 0x8225F7A0; return 0x8221C6C0;
		/* 8225F79Ch case    2:*/		return 0x8225F7A0;
		  /* 8225F7A0h */ case    3:  		/* stw R3, <#[R30 + 172]> */
		/* 8225F7A0h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 8225F7A0h case    3:*/		return 0x8225F7A4;
		  /* 8225F7A4h */ case    4:  		/* mr R4, R30 */
		/* 8225F7A4h case    4:*/		regs.R4 = regs.R30;
		/* 8225F7A4h case    4:*/		return 0x8225F7A8;
		  /* 8225F7A8h */ case    5:  		/* mr R3, R31 */
		/* 8225F7A8h case    5:*/		regs.R3 = regs.R31;
		/* 8225F7A8h case    5:*/		return 0x8225F7AC;
		  /* 8225F7ACh */ case    6:  		/* bl -168452 */
		/* 8225F7ACh case    6:*/		regs.LR = 0x8225F7B0; return 0x822365A8;
		/* 8225F7ACh case    6:*/		return 0x8225F7B0;
		  /* 8225F7B0h */ case    7:  		/* mr R4, R30 */
		/* 8225F7B0h case    7:*/		regs.R4 = regs.R30;
		/* 8225F7B0h case    7:*/		return 0x8225F7B4;
		  /* 8225F7B4h */ case    8:  		/* mr R3, R14 */
		/* 8225F7B4h case    8:*/		regs.R3 = regs.R14;
		/* 8225F7B4h case    8:*/		return 0x8225F7B8;
		  /* 8225F7B8h */ case    9:  		/* bl -26760 */
		/* 8225F7B8h case    9:*/		regs.LR = 0x8225F7BC; return 0x82258F30;
		/* 8225F7B8h case    9:*/		return 0x8225F7BC;
		  /* 8225F7BCh */ case   10:  		/* mr R3, R30 */
		/* 8225F7BCh case   10:*/		regs.R3 = regs.R30;
		/* 8225F7BCh case   10:*/		return 0x8225F7C0;
		  /* 8225F7C0h */ case   11:  		/* bl -38912 */
		/* 8225F7C0h case   11:*/		regs.LR = 0x8225F7C4; return 0x82255FC0;
		/* 8225F7C0h case   11:*/		return 0x8225F7C4;
		  /* 8225F7C4h */ case   12:  		/* lwz R22, <#[R1 + 128]> */
		/* 8225F7C4h case   12:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000080) );
		/* 8225F7C4h case   12:*/		return 0x8225F7C8;
		  /* 8225F7C8h */ case   13:  		/* lwz R24, <#[R1 + 132]> */
		/* 8225F7C8h case   13:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 8225F7C8h case   13:*/		return 0x8225F7CC;
		  /* 8225F7CCh */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F7CCh case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F7CCh case   14:*/		return 0x8225F7D0;
		  /* 8225F7D0h */ case   15:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F7D0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8225F7EC;  }
		/* 8225F7D0h case   15:*/		return 0x8225F7D4;
		  /* 8225F7D4h */ case   16:  		/* lwz R5, <#[R1 + 268]> */
		/* 8225F7D4h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000010C) );
		/* 8225F7D4h case   16:*/		return 0x8225F7D8;
		  /* 8225F7D8h */ case   17:  		/* li R7, 2880 */
		/* 8225F7D8h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0xB40);
		/* 8225F7D8h case   17:*/		return 0x8225F7DC;
	}
	return 0x8225F7DC;
} // Block from 8225F794h-8225F7DCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 8225F7DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F7DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F7DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F7DC);
		  /* 8225F7DCh */ case    0:  		/* mr R6, R22 */
		/* 8225F7DCh case    0:*/		regs.R6 = regs.R22;
		/* 8225F7DCh case    0:*/		return 0x8225F7E0;
		  /* 8225F7E0h */ case    1:  		/* mr R4, R24 */
		/* 8225F7E0h case    1:*/		regs.R4 = regs.R24;
		/* 8225F7E0h case    1:*/		return 0x8225F7E4;
		  /* 8225F7E4h */ case    2:  		/* li R3, 0 */
		/* 8225F7E4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F7E4h case    2:*/		return 0x8225F7E8;
		  /* 8225F7E8h */ case    3:  		/* bl -1080288 */
		/* 8225F7E8h case    3:*/		regs.LR = 0x8225F7EC; return 0x82157C08;
		/* 8225F7E8h case    3:*/		return 0x8225F7EC;
	}
	return 0x8225F7EC;
} // Block from 8225F7DCh-8225F7ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8225F7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F7EC);
		  /* 8225F7ECh */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225F7ECh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F7ECh case    0:*/		return 0x8225F7F0;
		  /* 8225F7F0h */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225F7F0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225F7F0h case    1:*/		return 0x8225F7F4;
		  /* 8225F7F4h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8225F7F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225F7F4h case    2:*/		return 0x8225F7F8;
		  /* 8225F7F8h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225F7F8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225F7F8h case    3:*/		return 0x8225F7FC;
		  /* 8225F7FCh */ case    4:  		/* mtspr CTR, R11 */
		/* 8225F7FCh case    4:*/		regs.CTR = regs.R11;
		/* 8225F7FCh case    4:*/		return 0x8225F800;
		  /* 8225F800h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8225F800h case    5:*/		if ( 1 ) { regs.LR = 0x8225F804; return (uint32)regs.CTR; }
		/* 8225F800h case    5:*/		return 0x8225F804;
		  /* 8225F804h */ case    6:  		/* lis R11, -32222 */
		/* 8225F804h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F804h case    6:*/		return 0x8225F808;
		  /* 8225F808h */ case    7:  		/* mr R5, R3 */
		/* 8225F808h case    7:*/		regs.R5 = regs.R3;
		/* 8225F808h case    7:*/		return 0x8225F80C;
		  /* 8225F80Ch */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F80Ch case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F80Ch case    8:*/		return 0x8225F810;
		  /* 8225F810h */ case    9:  		/* mr R4, R25 */
		/* 8225F810h case    9:*/		regs.R4 = regs.R25;
		/* 8225F810h case    9:*/		return 0x8225F814;
		  /* 8225F814h */ case   10:  		/* addi R6, R11, -12392 */
		/* 8225F814h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F814h case   10:*/		return 0x8225F818;
		  /* 8225F818h */ case   11:  		/* mr R7, R30 */
		/* 8225F818h case   11:*/		regs.R7 = regs.R30;
		/* 8225F818h case   11:*/		return 0x8225F81C;
		  /* 8225F81Ch */ case   12:  		/* bl -188428 */
		/* 8225F81Ch case   12:*/		regs.LR = 0x8225F820; return 0x82231810;
		/* 8225F81Ch case   12:*/		return 0x8225F820;
		  /* 8225F820h */ case   13:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F820h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F820h case   13:*/		return 0x8225F824;
		  /* 8225F824h */ case   14:  		/* cmpwi CR6, R3, 1 */
		/* 8225F824h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225F824h case   14:*/		return 0x8225F828;
		  /* 8225F828h */ case   15:  		/* bc 4, CR6_EQ, 116 */
		/* 8225F828h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8225F89C;  }
		/* 8225F828h case   15:*/		return 0x8225F82C;
		  /* 8225F82Ch */ case   16:  		/* li R3, 41 */
		/* 8225F82Ch case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x29);
		/* 8225F82Ch case   16:*/		return 0x8225F830;
		  /* 8225F830h */ case   17:  		/* bl -39168 */
		/* 8225F830h case   17:*/		regs.LR = 0x8225F834; return 0x82255F30;
		/* 8225F830h case   17:*/		return 0x8225F834;
		  /* 8225F834h */ case   18:  		/* mr R5, R28 */
		/* 8225F834h case   18:*/		regs.R5 = regs.R28;
		/* 8225F834h case   18:*/		return 0x8225F838;
		  /* 8225F838h */ case   19:  		/* li R4, 0 */
		/* 8225F838h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F838h case   19:*/		return 0x8225F83C;
		  /* 8225F83Ch */ case   20:  		/* mr R30, R3 */
		/* 8225F83Ch case   20:*/		regs.R30 = regs.R3;
		/* 8225F83Ch case   20:*/		return 0x8225F840;
		  /* 8225F840h */ case   21:  		/* bl -38056 */
		/* 8225F840h case   21:*/		regs.LR = 0x8225F844; return 0x82256398;
		/* 8225F840h case   21:*/		return 0x8225F844;
		  /* 8225F844h */ case   22:  		/* mr R3, R30 */
		/* 8225F844h case   22:*/		regs.R3 = regs.R30;
		/* 8225F844h case   22:*/		return 0x8225F848;
		  /* 8225F848h */ case   23:  		/* mr R5, R19 */
		/* 8225F848h case   23:*/		regs.R5 = regs.R19;
		/* 8225F848h case   23:*/		return 0x8225F84C;
		  /* 8225F84Ch */ case   24:  		/* li R4, 1 */
		/* 8225F84Ch case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F84Ch case   24:*/		return 0x8225F850;
		  /* 8225F850h */ case   25:  		/* bl -38072 */
		/* 8225F850h case   25:*/		regs.LR = 0x8225F854; return 0x82256398;
		/* 8225F850h case   25:*/		return 0x8225F854;
		  /* 8225F854h */ case   26:  		/* mr R3, R30 */
		/* 8225F854h case   26:*/		regs.R3 = regs.R30;
		/* 8225F854h case   26:*/		return 0x8225F858;
		  /* 8225F858h */ case   27:  		/* mr R5, R28 */
		/* 8225F858h case   27:*/		regs.R5 = regs.R28;
		/* 8225F858h case   27:*/		return 0x8225F85C;
		  /* 8225F85Ch */ case   28:  		/* li R4, 2 */
		/* 8225F85Ch case   28:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225F85Ch case   28:*/		return 0x8225F860;
		  /* 8225F860h */ case   29:  		/* bl -38088 */
		/* 8225F860h case   29:*/		regs.LR = 0x8225F864; return 0x82256398;
		/* 8225F860h case   29:*/		return 0x8225F864;
		  /* 8225F864h */ case   30:  		/* lwz R11, <#[R27 - 1276]> */
		/* 8225F864h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 8225F864h case   30:*/		return 0x8225F868;
		  /* 8225F868h */ case   31:  		/* mr R4, R30 */
		/* 8225F868h case   31:*/		regs.R4 = regs.R30;
		/* 8225F868h case   31:*/		return 0x8225F86C;
		  /* 8225F86Ch */ case   32:  		/* mr R3, R31 */
		/* 8225F86Ch case   32:*/		regs.R3 = regs.R31;
		/* 8225F86Ch case   32:*/		return 0x8225F870;
		  /* 8225F870h */ case   33:  		/* stw R11, <#[R30 + 132]> */
		/* 8225F870h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225F870h case   33:*/		return 0x8225F874;
		  /* 8225F874h */ case   34:  		/* bl -168652 */
		/* 8225F874h case   34:*/		regs.LR = 0x8225F878; return 0x822365A8;
		/* 8225F874h case   34:*/		return 0x8225F878;
		  /* 8225F878h */ case   35:  		/* mr R4, R30 */
		/* 8225F878h case   35:*/		regs.R4 = regs.R30;
		/* 8225F878h case   35:*/		return 0x8225F87C;
		  /* 8225F87Ch */ case   36:  		/* mr R3, R14 */
		/* 8225F87Ch case   36:*/		regs.R3 = regs.R14;
		/* 8225F87Ch case   36:*/		return 0x8225F880;
		  /* 8225F880h */ case   37:  		/* bl -26960 */
		/* 8225F880h case   37:*/		regs.LR = 0x8225F884; return 0x82258F30;
		/* 8225F880h case   37:*/		return 0x8225F884;
		  /* 8225F884h */ case   38:  		/* mr R3, R30 */
		/* 8225F884h case   38:*/		regs.R3 = regs.R30;
		/* 8225F884h case   38:*/		return 0x8225F888;
		  /* 8225F888h */ case   39:  		/* bl -39112 */
		/* 8225F888h case   39:*/		regs.LR = 0x8225F88C; return 0x82255FC0;
		/* 8225F888h case   39:*/		return 0x8225F88C;
		  /* 8225F88Ch */ case   40:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F88Ch case   40:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F88Ch case   40:*/		return 0x8225F890;
		  /* 8225F890h */ case   41:  		/* bc 4, CR0_EQ, 140 */
		/* 8225F890h case   41:*/		if ( !regs.CR[0].eq ) { return 0x8225F91C;  }
		/* 8225F890h case   41:*/		return 0x8225F894;
		  /* 8225F894h */ case   42:  		/* li R7, 2894 */
		/* 8225F894h case   42:*/		cpu::op::li<0>(regs,&regs.R7,0xB4E);
		/* 8225F894h case   42:*/		return 0x8225F898;
		  /* 8225F898h */ case   43:  		/* b 112 */
		/* 8225F898h case   43:*/		return 0x8225F908;
		/* 8225F898h case   43:*/		return 0x8225F89C;
	}
	return 0x8225F89C;
} // Block from 8225F7ECh-8225F89Ch (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225F89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F89C);
		  /* 8225F89Ch */ case    0:  		/* li R3, 40 */
		/* 8225F89Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x28);
		/* 8225F89Ch case    0:*/		return 0x8225F8A0;
		  /* 8225F8A0h */ case    1:  		/* bl -39280 */
		/* 8225F8A0h case    1:*/		regs.LR = 0x8225F8A4; return 0x82255F30;
		/* 8225F8A0h case    1:*/		return 0x8225F8A4;
		  /* 8225F8A4h */ case    2:  		/* mr R5, R28 */
		/* 8225F8A4h case    2:*/		regs.R5 = regs.R28;
		/* 8225F8A4h case    2:*/		return 0x8225F8A8;
		  /* 8225F8A8h */ case    3:  		/* li R4, 0 */
		/* 8225F8A8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F8A8h case    3:*/		return 0x8225F8AC;
		  /* 8225F8ACh */ case    4:  		/* mr R30, R3 */
		/* 8225F8ACh case    4:*/		regs.R30 = regs.R3;
		/* 8225F8ACh case    4:*/		return 0x8225F8B0;
		  /* 8225F8B0h */ case    5:  		/* bl -38168 */
		/* 8225F8B0h case    5:*/		regs.LR = 0x8225F8B4; return 0x82256398;
		/* 8225F8B0h case    5:*/		return 0x8225F8B4;
		  /* 8225F8B4h */ case    6:  		/* mr R3, R30 */
		/* 8225F8B4h case    6:*/		regs.R3 = regs.R30;
		/* 8225F8B4h case    6:*/		return 0x8225F8B8;
		  /* 8225F8B8h */ case    7:  		/* mr R5, R28 */
		/* 8225F8B8h case    7:*/		regs.R5 = regs.R28;
		/* 8225F8B8h case    7:*/		return 0x8225F8BC;
		  /* 8225F8BCh */ case    8:  		/* li R4, 1 */
		/* 8225F8BCh case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F8BCh case    8:*/		return 0x8225F8C0;
		  /* 8225F8C0h */ case    9:  		/* bl -38184 */
		/* 8225F8C0h case    9:*/		regs.LR = 0x8225F8C4; return 0x82256398;
		/* 8225F8C0h case    9:*/		return 0x8225F8C4;
		  /* 8225F8C4h */ case   10:  		/* mr R3, R30 */
		/* 8225F8C4h case   10:*/		regs.R3 = regs.R30;
		/* 8225F8C4h case   10:*/		return 0x8225F8C8;
		  /* 8225F8C8h */ case   11:  		/* mr R5, R19 */
		/* 8225F8C8h case   11:*/		regs.R5 = regs.R19;
		/* 8225F8C8h case   11:*/		return 0x8225F8CC;
		  /* 8225F8CCh */ case   12:  		/* li R4, 2 */
		/* 8225F8CCh case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225F8CCh case   12:*/		return 0x8225F8D0;
		  /* 8225F8D0h */ case   13:  		/* bl -38200 */
		/* 8225F8D0h case   13:*/		regs.LR = 0x8225F8D4; return 0x82256398;
		/* 8225F8D0h case   13:*/		return 0x8225F8D4;
		  /* 8225F8D4h */ case   14:  		/* lwz R11, <#[R27 - 1276]> */
		/* 8225F8D4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 8225F8D4h case   14:*/		return 0x8225F8D8;
		  /* 8225F8D8h */ case   15:  		/* mr R4, R30 */
		/* 8225F8D8h case   15:*/		regs.R4 = regs.R30;
		/* 8225F8D8h case   15:*/		return 0x8225F8DC;
		  /* 8225F8DCh */ case   16:  		/* mr R3, R31 */
		/* 8225F8DCh case   16:*/		regs.R3 = regs.R31;
		/* 8225F8DCh case   16:*/		return 0x8225F8E0;
		  /* 8225F8E0h */ case   17:  		/* stw R11, <#[R30 + 136]> */
		/* 8225F8E0h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 8225F8E0h case   17:*/		return 0x8225F8E4;
		  /* 8225F8E4h */ case   18:  		/* bl -168764 */
		/* 8225F8E4h case   18:*/		regs.LR = 0x8225F8E8; return 0x822365A8;
		/* 8225F8E4h case   18:*/		return 0x8225F8E8;
		  /* 8225F8E8h */ case   19:  		/* mr R4, R30 */
		/* 8225F8E8h case   19:*/		regs.R4 = regs.R30;
		/* 8225F8E8h case   19:*/		return 0x8225F8EC;
		  /* 8225F8ECh */ case   20:  		/* mr R3, R14 */
		/* 8225F8ECh case   20:*/		regs.R3 = regs.R14;
		/* 8225F8ECh case   20:*/		return 0x8225F8F0;
		  /* 8225F8F0h */ case   21:  		/* bl -27072 */
		/* 8225F8F0h case   21:*/		regs.LR = 0x8225F8F4; return 0x82258F30;
		/* 8225F8F0h case   21:*/		return 0x8225F8F4;
		  /* 8225F8F4h */ case   22:  		/* mr R3, R30 */
		/* 8225F8F4h case   22:*/		regs.R3 = regs.R30;
		/* 8225F8F4h case   22:*/		return 0x8225F8F8;
		  /* 8225F8F8h */ case   23:  		/* bl -39224 */
		/* 8225F8F8h case   23:*/		regs.LR = 0x8225F8FC; return 0x82255FC0;
		/* 8225F8F8h case   23:*/		return 0x8225F8FC;
		  /* 8225F8FCh */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F8FCh case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F8FCh case   24:*/		return 0x8225F900;
		  /* 8225F900h */ case   25:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F900h case   25:*/		if ( !regs.CR[0].eq ) { return 0x8225F91C;  }
		/* 8225F900h case   25:*/		return 0x8225F904;
		  /* 8225F904h */ case   26:  		/* li R7, 2903 */
		/* 8225F904h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0xB57);
		/* 8225F904h case   26:*/		return 0x8225F908;
	}
	return 0x8225F908;
} // Block from 8225F89Ch-8225F908h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8225F908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F908);
		  /* 8225F908h */ case    0:  		/* mr R6, R22 */
		/* 8225F908h case    0:*/		regs.R6 = regs.R22;
		/* 8225F908h case    0:*/		return 0x8225F90C;
		  /* 8225F90Ch */ case    1:  		/* lwz R5, <#[R1 + 368]> */
		/* 8225F90Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000170) );
		/* 8225F90Ch case    1:*/		return 0x8225F910;
		  /* 8225F910h */ case    2:  		/* mr R4, R24 */
		/* 8225F910h case    2:*/		regs.R4 = regs.R24;
		/* 8225F910h case    2:*/		return 0x8225F914;
		  /* 8225F914h */ case    3:  		/* li R3, 0 */
		/* 8225F914h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F914h case    3:*/		return 0x8225F918;
		  /* 8225F918h */ case    4:  		/* bl -1080592 */
		/* 8225F918h case    4:*/		regs.LR = 0x8225F91C; return 0x82157C08;
		/* 8225F918h case    4:*/		return 0x8225F91C;
	}
	return 0x8225F91C;
} // Block from 8225F908h-8225F91Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8225F91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F91C);
		  /* 8225F91Ch */ case    0:  		/* li R3, 23 */
		/* 8225F91Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x17);
		/* 8225F91Ch case    0:*/		return 0x8225F920;
		  /* 8225F920h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225F920h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F920h case    1:*/		return 0x8225F924;
		  /* 8225F924h */ case    2:  		/* bl -39412 */
		/* 8225F924h case    2:*/		regs.LR = 0x8225F928; return 0x82255F30;
		/* 8225F924h case    2:*/		return 0x8225F928;
		  /* 8225F928h */ case    3:  		/* mr R5, R18 */
		/* 8225F928h case    3:*/		regs.R5 = regs.R18;
		/* 8225F928h case    3:*/		return 0x8225F92C;
		  /* 8225F92Ch */ case    4:  		/* li R4, 0 */
		/* 8225F92Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225F92Ch case    4:*/		return 0x8225F930;
		  /* 8225F930h */ case    5:  		/* mr R30, R3 */
		/* 8225F930h case    5:*/		regs.R30 = regs.R3;
		/* 8225F930h case    5:*/		return 0x8225F934;
		  /* 8225F934h */ case    6:  		/* bl -38300 */
		/* 8225F934h case    6:*/		regs.LR = 0x8225F938; return 0x82256398;
		/* 8225F934h case    6:*/		return 0x8225F938;
		  /* 8225F938h */ case    7:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225F938h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225F938h case    7:*/		return 0x8225F93C;
		  /* 8225F93Ch */ case    8:  		/* mr R3, R30 */
		/* 8225F93Ch case    8:*/		regs.R3 = regs.R30;
		/* 8225F93Ch case    8:*/		return 0x8225F940;
		  /* 8225F940h */ case    9:  		/* mr R5, R28 */
		/* 8225F940h case    9:*/		regs.R5 = regs.R28;
		/* 8225F940h case    9:*/		return 0x8225F944;
		  /* 8225F944h */ case   10:  		/* li R4, 1 */
		/* 8225F944h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225F944h case   10:*/		return 0x8225F948;
		  /* 8225F948h */ case   11:  		/* stw R11, <#[R30 + 132]> */
		/* 8225F948h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225F948h case   11:*/		return 0x8225F94C;
		  /* 8225F94Ch */ case   12:  		/* bl -38324 */
		/* 8225F94Ch case   12:*/		regs.LR = 0x8225F950; return 0x82256398;
		/* 8225F94Ch case   12:*/		return 0x8225F950;
		  /* 8225F950h */ case   13:  		/* lis R11, -32222 */
		/* 8225F950h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F950h case   13:*/		return 0x8225F954;
		  /* 8225F954h */ case   14:  		/* addi R5, R1, 544 */
		/* 8225F954h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x220);
		/* 8225F954h case   14:*/		return 0x8225F958;
		  /* 8225F958h */ case   15:  		/* lwz R7, <#[R31 + 12]> */
		/* 8225F958h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F958h case   15:*/		return 0x8225F95C;
		  /* 8225F95Ch */ case   16:  		/* addi R6, R11, -12392 */
		/* 8225F95Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F95Ch case   16:*/		return 0x8225F960;
		  /* 8225F960h */ case   17:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F960h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F960h case   17:*/		return 0x8225F964;
		  /* 8225F964h */ case   18:  		/* mr R4, R25 */
		/* 8225F964h case   18:*/		regs.R4 = regs.R25;
		/* 8225F964h case   18:*/		return 0x8225F968;
		  /* 8225F968h */ case   19:  		/* bl -179272 */
		/* 8225F968h case   19:*/		regs.LR = 0x8225F96C; return 0x82233D20;
		/* 8225F968h case   19:*/		return 0x8225F96C;
		  /* 8225F96Ch */ case   20:  		/* lfs FR4, <#[R1 + 544]> */
		/* 8225F96Ch case   20:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x00000220) );
		/* 8225F96Ch case   20:*/		return 0x8225F970;
		  /* 8225F970h */ case   21:  		/* mr R3, R30 */
		/* 8225F970h case   21:*/		regs.R3 = regs.R30;
		/* 8225F970h case   21:*/		return 0x8225F974;
		  /* 8225F974h */ case   22:  		/* fmr FR3, FR4 */
		/* 8225F974h case   22:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 8225F974h case   22:*/		return 0x8225F978;
		  /* 8225F978h */ case   23:  		/* li R5, 2 */
		/* 8225F978h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8225F978h case   23:*/		return 0x8225F97C;
		  /* 8225F97Ch */ case   24:  		/* fmr FR2, FR4 */
		/* 8225F97Ch case   24:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 8225F97Ch case   24:*/		return 0x8225F980;
		  /* 8225F980h */ case   25:  		/* mr R4, R31 */
		/* 8225F980h case   25:*/		regs.R4 = regs.R31;
		/* 8225F980h case   25:*/		return 0x8225F984;
		  /* 8225F984h */ case   26:  		/* fmr FR1, FR4 */
		/* 8225F984h case   26:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 8225F984h case   26:*/		return 0x8225F988;
		  /* 8225F988h */ case   27:  		/* bl -35440 */
		/* 8225F988h case   27:*/		regs.LR = 0x8225F98C; return 0x82256F18;
		/* 8225F988h case   27:*/		return 0x8225F98C;
		  /* 8225F98Ch */ case   28:  		/* mr R4, R30 */
		/* 8225F98Ch case   28:*/		regs.R4 = regs.R30;
		/* 8225F98Ch case   28:*/		return 0x8225F990;
		  /* 8225F990h */ case   29:  		/* mr R3, R31 */
		/* 8225F990h case   29:*/		regs.R3 = regs.R31;
		/* 8225F990h case   29:*/		return 0x8225F994;
		  /* 8225F994h */ case   30:  		/* bl -168940 */
		/* 8225F994h case   30:*/		regs.LR = 0x8225F998; return 0x822365A8;
		/* 8225F994h case   30:*/		return 0x8225F998;
		  /* 8225F998h */ case   31:  		/* mr R4, R30 */
		/* 8225F998h case   31:*/		regs.R4 = regs.R30;
		/* 8225F998h case   31:*/		return 0x8225F99C;
		  /* 8225F99Ch */ case   32:  		/* mr R3, R14 */
		/* 8225F99Ch case   32:*/		regs.R3 = regs.R14;
		/* 8225F99Ch case   32:*/		return 0x8225F9A0;
		  /* 8225F9A0h */ case   33:  		/* bl -27248 */
		/* 8225F9A0h case   33:*/		regs.LR = 0x8225F9A4; return 0x82258F30;
		/* 8225F9A0h case   33:*/		return 0x8225F9A4;
		  /* 8225F9A4h */ case   34:  		/* mr R3, R30 */
		/* 8225F9A4h case   34:*/		regs.R3 = regs.R30;
		/* 8225F9A4h case   34:*/		return 0x8225F9A8;
		  /* 8225F9A8h */ case   35:  		/* bl -39400 */
		/* 8225F9A8h case   35:*/		regs.LR = 0x8225F9AC; return 0x82255FC0;
		/* 8225F9A8h case   35:*/		return 0x8225F9AC;
		  /* 8225F9ACh */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225F9ACh case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225F9ACh case   36:*/		return 0x8225F9B0;
		  /* 8225F9B0h */ case   37:  		/* bc 4, CR0_EQ, 28 */
		/* 8225F9B0h case   37:*/		if ( !regs.CR[0].eq ) { return 0x8225F9CC;  }
		/* 8225F9B0h case   37:*/		return 0x8225F9B4;
		  /* 8225F9B4h */ case   38:  		/* mr R6, R22 */
		/* 8225F9B4h case   38:*/		regs.R6 = regs.R22;
		/* 8225F9B4h case   38:*/		return 0x8225F9B8;
		  /* 8225F9B8h */ case   39:  		/* lwz R5, <#[R1 + 304]> */
		/* 8225F9B8h case   39:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000130) );
		/* 8225F9B8h case   39:*/		return 0x8225F9BC;
		  /* 8225F9BCh */ case   40:  		/* mr R4, R24 */
		/* 8225F9BCh case   40:*/		regs.R4 = regs.R24;
		/* 8225F9BCh case   40:*/		return 0x8225F9C0;
		  /* 8225F9C0h */ case   41:  		/* li R7, 2918 */
		/* 8225F9C0h case   41:*/		cpu::op::li<0>(regs,&regs.R7,0xB66);
		/* 8225F9C0h case   41:*/		return 0x8225F9C4;
		  /* 8225F9C4h */ case   42:  		/* li R3, 0 */
		/* 8225F9C4h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225F9C4h case   42:*/		return 0x8225F9C8;
		  /* 8225F9C8h */ case   43:  		/* bl -1080768 */
		/* 8225F9C8h case   43:*/		regs.LR = 0x8225F9CC; return 0x82157C08;
		/* 8225F9C8h case   43:*/		return 0x8225F9CC;
	}
	return 0x8225F9CC;
} // Block from 8225F91Ch-8225F9CCh (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225F9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225F9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225F9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225F9CC);
		  /* 8225F9CCh */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225F9CCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225F9CCh case    0:*/		return 0x8225F9D0;
		  /* 8225F9D0h */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225F9D0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225F9D0h case    1:*/		return 0x8225F9D4;
		  /* 8225F9D4h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8225F9D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225F9D4h case    2:*/		return 0x8225F9D8;
		  /* 8225F9D8h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225F9D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225F9D8h case    3:*/		return 0x8225F9DC;
		  /* 8225F9DCh */ case    4:  		/* mtspr CTR, R11 */
		/* 8225F9DCh case    4:*/		regs.CTR = regs.R11;
		/* 8225F9DCh case    4:*/		return 0x8225F9E0;
		  /* 8225F9E0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8225F9E0h case    5:*/		if ( 1 ) { regs.LR = 0x8225F9E4; return (uint32)regs.CTR; }
		/* 8225F9E0h case    5:*/		return 0x8225F9E4;
		  /* 8225F9E4h */ case    6:  		/* lis R11, -32222 */
		/* 8225F9E4h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225F9E4h case    6:*/		return 0x8225F9E8;
		  /* 8225F9E8h */ case    7:  		/* mr R5, R3 */
		/* 8225F9E8h case    7:*/		regs.R5 = regs.R3;
		/* 8225F9E8h case    7:*/		return 0x8225F9EC;
		  /* 8225F9ECh */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225F9ECh case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225F9ECh case    8:*/		return 0x8225F9F0;
		  /* 8225F9F0h */ case    9:  		/* mr R4, R25 */
		/* 8225F9F0h case    9:*/		regs.R4 = regs.R25;
		/* 8225F9F0h case    9:*/		return 0x8225F9F4;
		  /* 8225F9F4h */ case   10:  		/* addi R6, R11, -12392 */
		/* 8225F9F4h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225F9F4h case   10:*/		return 0x8225F9F8;
		  /* 8225F9F8h */ case   11:  		/* mr R7, R30 */
		/* 8225F9F8h case   11:*/		regs.R7 = regs.R30;
		/* 8225F9F8h case   11:*/		return 0x8225F9FC;
		  /* 8225F9FCh */ case   12:  		/* bl -189228 */
		/* 8225F9FCh case   12:*/		regs.LR = 0x8225FA00; return 0x822316D0;
		/* 8225F9FCh case   12:*/		return 0x8225FA00;
		  /* 8225FA00h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 8225FA00h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225FA00h case   13:*/		return 0x8225FA04;
		  /* 8225FA04h */ case   14:  		/* bc 4, CR6_EQ, 772 */
		/* 8225FA04h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8225FD08;  }
		/* 8225FA04h case   14:*/		return 0x8225FA08;
		  /* 8225FA08h */ case   15:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225FA08h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FA08h case   15:*/		return 0x8225FA0C;
		  /* 8225FA0Ch */ case   16:  		/* li R4, 0 */
		/* 8225FA0Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FA0Ch case   16:*/		return 0x8225FA10;
		  /* 8225FA10h */ case   17:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225FA10h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225FA10h case   17:*/		return 0x8225FA14;
		  /* 8225FA14h */ case   18:  		/* addi R5, R11, -1 */
		/* 8225FA14h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225FA14h case   18:*/		return 0x8225FA18;
		  /* 8225FA18h */ case   19:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225FA18h case   19:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225FA18h case   19:*/		return 0x8225FA1C;
		  /* 8225FA1Ch */ case   20:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225FA1Ch case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225FA1Ch case   20:*/		return 0x8225FA20;
		  /* 8225FA20h */ case   21:  		/* bl -107024 */
		/* 8225FA20h case   21:*/		regs.LR = 0x8225FA24; return 0x82245810;
		/* 8225FA20h case   21:*/		return 0x8225FA24;
		  /* 8225FA24h */ case   22:  		/* lwz R10, <#[R31 + 12]> */
		/* 8225FA24h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FA24h case   22:*/		return 0x8225FA28;
		  /* 8225FA28h */ case   23:  		/* li R4, 0 */
		/* 8225FA28h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FA28h case   23:*/		return 0x8225FA2C;
		  /* 8225FA2Ch */ case   24:  		/* mr R29, R3 */
		/* 8225FA2Ch case   24:*/		regs.R29 = regs.R3;
		/* 8225FA2Ch case   24:*/		return 0x8225FA30;
		  /* 8225FA30h */ case   25:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8225FA30h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225FA30h case   25:*/		return 0x8225FA34;
		  /* 8225FA34h */ case   26:  		/* addi R5, R11, -1 */
		/* 8225FA34h case   26:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8225FA34h case   26:*/		return 0x8225FA38;
		  /* 8225FA38h */ case   27:  		/* stw R5, <#[R10 + 1508]> */
		/* 8225FA38h case   27:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 8225FA38h case   27:*/		return 0x8225FA3C;
		  /* 8225FA3Ch */ case   28:  		/* lwz R3, <#[R31 + 172]> */
		/* 8225FA3Ch case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8225FA3Ch case   28:*/		return 0x8225FA40;
		  /* 8225FA40h */ case   29:  		/* bl -107056 */
		/* 8225FA40h case   29:*/		regs.LR = 0x8225FA44; return 0x82245810;
		/* 8225FA40h case   29:*/		return 0x8225FA44;
		  /* 8225FA44h */ case   30:  		/* mr R28, R3 */
		/* 8225FA44h case   30:*/		regs.R28 = regs.R3;
		/* 8225FA44h case   30:*/		return 0x8225FA48;
		  /* 8225FA48h */ case   31:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FA48h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FA48h case   31:*/		return 0x8225FA4C;
		  /* 8225FA4Ch */ case   32:  		/* li R3, 112 */
		/* 8225FA4Ch case   32:*/		cpu::op::li<0>(regs,&regs.R3,0x70);
		/* 8225FA4Ch case   32:*/		return 0x8225FA50;
		  /* 8225FA50h */ case   33:  		/* bl -39712 */
		/* 8225FA50h case   33:*/		regs.LR = 0x8225FA54; return 0x82255F30;
		/* 8225FA50h case   33:*/		return 0x8225FA54;
		  /* 8225FA54h */ case   34:  		/* mr R5, R29 */
		/* 8225FA54h case   34:*/		regs.R5 = regs.R29;
		/* 8225FA54h case   34:*/		return 0x8225FA58;
		  /* 8225FA58h */ case   35:  		/* li R4, 0 */
		/* 8225FA58h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FA58h case   35:*/		return 0x8225FA5C;
		  /* 8225FA5Ch */ case   36:  		/* mr R30, R3 */
		/* 8225FA5Ch case   36:*/		regs.R30 = regs.R3;
		/* 8225FA5Ch case   36:*/		return 0x8225FA60;
		  /* 8225FA60h */ case   37:  		/* bl -38600 */
		/* 8225FA60h case   37:*/		regs.LR = 0x8225FA64; return 0x82256398;
		/* 8225FA60h case   37:*/		return 0x8225FA64;
		  /* 8225FA64h */ case   38:  		/* mr R5, R19 */
		/* 8225FA64h case   38:*/		regs.R5 = regs.R19;
		/* 8225FA64h case   38:*/		return 0x8225FA68;
		  /* 8225FA68h */ case   39:  		/* li R4, 1 */
		/* 8225FA68h case   39:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225FA68h case   39:*/		return 0x8225FA6C;
		  /* 8225FA6Ch */ case   40:  		/* mr R3, R30 */
		/* 8225FA6Ch case   40:*/		regs.R3 = regs.R30;
		/* 8225FA6Ch case   40:*/		return 0x8225FA70;
		  /* 8225FA70h */ case   41:  		/* bl -38616 */
		/* 8225FA70h case   41:*/		regs.LR = 0x8225FA74; return 0x82256398;
		/* 8225FA70h case   41:*/		return 0x8225FA74;
		  /* 8225FA74h */ case   42:  		/* lwz R11, <#[R31 + 88]> */
		/* 8225FA74h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8225FA74h case   42:*/		return 0x8225FA78;
		  /* 8225FA78h */ case   43:  		/* lwzx R11, <#[R17 + R11]> */
		/* 8225FA78h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 8225FA78h case   43:*/		return 0x8225FA7C;
		  /* 8225FA7Ch */ case   44:  		/* cmplwi CR6, R11, 1 */
		/* 8225FA7Ch case   44:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8225FA7Ch case   44:*/		return 0x8225FA80;
		  /* 8225FA80h */ case   45:  		/* bc 12, CR6_LT, 32 */
		/* 8225FA80h case   45:*/		if ( regs.CR[6].lt ) { return 0x8225FAA0;  }
		/* 8225FA80h case   45:*/		return 0x8225FA84;
		  /* 8225FA84h */ case   46:  		/* bc 12, CR6_EQ, 20 */
		/* 8225FA84h case   46:*/		if ( regs.CR[6].eq ) { return 0x8225FA98;  }
		/* 8225FA84h case   46:*/		return 0x8225FA88;
		  /* 8225FA88h */ case   47:  		/* cmplwi CR6, R11, 3 */
		/* 8225FA88h case   47:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8225FA88h case   47:*/		return 0x8225FA8C;
		  /* 8225FA8Ch */ case   48:  		/* bc 4, CR6_LT, 20 */
		/* 8225FA8Ch case   48:*/		if ( !regs.CR[6].lt ) { return 0x8225FAA0;  }
		/* 8225FA8Ch case   48:*/		return 0x8225FA90;
		  /* 8225FA90h */ case   49:  		/* li R11, 1 */
		/* 8225FA90h case   49:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8225FA90h case   49:*/		return 0x8225FA94;
		  /* 8225FA94h */ case   50:  		/* b 16 */
		/* 8225FA94h case   50:*/		return 0x8225FAA4;
		/* 8225FA94h case   50:*/		return 0x8225FA98;
	}
	return 0x8225FA98;
} // Block from 8225F9CCh-8225FA98h (51 instructions)

//////////////////////////////////////////////////////
// Block at 8225FA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FA98);
		  /* 8225FA98h */ case    0:  		/* li R11, 0 */
		/* 8225FA98h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8225FA98h case    0:*/		return 0x8225FA9C;
		  /* 8225FA9Ch */ case    1:  		/* b 8 */
		/* 8225FA9Ch case    1:*/		return 0x8225FAA4;
		/* 8225FA9Ch case    1:*/		return 0x8225FAA0;
	}
	return 0x8225FAA0;
} // Block from 8225FA98h-8225FAA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8225FAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FAA0);
		  /* 8225FAA0h */ case    0:  		/* li R11, 2 */
		/* 8225FAA0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8225FAA0h case    0:*/		return 0x8225FAA4;
	}
	return 0x8225FAA4;
} // Block from 8225FAA0h-8225FAA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8225FAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FAA4);
		  /* 8225FAA4h */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 8225FAA4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 8225FAA4h case    0:*/		return 0x8225FAA8;
		  /* 8225FAA8h */ case    1:  		/* cmplwi CR6, R16, 0 */
		/* 8225FAA8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 8225FAA8h case    1:*/		return 0x8225FAAC;
		  /* 8225FAACh */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8225FAACh case    2:*/		if ( regs.CR[6].eq ) { return 0x8225FABC;  }
		/* 8225FAACh case    2:*/		return 0x8225FAB0;
		  /* 8225FAB0h */ case    3:  		/* mr R4, R21 */
		/* 8225FAB0h case    3:*/		regs.R4 = regs.R21;
		/* 8225FAB0h case    3:*/		return 0x8225FAB4;
		  /* 8225FAB4h */ case    4:  		/* mr R3, R30 */
		/* 8225FAB4h case    4:*/		regs.R3 = regs.R30;
		/* 8225FAB4h case    4:*/		return 0x8225FAB8;
		  /* 8225FAB8h */ case    5:  		/* bl -22536 */
		/* 8225FAB8h case    5:*/		regs.LR = 0x8225FABC; return 0x8225A2B0;
		/* 8225FAB8h case    5:*/		return 0x8225FABC;
	}
	return 0x8225FABC;
} // Block from 8225FAA4h-8225FABCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8225FABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FABC);
		  /* 8225FABCh */ case    0:  		/* stw R25, <#[R30 + 176]> */
		/* 8225FABCh case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x000000B0) );
		/* 8225FABCh case    0:*/		return 0x8225FAC0;
		  /* 8225FAC0h */ case    1:  		/* mr R4, R30 */
		/* 8225FAC0h case    1:*/		regs.R4 = regs.R30;
		/* 8225FAC0h case    1:*/		return 0x8225FAC4;
		  /* 8225FAC4h */ case    2:  		/* mr R3, R31 */
		/* 8225FAC4h case    2:*/		regs.R3 = regs.R31;
		/* 8225FAC4h case    2:*/		return 0x8225FAC8;
		  /* 8225FAC8h */ case    3:  		/* bl -169248 */
		/* 8225FAC8h case    3:*/		regs.LR = 0x8225FACC; return 0x822365A8;
		/* 8225FAC8h case    3:*/		return 0x8225FACC;
		  /* 8225FACCh */ case    4:  		/* mr R4, R30 */
		/* 8225FACCh case    4:*/		regs.R4 = regs.R30;
		/* 8225FACCh case    4:*/		return 0x8225FAD0;
		  /* 8225FAD0h */ case    5:  		/* mr R3, R14 */
		/* 8225FAD0h case    5:*/		regs.R3 = regs.R14;
		/* 8225FAD0h case    5:*/		return 0x8225FAD4;
		  /* 8225FAD4h */ case    6:  		/* bl -27556 */
		/* 8225FAD4h case    6:*/		regs.LR = 0x8225FAD8; return 0x82258F30;
		/* 8225FAD4h case    6:*/		return 0x8225FAD8;
		  /* 8225FAD8h */ case    7:  		/* mr R3, R30 */
		/* 8225FAD8h case    7:*/		regs.R3 = regs.R30;
		/* 8225FAD8h case    7:*/		return 0x8225FADC;
		  /* 8225FADCh */ case    8:  		/* bl -39708 */
		/* 8225FADCh case    8:*/		regs.LR = 0x8225FAE0; return 0x82255FC0;
		/* 8225FADCh case    8:*/		return 0x8225FAE0;
		  /* 8225FAE0h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FAE0h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FAE0h case    9:*/		return 0x8225FAE4;
		  /* 8225FAE4h */ case   10:  		/* bc 4, CR0_EQ, 28 */
		/* 8225FAE4h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8225FB00;  }
		/* 8225FAE4h case   10:*/		return 0x8225FAE8;
		  /* 8225FAE8h */ case   11:  		/* mr R6, R22 */
		/* 8225FAE8h case   11:*/		regs.R6 = regs.R22;
		/* 8225FAE8h case   11:*/		return 0x8225FAEC;
		  /* 8225FAECh */ case   12:  		/* lwz R5, <#[R1 + 392]> */
		/* 8225FAECh case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000188) );
		/* 8225FAECh case   12:*/		return 0x8225FAF0;
		  /* 8225FAF0h */ case   13:  		/* mr R4, R24 */
		/* 8225FAF0h case   13:*/		regs.R4 = regs.R24;
		/* 8225FAF0h case   13:*/		return 0x8225FAF4;
		  /* 8225FAF4h */ case   14:  		/* li R7, 2944 */
		/* 8225FAF4h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0xB80);
		/* 8225FAF4h case   14:*/		return 0x8225FAF8;
		  /* 8225FAF8h */ case   15:  		/* li R3, 0 */
		/* 8225FAF8h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225FAF8h case   15:*/		return 0x8225FAFC;
		  /* 8225FAFCh */ case   16:  		/* bl -1081076 */
		/* 8225FAFCh case   16:*/		regs.LR = 0x8225FB00; return 0x82157C08;
		/* 8225FAFCh case   16:*/		return 0x8225FB00;
	}
	return 0x8225FB00;
} // Block from 8225FABCh-8225FB00h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8225FB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FB00);
		  /* 8225FB00h */ case    0:  		/* li R3, 20 */
		/* 8225FB00h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225FB00h case    0:*/		return 0x8225FB04;
		  /* 8225FB04h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FB04h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FB04h case    1:*/		return 0x8225FB08;
		  /* 8225FB08h */ case    2:  		/* bl -39896 */
		/* 8225FB08h case    2:*/		regs.LR = 0x8225FB0C; return 0x82255F30;
		/* 8225FB08h case    2:*/		return 0x8225FB0C;
		  /* 8225FB0Ch */ case    3:  		/* mr R5, R28 */
		/* 8225FB0Ch case    3:*/		regs.R5 = regs.R28;
		/* 8225FB0Ch case    3:*/		return 0x8225FB10;
		  /* 8225FB10h */ case    4:  		/* li R4, 0 */
		/* 8225FB10h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FB10h case    4:*/		return 0x8225FB14;
		  /* 8225FB14h */ case    5:  		/* mr R30, R3 */
		/* 8225FB14h case    5:*/		regs.R30 = regs.R3;
		/* 8225FB14h case    5:*/		return 0x8225FB18;
		  /* 8225FB18h */ case    6:  		/* bl -38784 */
		/* 8225FB18h case    6:*/		regs.LR = 0x8225FB1C; return 0x82256398;
		/* 8225FB18h case    6:*/		return 0x8225FB1C;
		  /* 8225FB1Ch */ case    7:  		/* lwz R11, <#[R27 - 1304]> */
		/* 8225FB1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAE8) );
		/* 8225FB1Ch case    7:*/		return 0x8225FB20;
		  /* 8225FB20h */ case    8:  		/* mr R3, R30 */
		/* 8225FB20h case    8:*/		regs.R3 = regs.R30;
		/* 8225FB20h case    8:*/		return 0x8225FB24;
		  /* 8225FB24h */ case    9:  		/* mr R5, R29 */
		/* 8225FB24h case    9:*/		regs.R5 = regs.R29;
		/* 8225FB24h case    9:*/		return 0x8225FB28;
		  /* 8225FB28h */ case   10:  		/* li R4, 1 */
		/* 8225FB28h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225FB28h case   10:*/		return 0x8225FB2C;
		  /* 8225FB2Ch */ case   11:  		/* stw R11, <#[R30 + 128]> */
		/* 8225FB2Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225FB2Ch case   11:*/		return 0x8225FB30;
		  /* 8225FB30h */ case   12:  		/* bl -38808 */
		/* 8225FB30h case   12:*/		regs.LR = 0x8225FB34; return 0x82256398;
		/* 8225FB30h case   12:*/		return 0x8225FB34;
		  /* 8225FB34h */ case   13:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FB34h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FB34h case   13:*/		return 0x8225FB38;
		  /* 8225FB38h */ case   14:  		/* mr R3, R30 */
		/* 8225FB38h case   14:*/		regs.R3 = regs.R30;
		/* 8225FB38h case   14:*/		return 0x8225FB3C;
		  /* 8225FB3Ch */ case   15:  		/* mr R5, R18 */
		/* 8225FB3Ch case   15:*/		regs.R5 = regs.R18;
		/* 8225FB3Ch case   15:*/		return 0x8225FB40;
		  /* 8225FB40h */ case   16:  		/* li R4, 2 */
		/* 8225FB40h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225FB40h case   16:*/		return 0x8225FB44;
		  /* 8225FB44h */ case   17:  		/* stw R11, <#[R30 + 132]> */
		/* 8225FB44h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225FB44h case   17:*/		return 0x8225FB48;
		  /* 8225FB48h */ case   18:  		/* bl -38832 */
		/* 8225FB48h case   18:*/		regs.LR = 0x8225FB4C; return 0x82256398;
		/* 8225FB48h case   18:*/		return 0x8225FB4C;
		  /* 8225FB4Ch */ case   19:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FB4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FB4Ch case   19:*/		return 0x8225FB50;
		  /* 8225FB50h */ case   20:  		/* mr R3, R30 */
		/* 8225FB50h case   20:*/		regs.R3 = regs.R30;
		/* 8225FB50h case   20:*/		return 0x8225FB54;
		  /* 8225FB54h */ case   21:  		/* mr R5, R18 */
		/* 8225FB54h case   21:*/		regs.R5 = regs.R18;
		/* 8225FB54h case   21:*/		return 0x8225FB58;
		  /* 8225FB58h */ case   22:  		/* li R4, 3 */
		/* 8225FB58h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225FB58h case   22:*/		return 0x8225FB5C;
		  /* 8225FB5Ch */ case   23:  		/* stw R11, <#[R30 + 136]> */
		/* 8225FB5Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 8225FB5Ch case   23:*/		return 0x8225FB60;
		  /* 8225FB60h */ case   24:  		/* bl -38856 */
		/* 8225FB60h case   24:*/		regs.LR = 0x8225FB64; return 0x82256398;
		/* 8225FB60h case   24:*/		return 0x8225FB64;
		  /* 8225FB64h */ case   25:  		/* lwz R11, <#[R27 - 1280]> */
		/* 8225FB64h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB00) );
		/* 8225FB64h case   25:*/		return 0x8225FB68;
		  /* 8225FB68h */ case   26:  		/* mr R4, R30 */
		/* 8225FB68h case   26:*/		regs.R4 = regs.R30;
		/* 8225FB68h case   26:*/		return 0x8225FB6C;
		  /* 8225FB6Ch */ case   27:  		/* mr R3, R31 */
		/* 8225FB6Ch case   27:*/		regs.R3 = regs.R31;
		/* 8225FB6Ch case   27:*/		return 0x8225FB70;
		  /* 8225FB70h */ case   28:  		/* stw R11, <#[R30 + 140]> */
		/* 8225FB70h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000008C) );
		/* 8225FB70h case   28:*/		return 0x8225FB74;
		  /* 8225FB74h */ case   29:  		/* bl -169420 */
		/* 8225FB74h case   29:*/		regs.LR = 0x8225FB78; return 0x822365A8;
		/* 8225FB74h case   29:*/		return 0x8225FB78;
		  /* 8225FB78h */ case   30:  		/* mr R4, R30 */
		/* 8225FB78h case   30:*/		regs.R4 = regs.R30;
		/* 8225FB78h case   30:*/		return 0x8225FB7C;
		  /* 8225FB7Ch */ case   31:  		/* mr R3, R14 */
		/* 8225FB7Ch case   31:*/		regs.R3 = regs.R14;
		/* 8225FB7Ch case   31:*/		return 0x8225FB80;
		  /* 8225FB80h */ case   32:  		/* bl -27728 */
		/* 8225FB80h case   32:*/		regs.LR = 0x8225FB84; return 0x82258F30;
		/* 8225FB80h case   32:*/		return 0x8225FB84;
		  /* 8225FB84h */ case   33:  		/* mr R3, R30 */
		/* 8225FB84h case   33:*/		regs.R3 = regs.R30;
		/* 8225FB84h case   33:*/		return 0x8225FB88;
		  /* 8225FB88h */ case   34:  		/* bl -39880 */
		/* 8225FB88h case   34:*/		regs.LR = 0x8225FB8C; return 0x82255FC0;
		/* 8225FB88h case   34:*/		return 0x8225FB8C;
		  /* 8225FB8Ch */ case   35:  		/* lwz R30, <#[R1 + 244]> */
		/* 8225FB8Ch case   35:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000F4) );
		/* 8225FB8Ch case   35:*/		return 0x8225FB90;
		  /* 8225FB90h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FB90h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FB90h case   36:*/		return 0x8225FB94;
		  /* 8225FB94h */ case   37:  		/* bc 4, CR0_EQ, 28 */
		/* 8225FB94h case   37:*/		if ( !regs.CR[0].eq ) { return 0x8225FBB0;  }
		/* 8225FB94h case   37:*/		return 0x8225FB98;
		  /* 8225FB98h */ case   38:  		/* mr R6, R22 */
		/* 8225FB98h case   38:*/		regs.R6 = regs.R22;
		/* 8225FB98h case   38:*/		return 0x8225FB9C;
		  /* 8225FB9Ch */ case   39:  		/* mr R4, R24 */
		/* 8225FB9Ch case   39:*/		regs.R4 = regs.R24;
		/* 8225FB9Ch case   39:*/		return 0x8225FBA0;
		  /* 8225FBA0h */ case   40:  		/* mr R5, R30 */
		/* 8225FBA0h case   40:*/		regs.R5 = regs.R30;
		/* 8225FBA0h case   40:*/		return 0x8225FBA4;
		  /* 8225FBA4h */ case   41:  		/* li R7, 2957 */
		/* 8225FBA4h case   41:*/		cpu::op::li<0>(regs,&regs.R7,0xB8D);
		/* 8225FBA4h case   41:*/		return 0x8225FBA8;
		  /* 8225FBA8h */ case   42:  		/* li R3, 0 */
		/* 8225FBA8h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225FBA8h case   42:*/		return 0x8225FBAC;
		  /* 8225FBACh */ case   43:  		/* bl -1081252 */
		/* 8225FBACh case   43:*/		regs.LR = 0x8225FBB0; return 0x82157C08;
		/* 8225FBACh case   43:*/		return 0x8225FBB0;
	}
	return 0x8225FBB0;
} // Block from 8225FB00h-8225FBB0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225FBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FBB0);
		  /* 8225FBB0h */ case    0:  		/* li R3, 20 */
		/* 8225FBB0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225FBB0h case    0:*/		return 0x8225FBB4;
		  /* 8225FBB4h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FBB4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FBB4h case    1:*/		return 0x8225FBB8;
		  /* 8225FBB8h */ case    2:  		/* bl -40072 */
		/* 8225FBB8h case    2:*/		regs.LR = 0x8225FBBC; return 0x82255F30;
		/* 8225FBB8h case    2:*/		return 0x8225FBBC;
		  /* 8225FBBCh */ case    3:  		/* mr R5, R28 */
		/* 8225FBBCh case    3:*/		regs.R5 = regs.R28;
		/* 8225FBBCh case    3:*/		return 0x8225FBC0;
		  /* 8225FBC0h */ case    4:  		/* li R4, 0 */
		/* 8225FBC0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FBC0h case    4:*/		return 0x8225FBC4;
		  /* 8225FBC4h */ case    5:  		/* mr R26, R3 */
		/* 8225FBC4h case    5:*/		regs.R26 = regs.R3;
		/* 8225FBC4h case    5:*/		return 0x8225FBC8;
		  /* 8225FBC8h */ case    6:  		/* bl -38960 */
		/* 8225FBC8h case    6:*/		regs.LR = 0x8225FBCC; return 0x82256398;
		/* 8225FBC8h case    6:*/		return 0x8225FBCC;
		  /* 8225FBCCh */ case    7:  		/* lwz R11, <#[R27 - 1300]> */
		/* 8225FBCCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAEC) );
		/* 8225FBCCh case    7:*/		return 0x8225FBD0;
		  /* 8225FBD0h */ case    8:  		/* mr R3, R26 */
		/* 8225FBD0h case    8:*/		regs.R3 = regs.R26;
		/* 8225FBD0h case    8:*/		return 0x8225FBD4;
		  /* 8225FBD4h */ case    9:  		/* mr R5, R29 */
		/* 8225FBD4h case    9:*/		regs.R5 = regs.R29;
		/* 8225FBD4h case    9:*/		return 0x8225FBD8;
		  /* 8225FBD8h */ case   10:  		/* li R4, 1 */
		/* 8225FBD8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225FBD8h case   10:*/		return 0x8225FBDC;
		  /* 8225FBDCh */ case   11:  		/* stw R11, <#[R26 + 128]> */
		/* 8225FBDCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000080) );
		/* 8225FBDCh case   11:*/		return 0x8225FBE0;
		  /* 8225FBE0h */ case   12:  		/* bl -38984 */
		/* 8225FBE0h case   12:*/		regs.LR = 0x8225FBE4; return 0x82256398;
		/* 8225FBE0h case   12:*/		return 0x8225FBE4;
		  /* 8225FBE4h */ case   13:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FBE4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FBE4h case   13:*/		return 0x8225FBE8;
		  /* 8225FBE8h */ case   14:  		/* mr R3, R26 */
		/* 8225FBE8h case   14:*/		regs.R3 = regs.R26;
		/* 8225FBE8h case   14:*/		return 0x8225FBEC;
		  /* 8225FBECh */ case   15:  		/* mr R5, R18 */
		/* 8225FBECh case   15:*/		regs.R5 = regs.R18;
		/* 8225FBECh case   15:*/		return 0x8225FBF0;
		  /* 8225FBF0h */ case   16:  		/* li R4, 2 */
		/* 8225FBF0h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225FBF0h case   16:*/		return 0x8225FBF4;
		  /* 8225FBF4h */ case   17:  		/* stw R11, <#[R26 + 132]> */
		/* 8225FBF4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000084) );
		/* 8225FBF4h case   17:*/		return 0x8225FBF8;
		  /* 8225FBF8h */ case   18:  		/* bl -39008 */
		/* 8225FBF8h case   18:*/		regs.LR = 0x8225FBFC; return 0x82256398;
		/* 8225FBF8h case   18:*/		return 0x8225FBFC;
		  /* 8225FBFCh */ case   19:  		/* lwz R11, <#[R27 - 1276]> */
		/* 8225FBFCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 8225FBFCh case   19:*/		return 0x8225FC00;
		  /* 8225FC00h */ case   20:  		/* mr R3, R26 */
		/* 8225FC00h case   20:*/		regs.R3 = regs.R26;
		/* 8225FC00h case   20:*/		return 0x8225FC04;
		  /* 8225FC04h */ case   21:  		/* mr R5, R18 */
		/* 8225FC04h case   21:*/		regs.R5 = regs.R18;
		/* 8225FC04h case   21:*/		return 0x8225FC08;
		  /* 8225FC08h */ case   22:  		/* li R4, 3 */
		/* 8225FC08h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225FC08h case   22:*/		return 0x8225FC0C;
		  /* 8225FC0Ch */ case   23:  		/* stw R11, <#[R26 + 136]> */
		/* 8225FC0Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000088) );
		/* 8225FC0Ch case   23:*/		return 0x8225FC10;
		  /* 8225FC10h */ case   24:  		/* bl -39032 */
		/* 8225FC10h case   24:*/		regs.LR = 0x8225FC14; return 0x82256398;
		/* 8225FC10h case   24:*/		return 0x8225FC14;
		  /* 8225FC14h */ case   25:  		/* lwz R11, <#[R27 - 1272]> */
		/* 8225FC14h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB08) );
		/* 8225FC14h case   25:*/		return 0x8225FC18;
		  /* 8225FC18h */ case   26:  		/* mr R4, R26 */
		/* 8225FC18h case   26:*/		regs.R4 = regs.R26;
		/* 8225FC18h case   26:*/		return 0x8225FC1C;
		  /* 8225FC1Ch */ case   27:  		/* mr R3, R31 */
		/* 8225FC1Ch case   27:*/		regs.R3 = regs.R31;
		/* 8225FC1Ch case   27:*/		return 0x8225FC20;
		  /* 8225FC20h */ case   28:  		/* stw R11, <#[R26 + 140]> */
		/* 8225FC20h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000008C) );
		/* 8225FC20h case   28:*/		return 0x8225FC24;
		  /* 8225FC24h */ case   29:  		/* bl -169596 */
		/* 8225FC24h case   29:*/		regs.LR = 0x8225FC28; return 0x822365A8;
		/* 8225FC24h case   29:*/		return 0x8225FC28;
		  /* 8225FC28h */ case   30:  		/* mr R4, R26 */
		/* 8225FC28h case   30:*/		regs.R4 = regs.R26;
		/* 8225FC28h case   30:*/		return 0x8225FC2C;
		  /* 8225FC2Ch */ case   31:  		/* mr R3, R14 */
		/* 8225FC2Ch case   31:*/		regs.R3 = regs.R14;
		/* 8225FC2Ch case   31:*/		return 0x8225FC30;
		  /* 8225FC30h */ case   32:  		/* bl -27904 */
		/* 8225FC30h case   32:*/		regs.LR = 0x8225FC34; return 0x82258F30;
		/* 8225FC30h case   32:*/		return 0x8225FC34;
		  /* 8225FC34h */ case   33:  		/* mr R3, R26 */
		/* 8225FC34h case   33:*/		regs.R3 = regs.R26;
		/* 8225FC34h case   33:*/		return 0x8225FC38;
		  /* 8225FC38h */ case   34:  		/* bl -40056 */
		/* 8225FC38h case   34:*/		regs.LR = 0x8225FC3C; return 0x82255FC0;
		/* 8225FC38h case   34:*/		return 0x8225FC3C;
		  /* 8225FC3Ch */ case   35:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FC3Ch case   35:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FC3Ch case   35:*/		return 0x8225FC40;
		  /* 8225FC40h */ case   36:  		/* bc 4, CR0_EQ, 28 */
		/* 8225FC40h case   36:*/		if ( !regs.CR[0].eq ) { return 0x8225FC5C;  }
		/* 8225FC40h case   36:*/		return 0x8225FC44;
		  /* 8225FC44h */ case   37:  		/* mr R6, R22 */
		/* 8225FC44h case   37:*/		regs.R6 = regs.R22;
		/* 8225FC44h case   37:*/		return 0x8225FC48;
		  /* 8225FC48h */ case   38:  		/* mr R5, R30 */
		/* 8225FC48h case   38:*/		regs.R5 = regs.R30;
		/* 8225FC48h case   38:*/		return 0x8225FC4C;
		  /* 8225FC4Ch */ case   39:  		/* mr R4, R24 */
		/* 8225FC4Ch case   39:*/		regs.R4 = regs.R24;
		/* 8225FC4Ch case   39:*/		return 0x8225FC50;
		  /* 8225FC50h */ case   40:  		/* li R7, 2970 */
		/* 8225FC50h case   40:*/		cpu::op::li<0>(regs,&regs.R7,0xB9A);
		/* 8225FC50h case   40:*/		return 0x8225FC54;
		  /* 8225FC54h */ case   41:  		/* li R3, 0 */
		/* 8225FC54h case   41:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225FC54h case   41:*/		return 0x8225FC58;
		  /* 8225FC58h */ case   42:  		/* bl -1081424 */
		/* 8225FC58h case   42:*/		regs.LR = 0x8225FC5C; return 0x82157C08;
		/* 8225FC58h case   42:*/		return 0x8225FC5C;
	}
	return 0x8225FC5C;
} // Block from 8225FBB0h-8225FC5Ch (43 instructions)

//////////////////////////////////////////////////////
// Block at 8225FC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FC5C);
		  /* 8225FC5Ch */ case    0:  		/* li R3, 20 */
		/* 8225FC5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 8225FC5Ch case    0:*/		return 0x8225FC60;
		  /* 8225FC60h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FC60h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FC60h case    1:*/		return 0x8225FC64;
		  /* 8225FC64h */ case    2:  		/* bl -40244 */
		/* 8225FC64h case    2:*/		regs.LR = 0x8225FC68; return 0x82255F30;
		/* 8225FC64h case    2:*/		return 0x8225FC68;
		  /* 8225FC68h */ case    3:  		/* mr R5, R18 */
		/* 8225FC68h case    3:*/		regs.R5 = regs.R18;
		/* 8225FC68h case    3:*/		return 0x8225FC6C;
		  /* 8225FC6Ch */ case    4:  		/* li R4, 0 */
		/* 8225FC6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FC6Ch case    4:*/		return 0x8225FC70;
		  /* 8225FC70h */ case    5:  		/* mr R26, R3 */
		/* 8225FC70h case    5:*/		regs.R26 = regs.R3;
		/* 8225FC70h case    5:*/		return 0x8225FC74;
		  /* 8225FC74h */ case    6:  		/* bl -39132 */
		/* 8225FC74h case    6:*/		regs.LR = 0x8225FC78; return 0x82256398;
		/* 8225FC74h case    6:*/		return 0x8225FC78;
		  /* 8225FC78h */ case    7:  		/* lwz R11, <#[R27 - 1300]> */
		/* 8225FC78h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAEC) );
		/* 8225FC78h case    7:*/		return 0x8225FC7C;
		  /* 8225FC7Ch */ case    8:  		/* mr R3, R26 */
		/* 8225FC7Ch case    8:*/		regs.R3 = regs.R26;
		/* 8225FC7Ch case    8:*/		return 0x8225FC80;
		  /* 8225FC80h */ case    9:  		/* mr R5, R29 */
		/* 8225FC80h case    9:*/		regs.R5 = regs.R29;
		/* 8225FC80h case    9:*/		return 0x8225FC84;
		  /* 8225FC84h */ case   10:  		/* li R4, 1 */
		/* 8225FC84h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225FC84h case   10:*/		return 0x8225FC88;
		  /* 8225FC88h */ case   11:  		/* stw R11, <#[R26 + 128]> */
		/* 8225FC88h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000080) );
		/* 8225FC88h case   11:*/		return 0x8225FC8C;
		  /* 8225FC8Ch */ case   12:  		/* bl -39156 */
		/* 8225FC8Ch case   12:*/		regs.LR = 0x8225FC90; return 0x82256398;
		/* 8225FC8Ch case   12:*/		return 0x8225FC90;
		  /* 8225FC90h */ case   13:  		/* lwz R11, <#[R27 - 1280]> */
		/* 8225FC90h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB00) );
		/* 8225FC90h case   13:*/		return 0x8225FC94;
		  /* 8225FC94h */ case   14:  		/* mr R3, R26 */
		/* 8225FC94h case   14:*/		regs.R3 = regs.R26;
		/* 8225FC94h case   14:*/		return 0x8225FC98;
		  /* 8225FC98h */ case   15:  		/* mr R5, R28 */
		/* 8225FC98h case   15:*/		regs.R5 = regs.R28;
		/* 8225FC98h case   15:*/		return 0x8225FC9C;
		  /* 8225FC9Ch */ case   16:  		/* li R4, 2 */
		/* 8225FC9Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8225FC9Ch case   16:*/		return 0x8225FCA0;
		  /* 8225FCA0h */ case   17:  		/* stw R11, <#[R26 + 132]> */
		/* 8225FCA0h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000084) );
		/* 8225FCA0h case   17:*/		return 0x8225FCA4;
		  /* 8225FCA4h */ case   18:  		/* bl -39180 */
		/* 8225FCA4h case   18:*/		regs.LR = 0x8225FCA8; return 0x82256398;
		/* 8225FCA4h case   18:*/		return 0x8225FCA8;
		  /* 8225FCA8h */ case   19:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FCA8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FCA8h case   19:*/		return 0x8225FCAC;
		  /* 8225FCACh */ case   20:  		/* mr R3, R26 */
		/* 8225FCACh case   20:*/		regs.R3 = regs.R26;
		/* 8225FCACh case   20:*/		return 0x8225FCB0;
		  /* 8225FCB0h */ case   21:  		/* mr R5, R28 */
		/* 8225FCB0h case   21:*/		regs.R5 = regs.R28;
		/* 8225FCB0h case   21:*/		return 0x8225FCB4;
		  /* 8225FCB4h */ case   22:  		/* li R4, 3 */
		/* 8225FCB4h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8225FCB4h case   22:*/		return 0x8225FCB8;
		  /* 8225FCB8h */ case   23:  		/* stw R11, <#[R26 + 136]> */
		/* 8225FCB8h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000088) );
		/* 8225FCB8h case   23:*/		return 0x8225FCBC;
		  /* 8225FCBCh */ case   24:  		/* bl -39204 */
		/* 8225FCBCh case   24:*/		regs.LR = 0x8225FCC0; return 0x82256398;
		/* 8225FCBCh case   24:*/		return 0x8225FCC0;
		  /* 8225FCC0h */ case   25:  		/* lwz R11, <#[R27 - 1280]> */
		/* 8225FCC0h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB00) );
		/* 8225FCC0h case   25:*/		return 0x8225FCC4;
		  /* 8225FCC4h */ case   26:  		/* mr R4, R26 */
		/* 8225FCC4h case   26:*/		regs.R4 = regs.R26;
		/* 8225FCC4h case   26:*/		return 0x8225FCC8;
		  /* 8225FCC8h */ case   27:  		/* mr R3, R31 */
		/* 8225FCC8h case   27:*/		regs.R3 = regs.R31;
		/* 8225FCC8h case   27:*/		return 0x8225FCCC;
		  /* 8225FCCCh */ case   28:  		/* stw R11, <#[R26 + 140]> */
		/* 8225FCCCh case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000008C) );
		/* 8225FCCCh case   28:*/		return 0x8225FCD0;
		  /* 8225FCD0h */ case   29:  		/* bl -169768 */
		/* 8225FCD0h case   29:*/		regs.LR = 0x8225FCD4; return 0x822365A8;
		/* 8225FCD0h case   29:*/		return 0x8225FCD4;
		  /* 8225FCD4h */ case   30:  		/* mr R4, R26 */
		/* 8225FCD4h case   30:*/		regs.R4 = regs.R26;
		/* 8225FCD4h case   30:*/		return 0x8225FCD8;
		  /* 8225FCD8h */ case   31:  		/* mr R3, R14 */
		/* 8225FCD8h case   31:*/		regs.R3 = regs.R14;
		/* 8225FCD8h case   31:*/		return 0x8225FCDC;
		  /* 8225FCDCh */ case   32:  		/* bl -28076 */
		/* 8225FCDCh case   32:*/		regs.LR = 0x8225FCE0; return 0x82258F30;
		/* 8225FCDCh case   32:*/		return 0x8225FCE0;
		  /* 8225FCE0h */ case   33:  		/* mr R3, R26 */
		/* 8225FCE0h case   33:*/		regs.R3 = regs.R26;
		/* 8225FCE0h case   33:*/		return 0x8225FCE4;
		  /* 8225FCE4h */ case   34:  		/* bl -40228 */
		/* 8225FCE4h case   34:*/		regs.LR = 0x8225FCE8; return 0x82255FC0;
		/* 8225FCE4h case   34:*/		return 0x8225FCE8;
		  /* 8225FCE8h */ case   35:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FCE8h case   35:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FCE8h case   35:*/		return 0x8225FCEC;
		  /* 8225FCECh */ case   36:  		/* bc 4, CR0_EQ, 28 */
		/* 8225FCECh case   36:*/		if ( !regs.CR[0].eq ) { return 0x8225FD08;  }
		/* 8225FCECh case   36:*/		return 0x8225FCF0;
		  /* 8225FCF0h */ case   37:  		/* mr R6, R22 */
		/* 8225FCF0h case   37:*/		regs.R6 = regs.R22;
		/* 8225FCF0h case   37:*/		return 0x8225FCF4;
		  /* 8225FCF4h */ case   38:  		/* mr R5, R30 */
		/* 8225FCF4h case   38:*/		regs.R5 = regs.R30;
		/* 8225FCF4h case   38:*/		return 0x8225FCF8;
		  /* 8225FCF8h */ case   39:  		/* mr R4, R24 */
		/* 8225FCF8h case   39:*/		regs.R4 = regs.R24;
		/* 8225FCF8h case   39:*/		return 0x8225FCFC;
		  /* 8225FCFCh */ case   40:  		/* li R7, 2983 */
		/* 8225FCFCh case   40:*/		cpu::op::li<0>(regs,&regs.R7,0xBA7);
		/* 8225FCFCh case   40:*/		return 0x8225FD00;
		  /* 8225FD00h */ case   41:  		/* li R3, 0 */
		/* 8225FD00h case   41:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225FD00h case   41:*/		return 0x8225FD04;
		  /* 8225FD04h */ case   42:  		/* bl -1081596 */
		/* 8225FD04h case   42:*/		regs.LR = 0x8225FD08; return 0x82157C08;
		/* 8225FD04h case   42:*/		return 0x8225FD08;
	}
	return 0x8225FD08;
} // Block from 8225FC5Ch-8225FD08h (43 instructions)

//////////////////////////////////////////////////////
// Block at 8225FD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FD08);
		  /* 8225FD08h */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225FD08h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FD08h case    0:*/		return 0x8225FD0C;
		  /* 8225FD0Ch */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225FD0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225FD0Ch case    1:*/		return 0x8225FD10;
		  /* 8225FD10h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8225FD10h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225FD10h case    2:*/		return 0x8225FD14;
		  /* 8225FD14h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225FD14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225FD14h case    3:*/		return 0x8225FD18;
		  /* 8225FD18h */ case    4:  		/* mtspr CTR, R11 */
		/* 8225FD18h case    4:*/		regs.CTR = regs.R11;
		/* 8225FD18h case    4:*/		return 0x8225FD1C;
		  /* 8225FD1Ch */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8225FD1Ch case    5:*/		if ( 1 ) { regs.LR = 0x8225FD20; return (uint32)regs.CTR; }
		/* 8225FD1Ch case    5:*/		return 0x8225FD20;
		  /* 8225FD20h */ case    6:  		/* lis R11, -32222 */
		/* 8225FD20h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225FD20h case    6:*/		return 0x8225FD24;
		  /* 8225FD24h */ case    7:  		/* mr R5, R3 */
		/* 8225FD24h case    7:*/		regs.R5 = regs.R3;
		/* 8225FD24h case    7:*/		return 0x8225FD28;
		  /* 8225FD28h */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225FD28h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225FD28h case    8:*/		return 0x8225FD2C;
		  /* 8225FD2Ch */ case    9:  		/* mr R4, R25 */
		/* 8225FD2Ch case    9:*/		regs.R4 = regs.R25;
		/* 8225FD2Ch case    9:*/		return 0x8225FD30;
		  /* 8225FD30h */ case   10:  		/* addi R6, R11, -12392 */
		/* 8225FD30h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225FD30h case   10:*/		return 0x8225FD34;
		  /* 8225FD34h */ case   11:  		/* mr R7, R30 */
		/* 8225FD34h case   11:*/		regs.R7 = regs.R30;
		/* 8225FD34h case   11:*/		return 0x8225FD38;
		  /* 8225FD38h */ case   12:  		/* bl -189152 */
		/* 8225FD38h case   12:*/		regs.LR = 0x8225FD3C; return 0x82231A58;
		/* 8225FD38h case   12:*/		return 0x8225FD3C;
		  /* 8225FD3Ch */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 8225FD3Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225FD3Ch case   13:*/		return 0x8225FD40;
		  /* 8225FD40h */ case   14:  		/* bc 4, CR6_EQ, 236 */
		/* 8225FD40h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8225FE2C;  }
		/* 8225FD40h case   14:*/		return 0x8225FD44;
		  /* 8225FD44h */ case   15:  		/* li R3, 49 */
		/* 8225FD44h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225FD44h case   15:*/		return 0x8225FD48;
		  /* 8225FD48h */ case   16:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FD48h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FD48h case   16:*/		return 0x8225FD4C;
		  /* 8225FD4Ch */ case   17:  		/* bl -40476 */
		/* 8225FD4Ch case   17:*/		regs.LR = 0x8225FD50; return 0x82255F30;
		/* 8225FD4Ch case   17:*/		return 0x8225FD50;
		  /* 8225FD50h */ case   18:  		/* mr R5, R18 */
		/* 8225FD50h case   18:*/		regs.R5 = regs.R18;
		/* 8225FD50h case   18:*/		return 0x8225FD54;
		  /* 8225FD54h */ case   19:  		/* li R4, 0 */
		/* 8225FD54h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FD54h case   19:*/		return 0x8225FD58;
		  /* 8225FD58h */ case   20:  		/* mr R30, R3 */
		/* 8225FD58h case   20:*/		regs.R30 = regs.R3;
		/* 8225FD58h case   20:*/		return 0x8225FD5C;
		  /* 8225FD5Ch */ case   21:  		/* bl -39364 */
		/* 8225FD5Ch case   21:*/		regs.LR = 0x8225FD60; return 0x82256398;
		/* 8225FD5Ch case   21:*/		return 0x8225FD60;
		  /* 8225FD60h */ case   22:  		/* mr R3, R30 */
		/* 8225FD60h case   22:*/		regs.R3 = regs.R30;
		/* 8225FD60h case   22:*/		return 0x8225FD64;
		  /* 8225FD64h */ case   23:  		/* mr R5, R18 */
		/* 8225FD64h case   23:*/		regs.R5 = regs.R18;
		/* 8225FD64h case   23:*/		return 0x8225FD68;
		  /* 8225FD68h */ case   24:  		/* li R4, 1 */
		/* 8225FD68h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8225FD68h case   24:*/		return 0x8225FD6C;
		  /* 8225FD6Ch */ case   25:  		/* bl -39380 */
		/* 8225FD6Ch case   25:*/		regs.LR = 0x8225FD70; return 0x82256398;
		/* 8225FD6Ch case   25:*/		return 0x8225FD70;
		  /* 8225FD70h */ case   26:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FD70h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FD70h case   26:*/		return 0x8225FD74;
		  /* 8225FD74h */ case   27:  		/* mr R4, R30 */
		/* 8225FD74h case   27:*/		regs.R4 = regs.R30;
		/* 8225FD74h case   27:*/		return 0x8225FD78;
		  /* 8225FD78h */ case   28:  		/* mr R3, R31 */
		/* 8225FD78h case   28:*/		regs.R3 = regs.R31;
		/* 8225FD78h case   28:*/		return 0x8225FD7C;
		  /* 8225FD7Ch */ case   29:  		/* stw R11, <#[R30 + 132]> */
		/* 8225FD7Ch case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225FD7Ch case   29:*/		return 0x8225FD80;
		  /* 8225FD80h */ case   30:  		/* bl -169944 */
		/* 8225FD80h case   30:*/		regs.LR = 0x8225FD84; return 0x822365A8;
		/* 8225FD80h case   30:*/		return 0x8225FD84;
		  /* 8225FD84h */ case   31:  		/* mr R4, R30 */
		/* 8225FD84h case   31:*/		regs.R4 = regs.R30;
		/* 8225FD84h case   31:*/		return 0x8225FD88;
		  /* 8225FD88h */ case   32:  		/* mr R3, R14 */
		/* 8225FD88h case   32:*/		regs.R3 = regs.R14;
		/* 8225FD88h case   32:*/		return 0x8225FD8C;
		  /* 8225FD8Ch */ case   33:  		/* bl -28252 */
		/* 8225FD8Ch case   33:*/		regs.LR = 0x8225FD90; return 0x82258F30;
		/* 8225FD8Ch case   33:*/		return 0x8225FD90;
		  /* 8225FD90h */ case   34:  		/* mr R3, R30 */
		/* 8225FD90h case   34:*/		regs.R3 = regs.R30;
		/* 8225FD90h case   34:*/		return 0x8225FD94;
		  /* 8225FD94h */ case   35:  		/* bl -40404 */
		/* 8225FD94h case   35:*/		regs.LR = 0x8225FD98; return 0x82255FC0;
		/* 8225FD94h case   35:*/		return 0x8225FD98;
		  /* 8225FD98h */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FD98h case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FD98h case   36:*/		return 0x8225FD9C;
		  /* 8225FD9Ch */ case   37:  		/* bc 4, CR0_EQ, 28 */
		/* 8225FD9Ch case   37:*/		if ( !regs.CR[0].eq ) { return 0x8225FDB8;  }
		/* 8225FD9Ch case   37:*/		return 0x8225FDA0;
		  /* 8225FDA0h */ case   38:  		/* mr R6, R22 */
		/* 8225FDA0h case   38:*/		regs.R6 = regs.R22;
		/* 8225FDA0h case   38:*/		return 0x8225FDA4;
		  /* 8225FDA4h */ case   39:  		/* lwz R5, <#[R1 + 256]> */
		/* 8225FDA4h case   39:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000100) );
		/* 8225FDA4h case   39:*/		return 0x8225FDA8;
		  /* 8225FDA8h */ case   40:  		/* mr R4, R24 */
		/* 8225FDA8h case   40:*/		regs.R4 = regs.R24;
		/* 8225FDA8h case   40:*/		return 0x8225FDAC;
		  /* 8225FDACh */ case   41:  		/* li R7, 2996 */
		/* 8225FDACh case   41:*/		cpu::op::li<0>(regs,&regs.R7,0xBB4);
		/* 8225FDACh case   41:*/		return 0x8225FDB0;
		  /* 8225FDB0h */ case   42:  		/* li R3, 0 */
		/* 8225FDB0h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225FDB0h case   42:*/		return 0x8225FDB4;
		  /* 8225FDB4h */ case   43:  		/* bl -1081772 */
		/* 8225FDB4h case   43:*/		regs.LR = 0x8225FDB8; return 0x82157C08;
		/* 8225FDB4h case   43:*/		return 0x8225FDB8;
	}
	return 0x8225FDB8;
} // Block from 8225FD08h-8225FDB8h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225FDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FDB8);
		  /* 8225FDB8h */ case    0:  		/* li R3, 49 */
		/* 8225FDB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225FDB8h case    0:*/		return 0x8225FDBC;
		  /* 8225FDBCh */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FDBCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FDBCh case    1:*/		return 0x8225FDC0;
		  /* 8225FDC0h */ case    2:  		/* bl -40592 */
		/* 8225FDC0h case    2:*/		regs.LR = 0x8225FDC4; return 0x82255F30;
		/* 8225FDC0h case    2:*/		return 0x8225FDC4;
		  /* 8225FDC4h */ case    3:  		/* mr R5, R18 */
		/* 8225FDC4h case    3:*/		regs.R5 = regs.R18;
		/* 8225FDC4h case    3:*/		return 0x8225FDC8;
		  /* 8225FDC8h */ case    4:  		/* li R4, 0 */
		/* 8225FDC8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FDC8h case    4:*/		return 0x8225FDCC;
		  /* 8225FDCCh */ case    5:  		/* mr R30, R3 */
		/* 8225FDCCh case    5:*/		regs.R30 = regs.R3;
		/* 8225FDCCh case    5:*/		return 0x8225FDD0;
		  /* 8225FDD0h */ case    6:  		/* bl -39480 */
		/* 8225FDD0h case    6:*/		regs.LR = 0x8225FDD4; return 0x82256398;
		/* 8225FDD0h case    6:*/		return 0x8225FDD4;
		  /* 8225FDD4h */ case    7:  		/* lwz R11, <#[R27 - 1292]> */
		/* 8225FDD4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF4) );
		/* 8225FDD4h case    7:*/		return 0x8225FDD8;
		  /* 8225FDD8h */ case    8:  		/* mr R3, R30 */
		/* 8225FDD8h case    8:*/		regs.R3 = regs.R30;
		/* 8225FDD8h case    8:*/		return 0x8225FDDC;
		  /* 8225FDDCh */ case    9:  		/* fmr FR4, FR31 */
		/* 8225FDDCh case    9:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8225FDDCh case    9:*/		return 0x8225FDE0;
		  /* 8225FDE0h */ case   10:  		/* li R5, 1 */
		/* 8225FDE0h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225FDE0h case   10:*/		return 0x8225FDE4;
		  /* 8225FDE4h */ case   11:  		/* fmr FR3, FR31 */
		/* 8225FDE4h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 8225FDE4h case   11:*/		return 0x8225FDE8;
		  /* 8225FDE8h */ case   12:  		/* mr R4, R31 */
		/* 8225FDE8h case   12:*/		regs.R4 = regs.R31;
		/* 8225FDE8h case   12:*/		return 0x8225FDEC;
		  /* 8225FDECh */ case   13:  		/* fmr FR2, FR31 */
		/* 8225FDECh case   13:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 8225FDECh case   13:*/		return 0x8225FDF0;
		  /* 8225FDF0h */ case   14:  		/* fmr FR1, FR31 */
		/* 8225FDF0h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8225FDF0h case   14:*/		return 0x8225FDF4;
		  /* 8225FDF4h */ case   15:  		/* stw R11, <#[R30 + 128]> */
		/* 8225FDF4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8225FDF4h case   15:*/		return 0x8225FDF8;
		  /* 8225FDF8h */ case   16:  		/* bl -36576 */
		/* 8225FDF8h case   16:*/		regs.LR = 0x8225FDFC; return 0x82256F18;
		/* 8225FDF8h case   16:*/		return 0x8225FDFC;
		  /* 8225FDFCh */ case   17:  		/* mr R4, R30 */
		/* 8225FDFCh case   17:*/		regs.R4 = regs.R30;
		/* 8225FDFCh case   17:*/		return 0x8225FE00;
		  /* 8225FE00h */ case   18:  		/* mr R3, R31 */
		/* 8225FE00h case   18:*/		regs.R3 = regs.R31;
		/* 8225FE00h case   18:*/		return 0x8225FE04;
		  /* 8225FE04h */ case   19:  		/* bl -170076 */
		/* 8225FE04h case   19:*/		regs.LR = 0x8225FE08; return 0x822365A8;
		/* 8225FE04h case   19:*/		return 0x8225FE08;
		  /* 8225FE08h */ case   20:  		/* mr R4, R30 */
		/* 8225FE08h case   20:*/		regs.R4 = regs.R30;
		/* 8225FE08h case   20:*/		return 0x8225FE0C;
		  /* 8225FE0Ch */ case   21:  		/* mr R3, R14 */
		/* 8225FE0Ch case   21:*/		regs.R3 = regs.R14;
		/* 8225FE0Ch case   21:*/		return 0x8225FE10;
		  /* 8225FE10h */ case   22:  		/* bl -28384 */
		/* 8225FE10h case   22:*/		regs.LR = 0x8225FE14; return 0x82258F30;
		/* 8225FE10h case   22:*/		return 0x8225FE14;
		  /* 8225FE14h */ case   23:  		/* mr R3, R30 */
		/* 8225FE14h case   23:*/		regs.R3 = regs.R30;
		/* 8225FE14h case   23:*/		return 0x8225FE18;
		  /* 8225FE18h */ case   24:  		/* bl -40536 */
		/* 8225FE18h case   24:*/		regs.LR = 0x8225FE1C; return 0x82255FC0;
		/* 8225FE18h case   24:*/		return 0x8225FE1C;
		  /* 8225FE1Ch */ case   25:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FE1Ch case   25:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FE1Ch case   25:*/		return 0x8225FE20;
		  /* 8225FE20h */ case   26:  		/* bc 4, CR0_EQ, -3976 */
		/* 8225FE20h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8225EE98;  }
		/* 8225FE20h case   26:*/		return 0x8225FE24;
		  /* 8225FE24h */ case   27:  		/* li R7, 3004 */
		/* 8225FE24h case   27:*/		cpu::op::li<0>(regs,&regs.R7,0xBBC);
		/* 8225FE24h case   27:*/		return 0x8225FE28;
		  /* 8225FE28h */ case   28:  		/* b 476 */
		/* 8225FE28h case   28:*/		return 0x82260004;
		/* 8225FE28h case   28:*/		return 0x8225FE2C;
	}
	return 0x8225FE2C;
} // Block from 8225FDB8h-8225FE2Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 8225FE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FE2C);
		  /* 8225FE2Ch */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225FE2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FE2Ch case    0:*/		return 0x8225FE30;
		  /* 8225FE30h */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225FE30h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225FE30h case    1:*/		return 0x8225FE34;
		  /* 8225FE34h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8225FE34h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225FE34h case    2:*/		return 0x8225FE38;
		  /* 8225FE38h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225FE38h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225FE38h case    3:*/		return 0x8225FE3C;
		  /* 8225FE3Ch */ case    4:  		/* mtspr CTR, R11 */
		/* 8225FE3Ch case    4:*/		regs.CTR = regs.R11;
		/* 8225FE3Ch case    4:*/		return 0x8225FE40;
		  /* 8225FE40h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8225FE40h case    5:*/		if ( 1 ) { regs.LR = 0x8225FE44; return (uint32)regs.CTR; }
		/* 8225FE40h case    5:*/		return 0x8225FE44;
		  /* 8225FE44h */ case    6:  		/* lis R11, -32222 */
		/* 8225FE44h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225FE44h case    6:*/		return 0x8225FE48;
		  /* 8225FE48h */ case    7:  		/* mr R5, R3 */
		/* 8225FE48h case    7:*/		regs.R5 = regs.R3;
		/* 8225FE48h case    7:*/		return 0x8225FE4C;
		  /* 8225FE4Ch */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225FE4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225FE4Ch case    8:*/		return 0x8225FE50;
		  /* 8225FE50h */ case    9:  		/* mr R4, R25 */
		/* 8225FE50h case    9:*/		regs.R4 = regs.R25;
		/* 8225FE50h case    9:*/		return 0x8225FE54;
		  /* 8225FE54h */ case   10:  		/* addi R6, R11, -12392 */
		/* 8225FE54h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225FE54h case   10:*/		return 0x8225FE58;
		  /* 8225FE58h */ case   11:  		/* mr R7, R30 */
		/* 8225FE58h case   11:*/		regs.R7 = regs.R30;
		/* 8225FE58h case   11:*/		return 0x8225FE5C;
		  /* 8225FE5Ch */ case   12:  		/* bl -189148 */
		/* 8225FE5Ch case   12:*/		regs.LR = 0x8225FE60; return 0x82231B80;
		/* 8225FE5Ch case   12:*/		return 0x8225FE60;
		  /* 8225FE60h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 8225FE60h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225FE60h case   13:*/		return 0x8225FE64;
		  /* 8225FE64h */ case   14:  		/* bc 4, CR6_EQ, 104 */
		/* 8225FE64h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8225FECC;  }
		/* 8225FE64h case   14:*/		return 0x8225FE68;
		  /* 8225FE68h */ case   15:  		/* li R3, 49 */
		/* 8225FE68h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225FE68h case   15:*/		return 0x8225FE6C;
		  /* 8225FE6Ch */ case   16:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FE6Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FE6Ch case   16:*/		return 0x8225FE70;
		  /* 8225FE70h */ case   17:  		/* bl -40768 */
		/* 8225FE70h case   17:*/		regs.LR = 0x8225FE74; return 0x82255F30;
		/* 8225FE70h case   17:*/		return 0x8225FE74;
		  /* 8225FE74h */ case   18:  		/* mr R5, R18 */
		/* 8225FE74h case   18:*/		regs.R5 = regs.R18;
		/* 8225FE74h case   18:*/		return 0x8225FE78;
		  /* 8225FE78h */ case   19:  		/* li R4, 0 */
		/* 8225FE78h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FE78h case   19:*/		return 0x8225FE7C;
		  /* 8225FE7Ch */ case   20:  		/* mr R30, R3 */
		/* 8225FE7Ch case   20:*/		regs.R30 = regs.R3;
		/* 8225FE7Ch case   20:*/		return 0x8225FE80;
		  /* 8225FE80h */ case   21:  		/* bl -39656 */
		/* 8225FE80h case   21:*/		regs.LR = 0x8225FE84; return 0x82256398;
		/* 8225FE80h case   21:*/		return 0x8225FE84;
		  /* 8225FE84h */ case   22:  		/* mr R3, R30 */
		/* 8225FE84h case   22:*/		regs.R3 = regs.R30;
		/* 8225FE84h case   22:*/		return 0x8225FE88;
		  /* 8225FE88h */ case   23:  		/* mr R5, R18 */
		/* 8225FE88h case   23:*/		regs.R5 = regs.R18;
		/* 8225FE88h case   23:*/		return 0x8225FE8C;
		  /* 8225FE8Ch */ case   24:  		/* li R4, 0 */
		/* 8225FE8Ch case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FE8Ch case   24:*/		return 0x8225FE90;
		  /* 8225FE90h */ case   25:  		/* bl -39672 */
		/* 8225FE90h case   25:*/		regs.LR = 0x8225FE94; return 0x82256398;
		/* 8225FE90h case   25:*/		return 0x8225FE94;
		  /* 8225FE94h */ case   26:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FE94h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FE94h case   26:*/		return 0x8225FE98;
		  /* 8225FE98h */ case   27:  		/* mr R4, R30 */
		/* 8225FE98h case   27:*/		regs.R4 = regs.R30;
		/* 8225FE98h case   27:*/		return 0x8225FE9C;
		  /* 8225FE9Ch */ case   28:  		/* mr R3, R31 */
		/* 8225FE9Ch case   28:*/		regs.R3 = regs.R31;
		/* 8225FE9Ch case   28:*/		return 0x8225FEA0;
		  /* 8225FEA0h */ case   29:  		/* stw R11, <#[R30 + 132]> */
		/* 8225FEA0h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225FEA0h case   29:*/		return 0x8225FEA4;
		  /* 8225FEA4h */ case   30:  		/* bl -170236 */
		/* 8225FEA4h case   30:*/		regs.LR = 0x8225FEA8; return 0x822365A8;
		/* 8225FEA4h case   30:*/		return 0x8225FEA8;
		  /* 8225FEA8h */ case   31:  		/* mr R4, R30 */
		/* 8225FEA8h case   31:*/		regs.R4 = regs.R30;
		/* 8225FEA8h case   31:*/		return 0x8225FEAC;
		  /* 8225FEACh */ case   32:  		/* mr R3, R14 */
		/* 8225FEACh case   32:*/		regs.R3 = regs.R14;
		/* 8225FEACh case   32:*/		return 0x8225FEB0;
		  /* 8225FEB0h */ case   33:  		/* bl -28544 */
		/* 8225FEB0h case   33:*/		regs.LR = 0x8225FEB4; return 0x82258F30;
		/* 8225FEB0h case   33:*/		return 0x8225FEB4;
		  /* 8225FEB4h */ case   34:  		/* mr R3, R30 */
		/* 8225FEB4h case   34:*/		regs.R3 = regs.R30;
		/* 8225FEB4h case   34:*/		return 0x8225FEB8;
		  /* 8225FEB8h */ case   35:  		/* bl -40696 */
		/* 8225FEB8h case   35:*/		regs.LR = 0x8225FEBC; return 0x82255FC0;
		/* 8225FEB8h case   35:*/		return 0x8225FEBC;
		  /* 8225FEBCh */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FEBCh case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FEBCh case   36:*/		return 0x8225FEC0;
		  /* 8225FEC0h */ case   37:  		/* bc 4, CR0_EQ, -4136 */
		/* 8225FEC0h case   37:*/		if ( !regs.CR[0].eq ) { return 0x8225EE98;  }
		/* 8225FEC0h case   37:*/		return 0x8225FEC4;
		  /* 8225FEC4h */ case   38:  		/* li R7, 3017 */
		/* 8225FEC4h case   38:*/		cpu::op::li<0>(regs,&regs.R7,0xBC9);
		/* 8225FEC4h case   38:*/		return 0x8225FEC8;
		  /* 8225FEC8h */ case   39:  		/* b 316 */
		/* 8225FEC8h case   39:*/		return 0x82260004;
		/* 8225FEC8h case   39:*/		return 0x8225FECC;
	}
	return 0x8225FECC;
} // Block from 8225FE2Ch-8225FECCh (40 instructions)

//////////////////////////////////////////////////////
// Block at 8225FECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FECC);
		  /* 8225FECCh */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 8225FECCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FECCh case    0:*/		return 0x8225FED0;
		  /* 8225FED0h */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 8225FED0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 8225FED0h case    1:*/		return 0x8225FED4;
		  /* 8225FED4h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8225FED4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8225FED4h case    2:*/		return 0x8225FED8;
		  /* 8225FED8h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 8225FED8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8225FED8h case    3:*/		return 0x8225FEDC;
		  /* 8225FEDCh */ case    4:  		/* mtspr CTR, R11 */
		/* 8225FEDCh case    4:*/		regs.CTR = regs.R11;
		/* 8225FEDCh case    4:*/		return 0x8225FEE0;
		  /* 8225FEE0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8225FEE0h case    5:*/		if ( 1 ) { regs.LR = 0x8225FEE4; return (uint32)regs.CTR; }
		/* 8225FEE0h case    5:*/		return 0x8225FEE4;
		  /* 8225FEE4h */ case    6:  		/* lis R11, -32222 */
		/* 8225FEE4h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8225FEE4h case    6:*/		return 0x8225FEE8;
		  /* 8225FEE8h */ case    7:  		/* mr R5, R3 */
		/* 8225FEE8h case    7:*/		regs.R5 = regs.R3;
		/* 8225FEE8h case    7:*/		return 0x8225FEEC;
		  /* 8225FEECh */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 8225FEECh case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8225FEECh case    8:*/		return 0x8225FEF0;
		  /* 8225FEF0h */ case    9:  		/* mr R4, R25 */
		/* 8225FEF0h case    9:*/		regs.R4 = regs.R25;
		/* 8225FEF0h case    9:*/		return 0x8225FEF4;
		  /* 8225FEF4h */ case   10:  		/* addi R6, R11, -12392 */
		/* 8225FEF4h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8225FEF4h case   10:*/		return 0x8225FEF8;
		  /* 8225FEF8h */ case   11:  		/* mr R7, R30 */
		/* 8225FEF8h case   11:*/		regs.R7 = regs.R30;
		/* 8225FEF8h case   11:*/		return 0x8225FEFC;
		  /* 8225FEFCh */ case   12:  		/* bl -189012 */
		/* 8225FEFCh case   12:*/		regs.LR = 0x8225FF00; return 0x82231CA8;
		/* 8225FEFCh case   12:*/		return 0x8225FF00;
		  /* 8225FF00h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 8225FF00h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8225FF00h case   13:*/		return 0x8225FF04;
		  /* 8225FF04h */ case   14:  		/* bc 4, CR6_EQ, 280 */
		/* 8225FF04h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8226001C;  }
		/* 8225FF04h case   14:*/		return 0x8225FF08;
		  /* 8225FF08h */ case   15:  		/* li R3, 49 */
		/* 8225FF08h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225FF08h case   15:*/		return 0x8225FF0C;
		  /* 8225FF0Ch */ case   16:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FF0Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FF0Ch case   16:*/		return 0x8225FF10;
		  /* 8225FF10h */ case   17:  		/* bl -40928 */
		/* 8225FF10h case   17:*/		regs.LR = 0x8225FF14; return 0x82255F30;
		/* 8225FF10h case   17:*/		return 0x8225FF14;
		  /* 8225FF14h */ case   18:  		/* mr R5, R18 */
		/* 8225FF14h case   18:*/		regs.R5 = regs.R18;
		/* 8225FF14h case   18:*/		return 0x8225FF18;
		  /* 8225FF18h */ case   19:  		/* li R4, 0 */
		/* 8225FF18h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FF18h case   19:*/		return 0x8225FF1C;
		  /* 8225FF1Ch */ case   20:  		/* mr R30, R3 */
		/* 8225FF1Ch case   20:*/		regs.R30 = regs.R3;
		/* 8225FF1Ch case   20:*/		return 0x8225FF20;
		  /* 8225FF20h */ case   21:  		/* bl -39816 */
		/* 8225FF20h case   21:*/		regs.LR = 0x8225FF24; return 0x82256398;
		/* 8225FF20h case   21:*/		return 0x8225FF24;
		  /* 8225FF24h */ case   22:  		/* mr R3, R30 */
		/* 8225FF24h case   22:*/		regs.R3 = regs.R30;
		/* 8225FF24h case   22:*/		return 0x8225FF28;
		  /* 8225FF28h */ case   23:  		/* mr R5, R18 */
		/* 8225FF28h case   23:*/		regs.R5 = regs.R18;
		/* 8225FF28h case   23:*/		return 0x8225FF2C;
		  /* 8225FF2Ch */ case   24:  		/* li R4, 0 */
		/* 8225FF2Ch case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FF2Ch case   24:*/		return 0x8225FF30;
		  /* 8225FF30h */ case   25:  		/* bl -39832 */
		/* 8225FF30h case   25:*/		regs.LR = 0x8225FF34; return 0x82256398;
		/* 8225FF30h case   25:*/		return 0x8225FF34;
		  /* 8225FF34h */ case   26:  		/* lwz R11, <#[R27 - 1284]> */
		/* 8225FF34h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAFC) );
		/* 8225FF34h case   26:*/		return 0x8225FF38;
		  /* 8225FF38h */ case   27:  		/* mr R4, R30 */
		/* 8225FF38h case   27:*/		regs.R4 = regs.R30;
		/* 8225FF38h case   27:*/		return 0x8225FF3C;
		  /* 8225FF3Ch */ case   28:  		/* mr R3, R31 */
		/* 8225FF3Ch case   28:*/		regs.R3 = regs.R31;
		/* 8225FF3Ch case   28:*/		return 0x8225FF40;
		  /* 8225FF40h */ case   29:  		/* stw R11, <#[R30 + 132]> */
		/* 8225FF40h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 8225FF40h case   29:*/		return 0x8225FF44;
		  /* 8225FF44h */ case   30:  		/* bl -170396 */
		/* 8225FF44h case   30:*/		regs.LR = 0x8225FF48; return 0x822365A8;
		/* 8225FF44h case   30:*/		return 0x8225FF48;
		  /* 8225FF48h */ case   31:  		/* mr R4, R30 */
		/* 8225FF48h case   31:*/		regs.R4 = regs.R30;
		/* 8225FF48h case   31:*/		return 0x8225FF4C;
		  /* 8225FF4Ch */ case   32:  		/* mr R3, R14 */
		/* 8225FF4Ch case   32:*/		regs.R3 = regs.R14;
		/* 8225FF4Ch case   32:*/		return 0x8225FF50;
		  /* 8225FF50h */ case   33:  		/* bl -28704 */
		/* 8225FF50h case   33:*/		regs.LR = 0x8225FF54; return 0x82258F30;
		/* 8225FF50h case   33:*/		return 0x8225FF54;
		  /* 8225FF54h */ case   34:  		/* mr R3, R30 */
		/* 8225FF54h case   34:*/		regs.R3 = regs.R30;
		/* 8225FF54h case   34:*/		return 0x8225FF58;
		  /* 8225FF58h */ case   35:  		/* bl -40856 */
		/* 8225FF58h case   35:*/		regs.LR = 0x8225FF5C; return 0x82255FC0;
		/* 8225FF58h case   35:*/		return 0x8225FF5C;
		  /* 8225FF5Ch */ case   36:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FF5Ch case   36:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FF5Ch case   36:*/		return 0x8225FF60;
		  /* 8225FF60h */ case   37:  		/* bc 4, CR0_EQ, 28 */
		/* 8225FF60h case   37:*/		if ( !regs.CR[0].eq ) { return 0x8225FF7C;  }
		/* 8225FF60h case   37:*/		return 0x8225FF64;
		  /* 8225FF64h */ case   38:  		/* mr R6, R22 */
		/* 8225FF64h case   38:*/		regs.R6 = regs.R22;
		/* 8225FF64h case   38:*/		return 0x8225FF68;
		  /* 8225FF68h */ case   39:  		/* lwz R5, <#[R1 + 256]> */
		/* 8225FF68h case   39:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000100) );
		/* 8225FF68h case   39:*/		return 0x8225FF6C;
		  /* 8225FF6Ch */ case   40:  		/* mr R4, R24 */
		/* 8225FF6Ch case   40:*/		regs.R4 = regs.R24;
		/* 8225FF6Ch case   40:*/		return 0x8225FF70;
		  /* 8225FF70h */ case   41:  		/* li R7, 3029 */
		/* 8225FF70h case   41:*/		cpu::op::li<0>(regs,&regs.R7,0xBD5);
		/* 8225FF70h case   41:*/		return 0x8225FF74;
		  /* 8225FF74h */ case   42:  		/* li R3, 0 */
		/* 8225FF74h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8225FF74h case   42:*/		return 0x8225FF78;
		  /* 8225FF78h */ case   43:  		/* bl -1082224 */
		/* 8225FF78h case   43:*/		regs.LR = 0x8225FF7C; return 0x82157C08;
		/* 8225FF78h case   43:*/		return 0x8225FF7C;
	}
	return 0x8225FF7C;
} // Block from 8225FECCh-8225FF7Ch (44 instructions)

//////////////////////////////////////////////////////
// Block at 8225FF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8225FF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8225FF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8225FF7C);
		  /* 8225FF7Ch */ case    0:  		/* li R3, 49 */
		/* 8225FF7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 8225FF7Ch case    0:*/		return 0x8225FF80;
		  /* 8225FF80h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 8225FF80h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8225FF80h case    1:*/		return 0x8225FF84;
		  /* 8225FF84h */ case    2:  		/* bl -41044 */
		/* 8225FF84h case    2:*/		regs.LR = 0x8225FF88; return 0x82255F30;
		/* 8225FF84h case    2:*/		return 0x8225FF88;
		  /* 8225FF88h */ case    3:  		/* mr R5, R18 */
		/* 8225FF88h case    3:*/		regs.R5 = regs.R18;
		/* 8225FF88h case    3:*/		return 0x8225FF8C;
		  /* 8225FF8Ch */ case    4:  		/* li R4, 0 */
		/* 8225FF8Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FF8Ch case    4:*/		return 0x8225FF90;
		  /* 8225FF90h */ case    5:  		/* mr R30, R3 */
		/* 8225FF90h case    5:*/		regs.R30 = regs.R3;
		/* 8225FF90h case    5:*/		return 0x8225FF94;
		  /* 8225FF94h */ case    6:  		/* bl -39932 */
		/* 8225FF94h case    6:*/		regs.LR = 0x8225FF98; return 0x82256398;
		/* 8225FF94h case    6:*/		return 0x8225FF98;
		  /* 8225FF98h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 8225FF98h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8225FF98h case    7:*/		return 0x8225FF9C;
		  /* 8225FF9Ch */ case    8:  		/* mr R3, R30 */
		/* 8225FF9Ch case    8:*/		regs.R3 = regs.R30;
		/* 8225FF9Ch case    8:*/		return 0x8225FFA0;
		  /* 8225FFA0h */ case    9:  		/* li R6, 1 */
		/* 8225FFA0h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8225FFA0h case    9:*/		return 0x8225FFA4;
		  /* 8225FFA4h */ case   10:  		/* li R5, 3 */
		/* 8225FFA4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8225FFA4h case   10:*/		return 0x8225FFA8;
		  /* 8225FFA8h */ case   11:  		/* li R4, 0 */
		/* 8225FFA8h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8225FFA8h case   11:*/		return 0x8225FFAC;
		  /* 8225FFACh */ case   12:  		/* lwz R11, <#[R11 + 84]> */
		/* 8225FFACh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8225FFACh case   12:*/		return 0x8225FFB0;
		  /* 8225FFB0h */ case   13:  		/* mtspr CTR, R11 */
		/* 8225FFB0h case   13:*/		regs.CTR = regs.R11;
		/* 8225FFB0h case   13:*/		return 0x8225FFB4;
		  /* 8225FFB4h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8225FFB4h case   14:*/		if ( 1 ) { regs.LR = 0x8225FFB8; return (uint32)regs.CTR; }
		/* 8225FFB4h case   14:*/		return 0x8225FFB8;
		  /* 8225FFB8h */ case   15:  		/* mr R3, R30 */
		/* 8225FFB8h case   15:*/		regs.R3 = regs.R30;
		/* 8225FFB8h case   15:*/		return 0x8225FFBC;
		  /* 8225FFBCh */ case   16:  		/* fmr FR4, FR31 */
		/* 8225FFBCh case   16:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8225FFBCh case   16:*/		return 0x8225FFC0;
		  /* 8225FFC0h */ case   17:  		/* li R5, 1 */
		/* 8225FFC0h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8225FFC0h case   17:*/		return 0x8225FFC4;
		  /* 8225FFC4h */ case   18:  		/* fmr FR3, FR31 */
		/* 8225FFC4h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 8225FFC4h case   18:*/		return 0x8225FFC8;
		  /* 8225FFC8h */ case   19:  		/* mr R4, R31 */
		/* 8225FFC8h case   19:*/		regs.R4 = regs.R31;
		/* 8225FFC8h case   19:*/		return 0x8225FFCC;
		  /* 8225FFCCh */ case   20:  		/* fmr FR2, FR31 */
		/* 8225FFCCh case   20:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 8225FFCCh case   20:*/		return 0x8225FFD0;
		  /* 8225FFD0h */ case   21:  		/* fmr FR1, FR31 */
		/* 8225FFD0h case   21:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8225FFD0h case   21:*/		return 0x8225FFD4;
		  /* 8225FFD4h */ case   22:  		/* bl -37052 */
		/* 8225FFD4h case   22:*/		regs.LR = 0x8225FFD8; return 0x82256F18;
		/* 8225FFD4h case   22:*/		return 0x8225FFD8;
		  /* 8225FFD8h */ case   23:  		/* mr R4, R30 */
		/* 8225FFD8h case   23:*/		regs.R4 = regs.R30;
		/* 8225FFD8h case   23:*/		return 0x8225FFDC;
		  /* 8225FFDCh */ case   24:  		/* mr R3, R31 */
		/* 8225FFDCh case   24:*/		regs.R3 = regs.R31;
		/* 8225FFDCh case   24:*/		return 0x8225FFE0;
		  /* 8225FFE0h */ case   25:  		/* bl -170552 */
		/* 8225FFE0h case   25:*/		regs.LR = 0x8225FFE4; return 0x822365A8;
		/* 8225FFE0h case   25:*/		return 0x8225FFE4;
		  /* 8225FFE4h */ case   26:  		/* mr R4, R30 */
		/* 8225FFE4h case   26:*/		regs.R4 = regs.R30;
		/* 8225FFE4h case   26:*/		return 0x8225FFE8;
		  /* 8225FFE8h */ case   27:  		/* mr R3, R14 */
		/* 8225FFE8h case   27:*/		regs.R3 = regs.R14;
		/* 8225FFE8h case   27:*/		return 0x8225FFEC;
		  /* 8225FFECh */ case   28:  		/* bl -28860 */
		/* 8225FFECh case   28:*/		regs.LR = 0x8225FFF0; return 0x82258F30;
		/* 8225FFECh case   28:*/		return 0x8225FFF0;
		  /* 8225FFF0h */ case   29:  		/* mr R3, R30 */
		/* 8225FFF0h case   29:*/		regs.R3 = regs.R30;
		/* 8225FFF0h case   29:*/		return 0x8225FFF4;
		  /* 8225FFF4h */ case   30:  		/* bl -41012 */
		/* 8225FFF4h case   30:*/		regs.LR = 0x8225FFF8; return 0x82255FC0;
		/* 8225FFF4h case   30:*/		return 0x8225FFF8;
		  /* 8225FFF8h */ case   31:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8225FFF8h case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8225FFF8h case   31:*/		return 0x8225FFFC;
		  /* 8225FFFCh */ case   32:  		/* bc 4, CR0_EQ, -4452 */
		/* 8225FFFCh case   32:*/		if ( !regs.CR[0].eq ) { return 0x8225EE98;  }
		/* 8225FFFCh case   32:*/		return 0x82260000;
		  /* 82260000h */ case   33:  		/* li R7, 3037 */
		/* 82260000h case   33:*/		cpu::op::li<0>(regs,&regs.R7,0xBDD);
		/* 82260000h case   33:*/		return 0x82260004;
	}
	return 0x82260004;
} // Block from 8225FF7Ch-82260004h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82260004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260004);
		  /* 82260004h */ case    0:  		/* lwz R5, <#[R1 + 256]> */
		/* 82260004h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000100) );
		/* 82260004h case    0:*/		return 0x82260008;
		  /* 82260008h */ case    1:  		/* mr R4, R24 */
		/* 82260008h case    1:*/		regs.R4 = regs.R24;
		/* 82260008h case    1:*/		return 0x8226000C;
		  /* 8226000Ch */ case    2:  		/* mr R6, R22 */
		/* 8226000Ch case    2:*/		regs.R6 = regs.R22;
		/* 8226000Ch case    2:*/		return 0x82260010;
		  /* 82260010h */ case    3:  		/* li R3, 0 */
		/* 82260010h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260010h case    3:*/		return 0x82260014;
		  /* 82260014h */ case    4:  		/* bl -1082380 */
		/* 82260014h case    4:*/		regs.LR = 0x82260018; return 0x82157C08;
		/* 82260014h case    4:*/		return 0x82260018;
		  /* 82260018h */ case    5:  		/* b -4480 */
		/* 82260018h case    5:*/		return 0x8225EE98;
		/* 82260018h case    5:*/		return 0x8226001C;
	}
	return 0x8226001C;
} // Block from 82260004h-8226001Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226001Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226001C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226001C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226001C);
		  /* 8226001Ch */ case    0:  		/* lwz R5, <#[R1 + 196]> */
		/* 8226001Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 8226001Ch case    0:*/		return 0x82260020;
		  /* 82260020h */ case    1:  		/* li R7, 3039 */
		/* 82260020h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0xBDF);
		/* 82260020h case    1:*/		return 0x82260024;
		  /* 82260024h */ case    2:  		/* b -28 */
		/* 82260024h case    2:*/		return 0x82260008;
		/* 82260024h case    2:*/		return 0x82260028;
	}
	return 0x82260028;
} // Block from 8226001Ch-82260028h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82260028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260028);
		  /* 82260028h */ case    0:  		/* lwz R28, <#[R1 + 184]> */
		/* 82260028h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B8) );
		/* 82260028h case    0:*/		return 0x8226002C;
	}
	return 0x8226002C;
} // Block from 82260028h-8226002Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226002Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226002C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226002C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226002C);
		  /* 8226002Ch */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 8226002Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8226002Ch case    0:*/		return 0x82260030;
		  /* 82260030h */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 82260030h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 82260030h case    1:*/		return 0x82260034;
		  /* 82260034h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 82260034h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82260034h case    2:*/		return 0x82260038;
		  /* 82260038h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 82260038h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82260038h case    3:*/		return 0x8226003C;
		  /* 8226003Ch */ case    4:  		/* mtspr CTR, R11 */
		/* 8226003Ch case    4:*/		regs.CTR = regs.R11;
		/* 8226003Ch case    4:*/		return 0x82260040;
		  /* 82260040h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82260040h case    5:*/		if ( 1 ) { regs.LR = 0x82260044; return (uint32)regs.CTR; }
		/* 82260040h case    5:*/		return 0x82260044;
		  /* 82260044h */ case    6:  		/* lis R11, -32222 */
		/* 82260044h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82260044h case    6:*/		return 0x82260048;
		  /* 82260048h */ case    7:  		/* mr R5, R3 */
		/* 82260048h case    7:*/		regs.R5 = regs.R3;
		/* 82260048h case    7:*/		return 0x8226004C;
		  /* 8226004Ch */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 8226004Ch case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8226004Ch case    8:*/		return 0x82260050;
		  /* 82260050h */ case    9:  		/* mr R4, R25 */
		/* 82260050h case    9:*/		regs.R4 = regs.R25;
		/* 82260050h case    9:*/		return 0x82260054;
		  /* 82260054h */ case   10:  		/* addi R6, R11, -12392 */
		/* 82260054h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 82260054h case   10:*/		return 0x82260058;
		  /* 82260058h */ case   11:  		/* mr R7, R30 */
		/* 82260058h case   11:*/		regs.R7 = regs.R30;
		/* 82260058h case   11:*/		return 0x8226005C;
		  /* 8226005Ch */ case   12:  		/* bl -187684 */
		/* 8226005Ch case   12:*/		regs.LR = 0x82260060; return 0x82232338;
		/* 8226005Ch case   12:*/		return 0x82260060;
		  /* 82260060h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 82260060h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82260060h case   13:*/		return 0x82260064;
		  /* 82260064h */ case   14:  		/* bc 4, CR6_EQ, 492 */
		/* 82260064h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82260250;  }
		/* 82260064h case   14:*/		return 0x82260068;
		  /* 82260068h */ case   15:  		/* li R3, 30 */
		/* 82260068h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x1E);
		/* 82260068h case   15:*/		return 0x8226006C;
		  /* 8226006Ch */ case   16:  		/* lwz R4, <#[R31 + 12]> */
		/* 8226006Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8226006Ch case   16:*/		return 0x82260070;
		  /* 82260070h */ case   17:  		/* bl -41280 */
		/* 82260070h case   17:*/		regs.LR = 0x82260074; return 0x82255F30;
		/* 82260070h case   17:*/		return 0x82260074;
		  /* 82260074h */ case   18:  		/* li R26, 1 */
		/* 82260074h case   18:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82260074h case   18:*/		return 0x82260078;
		  /* 82260078h */ case   19:  		/* mr R5, R18 */
		/* 82260078h case   19:*/		regs.R5 = regs.R18;
		/* 82260078h case   19:*/		return 0x8226007C;
		  /* 8226007Ch */ case   20:  		/* stb R26, <#[R3 + 164]> */
		/* 8226007Ch case   20:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R3 + 0x000000A4) );
		/* 8226007Ch case   20:*/		return 0x82260080;
		  /* 82260080h */ case   21:  		/* li R4, 0 */
		/* 82260080h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82260080h case   21:*/		return 0x82260084;
		  /* 82260084h */ case   22:  		/* mr R30, R3 */
		/* 82260084h case   22:*/		regs.R30 = regs.R3;
		/* 82260084h case   22:*/		return 0x82260088;
		  /* 82260088h */ case   23:  		/* bl -40176 */
		/* 82260088h case   23:*/		regs.LR = 0x8226008C; return 0x82256398;
		/* 82260088h case   23:*/		return 0x8226008C;
		  /* 8226008Ch */ case   24:  		/* lwz R11, <#[R27 - 1296]> */
		/* 8226008Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF0) );
		/* 8226008Ch case   24:*/		return 0x82260090;
		  /* 82260090h */ case   25:  		/* mr R3, R30 */
		/* 82260090h case   25:*/		regs.R3 = regs.R30;
		/* 82260090h case   25:*/		return 0x82260094;
		  /* 82260094h */ case   26:  		/* mr R5, R18 */
		/* 82260094h case   26:*/		regs.R5 = regs.R18;
		/* 82260094h case   26:*/		return 0x82260098;
		  /* 82260098h */ case   27:  		/* li R4, 1 */
		/* 82260098h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82260098h case   27:*/		return 0x8226009C;
		  /* 8226009Ch */ case   28:  		/* stw R11, <#[R30 + 128]> */
		/* 8226009Ch case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8226009Ch case   28:*/		return 0x822600A0;
		  /* 822600A0h */ case   29:  		/* bl -40200 */
		/* 822600A0h case   29:*/		regs.LR = 0x822600A4; return 0x82256398;
		/* 822600A0h case   29:*/		return 0x822600A4;
		  /* 822600A4h */ case   30:  		/* mr R3, R30 */
		/* 822600A4h case   30:*/		regs.R3 = regs.R30;
		/* 822600A4h case   30:*/		return 0x822600A8;
		  /* 822600A8h */ case   31:  		/* mr R5, R18 */
		/* 822600A8h case   31:*/		regs.R5 = regs.R18;
		/* 822600A8h case   31:*/		return 0x822600AC;
		  /* 822600ACh */ case   32:  		/* li R4, 2 */
		/* 822600ACh case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 822600ACh case   32:*/		return 0x822600B0;
		  /* 822600B0h */ case   33:  		/* bl -40216 */
		/* 822600B0h case   33:*/		regs.LR = 0x822600B4; return 0x82256398;
		/* 822600B0h case   33:*/		return 0x822600B4;
		  /* 822600B4h */ case   34:  		/* stb R26, <#[R30 + 154]> */
		/* 822600B4h case   34:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R30 + 0x0000009A) );
		/* 822600B4h case   34:*/		return 0x822600B8;
		  /* 822600B8h */ case   35:  		/* mr R3, R30 */
		/* 822600B8h case   35:*/		regs.R3 = regs.R30;
		/* 822600B8h case   35:*/		return 0x822600BC;
		  /* 822600BCh */ case   36:  		/* fmr FR4, FR31 */
		/* 822600BCh case   36:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 822600BCh case   36:*/		return 0x822600C0;
		  /* 822600C0h */ case   37:  		/* li R5, 3 */
		/* 822600C0h case   37:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 822600C0h case   37:*/		return 0x822600C4;
		  /* 822600C4h */ case   38:  		/* fmr FR3, FR31 */
		/* 822600C4h case   38:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 822600C4h case   38:*/		return 0x822600C8;
		  /* 822600C8h */ case   39:  		/* mr R4, R31 */
		/* 822600C8h case   39:*/		regs.R4 = regs.R31;
		/* 822600C8h case   39:*/		return 0x822600CC;
		  /* 822600CCh */ case   40:  		/* fmr FR2, FR31 */
		/* 822600CCh case   40:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 822600CCh case   40:*/		return 0x822600D0;
		  /* 822600D0h */ case   41:  		/* fmr FR1, FR31 */
		/* 822600D0h case   41:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822600D0h case   41:*/		return 0x822600D4;
		  /* 822600D4h */ case   42:  		/* bl -37308 */
		/* 822600D4h case   42:*/		regs.LR = 0x822600D8; return 0x82256F18;
		/* 822600D4h case   42:*/		return 0x822600D8;
		  /* 822600D8h */ case   43:  		/* mr R4, R30 */
		/* 822600D8h case   43:*/		regs.R4 = regs.R30;
		/* 822600D8h case   43:*/		return 0x822600DC;
		  /* 822600DCh */ case   44:  		/* mr R3, R31 */
		/* 822600DCh case   44:*/		regs.R3 = regs.R31;
		/* 822600DCh case   44:*/		return 0x822600E0;
		  /* 822600E0h */ case   45:  		/* bl -170808 */
		/* 822600E0h case   45:*/		regs.LR = 0x822600E4; return 0x822365A8;
		/* 822600E0h case   45:*/		return 0x822600E4;
		  /* 822600E4h */ case   46:  		/* mr R4, R30 */
		/* 822600E4h case   46:*/		regs.R4 = regs.R30;
		/* 822600E4h case   46:*/		return 0x822600E8;
		  /* 822600E8h */ case   47:  		/* mr R3, R14 */
		/* 822600E8h case   47:*/		regs.R3 = regs.R14;
		/* 822600E8h case   47:*/		return 0x822600EC;
		  /* 822600ECh */ case   48:  		/* bl -29116 */
		/* 822600ECh case   48:*/		regs.LR = 0x822600F0; return 0x82258F30;
		/* 822600ECh case   48:*/		return 0x822600F0;
		  /* 822600F0h */ case   49:  		/* mr R3, R30 */
		/* 822600F0h case   49:*/		regs.R3 = regs.R30;
		/* 822600F0h case   49:*/		return 0x822600F4;
		  /* 822600F4h */ case   50:  		/* bl -41268 */
		/* 822600F4h case   50:*/		regs.LR = 0x822600F8; return 0x82255FC0;
		/* 822600F4h case   50:*/		return 0x822600F8;
		  /* 822600F8h */ case   51:  		/* lwz R30, <#[R1 + 324]> */
		/* 822600F8h case   51:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 822600F8h case   51:*/		return 0x822600FC;
		  /* 822600FCh */ case   52:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822600FCh case   52:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822600FCh case   52:*/		return 0x82260100;
		  /* 82260100h */ case   53:  		/* bc 4, CR0_EQ, 28 */
		/* 82260100h case   53:*/		if ( !regs.CR[0].eq ) { return 0x8226011C;  }
		/* 82260100h case   53:*/		return 0x82260104;
		  /* 82260104h */ case   54:  		/* mr R6, R22 */
		/* 82260104h case   54:*/		regs.R6 = regs.R22;
		/* 82260104h case   54:*/		return 0x82260108;
		  /* 82260108h */ case   55:  		/* mr R4, R24 */
		/* 82260108h case   55:*/		regs.R4 = regs.R24;
		/* 82260108h case   55:*/		return 0x8226010C;
		  /* 8226010Ch */ case   56:  		/* mr R5, R30 */
		/* 8226010Ch case   56:*/		regs.R5 = regs.R30;
		/* 8226010Ch case   56:*/		return 0x82260110;
		  /* 82260110h */ case   57:  		/* li R7, 3201 */
		/* 82260110h case   57:*/		cpu::op::li<0>(regs,&regs.R7,0xC81);
		/* 82260110h case   57:*/		return 0x82260114;
		  /* 82260114h */ case   58:  		/* li R3, 0 */
		/* 82260114h case   58:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260114h case   58:*/		return 0x82260118;
		  /* 82260118h */ case   59:  		/* bl -1082640 */
		/* 82260118h case   59:*/		regs.LR = 0x8226011C; return 0x82157C08;
		/* 82260118h case   59:*/		return 0x8226011C;
	}
	return 0x8226011C;
} // Block from 8226002Ch-8226011Ch (60 instructions)

//////////////////////////////////////////////////////
// Block at 8226011Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226011C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226011C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226011C);
		  /* 8226011Ch */ case    0:  		/* li R3, 38 */
		/* 8226011Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x26);
		/* 8226011Ch case    0:*/		return 0x82260120;
		  /* 82260120h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260120h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260120h case    1:*/		return 0x82260124;
		  /* 82260124h */ case    2:  		/* bl -41460 */
		/* 82260124h case    2:*/		regs.LR = 0x82260128; return 0x82255F30;
		/* 82260124h case    2:*/		return 0x82260128;
		  /* 82260128h */ case    3:  		/* mr R5, R18 */
		/* 82260128h case    3:*/		regs.R5 = regs.R18;
		/* 82260128h case    3:*/		return 0x8226012C;
		  /* 8226012Ch */ case    4:  		/* li R4, 0 */
		/* 8226012Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8226012Ch case    4:*/		return 0x82260130;
		  /* 82260130h */ case    5:  		/* mr R29, R3 */
		/* 82260130h case    5:*/		regs.R29 = regs.R3;
		/* 82260130h case    5:*/		return 0x82260134;
		  /* 82260134h */ case    6:  		/* bl -40348 */
		/* 82260134h case    6:*/		regs.LR = 0x82260138; return 0x82256398;
		/* 82260134h case    6:*/		return 0x82260138;
		  /* 82260138h */ case    7:  		/* lwz R11, <#[R27 - 1296]> */
		/* 82260138h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF0) );
		/* 82260138h case    7:*/		return 0x8226013C;
		  /* 8226013Ch */ case    8:  		/* mr R3, R29 */
		/* 8226013Ch case    8:*/		regs.R3 = regs.R29;
		/* 8226013Ch case    8:*/		return 0x82260140;
		  /* 82260140h */ case    9:  		/* mr R5, R18 */
		/* 82260140h case    9:*/		regs.R5 = regs.R18;
		/* 82260140h case    9:*/		return 0x82260144;
		  /* 82260144h */ case   10:  		/* li R4, 1 */
		/* 82260144h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82260144h case   10:*/		return 0x82260148;
		  /* 82260148h */ case   11:  		/* stw R11, <#[R29 + 128]> */
		/* 82260148h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000080) );
		/* 82260148h case   11:*/		return 0x8226014C;
		  /* 8226014Ch */ case   12:  		/* bl -40372 */
		/* 8226014Ch case   12:*/		regs.LR = 0x82260150; return 0x82256398;
		/* 8226014Ch case   12:*/		return 0x82260150;
		  /* 82260150h */ case   13:  		/* lwz R11, <#[R27 - 1276]> */
		/* 82260150h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 82260150h case   13:*/		return 0x82260154;
		  /* 82260154h */ case   14:  		/* mr R3, R29 */
		/* 82260154h case   14:*/		regs.R3 = regs.R29;
		/* 82260154h case   14:*/		return 0x82260158;
		  /* 82260158h */ case   15:  		/* mr R5, R18 */
		/* 82260158h case   15:*/		regs.R5 = regs.R18;
		/* 82260158h case   15:*/		return 0x8226015C;
		  /* 8226015Ch */ case   16:  		/* li R4, 2 */
		/* 8226015Ch case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8226015Ch case   16:*/		return 0x82260160;
		  /* 82260160h */ case   17:  		/* stw R11, <#[R29 + 132]> */
		/* 82260160h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 82260160h case   17:*/		return 0x82260164;
		  /* 82260164h */ case   18:  		/* bl -40396 */
		/* 82260164h case   18:*/		regs.LR = 0x82260168; return 0x82256398;
		/* 82260164h case   18:*/		return 0x82260168;
		  /* 82260168h */ case   19:  		/* lwz R11, <#[R27 - 1276]> */
		/* 82260168h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 82260168h case   19:*/		return 0x8226016C;
		  /* 8226016Ch */ case   20:  		/* mr R3, R29 */
		/* 8226016Ch case   20:*/		regs.R3 = regs.R29;
		/* 8226016Ch case   20:*/		return 0x82260170;
		  /* 82260170h */ case   21:  		/* fmr FR4, FR30 */
		/* 82260170h case   21:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR30);
		/* 82260170h case   21:*/		return 0x82260174;
		  /* 82260174h */ case   22:  		/* li R5, 3 */
		/* 82260174h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82260174h case   22:*/		return 0x82260178;
		  /* 82260178h */ case   23:  		/* fmr FR3, FR30 */
		/* 82260178h case   23:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR30);
		/* 82260178h case   23:*/		return 0x8226017C;
		  /* 8226017Ch */ case   24:  		/* mr R4, R31 */
		/* 8226017Ch case   24:*/		regs.R4 = regs.R31;
		/* 8226017Ch case   24:*/		return 0x82260180;
		  /* 82260180h */ case   25:  		/* fmr FR2, FR30 */
		/* 82260180h case   25:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 82260180h case   25:*/		return 0x82260184;
		  /* 82260184h */ case   26:  		/* fmr FR1, FR30 */
		/* 82260184h case   26:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82260184h case   26:*/		return 0x82260188;
		  /* 82260188h */ case   27:  		/* stw R11, <#[R29 + 136]> */
		/* 82260188h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000088) );
		/* 82260188h case   27:*/		return 0x8226018C;
		  /* 8226018Ch */ case   28:  		/* bl -37492 */
		/* 8226018Ch case   28:*/		regs.LR = 0x82260190; return 0x82256F18;
		/* 8226018Ch case   28:*/		return 0x82260190;
		  /* 82260190h */ case   29:  		/* mr R4, R29 */
		/* 82260190h case   29:*/		regs.R4 = regs.R29;
		/* 82260190h case   29:*/		return 0x82260194;
		  /* 82260194h */ case   30:  		/* mr R3, R31 */
		/* 82260194h case   30:*/		regs.R3 = regs.R31;
		/* 82260194h case   30:*/		return 0x82260198;
		  /* 82260198h */ case   31:  		/* bl -170992 */
		/* 82260198h case   31:*/		regs.LR = 0x8226019C; return 0x822365A8;
		/* 82260198h case   31:*/		return 0x8226019C;
		  /* 8226019Ch */ case   32:  		/* mr R4, R29 */
		/* 8226019Ch case   32:*/		regs.R4 = regs.R29;
		/* 8226019Ch case   32:*/		return 0x822601A0;
		  /* 822601A0h */ case   33:  		/* mr R3, R14 */
		/* 822601A0h case   33:*/		regs.R3 = regs.R14;
		/* 822601A0h case   33:*/		return 0x822601A4;
		  /* 822601A4h */ case   34:  		/* bl -29300 */
		/* 822601A4h case   34:*/		regs.LR = 0x822601A8; return 0x82258F30;
		/* 822601A4h case   34:*/		return 0x822601A8;
		  /* 822601A8h */ case   35:  		/* mr R3, R29 */
		/* 822601A8h case   35:*/		regs.R3 = regs.R29;
		/* 822601A8h case   35:*/		return 0x822601AC;
		  /* 822601ACh */ case   36:  		/* bl -41452 */
		/* 822601ACh case   36:*/		regs.LR = 0x822601B0; return 0x82255FC0;
		/* 822601ACh case   36:*/		return 0x822601B0;
		  /* 822601B0h */ case   37:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822601B0h case   37:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822601B0h case   37:*/		return 0x822601B4;
		  /* 822601B4h */ case   38:  		/* bc 4, CR0_EQ, 28 */
		/* 822601B4h case   38:*/		if ( !regs.CR[0].eq ) { return 0x822601D0;  }
		/* 822601B4h case   38:*/		return 0x822601B8;
		  /* 822601B8h */ case   39:  		/* mr R6, R22 */
		/* 822601B8h case   39:*/		regs.R6 = regs.R22;
		/* 822601B8h case   39:*/		return 0x822601BC;
		  /* 822601BCh */ case   40:  		/* mr R5, R30 */
		/* 822601BCh case   40:*/		regs.R5 = regs.R30;
		/* 822601BCh case   40:*/		return 0x822601C0;
		  /* 822601C0h */ case   41:  		/* mr R4, R24 */
		/* 822601C0h case   41:*/		regs.R4 = regs.R24;
		/* 822601C0h case   41:*/		return 0x822601C4;
		  /* 822601C4h */ case   42:  		/* li R7, 3214 */
		/* 822601C4h case   42:*/		cpu::op::li<0>(regs,&regs.R7,0xC8E);
		/* 822601C4h case   42:*/		return 0x822601C8;
		  /* 822601C8h */ case   43:  		/* li R3, 0 */
		/* 822601C8h case   43:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822601C8h case   43:*/		return 0x822601CC;
		  /* 822601CCh */ case   44:  		/* bl -1082820 */
		/* 822601CCh case   44:*/		regs.LR = 0x822601D0; return 0x82157C08;
		/* 822601CCh case   44:*/		return 0x822601D0;
	}
	return 0x822601D0;
} // Block from 8226011Ch-822601D0h (45 instructions)

//////////////////////////////////////////////////////
// Block at 822601D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822601D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822601D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822601D0);
		  /* 822601D0h */ case    0:  		/* li R3, 68 */
		/* 822601D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x44);
		/* 822601D0h case    0:*/		return 0x822601D4;
		  /* 822601D4h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 822601D4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822601D4h case    1:*/		return 0x822601D8;
		  /* 822601D8h */ case    2:  		/* bl -41640 */
		/* 822601D8h case    2:*/		regs.LR = 0x822601DC; return 0x82255F30;
		/* 822601D8h case    2:*/		return 0x822601DC;
		  /* 822601DCh */ case    3:  		/* mr R5, R18 */
		/* 822601DCh case    3:*/		regs.R5 = regs.R18;
		/* 822601DCh case    3:*/		return 0x822601E0;
		  /* 822601E0h */ case    4:  		/* li R4, 0 */
		/* 822601E0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822601E0h case    4:*/		return 0x822601E4;
		  /* 822601E4h */ case    5:  		/* mr R29, R3 */
		/* 822601E4h case    5:*/		regs.R29 = regs.R3;
		/* 822601E4h case    5:*/		return 0x822601E8;
		  /* 822601E8h */ case    6:  		/* bl -40528 */
		/* 822601E8h case    6:*/		regs.LR = 0x822601EC; return 0x82256398;
		/* 822601E8h case    6:*/		return 0x822601EC;
		  /* 822601ECh */ case    7:  		/* lwz R11, <#[R27 - 1296]> */
		/* 822601ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF0) );
		/* 822601ECh case    7:*/		return 0x822601F0;
		  /* 822601F0h */ case    8:  		/* mr R3, R29 */
		/* 822601F0h case    8:*/		regs.R3 = regs.R29;
		/* 822601F0h case    8:*/		return 0x822601F4;
		  /* 822601F4h */ case    9:  		/* mr R5, R18 */
		/* 822601F4h case    9:*/		regs.R5 = regs.R18;
		/* 822601F4h case    9:*/		return 0x822601F8;
		  /* 822601F8h */ case   10:  		/* li R4, 1 */
		/* 822601F8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822601F8h case   10:*/		return 0x822601FC;
		  /* 822601FCh */ case   11:  		/* stw R11, <#[R29 + 128]> */
		/* 822601FCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000080) );
		/* 822601FCh case   11:*/		return 0x82260200;
		  /* 82260200h */ case   12:  		/* bl -40552 */
		/* 82260200h case   12:*/		regs.LR = 0x82260204; return 0x82256398;
		/* 82260200h case   12:*/		return 0x82260204;
		  /* 82260204h */ case   13:  		/* lwz R11, <#[R27 - 1276]> */
		/* 82260204h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFB04) );
		/* 82260204h case   13:*/		return 0x82260208;
		  /* 82260208h */ case   14:  		/* mr R4, R29 */
		/* 82260208h case   14:*/		regs.R4 = regs.R29;
		/* 82260208h case   14:*/		return 0x8226020C;
		  /* 8226020Ch */ case   15:  		/* mr R3, R31 */
		/* 8226020Ch case   15:*/		regs.R3 = regs.R31;
		/* 8226020Ch case   15:*/		return 0x82260210;
		  /* 82260210h */ case   16:  		/* stw R11, <#[R29 + 132]> */
		/* 82260210h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000084) );
		/* 82260210h case   16:*/		return 0x82260214;
		  /* 82260214h */ case   17:  		/* bl -171116 */
		/* 82260214h case   17:*/		regs.LR = 0x82260218; return 0x822365A8;
		/* 82260214h case   17:*/		return 0x82260218;
		  /* 82260218h */ case   18:  		/* mr R4, R29 */
		/* 82260218h case   18:*/		regs.R4 = regs.R29;
		/* 82260218h case   18:*/		return 0x8226021C;
		  /* 8226021Ch */ case   19:  		/* mr R3, R14 */
		/* 8226021Ch case   19:*/		regs.R3 = regs.R14;
		/* 8226021Ch case   19:*/		return 0x82260220;
		  /* 82260220h */ case   20:  		/* bl -29424 */
		/* 82260220h case   20:*/		regs.LR = 0x82260224; return 0x82258F30;
		/* 82260220h case   20:*/		return 0x82260224;
		  /* 82260224h */ case   21:  		/* mr R3, R29 */
		/* 82260224h case   21:*/		regs.R3 = regs.R29;
		/* 82260224h case   21:*/		return 0x82260228;
		  /* 82260228h */ case   22:  		/* bl -41576 */
		/* 82260228h case   22:*/		regs.LR = 0x8226022C; return 0x82255FC0;
		/* 82260228h case   22:*/		return 0x8226022C;
		  /* 8226022Ch */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8226022Ch case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8226022Ch case   23:*/		return 0x82260230;
		  /* 82260230h */ case   24:  		/* bc 4, CR0_EQ, 36 */
		/* 82260230h case   24:*/		if ( !regs.CR[0].eq ) { return 0x82260254;  }
		/* 82260230h case   24:*/		return 0x82260234;
		  /* 82260234h */ case   25:  		/* mr R6, R22 */
		/* 82260234h case   25:*/		regs.R6 = regs.R22;
		/* 82260234h case   25:*/		return 0x82260238;
		  /* 82260238h */ case   26:  		/* mr R5, R30 */
		/* 82260238h case   26:*/		regs.R5 = regs.R30;
		/* 82260238h case   26:*/		return 0x8226023C;
		  /* 8226023Ch */ case   27:  		/* mr R4, R24 */
		/* 8226023Ch case   27:*/		regs.R4 = regs.R24;
		/* 8226023Ch case   27:*/		return 0x82260240;
		  /* 82260240h */ case   28:  		/* li R7, 3224 */
		/* 82260240h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0xC98);
		/* 82260240h case   28:*/		return 0x82260244;
		  /* 82260244h */ case   29:  		/* li R3, 0 */
		/* 82260244h case   29:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260244h case   29:*/		return 0x82260248;
		  /* 82260248h */ case   30:  		/* bl -1082944 */
		/* 82260248h case   30:*/		regs.LR = 0x8226024C; return 0x82157C08;
		/* 82260248h case   30:*/		return 0x8226024C;
		  /* 8226024Ch */ case   31:  		/* b 8 */
		/* 8226024Ch case   31:*/		return 0x82260254;
		/* 8226024Ch case   31:*/		return 0x82260250;
	}
	return 0x82260250;
} // Block from 822601D0h-82260250h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82260250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260250);
		  /* 82260250h */ case    0:  		/* li R26, 1 */
		/* 82260250h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82260250h case    0:*/		return 0x82260254;
	}
	return 0x82260254;
} // Block from 82260250h-82260254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260254);
		  /* 82260254h */ case    0:  		/* lwz R30, <#[R31 + 12]> */
		/* 82260254h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260254h case    0:*/		return 0x82260258;
		  /* 82260258h */ case    1:  		/* lwz R3, <#[R30 + 1488]> */
		/* 82260258h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000005D0) );
		/* 82260258h case    1:*/		return 0x8226025C;
		  /* 8226025Ch */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8226025Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8226025Ch case    2:*/		return 0x82260260;
		  /* 82260260h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 82260260h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82260260h case    3:*/		return 0x82260264;
		  /* 82260264h */ case    4:  		/* mtspr CTR, R11 */
		/* 82260264h case    4:*/		regs.CTR = regs.R11;
		/* 82260264h case    4:*/		return 0x82260268;
		  /* 82260268h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82260268h case    5:*/		if ( 1 ) { regs.LR = 0x8226026C; return (uint32)regs.CTR; }
		/* 82260268h case    5:*/		return 0x8226026C;
		  /* 8226026Ch */ case    6:  		/* lis R11, -32222 */
		/* 8226026Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 8226026Ch case    6:*/		return 0x82260270;
		  /* 82260270h */ case    7:  		/* mr R5, R3 */
		/* 82260270h case    7:*/		regs.R5 = regs.R3;
		/* 82260270h case    7:*/		return 0x82260274;
		  /* 82260274h */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 82260274h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82260274h case    8:*/		return 0x82260278;
		  /* 82260278h */ case    9:  		/* mr R4, R25 */
		/* 82260278h case    9:*/		regs.R4 = regs.R25;
		/* 82260278h case    9:*/		return 0x8226027C;
		  /* 8226027Ch */ case   10:  		/* addi R6, R11, -12392 */
		/* 8226027Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 8226027Ch case   10:*/		return 0x82260280;
		  /* 82260280h */ case   11:  		/* mr R7, R30 */
		/* 82260280h case   11:*/		regs.R7 = regs.R30;
		/* 82260280h case   11:*/		return 0x82260284;
		  /* 82260284h */ case   12:  		/* bl -196692 */
		/* 82260284h case   12:*/		regs.LR = 0x82260288; return 0x82230230;
		/* 82260284h case   12:*/		return 0x82260288;
		  /* 82260288h */ case   13:  		/* cmpwi CR6, R3, 1 */
		/* 82260288h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82260288h case   13:*/		return 0x8226028C;
		  /* 8226028Ch */ case   14:  		/* bc 4, CR6_EQ, 596 */
		/* 8226028Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x822604E0;  }
		/* 8226028Ch case   14:*/		return 0x82260290;
		  /* 82260290h */ case   15:  		/* lis R11, -32222 */
		/* 82260290h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82260290h case   15:*/		return 0x82260294;
		  /* 82260294h */ case   16:  		/* lwz R7, <#[R31 + 12]> */
		/* 82260294h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260294h case   16:*/		return 0x82260298;
		  /* 82260298h */ case   17:  		/* addi R5, R1, 364 */
		/* 82260298h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x16C);
		/* 82260298h case   17:*/		return 0x8226029C;
		  /* 8226029Ch */ case   18:  		/* lwz R3, <#[R31 + 16]> */
		/* 8226029Ch case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8226029Ch case   18:*/		return 0x822602A0;
		  /* 822602A0h */ case   19:  		/* addi R6, R11, -12392 */
		/* 822602A0h case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 822602A0h case   19:*/		return 0x822602A4;
		  /* 822602A4h */ case   20:  		/* mr R4, R25 */
		/* 822602A4h case   20:*/		regs.R4 = regs.R25;
		/* 822602A4h case   20:*/		return 0x822602A8;
		  /* 822602A8h */ case   21:  		/* bl -183496 */
		/* 822602A8h case   21:*/		regs.LR = 0x822602AC; return 0x822335E0;
		/* 822602A8h case   21:*/		return 0x822602AC;
		  /* 822602ACh */ case   22:  		/* lis R11, -32222 */
		/* 822602ACh case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 822602ACh case   22:*/		return 0x822602B0;
		  /* 822602B0h */ case   23:  		/* addi R5, R1, 332 */
		/* 822602B0h case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x14C);
		/* 822602B0h case   23:*/		return 0x822602B4;
		  /* 822602B4h */ case   24:  		/* lwz R7, <#[R31 + 12]> */
		/* 822602B4h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 822602B4h case   24:*/		return 0x822602B8;
		  /* 822602B8h */ case   25:  		/* addi R6, R11, -12392 */
		/* 822602B8h case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 822602B8h case   25:*/		return 0x822602BC;
		  /* 822602BCh */ case   26:  		/* lwz R3, <#[R31 + 16]> */
		/* 822602BCh case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 822602BCh case   26:*/		return 0x822602C0;
		  /* 822602C0h */ case   27:  		/* mr R4, R25 */
		/* 822602C0h case   27:*/		regs.R4 = regs.R25;
		/* 822602C0h case   27:*/		return 0x822602C4;
		  /* 822602C4h */ case   28:  		/* bl -183348 */
		/* 822602C4h case   28:*/		regs.LR = 0x822602C8; return 0x82233690;
		/* 822602C4h case   28:*/		return 0x822602C8;
		  /* 822602C8h */ case   29:  		/* lis R11, -32222 */
		/* 822602C8h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 822602C8h case   29:*/		return 0x822602CC;
		  /* 822602CCh */ case   30:  		/* addi R5, R1, 348 */
		/* 822602CCh case   30:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x15C);
		/* 822602CCh case   30:*/		return 0x822602D0;
		  /* 822602D0h */ case   31:  		/* lwz R7, <#[R31 + 12]> */
		/* 822602D0h case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 822602D0h case   31:*/		return 0x822602D4;
		  /* 822602D4h */ case   32:  		/* addi R6, R11, -12392 */
		/* 822602D4h case   32:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 822602D4h case   32:*/		return 0x822602D8;
		  /* 822602D8h */ case   33:  		/* lwz R3, <#[R31 + 16]> */
		/* 822602D8h case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 822602D8h case   33:*/		return 0x822602DC;
		  /* 822602DCh */ case   34:  		/* mr R4, R25 */
		/* 822602DCh case   34:*/		regs.R4 = regs.R25;
		/* 822602DCh case   34:*/		return 0x822602E0;
		  /* 822602E0h */ case   35:  		/* bl -183200 */
		/* 822602E0h case   35:*/		regs.LR = 0x822602E4; return 0x82233740;
		/* 822602E0h case   35:*/		return 0x822602E4;
		  /* 822602E4h */ case   36:  		/* lis R11, -32222 */
		/* 822602E4h case   36:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 822602E4h case   36:*/		return 0x822602E8;
		  /* 822602E8h */ case   37:  		/* addi R5, R1, 360 */
		/* 822602E8h case   37:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x168);
		/* 822602E8h case   37:*/		return 0x822602EC;
		  /* 822602ECh */ case   38:  		/* lwz R7, <#[R31 + 12]> */
		/* 822602ECh case   38:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 822602ECh case   38:*/		return 0x822602F0;
		  /* 822602F0h */ case   39:  		/* addi R6, R11, -12392 */
		/* 822602F0h case   39:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 822602F0h case   39:*/		return 0x822602F4;
		  /* 822602F4h */ case   40:  		/* lwz R3, <#[R31 + 16]> */
		/* 822602F4h case   40:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 822602F4h case   40:*/		return 0x822602F8;
		  /* 822602F8h */ case   41:  		/* mr R4, R25 */
		/* 822602F8h case   41:*/		regs.R4 = regs.R25;
		/* 822602F8h case   41:*/		return 0x822602FC;
		  /* 822602FCh */ case   42:  		/* bl -183052 */
		/* 822602FCh case   42:*/		regs.LR = 0x82260300; return 0x822337F0;
		/* 822602FCh case   42:*/		return 0x82260300;
		  /* 82260300h */ case   43:  		/* lfs FR0, <#[R1 + 364]> */
		/* 82260300h case   43:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000016C) );
		/* 82260300h case   43:*/		return 0x82260304;
		  /* 82260304h */ case   44:  		/* lfs FR13, <#[R1 + 332]> */
		/* 82260304h case   44:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x0000014C) );
		/* 82260304h case   44:*/		return 0x82260308;
		  /* 82260308h */ case   45:  		/* fcmpu CR6, FR0, FR31 */
		/* 82260308h case   45:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82260308h case   45:*/		return 0x8226030C;
		  /* 8226030Ch */ case   46:  		/* lfs FR12, <#[R1 + 348]> */
		/* 8226030Ch case   46:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R1 + 0x0000015C) );
		/* 8226030Ch case   46:*/		return 0x82260310;
		  /* 82260310h */ case   47:  		/* lfs FR11, <#[R1 + 360]> */
		/* 82260310h case   47:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000168) );
		/* 82260310h case   47:*/		return 0x82260314;
		  /* 82260314h */ case   48:  		/* bc 4, CR6_EQ, 28 */
		/* 82260314h case   48:*/		if ( !regs.CR[6].eq ) { return 0x82260330;  }
		/* 82260314h case   48:*/		return 0x82260318;
		  /* 82260318h */ case   49:  		/* fcmpu CR6, FR13, FR31 */
		/* 82260318h case   49:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82260318h case   49:*/		return 0x8226031C;
		  /* 8226031Ch */ case   50:  		/* bc 4, CR6_EQ, 20 */
		/* 8226031Ch case   50:*/		if ( !regs.CR[6].eq ) { return 0x82260330;  }
		/* 8226031Ch case   50:*/		return 0x82260320;
		  /* 82260320h */ case   51:  		/* fcmpu CR6, FR12, FR31 */
		/* 82260320h case   51:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR31);
		/* 82260320h case   51:*/		return 0x82260324;
		  /* 82260324h */ case   52:  		/* bc 4, CR6_EQ, 12 */
		/* 82260324h case   52:*/		if ( !regs.CR[6].eq ) { return 0x82260330;  }
		/* 82260324h case   52:*/		return 0x82260328;
		  /* 82260328h */ case   53:  		/* fcmpu CR6, FR11, FR31 */
		/* 82260328h case   53:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR31);
		/* 82260328h case   53:*/		return 0x8226032C;
		  /* 8226032Ch */ case   54:  		/* bc 12, CR6_EQ, 6804 */
		/* 8226032Ch case   54:*/		if ( regs.CR[6].eq ) { return 0x82261DC0;  }
		/* 8226032Ch case   54:*/		return 0x82260330;
	}
	return 0x82260330;
} // Block from 82260254h-82260330h (55 instructions)

//////////////////////////////////////////////////////
// Block at 82260330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260330);
		  /* 82260330h */ case    0:  		/* fcmpu CR6, FR0, FR30 */
		/* 82260330h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82260330h case    0:*/		return 0x82260334;
		  /* 82260334h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82260334h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82260350;  }
		/* 82260334h case    1:*/		return 0x82260338;
		  /* 82260338h */ case    2:  		/* fcmpu CR6, FR13, FR30 */
		/* 82260338h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR30);
		/* 82260338h case    2:*/		return 0x8226033C;
		  /* 8226033Ch */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 8226033Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82260350;  }
		/* 8226033Ch case    3:*/		return 0x82260340;
		  /* 82260340h */ case    4:  		/* fcmpu CR6, FR12, FR30 */
		/* 82260340h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR30);
		/* 82260340h case    4:*/		return 0x82260344;
		  /* 82260344h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82260344h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82260350;  }
		/* 82260344h case    5:*/		return 0x82260348;
		  /* 82260348h */ case    6:  		/* fcmpu CR6, FR11, FR30 */
		/* 82260348h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR30);
		/* 82260348h case    6:*/		return 0x8226034C;
		  /* 8226034Ch */ case    7:  		/* bc 12, CR6_EQ, 6772 */
		/* 8226034Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82261DC0;  }
		/* 8226034Ch case    7:*/		return 0x82260350;
	}
	return 0x82260350;
} // Block from 82260330h-82260350h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82260350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260350);
		  /* 82260350h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 82260350h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260350h case    0:*/		return 0x82260354;
		  /* 82260354h */ case    1:  		/* li R4, 0 */
		/* 82260354h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82260354h case    1:*/		return 0x82260358;
		  /* 82260358h */ case    2:  		/* lwz R11, <#[R10 + 1508]> */
		/* 82260358h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 82260358h case    2:*/		return 0x8226035C;
		  /* 8226035Ch */ case    3:  		/* addi R5, R11, -1 */
		/* 8226035Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 8226035Ch case    3:*/		return 0x82260360;
		  /* 82260360h */ case    4:  		/* stw R5, <#[R10 + 1508]> */
		/* 82260360h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x000005E4) );
		/* 82260360h case    4:*/		return 0x82260364;
		  /* 82260364h */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 82260364h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82260364h case    5:*/		return 0x82260368;
		  /* 82260368h */ case    6:  		/* bl -109400 */
		/* 82260368h case    6:*/		regs.LR = 0x8226036C; return 0x82245810;
		/* 82260368h case    6:*/		return 0x8226036C;
		  /* 8226036Ch */ case    7:  		/* mr R29, R3 */
		/* 8226036Ch case    7:*/		regs.R29 = regs.R3;
		/* 8226036Ch case    7:*/		return 0x82260370;
		  /* 82260370h */ case    8:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260370h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260370h case    8:*/		return 0x82260374;
		  /* 82260374h */ case    9:  		/* li R3, 109 */
		/* 82260374h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x6D);
		/* 82260374h case    9:*/		return 0x82260378;
		  /* 82260378h */ case   10:  		/* bl -42056 */
		/* 82260378h case   10:*/		regs.LR = 0x8226037C; return 0x82255F30;
		/* 82260378h case   10:*/		return 0x8226037C;
		  /* 8226037Ch */ case   11:  		/* mr R5, R29 */
		/* 8226037Ch case   11:*/		regs.R5 = regs.R29;
		/* 8226037Ch case   11:*/		return 0x82260380;
		  /* 82260380h */ case   12:  		/* li R4, 0 */
		/* 82260380h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82260380h case   12:*/		return 0x82260384;
		  /* 82260384h */ case   13:  		/* mr R30, R3 */
		/* 82260384h case   13:*/		regs.R30 = regs.R3;
		/* 82260384h case   13:*/		return 0x82260388;
		  /* 82260388h */ case   14:  		/* bl -40944 */
		/* 82260388h case   14:*/		regs.LR = 0x8226038C; return 0x82256398;
		/* 82260388h case   14:*/		return 0x8226038C;
		  /* 8226038Ch */ case   15:  		/* lwz R11, <#[R27 - 1288]> */
		/* 8226038Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAF8) );
		/* 8226038Ch case   15:*/		return 0x82260390;
		  /* 82260390h */ case   16:  		/* mr R5, R19 */
		/* 82260390h case   16:*/		regs.R5 = regs.R19;
		/* 82260390h case   16:*/		return 0x82260394;
		  /* 82260394h */ case   17:  		/* li R4, 1 */
		/* 82260394h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82260394h case   17:*/		return 0x82260398;
		  /* 82260398h */ case   18:  		/* mr R3, R30 */
		/* 82260398h case   18:*/		regs.R3 = regs.R30;
		/* 82260398h case   18:*/		return 0x8226039C;
		  /* 8226039Ch */ case   19:  		/* stw R11, <#[R30 + 128]> */
		/* 8226039Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 8226039Ch case   19:*/		return 0x822603A0;
		  /* 822603A0h */ case   20:  		/* bl -40968 */
		/* 822603A0h case   20:*/		regs.LR = 0x822603A4; return 0x82256398;
		/* 822603A0h case   20:*/		return 0x822603A4;
		  /* 822603A4h */ case   21:  		/* cmplwi CR6, R16, 0 */
		/* 822603A4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 822603A4h case   21:*/		return 0x822603A8;
		  /* 822603A8h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 822603A8h case   22:*/		if ( regs.CR[6].eq ) { return 0x822603B8;  }
		/* 822603A8h case   22:*/		return 0x822603AC;
		  /* 822603ACh */ case   23:  		/* mr R4, R21 */
		/* 822603ACh case   23:*/		regs.R4 = regs.R21;
		/* 822603ACh case   23:*/		return 0x822603B0;
		  /* 822603B0h */ case   24:  		/* mr R3, R30 */
		/* 822603B0h case   24:*/		regs.R3 = regs.R30;
		/* 822603B0h case   24:*/		return 0x822603B4;
		  /* 822603B4h */ case   25:  		/* bl -24836 */
		/* 822603B4h case   25:*/		regs.LR = 0x822603B8; return 0x8225A2B0;
		/* 822603B4h case   25:*/		return 0x822603B8;
	}
	return 0x822603B8;
} // Block from 82260350h-822603B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822603B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822603B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822603B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822603B8);
		  /* 822603B8h */ case    0:  		/* stw R25, <#[R30 + 176]> */
		/* 822603B8h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x000000B0) );
		/* 822603B8h case    0:*/		return 0x822603BC;
		  /* 822603BCh */ case    1:  		/* mr R4, R25 */
		/* 822603BCh case    1:*/		regs.R4 = regs.R25;
		/* 822603BCh case    1:*/		return 0x822603C0;
		  /* 822603C0h */ case    2:  		/* lwz R3, <#[R31 + 12]> */
		/* 822603C0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 822603C0h case    2:*/		return 0x822603C4;
		  /* 822603C4h */ case    3:  		/* bl -277764 */
		/* 822603C4h case    3:*/		regs.LR = 0x822603C8; return 0x8221C6C0;
		/* 822603C4h case    3:*/		return 0x822603C8;
		  /* 822603C8h */ case    4:  		/* stw R3, <#[R30 + 172]> */
		/* 822603C8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x000000AC) );
		/* 822603C8h case    4:*/		return 0x822603CC;
		  /* 822603CCh */ case    5:  		/* lwz R11, <#[R31 + 88]> */
		/* 822603CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 822603CCh case    5:*/		return 0x822603D0;
		  /* 822603D0h */ case    6:  		/* lwzx R11, <#[R17 + R11]> */
		/* 822603D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 822603D0h case    6:*/		return 0x822603D4;
		  /* 822603D4h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 822603D4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822603D4h case    7:*/		return 0x822603D8;
		  /* 822603D8h */ case    8:  		/* bc 12, CR6_LT, 32 */
		/* 822603D8h case    8:*/		if ( regs.CR[6].lt ) { return 0x822603F8;  }
		/* 822603D8h case    8:*/		return 0x822603DC;
		  /* 822603DCh */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 822603DCh case    9:*/		if ( regs.CR[6].eq ) { return 0x822603F0;  }
		/* 822603DCh case    9:*/		return 0x822603E0;
		  /* 822603E0h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 822603E0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 822603E0h case   10:*/		return 0x822603E4;
		  /* 822603E4h */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 822603E4h case   11:*/		if ( !regs.CR[6].lt ) { return 0x822603F8;  }
		/* 822603E4h case   11:*/		return 0x822603E8;
		  /* 822603E8h */ case   12:  		/* mr R11, R26 */
		/* 822603E8h case   12:*/		regs.R11 = regs.R26;
		/* 822603E8h case   12:*/		return 0x822603EC;
		  /* 822603ECh */ case   13:  		/* b 16 */
		/* 822603ECh case   13:*/		return 0x822603FC;
		/* 822603ECh case   13:*/		return 0x822603F0;
	}
	return 0x822603F0;
} // Block from 822603B8h-822603F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822603F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822603F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822603F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822603F0);
		  /* 822603F0h */ case    0:  		/* li R11, 0 */
		/* 822603F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822603F0h case    0:*/		return 0x822603F4;
		  /* 822603F4h */ case    1:  		/* b 8 */
		/* 822603F4h case    1:*/		return 0x822603FC;
		/* 822603F4h case    1:*/		return 0x822603F8;
	}
	return 0x822603F8;
} // Block from 822603F0h-822603F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822603F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822603F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822603F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822603F8);
		  /* 822603F8h */ case    0:  		/* li R11, 2 */
		/* 822603F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 822603F8h case    0:*/		return 0x822603FC;
	}
	return 0x822603FC;
} // Block from 822603F8h-822603FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822603FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822603FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822603FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822603FC);
		  /* 822603FCh */ case    0:  		/* stw R11, <#[R30 + 180]> */
		/* 822603FCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 822603FCh case    0:*/		return 0x82260400;
		  /* 82260400h */ case    1:  		/* mr R4, R30 */
		/* 82260400h case    1:*/		regs.R4 = regs.R30;
		/* 82260400h case    1:*/		return 0x82260404;
		  /* 82260404h */ case    2:  		/* stw R23, <#[R30 + 184]> */
		/* 82260404h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R30 + 0x000000B8) );
		/* 82260404h case    2:*/		return 0x82260408;
		  /* 82260408h */ case    3:  		/* mr R3, R31 */
		/* 82260408h case    3:*/		regs.R3 = regs.R31;
		/* 82260408h case    3:*/		return 0x8226040C;
		  /* 8226040Ch */ case    4:  		/* bl -171620 */
		/* 8226040Ch case    4:*/		regs.LR = 0x82260410; return 0x822365A8;
		/* 8226040Ch case    4:*/		return 0x82260410;
		  /* 82260410h */ case    5:  		/* mr R4, R30 */
		/* 82260410h case    5:*/		regs.R4 = regs.R30;
		/* 82260410h case    5:*/		return 0x82260414;
		  /* 82260414h */ case    6:  		/* mr R3, R14 */
		/* 82260414h case    6:*/		regs.R3 = regs.R14;
		/* 82260414h case    6:*/		return 0x82260418;
		  /* 82260418h */ case    7:  		/* bl -29928 */
		/* 82260418h case    7:*/		regs.LR = 0x8226041C; return 0x82258F30;
		/* 82260418h case    7:*/		return 0x8226041C;
		  /* 8226041Ch */ case    8:  		/* mr R3, R30 */
		/* 8226041Ch case    8:*/		regs.R3 = regs.R30;
		/* 8226041Ch case    8:*/		return 0x82260420;
		  /* 82260420h */ case    9:  		/* bl -42080 */
		/* 82260420h case    9:*/		regs.LR = 0x82260424; return 0x82255FC0;
		/* 82260420h case    9:*/		return 0x82260424;
		  /* 82260424h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82260424h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82260424h case   10:*/		return 0x82260428;
		  /* 82260428h */ case   11:  		/* bc 4, CR0_EQ, 28 */
		/* 82260428h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82260444;  }
		/* 82260428h case   11:*/		return 0x8226042C;
		  /* 8226042Ch */ case   12:  		/* mr R6, R22 */
		/* 8226042Ch case   12:*/		regs.R6 = regs.R22;
		/* 8226042Ch case   12:*/		return 0x82260430;
		  /* 82260430h */ case   13:  		/* mr R5, R28 */
		/* 82260430h case   13:*/		regs.R5 = regs.R28;
		/* 82260430h case   13:*/		return 0x82260434;
		  /* 82260434h */ case   14:  		/* mr R4, R24 */
		/* 82260434h case   14:*/		regs.R4 = regs.R24;
		/* 82260434h case   14:*/		return 0x82260438;
		  /* 82260438h */ case   15:  		/* li R7, 3283 */
		/* 82260438h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0xCD3);
		/* 82260438h case   15:*/		return 0x8226043C;
		  /* 8226043Ch */ case   16:  		/* li R3, 0 */
		/* 8226043Ch case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226043Ch case   16:*/		return 0x82260440;
		  /* 82260440h */ case   17:  		/* bl -1083448 */
		/* 82260440h case   17:*/		regs.LR = 0x82260444; return 0x82157C08;
		/* 82260440h case   17:*/		return 0x82260444;
	}
	return 0x82260444;
} // Block from 822603FCh-82260444h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82260444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260444);
		  /* 82260444h */ case    0:  		/* li R3, 20 */
		/* 82260444h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 82260444h case    0:*/		return 0x82260448;
		  /* 82260448h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260448h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260448h case    1:*/		return 0x8226044C;
		  /* 8226044Ch */ case    2:  		/* bl -42268 */
		/* 8226044Ch case    2:*/		regs.LR = 0x82260450; return 0x82255F30;
		/* 8226044Ch case    2:*/		return 0x82260450;
		  /* 82260450h */ case    3:  		/* mr R5, R18 */
		/* 82260450h case    3:*/		regs.R5 = regs.R18;
		/* 82260450h case    3:*/		return 0x82260454;
		  /* 82260454h */ case    4:  		/* li R4, 0 */
		/* 82260454h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82260454h case    4:*/		return 0x82260458;
		  /* 82260458h */ case    5:  		/* mr R30, R3 */
		/* 82260458h case    5:*/		regs.R30 = regs.R3;
		/* 82260458h case    5:*/		return 0x8226045C;
		  /* 8226045Ch */ case    6:  		/* bl -41156 */
		/* 8226045Ch case    6:*/		regs.LR = 0x82260460; return 0x82256398;
		/* 8226045Ch case    6:*/		return 0x82260460;
		  /* 82260460h */ case    7:  		/* mr R3, R30 */
		/* 82260460h case    7:*/		regs.R3 = regs.R30;
		/* 82260460h case    7:*/		return 0x82260464;
		  /* 82260464h */ case    8:  		/* mr R5, R29 */
		/* 82260464h case    8:*/		regs.R5 = regs.R29;
		/* 82260464h case    8:*/		return 0x82260468;
		  /* 82260468h */ case    9:  		/* li R4, 1 */
		/* 82260468h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82260468h case    9:*/		return 0x8226046C;
		  /* 8226046Ch */ case   10:  		/* bl -41172 */
		/* 8226046Ch case   10:*/		regs.LR = 0x82260470; return 0x82256398;
		/* 8226046Ch case   10:*/		return 0x82260470;
		  /* 82260470h */ case   11:  		/* mr R3, R30 */
		/* 82260470h case   11:*/		regs.R3 = regs.R30;
		/* 82260470h case   11:*/		return 0x82260474;
		  /* 82260474h */ case   12:  		/* li R5, 2 */
		/* 82260474h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82260474h case   12:*/		return 0x82260478;
		  /* 82260478h */ case   13:  		/* lfs FR4, <#[R1 + 360]> */
		/* 82260478h case   13:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R1 + 0x00000168) );
		/* 82260478h case   13:*/		return 0x8226047C;
		  /* 8226047Ch */ case   14:  		/* mr R4, R31 */
		/* 8226047Ch case   14:*/		regs.R4 = regs.R31;
		/* 8226047Ch case   14:*/		return 0x82260480;
		  /* 82260480h */ case   15:  		/* lfs FR3, <#[R1 + 348]> */
		/* 82260480h case   15:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R1 + 0x0000015C) );
		/* 82260480h case   15:*/		return 0x82260484;
		  /* 82260484h */ case   16:  		/* lfs FR2, <#[R1 + 332]> */
		/* 82260484h case   16:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x0000014C) );
		/* 82260484h case   16:*/		return 0x82260488;
		  /* 82260488h */ case   17:  		/* lfs FR1, <#[R1 + 364]> */
		/* 82260488h case   17:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x0000016C) );
		/* 82260488h case   17:*/		return 0x8226048C;
		  /* 8226048Ch */ case   18:  		/* bl -38260 */
		/* 8226048Ch case   18:*/		regs.LR = 0x82260490; return 0x82256F18;
		/* 8226048Ch case   18:*/		return 0x82260490;
		  /* 82260490h */ case   19:  		/* mr R3, R30 */
		/* 82260490h case   19:*/		regs.R3 = regs.R30;
		/* 82260490h case   19:*/		return 0x82260494;
		  /* 82260494h */ case   20:  		/* mr R5, R18 */
		/* 82260494h case   20:*/		regs.R5 = regs.R18;
		/* 82260494h case   20:*/		return 0x82260498;
		  /* 82260498h */ case   21:  		/* li R4, 3 */
		/* 82260498h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82260498h case   21:*/		return 0x8226049C;
		  /* 8226049Ch */ case   22:  		/* bl -41220 */
		/* 8226049Ch case   22:*/		regs.LR = 0x822604A0; return 0x82256398;
		/* 8226049Ch case   22:*/		return 0x822604A0;
		  /* 822604A0h */ case   23:  		/* mr R4, R30 */
		/* 822604A0h case   23:*/		regs.R4 = regs.R30;
		/* 822604A0h case   23:*/		return 0x822604A4;
		  /* 822604A4h */ case   24:  		/* mr R3, R31 */
		/* 822604A4h case   24:*/		regs.R3 = regs.R31;
		/* 822604A4h case   24:*/		return 0x822604A8;
		  /* 822604A8h */ case   25:  		/* bl -171776 */
		/* 822604A8h case   25:*/		regs.LR = 0x822604AC; return 0x822365A8;
		/* 822604A8h case   25:*/		return 0x822604AC;
		  /* 822604ACh */ case   26:  		/* mr R4, R30 */
		/* 822604ACh case   26:*/		regs.R4 = regs.R30;
		/* 822604ACh case   26:*/		return 0x822604B0;
		  /* 822604B0h */ case   27:  		/* mr R3, R14 */
		/* 822604B0h case   27:*/		regs.R3 = regs.R14;
		/* 822604B0h case   27:*/		return 0x822604B4;
		  /* 822604B4h */ case   28:  		/* bl -30084 */
		/* 822604B4h case   28:*/		regs.LR = 0x822604B8; return 0x82258F30;
		/* 822604B4h case   28:*/		return 0x822604B8;
		  /* 822604B8h */ case   29:  		/* mr R3, R30 */
		/* 822604B8h case   29:*/		regs.R3 = regs.R30;
		/* 822604B8h case   29:*/		return 0x822604BC;
		  /* 822604BCh */ case   30:  		/* bl -42236 */
		/* 822604BCh case   30:*/		regs.LR = 0x822604C0; return 0x82255FC0;
		/* 822604BCh case   30:*/		return 0x822604C0;
		  /* 822604C0h */ case   31:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822604C0h case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822604C0h case   31:*/		return 0x822604C4;
		  /* 822604C4h */ case   32:  		/* bc 4, CR0_EQ, 28 */
		/* 822604C4h case   32:*/		if ( !regs.CR[0].eq ) { return 0x822604E0;  }
		/* 822604C4h case   32:*/		return 0x822604C8;
		  /* 822604C8h */ case   33:  		/* mr R6, R22 */
		/* 822604C8h case   33:*/		regs.R6 = regs.R22;
		/* 822604C8h case   33:*/		return 0x822604CC;
		  /* 822604CCh */ case   34:  		/* mr R5, R28 */
		/* 822604CCh case   34:*/		regs.R5 = regs.R28;
		/* 822604CCh case   34:*/		return 0x822604D0;
		  /* 822604D0h */ case   35:  		/* mr R4, R24 */
		/* 822604D0h case   35:*/		regs.R4 = regs.R24;
		/* 822604D0h case   35:*/		return 0x822604D4;
		  /* 822604D4h */ case   36:  		/* li R7, 3293 */
		/* 822604D4h case   36:*/		cpu::op::li<0>(regs,&regs.R7,0xCDD);
		/* 822604D4h case   36:*/		return 0x822604D8;
		  /* 822604D8h */ case   37:  		/* li R3, 0 */
		/* 822604D8h case   37:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822604D8h case   37:*/		return 0x822604DC;
		  /* 822604DCh */ case   38:  		/* bl -1083604 */
		/* 822604DCh case   38:*/		regs.LR = 0x822604E0; return 0x82157C08;
		/* 822604DCh case   38:*/		return 0x822604E0;
	}
	return 0x822604E0;
} // Block from 82260444h-822604E0h (39 instructions)

//////////////////////////////////////////////////////
// Block at 822604E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822604E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822604E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822604E0);
		  /* 822604E0h */ case    0:  		/* lwz R11, <#[R27 - 1320]> */
		/* 822604E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFFFAD8) );
		/* 822604E0h case    0:*/		return 0x822604E4;
		  /* 822604E4h */ case    1:  		/* li R3, 49 */
		/* 822604E4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 822604E4h case    1:*/		return 0x822604E8;
		  /* 822604E8h */ case    2:  		/* lwz R30, <#[R27 - 1312]> */
		/* 822604E8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0xFFFFFAE0) );
		/* 822604E8h case    2:*/		return 0x822604EC;
		  /* 822604ECh */ case    3:  		/* lwz R4, <#[R31 + 12]> */
		/* 822604ECh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822604ECh case    3:*/		return 0x822604F0;
		  /* 822604F0h */ case    4:  		/* stw R11, <#[R1 + 152]> */
		/* 822604F0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 822604F0h case    4:*/		return 0x822604F4;
		  /* 822604F4h */ case    5:  		/* stw R30, <#[R1 + 236]> */
		/* 822604F4h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x000000EC) );
		/* 822604F4h case    5:*/		return 0x822604F8;
		  /* 822604F8h */ case    6:  		/* bl -42440 */
		/* 822604F8h case    6:*/		regs.LR = 0x822604FC; return 0x82255F30;
		/* 822604F8h case    6:*/		return 0x822604FC;
		  /* 822604FCh */ case    7:  		/* addi R10, R1, 152 */
		/* 822604FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x98);
		/* 822604FCh case    7:*/		return 0x82260500;
		  /* 82260500h */ case    8:  		/* stb R26, <#[R1 + 103]> */
		/* 82260500h case    8:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x00000067) );
		/* 82260500h case    8:*/		return 0x82260504;
		  /* 82260504h */ case    9:  		/* lwz R11, <#[R1 + 228]> */
		/* 82260504h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000E4) );
		/* 82260504h case    9:*/		return 0x82260508;
		  /* 82260508h */ case   10:  		/* mr R15, R3 */
		/* 82260508h case   10:*/		regs.R15 = regs.R3;
		/* 82260508h case   10:*/		return 0x8226050C;
		  /* 8226050Ch */ case   11:  		/* stw R10, <#[R1 + 84]> */
		/* 8226050Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8226050Ch case   11:*/		return 0x82260510;
		  /* 82260510h */ case   12:  		/* mr R10, R30 */
		/* 82260510h case   12:*/		regs.R10 = regs.R30;
		/* 82260510h case   12:*/		return 0x82260514;
		  /* 82260514h */ case   13:  		/* lwz R30, <#[R1 + 164]> */
		/* 82260514h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A4) );
		/* 82260514h case   13:*/		return 0x82260518;
		  /* 82260518h */ case   14:  		/* mr R8, R3 */
		/* 82260518h case   14:*/		regs.R8 = regs.R3;
		/* 82260518h case   14:*/		return 0x8226051C;
		  /* 8226051Ch */ case   15:  		/* li R9, 1 */
		/* 8226051Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8226051Ch case   15:*/		return 0x82260520;
		  /* 82260520h */ case   16:  		/* lwz R7, <#[R1 + 180]> */
		/* 82260520h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000B4) );
		/* 82260520h case   16:*/		return 0x82260524;
		  /* 82260524h */ case   17:  		/* li R5, 0 */
		/* 82260524h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82260524h case   17:*/		return 0x82260528;
		  /* 82260528h */ case   18:  		/* lwz R6, <#[R1 + 224]> */
		/* 82260528h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000E0) );
		/* 82260528h case   18:*/		return 0x8226052C;
		  /* 8226052Ch */ case   19:  		/* li R4, 0 */
		/* 8226052Ch case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8226052Ch case   19:*/		return 0x82260530;
		  /* 82260530h */ case   20:  		/* stw R11, <#[R1 + 108]> */
		/* 82260530h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82260530h case   20:*/		return 0x82260534;
		  /* 82260534h */ case   21:  		/* mr R3, R31 */
		/* 82260534h case   21:*/		regs.R3 = regs.R31;
		/* 82260534h case   21:*/		return 0x82260538;
		  /* 82260538h */ case   22:  		/* stw R14, <#[R1 + 116]> */
		/* 82260538h case   22:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000074) );
		/* 82260538h case   22:*/		return 0x8226053C;
		  /* 8226053Ch */ case   23:  		/* stw R30, <#[R1 + 92]> */
		/* 8226053Ch case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 8226053Ch case   23:*/		return 0x82260540;
		  /* 82260540h */ case   24:  		/* bl -14192 */
		/* 82260540h case   24:*/		regs.LR = 0x82260544; return 0x8225CDD0;
		/* 82260540h case   24:*/		return 0x82260544;
		  /* 82260544h */ case   25:  		/* mr R3, R15 */
		/* 82260544h case   25:*/		regs.R3 = regs.R15;
		/* 82260544h case   25:*/		return 0x82260548;
		  /* 82260548h */ case   26:  		/* mr R5, R18 */
		/* 82260548h case   26:*/		regs.R5 = regs.R18;
		/* 82260548h case   26:*/		return 0x8226054C;
		  /* 8226054Ch */ case   27:  		/* li R4, 1 */
		/* 8226054Ch case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8226054Ch case   27:*/		return 0x82260550;
		  /* 82260550h */ case   28:  		/* bl -41400 */
		/* 82260550h case   28:*/		regs.LR = 0x82260554; return 0x82256398;
		/* 82260550h case   28:*/		return 0x82260554;
		  /* 82260554h */ case   29:  		/* mr R4, R15 */
		/* 82260554h case   29:*/		regs.R4 = regs.R15;
		/* 82260554h case   29:*/		return 0x82260558;
		  /* 82260558h */ case   30:  		/* mr R3, R31 */
		/* 82260558h case   30:*/		regs.R3 = regs.R31;
		/* 82260558h case   30:*/		return 0x8226055C;
		  /* 8226055Ch */ case   31:  		/* bl -171956 */
		/* 8226055Ch case   31:*/		regs.LR = 0x82260560; return 0x822365A8;
		/* 8226055Ch case   31:*/		return 0x82260560;
		  /* 82260560h */ case   32:  		/* mr R4, R15 */
		/* 82260560h case   32:*/		regs.R4 = regs.R15;
		/* 82260560h case   32:*/		return 0x82260564;
		  /* 82260564h */ case   33:  		/* mr R3, R14 */
		/* 82260564h case   33:*/		regs.R3 = regs.R14;
		/* 82260564h case   33:*/		return 0x82260568;
		  /* 82260568h */ case   34:  		/* bl -30264 */
		/* 82260568h case   34:*/		regs.LR = 0x8226056C; return 0x82258F30;
		/* 82260568h case   34:*/		return 0x8226056C;
		  /* 8226056Ch */ case   35:  		/* mr R3, R15 */
		/* 8226056Ch case   35:*/		regs.R3 = regs.R15;
		/* 8226056Ch case   35:*/		return 0x82260570;
		  /* 82260570h */ case   36:  		/* bl -42416 */
		/* 82260570h case   36:*/		regs.LR = 0x82260574; return 0x82255FC0;
		/* 82260570h case   36:*/		return 0x82260574;
		  /* 82260574h */ case   37:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82260574h case   37:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82260574h case   37:*/		return 0x82260578;
		  /* 82260578h */ case   38:  		/* bc 4, CR0_EQ, 6216 */
		/* 82260578h case   38:*/		if ( !regs.CR[0].eq ) { return 0x82261DC0;  }
		/* 82260578h case   38:*/		return 0x8226057C;
		  /* 8226057Ch */ case   39:  		/* mr R6, R22 */
		/* 8226057Ch case   39:*/		regs.R6 = regs.R22;
		/* 8226057Ch case   39:*/		return 0x82260580;
		  /* 82260580h */ case   40:  		/* mr R5, R28 */
		/* 82260580h case   40:*/		regs.R5 = regs.R28;
		/* 82260580h case   40:*/		return 0x82260584;
		  /* 82260584h */ case   41:  		/* mr R4, R24 */
		/* 82260584h case   41:*/		regs.R4 = regs.R24;
		/* 82260584h case   41:*/		return 0x82260588;
		  /* 82260588h */ case   42:  		/* li R7, 3309 */
		/* 82260588h case   42:*/		cpu::op::li<0>(regs,&regs.R7,0xCED);
		/* 82260588h case   42:*/		return 0x8226058C;
		  /* 8226058Ch */ case   43:  		/* li R3, 0 */
		/* 8226058Ch case   43:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226058Ch case   43:*/		return 0x82260590;
		  /* 82260590h */ case   44:  		/* bl -1083784 */
		/* 82260590h case   44:*/		regs.LR = 0x82260594; return 0x82157C08;
		/* 82260590h case   44:*/		return 0x82260594;
		  /* 82260594h */ case   45:  		/* b 6188 */
		/* 82260594h case   45:*/		return 0x82261DC0;
		/* 82260594h case   45:*/		return 0x82260598;
		  /* 82260598h */ case   46:  		/* lwz R11, <#[R1 + 176]> */
		/* 82260598h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260598h case   46:*/		return 0x8226059C;
		  /* 8226059Ch */ case   47:  		/* lwz R10, <#[R15 + 184]> */
		/* 8226059Ch case   47:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x000000B8) );
		/* 8226059Ch case   47:*/		return 0x822605A0;
		  /* 822605A0h */ case   48:  		/* lbz R11, <#[R11]> */
		/* 822605A0h case   48:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822605A0h case   48:*/		return 0x822605A4;
		  /* 822605A4h */ case   49:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 822605A4h case   49:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822605A4h case   49:*/		return 0x822605A8;
		  /* 822605A8h */ case   50:  		/* sth R11, <#[R10 + 18]> */
		/* 822605A8h case   50:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000012) );
		/* 822605A8h case   50:*/		return 0x822605AC;
		  /* 822605ACh */ case   51:  		/* b 6164 */
		/* 822605ACh case   51:*/		return 0x82261DC0;
		/* 822605ACh case   51:*/		return 0x822605B0;
		  /* 822605B0h */ case   52:  		/* lwz R11, <#[R1 + 140]> */
		/* 822605B0h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 822605B0h case   52:*/		return 0x822605B4;
		  /* 822605B4h */ case   53:  		/* lwz R10, <#[R1 + 144]> */
		/* 822605B4h case   53:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 822605B4h case   53:*/		return 0x822605B8;
		  /* 822605B8h */ case   54:  		/* addi R11, R11, 1 */
		/* 822605B8h case   54:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822605B8h case   54:*/		return 0x822605BC;
		  /* 822605BCh */ case   55:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 822605BCh case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 822605BCh case   55:*/		return 0x822605C0;
		  /* 822605C0h */ case   56:  		/* stw R11, <#[R1 + 140]> */
		/* 822605C0h case   56:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 822605C0h case   56:*/		return 0x822605C4;
		  /* 822605C4h */ case   57:  		/* lwbrx R11, <#[R9 + R10]> */
		/* 822605C4h case   57:*/		cpu::mem::lwbrx( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822605C4h case   57:*/		return 0x822605C8;
		  /* 822605C8h */ case   58:  		/* stw R11, <#[R1 + 236]> */
		/* 822605C8h case   58:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000EC) );
		/* 822605C8h case   58:*/		return 0x822605CC;
		  /* 822605CCh */ case   59:  		/* b 6132 */
		/* 822605CCh case   59:*/		return 0x82261DC0;
		/* 822605CCh case   59:*/		return 0x822605D0;
		  /* 822605D0h */ case   60:  		/* li R11, 1 */
		/* 822605D0h case   60:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822605D0h case   60:*/		return 0x822605D4;
		  /* 822605D4h */ case   61:  		/* stb R11, <#[R1 + 200]> */
		/* 822605D4h case   61:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x000000C8) );
		/* 822605D4h case   61:*/		return 0x822605D8;
		  /* 822605D8h */ case   62:  		/* b 6120 */
		/* 822605D8h case   62:*/		return 0x82261DC0;
		/* 822605D8h case   62:*/		return 0x822605DC;
		  /* 822605DCh */ case   63:  		/* lwz R11, <#[R1 + 140]> */
		/* 822605DCh case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 822605DCh case   63:*/		return 0x822605E0;
		  /* 822605E0h */ case   64:  		/* lwz R10, <#[R1 + 144]> */
		/* 822605E0h case   64:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 822605E0h case   64:*/		return 0x822605E4;
		  /* 822605E4h */ case   65:  		/* addi R11, R11, 1 */
		/* 822605E4h case   65:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822605E4h case   65:*/		return 0x822605E8;
		  /* 822605E8h */ case   66:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 822605E8h case   66:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 822605E8h case   66:*/		return 0x822605EC;
		  /* 822605ECh */ case   67:  		/* stw R11, <#[R1 + 140]> */
		/* 822605ECh case   67:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 822605ECh case   67:*/		return 0x822605F0;
		  /* 822605F0h */ case   68:  		/* lwbrx R11, <#[R9 + R10]> */
		/* 822605F0h case   68:*/		cpu::mem::lwbrx( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822605F0h case   68:*/		return 0x822605F4;
		  /* 822605F4h */ case   69:  		/* stw R11, <#[R1 + 152]> */
		/* 822605F4h case   69:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 822605F4h case   69:*/		return 0x822605F8;
		  /* 822605F8h */ case   70:  		/* b 6088 */
		/* 822605F8h case   70:*/		return 0x82261DC0;
		/* 822605F8h case   70:*/		return 0x822605FC;
		  /* 822605FCh */ case   71:  		/* lwz R29, <#[R31 + 12]> */
		/* 822605FCh case   71:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 822605FCh case   71:*/		return 0x82260600;
		  /* 82260600h */ case   72:  		/* lwz R11, <#[R1 + 176]> */
		/* 82260600h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260600h case   72:*/		return 0x82260604;
		  /* 82260604h */ case   73:  		/* lwz R3, <#[R29 + 1488]> */
		/* 82260604h case   73:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 82260604h case   73:*/		return 0x82260608;
		  /* 82260608h */ case   74:  		/* lbz R30, <#[R11 + 1]> */
		/* 82260608h case   74:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000001) );
		/* 82260608h case   74:*/		return 0x8226060C;
		  /* 8226060Ch */ case   75:  		/* lwz R28, <#[R29 + 1536]> */
		/* 8226060Ch case   75:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000600) );
		/* 8226060Ch case   75:*/		return 0x82260610;
		  /* 82260610h */ case   76:  		/* lwz R11, <#[R3]> */
		/* 82260610h case   76:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82260610h case   76:*/		return 0x82260614;
		  /* 82260614h */ case   77:  		/* lwz R11, <#[R11 + 28]> */
		/* 82260614h case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82260614h case   77:*/		return 0x82260618;
		  /* 82260618h */ case   78:  		/* mtspr CTR, R11 */
		/* 82260618h case   78:*/		regs.CTR = regs.R11;
		/* 82260618h case   78:*/		return 0x8226061C;
		  /* 8226061Ch */ case   79:  		/* bcctrl 20, CR0_LT */
		/* 8226061Ch case   79:*/		if ( 1 ) { regs.LR = 0x82260620; return (uint32)regs.CTR; }
		/* 8226061Ch case   79:*/		return 0x82260620;
		  /* 82260620h */ case   80:  		/* lis R11, -32222 */
		/* 82260620h case   80:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82260620h case   80:*/		return 0x82260624;
		  /* 82260624h */ case   81:  		/* mr R5, R3 */
		/* 82260624h case   81:*/		regs.R5 = regs.R3;
		/* 82260624h case   81:*/		return 0x82260628;
		  /* 82260628h */ case   82:  		/* mr R4, R30 */
		/* 82260628h case   82:*/		regs.R4 = regs.R30;
		/* 82260628h case   82:*/		return 0x8226062C;
		  /* 8226062Ch */ case   83:  		/* mr R3, R28 */
		/* 8226062Ch case   83:*/		regs.R3 = regs.R28;
		/* 8226062Ch case   83:*/		return 0x82260630;
		  /* 82260630h */ case   84:  		/* addi R6, R11, -12392 */
		/* 82260630h case   84:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 82260630h case   84:*/		return 0x82260634;
		  /* 82260634h */ case   85:  		/* mr R7, R29 */
		/* 82260634h case   85:*/		regs.R7 = regs.R29;
		/* 82260634h case   85:*/		return 0x82260638;
		  /* 82260638h */ case   86:  		/* bl -197512 */
		/* 82260638h case   86:*/		regs.LR = 0x8226063C; return 0x822302B0;
		/* 82260638h case   86:*/		return 0x8226063C;
		  /* 8226063Ch */ case   87:  		/* cmpwi CR6, R3, 1 */
		/* 8226063Ch case   87:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 8226063Ch case   87:*/		return 0x82260640;
		  /* 82260640h */ case   88:  		/* bc 4, CR6_EQ, 68 */
		/* 82260640h case   88:*/		if ( !regs.CR[6].eq ) { return 0x82260684;  }
		/* 82260640h case   88:*/		return 0x82260644;
		  /* 82260644h */ case   89:  		/* lwz R11, <#[R15]> */
		/* 82260644h case   89:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82260644h case   89:*/		return 0x82260648;
		  /* 82260648h */ case   90:  		/* mr R3, R15 */
		/* 82260648h case   90:*/		regs.R3 = regs.R15;
		/* 82260648h case   90:*/		return 0x8226064C;
		  /* 8226064Ch */ case   91:  		/* lwz R11, <#[R11 + 4]> */
		/* 8226064Ch case   91:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8226064Ch case   91:*/		return 0x82260650;
		  /* 82260650h */ case   92:  		/* mtspr CTR, R11 */
		/* 82260650h case   92:*/		regs.CTR = regs.R11;
		/* 82260650h case   92:*/		return 0x82260654;
		  /* 82260654h */ case   93:  		/* bcctrl 20, CR0_LT */
		/* 82260654h case   93:*/		if ( 1 ) { regs.LR = 0x82260658; return (uint32)regs.CTR; }
		/* 82260654h case   93:*/		return 0x82260658;
		  /* 82260658h */ case   94:  		/* addi R11, R3, 1 */
		/* 82260658h case   94:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82260658h case   94:*/		return 0x8226065C;
		  /* 8226065Ch */ case   95:  		/* li R10, 28 */
		/* 8226065Ch case   95:*/		cpu::op::li<0>(regs,&regs.R10,0x1C);
		/* 8226065Ch case   95:*/		return 0x82260660;
		  /* 82260660h */ case   96:  		/* addi R9, R11, 20 */
		/* 82260660h case   96:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x14);
		/* 82260660h case   96:*/		return 0x82260664;
		  /* 82260664h */ case   97:  		/* addi R11, R11, 14 */
		/* 82260664h case   97:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xE);
		/* 82260664h case   97:*/		return 0x82260668;
		  /* 82260668h */ case   98:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82260668h case   98:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82260668h case   98:*/		return 0x8226066C;
		  /* 8226066Ch */ case   99:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226066Ch case   99:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226066Ch case   99:*/		return 0x82260670;
		  /* 82260670h */ case  100:  		/* stwx R10, <#[R9 + R15]> */
		/* 82260670h case  100:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R15 + 0x00000000) );
		/* 82260670h case  100:*/		return 0x82260674;
		  /* 82260674h */ case  101:  		/* stwx R30, <#[R11 + R15]> */
		/* 82260674h case  101:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82260674h case  101:*/		return 0x82260678;
		  /* 82260678h */ case  102:  		/* lwz R11, <#[R15 + 20]> */
		/* 82260678h case  102:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000014) );
		/* 82260678h case  102:*/		return 0x8226067C;
		  /* 8226067Ch */ case  103:  		/* addi R11, R11, 1 */
		/* 8226067Ch case  103:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226067Ch case  103:*/		return 0x82260680;
		  /* 82260680h */ case  104:  		/* stw R11, <#[R15 + 20]> */
		/* 82260680h case  104:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000014) );
		/* 82260680h case  104:*/		return 0x82260684;
	}
	return 0x82260684;
} // Block from 822604E0h-82260684h (105 instructions)

//////////////////////////////////////////////////////
// Block at 82260684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260684);
		  /* 82260684h */ case    0:  		/* rlwinm R11, R30, 27, 5, 31 */
		/* 82260684h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R30);
		/* 82260684h case    0:*/		return 0x82260688;
		  /* 82260688h */ case    1:  		/* lwz R10, <#[R1 + 260]> */
		/* 82260688h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 82260688h case    1:*/		return 0x8226068C;
		  /* 8226068Ch */ case    2:  		/* rlwinm R9, R30, 0, 27, 31 */
		/* 8226068Ch case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R30);
		/* 8226068Ch case    2:*/		return 0x82260690;
		  /* 82260690h */ case    3:  		/* addi R11, R11, 2 */
		/* 82260690h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82260690h case    3:*/		return 0x82260694;
		  /* 82260694h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82260694h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82260694h case    4:*/		return 0x82260698;
		  /* 82260698h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82260698h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82260698h case    5:*/		return 0x8226069C;
		  /* 8226069Ch */ case    6:  		/* srw R11, R11, R9 */
		/* 8226069Ch case    6:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8226069Ch case    6:*/		return 0x822606A0;
		  /* 822606A0h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822606A0h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822606A0h case    7:*/		return 0x822606A4;
		  /* 822606A4h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 822606A4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x822606B8;  }
		/* 822606A4h case    8:*/		return 0x822606A8;
		  /* 822606A8h */ case    9:  		/* mr R5, R30 */
		/* 822606A8h case    9:*/		regs.R5 = regs.R30;
		/* 822606A8h case    9:*/		return 0x822606AC;
		  /* 822606ACh */ case   10:  		/* lwz R4, <#[R1 + 520]> */
		/* 822606ACh case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000208) );
		/* 822606ACh case   10:*/		return 0x822606B0;
		  /* 822606B0h */ case   11:  		/* lwz R3, <#[R31 + 12]> */
		/* 822606B0h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 822606B0h case   11:*/		return 0x822606B4;
		  /* 822606B4h */ case   12:  		/* bl -275188 */
		/* 822606B4h case   12:*/		regs.LR = 0x822606B8; return 0x8221D3C0;
		/* 822606B4h case   12:*/		return 0x822606B8;
	}
	return 0x822606B8;
} // Block from 82260684h-822606B8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822606B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822606B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822606B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822606B8);
		  /* 822606B8h */ case    0:  		/* stw R30, <#[R15 + 176]> */
		/* 822606B8h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R15 + 0x000000B0) );
		/* 822606B8h case    0:*/		return 0x822606BC;
		  /* 822606BCh */ case    1:  		/* mr R4, R30 */
		/* 822606BCh case    1:*/		regs.R4 = regs.R30;
		/* 822606BCh case    1:*/		return 0x822606C0;
		  /* 822606C0h */ case    2:  		/* lwz R3, <#[R31 + 12]> */
		/* 822606C0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 822606C0h case    2:*/		return 0x822606C4;
		  /* 822606C4h */ case    3:  		/* bl -278532 */
		/* 822606C4h case    3:*/		regs.LR = 0x822606C8; return 0x8221C6C0;
		/* 822606C4h case    3:*/		return 0x822606C8;
		  /* 822606C8h */ case    4:  		/* stw R3, <#[R15 + 172]> */
		/* 822606C8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R15 + 0x000000AC) );
		/* 822606C8h case    4:*/		return 0x822606CC;
		  /* 822606CCh */ case    5:  		/* rlwinm R11, R30, 3, 0, 28 */
		/* 822606CCh case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R30);
		/* 822606CCh case    5:*/		return 0x822606D0;
		  /* 822606D0h */ case    6:  		/* lwz R10, <#[R31 + 88]> */
		/* 822606D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000058) );
		/* 822606D0h case    6:*/		return 0x822606D4;
		  /* 822606D4h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 822606D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822606D4h case    7:*/		return 0x822606D8;
		  /* 822606D8h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 822606D8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822606D8h case    8:*/		return 0x822606DC;
		  /* 822606DCh */ case    9:  		/* bc 12, CR6_LT, 32 */
		/* 822606DCh case    9:*/		if ( regs.CR[6].lt ) { return 0x822606FC;  }
		/* 822606DCh case    9:*/		return 0x822606E0;
		  /* 822606E0h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 822606E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x822606F4;  }
		/* 822606E0h case   10:*/		return 0x822606E4;
		  /* 822606E4h */ case   11:  		/* cmplwi CR6, R11, 3 */
		/* 822606E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 822606E4h case   11:*/		return 0x822606E8;
		  /* 822606E8h */ case   12:  		/* bc 4, CR6_LT, 20 */
		/* 822606E8h case   12:*/		if ( !regs.CR[6].lt ) { return 0x822606FC;  }
		/* 822606E8h case   12:*/		return 0x822606EC;
		  /* 822606ECh */ case   13:  		/* li R11, 1 */
		/* 822606ECh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822606ECh case   13:*/		return 0x822606F0;
		  /* 822606F0h */ case   14:  		/* b 16 */
		/* 822606F0h case   14:*/		return 0x82260700;
		/* 822606F0h case   14:*/		return 0x822606F4;
	}
	return 0x822606F4;
} // Block from 822606B8h-822606F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822606F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822606F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822606F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822606F4);
		  /* 822606F4h */ case    0:  		/* li R11, 0 */
		/* 822606F4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822606F4h case    0:*/		return 0x822606F8;
		  /* 822606F8h */ case    1:  		/* b 8 */
		/* 822606F8h case    1:*/		return 0x82260700;
		/* 822606F8h case    1:*/		return 0x822606FC;
	}
	return 0x822606FC;
} // Block from 822606F4h-822606FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822606FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822606FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822606FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822606FC);
		  /* 822606FCh */ case    0:  		/* li R11, 2 */
		/* 822606FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 822606FCh case    0:*/		return 0x82260700;
	}
	return 0x82260700;
} // Block from 822606FCh-82260700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260700);
		  /* 82260700h */ case    0:  		/* stw R11, <#[R15 + 180]> */
		/* 82260700h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x000000B4) );
		/* 82260700h case    0:*/		return 0x82260704;
		  /* 82260704h */ case    1:  		/* b 5820 */
		/* 82260704h case    1:*/		return 0x82261DC0;
		/* 82260704h case    1:*/		return 0x82260708;
		  /* 82260708h */ case    2:  		/* lwz R11, <#[R1 + 176]> */
		/* 82260708h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260708h case    2:*/		return 0x8226070C;
		  /* 8226070Ch */ case    3:  		/* lbz R10, <#[R11 + 1]> */
		/* 8226070Ch case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000001) );
		/* 8226070Ch case    3:*/		return 0x82260710;
		  /* 82260710h */ case    4:  		/* stw R10, <#[R15 + 176]> */
		/* 82260710h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R15 + 0x000000B0) );
		/* 82260710h case    4:*/		return 0x82260714;
		  /* 82260714h */ case    5:  		/* lbz R4, <#[R11 + 1]> */
		/* 82260714h case    5:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000001) );
		/* 82260714h case    5:*/		return 0x82260718;
		  /* 82260718h */ case    6:  		/* lwz R3, <#[R31 + 12]> */
		/* 82260718h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260718h case    6:*/		return 0x8226071C;
		  /* 8226071Ch */ case    7:  		/* bl -278620 */
		/* 8226071Ch case    7:*/		regs.LR = 0x82260720; return 0x8221C6C0;
		/* 8226071Ch case    7:*/		return 0x82260720;
		  /* 82260720h */ case    8:  		/* stw R3, <#[R15 + 172]> */
		/* 82260720h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R15 + 0x000000AC) );
		/* 82260720h case    8:*/		return 0x82260724;
		  /* 82260724h */ case    9:  		/* b 5788 */
		/* 82260724h case    9:*/		return 0x82261DC0;
		/* 82260724h case    9:*/		return 0x82260728;
		  /* 82260728h */ case   10:  		/* lwz R11, <#[R1 + 140]> */
		/* 82260728h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260728h case   10:*/		return 0x8226072C;
		  /* 8226072Ch */ case   11:  		/* li R5, 4 */
		/* 8226072Ch case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8226072Ch case   11:*/		return 0x82260730;
		  /* 82260730h */ case   12:  		/* lwz R10, <#[R1 + 144]> */
		/* 82260730h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82260730h case   12:*/		return 0x82260734;
		  /* 82260734h */ case   13:  		/* li R4, 3 */
		/* 82260734h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82260734h case   13:*/		return 0x82260738;
		  /* 82260738h */ case   14:  		/* addi R11, R11, 1 */
		/* 82260738h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82260738h case   14:*/		return 0x8226073C;
		  /* 8226073Ch */ case   15:  		/* lwz R30, <#[R15 + 184]> */
		/* 8226073Ch case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R15 + 0x000000B8) );
		/* 8226073Ch case   15:*/		return 0x82260740;
		  /* 82260740h */ case   16:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82260740h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82260740h case   16:*/		return 0x82260744;
		  /* 82260744h */ case   17:  		/* stw R11, <#[R1 + 140]> */
		/* 82260744h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260744h case   17:*/		return 0x82260748;
		  /* 82260748h */ case   18:  		/* lfsx FR1, <#[R9 + R10]> */
		/* 82260748h case   18:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82260748h case   18:*/		return 0x8226074C;
		  /* 8226074Ch */ case   19:  		/* bl -43796 */
		/* 8226074Ch case   19:*/		regs.LR = 0x82260750; return 0x82255C38;
		/* 8226074Ch case   19:*/		return 0x82260750;
		  /* 82260750h */ case   20:  		/* sth R3, <#[R30 + 24]> */
		/* 82260750h case   20:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 82260750h case   20:*/		return 0x82260754;
		  /* 82260754h */ case   21:  		/* b 5740 */
		/* 82260754h case   21:*/		return 0x82261DC0;
		/* 82260754h case   21:*/		return 0x82260758;
		  /* 82260758h */ case   22:  		/* lwz R11, <#[R1 + 176]> */
		/* 82260758h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260758h case   22:*/		return 0x8226075C;
		  /* 8226075Ch */ case   23:  		/* lhz R11, <#[R11]> */
		/* 8226075Ch case   23:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8226075Ch case   23:*/		return 0x82260760;
		  /* 82260760h */ case   24:  		/* rlwinm. R11, R11, 0, 19, 31 */
		/* 82260760h case   24:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82260760h case   24:*/		return 0x82260764;
		  /* 82260764h */ case   25:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260764h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260764h case   25:*/		return 0x82260768;
		  /* 82260768h */ case   26:  		/* addi R7, R11, 4916 */
		/* 82260768h case   26:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1334);
		/* 82260768h case   26:*/		return 0x8226076C;
		  /* 8226076Ch */ case   27:  		/* bc 12, CR0_EQ, 8 */
		/* 8226076Ch case   27:*/		if ( regs.CR[0].eq ) { return 0x82260774;  }
		/* 8226076Ch case   27:*/		return 0x82260770;
		  /* 82260770h */ case   28:  		/* addi R7, R11, 4868 */
		/* 82260770h case   28:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1304);
		/* 82260770h case   28:*/		return 0x82260774;
	}
	return 0x82260774;
} // Block from 82260700h-82260774h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82260774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260774);
		  /* 82260774h */ case    0:  		/* mr R6, R14 */
		/* 82260774h case    0:*/		regs.R6 = regs.R14;
		/* 82260774h case    0:*/		return 0x82260778;
		  /* 82260778h */ case    1:  		/* addi R5, R1, 140 */
		/* 82260778h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x8C);
		/* 82260778h case    1:*/		return 0x8226077C;
		  /* 8226077Ch */ case    2:  		/* lwz R8, <#[R1 + 148]> */
		/* 8226077Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000094) );
		/* 8226077Ch case    2:*/		return 0x82260780;
		  /* 82260780h */ case    3:  		/* mr R3, R31 */
		/* 82260780h case    3:*/		regs.R3 = regs.R31;
		/* 82260780h case    3:*/		return 0x82260784;
		  /* 82260784h */ case    4:  		/* lwz R4, <#[R1 + 144]> */
		/* 82260784h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000090) );
		/* 82260784h case    4:*/		return 0x82260788;
		  /* 82260788h */ case    5:  		/* bl -15640 */
		/* 82260788h case    5:*/		regs.LR = 0x8226078C; return 0x8225CA70;
		/* 82260788h case    5:*/		return 0x8226078C;
		  /* 8226078Ch */ case    6:  		/* stw R3, <#[R1 + 144]> */
		/* 8226078Ch case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000090) );
		/* 8226078Ch case    6:*/		return 0x82260790;
		  /* 82260790h */ case    7:  		/* b 5680 */
		/* 82260790h case    7:*/		return 0x82261DC0;
		/* 82260790h case    7:*/		return 0x82260794;
		  /* 82260794h */ case    8:  		/* li R7, 3389 */
		/* 82260794h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0xD3D);
		/* 82260794h case    8:*/		return 0x82260798;
		  /* 82260798h */ case    9:  		/* lwz R5, <#[R1 + 196]> */
		/* 82260798h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 82260798h case    9:*/		return 0x8226079C;
		  /* 8226079Ch */ case   10:  		/* lwz R6, <#[R1 + 128]> */
		/* 8226079Ch case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8226079Ch case   10:*/		return 0x822607A0;
		  /* 822607A0h */ case   11:  		/* lwz R4, <#[R1 + 132]> */
		/* 822607A0h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 822607A0h case   11:*/		return 0x822607A4;
		  /* 822607A4h */ case   12:  		/* b -536 */
		/* 822607A4h case   12:*/		return 0x8226058C;
		/* 822607A4h case   12:*/		return 0x822607A8;
		  /* 822607A8h */ case   13:  		/* lwz R11, <#[R1 + 176]> */
		/* 822607A8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 822607A8h case   13:*/		return 0x822607AC;
		  /* 822607ACh */ case   14:  		/* lhz R11, <#[R11]> */
		/* 822607ACh case   14:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822607ACh case   14:*/		return 0x822607B0;
		  /* 822607B0h */ case   15:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822607B0h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822607B0h case   15:*/		return 0x822607B4;
		  /* 822607B4h */ case   16:  		/* lwz R11, <#[R1 + 136]> */
		/* 822607B4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822607B4h case   16:*/		return 0x822607B8;
		  /* 822607B8h */ case   17:  		/* addi R7, R11, 6708 */
		/* 822607B8h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1A34);
		/* 822607B8h case   17:*/		return 0x822607BC;
		  /* 822607BCh */ case   18:  		/* bc 4, CR0_EQ, -72 */
		/* 822607BCh case   18:*/		if ( !regs.CR[0].eq ) { return 0x82260774;  }
		/* 822607BCh case   18:*/		return 0x822607C0;
		  /* 822607C0h */ case   19:  		/* addi R7, R11, 6852 */
		/* 822607C0h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1AC4);
		/* 822607C0h case   19:*/		return 0x822607C4;
		  /* 822607C4h */ case   20:  		/* b -80 */
		/* 822607C4h case   20:*/		return 0x82260774;
		/* 822607C4h case   20:*/		return 0x822607C8;
		  /* 822607C8h */ case   21:  		/* lwz R11, <#[R1 + 176]> */
		/* 822607C8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 822607C8h case   21:*/		return 0x822607CC;
		  /* 822607CCh */ case   22:  		/* lhz R11, <#[R11]> */
		/* 822607CCh case   22:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822607CCh case   22:*/		return 0x822607D0;
		  /* 822607D0h */ case   23:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 822607D0h case   23:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 822607D0h case   23:*/		return 0x822607D4;
		  /* 822607D4h */ case   24:  		/* cmplwi CR6, R11, 1 */
		/* 822607D4h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822607D4h case   24:*/		return 0x822607D8;
		  /* 822607D8h */ case   25:  		/* bc 12, CR6_LT, 120 */
		/* 822607D8h case   25:*/		if ( regs.CR[6].lt ) { return 0x82260850;  }
		/* 822607D8h case   25:*/		return 0x822607DC;
		  /* 822607DCh */ case   26:  		/* bc 12, CR6_EQ, 104 */
		/* 822607DCh case   26:*/		if ( regs.CR[6].eq ) { return 0x82260844;  }
		/* 822607DCh case   26:*/		return 0x822607E0;
		  /* 822607E0h */ case   27:  		/* cmplwi CR6, R11, 3 */
		/* 822607E0h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 822607E0h case   27:*/		return 0x822607E4;
		  /* 822607E4h */ case   28:  		/* bc 12, CR6_LT, 84 */
		/* 822607E4h case   28:*/		if ( regs.CR[6].lt ) { return 0x82260838;  }
		/* 822607E4h case   28:*/		return 0x822607E8;
		  /* 822607E8h */ case   29:  		/* bc 12, CR6_EQ, 68 */
		/* 822607E8h case   29:*/		if ( regs.CR[6].eq ) { return 0x8226082C;  }
		/* 822607E8h case   29:*/		return 0x822607EC;
		  /* 822607ECh */ case   30:  		/* cmplwi CR6, R11, 5 */
		/* 822607ECh case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 822607ECh case   30:*/		return 0x822607F0;
		  /* 822607F0h */ case   31:  		/* bc 12, CR6_LT, 48 */
		/* 822607F0h case   31:*/		if ( regs.CR[6].lt ) { return 0x82260820;  }
		/* 822607F0h case   31:*/		return 0x822607F4;
		  /* 822607F4h */ case   32:  		/* bc 12, CR6_EQ, 32 */
		/* 822607F4h case   32:*/		if ( regs.CR[6].eq ) { return 0x82260814;  }
		/* 822607F4h case   32:*/		return 0x822607F8;
		  /* 822607F8h */ case   33:  		/* li R7, 3424 */
		/* 822607F8h case   33:*/		cpu::op::li<0>(regs,&regs.R7,0xD60);
		/* 822607F8h case   33:*/		return 0x822607FC;
		  /* 822607FCh */ case   34:  		/* lwz R6, <#[R1 + 128]> */
		/* 822607FCh case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 822607FCh case   34:*/		return 0x82260800;
		  /* 82260800h */ case   35:  		/* li R3, 0 */
		/* 82260800h case   35:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260800h case   35:*/		return 0x82260804;
		  /* 82260804h */ case   36:  		/* lwz R5, <#[R1 + 196]> */
		/* 82260804h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 82260804h case   36:*/		return 0x82260808;
		  /* 82260808h */ case   37:  		/* lwz R4, <#[R1 + 132]> */
		/* 82260808h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82260808h case   37:*/		return 0x8226080C;
		  /* 8226080Ch */ case   38:  		/* bl -1084420 */
		/* 8226080Ch case   38:*/		regs.LR = 0x82260810; return 0x82157C08;
		/* 8226080Ch case   38:*/		return 0x82260810;
		  /* 82260810h */ case   39:  		/* b 76 */
		/* 82260810h case   39:*/		return 0x8226085C;
		/* 82260810h case   39:*/		return 0x82260814;
	}
	return 0x82260814;
} // Block from 82260774h-82260814h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82260814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260814);
		  /* 82260814h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260814h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260814h case    0:*/		return 0x82260818;
		  /* 82260818h */ case    1:  		/* addi R11, R11, 1568 */
		/* 82260818h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x620);
		/* 82260818h case    1:*/		return 0x8226081C;
		  /* 8226081Ch */ case    2:  		/* b 60 */
		/* 8226081Ch case    2:*/		return 0x82260858;
		/* 8226081Ch case    2:*/		return 0x82260820;
	}
	return 0x82260820;
} // Block from 82260814h-82260820h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82260820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260820);
		  /* 82260820h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260820h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260820h case    0:*/		return 0x82260824;
		  /* 82260824h */ case    1:  		/* addi R11, R11, 1596 */
		/* 82260824h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x63C);
		/* 82260824h case    1:*/		return 0x82260828;
		  /* 82260828h */ case    2:  		/* b 48 */
		/* 82260828h case    2:*/		return 0x82260858;
		/* 82260828h case    2:*/		return 0x8226082C;
	}
	return 0x8226082C;
} // Block from 82260820h-8226082Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226082Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226082C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226082C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226082C);
		  /* 8226082Ch */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 8226082Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 8226082Ch case    0:*/		return 0x82260830;
		  /* 82260830h */ case    1:  		/* addi R11, R11, 1540 */
		/* 82260830h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x604);
		/* 82260830h case    1:*/		return 0x82260834;
		  /* 82260834h */ case    2:  		/* b 36 */
		/* 82260834h case    2:*/		return 0x82260858;
		/* 82260834h case    2:*/		return 0x82260838;
	}
	return 0x82260838;
} // Block from 8226082Ch-82260838h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82260838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260838);
		  /* 82260838h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260838h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260838h case    0:*/		return 0x8226083C;
		  /* 8226083Ch */ case    1:  		/* addi R11, R11, 1512 */
		/* 8226083Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5E8);
		/* 8226083Ch case    1:*/		return 0x82260840;
		  /* 82260840h */ case    2:  		/* b 24 */
		/* 82260840h case    2:*/		return 0x82260858;
		/* 82260840h case    2:*/		return 0x82260844;
	}
	return 0x82260844;
} // Block from 82260838h-82260844h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82260844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260844);
		  /* 82260844h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260844h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260844h case    0:*/		return 0x82260848;
		  /* 82260848h */ case    1:  		/* addi R11, R11, 1456 */
		/* 82260848h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5B0);
		/* 82260848h case    1:*/		return 0x8226084C;
		  /* 8226084Ch */ case    2:  		/* b 12 */
		/* 8226084Ch case    2:*/		return 0x82260858;
		/* 8226084Ch case    2:*/		return 0x82260850;
	}
	return 0x82260850;
} // Block from 82260844h-82260850h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82260850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260850);
		  /* 82260850h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260850h case    0:*/		return 0x82260854;
		  /* 82260854h */ case    1:  		/* addi R11, R11, 1484 */
		/* 82260854h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5CC);
		/* 82260854h case    1:*/		return 0x82260858;
	}
	return 0x82260858;
} // Block from 82260850h-82260858h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82260858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260858);
		  /* 82260858h */ case    0:  		/* stw R11, <#[R1 + 232]> */
		/* 82260858h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000E8) );
		/* 82260858h case    0:*/		return 0x8226085C;
	}
	return 0x8226085C;
} // Block from 82260858h-8226085Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226085Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226085C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226085C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226085C);
		  /* 8226085Ch */ case    0:  		/* lwz R7, <#[R1 + 232]> */
		/* 8226085Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000E8) );
		/* 8226085Ch case    0:*/		return 0x82260860;
		  /* 82260860h */ case    1:  		/* b -236 */
		/* 82260860h case    1:*/		return 0x82260774;
		/* 82260860h case    1:*/		return 0x82260864;
		  /* 82260864h */ case    2:  		/* lwz R11, <#[R1 + 176]> */
		/* 82260864h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260864h case    2:*/		return 0x82260868;
		  /* 82260868h */ case    3:  		/* lhz R11, <#[R11]> */
		/* 82260868h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82260868h case    3:*/		return 0x8226086C;
		  /* 8226086Ch */ case    4:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8226086Ch case    4:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8226086Ch case    4:*/		return 0x82260870;
		  /* 82260870h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 82260870h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82260870h case    5:*/		return 0x82260874;
		  /* 82260874h */ case    6:  		/* bc 12, CR6_LT, 120 */
		/* 82260874h case    6:*/		if ( regs.CR[6].lt ) { return 0x822608EC;  }
		/* 82260874h case    6:*/		return 0x82260878;
		  /* 82260878h */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82260878h case    7:*/		if ( regs.CR[6].eq ) { return 0x822608E0;  }
		/* 82260878h case    7:*/		return 0x8226087C;
		  /* 8226087Ch */ case    8:  		/* cmplwi CR6, R11, 3 */
		/* 8226087Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226087Ch case    8:*/		return 0x82260880;
		  /* 82260880h */ case    9:  		/* bc 12, CR6_LT, 84 */
		/* 82260880h case    9:*/		if ( regs.CR[6].lt ) { return 0x822608D4;  }
		/* 82260880h case    9:*/		return 0x82260884;
		  /* 82260884h */ case   10:  		/* bc 12, CR6_EQ, 68 */
		/* 82260884h case   10:*/		if ( regs.CR[6].eq ) { return 0x822608C8;  }
		/* 82260884h case   10:*/		return 0x82260888;
		  /* 82260888h */ case   11:  		/* cmplwi CR6, R11, 5 */
		/* 82260888h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82260888h case   11:*/		return 0x8226088C;
		  /* 8226088Ch */ case   12:  		/* bc 12, CR6_LT, 48 */
		/* 8226088Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x822608BC;  }
		/* 8226088Ch case   12:*/		return 0x82260890;
		  /* 82260890h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 82260890h case   13:*/		if ( regs.CR[6].eq ) { return 0x822608B0;  }
		/* 82260890h case   13:*/		return 0x82260894;
		  /* 82260894h */ case   14:  		/* li R7, 3455 */
		/* 82260894h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0xD7F);
		/* 82260894h case   14:*/		return 0x82260898;
		  /* 82260898h */ case   15:  		/* lwz R6, <#[R1 + 128]> */
		/* 82260898h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82260898h case   15:*/		return 0x8226089C;
		  /* 8226089Ch */ case   16:  		/* li R3, 0 */
		/* 8226089Ch case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226089Ch case   16:*/		return 0x822608A0;
		  /* 822608A0h */ case   17:  		/* lwz R5, <#[R1 + 196]> */
		/* 822608A0h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 822608A0h case   17:*/		return 0x822608A4;
		  /* 822608A4h */ case   18:  		/* lwz R4, <#[R1 + 132]> */
		/* 822608A4h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 822608A4h case   18:*/		return 0x822608A8;
		  /* 822608A8h */ case   19:  		/* bl -1084576 */
		/* 822608A8h case   19:*/		regs.LR = 0x822608AC; return 0x82157C08;
		/* 822608A8h case   19:*/		return 0x822608AC;
		  /* 822608ACh */ case   20:  		/* b 76 */
		/* 822608ACh case   20:*/		return 0x822608F8;
		/* 822608ACh case   20:*/		return 0x822608B0;
	}
	return 0x822608B0;
} // Block from 8226085Ch-822608B0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822608B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608B0);
		  /* 822608B0h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822608B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822608B0h case    0:*/		return 0x822608B4;
		  /* 822608B4h */ case    1:  		/* addi R11, R11, 1408 */
		/* 822608B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x580);
		/* 822608B4h case    1:*/		return 0x822608B8;
		  /* 822608B8h */ case    2:  		/* b 60 */
		/* 822608B8h case    2:*/		return 0x822608F4;
		/* 822608B8h case    2:*/		return 0x822608BC;
	}
	return 0x822608BC;
} // Block from 822608B0h-822608BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822608BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608BC);
		  /* 822608BCh */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822608BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822608BCh case    0:*/		return 0x822608C0;
		  /* 822608C0h */ case    1:  		/* addi R11, R11, 1372 */
		/* 822608C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x55C);
		/* 822608C0h case    1:*/		return 0x822608C4;
		  /* 822608C4h */ case    2:  		/* b 48 */
		/* 822608C4h case    2:*/		return 0x822608F4;
		/* 822608C4h case    2:*/		return 0x822608C8;
	}
	return 0x822608C8;
} // Block from 822608BCh-822608C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822608C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608C8);
		  /* 822608C8h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822608C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822608C8h case    0:*/		return 0x822608CC;
		  /* 822608CCh */ case    1:  		/* addi R11, R11, 1336 */
		/* 822608CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x538);
		/* 822608CCh case    1:*/		return 0x822608D0;
		  /* 822608D0h */ case    2:  		/* b 36 */
		/* 822608D0h case    2:*/		return 0x822608F4;
		/* 822608D0h case    2:*/		return 0x822608D4;
	}
	return 0x822608D4;
} // Block from 822608C8h-822608D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822608D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608D4);
		  /* 822608D4h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822608D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822608D4h case    0:*/		return 0x822608D8;
		  /* 822608D8h */ case    1:  		/* addi R11, R11, 1300 */
		/* 822608D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x514);
		/* 822608D8h case    1:*/		return 0x822608DC;
		  /* 822608DCh */ case    2:  		/* b 24 */
		/* 822608DCh case    2:*/		return 0x822608F4;
		/* 822608DCh case    2:*/		return 0x822608E0;
	}
	return 0x822608E0;
} // Block from 822608D4h-822608E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822608E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608E0);
		  /* 822608E0h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822608E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822608E0h case    0:*/		return 0x822608E4;
		  /* 822608E4h */ case    1:  		/* addi R11, R11, 1264 */
		/* 822608E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4F0);
		/* 822608E4h case    1:*/		return 0x822608E8;
		  /* 822608E8h */ case    2:  		/* b 12 */
		/* 822608E8h case    2:*/		return 0x822608F4;
		/* 822608E8h case    2:*/		return 0x822608EC;
	}
	return 0x822608EC;
} // Block from 822608E0h-822608ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822608ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608EC);
		  /* 822608ECh */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822608ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822608ECh case    0:*/		return 0x822608F0;
		  /* 822608F0h */ case    1:  		/* addi R11, R11, 1228 */
		/* 822608F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4CC);
		/* 822608F0h case    1:*/		return 0x822608F4;
	}
	return 0x822608F4;
} // Block from 822608ECh-822608F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822608F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608F4);
		  /* 822608F4h */ case    0:  		/* stw R11, <#[R1 + 240]> */
		/* 822608F4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000F0) );
		/* 822608F4h case    0:*/		return 0x822608F8;
	}
	return 0x822608F8;
} // Block from 822608F4h-822608F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822608F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822608F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822608F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822608F8);
		  /* 822608F8h */ case    0:  		/* lwz R7, <#[R1 + 240]> */
		/* 822608F8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000F0) );
		/* 822608F8h case    0:*/		return 0x822608FC;
		  /* 822608FCh */ case    1:  		/* b -392 */
		/* 822608FCh case    1:*/		return 0x82260774;
		/* 822608FCh case    1:*/		return 0x82260900;
		  /* 82260900h */ case    2:  		/* lwz R11, <#[R1 + 176]> */
		/* 82260900h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260900h case    2:*/		return 0x82260904;
		  /* 82260904h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82260904h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82260904h case    3:*/		return 0x82260908;
		  /* 82260908h */ case    4:  		/* rlwinm. R29, R11, 10, 29, 31 */
		/* 82260908h case    4:*/		cpu::op::rlwinm<1,10,29,31>(regs,&regs.R29,regs.R11);
		/* 82260908h case    4:*/		return 0x8226090C;
		  /* 8226090Ch */ case    5:  		/* bc 12, CR0_EQ, 5300 */
		/* 8226090Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82261DC0;  }
		/* 8226090Ch case    5:*/		return 0x82260910;
		  /* 82260910h */ case    6:  		/* li R3, 18 */
		/* 82260910h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 82260910h case    6:*/		return 0x82260914;
		  /* 82260914h */ case    7:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260914h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260914h case    7:*/		return 0x82260918;
		  /* 82260918h */ case    8:  		/* bl -43496 */
		/* 82260918h case    8:*/		regs.LR = 0x8226091C; return 0x82255F30;
		/* 82260918h case    8:*/		return 0x8226091C;
		  /* 8226091Ch */ case    9:  		/* lwz R27, <#[R1 + 564]> */
		/* 8226091Ch case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000234) );
		/* 8226091Ch case    9:*/		return 0x82260920;
		  /* 82260920h */ case   10:  		/* mr R30, R3 */
		/* 82260920h case   10:*/		regs.R30 = regs.R3;
		/* 82260920h case   10:*/		return 0x82260924;
		  /* 82260924h */ case   11:  		/* cmpwi CR6, R27, 0 */
		/* 82260924h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82260924h case   11:*/		return 0x82260928;
		  /* 82260928h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 82260928h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82260944;  }
		/* 82260928h case   12:*/		return 0x8226092C;
		  /* 8226092Ch */ case   13:  		/* lwz R10, <#[R31 + 12]> */
		/* 8226092Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8226092Ch case   13:*/		return 0x82260930;
		  /* 82260930h */ case   14:  		/* lwz R11, <#[R10 + 1508]> */
		/* 82260930h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 82260930h case   14:*/		return 0x82260934;
		  /* 82260934h */ case   15:  		/* addi R11, R11, -1 */
		/* 82260934h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82260934h case   15:*/		return 0x82260938;
		  /* 82260938h */ case   16:  		/* mr R27, R11 */
		/* 82260938h case   16:*/		regs.R27 = regs.R11;
		/* 82260938h case   16:*/		return 0x8226093C;
		  /* 8226093Ch */ case   17:  		/* stw R11, <#[R10 + 1508]> */
		/* 8226093Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8226093Ch case   17:*/		return 0x82260940;
		  /* 82260940h */ case   18:  		/* stw R11, <#[R1 + 564]> */
		/* 82260940h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000234) );
		/* 82260940h case   18:*/		return 0x82260944;
	}
	return 0x82260944;
} // Block from 822608F8h-82260944h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82260944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260944);
		  /* 82260944h */ case    0:  		/* li R26, 0 */
		/* 82260944h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82260944h case    0:*/		return 0x82260948;
		  /* 82260948h */ case    1:  		/* stw R27, <#[R30 + 56]> */
		/* 82260948h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000038) );
		/* 82260948h case    1:*/		return 0x8226094C;
		  /* 8226094Ch */ case    2:  		/* lwz R9, <#[R1 + 180]> */
		/* 8226094Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000B4) );
		/* 8226094Ch case    2:*/		return 0x82260950;
		  /* 82260950h */ case    3:  		/* mr R7, R30 */
		/* 82260950h case    3:*/		regs.R7 = regs.R30;
		/* 82260950h case    3:*/		return 0x82260954;
		  /* 82260954h */ case    4:  		/* stw R26, <#[R30 + 80]> */
		/* 82260954h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000050) );
		/* 82260954h case    4:*/		return 0x82260958;
		  /* 82260958h */ case    5:  		/* addi R4, R1, 152 */
		/* 82260958h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 82260958h case    5:*/		return 0x8226095C;
		  /* 8226095Ch */ case    6:  		/* lwz R28, <#[R1 + 168]> */
		/* 8226095Ch case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A8) );
		/* 8226095Ch case    6:*/		return 0x82260960;
		  /* 82260960h */ case    7:  		/* mr R3, R31 */
		/* 82260960h case    7:*/		regs.R3 = regs.R31;
		/* 82260960h case    7:*/		return 0x82260964;
		  /* 82260964h */ case    8:  		/* mr R6, R28 */
		/* 82260964h case    8:*/		regs.R6 = regs.R28;
		/* 82260964h case    8:*/		return 0x82260968;
		  /* 82260968h */ case    9:  		/* lwz R10, <#[R9]> */
		/* 82260968h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82260968h case    9:*/		return 0x8226096C;
		  /* 8226096Ch */ case   10:  		/* lwz R11, <#[R31 + 92]> */
		/* 8226096Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8226096Ch case   10:*/		return 0x82260970;
		  /* 82260970h */ case   11:  		/* lwz R8, <#[R10]> */
		/* 82260970h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82260970h case   11:*/		return 0x82260974;
		  /* 82260974h */ case   12:  		/* rlwinm R10, R8, 19, 23, 28 */
		/* 82260974h case   12:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R8);
		/* 82260974h case   12:*/		return 0x82260978;
		  /* 82260978h */ case   13:  		/* add R11, R10, R11 */
		/* 82260978h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82260978h case   13:*/		return 0x8226097C;
		  /* 8226097Ch */ case   14:  		/* extsh R10, R8 */
		/* 8226097Ch case   14:*/		cpu::op::extsh<0>(regs,&regs.R10,regs.R8);
		/* 8226097Ch case   14:*/		return 0x82260980;
		  /* 82260980h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 82260980h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82260980h case   15:*/		return 0x82260984;
		  /* 82260984h */ case   16:  		/* stw R10, <#[R30 + 60]> */
		/* 82260984h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x0000003C) );
		/* 82260984h case   16:*/		return 0x82260988;
		  /* 82260988h */ case   17:  		/* stw R11, <#[R30 + 84]> */
		/* 82260988h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 82260988h case   17:*/		return 0x8226098C;
		  /* 8226098Ch */ case   18:  		/* lwz R5, <#[R9]> */
		/* 8226098Ch case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 8226098Ch case   18:*/		return 0x82260990;
		  /* 82260990h */ case   19:  		/* bl -24976 */
		/* 82260990h case   19:*/		regs.LR = 0x82260994; return 0x8225A800;
		/* 82260990h case   19:*/		return 0x82260994;
		  /* 82260994h */ case   20:  		/* cmpwi CR6, R29, 1 */
		/* 82260994h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000001);
		/* 82260994h case   20:*/		return 0x82260998;
		  /* 82260998h */ case   21:  		/* bc 12, CR6_EQ, 104 */
		/* 82260998h case   21:*/		if ( regs.CR[6].eq ) { return 0x82260A00;  }
		/* 82260998h case   21:*/		return 0x8226099C;
		  /* 8226099Ch */ case   22:  		/* cmpwi CR6, R29, 2 */
		/* 8226099Ch case   22:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000002);
		/* 8226099Ch case   22:*/		return 0x822609A0;
		  /* 822609A0h */ case   23:  		/* bc 12, CR6_EQ, 76 */
		/* 822609A0h case   23:*/		if ( regs.CR[6].eq ) { return 0x822609EC;  }
		/* 822609A0h case   23:*/		return 0x822609A4;
		  /* 822609A4h */ case   24:  		/* cmpwi CR6, R29, 3 */
		/* 822609A4h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000003);
		/* 822609A4h case   24:*/		return 0x822609A8;
		  /* 822609A8h */ case   25:  		/* bc 12, CR6_EQ, 32 */
		/* 822609A8h case   25:*/		if ( regs.CR[6].eq ) { return 0x822609C8;  }
		/* 822609A8h case   25:*/		return 0x822609AC;
		  /* 822609ACh */ case   26:  		/* cmpwi CR6, R29, 4 */
		/* 822609ACh case   26:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 822609ACh case   26:*/		return 0x822609B0;
		  /* 822609B0h */ case   27:  		/* bc 4, CR6_EQ, 120 */
		/* 822609B0h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82260A28;  }
		/* 822609B0h case   27:*/		return 0x822609B4;
		  /* 822609B4h */ case   28:  		/* fmr FR4, FR31 */
		/* 822609B4h case   28:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 822609B4h case   28:*/		return 0x822609B8;
		  /* 822609B8h */ case   29:  		/* fmr FR3, FR31 */
		/* 822609B8h case   29:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 822609B8h case   29:*/		return 0x822609BC;
		  /* 822609BCh */ case   30:  		/* fmr FR2, FR31 */
		/* 822609BCh case   30:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 822609BCh case   30:*/		return 0x822609C0;
		  /* 822609C0h */ case   31:  		/* fmr FR1, FR31 */
		/* 822609C0h case   31:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822609C0h case   31:*/		return 0x822609C4;
		  /* 822609C4h */ case   32:  		/* b 20 */
		/* 822609C4h case   32:*/		return 0x822609D8;
		/* 822609C4h case   32:*/		return 0x822609C8;
	}
	return 0x822609C8;
} // Block from 82260944h-822609C8h (33 instructions)

//////////////////////////////////////////////////////
// Block at 822609C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822609C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822609C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822609C8);
		  /* 822609C8h */ case    0:  		/* fmr FR4, FR27 */
		/* 822609C8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR27);
		/* 822609C8h case    0:*/		return 0x822609CC;
		  /* 822609CCh */ case    1:  		/* fmr FR3, FR27 */
		/* 822609CCh case    1:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR27);
		/* 822609CCh case    1:*/		return 0x822609D0;
		  /* 822609D0h */ case    2:  		/* fmr FR2, FR27 */
		/* 822609D0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR27);
		/* 822609D0h case    2:*/		return 0x822609D4;
		  /* 822609D4h */ case    3:  		/* fmr FR1, FR27 */
		/* 822609D4h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR27);
		/* 822609D4h case    3:*/		return 0x822609D8;
	}
	return 0x822609D8;
} // Block from 822609C8h-822609D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822609D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822609D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822609D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822609D8);
		  /* 822609D8h */ case    0:  		/* mr R3, R30 */
		/* 822609D8h case    0:*/		regs.R3 = regs.R30;
		/* 822609D8h case    0:*/		return 0x822609DC;
		  /* 822609DCh */ case    1:  		/* mr R4, R31 */
		/* 822609DCh case    1:*/		regs.R4 = regs.R31;
		/* 822609DCh case    1:*/		return 0x822609E0;
		  /* 822609E0h */ case    2:  		/* li R5, 2 */
		/* 822609E0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 822609E0h case    2:*/		return 0x822609E4;
		  /* 822609E4h */ case    3:  		/* bl -39628 */
		/* 822609E4h case    3:*/		regs.LR = 0x822609E8; return 0x82256F18;
		/* 822609E4h case    3:*/		return 0x822609E8;
		  /* 822609E8h */ case    4:  		/* b 64 */
		/* 822609E8h case    4:*/		return 0x82260A28;
		/* 822609E8h case    4:*/		return 0x822609EC;
	}
	return 0x822609EC;
} // Block from 822609D8h-822609ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822609ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822609EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822609EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822609EC);
		  /* 822609ECh */ case    0:  		/* fmr FR4, FR31 */
		/* 822609ECh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 822609ECh case    0:*/		return 0x822609F0;
		  /* 822609F0h */ case    1:  		/* fmr FR3, FR31 */
		/* 822609F0h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 822609F0h case    1:*/		return 0x822609F4;
		  /* 822609F4h */ case    2:  		/* fmr FR2, FR31 */
		/* 822609F4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 822609F4h case    2:*/		return 0x822609F8;
		  /* 822609F8h */ case    3:  		/* fmr FR1, FR31 */
		/* 822609F8h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822609F8h case    3:*/		return 0x822609FC;
		  /* 822609FCh */ case    4:  		/* b 20 */
		/* 822609FCh case    4:*/		return 0x82260A10;
		/* 822609FCh case    4:*/		return 0x82260A00;
	}
	return 0x82260A00;
} // Block from 822609ECh-82260A00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82260A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260A00);
		  /* 82260A00h */ case    0:  		/* fmr FR4, FR27 */
		/* 82260A00h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR27);
		/* 82260A00h case    0:*/		return 0x82260A04;
		  /* 82260A04h */ case    1:  		/* fmr FR3, FR27 */
		/* 82260A04h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR27);
		/* 82260A04h case    1:*/		return 0x82260A08;
		  /* 82260A08h */ case    2:  		/* fmr FR2, FR27 */
		/* 82260A08h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR27);
		/* 82260A08h case    2:*/		return 0x82260A0C;
		  /* 82260A0Ch */ case    3:  		/* fmr FR1, FR27 */
		/* 82260A0Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR27);
		/* 82260A0Ch case    3:*/		return 0x82260A10;
	}
	return 0x82260A10;
} // Block from 82260A00h-82260A10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82260A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260A10);
		  /* 82260A10h */ case    0:  		/* li R5, 2 */
		/* 82260A10h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82260A10h case    0:*/		return 0x82260A14;
		  /* 82260A14h */ case    1:  		/* mr R4, R31 */
		/* 82260A14h case    1:*/		regs.R4 = regs.R31;
		/* 82260A14h case    1:*/		return 0x82260A18;
		  /* 82260A18h */ case    2:  		/* mr R3, R30 */
		/* 82260A18h case    2:*/		regs.R3 = regs.R30;
		/* 82260A18h case    2:*/		return 0x82260A1C;
		  /* 82260A1Ch */ case    3:  		/* bl -39684 */
		/* 82260A1Ch case    3:*/		regs.LR = 0x82260A20; return 0x82256F18;
		/* 82260A1Ch case    3:*/		return 0x82260A20;
		  /* 82260A20h */ case    4:  		/* li R11, 1 */
		/* 82260A20h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82260A20h case    4:*/		return 0x82260A24;
		  /* 82260A24h */ case    5:  		/* stb R11, <#[R30 + 154]> */
		/* 82260A24h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x0000009A) );
		/* 82260A24h case    5:*/		return 0x82260A28;
	}
	return 0x82260A28;
} // Block from 82260A10h-82260A28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82260A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260A28);
		  /* 82260A28h */ case    0:  		/* mr R4, R30 */
		/* 82260A28h case    0:*/		regs.R4 = regs.R30;
		/* 82260A28h case    0:*/		return 0x82260A2C;
		  /* 82260A2Ch */ case    1:  		/* mr R3, R31 */
		/* 82260A2Ch case    1:*/		regs.R3 = regs.R31;
		/* 82260A2Ch case    1:*/		return 0x82260A30;
		  /* 82260A30h */ case    2:  		/* bl -173192 */
		/* 82260A30h case    2:*/		regs.LR = 0x82260A34; return 0x822365A8;
		/* 82260A30h case    2:*/		return 0x82260A34;
		  /* 82260A34h */ case    3:  		/* mr R4, R30 */
		/* 82260A34h case    3:*/		regs.R4 = regs.R30;
		/* 82260A34h case    3:*/		return 0x82260A38;
		  /* 82260A38h */ case    4:  		/* mr R3, R14 */
		/* 82260A38h case    4:*/		regs.R3 = regs.R14;
		/* 82260A38h case    4:*/		return 0x82260A3C;
		  /* 82260A3Ch */ case    5:  		/* bl -31500 */
		/* 82260A3Ch case    5:*/		regs.LR = 0x82260A40; return 0x82258F30;
		/* 82260A3Ch case    5:*/		return 0x82260A40;
		  /* 82260A40h */ case    6:  		/* mr R3, R30 */
		/* 82260A40h case    6:*/		regs.R3 = regs.R30;
		/* 82260A40h case    6:*/		return 0x82260A44;
		  /* 82260A44h */ case    7:  		/* bl -43652 */
		/* 82260A44h case    7:*/		regs.LR = 0x82260A48; return 0x82255FC0;
		/* 82260A44h case    7:*/		return 0x82260A48;
		  /* 82260A48h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82260A48h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82260A48h case    8:*/		return 0x82260A4C;
		  /* 82260A4Ch */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 82260A4Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x82260A68;  }
		/* 82260A4Ch case    9:*/		return 0x82260A50;
		  /* 82260A50h */ case   10:  		/* li R7, 3516 */
		/* 82260A50h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0xDBC);
		/* 82260A50h case   10:*/		return 0x82260A54;
		  /* 82260A54h */ case   11:  		/* lwz R6, <#[R1 + 128]> */
		/* 82260A54h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82260A54h case   11:*/		return 0x82260A58;
		  /* 82260A58h */ case   12:  		/* li R3, 0 */
		/* 82260A58h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260A58h case   12:*/		return 0x82260A5C;
		  /* 82260A5Ch */ case   13:  		/* lwz R5, <#[R1 + 464]> */
		/* 82260A5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001D0) );
		/* 82260A5Ch case   13:*/		return 0x82260A60;
		  /* 82260A60h */ case   14:  		/* lwz R4, <#[R1 + 132]> */
		/* 82260A60h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82260A60h case   14:*/		return 0x82260A64;
		  /* 82260A64h */ case   15:  		/* bl -1085020 */
		/* 82260A64h case   15:*/		regs.LR = 0x82260A68; return 0x82157C08;
		/* 82260A64h case   15:*/		return 0x82260A68;
	}
	return 0x82260A68;
} // Block from 82260A28h-82260A68h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82260A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260A68);
		  /* 82260A68h */ case    0:  		/* addi R11, R28, 14 */
		/* 82260A68h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xE);
		/* 82260A68h case    0:*/		return 0x82260A6C;
		  /* 82260A6Ch */ case    1:  		/* lwz R10, <#[R1 + 140]> */
		/* 82260A6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260A6Ch case    1:*/		return 0x82260A70;
		  /* 82260A70h */ case    2:  		/* addi R9, R28, 20 */
		/* 82260A70h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0x14);
		/* 82260A70h case    2:*/		return 0x82260A74;
		  /* 82260A74h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82260A74h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82260A74h case    3:*/		return 0x82260A78;
		  /* 82260A78h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82260A78h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82260A78h case    4:*/		return 0x82260A7C;
		  /* 82260A7Ch */ case    5:  		/* addi R8, R28, 1 */
		/* 82260A7Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R28,0x1);
		/* 82260A7Ch case    5:*/		return 0x82260A80;
		  /* 82260A80h */ case    6:  		/* addi R10, R10, 1 */
		/* 82260A80h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82260A80h case    6:*/		return 0x82260A84;
		  /* 82260A84h */ case    7:  		/* stw R8, <#[R1 + 168]> */
		/* 82260A84h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260A84h case    7:*/		return 0x82260A88;
		  /* 82260A88h */ case    8:  		/* stw R10, <#[R1 + 140]> */
		/* 82260A88h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260A88h case    8:*/		return 0x82260A8C;
		  /* 82260A8Ch */ case    9:  		/* stwx R27, <#[R11 + R15]> */
		/* 82260A8Ch case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82260A8Ch case    9:*/		return 0x82260A90;
		  /* 82260A90h */ case   10:  		/* stwx R26, <#[R9 + R15]> */
		/* 82260A90h case   10:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R9 + regs.R15 + 0x00000000) );
		/* 82260A90h case   10:*/		return 0x82260A94;
		  /* 82260A94h */ case   11:  		/* b 4908 */
		/* 82260A94h case   11:*/		return 0x82261DC0;
		/* 82260A94h case   11:*/		return 0x82260A98;
		  /* 82260A98h */ case   12:  		/* lwz R10, <#[R1 + 176]> */
		/* 82260A98h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260A98h case   12:*/		return 0x82260A9C;
		  /* 82260A9Ch */ case   13:  		/* cmpwi CR6, R11, 20 */
		/* 82260A9Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000014);
		/* 82260A9Ch case   13:*/		return 0x82260AA0;
		  /* 82260AA0h */ case   14:  		/* lhz R10, <#[R10]> */
		/* 82260AA0h case   14:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82260AA0h case   14:*/		return 0x82260AA4;
		  /* 82260AA4h */ case   15:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82260AA4h case   15:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82260AA4h case   15:*/		return 0x82260AA8;
		  /* 82260AA8h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 82260AA8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82260AB4;  }
		/* 82260AA8h case   16:*/		return 0x82260AAC;
		  /* 82260AACh */ case   17:  		/* lwz R11, <#[R1 + 272]> */
		/* 82260AACh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000110) );
		/* 82260AACh case   17:*/		return 0x82260AB0;
		  /* 82260AB0h */ case   18:  		/* b 28 */
		/* 82260AB0h case   18:*/		return 0x82260ACC;
		/* 82260AB0h case   18:*/		return 0x82260AB4;
	}
	return 0x82260AB4;
} // Block from 82260A68h-82260AB4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82260AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260AB4);
		  /* 82260AB4h */ case    0:  		/* cmpwi CR6, R11, 21 */
		/* 82260AB4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000015);
		/* 82260AB4h case    0:*/		return 0x82260AB8;
		  /* 82260AB8h */ case    1:  		/* lwz R11, <#[R1 + 272]> */
		/* 82260AB8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000110) );
		/* 82260AB8h case    1:*/		return 0x82260ABC;
		  /* 82260ABCh */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82260ABCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82260AC8;  }
		/* 82260ABCh case    2:*/		return 0x82260AC0;
		  /* 82260AC0h */ case    3:  		/* addi R11, R11, 16 */
		/* 82260AC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82260AC0h case    3:*/		return 0x82260AC4;
		  /* 82260AC4h */ case    4:  		/* b 8 */
		/* 82260AC4h case    4:*/		return 0x82260ACC;
		/* 82260AC4h case    4:*/		return 0x82260AC8;
	}
	return 0x82260AC8;
} // Block from 82260AB4h-82260AC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82260AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260AC8);
		  /* 82260AC8h */ case    0:  		/* addi R11, R11, 32 */
		/* 82260AC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82260AC8h case    0:*/		return 0x82260ACC;
	}
	return 0x82260ACC;
} // Block from 82260AC8h-82260ACCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260ACC);
		  /* 82260ACCh */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82260ACCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82260ACCh case    0:*/		return 0x82260AD0;
		  /* 82260AD0h */ case    1:  		/* lwzx R7, <#[R10 + R11]> */
		/* 82260AD0h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82260AD0h case    1:*/		return 0x82260AD4;
		  /* 82260AD4h */ case    2:  		/* b -864 */
		/* 82260AD4h case    2:*/		return 0x82260774;
		/* 82260AD4h case    2:*/		return 0x82260AD8;
		  /* 82260AD8h */ case    3:  		/* lwz R10, <#[R1 + 176]> */
		/* 82260AD8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B0) );
		/* 82260AD8h case    3:*/		return 0x82260ADC;
		  /* 82260ADCh */ case    4:  		/* addi R11, R11, -63 */
		/* 82260ADCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFC1);
		/* 82260ADCh case    4:*/		return 0x82260AE0;
		  /* 82260AE0h */ case    5:  		/* lwz R9, <#[R1 + 272]> */
		/* 82260AE0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000110) );
		/* 82260AE0h case    5:*/		return 0x82260AE4;
		  /* 82260AE4h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82260AE4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82260AE4h case    6:*/		return 0x82260AE8;
		  /* 82260AE8h */ case    7:  		/* addi R9, R9, 48 */
		/* 82260AE8h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x30);
		/* 82260AE8h case    7:*/		return 0x82260AEC;
		  /* 82260AECh */ case    8:  		/* lhz R10, <#[R10]> */
		/* 82260AECh case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82260AECh case    8:*/		return 0x82260AF0;
		  /* 82260AF0h */ case    9:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82260AF0h case    9:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82260AF0h case    9:*/		return 0x82260AF4;
		  /* 82260AF4h */ case   10:  		/* add R11, R10, R11 */
		/* 82260AF4h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82260AF4h case   10:*/		return 0x82260AF8;
		  /* 82260AF8h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82260AF8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82260AF8h case   11:*/		return 0x82260AFC;
		  /* 82260AFCh */ case   12:  		/* lwzx R7, <#[R11 + R9]> */
		/* 82260AFCh case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82260AFCh case   12:*/		return 0x82260B00;
		  /* 82260B00h */ case   13:  		/* b -908 */
		/* 82260B00h case   13:*/		return 0x82260774;
		/* 82260B00h case   13:*/		return 0x82260B04;
		  /* 82260B04h */ case   14:  		/* lwz R11, <#[R1 + 140]> */
		/* 82260B04h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260B04h case   14:*/		return 0x82260B08;
		  /* 82260B08h */ case   15:  		/* lwz R10, <#[R1 + 144]> */
		/* 82260B08h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82260B08h case   15:*/		return 0x82260B0C;
		  /* 82260B0Ch */ case   16:  		/* addi R11, R11, 1 */
		/* 82260B0Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82260B0Ch case   16:*/		return 0x82260B10;
		  /* 82260B10h */ case   17:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260B10h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260B10h case   17:*/		return 0x82260B14;
		  /* 82260B14h */ case   18:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82260B14h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82260B14h case   18:*/		return 0x82260B18;
		  /* 82260B18h */ case   19:  		/* stw R11, <#[R1 + 140]> */
		/* 82260B18h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260B18h case   19:*/		return 0x82260B1C;
		  /* 82260B1Ch */ case   20:  		/* lwzx R3, <#[R9 + R10]> */
		/* 82260B1Ch case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82260B1Ch case   20:*/		return 0x82260B20;
		  /* 82260B20h */ case   21:  		/* bl -44016 */
		/* 82260B20h case   21:*/		regs.LR = 0x82260B24; return 0x82255F30;
		/* 82260B20h case   21:*/		return 0x82260B24;
		  /* 82260B24h */ case   22:  		/* mr R15, R3 */
		/* 82260B24h case   22:*/		regs.R15 = regs.R3;
		/* 82260B24h case   22:*/		return 0x82260B28;
		  /* 82260B28h */ case   23:  		/* b 4760 */
		/* 82260B28h case   23:*/		return 0x82261DC0;
		/* 82260B28h case   23:*/		return 0x82260B2C;
		  /* 82260B2Ch */ case   24:  		/* lwz R10, <#[R1 + 228]> */
		/* 82260B2Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000E4) );
		/* 82260B2Ch case   24:*/		return 0x82260B30;
		  /* 82260B30h */ case   25:  		/* addi R9, R1, 152 */
		/* 82260B30h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x98);
		/* 82260B30h case   25:*/		return 0x82260B34;
		  /* 82260B34h */ case   26:  		/* lbz R7, <#[R1 + 200]> */
		/* 82260B34h case   26:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000C8) );
		/* 82260B34h case   26:*/		return 0x82260B38;
		  /* 82260B38h */ case   27:  		/* mr R8, R15 */
		/* 82260B38h case   27:*/		regs.R8 = regs.R15;
		/* 82260B38h case   27:*/		return 0x82260B3C;
		  /* 82260B3Ch */ case   28:  		/* lwz R6, <#[R1 + 164]> */
		/* 82260B3Ch case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000A4) );
		/* 82260B3Ch case   28:*/		return 0x82260B40;
		  /* 82260B40h */ case   29:  		/* addi R4, R11, -2 */
		/* 82260B40h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFE);
		/* 82260B40h case   29:*/		return 0x82260B44;
		  /* 82260B44h */ case   30:  		/* stw R9, <#[R1 + 84]> */
		/* 82260B44h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82260B44h case   30:*/		return 0x82260B48;
		  /* 82260B48h */ case   31:  		/* mr R3, R31 */
		/* 82260B48h case   31:*/		regs.R3 = regs.R31;
		/* 82260B48h case   31:*/		return 0x82260B4C;
		  /* 82260B4Ch */ case   32:  		/* stw R14, <#[R1 + 116]> */
		/* 82260B4Ch case   32:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000074) );
		/* 82260B4Ch case   32:*/		return 0x82260B50;
		  /* 82260B50h */ case   33:  		/* stw R10, <#[R1 + 108]> */
		/* 82260B50h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 82260B50h case   33:*/		return 0x82260B54;
		  /* 82260B54h */ case   34:  		/* stb R7, <#[R1 + 103]> */
		/* 82260B54h case   34:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R1 + 0x00000067) );
		/* 82260B54h case   34:*/		return 0x82260B58;
		  /* 82260B58h */ case   35:  		/* stw R6, <#[R1 + 92]> */
		/* 82260B58h case   35:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 82260B58h case   35:*/		return 0x82260B5C;
		  /* 82260B5Ch */ case   36:  		/* lwz R30, <#[R1 + 168]> */
		/* 82260B5Ch case   36:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260B5Ch case   36:*/		return 0x82260B60;
		  /* 82260B60h */ case   37:  		/* lwz R10, <#[R1 + 236]> */
		/* 82260B60h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000EC) );
		/* 82260B60h case   37:*/		return 0x82260B64;
		  /* 82260B64h */ case   38:  		/* mr R5, R30 */
		/* 82260B64h case   38:*/		regs.R5 = regs.R30;
		/* 82260B64h case   38:*/		return 0x82260B68;
		  /* 82260B68h */ case   39:  		/* lwz R9, <#[R1 + 312]> */
		/* 82260B68h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000138) );
		/* 82260B68h case   39:*/		return 0x82260B6C;
		  /* 82260B6Ch */ case   40:  		/* lwz R7, <#[R1 + 180]> */
		/* 82260B6Ch case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000B4) );
		/* 82260B6Ch case   40:*/		return 0x82260B70;
		  /* 82260B70h */ case   41:  		/* lwz R6, <#[R1 + 224]> */
		/* 82260B70h case   41:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000E0) );
		/* 82260B70h case   41:*/		return 0x82260B74;
		  /* 82260B74h */ case   42:  		/* bl -15780 */
		/* 82260B74h case   42:*/		regs.LR = 0x82260B78; return 0x8225CDD0;
		/* 82260B74h case   42:*/		return 0x82260B78;
		  /* 82260B78h */ case   43:  		/* addi R11, R30, 1 */
		/* 82260B78h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 82260B78h case   43:*/		return 0x82260B7C;
		  /* 82260B7Ch */ case   44:  		/* stw R11, <#[R1 + 168]> */
		/* 82260B7Ch case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260B7Ch case   44:*/		return 0x82260B80;
		  /* 82260B80h */ case   45:  		/* b 4672 */
		/* 82260B80h case   45:*/		return 0x82261DC0;
		/* 82260B80h case   45:*/		return 0x82260B84;
		  /* 82260B84h */ case   46:  		/* lwz R11, <#[R1 + 168]> */
		/* 82260B84h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260B84h case   46:*/		return 0x82260B88;
		  /* 82260B88h */ case   47:  		/* li R10, 1 */
		/* 82260B88h case   47:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82260B88h case   47:*/		return 0x82260B8C;
		  /* 82260B8Ch */ case   48:  		/* add R11, R11, R15 */
		/* 82260B8Ch case   48:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R15);
		/* 82260B8Ch case   48:*/		return 0x82260B90;
		  /* 82260B90h */ case   49:  		/* stb R10, <#[R11 + 158]> */
		/* 82260B90h case   49:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x0000009E) );
		/* 82260B90h case   49:*/		return 0x82260B94;
		  /* 82260B94h */ case   50:  		/* b 4652 */
		/* 82260B94h case   50:*/		return 0x82261DC0;
		/* 82260B94h case   50:*/		return 0x82260B98;
		  /* 82260B98h */ case   51:  		/* lwz R11, <#[R1 + 168]> */
		/* 82260B98h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260B98h case   51:*/		return 0x82260B9C;
		  /* 82260B9Ch */ case   52:  		/* add R11, R11, R15 */
		/* 82260B9Ch case   52:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R15);
		/* 82260B9Ch case   52:*/		return 0x82260BA0;
		  /* 82260BA0h */ case   53:  		/* addi R10, R11, 152 */
		/* 82260BA0h case   53:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x98);
		/* 82260BA0h case   53:*/		return 0x82260BA4;
		  /* 82260BA4h */ case   54:  		/* lbz R10, <#[R11 + 152]> */
		/* 82260BA4h case   54:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000098) );
		/* 82260BA4h case   54:*/		return 0x82260BA8;
		  /* 82260BA8h */ case   55:  		/* cntlzw R10, R10 */
		/* 82260BA8h case   55:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82260BA8h case   55:*/		return 0x82260BAC;
		  /* 82260BACh */ case   56:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 82260BACh case   56:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 82260BACh case   56:*/		return 0x82260BB0;
		  /* 82260BB0h */ case   57:  		/* stb R10, <#[R11 + 152]> */
		/* 82260BB0h case   57:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000098) );
		/* 82260BB0h case   57:*/		return 0x82260BB4;
		  /* 82260BB4h */ case   58:  		/* b 4620 */
		/* 82260BB4h case   58:*/		return 0x82261DC0;
		/* 82260BB4h case   58:*/		return 0x82260BB8;
		  /* 82260BB8h */ case   59:  		/* li R11, 1 */
		/* 82260BB8h case   59:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82260BB8h case   59:*/		return 0x82260BBC;
		  /* 82260BBCh */ case   60:  		/* stb R11, <#[R15 + 164]> */
		/* 82260BBCh case   60:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R15 + 0x000000A4) );
		/* 82260BBCh case   60:*/		return 0x82260BC0;
		  /* 82260BC0h */ case   61:  		/* b 4608 */
		/* 82260BC0h case   61:*/		return 0x82261DC0;
		/* 82260BC0h case   61:*/		return 0x82260BC4;
		  /* 82260BC4h */ case   62:  		/* addi R11, R11, -79 */
		/* 82260BC4h case   62:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFB1);
		/* 82260BC4h case   62:*/		return 0x82260BC8;
		  /* 82260BC8h */ case   63:  		/* addi R10, R1, 560 */
		/* 82260BC8h case   63:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x230);
		/* 82260BC8h case   63:*/		return 0x82260BCC;
		  /* 82260BCCh */ case   64:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82260BCCh case   64:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82260BCCh case   64:*/		return 0x82260BD0;
		  /* 82260BD0h */ case   65:  		/* lwzx R11, <#[R9 + R10]> */
		/* 82260BD0h case   65:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82260BD0h case   65:*/		return 0x82260BD4;
		  /* 82260BD4h */ case   66:  		/* cmpwi CR6, R11, 0 */
		/* 82260BD4h case   66:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82260BD4h case   66:*/		return 0x82260BD8;
		  /* 82260BD8h */ case   67:  		/* bc 4, CR6_EQ, 24 */
		/* 82260BD8h case   67:*/		if ( !regs.CR[6].eq ) { return 0x82260BF0;  }
		/* 82260BD8h case   67:*/		return 0x82260BDC;
		  /* 82260BDCh */ case   68:  		/* lwz R8, <#[R31 + 12]> */
		/* 82260BDCh case   68:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260BDCh case   68:*/		return 0x82260BE0;
		  /* 82260BE0h */ case   69:  		/* lwz R11, <#[R8 + 1508]> */
		/* 82260BE0h case   69:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x000005E4) );
		/* 82260BE0h case   69:*/		return 0x82260BE4;
		  /* 82260BE4h */ case   70:  		/* addi R11, R11, -1 */
		/* 82260BE4h case   70:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82260BE4h case   70:*/		return 0x82260BE8;
		  /* 82260BE8h */ case   71:  		/* stwx R11, <#[R9 + R10]> */
		/* 82260BE8h case   71:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82260BE8h case   71:*/		return 0x82260BEC;
		  /* 82260BECh */ case   72:  		/* stw R11, <#[R8 + 1508]> */
		/* 82260BECh case   72:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x000005E4) );
		/* 82260BECh case   72:*/		return 0x82260BF0;
	}
	return 0x82260BF0;
} // Block from 82260ACCh-82260BF0h (73 instructions)

//////////////////////////////////////////////////////
// Block at 82260BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260BF0);
		  /* 82260BF0h */ case    0:  		/* lwz R30, <#[R1 + 168]> */
		/* 82260BF0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260BF0h case    0:*/		return 0x82260BF4;
		  /* 82260BF4h */ case    1:  		/* li R11, 0 */
		/* 82260BF4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82260BF4h case    1:*/		return 0x82260BF8;
		  /* 82260BF8h */ case    2:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82260BF8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82260BF8h case    2:*/		return 0x82260BFC;
		  /* 82260BFCh */ case    3:  		/* mr R3, R31 */
		/* 82260BFCh case    3:*/		regs.R3 = regs.R31;
		/* 82260BFCh case    3:*/		return 0x82260C00;
		  /* 82260C00h */ case    4:  		/* addi R9, R30, 14 */
		/* 82260C00h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xE);
		/* 82260C00h case    4:*/		return 0x82260C04;
		  /* 82260C04h */ case    5:  		/* addi R8, R30, 20 */
		/* 82260C04h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x14);
		/* 82260C04h case    5:*/		return 0x82260C08;
		  /* 82260C08h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82260C08h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82260C08h case    6:*/		return 0x82260C0C;
		  /* 82260C0Ch */ case    7:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82260C0Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82260C0Ch case    7:*/		return 0x82260C10;
		  /* 82260C10h */ case    8:  		/* cmpwi CR6, R30, 0 */
		/* 82260C10h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82260C10h case    8:*/		return 0x82260C14;
		  /* 82260C14h */ case    9:  		/* stwx R10, <#[R9 + R15]> */
		/* 82260C14h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R15 + 0x00000000) );
		/* 82260C14h case    9:*/		return 0x82260C18;
		  /* 82260C18h */ case   10:  		/* stwx R11, <#[R8 + R15]> */
		/* 82260C18h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82260C18h case   10:*/		return 0x82260C1C;
		  /* 82260C1Ch */ case   11:  		/* bc 4, CR6_EQ, 36 */
		/* 82260C1Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82260C40;  }
		/* 82260C1Ch case   11:*/		return 0x82260C20;
		  /* 82260C20h */ case   12:  		/* li R9, 0 */
		/* 82260C20h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82260C20h case   12:*/		return 0x82260C24;
		  /* 82260C24h */ case   13:  		/* lwz R5, <#[R1 + 236]> */
		/* 82260C24h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000EC) );
		/* 82260C24h case   13:*/		return 0x82260C28;
		  /* 82260C28h */ case   14:  		/* mr R8, R15 */
		/* 82260C28h case   14:*/		regs.R8 = regs.R15;
		/* 82260C28h case   14:*/		return 0x82260C2C;
		  /* 82260C2Ch */ case   15:  		/* lwz R4, <#[R1 + 164]> */
		/* 82260C2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A4) );
		/* 82260C2Ch case   15:*/		return 0x82260C30;
		  /* 82260C30h */ case   16:  		/* li R7, 0 */
		/* 82260C30h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82260C30h case   16:*/		return 0x82260C34;
		  /* 82260C34h */ case   17:  		/* li R6, 0 */
		/* 82260C34h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82260C34h case   17:*/		return 0x82260C38;
		  /* 82260C38h */ case   18:  		/* bl -16720 */
		/* 82260C38h case   18:*/		regs.LR = 0x82260C3C; return 0x8225CAE8;
		/* 82260C38h case   18:*/		return 0x82260C3C;
		  /* 82260C3Ch */ case   19:  		/* b -196 */
		/* 82260C3Ch case   19:*/		return 0x82260B78;
		/* 82260C3Ch case   19:*/		return 0x82260C40;
	}
	return 0x82260C40;
} // Block from 82260BF0h-82260C40h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82260C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260C40);
		  /* 82260C40h */ case    0:  		/* mr R7, R15 */
		/* 82260C40h case    0:*/		regs.R7 = regs.R15;
		/* 82260C40h case    0:*/		return 0x82260C44;
		  /* 82260C44h */ case    1:  		/* mr R6, R30 */
		/* 82260C44h case    1:*/		regs.R6 = regs.R30;
		/* 82260C44h case    1:*/		return 0x82260C48;
		  /* 82260C48h */ case    2:  		/* li R5, 0 */
		/* 82260C48h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82260C48h case    2:*/		return 0x82260C4C;
		  /* 82260C4Ch */ case    3:  		/* addi R4, R1, 152 */
		/* 82260C4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 82260C4Ch case    3:*/		return 0x82260C50;
		  /* 82260C50h */ case    4:  		/* bl -25680 */
		/* 82260C50h case    4:*/		regs.LR = 0x82260C54; return 0x8225A800;
		/* 82260C50h case    4:*/		return 0x82260C54;
		  /* 82260C54h */ case    5:  		/* b -220 */
		/* 82260C54h case    5:*/		return 0x82260B78;
		/* 82260C54h case    5:*/		return 0x82260C58;
		  /* 82260C58h */ case    6:  		/* lwz R11, <#[R1 + 168]> */
		/* 82260C58h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260C58h case    6:*/		return 0x82260C5C;
		  /* 82260C5Ch */ case    7:  		/* li R10, 31 */
		/* 82260C5Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1F);
		/* 82260C5Ch case    7:*/		return 0x82260C60;
		  /* 82260C60h */ case    8:  		/* li R9, 2 */
		/* 82260C60h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82260C60h case    8:*/		return 0x82260C64;
		  /* 82260C64h */ case    9:  		/* addi R8, R11, 14 */
		/* 82260C64h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xE);
		/* 82260C64h case    9:*/		return 0x82260C68;
		  /* 82260C68h */ case   10:  		/* addi R7, R11, 20 */
		/* 82260C68h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x14);
		/* 82260C68h case   10:*/		return 0x82260C6C;
		  /* 82260C6Ch */ case   11:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82260C6Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82260C6Ch case   11:*/		return 0x82260C70;
		  /* 82260C70h */ case   12:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82260C70h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82260C70h case   12:*/		return 0x82260C74;
		  /* 82260C74h */ case   13:  		/* addi R11, R11, 1 */
		/* 82260C74h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82260C74h case   13:*/		return 0x82260C78;
		  /* 82260C78h */ case   14:  		/* stw R11, <#[R1 + 168]> */
		/* 82260C78h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260C78h case   14:*/		return 0x82260C7C;
		  /* 82260C7Ch */ case   15:  		/* stwx R9, <#[R8 + R15]> */
		/* 82260C7Ch case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82260C7Ch case   15:*/		return 0x82260C80;
		  /* 82260C80h */ case   16:  		/* stwx R10, <#[R7 + R15]> */
		/* 82260C80h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + regs.R15 + 0x00000000) );
		/* 82260C80h case   16:*/		return 0x82260C84;
		  /* 82260C84h */ case   17:  		/* b 4412 */
		/* 82260C84h case   17:*/		return 0x82261DC0;
		/* 82260C84h case   17:*/		return 0x82260C88;
		  /* 82260C88h */ case   18:  		/* lwz R11, <#[R1 + 140]> */
		/* 82260C88h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260C88h case   18:*/		return 0x82260C8C;
		  /* 82260C8Ch */ case   19:  		/* lfs FR1, <#[R9 + 4]> */
		/* 82260C8Ch case   19:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R9 + 0x00000004) );
		/* 82260C8Ch case   19:*/		return 0x82260C90;
		  /* 82260C90h */ case   20:  		/* lwz R29, <#[R1 + 168]> */
		/* 82260C90h case   20:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260C90h case   20:*/		return 0x82260C94;
		  /* 82260C94h */ case   21:  		/* mr R4, R31 */
		/* 82260C94h case   21:*/		regs.R4 = regs.R31;
		/* 82260C94h case   21:*/		return 0x82260C98;
		  /* 82260C98h */ case   22:  		/* addi R30, R11, 4 */
		/* 82260C98h case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 82260C98h case   22:*/		return 0x82260C9C;
		  /* 82260C9Ch */ case   23:  		/* addi R10, R11, 3 */
		/* 82260C9Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 82260C9Ch case   23:*/		return 0x82260CA0;
		  /* 82260CA0h */ case   24:  		/* addi R9, R11, 2 */
		/* 82260CA0h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2);
		/* 82260CA0h case   24:*/		return 0x82260CA4;
		  /* 82260CA4h */ case   25:  		/* lwz R11, <#[R1 + 144]> */
		/* 82260CA4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82260CA4h case   25:*/		return 0x82260CA8;
		  /* 82260CA8h */ case   26:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 82260CA8h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 82260CA8h case   26:*/		return 0x82260CAC;
		  /* 82260CACh */ case   27:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82260CACh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82260CACh case   27:*/		return 0x82260CB0;
		  /* 82260CB0h */ case   28:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82260CB0h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82260CB0h case   28:*/		return 0x82260CB4;
		  /* 82260CB4h */ case   29:  		/* mr R3, R15 */
		/* 82260CB4h case   29:*/		regs.R3 = regs.R15;
		/* 82260CB4h case   29:*/		return 0x82260CB8;
		  /* 82260CB8h */ case   30:  		/* mr R5, R29 */
		/* 82260CB8h case   30:*/		regs.R5 = regs.R29;
		/* 82260CB8h case   30:*/		return 0x82260CBC;
		  /* 82260CBCh */ case   31:  		/* lfsx FR4, <#[R8 + R11]> */
		/* 82260CBCh case   31:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82260CBCh case   31:*/		return 0x82260CC0;
		  /* 82260CC0h */ case   32:  		/* lfsx FR3, <#[R10 + R11]> */
		/* 82260CC0h case   32:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82260CC0h case   32:*/		return 0x82260CC4;
		  /* 82260CC4h */ case   33:  		/* lfsx FR2, <#[R9 + R11]> */
		/* 82260CC4h case   33:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82260CC4h case   33:*/		return 0x82260CC8;
		  /* 82260CC8h */ case   34:  		/* bl -40368 */
		/* 82260CC8h case   34:*/		regs.LR = 0x82260CCC; return 0x82256F18;
		/* 82260CC8h case   34:*/		return 0x82260CCC;
		  /* 82260CCCh */ case   35:  		/* addi R11, R29, 1 */
		/* 82260CCCh case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x1);
		/* 82260CCCh case   35:*/		return 0x82260CD0;
		  /* 82260CD0h */ case   36:  		/* stw R30, <#[R1 + 140]> */
		/* 82260CD0h case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260CD0h case   36:*/		return 0x82260CD4;
		  /* 82260CD4h */ case   37:  		/* b -344 */
		/* 82260CD4h case   37:*/		return 0x82260B7C;
		/* 82260CD4h case   37:*/		return 0x82260CD8;
		  /* 82260CD8h */ case   38:  		/* lwz R11, <#[R1 + 140]> */
		/* 82260CD8h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260CD8h case   38:*/		return 0x82260CDC;
		  /* 82260CDCh */ case   39:  		/* mr R4, R31 */
		/* 82260CDCh case   39:*/		regs.R4 = regs.R31;
		/* 82260CDCh case   39:*/		return 0x82260CE0;
		  /* 82260CE0h */ case   40:  		/* lwz R10, <#[R1 + 144]> */
		/* 82260CE0h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82260CE0h case   40:*/		return 0x82260CE4;
		  /* 82260CE4h */ case   41:  		/* mr R3, R15 */
		/* 82260CE4h case   41:*/		regs.R3 = regs.R15;
		/* 82260CE4h case   41:*/		return 0x82260CE8;
		  /* 82260CE8h */ case   42:  		/* addi R11, R11, 1 */
		/* 82260CE8h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82260CE8h case   42:*/		return 0x82260CEC;
		  /* 82260CECh */ case   43:  		/* lwz R30, <#[R1 + 168]> */
		/* 82260CECh case   43:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A8) );
		/* 82260CECh case   43:*/		return 0x82260CF0;
		  /* 82260CF0h */ case   44:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82260CF0h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82260CF0h case   44:*/		return 0x82260CF4;
		  /* 82260CF4h */ case   45:  		/* stw R11, <#[R1 + 140]> */
		/* 82260CF4h case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82260CF4h case   45:*/		return 0x82260CF8;
		  /* 82260CF8h */ case   46:  		/* mr R5, R30 */
		/* 82260CF8h case   46:*/		regs.R5 = regs.R30;
		/* 82260CF8h case   46:*/		return 0x82260CFC;
		  /* 82260CFCh */ case   47:  		/* lfsx FR1, <#[R9 + R10]> */
		/* 82260CFCh case   47:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82260CFCh case   47:*/		return 0x82260D00;
		  /* 82260D00h */ case   48:  		/* fmr FR4, FR1 */
		/* 82260D00h case   48:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR1);
		/* 82260D00h case   48:*/		return 0x82260D04;
		  /* 82260D04h */ case   49:  		/* fmr FR3, FR1 */
		/* 82260D04h case   49:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR1);
		/* 82260D04h case   49:*/		return 0x82260D08;
		  /* 82260D08h */ case   50:  		/* fmr FR2, FR1 */
		/* 82260D08h case   50:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 82260D08h case   50:*/		return 0x82260D0C;
		  /* 82260D0Ch */ case   51:  		/* bl -40436 */
		/* 82260D0Ch case   51:*/		regs.LR = 0x82260D10; return 0x82256F18;
		/* 82260D0Ch case   51:*/		return 0x82260D10;
		  /* 82260D10h */ case   52:  		/* b -408 */
		/* 82260D10h case   52:*/		return 0x82260B78;
		/* 82260D10h case   52:*/		return 0x82260D14;
		  /* 82260D14h */ case   53:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260D14h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260D14h case   53:*/		return 0x82260D18;
		  /* 82260D18h */ case   54:  		/* addi R7, R11, -548 */
		/* 82260D18h case   54:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFDDC);
		/* 82260D18h case   54:*/		return 0x82260D1C;
		  /* 82260D1Ch */ case   55:  		/* b -1448 */
		/* 82260D1Ch case   55:*/		return 0x82260774;
		/* 82260D1Ch case   55:*/		return 0x82260D20;
		  /* 82260D20h */ case   56:  		/* lwz R11, <#[R1 + 136]> */
		/* 82260D20h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82260D20h case   56:*/		return 0x82260D24;
		  /* 82260D24h */ case   57:  		/* addi R7, R11, 5092 */
		/* 82260D24h case   57:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x13E4);
		/* 82260D24h case   57:*/		return 0x82260D28;
		  /* 82260D28h */ case   58:  		/* b -1460 */
		/* 82260D28h case   58:*/		return 0x82260774;
		/* 82260D28h case   58:*/		return 0x82260D2C;
		  /* 82260D2Ch */ case   59:  		/* lwz R28, <#[R1 + 164]> */
		/* 82260D2Ch case   59:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A4) );
		/* 82260D2Ch case   59:*/		return 0x82260D30;
		  /* 82260D30h */ case   60:  		/* li R30, 0 */
		/* 82260D30h case   60:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82260D30h case   60:*/		return 0x82260D34;
		  /* 82260D34h */ case   61:  		/* lwz R11, <#[R28 + 4]> */
		/* 82260D34h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82260D34h case   61:*/		return 0x82260D38;
		  /* 82260D38h */ case   62:  		/* cmplwi CR6, R11, 0 */
		/* 82260D38h case   62:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82260D38h case   62:*/		return 0x82260D3C;
		  /* 82260D3Ch */ case   63:  		/* bc 12, CR6_EQ, 44 */
		/* 82260D3Ch case   63:*/		if ( regs.CR[6].eq ) { return 0x82260D68;  }
		/* 82260D3Ch case   63:*/		return 0x82260D40;
		  /* 82260D40h */ case   64:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 82260D40h case   64:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 82260D40h case   64:*/		return 0x82260D44;
		  /* 82260D44h */ case   65:  		/* addi R11, R10, -1 */
		/* 82260D44h case   65:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82260D44h case   65:*/		return 0x82260D48;
		  /* 82260D48h */ case   66:  		/* cmplw CR6, R11, R10 */
		/* 82260D48h case   66:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82260D48h case   66:*/		return 0x82260D4C;
		  /* 82260D4Ch */ case   67:  		/* bc 4, CR6_LT, 20 */
		/* 82260D4Ch case   67:*/		if ( !regs.CR[6].lt ) { return 0x82260D60;  }
		/* 82260D4Ch case   67:*/		return 0x82260D50;
		  /* 82260D50h */ case   68:  		/* lwz R10, <#[R28 + 8]> */
		/* 82260D50h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82260D50h case   68:*/		return 0x82260D54;
		  /* 82260D54h */ case   69:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82260D54h case   69:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82260D54h case   69:*/		return 0x82260D58;
		  /* 82260D58h */ case   70:  		/* add R11, R11, R10 */
		/* 82260D58h case   70:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82260D58h case   70:*/		return 0x82260D5C;
		  /* 82260D5Ch */ case   71:  		/* b 8 */
		/* 82260D5Ch case   71:*/		return 0x82260D64;
		/* 82260D5Ch case   71:*/		return 0x82260D60;
	}
	return 0x82260D60;
} // Block from 82260C40h-82260D60h (72 instructions)

//////////////////////////////////////////////////////
// Block at 82260D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260D60);
		  /* 82260D60h */ case    0:  		/* li R11, 0 */
		/* 82260D60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82260D60h case    0:*/		return 0x82260D64;
	}
	return 0x82260D64;
} // Block from 82260D60h-82260D64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260D64);
		  /* 82260D64h */ case    0:  		/* lwz R30, <#[R11]> */
		/* 82260D64h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82260D64h case    0:*/		return 0x82260D68;
	}
	return 0x82260D68;
} // Block from 82260D64h-82260D68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260D68);
		  /* 82260D68h */ case    0:  		/* lwz R11, <#[R1 + 180]> */
		/* 82260D68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 82260D68h case    0:*/		return 0x82260D6C;
		  /* 82260D6Ch */ case    1:  		/* mr R3, R31 */
		/* 82260D6Ch case    1:*/		regs.R3 = regs.R31;
		/* 82260D6Ch case    1:*/		return 0x82260D70;
		  /* 82260D70h */ case    2:  		/* lwz R29, <#[R31 + 12]> */
		/* 82260D70h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260D70h case    2:*/		return 0x82260D74;
		  /* 82260D74h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82260D74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82260D74h case    3:*/		return 0x82260D78;
		  /* 82260D78h */ case    4:  		/* lwz R27, <#[R29 + 1536]> */
		/* 82260D78h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x00000600) );
		/* 82260D78h case    4:*/		return 0x82260D7C;
		  /* 82260D7Ch */ case    5:  		/* lwz R11, <#[R11]> */
		/* 82260D7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82260D7Ch case    5:*/		return 0x82260D80;
		  /* 82260D80h */ case    6:  		/* rlwinm R26, R11, 0, 16, 31 */
		/* 82260D80h case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R26,regs.R11);
		/* 82260D80h case    6:*/		return 0x82260D84;
		  /* 82260D84h */ case    7:  		/* bl -176332 */
		/* 82260D84h case    7:*/		regs.LR = 0x82260D88; return 0x82235CB8;
		/* 82260D84h case    7:*/		return 0x82260D88;
		  /* 82260D88h */ case    8:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 82260D88h case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82260D88h case    8:*/		return 0x82260D8C;
		  /* 82260D8Ch */ case    9:  		/* lis R10, -32222 */
		/* 82260D8Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 82260D8Ch case    9:*/		return 0x82260D90;
		  /* 82260D90h */ case   10:  		/* cntlzw R11, R11 */
		/* 82260D90h case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82260D90h case   10:*/		return 0x82260D94;
		  /* 82260D94h */ case   11:  		/* mr R3, R27 */
		/* 82260D94h case   11:*/		regs.R3 = regs.R27;
		/* 82260D94h case   11:*/		return 0x82260D98;
		  /* 82260D98h */ case   12:  		/* rlwinm R4, R11, 27, 31, 31 */
		/* 82260D98h case   12:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R4,regs.R11);
		/* 82260D98h case   12:*/		return 0x82260D9C;
		  /* 82260D9Ch */ case   13:  		/* mr R5, R26 */
		/* 82260D9Ch case   13:*/		regs.R5 = regs.R26;
		/* 82260D9Ch case   13:*/		return 0x82260DA0;
		  /* 82260DA0h */ case   14:  		/* addi R6, R1, 472 */
		/* 82260DA0h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x1D8);
		/* 82260DA0h case   14:*/		return 0x82260DA4;
		  /* 82260DA4h */ case   15:  		/* addi R7, R10, -12392 */
		/* 82260DA4h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFCF98);
		/* 82260DA4h case   15:*/		return 0x82260DA8;
		  /* 82260DA8h */ case   16:  		/* mr R8, R29 */
		/* 82260DA8h case   16:*/		regs.R8 = regs.R29;
		/* 82260DA8h case   16:*/		return 0x82260DAC;
		  /* 82260DACh */ case   17:  		/* bl -189940 */
		/* 82260DACh case   17:*/		regs.LR = 0x82260DB0; return 0x822327B8;
		/* 82260DACh case   17:*/		return 0x82260DB0;
		  /* 82260DB0h */ case   18:  		/* cmpwi CR6, R3, 1 */
		/* 82260DB0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82260DB0h case   18:*/		return 0x82260DB4;
		  /* 82260DB4h */ case   19:  		/* bc 12, CR6_EQ, 28 */
		/* 82260DB4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82260DD0;  }
		/* 82260DB4h case   19:*/		return 0x82260DB8;
		  /* 82260DB8h */ case   20:  		/* li R7, 3713 */
		/* 82260DB8h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0xE81);
		/* 82260DB8h case   20:*/		return 0x82260DBC;
		  /* 82260DBCh */ case   21:  		/* lwz R6, <#[R1 + 128]> */
		/* 82260DBCh case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82260DBCh case   21:*/		return 0x82260DC0;
		  /* 82260DC0h */ case   22:  		/* li R3, 0 */
		/* 82260DC0h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260DC0h case   22:*/		return 0x82260DC4;
		  /* 82260DC4h */ case   23:  		/* lwz R5, <#[R1 + 300]> */
		/* 82260DC4h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000012C) );
		/* 82260DC4h case   23:*/		return 0x82260DC8;
		  /* 82260DC8h */ case   24:  		/* lwz R4, <#[R1 + 132]> */
		/* 82260DC8h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82260DC8h case   24:*/		return 0x82260DCC;
		  /* 82260DCCh */ case   25:  		/* bl -1085892 */
		/* 82260DCCh case   25:*/		regs.LR = 0x82260DD0; return 0x82157C08;
		/* 82260DCCh case   25:*/		return 0x82260DD0;
	}
	return 0x82260DD0;
} // Block from 82260D68h-82260DD0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82260DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260DD0);
		  /* 82260DD0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82260DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260DD0h case    0:*/		return 0x82260DD4;
		  /* 82260DD4h */ case    1:  		/* li R3, 160 */
		/* 82260DD4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xA0);
		/* 82260DD4h case    1:*/		return 0x82260DD8;
		  /* 82260DD8h */ case    2:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82260DD8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82260DD8h case    2:*/		return 0x82260DDC;
		  /* 82260DDCh */ case    3:  		/* bl -26348 */
		/* 82260DDCh case    3:*/		regs.LR = 0x82260DE0; return 0x8225A6F0;
		/* 82260DDCh case    3:*/		return 0x82260DE0;
		  /* 82260DE0h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 82260DE0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82260DE0h case    4:*/		return 0x82260DE4;
		  /* 82260DE4h */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 82260DE4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82260E00;  }
		/* 82260DE4h case    5:*/		return 0x82260DE8;
		  /* 82260DE8h */ case    6:  		/* mr R5, R30 */
		/* 82260DE8h case    6:*/		regs.R5 = regs.R30;
		/* 82260DE8h case    6:*/		return 0x82260DEC;
		  /* 82260DECh */ case    7:  		/* lwz R4, <#[R1 + 472]> */
		/* 82260DECh case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000001D8) );
		/* 82260DECh case    7:*/		return 0x82260DF0;
		  /* 82260DF0h */ case    8:  		/* lwz R6, <#[R31 + 12]> */
		/* 82260DF0h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260DF0h case    8:*/		return 0x82260DF4;
		  /* 82260DF4h */ case    9:  		/* bl -28580 */
		/* 82260DF4h case    9:*/		regs.LR = 0x82260DF8; return 0x82259E50;
		/* 82260DF4h case    9:*/		return 0x82260DF8;
		  /* 82260DF8h */ case   10:  		/* mr R30, R3 */
		/* 82260DF8h case   10:*/		regs.R30 = regs.R3;
		/* 82260DF8h case   10:*/		return 0x82260DFC;
		  /* 82260DFCh */ case   11:  		/* b 8 */
		/* 82260DFCh case   11:*/		return 0x82260E04;
		/* 82260DFCh case   11:*/		return 0x82260E00;
	}
	return 0x82260E00;
} // Block from 82260DD0h-82260E00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82260E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260E00);
		  /* 82260E00h */ case    0:  		/* li R30, 0 */
		/* 82260E00h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82260E00h case    0:*/		return 0x82260E04;
	}
	return 0x82260E04;
} // Block from 82260E00h-82260E04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260E04);
		  /* 82260E04h */ case    0:  		/* lwz R29, <#[R1 + 188]> */
		/* 82260E04h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000BC) );
		/* 82260E04h case    0:*/		return 0x82260E08;
		  /* 82260E08h */ case    1:  		/* mr R3, R31 */
		/* 82260E08h case    1:*/		regs.R3 = regs.R31;
		/* 82260E08h case    1:*/		return 0x82260E0C;
		  /* 82260E0Ch */ case    2:  		/* lwz R4, <#[R30 + 144]> */
		/* 82260E0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000090) );
		/* 82260E0Ch case    2:*/		return 0x82260E10;
		  /* 82260E10h */ case    3:  		/* stw R29, <#[R30 + 52]> */
		/* 82260E10h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000034) );
		/* 82260E10h case    3:*/		return 0x82260E14;
		  /* 82260E14h */ case    4:  		/* bl -174188 */
		/* 82260E14h case    4:*/		regs.LR = 0x82260E18; return 0x822365A8;
		/* 82260E14h case    4:*/		return 0x82260E18;
		  /* 82260E18h */ case    5:  		/* mr R3, R28 */
		/* 82260E18h case    5:*/		regs.R3 = regs.R28;
		/* 82260E18h case    5:*/		return 0x82260E1C;
		  /* 82260E1Ch */ case    6:  		/* lwz R4, <#[R28 + 4]> */
		/* 82260E1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000004) );
		/* 82260E1Ch case    6:*/		return 0x82260E20;
		  /* 82260E20h */ case    7:  		/* bl -54112 */
		/* 82260E20h case    7:*/		regs.LR = 0x82260E24; return 0x82253AC0;
		/* 82260E20h case    7:*/		return 0x82260E24;
		  /* 82260E24h */ case    8:  		/* addic. R28, R29, 1 */
		/* 82260E24h case    8:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R29,0x1);
		/* 82260E24h case    8:*/		return 0x82260E28;
		  /* 82260E28h */ case    9:  		/* stw R30, <#[R3]> */
		/* 82260E28h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82260E28h case    9:*/		return 0x82260E2C;
		  /* 82260E2Ch */ case   10:  		/* stw R28, <#[R1 + 188]> */
		/* 82260E2Ch case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x000000BC) );
		/* 82260E2Ch case   10:*/		return 0x82260E30;
		  /* 82260E30h */ case   11:  		/* bc 4, CR0_LT, 28 */
		/* 82260E30h case   11:*/		if ( !regs.CR[0].lt ) { return 0x82260E4C;  }
		/* 82260E30h case   11:*/		return 0x82260E34;
		  /* 82260E34h */ case   12:  		/* li R7, 3722 */
		/* 82260E34h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0xE8A);
		/* 82260E34h case   12:*/		return 0x82260E38;
		  /* 82260E38h */ case   13:  		/* lwz R6, <#[R1 + 128]> */
		/* 82260E38h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82260E38h case   13:*/		return 0x82260E3C;
		  /* 82260E3Ch */ case   14:  		/* li R3, 0 */
		/* 82260E3Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260E3Ch case   14:*/		return 0x82260E40;
		  /* 82260E40h */ case   15:  		/* lwz R5, <#[R1 + 340]> */
		/* 82260E40h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000154) );
		/* 82260E40h case   15:*/		return 0x82260E44;
		  /* 82260E44h */ case   16:  		/* lwz R4, <#[R1 + 132]> */
		/* 82260E44h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82260E44h case   16:*/		return 0x82260E48;
		  /* 82260E48h */ case   17:  		/* bl -1086016 */
		/* 82260E48h case   17:*/		regs.LR = 0x82260E4C; return 0x82157C08;
		/* 82260E48h case   17:*/		return 0x82260E4C;
	}
	return 0x82260E4C;
} // Block from 82260E04h-82260E4Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 82260E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260E4C);
		  /* 82260E4Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82260E4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260E4Ch case    0:*/		return 0x82260E50;
		  /* 82260E50h */ case    1:  		/* lwz R10, <#[R11 + 1360]> */
		/* 82260E50h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000550) );
		/* 82260E50h case    1:*/		return 0x82260E54;
		  /* 82260E54h */ case    2:  		/* lwz R10, <#[R10 + 28]> */
		/* 82260E54h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000001C) );
		/* 82260E54h case    2:*/		return 0x82260E58;
		  /* 82260E58h */ case    3:  		/* cmpw CR6, R28, R10 */
		/* 82260E58h case    3:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R10);
		/* 82260E58h case    3:*/		return 0x82260E5C;
		  /* 82260E5Ch */ case    4:  		/* bc 12, CR6_GT, 9572 */
		/* 82260E5Ch case    4:*/		if ( regs.CR[6].gt ) { return 0x822633C0;  }
		/* 82260E5Ch case    4:*/		return 0x82260E60;
		  /* 82260E60h */ case    5:  		/* lwz R29, <#[R1 + 160]> */
		/* 82260E60h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000A0) );
		/* 82260E60h case    5:*/		return 0x82260E64;
		  /* 82260E64h */ case    6:  		/* mr R5, R30 */
		/* 82260E64h case    6:*/		regs.R5 = regs.R30;
		/* 82260E64h case    6:*/		return 0x82260E68;
		  /* 82260E68h */ case    7:  		/* mr R3, R31 */
		/* 82260E68h case    7:*/		regs.R3 = regs.R31;
		/* 82260E68h case    7:*/		return 0x82260E6C;
		  /* 82260E6Ch */ case    8:  		/* mr R4, R29 */
		/* 82260E6Ch case    8:*/		regs.R4 = regs.R29;
		/* 82260E6Ch case    8:*/		return 0x82260E70;
		  /* 82260E70h */ case    9:  		/* bl -176664 */
		/* 82260E70h case    9:*/		regs.LR = 0x82260E74; return 0x82235C58;
		/* 82260E70h case    9:*/		return 0x82260E74;
		  /* 82260E74h */ case   10:  		/* mr R4, R30 */
		/* 82260E74h case   10:*/		regs.R4 = regs.R30;
		/* 82260E74h case   10:*/		return 0x82260E78;
		  /* 82260E78h */ case   11:  		/* mr R3, R29 */
		/* 82260E78h case   11:*/		regs.R3 = regs.R29;
		/* 82260E78h case   11:*/		return 0x82260E7C;
		  /* 82260E7Ch */ case   12:  		/* bl -30124 */
		/* 82260E7Ch case   12:*/		regs.LR = 0x82260E80; return 0x822598D0;
		/* 82260E7Ch case   12:*/		return 0x82260E80;
		  /* 82260E80h */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 82260E80h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260E80h case   13:*/		return 0x82260E84;
		  /* 82260E84h */ case   14:  		/* li R3, 136 */
		/* 82260E84h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 82260E84h case   14:*/		return 0x82260E88;
		  /* 82260E88h */ case   15:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82260E88h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82260E88h case   15:*/		return 0x82260E8C;
		  /* 82260E8Ch */ case   16:  		/* bl -26524 */
		/* 82260E8Ch case   16:*/		regs.LR = 0x82260E90; return 0x8225A6F0;
		/* 82260E8Ch case   16:*/		return 0x82260E90;
		  /* 82260E90h */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 82260E90h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82260E90h case   17:*/		return 0x82260E94;
		  /* 82260E94h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 82260E94h case   18:*/		if ( regs.CR[0].eq ) { return 0x82260EA8;  }
		/* 82260E94h case   18:*/		return 0x82260E98;
		  /* 82260E98h */ case   19:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260E98h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260E98h case   19:*/		return 0x82260E9C;
		  /* 82260E9Ch */ case   20:  		/* bl -32076 */
		/* 82260E9Ch case   20:*/		regs.LR = 0x82260EA0; return 0x82259150;
		/* 82260E9Ch case   20:*/		return 0x82260EA0;
		  /* 82260EA0h */ case   21:  		/* mr R14, R3 */
		/* 82260EA0h case   21:*/		regs.R14 = regs.R3;
		/* 82260EA0h case   21:*/		return 0x82260EA4;
		  /* 82260EA4h */ case   22:  		/* b 8 */
		/* 82260EA4h case   22:*/		return 0x82260EAC;
		/* 82260EA4h case   22:*/		return 0x82260EA8;
	}
	return 0x82260EA8;
} // Block from 82260E4Ch-82260EA8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82260EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260EA8);
		  /* 82260EA8h */ case    0:  		/* li R14, 0 */
		/* 82260EA8h case    0:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82260EA8h case    0:*/		return 0x82260EAC;
	}
	return 0x82260EAC;
} // Block from 82260EA8h-82260EACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260EAC);
		  /* 82260EACh */ case    0:  		/* stw R28, <#[R14 + 52]> */
		/* 82260EACh case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R14 + 0x00000034) );
		/* 82260EACh case    0:*/		return 0x82260EB0;
		  /* 82260EB0h */ case    1:  		/* mr R3, R31 */
		/* 82260EB0h case    1:*/		regs.R3 = regs.R31;
		/* 82260EB0h case    1:*/		return 0x82260EB4;
		  /* 82260EB4h */ case    2:  		/* mr R4, R30 */
		/* 82260EB4h case    2:*/		regs.R4 = regs.R30;
		/* 82260EB4h case    2:*/		return 0x82260EB8;
		  /* 82260EB8h */ case    3:  		/* mr R5, R14 */
		/* 82260EB8h case    3:*/		regs.R5 = regs.R14;
		/* 82260EB8h case    3:*/		return 0x82260EBC;
		  /* 82260EBCh */ case    4:  		/* bl -176740 */
		/* 82260EBCh case    4:*/		regs.LR = 0x82260EC0; return 0x82235C58;
		/* 82260EBCh case    4:*/		return 0x82260EC0;
		  /* 82260EC0h */ case    5:  		/* mr R4, R14 */
		/* 82260EC0h case    5:*/		regs.R4 = regs.R14;
		/* 82260EC0h case    5:*/		return 0x82260EC4;
		  /* 82260EC4h */ case    6:  		/* mr R3, R30 */
		/* 82260EC4h case    6:*/		regs.R3 = regs.R30;
		/* 82260EC4h case    6:*/		return 0x82260EC8;
		  /* 82260EC8h */ case    7:  		/* bl -30200 */
		/* 82260EC8h case    7:*/		regs.LR = 0x82260ECC; return 0x822598D0;
		/* 82260EC8h case    7:*/		return 0x82260ECC;
		  /* 82260ECCh */ case    8:  		/* stw R14, <#[R1 + 160]> */
		/* 82260ECCh case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x000000A0) );
		/* 82260ECCh case    8:*/		return 0x82260ED0;
		  /* 82260ED0h */ case    9:  		/* b 3824 */
		/* 82260ED0h case    9:*/		return 0x82261DC0;
		/* 82260ED0h case    9:*/		return 0x82260ED4;
		  /* 82260ED4h */ case   10:  		/* lwz R27, <#[R1 + 164]> */
		/* 82260ED4h case   10:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000A4) );
		/* 82260ED4h case   10:*/		return 0x82260ED8;
		  /* 82260ED8h */ case   11:  		/* lwz R10, <#[R27 + 4]> */
		/* 82260ED8h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 82260ED8h case   11:*/		return 0x82260EDC;
		  /* 82260EDCh */ case   12:  		/* addi R11, R10, -1 */
		/* 82260EDCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82260EDCh case   12:*/		return 0x82260EE0;
		  /* 82260EE0h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 82260EE0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82260EE0h case   13:*/		return 0x82260EE4;
		  /* 82260EE4h */ case   14:  		/* bc 4, CR6_LT, 20 */
		/* 82260EE4h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82260EF8;  }
		/* 82260EE4h case   14:*/		return 0x82260EE8;
		  /* 82260EE8h */ case   15:  		/* lwz R10, <#[R27 + 8]> */
		/* 82260EE8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 82260EE8h case   15:*/		return 0x82260EEC;
		  /* 82260EECh */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82260EECh case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82260EECh case   16:*/		return 0x82260EF0;
		  /* 82260EF0h */ case   17:  		/* add R11, R11, R10 */
		/* 82260EF0h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82260EF0h case   17:*/		return 0x82260EF4;
		  /* 82260EF4h */ case   18:  		/* b 8 */
		/* 82260EF4h case   18:*/		return 0x82260EFC;
		/* 82260EF4h case   18:*/		return 0x82260EF8;
	}
	return 0x82260EF8;
} // Block from 82260EACh-82260EF8h (19 instructions)

