#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82220E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220E44);
		  /* 82220E44h */ case    0:  		/* mr R3, R30 */
		/* 82220E44h case    0:*/		regs.R3 = regs.R30;
		/* 82220E44h case    0:*/		return 0x82220E48;
		  /* 82220E48h */ case    1:  		/* bl -170568 */
		/* 82220E48h case    1:*/		regs.LR = 0x82220E4C; return 0x821F7400;
		/* 82220E48h case    1:*/		return 0x82220E4C;
		  /* 82220E4Ch */ case    2:  		/* addi R31, R31, -1 */
		/* 82220E4Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82220E4Ch case    2:*/		return 0x82220E50;
	}
	return 0x82220E50;
} // Block from 82220E44h-82220E50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82220E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220E50);
		  /* 82220E50h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82220E50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82220E50h case    0:*/		return 0x82220E54;
		  /* 82220E54h */ case    1:  		/* bc 4, CR6_EQ, -52 */
		/* 82220E54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82220E20;  }
		/* 82220E54h case    1:*/		return 0x82220E58;
		  /* 82220E58h */ case    2:  		/* b 12 */
		/* 82220E58h case    2:*/		return 0x82220E64;
		/* 82220E58h case    2:*/		return 0x82220E5C;
	}
	return 0x82220E5C;
} // Block from 82220E50h-82220E5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82220E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220E5C);
		  /* 82220E5Ch */ case    0:  		/* subf R11, R31, R11 */
		/* 82220E5Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82220E5Ch case    0:*/		return 0x82220E60;
		  /* 82220E60h */ case    1:  		/* stw R11, <#[R30 + 4]> */
		/* 82220E60h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82220E60h case    1:*/		return 0x82220E64;
	}
	return 0x82220E64;
} // Block from 82220E5Ch-82220E64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82220E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220E64);
		  /* 82220E64h */ case    0:  		/* addi R1, R1, 112 */
		/* 82220E64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82220E64h case    0:*/		return 0x82220E68;
		  /* 82220E68h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82220E68h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82220E68h case    1:*/		return 0x82220E6C;
		  /* 82220E6Ch */ case    2:  		/* mtspr LR, R12 */
		/* 82220E6Ch case    2:*/		regs.LR = regs.R12;
		/* 82220E6Ch case    2:*/		return 0x82220E70;
		  /* 82220E70h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82220E70h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82220E70h case    3:*/		return 0x82220E74;
		  /* 82220E74h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82220E74h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82220E74h case    4:*/		return 0x82220E78;
		  /* 82220E78h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82220E78h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82220E78h case    5:*/		return 0x82220E7C;
	}
	return 0x82220E7C;
} // Block from 82220E64h-82220E7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82220E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220E7C);
		  /* 82220E7Ch */ case    0:  		/* nop */
		/* 82220E7Ch case    0:*/		cpu::op::nop();
		/* 82220E7Ch case    0:*/		return 0x82220E80;
		  /* 82220E80h */ case    1:  		/* lwz R11, <#[R4 + 4]> */
		/* 82220E80h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82220E80h case    1:*/		return 0x82220E84;
		  /* 82220E84h */ case    2:  		/* rlwinm R10, R11, 14, 27, 31 */
		/* 82220E84h case    2:*/		cpu::op::rlwinm<0,14,27,31>(regs,&regs.R10,regs.R11);
		/* 82220E84h case    2:*/		return 0x82220E88;
		  /* 82220E88h */ case    3:  		/* cmplw CR6, R5, R10 */
		/* 82220E88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 82220E88h case    3:*/		return 0x82220E8C;
		  /* 82220E8Ch */ case    4:  		/* bc 12, CR6_LT, 12 */
		/* 82220E8Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82220E98;  }
		/* 82220E8Ch case    4:*/		return 0x82220E90;
		  /* 82220E90h */ case    5:  		/* li R3, 0 */
		/* 82220E90h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82220E90h case    5:*/		return 0x82220E94;
		  /* 82220E94h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82220E94h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82220E94h case    6:*/		return 0x82220E98;
	}
	return 0x82220E98;
} // Block from 82220E7Ch-82220E98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82220E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220E98);
		  /* 82220E98h */ case    0:  		/* rlwinm. R11, R11, 0, 18, 18 */
		/* 82220E98h case    0:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R11);
		/* 82220E98h case    0:*/		return 0x82220E9C;
		  /* 82220E9Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82220E9Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82220EB4;  }
		/* 82220E9Ch case    1:*/		return 0x82220EA0;
		  /* 82220EA0h */ case    2:  		/* lwz R11, <#[R3 + 56]> */
		/* 82220EA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82220EA0h case    2:*/		return 0x82220EA4;
		  /* 82220EA4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82220EA4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82220EA4h case    3:*/		return 0x82220EA8;
		  /* 82220EA8h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82220EA8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82220EB4;  }
		/* 82220EA8h case    4:*/		return 0x82220EAC;
		  /* 82220EACh */ case    5:  		/* li R10, 1 */
		/* 82220EACh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82220EACh case    5:*/		return 0x82220EB0;
		  /* 82220EB0h */ case    6:  		/* stw R10, <#[R11 + 28]> */
		/* 82220EB0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82220EB0h case    6:*/		return 0x82220EB4;
	}
	return 0x82220EB4;
} // Block from 82220E98h-82220EB4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82220EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220EB4);
		  /* 82220EB4h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 82220EB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82220EB4h case    0:*/		return 0x82220EB8;
		  /* 82220EB8h */ case    1:  		/* rlwinm R10, R5, 5, 23, 26 */
		/* 82220EB8h case    1:*/		cpu::op::rlwinm<0,5,23,26>(regs,&regs.R10,regs.R5);
		/* 82220EB8h case    1:*/		return 0x82220EBC;
		  /* 82220EBCh */ case    2:  		/* lwz R9, <#[R7 + 4]> */
		/* 82220EBCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000004) );
		/* 82220EBCh case    2:*/		return 0x82220EC0;
		  /* 82220EC0h */ case    3:  		/* rlwinm R11, R11, 9, 27, 31 */
		/* 82220EC0h case    3:*/		cpu::op::rlwinm<0,9,27,31>(regs,&regs.R11,regs.R11);
		/* 82220EC0h case    3:*/		return 0x82220EC4;
		  /* 82220EC4h */ case    4:  		/* rlwinm R9, R9, 0, 0, 22 */
		/* 82220EC4h case    4:*/		cpu::op::rlwinm<0,0,0,22>(regs,&regs.R9,regs.R9);
		/* 82220EC4h case    4:*/		return 0x82220EC8;
		  /* 82220EC8h */ case    5:  		/* or R11, R10, R11 */
		/* 82220EC8h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82220EC8h case    5:*/		return 0x82220ECC;
		  /* 82220ECCh */ case    6:  		/* or R11, R11, R9 */
		/* 82220ECCh case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82220ECCh case    6:*/		return 0x82220ED0;
		  /* 82220ED0h */ case    7:  		/* stw R11, <#[R7 + 4]> */
		/* 82220ED0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 82220ED0h case    7:*/		return 0x82220ED4;
		  /* 82220ED4h */ case    8:  		/* lwz R11, <#[R4 + 4]> */
		/* 82220ED4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82220ED4h case    8:*/		return 0x82220ED8;
		  /* 82220ED8h */ case    9:  		/* lwz R10, <#[R7 + 4]> */
		/* 82220ED8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000004) );
		/* 82220ED8h case    9:*/		return 0x82220EDC;
		  /* 82220EDCh */ case   10:  		/* rlwimi R10, R11, 28, 18, 18 */
		/* 82220EDCh case   10:*/		cpu::op::rlwimi<0,28,18,18>(regs,&regs.R10,regs.R11);
		/* 82220EDCh case   10:*/		return 0x82220EE0;
		  /* 82220EE0h */ case   11:  		/* stw R10, <#[R7 + 4]> */
		/* 82220EE0h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		/* 82220EE0h case   11:*/		return 0x82220EE4;
		  /* 82220EE4h */ case   12:  		/* lwz R11, <#[R4 + 4]> */
		/* 82220EE4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82220EE4h case   12:*/		return 0x82220EE8;
		  /* 82220EE8h */ case   13:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 82220EE8h case   13:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 82220EE8h case   13:*/		return 0x82220EEC;
		  /* 82220EECh */ case   14:  		/* cmplwi CR6, R11, 16384 */
		/* 82220EECh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 82220EECh case   14:*/		return 0x82220EF0;
		  /* 82220EF0h */ case   15:  		/* bc 12, CR6_EQ, 24 */
		/* 82220EF0h case   15:*/		if ( regs.CR[6].eq ) { return 0x82220F08;  }
		/* 82220EF0h case   15:*/		return 0x82220EF4;
		  /* 82220EF4h */ case   16:  		/* lwz R11, <#[R4 + 4]> */
		/* 82220EF4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82220EF4h case   16:*/		return 0x82220EF8;
		  /* 82220EF8h */ case   17:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 82220EF8h case   17:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 82220EF8h case   17:*/		return 0x82220EFC;
		  /* 82220EFCh */ case   18:  		/* cmplwi CR6, R11, 49152 */
		/* 82220EFCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000C000);
		/* 82220EFCh case   18:*/		return 0x82220F00;
		  /* 82220F00h */ case   19:  		/* li R11, 0 */
		/* 82220F00h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82220F00h case   19:*/		return 0x82220F04;
		  /* 82220F04h */ case   20:  		/* bc 4, CR6_EQ, 8 */
		/* 82220F04h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82220F0C;  }
		/* 82220F04h case   20:*/		return 0x82220F08;
	}
	return 0x82220F08;
} // Block from 82220EB4h-82220F08h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82220F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220F08);
		  /* 82220F08h */ case    0:  		/* li R11, 1 */
		/* 82220F08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82220F08h case    0:*/		return 0x82220F0C;
	}
	return 0x82220F0C;
} // Block from 82220F08h-82220F0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82220F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220F0C);
		  /* 82220F0Ch */ case    0:  		/* lwz R10, <#[R7 + 4]> */
		/* 82220F0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000004) );
		/* 82220F0Ch case    0:*/		return 0x82220F10;
		  /* 82220F10h */ case    1:  		/* li R3, 1 */
		/* 82220F10h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82220F10h case    1:*/		return 0x82220F14;
		  /* 82220F14h */ case    2:  		/* stw R6, <#[R7]> */
		/* 82220F14h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 82220F14h case    2:*/		return 0x82220F18;
		  /* 82220F18h */ case    3:  		/* rlwimi R10, R11, 16, 15, 15 */
		/* 82220F18h case    3:*/		cpu::op::rlwimi<0,16,15,15>(regs,&regs.R10,regs.R11);
		/* 82220F18h case    3:*/		return 0x82220F1C;
		  /* 82220F1Ch */ case    4:  		/* stw R10, <#[R7 + 4]> */
		/* 82220F1Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		/* 82220F1Ch case    4:*/		return 0x82220F20;
		  /* 82220F20h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 82220F20h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82220F20h case    5:*/		return 0x82220F24;
		  /* 82220F24h */ case    6:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82220F24h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82220F24h case    6:*/		return 0x82220F28;
		  /* 82220F28h */ case    7:  		/* stw R11, <#[R8]> */
		/* 82220F28h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82220F28h case    7:*/		return 0x82220F2C;
		  /* 82220F2Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 82220F2Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82220F2Ch case    8:*/		return 0x82220F30;
	}
	return 0x82220F30;
} // Block from 82220F0Ch-82220F30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82220F30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220F30);
		  /* 82220F30h */ case    0:  		/* mfspr R12, LR */
		/* 82220F30h case    0:*/		regs.R12 = regs.LR;
		/* 82220F30h case    0:*/		return 0x82220F34;
		  /* 82220F34h */ case    1:  		/* bl -1637608 */
		/* 82220F34h case    1:*/		regs.LR = 0x82220F38; return 0x8209124C;
		/* 82220F34h case    1:*/		return 0x82220F38;
		  /* 82220F38h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82220F38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82220F38h case    2:*/		return 0x82220F3C;
		  /* 82220F3Ch */ case    3:  		/* mr R31, R4 */
		/* 82220F3Ch case    3:*/		regs.R31 = regs.R4;
		/* 82220F3Ch case    3:*/		return 0x82220F40;
		  /* 82220F40h */ case    4:  		/* mr R4, R6 */
		/* 82220F40h case    4:*/		regs.R4 = regs.R6;
		/* 82220F40h case    4:*/		return 0x82220F44;
		  /* 82220F44h */ case    5:  		/* mr R28, R5 */
		/* 82220F44h case    5:*/		regs.R28 = regs.R5;
		/* 82220F44h case    5:*/		return 0x82220F48;
		  /* 82220F48h */ case    6:  		/* mr R25, R7 */
		/* 82220F48h case    6:*/		regs.R25 = regs.R7;
		/* 82220F48h case    6:*/		return 0x82220F4C;
		  /* 82220F4Ch */ case    7:  		/* bl -216884 */
		/* 82220F4Ch case    7:*/		regs.LR = 0x82220F50; return 0x821EC018;
		/* 82220F4Ch case    7:*/		return 0x82220F50;
		  /* 82220F50h */ case    8:  		/* mr R11, R3 */
		/* 82220F50h case    8:*/		regs.R11 = regs.R3;
		/* 82220F50h case    8:*/		return 0x82220F54;
		  /* 82220F54h */ case    9:  		/* mr R3, R31 */
		/* 82220F54h case    9:*/		regs.R3 = regs.R31;
		/* 82220F54h case    9:*/		return 0x82220F58;
		  /* 82220F58h */ case   10:  		/* mr R5, R28 */
		/* 82220F58h case   10:*/		regs.R5 = regs.R28;
		/* 82220F58h case   10:*/		return 0x82220F5C;
		  /* 82220F5Ch */ case   11:  		/* lwz R4, <#[R11 + 24]> */
		/* 82220F5Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 82220F5Ch case   11:*/		return 0x82220F60;
		  /* 82220F60h */ case   12:  		/* bl -1631384 */
		/* 82220F60h case   12:*/		regs.LR = 0x82220F64; return 0x82092AC8;
		/* 82220F60h case   12:*/		return 0x82220F64;
		  /* 82220F64h */ case   13:  		/* add R26, R31, R28 */
		/* 82220F64h case   13:*/		cpu::op::add<0>(regs,&regs.R26,regs.R31,regs.R28);
		/* 82220F64h case   13:*/		return 0x82220F68;
		  /* 82220F68h */ case   14:  		/* li R27, 0 */
		/* 82220F68h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82220F68h case   14:*/		return 0x82220F6C;
		  /* 82220F6Ch */ case   15:  		/* li R4, 95 */
		/* 82220F6Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x5F);
		/* 82220F6Ch case   15:*/		return 0x82220F70;
		  /* 82220F70h */ case   16:  		/* mr R3, R31 */
		/* 82220F70h case   16:*/		regs.R3 = regs.R31;
		/* 82220F70h case   16:*/		return 0x82220F74;
		  /* 82220F74h */ case   17:  		/* stb R27, <#[R26 - 1]> */
		/* 82220F74h case   17:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R26 + 0xFFFFFFFF) );
		/* 82220F74h case   17:*/		return 0x82220F78;
		  /* 82220F78h */ case   18:  		/* bl -1629096 */
		/* 82220F78h case   18:*/		regs.LR = 0x82220F7C; return 0x820933D0;
		/* 82220F78h case   18:*/		return 0x82220F7C;
		  /* 82220F7Ch */ case   19:  		/* or. R30, R3, R3 */
		/* 82220F7Ch case   19:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82220F7Ch case   19:*/		return 0x82220F80;
		  /* 82220F80h */ case   20:  		/* bc 12, CR0_EQ, 56 */
		/* 82220F80h case   20:*/		if ( regs.CR[0].eq ) { return 0x82220FB8;  }
		/* 82220F80h case   20:*/		return 0x82220F84;
		  /* 82220F84h */ case   21:  		/* lis R11, -32253 */
		/* 82220F84h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82220F84h case   21:*/		return 0x82220F88;
		  /* 82220F88h */ case   22:  		/* mr R3, R30 */
		/* 82220F88h case   22:*/		regs.R3 = regs.R30;
		/* 82220F88h case   22:*/		return 0x82220F8C;
		  /* 82220F8Ch */ case   23:  		/* addi R4, R11, 30572 */
		/* 82220F8Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x776C);
		/* 82220F8Ch case   23:*/		return 0x82220F90;
		  /* 82220F90h */ case   24:  		/* bl -1629024 */
		/* 82220F90h case   24:*/		regs.LR = 0x82220F94; return 0x82093430;
		/* 82220F90h case   24:*/		return 0x82220F94;
		  /* 82220F94h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 82220F94h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82220F94h case   25:*/		return 0x82220F98;
		  /* 82220F98h */ case   26:  		/* bc 12, CR0_EQ, 28 */
		/* 82220F98h case   26:*/		if ( regs.CR[0].eq ) { return 0x82220FB4;  }
		/* 82220F98h case   26:*/		return 0x82220F9C;
		  /* 82220F9Ch */ case   27:  		/* lis R11, -32252 */
		/* 82220F9Ch case   27:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82220F9Ch case   27:*/		return 0x82220FA0;
		  /* 82220FA0h */ case   28:  		/* mr R3, R30 */
		/* 82220FA0h case   28:*/		regs.R3 = regs.R30;
		/* 82220FA0h case   28:*/		return 0x82220FA4;
		  /* 82220FA4h */ case   29:  		/* addi R4, R11, -13552 */
		/* 82220FA4h case   29:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFCB10);
		/* 82220FA4h case   29:*/		return 0x82220FA8;
		  /* 82220FA8h */ case   30:  		/* bl -1629048 */
		/* 82220FA8h case   30:*/		regs.LR = 0x82220FAC; return 0x82093430;
		/* 82220FA8h case   30:*/		return 0x82220FAC;
		  /* 82220FACh */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 82220FACh case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82220FACh case   31:*/		return 0x82220FB0;
		  /* 82220FB0h */ case   32:  		/* bc 4, CR0_EQ, 8 */
		/* 82220FB0h case   32:*/		if ( !regs.CR[0].eq ) { return 0x82220FB8;  }
		/* 82220FB0h case   32:*/		return 0x82220FB4;
	}
	return 0x82220FB4;
} // Block from 82220F30h-82220FB4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82220FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220FB4);
		  /* 82220FB4h */ case    0:  		/* stb R27, <#[R30]> */
		/* 82220FB4h case    0:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R30 + 0x00000000) );
		/* 82220FB4h case    0:*/		return 0x82220FB8;
	}
	return 0x82220FB8;
} // Block from 82220FB4h-82220FB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82220FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220FB8);
		  /* 82220FB8h */ case    0:  		/* mr R11, R31 */
		/* 82220FB8h case    0:*/		regs.R11 = regs.R31;
		/* 82220FB8h case    0:*/		return 0x82220FBC;
		  /* 82220FBCh */ case    1:  		/* lbz R10, <#[R11]> */
		/* 82220FBCh case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82220FBCh case    1:*/		return 0x82220FC0;
		  /* 82220FC0h */ case    2:  		/* addi R11, R11, 1 */
		/* 82220FC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82220FC0h case    2:*/		return 0x82220FC4;
		  /* 82220FC4h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82220FC4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82220FC4h case    3:*/		return 0x82220FC8;
		  /* 82220FC8h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82220FC8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82220FBC;  }
		/* 82220FC8h case    4:*/		return 0x82220FCC;
		  /* 82220FCCh */ case    5:  		/* subf R11, R31, R11 */
		/* 82220FCCh case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82220FCCh case    5:*/		return 0x82220FD0;
		  /* 82220FD0h */ case    6:  		/* addi R11, R11, -1 */
		/* 82220FD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82220FD0h case    6:*/		return 0x82220FD4;
		  /* 82220FD4h */ case    7:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82220FD4h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82220FD4h case    7:*/		return 0x82220FD8;
		  /* 82220FD8h */ case    8:  		/* add R30, R11, R31 */
		/* 82220FD8h case    8:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R31);
		/* 82220FD8h case    8:*/		return 0x82220FDC;
		  /* 82220FDCh */ case    9:  		/* cmplw CR6, R30, R31 */
		/* 82220FDCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 82220FDCh case    9:*/		return 0x82220FE0;
		  /* 82220FE0h */ case   10:  		/* bc 4, CR6_GT, 40 */
		/* 82220FE0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82221008;  }
		/* 82220FE0h case   10:*/		return 0x82220FE4;
		  /* 82220FE4h */ case   11:  		/* lbz R11, <#[R30 - 1]> */
		/* 82220FE4h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFFF) );
		/* 82220FE4h case   11:*/		return 0x82220FE8;
		  /* 82220FE8h */ case   12:  		/* addi R29, R30, -1 */
		/* 82220FE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0xFFFFFFFF);
		/* 82220FE8h case   12:*/		return 0x82220FEC;
		  /* 82220FECh */ case   13:  		/* extsb R3, R11 */
		/* 82220FECh case   13:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 82220FECh case   13:*/		return 0x82220FF0;
	}
	return 0x82220FF0;
} // Block from 82220FB8h-82220FF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82220FF0h
// Function '?ProcessCompilerStates@XGRAPHICS@@YAXPAU_CP_COMPILED_PROGRAM@1@PAU_OBJECT_LIST@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82220FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82220FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82220FF0);
		  /* 82220FF0h */ case    0:  		/* bl -1603808 */
		/* 82220FF0h case    0:*/		regs.LR = 0x82220FF4; return 0x82099710;
		/* 82220FF0h case    0:*/		return 0x82220FF4;
		  /* 82220FF4h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 82220FF4h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82220FF4h case    1:*/		return 0x82220FF8;
		  /* 82220FF8h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82220FF8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82221008;  }
		/* 82220FF8h case    2:*/		return 0x82220FFC;
		  /* 82220FFCh */ case    3:  		/* mr R30, R29 */
		/* 82220FFCh case    3:*/		regs.R30 = regs.R29;
		/* 82220FFCh case    3:*/		return 0x82221000;
		  /* 82221000h */ case    4:  		/* cmplw CR6, R29, R31 */
		/* 82221000h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 82221000h case    4:*/		return 0x82221004;
		  /* 82221004h */ case    5:  		/* bc 12, CR6_GT, -32 */
		/* 82221004h case    5:*/		if ( regs.CR[6].gt ) { return 0x82220FE4;  }
		/* 82221004h case    5:*/		return 0x82221008;
	}
	return 0x82221008;
} // Block from 82220FF0h-82221008h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221008);
		  /* 82221008h */ case    0:  		/* li R5, 10 */
		/* 82221008h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 82221008h case    0:*/		return 0x8222100C;
		  /* 8222100Ch */ case    1:  		/* addi R4, R1, 80 */
		/* 8222100Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8222100Ch case    1:*/		return 0x82221010;
		  /* 82221010h */ case    2:  		/* mr R3, R30 */
		/* 82221010h case    2:*/		regs.R3 = regs.R30;
		/* 82221010h case    2:*/		return 0x82221014;
		  /* 82221014h */ case    3:  		/* bl -1608740 */
		/* 82221014h case    3:*/		regs.LR = 0x82221018; return 0x820983F0;
		/* 82221014h case    3:*/		return 0x82221018;
		  /* 82221018h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 82221018h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82221018h case    4:*/		return 0x8222101C;
		  /* 8222101Ch */ case    5:  		/* add R6, R3, R25 */
		/* 8222101Ch case    5:*/		cpu::op::add<0>(regs,&regs.R6,regs.R3,regs.R25);
		/* 8222101Ch case    5:*/		return 0x82221020;
		  /* 82221020h */ case    6:  		/* lbz R11, <#[R11]> */
		/* 82221020h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82221020h case    6:*/		return 0x82221024;
		  /* 82221024h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82221024h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82221024h case    7:*/		return 0x82221028;
		  /* 82221028h */ case    8:  		/* bc 4, CR0_EQ, 40 */
		/* 82221028h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82221050;  }
		/* 82221028h case    8:*/		return 0x8222102C;
		  /* 8222102Ch */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 8222102Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8222102Ch case    9:*/		return 0x82221030;
		  /* 82221030h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 82221030h case   10:*/		if ( regs.CR[6].eq ) { return 0x82221050;  }
		/* 82221030h case   10:*/		return 0x82221034;
		  /* 82221034h */ case   11:  		/* subf R11, R30, R31 */
		/* 82221034h case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 82221034h case   11:*/		return 0x82221038;
		  /* 82221038h */ case   12:  		/* lis R10, -32255 */
		/* 82221038h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82221038h case   12:*/		return 0x8222103C;
		  /* 8222103Ch */ case   13:  		/* add R4, R11, R28 */
		/* 8222103Ch case   13:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R28);
		/* 8222103Ch case   13:*/		return 0x82221040;
		  /* 82221040h */ case   14:  		/* addi R5, R10, -10436 */
		/* 82221040h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFD73C);
		/* 82221040h case   14:*/		return 0x82221044;
		  /* 82221044h */ case   15:  		/* mr R3, R30 */
		/* 82221044h case   15:*/		regs.R3 = regs.R30;
		/* 82221044h case   15:*/		return 0x82221048;
		  /* 82221048h */ case   16:  		/* bl 294240 */
		/* 82221048h case   16:*/		regs.LR = 0x8222104C; return 0x82268DA8;
		/* 82221048h case   16:*/		return 0x8222104C;
		  /* 8222104Ch */ case   17:  		/* stb R27, <#[R26 - 1]> */
		/* 8222104Ch case   17:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R26 + 0xFFFFFFFF) );
		/* 8222104Ch case   17:*/		return 0x82221050;
	}
	return 0x82221050;
} // Block from 82221008h-82221050h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82221050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221050);
		  /* 82221050h */ case    0:  		/* addi R1, R1, 160 */
		/* 82221050h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82221050h case    0:*/		return 0x82221054;
		  /* 82221054h */ case    1:  		/* b -1637816 */
		/* 82221054h case    1:*/		return 0x8209129C;
		/* 82221054h case    1:*/		return 0x82221058;
	}
	return 0x82221058;
} // Block from 82221050h-82221058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221058);
		  /* 82221058h */ case    0:  		/* mfspr R12, LR */
		/* 82221058h case    0:*/		regs.R12 = regs.LR;
		/* 82221058h case    0:*/		return 0x8222105C;
		  /* 8222105Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222105Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222105Ch case    1:*/		return 0x82221060;
		  /* 82221060h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82221060h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221060h case    2:*/		return 0x82221064;
		  /* 82221064h */ case    3:  		/* stwu R1, <#[R1 - 208]> */
		/* 82221064h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82221064h case    3:*/		return 0x82221068;
		  /* 82221068h */ case    4:  		/* mr R31, R3 */
		/* 82221068h case    4:*/		regs.R31 = regs.R3;
		/* 82221068h case    4:*/		return 0x8222106C;
		  /* 8222106Ch */ case    5:  		/* mr R11, R7 */
		/* 8222106Ch case    5:*/		regs.R11 = regs.R7;
		/* 8222106Ch case    5:*/		return 0x82221070;
		  /* 82221070h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 82221070h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82221070h case    6:*/		return 0x82221074;
		  /* 82221074h */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 82221074h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8222108C;  }
		/* 82221074h case    7:*/		return 0x82221078;
		  /* 82221078h */ case    8:  		/* lwz R10, <#[R3 + 56]> */
		/* 82221078h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 82221078h case    8:*/		return 0x8222107C;
		  /* 8222107Ch */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 8222107Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222107Ch case    9:*/		return 0x82221080;
		  /* 82221080h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82221080h case   10:*/		if ( regs.CR[6].eq ) { return 0x8222108C;  }
		/* 82221080h case   10:*/		return 0x82221084;
		  /* 82221084h */ case   11:  		/* li R9, 1 */
		/* 82221084h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82221084h case   11:*/		return 0x82221088;
		  /* 82221088h */ case   12:  		/* stw R9, <#[R10 + 28]> */
		/* 82221088h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000001C) );
		/* 82221088h case   12:*/		return 0x8222108C;
	}
	return 0x8222108C;
} // Block from 82221058h-8222108Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222108Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222108C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222108C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222108C);
		  /* 8222108Ch */ case    0:  		/* rlwinm. R10, R6, 0, 24, 31 */
		/* 8222108Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R6);
		/* 8222108Ch case    0:*/		return 0x82221090;
		  /* 82221090h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82221090h case    1:*/		if ( regs.CR[0].eq ) { return 0x822210C4;  }
		/* 82221090h case    1:*/		return 0x82221094;
		  /* 82221094h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82221094h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82221094h case    2:*/		return 0x82221098;
		  /* 82221098h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 82221098h case    3:*/		if ( regs.CR[6].eq ) { return 0x822210C4;  }
		/* 82221098h case    3:*/		return 0x8222109C;
		  /* 8222109Ch */ case    4:  		/* mr R7, R8 */
		/* 8222109Ch case    4:*/		regs.R7 = regs.R8;
		/* 8222109Ch case    4:*/		return 0x822210A0;
	}
	return 0x822210A0;
} // Block from 8222108Ch-822210A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822210A0h
// Function '?CP_ReplacePS@XGRAPHICS@@YAXPAU_CP_COMPILED_PROGRAM@1@PAU_CS_COMPILED_SHADER@1@PAU_ABSTRACT_STATE@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822210A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822210A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822210A0);
		  /* 822210A0h */ case    0:  		/* mr R6, R11 */
		/* 822210A0h case    0:*/		regs.R6 = regs.R11;
		/* 822210A0h case    0:*/		return 0x822210A4;
		  /* 822210A4h */ case    1:  		/* li R5, 100 */
		/* 822210A4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 822210A4h case    1:*/		return 0x822210A8;
		  /* 822210A8h */ case    2:  		/* addi R4, R1, 80 */
		/* 822210A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822210A8h case    2:*/		return 0x822210AC;
		  /* 822210ACh */ case    3:  		/* mr R3, R31 */
		/* 822210ACh case    3:*/		regs.R3 = regs.R31;
		/* 822210ACh case    3:*/		return 0x822210B0;
		  /* 822210B0h */ case    4:  		/* bl -384 */
		/* 822210B0h case    4:*/		regs.LR = 0x822210B4; return 0x82220F30;
		/* 822210B0h case    4:*/		return 0x822210B4;
		  /* 822210B4h */ case    5:  		/* addi R5, R1, 80 */
		/* 822210B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 822210B4h case    5:*/		return 0x822210B8;
		  /* 822210B8h */ case    6:  		/* li R4, 3628 */
		/* 822210B8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xE2C);
		/* 822210B8h case    6:*/		return 0x822210BC;
		  /* 822210BCh */ case    7:  		/* mr R3, R31 */
		/* 822210BCh case    7:*/		regs.R3 = regs.R31;
		/* 822210BCh case    7:*/		return 0x822210C0;
		  /* 822210C0h */ case    8:  		/* bl -848472 */
		/* 822210C0h case    8:*/		regs.LR = 0x822210C4; return 0x82151E68;
		/* 822210C0h case    8:*/		return 0x822210C4;
	}
	return 0x822210C4;
} // Block from 822210A0h-822210C4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822210C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822210C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822210C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822210C4);
		  /* 822210C4h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 822210C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 822210C4h case    0:*/		return 0x822210C8;
		  /* 822210C8h */ case    1:  		/* li R3, 1 */
		/* 822210C8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822210C8h case    1:*/		return 0x822210CC;
		  /* 822210CCh */ case    2:  		/* rlwimi R11, R5, 14, 16, 17 */
		/* 822210CCh case    2:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R11,regs.R5);
		/* 822210CCh case    2:*/		return 0x822210D0;
		  /* 822210D0h */ case    3:  		/* stw R11, <#[R4 + 4]> */
		/* 822210D0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 822210D0h case    3:*/		return 0x822210D4;
		  /* 822210D4h */ case    4:  		/* addi R1, R1, 208 */
		/* 822210D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 822210D4h case    4:*/		return 0x822210D8;
		  /* 822210D8h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 822210D8h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822210D8h case    5:*/		return 0x822210DC;
		  /* 822210DCh */ case    6:  		/* mtspr LR, R12 */
		/* 822210DCh case    6:*/		regs.LR = regs.R12;
		/* 822210DCh case    6:*/		return 0x822210E0;
		  /* 822210E0h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 822210E0h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822210E0h case    7:*/		return 0x822210E4;
		  /* 822210E4h */ case    8:  		/* bclr 20, CR0_LT */
		/* 822210E4h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822210E4h case    8:*/		return 0x822210E8;
	}
	return 0x822210E8;
} // Block from 822210C4h-822210E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822210E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822210E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822210E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822210E8);
		  /* 822210E8h */ case    0:  		/* mfspr R12, LR */
		/* 822210E8h case    0:*/		regs.R12 = regs.LR;
		/* 822210E8h case    0:*/		return 0x822210EC;
		  /* 822210ECh */ case    1:  		/* bl -1638052 */
		/* 822210ECh case    1:*/		regs.LR = 0x822210F0; return 0x82091248;
		/* 822210ECh case    1:*/		return 0x822210F0;
		  /* 822210F0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 822210F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 822210F0h case    2:*/		return 0x822210F4;
		  /* 822210F4h */ case    3:  		/* mr R24, R10 */
		/* 822210F4h case    3:*/		regs.R24 = regs.R10;
		/* 822210F4h case    3:*/		return 0x822210F8;
		  /* 822210F8h */ case    4:  		/* lwz R10, <#[R3 + 12]> */
		/* 822210F8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 822210F8h case    4:*/		return 0x822210FC;
		  /* 822210FCh */ case    5:  		/* mulli R11, R4, 40 */
		/* 822210FCh case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x28);
		/* 822210FCh case    5:*/		return 0x82221100;
		  /* 82221100h */ case    6:  		/* add R31, R11, R10 */
		/* 82221100h case    6:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 82221100h case    6:*/		return 0x82221104;
		  /* 82221104h */ case    7:  		/* mr R25, R9 */
		/* 82221104h case    7:*/		regs.R25 = regs.R9;
		/* 82221104h case    7:*/		return 0x82221108;
		  /* 82221108h */ case    8:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82221108h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82221108h case    8:*/		return 0x8222110C;
		  /* 8222110Ch */ case    9:  		/* mr R30, R5 */
		/* 8222110Ch case    9:*/		regs.R30 = regs.R5;
		/* 8222110Ch case    9:*/		return 0x82221110;
		  /* 82221110h */ case   10:  		/* mr R28, R6 */
		/* 82221110h case   10:*/		regs.R28 = regs.R6;
		/* 82221110h case   10:*/		return 0x82221114;
		  /* 82221114h */ case   11:  		/* mr R27, R7 */
		/* 82221114h case   11:*/		regs.R27 = regs.R7;
		/* 82221114h case   11:*/		return 0x82221118;
		  /* 82221118h */ case   12:  		/* lwz R11, <#[R31 + 28]> */
		/* 82221118h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82221118h case   12:*/		return 0x8222111C;
		  /* 8222111Ch */ case   13:  		/* mr R26, R8 */
		/* 8222111Ch case   13:*/		regs.R26 = regs.R8;
		/* 8222111Ch case   13:*/		return 0x82221120;
		  /* 82221120h */ case   14:  		/* rlwinm R29, R9, 29, 18, 31 */
		/* 82221120h case   14:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R29,regs.R9);
		/* 82221120h case   14:*/		return 0x82221124;
		  /* 82221124h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 82221124h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82221124h case   15:*/		return 0x82221128;
		  /* 82221128h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 82221128h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82221130;  }
		/* 82221128h case   16:*/		return 0x8222112C;
		  /* 8222112Ch */ case   17:  		/* bl -604092 */
		/* 8222112Ch case   17:*/		regs.LR = 0x82221130; return 0x8218D970;
		/* 8222112Ch case   17:*/		return 0x82221130;
	}
	return 0x82221130;
} // Block from 822210E8h-82221130h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82221130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221130);
		  /* 82221130h */ case    0:  		/* lwz R9, <#[R31 + 28]> */
		/* 82221130h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000001C) );
		/* 82221130h case    0:*/		return 0x82221134;
		  /* 82221134h */ case    1:  		/* rlwinm R11, R30, 3, 0, 28 */
		/* 82221134h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R30);
		/* 82221134h case    1:*/		return 0x82221138;
		  /* 82221138h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 82221138h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82221138h case    2:*/		return 0x8222113C;
		  /* 8222113Ch */ case    3:  		/* mr R4, R30 */
		/* 8222113Ch case    3:*/		regs.R4 = regs.R30;
		/* 8222113Ch case    3:*/		return 0x82221140;
		  /* 82221140h */ case    4:  		/* addi R8, R30, 1 */
		/* 82221140h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x1);
		/* 82221140h case    4:*/		return 0x82221144;
		  /* 82221144h */ case    5:  		/* rlwinm. R7, R10, 0, 1, 1 */
		/* 82221144h case    5:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R7,regs.R10);
		/* 82221144h case    5:*/		return 0x82221148;
		  /* 82221148h */ case    6:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82221148h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82221148h case    6:*/		return 0x8222114C;
		  /* 8222114Ch */ case    7:  		/* li R10, 0 */
		/* 8222114Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222114Ch case    7:*/		return 0x82221150;
		  /* 82221150h */ case    8:  		/* rlwinm R5, R9, 28, 18, 31 */
		/* 82221150h case    8:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R5,regs.R9);
		/* 82221150h case    8:*/		return 0x82221154;
		  /* 82221154h */ case    9:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 82221154h case    9:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 82221154h case    9:*/		return 0x82221158;
		  /* 82221158h */ case   10:  		/* bc 12, CR0_EQ, 68 */
		/* 82221158h case   10:*/		if ( regs.CR[0].eq ) { return 0x8222119C;  }
		/* 82221158h case   10:*/		return 0x8222115C;
		  /* 8222115Ch */ case   11:  		/* li R9, 0 */
		/* 8222115Ch case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8222115Ch case   11:*/		return 0x82221160;
		  /* 82221160h */ case   12:  		/* cmplwi CR6, R29, 0 */
		/* 82221160h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82221160h case   12:*/		return 0x82221164;
		  /* 82221164h */ case   13:  		/* bc 12, CR6_EQ, 168 */
		/* 82221164h case   13:*/		if ( regs.CR[6].eq ) { return 0x8222120C;  }
		/* 82221164h case   13:*/		return 0x82221168;
		  /* 82221168h */ case   14:  		/* lwz R6, <#[R31 + 28]> */
		/* 82221168h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000001C) );
		/* 82221168h case   14:*/		return 0x8222116C;
		  /* 8222116Ch */ case   15:  		/* li R7, 0 */
		/* 8222116Ch case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8222116Ch case   15:*/		return 0x82221170;
		  /* 82221170h */ case   16:  		/* mtspr CTR, R29 */
		/* 82221170h case   16:*/		regs.CTR = regs.R29;
		/* 82221170h case   16:*/		return 0x82221174;
		  /* 82221174h */ case   17:  		/* lwzx R11, <#[R7 + R6]> */
		/* 82221174h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 82221174h case   17:*/		return 0x82221178;
		  /* 82221178h */ case   18:  		/* rlwinm R3, R11, 28, 18, 31 */
		/* 82221178h case   18:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R3,regs.R11);
		/* 82221178h case   18:*/		return 0x8222117C;
		  /* 8222117Ch */ case   19:  		/* cmplw CR6, R3, R5 */
		/* 8222117Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R5);
		/* 8222117Ch case   19:*/		return 0x82221180;
		  /* 82221180h */ case   20:  		/* bc 4, CR6_EQ, 16 */
		/* 82221180h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82221190;  }
		/* 82221180h case   20:*/		return 0x82221184;
		  /* 82221184h */ case   21:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82221184h case   21:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82221184h case   21:*/		return 0x82221188;
		  /* 82221188h */ case   22:  		/* addi R10, R10, 1 */
		/* 82221188h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82221188h case   22:*/		return 0x8222118C;
		  /* 8222118Ch */ case   23:  		/* or R9, R11, R9 */
		/* 8222118Ch case   23:*/		cpu::op::or<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8222118Ch case   23:*/		return 0x82221190;
	}
	return 0x82221190;
} // Block from 82221130h-82221190h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82221190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221190);
		  /* 82221190h */ case    0:  		/* addi R7, R7, 8 */
		/* 82221190h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x8);
		/* 82221190h case    0:*/		return 0x82221194;
		  /* 82221194h */ case    1:  		/* bc 16, CR0_LT, -32 */
		/* 82221194h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82221174;  }
		/* 82221194h case    1:*/		return 0x82221198;
		  /* 82221198h */ case    2:  		/* b 116 */
		/* 82221198h case    2:*/		return 0x8222120C;
		/* 82221198h case    2:*/		return 0x8222119C;
	}
	return 0x8222119C;
} // Block from 82221190h-8222119Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222119Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222119C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222119C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222119C);
		  /* 8222119Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8222119Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8222119Ch case    0:*/		return 0x822211A0;
		  /* 822211A0h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 822211A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x822211D0;  }
		/* 822211A0h case    1:*/		return 0x822211A4;
		  /* 822211A4h */ case    2:  		/* lwz R7, <#[R31 + 28]> */
		/* 822211A4h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000001C) );
		/* 822211A4h case    2:*/		return 0x822211A8;
	}
	return 0x822211A8;
} // Block from 8222119Ch-822211A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822211A8h
// Function '?CP_ReplaceVS@XGRAPHICS@@YAXPAU_CP_COMPILED_PROGRAM@1@PAU_CS_COMPILED_SHADER@1@PAU_ABSTRACT_STATE@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822211A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822211A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822211A8);
		  /* 822211A8h */ case    0:  		/* add R10, R11, R7 */
		/* 822211A8h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R7);
		/* 822211A8h case    0:*/		return 0x822211AC;
		  /* 822211ACh */ case    1:  		/* lwz R10, <#[R10 - 8]> */
		/* 822211ACh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 822211ACh case    1:*/		return 0x822211B0;
		  /* 822211B0h */ case    2:  		/* rlwinm R6, R10, 28, 18, 31 */
		/* 822211B0h case    2:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R6,regs.R10);
		/* 822211B0h case    2:*/		return 0x822211B4;
		  /* 822211B4h */ case    3:  		/* cmplw CR6, R6, R5 */
		/* 822211B4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 822211B4h case    3:*/		return 0x822211B8;
		  /* 822211B8h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 822211B8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822211D0;  }
		/* 822211B8h case    4:*/		return 0x822211BC;
		  /* 822211BCh */ case    5:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 822211BCh case    5:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 822211BCh case    5:*/		return 0x822211C0;
		  /* 822211C0h */ case    6:  		/* addic. R4, R4, -1 */
		/* 822211C0h case    6:*/		cpu::op::addic<1>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 822211C0h case    6:*/		return 0x822211C4;
		  /* 822211C4h */ case    7:  		/* or R9, R10, R9 */
		/* 822211C4h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 822211C4h case    7:*/		return 0x822211C8;
		  /* 822211C8h */ case    8:  		/* addi R11, R11, -8 */
		/* 822211C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 822211C8h case    8:*/		return 0x822211CC;
		  /* 822211CCh */ case    9:  		/* bc 4, CR0_EQ, -36 */
		/* 822211CCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x822211A8;  }
		/* 822211CCh case    9:*/		return 0x822211D0;
	}
	return 0x822211D0;
} // Block from 822211A8h-822211D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822211D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822211D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822211D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822211D0);
		  /* 822211D0h */ case    0:  		/* cmplw CR6, R8, R29 */
		/* 822211D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 822211D0h case    0:*/		return 0x822211D4;
		  /* 822211D4h */ case    1:  		/* bc 4, CR6_LT, 52 */
		/* 822211D4h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82221208;  }
		/* 822211D4h case    1:*/		return 0x822211D8;
		  /* 822211D8h */ case    2:  		/* lwz R7, <#[R31 + 28]> */
		/* 822211D8h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000001C) );
		/* 822211D8h case    2:*/		return 0x822211DC;
		  /* 822211DCh */ case    3:  		/* rlwinm R11, R8, 3, 0, 28 */
		/* 822211DCh case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R8);
		/* 822211DCh case    3:*/		return 0x822211E0;
		  /* 822211E0h */ case    4:  		/* lwzx R10, <#[R11 + R7]> */
		/* 822211E0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 822211E0h case    4:*/		return 0x822211E4;
		  /* 822211E4h */ case    5:  		/* rlwinm R6, R10, 28, 18, 31 */
		/* 822211E4h case    5:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R6,regs.R10);
		/* 822211E4h case    5:*/		return 0x822211E8;
		  /* 822211E8h */ case    6:  		/* cmplw CR6, R6, R5 */
		/* 822211E8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 822211E8h case    6:*/		return 0x822211EC;
		  /* 822211ECh */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 822211ECh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82221208;  }
		/* 822211ECh case    7:*/		return 0x822211F0;
		  /* 822211F0h */ case    8:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 822211F0h case    8:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 822211F0h case    8:*/		return 0x822211F4;
		  /* 822211F4h */ case    9:  		/* addi R8, R8, 1 */
		/* 822211F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 822211F4h case    9:*/		return 0x822211F8;
		  /* 822211F8h */ case   10:  		/* or R9, R10, R9 */
		/* 822211F8h case   10:*/		cpu::op::or<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 822211F8h case   10:*/		return 0x822211FC;
		  /* 822211FCh */ case   11:  		/* addi R11, R11, 8 */
		/* 822211FCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 822211FCh case   11:*/		return 0x82221200;
		  /* 82221200h */ case   12:  		/* cmplw CR6, R8, R29 */
		/* 82221200h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 82221200h case   12:*/		return 0x82221204;
		  /* 82221204h */ case   13:  		/* bc 12, CR6_LT, -36 */
		/* 82221204h case   13:*/		if ( regs.CR[6].lt ) { return 0x822211E0;  }
		/* 82221204h case   13:*/		return 0x82221208;
	}
	return 0x82221208;
} // Block from 822211D0h-82221208h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82221208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221208);
		  /* 82221208h */ case    0:  		/* subf R10, R4, R8 */
		/* 82221208h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R4,regs.R8);
		/* 82221208h case    0:*/		return 0x8222120C;
	}
	return 0x8222120C;
} // Block from 82221208h-8222120Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222120Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222120C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222120C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222120C);
		  /* 8222120Ch */ case    0:  		/* stw R5, <#[R28]> */
		/* 8222120Ch case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R28 + 0x00000000) );
		/* 8222120Ch case    0:*/		return 0x82221210;
		  /* 82221210h */ case    1:  		/* stw R9, <#[R27]> */
		/* 82221210h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 82221210h case    1:*/		return 0x82221214;
		  /* 82221214h */ case    2:  		/* stw R4, <#[R26]> */
		/* 82221214h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R26 + 0x00000000) );
		/* 82221214h case    2:*/		return 0x82221218;
		  /* 82221218h */ case    3:  		/* stw R8, <#[R25]> */
		/* 82221218h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R25 + 0x00000000) );
		/* 82221218h case    3:*/		return 0x8222121C;
		  /* 8222121Ch */ case    4:  		/* stw R10, <#[R24]> */
		/* 8222121Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 8222121Ch case    4:*/		return 0x82221220;
		  /* 82221220h */ case    5:  		/* addi R1, R1, 160 */
		/* 82221220h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82221220h case    5:*/		return 0x82221224;
		  /* 82221224h */ case    6:  		/* b -1638284 */
		/* 82221224h case    6:*/		return 0x82091298;
		/* 82221224h case    6:*/		return 0x82221228;
		  /* 82221228h */ case    7:  		/* lwz R11, <#[R4]> */
		/* 82221228h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82221228h case    7:*/		return 0x8222122C;
		  /* 8222122Ch */ case    8:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8222122Ch case    8:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8222122Ch case    8:*/		return 0x82221230;
		  /* 82221230h */ case    9:  		/* bc 12, CR0_EQ, 112 */
		/* 82221230h case    9:*/		if ( regs.CR[0].eq ) { return 0x822212A0;  }
		/* 82221230h case    9:*/		return 0x82221234;
		  /* 82221234h */ case   10:  		/* rlwinm. R11, R11, 0, 15, 28 */
		/* 82221234h case   10:*/		cpu::op::rlwinm<1,0,15,28>(regs,&regs.R11,regs.R11);
		/* 82221234h case   10:*/		return 0x82221238;
		  /* 82221238h */ case   11:  		/* li R7, 0 */
		/* 82221238h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82221238h case   11:*/		return 0x8222123C;
		  /* 8222123Ch */ case   12:  		/* bclr 12, CR0_EQ */
		/* 8222123Ch case   12:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8222123Ch case   12:*/		return 0x82221240;
	}
	return 0x82221240;
} // Block from 8222120Ch-82221240h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82221240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221240);
		  /* 82221240h */ case    0:  		/* li R10, 0 */
		/* 82221240h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221240h case    0:*/		return 0x82221244;
		  /* 82221244h */ case    1:  		/* lwz R11, <#[R4 + 28]> */
		/* 82221244h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82221244h case    1:*/		return 0x82221248;
		  /* 82221248h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82221248h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82221248h case    2:*/		return 0x8222124C;
		  /* 8222124Ch */ case    3:  		/* rlwinm R9, R11, 28, 18, 31 */
		/* 8222124Ch case    3:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R9,regs.R11);
		/* 8222124Ch case    3:*/		return 0x82221250;
		  /* 82221250h */ case    4:  		/* cmplw CR6, R9, R5 */
		/* 82221250h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 82221250h case    4:*/		return 0x82221254;
		  /* 82221254h */ case    5:  		/* bc 4, CR6_EQ, 48 */
		/* 82221254h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82221284;  }
		/* 82221254h case    5:*/		return 0x82221258;
		  /* 82221258h */ case    6:  		/* lwz R9, <#[R4 + 24]> */
		/* 82221258h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000018) );
		/* 82221258h case    6:*/		return 0x8222125C;
		  /* 8222125Ch */ case    7:  		/* rlwinm R6, R11, 0, 28, 31 */
		/* 8222125Ch case    7:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R11);
		/* 8222125Ch case    7:*/		return 0x82221260;
		  /* 82221260h */ case    8:  		/* li R3, 1 */
		/* 82221260h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82221260h case    8:*/		return 0x82221264;
		  /* 82221264h */ case    9:  		/* add R11, R9, R10 */
		/* 82221264h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 82221264h case    9:*/		return 0x82221268;
		  /* 82221268h */ case   10:  		/* cntlzw R9, R6 */
		/* 82221268h case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R6);
		/* 82221268h case   10:*/		return 0x8222126C;
		  /* 8222126Ch */ case   11:  		/* subfic R9, R9, 31 */
		/* 8222126Ch case   11:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R9,0x1F);
		/* 8222126Ch case   11:*/		return 0x82221270;
		  /* 82221270h */ case   12:  		/* lwz R6, <#[R11 + 4]> */
		/* 82221270h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82221270h case   12:*/		return 0x82221274;
		  /* 82221274h */ case   13:  		/* stw R8, <#[R11]> */
		/* 82221274h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82221274h case   13:*/		return 0x82221278;
		  /* 82221278h */ case   14:  		/* rlwimi R6, R9, 2, 16, 29 */
		/* 82221278h case   14:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R6,regs.R9);
		/* 82221278h case   14:*/		return 0x8222127C;
		  /* 8222127Ch */ case   15:  		/* rlwimi R6, R3, 0, 30, 14 */
		/* 8222127Ch case   15:*/		cpu::op::rlwimi<0,0,30,14>(regs,&regs.R6,regs.R3);
		/* 8222127Ch case   15:*/		return 0x82221280;
		  /* 82221280h */ case   16:  		/* stw R6, <#[R11 + 4]> */
		/* 82221280h case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82221280h case   16:*/		return 0x82221284;
	}
	return 0x82221284;
} // Block from 82221240h-82221284h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82221284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221284);
		  /* 82221284h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 82221284h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82221284h case    0:*/		return 0x82221288;
		  /* 82221288h */ case    1:  		/* addi R7, R7, 1 */
		/* 82221288h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82221288h case    1:*/		return 0x8222128C;
		  /* 8222128Ch */ case    2:  		/* addi R10, R10, 8 */
		/* 8222128Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 8222128Ch case    2:*/		return 0x82221290;
		  /* 82221290h */ case    3:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 82221290h case    3:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 82221290h case    3:*/		return 0x82221294;
		  /* 82221294h */ case    4:  		/* cmplw CR6, R7, R11 */
		/* 82221294h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82221294h case    4:*/		return 0x82221298;
		  /* 82221298h */ case    5:  		/* bc 12, CR6_LT, -84 */
		/* 82221298h case    5:*/		if ( regs.CR[6].lt ) { return 0x82221244;  }
		/* 82221298h case    5:*/		return 0x8222129C;
		  /* 8222129Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 8222129Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222129Ch case    6:*/		return 0x822212A0;
	}
	return 0x822212A0;
} // Block from 82221284h-822212A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822212A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822212A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822212A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822212A0);
		  /* 822212A0h */ case    0:  		/* cmplw CR6, R6, R7 */
		/* 822212A0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 822212A0h case    0:*/		return 0x822212A4;
		  /* 822212A4h */ case    1:  		/* bclr 4, CR6_LT */
		/* 822212A4h case    1:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 822212A4h case    1:*/		return 0x822212A8;
	}
	return 0x822212A8;
} // Block from 822212A0h-822212A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822212A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822212A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822212A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822212A8);
		  /* 822212A8h */ case    0:  		/* subf R11, R6, R7 */
		/* 822212A8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R7);
		/* 822212A8h case    0:*/		return 0x822212AC;
		  /* 822212ACh */ case    1:  		/* rlwinm R10, R6, 3, 0, 28 */
		/* 822212ACh case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R6);
		/* 822212ACh case    1:*/		return 0x822212B0;
	}
	return 0x822212B0;
} // Block from 822212A8h-822212B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822212B0h
// Function '?CP_UpdatePSCompilerState@XGRAPHICS@@YAXPAU_CP_COMPILED_PROGRAM@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822212B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822212B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822212B0);
		  /* 822212B0h */ case    0:  		/* li R9, 0 */
		/* 822212B0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822212B0h case    0:*/		return 0x822212B4;
		  /* 822212B4h */ case    1:  		/* mtspr CTR, R11 */
		/* 822212B4h case    1:*/		regs.CTR = regs.R11;
		/* 822212B4h case    1:*/		return 0x822212B8;
		  /* 822212B8h */ case    2:  		/* lwz R11, <#[R4 + 24]> */
		/* 822212B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 822212B8h case    2:*/		return 0x822212BC;
		  /* 822212BCh */ case    3:  		/* li R7, 1 */
		/* 822212BCh case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 822212BCh case    3:*/		return 0x822212C0;
		  /* 822212C0h */ case    4:  		/* add R11, R10, R11 */
		/* 822212C0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822212C0h case    4:*/		return 0x822212C4;
		  /* 822212C4h */ case    5:  		/* addi R10, R10, 8 */
		/* 822212C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 822212C4h case    5:*/		return 0x822212C8;
		  /* 822212C8h */ case    6:  		/* lwz R6, <#[R11 + 4]> */
		/* 822212C8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 822212C8h case    6:*/		return 0x822212CC;
		  /* 822212CCh */ case    7:  		/* stw R8, <#[R11]> */
		/* 822212CCh case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 822212CCh case    7:*/		return 0x822212D0;
		  /* 822212D0h */ case    8:  		/* rlwimi R6, R9, 0, 16, 29 */
		/* 822212D0h case    8:*/		cpu::op::rlwimi<0,0,16,29>(regs,&regs.R6,regs.R9);
		/* 822212D0h case    8:*/		return 0x822212D4;
		  /* 822212D4h */ case    9:  		/* addi R9, R9, 4 */
		/* 822212D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 822212D4h case    9:*/		return 0x822212D8;
		  /* 822212D8h */ case   10:  		/* rlwimi R6, R7, 0, 30, 14 */
		/* 822212D8h case   10:*/		cpu::op::rlwimi<0,0,30,14>(regs,&regs.R6,regs.R7);
		/* 822212D8h case   10:*/		return 0x822212DC;
		  /* 822212DCh */ case   11:  		/* stw R6, <#[R11 + 4]> */
		/* 822212DCh case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 822212DCh case   11:*/		return 0x822212E0;
		  /* 822212E0h */ case   12:  		/* bc 16, CR0_LT, -40 */
		/* 822212E0h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822212B8;  }
		/* 822212E0h case   12:*/		return 0x822212E4;
		  /* 822212E4h */ case   13:  		/* bclr 20, CR0_LT */
		/* 822212E4h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822212E4h case   13:*/		return 0x822212E8;
	}
	return 0x822212E8;
} // Block from 822212B0h-822212E8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822212E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822212E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822212E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822212E8);
		  /* 822212E8h */ case    0:  		/* mfspr R12, LR */
		/* 822212E8h case    0:*/		regs.R12 = regs.LR;
		/* 822212E8h case    0:*/		return 0x822212EC;
		  /* 822212ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822212ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822212ECh case    1:*/		return 0x822212F0;
		  /* 822212F0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822212F0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822212F0h case    2:*/		return 0x822212F4;
		  /* 822212F4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822212F4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822212F4h case    3:*/		return 0x822212F8;
		  /* 822212F8h */ case    4:  		/* stwu R1, <#[R1 - 208]> */
		/* 822212F8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 822212F8h case    4:*/		return 0x822212FC;
		  /* 822212FCh */ case    5:  		/* std R4, <#[R1 + 240]> */
		/* 822212FCh case    5:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x000000F0) );
		/* 822212FCh case    5:*/		return 0x82221300;
		  /* 82221300h */ case    6:  		/* mr R31, R3 */
		/* 82221300h case    6:*/		regs.R31 = regs.R3;
		/* 82221300h case    6:*/		return 0x82221304;
		  /* 82221304h */ case    7:  		/* std R5, <#[R1 + 248]> */
		/* 82221304h case    7:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x000000F8) );
		/* 82221304h case    7:*/		return 0x82221308;
		  /* 82221308h */ case    8:  		/* li R9, 0 */
		/* 82221308h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82221308h case    8:*/		return 0x8222130C;
		  /* 8222130Ch */ case    9:  		/* lwz R5, <#[R3 + 536]> */
		/* 8222130Ch case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000218) );
		/* 8222130Ch case    9:*/		return 0x82221310;
		  /* 82221310h */ case   10:  		/* cmplwi CR6, R5, 0 */
		/* 82221310h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82221310h case   10:*/		return 0x82221314;
		  /* 82221314h */ case   11:  		/* bc 12, CR6_EQ, 60 */
		/* 82221314h case   11:*/		if ( regs.CR[6].eq ) { return 0x82221350;  }
		/* 82221314h case   11:*/		return 0x82221318;
		  /* 82221318h */ case   12:  		/* lwz R3, <#[R1 + 244]> */
		/* 82221318h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000F4) );
		/* 82221318h case   12:*/		return 0x8222131C;
		  /* 8222131Ch */ case   13:  		/* addi R11, R31, 348 */
		/* 8222131Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x15C);
		/* 8222131Ch case   13:*/		return 0x82221320;
		  /* 82221320h */ case   14:  		/* rlwinm R4, R3, 0, 27, 31 */
		/* 82221320h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R3);
		/* 82221320h case   14:*/		return 0x82221324;
		  /* 82221324h */ case   15:  		/* lwz R10, <#[R11]> */
		/* 82221324h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82221324h case   15:*/		return 0x82221328;
		  /* 82221328h */ case   16:  		/* rlwinm R30, R10, 0, 27, 31 */
		/* 82221328h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R10);
		/* 82221328h case   16:*/		return 0x8222132C;
		  /* 8222132Ch */ case   17:  		/* cmplw CR6, R30, R4 */
		/* 8222132Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 8222132Ch case   17:*/		return 0x82221330;
		  /* 82221330h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 82221330h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82221340;  }
		/* 82221330h case   18:*/		return 0x82221334;
		  /* 82221334h */ case   19:  		/* xor R10, R10, R3 */
		/* 82221334h case   19:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82221334h case   19:*/		return 0x82221338;
	}
	return 0x82221338;
} // Block from 822212E8h-82221338h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82221338h
// Function '?CP_UpdateVSCompilerState@XGRAPHICS@@YAXPAU_CP_COMPILED_PROGRAM@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221338);
		  /* 82221338h */ case    0:  		/* rlwinm. R10, R10, 0, 23, 26 */
		/* 82221338h case    0:*/		cpu::op::rlwinm<1,0,23,26>(regs,&regs.R10,regs.R10);
		/* 82221338h case    0:*/		return 0x8222133C;
		  /* 8222133Ch */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8222133Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8222136C;  }
		/* 8222133Ch case    1:*/		return 0x82221340;
	}
	return 0x82221340;
} // Block from 82221338h-82221340h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221340);
		  /* 82221340h */ case    0:  		/* addi R9, R9, 1 */
		/* 82221340h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82221340h case    0:*/		return 0x82221344;
		  /* 82221344h */ case    1:  		/* addi R11, R11, 12 */
		/* 82221344h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82221344h case    1:*/		return 0x82221348;
		  /* 82221348h */ case    2:  		/* cmplw CR6, R9, R5 */
		/* 82221348h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 82221348h case    2:*/		return 0x8222134C;
		  /* 8222134Ch */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 8222134Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82221324;  }
		/* 8222134Ch case    3:*/		return 0x82221350;
	}
	return 0x82221350;
} // Block from 82221340h-82221350h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221350);
		  /* 82221350h */ case    0:  		/* li R3, 0 */
		/* 82221350h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82221350h case    0:*/		return 0x82221354;
		  /* 82221354h */ case    1:  		/* addi R1, R1, 208 */
		/* 82221354h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82221354h case    1:*/		return 0x82221358;
		  /* 82221358h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82221358h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82221358h case    2:*/		return 0x8222135C;
		  /* 8222135Ch */ case    3:  		/* mtspr LR, R12 */
		/* 8222135Ch case    3:*/		regs.LR = regs.R12;
		/* 8222135Ch case    3:*/		return 0x82221360;
		  /* 82221360h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82221360h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82221360h case    4:*/		return 0x82221364;
		  /* 82221364h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82221364h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221364h case    5:*/		return 0x82221368;
		  /* 82221368h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82221368h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221368h case    6:*/		return 0x8222136C;
	}
	return 0x8222136C;
} // Block from 82221350h-8222136Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222136Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222136C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222136C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222136C);
		  /* 8222136Ch */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8222136Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8222136Ch case    0:*/		return 0x82221370;
		  /* 82221370h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 82221370h case    1:*/		if ( regs.CR[6].eq ) { return 0x822213A8;  }
		/* 82221370h case    1:*/		return 0x82221374;
		  /* 82221374h */ case    2:  		/* lwz R11, <#[R7 + 28]> */
		/* 82221374h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000001C) );
		/* 82221374h case    2:*/		return 0x82221378;
		  /* 82221378h */ case    3:  		/* rlwinm R10, R8, 3, 0, 28 */
		/* 82221378h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R8);
		/* 82221378h case    3:*/		return 0x8222137C;
		  /* 8222137Ch */ case    4:  		/* li R5, 100 */
		/* 8222137Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 8222137Ch case    4:*/		return 0x82221380;
		  /* 82221380h */ case    5:  		/* lwz R6, <#[R6 + 8]> */
		/* 82221380h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000008) );
		/* 82221380h case    5:*/		return 0x82221384;
		  /* 82221384h */ case    6:  		/* addi R4, R1, 80 */
		/* 82221384h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82221384h case    6:*/		return 0x82221388;
		  /* 82221388h */ case    7:  		/* mr R3, R31 */
		/* 82221388h case    7:*/		regs.R3 = regs.R31;
		/* 82221388h case    7:*/		return 0x8222138C;
		  /* 8222138Ch */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8222138Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8222138Ch case    8:*/		return 0x82221390;
		  /* 82221390h */ case    9:  		/* rlwinm R7, R11, 5, 28, 31 */
		/* 82221390h case    9:*/		cpu::op::rlwinm<0,5,28,31>(regs,&regs.R7,regs.R11);
		/* 82221390h case    9:*/		return 0x82221394;
		  /* 82221394h */ case   10:  		/* bl -1124 */
		/* 82221394h case   10:*/		regs.LR = 0x82221398; return 0x82220F30;
		/* 82221394h case   10:*/		return 0x82221398;
		  /* 82221398h */ case   11:  		/* addi R5, R1, 80 */
		/* 82221398h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82221398h case   11:*/		return 0x8222139C;
		  /* 8222139Ch */ case   12:  		/* li R4, 3513 */
		/* 8222139Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0xDB9);
		/* 8222139Ch case   12:*/		return 0x822213A0;
		  /* 822213A0h */ case   13:  		/* mr R3, R31 */
		/* 822213A0h case   13:*/		regs.R3 = regs.R31;
		/* 822213A0h case   13:*/		return 0x822213A4;
		  /* 822213A4h */ case   14:  		/* bl -849212 */
		/* 822213A4h case   14:*/		regs.LR = 0x822213A8; return 0x82151E68;
		/* 822213A4h case   14:*/		return 0x822213A8;
	}
	return 0x822213A8;
} // Block from 8222136Ch-822213A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822213A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822213A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822213A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822213A8);
		  /* 822213A8h */ case    0:  		/* li R3, 1 */
		/* 822213A8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822213A8h case    0:*/		return 0x822213AC;
		  /* 822213ACh */ case    1:  		/* b -88 */
		/* 822213ACh case    1:*/		return 0x82221354;
		/* 822213ACh case    1:*/		return 0x822213B0;
	}
	return 0x822213B0;
} // Block from 822213A8h-822213B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822213B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822213B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822213B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822213B0);
		  /* 822213B0h */ case    0:  		/* mfspr R12, LR */
		/* 822213B0h case    0:*/		regs.R12 = regs.LR;
		/* 822213B0h case    0:*/		return 0x822213B4;
		  /* 822213B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822213B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822213B4h case    1:*/		return 0x822213B8;
		  /* 822213B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822213B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822213B8h case    2:*/		return 0x822213BC;
		  /* 822213BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822213BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822213BCh case    3:*/		return 0x822213C0;
	}
	return 0x822213C0;
} // Block from 822213B0h-822213C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822213C0h
// Function '?ComputesScalarResult@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822213C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822213C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822213C0);
		  /* 822213C0h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 822213C0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822213C0h case    0:*/		return 0x822213C4;
		  /* 822213C4h */ case    1:  		/* mr R30, R4 */
		/* 822213C4h case    1:*/		regs.R30 = regs.R4;
		/* 822213C4h case    1:*/		return 0x822213C8;
		  /* 822213C8h */ case    2:  		/* li R5, 44 */
		/* 822213C8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x2C);
		/* 822213C8h case    2:*/		return 0x822213CC;
		  /* 822213CCh */ case    3:  		/* li R4, 0 */
		/* 822213CCh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822213CCh case    3:*/		return 0x822213D0;
		  /* 822213D0h */ case    4:  		/* mr R31, R3 */
		/* 822213D0h case    4:*/		regs.R31 = regs.R3;
		/* 822213D0h case    4:*/		return 0x822213D4;
		  /* 822213D4h */ case    5:  		/* bl -1638548 */
		/* 822213D4h case    5:*/		regs.LR = 0x822213D8; return 0x82091340;
		/* 822213D4h case    5:*/		return 0x822213D8;
		  /* 822213D8h */ case    6:  		/* lwz R10, <#[R31 + 8]> */
		/* 822213D8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822213D8h case    6:*/		return 0x822213DC;
		  /* 822213DCh */ case    7:  		/* lis R11, 64 */
		/* 822213DCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x40);
		/* 822213DCh case    7:*/		return 0x822213E0;
		  /* 822213E0h */ case    8:  		/* rlwinm R10, R10, 0, 25, 17 */
		/* 822213E0h case    8:*/		cpu::op::rlwinm<0,0,25,17>(regs,&regs.R10,regs.R10);
		/* 822213E0h case    8:*/		return 0x822213E4;
		  /* 822213E4h */ case    9:  		/* rlwimi R11, R30, 7, 18, 24 */
		/* 822213E4h case    9:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R11,regs.R30);
		/* 822213E4h case    9:*/		return 0x822213E8;
		  /* 822213E8h */ case   10:  		/* mr R3, R31 */
		/* 822213E8h case   10:*/		regs.R3 = regs.R31;
		/* 822213E8h case   10:*/		return 0x822213EC;
		  /* 822213ECh */ case   11:  		/* or R11, R11, R10 */
		/* 822213ECh case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822213ECh case   11:*/		return 0x822213F0;
		  /* 822213F0h */ case   12:  		/* stw R11, <#[R31 + 8]> */
		/* 822213F0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822213F0h case   12:*/		return 0x822213F4;
		  /* 822213F4h */ case   13:  		/* addi R1, R1, 112 */
		/* 822213F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822213F4h case   13:*/		return 0x822213F8;
		  /* 822213F8h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 822213F8h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822213F8h case   14:*/		return 0x822213FC;
		  /* 822213FCh */ case   15:  		/* mtspr LR, R12 */
		/* 822213FCh case   15:*/		regs.LR = regs.R12;
		/* 822213FCh case   15:*/		return 0x82221400;
		  /* 82221400h */ case   16:  		/* ld R30, <#[R1 - 24]> */
		/* 82221400h case   16:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82221400h case   16:*/		return 0x82221404;
		  /* 82221404h */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 82221404h case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221404h case   17:*/		return 0x82221408;
		  /* 82221408h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82221408h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221408h case   18:*/		return 0x8222140C;
	}
	return 0x8222140C;
} // Block from 822213C0h-8222140Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8222140Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222140C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222140C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222140C);
		  /* 8222140Ch */ case    0:  		/* nop */
		/* 8222140Ch case    0:*/		cpu::op::nop();
		/* 8222140Ch case    0:*/		return 0x82221410;
	}
	return 0x82221410;
} // Block from 8222140Ch-82221410h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221410h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221410);
		  /* 82221410h */ case    0:  		/* mfspr R12, LR */
		/* 82221410h case    0:*/		regs.R12 = regs.LR;
		/* 82221410h case    0:*/		return 0x82221414;
		  /* 82221414h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82221414h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82221414h case    1:*/		return 0x82221418;
	}
	return 0x82221418;
} // Block from 82221410h-82221418h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221418h
// Function '?XenosSaturate@D3DXShader@@YAMM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221418);
		  /* 82221418h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 82221418h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221418h case    0:*/		return 0x8222141C;
		  /* 8222141Ch */ case    1:  		/* stwu R1, <#[R1 - 112]> */
		/* 8222141Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8222141Ch case    1:*/		return 0x82221420;
		  /* 82221420h */ case    2:  		/* mr R31, R4 */
		/* 82221420h case    2:*/		regs.R31 = regs.R4;
		/* 82221420h case    2:*/		return 0x82221424;
		  /* 82221424h */ case    3:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 82221424h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 82221424h case    3:*/		return 0x82221428;
		  /* 82221428h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82221428h case    4:*/		if ( regs.CR[0].eq ) { return 0x82221430;  }
		/* 82221428h case    4:*/		return 0x8222142C;
		  /* 8222142Ch */ case    5:  		/* bl -2604 */
		/* 8222142Ch case    5:*/		regs.LR = 0x82221430; return 0x82220A00;
		/* 8222142Ch case    5:*/		return 0x82221430;
	}
	return 0x82221430;
} // Block from 82221418h-82221430h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221430);
		  /* 82221430h */ case    0:  		/* rlwinm. R11, R31, 0, 30, 30 */
		/* 82221430h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R31);
		/* 82221430h case    0:*/		return 0x82221434;
		  /* 82221434h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82221434h case    1:*/		if ( regs.CR[0].eq ) { return 0x82221448;  }
		/* 82221434h case    1:*/		return 0x82221438;
		  /* 82221438h */ case    2:  		/* lis R11, -32256 */
		/* 82221438h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82221438h case    2:*/		return 0x8222143C;
		  /* 8222143Ch */ case    3:  		/* lfd FR2, <#[R11 + 1808]> */
		/* 8222143Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000710) );
		/* 8222143Ch case    3:*/		return 0x82221440;
		  /* 82221440h */ case    4:  		/* bl -1610968 */
		/* 82221440h case    4:*/		regs.LR = 0x82221444; return 0x82097F68;
		/* 82221440h case    4:*/		return 0x82221444;
		  /* 82221444h */ case    5:  		/* frsp FR1, FR1 */
		/* 82221444h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR1);
		/* 82221444h case    5:*/		return 0x82221448;
	}
	return 0x82221448;
} // Block from 82221430h-82221448h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221448);
		  /* 82221448h */ case    0:  		/* rlwinm. R11, R31, 0, 29, 29 */
		/* 82221448h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R31);
		/* 82221448h case    0:*/		return 0x8222144C;
		  /* 8222144Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8222144Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82221464;  }
		/* 8222144Ch case    1:*/		return 0x82221450;
		  /* 82221450h */ case    2:  		/* stfs FR1, <#[R1 + 80]> */
		/* 82221450h case    2:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000050) );
		/* 82221450h case    2:*/		return 0x82221454;
		  /* 82221454h */ case    3:  		/* lwz R11, <#[R1 + 80]> */
		/* 82221454h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82221454h case    3:*/		return 0x82221458;
		  /* 82221458h */ case    4:  		/* xoris R11, R11, 32768 */
		/* 82221458h case    4:*/		cpu::op::xoris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82221458h case    4:*/		return 0x8222145C;
		  /* 8222145Ch */ case    5:  		/* stw R11, <#[R1 + 132]> */
		/* 8222145Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 8222145Ch case    5:*/		return 0x82221460;
		  /* 82221460h */ case    6:  		/* lfs FR1, <#[R1 + 132]> */
		/* 82221460h case    6:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000084) );
		/* 82221460h case    6:*/		return 0x82221464;
	}
	return 0x82221464;
} // Block from 82221448h-82221464h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82221464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221464);
		  /* 82221464h */ case    0:  		/* addi R1, R1, 112 */
		/* 82221464h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82221464h case    0:*/		return 0x82221468;
		  /* 82221468h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82221468h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82221468h case    1:*/		return 0x8222146C;
		  /* 8222146Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8222146Ch case    2:*/		regs.LR = regs.R12;
		/* 8222146Ch case    2:*/		return 0x82221470;
		  /* 82221470h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82221470h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221470h case    3:*/		return 0x82221474;
		  /* 82221474h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82221474h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221474h case    4:*/		return 0x82221478;
	}
	return 0x82221478;
} // Block from 82221464h-82221478h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82221478h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221478);
		  /* 82221478h */ case    0:  		/* mfspr R12, LR */
		/* 82221478h case    0:*/		regs.R12 = regs.LR;
		/* 82221478h case    0:*/		return 0x8222147C;
		  /* 8222147Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222147Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222147Ch case    1:*/		return 0x82221480;
		  /* 82221480h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82221480h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82221480h case    2:*/		return 0x82221484;
		  /* 82221484h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82221484h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221484h case    3:*/		return 0x82221488;
		  /* 82221488h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82221488h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82221488h case    4:*/		return 0x8222148C;
		  /* 8222148Ch */ case    5:  		/* mr R30, R4 */
		/* 8222148Ch case    5:*/		regs.R30 = regs.R4;
		/* 8222148Ch case    5:*/		return 0x82221490;
		  /* 82221490h */ case    6:  		/* mr R31, R5 */
		/* 82221490h case    6:*/		regs.R31 = regs.R5;
		/* 82221490h case    6:*/		return 0x82221494;
		  /* 82221494h */ case    7:  		/* rlwinm. R11, R5, 0, 31, 31 */
		/* 82221494h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R5);
		/* 82221494h case    7:*/		return 0x82221498;
		  /* 82221498h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82221498h case    8:*/		if ( regs.CR[0].eq ) { return 0x822214A4;  }
		/* 82221498h case    8:*/		return 0x8222149C;
		  /* 8222149Ch */ case    9:  		/* frsp FR1, FR1 */
		/* 8222149Ch case    9:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR1);
		/* 8222149Ch case    9:*/		return 0x822214A0;
		  /* 822214A0h */ case   10:  		/* bl -2720 */
		/* 822214A0h case   10:*/		regs.LR = 0x822214A4; return 0x82220A00;
		/* 822214A0h case   10:*/		return 0x822214A4;
	}
	return 0x822214A4;
} // Block from 82221478h-822214A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822214A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822214A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822214A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822214A4);
		  /* 822214A4h */ case    0:  		/* rlwinm. R11, R31, 0, 30, 30 */
		/* 822214A4h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R31);
		/* 822214A4h case    0:*/		return 0x822214A8;
		  /* 822214A8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822214A8h case    1:*/		if ( regs.CR[0].eq ) { return 0x822214B8;  }
		/* 822214A8h case    1:*/		return 0x822214AC;
		  /* 822214ACh */ case    2:  		/* lis R11, -32256 */
		/* 822214ACh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822214ACh case    2:*/		return 0x822214B0;
		  /* 822214B0h */ case    3:  		/* lfd FR2, <#[R11 + 1808]> */
		/* 822214B0h case    3:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000710) );
		/* 822214B0h case    3:*/		return 0x822214B4;
		  /* 822214B4h */ case    4:  		/* bl -1611084 */
		/* 822214B4h case    4:*/		regs.LR = 0x822214B8; return 0x82097F68;
		/* 822214B4h case    4:*/		return 0x822214B8;
	}
	return 0x822214B8;
} // Block from 822214A4h-822214B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822214B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822214B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822214B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822214B8);
		  /* 822214B8h */ case    0:  		/* rlwinm. R11, R31, 0, 29, 29 */
		/* 822214B8h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R31);
		/* 822214B8h case    0:*/		return 0x822214BC;
		  /* 822214BCh */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 822214BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x822214DC;  }
		/* 822214BCh case    1:*/		return 0x822214C0;
		  /* 822214C0h */ case    2:  		/* cmpwi CR6, R30, 2 */
		/* 822214C0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000002);
		/* 822214C0h case    2:*/		return 0x822214C4;
		  /* 822214C4h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 822214C4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822214D8;  }
		/* 822214C4h case    3:*/		return 0x822214C8;
		  /* 822214C8h */ case    4:  		/* lis R11, -32252 */
		/* 822214C8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822214C8h case    4:*/		return 0x822214CC;
		  /* 822214CCh */ case    5:  		/* lfd FR0, <#[R11 - 336]> */
		/* 822214CCh case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFEB0) );
		/* 822214CCh case    5:*/		return 0x822214D0;
		  /* 822214D0h */ case    6:  		/* fsub FR1, FR0, FR1 */
		/* 822214D0h case    6:*/		cpu::op::fsub<0>(regs,&regs.FR1,regs.FR0,regs.FR1);
		/* 822214D0h case    6:*/		return 0x822214D4;
		  /* 822214D4h */ case    7:  		/* b 8 */
		/* 822214D4h case    7:*/		return 0x822214DC;
		/* 822214D4h case    7:*/		return 0x822214D8;
	}
	return 0x822214D8;
} // Block from 822214B8h-822214D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822214D8h
// Function '?Xenos2ToX@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822214D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822214D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822214D8);
		  /* 822214D8h */ case    0:  		/* bl -1611064 */
		/* 822214D8h case    0:*/		regs.LR = 0x822214DC; return 0x82097FA0;
		/* 822214D8h case    0:*/		return 0x822214DC;
	}
	return 0x822214DC;
} // Block from 822214D8h-822214DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822214DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822214DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822214DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822214DC);
		  /* 822214DCh */ case    0:  		/* addi R1, R1, 112 */
		/* 822214DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822214DCh case    0:*/		return 0x822214E0;
		  /* 822214E0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822214E0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822214E0h case    1:*/		return 0x822214E4;
		  /* 822214E4h */ case    2:  		/* mtspr LR, R12 */
		/* 822214E4h case    2:*/		regs.LR = regs.R12;
		/* 822214E4h case    2:*/		return 0x822214E8;
		  /* 822214E8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 822214E8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822214E8h case    3:*/		return 0x822214EC;
		  /* 822214ECh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 822214ECh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822214ECh case    4:*/		return 0x822214F0;
		  /* 822214F0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822214F0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822214F0h case    5:*/		return 0x822214F4;
	}
	return 0x822214F4;
} // Block from 822214DCh-822214F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822214F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822214F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822214F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822214F4);
		  /* 822214F4h */ case    0:  		/* nop */
		/* 822214F4h case    0:*/		cpu::op::nop();
		/* 822214F4h case    0:*/		return 0x822214F8;
	}
	return 0x822214F8;
} // Block from 822214F4h-822214F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822214F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822214F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822214F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822214F8);
		  /* 822214F8h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 822214F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 822214F8h case    0:*/		return 0x822214FC;
		  /* 822214FCh */ case    1:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 822214FCh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 822214FCh case    1:*/		return 0x82221500;
		  /* 82221500h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82221500h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82221500h case    2:*/		return 0x82221504;
		  /* 82221504h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82221504h case    3:*/		if ( regs.CR[6].lt ) { return 0x82221514;  }
		/* 82221504h case    3:*/		return 0x82221508;
		  /* 82221508h */ case    4:  		/* cmplwi CR6, R11, 102 */
		/* 82221508h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82221508h case    4:*/		return 0x8222150C;
		  /* 8222150Ch */ case    5:  		/* li R11, 1 */
		/* 8222150Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222150Ch case    5:*/		return 0x82221510;
		  /* 82221510h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82221510h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82221518;  }
		/* 82221510h case    6:*/		return 0x82221514;
	}
	return 0x82221514;
} // Block from 822214F8h-82221514h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82221514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221514);
		  /* 82221514h */ case    0:  		/* li R11, 0 */
		/* 82221514h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221514h case    0:*/		return 0x82221518;
	}
	return 0x82221518;
} // Block from 82221514h-82221518h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221518);
		  /* 82221518h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82221518h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82221518h case    0:*/		return 0x8222151C;
		  /* 8222151Ch */ case    1:  		/* bc 4, CR0_EQ, 76 */
		/* 8222151Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82221568;  }
		/* 8222151Ch case    1:*/		return 0x82221520;
		  /* 82221520h */ case    2:  		/* rlwinm. R11, R7, 0, 0, 30 */
		/* 82221520h case    2:*/		cpu::op::rlwinm<1,0,0,30>(regs,&regs.R11,regs.R7);
		/* 82221520h case    2:*/		return 0x82221524;
		  /* 82221524h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82221524h case    3:*/		if ( regs.CR[0].eq ) { return 0x82221530;  }
		/* 82221524h case    3:*/		return 0x82221528;
		  /* 82221528h */ case    4:  		/* li R3, 0 */
		/* 82221528h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82221528h case    4:*/		return 0x8222152C;
		  /* 8222152Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8222152Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222152Ch case    5:*/		return 0x82221530;
	}
	return 0x82221530;
} // Block from 82221518h-82221530h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221530);
		  /* 82221530h */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 82221530h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 82221530h case    0:*/		return 0x82221534;
		  /* 82221534h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82221534h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82221534h case    1:*/		return 0x82221538;
		  /* 82221538h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 82221538h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82221538h case    2:*/		return 0x8222153C;
		  /* 8222153Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8222153Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8222154C;  }
		/* 8222153Ch case    3:*/		return 0x82221540;
		  /* 82221540h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 82221540h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82221540h case    4:*/		return 0x82221544;
		  /* 82221544h */ case    5:  		/* li R11, 0 */
		/* 82221544h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221544h case    5:*/		return 0x82221548;
		  /* 82221548h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82221548h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82221550;  }
		/* 82221548h case    6:*/		return 0x8222154C;
	}
	return 0x8222154C;
} // Block from 82221530h-8222154Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222154Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222154C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222154C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222154C);
		  /* 8222154Ch */ case    0:  		/* li R11, 1 */
		/* 8222154Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222154Ch case    0:*/		return 0x82221550;
	}
	return 0x82221550;
} // Block from 8222154Ch-82221550h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221550);
		  /* 82221550h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82221550h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82221550h case    0:*/		return 0x82221554;
		  /* 82221554h */ case    1:  		/* bc 4, CR0_EQ, -44 */
		/* 82221554h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82221528;  }
		/* 82221554h case    1:*/		return 0x82221558;
		  /* 82221558h */ case    2:  		/* lwz R11, <#[R4 + 12]> */
		/* 82221558h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82221558h case    2:*/		return 0x8222155C;
		  /* 8222155Ch */ case    3:  		/* addi R11, R11, 4 */
		/* 8222155Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8222155Ch case    3:*/		return 0x82221560;
	}
	return 0x82221560;
} // Block from 82221550h-82221560h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221560h
// Function '?XenosLog2@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221560);
		  /* 82221560h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82221560h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82221560h case    0:*/		return 0x82221564;
		  /* 82221564h */ case    1:  		/* b 236 */
		/* 82221564h case    1:*/		return 0x82221650;
		/* 82221564h case    1:*/		return 0x82221568;
	}
	return 0x82221568;
} // Block from 82221560h-82221568h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221568);
		  /* 82221568h */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 82221568h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 82221568h case    0:*/		return 0x8222156C;
		  /* 8222156Ch */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8222156Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8222156Ch case    1:*/		return 0x82221570;
		  /* 82221570h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 82221570h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82221570h case    2:*/		return 0x82221574;
		  /* 82221574h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82221574h case    3:*/		if ( regs.CR[6].eq ) { return 0x82221584;  }
		/* 82221574h case    3:*/		return 0x82221578;
		  /* 82221578h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 82221578h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82221578h case    4:*/		return 0x8222157C;
		  /* 8222157Ch */ case    5:  		/* li R11, 0 */
		/* 8222157Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222157Ch case    5:*/		return 0x82221580;
		  /* 82221580h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82221580h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82221588;  }
		/* 82221580h case    6:*/		return 0x82221584;
	}
	return 0x82221584;
} // Block from 82221568h-82221584h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82221584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221584);
		  /* 82221584h */ case    0:  		/* li R11, 1 */
		/* 82221584h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82221584h case    0:*/		return 0x82221588;
	}
	return 0x82221588;
} // Block from 82221584h-82221588h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221588);
		  /* 82221588h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82221588h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82221588h case    0:*/		return 0x8222158C;
		  /* 8222158Ch */ case    1:  		/* bc 12, CR0_EQ, 180 */
		/* 8222158Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82221640;  }
		/* 8222158Ch case    1:*/		return 0x82221590;
		  /* 82221590h */ case    2:  		/* rlwinm R11, R10, 0, 10, 12 */
		/* 82221590h case    2:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R10);
		/* 82221590h case    2:*/		return 0x82221594;
		  /* 82221594h */ case    3:  		/* lis R10, 16 */
		/* 82221594h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 82221594h case    3:*/		return 0x82221598;
		  /* 82221598h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 82221598h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82221598h case    4:*/		return 0x8222159C;
		  /* 8222159Ch */ case    5:  		/* bc 4, CR6_GT, -68 */
		/* 8222159Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82221558;  }
		/* 8222159Ch case    5:*/		return 0x822215A0;
		  /* 822215A0h */ case    6:  		/* lwz R8, <#[R3 + 44]> */
		/* 822215A0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000002C) );
		/* 822215A0h case    6:*/		return 0x822215A4;
		  /* 822215A4h */ case    7:  		/* lwz R9, <#[R3 + 48]> */
		/* 822215A4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000030) );
		/* 822215A4h case    7:*/		return 0x822215A8;
		  /* 822215A8h */ case    8:  		/* lwz R11, <#[R8 + 12]> */
		/* 822215A8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 822215A8h case    8:*/		return 0x822215AC;
		  /* 822215ACh */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 822215ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822215ACh case    9:*/		return 0x822215B0;
		  /* 822215B0h */ case   10:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 822215B0h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 822215B0h case   10:*/		return 0x822215B4;
		  /* 822215B4h */ case   11:  		/* cmplwi CR6, R11, 125 */
		/* 822215B4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 822215B4h case   11:*/		return 0x822215B8;
		  /* 822215B8h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 822215B8h case   12:*/		if ( regs.CR[6].eq ) { return 0x822215C8;  }
		/* 822215B8h case   12:*/		return 0x822215BC;
		  /* 822215BCh */ case   13:  		/* cmplwi CR6, R11, 124 */
		/* 822215BCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 822215BCh case   13:*/		return 0x822215C0;
		  /* 822215C0h */ case   14:  		/* li R11, 0 */
		/* 822215C0h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822215C0h case   14:*/		return 0x822215C4;
		  /* 822215C4h */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 822215C4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x822215CC;  }
		/* 822215C4h case   15:*/		return 0x822215C8;
	}
	return 0x822215C8;
} // Block from 82221588h-822215C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822215C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822215C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822215C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822215C8);
		  /* 822215C8h */ case    0:  		/* li R11, 1 */
		/* 822215C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822215C8h case    0:*/		return 0x822215CC;
	}
	return 0x822215CC;
} // Block from 822215C8h-822215CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822215CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822215CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822215CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822215CC);
		  /* 822215CCh */ case    0:  		/* lwz R3, <#[R9 + 12]> */
		/* 822215CCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x0000000C) );
		/* 822215CCh case    0:*/		return 0x822215D0;
		  /* 822215D0h */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 822215D0h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 822215D0h case    1:*/		return 0x822215D4;
		  /* 822215D4h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 822215D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822215D4h case    2:*/		return 0x822215D8;
		  /* 822215D8h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 822215D8h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 822215D8h case    3:*/		return 0x822215DC;
		  /* 822215DCh */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 822215DCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 822215DCh case    4:*/		return 0x822215E0;
		  /* 822215E0h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 822215E0h case    5:*/		if ( regs.CR[6].eq ) { return 0x822215F0;  }
		/* 822215E0h case    5:*/		return 0x822215E4;
		  /* 822215E4h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 822215E4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 822215E4h case    6:*/		return 0x822215E8;
		  /* 822215E8h */ case    7:  		/* li R11, 0 */
		/* 822215E8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822215E8h case    7:*/		return 0x822215EC;
		  /* 822215ECh */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 822215ECh case    8:*/		if ( !regs.CR[6].eq ) { return 0x822215F4;  }
		/* 822215ECh case    8:*/		return 0x822215F0;
	}
	return 0x822215F0;
} // Block from 822215CCh-822215F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822215F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822215F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822215F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822215F0);
		  /* 822215F0h */ case    0:  		/* li R11, 1 */
		/* 822215F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822215F0h case    0:*/		return 0x822215F4;
	}
	return 0x822215F4;
} // Block from 822215F0h-822215F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822215F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822215F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822215F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822215F4);
		  /* 822215F4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822215F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822215F4h case    0:*/		return 0x822215F8;
	}
	return 0x822215F8;
} // Block from 822215F4h-822215F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822215F8h
// Function '?XenosSqrtIEEE@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822215F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822215F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822215F8);
		  /* 822215F8h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 822215F8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822215F8h case    0:*/		return 0x822215FC;
		  /* 822215FCh */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 822215FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82221618;  }
		/* 822215FCh case    1:*/		return 0x82221600;
		  /* 82221600h */ case    2:  		/* rlwinm. R3, R11, 0, 24, 31 */
		/* 82221600h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82221600h case    2:*/		return 0x82221604;
		  /* 82221604h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 82221604h case    3:*/		if ( regs.CR[0].eq ) { return 0x82221618;  }
		/* 82221604h case    3:*/		return 0x82221608;
		  /* 82221608h */ case    4:  		/* lwz R9, <#[R9]> */
		/* 82221608h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82221608h case    4:*/		return 0x8222160C;
		  /* 8222160Ch */ case    5:  		/* xor R9, R9, R7 */
		/* 8222160Ch case    5:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8222160Ch case    5:*/		return 0x82221610;
		  /* 82221610h */ case    6:  		/* rlwinm. R9, R9, 0, 27, 28 */
		/* 82221610h case    6:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R9,regs.R9);
		/* 82221610h case    6:*/		return 0x82221614;
		  /* 82221614h */ case    7:  		/* bc 4, CR0_EQ, -236 */
		/* 82221614h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82221528;  }
		/* 82221614h case    7:*/		return 0x82221618;
	}
	return 0x82221618;
} // Block from 822215F8h-82221618h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82221618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221618);
		  /* 82221618h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82221618h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82221618h case    0:*/		return 0x8222161C;
		  /* 8222161Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8222161Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82221628;  }
		/* 8222161Ch case    1:*/		return 0x82221620;
		  /* 82221620h */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82221620h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82221620h case    2:*/		return 0x82221624;
		  /* 82221624h */ case    3:  		/* bc 12, CR0_EQ, -204 */
		/* 82221624h case    3:*/		if ( regs.CR[0].eq ) { return 0x82221558;  }
		/* 82221624h case    3:*/		return 0x82221628;
	}
	return 0x82221628;
} // Block from 82221618h-82221628h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221628);
		  /* 82221628h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 82221628h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82221628h case    0:*/		return 0x8222162C;
		  /* 8222162Ch */ case    1:  		/* rlwinm R10, R7, 31, 1, 31 */
		/* 8222162Ch case    1:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R7);
		/* 8222162Ch case    1:*/		return 0x82221630;
		  /* 82221630h */ case    2:  		/* rlwinm R11, R11, 31, 24, 31 */
		/* 82221630h case    2:*/		cpu::op::rlwinm<0,31,24,31>(regs,&regs.R11,regs.R11);
		/* 82221630h case    2:*/		return 0x82221634;
		  /* 82221634h */ case    3:  		/* xor R11, R11, R10 */
		/* 82221634h case    3:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82221634h case    3:*/		return 0x82221638;
		  /* 82221638h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82221638h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82221638h case    4:*/		return 0x8222163C;
		  /* 8222163Ch */ case    5:  		/* b -232 */
		/* 8222163Ch case    5:*/		return 0x82221554;
		/* 8222163Ch case    5:*/		return 0x82221640;
	}
	return 0x82221640;
} // Block from 82221628h-82221640h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221640);
		  /* 82221640h */ case    0:  		/* rlwinm. R11, R7, 0, 28, 28 */
		/* 82221640h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R7);
		/* 82221640h case    0:*/		return 0x82221644;
		  /* 82221644h */ case    1:  		/* b -240 */
		/* 82221644h case    1:*/		return 0x82221554;
		/* 82221644h case    1:*/		return 0x82221648;
		  /* 82221648h */ case    2:  		/* addi R11, R10, 8 */
		/* 82221648h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82221648h case    2:*/		return 0x8222164C;
		  /* 8222164Ch */ case    3:  		/* lwz R10, <#[R10 + 8]> */
		/* 8222164Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8222164Ch case    3:*/		return 0x82221650;
	}
	return 0x82221650;
} // Block from 82221640h-82221650h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221650);
		  /* 82221650h */ case    0:  		/* cmplw CR6, R10, R4 */
		/* 82221650h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 82221650h case    0:*/		return 0x82221654;
		  /* 82221654h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82221654h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82221648;  }
		/* 82221654h case    1:*/		return 0x82221658;
		  /* 82221658h */ case    2:  		/* lwz R10, <#[R4 + 8]> */
		/* 82221658h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 82221658h case    2:*/		return 0x8222165C;
		  /* 8222165Ch */ case    3:  		/* li R3, 1 */
		/* 8222165Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8222165Ch case    3:*/		return 0x82221660;
		  /* 82221660h */ case    4:  		/* stw R10, <#[R11]> */
		/* 82221660h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82221660h case    4:*/		return 0x82221664;
		  /* 82221664h */ case    5:  		/* lwz R11, <#[R5 + 4]> */
		/* 82221664h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82221664h case    5:*/		return 0x82221668;
		  /* 82221668h */ case    6:  		/* stw R11, <#[R4 + 8]> */
		/* 82221668h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82221668h case    6:*/		return 0x8222166C;
		  /* 8222166Ch */ case    7:  		/* stw R4, <#[R5 + 4]> */
		/* 8222166Ch case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R5 + 0x00000004) );
		/* 8222166Ch case    7:*/		return 0x82221670;
		  /* 82221670h */ case    8:  		/* lwz R11, <#[R4]> */
		/* 82221670h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82221670h case    8:*/		return 0x82221674;
		  /* 82221674h */ case    9:  		/* rlwimi R11, R6, 5, 19, 26 */
		/* 82221674h case    9:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R6);
		/* 82221674h case    9:*/		return 0x82221678;
		  /* 82221678h */ case   10:  		/* rlwimi R11, R7, 0, 27, 31 */
		/* 82221678h case   10:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R11,regs.R7);
		/* 82221678h case   10:*/		return 0x8222167C;
		  /* 8222167Ch */ case   11:  		/* stw R5, <#[R4 + 12]> */
		/* 8222167Ch case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 8222167Ch case   11:*/		return 0x82221680;
		  /* 82221680h */ case   12:  		/* stw R11, <#[R4]> */
		/* 82221680h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82221680h case   12:*/		return 0x82221684;
		  /* 82221684h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82221684h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221684h case   13:*/		return 0x82221688;
	}
	return 0x82221688;
} // Block from 82221650h-82221688h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82221688h
// Function '?XenosRecipSqrtIEEE@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221688);
		  /* 82221688h */ case    0:  		/* addi R11, R4, 11 */
		/* 82221688h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xB);
		/* 82221688h case    0:*/		return 0x8222168C;
		  /* 8222168Ch */ case    1:  		/* mr R4, R5 */
		/* 8222168Ch case    1:*/		regs.R4 = regs.R5;
		/* 8222168Ch case    1:*/		return 0x82221690;
		  /* 82221690h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82221690h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82221690h case    2:*/		return 0x82221694;
		  /* 82221694h */ case    3:  		/* lfsx FR1, <#[R11 + R3]> */
		/* 82221694h case    3:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82221694h case    3:*/		return 0x82221698;
		  /* 82221698h */ case    4:  		/* b -648 */
		/* 82221698h case    4:*/		return 0x82221410;
		/* 82221698h case    4:*/		return 0x8222169C;
		  /* 8222169Ch */ case    5:  		/* nop */
		/* 8222169Ch case    5:*/		cpu::op::nop();
		/* 8222169Ch case    5:*/		return 0x822216A0;
	}
	return 0x822216A0;
} // Block from 82221688h-822216A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822216A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822216A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822216A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822216A0);
		  /* 822216A0h */ case    0:  		/* mfspr R12, LR */
		/* 822216A0h case    0:*/		regs.R12 = regs.LR;
		/* 822216A0h case    0:*/		return 0x822216A4;
		  /* 822216A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822216A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822216A4h case    1:*/		return 0x822216A8;
		  /* 822216A8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822216A8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822216A8h case    2:*/		return 0x822216AC;
		  /* 822216ACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822216ACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822216ACh case    3:*/		return 0x822216B0;
		  /* 822216B0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822216B0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822216B0h case    4:*/		return 0x822216B4;
		  /* 822216B4h */ case    5:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 822216B4h case    5:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 822216B4h case    5:*/		return 0x822216B8;
		  /* 822216B8h */ case    6:  		/* mr R30, R5 */
		/* 822216B8h case    6:*/		regs.R30 = regs.R5;
		/* 822216B8h case    6:*/		return 0x822216BC;
		  /* 822216BCh */ case    7:  		/* lwz R11, <#[R11]> */
		/* 822216BCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822216BCh case    7:*/		return 0x822216C0;
		  /* 822216C0h */ case    8:  		/* lwz R11, <#[R11 + 148]> */
		/* 822216C0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000094) );
		/* 822216C0h case    8:*/		return 0x822216C4;
		  /* 822216C4h */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 822216C4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 822216C4h case    9:*/		return 0x822216C8;
		  /* 822216C8h */ case   10:  		/* nor R11, R11, R11 */
		/* 822216C8h case   10:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822216C8h case   10:*/		return 0x822216CC;
		  /* 822216CCh */ case   11:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 822216CCh case   11:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 822216CCh case   11:*/		return 0x822216D0;
		  /* 822216D0h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 822216D0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x822216DC;  }
		/* 822216D0h case   12:*/		return 0x822216D4;
		  /* 822216D4h */ case   13:  		/* li R31, 0 */
		/* 822216D4h case   13:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822216D4h case   13:*/		return 0x822216D8;
		  /* 822216D8h */ case   14:  		/* b 24 */
		/* 822216D8h case   14:*/		return 0x822216F0;
		/* 822216D8h case   14:*/		return 0x822216DC;
	}
	return 0x822216DC;
} // Block from 822216A0h-822216DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 822216DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822216DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822216DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822216DC);
		  /* 822216DCh */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 822216DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 822216DCh case    0:*/		return 0x822216E0;
		  /* 822216E0h */ case    1:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 822216E0h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 822216E0h case    1:*/		return 0x822216E4;
		  /* 822216E4h */ case    2:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 822216E4h case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 822216E4h case    2:*/		return 0x822216E8;
		  /* 822216E8h */ case    3:  		/* srw R11, R11, R10 */
		/* 822216E8h case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822216E8h case    3:*/		return 0x822216EC;
		  /* 822216ECh */ case    4:  		/* rlwinm R31, R11, 0, 30, 31 */
		/* 822216ECh case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R11);
		/* 822216ECh case    4:*/		return 0x822216F0;
	}
	return 0x822216F0;
} // Block from 822216DCh-822216F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822216F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822216F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822216F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822216F0);
		  /* 822216F0h */ case    0:  		/* bl -411552 */
		/* 822216F0h case    0:*/		regs.LR = 0x822216F4; return 0x821BCF50;
		/* 822216F0h case    0:*/		return 0x822216F4;
		  /* 822216F4h */ case    1:  		/* mr R5, R30 */
		/* 822216F4h case    1:*/		regs.R5 = regs.R30;
		/* 822216F4h case    1:*/		return 0x822216F8;
		  /* 822216F8h */ case    2:  		/* mr R4, R31 */
		/* 822216F8h case    2:*/		regs.R4 = regs.R31;
		/* 822216F8h case    2:*/		return 0x822216FC;
		  /* 822216FCh */ case    3:  		/* bl -644 */
		/* 822216FCh case    3:*/		regs.LR = 0x82221700; return 0x82221478;
		/* 822216FCh case    3:*/		return 0x82221700;
		  /* 82221700h */ case    4:  		/* addi R1, R1, 112 */
		/* 82221700h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82221700h case    4:*/		return 0x82221704;
		  /* 82221704h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 82221704h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82221704h case    5:*/		return 0x82221708;
		  /* 82221708h */ case    6:  		/* mtspr LR, R12 */
		/* 82221708h case    6:*/		regs.LR = regs.R12;
		/* 82221708h case    6:*/		return 0x8222170C;
		  /* 8222170Ch */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 8222170Ch case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8222170Ch case    7:*/		return 0x82221710;
		  /* 82221710h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82221710h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221710h case    8:*/		return 0x82221714;
		  /* 82221714h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82221714h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221714h case    9:*/		return 0x82221718;
	}
	return 0x82221718;
} // Block from 822216F0h-82221718h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82221718h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221718);
		  /* 82221718h */ case    0:  		/* rlwinm. R11, R3, 0, 30, 31 */
		/* 82221718h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R3);
		/* 82221718h case    0:*/		return 0x8222171C;
		  /* 8222171Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8222171Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82221728;  }
		/* 8222171Ch case    1:*/		return 0x82221720;
		  /* 82221720h */ case    2:  		/* li R3, 0 */
		/* 82221720h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82221720h case    2:*/		return 0x82221724;
		  /* 82221724h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82221724h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221724h case    3:*/		return 0x82221728;
	}
	return 0x82221728;
} // Block from 82221718h-82221728h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221728);
		  /* 82221728h */ case    0:  		/* rlwinm. R11, R3, 0, 31, 31 */
		/* 82221728h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R3);
		/* 82221728h case    0:*/		return 0x8222172C;
		  /* 8222172Ch */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 8222172Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82221764;  }
		/* 8222172Ch case    1:*/		return 0x82221730;
		  /* 82221730h */ case    2:  		/* rlwinm. R11, R3, 0, 30, 30 */
		/* 82221730h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R3);
		/* 82221730h case    2:*/		return 0x82221734;
		  /* 82221734h */ case    3:  		/* lis R11, -32256 */
		/* 82221734h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82221734h case    3:*/		return 0x82221738;
		  /* 82221738h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82221738h case    4:*/		if ( regs.CR[0].eq ) { return 0x82221748;  }
		/* 82221738h case    4:*/		return 0x8222173C;
		  /* 8222173Ch */ case    5:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 8222173Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 8222173Ch case    5:*/		return 0x82221740;
		  /* 82221740h */ case    6:  		/* stfd FR0, <#[R4]> */
		/* 82221740h case    6:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 82221740h case    6:*/		return 0x82221744;
		  /* 82221744h */ case    7:  		/* b 24 */
		/* 82221744h case    7:*/		return 0x8222175C;
		/* 82221744h case    7:*/		return 0x82221748;
	}
	return 0x82221748;
} // Block from 82221728h-82221748h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82221748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221748);
		  /* 82221748h */ case    0:  		/* lis R10, -128 */
		/* 82221748h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 82221748h case    0:*/		return 0x8222174C;
		  /* 8222174Ch */ case    1:  		/* stw R10, <#[R1 - 16]> */
		/* 8222174Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222174Ch case    1:*/		return 0x82221750;
		  /* 82221750h */ case    2:  		/* lfs FR0, <#[R1 - 16]> */
		/* 82221750h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221750h case    2:*/		return 0x82221754;
		  /* 82221754h */ case    3:  		/* stfd FR0, <#[R4]> */
		/* 82221754h case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 82221754h case    3:*/		return 0x82221758;
	}
	return 0x82221758;
} // Block from 82221748h-82221758h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221758h
// Function '?XenosRecipIEEE@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221758);
		  /* 82221758h */ case    0:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82221758h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82221758h case    0:*/		return 0x8222175C;
	}
	return 0x8222175C;
} // Block from 82221758h-8222175Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222175Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222175C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222175C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222175C);
		  /* 8222175Ch */ case    0:  		/* stfd FR0, <#[R5]> */
		/* 8222175Ch case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 8222175Ch case    0:*/		return 0x82221760;
		  /* 82221760h */ case    1:  		/* b 32 */
		/* 82221760h case    1:*/		return 0x82221780;
		/* 82221760h case    1:*/		return 0x82221764;
	}
	return 0x82221764;
} // Block from 8222175Ch-82221764h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221764);
		  /* 82221764h */ case    0:  		/* lis R10, -32256 */
		/* 82221764h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82221764h case    0:*/		return 0x82221768;
		  /* 82221768h */ case    1:  		/* lis R11, 32640 */
		/* 82221768h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x7F80);
		/* 82221768h case    1:*/		return 0x8222176C;
		  /* 8222176Ch */ case    2:  		/* stw R11, <#[R1 - 16]> */
		/* 8222176Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222176Ch case    2:*/		return 0x82221770;
		  /* 82221770h */ case    3:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 82221770h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 82221770h case    3:*/		return 0x82221774;
		  /* 82221774h */ case    4:  		/* stfd FR0, <#[R4]> */
		/* 82221774h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 82221774h case    4:*/		return 0x82221778;
		  /* 82221778h */ case    5:  		/* lfs FR0, <#[R1 - 16]> */
		/* 82221778h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221778h case    5:*/		return 0x8222177C;
		  /* 8222177Ch */ case    6:  		/* stfd FR0, <#[R5]> */
		/* 8222177Ch case    6:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 8222177Ch case    6:*/		return 0x82221780;
	}
	return 0x82221780;
} // Block from 82221764h-82221780h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82221780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221780);
		  /* 82221780h */ case    0:  		/* li R3, 1 */
		/* 82221780h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82221780h case    0:*/		return 0x82221784;
		  /* 82221784h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82221784h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221784h case    1:*/		return 0x82221788;
	}
	return 0x82221788;
} // Block from 82221780h-82221788h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221788);
		  /* 82221788h */ case    0:  		/* lis R11, -32256 */
		/* 82221788h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82221788h case    0:*/		return 0x8222178C;
		  /* 8222178Ch */ case    1:  		/* rlwinm. R10, R5, 0, 31, 31 */
		/* 8222178Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R5);
		/* 8222178Ch case    1:*/		return 0x82221790;
		  /* 82221790h */ case    2:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 82221790h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 82221790h case    2:*/		return 0x82221794;
		  /* 82221794h */ case    3:  		/* bc 12, CR0_EQ, 76 */
		/* 82221794h case    3:*/		if ( regs.CR[0].eq ) { return 0x822217E0;  }
		/* 82221794h case    3:*/		return 0x82221798;
		  /* 82221798h */ case    4:  		/* lis R11, -32256 */
		/* 82221798h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82221798h case    4:*/		return 0x8222179C;
		  /* 8222179Ch */ case    5:  		/* lfd FR0, <#[R3]> */
		/* 8222179Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000000) );
		/* 8222179Ch case    5:*/		return 0x822217A0;
		  /* 822217A0h */ case    6:  		/* fcmpu CR6, FR0, FR13 */
		/* 822217A0h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822217A0h case    6:*/		return 0x822217A4;
		  /* 822217A4h */ case    7:  		/* lfd FR12, <#[R11 + 1848]> */
		/* 822217A4h case    7:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000738) );
		/* 822217A4h case    7:*/		return 0x822217A8;
		  /* 822217A8h */ case    8:  		/* bc 4, CR6_LT, 12 */
		/* 822217A8h case    8:*/		if ( !regs.CR[6].lt ) { return 0x822217B4;  }
		/* 822217A8h case    8:*/		return 0x822217AC;
		  /* 822217ACh */ case    9:  		/* stfd FR13, <#[R3]> */
		/* 822217ACh case    9:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R3 + 0x00000000) );
		/* 822217ACh case    9:*/		return 0x822217B0;
		  /* 822217B0h */ case   10:  		/* b 16 */
		/* 822217B0h case   10:*/		return 0x822217C0;
		/* 822217B0h case   10:*/		return 0x822217B4;
	}
	return 0x822217B4;
} // Block from 82221788h-822217B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822217B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822217B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822217B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822217B4);
		  /* 822217B4h */ case    0:  		/* fcmpu CR6, FR0, FR12 */
		/* 822217B4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 822217B4h case    0:*/		return 0x822217B8;
		  /* 822217B8h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 822217B8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x822217C0;  }
		/* 822217B8h case    1:*/		return 0x822217BC;
		  /* 822217BCh */ case    2:  		/* stfd FR12, <#[R3]> */
		/* 822217BCh case    2:*/		cpu::mem::store64f( regs, regs.FR12, (uint32)(regs.R3 + 0x00000000) );
		/* 822217BCh case    2:*/		return 0x822217C0;
	}
	return 0x822217C0;
} // Block from 822217B4h-822217C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822217C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822217C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822217C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822217C0);
		  /* 822217C0h */ case    0:  		/* lfd FR0, <#[R4]> */
		/* 822217C0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 822217C0h case    0:*/		return 0x822217C4;
		  /* 822217C4h */ case    1:  		/* fcmpu CR6, FR0, FR13 */
		/* 822217C4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822217C4h case    1:*/		return 0x822217C8;
		  /* 822217C8h */ case    2:  		/* bc 4, CR6_LT, 12 */
		/* 822217C8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x822217D4;  }
		/* 822217C8h case    2:*/		return 0x822217CC;
		  /* 822217CCh */ case    3:  		/* stfd FR13, <#[R4]> */
		/* 822217CCh case    3:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R4 + 0x00000000) );
		/* 822217CCh case    3:*/		return 0x822217D0;
		  /* 822217D0h */ case    4:  		/* b 16 */
		/* 822217D0h case    4:*/		return 0x822217E0;
		/* 822217D0h case    4:*/		return 0x822217D4;
	}
	return 0x822217D4;
} // Block from 822217C0h-822217D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822217D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822217D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822217D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822217D4);
		  /* 822217D4h */ case    0:  		/* fcmpu CR6, FR0, FR12 */
		/* 822217D4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 822217D4h case    0:*/		return 0x822217D8;
		  /* 822217D8h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 822217D8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x822217E0;  }
		/* 822217D8h case    1:*/		return 0x822217DC;
		  /* 822217DCh */ case    2:  		/* stfd FR12, <#[R4]> */
		/* 822217DCh case    2:*/		cpu::mem::store64f( regs, regs.FR12, (uint32)(regs.R4 + 0x00000000) );
		/* 822217DCh case    2:*/		return 0x822217E0;
	}
	return 0x822217E0;
} // Block from 822217D4h-822217E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822217E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822217E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822217E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822217E0);
		  /* 822217E0h */ case    0:  		/* rlwinm. R11, R5, 0, 30, 30 */
		/* 822217E0h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R5);
		/* 822217E0h case    0:*/		return 0x822217E4;
		  /* 822217E4h */ case    1:  		/* bc 12, CR0_EQ, 68 */
		/* 822217E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82221828;  }
		/* 822217E4h case    1:*/		return 0x822217E8;
		  /* 822217E8h */ case    2:  		/* lfd FR12, <#[R3]> */
		/* 822217E8h case    2:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00000000) );
		/* 822217E8h case    2:*/		return 0x822217EC;
		  /* 822217ECh */ case    3:  		/* fcmpu CR6, FR12, FR13 */
		/* 822217ECh case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR13);
		/* 822217ECh case    3:*/		return 0x822217F0;
		  /* 822217F0h */ case    4:  		/* bc 4, CR6_LT, 56 */
		/* 822217F0h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82221828;  }
		/* 822217F0h case    4:*/		return 0x822217F4;
		  /* 822217F4h */ case    5:  		/* lfd FR0, <#[R4]> */
		/* 822217F4h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 822217F4h case    5:*/		return 0x822217F8;
		  /* 822217F8h */ case    6:  		/* fcmpu CR6, FR0, FR13 */
		/* 822217F8h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822217F8h case    6:*/		return 0x822217FC;
		  /* 822217FCh */ case    7:  		/* bc 4, CR6_LT, 24 */
		/* 822217FCh case    7:*/		if ( !regs.CR[6].lt ) { return 0x82221814;  }
		/* 822217FCh case    7:*/		return 0x82221800;
		  /* 82221800h */ case    8:  		/* fneg FR0, FR0 */
		/* 82221800h case    8:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82221800h case    8:*/		return 0x82221804;
		  /* 82221804h */ case    9:  		/* stfd FR0, <#[R3]> */
		/* 82221804h case    9:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000000) );
		/* 82221804h case    9:*/		return 0x82221808;
		  /* 82221808h */ case   10:  		/* fneg FR0, FR12 */
		/* 82221808h case   10:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR12);
		/* 82221808h case   10:*/		return 0x8222180C;
		  /* 8222180Ch */ case   11:  		/* stfd FR0, <#[R4]> */
		/* 8222180Ch case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 8222180Ch case   11:*/		return 0x82221810;
		  /* 82221810h */ case   12:  		/* b 24 */
		/* 82221810h case   12:*/		return 0x82221828;
		/* 82221810h case   12:*/		return 0x82221814;
	}
	return 0x82221814;
} // Block from 822217E0h-82221814h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82221814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221814);
		  /* 82221814h */ case    0:  		/* fneg FR12, FR12 */
		/* 82221814h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR12,regs.FR12);
		/* 82221814h case    0:*/		return 0x82221818;
	}
	return 0x82221818;
} // Block from 82221814h-82221818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221818h
// Function '?Skip@ComponentTypeEnumerator@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221818);
		  /* 82221818h */ case    0:  		/* stfd FR13, <#[R3]> */
		/* 82221818h case    0:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R3 + 0x00000000) );
		/* 82221818h case    0:*/		return 0x8222181C;
		  /* 8222181Ch */ case    1:  		/* fcmpu CR6, FR12, FR0 */
		/* 8222181Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 8222181Ch case    1:*/		return 0x82221820;
		  /* 82221820h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 82221820h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82221828;  }
		/* 82221820h case    2:*/		return 0x82221824;
		  /* 82221824h */ case    3:  		/* stfd FR12, <#[R4]> */
		/* 82221824h case    3:*/		cpu::mem::store64f( regs, regs.FR12, (uint32)(regs.R4 + 0x00000000) );
		/* 82221824h case    3:*/		return 0x82221828;
	}
	return 0x82221828;
} // Block from 82221818h-82221828h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82221828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221828);
		  /* 82221828h */ case    0:  		/* rlwinm. R11, R5, 0, 29, 29 */
		/* 82221828h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R5);
		/* 82221828h case    0:*/		return 0x8222182C;
		  /* 8222182Ch */ case    1:  		/* bclr 12, CR0_EQ */
		/* 8222182Ch case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8222182Ch case    1:*/		return 0x82221830;
	}
	return 0x82221830;
} // Block from 82221828h-82221830h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221830);
		  /* 82221830h */ case    0:  		/* lfd FR0, <#[R4]> */
		/* 82221830h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 82221830h case    0:*/		return 0x82221834;
		  /* 82221834h */ case    1:  		/* lfd FR13, <#[R3]> */
		/* 82221834h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R3 + 0x00000000) );
		/* 82221834h case    1:*/		return 0x82221838;
		  /* 82221838h */ case    2:  		/* fneg FR0, FR0 */
		/* 82221838h case    2:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82221838h case    2:*/		return 0x8222183C;
		  /* 8222183Ch */ case    3:  		/* stfd FR0, <#[R3]> */
		/* 8222183Ch case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000000) );
		/* 8222183Ch case    3:*/		return 0x82221840;
		  /* 82221840h */ case    4:  		/* fneg FR0, FR13 */
		/* 82221840h case    4:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR13);
		/* 82221840h case    4:*/		return 0x82221844;
		  /* 82221844h */ case    5:  		/* stfd FR0, <#[R4]> */
		/* 82221844h case    5:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 82221844h case    5:*/		return 0x82221848;
		  /* 82221848h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82221848h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221848h case    6:*/		return 0x8222184C;
	}
	return 0x8222184C;
} // Block from 82221830h-8222184Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222184Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222184C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222184C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222184C);
		  /* 8222184Ch */ case    0:  		/* nop */
		/* 8222184Ch case    0:*/		cpu::op::nop();
		/* 8222184Ch case    0:*/		return 0x82221850;
	}
	return 0x82221850;
} // Block from 8222184Ch-82221850h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221850h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221850);
		  /* 82221850h */ case    0:  		/* mfspr R12, LR */
		/* 82221850h case    0:*/		regs.R12 = regs.LR;
		/* 82221850h case    0:*/		return 0x82221854;
		  /* 82221854h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82221854h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82221854h case    1:*/		return 0x82221858;
		  /* 82221858h */ case    2:  		/* stfd FR30, <#[R1 - 24]> */
		/* 82221858h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82221858h case    2:*/		return 0x8222185C;
		  /* 8222185Ch */ case    3:  		/* stfd FR31, <#[R1 - 16]> */
		/* 8222185Ch case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222185Ch case    3:*/		return 0x82221860;
		  /* 82221860h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82221860h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82221860h case    4:*/		return 0x82221864;
		  /* 82221864h */ case    5:  		/* lis R10, -32256 */
		/* 82221864h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82221864h case    5:*/		return 0x82221868;
		  /* 82221868h */ case    6:  		/* fmr FR31, FR1 */
		/* 82221868h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82221868h case    6:*/		return 0x8222186C;
		  /* 8222186Ch */ case    7:  		/* lis R11, -32768 */
		/* 8222186Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 8222186Ch case    7:*/		return 0x82221870;
		  /* 82221870h */ case    8:  		/* fmr FR30, FR2 */
		/* 82221870h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR2);
		/* 82221870h case    8:*/		return 0x82221874;
		  /* 82221874h */ case    9:  		/* stw R11, <#[R1 + 80]> */
		/* 82221874h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82221874h case    9:*/		return 0x82221878;
		  /* 82221878h */ case   10:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82221878h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82221878h case   10:*/		return 0x8222187C;
		  /* 8222187Ch */ case   11:  		/* fcmpu CR6, FR0, FR1 */
		/* 8222187Ch case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR1);
		/* 8222187Ch case   11:*/		return 0x82221880;
		  /* 82221880h */ case   12:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 82221880h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 82221880h case   12:*/		return 0x82221884;
		  /* 82221884h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 82221884h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8222188C;  }
		/* 82221884h case   13:*/		return 0x82221888;
		  /* 82221888h */ case   14:  		/* fmr FR31, FR0 */
		/* 82221888h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR0);
		/* 82221888h case   14:*/		return 0x8222188C;
	}
	return 0x8222188C;
} // Block from 82221850h-8222188Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222188Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222188C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222188C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222188C);
		  /* 8222188Ch */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 8222188Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222188Ch case    0:*/		return 0x82221890;
		  /* 82221890h */ case    1:  		/* lfs FR13, <#[R1 + 80]> */
		/* 82221890h case    1:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82221890h case    1:*/		return 0x82221894;
		  /* 82221894h */ case    2:  		/* fcmpu CR6, FR13, FR30 */
		/* 82221894h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR30);
		/* 82221894h case    2:*/		return 0x82221898;
	}
	return 0x82221898;
} // Block from 8222188Ch-82221898h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82221898h
// Function '?GetLinkageFromInputSemantic@Compiler@D3DXShader@@AAA_NPAUInputSemantic@2@IPBDPAULinkageSemantics@2@PAW4PARAMGEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221898);
		  /* 82221898h */ case    0:  		/* bc 4, CR6_EQ, 8 */
		/* 82221898h case    0:*/		if ( !regs.CR[6].eq ) { return 0x822218A0;  }
		/* 82221898h case    0:*/		return 0x8222189C;
		  /* 8222189Ch */ case    1:  		/* fmr FR30, FR0 */
		/* 8222189Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR0);
		/* 8222189Ch case    1:*/		return 0x822218A0;
	}
	return 0x822218A0;
} // Block from 82221898h-822218A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822218A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822218A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822218A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822218A0);
		  /* 822218A0h */ case    0:  		/* fmr FR1, FR31 */
		/* 822218A0h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822218A0h case    0:*/		return 0x822218A4;
		  /* 822218A4h */ case    1:  		/* bl -1611884 */
		/* 822218A4h case    1:*/		regs.LR = 0x822218A8; return 0x82098038;
		/* 822218A4h case    1:*/		return 0x822218A8;
		  /* 822218A8h */ case    2:  		/* cmpwi CR6, R3, 4 */
		/* 822218A8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 822218A8h case    2:*/		return 0x822218AC;
		  /* 822218ACh */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 822218ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x822218FC;  }
		/* 822218ACh case    3:*/		return 0x822218B0;
		  /* 822218B0h */ case    4:  		/* cmpwi CR6, R3, 512 */
		/* 822218B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000200);
		/* 822218B0h case    4:*/		return 0x822218B4;
		  /* 822218B4h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 822218B4h case    5:*/		if ( regs.CR[6].eq ) { return 0x822218F4;  }
		/* 822218B4h case    5:*/		return 0x822218B8;
		  /* 822218B8h */ case    6:  		/* fmr FR1, FR30 */
		/* 822218B8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 822218B8h case    6:*/		return 0x822218BC;
		  /* 822218BCh */ case    7:  		/* bl -1611908 */
		/* 822218BCh case    7:*/		regs.LR = 0x822218C0; return 0x82098038;
		/* 822218BCh case    7:*/		return 0x822218C0;
		  /* 822218C0h */ case    8:  		/* cmpwi CR6, R3, 4 */
		/* 822218C0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 822218C0h case    8:*/		return 0x822218C4;
		  /* 822218C4h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 822218C4h case    9:*/		if ( regs.CR[6].eq ) { return 0x822218E4;  }
		/* 822218C4h case    9:*/		return 0x822218C8;
		  /* 822218C8h */ case   10:  		/* cmpwi CR6, R3, 512 */
		/* 822218C8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000200);
		/* 822218C8h case   10:*/		return 0x822218CC;
		  /* 822218CCh */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 822218CCh case   11:*/		if ( regs.CR[6].eq ) { return 0x822218D8;  }
		/* 822218CCh case   11:*/		return 0x822218D0;
		  /* 822218D0h */ case   12:  		/* fmul FR1, FR31, FR30 */
		/* 822218D0h case   12:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR31,regs.FR30);
		/* 822218D0h case   12:*/		return 0x822218D4;
		  /* 822218D4h */ case   13:  		/* b 60 */
		/* 822218D4h case   13:*/		return 0x82221910;
		/* 822218D4h case   13:*/		return 0x822218D8;
	}
	return 0x822218D8;
} // Block from 822218A0h-822218D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822218D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822218D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822218D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822218D8);
		  /* 822218D8h */ case    0:  		/* fmr FR2, FR31 */
		/* 822218D8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 822218D8h case    0:*/		return 0x822218DC;
		  /* 822218DCh */ case    1:  		/* fmr FR1, FR30 */
		/* 822218DCh case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 822218DCh case    1:*/		return 0x822218E0;
		  /* 822218E0h */ case    2:  		/* b 44 */
		/* 822218E0h case    2:*/		return 0x8222190C;
		/* 822218E0h case    2:*/		return 0x822218E4;
	}
	return 0x822218E4;
} // Block from 822218D8h-822218E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822218E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822218E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822218E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822218E4);
		  /* 822218E4h */ case    0:  		/* fmr FR1, FR31 */
		/* 822218E4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822218E4h case    0:*/		return 0x822218E8;
		  /* 822218E8h */ case    1:  		/* bl -1612104 */
		/* 822218E8h case    1:*/		regs.LR = 0x822218EC; return 0x82097FA0;
		/* 822218E8h case    1:*/		return 0x822218EC;
		  /* 822218ECh */ case    2:  		/* fmr FR2, FR1 */
		/* 822218ECh case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 822218ECh case    2:*/		return 0x822218F0;
		  /* 822218F0h */ case    3:  		/* b -20 */
		/* 822218F0h case    3:*/		return 0x822218DC;
		/* 822218F0h case    3:*/		return 0x822218F4;
	}
	return 0x822218F4;
} // Block from 822218E4h-822218F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822218F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822218F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822218F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822218F4);
		  /* 822218F4h */ case    0:  		/* fmr FR2, FR30 */
		/* 822218F4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 822218F4h case    0:*/		return 0x822218F8;
		  /* 822218F8h */ case    1:  		/* b 16 */
		/* 822218F8h case    1:*/		return 0x82221908;
		/* 822218F8h case    1:*/		return 0x822218FC;
	}
	return 0x822218FC;
} // Block from 822218F4h-822218FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822218FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822218FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822218FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822218FC);
		  /* 822218FCh */ case    0:  		/* fmr FR1, FR30 */
		/* 822218FCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 822218FCh case    0:*/		return 0x82221900;
		  /* 82221900h */ case    1:  		/* bl -1612128 */
		/* 82221900h case    1:*/		regs.LR = 0x82221904; return 0x82097FA0;
		/* 82221900h case    1:*/		return 0x82221904;
		  /* 82221904h */ case    2:  		/* fmr FR2, FR1 */
		/* 82221904h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 82221904h case    2:*/		return 0x82221908;
	}
	return 0x82221908;
} // Block from 822218FCh-82221908h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82221908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221908);
		  /* 82221908h */ case    0:  		/* fmr FR1, FR31 */
		/* 82221908h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82221908h case    0:*/		return 0x8222190C;
	}
	return 0x8222190C;
} // Block from 82221908h-8222190Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222190Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222190C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222190C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222190C);
		  /* 8222190Ch */ case    0:  		/* bl -1612196 */
		/* 8222190Ch case    0:*/		regs.LR = 0x82221910; return 0x82097F68;
		/* 8222190Ch case    0:*/		return 0x82221910;
	}
	return 0x82221910;
} // Block from 8222190Ch-82221910h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221910);
		  /* 82221910h */ case    0:  		/* addi R1, R1, 112 */
		/* 82221910h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82221910h case    0:*/		return 0x82221914;
		  /* 82221914h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82221914h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82221914h case    1:*/		return 0x82221918;
		  /* 82221918h */ case    2:  		/* mtspr LR, R12 */
		/* 82221918h case    2:*/		regs.LR = regs.R12;
		/* 82221918h case    2:*/		return 0x8222191C;
		  /* 8222191Ch */ case    3:  		/* lfd FR30, <#[R1 - 24]> */
		/* 8222191Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8222191Ch case    3:*/		return 0x82221920;
		  /* 82221920h */ case    4:  		/* lfd FR31, <#[R1 - 16]> */
		/* 82221920h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82221920h case    4:*/		return 0x82221924;
		  /* 82221924h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82221924h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221924h case    5:*/		return 0x82221928;
	}
	return 0x82221928;
} // Block from 82221910h-82221928h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221928h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221928);
		  /* 82221928h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82221928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82221928h case    0:*/		return 0x8222192C;
		  /* 8222192Ch */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8222192Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8222192Ch case    1:*/		return 0x82221930;
		  /* 82221930h */ case    2:  		/* cmplwi CR6, R10, 59 */
		/* 82221930h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003B);
		/* 82221930h case    2:*/		return 0x82221934;
		  /* 82221934h */ case    3:  		/* bc 12, CR6_GT, 120 */
		/* 82221934h case    3:*/		if ( regs.CR[6].gt ) { return 0x822219AC;  }
		/* 82221934h case    3:*/		return 0x82221938;
		  /* 82221938h */ case    4:  		/* bc 12, CR6_EQ, 104 */
		/* 82221938h case    4:*/		if ( regs.CR[6].eq ) { return 0x822219A0;  }
		/* 82221938h case    4:*/		return 0x8222193C;
		  /* 8222193Ch */ case    5:  		/* cmplwi CR6, R10, 21 */
		/* 8222193Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000015);
		/* 8222193Ch case    5:*/		return 0x82221940;
		  /* 82221940h */ case    6:  		/* bc 12, CR6_EQ, 84 */
		/* 82221940h case    6:*/		if ( regs.CR[6].eq ) { return 0x82221994;  }
		/* 82221940h case    6:*/		return 0x82221944;
		  /* 82221944h */ case    7:  		/* cmplwi CR6, R10, 22 */
		/* 82221944h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000016);
		/* 82221944h case    7:*/		return 0x82221948;
	}
	return 0x82221948;
} // Block from 82221928h-82221948h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82221948h
// Function '?GetSemanticName@Compiler@D3DXShader@@AAAXPADKPAVCNode@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221948);
		  /* 82221948h */ case    0:  		/* bc 12, CR6_EQ, 68 */
		/* 82221948h case    0:*/		if ( regs.CR[6].eq ) { return 0x8222198C;  }
		/* 82221948h case    0:*/		return 0x8222194C;
		  /* 8222194Ch */ case    1:  		/* cmplwi CR6, R10, 23 */
		/* 8222194Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000017);
		/* 8222194Ch case    1:*/		return 0x82221950;
		  /* 82221950h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82221950h case    2:*/		if ( regs.CR[6].eq ) { return 0x82221974;  }
		/* 82221950h case    2:*/		return 0x82221954;
		  /* 82221954h */ case    3:  		/* cmplwi CR6, R10, 24 */
		/* 82221954h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000018);
		/* 82221954h case    3:*/		return 0x82221958;
		  /* 82221958h */ case    4:  		/* bc 4, CR6_EQ, 108 */
		/* 82221958h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822219C4;  }
		/* 82221958h case    4:*/		return 0x8222195C;
		  /* 8222195Ch */ case    5:  		/* li R10, 23 */
		/* 8222195Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x17);
		/* 8222195Ch case    5:*/		return 0x82221960;
		  /* 82221960h */ case    6:  		/* li R4, 4 */
		/* 82221960h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82221960h case    6:*/		return 0x82221964;
		  /* 82221964h */ case    7:  		/* rlwimi R11, R10, 7, 18, 24 */
		/* 82221964h case    7:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R11,regs.R10);
		/* 82221964h case    7:*/		return 0x82221968;
		  /* 82221968h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 82221968h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82221968h case    8:*/		return 0x8222196C;
		  /* 8222196Ch */ case    9:  		/* lwz R3, <#[R3 + 48]> */
		/* 8222196Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 8222196Ch case    9:*/		return 0x82221970;
		  /* 82221970h */ case   10:  		/* b -695984 */
		/* 82221970h case   10:*/		return 0x82177AC0;
		/* 82221970h case   10:*/		return 0x82221974;
	}
	return 0x82221974;
} // Block from 82221948h-82221974h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82221974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221974);
		  /* 82221974h */ case    0:  		/* li R10, 3 */
		/* 82221974h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 82221974h case    0:*/		return 0x82221978;
		  /* 82221978h */ case    1:  		/* li R4, 4 */
		/* 82221978h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82221978h case    1:*/		return 0x8222197C;
		  /* 8222197Ch */ case    2:  		/* rlwimi R11, R10, 10, 18, 24 */
		/* 8222197Ch case    2:*/		cpu::op::rlwimi<0,10,18,24>(regs,&regs.R11,regs.R10);
		/* 8222197Ch case    2:*/		return 0x82221980;
		  /* 82221980h */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 82221980h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82221980h case    3:*/		return 0x82221984;
		  /* 82221984h */ case    4:  		/* lwz R3, <#[R3 + 48]> */
		/* 82221984h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82221984h case    4:*/		return 0x82221988;
		  /* 82221988h */ case    5:  		/* b -696008 */
		/* 82221988h case    5:*/		return 0x82177AC0;
		/* 82221988h case    5:*/		return 0x8222198C;
	}
	return 0x8222198C;
} // Block from 82221974h-8222198Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8222198Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222198C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222198C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222198C);
		  /* 8222198Ch */ case    0:  		/* li R10, 21 */
		/* 8222198Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x15);
		/* 8222198Ch case    0:*/		return 0x82221990;
		  /* 82221990h */ case    1:  		/* b 124 */
		/* 82221990h case    1:*/		return 0x82221A0C;
		/* 82221990h case    1:*/		return 0x82221994;
	}
	return 0x82221994;
} // Block from 8222198Ch-82221994h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221994);
		  /* 82221994h */ case    0:  		/* li R10, 11 */
		/* 82221994h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 82221994h case    0:*/		return 0x82221998;
		  /* 82221998h */ case    1:  		/* rlwimi R11, R10, 8, 18, 24 */
		/* 82221998h case    1:*/		cpu::op::rlwimi<0,8,18,24>(regs,&regs.R11,regs.R10);
		/* 82221998h case    1:*/		return 0x8222199C;
		  /* 8222199Ch */ case    2:  		/* b 116 */
		/* 8222199Ch case    2:*/		return 0x82221A10;
		/* 8222199Ch case    2:*/		return 0x822219A0;
	}
	return 0x822219A0;
} // Block from 82221994h-822219A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822219A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822219A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822219A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822219A0);
		  /* 822219A0h */ case    0:  		/* li R10, 15 */
		/* 822219A0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 822219A0h case    0:*/		return 0x822219A4;
		  /* 822219A4h */ case    1:  		/* rlwimi R11, R10, 9, 18, 24 */
		/* 822219A4h case    1:*/		cpu::op::rlwimi<0,9,18,24>(regs,&regs.R11,regs.R10);
		/* 822219A4h case    1:*/		return 0x822219A8;
		  /* 822219A8h */ case    2:  		/* b 104 */
		/* 822219A8h case    2:*/		return 0x82221A10;
		/* 822219A8h case    2:*/		return 0x822219AC;
	}
	return 0x822219AC;
} // Block from 822219A0h-822219ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822219ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822219AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822219AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822219AC);
		  /* 822219ACh */ case    0:  		/* cmplwi CR6, R10, 60 */
		/* 822219ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003C);
		/* 822219ACh case    0:*/		return 0x822219B0;
		  /* 822219B0h */ case    1:  		/* bc 12, CR6_EQ, 88 */
		/* 822219B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82221A08;  }
		/* 822219B0h case    1:*/		return 0x822219B4;
		  /* 822219B4h */ case    2:  		/* cmplwi CR6, R10, 61 */
		/* 822219B4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003D);
		/* 822219B4h case    2:*/		return 0x822219B8;
		  /* 822219B8h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 822219B8h case    3:*/		if ( regs.CR[6].eq ) { return 0x822219F0;  }
		/* 822219B8h case    3:*/		return 0x822219BC;
		  /* 822219BCh */ case    4:  		/* cmplwi CR6, R10, 62 */
		/* 822219BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003E);
		/* 822219BCh case    4:*/		return 0x822219C0;
		  /* 822219C0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 822219C0h case    5:*/		if ( regs.CR[6].eq ) { return 0x822219D8;  }
		/* 822219C0h case    5:*/		return 0x822219C4;
	}
	return 0x822219C4;
} // Block from 822219ACh-822219C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822219C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822219C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822219C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822219C4);
		  /* 822219C4h */ case    0:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 822219C4h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 822219C4h case    0:*/		return 0x822219C8;
		  /* 822219C8h */ case    1:  		/* li R4, 4800 */
		/* 822219C8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822219C8h case    1:*/		return 0x822219CC;
		  /* 822219CCh */ case    2:  		/* lwz R11, <#[R11]> */
		/* 822219CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822219CCh case    2:*/		return 0x822219D0;
		  /* 822219D0h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 822219D0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 822219D0h case    3:*/		return 0x822219D4;
		  /* 822219D4h */ case    4:  		/* b -850796 */
		/* 822219D4h case    4:*/		return 0x82151E68;
		/* 822219D4h case    4:*/		return 0x822219D8;
	}
	return 0x822219D8;
} // Block from 822219C4h-822219D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822219D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822219D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822219D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822219D8);
		  /* 822219D8h */ case    0:  		/* li R10, 61 */
		/* 822219D8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3D);
		/* 822219D8h case    0:*/		return 0x822219DC;
		  /* 822219DCh */ case    1:  		/* li R4, 4 */
		/* 822219DCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 822219DCh case    1:*/		return 0x822219E0;
		  /* 822219E0h */ case    2:  		/* rlwimi R11, R10, 7, 18, 24 */
		/* 822219E0h case    2:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R11,regs.R10);
		/* 822219E0h case    2:*/		return 0x822219E4;
		  /* 822219E4h */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 822219E4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822219E4h case    3:*/		return 0x822219E8;
		  /* 822219E8h */ case    4:  		/* lwz R3, <#[R3 + 44]> */
		/* 822219E8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000002C) );
		/* 822219E8h case    4:*/		return 0x822219EC;
		  /* 822219ECh */ case    5:  		/* b -696108 */
		/* 822219ECh case    5:*/		return 0x82177AC0;
		/* 822219ECh case    5:*/		return 0x822219F0;
	}
	return 0x822219F0;
} // Block from 822219D8h-822219F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822219F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822219F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822219F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822219F0);
		  /* 822219F0h */ case    0:  		/* li R10, 31 */
		/* 822219F0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1F);
		/* 822219F0h case    0:*/		return 0x822219F4;
		  /* 822219F4h */ case    1:  		/* li R4, 4 */
		/* 822219F4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 822219F4h case    1:*/		return 0x822219F8;
		  /* 822219F8h */ case    2:  		/* rlwimi R11, R10, 8, 18, 24 */
		/* 822219F8h case    2:*/		cpu::op::rlwimi<0,8,18,24>(regs,&regs.R11,regs.R10);
		/* 822219F8h case    2:*/		return 0x822219FC;
		  /* 822219FCh */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 822219FCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822219FCh case    3:*/		return 0x82221A00;
		  /* 82221A00h */ case    4:  		/* lwz R3, <#[R3 + 44]> */
		/* 82221A00h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000002C) );
		/* 82221A00h case    4:*/		return 0x82221A04;
		  /* 82221A04h */ case    5:  		/* b -696132 */
		/* 82221A04h case    5:*/		return 0x82177AC0;
		/* 82221A04h case    5:*/		return 0x82221A08;
	}
	return 0x82221A08;
} // Block from 822219F0h-82221A08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A08);
		  /* 82221A08h */ case    0:  		/* li R10, 59 */
		/* 82221A08h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3B);
		/* 82221A08h case    0:*/		return 0x82221A0C;
	}
	return 0x82221A0C;
} // Block from 82221A08h-82221A0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A0C);
		  /* 82221A0Ch */ case    0:  		/* rlwimi R11, R10, 7, 18, 24 */
		/* 82221A0Ch case    0:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R11,regs.R10);
		/* 82221A0Ch case    0:*/		return 0x82221A10;
	}
	return 0x82221A10;
} // Block from 82221A0Ch-82221A10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A10);
		  /* 82221A10h */ case    0:  		/* stw R11, <#[R3 + 8]> */
		/* 82221A10h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82221A10h case    0:*/		return 0x82221A14;
		  /* 82221A14h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82221A14h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221A14h case    1:*/		return 0x82221A18;
	}
	return 0x82221A18;
} // Block from 82221A10h-82221A18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221A18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A18);
		  /* 82221A18h */ case    0:  		/* mfspr R12, LR */
		/* 82221A18h case    0:*/		regs.R12 = regs.LR;
		/* 82221A18h case    0:*/		return 0x82221A1C;
		  /* 82221A1Ch */ case    1:  		/* bl -1640384 */
		/* 82221A1Ch case    1:*/		regs.LR = 0x82221A20; return 0x8209125C;
		/* 82221A1Ch case    1:*/		return 0x82221A20;
		  /* 82221A20h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82221A20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82221A20h case    2:*/		return 0x82221A24;
		  /* 82221A24h */ case    3:  		/* mr R30, R3 */
		/* 82221A24h case    3:*/		regs.R30 = regs.R3;
		/* 82221A24h case    3:*/		return 0x82221A28;
		  /* 82221A28h */ case    4:  		/* mr R31, R4 */
		/* 82221A28h case    4:*/		regs.R31 = regs.R4;
		/* 82221A28h case    4:*/		return 0x82221A2C;
		  /* 82221A2Ch */ case    5:  		/* mr R29, R5 */
		/* 82221A2Ch case    5:*/		regs.R29 = regs.R5;
		/* 82221A2Ch case    5:*/		return 0x82221A30;
		  /* 82221A30h */ case    6:  		/* bl -4232 */
		/* 82221A30h case    6:*/		regs.LR = 0x82221A34; return 0x822209A8;
		/* 82221A30h case    6:*/		return 0x82221A34;
		  /* 82221A34h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82221A34h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82221A34h case    7:*/		return 0x82221A38;
		  /* 82221A38h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82221A38h case    8:*/		if ( regs.CR[0].eq ) { return 0x82221A44;  }
		/* 82221A38h case    8:*/		return 0x82221A3C;
		  /* 82221A3Ch */ case    9:  		/* li R3, 1 */
		/* 82221A3Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82221A3Ch case    9:*/		return 0x82221A40;
		  /* 82221A40h */ case   10:  		/* b 152 */
		/* 82221A40h case   10:*/		return 0x82221AD8;
		/* 82221A40h case   10:*/		return 0x82221A44;
	}
	return 0x82221A44;
} // Block from 82221A18h-82221A44h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82221A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A44);
		  /* 82221A44h */ case    0:  		/* mr R3, R30 */
		/* 82221A44h case    0:*/		regs.R3 = regs.R30;
		/* 82221A44h case    0:*/		return 0x82221A48;
		  /* 82221A48h */ case    1:  		/* bl -724120 */
		/* 82221A48h case    1:*/		regs.LR = 0x82221A4C; return 0x82170DB0;
		/* 82221A48h case    1:*/		return 0x82221A4C;
		  /* 82221A4Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82221A4Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82221A4Ch case    2:*/		return 0x82221A50;
		  /* 82221A50h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82221A50h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82221A5C;  }
		/* 82221A50h case    3:*/		return 0x82221A54;
		  /* 82221A54h */ case    4:  		/* li R3, 0 */
		/* 82221A54h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82221A54h case    4:*/		return 0x82221A58;
		  /* 82221A58h */ case    5:  		/* b 128 */
		/* 82221A58h case    5:*/		return 0x82221AD8;
		/* 82221A58h case    5:*/		return 0x82221A5C;
	}
	return 0x82221A5C;
} // Block from 82221A44h-82221A5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A5C);
		  /* 82221A5Ch */ case    0:  		/* cmplwi CR6, R29, 228 */
		/* 82221A5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x000000E4);
		/* 82221A5Ch case    0:*/		return 0x82221A60;
		  /* 82221A60h */ case    1:  		/* bc 12, CR6_EQ, -36 */
		/* 82221A60h case    1:*/		if ( regs.CR[6].eq ) { return 0x82221A3C;  }
		/* 82221A60h case    1:*/		return 0x82221A64;
		  /* 82221A64h */ case    2:  		/* li R10, 0 */
		/* 82221A64h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221A64h case    2:*/		return 0x82221A68;
		  /* 82221A68h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82221A68h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82221A68h case    3:*/		return 0x82221A6C;
		  /* 82221A6Ch */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82221A6Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82221A94;  }
		/* 82221A6Ch case    4:*/		return 0x82221A70;
	}
	return 0x82221A70;
} // Block from 82221A5Ch-82221A70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82221A70h
// Function '?ChangeInterpolationMode@Compiler@D3DXShader@@AAA_NPAULinkageSemantics@2@I_NPAVCNode@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A70);
		  /* 82221A70h */ case    0:  		/* li R11, 0 */
		/* 82221A70h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221A70h case    0:*/		return 0x82221A74;
		  /* 82221A74h */ case    1:  		/* mtspr CTR, R31 */
		/* 82221A74h case    1:*/		regs.CTR = regs.R31;
		/* 82221A74h case    1:*/		return 0x82221A78;
		  /* 82221A78h */ case    2:  		/* srw R9, R29, R11 */
		/* 82221A78h case    2:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R11);
		/* 82221A78h case    2:*/		return 0x82221A7C;
		  /* 82221A7Ch */ case    3:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 82221A7Ch case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 82221A7Ch case    3:*/		return 0x82221A80;
		  /* 82221A80h */ case    4:  		/* li R8, 1 */
		/* 82221A80h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82221A80h case    4:*/		return 0x82221A84;
		  /* 82221A84h */ case    5:  		/* addi R11, R11, 2 */
		/* 82221A84h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82221A84h case    5:*/		return 0x82221A88;
		  /* 82221A88h */ case    6:  		/* slw R9, R8, R9 */
		/* 82221A88h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82221A88h case    6:*/		return 0x82221A8C;
		  /* 82221A8Ch */ case    7:  		/* or R10, R9, R10 */
		/* 82221A8Ch case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82221A8Ch case    7:*/		return 0x82221A90;
		  /* 82221A90h */ case    8:  		/* bc 16, CR0_LT, -24 */
		/* 82221A90h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82221A78;  }
		/* 82221A90h case    8:*/		return 0x82221A94;
	}
	return 0x82221A94;
} // Block from 82221A70h-82221A94h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82221A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221A94);
		  /* 82221A94h */ case    0:  		/* lis R11, -28311 */
		/* 82221A94h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 82221A94h case    0:*/		return 0x82221A98;
		  /* 82221A98h */ case    1:  		/* lwz R9, <#[R30 + 8]> */
		/* 82221A98h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 82221A98h case    1:*/		return 0x82221A9C;
		  /* 82221A9Ch */ case    2:  		/* lis R8, 0 */
		/* 82221A9Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 82221A9Ch case    2:*/		return 0x82221AA0;
		  /* 82221AA0h */ case    3:  		/* ori R11, R11, 5192 */
		/* 82221AA0h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 82221AA0h case    3:*/		return 0x82221AA4;
		  /* 82221AA4h */ case    4:  		/* ori R8, R8, 36262 */
		/* 82221AA4h case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x8DA6);
		/* 82221AA4h case    4:*/		return 0x82221AA8;
		  /* 82221AA8h */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 82221AA8h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82221AA8h case    5:*/		return 0x82221AAC;
		  /* 82221AACh */ case    6:  		/* rldimi R11, R8, 32, 0 */
		/* 82221AACh case    6:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R8);
		/* 82221AACh case    6:*/		return 0x82221AB0;
		  /* 82221AB0h */ case    7:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 82221AB0h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 82221AB0h case    7:*/		return 0x82221AB4;
		  /* 82221AB4h */ case    8:  		/* srd R11, R11, R10 */
		/* 82221AB4h case    8:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82221AB4h case    8:*/		return 0x82221AB8;
		  /* 82221AB8h */ case    9:  		/* srd R11, R11, R10 */
		/* 82221AB8h case    9:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82221AB8h case    9:*/		return 0x82221ABC;
		  /* 82221ABCh */ case   10:  		/* srd R11, R11, R10 */
		/* 82221ABCh case   10:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82221ABCh case   10:*/		return 0x82221AC0;
		  /* 82221AC0h */ case   11:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82221AC0h case   11:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82221AC0h case   11:*/		return 0x82221AC4;
		  /* 82221AC4h */ case   12:  		/* li R8, -1 */
		/* 82221AC4h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82221AC4h case   12:*/		return 0x82221AC8;
		  /* 82221AC8h */ case   13:  		/* subf R11, R11, R9 */
		/* 82221AC8h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82221AC8h case   13:*/		return 0x82221ACC;
		  /* 82221ACCh */ case   14:  		/* add R11, R11, R31 */
		/* 82221ACCh case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82221ACCh case   14:*/		return 0x82221AD0;
		  /* 82221AD0h */ case   15:  		/* subfic R11, R11, 4 */
		/* 82221AD0h case   15:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82221AD0h case   15:*/		return 0x82221AD4;
		  /* 82221AD4h */ case   16:  		/* subfze R3, R8 */
		/* 82221AD4h case   16:*/		cpu::op::subfze<0>(regs,&regs.R3,regs.R8);
		/* 82221AD4h case   16:*/		return 0x82221AD8;
	}
	return 0x82221AD8;
} // Block from 82221A94h-82221AD8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82221AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221AD8);
		  /* 82221AD8h */ case    0:  		/* addi R1, R1, 112 */
		/* 82221AD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82221AD8h case    0:*/		return 0x82221ADC;
		  /* 82221ADCh */ case    1:  		/* b -1640496 */
		/* 82221ADCh case    1:*/		return 0x820912AC;
		/* 82221ADCh case    1:*/		return 0x82221AE0;
	}
	return 0x82221AE0;
} // Block from 82221AD8h-82221AE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82221AE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221AE0);
		  /* 82221AE0h */ case    0:  		/* mfspr R12, LR */
		/* 82221AE0h case    0:*/		regs.R12 = regs.LR;
		/* 82221AE0h case    0:*/		return 0x82221AE4;
		  /* 82221AE4h */ case    1:  		/* bl -1640588 */
		/* 82221AE4h case    1:*/		regs.LR = 0x82221AE8; return 0x82091258;
		/* 82221AE4h case    1:*/		return 0x82221AE8;
		  /* 82221AE8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82221AE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82221AE8h case    2:*/		return 0x82221AEC;
		  /* 82221AECh */ case    3:  		/* mr R29, R3 */
		/* 82221AECh case    3:*/		regs.R29 = regs.R3;
		/* 82221AECh case    3:*/		return 0x82221AF0;
		  /* 82221AF0h */ case    4:  		/* mr R31, R4 */
		/* 82221AF0h case    4:*/		regs.R31 = regs.R4;
		/* 82221AF0h case    4:*/		return 0x82221AF4;
		  /* 82221AF4h */ case    5:  		/* mr R30, R5 */
		/* 82221AF4h case    5:*/		regs.R30 = regs.R5;
		/* 82221AF4h case    5:*/		return 0x82221AF8;
		  /* 82221AF8h */ case    6:  		/* bl -4432 */
		/* 82221AF8h case    6:*/		regs.LR = 0x82221AFC; return 0x822209A8;
		/* 82221AF8h case    6:*/		return 0x82221AFC;
		  /* 82221AFCh */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82221AFCh case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82221AFCh case    7:*/		return 0x82221B00;
	}
	return 0x82221B00;
} // Block from 82221AE0h-82221B00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82221B00h
// Function '?GetVariableRegisterComponentRange@Compiler@D3DXShader@@AAAXIIPAI0000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221B00);
		  /* 82221B00h */ case    0:  		/* bc 12, CR0_EQ, 24 */
		/* 82221B00h case    0:*/		if ( regs.CR[0].eq ) { return 0x82221B18;  }
		/* 82221B00h case    0:*/		return 0x82221B04;
		  /* 82221B04h */ case    1:  		/* lwz R11, <#[R29 + 8]> */
		/* 82221B04h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82221B04h case    1:*/		return 0x82221B08;
		  /* 82221B08h */ case    2:  		/* rlwimi R11, R31, 14, 15, 17 */
		/* 82221B08h case    2:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R31);
		/* 82221B08h case    2:*/		return 0x82221B0C;
		  /* 82221B0Ch */ case    3:  		/* stw R11, <#[R29 + 8]> */
		/* 82221B0Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82221B0Ch case    3:*/		return 0x82221B10;
		  /* 82221B10h */ case    4:  		/* addi R1, R1, 128 */
		/* 82221B10h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82221B10h case    4:*/		return 0x82221B14;
		  /* 82221B14h */ case    5:  		/* b -1640556 */
		/* 82221B14h case    5:*/		return 0x820912A8;
		/* 82221B14h case    5:*/		return 0x82221B18;
	}
	return 0x82221B18;
} // Block from 82221B00h-82221B18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221B18);
		  /* 82221B18h */ case    0:  		/* li R11, 0 */
		/* 82221B18h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221B18h case    0:*/		return 0x82221B1C;
		  /* 82221B1Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82221B1Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82221B1Ch case    1:*/		return 0x82221B20;
		  /* 82221B20h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 82221B20h case    2:*/		if ( regs.CR[6].eq ) { return 0x82221B48;  }
		/* 82221B20h case    2:*/		return 0x82221B24;
		  /* 82221B24h */ case    3:  		/* li R10, 0 */
		/* 82221B24h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221B24h case    3:*/		return 0x82221B28;
		  /* 82221B28h */ case    4:  		/* mtspr CTR, R31 */
		/* 82221B28h case    4:*/		regs.CTR = regs.R31;
		/* 82221B28h case    4:*/		return 0x82221B2C;
		  /* 82221B2Ch */ case    5:  		/* srw R9, R30, R10 */
		/* 82221B2Ch case    5:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R30,regs.R10);
		/* 82221B2Ch case    5:*/		return 0x82221B30;
		  /* 82221B30h */ case    6:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 82221B30h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 82221B30h case    6:*/		return 0x82221B34;
		  /* 82221B34h */ case    7:  		/* li R8, 1 */
		/* 82221B34h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82221B34h case    7:*/		return 0x82221B38;
		  /* 82221B38h */ case    8:  		/* addi R10, R10, 2 */
		/* 82221B38h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82221B38h case    8:*/		return 0x82221B3C;
		  /* 82221B3Ch */ case    9:  		/* slw R9, R8, R9 */
		/* 82221B3Ch case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82221B3Ch case    9:*/		return 0x82221B40;
		  /* 82221B40h */ case   10:  		/* or R11, R9, R11 */
		/* 82221B40h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82221B40h case   10:*/		return 0x82221B44;
		  /* 82221B44h */ case   11:  		/* bc 16, CR0_LT, -24 */
		/* 82221B44h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82221B2C;  }
		/* 82221B44h case   11:*/		return 0x82221B48;
	}
	return 0x82221B48;
} // Block from 82221B18h-82221B48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82221B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221B48);
		  /* 82221B48h */ case    0:  		/* lis R10, -28311 */
		/* 82221B48h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 82221B48h case    0:*/		return 0x82221B4C;
		  /* 82221B4Ch */ case    1:  		/* lwz R9, <#[R29 + 8]> */
		/* 82221B4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 82221B4Ch case    1:*/		return 0x82221B50;
		  /* 82221B50h */ case    2:  		/* lis R8, 0 */
		/* 82221B50h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 82221B50h case    2:*/		return 0x82221B54;
		  /* 82221B54h */ case    3:  		/* ori R10, R10, 5192 */
		/* 82221B54h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82221B54h case    3:*/		return 0x82221B58;
		  /* 82221B58h */ case    4:  		/* ori R8, R8, 36262 */
		/* 82221B58h case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x8DA6);
		/* 82221B58h case    4:*/		return 0x82221B5C;
		  /* 82221B5Ch */ case    5:  		/* rldicl R7, R11, 0, 32 */
		/* 82221B5Ch case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R11);
		/* 82221B5Ch case    5:*/		return 0x82221B60;
		  /* 82221B60h */ case    6:  		/* rldimi R10, R8, 32, 0 */
		/* 82221B60h case    6:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R8);
		/* 82221B60h case    6:*/		return 0x82221B64;
		  /* 82221B64h */ case    7:  		/* rlwinm R6, R9, 18, 29, 31 */
		/* 82221B64h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R9);
		/* 82221B64h case    7:*/		return 0x82221B68;
		  /* 82221B68h */ case    8:  		/* srd R10, R10, R7 */
		/* 82221B68h case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82221B68h case    8:*/		return 0x82221B6C;
		  /* 82221B6Ch */ case    9:  		/* srd R10, R10, R7 */
		/* 82221B6Ch case    9:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82221B6Ch case    9:*/		return 0x82221B70;
		  /* 82221B70h */ case   10:  		/* srd R10, R10, R7 */
		/* 82221B70h case   10:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82221B70h case   10:*/		return 0x82221B74;
		  /* 82221B74h */ case   11:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82221B74h case   11:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82221B74h case   11:*/		return 0x82221B78;
		  /* 82221B78h */ case   12:  		/* rlwinm R8, R9, 31, 28, 31 */
		/* 82221B78h case   12:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R8,regs.R9);
		/* 82221B78h case   12:*/		return 0x82221B7C;
		  /* 82221B7Ch */ case   13:  		/* subf R10, R10, R6 */
		/* 82221B7Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 82221B7Ch case   13:*/		return 0x82221B80;
		  /* 82221B80h */ case   14:  		/* mr R7, R30 */
		/* 82221B80h case   14:*/		regs.R7 = regs.R30;
		/* 82221B80h case   14:*/		return 0x82221B84;
		  /* 82221B84h */ case   15:  		/* add R6, R10, R31 */
		/* 82221B84h case   15:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R31);
		/* 82221B84h case   15:*/		return 0x82221B88;
		  /* 82221B88h */ case   16:  		/* subf R11, R11, R8 */
		/* 82221B88h case   16:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82221B88h case   16:*/		return 0x82221B8C;
		  /* 82221B8Ch */ case   17:  		/* rlwinm R10, R31, 1, 0, 30 */
		/* 82221B8Ch case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R31);
		/* 82221B8Ch case   17:*/		return 0x82221B90;
		  /* 82221B90h */ case   18:  		/* li R4, 3 */
		/* 82221B90h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82221B90h case   18:*/		return 0x82221B94;
		  /* 82221B94h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82221B94h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82221B94h case   19:*/		return 0x82221B98;
		  /* 82221B98h */ case   20:  		/* bc 12, CR6_EQ, 56 */
		/* 82221B98h case   20:*/		if ( regs.CR[6].eq ) { return 0x82221BD0;  }
		/* 82221B98h case   20:*/		return 0x82221B9C;
		  /* 82221B9Ch */ case   21:  		/* addi R5, R11, -1 */
		/* 82221B9Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFFF);
		/* 82221B9Ch case   21:*/		return 0x82221BA0;
		  /* 82221BA0h */ case   22:  		/* slw R3, R4, R10 */
		/* 82221BA0h case   22:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R4,regs.R10);
		/* 82221BA0h case   22:*/		return 0x82221BA4;
		  /* 82221BA4h */ case   23:  		/* andc R5, R11, R5 */
		/* 82221BA4h case   23:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 82221BA4h case   23:*/		return 0x82221BA8;
		  /* 82221BA8h */ case   24:  		/* addi R31, R11, -1 */
		/* 82221BA8h case   24:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82221BA8h case   24:*/		return 0x82221BAC;
		  /* 82221BACh */ case   25:  		/* cntlzw R5, R5 */
		/* 82221BACh case   25:*/		cpu::op::cntlzw<0>(regs,&regs.R5,regs.R5);
		/* 82221BACh case   25:*/		return 0x82221BB0;
		  /* 82221BB0h */ case   26:  		/* andc R7, R7, R3 */
		/* 82221BB0h case   26:*/		cpu::op::andc<0>(regs,&regs.R7,regs.R7,regs.R3);
		/* 82221BB0h case   26:*/		return 0x82221BB4;
		  /* 82221BB4h */ case   27:  		/* subfic R5, R5, 31 */
		/* 82221BB4h case   27:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R5,0x1F);
		/* 82221BB4h case   27:*/		return 0x82221BB8;
		  /* 82221BB8h */ case   28:  		/* andc R3, R11, R31 */
		/* 82221BB8h case   28:*/		cpu::op::andc<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 82221BB8h case   28:*/		return 0x82221BBC;
		  /* 82221BBCh */ case   29:  		/* slw R5, R5, R10 */
		/* 82221BBCh case   29:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R5,regs.R10);
		/* 82221BBCh case   29:*/		return 0x82221BC0;
		  /* 82221BC0h */ case   30:  		/* or R7, R7, R5 */
		/* 82221BC0h case   30:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R5);
		/* 82221BC0h case   30:*/		return 0x82221BC4;
		  /* 82221BC4h */ case   31:  		/* addi R10, R10, 2 */
		/* 82221BC4h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82221BC4h case   31:*/		return 0x82221BC8;
		  /* 82221BC8h */ case   32:  		/* subf R11, R3, R11 */
		/* 82221BC8h case   32:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82221BC8h case   32:*/		return 0x82221BCC;
		  /* 82221BCCh */ case   33:  		/* b -56 */
		/* 82221BCCh case   33:*/		return 0x82221B94;
		/* 82221BCCh case   33:*/		return 0x82221BD0;
	}
	return 0x82221BD0;
} // Block from 82221B48h-82221BD0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82221BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221BD0);
		  /* 82221BD0h */ case    0:  		/* li R3, 0 */
		/* 82221BD0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82221BD0h case    0:*/		return 0x82221BD4;
		  /* 82221BD4h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 82221BD4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82221BD4h case    1:*/		return 0x82221BD8;
		  /* 82221BD8h */ case    2:  		/* li R11, 0 */
		/* 82221BD8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221BD8h case    2:*/		return 0x82221BDC;
		  /* 82221BDCh */ case    3:  		/* bc 12, CR6_EQ, 104 */
		/* 82221BDCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82221C44;  }
		/* 82221BDCh case    3:*/		return 0x82221BE0;
		  /* 82221BE0h */ case    4:  		/* addi R10, R8, -1 */
		/* 82221BE0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFF);
		/* 82221BE0h case    4:*/		return 0x82221BE4;
		  /* 82221BE4h */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 82221BE4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82221BE4h case    5:*/		return 0x82221BE8;
		  /* 82221BE8h */ case    6:  		/* andc R10, R8, R10 */
		/* 82221BE8h case    6:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82221BE8h case    6:*/		return 0x82221BEC;
		  /* 82221BECh */ case    7:  		/* cntlzw R10, R10 */
		/* 82221BECh case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82221BECh case    7:*/		return 0x82221BF0;
		  /* 82221BF0h */ case    8:  		/* subfic R5, R10, 31 */
		/* 82221BF0h case    8:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R10,0x1F);
		/* 82221BF0h case    8:*/		return 0x82221BF4;
		  /* 82221BF4h */ case    9:  		/* bc 12, CR6_EQ, 64 */
		/* 82221BF4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82221C34;  }
		/* 82221BF4h case    9:*/		return 0x82221BF8;
		  /* 82221BF8h */ case   10:  		/* li R10, 0 */
		/* 82221BF8h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221BF8h case   10:*/		return 0x82221BFC;
		  /* 82221BFCh */ case   11:  		/* srw R31, R7, R10 */
		/* 82221BFCh case   11:*/		cpu::op::srw<0>(regs,&regs.R31,regs.R7,regs.R10);
		/* 82221BFCh case   11:*/		return 0x82221C00;
		  /* 82221C00h */ case   12:  		/* rlwinm R31, R31, 0, 30, 31 */
		/* 82221C00h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R31);
		/* 82221C00h case   12:*/		return 0x82221C04;
		  /* 82221C04h */ case   13:  		/* cmpw CR6, R5, R31 */
		/* 82221C04h case   13:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R31);
		/* 82221C04h case   13:*/		return 0x82221C08;
		  /* 82221C08h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 82221C08h case   14:*/		if ( regs.CR[6].eq ) { return 0x82221C20;  }
		/* 82221C08h case   14:*/		return 0x82221C0C;
		  /* 82221C0Ch */ case   15:  		/* addi R11, R11, 1 */
		/* 82221C0Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82221C0Ch case   15:*/		return 0x82221C10;
		  /* 82221C10h */ case   16:  		/* addi R10, R10, 2 */
		/* 82221C10h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82221C10h case   16:*/		return 0x82221C14;
		  /* 82221C14h */ case   17:  		/* cmplw CR6, R11, R6 */
		/* 82221C14h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82221C14h case   17:*/		return 0x82221C18;
		  /* 82221C18h */ case   18:  		/* bc 12, CR6_LT, -28 */
		/* 82221C18h case   18:*/		if ( regs.CR[6].lt ) { return 0x82221BFC;  }
		/* 82221C18h case   18:*/		return 0x82221C1C;
		  /* 82221C1Ch */ case   19:  		/* b 24 */
		/* 82221C1Ch case   19:*/		return 0x82221C34;
		/* 82221C1Ch case   19:*/		return 0x82221C20;
	}
	return 0x82221C20;
} // Block from 82221BD0h-82221C20h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82221C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221C20);
		  /* 82221C20h */ case    0:  		/* rlwinm R10, R5, 1, 0, 30 */
		/* 82221C20h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R5);
		/* 82221C20h case    0:*/		return 0x82221C24;
		  /* 82221C24h */ case    1:  		/* slw R5, R4, R10 */
		/* 82221C24h case    1:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R4,regs.R10);
		/* 82221C24h case    1:*/		return 0x82221C28;
		  /* 82221C28h */ case    2:  		/* slw R11, R11, R10 */
		/* 82221C28h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82221C28h case    2:*/		return 0x82221C2C;
		  /* 82221C2Ch */ case    3:  		/* andc R10, R3, R5 */
		/* 82221C2Ch case    3:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R3,regs.R5);
		/* 82221C2Ch case    3:*/		return 0x82221C30;
		  /* 82221C30h */ case    4:  		/* or R3, R10, R11 */
		/* 82221C30h case    4:*/		cpu::op::or<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82221C30h case    4:*/		return 0x82221C34;
	}
	return 0x82221C34;
} // Block from 82221C20h-82221C34h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82221C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221C34);
		  /* 82221C34h */ case    0:  		/* addi R11, R8, -1 */
		/* 82221C34h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 82221C34h case    0:*/		return 0x82221C38;
		  /* 82221C38h */ case    1:  		/* andc R11, R8, R11 */
		/* 82221C38h case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82221C38h case    1:*/		return 0x82221C3C;
		  /* 82221C3Ch */ case    2:  		/* subf R8, R11, R8 */
		/* 82221C3Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 82221C3Ch case    2:*/		return 0x82221C40;
	}
	return 0x82221C40;
} // Block from 82221C34h-82221C40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82221C40h
// Function '?CacheVariableRegisterInstr@Compiler@D3DXShader@@AAAXPAUVariable@2@IIIPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221C40);
		  /* 82221C40h */ case    0:  		/* b -108 */
		/* 82221C40h case    0:*/		return 0x82221BD4;
		/* 82221C40h case    0:*/		return 0x82221C44;
	}
	return 0x82221C44;
} // Block from 82221C40h-82221C44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221C44);
		  /* 82221C44h */ case    0:  		/* rlwimi R9, R6, 14, 15, 17 */
		/* 82221C44h case    0:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R6);
		/* 82221C44h case    0:*/		return 0x82221C48;
		  /* 82221C48h */ case    1:  		/* rlwinm R8, R6, 0, 29, 31 */
		/* 82221C48h case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R8,regs.R6);
		/* 82221C48h case    1:*/		return 0x82221C4C;
		  /* 82221C4Ch */ case    2:  		/* stw R9, <#[R29 + 8]> */
		/* 82221C4Ch case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 82221C4Ch case    2:*/		return 0x82221C50;
		  /* 82221C50h */ case    3:  		/* addi R10, R29, 40 */
		/* 82221C50h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x28);
		/* 82221C50h case    3:*/		return 0x82221C54;
		  /* 82221C54h */ case    4:  		/* lwz R9, <#[R29 + 8]> */
		/* 82221C54h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 82221C54h case    4:*/		return 0x82221C58;
		  /* 82221C58h */ case    5:  		/* rlwinm R9, R9, 13, 29, 31 */
		/* 82221C58h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R9,regs.R9);
		/* 82221C58h case    5:*/		return 0x82221C5C;
		  /* 82221C5Ch */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 82221C5Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82221C5Ch case    6:*/		return 0x82221C60;
		  /* 82221C60h */ case    7:  		/* bc 4, CR6_LT, 100 */
		/* 82221C60h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82221CC4;  }
		/* 82221C60h case    7:*/		return 0x82221C64;
		  /* 82221C64h */ case    8:  		/* lwzu R9, <#[R10 + 4]> */
		/* 82221C64h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82221C64h case    8:*/		return 0x82221C68;
		  /* 82221C68h */ case    9:  		/* rlwinm R6, R8, 25, 0, 6 */
		/* 82221C68h case    9:*/		cpu::op::rlwinm<0,25,0,6>(regs,&regs.R6,regs.R8);
		/* 82221C68h case    9:*/		return 0x82221C6C;
		  /* 82221C6Ch */ case   10:  		/* rlwinm R5, R7, 27, 29, 30 */
		/* 82221C6Ch case   10:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R5,regs.R7);
		/* 82221C6Ch case   10:*/		return 0x82221C70;
		  /* 82221C70h */ case   11:  		/* rlwinm R4, R7, 29, 29, 30 */
		/* 82221C70h case   11:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R4,regs.R7);
		/* 82221C70h case   11:*/		return 0x82221C74;
		  /* 82221C74h */ case   12:  		/* rlwinm R31, R7, 31, 29, 30 */
		/* 82221C74h case   12:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R31,regs.R7);
		/* 82221C74h case   12:*/		return 0x82221C78;
		  /* 82221C78h */ case   13:  		/* rlwinm R30, R7, 1, 29, 30 */
		/* 82221C78h case   13:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R30,regs.R7);
		/* 82221C78h case   13:*/		return 0x82221C7C;
		  /* 82221C7Ch */ case   14:  		/* lwz R28, <#[R9]> */
		/* 82221C7Ch case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + 0x00000000) );
		/* 82221C7Ch case   14:*/		return 0x82221C80;
		  /* 82221C80h */ case   15:  		/* addi R11, R11, 1 */
		/* 82221C80h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82221C80h case   15:*/		return 0x82221C84;
		  /* 82221C84h */ case   16:  		/* rlwinm R28, R28, 0, 7, 3 */
		/* 82221C84h case   16:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R28,regs.R28);
		/* 82221C84h case   16:*/		return 0x82221C88;
		  /* 82221C88h */ case   17:  		/* or R6, R28, R6 */
		/* 82221C88h case   17:*/		cpu::op::or<0>(regs,&regs.R6,regs.R28,regs.R6);
		/* 82221C88h case   17:*/		return 0x82221C8C;
		  /* 82221C8Ch */ case   18:  		/* rlwinm R28, R6, 27, 24, 31 */
		/* 82221C8Ch case   18:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R28,regs.R6);
		/* 82221C8Ch case   18:*/		return 0x82221C90;
		  /* 82221C90h */ case   19:  		/* rlwinm R6, R6, 0, 27, 18 */
		/* 82221C90h case   19:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R6,regs.R6);
		/* 82221C90h case   19:*/		return 0x82221C94;
		  /* 82221C94h */ case   20:  		/* srw R5, R28, R5 */
		/* 82221C94h case   20:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R28,regs.R5);
		/* 82221C94h case   20:*/		return 0x82221C98;
		  /* 82221C98h */ case   21:  		/* srw R4, R28, R4 */
		/* 82221C98h case   21:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R28,regs.R4);
		/* 82221C98h case   21:*/		return 0x82221C9C;
		  /* 82221C9Ch */ case   22:  		/* rlwimi R4, R5, 2, 28, 29 */
		/* 82221C9Ch case   22:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R4,regs.R5);
		/* 82221C9Ch case   22:*/		return 0x82221CA0;
		  /* 82221CA0h */ case   23:  		/* srw R5, R28, R31 */
		/* 82221CA0h case   23:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R28,regs.R31);
		/* 82221CA0h case   23:*/		return 0x82221CA4;
		  /* 82221CA4h */ case   24:  		/* rlwinm R4, R4, 0, 28, 31 */
		/* 82221CA4h case   24:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R4,regs.R4);
		/* 82221CA4h case   24:*/		return 0x82221CA8;
		  /* 82221CA8h */ case   25:  		/* srw R31, R28, R30 */
		/* 82221CA8h case   25:*/		cpu::op::srw<0>(regs,&regs.R31,regs.R28,regs.R30);
		/* 82221CA8h case   25:*/		return 0x82221CAC;
		  /* 82221CACh */ case   26:  		/* rlwimi R5, R4, 2, 0, 29 */
		/* 82221CACh case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R5,regs.R4);
		/* 82221CACh case   26:*/		return 0x82221CB0;
		  /* 82221CB0h */ case   27:  		/* rlwimi R31, R5, 2, 0, 29 */
		/* 82221CB0h case   27:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R31,regs.R5);
		/* 82221CB0h case   27:*/		return 0x82221CB4;
		  /* 82221CB4h */ case   28:  		/* rlwinm R5, R31, 5, 0, 26 */
		/* 82221CB4h case   28:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R5,regs.R31);
		/* 82221CB4h case   28:*/		return 0x82221CB8;
		  /* 82221CB8h */ case   29:  		/* or R6, R5, R6 */
		/* 82221CB8h case   29:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 82221CB8h case   29:*/		return 0x82221CBC;
		  /* 82221CBCh */ case   30:  		/* stw R6, <#[R9]> */
		/* 82221CBCh case   30:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 82221CBCh case   30:*/		return 0x82221CC0;
		  /* 82221CC0h */ case   31:  		/* b -108 */
		/* 82221CC0h case   31:*/		return 0x82221C54;
		/* 82221CC0h case   31:*/		return 0x82221CC4;
	}
	return 0x82221CC4;
} // Block from 82221C44h-82221CC4h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82221CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221CC4);
		  /* 82221CC4h */ case    0:  		/* lwz R10, <#[R29 + 4]> */
		/* 82221CC4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 82221CC4h case    0:*/		return 0x82221CC8;
		  /* 82221CC8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82221CC8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82221CC8h case    1:*/		return 0x82221CCC;
		  /* 82221CCCh */ case    2:  		/* bc 12, CR6_EQ, -444 */
		/* 82221CCCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82221B10;  }
		/* 82221CCCh case    2:*/		return 0x82221CD0;
		  /* 82221CD0h */ case    3:  		/* lwz R11, <#[R10 + 16]> */
		/* 82221CD0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82221CD0h case    3:*/		return 0x82221CD4;
		  /* 82221CD4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82221CD4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82221CD4h case    4:*/		return 0x82221CD8;
		  /* 82221CD8h */ case    5:  		/* bc 12, CR6_EQ, 80 */
		/* 82221CD8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82221D28;  }
		/* 82221CD8h case    5:*/		return 0x82221CDC;
		  /* 82221CDCh */ case    6:  		/* lwz R11, <#[R10]> */
		/* 82221CDCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82221CDCh case    6:*/		return 0x82221CE0;
		  /* 82221CE0h */ case    7:  		/* rlwinm. R9, R11, 0, 4, 6 */
		/* 82221CE0h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R11);
		/* 82221CE0h case    7:*/		return 0x82221CE4;
		  /* 82221CE4h */ case    8:  		/* bc 12, CR0_EQ, 68 */
		/* 82221CE4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82221D28;  }
		/* 82221CE4h case    8:*/		return 0x82221CE8;
		  /* 82221CE8h */ case    9:  		/* rlwinm R9, R11, 22, 29, 30 */
		/* 82221CE8h case    9:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R11);
		/* 82221CE8h case    9:*/		return 0x82221CEC;
		  /* 82221CECh */ case   10:  		/* rlwinm R8, R11, 24, 29, 30 */
		/* 82221CECh case   10:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R11);
		/* 82221CECh case   10:*/		return 0x82221CF0;
		  /* 82221CF0h */ case   11:  		/* srw R9, R3, R9 */
		/* 82221CF0h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 82221CF0h case   11:*/		return 0x82221CF4;
		  /* 82221CF4h */ case   12:  		/* srw R8, R3, R8 */
		/* 82221CF4h case   12:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R3,regs.R8);
		/* 82221CF4h case   12:*/		return 0x82221CF8;
		  /* 82221CF8h */ case   13:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82221CF8h case   13:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82221CF8h case   13:*/		return 0x82221CFC;
		  /* 82221CFCh */ case   14:  		/* rlwinm R9, R11, 26, 29, 30 */
		/* 82221CFCh case   14:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R11);
		/* 82221CFCh case   14:*/		return 0x82221D00;
	}
	return 0x82221D00;
} // Block from 82221CC4h-82221D00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82221D00h
// Function '?DetectOrReportDuplicateSemantic@Compiler@D3DXShader@@QAA_NULinkageSemantics@2@PAVComponentTypeEnumerator@2@PAUVariable@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221D00);
		  /* 82221D00h */ case    0:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 82221D00h case    0:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 82221D00h case    0:*/		return 0x82221D04;
		  /* 82221D04h */ case    1:  		/* srw R9, R3, R9 */
		/* 82221D04h case    1:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 82221D04h case    1:*/		return 0x82221D08;
		  /* 82221D08h */ case    2:  		/* rlwinm R7, R11, 28, 29, 30 */
		/* 82221D08h case    2:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R11);
		/* 82221D08h case    2:*/		return 0x82221D0C;
		  /* 82221D0Ch */ case    3:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 82221D0Ch case    3:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82221D0Ch case    3:*/		return 0x82221D10;
		  /* 82221D10h */ case    4:  		/* srw R8, R3, R7 */
		/* 82221D10h case    4:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R3,regs.R7);
		/* 82221D10h case    4:*/		return 0x82221D14;
		  /* 82221D14h */ case    5:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 82221D14h case    5:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82221D14h case    5:*/		return 0x82221D18;
		  /* 82221D18h */ case    6:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82221D18h case    6:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82221D18h case    6:*/		return 0x82221D1C;
		  /* 82221D1Ch */ case    7:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 82221D1Ch case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 82221D1Ch case    7:*/		return 0x82221D20;
		  /* 82221D20h */ case    8:  		/* or R11, R9, R11 */
		/* 82221D20h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82221D20h case    8:*/		return 0x82221D24;
		  /* 82221D24h */ case    9:  		/* stw R11, <#[R10]> */
		/* 82221D24h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82221D24h case    9:*/		return 0x82221D28;
	}
	return 0x82221D28;
} // Block from 82221D00h-82221D28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82221D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221D28);
		  /* 82221D28h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82221D28h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82221D28h case    0:*/		return 0x82221D2C;
		  /* 82221D2Ch */ case    1:  		/* b -100 */
		/* 82221D2Ch case    1:*/		return 0x82221CC8;
		/* 82221D2Ch case    1:*/		return 0x82221D30;
		  /* 82221D30h */ case    2:  		/* li R8, 4 */
		/* 82221D30h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82221D30h case    2:*/		return 0x82221D34;
		  /* 82221D34h */ case    3:  		/* li R9, 0 */
		/* 82221D34h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82221D34h case    3:*/		return 0x82221D38;
		  /* 82221D38h */ case    4:  		/* li R10, 0 */
		/* 82221D38h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221D38h case    4:*/		return 0x82221D3C;
		  /* 82221D3Ch */ case    5:  		/* li R11, 0 */
		/* 82221D3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221D3Ch case    5:*/		return 0x82221D40;
		  /* 82221D40h */ case    6:  		/* mtspr CTR, R8 */
		/* 82221D40h case    6:*/		regs.CTR = regs.R8;
		/* 82221D40h case    6:*/		return 0x82221D44;
		  /* 82221D44h */ case    7:  		/* srw R8, R3, R11 */
		/* 82221D44h case    7:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R3,regs.R11);
		/* 82221D44h case    7:*/		return 0x82221D48;
		  /* 82221D48h */ case    8:  		/* add R8, R8, R10 */
		/* 82221D48h case    8:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82221D48h case    8:*/		return 0x82221D4C;
		  /* 82221D4Ch */ case    9:  		/* li R7, 3 */
		/* 82221D4Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 82221D4Ch case    9:*/		return 0x82221D50;
		  /* 82221D50h */ case   10:  		/* rlwinm R8, R8, 0, 30, 31 */
		/* 82221D50h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R8);
		/* 82221D50h case   10:*/		return 0x82221D54;
		  /* 82221D54h */ case   11:  		/* slw R7, R7, R11 */
		/* 82221D54h case   11:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 82221D54h case   11:*/		return 0x82221D58;
		  /* 82221D58h */ case   12:  		/* slw R8, R8, R11 */
		/* 82221D58h case   12:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 82221D58h case   12:*/		return 0x82221D5C;
		  /* 82221D5Ch */ case   13:  		/* andc R9, R9, R7 */
		/* 82221D5Ch case   13:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82221D5Ch case   13:*/		return 0x82221D60;
		  /* 82221D60h */ case   14:  		/* addi R10, R10, 1 */
		/* 82221D60h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82221D60h case   14:*/		return 0x82221D64;
		  /* 82221D64h */ case   15:  		/* or R9, R8, R9 */
		/* 82221D64h case   15:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82221D64h case   15:*/		return 0x82221D68;
		  /* 82221D68h */ case   16:  		/* addi R11, R11, 2 */
		/* 82221D68h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82221D68h case   16:*/		return 0x82221D6C;
		  /* 82221D6Ch */ case   17:  		/* bc 16, CR0_LT, -40 */
		/* 82221D6Ch case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82221D44;  }
		/* 82221D6Ch case   17:*/		return 0x82221D70;
		  /* 82221D70h */ case   18:  		/* mr R3, R9 */
		/* 82221D70h case   18:*/		regs.R3 = regs.R9;
		/* 82221D70h case   18:*/		return 0x82221D74;
		  /* 82221D74h */ case   19:  		/* bclr 20, CR0_LT */
		/* 82221D74h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82221D74h case   19:*/		return 0x82221D78;
	}
	return 0x82221D78;
} // Block from 82221D28h-82221D78h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82221D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221D78);
		  /* 82221D78h */ case    0:  		/* mfspr R12, LR */
		/* 82221D78h case    0:*/		regs.R12 = regs.LR;
		/* 82221D78h case    0:*/		return 0x82221D7C;
		  /* 82221D7Ch */ case    1:  		/* bl -1641264 */
		/* 82221D7Ch case    1:*/		regs.LR = 0x82221D80; return 0x8209124C;
		/* 82221D7Ch case    1:*/		return 0x82221D80;
		  /* 82221D80h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82221D80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82221D80h case    2:*/		return 0x82221D84;
		  /* 82221D84h */ case    3:  		/* addi R11, R4, 11 */
		/* 82221D84h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xB);
		/* 82221D84h case    3:*/		return 0x82221D88;
		  /* 82221D88h */ case    4:  		/* mr R29, R3 */
		/* 82221D88h case    4:*/		regs.R29 = regs.R3;
		/* 82221D88h case    4:*/		return 0x82221D8C;
		  /* 82221D8Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82221D8Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82221D8Ch case    5:*/		return 0x82221D90;
		  /* 82221D90h */ case    6:  		/* mr R25, R5 */
		/* 82221D90h case    6:*/		regs.R25 = regs.R5;
		/* 82221D90h case    6:*/		return 0x82221D94;
		  /* 82221D94h */ case    7:  		/* mr R26, R7 */
		/* 82221D94h case    7:*/		regs.R26 = regs.R7;
		/* 82221D94h case    7:*/		return 0x82221D98;
		  /* 82221D98h */ case    8:  		/* lwzx R27, <#[R11 + R3]> */
		/* 82221D98h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82221D98h case    8:*/		return 0x82221D9C;
		  /* 82221D9Ch */ case    9:  		/* lwz R11, <#[R27]> */
		/* 82221D9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82221D9Ch case    9:*/		return 0x82221DA0;
		  /* 82221DA0h */ case   10:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82221DA0h case   10:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82221DA0h case   10:*/		return 0x82221DA4;
		  /* 82221DA4h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 82221DA4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82221DB4;  }
		/* 82221DA4h case   11:*/		return 0x82221DA8;
		  /* 82221DA8h */ case   12:  		/* lwz R11, <#[R7]> */
		/* 82221DA8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82221DA8h case   12:*/		return 0x82221DAC;
		  /* 82221DACh */ case   13:  		/* ori R11, R11, 1 */
		/* 82221DACh case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82221DACh case   13:*/		return 0x82221DB0;
		  /* 82221DB0h */ case   14:  		/* stw R11, <#[R7]> */
		/* 82221DB0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82221DB0h case   14:*/		return 0x82221DB4;
	}
	return 0x82221DB4;
} // Block from 82221D78h-82221DB4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82221DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221DB4);
		  /* 82221DB4h */ case    0:  		/* lwz R28, <#[R27]> */
		/* 82221DB4h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x00000000) );
		/* 82221DB4h case    0:*/		return 0x82221DB8;
		  /* 82221DB8h */ case    1:  		/* mr R3, R29 */
		/* 82221DB8h case    1:*/		regs.R3 = regs.R29;
		/* 82221DB8h case    1:*/		return 0x82221DBC;
		  /* 82221DBCh */ case    2:  		/* li R31, 0 */
		/* 82221DBCh case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82221DBCh case    2:*/		return 0x82221DC0;
		  /* 82221DC0h */ case    3:  		/* rlwinm R30, R28, 7, 29, 31 */
		/* 82221DC0h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R30,regs.R28);
		/* 82221DC0h case    3:*/		return 0x82221DC4;
		  /* 82221DC4h */ case    4:  		/* bl -724924 */
		/* 82221DC4h case    4:*/		regs.LR = 0x82221DC8; return 0x82170E08;
		/* 82221DC4h case    4:*/		return 0x82221DC8;
	}
	return 0x82221DC8;
} // Block from 82221DB4h-82221DC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82221DC8h
// Function '??0Instruction@D3DXShader@@QAA@W4Opcode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221DC8);
		  /* 82221DC8h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82221DC8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82221DC8h case    0:*/		return 0x82221DCC;
		  /* 82221DCCh */ case    1:  		/* bc 12, CR0_EQ, 236 */
		/* 82221DCCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82221EB8;  }
		/* 82221DCCh case    1:*/		return 0x82221DD0;
		  /* 82221DD0h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 82221DD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82221DD0h case    2:*/		return 0x82221DD4;
		  /* 82221DD4h */ case    3:  		/* rlwinm. R6, R11, 31, 28, 31 */
		/* 82221DD4h case    3:*/		cpu::op::rlwinm<1,31,28,31>(regs,&regs.R6,regs.R11);
		/* 82221DD4h case    3:*/		return 0x82221DD8;
		  /* 82221DD8h */ case    4:  		/* mr R11, R6 */
		/* 82221DD8h case    4:*/		regs.R11 = regs.R6;
		/* 82221DD8h case    4:*/		return 0x82221DDC;
		  /* 82221DDCh */ case    5:  		/* bc 12, CR0_EQ, 344 */
		/* 82221DDCh case    5:*/		if ( regs.CR[0].eq ) { return 0x82221F34;  }
		/* 82221DDCh case    5:*/		return 0x82221DE0;
		  /* 82221DE0h */ case    6:  		/* li R8, 0 */
		/* 82221DE0h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82221DE0h case    6:*/		return 0x82221DE4;
		  /* 82221DE4h */ case    7:  		/* li R10, 0 */
		/* 82221DE4h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221DE4h case    7:*/		return 0x82221DE8;
		  /* 82221DE8h */ case    8:  		/* cmplw CR6, R8, R30 */
		/* 82221DE8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R30);
		/* 82221DE8h case    8:*/		return 0x82221DEC;
		  /* 82221DECh */ case    9:  		/* bc 4, CR6_LT, 64 */
		/* 82221DECh case    9:*/		if ( !regs.CR[6].lt ) { return 0x82221E2C;  }
		/* 82221DECh case    9:*/		return 0x82221DF0;
		  /* 82221DF0h */ case   10:  		/* addi R9, R11, -1 */
		/* 82221DF0h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 82221DF0h case   10:*/		return 0x82221DF4;
		  /* 82221DF4h */ case   11:  		/* rlwinm R7, R28, 27, 24, 31 */
		/* 82221DF4h case   11:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R28);
		/* 82221DF4h case   11:*/		return 0x82221DF8;
		  /* 82221DF8h */ case   12:  		/* andc R9, R11, R9 */
		/* 82221DF8h case   12:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82221DF8h case   12:*/		return 0x82221DFC;
		  /* 82221DFCh */ case   13:  		/* srw R7, R7, R10 */
		/* 82221DFCh case   13:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82221DFCh case   13:*/		return 0x82221E00;
		  /* 82221E00h */ case   14:  		/* cntlzw R5, R9 */
		/* 82221E00h case   14:*/		cpu::op::cntlzw<0>(regs,&regs.R5,regs.R9);
		/* 82221E00h case   14:*/		return 0x82221E04;
		  /* 82221E04h */ case   15:  		/* subf. R11, R9, R11 */
		/* 82221E04h case   15:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82221E04h case   15:*/		return 0x82221E08;
		  /* 82221E08h */ case   16:  		/* subfic R9, R5, 31 */
		/* 82221E08h case   16:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R5,0x1F);
		/* 82221E08h case   16:*/		return 0x82221E0C;
		  /* 82221E0Ch */ case   17:  		/* addi R8, R8, 1 */
		/* 82221E0Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82221E0Ch case   17:*/		return 0x82221E10;
		  /* 82221E10h */ case   18:  		/* subf R7, R9, R7 */
		/* 82221E10h case   18:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R7);
		/* 82221E10h case   18:*/		return 0x82221E14;
		  /* 82221E14h */ case   19:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 82221E14h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 82221E14h case   19:*/		return 0x82221E18;
		  /* 82221E18h */ case   20:  		/* rlwinm R7, R7, 0, 30, 31 */
		/* 82221E18h case   20:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R7);
		/* 82221E18h case   20:*/		return 0x82221E1C;
		  /* 82221E1Ch */ case   21:  		/* addi R10, R10, 2 */
		/* 82221E1Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82221E1Ch case   21:*/		return 0x82221E20;
		  /* 82221E20h */ case   22:  		/* slw R9, R7, R9 */
		/* 82221E20h case   22:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82221E20h case   22:*/		return 0x82221E24;
		  /* 82221E24h */ case   23:  		/* or R31, R9, R31 */
		/* 82221E24h case   23:*/		cpu::op::or<0>(regs,&regs.R31,regs.R9,regs.R31);
		/* 82221E24h case   23:*/		return 0x82221E28;
	}
	return 0x82221E28;
} // Block from 82221DC8h-82221E28h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82221E28h
// Function '?ApplyModifiers@D3DXShader@@YAMMI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221E28);
		  /* 82221E28h */ case    0:  		/* bc 4, CR0_EQ, -64 */
		/* 82221E28h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82221DE8;  }
		/* 82221E28h case    0:*/		return 0x82221E2C;
	}
	return 0x82221E2C;
} // Block from 82221E28h-82221E2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221E2C);
		  /* 82221E2Ch */ case    0:  		/* cntlzw R11, R6 */
		/* 82221E2Ch case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R6);
		/* 82221E2Ch case    0:*/		return 0x82221E30;
		  /* 82221E30h */ case    1:  		/* nor R10, R6, R6 */
		/* 82221E30h case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R6,regs.R6);
		/* 82221E30h case    1:*/		return 0x82221E34;
		  /* 82221E34h */ case    2:  		/* subfic R7, R11, 31 */
		/* 82221E34h case    2:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R11,0x1F);
		/* 82221E34h case    2:*/		return 0x82221E38;
		  /* 82221E38h */ case    3:  		/* rlwinm R9, R10, 0, 28, 31 */
		/* 82221E38h case    3:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R10);
		/* 82221E38h case    3:*/		return 0x82221E3C;
		  /* 82221E3Ch */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82221E3Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82221E3Ch case    4:*/		return 0x82221E40;
		  /* 82221E40h */ case    5:  		/* bc 12, CR6_EQ, 244 */
		/* 82221E40h case    5:*/		if ( regs.CR[6].eq ) { return 0x82221F34;  }
		/* 82221E40h case    5:*/		return 0x82221E44;
		  /* 82221E44h */ case    6:  		/* addi R11, R9, -1 */
		/* 82221E44h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82221E44h case    6:*/		return 0x82221E48;
		  /* 82221E48h */ case    7:  		/* andc R11, R9, R11 */
		/* 82221E48h case    7:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82221E48h case    7:*/		return 0x82221E4C;
		  /* 82221E4Ch */ case    8:  		/* cntlzw R11, R11 */
		/* 82221E4Ch case    8:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82221E4Ch case    8:*/		return 0x82221E50;
		  /* 82221E50h */ case    9:  		/* subfic R11, R11, 31 */
		/* 82221E50h case    9:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82221E50h case    9:*/		return 0x82221E54;
		  /* 82221E54h */ case   10:  		/* cmplw CR6, R11, R7 */
		/* 82221E54h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82221E54h case   10:*/		return 0x82221E58;
		  /* 82221E58h */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 82221E58h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82221E6C;  }
		/* 82221E58h case   11:*/		return 0x82221E5C;
		  /* 82221E5Ch */ case   12:  		/* rlwinm R10, R7, 1, 0, 30 */
		/* 82221E5Ch case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R7);
		/* 82221E5Ch case   12:*/		return 0x82221E60;
		  /* 82221E60h */ case   13:  		/* srw R10, R31, R10 */
		/* 82221E60h case   13:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 82221E60h case   13:*/		return 0x82221E64;
		  /* 82221E64h */ case   14:  		/* add R10, R10, R7 */
		/* 82221E64h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82221E64h case   14:*/		return 0x82221E68;
		  /* 82221E68h */ case   15:  		/* b 40 */
		/* 82221E68h case   15:*/		return 0x82221E90;
		/* 82221E68h case   15:*/		return 0x82221E6C;
	}
	return 0x82221E6C;
} // Block from 82221E2Ch-82221E6Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82221E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221E6C);
		  /* 82221E6Ch */ case    0:  		/* srw R10, R6, R11 */
		/* 82221E6Ch case    0:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R6,regs.R11);
		/* 82221E6Ch case    0:*/		return 0x82221E70;
		  /* 82221E70h */ case    1:  		/* slw R10, R10, R11 */
		/* 82221E70h case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82221E70h case    1:*/		return 0x82221E74;
		  /* 82221E74h */ case    2:  		/* addi R8, R10, -1 */
		/* 82221E74h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 82221E74h case    2:*/		return 0x82221E78;
		  /* 82221E78h */ case    3:  		/* andc R10, R10, R8 */
		/* 82221E78h case    3:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82221E78h case    3:*/		return 0x82221E7C;
		  /* 82221E7Ch */ case    4:  		/* cntlzw R10, R10 */
		/* 82221E7Ch case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82221E7Ch case    4:*/		return 0x82221E80;
		  /* 82221E80h */ case    5:  		/* subfic R10, R10, 31 */
		/* 82221E80h case    5:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 82221E80h case    5:*/		return 0x82221E84;
		  /* 82221E84h */ case    6:  		/* rlwinm R8, R10, 1, 0, 30 */
		/* 82221E84h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R10);
		/* 82221E84h case    6:*/		return 0x82221E88;
		  /* 82221E88h */ case    7:  		/* srw R8, R31, R8 */
		/* 82221E88h case    7:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R31,regs.R8);
		/* 82221E88h case    7:*/		return 0x82221E8C;
		  /* 82221E8Ch */ case    8:  		/* add R10, R8, R10 */
		/* 82221E8Ch case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82221E8Ch case    8:*/		return 0x82221E90;
	}
	return 0x82221E90;
} // Block from 82221E6Ch-82221E90h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82221E90h
// Function '?ApplyModifiers@D3DXShader@@YANNW4ConstantValueType@1@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221E90);
		  /* 82221E90h */ case    0:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82221E90h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82221E90h case    0:*/		return 0x82221E94;
		  /* 82221E94h */ case    1:  		/* addi R8, R9, -1 */
		/* 82221E94h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 82221E94h case    1:*/		return 0x82221E98;
		  /* 82221E98h */ case    2:  		/* subf R10, R11, R10 */
		/* 82221E98h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82221E98h case    2:*/		return 0x82221E9C;
		  /* 82221E9Ch */ case    3:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82221E9Ch case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82221E9Ch case    3:*/		return 0x82221EA0;
		  /* 82221EA0h */ case    4:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82221EA0h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82221EA0h case    4:*/		return 0x82221EA4;
		  /* 82221EA4h */ case    5:  		/* andc R8, R9, R8 */
		/* 82221EA4h case    5:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 82221EA4h case    5:*/		return 0x82221EA8;
		  /* 82221EA8h */ case    6:  		/* slw R11, R10, R11 */
		/* 82221EA8h case    6:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82221EA8h case    6:*/		return 0x82221EAC;
		  /* 82221EACh */ case    7:  		/* or R31, R11, R31 */
		/* 82221EACh case    7:*/		cpu::op::or<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 82221EACh case    7:*/		return 0x82221EB0;
		  /* 82221EB0h */ case    8:  		/* subf R9, R8, R9 */
		/* 82221EB0h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82221EB0h case    8:*/		return 0x82221EB4;
		  /* 82221EB4h */ case    9:  		/* b -120 */
		/* 82221EB4h case    9:*/		return 0x82221E3C;
		/* 82221EB4h case    9:*/		return 0x82221EB8;
	}
	return 0x82221EB8;
} // Block from 82221E90h-82221EB8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82221EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221EB8);
		  /* 82221EB8h */ case    0:  		/* li R10, 0 */
		/* 82221EB8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221EB8h case    0:*/		return 0x82221EBC;
		  /* 82221EBCh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82221EBCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82221EBCh case    1:*/		return 0x82221EC0;
		  /* 82221EC0h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 82221EC0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82221EF0;  }
		/* 82221EC0h case    2:*/		return 0x82221EC4;
		  /* 82221EC4h */ case    3:  		/* rlwinm R9, R28, 27, 24, 31 */
		/* 82221EC4h case    3:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R28);
		/* 82221EC4h case    3:*/		return 0x82221EC8;
		  /* 82221EC8h */ case    4:  		/* mtspr CTR, R30 */
		/* 82221EC8h case    4:*/		regs.CTR = regs.R30;
		/* 82221EC8h case    4:*/		return 0x82221ECC;
		  /* 82221ECCh */ case    5:  		/* li R11, 0 */
		/* 82221ECCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82221ECCh case    5:*/		return 0x82221ED0;
		  /* 82221ED0h */ case    6:  		/* srw R8, R9, R11 */
		/* 82221ED0h case    6:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 82221ED0h case    6:*/		return 0x82221ED4;
		  /* 82221ED4h */ case    7:  		/* subf R8, R10, R8 */
		/* 82221ED4h case    7:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 82221ED4h case    7:*/		return 0x82221ED8;
		  /* 82221ED8h */ case    8:  		/* addi R10, R10, 1 */
		/* 82221ED8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82221ED8h case    8:*/		return 0x82221EDC;
		  /* 82221EDCh */ case    9:  		/* rlwinm R8, R8, 0, 30, 31 */
		/* 82221EDCh case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R8);
		/* 82221EDCh case    9:*/		return 0x82221EE0;
		  /* 82221EE0h */ case   10:  		/* slw R8, R8, R11 */
		/* 82221EE0h case   10:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 82221EE0h case   10:*/		return 0x82221EE4;
		  /* 82221EE4h */ case   11:  		/* or R31, R8, R31 */
		/* 82221EE4h case   11:*/		cpu::op::or<0>(regs,&regs.R31,regs.R8,regs.R31);
		/* 82221EE4h case   11:*/		return 0x82221EE8;
		  /* 82221EE8h */ case   12:  		/* addi R11, R11, 2 */
		/* 82221EE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82221EE8h case   12:*/		return 0x82221EEC;
		  /* 82221EECh */ case   13:  		/* bc 16, CR0_LT, -28 */
		/* 82221EECh case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82221ED0;  }
		/* 82221EECh case   13:*/		return 0x82221EF0;
	}
	return 0x82221EF0;
} // Block from 82221EB8h-82221EF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82221EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221EF0);
		  /* 82221EF0h */ case    0:  		/* mr R9, R30 */
		/* 82221EF0h case    0:*/		regs.R9 = regs.R30;
		/* 82221EF0h case    0:*/		return 0x82221EF4;
		  /* 82221EF4h */ case    1:  		/* cmplwi CR6, R30, 4 */
		/* 82221EF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000004);
		/* 82221EF4h case    1:*/		return 0x82221EF8;
		  /* 82221EF8h */ case    2:  		/* bc 4, CR6_LT, 60 */
		/* 82221EF8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82221F34;  }
		/* 82221EF8h case    2:*/		return 0x82221EFC;
		  /* 82221EFCh */ case    3:  		/* addi R11, R30, -1 */
		/* 82221EFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 82221EFCh case    3:*/		return 0x82221F00;
		  /* 82221F00h */ case    4:  		/* subfic R10, R30, 4 */
		/* 82221F00h case    4:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R30,0x4);
		/* 82221F00h case    4:*/		return 0x82221F04;
		  /* 82221F04h */ case    5:  		/* rlwinm R7, R11, 1, 0, 30 */
		/* 82221F04h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R11);
		/* 82221F04h case    5:*/		return 0x82221F08;
		  /* 82221F08h */ case    6:  		/* rlwinm R8, R28, 27, 24, 31 */
		/* 82221F08h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R28);
		/* 82221F08h case    6:*/		return 0x82221F0C;
		  /* 82221F0Ch */ case    7:  		/* rlwinm R11, R30, 1, 0, 30 */
		/* 82221F0Ch case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R30);
		/* 82221F0Ch case    7:*/		return 0x82221F10;
	}
	return 0x82221F10;
} // Block from 82221EF0h-82221F10h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82221F10h
// Function '?ChangeDependency@Instruction@D3DXShader@@QAA_NPAVDependency@2@PAV12@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221F10);
		  /* 82221F10h */ case    0:  		/* srw R8, R8, R7 */
		/* 82221F10h case    0:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82221F10h case    0:*/		return 0x82221F14;
		  /* 82221F14h */ case    1:  		/* mtspr CTR, R10 */
		/* 82221F14h case    1:*/		regs.CTR = regs.R10;
		/* 82221F14h case    1:*/		return 0x82221F18;
		  /* 82221F18h */ case    2:  		/* subf R10, R9, R8 */
		/* 82221F18h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R8);
		/* 82221F18h case    2:*/		return 0x82221F1C;
		  /* 82221F1Ch */ case    3:  		/* addi R9, R9, 1 */
		/* 82221F1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82221F1Ch case    3:*/		return 0x82221F20;
		  /* 82221F20h */ case    4:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82221F20h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82221F20h case    4:*/		return 0x82221F24;
		  /* 82221F24h */ case    5:  		/* slw R10, R10, R11 */
		/* 82221F24h case    5:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82221F24h case    5:*/		return 0x82221F28;
		  /* 82221F28h */ case    6:  		/* or R31, R10, R31 */
		/* 82221F28h case    6:*/		cpu::op::or<0>(regs,&regs.R31,regs.R10,regs.R31);
		/* 82221F28h case    6:*/		return 0x82221F2C;
		  /* 82221F2Ch */ case    7:  		/* addi R11, R11, 2 */
		/* 82221F2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82221F2Ch case    7:*/		return 0x82221F30;
		  /* 82221F30h */ case    8:  		/* bc 16, CR0_LT, -24 */
		/* 82221F30h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82221F18;  }
		/* 82221F30h case    8:*/		return 0x82221F34;
	}
	return 0x82221F34;
} // Block from 82221F10h-82221F34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82221F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221F34);
		  /* 82221F34h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 82221F34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82221F34h case    0:*/		return 0x82221F38;
		  /* 82221F38h */ case    1:  		/* rlwimi R11, R31, 1, 23, 30 */
		/* 82221F38h case    1:*/		cpu::op::rlwimi<0,1,23,30>(regs,&regs.R11,regs.R31);
		/* 82221F38h case    1:*/		return 0x82221F3C;
		  /* 82221F3Ch */ case    2:  		/* stw R11, <#[R26]> */
		/* 82221F3Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82221F3Ch case    2:*/		return 0x82221F40;
		  /* 82221F40h */ case    3:  		/* lwz R10, <#[R27 + 12]> */
		/* 82221F40h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x0000000C) );
		/* 82221F40h case    3:*/		return 0x82221F44;
		  /* 82221F44h */ case    4:  		/* lwz R10, <#[R10 + 8]> */
		/* 82221F44h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82221F44h case    4:*/		return 0x82221F48;
		  /* 82221F48h */ case    5:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82221F48h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82221F48h case    5:*/		return 0x82221F4C;
		  /* 82221F4Ch */ case    6:  		/* cmplwi CR6, R10, 125 */
		/* 82221F4Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 82221F4Ch case    6:*/		return 0x82221F50;
		  /* 82221F50h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82221F50h case    7:*/		if ( regs.CR[6].eq ) { return 0x82221F60;  }
		/* 82221F50h case    7:*/		return 0x82221F54;
		  /* 82221F54h */ case    8:  		/* cmplwi CR6, R10, 124 */
		/* 82221F54h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 82221F54h case    8:*/		return 0x82221F58;
		  /* 82221F58h */ case    9:  		/* li R10, 0 */
		/* 82221F58h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82221F58h case    9:*/		return 0x82221F5C;
		  /* 82221F5Ch */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 82221F5Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x82221F64;  }
		/* 82221F5Ch case   10:*/		return 0x82221F60;
	}
	return 0x82221F60;
} // Block from 82221F34h-82221F60h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82221F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221F60);
		  /* 82221F60h */ case    0:  		/* li R10, 1 */
		/* 82221F60h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82221F60h case    0:*/		return 0x82221F64;
	}
	return 0x82221F64;
} // Block from 82221F60h-82221F64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82221F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221F64);
		  /* 82221F64h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82221F64h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82221F64h case    0:*/		return 0x82221F68;
		  /* 82221F68h */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 82221F68h case    1:*/		if ( regs.CR[0].eq ) { return 0x82221FCC;  }
		/* 82221F68h case    1:*/		return 0x82221F6C;
		  /* 82221F6Ch */ case    2:  		/* lwz R11, <#[R27]> */
		/* 82221F6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82221F6Ch case    2:*/		return 0x82221F70;
		  /* 82221F70h */ case    3:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82221F70h case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82221F70h case    3:*/		return 0x82221F74;
		  /* 82221F74h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82221F74h case    4:*/		if ( regs.CR[0].eq ) { return 0x82221F84;  }
		/* 82221F74h case    4:*/		return 0x82221F78;
		  /* 82221F78h */ case    5:  		/* lwz R11, <#[R25]> */
		/* 82221F78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82221F78h case    5:*/		return 0x82221F7C;
		  /* 82221F7Ch */ case    6:  		/* ori R11, R11, 128 */
		/* 82221F7Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82221F7Ch case    6:*/		return 0x82221F80;
		  /* 82221F80h */ case    7:  		/* stw R11, <#[R25]> */
		/* 82221F80h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82221F80h case    7:*/		return 0x82221F84;
	}
	return 0x82221F84;
} // Block from 82221F64h-82221F84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82221F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221F84);
		  /* 82221F84h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 82221F84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82221F84h case    0:*/		return 0x82221F88;
		  /* 82221F88h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 82221F88h case    1:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 82221F88h case    1:*/		return 0x82221F8C;
		  /* 82221F8Ch */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 82221F8Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82221FB4;  }
		/* 82221F8Ch case    2:*/		return 0x82221F90;
		  /* 82221F90h */ case    3:  		/* lwz R11, <#[R26]> */
		/* 82221F90h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82221F90h case    3:*/		return 0x82221F94;
		  /* 82221F94h */ case    4:  		/* ori R11, R11, 512 */
		/* 82221F94h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82221F94h case    4:*/		return 0x82221F98;
		  /* 82221F98h */ case    5:  		/* stw R11, <#[R26]> */
		/* 82221F98h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82221F98h case    5:*/		return 0x82221F9C;
		  /* 82221F9Ch */ case    6:  		/* lwz R11, <#[R27]> */
		/* 82221F9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82221F9Ch case    6:*/		return 0x82221FA0;
		  /* 82221FA0h */ case    7:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82221FA0h case    7:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82221FA0h case    7:*/		return 0x82221FA4;
		  /* 82221FA4h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82221FA4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82221FB4;  }
		/* 82221FA4h case    8:*/		return 0x82221FA8;
		  /* 82221FA8h */ case    9:  		/* lwz R11, <#[R25 + 4]> */
		/* 82221FA8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82221FA8h case    9:*/		return 0x82221FAC;
		  /* 82221FACh */ case   10:  		/* oris R11, R11, 8192 */
		/* 82221FACh case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82221FACh case   10:*/		return 0x82221FB0;
		  /* 82221FB0h */ case   11:  		/* stw R11, <#[R25 + 4]> */
		/* 82221FB0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82221FB0h case   11:*/		return 0x82221FB4;
	}
	return 0x82221FB4;
} // Block from 82221F84h-82221FB4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82221FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221FB4);
		  /* 82221FB4h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 82221FB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82221FB4h case    0:*/		return 0x82221FB8;
		  /* 82221FB8h */ case    1:  		/* li R3, 1 */
		/* 82221FB8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82221FB8h case    1:*/		return 0x82221FBC;
		  /* 82221FBCh */ case    2:  		/* lwz R10, <#[R26]> */
		/* 82221FBCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 82221FBCh case    2:*/		return 0x82221FC0;
		  /* 82221FC0h */ case    3:  		/* rlwimi R10, R11, 26, 13, 20 */
		/* 82221FC0h case    3:*/		cpu::op::rlwimi<0,26,13,20>(regs,&regs.R10,regs.R11);
		/* 82221FC0h case    3:*/		return 0x82221FC4;
		  /* 82221FC4h */ case    4:  		/* stw R10, <#[R26]> */
		/* 82221FC4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 82221FC4h case    4:*/		return 0x82221FC8;
		  /* 82221FC8h */ case    5:  		/* b 56 */
		/* 82221FC8h case    5:*/		return 0x82222000;
		/* 82221FC8h case    5:*/		return 0x82221FCC;
	}
	return 0x82221FCC;
} // Block from 82221FB4h-82221FCCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82221FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221FCC);
		  /* 82221FCCh */ case    0:  		/* ori R11, R11, 1024 */
		/* 82221FCCh case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82221FCCh case    0:*/		return 0x82221FD0;
		  /* 82221FD0h */ case    1:  		/* stw R11, <#[R26]> */
		/* 82221FD0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82221FD0h case    1:*/		return 0x82221FD4;
		  /* 82221FD4h */ case    2:  		/* lwz R10, <#[R27]> */
		/* 82221FD4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82221FD4h case    2:*/		return 0x82221FD8;
		  /* 82221FD8h */ case    3:  		/* rlwinm. R8, R10, 31, 31, 31 */
		/* 82221FD8h case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R8,regs.R10);
		/* 82221FD8h case    3:*/		return 0x82221FDC;
		  /* 82221FDCh */ case    4:  		/* rlwinm R9, R10, 15, 24, 31 */
		/* 82221FDCh case    4:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R9,regs.R10);
		/* 82221FDCh case    4:*/		return 0x82221FE0;
		  /* 82221FE0h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82221FE0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82221FE8;  }
		/* 82221FE0h case    5:*/		return 0x82221FE4;
		  /* 82221FE4h */ case    6:  		/* ori R9, R9, 128 */
		/* 82221FE4h case    6:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x80);
		/* 82221FE4h case    6:*/		return 0x82221FE8;
	}
	return 0x82221FE8;
} // Block from 82221FCCh-82221FE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82221FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221FE8);
		  /* 82221FE8h */ case    0:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 82221FE8h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 82221FE8h case    0:*/		return 0x82221FEC;
		  /* 82221FECh */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82221FECh case    1:*/		if ( regs.CR[0].eq ) { return 0x82221FF4;  }
		/* 82221FECh case    1:*/		return 0x82221FF0;
		  /* 82221FF0h */ case    2:  		/* ori R9, R9, 64 */
		/* 82221FF0h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x40);
		/* 82221FF0h case    2:*/		return 0x82221FF4;
	}
	return 0x82221FF4;
} // Block from 82221FE8h-82221FF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82221FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82221FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82221FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82221FF4);
		  /* 82221FF4h */ case    0:  		/* rlwimi R11, R9, 11, 13, 20 */
		/* 82221FF4h case    0:*/		cpu::op::rlwimi<0,11,13,20>(regs,&regs.R11,regs.R9);
		/* 82221FF4h case    0:*/		return 0x82221FF8;
		  /* 82221FF8h */ case    1:  		/* li R3, 0 */
		/* 82221FF8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82221FF8h case    1:*/		return 0x82221FFC;
		  /* 82221FFCh */ case    2:  		/* stw R11, <#[R26]> */
		/* 82221FFCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82221FFCh case    2:*/		return 0x82222000;
	}
	return 0x82222000;
} // Block from 82221FF4h-82222000h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222000);
		  /* 82222000h */ case    0:  		/* addi R1, R1, 144 */
		/* 82222000h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82222000h case    0:*/		return 0x82222004;
		  /* 82222004h */ case    1:  		/* b -1641832 */
		/* 82222004h case    1:*/		return 0x8209129C;
		/* 82222004h case    1:*/		return 0x82222008;
	}
	return 0x82222008;
} // Block from 82222000h-82222008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222008h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222008);
		  /* 82222008h */ case    0:  		/* lwz R11, <#[R3 + 48]> */
		/* 82222008h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82222008h case    0:*/		return 0x8222200C;
		  /* 8222200Ch */ case    1:  		/* lis R8, -1 */
		/* 8222200Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8222200Ch case    1:*/		return 0x82222010;
		  /* 82222010h */ case    2:  		/* li R10, 0 */
		/* 82222010h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82222010h case    2:*/		return 0x82222014;
		  /* 82222014h */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82222014h case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82222014h case    3:*/		return 0x82222018;
		  /* 82222018h */ case    4:  		/* cmplw CR6, R11, R8 */
		/* 82222018h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82222018h case    4:*/		return 0x8222201C;
		  /* 8222201Ch */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 8222201Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8222208C;  }
		/* 8222201Ch case    5:*/		return 0x82222020;
		  /* 82222020h */ case    6:  		/* lwz R9, <#[R5]> */
		/* 82222020h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 82222020h case    6:*/		return 0x82222024;
		  /* 82222024h */ case    7:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82222024h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82222024h case    7:*/		return 0x82222028;
		  /* 82222028h */ case    8:  		/* cmplwi CR6, R9, 17 */
		/* 82222028h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000011);
		/* 82222028h case    8:*/		return 0x8222202C;
		  /* 8222202Ch */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 8222202Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82222038;  }
		/* 8222202Ch case    9:*/		return 0x82222030;
		  /* 82222030h */ case   10:  		/* li R10, 3558 */
		/* 82222030h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0xDE6);
		/* 82222030h case   10:*/		return 0x82222034;
		  /* 82222034h */ case   11:  		/* b 16 */
		/* 82222034h case   11:*/		return 0x82222044;
		/* 82222034h case   11:*/		return 0x82222038;
	}
	return 0x82222038;
} // Block from 82222008h-82222038h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82222038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222038);
		  /* 82222038h */ case    0:  		/* cmplwi CR6, R9, 18 */
		/* 82222038h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000012);
		/* 82222038h case    0:*/		return 0x8222203C;
		  /* 8222203Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8222203Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82222044;  }
		/* 8222203Ch case    1:*/		return 0x82222040;
		  /* 82222040h */ case    2:  		/* li R10, 3559 */
		/* 82222040h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xDE7);
		/* 82222040h case    2:*/		return 0x82222044;
	}
	return 0x82222044;
} // Block from 82222038h-82222044h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222044);
		  /* 82222044h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 82222044h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82222044h case    0:*/		return 0x82222048;
		  /* 82222048h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82222048h case    1:*/		if ( regs.CR[6].eq ) { return 0x8222208C;  }
		/* 82222048h case    1:*/		return 0x8222204C;
		  /* 8222204Ch */ case    2:  		/* lwz R11, <#[R5 + 4]> */
		/* 8222204Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 8222204Ch case    2:*/		return 0x82222050;
		  /* 82222050h */ case    3:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 82222050h case    3:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 82222050h case    3:*/		return 0x82222054;
		  /* 82222054h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 82222054h case    4:*/		if ( regs.CR[0].eq ) { return 0x82222080;  }
		/* 82222054h case    4:*/		return 0x82222058;
		  /* 82222058h */ case    5:  		/* lwz R11, <#[R5 + 8]> */
		/* 82222058h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 82222058h case    5:*/		return 0x8222205C;
		  /* 8222205Ch */ case    6:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8222205Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8222205Ch case    6:*/		return 0x82222060;
		  /* 82222060h */ case    7:  		/* bc 4, CR0_EQ, 32 */
		/* 82222060h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82222080;  }
		/* 82222060h case    7:*/		return 0x82222064;
		  /* 82222064h */ case    8:  		/* lwz R10, <#[R4 + 20]> */
		/* 82222064h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 82222064h case    8:*/		return 0x82222068;
		  /* 82222068h */ case    9:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82222068h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82222068h case    9:*/		return 0x8222206C;
		  /* 8222206Ch */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 8222206Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82222078;  }
		/* 8222206Ch case   10:*/		return 0x82222070;
		  /* 82222070h */ case   11:  		/* li R10, 3557 */
		/* 82222070h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0xDE5);
		/* 82222070h case   11:*/		return 0x82222074;
		  /* 82222074h */ case   12:  		/* b 12 */
		/* 82222074h case   12:*/		return 0x82222080;
		/* 82222074h case   12:*/		return 0x82222078;
	}
	return 0x82222078;
} // Block from 82222044h-82222078h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82222078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222078);
		  /* 82222078h */ case    0:  		/* rlwinm R11, R11, 18, 30, 31 */
		/* 82222078h case    0:*/		cpu::op::rlwinm<0,18,30,31>(regs,&regs.R11,regs.R11);
		/* 82222078h case    0:*/		return 0x8222207C;
		  /* 8222207Ch */ case    1:  		/* addi R10, R11, 3630 */
		/* 8222207Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xE2E);
		/* 8222207Ch case    1:*/		return 0x82222080;
	}
	return 0x82222080;
} // Block from 82222078h-82222080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222080);
		  /* 82222080h */ case    0:  		/* lwz R11, <#[R5]> */
		/* 82222080h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82222080h case    0:*/		return 0x82222084;
		  /* 82222084h */ case    1:  		/* oris R11, R11, 8 */
		/* 82222084h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82222084h case    1:*/		return 0x82222088;
		  /* 82222088h */ case    2:  		/* stw R11, <#[R5]> */
		/* 82222088h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82222088h case    2:*/		return 0x8222208C;
	}
	return 0x8222208C;
} // Block from 82222080h-8222208Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222208Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222208C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222208C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222208C);
		  /* 8222208Ch */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 8222208Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8222208Ch case    0:*/		return 0x82222090;
		  /* 82222090h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82222090h case    1:*/		if ( regs.CR[6].eq ) { return 0x822220A4;  }
		/* 82222090h case    1:*/		return 0x82222094;
		  /* 82222094h */ case    2:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 82222094h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 82222094h case    2:*/		return 0x82222098;
		  /* 82222098h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82222098h case    3:*/		if ( regs.CR[0].eq ) { return 0x822220A4;  }
		/* 82222098h case    3:*/		return 0x8222209C;
		  /* 8222209Ch */ case    4:  		/* mr R4, R10 */
		/* 8222209Ch case    4:*/		regs.R4 = regs.R10;
		/* 8222209Ch case    4:*/		return 0x822220A0;
	}
	return 0x822220A0;
} // Block from 8222208Ch-822220A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822220A0h
// Function '?GetModifiedFloatConstantValue@Instruction@D3DXShader@@QAAMII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822220A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822220A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822220A0);
		  /* 822220A0h */ case    0:  		/* b -852536 */
		/* 822220A0h case    0:*/		return 0x82151E68;
		/* 822220A0h case    0:*/		return 0x822220A4;
	}
	return 0x822220A4;
} // Block from 822220A0h-822220A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822220A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822220A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822220A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822220A4);
		  /* 822220A4h */ case    0:  		/* mr R3, R10 */
		/* 822220A4h case    0:*/		regs.R3 = regs.R10;
		/* 822220A4h case    0:*/		return 0x822220A8;
		  /* 822220A8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822220A8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822220A8h case    1:*/		return 0x822220AC;
	}
	return 0x822220AC;
} // Block from 822220A4h-822220ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822220ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822220AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822220AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822220AC);
		  /* 822220ACh */ case    0:  		/* nop */
		/* 822220ACh case    0:*/		cpu::op::nop();
		/* 822220ACh case    0:*/		return 0x822220B0;
		  /* 822220B0h */ case    1:  		/* li R11, 0 */
		/* 822220B0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822220B0h case    1:*/		return 0x822220B4;
		  /* 822220B4h */ case    2:  		/* stw R11, <#[R3]> */
		/* 822220B4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822220B4h case    2:*/		return 0x822220B8;
	}
	return 0x822220B8;
} // Block from 822220ACh-822220B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822220B8h
// Function '?GetModifiedConstantValue@Instruction@D3DXShader@@QAANII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822220B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822220B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822220B8);
		  /* 822220B8h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 822220B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822220B8h case    0:*/		return 0x822220BC;
		  /* 822220BCh */ case    1:  		/* stw R11, <#[R3 + 8]> */
		/* 822220BCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822220BCh case    1:*/		return 0x822220C0;
		  /* 822220C0h */ case    2:  		/* stw R11, <#[R3 + 12]> */
		/* 822220C0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 822220C0h case    2:*/		return 0x822220C4;
		  /* 822220C4h */ case    3:  		/* stw R11, <#[R3 + 16]> */
		/* 822220C4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822220C4h case    3:*/		return 0x822220C8;
		  /* 822220C8h */ case    4:  		/* stw R4, <#[R3 + 16]> */
		/* 822220C8h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 822220C8h case    4:*/		return 0x822220CC;
		  /* 822220CCh */ case    5:  		/* lwz R11, <#[R3]> */
		/* 822220CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822220CCh case    5:*/		return 0x822220D0;
		  /* 822220D0h */ case    6:  		/* oris R11, R11, 32768 */
		/* 822220D0h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 822220D0h case    6:*/		return 0x822220D4;
		  /* 822220D4h */ case    7:  		/* stw R11, <#[R3]> */
		/* 822220D4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822220D4h case    7:*/		return 0x822220D8;
		  /* 822220D8h */ case    8:  		/* stw R3, <#[R4 + 4]> */
		/* 822220D8h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000004) );
		/* 822220D8h case    8:*/		return 0x822220DC;
		  /* 822220DCh */ case    9:  		/* bclr 20, CR0_LT */
		/* 822220DCh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822220DCh case    9:*/		return 0x822220E0;
	}
	return 0x822220E0;
} // Block from 822220B8h-822220E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822220E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822220E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822220E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822220E0);
		  /* 822220E0h */ case    0:  		/* mfspr R12, LR */
		/* 822220E0h case    0:*/		regs.R12 = regs.LR;
		/* 822220E0h case    0:*/		return 0x822220E4;
		  /* 822220E4h */ case    1:  		/* bl -1642148 */
		/* 822220E4h case    1:*/		regs.LR = 0x822220E8; return 0x82091240;
		/* 822220E4h case    1:*/		return 0x822220E8;
		  /* 822220E8h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 822220E8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 822220E8h case    2:*/		return 0x822220EC;
		  /* 822220ECh */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 822220ECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 822220ECh case    3:*/		return 0x822220F0;
		  /* 822220F0h */ case    4:  		/* mr R26, R3 */
		/* 822220F0h case    4:*/		regs.R26 = regs.R3;
		/* 822220F0h case    4:*/		return 0x822220F4;
		  /* 822220F4h */ case    5:  		/* mr R25, R4 */
		/* 822220F4h case    5:*/		regs.R25 = regs.R4;
		/* 822220F4h case    5:*/		return 0x822220F8;
		  /* 822220F8h */ case    6:  		/* bl -777840 */
		/* 822220F8h case    6:*/		regs.LR = 0x822220FC; return 0x82164288;
		/* 822220F8h case    6:*/		return 0x822220FC;
		  /* 822220FCh */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822220FCh case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822220FCh case    7:*/		return 0x82222100;
		  /* 82222100h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82222100h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222210C;  }
		/* 82222100h case    8:*/		return 0x82222104;
		  /* 82222104h */ case    9:  		/* li R3, 1 */
		/* 82222104h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82222104h case    9:*/		return 0x82222108;
		  /* 82222108h */ case   10:  		/* b 188 */
		/* 82222108h case   10:*/		return 0x822221C4;
		/* 82222108h case   10:*/		return 0x8222210C;
	}
	return 0x8222210C;
} // Block from 822220E0h-8222210Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8222210Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222210C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222210C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222210C);
		  /* 8222210Ch */ case    0:  		/* lwz R24, <#[R26 + 12]> */
		/* 8222210Ch case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R26 + 0x0000000C) );
		/* 8222210Ch case    0:*/		return 0x82222110;
		  /* 82222110h */ case    1:  		/* lwz R23, <#[R25 + 12]> */
		/* 82222110h case    1:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R25 + 0x0000000C) );
		/* 82222110h case    1:*/		return 0x82222114;
		  /* 82222114h */ case    2:  		/* lwz R11, <#[R24 + 8]> */
		/* 82222114h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82222114h case    2:*/		return 0x82222118;
		  /* 82222118h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82222118h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82222118h case    3:*/		return 0x8222211C;
		  /* 8222211Ch */ case    4:  		/* cmplwi CR6, R11, 16000 */
		/* 8222211Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8222211Ch case    4:*/		return 0x82222120;
		  /* 82222120h */ case    5:  		/* bc 4, CR6_EQ, 160 */
		/* 82222120h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822221C0;  }
		/* 82222120h case    5:*/		return 0x82222124;
		  /* 82222124h */ case    6:  		/* lwz R11, <#[R23 + 8]> */
		/* 82222124h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 82222124h case    6:*/		return 0x82222128;
		  /* 82222128h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82222128h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82222128h case    7:*/		return 0x8222212C;
		  /* 8222212Ch */ case    8:  		/* cmplwi CR6, R11, 16000 */
		/* 8222212Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8222212Ch case    8:*/		return 0x82222130;
	}
	return 0x82222130;
} // Block from 8222210Ch-82222130h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82222130h
// Function '?ComputeBoundsFromConstraintFlags@D3DXShader@@YA_NIPAN0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222130);
		  /* 82222130h */ case    0:  		/* bc 4, CR6_EQ, 144 */
		/* 82222130h case    0:*/		if ( !regs.CR[6].eq ) { return 0x822221C0;  }
		/* 82222130h case    0:*/		return 0x82222134;
		  /* 82222134h */ case    1:  		/* lwz R11, <#[R26]> */
		/* 82222134h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82222134h case    1:*/		return 0x82222138;
		  /* 82222138h */ case    2:  		/* lwz R10, <#[R25]> */
		/* 82222138h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 82222138h case    2:*/		return 0x8222213C;
		  /* 8222213Ch */ case    3:  		/* rlwinm R30, R11, 7, 29, 31 */
		/* 8222213Ch case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R30,regs.R11);
		/* 8222213Ch case    3:*/		return 0x82222140;
		  /* 82222140h */ case    4:  		/* rlwinm R9, R10, 7, 29, 31 */
		/* 82222140h case    4:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R10);
		/* 82222140h case    4:*/		return 0x82222144;
		  /* 82222144h */ case    5:  		/* cmplw CR6, R30, R9 */
		/* 82222144h case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 82222144h case    5:*/		return 0x82222148;
		  /* 82222148h */ case    6:  		/* bc 4, CR6_EQ, 120 */
		/* 82222148h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822221C0;  }
		/* 82222148h case    6:*/		return 0x8222214C;
		  /* 8222214Ch */ case    7:  		/* rlwinm R29, R11, 0, 27, 31 */
		/* 8222214Ch case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R29,regs.R11);
		/* 8222214Ch case    7:*/		return 0x82222150;
		  /* 82222150h */ case    8:  		/* rlwinm R28, R10, 0, 27, 31 */
		/* 82222150h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R28,regs.R10);
		/* 82222150h case    8:*/		return 0x82222154;
		  /* 82222154h */ case    9:  		/* li R27, 0 */
		/* 82222154h case    9:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82222154h case    9:*/		return 0x82222158;
		  /* 82222158h */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 82222158h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82222158h case   10:*/		return 0x8222215C;
		  /* 8222215Ch */ case   11:  		/* bc 12, CR6_EQ, -88 */
		/* 8222215Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82222104;  }
		/* 8222215Ch case   11:*/		return 0x82222160;
		  /* 82222160h */ case   12:  		/* li R31, 0 */
		/* 82222160h case   12:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82222160h case   12:*/		return 0x82222164;
		  /* 82222164h */ case   13:  		/* lwz R11, <#[R26]> */
		/* 82222164h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82222164h case   13:*/		return 0x82222168;
		  /* 82222168h */ case   14:  		/* mr R5, R29 */
		/* 82222168h case   14:*/		regs.R5 = regs.R29;
		/* 82222168h case   14:*/		return 0x8222216C;
		  /* 8222216Ch */ case   15:  		/* lwz R10, <#[R25]> */
		/* 8222216Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 8222216Ch case   15:*/		return 0x82222170;
		  /* 82222170h */ case   16:  		/* mr R3, R24 */
		/* 82222170h case   16:*/		regs.R3 = regs.R24;
		/* 82222170h case   16:*/		return 0x82222174;
		  /* 82222174h */ case   17:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 82222174h case   17:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 82222174h case   17:*/		return 0x82222178;
		  /* 82222178h */ case   18:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82222178h case   18:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82222178h case   18:*/		return 0x8222217C;
		  /* 8222217Ch */ case   19:  		/* srw R11, R11, R31 */
		/* 8222217Ch case   19:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8222217Ch case   19:*/		return 0x82222180;
		  /* 82222180h */ case   20:  		/* srw R10, R10, R31 */
		/* 82222180h case   20:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82222180h case   20:*/		return 0x82222184;
		  /* 82222184h */ case   21:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 82222184h case   21:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 82222184h case   21:*/		return 0x82222188;
		  /* 82222188h */ case   22:  		/* rlwinm R22, R10, 0, 30, 31 */
		/* 82222188h case   22:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R22,regs.R10);
		/* 82222188h case   22:*/		return 0x8222218C;
		  /* 8222218Ch */ case   23:  		/* bl -2796 */
		/* 8222218Ch case   23:*/		regs.LR = 0x82222190; return 0x822216A0;
		/* 8222218Ch case   23:*/		return 0x82222190;
		  /* 82222190h */ case   24:  		/* mr R5, R28 */
		/* 82222190h case   24:*/		regs.R5 = regs.R28;
		/* 82222190h case   24:*/		return 0x82222194;
		  /* 82222194h */ case   25:  		/* mr R4, R22 */
		/* 82222194h case   25:*/		regs.R4 = regs.R22;
		/* 82222194h case   25:*/		return 0x82222198;
		  /* 82222198h */ case   26:  		/* fmr FR31, FR1 */
		/* 82222198h case   26:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82222198h case   26:*/		return 0x8222219C;
		  /* 8222219Ch */ case   27:  		/* mr R3, R23 */
		/* 8222219Ch case   27:*/		regs.R3 = regs.R23;
		/* 8222219Ch case   27:*/		return 0x822221A0;
	}
	return 0x822221A0;
} // Block from 82222130h-822221A0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822221A0h
// Function '?ApplyModifiersToConstraintBounds@D3DXShader@@YAXPAN0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822221A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822221A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822221A0);
		  /* 822221A0h */ case    0:  		/* bl -2816 */
		/* 822221A0h case    0:*/		regs.LR = 0x822221A4; return 0x822216A0;
		/* 822221A0h case    0:*/		return 0x822221A4;
		  /* 822221A4h */ case    1:  		/* fcmpu CR6, FR31, FR1 */
		/* 822221A4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR1);
		/* 822221A4h case    1:*/		return 0x822221A8;
		  /* 822221A8h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 822221A8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822221C0;  }
		/* 822221A8h case    2:*/		return 0x822221AC;
		  /* 822221ACh */ case    3:  		/* addi R27, R27, 1 */
		/* 822221ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 822221ACh case    3:*/		return 0x822221B0;
		  /* 822221B0h */ case    4:  		/* addi R31, R31, 2 */
		/* 822221B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 822221B0h case    4:*/		return 0x822221B4;
		  /* 822221B4h */ case    5:  		/* cmplw CR6, R27, R30 */
		/* 822221B4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R30);
		/* 822221B4h case    5:*/		return 0x822221B8;
		  /* 822221B8h */ case    6:  		/* bc 12, CR6_LT, -84 */
		/* 822221B8h case    6:*/		if ( regs.CR[6].lt ) { return 0x82222164;  }
		/* 822221B8h case    6:*/		return 0x822221BC;
		  /* 822221BCh */ case    7:  		/* b -184 */
		/* 822221BCh case    7:*/		return 0x82222104;
		/* 822221BCh case    7:*/		return 0x822221C0;
	}
	return 0x822221C0;
} // Block from 822221A0h-822221C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822221C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822221C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822221C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822221C0);
		  /* 822221C0h */ case    0:  		/* li R3, 0 */
		/* 822221C0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822221C0h case    0:*/		return 0x822221C4;
	}
	return 0x822221C4;
} // Block from 822221C0h-822221C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822221C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822221C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822221C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822221C4);
		  /* 822221C4h */ case    0:  		/* addi R1, R1, 176 */
		/* 822221C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 822221C4h case    0:*/		return 0x822221C8;
		  /* 822221C8h */ case    1:  		/* lfd FR31, <#[R1 - 96]> */
		/* 822221C8h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 822221C8h case    1:*/		return 0x822221CC;
		  /* 822221CCh */ case    2:  		/* b -1642300 */
		/* 822221CCh case    2:*/		return 0x82091290;
		/* 822221CCh case    2:*/		return 0x822221D0;
		  /* 822221D0h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 822221D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822221D0h case    3:*/		return 0x822221D4;
		  /* 822221D4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 822221D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822221D4h case    4:*/		return 0x822221D8;
		  /* 822221D8h */ case    5:  		/* bc 12, CR6_EQ, 84 */
		/* 822221D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8222222C;  }
		/* 822221D8h case    5:*/		return 0x822221DC;
		  /* 822221DCh */ case    6:  		/* lwz R10, <#[R11]> */
		/* 822221DCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822221DCh case    6:*/		return 0x822221E0;
		  /* 822221E0h */ case    7:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 822221E0h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 822221E0h case    7:*/		return 0x822221E4;
		  /* 822221E4h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 822221E4h case    8:*/		if ( regs.CR[0].eq ) { return 0x822221F0;  }
		/* 822221E4h case    8:*/		return 0x822221E8;
		  /* 822221E8h */ case    9:  		/* rlwinm. R10, R10, 0, 28, 28 */
		/* 822221E8h case    9:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R10);
		/* 822221E8h case    9:*/		return 0x822221EC;
		  /* 822221ECh */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 822221ECh case   10:*/		if ( !regs.CR[0].eq ) { return 0x822221F8;  }
		/* 822221ECh case   10:*/		return 0x822221F0;
	}
	return 0x822221F0;
} // Block from 822221C4h-822221F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822221F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822221F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822221F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822221F0);
		  /* 822221F0h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 822221F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822221F0h case    0:*/		return 0x822221F4;
		  /* 822221F4h */ case    1:  		/* b -32 */
		/* 822221F4h case    1:*/		return 0x822221D4;
		/* 822221F4h case    1:*/		return 0x822221F8;
	}
	return 0x822221F8;
} // Block from 822221F0h-822221F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822221F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822221F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822221F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822221F8);
		  /* 822221F8h */ case    0:  		/* lwz R11, <#[R11 + 12]> */
		/* 822221F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822221F8h case    0:*/		return 0x822221FC;
		  /* 822221FCh */ case    1:  		/* lwz R10, <#[R11 + 8]> */
		/* 822221FCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 822221FCh case    1:*/		return 0x82222200;
		  /* 82222200h */ case    2:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82222200h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82222200h case    2:*/		return 0x82222204;
		  /* 82222204h */ case    3:  		/* cmplwi CR6, R10, 15104 */
		/* 82222204h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003B00);
		/* 82222204h case    3:*/		return 0x82222208;
		  /* 82222208h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82222208h case    4:*/		if ( regs.CR[6].eq ) { return 0x82222220;  }
		/* 82222208h case    4:*/		return 0x8222220C;
		  /* 8222220Ch */ case    5:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 8222220Ch case    5:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 8222220Ch case    5:*/		return 0x82222210;
		  /* 82222210h */ case    6:  		/* li R4, 4800 */
		/* 82222210h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82222210h case    6:*/		return 0x82222214;
		  /* 82222214h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 82222214h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222214h case    7:*/		return 0x82222218;
		  /* 82222218h */ case    8:  		/* lwz R3, <#[R11 + 148]> */
		/* 82222218h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82222218h case    8:*/		return 0x8222221C;
		  /* 8222221Ch */ case    9:  		/* b -852916 */
		/* 8222221Ch case    9:*/		return 0x82151E68;
		/* 8222221Ch case    9:*/		return 0x82222220;
	}
	return 0x82222220;
} // Block from 822221F8h-82222220h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82222220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222220);
		  /* 82222220h */ case    0:  		/* lwz R11, <#[R11 + 48]> */
		/* 82222220h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82222220h case    0:*/		return 0x82222224;
		  /* 82222224h */ case    1:  		/* lwz R3, <#[R11 + 12]> */
		/* 82222224h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 82222224h case    1:*/		return 0x82222228;
		  /* 82222228h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82222228h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82222228h case    2:*/		return 0x8222222C;
	}
	return 0x8222222C;
} // Block from 82222220h-8222222Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222222Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222222C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222222C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222222C);
		  /* 8222222Ch */ case    0:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 8222222Ch case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 8222222Ch case    0:*/		return 0x82222230;
		  /* 82222230h */ case    1:  		/* li R4, 4800 */
		/* 82222230h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82222230h case    1:*/		return 0x82222234;
		  /* 82222234h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82222234h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222234h case    2:*/		return 0x82222238;
		  /* 82222238h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82222238h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82222238h case    3:*/		return 0x8222223C;
		  /* 8222223Ch */ case    4:  		/* b -852948 */
		/* 8222223Ch case    4:*/		return 0x82151E68;
		/* 8222223Ch case    4:*/		return 0x82222240;
	}
	return 0x82222240;
} // Block from 8222222Ch-82222240h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82222240h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222240);
		  /* 82222240h */ case    0:  		/* mfspr R12, LR */
		/* 82222240h case    0:*/		regs.R12 = regs.LR;
		/* 82222240h case    0:*/		return 0x82222244;
		  /* 82222244h */ case    1:  		/* bl -1642472 */
		/* 82222244h case    1:*/		regs.LR = 0x82222248; return 0x8209125C;
		/* 82222244h case    1:*/		return 0x82222248;
		  /* 82222248h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82222248h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82222248h case    2:*/		return 0x8222224C;
		  /* 8222224Ch */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 8222224Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8222224Ch case    3:*/		return 0x82222250;
		  /* 82222250h */ case    4:  		/* mr R31, R5 */
		/* 82222250h case    4:*/		regs.R31 = regs.R5;
		/* 82222250h case    4:*/		return 0x82222254;
		  /* 82222254h */ case    5:  		/* mr R30, R6 */
		/* 82222254h case    5:*/		regs.R30 = regs.R6;
		/* 82222254h case    5:*/		return 0x82222258;
		  /* 82222258h */ case    6:  		/* mr R29, R7 */
		/* 82222258h case    6:*/		regs.R29 = regs.R7;
		/* 82222258h case    6:*/		return 0x8222225C;
		  /* 8222225Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8222225Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222225Ch case    7:*/		return 0x82222260;
		  /* 82222260h */ case    8:  		/* bc 12, CR6_EQ, 76 */
		/* 82222260h case    8:*/		if ( regs.CR[6].eq ) { return 0x822222AC;  }
		/* 82222260h case    8:*/		return 0x82222264;
		  /* 82222264h */ case    9:  		/* lwz R10, <#[R11 + 16]> */
		/* 82222264h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82222264h case    9:*/		return 0x82222268;
	}
	return 0x82222268;
} // Block from 82222240h-82222268h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82222268h
// Function '?ConstraintMul@D3DXShader@@YANNN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222268);
		  /* 82222268h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82222268h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82222268h case    0:*/		return 0x8222226C;
		  /* 8222226Ch */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8222226Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8222229C;  }
		/* 8222226Ch case    1:*/		return 0x82222270;
		  /* 82222270h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82222270h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82222270h case    2:*/		return 0x82222274;
		  /* 82222274h */ case    3:  		/* rlwinm. R9, R10, 7, 29, 31 */
		/* 82222274h case    3:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R9,regs.R10);
		/* 82222274h case    3:*/		return 0x82222278;
		  /* 82222278h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 82222278h case    4:*/		if ( regs.CR[0].eq ) { return 0x8222229C;  }
		/* 82222278h case    4:*/		return 0x8222227C;
		  /* 8222227Ch */ case    5:  		/* rlwinm R8, R10, 0, 27, 31 */
		/* 8222227Ch case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R10);
		/* 8222227Ch case    5:*/		return 0x82222280;
		  /* 82222280h */ case    6:  		/* cmplw CR6, R8, R30 */
		/* 82222280h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R30);
		/* 82222280h case    6:*/		return 0x82222284;
		  /* 82222284h */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 82222284h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8222229C;  }
		/* 82222284h case    7:*/		return 0x82222288;
		  /* 82222288h */ case    8:  		/* cmplw CR6, R9, R31 */
		/* 82222288h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 82222288h case    8:*/		return 0x8222228C;
		  /* 8222228Ch */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 8222228Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8222229C;  }
		/* 8222228Ch case    9:*/		return 0x82222290;
		  /* 82222290h */ case   10:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82222290h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82222290h case   10:*/		return 0x82222294;
		  /* 82222294h */ case   11:  		/* cmplw CR6, R10, R29 */
		/* 82222294h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 82222294h case   11:*/		return 0x82222298;
		  /* 82222298h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 82222298h case   12:*/		if ( regs.CR[6].eq ) { return 0x822222A4;  }
		/* 82222298h case   12:*/		return 0x8222229C;
	}
	return 0x8222229C;
} // Block from 82222268h-8222229Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222229Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222229C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222229C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222229C);
		  /* 8222229Ch */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222229Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222229Ch case    0:*/		return 0x822222A0;
		  /* 822222A0h */ case    1:  		/* b -68 */
		/* 822222A0h case    1:*/		return 0x8222225C;
		/* 822222A0h case    1:*/		return 0x822222A4;
	}
	return 0x822222A4;
} // Block from 8222229Ch-822222A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822222A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822222A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822222A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822222A4);
		  /* 822222A4h */ case    0:  		/* mr R3, R11 */
		/* 822222A4h case    0:*/		regs.R3 = regs.R11;
		/* 822222A4h case    0:*/		return 0x822222A8;
		  /* 822222A8h */ case    1:  		/* b 52 */
		/* 822222A8h case    1:*/		return 0x822222DC;
		/* 822222A8h case    1:*/		return 0x822222AC;
	}
	return 0x822222AC;
} // Block from 822222A4h-822222ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822222ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822222AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822222AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822222AC);
		  /* 822222ACh */ case    0:  		/* bl -697004 */
		/* 822222ACh case    0:*/		regs.LR = 0x822222B0; return 0x82178000;
		/* 822222ACh case    0:*/		return 0x822222B0;
		  /* 822222B0h */ case    1:  		/* rlwinm R10, R29, 0, 24, 31 */
		/* 822222B0h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R29);
		/* 822222B0h case    1:*/		return 0x822222B4;
		  /* 822222B4h */ case    2:  		/* rlwinm R11, R31, 20, 9, 11 */
		/* 822222B4h case    2:*/		cpu::op::rlwinm<0,20,9,11>(regs,&regs.R11,regs.R31);
		/* 822222B4h case    2:*/		return 0x822222B8;
		  /* 822222B8h */ case    3:  		/* rlwinm R9, R30, 0, 27, 31 */
		/* 822222B8h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R30);
		/* 822222B8h case    3:*/		return 0x822222BC;
		  /* 822222BCh */ case    4:  		/* or R11, R11, R10 */
		/* 822222BCh case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822222BCh case    4:*/		return 0x822222C0;
		  /* 822222C0h */ case    5:  		/* lwz R10, <#[R3]> */
		/* 822222C0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 822222C0h case    5:*/		return 0x822222C4;
		  /* 822222C4h */ case    6:  		/* rlwinm R10, R10, 0, 0, 18 */
		/* 822222C4h case    6:*/		cpu::op::rlwinm<0,0,0,18>(regs,&regs.R10,regs.R10);
		/* 822222C4h case    6:*/		return 0x822222C8;
		  /* 822222C8h */ case    7:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 822222C8h case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 822222C8h case    7:*/		return 0x822222CC;
		  /* 822222CCh */ case    8:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 822222CCh case    8:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 822222CCh case    8:*/		return 0x822222D0;
		  /* 822222D0h */ case    9:  		/* or R11, R11, R10 */
		/* 822222D0h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822222D0h case    9:*/		return 0x822222D4;
		  /* 822222D4h */ case   10:  		/* or R11, R11, R9 */
		/* 822222D4h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 822222D4h case   10:*/		return 0x822222D8;
		  /* 822222D8h */ case   11:  		/* stw R11, <#[R3]> */
		/* 822222D8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822222D8h case   11:*/		return 0x822222DC;
	}
	return 0x822222DC;
} // Block from 822222ACh-822222DCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 822222DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822222DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822222DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822222DC);
		  /* 822222DCh */ case    0:  		/* addi R1, R1, 112 */
		/* 822222DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822222DCh case    0:*/		return 0x822222E0;
		  /* 822222E0h */ case    1:  		/* b -1642548 */
		/* 822222E0h case    1:*/		return 0x820912AC;
		/* 822222E0h case    1:*/		return 0x822222E4;
		  /* 822222E4h */ case    2:  		/* nop */
		/* 822222E4h case    2:*/		cpu::op::nop();
		/* 822222E4h case    2:*/		return 0x822222E8;
	}
	return 0x822222E8;
} // Block from 822222DCh-822222E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822222E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822222E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822222E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822222E8);
		  /* 822222E8h */ case    0:  		/* mfspr R12, LR */
		/* 822222E8h case    0:*/		regs.R12 = regs.LR;
		/* 822222E8h case    0:*/		return 0x822222EC;
		  /* 822222ECh */ case    1:  		/* bl -1642668 */
		/* 822222ECh case    1:*/		regs.LR = 0x822222F0; return 0x82091240;
		/* 822222ECh case    1:*/		return 0x822222F0;
		  /* 822222F0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 822222F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 822222F0h case    2:*/		return 0x822222F4;
		  /* 822222F4h */ case    3:  		/* mr R24, R3 */
		/* 822222F4h case    3:*/		regs.R24 = regs.R3;
		/* 822222F4h case    3:*/		return 0x822222F8;
		  /* 822222F8h */ case    4:  		/* mr R26, R4 */
		/* 822222F8h case    4:*/		regs.R26 = regs.R4;
		/* 822222F8h case    4:*/		return 0x822222FC;
		  /* 822222FCh */ case    5:  		/* mr R30, R5 */
		/* 822222FCh case    5:*/		regs.R30 = regs.R5;
		/* 822222FCh case    5:*/		return 0x82222300;
		  /* 82222300h */ case    6:  		/* mr R28, R6 */
		/* 82222300h case    6:*/		regs.R28 = regs.R6;
		/* 82222300h case    6:*/		return 0x82222304;
		  /* 82222304h */ case    7:  		/* mr R29, R7 */
		/* 82222304h case    7:*/		regs.R29 = regs.R7;
		/* 82222304h case    7:*/		return 0x82222308;
		  /* 82222308h */ case    8:  		/* mr R25, R8 */
		/* 82222308h case    8:*/		regs.R25 = regs.R8;
		/* 82222308h case    8:*/		return 0x8222230C;
		  /* 8222230Ch */ case    9:  		/* mr R22, R9 */
		/* 8222230Ch case    9:*/		regs.R22 = regs.R9;
		/* 8222230Ch case    9:*/		return 0x82222310;
		  /* 82222310h */ case   10:  		/* mr R23, R10 */
		/* 82222310h case   10:*/		regs.R23 = regs.R10;
		/* 82222310h case   10:*/		return 0x82222314;
		  /* 82222314h */ case   11:  		/* li R31, 0 */
		/* 82222314h case   11:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82222314h case   11:*/		return 0x82222318;
		  /* 82222318h */ case   12:  		/* cmplwi CR6, R7, 0 */
		/* 82222318h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82222318h case   12:*/		return 0x8222231C;
		  /* 8222231Ch */ case   13:  		/* bc 12, CR6_EQ, 52 */
		/* 8222231Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82222350;  }
		/* 8222231Ch case   13:*/		return 0x82222320;
		  /* 82222320h */ case   14:  		/* mr R27, R6 */
		/* 82222320h case   14:*/		regs.R27 = regs.R6;
		/* 82222320h case   14:*/		return 0x82222324;
		  /* 82222324h */ case   15:  		/* lwz R11, <#[R27 + 4]> */
		/* 82222324h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82222324h case   15:*/		return 0x82222328;
		  /* 82222328h */ case   16:  		/* mr R3, R26 */
		/* 82222328h case   16:*/		regs.R3 = regs.R26;
		/* 82222328h case   16:*/		return 0x8222232C;
		  /* 8222232Ch */ case   17:  		/* lwz R4, <#[R27]> */
		/* 8222232Ch case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000000) );
		/* 8222232Ch case   17:*/		return 0x82222330;
		  /* 82222330h */ case   18:  		/* rlwinm R5, R11, 4, 28, 31 */
		/* 82222330h case   18:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R5,regs.R11);
		/* 82222330h case   18:*/		return 0x82222334;
		  /* 82222334h */ case   19:  		/* bl 291588 */
		/* 82222334h case   19:*/		regs.LR = 0x82222338; return 0x82269638;
		/* 82222334h case   19:*/		return 0x82222338;
		  /* 82222338h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 82222338h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82222338h case   20:*/		return 0x8222233C;
		  /* 8222233Ch */ case   21:  		/* bc 12, CR0_EQ, 32 */
		/* 8222233Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x8222235C;  }
		/* 8222233Ch case   21:*/		return 0x82222340;
	}
	return 0x82222340;
} // Block from 822222E8h-82222340h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82222340h
// Function '?FlipCondition_InPlace@Instruction@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222340);
		  /* 82222340h */ case    0:  		/* addi R31, R31, 1 */
		/* 82222340h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82222340h case    0:*/		return 0x82222344;
		  /* 82222344h */ case    1:  		/* addi R27, R27, 12 */
		/* 82222344h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xC);
		/* 82222344h case    1:*/		return 0x82222348;
		  /* 82222348h */ case    2:  		/* cmplw CR6, R31, R29 */
		/* 82222348h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82222348h case    2:*/		return 0x8222234C;
		  /* 8222234Ch */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 8222234Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82222324;  }
		/* 8222234Ch case    3:*/		return 0x82222350;
	}
	return 0x82222350;
} // Block from 82222340h-82222350h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222350);
		  /* 82222350h */ case    0:  		/* li R3, 0 */
		/* 82222350h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82222350h case    0:*/		return 0x82222354;
		  /* 82222354h */ case    1:  		/* addi R1, R1, 176 */
		/* 82222354h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82222354h case    1:*/		return 0x82222358;
		  /* 82222358h */ case    2:  		/* b -1642696 */
		/* 82222358h case    2:*/		return 0x82091290;
		/* 82222358h case    2:*/		return 0x8222235C;
	}
	return 0x8222235C;
} // Block from 82222350h-8222235Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222235Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222235C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222235C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222235C);
		  /* 8222235Ch */ case    0:  		/* mulli R11, R31, 12 */
		/* 8222235Ch case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0xC);
		/* 8222235Ch case    0:*/		return 0x82222360;
		  /* 82222360h */ case    1:  		/* add R31, R11, R28 */
		/* 82222360h case    1:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R28);
		/* 82222360h case    1:*/		return 0x82222364;
		  /* 82222364h */ case    2:  		/* li R5, 10 */
		/* 82222364h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 82222364h case    2:*/		return 0x82222368;
		  /* 82222368h */ case    3:  		/* addi R4, R1, 80 */
		/* 82222368h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82222368h case    3:*/		return 0x8222236C;
		  /* 8222236Ch */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222236Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222236Ch case    4:*/		return 0x82222370;
		  /* 82222370h */ case    5:  		/* rlwinm R11, R11, 4, 28, 31 */
		/* 82222370h case    5:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R11,regs.R11);
		/* 82222370h case    5:*/		return 0x82222374;
		  /* 82222374h */ case    6:  		/* add R3, R11, R26 */
		/* 82222374h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82222374h case    6:*/		return 0x82222378;
		  /* 82222378h */ case    7:  		/* bl -1613704 */
		/* 82222378h case    7:*/		regs.LR = 0x8222237C; return 0x820983F0;
		/* 82222378h case    7:*/		return 0x8222237C;
		  /* 8222237Ch */ case    8:  		/* lwz R11, <#[R1 + 80]> */
		/* 8222237Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222237Ch case    8:*/		return 0x82222380;
		  /* 82222380h */ case    9:  		/* add R29, R3, R30 */
		/* 82222380h case    9:*/		cpu::op::add<0>(regs,&regs.R29,regs.R3,regs.R30);
		/* 82222380h case    9:*/		return 0x82222384;
		  /* 82222384h */ case   10:  		/* lbz R10, <#[R11]> */
		/* 82222384h case   10:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82222384h case   10:*/		return 0x82222388;
		  /* 82222388h */ case   11:  		/* cmplwi CR0, R10, 0 */
		/* 82222388h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82222388h case   11:*/		return 0x8222238C;
		  /* 8222238Ch */ case   12:  		/* bc 12, CR0_EQ, 104 */
		/* 8222238Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x822223F4;  }
		/* 8222238Ch case   12:*/		return 0x82222390;
		  /* 82222390h */ case   13:  		/* lwz R10, <#[R31 + 4]> */
		/* 82222390h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82222390h case   13:*/		return 0x82222394;
		  /* 82222394h */ case   14:  		/* rlwinm. R10, R10, 0, 15, 17 */
		/* 82222394h case   14:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R10,regs.R10);
		/* 82222394h case   14:*/		return 0x82222398;
		  /* 82222398h */ case   15:  		/* bc 4, CR0_EQ, -72 */
		/* 82222398h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82222350;  }
		/* 82222398h case   15:*/		return 0x8222239C;
		  /* 8222239Ch */ case   16:  		/* lis R10, -32253 */
		/* 8222239Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 8222239Ch case   16:*/		return 0x822223A0;
		  /* 822223A0h */ case   17:  		/* mr R3, R11 */
		/* 822223A0h case   17:*/		regs.R3 = regs.R11;
		/* 822223A0h case   17:*/		return 0x822223A4;
		  /* 822223A4h */ case   18:  		/* addi R4, R10, 30572 */
		/* 822223A4h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x776C);
		/* 822223A4h case   18:*/		return 0x822223A8;
		  /* 822223A8h */ case   19:  		/* bl -1634168 */
		/* 822223A8h case   19:*/		regs.LR = 0x822223AC; return 0x82093430;
		/* 822223A8h case   19:*/		return 0x822223AC;
		  /* 822223ACh */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 822223ACh case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822223ACh case   20:*/		return 0x822223B0;
		  /* 822223B0h */ case   21:  		/* bc 4, CR0_EQ, 12 */
		/* 822223B0h case   21:*/		if ( !regs.CR[0].eq ) { return 0x822223BC;  }
		/* 822223B0h case   21:*/		return 0x822223B4;
		  /* 822223B4h */ case   22:  		/* li R5, 1 */
		/* 822223B4h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822223B4h case   22:*/		return 0x822223B8;
		  /* 822223B8h */ case   23:  		/* b 32 */
		/* 822223B8h case   23:*/		return 0x822223D8;
		/* 822223B8h case   23:*/		return 0x822223BC;
	}
	return 0x822223BC;
} // Block from 8222235Ch-822223BCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 822223BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822223BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822223BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822223BC);
		  /* 822223BCh */ case    0:  		/* lis R11, -32252 */
		/* 822223BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822223BCh case    0:*/		return 0x822223C0;
		  /* 822223C0h */ case    1:  		/* lwz R3, <#[R1 + 80]> */
		/* 822223C0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 822223C0h case    1:*/		return 0x822223C4;
		  /* 822223C4h */ case    2:  		/* addi R4, R11, -13552 */
		/* 822223C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFCB10);
		/* 822223C4h case    2:*/		return 0x822223C8;
		  /* 822223C8h */ case    3:  		/* bl -1634200 */
		/* 822223C8h case    3:*/		regs.LR = 0x822223CC; return 0x82093430;
		/* 822223C8h case    3:*/		return 0x822223CC;
		  /* 822223CCh */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 822223CCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822223CCh case    4:*/		return 0x822223D0;
		  /* 822223D0h */ case    5:  		/* bc 4, CR0_EQ, -128 */
		/* 822223D0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82222350;  }
		/* 822223D0h case    5:*/		return 0x822223D4;
		  /* 822223D4h */ case    6:  		/* li R5, 0 */
		/* 822223D4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822223D4h case    6:*/		return 0x822223D8;
	}
	return 0x822223D8;
} // Block from 822223BCh-822223D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822223D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822223D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822223D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822223D8);
		  /* 822223D8h */ case    0:  		/* mr R8, R30 */
		/* 822223D8h case    0:*/		regs.R8 = regs.R30;
		/* 822223D8h case    0:*/		return 0x822223DC;
		  /* 822223DCh */ case    1:  		/* mr R7, R22 */
		/* 822223DCh case    1:*/		regs.R7 = regs.R22;
		/* 822223DCh case    1:*/		return 0x822223E0;
		  /* 822223E0h */ case    2:  		/* mr R6, R25 */
		/* 822223E0h case    2:*/		regs.R6 = regs.R25;
		/* 822223E0h case    2:*/		return 0x822223E4;
		  /* 822223E4h */ case    3:  		/* mr R4, R23 */
		/* 822223E4h case    3:*/		regs.R4 = regs.R23;
		/* 822223E4h case    3:*/		return 0x822223E8;
		  /* 822223E8h */ case    4:  		/* mr R3, R24 */
		/* 822223E8h case    4:*/		regs.R3 = regs.R24;
		/* 822223E8h case    4:*/		return 0x822223EC;
		  /* 822223ECh */ case    5:  		/* bl -5012 */
		/* 822223ECh case    5:*/		regs.LR = 0x822223F0; return 0x82221058;
		/* 822223ECh case    5:*/		return 0x822223F0;
		  /* 822223F0h */ case    6:  		/* mr R25, R3 */
		/* 822223F0h case    6:*/		regs.R25 = regs.R3;
		/* 822223F0h case    6:*/		return 0x822223F4;
	}
	return 0x822223F4;
} // Block from 822223D8h-822223F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822223F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822223F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822223F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822223F4);
		  /* 822223F4h */ case    0:  		/* mr R7, R23 */
		/* 822223F4h case    0:*/		regs.R7 = regs.R23;
		/* 822223F4h case    0:*/		return 0x822223F8;
		  /* 822223F8h */ case    1:  		/* lwz R8, <#[R1 + 260]> */
		/* 822223F8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000104) );
		/* 822223F8h case    1:*/		return 0x822223FC;
		  /* 822223FCh */ case    2:  		/* mr R6, R26 */
		/* 822223FCh case    2:*/		regs.R6 = regs.R26;
		/* 822223FCh case    2:*/		return 0x82222400;
		  /* 82222400h */ case    3:  		/* mr R5, R29 */
		/* 82222400h case    3:*/		regs.R5 = regs.R29;
		/* 82222400h case    3:*/		return 0x82222404;
		  /* 82222404h */ case    4:  		/* mr R4, R31 */
		/* 82222404h case    4:*/		regs.R4 = regs.R31;
		/* 82222404h case    4:*/		return 0x82222408;
		  /* 82222408h */ case    5:  		/* mr R3, R24 */
		/* 82222408h case    5:*/		regs.R3 = regs.R24;
		/* 82222408h case    5:*/		return 0x8222240C;
		  /* 8222240Ch */ case    6:  		/* bl -5516 */
		/* 8222240Ch case    6:*/		regs.LR = 0x82222410; return 0x82220E80;
		/* 8222240Ch case    6:*/		return 0x82222410;
		  /* 82222410h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82222410h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82222410h case    7:*/		return 0x82222414;
		  /* 82222414h */ case    8:  		/* bc 12, CR0_EQ, -196 */
		/* 82222414h case    8:*/		if ( regs.CR[0].eq ) { return 0x82222350;  }
		/* 82222414h case    8:*/		return 0x82222418;
		  /* 82222418h */ case    9:  		/* lwz R11, <#[R1 + 268]> */
		/* 82222418h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000010C) );
		/* 82222418h case    9:*/		return 0x8222241C;
		  /* 8222241Ch */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8222241Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222241Ch case   10:*/		return 0x82222420;
		  /* 82222420h */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 82222420h case   11:*/		if ( regs.CR[6].eq ) { return 0x82222428;  }
		/* 82222420h case   11:*/		return 0x82222424;
		  /* 82222424h */ case   12:  		/* stb R25, <#[R11]> */
		/* 82222424h case   12:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 82222424h case   12:*/		return 0x82222428;
	}
	return 0x82222428;
} // Block from 822223F4h-82222428h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82222428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222428);
		  /* 82222428h */ case    0:  		/* li R3, 1 */
		/* 82222428h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82222428h case    0:*/		return 0x8222242C;
		  /* 8222242Ch */ case    1:  		/* b -216 */
		/* 8222242Ch case    1:*/		return 0x82222354;
		/* 8222242Ch case    1:*/		return 0x82222430;
	}
	return 0x82222430;
} // Block from 82222428h-82222430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222430h
// Function '?CanNormalizeSwizzle@Instruction@D3DXShader@@QAA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222430);
		  /* 82222430h */ case    0:  		/* mfspr R12, LR */
		/* 82222430h case    0:*/		regs.R12 = regs.LR;
		/* 82222430h case    0:*/		return 0x82222434;
		  /* 82222434h */ case    1:  		/* bl -1642980 */
		/* 82222434h case    1:*/		regs.LR = 0x82222438; return 0x82091250;
		/* 82222434h case    1:*/		return 0x82222438;
		  /* 82222438h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82222438h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82222438h case    2:*/		return 0x8222243C;
		  /* 8222243Ch */ case    3:  		/* lwz R30, <#[R4 + 4]> */
		/* 8222243Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000004) );
		/* 8222243Ch case    3:*/		return 0x82222440;
		  /* 82222440h */ case    4:  		/* mr R31, R4 */
		/* 82222440h case    4:*/		regs.R31 = regs.R4;
		/* 82222440h case    4:*/		return 0x82222444;
		  /* 82222444h */ case    5:  		/* li R26, 0 */
		/* 82222444h case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82222444h case    5:*/		return 0x82222448;
		  /* 82222448h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 82222448h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82222448h case    6:*/		return 0x8222244C;
		  /* 8222244Ch */ case    7:  		/* bc 12, CR6_EQ, 44 */
		/* 8222244Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82222478;  }
		/* 8222244Ch case    7:*/		return 0x82222450;
		  /* 82222450h */ case    8:  		/* lwz R11, <#[R30 + 16]> */
		/* 82222450h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82222450h case    8:*/		return 0x82222454;
		  /* 82222454h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82222454h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222454h case    9:*/		return 0x82222458;
		  /* 82222458h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 82222458h case   10:*/		if ( regs.CR[6].eq ) { return 0x8222246C;  }
		/* 82222458h case   10:*/		return 0x8222245C;
		  /* 8222245Ch */ case   11:  		/* mr R3, R30 */
		/* 8222245Ch case   11:*/		regs.R3 = regs.R30;
		/* 8222245Ch case   11:*/		return 0x82222460;
		  /* 82222460h */ case   12:  		/* bl -777264 */
		/* 82222460h case   12:*/		regs.LR = 0x82222464; return 0x82164830;
		/* 82222460h case   12:*/		return 0x82222464;
		  /* 82222464h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82222464h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82222464h case   13:*/		return 0x82222468;
		  /* 82222468h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 82222468h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82222474;  }
		/* 82222468h case   14:*/		return 0x8222246C;
	}
	return 0x8222246C;
} // Block from 82222430h-8222246Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222246Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222246C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222246C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222246C);
		  /* 8222246Ch */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8222246Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8222246Ch case    0:*/		return 0x82222470;
		  /* 82222470h */ case    1:  		/* b -40 */
		/* 82222470h case    1:*/		return 0x82222448;
		/* 82222470h case    1:*/		return 0x82222474;
	}
	return 0x82222474;
} // Block from 8222246Ch-82222474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222474);
		  /* 82222474h */ case    0:  		/* li R26, -1 */
		/* 82222474h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 82222474h case    0:*/		return 0x82222478;
	}
	return 0x82222478;
} // Block from 82222474h-82222478h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222478);
		  /* 82222478h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82222478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82222478h case    0:*/		return 0x8222247C;
		  /* 8222247Ch */ case    1:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 8222247Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 8222247Ch case    1:*/		return 0x82222480;
		  /* 82222480h */ case    2:  		/* cmplwi CR6, R10, 14080 */
		/* 82222480h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 82222480h case    2:*/		return 0x82222484;
		  /* 82222484h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 82222484h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82222498;  }
		/* 82222484h case    3:*/		return 0x82222488;
		  /* 82222488h */ case    4:  		/* li R26, 0 */
		/* 82222488h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82222488h case    4:*/		return 0x8222248C;
		  /* 8222248Ch */ case    5:  		/* mr R3, R26 */
		/* 8222248Ch case    5:*/		regs.R3 = regs.R26;
		/* 8222248Ch case    5:*/		return 0x82222490;
		  /* 82222490h */ case    6:  		/* addi R1, R1, 144 */
		/* 82222490h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82222490h case    6:*/		return 0x82222494;
		  /* 82222494h */ case    7:  		/* b -1642996 */
		/* 82222494h case    7:*/		return 0x820912A0;
		/* 82222494h case    7:*/		return 0x82222498;
	}
	return 0x82222498;
} // Block from 82222478h-82222498h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82222498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222498);
		  /* 82222498h */ case    0:  		/* addi R30, R31, 44 */
		/* 82222498h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x2C);
		/* 82222498h case    0:*/		return 0x8222249C;
		  /* 8222249Ch */ case    1:  		/* li R29, 0 */
		/* 8222249Ch case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8222249Ch case    1:*/		return 0x822224A0;
		  /* 822224A0h */ case    2:  		/* rlwinm R27, R11, 13, 29, 31 */
		/* 822224A0h case    2:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R27,regs.R11);
		/* 822224A0h case    2:*/		return 0x822224A4;
		  /* 822224A4h */ case    3:  		/* mr R28, R30 */
		/* 822224A4h case    3:*/		regs.R28 = regs.R30;
		/* 822224A4h case    3:*/		return 0x822224A8;
		  /* 822224A8h */ case    4:  		/* cmplw CR6, R29, R27 */
		/* 822224A8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 822224A8h case    4:*/		return 0x822224AC;
		  /* 822224ACh */ case    5:  		/* bc 4, CR6_LT, -32 */
		/* 822224ACh case    5:*/		if ( !regs.CR[6].lt ) { return 0x8222248C;  }
		/* 822224ACh case    5:*/		return 0x822224B0;
		  /* 822224B0h */ case    6:  		/* lwz R31, <#[R28]> */
		/* 822224B0h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 822224B0h case    6:*/		return 0x822224B4;
		  /* 822224B4h */ case    7:  		/* mr R3, R31 */
		/* 822224B4h case    7:*/		regs.R3 = regs.R31;
		/* 822224B4h case    7:*/		return 0x822224B8;
		  /* 822224B8h */ case    8:  		/* bl -777352 */
		/* 822224B8h case    8:*/		regs.LR = 0x822224BC; return 0x82164830;
		/* 822224B8h case    8:*/		return 0x822224BC;
		  /* 822224BCh */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822224BCh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822224BCh case    9:*/		return 0x822224C0;
		  /* 822224C0h */ case   10:  		/* bc 12, CR0_EQ, 92 */
		/* 822224C0h case   10:*/		if ( regs.CR[0].eq ) { return 0x8222251C;  }
		/* 822224C0h case   10:*/		return 0x822224C4;
		  /* 822224C4h */ case   11:  		/* lwz R8, <#[R31 + 12]> */
		/* 822224C4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 822224C4h case   11:*/		return 0x822224C8;
		  /* 822224C8h */ case   12:  		/* lwz R11, <#[R8 + 8]> */
		/* 822224C8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 822224C8h case   12:*/		return 0x822224CC;
		  /* 822224CCh */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 822224CCh case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 822224CCh case   13:*/		return 0x822224D0;
		  /* 822224D0h */ case   14:  		/* cmplwi CR6, R11, 15872 */
		/* 822224D0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 822224D0h case   14:*/		return 0x822224D4;
		  /* 822224D4h */ case   15:  		/* bc 12, CR6_EQ, 72 */
		/* 822224D4h case   15:*/		if ( regs.CR[6].eq ) { return 0x8222251C;  }
		/* 822224D4h case   15:*/		return 0x822224D8;
		  /* 822224D8h */ case   16:  		/* li R9, 0 */
		/* 822224D8h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822224D8h case   16:*/		return 0x822224DC;
		  /* 822224DCh */ case   17:  		/* mr R10, R30 */
		/* 822224DCh case   17:*/		regs.R10 = regs.R30;
		/* 822224DCh case   17:*/		return 0x822224E0;
		  /* 822224E0h */ case   18:  		/* cmplw CR6, R9, R27 */
		/* 822224E0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R27);
		/* 822224E0h case   18:*/		return 0x822224E4;
		  /* 822224E4h */ case   19:  		/* bc 4, CR6_LT, 40 */
		/* 822224E4h case   19:*/		if ( !regs.CR[6].lt ) { return 0x8222250C;  }
		/* 822224E4h case   19:*/		return 0x822224E8;
		  /* 822224E8h */ case   20:  		/* lwz R11, <#[R10]> */
		/* 822224E8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 822224E8h case   20:*/		return 0x822224EC;
		  /* 822224ECh */ case   21:  		/* cmplw CR6, R11, R31 */
		/* 822224ECh case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 822224ECh case   21:*/		return 0x822224F0;
		  /* 822224F0h */ case   22:  		/* bc 12, CR6_EQ, 40 */
		/* 822224F0h case   22:*/		if ( regs.CR[6].eq ) { return 0x82222518;  }
		/* 822224F0h case   22:*/		return 0x822224F4;
		  /* 822224F4h */ case   23:  		/* lwz R7, <#[R11 + 12]> */
		/* 822224F4h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 822224F4h case   23:*/		return 0x822224F8;
	}
	return 0x822224F8;
} // Block from 82222498h-822224F8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 822224F8h
// Function '?NormalizeSwizzle@Instruction@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822224F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822224F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822224F8);
		  /* 822224F8h */ case    0:  		/* cmplw CR6, R7, R8 */
		/* 822224F8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 822224F8h case    0:*/		return 0x822224FC;
		  /* 822224FCh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 822224FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82222510;  }
		/* 822224FCh case    1:*/		return 0x82222500;
		  /* 82222500h */ case    2:  		/* addi R9, R9, 1 */
		/* 82222500h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82222500h case    2:*/		return 0x82222504;
		  /* 82222504h */ case    3:  		/* addi R10, R10, 4 */
		/* 82222504h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82222504h case    3:*/		return 0x82222508;
		  /* 82222508h */ case    4:  		/* b -40 */
		/* 82222508h case    4:*/		return 0x822224E0;
		/* 82222508h case    4:*/		return 0x8222250C;
	}
	return 0x8222250C;
} // Block from 822224F8h-8222250Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222250Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222250C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222250C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222250C);
		  /* 8222250Ch */ case    0:  		/* li R11, 0 */
		/* 8222250Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222250Ch case    0:*/		return 0x82222510;
	}
	return 0x82222510;
} // Block from 8222250Ch-82222510h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222510);
		  /* 82222510h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 82222510h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82222510h case    0:*/		return 0x82222514;
		  /* 82222514h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82222514h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222251C;  }
		/* 82222514h case    1:*/		return 0x82222518;
	}
	return 0x82222518;
} // Block from 82222510h-82222518h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222518);
		  /* 82222518h */ case    0:  		/* addi R26, R26, 1 */
		/* 82222518h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82222518h case    0:*/		return 0x8222251C;
	}
	return 0x8222251C;
} // Block from 82222518h-8222251Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222251Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222251C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222251C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222251C);
		  /* 8222251Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 8222251Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8222251Ch case    0:*/		return 0x82222520;
		  /* 82222520h */ case    1:  		/* addi R28, R28, 4 */
		/* 82222520h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82222520h case    1:*/		return 0x82222524;
		  /* 82222524h */ case    2:  		/* b -124 */
		/* 82222524h case    2:*/		return 0x822224A8;
		/* 82222524h case    2:*/		return 0x82222528;
	}
	return 0x82222528;
} // Block from 8222251Ch-82222528h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222528h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222528);
		  /* 82222528h */ case    0:  		/* mfspr R12, LR */
		/* 82222528h case    0:*/		regs.R12 = regs.LR;
		/* 82222528h case    0:*/		return 0x8222252C;
		  /* 8222252Ch */ case    1:  		/* bl -1643248 */
		/* 8222252Ch case    1:*/		regs.LR = 0x82222530; return 0x8209123C;
		/* 8222252Ch case    1:*/		return 0x82222530;
		  /* 82222530h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82222530h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82222530h case    2:*/		return 0x82222534;
		  /* 82222534h */ case    3:  		/* lwz R30, <#[R3 + 8]> */
		/* 82222534h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 82222534h case    3:*/		return 0x82222538;
		  /* 82222538h */ case    4:  		/* lis R11, -32252 */
		/* 82222538h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82222538h case    4:*/		return 0x8222253C;
		  /* 8222253Ch */ case    5:  		/* mr R26, R3 */
		/* 8222253Ch case    5:*/		regs.R26 = regs.R3;
		/* 8222253Ch case    5:*/		return 0x82222540;
		  /* 82222540h */ case    6:  		/* addi R29, R11, -704 */
		/* 82222540h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFD40);
		/* 82222540h case    6:*/		return 0x82222544;
		  /* 82222544h */ case    7:  		/* rlwinm R25, R30, 31, 28, 31 */
		/* 82222544h case    7:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R25,regs.R30);
		/* 82222544h case    7:*/		return 0x82222548;
		  /* 82222548h */ case    8:  		/* rlwinm R27, R30, 25, 25, 31 */
		/* 82222548h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R27,regs.R30);
		/* 82222548h case    8:*/		return 0x8222254C;
		  /* 8222254Ch */ case    9:  		/* add R11, R25, R29 */
		/* 8222254Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R25,regs.R29);
		/* 8222254Ch case    9:*/		return 0x82222550;
		  /* 82222550h */ case   10:  		/* mr R21, R4 */
		/* 82222550h case   10:*/		regs.R21 = regs.R4;
		/* 82222550h case   10:*/		return 0x82222554;
		  /* 82222554h */ case   11:  		/* mr R31, R5 */
		/* 82222554h case   11:*/		regs.R31 = regs.R5;
		/* 82222554h case   11:*/		return 0x82222558;
		  /* 82222558h */ case   12:  		/* li R24, 1 */
		/* 82222558h case   12:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 82222558h case   12:*/		return 0x8222255C;
		  /* 8222255Ch */ case   13:  		/* rlwinm R22, R4, 0, 28, 31 */
		/* 8222255Ch case   13:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R22,regs.R4);
		/* 8222255Ch case   13:*/		return 0x82222560;
		  /* 82222560h */ case   14:  		/* lbz R11, <#[R11 - 1]> */
		/* 82222560h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 82222560h case   14:*/		return 0x82222564;
		  /* 82222564h */ case   15:  		/* cmplwi CR6, R27, 96 */
		/* 82222564h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000060);
		/* 82222564h case   15:*/		return 0x82222568;
		  /* 82222568h */ case   16:  		/* rlwinm R10, R11, 27, 5, 30 */
		/* 82222568h case   16:*/		cpu::op::rlwinm<0,27,5,30>(regs,&regs.R10,regs.R11);
		/* 82222568h case   16:*/		return 0x8222256C;
		  /* 8222256Ch */ case   17:  		/* rlwinm R9, R11, 29, 29, 30 */
		/* 8222256Ch case   17:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R9,regs.R11);
		/* 8222256Ch case   17:*/		return 0x82222570;
		  /* 82222570h */ case   18:  		/* srw R10, R5, R10 */
		/* 82222570h case   18:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 82222570h case   18:*/		return 0x82222574;
		  /* 82222574h */ case   19:  		/* srw R9, R5, R9 */
		/* 82222574h case   19:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 82222574h case   19:*/		return 0x82222578;
		  /* 82222578h */ case   20:  		/* rlwimi R9, R10, 2, 28, 29 */
		/* 82222578h case   20:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R9,regs.R10);
		/* 82222578h case   20:*/		return 0x8222257C;
		  /* 8222257Ch */ case   21:  		/* rlwinm R10, R11, 31, 29, 30 */
		/* 8222257Ch case   21:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R10,regs.R11);
		/* 8222257Ch case   21:*/		return 0x82222580;
		  /* 82222580h */ case   22:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 82222580h case   22:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 82222580h case   22:*/		return 0x82222584;
		  /* 82222584h */ case   23:  		/* srw R10, R5, R10 */
		/* 82222584h case   23:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 82222584h case   23:*/		return 0x82222588;
		  /* 82222588h */ case   24:  		/* rlwinm R11, R11, 1, 29, 30 */
		/* 82222588h case   24:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R11,regs.R11);
		/* 82222588h case   24:*/		return 0x8222258C;
		  /* 8222258Ch */ case   25:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 8222258Ch case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8222258Ch case   25:*/		return 0x82222590;
		  /* 82222590h */ case   26:  		/* srw R23, R5, R11 */
		/* 82222590h case   26:*/		cpu::op::srw<0>(regs,&regs.R23,regs.R5,regs.R11);
		/* 82222590h case   26:*/		return 0x82222594;
		  /* 82222594h */ case   27:  		/* rlwimi R23, R10, 2, 0, 29 */
		/* 82222594h case   27:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R23,regs.R10);
		/* 82222594h case   27:*/		return 0x82222598;
		  /* 82222598h */ case   28:  		/* bc 12, CR6_LT, 16 */
		/* 82222598h case   28:*/		if ( regs.CR[6].lt ) { return 0x822225A8;  }
		/* 82222598h case   28:*/		return 0x8222259C;
		  /* 8222259Ch */ case   29:  		/* cmplwi CR6, R27, 102 */
		/* 8222259Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000066);
		/* 8222259Ch case   29:*/		return 0x822225A0;
		  /* 822225A0h */ case   30:  		/* mr R11, R24 */
		/* 822225A0h case   30:*/		regs.R11 = regs.R24;
		/* 822225A0h case   30:*/		return 0x822225A4;
		  /* 822225A4h */ case   31:  		/* bc 4, CR6_GT, 8 */
		/* 822225A4h case   31:*/		if ( !regs.CR[6].gt ) { return 0x822225AC;  }
		/* 822225A4h case   31:*/		return 0x822225A8;
	}
	return 0x822225A8;
} // Block from 82222528h-822225A8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 822225A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822225A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822225A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822225A8);
		  /* 822225A8h */ case    0:  		/* li R11, 0 */
		/* 822225A8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822225A8h case    0:*/		return 0x822225AC;
	}
	return 0x822225AC;
} // Block from 822225A8h-822225ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822225ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822225AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822225AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822225AC);
		  /* 822225ACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822225ACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822225ACh case    0:*/		return 0x822225B0;
		  /* 822225B0h */ case    1:  		/* bc 12, CR0_EQ, 620 */
		/* 822225B0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8222281C;  }
		/* 822225B0h case    1:*/		return 0x822225B4;
		  /* 822225B4h */ case    2:  		/* li R7, 0 */
		/* 822225B4h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 822225B4h case    2:*/		return 0x822225B8;
		  /* 822225B8h */ case    3:  		/* li R6, 0 */
		/* 822225B8h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822225B8h case    3:*/		return 0x822225BC;
		  /* 822225BCh */ case    4:  		/* li R8, 228 */
		/* 822225BCh case    4:*/		cpu::op::li<0>(regs,&regs.R8,0xE4);
		/* 822225BCh case    4:*/		return 0x822225C0;
		  /* 822225C0h */ case    5:  		/* cmplwi CR6, R27, 96 */
		/* 822225C0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000060);
		/* 822225C0h case    5:*/		return 0x822225C4;
		  /* 822225C4h */ case    6:  		/* bc 4, CR6_EQ, 60 */
		/* 822225C4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82222600;  }
		/* 822225C4h case    6:*/		return 0x822225C8;
		  /* 822225C8h */ case    7:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 822225C8h case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 822225C8h case    7:*/		return 0x822225CC;
		  /* 822225CCh */ case    8:  		/* rlwinm R6, R30, 18, 29, 31 */
		/* 822225CCh case    8:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R30);
		/* 822225CCh case    8:*/		return 0x822225D0;
		  /* 822225D0h */ case    9:  		/* rlwinm R5, R30, 13, 29, 31 */
		/* 822225D0h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R30);
		/* 822225D0h case    9:*/		return 0x822225D4;
		  /* 822225D4h */ case   10:  		/* li R4, 96 */
		/* 822225D4h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 822225D4h case   10:*/		return 0x822225D8;
		  /* 822225D8h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 822225D8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822225D8h case   11:*/		return 0x822225DC;
		  /* 822225DCh */ case   12:  		/* lwz R3, <#[R11 + 148]> */
		/* 822225DCh case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 822225DCh case   12:*/		return 0x822225E0;
		  /* 822225E0h */ case   13:  		/* bl -778672 */
		/* 822225E0h case   13:*/		regs.LR = 0x822225E4; return 0x82164430;
		/* 822225E0h case   13:*/		return 0x822225E4;
		  /* 822225E4h */ case   14:  		/* addi R11, R26, -20 */
		/* 822225E4h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFEC);
		/* 822225E4h case   14:*/		return 0x822225E8;
		  /* 822225E8h */ case   15:  		/* add R11, R3, R11 */
		/* 822225E8h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 822225E8h case   15:*/		return 0x822225EC;
		  /* 822225ECh */ case   16:  		/* lwz R11, <#[R11 + 12]> */
		/* 822225ECh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 822225ECh case   16:*/		return 0x822225F0;
		  /* 822225F0h */ case   17:  		/* rlwinm R7, R11, 20, 28, 31 */
		/* 822225F0h case   17:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R7,regs.R11);
		/* 822225F0h case   17:*/		return 0x822225F4;
		  /* 822225F4h */ case   18:  		/* rlwinm R6, R11, 24, 28, 31 */
		/* 822225F4h case   18:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R6,regs.R11);
		/* 822225F4h case   18:*/		return 0x822225F8;
		  /* 822225F8h */ case   19:  		/* rlwinm R8, R11, 15, 24, 31 */
		/* 822225F8h case   19:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R8,regs.R11);
		/* 822225F8h case   19:*/		return 0x822225FC;
		  /* 822225FCh */ case   20:  		/* b 96 */
		/* 822225FCh case   20:*/		return 0x8222265C;
		/* 822225FCh case   20:*/		return 0x82222600;
	}
	return 0x82222600;
} // Block from 822225ACh-82222600h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82222600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222600);
		  /* 82222600h */ case    0:  		/* cmplwi CR6, R27, 97 */
		/* 82222600h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000061);
		/* 82222600h case    0:*/		return 0x82222604;
		  /* 82222604h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82222604h case    1:*/		if ( regs.CR[6].eq ) { return 0x8222261C;  }
		/* 82222604h case    1:*/		return 0x82222608;
		  /* 82222608h */ case    2:  		/* cmplwi CR6, R27, 99 */
		/* 82222608h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000063);
		/* 82222608h case    2:*/		return 0x8222260C;
		  /* 8222260Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8222260Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8222261C;  }
		/* 8222260Ch case    3:*/		return 0x82222610;
		  /* 82222610h */ case    4:  		/* cmplwi CR6, R27, 100 */
		/* 82222610h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000064);
		/* 82222610h case    4:*/		return 0x82222614;
		  /* 82222614h */ case    5:  		/* li R11, 0 */
		/* 82222614h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82222614h case    5:*/		return 0x82222618;
		  /* 82222618h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82222618h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82222620;  }
		/* 82222618h case    6:*/		return 0x8222261C;
	}
	return 0x8222261C;
} // Block from 82222600h-8222261Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222261Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222261C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222261C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222261C);
		  /* 8222261Ch */ case    0:  		/* mr R11, R24 */
		/* 8222261Ch case    0:*/		regs.R11 = regs.R24;
		/* 8222261Ch case    0:*/		return 0x82222620;
	}
	return 0x82222620;
} // Block from 8222261Ch-82222620h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222620);
		  /* 82222620h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82222620h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82222620h case    0:*/		return 0x82222624;
		  /* 82222624h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 82222624h case    1:*/		if ( regs.CR[0].eq ) { return 0x8222265C;  }
		/* 82222624h case    1:*/		return 0x82222628;
		  /* 82222628h */ case    2:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 82222628h case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 82222628h case    2:*/		return 0x8222262C;
		  /* 8222262Ch */ case    3:  		/* rlwinm R6, R30, 18, 29, 31 */
		/* 8222262Ch case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R30);
		/* 8222262Ch case    3:*/		return 0x82222630;
		  /* 82222630h */ case    4:  		/* rlwinm R5, R30, 13, 29, 31 */
		/* 82222630h case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R30);
		/* 82222630h case    4:*/		return 0x82222634;
		  /* 82222634h */ case    5:  		/* mr R4, R27 */
		/* 82222634h case    5:*/		regs.R4 = regs.R27;
		/* 82222634h case    5:*/		return 0x82222638;
		  /* 82222638h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 82222638h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222638h case    6:*/		return 0x8222263C;
		  /* 8222263Ch */ case    7:  		/* lwz R3, <#[R11 + 148]> */
		/* 8222263Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 8222263Ch case    7:*/		return 0x82222640;
		  /* 82222640h */ case    8:  		/* bl -778768 */
		/* 82222640h case    8:*/		regs.LR = 0x82222644; return 0x82164430;
		/* 82222640h case    8:*/		return 0x82222644;
		  /* 82222644h */ case    9:  		/* addi R11, R26, -24 */
		/* 82222644h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFE8);
		/* 82222644h case    9:*/		return 0x82222648;
		  /* 82222648h */ case   10:  		/* add R11, R3, R11 */
		/* 82222648h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82222648h case   10:*/		return 0x8222264C;
		  /* 8222264Ch */ case   11:  		/* lwz R10, <#[R11 + 12]> */
		/* 8222264Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222264Ch case   11:*/		return 0x82222650;
		  /* 82222650h */ case   12:  		/* lbz R8, <#[R11 + 14]> */
		/* 82222650h case   12:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000E) );
		/* 82222650h case   12:*/		return 0x82222654;
		  /* 82222654h */ case   13:  		/* rlwinm R7, R10, 28, 28, 31 */
		/* 82222654h case   13:*/		cpu::op::rlwinm<0,28,28,31>(regs,&regs.R7,regs.R10);
		/* 82222654h case   13:*/		return 0x82222658;
		  /* 82222658h */ case   14:  		/* rlwinm R6, R10, 0, 28, 31 */
		/* 82222658h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R10);
		/* 82222658h case   14:*/		return 0x8222265C;
	}
	return 0x8222265C;
} // Block from 82222620h-8222265Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222265Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222265C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222265C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222265C);
		  /* 8222265Ch */ case    0:  		/* li R28, 0 */
		/* 8222265Ch case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8222265Ch case    0:*/		return 0x82222660;
		  /* 82222660h */ case    1:  		/* li R29, 0 */
		/* 82222660h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82222660h case    1:*/		return 0x82222664;
		  /* 82222664h */ case    2:  		/* li R31, 0 */
		/* 82222664h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82222664h case    2:*/		return 0x82222668;
		  /* 82222668h */ case    3:  		/* mr R10, R25 */
		/* 82222668h case    3:*/		regs.R10 = regs.R25;
		/* 82222668h case    3:*/		return 0x8222266C;
		  /* 8222266Ch */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8222266Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222266Ch case    4:*/		return 0x82222670;
		  /* 82222670h */ case    5:  		/* bc 12, CR6_EQ, 108 */
		/* 82222670h case    5:*/		if ( regs.CR[6].eq ) { return 0x822226DC;  }
		/* 82222670h case    5:*/		return 0x82222674;
		  /* 82222674h */ case    6:  		/* addi R11, R10, -1 */
		/* 82222674h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82222674h case    6:*/		return 0x82222678;
		  /* 82222678h */ case    7:  		/* li R5, 3 */
		/* 82222678h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82222678h case    7:*/		return 0x8222267C;
		  /* 8222267Ch */ case    8:  		/* andc R11, R10, R11 */
		/* 8222267Ch case    8:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8222267Ch case    8:*/		return 0x82222680;
		  /* 82222680h */ case    9:  		/* cntlzw R11, R11 */
		/* 82222680h case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82222680h case    9:*/		return 0x82222684;
		  /* 82222684h */ case   10:  		/* subfic R11, R11, 31 */
		/* 82222684h case   10:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82222684h case   10:*/		return 0x82222688;
		  /* 82222688h */ case   11:  		/* rlwinm R4, R11, 1, 0, 30 */
		/* 82222688h case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R4,regs.R11);
		/* 82222688h case   11:*/		return 0x8222268C;
		  /* 8222268Ch */ case   12:  		/* slw R9, R24, R11 */
		/* 8222268Ch case   12:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R24,regs.R11);
		/* 8222268Ch case   12:*/		return 0x82222690;
		  /* 82222690h */ case   13:  		/* srw R11, R23, R4 */
		/* 82222690h case   13:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R23,regs.R4);
		/* 82222690h case   13:*/		return 0x82222694;
		  /* 82222694h */ case   14:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82222694h case   14:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82222694h case   14:*/		return 0x82222698;
		  /* 82222698h */ case   15:  		/* srw R4, R8, R4 */
		/* 82222698h case   15:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R8,regs.R4);
		/* 82222698h case   15:*/		return 0x8222269C;
		  /* 8222269Ch */ case   16:  		/* rlwinm R3, R11, 1, 0, 30 */
		/* 8222269Ch case   16:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R3,regs.R11);
		/* 8222269Ch case   16:*/		return 0x822226A0;
		  /* 822226A0h */ case   17:  		/* rlwinm R4, R4, 0, 30, 31 */
		/* 822226A0h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R4);
		/* 822226A0h case   17:*/		return 0x822226A4;
		  /* 822226A4h */ case   18:  		/* slw R5, R5, R3 */
		/* 822226A4h case   18:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R5,regs.R3);
		/* 822226A4h case   18:*/		return 0x822226A8;
		  /* 822226A8h */ case   19:  		/* slw R4, R4, R3 */
		/* 822226A8h case   19:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R4,regs.R3);
		/* 822226A8h case   19:*/		return 0x822226AC;
		  /* 822226ACh */ case   20:  		/* andc R5, R31, R5 */
		/* 822226ACh case   20:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R31,regs.R5);
		/* 822226ACh case   20:*/		return 0x822226B0;
		  /* 822226B0h */ case   21:  		/* and. R3, R9, R7 */
		/* 822226B0h case   21:*/		cpu::op::and<1>(regs,&regs.R3,regs.R9,regs.R7);
		/* 822226B0h case   21:*/		return 0x822226B4;
		  /* 822226B4h */ case   22:  		/* or R31, R4, R5 */
		/* 822226B4h case   22:*/		cpu::op::or<0>(regs,&regs.R31,regs.R4,regs.R5);
		/* 822226B4h case   22:*/		return 0x822226B8;
		  /* 822226B8h */ case   23:  		/* bc 12, CR0_EQ, 8 */
		/* 822226B8h case   23:*/		if ( regs.CR[0].eq ) { return 0x822226C0;  }
		/* 822226B8h case   23:*/		return 0x822226BC;
		  /* 822226BCh */ case   24:  		/* slw R28, R24, R11 */
		/* 822226BCh case   24:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R24,regs.R11);
		/* 822226BCh case   24:*/		return 0x822226C0;
	}
	return 0x822226C0;
} // Block from 8222265Ch-822226C0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 822226C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822226C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822226C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822226C0);
		  /* 822226C0h */ case    0:  		/* and. R9, R9, R6 */
		/* 822226C0h case    0:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R6);
		/* 822226C0h case    0:*/		return 0x822226C4;
		  /* 822226C4h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 822226C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822226CC;  }
		/* 822226C4h case    1:*/		return 0x822226C8;
		  /* 822226C8h */ case    2:  		/* slw R29, R24, R11 */
		/* 822226C8h case    2:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R24,regs.R11);
		/* 822226C8h case    2:*/		return 0x822226CC;
	}
	return 0x822226CC;
} // Block from 822226C0h-822226CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822226CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822226CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822226CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822226CC);
		  /* 822226CCh */ case    0:  		/* addi R11, R10, -1 */
		/* 822226CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 822226CCh case    0:*/		return 0x822226D0;
		  /* 822226D0h */ case    1:  		/* andc R11, R10, R11 */
		/* 822226D0h case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822226D0h case    1:*/		return 0x822226D4;
		  /* 822226D4h */ case    2:  		/* subf R10, R11, R10 */
		/* 822226D4h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822226D4h case    2:*/		return 0x822226D8;
		  /* 822226D8h */ case    3:  		/* b -108 */
		/* 822226D8h case    3:*/		return 0x8222266C;
		/* 822226D8h case    3:*/		return 0x822226DC;
	}
	return 0x822226DC;
} // Block from 822226CCh-822226DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822226DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822226DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822226DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822226DC);
		  /* 822226DCh */ case    0:  		/* cmplwi CR6, R27, 96 */
		/* 822226DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000060);
		/* 822226DCh case    0:*/		return 0x822226E0;
		  /* 822226E0h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 822226E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222272C;  }
		/* 822226E0h case    1:*/		return 0x822226E4;
		  /* 822226E4h */ case    2:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 822226E4h case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 822226E4h case    2:*/		return 0x822226E8;
		  /* 822226E8h */ case    3:  		/* rlwinm R6, R30, 18, 29, 31 */
		/* 822226E8h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R30);
		/* 822226E8h case    3:*/		return 0x822226EC;
		  /* 822226ECh */ case    4:  		/* rlwinm R5, R30, 13, 29, 31 */
		/* 822226ECh case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R30);
		/* 822226ECh case    4:*/		return 0x822226F0;
		  /* 822226F0h */ case    5:  		/* li R4, 96 */
		/* 822226F0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 822226F0h case    5:*/		return 0x822226F4;
		  /* 822226F4h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 822226F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822226F4h case    6:*/		return 0x822226F8;
		  /* 822226F8h */ case    7:  		/* lwz R3, <#[R11 + 148]> */
		/* 822226F8h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 822226F8h case    7:*/		return 0x822226FC;
		  /* 822226FCh */ case    8:  		/* bl -778956 */
		/* 822226FCh case    8:*/		regs.LR = 0x82222700; return 0x82164430;
		/* 822226FCh case    8:*/		return 0x82222700;
		  /* 82222700h */ case    9:  		/* addi R11, R26, -20 */
		/* 82222700h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFEC);
		/* 82222700h case    9:*/		return 0x82222704;
		  /* 82222704h */ case   10:  		/* rlwimi R28, R31, 5, 19, 26 */
		/* 82222704h case   10:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R28,regs.R31);
		/* 82222704h case   10:*/		return 0x82222708;
		  /* 82222708h */ case   11:  		/* add R11, R3, R11 */
		/* 82222708h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82222708h case   11:*/		return 0x8222270C;
		  /* 8222270Ch */ case   12:  		/* andi. R10, R28, 8175 */
		/* 8222270Ch case   12:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R28,0x1FEF);
		/* 8222270Ch case   12:*/		return 0x82222710;
		  /* 82222710h */ case   13:  		/* rlwimi R29, R10, 4, 0, 27 */
		/* 82222710h case   13:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R29,regs.R10);
		/* 82222710h case   13:*/		return 0x82222714;
		  /* 82222714h */ case   14:  		/* lwz R10, <#[R11 + 12]> */
		/* 82222714h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82222714h case   14:*/		return 0x82222718;
		  /* 82222718h */ case   15:  		/* rlwinm R10, R10, 0, 24, 15 */
		/* 82222718h case   15:*/		cpu::op::rlwinm<0,0,24,15>(regs,&regs.R10,regs.R10);
		/* 82222718h case   15:*/		return 0x8222271C;
		  /* 8222271Ch */ case   16:  		/* rlwinm R9, R29, 8, 0, 23 */
		/* 8222271Ch case   16:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R9,regs.R29);
		/* 8222271Ch case   16:*/		return 0x82222720;
		  /* 82222720h */ case   17:  		/* rlwinm R10, R10, 0, 15, 6 */
		/* 82222720h case   17:*/		cpu::op::rlwinm<0,0,15,6>(regs,&regs.R10,regs.R10);
		/* 82222720h case   17:*/		return 0x82222724;
		  /* 82222724h */ case   18:  		/* or R10, R9, R10 */
		/* 82222724h case   18:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82222724h case   18:*/		return 0x82222728;
		  /* 82222728h */ case   19:  		/* b 96 */
		/* 82222728h case   19:*/		return 0x82222788;
		/* 82222728h case   19:*/		return 0x8222272C;
	}
	return 0x8222272C;
} // Block from 822226DCh-8222272Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8222272Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222272C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222272C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222272C);
		  /* 8222272Ch */ case    0:  		/* cmplwi CR6, R27, 97 */
		/* 8222272Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000061);
		/* 8222272Ch case    0:*/		return 0x82222730;
		  /* 82222730h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82222730h case    1:*/		if ( regs.CR[6].eq ) { return 0x82222748;  }
		/* 82222730h case    1:*/		return 0x82222734;
		  /* 82222734h */ case    2:  		/* cmplwi CR6, R27, 99 */
		/* 82222734h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000063);
		/* 82222734h case    2:*/		return 0x82222738;
		  /* 82222738h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82222738h case    3:*/		if ( regs.CR[6].eq ) { return 0x82222748;  }
		/* 82222738h case    3:*/		return 0x8222273C;
		  /* 8222273Ch */ case    4:  		/* cmplwi CR6, R27, 100 */
		/* 8222273Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000064);
		/* 8222273Ch case    4:*/		return 0x82222740;
		  /* 82222740h */ case    5:  		/* li R11, 0 */
		/* 82222740h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82222740h case    5:*/		return 0x82222744;
		  /* 82222744h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82222744h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8222274C;  }
		/* 82222744h case    6:*/		return 0x82222748;
	}
	return 0x82222748;
} // Block from 8222272Ch-82222748h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222748h
// Function '?DecodeSwizzle@D3DXShader@@YAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222748);
		  /* 82222748h */ case    0:  		/* mr R11, R24 */
		/* 82222748h case    0:*/		regs.R11 = regs.R24;
		/* 82222748h case    0:*/		return 0x8222274C;
	}
	return 0x8222274C;
} // Block from 82222748h-8222274Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222274Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222274C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222274C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222274C);
		  /* 8222274Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8222274Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8222274Ch case    0:*/		return 0x82222750;
		  /* 82222750h */ case    1:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 82222750h case    1:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 82222750h case    1:*/		return 0x82222754;
		  /* 82222754h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82222754h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222754h case    2:*/		return 0x82222758;
		  /* 82222758h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82222758h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82222758h case    3:*/		return 0x8222275C;
		  /* 8222275Ch */ case    4:  		/* bc 12, CR0_EQ, 176 */
		/* 8222275Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8222280C;  }
		/* 8222275Ch case    4:*/		return 0x82222760;
		  /* 82222760h */ case    5:  		/* rlwinm R6, R30, 18, 29, 31 */
		/* 82222760h case    5:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R30);
		/* 82222760h case    5:*/		return 0x82222764;
		  /* 82222764h */ case    6:  		/* rlwinm R5, R30, 13, 29, 31 */
		/* 82222764h case    6:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R30);
		/* 82222764h case    6:*/		return 0x82222768;
		  /* 82222768h */ case    7:  		/* mr R4, R27 */
		/* 82222768h case    7:*/		regs.R4 = regs.R27;
		/* 82222768h case    7:*/		return 0x8222276C;
		  /* 8222276Ch */ case    8:  		/* bl -779068 */
		/* 8222276Ch case    8:*/		regs.LR = 0x82222770; return 0x82164430;
		/* 8222276Ch case    8:*/		return 0x82222770;
		  /* 82222770h */ case    9:  		/* addi R11, R26, -24 */
		/* 82222770h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFE8);
		/* 82222770h case    9:*/		return 0x82222774;
		  /* 82222774h */ case   10:  		/* add R11, R3, R11 */
		/* 82222774h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82222774h case   10:*/		return 0x82222778;
		  /* 82222778h */ case   11:  		/* stb R31, <#[R11 + 14]> */
		/* 82222778h case   11:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R11 + 0x0000000E) );
		/* 82222778h case   11:*/		return 0x8222277C;
		  /* 8222277Ch */ case   12:  		/* lwz R10, <#[R11 + 12]> */
		/* 8222277Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222277Ch case   12:*/		return 0x82222780;
		  /* 82222780h */ case   13:  		/* rlwimi R10, R28, 4, 24, 27 */
		/* 82222780h case   13:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R10,regs.R28);
		/* 82222780h case   13:*/		return 0x82222784;
		  /* 82222784h */ case   14:  		/* rlwimi R10, R29, 0, 28, 31 */
		/* 82222784h case   14:*/		cpu::op::rlwimi<0,0,28,31>(regs,&regs.R10,regs.R29);
		/* 82222784h case   14:*/		return 0x82222788;
	}
	return 0x82222788;
} // Block from 8222274Ch-82222788h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82222788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222788);
		  /* 82222788h */ case    0:  		/* stw R10, <#[R11 + 12]> */
		/* 82222788h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82222788h case    0:*/		return 0x8222278C;
		  /* 8222278Ch */ case    1:  		/* lwz R10, <#[R26 + 4]> */
		/* 8222278Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 8222278Ch case    1:*/		return 0x82222790;
	}
	return 0x82222790;
} // Block from 82222788h-82222790h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222790h
// Function '?EncodeOperand@Instruction@D3DXShader@@QAAIIPATGPUALU_INSTRUCTION@@IPAUVectorOperandEncoding@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222790);
		  /* 82222790h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82222790h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82222790h case    0:*/		return 0x82222794;
		  /* 82222794h */ case    1:  		/* bc 12, CR6_EQ, 516 */
		/* 82222794h case    1:*/		if ( regs.CR[6].eq ) { return 0x82222998;  }
		/* 82222794h case    1:*/		return 0x82222798;
		  /* 82222798h */ case    2:  		/* lwz R11, <#[R10]> */
		/* 82222798h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82222798h case    2:*/		return 0x8222279C;
		  /* 8222279Ch */ case    3:  		/* rlwinm. R9, R11, 0, 4, 6 */
		/* 8222279Ch case    3:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R11);
		/* 8222279Ch case    3:*/		return 0x822227A0;
		  /* 822227A0h */ case    4:  		/* bc 12, CR0_EQ, 100 */
		/* 822227A0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82222804;  }
		/* 822227A0h case    4:*/		return 0x822227A4;
		  /* 822227A4h */ case    5:  		/* cmplwi CR6, R23, 228 */
		/* 822227A4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x000000E4);
		/* 822227A4h case    5:*/		return 0x822227A8;
		  /* 822227A8h */ case    6:  		/* bc 12, CR6_EQ, 68 */
		/* 822227A8h case    6:*/		if ( regs.CR[6].eq ) { return 0x822227EC;  }
		/* 822227A8h case    6:*/		return 0x822227AC;
		  /* 822227ACh */ case    7:  		/* rlwinm R9, R11, 22, 29, 30 */
		/* 822227ACh case    7:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R11);
		/* 822227ACh case    7:*/		return 0x822227B0;
		  /* 822227B0h */ case    8:  		/* rlwinm R8, R11, 24, 29, 30 */
		/* 822227B0h case    8:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R11);
		/* 822227B0h case    8:*/		return 0x822227B4;
		  /* 822227B4h */ case    9:  		/* srw R9, R23, R9 */
		/* 822227B4h case    9:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R23,regs.R9);
		/* 822227B4h case    9:*/		return 0x822227B8;
		  /* 822227B8h */ case   10:  		/* srw R8, R23, R8 */
		/* 822227B8h case   10:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R23,regs.R8);
		/* 822227B8h case   10:*/		return 0x822227BC;
		  /* 822227BCh */ case   11:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 822227BCh case   11:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 822227BCh case   11:*/		return 0x822227C0;
		  /* 822227C0h */ case   12:  		/* rlwinm R9, R11, 26, 29, 30 */
		/* 822227C0h case   12:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R11);
		/* 822227C0h case   12:*/		return 0x822227C4;
		  /* 822227C4h */ case   13:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 822227C4h case   13:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 822227C4h case   13:*/		return 0x822227C8;
		  /* 822227C8h */ case   14:  		/* srw R9, R23, R9 */
		/* 822227C8h case   14:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R23,regs.R9);
		/* 822227C8h case   14:*/		return 0x822227CC;
		  /* 822227CCh */ case   15:  		/* rlwinm R7, R11, 28, 29, 30 */
		/* 822227CCh case   15:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R11);
		/* 822227CCh case   15:*/		return 0x822227D0;
		  /* 822227D0h */ case   16:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 822227D0h case   16:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 822227D0h case   16:*/		return 0x822227D4;
		  /* 822227D4h */ case   17:  		/* srw R8, R23, R7 */
		/* 822227D4h case   17:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R23,regs.R7);
		/* 822227D4h case   17:*/		return 0x822227D8;
		  /* 822227D8h */ case   18:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 822227D8h case   18:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 822227D8h case   18:*/		return 0x822227DC;
		  /* 822227DCh */ case   19:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 822227DCh case   19:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 822227DCh case   19:*/		return 0x822227E0;
		  /* 822227E0h */ case   20:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 822227E0h case   20:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 822227E0h case   20:*/		return 0x822227E4;
		  /* 822227E4h */ case   21:  		/* or R11, R9, R11 */
		/* 822227E4h case   21:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822227E4h case   21:*/		return 0x822227E8;
		  /* 822227E8h */ case   22:  		/* stw R11, <#[R10]> */
		/* 822227E8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 822227E8h case   22:*/		return 0x822227EC;
	}
	return 0x822227EC;
} // Block from 82222790h-822227ECh (23 instructions)

//////////////////////////////////////////////////////
// Block at 822227ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822227EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822227EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822227EC);
		  /* 822227ECh */ case    0:  		/* lwz R11, <#[R10]> */
		/* 822227ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 822227ECh case    0:*/		return 0x822227F0;
		  /* 822227F0h */ case    1:  		/* lis R9, 16384 */
		/* 822227F0h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 822227F0h case    1:*/		return 0x822227F4;
		  /* 822227F4h */ case    2:  		/* rlwimi R9, R21, 13, 7, 18 */
		/* 822227F4h case    2:*/		cpu::op::rlwimi<0,13,7,18>(regs,&regs.R9,regs.R21);
		/* 822227F4h case    2:*/		return 0x822227F8;
		  /* 822227F8h */ case    3:  		/* rlwinm R11, R11, 0, 19, 6 */
		/* 822227F8h case    3:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R11,regs.R11);
		/* 822227F8h case    3:*/		return 0x822227FC;
		  /* 822227FCh */ case    4:  		/* or R11, R9, R11 */
		/* 822227FCh case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822227FCh case    4:*/		return 0x82222800;
		  /* 82222800h */ case    5:  		/* stw R11, <#[R10]> */
		/* 82222800h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82222800h case    5:*/		return 0x82222804;
	}
	return 0x82222804;
} // Block from 822227ECh-82222804h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82222804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222804);
		  /* 82222804h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82222804h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82222804h case    0:*/		return 0x82222808;
		  /* 82222808h */ case    1:  		/* b -120 */
		/* 82222808h case    1:*/		return 0x82222790;
		/* 82222808h case    1:*/		return 0x8222280C;
	}
	return 0x8222280C;
} // Block from 82222804h-8222280Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222280Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222280C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222280C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222280C);
		  /* 8222280Ch */ case    0:  		/* lis R10, -32252 */
		/* 8222280Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8222280Ch case    0:*/		return 0x82222810;
		  /* 82222810h */ case    1:  		/* li R4, 3500 */
		/* 82222810h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 82222810h case    1:*/		return 0x82222814;
		  /* 82222814h */ case    2:  		/* addi R5, R10, -328 */
		/* 82222814h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFEB8);
		/* 82222814h case    2:*/		return 0x82222818;
		  /* 82222818h */ case    3:  		/* bl -854448 */
		/* 82222818h case    3:*/		regs.LR = 0x8222281C; return 0x82151E68;
		/* 82222818h case    3:*/		return 0x8222281C;
	}
	return 0x8222281C;
} // Block from 8222280Ch-8222281Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222281Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222281C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222281C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222281C);
		  /* 8222281Ch */ case    0:  		/* cmplwi CR6, R23, 228 */
		/* 8222281Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x000000E4);
		/* 8222281Ch case    0:*/		return 0x82222820;
		  /* 82222820h */ case    1:  		/* bc 12, CR6_EQ, -148 */
		/* 82222820h case    1:*/		if ( regs.CR[6].eq ) { return 0x8222278C;  }
		/* 82222820h case    1:*/		return 0x82222824;
		  /* 82222824h */ case    2:  		/* mr R3, R26 */
		/* 82222824h case    2:*/		regs.R3 = regs.R26;
		/* 82222824h case    2:*/		return 0x82222828;
		  /* 82222828h */ case    3:  		/* bl -727584 */
		/* 82222828h case    3:*/		regs.LR = 0x8222282C; return 0x82170E08;
		/* 82222828h case    3:*/		return 0x8222282C;
		  /* 8222282Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222282Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222282Ch case    4:*/		return 0x82222830;
		  /* 82222830h */ case    5:  		/* bc 12, CR0_EQ, -164 */
		/* 82222830h case    5:*/		if ( regs.CR[0].eq ) { return 0x8222278C;  }
		/* 82222830h case    5:*/		return 0x82222834;
		  /* 82222834h */ case    6:  		/* lis R11, -28311 */
		/* 82222834h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 82222834h case    6:*/		return 0x82222838;
		  /* 82222838h */ case    7:  		/* lis R10, 0 */
		/* 82222838h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 82222838h case    7:*/		return 0x8222283C;
		  /* 8222283Ch */ case    8:  		/* add R9, R22, R29 */
		/* 8222283Ch case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R22,regs.R29);
		/* 8222283Ch case    8:*/		return 0x82222840;
		  /* 82222840h */ case    9:  		/* ori R11, R11, 5192 */
		/* 82222840h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 82222840h case    9:*/		return 0x82222844;
		  /* 82222844h */ case   10:  		/* ori R10, R10, 36262 */
		/* 82222844h case   10:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 82222844h case   10:*/		return 0x82222848;
		  /* 82222848h */ case   11:  		/* rlwinm R7, R31, 29, 29, 30 */
		/* 82222848h case   11:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R7,regs.R31);
		/* 82222848h case   11:*/		return 0x8222284C;
		  /* 8222284Ch */ case   12:  		/* rldimi R11, R10, 32, 0 */
		/* 8222284Ch case   12:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 8222284Ch case   12:*/		return 0x82222850;
		  /* 82222850h */ case   13:  		/* lbz R10, <#[R9 - 1]> */
		/* 82222850h case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFFFFF) );
		/* 82222850h case   13:*/		return 0x82222854;
		  /* 82222854h */ case   14:  		/* rlwinm R9, R31, 27, 29, 30 */
		/* 82222854h case   14:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R31);
		/* 82222854h case   14:*/		return 0x82222858;
		  /* 82222858h */ case   15:  		/* rldicl R8, R22, 0, 32 */
		/* 82222858h case   15:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R22);
		/* 82222858h case   15:*/		return 0x8222285C;
		  /* 8222285Ch */ case   16:  		/* srw R9, R10, R9 */
		/* 8222285Ch case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8222285Ch case   16:*/		return 0x82222860;
		  /* 82222860h */ case   17:  		/* srw R7, R10, R7 */
		/* 82222860h case   17:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R10,regs.R7);
		/* 82222860h case   17:*/		return 0x82222864;
		  /* 82222864h */ case   18:  		/* srd R11, R11, R8 */
		/* 82222864h case   18:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82222864h case   18:*/		return 0x82222868;
		  /* 82222868h */ case   19:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 82222868h case   19:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 82222868h case   19:*/		return 0x8222286C;
		  /* 8222286Ch */ case   20:  		/* rlwinm R6, R31, 31, 29, 30 */
		/* 8222286Ch case   20:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R6,regs.R31);
		/* 8222286Ch case   20:*/		return 0x82222870;
		  /* 82222870h */ case   21:  		/* srd R11, R11, R8 */
		/* 82222870h case   21:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82222870h case   21:*/		return 0x82222874;
		  /* 82222874h */ case   22:  		/* srw R5, R10, R6 */
		/* 82222874h case   22:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R10,regs.R6);
		/* 82222874h case   22:*/		return 0x82222878;
		  /* 82222878h */ case   23:  		/* rlwinm R9, R31, 1, 29, 30 */
		/* 82222878h case   23:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R9,regs.R31);
		/* 82222878h case   23:*/		return 0x8222287C;
		  /* 8222287Ch */ case   24:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 8222287Ch case   24:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 8222287Ch case   24:*/		return 0x82222880;
		  /* 82222880h */ case   25:  		/* srd R11, R11, R8 */
		/* 82222880h case   25:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82222880h case   25:*/		return 0x82222884;
		  /* 82222884h */ case   26:  		/* srw R10, R10, R9 */
		/* 82222884h case   26:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82222884h case   26:*/		return 0x82222888;
		  /* 82222888h */ case   27:  		/* rlwimi R5, R7, 2, 0, 29 */
		/* 82222888h case   27:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R5,regs.R7);
		/* 82222888h case   27:*/		return 0x8222288C;
		  /* 8222288Ch */ case   28:  		/* rlwinm. R6, R11, 0, 29, 31 */
		/* 8222288Ch case   28:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R6,regs.R11);
		/* 8222288Ch case   28:*/		return 0x82222890;
		  /* 82222890h */ case   29:  		/* rlwimi R10, R5, 2, 0, 29 */
		/* 82222890h case   29:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 82222890h case   29:*/		return 0x82222894;
		  /* 82222894h */ case   30:  		/* li R11, 0 */
		/* 82222894h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82222894h case   30:*/		return 0x82222898;
		  /* 82222898h */ case   31:  		/* li R9, 0 */
		/* 82222898h case   31:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82222898h case   31:*/		return 0x8222289C;
		  /* 8222289Ch */ case   32:  		/* bc 12, CR0_EQ, 52 */
		/* 8222289Ch case   32:*/		if ( regs.CR[0].eq ) { return 0x822228D0;  }
		/* 8222289Ch case   32:*/		return 0x822228A0;
		  /* 822228A0h */ case   33:  		/* li R8, 0 */
		/* 822228A0h case   33:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822228A0h case   33:*/		return 0x822228A4;
		  /* 822228A4h */ case   34:  		/* mtspr CTR, R6 */
		/* 822228A4h case   34:*/		regs.CTR = regs.R6;
		/* 822228A4h case   34:*/		return 0x822228A8;
		  /* 822228A8h */ case   35:  		/* srw R7, R10, R8 */
		/* 822228A8h case   35:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 822228A8h case   35:*/		return 0x822228AC;
		  /* 822228ACh */ case   36:  		/* rlwinm R7, R7, 1, 29, 30 */
		/* 822228ACh case   36:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R7,regs.R7);
		/* 822228ACh case   36:*/		return 0x822228B0;
		  /* 822228B0h */ case   37:  		/* li R5, 3 */
		/* 822228B0h case   37:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 822228B0h case   37:*/		return 0x822228B4;
		  /* 822228B4h */ case   38:  		/* addi R8, R8, 2 */
		/* 822228B4h case   38:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x2);
		/* 822228B4h case   38:*/		return 0x822228B8;
		  /* 822228B8h */ case   39:  		/* slw R5, R5, R7 */
		/* 822228B8h case   39:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R5,regs.R7);
		/* 822228B8h case   39:*/		return 0x822228BC;
		  /* 822228BCh */ case   40:  		/* slw R7, R9, R7 */
		/* 822228BCh case   40:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R9,regs.R7);
		/* 822228BCh case   40:*/		return 0x822228C0;
		  /* 822228C0h */ case   41:  		/* andc R11, R11, R5 */
		/* 822228C0h case   41:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 822228C0h case   41:*/		return 0x822228C4;
		  /* 822228C4h */ case   42:  		/* addi R9, R9, 1 */
		/* 822228C4h case   42:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 822228C4h case   42:*/		return 0x822228C8;
		  /* 822228C8h */ case   43:  		/* or R11, R11, R7 */
		/* 822228C8h case   43:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 822228C8h case   43:*/		return 0x822228CC;
		  /* 822228CCh */ case   44:  		/* bc 16, CR0_LT, -36 */
		/* 822228CCh case   44:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822228A8;  }
		/* 822228CCh case   44:*/		return 0x822228D0;
	}
	return 0x822228D0;
} // Block from 8222281Ch-822228D0h (45 instructions)

//////////////////////////////////////////////////////
// Block at 822228D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822228D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822228D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822228D0);
		  /* 822228D0h */ case    0:  		/* lis R10, -32252 */
		/* 822228D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 822228D0h case    0:*/		return 0x822228D4;
		  /* 822228D4h */ case    1:  		/* rlwinm R9, R11, 27, 29, 30 */
		/* 822228D4h case    1:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R11);
		/* 822228D4h case    1:*/		return 0x822228D8;
		  /* 822228D8h */ case    2:  		/* addi R10, R10, -17164 */
		/* 822228D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFBCF4);
		/* 822228D8h case    2:*/		return 0x822228DC;
		  /* 822228DCh */ case    3:  		/* rlwinm R5, R11, 29, 29, 30 */
		/* 822228DCh case    3:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R5,regs.R11);
		/* 822228DCh case    3:*/		return 0x822228E0;
		  /* 822228E0h */ case    4:  		/* add R10, R25, R10 */
		/* 822228E0h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R25,regs.R10);
		/* 822228E0h case    4:*/		return 0x822228E4;
		  /* 822228E4h */ case    5:  		/* rlwinm R4, R11, 31, 29, 30 */
		/* 822228E4h case    5:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R4,regs.R11);
		/* 822228E4h case    5:*/		return 0x822228E8;
		  /* 822228E8h */ case    6:  		/* rlwinm R11, R11, 1, 29, 30 */
		/* 822228E8h case    6:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R11,regs.R11);
		/* 822228E8h case    6:*/		return 0x822228EC;
		  /* 822228ECh */ case    7:  		/* li R7, 0 */
		/* 822228ECh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 822228ECh case    7:*/		return 0x822228F0;
		  /* 822228F0h */ case    8:  		/* addi R8, R26, 44 */
		/* 822228F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R26,0x2C);
		/* 822228F0h case    8:*/		return 0x822228F4;
		  /* 822228F4h */ case    9:  		/* lbz R10, <#[R10 - 1]> */
		/* 822228F4h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFFF) );
		/* 822228F4h case    9:*/		return 0x822228F8;
		  /* 822228F8h */ case   10:  		/* srw R9, R10, R9 */
		/* 822228F8h case   10:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 822228F8h case   10:*/		return 0x822228FC;
		  /* 822228FCh */ case   11:  		/* srw R5, R10, R5 */
		/* 822228FCh case   11:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 822228FCh case   11:*/		return 0x82222900;
		  /* 82222900h */ case   12:  		/* rlwimi R5, R9, 2, 28, 29 */
		/* 82222900h case   12:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R5,regs.R9);
		/* 82222900h case   12:*/		return 0x82222904;
		  /* 82222904h */ case   13:  		/* srw R9, R10, R4 */
		/* 82222904h case   13:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 82222904h case   13:*/		return 0x82222908;
		  /* 82222908h */ case   14:  		/* rlwinm R5, R5, 0, 28, 31 */
		/* 82222908h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R5,regs.R5);
		/* 82222908h case   14:*/		return 0x8222290C;
		  /* 8222290Ch */ case   15:  		/* srw R11, R10, R11 */
		/* 8222290Ch case   15:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8222290Ch case   15:*/		return 0x82222910;
		  /* 82222910h */ case   16:  		/* rlwimi R9, R5, 2, 0, 29 */
		/* 82222910h case   16:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 82222910h case   16:*/		return 0x82222914;
		  /* 82222914h */ case   17:  		/* rlwimi R11, R9, 2, 0, 29 */
		/* 82222914h case   17:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 82222914h case   17:*/		return 0x82222918;
		  /* 82222918h */ case   18:  		/* lwz R10, <#[R26 + 8]> */
		/* 82222918h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82222918h case   18:*/		return 0x8222291C;
		  /* 8222291Ch */ case   19:  		/* rlwinm R10, R10, 13, 29, 31 */
		/* 8222291Ch case   19:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R10);
		/* 8222291Ch case   19:*/		return 0x82222920;
		  /* 82222920h */ case   20:  		/* cmplw CR6, R7, R10 */
		/* 82222920h case   20:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82222920h case   20:*/		return 0x82222924;
		  /* 82222924h */ case   21:  		/* bc 4, CR6_LT, -408 */
		/* 82222924h case   21:*/		if ( !regs.CR[6].lt ) { return 0x8222278C;  }
		/* 82222924h case   21:*/		return 0x82222928;
		  /* 82222928h */ case   22:  		/* lwz R10, <#[R8]> */
		/* 82222928h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82222928h case   22:*/		return 0x8222292C;
		  /* 8222292Ch */ case   23:  		/* lwz R9, <#[R10]> */
		/* 8222292Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222292Ch case   23:*/		return 0x82222930;
		  /* 82222930h */ case   24:  		/* rlwinm. R5, R9, 0, 4, 6 */
		/* 82222930h case   24:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R5,regs.R9);
		/* 82222930h case   24:*/		return 0x82222934;
		  /* 82222934h */ case   25:  		/* bc 12, CR0_EQ, 88 */
		/* 82222934h case   25:*/		if ( regs.CR[0].eq ) { return 0x8222298C;  }
		/* 82222934h case   25:*/		return 0x82222938;
		  /* 82222938h */ case   26:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 82222938h case   26:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 82222938h case   26:*/		return 0x8222293C;
		  /* 8222293Ch */ case   27:  		/* lwz R5, <#[R10]> */
		/* 8222293Ch case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 8222293Ch case   27:*/		return 0x82222940;
		  /* 82222940h */ case   28:  		/* rlwinm R4, R11, 27, 29, 30 */
		/* 82222940h case   28:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R4,regs.R11);
		/* 82222940h case   28:*/		return 0x82222944;
		  /* 82222944h */ case   29:  		/* rlwinm R3, R6, 14, 15, 17 */
		/* 82222944h case   29:*/		cpu::op::rlwinm<0,14,15,17>(regs,&regs.R3,regs.R6);
		/* 82222944h case   29:*/		return 0x82222948;
		  /* 82222948h */ case   30:  		/* srw R4, R9, R4 */
		/* 82222948h case   30:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R9,regs.R4);
		/* 82222948h case   30:*/		return 0x8222294C;
		  /* 8222294Ch */ case   31:  		/* rlwinm R4, R4, 0, 30, 31 */
		/* 8222294Ch case   31:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R4);
		/* 8222294Ch case   31:*/		return 0x82222950;
		  /* 82222950h */ case   32:  		/* rlwinm R31, R11, 29, 29, 30 */
		/* 82222950h case   32:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R31,regs.R11);
		/* 82222950h case   32:*/		return 0x82222954;
		  /* 82222954h */ case   33:  		/* or R4, R4, R3 */
		/* 82222954h case   33:*/		cpu::op::or<0>(regs,&regs.R4,regs.R4,regs.R3);
		/* 82222954h case   33:*/		return 0x82222958;
		  /* 82222958h */ case   34:  		/* srw R3, R9, R31 */
		/* 82222958h case   34:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R9,regs.R31);
		/* 82222958h case   34:*/		return 0x8222295C;
		  /* 8222295Ch */ case   35:  		/* rlwinm R31, R11, 31, 29, 30 */
		/* 8222295Ch case   35:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R31,regs.R11);
		/* 8222295Ch case   35:*/		return 0x82222960;
		  /* 82222960h */ case   36:  		/* rlwimi R3, R4, 2, 0, 29 */
		/* 82222960h case   36:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R3,regs.R4);
		/* 82222960h case   36:*/		return 0x82222964;
		  /* 82222964h */ case   37:  		/* srw R4, R9, R31 */
		/* 82222964h case   37:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R9,regs.R31);
		/* 82222964h case   37:*/		return 0x82222968;
		  /* 82222968h */ case   38:  		/* rlwinm R31, R11, 1, 29, 30 */
		/* 82222968h case   38:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R31,regs.R11);
		/* 82222968h case   38:*/		return 0x8222296C;
		  /* 8222296Ch */ case   39:  		/* rlwimi R4, R3, 2, 0, 29 */
		/* 8222296Ch case   39:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R4,regs.R3);
		/* 8222296Ch case   39:*/		return 0x82222970;
		  /* 82222970h */ case   40:  		/* srw R9, R9, R31 */
		/* 82222970h case   40:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 82222970h case   40:*/		return 0x82222974;
		  /* 82222974h */ case   41:  		/* rlwimi R9, R4, 2, 0, 29 */
		/* 82222974h case   41:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 82222974h case   41:*/		return 0x82222978;
		  /* 82222978h */ case   42:  		/* rlwinm R5, R5, 0, 27, 18 */
		/* 82222978h case   42:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R5,regs.R5);
		/* 82222978h case   42:*/		return 0x8222297C;
		  /* 8222297Ch */ case   43:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 8222297Ch case   43:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 8222297Ch case   43:*/		return 0x82222980;
		  /* 82222980h */ case   44:  		/* rlwinm R5, R5, 0, 7, 3 */
		/* 82222980h case   44:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R5,regs.R5);
		/* 82222980h case   44:*/		return 0x82222984;
		  /* 82222984h */ case   45:  		/* or R9, R9, R5 */
		/* 82222984h case   45:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82222984h case   45:*/		return 0x82222988;
		  /* 82222988h */ case   46:  		/* stw R9, <#[R10]> */
		/* 82222988h case   46:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82222988h case   46:*/		return 0x8222298C;
	}
	return 0x8222298C;
} // Block from 822228D0h-8222298Ch (47 instructions)

//////////////////////////////////////////////////////
// Block at 8222298Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222298C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222298C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222298C);
		  /* 8222298Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 8222298Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8222298Ch case    0:*/		return 0x82222990;
		  /* 82222990h */ case    1:  		/* addi R8, R8, 4 */
		/* 82222990h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82222990h case    1:*/		return 0x82222994;
		  /* 82222994h */ case    2:  		/* b -124 */
		/* 82222994h case    2:*/		return 0x82222918;
		/* 82222994h case    2:*/		return 0x82222998;
	}
	return 0x82222998;
} // Block from 8222298Ch-82222998h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222998);
		  /* 82222998h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82222998h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82222998h case    0:*/		return 0x8222299C;
		  /* 8222299Ch */ case    1:  		/* rlwimi R11, R22, 1, 27, 30 */
		/* 8222299Ch case    1:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R11,regs.R22);
		/* 8222299Ch case    1:*/		return 0x822229A0;
		  /* 822229A0h */ case    2:  		/* stw R11, <#[R26 + 8]> */
		/* 822229A0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822229A0h case    2:*/		return 0x822229A4;
		  /* 822229A4h */ case    3:  		/* addi R1, R1, 176 */
		/* 822229A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 822229A4h case    3:*/		return 0x822229A8;
		  /* 822229A8h */ case    4:  		/* b -1644316 */
		/* 822229A8h case    4:*/		return 0x8209128C;
		/* 822229A8h case    4:*/		return 0x822229AC;
		  /* 822229ACh */ case    5:  		/* nop */
		/* 822229ACh case    5:*/		cpu::op::nop();
		/* 822229ACh case    5:*/		return 0x822229B0;
	}
	return 0x822229B0;
} // Block from 82222998h-822229B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822229B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822229B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822229B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822229B0);
		  /* 822229B0h */ case    0:  		/* mfspr R12, LR */
		/* 822229B0h case    0:*/		regs.R12 = regs.LR;
		/* 822229B0h case    0:*/		return 0x822229B4;
		  /* 822229B4h */ case    1:  		/* bl -1644380 */
		/* 822229B4h case    1:*/		regs.LR = 0x822229B8; return 0x82091258;
		/* 822229B4h case    1:*/		return 0x822229B8;
		  /* 822229B8h */ case    2:  		/* stfd FR31, <#[R1 - 48]> */
		/* 822229B8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 822229B8h case    2:*/		return 0x822229BC;
		  /* 822229BCh */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 822229BCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822229BCh case    3:*/		return 0x822229C0;
		  /* 822229C0h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 822229C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822229C0h case    4:*/		return 0x822229C4;
		  /* 822229C4h */ case    5:  		/* mr R31, R3 */
		/* 822229C4h case    5:*/		regs.R31 = regs.R3;
		/* 822229C4h case    5:*/		return 0x822229C8;
		  /* 822229C8h */ case    6:  		/* mr R30, R4 */
		/* 822229C8h case    6:*/		regs.R30 = regs.R4;
		/* 822229C8h case    6:*/		return 0x822229CC;
		  /* 822229CCh */ case    7:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 822229CCh case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 822229CCh case    7:*/		return 0x822229D0;
		  /* 822229D0h */ case    8:  		/* mr R29, R5 */
		/* 822229D0h case    8:*/		regs.R29 = regs.R5;
		/* 822229D0h case    8:*/		return 0x822229D4;
		  /* 822229D4h */ case    9:  		/* mr R28, R6 */
		/* 822229D4h case    9:*/		regs.R28 = regs.R6;
		/* 822229D4h case    9:*/		return 0x822229D8;
		  /* 822229D8h */ case   10:  		/* cmplwi CR6, R10, 125 */
		/* 822229D8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 822229D8h case   10:*/		return 0x822229DC;
		  /* 822229DCh */ case   11:  		/* bc 4, CR6_EQ, 68 */
		/* 822229DCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x82222A20;  }
		/* 822229DCh case   11:*/		return 0x822229E0;
		  /* 822229E0h */ case   12:  		/* bl -416400 */
		/* 822229E0h case   12:*/		regs.LR = 0x822229E4; return 0x821BCF50;
		/* 822229E0h case   12:*/		return 0x822229E4;
		  /* 822229E4h */ case   13:  		/* fmr FR31, FR1 */
		/* 822229E4h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 822229E4h case   13:*/		return 0x822229E8;
		  /* 822229E8h */ case   14:  		/* bl -1616408 */
		/* 822229E8h case   14:*/		regs.LR = 0x822229EC; return 0x82097FD0;
		/* 822229E8h case   14:*/		return 0x822229EC;
		  /* 822229ECh */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 822229ECh case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822229ECh case   15:*/		return 0x822229F0;
		  /* 822229F0h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 822229F0h case   16:*/		if ( regs.CR[0].eq ) { return 0x82222A00;  }
		/* 822229F0h case   16:*/		return 0x822229F4;
		  /* 822229F4h */ case   17:  		/* stfd FR31, <#[R29]> */
		/* 822229F4h case   17:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R29 + 0x00000000) );
		/* 822229F4h case   17:*/		return 0x822229F8;
		  /* 822229F8h */ case   18:  		/* stfd FR31, <#[R28]> */
		/* 822229F8h case   18:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R28 + 0x00000000) );
		/* 822229F8h case   18:*/		return 0x822229FC;
		  /* 822229FCh */ case   19:  		/* b 276 */
		/* 822229FCh case   19:*/		return 0x82222B10;
		/* 822229FCh case   19:*/		return 0x82222A00;
	}
	return 0x82222A00;
} // Block from 822229B0h-82222A00h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82222A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222A00);
		  /* 82222A00h */ case    0:  		/* lis R11, 32640 */
		/* 82222A00h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x7F80);
		/* 82222A00h case    0:*/		return 0x82222A04;
		  /* 82222A04h */ case    1:  		/* lis R10, -128 */
		/* 82222A04h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 82222A04h case    1:*/		return 0x82222A08;
		  /* 82222A08h */ case    2:  		/* stw R11, <#[R1 + 80]> */
		/* 82222A08h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82222A08h case    2:*/		return 0x82222A0C;
		  /* 82222A0Ch */ case    3:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82222A0Ch case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82222A0Ch case    3:*/		return 0x82222A10;
		  /* 82222A10h */ case    4:  		/* stw R10, <#[R1 + 80]> */
		/* 82222A10h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82222A10h case    4:*/		return 0x82222A14;
		  /* 82222A14h */ case    5:  		/* lfs FR13, <#[R1 + 80]> */
		/* 82222A14h case    5:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82222A14h case    5:*/		return 0x82222A18;
		  /* 82222A18h */ case    6:  		/* stfd FR13, <#[R29]> */
		/* 82222A18h case    6:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R29 + 0x00000000) );
		/* 82222A18h case    6:*/		return 0x82222A1C;
		  /* 82222A1Ch */ case    7:  		/* b 240 */
		/* 82222A1Ch case    7:*/		return 0x82222B0C;
		/* 82222A1Ch case    7:*/		return 0x82222A20;
	}
	return 0x82222A20;
} // Block from 82222A00h-82222A20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82222A20h
// Function '?ValidateTextureInstructionOptions@Compiler@D3DXShader@@QAA?AW4ErrorCode@2@PAVInstruction@2@PATGPUTEXTURE_FETCH_INSTRUCTION@@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222A20);
		  /* 82222A20h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82222A20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82222A20h case    0:*/		return 0x82222A24;
		  /* 82222A24h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82222A24h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222A24h case    1:*/		return 0x82222A28;
		  /* 82222A28h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 82222A28h case    2:*/		if ( regs.CR[6].eq ) { return 0x82222A70;  }
		/* 82222A28h case    2:*/		return 0x82222A2C;
		  /* 82222A2Ch */ case    3:  		/* lwz R9, <#[R11]> */
		/* 82222A2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82222A2Ch case    3:*/		return 0x82222A30;
		  /* 82222A30h */ case    4:  		/* cmpwi CR6, R9, 1 */
		/* 82222A30h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 82222A30h case    4:*/		return 0x82222A34;
		  /* 82222A34h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82222A34h case    5:*/		if ( regs.CR[6].eq ) { return 0x82222A44;  }
		/* 82222A34h case    5:*/		return 0x82222A38;
		  /* 82222A38h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82222A38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82222A38h case    6:*/		return 0x82222A3C;
		  /* 82222A3Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82222A3Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222A3Ch case    7:*/		return 0x82222A40;
		  /* 82222A40h */ case    8:  		/* bc 4, CR6_EQ, -20 */
		/* 82222A40h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82222A2C;  }
		/* 82222A40h case    8:*/		return 0x82222A44;
	}
	return 0x82222A44;
} // Block from 82222A20h-82222A44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82222A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222A44);
		  /* 82222A44h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82222A44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222A44h case    0:*/		return 0x82222A48;
		  /* 82222A48h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 82222A48h case    1:*/		if ( regs.CR[6].eq ) { return 0x82222A70;  }
		/* 82222A48h case    1:*/		return 0x82222A4C;
		  /* 82222A4Ch */ case    2:  		/* addi R10, R30, 1 */
		/* 82222A4Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x1);
		/* 82222A4Ch case    2:*/		return 0x82222A50;
		  /* 82222A50h */ case    3:  		/* addi R9, R30, 5 */
		/* 82222A50h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x5);
		/* 82222A50h case    3:*/		return 0x82222A54;
		  /* 82222A54h */ case    4:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82222A54h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82222A54h case    4:*/		return 0x82222A58;
		  /* 82222A58h */ case    5:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 82222A58h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 82222A58h case    5:*/		return 0x82222A5C;
		  /* 82222A5Ch */ case    6:  		/* lfdx FR0, <#[R10 + R11]> */
		/* 82222A5Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82222A5Ch case    6:*/		return 0x82222A60;
		  /* 82222A60h */ case    7:  		/* stfd FR0, <#[R29]> */
		/* 82222A60h case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R29 + 0x00000000) );
		/* 82222A60h case    7:*/		return 0x82222A64;
		  /* 82222A64h */ case    8:  		/* lfdx FR0, <#[R9 + R11]> */
		/* 82222A64h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82222A64h case    8:*/		return 0x82222A68;
		  /* 82222A68h */ case    9:  		/* stfd FR0, <#[R28]> */
		/* 82222A68h case    9:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 82222A68h case    9:*/		return 0x82222A6C;
		  /* 82222A6Ch */ case   10:  		/* b 164 */
		/* 82222A6Ch case   10:*/		return 0x82222B10;
		/* 82222A6Ch case   10:*/		return 0x82222A70;
	}
	return 0x82222A70;
} // Block from 82222A44h-82222A70h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82222A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222A70);
		  /* 82222A70h */ case    0:  		/* cmplwi CR6, R10, 124 */
		/* 82222A70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 82222A70h case    0:*/		return 0x82222A74;
		  /* 82222A74h */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 82222A74h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82222ACC;  }
		/* 82222A74h case    1:*/		return 0x82222A78;
		  /* 82222A78h */ case    2:  		/* rlwinm R11, R31, 0, 0, 19 */
		/* 82222A78h case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R31);
		/* 82222A78h case    2:*/		return 0x82222A7C;
		  /* 82222A7Ch */ case    3:  		/* lwz R10, <#[R31 + 8]> */
		/* 82222A7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82222A7Ch case    3:*/		return 0x82222A80;
		  /* 82222A80h */ case    4:  		/* rlwinm R6, R10, 18, 29, 31 */
		/* 82222A80h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R10);
		/* 82222A80h case    4:*/		return 0x82222A84;
		  /* 82222A84h */ case    5:  		/* rlwinm R5, R10, 13, 29, 31 */
		/* 82222A84h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R10);
		/* 82222A84h case    5:*/		return 0x82222A88;
		  /* 82222A88h */ case    6:  		/* rlwinm R4, R10, 25, 25, 31 */
		/* 82222A88h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R10);
		/* 82222A88h case    6:*/		return 0x82222A8C;
		  /* 82222A8Ch */ case    7:  		/* lwz R11, <#[R11]> */
		/* 82222A8Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222A8Ch case    7:*/		return 0x82222A90;
		  /* 82222A90h */ case    8:  		/* lwz R3, <#[R11 + 148]> */
		/* 82222A90h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82222A90h case    8:*/		return 0x82222A94;
		  /* 82222A94h */ case    9:  		/* bl -779876 */
		/* 82222A94h case    9:*/		regs.LR = 0x82222A98; return 0x82164430;
		/* 82222A94h case    9:*/		return 0x82222A98;
		  /* 82222A98h */ case   10:  		/* addi R11, R31, -8 */
		/* 82222A98h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF8);
		/* 82222A98h case   10:*/		return 0x82222A9C;
		  /* 82222A9Ch */ case   11:  		/* lis R10, 8192 */
		/* 82222A9Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x2000);
		/* 82222A9Ch case   11:*/		return 0x82222AA0;
		  /* 82222AA0h */ case   12:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82222AA0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82222AA0h case   12:*/		return 0x82222AA4;
		  /* 82222AA4h */ case   13:  		/* rlwinm R11, R11, 0, 1, 2 */
		/* 82222AA4h case   13:*/		cpu::op::rlwinm<0,0,1,2>(regs,&regs.R11,regs.R11);
		/* 82222AA4h case   13:*/		return 0x82222AA8;
		  /* 82222AA8h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 82222AA8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82222AA8h case   14:*/		return 0x82222AAC;
		  /* 82222AACh */ case   15:  		/* bc 4, CR6_EQ, 32 */
		/* 82222AACh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82222ACC;  }
		/* 82222AACh case   15:*/		return 0x82222AB0;
		  /* 82222AB0h */ case   16:  		/* lis R11, -32256 */
		/* 82222AB0h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82222AB0h case   16:*/		return 0x82222AB4;
		  /* 82222AB4h */ case   17:  		/* lis R10, -32256 */
		/* 82222AB4h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82222AB4h case   17:*/		return 0x82222AB8;
		  /* 82222AB8h */ case   18:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82222AB8h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82222AB8h case   18:*/		return 0x82222ABC;
		  /* 82222ABCh */ case   19:  		/* lfd FR13, <#[R10 + 1848]> */
		/* 82222ABCh case   19:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000738) );
		/* 82222ABCh case   19:*/		return 0x82222AC0;
		  /* 82222AC0h */ case   20:  		/* stfd FR0, <#[R29]> */
		/* 82222AC0h case   20:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R29 + 0x00000000) );
		/* 82222AC0h case   20:*/		return 0x82222AC4;
		  /* 82222AC4h */ case   21:  		/* stfd FR13, <#[R28]> */
		/* 82222AC4h case   21:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R28 + 0x00000000) );
		/* 82222AC4h case   21:*/		return 0x82222AC8;
	}
	return 0x82222AC8;
} // Block from 82222A70h-82222AC8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82222AC8h
// Function '??0Dependency@D3DXShader@@QAA@PAVInstruction@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222AC8);
		  /* 82222AC8h */ case    0:  		/* b 72 */
		/* 82222AC8h case    0:*/		return 0x82222B10;
		/* 82222AC8h case    0:*/		return 0x82222ACC;
	}
	return 0x82222ACC;
} // Block from 82222AC8h-82222ACCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222ACC);
		  /* 82222ACCh */ case    0:  		/* lhz R11, <#[R31 + 14]> */
		/* 82222ACCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000E) );
		/* 82222ACCh case    0:*/		return 0x82222AD0;
		  /* 82222AD0h */ case    1:  		/* rlwinm R10, R30, 2, 16, 29 */
		/* 82222AD0h case    1:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R10,regs.R30);
		/* 82222AD0h case    1:*/		return 0x82222AD4;
		  /* 82222AD4h */ case    2:  		/* mr R5, R28 */
		/* 82222AD4h case    2:*/		regs.R5 = regs.R28;
		/* 82222AD4h case    2:*/		return 0x82222AD8;
		  /* 82222AD8h */ case    3:  		/* srw R11, R11, R10 */
		/* 82222AD8h case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82222AD8h case    3:*/		return 0x82222ADC;
		  /* 82222ADCh */ case    4:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 82222ADCh case    4:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 82222ADCh case    4:*/		return 0x82222AE0;
		  /* 82222AE0h */ case    5:  		/* mr R4, R29 */
		/* 82222AE0h case    5:*/		regs.R4 = regs.R29;
		/* 82222AE0h case    5:*/		return 0x82222AE4;
		  /* 82222AE4h */ case    6:  		/* bl -5068 */
		/* 82222AE4h case    6:*/		regs.LR = 0x82222AE8; return 0x82221718;
		/* 82222AE4h case    6:*/		return 0x82222AE8;
		  /* 82222AE8h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82222AE8h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82222AE8h case    7:*/		return 0x82222AEC;
		  /* 82222AECh */ case    8:  		/* bc 4, CR0_EQ, 36 */
		/* 82222AECh case    8:*/		if ( !regs.CR[0].eq ) { return 0x82222B10;  }
		/* 82222AECh case    8:*/		return 0x82222AF0;
		  /* 82222AF0h */ case    9:  		/* lis R10, -128 */
		/* 82222AF0h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 82222AF0h case    9:*/		return 0x82222AF4;
		  /* 82222AF4h */ case   10:  		/* lis R11, 32640 */
		/* 82222AF4h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0x7F80);
		/* 82222AF4h case   10:*/		return 0x82222AF8;
	}
	return 0x82222AF8;
} // Block from 82222ACCh-82222AF8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82222AF8h
// Function '?IsEquivalentConstantDependency@Dependency@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222AF8);
		  /* 82222AF8h */ case    0:  		/* stw R10, <#[R1 + 80]> */
		/* 82222AF8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82222AF8h case    0:*/		return 0x82222AFC;
		  /* 82222AFCh */ case    1:  		/* stw R11, <#[R1 + 84]> */
		/* 82222AFCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82222AFCh case    1:*/		return 0x82222B00;
		  /* 82222B00h */ case    2:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82222B00h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82222B00h case    2:*/		return 0x82222B04;
		  /* 82222B04h */ case    3:  		/* stfd FR0, <#[R29]> */
		/* 82222B04h case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R29 + 0x00000000) );
		/* 82222B04h case    3:*/		return 0x82222B08;
		  /* 82222B08h */ case    4:  		/* lfs FR0, <#[R1 + 84]> */
		/* 82222B08h case    4:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000054) );
		/* 82222B08h case    4:*/		return 0x82222B0C;
	}
	return 0x82222B0C;
} // Block from 82222AF8h-82222B0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82222B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222B0C);
		  /* 82222B0Ch */ case    0:  		/* stfd FR0, <#[R28]> */
		/* 82222B0Ch case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R28 + 0x00000000) );
		/* 82222B0Ch case    0:*/		return 0x82222B10;
	}
	return 0x82222B10;
} // Block from 82222B0Ch-82222B10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222B10);
		  /* 82222B10h */ case    0:  		/* addi R1, R1, 144 */
		/* 82222B10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82222B10h case    0:*/		return 0x82222B14;
		  /* 82222B14h */ case    1:  		/* lfd FR31, <#[R1 - 48]> */
		/* 82222B14h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82222B14h case    1:*/		return 0x82222B18;
		  /* 82222B18h */ case    2:  		/* b -1644656 */
		/* 82222B18h case    2:*/		return 0x820912A8;
		/* 82222B18h case    2:*/		return 0x82222B1C;
		  /* 82222B1Ch */ case    3:  		/* nop */
		/* 82222B1Ch case    3:*/		cpu::op::nop();
		/* 82222B1Ch case    3:*/		return 0x82222B20;
	}
	return 0x82222B20;
} // Block from 82222B10h-82222B20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222B20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222B20);
		  /* 82222B20h */ case    0:  		/* mfspr R12, LR */
		/* 82222B20h case    0:*/		regs.R12 = regs.LR;
		/* 82222B20h case    0:*/		return 0x82222B24;
		  /* 82222B24h */ case    1:  		/* bl -1644760 */
		/* 82222B24h case    1:*/		regs.LR = 0x82222B28; return 0x8209124C;
		/* 82222B24h case    1:*/		return 0x82222B28;
		  /* 82222B28h */ case    2:  		/* stfd FR29, <#[R1 - 88]> */
		/* 82222B28h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 82222B28h case    2:*/		return 0x82222B2C;
		  /* 82222B2Ch */ case    3:  		/* stfd FR30, <#[R1 - 80]> */
		/* 82222B2Ch case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 82222B2Ch case    3:*/		return 0x82222B30;
		  /* 82222B30h */ case    4:  		/* stfd FR31, <#[R1 - 72]> */
		/* 82222B30h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82222B30h case    4:*/		return 0x82222B34;
		  /* 82222B34h */ case    5:  		/* stwu R1, <#[R1 - 176]> */
		/* 82222B34h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82222B34h case    5:*/		return 0x82222B38;
		  /* 82222B38h */ case    6:  		/* mr R27, R3 */
		/* 82222B38h case    6:*/		regs.R27 = regs.R3;
		/* 82222B38h case    6:*/		return 0x82222B3C;
		  /* 82222B3Ch */ case    7:  		/* fmr FR30, FR1 */
		/* 82222B3Ch case    7:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82222B3Ch case    7:*/		return 0x82222B40;
		  /* 82222B40h */ case    8:  		/* mr R28, R4 */
		/* 82222B40h case    8:*/		regs.R28 = regs.R4;
		/* 82222B40h case    8:*/		return 0x82222B44;
		  /* 82222B44h */ case    9:  		/* fmr FR29, FR2 */
		/* 82222B44h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR2);
		/* 82222B44h case    9:*/		return 0x82222B48;
		  /* 82222B48h */ case   10:  		/* mr R30, R7 */
		/* 82222B48h case   10:*/		regs.R30 = regs.R7;
		/* 82222B48h case   10:*/		return 0x82222B4C;
		  /* 82222B4Ch */ case   11:  		/* bl -1616764 */
		/* 82222B4Ch case   11:*/		regs.LR = 0x82222B50; return 0x82097FD0;
		/* 82222B4Ch case   11:*/		return 0x82222B50;
		  /* 82222B50h */ case   12:  		/* lis R29, -128 */
		/* 82222B50h case   12:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFFFF80);
		/* 82222B50h case   12:*/		return 0x82222B54;
		  /* 82222B54h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82222B54h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82222B54h case   13:*/		return 0x82222B58;
		  /* 82222B58h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 82222B58h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82222B64;  }
		/* 82222B58h case   14:*/		return 0x82222B5C;
		  /* 82222B5Ch */ case   15:  		/* stw R29, <#[R1 + 80]> */
		/* 82222B5Ch case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 82222B5Ch case   15:*/		return 0x82222B60;
		  /* 82222B60h */ case   16:  		/* lfs FR30, <#[R1 + 80]> */
		/* 82222B60h case   16:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 82222B60h case   16:*/		return 0x82222B64;
	}
	return 0x82222B64;
} // Block from 82222B20h-82222B64h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82222B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222B64);
		  /* 82222B64h */ case    0:  		/* fmr FR1, FR29 */
		/* 82222B64h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 82222B64h case    0:*/		return 0x82222B68;
		  /* 82222B68h */ case    1:  		/* bl -1616792 */
		/* 82222B68h case    1:*/		regs.LR = 0x82222B6C; return 0x82097FD0;
		/* 82222B68h case    1:*/		return 0x82222B6C;
		  /* 82222B6Ch */ case    2:  		/* lis R31, 32640 */
		/* 82222B6Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R31,0x7F80);
		/* 82222B6Ch case    2:*/		return 0x82222B70;
		  /* 82222B70h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 82222B70h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82222B70h case    3:*/		return 0x82222B74;
		  /* 82222B74h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 82222B74h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82222B80;  }
		/* 82222B74h case    4:*/		return 0x82222B78;
		  /* 82222B78h */ case    5:  		/* stw R31, <#[R1 + 80]> */
		/* 82222B78h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82222B78h case    5:*/		return 0x82222B7C;
		  /* 82222B7Ch */ case    6:  		/* lfs FR29, <#[R1 + 80]> */
		/* 82222B7Ch case    6:*/		cpu::mem::load32f( regs, &regs.FR29, (uint32)(regs.R1 + 0x00000050) );
		/* 82222B7Ch case    6:*/		return 0x82222B80;
	}
	return 0x82222B80;
} // Block from 82222B64h-82222B80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222B80);
		  /* 82222B80h */ case    0:  		/* lhz R11, <#[R27 + 14]> */
		/* 82222B80h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000E) );
		/* 82222B80h case    0:*/		return 0x82222B84;
		  /* 82222B84h */ case    1:  		/* rlwinm R10, R28, 2, 16, 29 */
		/* 82222B84h case    1:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R10,regs.R28);
		/* 82222B84h case    1:*/		return 0x82222B88;
		  /* 82222B88h */ case    2:  		/* lis R9, -32256 */
		/* 82222B88h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82222B88h case    2:*/		return 0x82222B8C;
		  /* 82222B8Ch */ case    3:  		/* srw R11, R11, R10 */
		/* 82222B8Ch case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82222B8Ch case    3:*/		return 0x82222B90;
		  /* 82222B90h */ case    4:  		/* rlwinm R25, R11, 0, 28, 31 */
		/* 82222B90h case    4:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R25,regs.R11);
		/* 82222B90h case    4:*/		return 0x82222B94;
		  /* 82222B94h */ case    5:  		/* lfd FR31, <#[R9 + 1808]> */
		/* 82222B94h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000710) );
		/* 82222B94h case    5:*/		return 0x82222B98;
		  /* 82222B98h */ case    6:  		/* rlwinm R26, R28, 2, 0, 29 */
		/* 82222B98h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R28);
		/* 82222B98h case    6:*/		return 0x82222B9C;
		  /* 82222B9Ch */ case    7:  		/* cmplwi CR6, R25, 2 */
		/* 82222B9Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000002);
		/* 82222B9Ch case    7:*/		return 0x82222BA0;
		  /* 82222BA0h */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 82222BA0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82222BB8;  }
		/* 82222BA0h case    8:*/		return 0x82222BA4;
		  /* 82222BA4h */ case    9:  		/* fmr FR30, FR31 */
		/* 82222BA4h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR31);
		/* 82222BA4h case    9:*/		return 0x82222BA8;
		  /* 82222BA8h */ case   10:  		/* fcmpu CR6, FR29, FR31 */
		/* 82222BA8h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR31);
		/* 82222BA8h case   10:*/		return 0x82222BAC;
		  /* 82222BACh */ case   11:  		/* bc 4, CR6_LT, 36 */
		/* 82222BACh case   11:*/		if ( !regs.CR[6].lt ) { return 0x82222BD0;  }
		/* 82222BACh case   11:*/		return 0x82222BB0;
		  /* 82222BB0h */ case   12:  		/* fmr FR29, FR31 */
		/* 82222BB0h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR31);
		/* 82222BB0h case   12:*/		return 0x82222BB4;
		  /* 82222BB4h */ case   13:  		/* b 28 */
		/* 82222BB4h case   13:*/		return 0x82222BD0;
		/* 82222BB4h case   13:*/		return 0x82222BB8;
	}
	return 0x82222BB8;
} // Block from 82222B80h-82222BB8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82222BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222BB8);
		  /* 82222BB8h */ case    0:  		/* cmplwi CR6, R25, 1 */
		/* 82222BB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000001);
		/* 82222BB8h case    0:*/		return 0x82222BBC;
		  /* 82222BBCh */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 82222BBCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82222BD0;  }
		/* 82222BBCh case    1:*/		return 0x82222BC0;
		  /* 82222BC0h */ case    2:  		/* fmr FR29, FR31 */
		/* 82222BC0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR31);
		/* 82222BC0h case    2:*/		return 0x82222BC4;
		  /* 82222BC4h */ case    3:  		/* fcmpu CR6, FR30, FR31 */
		/* 82222BC4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR31);
		/* 82222BC4h case    3:*/		return 0x82222BC8;
		  /* 82222BC8h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82222BC8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82222BD0;  }
		/* 82222BC8h case    4:*/		return 0x82222BCC;
		  /* 82222BCCh */ case    5:  		/* fmr FR30, FR31 */
		/* 82222BCCh case    5:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR31);
		/* 82222BCCh case    5:*/		return 0x82222BD0;
	}
	return 0x82222BD0;
} // Block from 82222BB8h-82222BD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82222BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222BD0);
		  /* 82222BD0h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 82222BD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82222BD0h case    0:*/		return 0x82222BD4;
		  /* 82222BD4h */ case    1:  		/* b 20 */
		/* 82222BD4h case    1:*/		return 0x82222BE8;
		/* 82222BD4h case    1:*/		return 0x82222BD8;
		  /* 82222BD8h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82222BD8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82222BD8h case    2:*/		return 0x82222BDC;
		  /* 82222BDCh */ case    3:  		/* cmpwi CR6, R10, 1 */
		/* 82222BDCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 82222BDCh case    3:*/		return 0x82222BE0;
		  /* 82222BE0h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82222BE0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82222BF0;  }
		/* 82222BE0h case    4:*/		return 0x82222BE4;
		  /* 82222BE4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82222BE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82222BE4h case    5:*/		return 0x82222BE8;
	}
	return 0x82222BE8;
} // Block from 82222BD0h-82222BE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82222BE8h
// Function '?FindAddressDef@Instruction@D3DXShader@@QAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222BE8);
		  /* 82222BE8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82222BE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222BE8h case    0:*/		return 0x82222BEC;
		  /* 82222BECh */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 82222BECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82222BD8;  }
		/* 82222BECh case    1:*/		return 0x82222BF0;
	}
	return 0x82222BF0;
} // Block from 82222BE8h-82222BF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222BF0);
		  /* 82222BF0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82222BF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222BF0h case    0:*/		return 0x82222BF4;
		  /* 82222BF4h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 82222BF4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82222C70;  }
		/* 82222BF4h case    1:*/		return 0x82222BF8;
		  /* 82222BF8h */ case    2:  		/* stw R29, <#[R1 + 80]> */
		/* 82222BF8h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 82222BF8h case    2:*/		return 0x82222BFC;
		  /* 82222BFCh */ case    3:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82222BFCh case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82222BFCh case    3:*/		return 0x82222C00;
		  /* 82222C00h */ case    4:  		/* fcmpu CR6, FR0, FR30 */
		/* 82222C00h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82222C00h case    4:*/		return 0x82222C04;
		  /* 82222C04h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 82222C04h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82222C20;  }
		/* 82222C04h case    5:*/		return 0x82222C08;
		  /* 82222C08h */ case    6:  		/* stw R31, <#[R1 + 80]> */
		/* 82222C08h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82222C08h case    6:*/		return 0x82222C0C;
		  /* 82222C0Ch */ case    7:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82222C0Ch case    7:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82222C0Ch case    7:*/		return 0x82222C10;
		  /* 82222C10h */ case    8:  		/* fcmpu CR6, FR0, FR29 */
		/* 82222C10h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82222C10h case    8:*/		return 0x82222C14;
		  /* 82222C14h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82222C14h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82222C20;  }
		/* 82222C14h case    9:*/		return 0x82222C18;
		  /* 82222C18h */ case   10:  		/* li R3, 0 */
		/* 82222C18h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82222C18h case   10:*/		return 0x82222C1C;
		  /* 82222C1Ch */ case   11:  		/* b 248 */
		/* 82222C1Ch case   11:*/		return 0x82222D14;
		/* 82222C1Ch case   11:*/		return 0x82222C20;
	}
	return 0x82222C20;
} // Block from 82222BF0h-82222C20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82222C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222C20);
		  /* 82222C20h */ case    0:  		/* li R5, 23 */
		/* 82222C20h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x17);
		/* 82222C20h case    0:*/		return 0x82222C24;
		  /* 82222C24h */ case    1:  		/* li R4, 72 */
		/* 82222C24h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 82222C24h case    1:*/		return 0x82222C28;
		  /* 82222C28h */ case    2:  		/* mr R3, R30 */
		/* 82222C28h case    2:*/		regs.R3 = regs.R30;
		/* 82222C28h case    2:*/		return 0x82222C2C;
		  /* 82222C2Ch */ case    3:  		/* bl -745604 */
		/* 82222C2Ch case    3:*/		regs.LR = 0x82222C30; return 0x8216CBA8;
		/* 82222C2Ch case    3:*/		return 0x82222C30;
		  /* 82222C30h */ case    4:  		/* li R10, 4 */
		/* 82222C30h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82222C30h case    4:*/		return 0x82222C34;
		  /* 82222C34h */ case    5:  		/* li R8, 1 */
		/* 82222C34h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82222C34h case    5:*/		return 0x82222C38;
		  /* 82222C38h */ case    6:  		/* stw R29, <#[R1 + 80]> */
		/* 82222C38h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 82222C38h case    6:*/		return 0x82222C3C;
		  /* 82222C3Ch */ case    7:  		/* mr R11, R3 */
		/* 82222C3Ch case    7:*/		regs.R11 = regs.R3;
		/* 82222C3Ch case    7:*/		return 0x82222C40;
		  /* 82222C40h */ case    8:  		/* stw R31, <#[R1 + 84]> */
		/* 82222C40h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 82222C40h case    8:*/		return 0x82222C44;
		  /* 82222C44h */ case    9:  		/* addi R9, R3, 32 */
		/* 82222C44h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x20);
		/* 82222C44h case    9:*/		return 0x82222C48;
		  /* 82222C48h */ case   10:  		/* stw R8, <#[R3]> */
		/* 82222C48h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 82222C48h case   10:*/		return 0x82222C4C;
		  /* 82222C4Ch */ case   11:  		/* mtspr CTR, R10 */
		/* 82222C4Ch case   11:*/		regs.CTR = regs.R10;
		/* 82222C4Ch case   11:*/		return 0x82222C50;
		  /* 82222C50h */ case   12:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82222C50h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82222C50h case   12:*/		return 0x82222C54;
		  /* 82222C54h */ case   13:  		/* lfs FR13, <#[R1 + 84]> */
		/* 82222C54h case   13:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000054) );
		/* 82222C54h case   13:*/		return 0x82222C58;
	}
	return 0x82222C58;
} // Block from 82222C20h-82222C58h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82222C58h
// Function '?GetDependencyWithModifiers@Compiler@D3DXShader@@QAAPAVDependency@2@PAVInstruction@2@III@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222C58);
		  /* 82222C58h */ case    0:  		/* stfd FR0, <#[R9 - 24]> */
		/* 82222C58h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R9 + 0xFFFFFFE8) );
		/* 82222C58h case    0:*/		return 0x82222C5C;
		  /* 82222C5Ch */ case    1:  		/* stfdu FR13, <#[R9 + 8]> */
		/* 82222C5Ch case    1:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 82222C5Ch case    1:*/		return 0x82222C60;
		  /* 82222C60h */ case    2:  		/* bc 16, CR0_LT, -16 */
		/* 82222C60h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82222C50;  }
		/* 82222C60h case    2:*/		return 0x82222C64;
		  /* 82222C64h */ case    3:  		/* lwz R10, <#[R27 + 16]> */
		/* 82222C64h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 82222C64h case    3:*/		return 0x82222C68;
		  /* 82222C68h */ case    4:  		/* stw R10, <#[R11 + 4]> */
		/* 82222C68h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82222C68h case    4:*/		return 0x82222C6C;
		  /* 82222C6Ch */ case    5:  		/* stw R11, <#[R27 + 16]> */
		/* 82222C6Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82222C6Ch case    5:*/		return 0x82222C70;
	}
	return 0x82222C70;
} // Block from 82222C58h-82222C70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82222C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222C70);
		  /* 82222C70h */ case    0:  		/* addi R10, R28, 1 */
		/* 82222C70h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1);
		/* 82222C70h case    0:*/		return 0x82222C74;
		  /* 82222C74h */ case    1:  		/* li R3, 0 */
		/* 82222C74h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82222C74h case    1:*/		return 0x82222C78;
		  /* 82222C78h */ case    2:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82222C78h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82222C78h case    2:*/		return 0x82222C7C;
		  /* 82222C7Ch */ case    3:  		/* lfdx FR0, <#[R10 + R11]> */
		/* 82222C7Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82222C7Ch case    3:*/		return 0x82222C80;
		  /* 82222C80h */ case    4:  		/* fcmpu CR6, FR0, FR30 */
		/* 82222C80h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82222C80h case    4:*/		return 0x82222C84;
		  /* 82222C84h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82222C84h case    5:*/		if ( regs.CR[6].eq ) { return 0x82222C90;  }
		/* 82222C84h case    5:*/		return 0x82222C88;
		  /* 82222C88h */ case    6:  		/* stfdx FR30, <#[R10 + R11]> */
		/* 82222C88h case    6:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82222C88h case    6:*/		return 0x82222C8C;
		  /* 82222C8Ch */ case    7:  		/* li R3, 1 */
		/* 82222C8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82222C8Ch case    7:*/		return 0x82222C90;
	}
	return 0x82222C90;
} // Block from 82222C70h-82222C90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82222C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222C90);
		  /* 82222C90h */ case    0:  		/* addi R10, R28, 5 */
		/* 82222C90h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x5);
		/* 82222C90h case    0:*/		return 0x82222C94;
		  /* 82222C94h */ case    1:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82222C94h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82222C94h case    1:*/		return 0x82222C98;
		  /* 82222C98h */ case    2:  		/* lfdx FR0, <#[R10 + R11]> */
		/* 82222C98h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82222C98h case    2:*/		return 0x82222C9C;
		  /* 82222C9Ch */ case    3:  		/* fcmpu CR6, FR0, FR29 */
		/* 82222C9Ch case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 82222C9Ch case    3:*/		return 0x82222CA0;
		  /* 82222CA0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82222CA0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82222CAC;  }
		/* 82222CA0h case    4:*/		return 0x82222CA4;
		  /* 82222CA4h */ case    5:  		/* stfdx FR29, <#[R10 + R11]> */
		/* 82222CA4h case    5:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82222CA4h case    5:*/		return 0x82222CA8;
		  /* 82222CA8h */ case    6:  		/* li R3, 1 */
		/* 82222CA8h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82222CA8h case    6:*/		return 0x82222CAC;
	}
	return 0x82222CAC;
} // Block from 82222C90h-82222CACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222CAC);
		  /* 82222CACh */ case    0:  		/* li R10, 0 */
		/* 82222CACh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82222CACh case    0:*/		return 0x82222CB0;
		  /* 82222CB0h */ case    1:  		/* fcmpu CR6, FR30, FR31 */
		/* 82222CB0h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR31);
		/* 82222CB0h case    1:*/		return 0x82222CB4;
		  /* 82222CB4h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82222CB4h case    2:*/		if ( regs.CR[6].lt ) { return 0x82222CBC;  }
		/* 82222CB4h case    2:*/		return 0x82222CB8;
		  /* 82222CB8h */ case    3:  		/* li R10, 2 */
		/* 82222CB8h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82222CB8h case    3:*/		return 0x82222CBC;
	}
	return 0x82222CBC;
} // Block from 82222CACh-82222CBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222CBC);
		  /* 82222CBCh */ case    0:  		/* fcmpu CR6, FR29, FR31 */
		/* 82222CBCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR31);
		/* 82222CBCh case    0:*/		return 0x82222CC0;
		  /* 82222CC0h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 82222CC0h case    1:*/		if ( regs.CR[6].gt ) { return 0x82222CC8;  }
		/* 82222CC0h case    1:*/		return 0x82222CC4;
		  /* 82222CC4h */ case    2:  		/* ori R10, R10, 1 */
		/* 82222CC4h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82222CC4h case    2:*/		return 0x82222CC8;
	}
	return 0x82222CC8;
} // Block from 82222CBCh-82222CC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222CC8);
		  /* 82222CC8h */ case    0:  		/* cmplw CR6, R25, R10 */
		/* 82222CC8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 82222CC8h case    0:*/		return 0x82222CCC;
		  /* 82222CCCh */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 82222CCCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82222D14;  }
		/* 82222CCCh case    1:*/		return 0x82222CD0;
		  /* 82222CD0h */ case    2:  		/* li R9, 3 */
		/* 82222CD0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 82222CD0h case    2:*/		return 0x82222CD4;
		  /* 82222CD4h */ case    3:  		/* lwz R11, <#[R27 + 12]> */
		/* 82222CD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82222CD4h case    3:*/		return 0x82222CD8;
		  /* 82222CD8h */ case    4:  		/* slw R10, R10, R26 */
		/* 82222CD8h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 82222CD8h case    4:*/		return 0x82222CDC;
		  /* 82222CDCh */ case    5:  		/* slw R9, R9, R26 */
		/* 82222CDCh case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R26);
		/* 82222CDCh case    5:*/		return 0x82222CE0;
		  /* 82222CE0h */ case    6:  		/* and R8, R11, R9 */
		/* 82222CE0h case    6:*/		cpu::op::and<0>(regs,&regs.R8,regs.R11,regs.R9);
		/* 82222CE0h case    6:*/		return 0x82222CE4;
		  /* 82222CE4h */ case    7:  		/* rlwinm R8, R8, 0, 16, 31 */
		/* 82222CE4h case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R8);
		/* 82222CE4h case    7:*/		return 0x82222CE8;
		  /* 82222CE8h */ case    8:  		/* cmplw CR6, R8, R10 */
		/* 82222CE8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82222CE8h case    8:*/		return 0x82222CEC;
		  /* 82222CECh */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82222CECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82222CF8;  }
		/* 82222CECh case    9:*/		return 0x82222CF0;
		  /* 82222CF0h */ case   10:  		/* li R11, 0 */
		/* 82222CF0h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82222CF0h case   10:*/		return 0x82222CF4;
		  /* 82222CF4h */ case   11:  		/* b 20 */
		/* 82222CF4h case   11:*/		return 0x82222D08;
		/* 82222CF4h case   11:*/		return 0x82222CF8;
	}
	return 0x82222CF8;
} // Block from 82222CC8h-82222CF8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82222CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222CF8);
		  /* 82222CF8h */ case    0:  		/* andc R9, R11, R9 */
		/* 82222CF8h case    0:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82222CF8h case    0:*/		return 0x82222CFC;
		  /* 82222CFCh */ case    1:  		/* li R11, 1 */
		/* 82222CFCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82222CFCh case    1:*/		return 0x82222D00;
	}
	return 0x82222D00;
} // Block from 82222CF8h-82222D00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222D00h
// Function '?ParseInputSemantic@Compiler@D3DXShader@@AAA_NPBDIPAUInputSemantic@2@K_NPAVCNode@2@PAULinkageSemantics@2@PAW4PARAMGEN@2@PA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222D00);
		  /* 82222D00h */ case    0:  		/* or R10, R9, R10 */
		/* 82222D00h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82222D00h case    0:*/		return 0x82222D04;
		  /* 82222D04h */ case    1:  		/* sth R10, <#[R27 + 14]> */
		/* 82222D04h case    1:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R27 + 0x0000000E) );
		/* 82222D04h case    1:*/		return 0x82222D08;
	}
	return 0x82222D08;
} // Block from 82222D00h-82222D08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222D08);
		  /* 82222D08h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82222D08h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82222D08h case    0:*/		return 0x82222D0C;
		  /* 82222D0Ch */ case    1:  		/* rlwinm R10, R3, 0, 24, 31 */
		/* 82222D0Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R3);
		/* 82222D0Ch case    1:*/		return 0x82222D10;
		  /* 82222D10h */ case    2:  		/* or R3, R11, R10 */
		/* 82222D10h case    2:*/		cpu::op::or<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82222D10h case    2:*/		return 0x82222D14;
	}
	return 0x82222D14;
} // Block from 82222D08h-82222D14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222D14);
		  /* 82222D14h */ case    0:  		/* addi R1, R1, 176 */
		/* 82222D14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82222D14h case    0:*/		return 0x82222D18;
		  /* 82222D18h */ case    1:  		/* lfd FR29, <#[R1 - 88]> */
		/* 82222D18h case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 82222D18h case    1:*/		return 0x82222D1C;
		  /* 82222D1Ch */ case    2:  		/* lfd FR30, <#[R1 - 80]> */
		/* 82222D1Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 82222D1Ch case    2:*/		return 0x82222D20;
		  /* 82222D20h */ case    3:  		/* lfd FR31, <#[R1 - 72]> */
		/* 82222D20h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82222D20h case    3:*/		return 0x82222D24;
		  /* 82222D24h */ case    4:  		/* b -1645192 */
		/* 82222D24h case    4:*/		return 0x8209129C;
		/* 82222D24h case    4:*/		return 0x82222D28;
	}
	return 0x82222D28;
} // Block from 82222D14h-82222D28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82222D28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222D28);
		  /* 82222D28h */ case    0:  		/* mfspr R12, LR */
		/* 82222D28h case    0:*/		regs.R12 = regs.LR;
		/* 82222D28h case    0:*/		return 0x82222D2C;
		  /* 82222D2Ch */ case    1:  		/* bl -1645264 */
		/* 82222D2Ch case    1:*/		regs.LR = 0x82222D30; return 0x8209125C;
		/* 82222D2Ch case    1:*/		return 0x82222D30;
		  /* 82222D30h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82222D30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82222D30h case    2:*/		return 0x82222D34;
		  /* 82222D34h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82222D34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82222D34h case    3:*/		return 0x82222D38;
		  /* 82222D38h */ case    4:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 82222D38h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 82222D38h case    4:*/		return 0x82222D3C;
		  /* 82222D3Ch */ case    5:  		/* mr R31, R3 */
		/* 82222D3Ch case    5:*/		regs.R31 = regs.R3;
		/* 82222D3Ch case    5:*/		return 0x82222D40;
		  /* 82222D40h */ case    6:  		/* lwz R3, <#[R3 + 12]> */
		/* 82222D40h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 82222D40h case    6:*/		return 0x82222D44;
		  /* 82222D44h */ case    7:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 82222D44h case    7:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 82222D44h case    7:*/		return 0x82222D48;
		  /* 82222D48h */ case    8:  		/* mr R30, R5 */
		/* 82222D48h case    8:*/		regs.R30 = regs.R5;
		/* 82222D48h case    8:*/		return 0x82222D4C;
		  /* 82222D4Ch */ case    9:  		/* srw R11, R11, R10 */
		/* 82222D4Ch case    9:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82222D4Ch case    9:*/		return 0x82222D50;
		  /* 82222D50h */ case   10:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 82222D50h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 82222D50h case   10:*/		return 0x82222D54;
		  /* 82222D54h */ case   11:  		/* mr R29, R6 */
		/* 82222D54h case   11:*/		regs.R29 = regs.R6;
		/* 82222D54h case   11:*/		return 0x82222D58;
		  /* 82222D58h */ case   12:  		/* bl -936 */
		/* 82222D58h case   12:*/		regs.LR = 0x82222D5C; return 0x822229B0;
		/* 82222D58h case   12:*/		return 0x82222D5C;
		  /* 82222D5Ch */ case   13:  		/* lwz R11, <#[R31]> */
		/* 82222D5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82222D5Ch case   13:*/		return 0x82222D60;
		  /* 82222D60h */ case   14:  		/* mr R4, R29 */
		/* 82222D60h case   14:*/		regs.R4 = regs.R29;
		/* 82222D60h case   14:*/		return 0x82222D64;
		  /* 82222D64h */ case   15:  		/* mr R3, R30 */
		/* 82222D64h case   15:*/		regs.R3 = regs.R30;
		/* 82222D64h case   15:*/		return 0x82222D68;
		  /* 82222D68h */ case   16:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 82222D68h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 82222D68h case   16:*/		return 0x82222D6C;
		  /* 82222D6Ch */ case   17:  		/* bl -5604 */
		/* 82222D6Ch case   17:*/		regs.LR = 0x82222D70; return 0x82221788;
		/* 82222D6Ch case   17:*/		return 0x82222D70;
		  /* 82222D70h */ case   18:  		/* addi R1, R1, 112 */
		/* 82222D70h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82222D70h case   18:*/		return 0x82222D74;
		  /* 82222D74h */ case   19:  		/* b -1645256 */
		/* 82222D74h case   19:*/		return 0x820912AC;
		/* 82222D74h case   19:*/		return 0x82222D78;
	}
	return 0x82222D78;
} // Block from 82222D28h-82222D78h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82222D78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222D78);
		  /* 82222D78h */ case    0:  		/* mfspr R12, LR */
		/* 82222D78h case    0:*/		regs.R12 = regs.LR;
		/* 82222D78h case    0:*/		return 0x82222D7C;
		  /* 82222D7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82222D7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82222D7Ch case    1:*/		return 0x82222D80;
		  /* 82222D80h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82222D80h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82222D80h case    2:*/		return 0x82222D84;
		  /* 82222D84h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82222D84h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82222D84h case    3:*/		return 0x82222D88;
		  /* 82222D88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82222D88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82222D88h case    4:*/		return 0x82222D8C;
		  /* 82222D8Ch */ case    5:  		/* mr R30, R3 */
		/* 82222D8Ch case    5:*/		regs.R30 = regs.R3;
		/* 82222D8Ch case    5:*/		return 0x82222D90;
		  /* 82222D90h */ case    6:  		/* mr R31, R4 */
		/* 82222D90h case    6:*/		regs.R31 = regs.R4;
		/* 82222D90h case    6:*/		return 0x82222D94;
		  /* 82222D94h */ case    7:  		/* mr R3, R5 */
		/* 82222D94h case    7:*/		regs.R3 = regs.R5;
		/* 82222D94h case    7:*/		return 0x82222D98;
		  /* 82222D98h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 82222D98h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82222D98h case    8:*/		return 0x82222D9C;
		  /* 82222D9Ch */ case    9:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82222D9Ch case    9:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82222D9Ch case    9:*/		return 0x82222DA0;
		  /* 82222DA0h */ case   10:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82222DA0h case   10:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82222DA0h case   10:*/		return 0x82222DA4;
		  /* 82222DA4h */ case   11:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82222DA4h case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82222DA4h case   11:*/		return 0x82222DA8;
		  /* 82222DA8h */ case   12:  		/* bl -780664 */
		/* 82222DA8h case   12:*/		regs.LR = 0x82222DAC; return 0x82164430;
		/* 82222DA8h case   12:*/		return 0x82222DAC;
		  /* 82222DACh */ case   13:  		/* addi R11, R30, -20 */
		/* 82222DACh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFEC);
		/* 82222DACh case   13:*/		return 0x82222DB0;
		  /* 82222DB0h */ case   14:  		/* add R9, R3, R11 */
		/* 82222DB0h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R3,regs.R11);
		/* 82222DB0h case   14:*/		return 0x82222DB4;
		  /* 82222DB4h */ case   15:  		/* lwz R11, <#[R9]> */
		/* 82222DB4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82222DB4h case   15:*/		return 0x82222DB8;
		  /* 82222DB8h */ case   16:  		/* stw R11, <#[R31]> */
		/* 82222DB8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82222DB8h case   16:*/		return 0x82222DBC;
		  /* 82222DBCh */ case   17:  		/* lwz R11, <#[R9 + 4]> */
		/* 82222DBCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82222DBCh case   17:*/		return 0x82222DC0;
		  /* 82222DC0h */ case   18:  		/* stw R11, <#[R31 + 4]> */
		/* 82222DC0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222DC0h case   18:*/		return 0x82222DC4;
		  /* 82222DC4h */ case   19:  		/* lwz R11, <#[R9 + 8]> */
		/* 82222DC4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82222DC4h case   19:*/		return 0x82222DC8;
		  /* 82222DC8h */ case   20:  		/* stw R11, <#[R31 + 8]> */
		/* 82222DC8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82222DC8h case   20:*/		return 0x82222DCC;
		  /* 82222DCCh */ case   21:  		/* lwz R11, <#[R30 + 4]> */
		/* 82222DCCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82222DCCh case   21:*/		return 0x82222DD0;
		  /* 82222DD0h */ case   22:  		/* cmplwi CR6, R11, 0 */
		/* 82222DD0h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82222DD0h case   22:*/		return 0x82222DD4;
		  /* 82222DD4h */ case   23:  		/* bc 12, CR6_EQ, 440 */
		/* 82222DD4h case   23:*/		if ( regs.CR[6].eq ) { return 0x82222F8C;  }
		/* 82222DD4h case   23:*/		return 0x82222DD8;
		  /* 82222DD8h */ case   24:  		/* lwz R10, <#[R11 + 16]> */
		/* 82222DD8h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82222DD8h case   24:*/		return 0x82222DDC;
		  /* 82222DDCh */ case   25:  		/* cmplwi CR6, R10, 0 */
		/* 82222DDCh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82222DDCh case   25:*/		return 0x82222DE0;
		  /* 82222DE0h */ case   26:  		/* bc 12, CR6_EQ, 16 */
		/* 82222DE0h case   26:*/		if ( regs.CR[6].eq ) { return 0x82222DF0;  }
		/* 82222DE0h case   26:*/		return 0x82222DE4;
		  /* 82222DE4h */ case   27:  		/* lwz R10, <#[R11]> */
		/* 82222DE4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82222DE4h case   27:*/		return 0x82222DE8;
		  /* 82222DE8h */ case   28:  		/* rlwinm. R8, R10, 0, 4, 6 */
		/* 82222DE8h case   28:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R10);
		/* 82222DE8h case   28:*/		return 0x82222DEC;
		  /* 82222DECh */ case   29:  		/* bc 4, CR0_EQ, 12 */
		/* 82222DECh case   29:*/		if ( !regs.CR[0].eq ) { return 0x82222DF8;  }
		/* 82222DECh case   29:*/		return 0x82222DF0;
	}
	return 0x82222DF0;
} // Block from 82222D78h-82222DF0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82222DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222DF0);
		  /* 82222DF0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82222DF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82222DF0h case    0:*/		return 0x82222DF4;
		  /* 82222DF4h */ case    1:  		/* b -36 */
		/* 82222DF4h case    1:*/		return 0x82222DD0;
		/* 82222DF4h case    1:*/		return 0x82222DF8;
	}
	return 0x82222DF8;
} // Block from 82222DF0h-82222DF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222DF8);
		  /* 82222DF8h */ case    0:  		/* lwz R8, <#[R31]> */
		/* 82222DF8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82222DF8h case    0:*/		return 0x82222DFC;
		  /* 82222DFCh */ case    1:  		/* rlwimi R8, R10, 27, 14, 19 */
		/* 82222DFCh case    1:*/		cpu::op::rlwimi<0,27,14,19>(regs,&regs.R8,regs.R10);
		/* 82222DFCh case    1:*/		return 0x82222E00;
		  /* 82222E00h */ case    2:  		/* stw R8, <#[R31]> */
		/* 82222E00h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82222E00h case    2:*/		return 0x82222E04;
		  /* 82222E04h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82222E04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222E04h case    3:*/		return 0x82222E08;
		  /* 82222E08h */ case    4:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 82222E08h case    4:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 82222E08h case    4:*/		return 0x82222E0C;
		  /* 82222E0Ch */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82222E0Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82222E1C;  }
		/* 82222E0Ch case    5:*/		return 0x82222E10;
		  /* 82222E10h */ case    6:  		/* rlwinm R11, R8, 0, 0, 31 */
		/* 82222E10h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R8);
		/* 82222E10h case    6:*/		return 0x82222E14;
		  /* 82222E14h */ case    7:  		/* oris R11, R11, 4 */
		/* 82222E14h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82222E14h case    7:*/		return 0x82222E18;
		  /* 82222E18h */ case    8:  		/* stw R11, <#[R31]> */
		/* 82222E18h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82222E18h case    8:*/		return 0x82222E1C;
	}
	return 0x82222E1C;
} // Block from 82222DF8h-82222E1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82222E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E1C);
		  /* 82222E1Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82222E1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82222E1Ch case    0:*/		return 0x82222E20;
		  /* 82222E20h */ case    1:  		/* lwz R8, <#[R9 + 12]> */
		/* 82222E20h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 82222E20h case    1:*/		return 0x82222E24;
		  /* 82222E24h */ case    2:  		/* rlwinm R10, R11, 31, 28, 31 */
		/* 82222E24h case    2:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R10,regs.R11);
		/* 82222E24h case    2:*/		return 0x82222E28;
		  /* 82222E28h */ case    3:  		/* rlwinm R11, R8, 15, 24, 31 */
		/* 82222E28h case    3:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R8);
		/* 82222E28h case    3:*/		return 0x82222E2C;
		  /* 82222E2Ch */ case    4:  		/* rlwinm. R8, R10, 0, 31, 31 */
		/* 82222E2Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R10);
		/* 82222E2Ch case    4:*/		return 0x82222E30;
		  /* 82222E30h */ case    5:  		/* lwz R8, <#[R31 + 4]> */
		/* 82222E30h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82222E30h case    5:*/		return 0x82222E34;
		  /* 82222E34h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 82222E34h case    6:*/		if ( regs.CR[0].eq ) { return 0x82222E48;  }
		/* 82222E34h case    6:*/		return 0x82222E38;
		  /* 82222E38h */ case    7:  		/* rlwinm R7, R11, 0, 30, 31 */
		/* 82222E38h case    7:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R11);
		/* 82222E38h case    7:*/		return 0x82222E3C;
		  /* 82222E3Ch */ case    8:  		/* rlwinm R8, R8, 0, 0, 28 */
		/* 82222E3Ch case    8:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R8,regs.R8);
		/* 82222E3Ch case    8:*/		return 0x82222E40;
		  /* 82222E40h */ case    9:  		/* or R8, R8, R7 */
		/* 82222E40h case    9:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82222E40h case    9:*/		return 0x82222E44;
		  /* 82222E44h */ case   10:  		/* b 8 */
		/* 82222E44h case   10:*/		return 0x82222E4C;
		/* 82222E44h case   10:*/		return 0x82222E48;
	}
	return 0x82222E48;
} // Block from 82222E1Ch-82222E48h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82222E48h
// Function '?ComputeReverseRegisterEffect@Compiler@D3DXShader@@QAAHPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E48);
		  /* 82222E48h */ case    0:  		/* ori R8, R8, 7 */
		/* 82222E48h case    0:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x7);
		/* 82222E48h case    0:*/		return 0x82222E4C;
	}
	return 0x82222E4C;
} // Block from 82222E48h-82222E4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E4C);
		  /* 82222E4Ch */ case    0:  		/* stw R8, <#[R31 + 4]> */
		/* 82222E4Ch case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82222E4Ch case    0:*/		return 0x82222E50;
		  /* 82222E50h */ case    1:  		/* rlwinm. R8, R10, 0, 30, 30 */
		/* 82222E50h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R8,regs.R10);
		/* 82222E50h case    1:*/		return 0x82222E54;
		  /* 82222E54h */ case    2:  		/* lwz R8, <#[R31 + 4]> */
		/* 82222E54h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82222E54h case    2:*/		return 0x82222E58;
		  /* 82222E58h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82222E58h case    3:*/		if ( regs.CR[0].eq ) { return 0x82222E68;  }
		/* 82222E58h case    3:*/		return 0x82222E5C;
		  /* 82222E5Ch */ case    4:  		/* rlwimi R8, R11, 1, 27, 28 */
		/* 82222E5Ch case    4:*/		cpu::op::rlwimi<0,1,27,28>(regs,&regs.R8,regs.R11);
		/* 82222E5Ch case    4:*/		return 0x82222E60;
		  /* 82222E60h */ case    5:  		/* rlwinm R8, R8, 0, 27, 25 */
		/* 82222E60h case    5:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R8,regs.R8);
		/* 82222E60h case    5:*/		return 0x82222E64;
		  /* 82222E64h */ case    6:  		/* b 8 */
		/* 82222E64h case    6:*/		return 0x82222E6C;
		/* 82222E64h case    6:*/		return 0x82222E68;
	}
	return 0x82222E68;
} // Block from 82222E4Ch-82222E68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E68);
		  /* 82222E68h */ case    0:  		/* ori R8, R8, 56 */
		/* 82222E68h case    0:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x38);
		/* 82222E68h case    0:*/		return 0x82222E6C;
	}
	return 0x82222E6C;
} // Block from 82222E68h-82222E6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E6C);
		  /* 82222E6Ch */ case    0:  		/* stw R8, <#[R31 + 4]> */
		/* 82222E6Ch case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82222E6Ch case    0:*/		return 0x82222E70;
		  /* 82222E70h */ case    1:  		/* rlwinm. R8, R10, 0, 29, 29 */
		/* 82222E70h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R8,regs.R10);
		/* 82222E70h case    1:*/		return 0x82222E74;
		  /* 82222E74h */ case    2:  		/* lwz R8, <#[R31 + 4]> */
		/* 82222E74h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82222E74h case    2:*/		return 0x82222E78;
		  /* 82222E78h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82222E78h case    3:*/		if ( regs.CR[0].eq ) { return 0x82222E88;  }
		/* 82222E78h case    3:*/		return 0x82222E7C;
		  /* 82222E7Ch */ case    4:  		/* rlwimi R8, R11, 2, 24, 25 */
		/* 82222E7Ch case    4:*/		cpu::op::rlwimi<0,2,24,25>(regs,&regs.R8,regs.R11);
		/* 82222E7Ch case    4:*/		return 0x82222E80;
		  /* 82222E80h */ case    5:  		/* rlwinm R8, R8, 0, 24, 22 */
		/* 82222E80h case    5:*/		cpu::op::rlwinm<0,0,24,22>(regs,&regs.R8,regs.R8);
		/* 82222E80h case    5:*/		return 0x82222E84;
		  /* 82222E84h */ case    6:  		/* b 8 */
		/* 82222E84h case    6:*/		return 0x82222E8C;
		/* 82222E84h case    6:*/		return 0x82222E88;
	}
	return 0x82222E88;
} // Block from 82222E6Ch-82222E88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E88);
		  /* 82222E88h */ case    0:  		/* ori R8, R8, 448 */
		/* 82222E88h case    0:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1C0);
		/* 82222E88h case    0:*/		return 0x82222E8C;
	}
	return 0x82222E8C;
} // Block from 82222E88h-82222E8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222E8C);
		  /* 82222E8Ch */ case    0:  		/* stw R8, <#[R31 + 4]> */
		/* 82222E8Ch case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82222E8Ch case    0:*/		return 0x82222E90;
		  /* 82222E90h */ case    1:  		/* rlwinm. R10, R10, 0, 28, 28 */
		/* 82222E90h case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R10);
		/* 82222E90h case    1:*/		return 0x82222E94;
		  /* 82222E94h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 82222E94h case    2:*/		if ( regs.CR[0].eq ) { return 0x82222EA8;  }
		/* 82222E94h case    2:*/		return 0x82222E98;
		  /* 82222E98h */ case    3:  		/* rlwinm R10, R8, 0, 0, 31 */
		/* 82222E98h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R8);
		/* 82222E98h case    3:*/		return 0x82222E9C;
		  /* 82222E9Ch */ case    4:  		/* rlwimi R10, R11, 3, 21, 22 */
		/* 82222E9Ch case    4:*/		cpu::op::rlwimi<0,3,21,22>(regs,&regs.R10,regs.R11);
		/* 82222E9Ch case    4:*/		return 0x82222EA0;
		  /* 82222EA0h */ case    5:  		/* rlwinm R11, R10, 0, 21, 19 */
		/* 82222EA0h case    5:*/		cpu::op::rlwinm<0,0,21,19>(regs,&regs.R11,regs.R10);
		/* 82222EA0h case    5:*/		return 0x82222EA4;
		  /* 82222EA4h */ case    6:  		/* b 12 */
		/* 82222EA4h case    6:*/		return 0x82222EB0;
		/* 82222EA4h case    6:*/		return 0x82222EA8;
	}
	return 0x82222EA8;
} // Block from 82222E8Ch-82222EA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222EA8);
		  /* 82222EA8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222EA8h case    0:*/		return 0x82222EAC;
		  /* 82222EACh */ case    1:  		/* ori R11, R11, 3584 */
		/* 82222EACh case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE00);
		/* 82222EACh case    1:*/		return 0x82222EB0;
	}
	return 0x82222EB0;
} // Block from 82222EA8h-82222EB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222EB0);
		  /* 82222EB0h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82222EB0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222EB0h case    0:*/		return 0x82222EB4;
		  /* 82222EB4h */ case    1:  		/* lwz R11, <#[R9 + 12]> */
		/* 82222EB4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82222EB4h case    1:*/		return 0x82222EB8;
		  /* 82222EB8h */ case    2:  		/* rlwinm. R11, R11, 24, 28, 31 */
		/* 82222EB8h case    2:*/		cpu::op::rlwinm<1,24,28,31>(regs,&regs.R11,regs.R11);
		/* 82222EB8h case    2:*/		return 0x82222EBC;
		  /* 82222EBCh */ case    3:  		/* bc 12, CR0_EQ, 100 */
		/* 82222EBCh case    3:*/		if ( regs.CR[0].eq ) { return 0x82222F20;  }
		/* 82222EBCh case    3:*/		return 0x82222EC0;
		  /* 82222EC0h */ case    4:  		/* cntlzw R11, R11 */
		/* 82222EC0h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82222EC0h case    4:*/		return 0x82222EC4;
		  /* 82222EC4h */ case    5:  		/* subfic R11, R11, 31 */
		/* 82222EC4h case    5:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82222EC4h case    5:*/		return 0x82222EC8;
		  /* 82222EC8h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 82222EC8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82222EC8h case    6:*/		return 0x82222ECC;
		  /* 82222ECCh */ case    7:  		/* bc 12, CR6_LT, 68 */
		/* 82222ECCh case    7:*/		if ( regs.CR[6].lt ) { return 0x82222F10;  }
		/* 82222ECCh case    7:*/		return 0x82222ED0;
		  /* 82222ED0h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 82222ED0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82222F00;  }
		/* 82222ED0h case    8:*/		return 0x82222ED4;
		  /* 82222ED4h */ case    9:  		/* cmplwi CR6, R11, 3 */
		/* 82222ED4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82222ED4h case    9:*/		return 0x82222ED8;
		  /* 82222ED8h */ case   10:  		/* bc 12, CR6_LT, 24 */
		/* 82222ED8h case   10:*/		if ( regs.CR[6].lt ) { return 0x82222EF0;  }
		/* 82222ED8h case   10:*/		return 0x82222EDC;
		  /* 82222EDCh */ case   11:  		/* bc 4, CR6_EQ, 68 */
		/* 82222EDCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x82222F20;  }
		/* 82222EDCh case   11:*/		return 0x82222EE0;
		  /* 82222EE0h */ case   12:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222EE0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222EE0h case   12:*/		return 0x82222EE4;
		  /* 82222EE4h */ case   13:  		/* li R10, 1 */
		/* 82222EE4h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82222EE4h case   13:*/		return 0x82222EE8;
		  /* 82222EE8h */ case   14:  		/* rlwimi R11, R10, 11, 20, 22 */
		/* 82222EE8h case   14:*/		cpu::op::rlwimi<0,11,20,22>(regs,&regs.R11,regs.R10);
		/* 82222EE8h case   14:*/		return 0x82222EEC;
		  /* 82222EECh */ case   15:  		/* b 48 */
		/* 82222EECh case   15:*/		return 0x82222F1C;
		/* 82222EECh case   15:*/		return 0x82222EF0;
	}
	return 0x82222EF0;
} // Block from 82222EB0h-82222EF0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82222EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222EF0);
		  /* 82222EF0h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222EF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222EF0h case    0:*/		return 0x82222EF4;
		  /* 82222EF4h */ case    1:  		/* li R10, 1 */
		/* 82222EF4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82222EF4h case    1:*/		return 0x82222EF8;
		  /* 82222EF8h */ case    2:  		/* rlwimi R11, R10, 8, 23, 25 */
		/* 82222EF8h case    2:*/		cpu::op::rlwimi<0,8,23,25>(regs,&regs.R11,regs.R10);
		/* 82222EF8h case    2:*/		return 0x82222EFC;
		  /* 82222EFCh */ case    3:  		/* b 32 */
		/* 82222EFCh case    3:*/		return 0x82222F1C;
		/* 82222EFCh case    3:*/		return 0x82222F00;
	}
	return 0x82222F00;
} // Block from 82222EF0h-82222F00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F00);
		  /* 82222F00h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F00h case    0:*/		return 0x82222F04;
		  /* 82222F04h */ case    1:  		/* li R10, 1 */
		/* 82222F04h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82222F04h case    1:*/		return 0x82222F08;
		  /* 82222F08h */ case    2:  		/* rlwimi R11, R10, 5, 26, 28 */
		/* 82222F08h case    2:*/		cpu::op::rlwimi<0,5,26,28>(regs,&regs.R11,regs.R10);
		/* 82222F08h case    2:*/		return 0x82222F0C;
		  /* 82222F0Ch */ case    3:  		/* b 16 */
		/* 82222F0Ch case    3:*/		return 0x82222F1C;
		/* 82222F0Ch case    3:*/		return 0x82222F10;
	}
	return 0x82222F10;
} // Block from 82222F00h-82222F10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F10);
		  /* 82222F10h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F10h case    0:*/		return 0x82222F14;
		  /* 82222F14h */ case    1:  		/* li R10, 1 */
		/* 82222F14h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82222F14h case    1:*/		return 0x82222F18;
		  /* 82222F18h */ case    2:  		/* rlwimi R11, R10, 2, 29, 31 */
		/* 82222F18h case    2:*/		cpu::op::rlwimi<0,2,29,31>(regs,&regs.R11,regs.R10);
		/* 82222F18h case    2:*/		return 0x82222F1C;
	}
	return 0x82222F1C;
} // Block from 82222F10h-82222F1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82222F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F1C);
		  /* 82222F1Ch */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82222F1Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F1Ch case    0:*/		return 0x82222F20;
	}
	return 0x82222F20;
} // Block from 82222F1Ch-82222F20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F20);
		  /* 82222F20h */ case    0:  		/* lwz R11, <#[R9 + 12]> */
		/* 82222F20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82222F20h case    0:*/		return 0x82222F24;
		  /* 82222F24h */ case    1:  		/* rlwinm. R11, R11, 20, 28, 31 */
		/* 82222F24h case    1:*/		cpu::op::rlwinm<1,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82222F24h case    1:*/		return 0x82222F28;
		  /* 82222F28h */ case    2:  		/* bc 12, CR0_EQ, 112 */
		/* 82222F28h case    2:*/		if ( regs.CR[0].eq ) { return 0x82222F98;  }
		/* 82222F28h case    2:*/		return 0x82222F2C;
		  /* 82222F2Ch */ case    3:  		/* cntlzw R11, R11 */
		/* 82222F2Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82222F2Ch case    3:*/		return 0x82222F30;
		  /* 82222F30h */ case    4:  		/* subfic R11, R11, 31 */
		/* 82222F30h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82222F30h case    4:*/		return 0x82222F34;
		  /* 82222F34h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 82222F34h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82222F34h case    5:*/		return 0x82222F38;
		  /* 82222F38h */ case    6:  		/* bc 12, CR6_LT, 68 */
		/* 82222F38h case    6:*/		if ( regs.CR[6].lt ) { return 0x82222F7C;  }
		/* 82222F38h case    6:*/		return 0x82222F3C;
		  /* 82222F3Ch */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 82222F3Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82222F6C;  }
		/* 82222F3Ch case    7:*/		return 0x82222F40;
	}
	return 0x82222F40;
} // Block from 82222F20h-82222F40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82222F40h
// Function '?SetRegister@Instruction@D3DXShader@@QAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F40);
		  /* 82222F40h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 82222F40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82222F40h case    0:*/		return 0x82222F44;
		  /* 82222F44h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 82222F44h case    1:*/		if ( regs.CR[6].lt ) { return 0x82222F5C;  }
		/* 82222F44h case    1:*/		return 0x82222F48;
		  /* 82222F48h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 82222F48h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82222F98;  }
		/* 82222F48h case    2:*/		return 0x82222F4C;
		  /* 82222F4Ch */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F4Ch case    3:*/		return 0x82222F50;
		  /* 82222F50h */ case    4:  		/* li R10, 5 */
		/* 82222F50h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82222F50h case    4:*/		return 0x82222F54;
		  /* 82222F54h */ case    5:  		/* rlwimi R11, R10, 9, 20, 22 */
		/* 82222F54h case    5:*/		cpu::op::rlwimi<0,9,20,22>(regs,&regs.R11,regs.R10);
		/* 82222F54h case    5:*/		return 0x82222F58;
		  /* 82222F58h */ case    6:  		/* b 60 */
		/* 82222F58h case    6:*/		return 0x82222F94;
		/* 82222F58h case    6:*/		return 0x82222F5C;
	}
	return 0x82222F5C;
} // Block from 82222F40h-82222F5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82222F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F5C);
		  /* 82222F5Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F5Ch case    0:*/		return 0x82222F60;
		  /* 82222F60h */ case    1:  		/* li R10, 5 */
		/* 82222F60h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82222F60h case    1:*/		return 0x82222F64;
		  /* 82222F64h */ case    2:  		/* rlwimi R11, R10, 6, 23, 25 */
		/* 82222F64h case    2:*/		cpu::op::rlwimi<0,6,23,25>(regs,&regs.R11,regs.R10);
		/* 82222F64h case    2:*/		return 0x82222F68;
		  /* 82222F68h */ case    3:  		/* b 44 */
		/* 82222F68h case    3:*/		return 0x82222F94;
		/* 82222F68h case    3:*/		return 0x82222F6C;
	}
	return 0x82222F6C;
} // Block from 82222F5Ch-82222F6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F6C);
		  /* 82222F6Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F6Ch case    0:*/		return 0x82222F70;
		  /* 82222F70h */ case    1:  		/* li R10, 5 */
		/* 82222F70h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82222F70h case    1:*/		return 0x82222F74;
		  /* 82222F74h */ case    2:  		/* rlwimi R11, R10, 3, 26, 28 */
		/* 82222F74h case    2:*/		cpu::op::rlwimi<0,3,26,28>(regs,&regs.R11,regs.R10);
		/* 82222F74h case    2:*/		return 0x82222F78;
		  /* 82222F78h */ case    3:  		/* b 28 */
		/* 82222F78h case    3:*/		return 0x82222F94;
		/* 82222F78h case    3:*/		return 0x82222F7C;
	}
	return 0x82222F7C;
} // Block from 82222F6Ch-82222F7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F7C);
		  /* 82222F7Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F7Ch case    0:*/		return 0x82222F80;
		  /* 82222F80h */ case    1:  		/* li R10, 5 */
		/* 82222F80h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82222F80h case    1:*/		return 0x82222F84;
		  /* 82222F84h */ case    2:  		/* rlwimi R11, R10, 0, 29, 31 */
		/* 82222F84h case    2:*/		cpu::op::rlwimi<0,0,29,31>(regs,&regs.R11,regs.R10);
		/* 82222F84h case    2:*/		return 0x82222F88;
		  /* 82222F88h */ case    3:  		/* b 12 */
		/* 82222F88h case    3:*/		return 0x82222F94;
		/* 82222F88h case    3:*/		return 0x82222F8C;
	}
	return 0x82222F8C;
} // Block from 82222F7Ch-82222F8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82222F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F8C);
		  /* 82222F8Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82222F8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F8Ch case    0:*/		return 0x82222F90;
		  /* 82222F90h */ case    1:  		/* ori R11, R11, 4095 */
		/* 82222F90h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82222F90h case    1:*/		return 0x82222F94;
	}
	return 0x82222F94;
} // Block from 82222F8Ch-82222F94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82222F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F94);
		  /* 82222F94h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82222F94h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82222F94h case    0:*/		return 0x82222F98;
	}
	return 0x82222F98;
} // Block from 82222F94h-82222F98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82222F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222F98);
		  /* 82222F98h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82222F98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82222F98h case    0:*/		return 0x82222F9C;
		  /* 82222F9Ch */ case    1:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82222F9Ch case    1:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82222F9Ch case    1:*/		return 0x82222FA0;
		  /* 82222FA0h */ case    2:  		/* bc 12, CR0_EQ, 64 */
		/* 82222FA0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82222FE0;  }
		/* 82222FA0h case    2:*/		return 0x82222FA4;
		  /* 82222FA4h */ case    3:  		/* lwz R11, <#[R30 + 44]> */
		/* 82222FA4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 82222FA4h case    3:*/		return 0x82222FA8;
		  /* 82222FA8h */ case    4:  		/* lwz R10, <#[R31]> */
		/* 82222FA8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82222FA8h case    4:*/		return 0x82222FAC;
		  /* 82222FACh */ case    5:  		/* lwz R9, <#[R11]> */
		/* 82222FACh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82222FACh case    5:*/		return 0x82222FB0;
		  /* 82222FB0h */ case    6:  		/* rlwimi R10, R9, 20, 21, 26 */
		/* 82222FB0h case    6:*/		cpu::op::rlwimi<0,20,21,26>(regs,&regs.R10,regs.R9);
		/* 82222FB0h case    6:*/		return 0x82222FB4;
		  /* 82222FB4h */ case    7:  		/* stw R10, <#[R31]> */
		/* 82222FB4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82222FB4h case    7:*/		return 0x82222FB8;
		  /* 82222FB8h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82222FB8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82222FB8h case    8:*/		return 0x82222FBC;
		  /* 82222FBCh */ case    9:  		/* lwz R9, <#[R31]> */
		/* 82222FBCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82222FBCh case    9:*/		return 0x82222FC0;
		  /* 82222FC0h */ case   10:  		/* rlwimi R9, R10, 25, 0, 1 */
		/* 82222FC0h case   10:*/		cpu::op::rlwimi<0,25,0,1>(regs,&regs.R9,regs.R10);
		/* 82222FC0h case   10:*/		return 0x82222FC4;
		  /* 82222FC4h */ case   11:  		/* stw R9, <#[R31]> */
		/* 82222FC4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82222FC4h case   11:*/		return 0x82222FC8;
		  /* 82222FC8h */ case   12:  		/* lwz R11, <#[R11]> */
		/* 82222FC8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82222FC8h case   12:*/		return 0x82222FCC;
		  /* 82222FCCh */ case   13:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 82222FCCh case   13:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 82222FCCh case   13:*/		return 0x82222FD0;
		  /* 82222FD0h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 82222FD0h case   14:*/		if ( regs.CR[0].eq ) { return 0x82222FE0;  }
		/* 82222FD0h case   14:*/		return 0x82222FD4;
		  /* 82222FD4h */ case   15:  		/* rlwinm R11, R9, 0, 0, 31 */
		/* 82222FD4h case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R9);
		/* 82222FD4h case   15:*/		return 0x82222FD8;
		  /* 82222FD8h */ case   16:  		/* ori R11, R11, 2048 */
		/* 82222FD8h case   16:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82222FD8h case   16:*/		return 0x82222FDC;
		  /* 82222FDCh */ case   17:  		/* stw R11, <#[R31]> */
		/* 82222FDCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82222FDCh case   17:*/		return 0x82222FE0;
	}
	return 0x82222FE0;
} // Block from 82222F98h-82222FE0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82222FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82222FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82222FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82222FE0);
		  /* 82222FE0h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82222FE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82222FE0h case    0:*/		return 0x82222FE4;
		  /* 82222FE4h */ case    1:  		/* lis R10, 8 */
		/* 82222FE4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 82222FE4h case    1:*/		return 0x82222FE8;
		  /* 82222FE8h */ case    2:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 82222FE8h case    2:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82222FE8h case    2:*/		return 0x82222FEC;
		  /* 82222FECh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82222FECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82222FECh case    3:*/		return 0x82222FF0;
		  /* 82222FF0h */ case    4:  		/* bc 4, CR6_GT, 60 */
		/* 82222FF0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8222302C;  }
		/* 82222FF0h case    4:*/		return 0x82222FF4;
		  /* 82222FF4h */ case    5:  		/* lwz R11, <#[R30 + 48]> */
		/* 82222FF4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 82222FF4h case    5:*/		return 0x82222FF8;
		  /* 82222FF8h */ case    6:  		/* li R10, 3 */
		/* 82222FF8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 82222FF8h case    6:*/		return 0x82222FFC;
		  /* 82222FFCh */ case    7:  		/* lwz R9, <#[R31]> */
		/* 82222FFCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82222FFCh case    7:*/		return 0x82223000;
		  /* 82223000h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 82223000h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82223000h case    8:*/		return 0x82223004;
		  /* 82223004h */ case    9:  		/* rlwinm R11, R11, 15, 24, 31 */
		/* 82223004h case    9:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R11);
		/* 82223004h case    9:*/		return 0x82223008;
		  /* 82223008h */ case   10:  		/* subfic R11, R11, 95 */
		/* 82223008h case   10:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x5F);
		/* 82223008h case   10:*/		return 0x8222300C;
		  /* 8222300Ch */ case   11:  		/* divwu R8, R11, R10 */
		/* 8222300Ch case   11:*/		cpu::op::divwu<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8222300Ch case   11:*/		return 0x82223010;
		  /* 82223010h */ case   12:  		/* divwu R10, R11, R10 */
		/* 82223010h case   12:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82223010h case   12:*/		return 0x82223014;
		  /* 82223014h */ case   13:  		/* mulli R8, R8, 3 */
		/* 82223014h case   13:*/		cpu::op::mulli<0>(regs,&regs.R8,regs.R8,0x3);
		/* 82223014h case   13:*/		return 0x82223018;
		  /* 82223018h */ case   14:  		/* subf R11, R8, R11 */
		/* 82223018h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82223018h case   14:*/		return 0x8222301C;
		  /* 8222301Ch */ case   15:  		/* rlwimi R10, R11, 5, 25, 26 */
		/* 8222301Ch case   15:*/		cpu::op::rlwimi<0,5,25,26>(regs,&regs.R10,regs.R11);
		/* 8222301Ch case   15:*/		return 0x82223020;
		  /* 82223020h */ case   16:  		/* rlwimi R9, R10, 20, 5, 11 */
		/* 82223020h case   16:*/		cpu::op::rlwimi<0,20,5,11>(regs,&regs.R9,regs.R10);
		/* 82223020h case   16:*/		return 0x82223024;
		  /* 82223024h */ case   17:  		/* stw R9, <#[R31]> */
		/* 82223024h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82223024h case   17:*/		return 0x82223028;
		  /* 82223028h */ case   18:  		/* b 20 */
		/* 82223028h case   18:*/		return 0x8222303C;
		/* 82223028h case   18:*/		return 0x8222302C;
	}
	return 0x8222302C;
} // Block from 82222FE0h-8222302Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8222302Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222302C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222302C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222302C);
		  /* 8222302Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8222302Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8222302Ch case    0:*/		return 0x82223030;
		  /* 82223030h */ case    1:  		/* li R10, 95 */
		/* 82223030h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5F);
		/* 82223030h case    1:*/		return 0x82223034;
		  /* 82223034h */ case    2:  		/* rlwimi R11, R10, 20, 5, 11 */
		/* 82223034h case    2:*/		cpu::op::rlwimi<0,20,5,11>(regs,&regs.R11,regs.R10);
		/* 82223034h case    2:*/		return 0x82223038;
		  /* 82223038h */ case    3:  		/* stw R11, <#[R31]> */
		/* 82223038h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223038h case    3:*/		return 0x8222303C;
	}
	return 0x8222303C;
} // Block from 8222302Ch-8222303Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222303Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222303C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222303C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222303C);
		  /* 8222303Ch */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222303Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222303Ch case    0:*/		return 0x82223040;
		  /* 82223040h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 82223040h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82223040h case    1:*/		return 0x82223044;
		  /* 82223044h */ case    2:  		/* lwz R11, <#[R11 + 76]> */
		/* 82223044h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82223044h case    2:*/		return 0x82223048;
		  /* 82223048h */ case    3:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82223048h case    3:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82223048h case    3:*/		return 0x8222304C;
		  /* 8222304Ch */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 8222304Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82223074;  }
		/* 8222304Ch case    4:*/		return 0x82223050;
		  /* 82223050h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223050h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223050h case    5:*/		return 0x82223054;
		  /* 82223054h */ case    6:  		/* oris R11, R11, 32768 */
		/* 82223054h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82223054h case    6:*/		return 0x82223058;
		  /* 82223058h */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 82223058h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223058h case    7:*/		return 0x8222305C;
		  /* 8222305Ch */ case    8:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222305Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222305Ch case    8:*/		return 0x82223060;
		  /* 82223060h */ case    9:  		/* lwz R11, <#[R11 + 76]> */
		/* 82223060h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82223060h case    9:*/		return 0x82223064;
		  /* 82223064h */ case   10:  		/* rlwinm R11, R11, 9, 24, 31 */
		/* 82223064h case   10:*/		cpu::op::rlwinm<0,9,24,31>(regs,&regs.R11,regs.R11);
		/* 82223064h case   10:*/		return 0x82223068;
		  /* 82223068h */ case   11:  		/* rlwimi R10, R11, 31, 0, 0 */
		/* 82223068h case   11:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R10,regs.R11);
		/* 82223068h case   11:*/		return 0x8222306C;
		  /* 8222306Ch */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8222306Ch case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8222306Ch case   12:*/		return 0x82223070;
		  /* 82223070h */ case   13:  		/* b 32 */
		/* 82223070h case   13:*/		return 0x82223090;
		/* 82223070h case   13:*/		return 0x82223074;
	}
	return 0x82223074;
} // Block from 8222303Ch-82223074h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82223074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223074);
		  /* 82223074h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82223074h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82223074h case    0:*/		return 0x82223078;
		  /* 82223078h */ case    1:  		/* lwz R9, <#[R31 + 4]> */
		/* 82223078h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82223078h case    1:*/		return 0x8222307C;
		  /* 8222307Ch */ case    2:  		/* rlwimi R10, R11, 13, 0, 0 */
		/* 8222307Ch case    2:*/		cpu::op::rlwimi<0,13,0,0>(regs,&regs.R10,regs.R11);
		/* 8222307Ch case    2:*/		return 0x82223080;
		  /* 82223080h */ case    3:  		/* stw R10, <#[R31 + 8]> */
		/* 82223080h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82223080h case    3:*/		return 0x82223084;
		  /* 82223084h */ case    4:  		/* lwz R11, <#[R30 + 8]> */
		/* 82223084h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82223084h case    4:*/		return 0x82223088;
		  /* 82223088h */ case    5:  		/* rlwimi R9, R11, 14, 0, 0 */
		/* 82223088h case    5:*/		cpu::op::rlwimi<0,14,0,0>(regs,&regs.R9,regs.R11);
		/* 82223088h case    5:*/		return 0x8222308C;
		  /* 8222308Ch */ case    6:  		/* stw R9, <#[R31 + 4]> */
		/* 8222308Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8222308Ch case    6:*/		return 0x82223090;
	}
	return 0x82223090;
} // Block from 82223074h-82223090h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82223090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223090);
		  /* 82223090h */ case    0:  		/* addi R1, R1, 112 */
		/* 82223090h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82223090h case    0:*/		return 0x82223094;
		  /* 82223094h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82223094h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82223094h case    1:*/		return 0x82223098;
		  /* 82223098h */ case    2:  		/* mtspr LR, R12 */
		/* 82223098h case    2:*/		regs.LR = regs.R12;
		/* 82223098h case    2:*/		return 0x8222309C;
		  /* 8222309Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8222309Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8222309Ch case    3:*/		return 0x822230A0;
		  /* 822230A0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 822230A0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822230A0h case    4:*/		return 0x822230A4;
		  /* 822230A4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822230A4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822230A4h case    5:*/		return 0x822230A8;
	}
	return 0x822230A8;
} // Block from 82223090h-822230A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822230A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822230A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822230A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822230A8);
		  /* 822230A8h */ case    0:  		/* mfspr R12, LR */
		/* 822230A8h case    0:*/		regs.R12 = regs.LR;
		/* 822230A8h case    0:*/		return 0x822230AC;
		  /* 822230ACh */ case    1:  		/* bl -1646168 */
		/* 822230ACh case    1:*/		regs.LR = 0x822230B0; return 0x82091254;
		/* 822230ACh case    1:*/		return 0x822230B0;
		  /* 822230B0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822230B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822230B0h case    2:*/		return 0x822230B4;
		  /* 822230B4h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 822230B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822230B4h case    3:*/		return 0x822230B8;
		  /* 822230B8h */ case    4:  		/* mr R30, R3 */
		/* 822230B8h case    4:*/		regs.R30 = regs.R3;
		/* 822230B8h case    4:*/		return 0x822230BC;
		  /* 822230BCh */ case    5:  		/* mr R31, R4 */
		/* 822230BCh case    5:*/		regs.R31 = regs.R4;
		/* 822230BCh case    5:*/		return 0x822230C0;
		  /* 822230C0h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 822230C0h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 822230C0h case    6:*/		return 0x822230C4;
		  /* 822230C4h */ case    7:  		/* mr R28, R5 */
		/* 822230C4h case    7:*/		regs.R28 = regs.R5;
		/* 822230C4h case    7:*/		return 0x822230C8;
		  /* 822230C8h */ case    8:  		/* li R27, 1 */
		/* 822230C8h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 822230C8h case    8:*/		return 0x822230CC;
		  /* 822230CCh */ case    9:  		/* li R29, 0 */
		/* 822230CCh case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822230CCh case    9:*/		return 0x822230D0;
		  /* 822230D0h */ case   10:  		/* li R9, 228 */
		/* 822230D0h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0xE4);
		/* 822230D0h case   10:*/		return 0x822230D4;
		  /* 822230D4h */ case   11:  		/* li R8, 0 */
		/* 822230D4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822230D4h case   11:*/		return 0x822230D8;
		  /* 822230D8h */ case   12:  		/* cmplwi CR6, R11, 97 */
		/* 822230D8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 822230D8h case   12:*/		return 0x822230DC;
		  /* 822230DCh */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 822230DCh case   13:*/		if ( regs.CR[6].eq ) { return 0x822230F4;  }
		/* 822230DCh case   13:*/		return 0x822230E0;
		  /* 822230E0h */ case   14:  		/* cmplwi CR6, R11, 99 */
		/* 822230E0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 822230E0h case   14:*/		return 0x822230E4;
		  /* 822230E4h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 822230E4h case   15:*/		if ( regs.CR[6].eq ) { return 0x822230F4;  }
		/* 822230E4h case   15:*/		return 0x822230E8;
		  /* 822230E8h */ case   16:  		/* cmplwi CR6, R11, 100 */
		/* 822230E8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 822230E8h case   16:*/		return 0x822230EC;
		  /* 822230ECh */ case   17:  		/* li R11, 0 */
		/* 822230ECh case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822230ECh case   17:*/		return 0x822230F0;
		  /* 822230F0h */ case   18:  		/* bc 4, CR6_EQ, 8 */
		/* 822230F0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x822230F8;  }
		/* 822230F0h case   18:*/		return 0x822230F4;
	}
	return 0x822230F4;
} // Block from 822230A8h-822230F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 822230F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822230F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822230F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822230F4);
		  /* 822230F4h */ case    0:  		/* mr R11, R27 */
		/* 822230F4h case    0:*/		regs.R11 = regs.R27;
		/* 822230F4h case    0:*/		return 0x822230F8;
	}
	return 0x822230F8;
} // Block from 822230F4h-822230F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822230F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822230F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822230F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822230F8);
		  /* 822230F8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822230F8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822230F8h case    0:*/		return 0x822230FC;
		  /* 822230FCh */ case    1:  		/* bc 12, CR0_EQ, 68 */
		/* 822230FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82223140;  }
		/* 822230FCh case    1:*/		return 0x82223100;
		  /* 82223100h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 82223100h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82223100h case    2:*/		return 0x82223104;
		  /* 82223104h */ case    3:  		/* mr R3, R28 */
		/* 82223104h case    3:*/		regs.R3 = regs.R28;
		/* 82223104h case    3:*/		return 0x82223108;
		  /* 82223108h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82223108h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82223108h case    4:*/		return 0x8222310C;
		  /* 8222310Ch */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8222310Ch case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8222310Ch case    5:*/		return 0x82223110;
		  /* 82223110h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82223110h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82223110h case    6:*/		return 0x82223114;
		  /* 82223114h */ case    7:  		/* bl -781540 */
		/* 82223114h case    7:*/		regs.LR = 0x82223118; return 0x82164430;
		/* 82223114h case    7:*/		return 0x82223118;
		  /* 82223118h */ case    8:  		/* addi R11, R30, -24 */
		/* 82223118h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFE8);
		/* 82223118h case    8:*/		return 0x8222311C;
		  /* 8222311Ch */ case    9:  		/* add R8, R3, R11 */
		/* 8222311Ch case    9:*/		cpu::op::add<0>(regs,&regs.R8,regs.R3,regs.R11);
		/* 8222311Ch case    9:*/		return 0x82223120;
		  /* 82223120h */ case   10:  		/* lwz R11, <#[R8]> */
		/* 82223120h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82223120h case   10:*/		return 0x82223124;
		  /* 82223124h */ case   11:  		/* stw R11, <#[R31]> */
		/* 82223124h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223124h case   11:*/		return 0x82223128;
		  /* 82223128h */ case   12:  		/* lwz R11, <#[R8 + 4]> */
		/* 82223128h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82223128h case   12:*/		return 0x8222312C;
		  /* 8222312Ch */ case   13:  		/* stw R11, <#[R31 + 4]> */
		/* 8222312Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222312Ch case   13:*/		return 0x82223130;
		  /* 82223130h */ case   14:  		/* lwz R11, <#[R8 + 8]> */
		/* 82223130h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 82223130h case   14:*/		return 0x82223134;
		  /* 82223134h */ case   15:  		/* stw R11, <#[R31 + 8]> */
		/* 82223134h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82223134h case   15:*/		return 0x82223138;
		  /* 82223138h */ case   16:  		/* lbz R9, <#[R8 + 14]> */
		/* 82223138h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000E) );
		/* 82223138h case   16:*/		return 0x8222313C;
		  /* 8222313Ch */ case   17:  		/* b 120 */
		/* 8222313Ch case   17:*/		return 0x822231B4;
		/* 8222313Ch case   17:*/		return 0x82223140;
	}
	return 0x82223140;
} // Block from 822230F8h-82223140h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82223140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223140);
		  /* 82223140h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 82223140h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223140h case    0:*/		return 0x82223144;
		  /* 82223144h */ case    1:  		/* lwz R11, <#[R31]> */
		/* 82223144h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223144h case    1:*/		return 0x82223148;
		  /* 82223148h */ case    2:  		/* oris R10, R10, 3871 */
		/* 82223148h case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xF1F);
		/* 82223148h case    2:*/		return 0x8222314C;
		  /* 8222314Ch */ case    3:  		/* oris R11, R11, 8 */
		/* 8222314Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8222314Ch case    3:*/		return 0x82223150;
		  /* 82223150h */ case    4:  		/* ori R10, R10, 61440 */
		/* 82223150h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xF000);
		/* 82223150h case    4:*/		return 0x82223154;
		  /* 82223154h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82223154h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223154h case    5:*/		return 0x82223158;
		  /* 82223158h */ case    6:  		/* stw R10, <#[R31 + 4]> */
		/* 82223158h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223158h case    6:*/		return 0x8222315C;
		  /* 8222315Ch */ case    7:  		/* lwz R10, <#[R30 + 8]> */
		/* 8222315Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8222315Ch case    7:*/		return 0x82223160;
		  /* 82223160h */ case    8:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82223160h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82223160h case    8:*/		return 0x82223164;
		  /* 82223164h */ case    9:  		/* cmplwi CR6, R10, 98 */
		/* 82223164h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000062);
		/* 82223164h case    9:*/		return 0x82223168;
		  /* 82223168h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 82223168h case   10:*/		if ( regs.CR[6].eq ) { return 0x822231A8;  }
		/* 82223168h case   10:*/		return 0x8222316C;
		  /* 8222316Ch */ case   11:  		/* cmplwi CR6, R10, 101 */
		/* 8222316Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000065);
		/* 8222316Ch case   11:*/		return 0x82223170;
		  /* 82223170h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 82223170h case   12:*/		if ( regs.CR[6].eq ) { return 0x8222319C;  }
		/* 82223170h case   12:*/		return 0x82223174;
		  /* 82223174h */ case   13:  		/* cmplwi CR6, R10, 102 */
		/* 82223174h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 82223174h case   13:*/		return 0x82223178;
		  /* 82223178h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 82223178h case   14:*/		if ( regs.CR[6].eq ) { return 0x82223190;  }
		/* 82223178h case   14:*/		return 0x8222317C;
		  /* 8222317Ch */ case   15:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 8222317Ch case   15:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 8222317Ch case   15:*/		return 0x82223180;
		  /* 82223180h */ case   16:  		/* li R4, 4800 */
		/* 82223180h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82223180h case   16:*/		return 0x82223184;
		  /* 82223184h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 82223184h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82223184h case   17:*/		return 0x82223188;
		  /* 82223188h */ case   18:  		/* lwz R3, <#[R11 + 148]> */
		/* 82223188h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82223188h case   18:*/		return 0x8222318C;
		  /* 8222318Ch */ case   19:  		/* bl -856868 */
		/* 8222318Ch case   19:*/		regs.LR = 0x82223190; return 0x82151E68;
		/* 8222318Ch case   19:*/		return 0x82223190;
	}
	return 0x82223190;
} // Block from 82223140h-82223190h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82223190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223190);
		  /* 82223190h */ case    0:  		/* li R10, 13 */
		/* 82223190h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xD);
		/* 82223190h case    0:*/		return 0x82223194;
		  /* 82223194h */ case    1:  		/* rlwimi R11, R10, 1, 27, 31 */
		/* 82223194h case    1:*/		cpu::op::rlwimi<0,1,27,31>(regs,&regs.R11,regs.R10);
		/* 82223194h case    1:*/		return 0x82223198;
		  /* 82223198h */ case    2:  		/* b 24 */
		/* 82223198h case    2:*/		return 0x822231B0;
		/* 82223198h case    2:*/		return 0x8222319C;
	}
	return 0x8222319C;
} // Block from 82223190h-8222319Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222319Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222319C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222319C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222319C);
		  /* 8222319Ch */ case    0:  		/* li R10, 25 */
		/* 8222319Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x19);
		/* 8222319Ch case    0:*/		return 0x822231A0;
		  /* 822231A0h */ case    1:  		/* rlwimi R11, R10, 0, 27, 31 */
		/* 822231A0h case    1:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R11,regs.R10);
		/* 822231A0h case    1:*/		return 0x822231A4;
		  /* 822231A4h */ case    2:  		/* b 12 */
		/* 822231A4h case    2:*/		return 0x822231B0;
		/* 822231A4h case    2:*/		return 0x822231A8;
	}
	return 0x822231A8;
} // Block from 8222319Ch-822231A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822231A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822231A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822231A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822231A8);
		  /* 822231A8h */ case    0:  		/* li R10, 3 */
		/* 822231A8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 822231A8h case    0:*/		return 0x822231AC;
		  /* 822231ACh */ case    1:  		/* rlwimi R11, R10, 3, 27, 31 */
		/* 822231ACh case    1:*/		cpu::op::rlwimi<0,3,27,31>(regs,&regs.R11,regs.R10);
		/* 822231ACh case    1:*/		return 0x822231B0;
	}
	return 0x822231B0;
} // Block from 822231A8h-822231B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822231B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822231B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822231B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822231B0);
		  /* 822231B0h */ case    0:  		/* stw R11, <#[R31]> */
		/* 822231B0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822231B0h case    0:*/		return 0x822231B4;
	}
	return 0x822231B4;
} // Block from 822231B0h-822231B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822231B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822231B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822231B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822231B4);
		  /* 822231B4h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 822231B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822231B4h case    0:*/		return 0x822231B8;
		  /* 822231B8h */ case    1:  		/* lis R10, 8 */
		/* 822231B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 822231B8h case    1:*/		return 0x822231BC;
		  /* 822231BCh */ case    2:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 822231BCh case    2:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 822231BCh case    2:*/		return 0x822231C0;
		  /* 822231C0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 822231C0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822231C0h case    3:*/		return 0x822231C4;
		  /* 822231C4h */ case    4:  		/* bc 4, CR6_GT, 16 */
		/* 822231C4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x822231D4;  }
		/* 822231C4h case    4:*/		return 0x822231C8;
		  /* 822231C8h */ case    5:  		/* lwz R29, <#[R30 + 44]> */
		/* 822231C8h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x0000002C) );
		/* 822231C8h case    5:*/		return 0x822231CC;
		  /* 822231CCh */ case    6:  		/* lwz R7, <#[R30 + 48]> */
		/* 822231CCh case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000030) );
		/* 822231CCh case    6:*/		return 0x822231D0;
		  /* 822231D0h */ case    7:  		/* b 8 */
		/* 822231D0h case    7:*/		return 0x822231D8;
		/* 822231D0h case    7:*/		return 0x822231D4;
	}
	return 0x822231D4;
} // Block from 822231B4h-822231D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822231D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822231D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822231D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822231D4);
		  /* 822231D4h */ case    0:  		/* lwz R7, <#[R30 + 44]> */
		/* 822231D4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x0000002C) );
		/* 822231D4h case    0:*/		return 0x822231D8;
	}
	return 0x822231D8;
} // Block from 822231D4h-822231D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822231D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822231D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822231D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822231D8);
		  /* 822231D8h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 822231D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 822231D8h case    0:*/		return 0x822231DC;
		  /* 822231DCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822231DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822231DCh case    1:*/		return 0x822231E0;
		  /* 822231E0h */ case    2:  		/* bc 12, CR6_EQ, 452 */
		/* 822231E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x822233A4;  }
		/* 822231E0h case    2:*/		return 0x822231E4;
		  /* 822231E4h */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 822231E4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 822231E4h case    3:*/		return 0x822231E8;
		  /* 822231E8h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 822231E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822231E8h case    4:*/		return 0x822231EC;
		  /* 822231ECh */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 822231ECh case    5:*/		if ( regs.CR[6].eq ) { return 0x822231FC;  }
		/* 822231ECh case    5:*/		return 0x822231F0;
		  /* 822231F0h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 822231F0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822231F0h case    6:*/		return 0x822231F4;
		  /* 822231F4h */ case    7:  		/* rlwinm. R6, R10, 0, 4, 6 */
		/* 822231F4h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R6,regs.R10);
		/* 822231F4h case    7:*/		return 0x822231F8;
		  /* 822231F8h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 822231F8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82223204;  }
		/* 822231F8h case    8:*/		return 0x822231FC;
	}
	return 0x822231FC;
} // Block from 822231D8h-822231FCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822231FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822231FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822231FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822231FC);
		  /* 822231FCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 822231FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822231FCh case    0:*/		return 0x82223200;
		  /* 82223200h */ case    1:  		/* b -36 */
		/* 82223200h case    1:*/		return 0x822231DC;
		/* 82223200h case    1:*/		return 0x82223204;
	}
	return 0x82223204;
} // Block from 822231FCh-82223204h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223204);
		  /* 82223204h */ case    0:  		/* lwz R6, <#[R31]> */
		/* 82223204h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82223204h case    0:*/		return 0x82223208;
		  /* 82223208h */ case    1:  		/* rlwimi R6, R10, 27, 14, 19 */
		/* 82223208h case    1:*/		cpu::op::rlwimi<0,27,14,19>(regs,&regs.R6,regs.R10);
		/* 82223208h case    1:*/		return 0x8222320C;
		  /* 8222320Ch */ case    2:  		/* stw R6, <#[R31]> */
		/* 8222320Ch case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 8222320Ch case    2:*/		return 0x82223210;
		  /* 82223210h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82223210h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82223210h case    3:*/		return 0x82223214;
		  /* 82223214h */ case    4:  		/* andi. R10, R11, 9 */
		/* 82223214h case    4:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x9);
		/* 82223214h case    4:*/		return 0x82223218;
		  /* 82223218h */ case    5:  		/* cmplwi CR0, R10, 0 */
		/* 82223218h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82223218h case    5:*/		return 0x8222321C;
		  /* 8222321Ch */ case    6:  		/* bc 12, CR0_EQ, 24 */
		/* 8222321Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82223234;  }
		/* 8222321Ch case    6:*/		return 0x82223220;
		  /* 82223220h */ case    7:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 82223220h case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 82223220h case    7:*/		return 0x82223224;
		  /* 82223224h */ case    8:  		/* li R4, 4800 */
		/* 82223224h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82223224h case    8:*/		return 0x82223228;
		  /* 82223228h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82223228h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82223228h case    9:*/		return 0x8222322C;
		  /* 8222322Ch */ case   10:  		/* lwz R3, <#[R11 + 148]> */
		/* 8222322Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 8222322Ch case   10:*/		return 0x82223230;
		  /* 82223230h */ case   11:  		/* bl -857032 */
		/* 82223230h case   11:*/		regs.LR = 0x82223234; return 0x82151E68;
		/* 82223230h case   11:*/		return 0x82223234;
	}
	return 0x82223234;
} // Block from 82223204h-82223234h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82223234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223234);
		  /* 82223234h */ case    0:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 82223234h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 82223234h case    0:*/		return 0x82223238;
		  /* 82223238h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223238h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223248;  }
		/* 82223238h case    1:*/		return 0x8222323C;
		  /* 8222323Ch */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8222323Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8222323Ch case    2:*/		return 0x82223240;
		  /* 82223240h */ case    3:  		/* oris R11, R11, 4 */
		/* 82223240h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82223240h case    3:*/		return 0x82223244;
		  /* 82223244h */ case    4:  		/* stw R11, <#[R31]> */
		/* 82223244h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223244h case    4:*/		return 0x82223248;
	}
	return 0x82223248;
} // Block from 82223234h-82223248h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223248);
		  /* 82223248h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82223248h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82223248h case    0:*/		return 0x8222324C;
		  /* 8222324Ch */ case    1:  		/* rlwinm R11, R11, 31, 28, 31 */
		/* 8222324Ch case    1:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R11);
		/* 8222324Ch case    1:*/		return 0x82223250;
		  /* 82223250h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82223250h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82223250h case    2:*/		return 0x82223254;
		  /* 82223254h */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 82223254h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223254h case    3:*/		return 0x82223258;
		  /* 82223258h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82223258h case    4:*/		if ( regs.CR[0].eq ) { return 0x8222326C;  }
		/* 82223258h case    4:*/		return 0x8222325C;
		  /* 8222325Ch */ case    5:  		/* rlwinm R6, R9, 0, 30, 31 */
		/* 8222325Ch case    5:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R9);
		/* 8222325Ch case    5:*/		return 0x82223260;
		  /* 82223260h */ case    6:  		/* rlwinm R10, R10, 0, 0, 28 */
		/* 82223260h case    6:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R10,regs.R10);
		/* 82223260h case    6:*/		return 0x82223264;
		  /* 82223264h */ case    7:  		/* or R10, R10, R6 */
		/* 82223264h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 82223264h case    7:*/		return 0x82223268;
		  /* 82223268h */ case    8:  		/* b 8 */
		/* 82223268h case    8:*/		return 0x82223270;
		/* 82223268h case    8:*/		return 0x8222326C;
	}
	return 0x8222326C;
} // Block from 82223248h-8222326Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222326Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222326C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222326C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222326C);
		  /* 8222326Ch */ case    0:  		/* ori R10, R10, 7 */
		/* 8222326Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x7);
		/* 8222326Ch case    0:*/		return 0x82223270;
	}
	return 0x82223270;
} // Block from 8222326Ch-82223270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223270);
		  /* 82223270h */ case    0:  		/* stw R10, <#[R31 + 4]> */
		/* 82223270h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223270h case    0:*/		return 0x82223274;
		  /* 82223274h */ case    1:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 82223274h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 82223274h case    1:*/		return 0x82223278;
		  /* 82223278h */ case    2:  		/* lwz R10, <#[R31 + 4]> */
		/* 82223278h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223278h case    2:*/		return 0x8222327C;
		  /* 8222327Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8222327Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8222328C;  }
		/* 8222327Ch case    3:*/		return 0x82223280;
		  /* 82223280h */ case    4:  		/* rlwimi R10, R9, 1, 27, 28 */
		/* 82223280h case    4:*/		cpu::op::rlwimi<0,1,27,28>(regs,&regs.R10,regs.R9);
		/* 82223280h case    4:*/		return 0x82223284;
		  /* 82223284h */ case    5:  		/* rlwinm R10, R10, 0, 27, 25 */
		/* 82223284h case    5:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R10,regs.R10);
		/* 82223284h case    5:*/		return 0x82223288;
		  /* 82223288h */ case    6:  		/* b 8 */
		/* 82223288h case    6:*/		return 0x82223290;
		/* 82223288h case    6:*/		return 0x8222328C;
	}
	return 0x8222328C;
} // Block from 82223270h-8222328Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222328Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222328C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222328C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222328C);
		  /* 8222328Ch */ case    0:  		/* ori R10, R10, 56 */
		/* 8222328Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x38);
		/* 8222328Ch case    0:*/		return 0x82223290;
	}
	return 0x82223290;
} // Block from 8222328Ch-82223290h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223290);
		  /* 82223290h */ case    0:  		/* stw R10, <#[R31 + 4]> */
		/* 82223290h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223290h case    0:*/		return 0x82223294;
		  /* 82223294h */ case    1:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 82223294h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82223294h case    1:*/		return 0x82223298;
		  /* 82223298h */ case    2:  		/* lwz R10, <#[R31 + 4]> */
		/* 82223298h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82223298h case    2:*/		return 0x8222329C;
		  /* 8222329Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8222329Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x822232AC;  }
		/* 8222329Ch case    3:*/		return 0x822232A0;
		  /* 822232A0h */ case    4:  		/* rlwimi R10, R9, 2, 24, 25 */
		/* 822232A0h case    4:*/		cpu::op::rlwimi<0,2,24,25>(regs,&regs.R10,regs.R9);
		/* 822232A0h case    4:*/		return 0x822232A4;
		  /* 822232A4h */ case    5:  		/* rlwinm R10, R10, 0, 24, 22 */
		/* 822232A4h case    5:*/		cpu::op::rlwinm<0,0,24,22>(regs,&regs.R10,regs.R10);
		/* 822232A4h case    5:*/		return 0x822232A8;
		  /* 822232A8h */ case    6:  		/* b 8 */
		/* 822232A8h case    6:*/		return 0x822232B0;
		/* 822232A8h case    6:*/		return 0x822232AC;
	}
	return 0x822232AC;
} // Block from 82223290h-822232ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822232ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822232AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822232AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822232AC);
		  /* 822232ACh */ case    0:  		/* ori R10, R10, 448 */
		/* 822232ACh case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1C0);
		/* 822232ACh case    0:*/		return 0x822232B0;
	}
	return 0x822232B0;
} // Block from 822232ACh-822232B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822232B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822232B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822232B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822232B0);
		  /* 822232B0h */ case    0:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 822232B0h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 822232B0h case    0:*/		return 0x822232B4;
		  /* 822232B4h */ case    1:  		/* stw R10, <#[R31 + 4]> */
		/* 822232B4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822232B4h case    1:*/		return 0x822232B8;
		  /* 822232B8h */ case    2:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 822232B8h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 822232B8h case    2:*/		return 0x822232BC;
		  /* 822232BCh */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 822232BCh case    3:*/		if ( regs.CR[0].eq ) { return 0x822232CC;  }
		/* 822232BCh case    3:*/		return 0x822232C0;
		  /* 822232C0h */ case    4:  		/* rlwimi R11, R9, 3, 21, 22 */
		/* 822232C0h case    4:*/		cpu::op::rlwimi<0,3,21,22>(regs,&regs.R11,regs.R9);
		/* 822232C0h case    4:*/		return 0x822232C4;
		  /* 822232C4h */ case    5:  		/* rlwinm R11, R11, 0, 21, 19 */
		/* 822232C4h case    5:*/		cpu::op::rlwinm<0,0,21,19>(regs,&regs.R11,regs.R11);
		/* 822232C4h case    5:*/		return 0x822232C8;
		  /* 822232C8h */ case    6:  		/* b 8 */
		/* 822232C8h case    6:*/		return 0x822232D0;
		/* 822232C8h case    6:*/		return 0x822232CC;
	}
	return 0x822232CC;
} // Block from 822232B0h-822232CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822232CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822232CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822232CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822232CC);
		  /* 822232CCh */ case    0:  		/* ori R11, R11, 3584 */
		/* 822232CCh case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE00);
		/* 822232CCh case    0:*/		return 0x822232D0;
	}
	return 0x822232D0;
} // Block from 822232CCh-822232D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822232D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822232D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822232D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822232D0);
		  /* 822232D0h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 822232D0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822232D0h case    0:*/		return 0x822232D4;
		  /* 822232D4h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 822232D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 822232D4h case    1:*/		return 0x822232D8;
		  /* 822232D8h */ case    2:  		/* bc 12, CR6_EQ, 216 */
		/* 822232D8h case    2:*/		if ( regs.CR[6].eq ) { return 0x822233B0;  }
		/* 822232D8h case    2:*/		return 0x822232DC;
		  /* 822232DCh */ case    3:  		/* lwz R11, <#[R8 + 12]> */
		/* 822232DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 822232DCh case    3:*/		return 0x822232E0;
		  /* 822232E0h */ case    4:  		/* rlwinm. R11, R11, 0, 28, 31 */
		/* 822232E0h case    4:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R11);
		/* 822232E0h case    4:*/		return 0x822232E4;
		  /* 822232E4h */ case    5:  		/* bc 12, CR0_EQ, 84 */
		/* 822232E4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82223338;  }
		/* 822232E4h case    5:*/		return 0x822232E8;
		  /* 822232E8h */ case    6:  		/* cntlzw R11, R11 */
		/* 822232E8h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 822232E8h case    6:*/		return 0x822232EC;
		  /* 822232ECh */ case    7:  		/* subfic R11, R11, 31 */
		/* 822232ECh case    7:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 822232ECh case    7:*/		return 0x822232F0;
		  /* 822232F0h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 822232F0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822232F0h case    8:*/		return 0x822232F4;
		  /* 822232F4h */ case    9:  		/* bc 12, CR6_LT, 56 */
		/* 822232F4h case    9:*/		if ( regs.CR[6].lt ) { return 0x8222332C;  }
		/* 822232F4h case    9:*/		return 0x822232F8;
		  /* 822232F8h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 822232F8h case   10:*/		if ( regs.CR[6].eq ) { return 0x82223320;  }
		/* 822232F8h case   10:*/		return 0x822232FC;
		  /* 822232FCh */ case   11:  		/* cmplwi CR6, R11, 3 */
		/* 822232FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 822232FCh case   11:*/		return 0x82223300;
		  /* 82223300h */ case   12:  		/* bc 12, CR6_LT, 20 */
		/* 82223300h case   12:*/		if ( regs.CR[6].lt ) { return 0x82223314;  }
		/* 82223300h case   12:*/		return 0x82223304;
		  /* 82223304h */ case   13:  		/* bc 4, CR6_EQ, 52 */
		/* 82223304h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82223338;  }
		/* 82223304h case   13:*/		return 0x82223308;
		  /* 82223308h */ case   14:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223308h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223308h case   14:*/		return 0x8222330C;
		  /* 8222330Ch */ case   15:  		/* rlwimi R11, R27, 11, 20, 22 */
		/* 8222330Ch case   15:*/		cpu::op::rlwimi<0,11,20,22>(regs,&regs.R11,regs.R27);
		/* 8222330Ch case   15:*/		return 0x82223310;
		  /* 82223310h */ case   16:  		/* b 36 */
		/* 82223310h case   16:*/		return 0x82223334;
		/* 82223310h case   16:*/		return 0x82223314;
	}
	return 0x82223314;
} // Block from 822232D0h-82223314h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82223314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223314);
		  /* 82223314h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223314h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223314h case    0:*/		return 0x82223318;
		  /* 82223318h */ case    1:  		/* rlwimi R11, R27, 8, 23, 25 */
		/* 82223318h case    1:*/		cpu::op::rlwimi<0,8,23,25>(regs,&regs.R11,regs.R27);
		/* 82223318h case    1:*/		return 0x8222331C;
		  /* 8222331Ch */ case    2:  		/* b 24 */
		/* 8222331Ch case    2:*/		return 0x82223334;
		/* 8222331Ch case    2:*/		return 0x82223320;
	}
	return 0x82223320;
} // Block from 82223314h-82223320h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223320);
		  /* 82223320h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223320h case    0:*/		return 0x82223324;
		  /* 82223324h */ case    1:  		/* rlwimi R11, R27, 5, 26, 28 */
		/* 82223324h case    1:*/		cpu::op::rlwimi<0,5,26,28>(regs,&regs.R11,regs.R27);
		/* 82223324h case    1:*/		return 0x82223328;
		  /* 82223328h */ case    2:  		/* b 12 */
		/* 82223328h case    2:*/		return 0x82223334;
		/* 82223328h case    2:*/		return 0x8222332C;
	}
	return 0x8222332C;
} // Block from 82223320h-8222332Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222332Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222332C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222332C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222332C);
		  /* 8222332Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222332Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222332Ch case    0:*/		return 0x82223330;
		  /* 82223330h */ case    1:  		/* rlwimi R11, R27, 2, 29, 31 */
		/* 82223330h case    1:*/		cpu::op::rlwimi<0,2,29,31>(regs,&regs.R11,regs.R27);
		/* 82223330h case    1:*/		return 0x82223334;
	}
	return 0x82223334;
} // Block from 8222332Ch-82223334h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223334);
		  /* 82223334h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82223334h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223334h case    0:*/		return 0x82223338;
	}
	return 0x82223338;
} // Block from 82223334h-82223338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223338);
		  /* 82223338h */ case    0:  		/* lwz R11, <#[R8 + 12]> */
		/* 82223338h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 82223338h case    0:*/		return 0x8222333C;
		  /* 8222333Ch */ case    1:  		/* rlwinm. R11, R11, 28, 28, 31 */
		/* 8222333Ch case    1:*/		cpu::op::rlwinm<1,28,28,31>(regs,&regs.R11,regs.R11);
		/* 8222333Ch case    1:*/		return 0x82223340;
		  /* 82223340h */ case    2:  		/* bc 12, CR0_EQ, 112 */
		/* 82223340h case    2:*/		if ( regs.CR[0].eq ) { return 0x822233B0;  }
		/* 82223340h case    2:*/		return 0x82223344;
		  /* 82223344h */ case    3:  		/* cntlzw R11, R11 */
		/* 82223344h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82223344h case    3:*/		return 0x82223348;
		  /* 82223348h */ case    4:  		/* subfic R11, R11, 31 */
		/* 82223348h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82223348h case    4:*/		return 0x8222334C;
		  /* 8222334Ch */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 8222334Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8222334Ch case    5:*/		return 0x82223350;
		  /* 82223350h */ case    6:  		/* bc 12, CR6_LT, 68 */
		/* 82223350h case    6:*/		if ( regs.CR[6].lt ) { return 0x82223394;  }
		/* 82223350h case    6:*/		return 0x82223354;
		  /* 82223354h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 82223354h case    7:*/		if ( regs.CR[6].eq ) { return 0x82223384;  }
		/* 82223354h case    7:*/		return 0x82223358;
		  /* 82223358h */ case    8:  		/* cmplwi CR6, R11, 3 */
		/* 82223358h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82223358h case    8:*/		return 0x8222335C;
		  /* 8222335Ch */ case    9:  		/* bc 12, CR6_LT, 24 */
		/* 8222335Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x82223374;  }
		/* 8222335Ch case    9:*/		return 0x82223360;
		  /* 82223360h */ case   10:  		/* bc 4, CR6_EQ, 80 */
		/* 82223360h case   10:*/		if ( !regs.CR[6].eq ) { return 0x822233B0;  }
		/* 82223360h case   10:*/		return 0x82223364;
		  /* 82223364h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223364h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223364h case   11:*/		return 0x82223368;
		  /* 82223368h */ case   12:  		/* li R10, 5 */
		/* 82223368h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82223368h case   12:*/		return 0x8222336C;
		  /* 8222336Ch */ case   13:  		/* rlwimi R11, R10, 9, 20, 22 */
		/* 8222336Ch case   13:*/		cpu::op::rlwimi<0,9,20,22>(regs,&regs.R11,regs.R10);
		/* 8222336Ch case   13:*/		return 0x82223370;
		  /* 82223370h */ case   14:  		/* b 60 */
		/* 82223370h case   14:*/		return 0x822233AC;
		/* 82223370h case   14:*/		return 0x82223374;
	}
	return 0x82223374;
} // Block from 82223338h-82223374h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82223374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223374);
		  /* 82223374h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223374h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223374h case    0:*/		return 0x82223378;
		  /* 82223378h */ case    1:  		/* li R10, 5 */
		/* 82223378h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82223378h case    1:*/		return 0x8222337C;
		  /* 8222337Ch */ case    2:  		/* rlwimi R11, R10, 6, 23, 25 */
		/* 8222337Ch case    2:*/		cpu::op::rlwimi<0,6,23,25>(regs,&regs.R11,regs.R10);
		/* 8222337Ch case    2:*/		return 0x82223380;
		  /* 82223380h */ case    3:  		/* b 44 */
		/* 82223380h case    3:*/		return 0x822233AC;
		/* 82223380h case    3:*/		return 0x82223384;
	}
	return 0x82223384;
} // Block from 82223374h-82223384h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82223384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223384);
		  /* 82223384h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223384h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223384h case    0:*/		return 0x82223388;
		  /* 82223388h */ case    1:  		/* li R10, 5 */
		/* 82223388h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82223388h case    1:*/		return 0x8222338C;
		  /* 8222338Ch */ case    2:  		/* rlwimi R11, R10, 3, 26, 28 */
		/* 8222338Ch case    2:*/		cpu::op::rlwimi<0,3,26,28>(regs,&regs.R11,regs.R10);
		/* 8222338Ch case    2:*/		return 0x82223390;
		  /* 82223390h */ case    3:  		/* b 28 */
		/* 82223390h case    3:*/		return 0x822233AC;
		/* 82223390h case    3:*/		return 0x82223394;
	}
	return 0x82223394;
} // Block from 82223384h-82223394h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82223394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223394);
		  /* 82223394h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223394h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223394h case    0:*/		return 0x82223398;
		  /* 82223398h */ case    1:  		/* li R10, 5 */
		/* 82223398h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82223398h case    1:*/		return 0x8222339C;
		  /* 8222339Ch */ case    2:  		/* rlwimi R11, R10, 0, 29, 31 */
		/* 8222339Ch case    2:*/		cpu::op::rlwimi<0,0,29,31>(regs,&regs.R11,regs.R10);
		/* 8222339Ch case    2:*/		return 0x822233A0;
		  /* 822233A0h */ case    3:  		/* b 12 */
		/* 822233A0h case    3:*/		return 0x822233AC;
		/* 822233A0h case    3:*/		return 0x822233A4;
	}
	return 0x822233A4;
} // Block from 82223394h-822233A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822233A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822233A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822233A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822233A4);
		  /* 822233A4h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 822233A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822233A4h case    0:*/		return 0x822233A8;
		  /* 822233A8h */ case    1:  		/* ori R11, R11, 4095 */
		/* 822233A8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 822233A8h case    1:*/		return 0x822233AC;
	}
	return 0x822233AC;
} // Block from 822233A4h-822233ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822233ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822233AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822233AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822233AC);
		  /* 822233ACh */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 822233ACh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822233ACh case    0:*/		return 0x822233B0;
	}
	return 0x822233B0;
} // Block from 822233ACh-822233B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822233B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822233B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822233B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822233B0);
		  /* 822233B0h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 822233B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 822233B0h case    0:*/		return 0x822233B4;
		  /* 822233B4h */ case    1:  		/* bc 12, CR6_EQ, 92 */
		/* 822233B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82223410;  }
		/* 822233B4h case    1:*/		return 0x822233B8;
		  /* 822233B8h */ case    2:  		/* lwz R11, <#[R7]> */
		/* 822233B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 822233B8h case    2:*/		return 0x822233BC;
		  /* 822233BCh */ case    3:  		/* lwz R10, <#[R31]> */
		/* 822233BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822233BCh case    3:*/		return 0x822233C0;
		  /* 822233C0h */ case    4:  		/* rlwimi R10, R11, 20, 21, 26 */
		/* 822233C0h case    4:*/		cpu::op::rlwimi<0,20,21,26>(regs,&regs.R10,regs.R11);
		/* 822233C0h case    4:*/		return 0x822233C4;
		  /* 822233C4h */ case    5:  		/* stw R10, <#[R31]> */
		/* 822233C4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822233C4h case    5:*/		return 0x822233C8;
	}
	return 0x822233C8;
} // Block from 822233B0h-822233C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822233C8h
// Function '?GetResultBounds@Instruction@D3DXShader@@QAAXIPAN0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822233C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822233C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822233C8);
		  /* 822233C8h */ case    0:  		/* lwz R11, <#[R7]> */
		/* 822233C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 822233C8h case    0:*/		return 0x822233CC;
		  /* 822233CCh */ case    1:  		/* rlwinm. R10, R11, 0, 28, 30 */
		/* 822233CCh case    1:*/		cpu::op::rlwinm<1,0,28,30>(regs,&regs.R10,regs.R11);
		/* 822233CCh case    1:*/		return 0x822233D0;
		  /* 822233D0h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 822233D0h case    2:*/		if ( regs.CR[0].eq ) { return 0x822233E8;  }
		/* 822233D0h case    2:*/		return 0x822233D4;
		  /* 822233D4h */ case    3:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 822233D4h case    3:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 822233D4h case    3:*/		return 0x822233D8;
		  /* 822233D8h */ case    4:  		/* li R4, 4800 */
		/* 822233D8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822233D8h case    4:*/		return 0x822233DC;
		  /* 822233DCh */ case    5:  		/* lwz R11, <#[R11]> */
		/* 822233DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822233DCh case    5:*/		return 0x822233E0;
		  /* 822233E0h */ case    6:  		/* lwz R3, <#[R11 + 148]> */
		/* 822233E0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 822233E0h case    6:*/		return 0x822233E4;
		  /* 822233E4h */ case    7:  		/* bl -857468 */
		/* 822233E4h case    7:*/		regs.LR = 0x822233E8; return 0x82151E68;
		/* 822233E4h case    7:*/		return 0x822233E8;
	}
	return 0x822233E8;
} // Block from 822233C8h-822233E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822233E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822233E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822233E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822233E8);
		  /* 822233E8h */ case    0:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 822233E8h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 822233E8h case    0:*/		return 0x822233EC;
		  /* 822233ECh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822233ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x822233FC;  }
		/* 822233ECh case    1:*/		return 0x822233F0;
		  /* 822233F0h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 822233F0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822233F0h case    2:*/		return 0x822233F4;
		  /* 822233F4h */ case    3:  		/* ori R11, R11, 2048 */
		/* 822233F4h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 822233F4h case    3:*/		return 0x822233F8;
		  /* 822233F8h */ case    4:  		/* stw R11, <#[R31]> */
		/* 822233F8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822233F8h case    4:*/		return 0x822233FC;
	}
	return 0x822233FC;
} // Block from 822233E8h-822233FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822233FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822233FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822233FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822233FC);
		  /* 822233FCh */ case    0:  		/* lwz R11, <#[R7]> */
		/* 822233FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 822233FCh case    0:*/		return 0x82223400;
		  /* 82223400h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 82223400h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82223400h case    1:*/		return 0x82223404;
		  /* 82223404h */ case    2:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 82223404h case    2:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 82223404h case    2:*/		return 0x82223408;
		  /* 82223408h */ case    3:  		/* rlwimi R10, R11, 26, 0, 5 */
		/* 82223408h case    3:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R10,regs.R11);
		/* 82223408h case    3:*/		return 0x8222340C;
		  /* 8222340Ch */ case    4:  		/* stw R10, <#[R31]> */
		/* 8222340Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222340Ch case    4:*/		return 0x82223410;
	}
	return 0x82223410;
} // Block from 822233FCh-82223410h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223410);
		  /* 82223410h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82223410h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82223410h case    0:*/		return 0x82223414;
		  /* 82223414h */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 82223414h case    1:*/		if ( regs.CR[6].eq ) { return 0x8222345C;  }
		/* 82223414h case    1:*/		return 0x82223418;
		  /* 82223418h */ case    2:  		/* lwz R10, <#[R29]> */
		/* 82223418h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82223418h case    2:*/		return 0x8222341C;
		  /* 8222341Ch */ case    3:  		/* lis R9, -1 */
		/* 8222341Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8222341Ch case    3:*/		return 0x82223420;
		  /* 82223420h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 82223420h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223420h case    4:*/		return 0x82223424;
		  /* 82223424h */ case    5:  		/* rlwimi R11, R10, 3, 7, 11 */
		/* 82223424h case    5:*/		cpu::op::rlwimi<0,3,7,11>(regs,&regs.R11,regs.R10);
		/* 82223424h case    5:*/		return 0x82223428;
		  /* 82223428h */ case    6:  		/* stw R11, <#[R31]> */
		/* 82223428h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223428h case    6:*/		return 0x8222342C;
		  /* 8222342Ch */ case    7:  		/* lwz R10, <#[R28 + 48]> */
		/* 8222342Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000030) );
		/* 8222342Ch case    7:*/		return 0x82223430;
		  /* 82223430h */ case    8:  		/* rlwinm R10, R10, 0, 0, 15 */
		/* 82223430h case    8:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R10,regs.R10);
		/* 82223430h case    8:*/		return 0x82223434;
		  /* 82223434h */ case    9:  		/* cmplw CR6, R10, R9 */
		/* 82223434h case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82223434h case    9:*/		return 0x82223438;
		  /* 82223438h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 82223438h case   10:*/		if ( regs.CR[6].eq ) { return 0x8222345C;  }
		/* 82223438h case   10:*/		return 0x8222343C;
		  /* 8222343Ch */ case   11:  		/* rlwinm R11, R11, 0, 7, 11 */
		/* 8222343Ch case   11:*/		cpu::op::rlwinm<0,0,7,11>(regs,&regs.R11,regs.R11);
		/* 8222343Ch case   11:*/		return 0x82223440;
		  /* 82223440h */ case   12:  		/* lis R10, 320 */
		/* 82223440h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x140);
		/* 82223440h case   12:*/		return 0x82223444;
		  /* 82223444h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 82223444h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82223444h case   13:*/		return 0x82223448;
		  /* 82223448h */ case   14:  		/* bc 12, CR6_LT, 20 */
		/* 82223448h case   14:*/		if ( regs.CR[6].lt ) { return 0x8222345C;  }
		/* 82223448h case   14:*/		return 0x8222344C;
		  /* 8222344Ch */ case   15:  		/* lwz R11, <#[R28 + 56]> */
		/* 8222344Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000038) );
		/* 8222344Ch case   15:*/		return 0x82223450;
		  /* 82223450h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82223450h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82223450h case   16:*/		return 0x82223454;
		  /* 82223454h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 82223454h case   17:*/		if ( regs.CR[6].eq ) { return 0x8222345C;  }
		/* 82223454h case   17:*/		return 0x82223458;
		  /* 82223458h */ case   18:  		/* stw R27, <#[R11 + 28]> */
		/* 82223458h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000001C) );
		/* 82223458h case   18:*/		return 0x8222345C;
	}
	return 0x8222345C;
} // Block from 82223410h-8222345Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8222345Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222345C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222345C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222345C);
		  /* 8222345Ch */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222345Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222345Ch case    0:*/		return 0x82223460;
		  /* 82223460h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 82223460h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82223460h case    1:*/		return 0x82223464;
		  /* 82223464h */ case    2:  		/* lwz R11, <#[R11 + 76]> */
		/* 82223464h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82223464h case    2:*/		return 0x82223468;
		  /* 82223468h */ case    3:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82223468h case    3:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82223468h case    3:*/		return 0x8222346C;
		  /* 8222346Ch */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 8222346Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82223494;  }
		/* 8222346Ch case    4:*/		return 0x82223470;
		  /* 82223470h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223470h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223470h case    5:*/		return 0x82223474;
		  /* 82223474h */ case    6:  		/* oris R11, R11, 32768 */
		/* 82223474h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82223474h case    6:*/		return 0x82223478;
		  /* 82223478h */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 82223478h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223478h case    7:*/		return 0x8222347C;
		  /* 8222347Ch */ case    8:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222347Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222347Ch case    8:*/		return 0x82223480;
		  /* 82223480h */ case    9:  		/* lwz R11, <#[R11 + 76]> */
		/* 82223480h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82223480h case    9:*/		return 0x82223484;
		  /* 82223484h */ case   10:  		/* rlwinm R11, R11, 9, 24, 31 */
		/* 82223484h case   10:*/		cpu::op::rlwinm<0,9,24,31>(regs,&regs.R11,regs.R11);
		/* 82223484h case   10:*/		return 0x82223488;
		  /* 82223488h */ case   11:  		/* rlwimi R10, R11, 31, 0, 0 */
		/* 82223488h case   11:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R10,regs.R11);
		/* 82223488h case   11:*/		return 0x8222348C;
		  /* 8222348Ch */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8222348Ch case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8222348Ch case   12:*/		return 0x82223490;
		  /* 82223490h */ case   13:  		/* b 32 */
		/* 82223490h case   13:*/		return 0x822234B0;
		/* 82223490h case   13:*/		return 0x82223494;
	}
	return 0x82223494;
} // Block from 8222345Ch-82223494h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82223494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223494);
		  /* 82223494h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82223494h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82223494h case    0:*/		return 0x82223498;
		  /* 82223498h */ case    1:  		/* lwz R9, <#[R31 + 4]> */
		/* 82223498h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82223498h case    1:*/		return 0x8222349C;
		  /* 8222349Ch */ case    2:  		/* rlwimi R10, R11, 13, 0, 0 */
		/* 8222349Ch case    2:*/		cpu::op::rlwimi<0,13,0,0>(regs,&regs.R10,regs.R11);
		/* 8222349Ch case    2:*/		return 0x822234A0;
		  /* 822234A0h */ case    3:  		/* stw R10, <#[R31 + 8]> */
		/* 822234A0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822234A0h case    3:*/		return 0x822234A4;
		  /* 822234A4h */ case    4:  		/* lwz R11, <#[R30 + 8]> */
		/* 822234A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822234A4h case    4:*/		return 0x822234A8;
		  /* 822234A8h */ case    5:  		/* rlwimi R9, R11, 14, 0, 0 */
		/* 822234A8h case    5:*/		cpu::op::rlwimi<0,14,0,0>(regs,&regs.R9,regs.R11);
		/* 822234A8h case    5:*/		return 0x822234AC;
		  /* 822234ACh */ case    6:  		/* stw R9, <#[R31 + 4]> */
		/* 822234ACh case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 822234ACh case    6:*/		return 0x822234B0;
	}
	return 0x822234B0;
} // Block from 82223494h-822234B0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822234B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822234B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822234B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822234B0);
		  /* 822234B0h */ case    0:  		/* li R6, 1 */
		/* 822234B0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 822234B0h case    0:*/		return 0x822234B4;
		  /* 822234B4h */ case    1:  		/* mr R5, R31 */
		/* 822234B4h case    1:*/		regs.R5 = regs.R31;
		/* 822234B4h case    1:*/		return 0x822234B8;
		  /* 822234B8h */ case    2:  		/* mr R4, R30 */
		/* 822234B8h case    2:*/		regs.R4 = regs.R30;
		/* 822234B8h case    2:*/		return 0x822234BC;
		  /* 822234BCh */ case    3:  		/* mr R3, R28 */
		/* 822234BCh case    3:*/		regs.R3 = regs.R28;
		/* 822234BCh case    3:*/		return 0x822234C0;
		  /* 822234C0h */ case    4:  		/* bl -5304 */
		/* 822234C0h case    4:*/		regs.LR = 0x822234C4; return 0x82222008;
		/* 822234C0h case    4:*/		return 0x822234C4;
		  /* 822234C4h */ case    5:  		/* addi R1, R1, 128 */
		/* 822234C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822234C4h case    5:*/		return 0x822234C8;
		  /* 822234C8h */ case    6:  		/* b -1647140 */
		/* 822234C8h case    6:*/		return 0x820912A4;
		/* 822234C8h case    6:*/		return 0x822234CC;
		  /* 822234CCh */ case    7:  		/* nop */
		/* 822234CCh case    7:*/		cpu::op::nop();
		/* 822234CCh case    7:*/		return 0x822234D0;
	}
	return 0x822234D0;
} // Block from 822234B0h-822234D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822234D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822234D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822234D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822234D0);
		  /* 822234D0h */ case    0:  		/* mfspr R12, LR */
		/* 822234D0h case    0:*/		regs.R12 = regs.LR;
		/* 822234D0h case    0:*/		return 0x822234D4;
		  /* 822234D4h */ case    1:  		/* bl -1647260 */
		/* 822234D4h case    1:*/		regs.LR = 0x822234D8; return 0x82091238;
		/* 822234D4h case    1:*/		return 0x822234D8;
		  /* 822234D8h */ case    2:  		/* stfd FR31, <#[R1 - 112]> */
		/* 822234D8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 822234D8h case    2:*/		return 0x822234DC;
		  /* 822234DCh */ case    3:  		/* stwu R1, <#[R1 - 192]> */
		/* 822234DCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 822234DCh case    3:*/		return 0x822234E0;
		  /* 822234E0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 822234E0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822234E0h case    4:*/		return 0x822234E4;
		  /* 822234E4h */ case    5:  		/* mr R24, R10 */
		/* 822234E4h case    5:*/		regs.R24 = regs.R10;
		/* 822234E4h case    5:*/		return 0x822234E8;
		  /* 822234E8h */ case    6:  		/* mr R25, R9 */
		/* 822234E8h case    6:*/		regs.R25 = regs.R9;
		/* 822234E8h case    6:*/		return 0x822234EC;
		  /* 822234ECh */ case    7:  		/* lwz R27, <#[R3 + 12]> */
		/* 822234ECh case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x0000000C) );
		/* 822234ECh case    7:*/		return 0x822234F0;
		  /* 822234F0h */ case    8:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 822234F0h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 822234F0h case    8:*/		return 0x822234F4;
		  /* 822234F4h */ case    9:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 822234F4h case    9:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 822234F4h case    9:*/		return 0x822234F8;
		  /* 822234F8h */ case   10:  		/* rlwinm R28, R11, 0, 27, 31 */
		/* 822234F8h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R28,regs.R11);
		/* 822234F8h case   10:*/		return 0x822234FC;
		  /* 822234FCh */ case   11:  		/* srw R11, R9, R10 */
		/* 822234FCh case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 822234FCh case   11:*/		return 0x82223500;
		  /* 82223500h */ case   12:  		/* mr R23, R5 */
		/* 82223500h case   12:*/		regs.R23 = regs.R5;
		/* 82223500h case   12:*/		return 0x82223504;
		  /* 82223504h */ case   13:  		/* mr R22, R6 */
		/* 82223504h case   13:*/		regs.R22 = regs.R6;
		/* 82223504h case   13:*/		return 0x82223508;
		  /* 82223508h */ case   14:  		/* mr R21, R7 */
		/* 82223508h case   14:*/		regs.R21 = regs.R7;
		/* 82223508h case   14:*/		return 0x8222350C;
		  /* 8222350Ch */ case   15:  		/* mr R20, R8 */
		/* 8222350Ch case   15:*/		regs.R20 = regs.R8;
		/* 8222350Ch case   15:*/		return 0x82223510;
		  /* 82223510h */ case   16:  		/* and. R10, R28, R24 */
		/* 82223510h case   16:*/		cpu::op::and<1>(regs,&regs.R10,regs.R28,regs.R24);
		/* 82223510h case   16:*/		return 0x82223514;
		  /* 82223514h */ case   17:  		/* rlwinm R26, R11, 0, 30, 31 */
		/* 82223514h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R26,regs.R11);
		/* 82223514h case   17:*/		return 0x82223518;
		  /* 82223518h */ case   18:  		/* bc 4, CR0_EQ, 1020 */
		/* 82223518h case   18:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223518h case   18:*/		return 0x8222351C;
		  /* 8222351Ch */ case   19:  		/* lis R11, -32256 */
		/* 8222351Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222351Ch case   19:*/		return 0x82223520;
		  /* 82223520h */ case   20:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82223520h case   20:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82223520h case   20:*/		return 0x82223524;
		  /* 82223524h */ case   21:  		/* lwz R11, <#[R27 + 8]> */
		/* 82223524h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82223524h case   21:*/		return 0x82223528;
		  /* 82223528h */ case   22:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82223528h case   22:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82223528h case   22:*/		return 0x8222352C;
		  /* 8222352Ch */ case   23:  		/* cmpwi CR6, R11, 3 */
		/* 8222352Ch case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8222352Ch case   23:*/		return 0x82223530;
		  /* 82223530h */ case   24:  		/* bc 12, CR6_EQ, 764 */
		/* 82223530h case   24:*/		if ( regs.CR[6].eq ) { return 0x8222382C;  }
		/* 82223530h case   24:*/		return 0x82223534;
		  /* 82223534h */ case   25:  		/* cmpwi CR6, R11, 13 */
		/* 82223534h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000D);
		/* 82223534h case   25:*/		return 0x82223538;
	}
	return 0x82223538;
} // Block from 822234D0h-82223538h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82223538h
// Function '?SetResultBounds@Instruction@D3DXShader@@QAA_NINNPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223538);
		  /* 82223538h */ case    0:  		/* bc 12, CR6_EQ, 548 */
		/* 82223538h case    0:*/		if ( regs.CR[6].eq ) { return 0x8222375C;  }
		/* 82223538h case    0:*/		return 0x8222353C;
		  /* 8222353Ch */ case    1:  		/* cmpwi CR6, R11, 110 */
		/* 8222353Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 8222353Ch case    1:*/		return 0x82223540;
		  /* 82223540h */ case    2:  		/* bc 12, CR6_EQ, 340 */
		/* 82223540h case    2:*/		if ( regs.CR[6].eq ) { return 0x82223694;  }
		/* 82223540h case    2:*/		return 0x82223544;
		  /* 82223544h */ case    3:  		/* cmpwi CR6, R11, 112 */
		/* 82223544h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000070);
		/* 82223544h case    3:*/		return 0x82223548;
		  /* 82223548h */ case    4:  		/* bc 4, CR6_EQ, 972 */
		/* 82223548h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82223914;  }
		/* 82223548h case    4:*/		return 0x8222354C;
		  /* 8222354Ch */ case    5:  		/* cmplwi CR6, R20, 0 */
		/* 8222354Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8222354Ch case    5:*/		return 0x82223550;
		  /* 82223550h */ case    6:  		/* bc 4, CR6_EQ, 964 */
		/* 82223550h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82223914;  }
		/* 82223550h case    6:*/		return 0x82223554;
		  /* 82223554h */ case    7:  		/* lwz R10, <#[R27]> */
		/* 82223554h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82223554h case    7:*/		return 0x82223558;
		  /* 82223558h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82223558h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82223558h case    8:*/		return 0x8222355C;
		  /* 8222355Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 8222355Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82223570;  }
		/* 8222355Ch case    9:*/		return 0x82223560;
		  /* 82223560h */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 82223560h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82223560h case   10:*/		return 0x82223564;
		  /* 82223564h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82223564h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82223564h case   11:*/		return 0x82223568;
		  /* 82223568h */ case   12:  		/* li R11, 1 */
		/* 82223568h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223568h case   12:*/		return 0x8222356C;
		  /* 8222356Ch */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 8222356Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82223574;  }
		/* 8222356Ch case   13:*/		return 0x82223570;
	}
	return 0x82223570;
} // Block from 82223538h-82223570h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82223570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223570);
		  /* 82223570h */ case    0:  		/* li R11, 0 */
		/* 82223570h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223570h case    0:*/		return 0x82223574;
	}
	return 0x82223574;
} // Block from 82223570h-82223574h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223574);
		  /* 82223574h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223574h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223574h case    0:*/		return 0x82223578;
		  /* 82223578h */ case    1:  		/* bc 4, CR0_EQ, 924 */
		/* 82223578h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223578h case    1:*/		return 0x8222357C;
		  /* 8222357Ch */ case    2:  		/* cmplwi CR0, R10, 0 */
		/* 8222357Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8222357Ch case    2:*/		return 0x82223580;
		  /* 82223580h */ case    3:  		/* bc 12, CR0_EQ, 916 */
		/* 82223580h case    3:*/		if ( regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223580h case    3:*/		return 0x82223584;
		  /* 82223584h */ case    4:  		/* lwz R6, <#[R10 + 12]> */
		/* 82223584h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000000C) );
		/* 82223584h case    4:*/		return 0x82223588;
		  /* 82223588h */ case    5:  		/* cmplw CR6, R27, R6 */
		/* 82223588h case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R6);
		/* 82223588h case    5:*/		return 0x8222358C;
		  /* 8222358Ch */ case    6:  		/* bc 12, CR6_EQ, 904 */
		/* 8222358Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82223914;  }
		/* 8222358Ch case    6:*/		return 0x82223590;
		  /* 82223590h */ case    7:  		/* lwz R11, <#[R27 + 28]> */
		/* 82223590h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 82223590h case    7:*/		return 0x82223594;
		  /* 82223594h */ case    8:  		/* li R8, 1 */
		/* 82223594h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82223594h case    8:*/		return 0x82223598;
		  /* 82223598h */ case    9:  		/* lwz R7, <#[R6 + 28]> */
		/* 82223598h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x0000001C) );
		/* 82223598h case    9:*/		return 0x8222359C;
		  /* 8222359Ch */ case   10:  		/* lwz R9, <#[R11 + 48]> */
		/* 8222359Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 8222359Ch case   10:*/		return 0x822235A0;
		  /* 822235A0h */ case   11:  		/* lwz R5, <#[R7 + 40]> */
		/* 822235A0h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000028) );
		/* 822235A0h case   11:*/		return 0x822235A4;
		  /* 822235A4h */ case   12:  		/* rlwinm R11, R9, 27, 18, 31 */
		/* 822235A4h case   12:*/		cpu::op::rlwinm<0,27,18,31>(regs,&regs.R11,regs.R9);
		/* 822235A4h case   12:*/		return 0x822235A8;
		  /* 822235A8h */ case   13:  		/* rlwinm R4, R9, 0, 27, 31 */
		/* 822235A8h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R9);
		/* 822235A8h case   13:*/		return 0x822235AC;
		  /* 822235ACh */ case   14:  		/* addi R11, R11, 1 */
		/* 822235ACh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822235ACh case   14:*/		return 0x822235B0;
		  /* 822235B0h */ case   15:  		/* slw R8, R8, R4 */
		/* 822235B0h case   15:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R4);
		/* 822235B0h case   15:*/		return 0x822235B4;
		  /* 822235B4h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822235B4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822235B4h case   16:*/		return 0x822235B8;
		  /* 822235B8h */ case   17:  		/* lwzx R11, <#[R11 + R5]> */
		/* 822235B8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 822235B8h case   17:*/		return 0x822235BC;
		  /* 822235BCh */ case   18:  		/* and. R11, R11, R8 */
		/* 822235BCh case   18:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 822235BCh case   18:*/		return 0x822235C0;
		  /* 822235C0h */ case   19:  		/* bc 4, CR0_EQ, 852 */
		/* 822235C0h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 822235C0h case   19:*/		return 0x822235C4;
		  /* 822235C4h */ case   20:  		/* lwz R8, <#[R10]> */
		/* 822235C4h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 822235C4h case   20:*/		return 0x822235C8;
		  /* 822235C8h */ case   21:  		/* rlwinm. R10, R8, 0, 27, 28 */
		/* 822235C8h case   21:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R8);
		/* 822235C8h case   21:*/		return 0x822235CC;
		  /* 822235CCh */ case   22:  		/* rlwinm R11, R8, 0, 27, 31 */
		/* 822235CCh case   22:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R8);
		/* 822235CCh case   22:*/		return 0x822235D0;
		  /* 822235D0h */ case   23:  		/* bc 12, CR0_EQ, 20 */
		/* 822235D0h case   23:*/		if ( regs.CR[0].eq ) { return 0x822235E4;  }
		/* 822235D0h case   23:*/		return 0x822235D4;
		  /* 822235D4h */ case   24:  		/* rlwinm. R10, R28, 0, 27, 28 */
		/* 822235D4h case   24:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R28);
		/* 822235D4h case   24:*/		return 0x822235D8;
		  /* 822235D8h */ case   25:  		/* bc 12, CR0_EQ, 12 */
		/* 822235D8h case   25:*/		if ( regs.CR[0].eq ) { return 0x822235E4;  }
		/* 822235D8h case   25:*/		return 0x822235DC;
		  /* 822235DCh */ case   26:  		/* li R10, 0 */
		/* 822235DCh case   26:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822235DCh case   26:*/		return 0x822235E0;
		  /* 822235E0h */ case   27:  		/* b 44 */
		/* 822235E0h case   27:*/		return 0x8222360C;
		/* 822235E0h case   27:*/		return 0x822235E4;
	}
	return 0x822235E4;
} // Block from 82223574h-822235E4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822235E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822235E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822235E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822235E4);
		  /* 822235E4h */ case    0:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 822235E4h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 822235E4h case    0:*/		return 0x822235E8;
		  /* 822235E8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 822235E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x822235F4;  }
		/* 822235E8h case    1:*/		return 0x822235EC;
		  /* 822235ECh */ case    2:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 822235ECh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 822235ECh case    2:*/		return 0x822235F0;
		  /* 822235F0h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 822235F0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x822235DC;  }
		/* 822235F0h case    3:*/		return 0x822235F4;
	}
	return 0x822235F4;
} // Block from 822235E4h-822235F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822235F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822235F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822235F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822235F4);
		  /* 822235F4h */ case    0:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 822235F4h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 822235F4h case    0:*/		return 0x822235F8;
		  /* 822235F8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822235F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223608;  }
		/* 822235F8h case    1:*/		return 0x822235FC;
		  /* 822235FCh */ case    2:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 822235FCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 822235FCh case    2:*/		return 0x82223600;
		  /* 82223600h */ case    3:  		/* li R10, 0 */
		/* 82223600h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82223600h case    3:*/		return 0x82223604;
		  /* 82223604h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82223604h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8222360C;  }
		/* 82223604h case    4:*/		return 0x82223608;
	}
	return 0x82223608;
} // Block from 822235F4h-82223608h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223608);
		  /* 82223608h */ case    0:  		/* li R10, 1 */
		/* 82223608h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82223608h case    0:*/		return 0x8222360C;
	}
	return 0x8222360C;
} // Block from 82223608h-8222360Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222360Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222360C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222360C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222360C);
		  /* 8222360Ch */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8222360Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8222360Ch case    0:*/		return 0x82223610;
		  /* 82223610h */ case    1:  		/* bc 12, CR0_EQ, 772 */
		/* 82223610h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223610h case    1:*/		return 0x82223614;
		  /* 82223614h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 82223614h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82223614h case    2:*/		return 0x82223618;
		  /* 82223618h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82223618h case    3:*/		if ( regs.CR[6].eq ) { return 0x82223634;  }
		/* 82223618h case    3:*/		return 0x8222361C;
		  /* 8222361Ch */ case    4:  		/* lwz R10, <#[R25 + 28]> */
		/* 8222361Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000001C) );
		/* 8222361Ch case    4:*/		return 0x82223620;
		  /* 82223620h */ case    5:  		/* lwz R7, <#[R7 + 76]> */
		/* 82223620h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000004C) );
		/* 82223620h case    5:*/		return 0x82223624;
		  /* 82223624h */ case    6:  		/* lwz R10, <#[R10 + 76]> */
		/* 82223624h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 82223624h case    6:*/		return 0x82223628;
		  /* 82223628h */ case    7:  		/* xor R10, R10, R7 */
		/* 82223628h case    7:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82223628h case    7:*/		return 0x8222362C;
		  /* 8222362Ch */ case    8:  		/* rlwinm. R10, R10, 0, 13, 31 */
		/* 8222362Ch case    8:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R10,regs.R10);
		/* 8222362Ch case    8:*/		return 0x82223630;
		  /* 82223630h */ case    9:  		/* bc 4, CR0_EQ, 740 */
		/* 82223630h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223630h case    9:*/		return 0x82223634;
	}
	return 0x82223634;
} // Block from 8222360Ch-82223634h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82223634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223634);
		  /* 82223634h */ case    0:  		/* rlwinm. R10, R9, 11, 31, 31 */
		/* 82223634h case    0:*/		cpu::op::rlwinm<1,11,31,31>(regs,&regs.R10,regs.R9);
		/* 82223634h case    0:*/		return 0x82223638;
		  /* 82223638h */ case    1:  		/* bc 4, CR0_EQ, 732 */
		/* 82223638h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223638h case    1:*/		return 0x8222363C;
		  /* 8222363Ch */ case    2:  		/* rlwinm. R10, R9, 13, 31, 31 */
		/* 8222363Ch case    2:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R10,regs.R9);
		/* 8222363Ch case    2:*/		return 0x82223640;
		  /* 82223640h */ case    3:  		/* bc 4, CR0_EQ, 724 */
		/* 82223640h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223640h case    3:*/		return 0x82223644;
		  /* 82223644h */ case    4:  		/* rlwinm. R9, R11, 0, 29, 29 */
		/* 82223644h case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R11);
		/* 82223644h case    4:*/		return 0x82223648;
		  /* 82223648h */ case    5:  		/* rlwinm R26, R8, 27, 30, 31 */
		/* 82223648h case    5:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R26,regs.R8);
		/* 82223648h case    5:*/		return 0x8222364C;
		  /* 8222364Ch */ case    6:  		/* mr R10, R28 */
		/* 8222364Ch case    6:*/		regs.R10 = regs.R28;
		/* 8222364Ch case    6:*/		return 0x82223650;
		  /* 82223650h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82223650h case    7:*/		if ( regs.CR[0].eq ) { return 0x82223660;  }
		/* 82223650h case    7:*/		return 0x82223654;
		  /* 82223654h */ case    8:  		/* rlwinm. R9, R28, 0, 30, 30 */
		/* 82223654h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R28);
		/* 82223654h case    8:*/		return 0x82223658;
		  /* 82223658h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 82223658h case    9:*/		if ( regs.CR[0].eq ) { return 0x82223660;  }
		/* 82223658h case    9:*/		return 0x8222365C;
		  /* 8222365Ch */ case   10:  		/* addi R11, R11, -4 */
		/* 8222365Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8222365Ch case   10:*/		return 0x82223660;
	}
	return 0x82223660;
} // Block from 82223634h-82223660h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82223660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223660);
		  /* 82223660h */ case    0:  		/* and R9, R11, R28 */
		/* 82223660h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R28);
		/* 82223660h case    0:*/		return 0x82223664;
		  /* 82223664h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 82223664h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 82223664h case    1:*/		return 0x82223668;
		  /* 82223668h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82223668h case    2:*/		if ( regs.CR[0].eq ) { return 0x82223674;  }
		/* 82223668h case    2:*/		return 0x8222366C;
		  /* 8222366Ch */ case    3:  		/* addi R11, R11, -4 */
		/* 8222366Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8222366Ch case    3:*/		return 0x82223670;
		  /* 82223670h */ case    4:  		/* addi R10, R28, -4 */
		/* 82223670h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 82223670h case    4:*/		return 0x82223674;
	}
	return 0x82223674;
} // Block from 82223660h-82223674h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223674);
		  /* 82223674h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82223674h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82223674h case    0:*/		return 0x82223678;
		  /* 82223678h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223678h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223688;  }
		/* 82223678h case    1:*/		return 0x8222367C;
		  /* 8222367Ch */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8222367Ch case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8222367Ch case    2:*/		return 0x82223680;
		  /* 82223680h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82223680h case    3:*/		if ( regs.CR[0].eq ) { return 0x82223688;  }
		/* 82223680h case    3:*/		return 0x82223684;
		  /* 82223684h */ case    4:  		/* addi R10, R10, -2 */
		/* 82223684h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82223684h case    4:*/		return 0x82223688;
	}
	return 0x82223688;
} // Block from 82223674h-82223688h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223688);
		  /* 82223688h */ case    0:  		/* or R28, R10, R11 */
		/* 82223688h case    0:*/		cpu::op::or<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 82223688h case    0:*/		return 0x8222368C;
		  /* 8222368Ch */ case    1:  		/* mr R27, R6 */
		/* 8222368Ch case    1:*/		regs.R27 = regs.R6;
		/* 8222368Ch case    1:*/		return 0x82223690;
		  /* 82223690h */ case    2:  		/* b 636 */
		/* 82223690h case    2:*/		return 0x8222390C;
		/* 82223690h case    2:*/		return 0x82223694;
	}
	return 0x82223694;
} // Block from 82223688h-82223694h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223694);
		  /* 82223694h */ case    0:  		/* addi R11, R26, 11 */
		/* 82223694h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xB);
		/* 82223694h case    0:*/		return 0x82223698;
		  /* 82223698h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82223698h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82223698h case    1:*/		return 0x8222369C;
		  /* 8222369Ch */ case    2:  		/* lwzx R8, <#[R11 + R27]> */
		/* 8222369Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8222369Ch case    2:*/		return 0x822236A0;
		  /* 822236A0h */ case    3:  		/* lwz R9, <#[R8]> */
		/* 822236A0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 822236A0h case    3:*/		return 0x822236A4;
		  /* 822236A4h */ case    4:  		/* rlwinm. R10, R9, 0, 27, 28 */
		/* 822236A4h case    4:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R9);
		/* 822236A4h case    4:*/		return 0x822236A8;
		  /* 822236A8h */ case    5:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 822236A8h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 822236A8h case    5:*/		return 0x822236AC;
		  /* 822236ACh */ case    6:  		/* bc 4, CR0_EQ, 616 */
		/* 822236ACh case    6:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 822236ACh case    6:*/		return 0x822236B0;
		  /* 822236B0h */ case    7:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 822236B0h case    7:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 822236B0h case    7:*/		return 0x822236B4;
		  /* 822236B4h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 822236B4h case    8:*/		if ( regs.CR[0].eq ) { return 0x822236C8;  }
		/* 822236B4h case    8:*/		return 0x822236B8;
		  /* 822236B8h */ case    9:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 822236B8h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 822236B8h case    9:*/		return 0x822236BC;
		  /* 822236BCh */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 822236BCh case   10:*/		if ( regs.CR[0].eq ) { return 0x822236C8;  }
		/* 822236BCh case   10:*/		return 0x822236C0;
		  /* 822236C0h */ case   11:  		/* li R10, 0 */
		/* 822236C0h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822236C0h case   11:*/		return 0x822236C4;
		  /* 822236C4h */ case   12:  		/* b 28 */
		/* 822236C4h case   12:*/		return 0x822236E0;
		/* 822236C4h case   12:*/		return 0x822236C8;
	}
	return 0x822236C8;
} // Block from 82223694h-822236C8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822236C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822236C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822236C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822236C8);
		  /* 822236C8h */ case    0:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 822236C8h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 822236C8h case    0:*/		return 0x822236CC;
		  /* 822236CCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822236CCh case    1:*/		if ( regs.CR[0].eq ) { return 0x822236DC;  }
		/* 822236CCh case    1:*/		return 0x822236D0;
		  /* 822236D0h */ case    2:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 822236D0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 822236D0h case    2:*/		return 0x822236D4;
		  /* 822236D4h */ case    3:  		/* li R10, 0 */
		/* 822236D4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822236D4h case    3:*/		return 0x822236D8;
		  /* 822236D8h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 822236D8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x822236E0;  }
		/* 822236D8h case    4:*/		return 0x822236DC;
	}
	return 0x822236DC;
} // Block from 822236C8h-822236DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822236DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822236DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822236DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822236DC);
		  /* 822236DCh */ case    0:  		/* li R10, 1 */
		/* 822236DCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822236DCh case    0:*/		return 0x822236E0;
	}
	return 0x822236E0;
} // Block from 822236DCh-822236E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822236E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822236E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822236E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822236E0);
		  /* 822236E0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822236E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822236E0h case    0:*/		return 0x822236E4;
		  /* 822236E4h */ case    1:  		/* bc 12, CR0_EQ, 560 */
		/* 822236E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223914;  }
		/* 822236E4h case    1:*/		return 0x822236E8;
		  /* 822236E8h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 822236E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 822236E8h case    2:*/		return 0x822236EC;
		  /* 822236ECh */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 822236ECh case    3:*/		if ( regs.CR[6].eq ) { return 0x82223710;  }
		/* 822236ECh case    3:*/		return 0x822236F0;
		  /* 822236F0h */ case    4:  		/* lwz R10, <#[R8 + 12]> */
		/* 822236F0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x0000000C) );
		/* 822236F0h case    4:*/		return 0x822236F4;
		  /* 822236F4h */ case    5:  		/* lwz R7, <#[R25 + 28]> */
		/* 822236F4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x0000001C) );
		/* 822236F4h case    5:*/		return 0x822236F8;
		  /* 822236F8h */ case    6:  		/* lwz R10, <#[R10 + 28]> */
		/* 822236F8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000001C) );
		/* 822236F8h case    6:*/		return 0x822236FC;
		  /* 822236FCh */ case    7:  		/* lwz R7, <#[R7 + 76]> */
		/* 822236FCh case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000004C) );
		/* 822236FCh case    7:*/		return 0x82223700;
		  /* 82223700h */ case    8:  		/* lwz R10, <#[R10 + 76]> */
		/* 82223700h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 82223700h case    8:*/		return 0x82223704;
		  /* 82223704h */ case    9:  		/* xor R10, R10, R7 */
		/* 82223704h case    9:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82223704h case    9:*/		return 0x82223708;
		  /* 82223708h */ case   10:  		/* rlwinm. R10, R10, 0, 13, 31 */
		/* 82223708h case   10:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R10,regs.R10);
		/* 82223708h case   10:*/		return 0x8222370C;
		  /* 8222370Ch */ case   11:  		/* bc 4, CR0_EQ, 520 */
		/* 8222370Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 8222370Ch case   11:*/		return 0x82223710;
	}
	return 0x82223710;
} // Block from 822236E0h-82223710h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82223710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223710);
		  /* 82223710h */ case    0:  		/* rlwinm. R7, R11, 0, 29, 29 */
		/* 82223710h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R7,regs.R11);
		/* 82223710h case    0:*/		return 0x82223714;
		  /* 82223714h */ case    1:  		/* rlwinm R26, R9, 27, 30, 31 */
		/* 82223714h case    1:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R26,regs.R9);
		/* 82223714h case    1:*/		return 0x82223718;
		  /* 82223718h */ case    2:  		/* mr R10, R28 */
		/* 82223718h case    2:*/		regs.R10 = regs.R28;
		/* 82223718h case    2:*/		return 0x8222371C;
		  /* 8222371Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8222371Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8222372C;  }
		/* 8222371Ch case    3:*/		return 0x82223720;
		  /* 82223720h */ case    4:  		/* rlwinm. R9, R28, 0, 30, 30 */
		/* 82223720h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R28);
		/* 82223720h case    4:*/		return 0x82223724;
		  /* 82223724h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82223724h case    5:*/		if ( regs.CR[0].eq ) { return 0x8222372C;  }
		/* 82223724h case    5:*/		return 0x82223728;
		  /* 82223728h */ case    6:  		/* addi R11, R11, -4 */
		/* 82223728h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82223728h case    6:*/		return 0x8222372C;
	}
	return 0x8222372C;
} // Block from 82223710h-8222372Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222372Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222372C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222372C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222372C);
		  /* 8222372Ch */ case    0:  		/* and R9, R11, R28 */
		/* 8222372Ch case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R28);
		/* 8222372Ch case    0:*/		return 0x82223730;
		  /* 82223730h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 82223730h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 82223730h case    1:*/		return 0x82223734;
		  /* 82223734h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82223734h case    2:*/		if ( regs.CR[0].eq ) { return 0x82223740;  }
		/* 82223734h case    2:*/		return 0x82223738;
		  /* 82223738h */ case    3:  		/* addi R11, R11, -4 */
		/* 82223738h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82223738h case    3:*/		return 0x8222373C;
		  /* 8222373Ch */ case    4:  		/* addi R10, R28, -4 */
		/* 8222373Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 8222373Ch case    4:*/		return 0x82223740;
	}
	return 0x82223740;
} // Block from 8222372Ch-82223740h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223740h
// Function '?GetResultBounds@Dependency@D3DXShader@@QAAXIPAN0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223740);
		  /* 82223740h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82223740h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82223740h case    0:*/		return 0x82223744;
		  /* 82223744h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223744h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223754;  }
		/* 82223744h case    1:*/		return 0x82223748;
		  /* 82223748h */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 82223748h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 82223748h case    2:*/		return 0x8222374C;
		  /* 8222374Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8222374Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82223754;  }
		/* 8222374Ch case    3:*/		return 0x82223750;
		  /* 82223750h */ case    4:  		/* addi R10, R10, -2 */
		/* 82223750h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82223750h case    4:*/		return 0x82223754;
	}
	return 0x82223754;
} // Block from 82223740h-82223754h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223754);
		  /* 82223754h */ case    0:  		/* lwz R27, <#[R8 + 12]> */
		/* 82223754h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + 0x0000000C) );
		/* 82223754h case    0:*/		return 0x82223758;
		  /* 82223758h */ case    1:  		/* b 432 */
		/* 82223758h case    1:*/		return 0x82223908;
		/* 82223758h case    1:*/		return 0x8222375C;
	}
	return 0x8222375C;
} // Block from 82223754h-8222375Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222375Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222375C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222375C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222375C);
		  /* 8222375Ch */ case    0:  		/* lwz R11, <#[R27 + 44]> */
		/* 8222375Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 8222375Ch case    0:*/		return 0x82223760;
		  /* 82223760h */ case    1:  		/* lwz R31, <#[R27 + 48]> */
		/* 82223760h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x00000030) );
		/* 82223760h case    1:*/		return 0x82223764;
		  /* 82223764h */ case    2:  		/* lwz R30, <#[R27 + 52]> */
		/* 82223764h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000034) );
		/* 82223764h case    2:*/		return 0x82223768;
		  /* 82223768h */ case    3:  		/* lwz R3, <#[R11 + 12]> */
		/* 82223768h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 82223768h case    3:*/		return 0x8222376C;
		  /* 8222376Ch */ case    4:  		/* lwz R10, <#[R3 + 8]> */
		/* 8222376Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8222376Ch case    4:*/		return 0x82223770;
		  /* 82223770h */ case    5:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82223770h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82223770h case    5:*/		return 0x82223774;
		  /* 82223774h */ case    6:  		/* cmplwi CR6, R10, 16000 */
		/* 82223774h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E80);
		/* 82223774h case    6:*/		return 0x82223778;
		  /* 82223778h */ case    7:  		/* bc 4, CR6_EQ, 412 */
		/* 82223778h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82223914;  }
		/* 82223778h case    7:*/		return 0x8222377C;
		  /* 8222377Ch */ case    8:  		/* lwz R11, <#[R11]> */
		/* 8222377Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8222377Ch case    8:*/		return 0x82223780;
		  /* 82223780h */ case    9:  		/* rlwinm R29, R26, 1, 0, 30 */
		/* 82223780h case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R26);
		/* 82223780h case    9:*/		return 0x82223784;
		  /* 82223784h */ case   10:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 82223784h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 82223784h case   10:*/		return 0x82223788;
		  /* 82223788h */ case   11:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 82223788h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 82223788h case   11:*/		return 0x8222378C;
		  /* 8222378Ch */ case   12:  		/* srw R11, R10, R29 */
		/* 8222378Ch case   12:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R29);
		/* 8222378Ch case   12:*/		return 0x82223790;
	}
	return 0x82223790;
} // Block from 8222375Ch-82223790h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82223790h
// Function '?EncodeVFETCH@Instruction@D3DXShader@@QAAXPATGPUVERTEX_FETCH_INSTRUCTION@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223790);
		  /* 82223790h */ case    0:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 82223790h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 82223790h case    0:*/		return 0x82223794;
		  /* 82223794h */ case    1:  		/* bl -8436 */
		/* 82223794h case    1:*/		regs.LR = 0x82223798; return 0x822216A0;
		/* 82223794h case    1:*/		return 0x82223798;
		  /* 82223798h */ case    2:  		/* fcmpu CR6, FR1, FR31 */
		/* 82223798h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82223798h case    2:*/		return 0x8222379C;
		  /* 8222379Ch */ case    3:  		/* mr R9, R31 */
		/* 8222379Ch case    3:*/		regs.R9 = regs.R31;
		/* 8222379Ch case    3:*/		return 0x822237A0;
		  /* 822237A0h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 822237A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x822237A8;  }
		/* 822237A0h case    4:*/		return 0x822237A4;
		  /* 822237A4h */ case    5:  		/* mr R9, R30 */
		/* 822237A4h case    5:*/		regs.R9 = regs.R30;
		/* 822237A4h case    5:*/		return 0x822237A8;
	}
	return 0x822237A8;
} // Block from 82223790h-822237A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822237A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822237A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822237A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822237A8);
		  /* 822237A8h */ case    0:  		/* lwz R8, <#[R9]> */
		/* 822237A8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 822237A8h case    0:*/		return 0x822237AC;
		  /* 822237ACh */ case    1:  		/* rlwinm. R10, R8, 0, 27, 28 */
		/* 822237ACh case    1:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R8);
		/* 822237ACh case    1:*/		return 0x822237B0;
		  /* 822237B0h */ case    2:  		/* rlwinm R11, R8, 0, 27, 31 */
		/* 822237B0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R8);
		/* 822237B0h case    2:*/		return 0x822237B4;
		  /* 822237B4h */ case    3:  		/* bc 4, CR0_EQ, 352 */
		/* 822237B4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 822237B4h case    3:*/		return 0x822237B8;
		  /* 822237B8h */ case    4:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 822237B8h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 822237B8h case    4:*/		return 0x822237BC;
		  /* 822237BCh */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 822237BCh case    5:*/		if ( regs.CR[0].eq ) { return 0x822237D0;  }
		/* 822237BCh case    5:*/		return 0x822237C0;
		  /* 822237C0h */ case    6:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 822237C0h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 822237C0h case    6:*/		return 0x822237C4;
		  /* 822237C4h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 822237C4h case    7:*/		if ( regs.CR[0].eq ) { return 0x822237D0;  }
		/* 822237C4h case    7:*/		return 0x822237C8;
		  /* 822237C8h */ case    8:  		/* li R10, 0 */
		/* 822237C8h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822237C8h case    8:*/		return 0x822237CC;
		  /* 822237CCh */ case    9:  		/* b 28 */
		/* 822237CCh case    9:*/		return 0x822237E8;
		/* 822237CCh case    9:*/		return 0x822237D0;
	}
	return 0x822237D0;
} // Block from 822237A8h-822237D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822237D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822237D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822237D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822237D0);
		  /* 822237D0h */ case    0:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 822237D0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 822237D0h case    0:*/		return 0x822237D4;
		  /* 822237D4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822237D4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822237E4;  }
		/* 822237D4h case    1:*/		return 0x822237D8;
		  /* 822237D8h */ case    2:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 822237D8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 822237D8h case    2:*/		return 0x822237DC;
		  /* 822237DCh */ case    3:  		/* li R10, 0 */
		/* 822237DCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822237DCh case    3:*/		return 0x822237E0;
		  /* 822237E0h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 822237E0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x822237E8;  }
		/* 822237E0h case    4:*/		return 0x822237E4;
	}
	return 0x822237E4;
} // Block from 822237D0h-822237E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822237E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822237E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822237E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822237E4);
		  /* 822237E4h */ case    0:  		/* li R10, 1 */
		/* 822237E4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822237E4h case    0:*/		return 0x822237E8;
	}
	return 0x822237E8;
} // Block from 822237E4h-822237E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822237E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822237E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822237E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822237E8);
		  /* 822237E8h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822237E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822237E8h case    0:*/		return 0x822237EC;
		  /* 822237ECh */ case    1:  		/* bc 12, CR0_EQ, 296 */
		/* 822237ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x82223914;  }
		/* 822237ECh case    1:*/		return 0x822237F0;
		  /* 822237F0h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 822237F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 822237F0h case    2:*/		return 0x822237F4;
		  /* 822237F4h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 822237F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82223818;  }
		/* 822237F4h case    3:*/		return 0x822237F8;
		  /* 822237F8h */ case    4:  		/* lwz R10, <#[R9 + 12]> */
		/* 822237F8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000C) );
		/* 822237F8h case    4:*/		return 0x822237FC;
		  /* 822237FCh */ case    5:  		/* lwz R7, <#[R25 + 28]> */
		/* 822237FCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x0000001C) );
		/* 822237FCh case    5:*/		return 0x82223800;
		  /* 82223800h */ case    6:  		/* lwz R10, <#[R10 + 28]> */
		/* 82223800h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000001C) );
		/* 82223800h case    6:*/		return 0x82223804;
		  /* 82223804h */ case    7:  		/* lwz R7, <#[R7 + 76]> */
		/* 82223804h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000004C) );
		/* 82223804h case    7:*/		return 0x82223808;
		  /* 82223808h */ case    8:  		/* lwz R10, <#[R10 + 76]> */
		/* 82223808h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 82223808h case    8:*/		return 0x8222380C;
		  /* 8222380Ch */ case    9:  		/* xor R10, R10, R7 */
		/* 8222380Ch case    9:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8222380Ch case    9:*/		return 0x82223810;
		  /* 82223810h */ case   10:  		/* rlwinm. R10, R10, 0, 13, 31 */
		/* 82223810h case   10:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R10,regs.R10);
		/* 82223810h case   10:*/		return 0x82223814;
		  /* 82223814h */ case   11:  		/* bc 4, CR0_EQ, 256 */
		/* 82223814h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223814h case   11:*/		return 0x82223818;
	}
	return 0x82223818;
} // Block from 822237E8h-82223818h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82223818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223818);
		  /* 82223818h */ case    0:  		/* rlwinm R10, R8, 27, 24, 31 */
		/* 82223818h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R8);
		/* 82223818h case    0:*/		return 0x8222381C;
		  /* 8222381Ch */ case    1:  		/* lwz R27, <#[R9 + 12]> */
		/* 8222381Ch case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + 0x0000000C) );
		/* 8222381Ch case    1:*/		return 0x82223820;
		  /* 82223820h */ case    2:  		/* rlwinm. R9, R11, 0, 29, 29 */
		/* 82223820h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R11);
		/* 82223820h case    2:*/		return 0x82223824;
		  /* 82223824h */ case    3:  		/* srw R10, R10, R29 */
		/* 82223824h case    3:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 82223824h case    3:*/		return 0x82223828;
		  /* 82223828h */ case    4:  		/* b 160 */
		/* 82223828h case    4:*/		return 0x822238C8;
		/* 82223828h case    4:*/		return 0x8222382C;
	}
	return 0x8222382C;
} // Block from 82223818h-8222382Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222382Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222382C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222382C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222382C);
		  /* 8222382Ch */ case    0:  		/* lwz R31, <#[R27 + 44]> */
		/* 8222382Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x0000002C) );
		/* 8222382Ch case    0:*/		return 0x82223830;
		  /* 82223830h */ case    1:  		/* lwz R4, <#[R27 + 48]> */
		/* 82223830h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000030) );
		/* 82223830h case    1:*/		return 0x82223834;
		  /* 82223834h */ case    2:  		/* mr R3, R31 */
		/* 82223834h case    2:*/		regs.R3 = regs.R31;
		/* 82223834h case    2:*/		return 0x82223838;
		  /* 82223838h */ case    3:  		/* bl -783792 */
		/* 82223838h case    3:*/		regs.LR = 0x8222383C; return 0x82164288;
		/* 82223838h case    3:*/		return 0x8222383C;
		  /* 8222383Ch */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222383Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222383Ch case    4:*/		return 0x82223840;
		  /* 82223840h */ case    5:  		/* bc 12, CR0_EQ, 212 */
		/* 82223840h case    5:*/		if ( regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223840h case    5:*/		return 0x82223844;
		  /* 82223844h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82223844h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82223844h case    6:*/		return 0x82223848;
		  /* 82223848h */ case    7:  		/* rlwinm. R10, R9, 0, 27, 28 */
		/* 82223848h case    7:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R9);
		/* 82223848h case    7:*/		return 0x8222384C;
		  /* 8222384Ch */ case    8:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 8222384Ch case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 8222384Ch case    8:*/		return 0x82223850;
		  /* 82223850h */ case    9:  		/* bc 4, CR0_EQ, 196 */
		/* 82223850h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223850h case    9:*/		return 0x82223854;
		  /* 82223854h */ case   10:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 82223854h case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 82223854h case   10:*/		return 0x82223858;
		  /* 82223858h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 82223858h case   11:*/		if ( regs.CR[0].eq ) { return 0x8222386C;  }
		/* 82223858h case   11:*/		return 0x8222385C;
		  /* 8222385Ch */ case   12:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 8222385Ch case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 8222385Ch case   12:*/		return 0x82223860;
		  /* 82223860h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 82223860h case   13:*/		if ( regs.CR[0].eq ) { return 0x8222386C;  }
		/* 82223860h case   13:*/		return 0x82223864;
		  /* 82223864h */ case   14:  		/* li R10, 0 */
		/* 82223864h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82223864h case   14:*/		return 0x82223868;
		  /* 82223868h */ case   15:  		/* b 28 */
		/* 82223868h case   15:*/		return 0x82223884;
		/* 82223868h case   15:*/		return 0x8222386C;
	}
	return 0x8222386C;
} // Block from 8222382Ch-8222386Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8222386Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222386C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222386C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222386C);
		  /* 8222386Ch */ case    0:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 8222386Ch case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 8222386Ch case    0:*/		return 0x82223870;
		  /* 82223870h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223870h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223880;  }
		/* 82223870h case    1:*/		return 0x82223874;
		  /* 82223874h */ case    2:  		/* rlwinm. R10, R28, 0, 31, 31 */
		/* 82223874h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R28);
		/* 82223874h case    2:*/		return 0x82223878;
		  /* 82223878h */ case    3:  		/* li R10, 0 */
		/* 82223878h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82223878h case    3:*/		return 0x8222387C;
		  /* 8222387Ch */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8222387Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x82223884;  }
		/* 8222387Ch case    4:*/		return 0x82223880;
	}
	return 0x82223880;
} // Block from 8222386Ch-82223880h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223880);
		  /* 82223880h */ case    0:  		/* li R10, 1 */
		/* 82223880h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82223880h case    0:*/		return 0x82223884;
	}
	return 0x82223884;
} // Block from 82223880h-82223884h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223884);
		  /* 82223884h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82223884h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82223884h case    0:*/		return 0x82223888;
		  /* 82223888h */ case    1:  		/* bc 12, CR0_EQ, 140 */
		/* 82223888h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223914;  }
		/* 82223888h case    1:*/		return 0x8222388C;
		  /* 8222388Ch */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 8222388Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8222388Ch case    2:*/		return 0x82223890;
		  /* 82223890h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 82223890h case    3:*/		if ( regs.CR[6].eq ) { return 0x822238B4;  }
		/* 82223890h case    3:*/		return 0x82223894;
		  /* 82223894h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 82223894h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82223894h case    4:*/		return 0x82223898;
		  /* 82223898h */ case    5:  		/* lwz R8, <#[R25 + 28]> */
		/* 82223898h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x0000001C) );
		/* 82223898h case    5:*/		return 0x8222389C;
		  /* 8222389Ch */ case    6:  		/* lwz R10, <#[R10 + 28]> */
		/* 8222389Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000001C) );
		/* 8222389Ch case    6:*/		return 0x822238A0;
		  /* 822238A0h */ case    7:  		/* lwz R8, <#[R8 + 76]> */
		/* 822238A0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000004C) );
		/* 822238A0h case    7:*/		return 0x822238A4;
		  /* 822238A4h */ case    8:  		/* lwz R10, <#[R10 + 76]> */
		/* 822238A4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 822238A4h case    8:*/		return 0x822238A8;
		  /* 822238A8h */ case    9:  		/* xor R10, R10, R8 */
		/* 822238A8h case    9:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 822238A8h case    9:*/		return 0x822238AC;
		  /* 822238ACh */ case   10:  		/* rlwinm. R10, R10, 0, 13, 31 */
		/* 822238ACh case   10:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R10,regs.R10);
		/* 822238ACh case   10:*/		return 0x822238B0;
		  /* 822238B0h */ case   11:  		/* bc 4, CR0_EQ, 100 */
		/* 822238B0h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82223914;  }
		/* 822238B0h case   11:*/		return 0x822238B4;
	}
	return 0x822238B4;
} // Block from 82223884h-822238B4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822238B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822238B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822238B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822238B4);
		  /* 822238B4h */ case    0:  		/* rlwinm R10, R26, 1, 0, 30 */
		/* 822238B4h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R26);
		/* 822238B4h case    0:*/		return 0x822238B8;
		  /* 822238B8h */ case    1:  		/* lwz R27, <#[R31 + 12]> */
		/* 822238B8h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 822238B8h case    1:*/		return 0x822238BC;
		  /* 822238BCh */ case    2:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 822238BCh case    2:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 822238BCh case    2:*/		return 0x822238C0;
		  /* 822238C0h */ case    3:  		/* rlwinm. R8, R11, 0, 29, 29 */
		/* 822238C0h case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R8,regs.R11);
		/* 822238C0h case    3:*/		return 0x822238C4;
		  /* 822238C4h */ case    4:  		/* srw R10, R9, R10 */
		/* 822238C4h case    4:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 822238C4h case    4:*/		return 0x822238C8;
	}
	return 0x822238C8;
} // Block from 822238B4h-822238C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822238C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822238C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822238C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822238C8);
		  /* 822238C8h */ case    0:  		/* rlwinm R26, R10, 0, 30, 31 */
		/* 822238C8h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R26,regs.R10);
		/* 822238C8h case    0:*/		return 0x822238CC;
		  /* 822238CCh */ case    1:  		/* mr R10, R28 */
		/* 822238CCh case    1:*/		regs.R10 = regs.R28;
		/* 822238CCh case    1:*/		return 0x822238D0;
		  /* 822238D0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 822238D0h case    2:*/		if ( regs.CR[0].eq ) { return 0x822238E0;  }
		/* 822238D0h case    2:*/		return 0x822238D4;
		  /* 822238D4h */ case    3:  		/* rlwinm. R9, R28, 0, 30, 30 */
		/* 822238D4h case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R28);
		/* 822238D4h case    3:*/		return 0x822238D8;
		  /* 822238D8h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 822238D8h case    4:*/		if ( regs.CR[0].eq ) { return 0x822238E0;  }
		/* 822238D8h case    4:*/		return 0x822238DC;
		  /* 822238DCh */ case    5:  		/* addi R11, R11, -4 */
		/* 822238DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 822238DCh case    5:*/		return 0x822238E0;
	}
	return 0x822238E0;
} // Block from 822238C8h-822238E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822238E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822238E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822238E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822238E0);
		  /* 822238E0h */ case    0:  		/* and R9, R11, R28 */
		/* 822238E0h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R28);
		/* 822238E0h case    0:*/		return 0x822238E4;
		  /* 822238E4h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 822238E4h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 822238E4h case    1:*/		return 0x822238E8;
		  /* 822238E8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 822238E8h case    2:*/		if ( regs.CR[0].eq ) { return 0x822238F4;  }
		/* 822238E8h case    2:*/		return 0x822238EC;
		  /* 822238ECh */ case    3:  		/* addi R11, R11, -4 */
		/* 822238ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 822238ECh case    3:*/		return 0x822238F0;
		  /* 822238F0h */ case    4:  		/* addi R10, R28, -4 */
		/* 822238F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 822238F0h case    4:*/		return 0x822238F4;
	}
	return 0x822238F4;
} // Block from 822238E0h-822238F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822238F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822238F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822238F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822238F4);
		  /* 822238F4h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 822238F4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 822238F4h case    0:*/		return 0x822238F8;
		  /* 822238F8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822238F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223908;  }
		/* 822238F8h case    1:*/		return 0x822238FC;
		  /* 822238FCh */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 822238FCh case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 822238FCh case    2:*/		return 0x82223900;
		  /* 82223900h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82223900h case    3:*/		if ( regs.CR[0].eq ) { return 0x82223908;  }
		/* 82223900h case    3:*/		return 0x82223904;
		  /* 82223904h */ case    4:  		/* addi R10, R10, -2 */
		/* 82223904h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82223904h case    4:*/		return 0x82223908;
	}
	return 0x82223908;
} // Block from 822238F4h-82223908h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223908);
		  /* 82223908h */ case    0:  		/* or R28, R11, R10 */
		/* 82223908h case    0:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R10);
		/* 82223908h case    0:*/		return 0x8222390C;
	}
	return 0x8222390C;
} // Block from 82223908h-8222390Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222390Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222390C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222390C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222390C);
		  /* 8222390Ch */ case    0:  		/* and. R11, R28, R24 */
		/* 8222390Ch case    0:*/		cpu::op::and<1>(regs,&regs.R11,regs.R28,regs.R24);
		/* 8222390Ch case    0:*/		return 0x82223910;
		  /* 82223910h */ case    1:  		/* bc 12, CR0_EQ, -1004 */
		/* 82223910h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223524;  }
		/* 82223910h case    1:*/		return 0x82223914;
	}
	return 0x82223914;
} // Block from 8222390Ch-82223914h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223914);
		  /* 82223914h */ case    0:  		/* stw R27, <#[R23]> */
		/* 82223914h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R23 + 0x00000000) );
		/* 82223914h case    0:*/		return 0x82223918;
		  /* 82223918h */ case    1:  		/* stw R26, <#[R22]> */
		/* 82223918h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R22 + 0x00000000) );
		/* 82223918h case    1:*/		return 0x8222391C;
		  /* 8222391Ch */ case    2:  		/* stw R28, <#[R21]> */
		/* 8222391Ch case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R21 + 0x00000000) );
		/* 8222391Ch case    2:*/		return 0x82223920;
		  /* 82223920h */ case    3:  		/* addi R1, R1, 192 */
		/* 82223920h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82223920h case    3:*/		return 0x82223924;
		  /* 82223924h */ case    4:  		/* lfd FR31, <#[R1 - 112]> */
		/* 82223924h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 82223924h case    4:*/		return 0x82223928;
		  /* 82223928h */ case    5:  		/* b -1648288 */
		/* 82223928h case    5:*/		return 0x82091288;
		/* 82223928h case    5:*/		return 0x8222392C;
		  /* 8222392Ch */ case    6:  		/* nop */
		/* 8222392Ch case    6:*/		cpu::op::nop();
		/* 8222392Ch case    6:*/		return 0x82223930;
		  /* 82223930h */ case    7:  		/* addi R10, R5, 1 */
		/* 82223930h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x1);
		/* 82223930h case    7:*/		return 0x82223934;
		  /* 82223934h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 82223934h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82223934h case    8:*/		return 0x82223938;
		  /* 82223938h */ case    9:  		/* addi R9, R4, 1 */
		/* 82223938h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x1);
		/* 82223938h case    9:*/		return 0x8222393C;
		  /* 8222393Ch */ case   10:  		/* rlwinm R8, R10, 0, 27, 31 */
		/* 8222393Ch case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R10);
		/* 8222393Ch case   10:*/		return 0x82223940;
		  /* 82223940h */ case   11:  		/* li R7, 2 */
		/* 82223940h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82223940h case   11:*/		return 0x82223944;
		  /* 82223944h */ case   12:  		/* nor R6, R11, R11 */
		/* 82223944h case   12:*/		cpu::op::nor<0>(regs,&regs.R6,regs.R11,regs.R11);
		/* 82223944h case   12:*/		return 0x82223948;
		  /* 82223948h */ case   13:  		/* slw R7, R7, R8 */
		/* 82223948h case   13:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 82223948h case   13:*/		return 0x8222394C;
		  /* 8222394Ch */ case   14:  		/* rlwinm R5, R9, 0, 27, 31 */
		/* 8222394Ch case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R9);
		/* 8222394Ch case   14:*/		return 0x82223950;
		  /* 82223950h */ case   15:  		/* li R4, -1 */
		/* 82223950h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82223950h case   15:*/		return 0x82223954;
		  /* 82223954h */ case   16:  		/* rlwinm. R3, R6, 0, 31, 31 */
		/* 82223954h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R3,regs.R6);
		/* 82223954h case   16:*/		return 0x82223958;
		  /* 82223958h */ case   17:  		/* slw R8, R4, R5 */
		/* 82223958h case   17:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R4,regs.R5);
		/* 82223958h case   17:*/		return 0x8222395C;
		  /* 8222395Ch */ case   18:  		/* addi R6, R7, -1 */
		/* 8222395Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R7,0xFFFFFFFF);
		/* 8222395Ch case   18:*/		return 0x82223960;
		  /* 82223960h */ case   19:  		/* bc 4, CR0_EQ, 24 */
		/* 82223960h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82223978;  }
		/* 82223960h case   19:*/		return 0x82223964;
		  /* 82223964h */ case   20:  		/* and R11, R11, R6 */
		/* 82223964h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82223964h case   20:*/		return 0x82223968;
		  /* 82223968h */ case   21:  		/* and R10, R6, R8 */
		/* 82223968h case   21:*/		cpu::op::and<0>(regs,&regs.R10,regs.R6,regs.R8);
		/* 82223968h case   21:*/		return 0x8222396C;
		  /* 8222396Ch */ case   22:  		/* and R11, R11, R8 */
		/* 8222396Ch case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8222396Ch case   22:*/		return 0x82223970;
		  /* 82223970h */ case   23:  		/* subf R11, R10, R11 */
		/* 82223970h case   23:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82223970h case   23:*/		return 0x82223974;
		  /* 82223974h */ case   24:  		/* b 108 */
		/* 82223974h case   24:*/		return 0x822239E0;
		/* 82223974h case   24:*/		return 0x82223978;
	}
	return 0x82223978;
} // Block from 82223914h-82223978h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82223978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223978);
		  /* 82223978h */ case    0:  		/* rlwinm R5, R9, 27, 5, 31 */
		/* 82223978h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R5,regs.R9);
		/* 82223978h case    0:*/		return 0x8222397C;
		  /* 8222397Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 8222397Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8222397Ch case    1:*/		return 0x82223980;
		  /* 82223980h */ case    2:  		/* rlwinm R9, R9, 29, 3, 29 */
		/* 82223980h case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R9);
		/* 82223980h case    2:*/		return 0x82223984;
		  /* 82223984h */ case    3:  		/* rlwinm R4, R10, 27, 5, 31 */
		/* 82223984h case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R4,regs.R10);
		/* 82223984h case    3:*/		return 0x82223988;
		  /* 82223988h */ case    4:  		/* rlwinm R7, R10, 29, 3, 29 */
		/* 82223988h case    4:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R7,regs.R10);
		/* 82223988h case    4:*/		return 0x8222398C;
		  /* 8222398Ch */ case    5:  		/* add R10, R9, R11 */
		/* 8222398Ch case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 8222398Ch case    5:*/		return 0x82223990;
		  /* 82223990h */ case    6:  		/* add R9, R7, R11 */
		/* 82223990h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R11);
		/* 82223990h case    6:*/		return 0x82223994;
		  /* 82223994h */ case    7:  		/* cmplw CR6, R5, R4 */
		/* 82223994h case    7:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 82223994h case    7:*/		return 0x82223998;
		  /* 82223998h */ case    8:  		/* lwz R11, <#[R10]> */
		/* 82223998h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82223998h case    8:*/		return 0x8222399C;
		  /* 8222399Ch */ case    9:  		/* bc 12, CR6_EQ, -56 */
		/* 8222399Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82223964;  }
		/* 8222399Ch case    9:*/		return 0x822239A0;
		  /* 822239A0h */ case   10:  		/* and R11, R11, R8 */
		/* 822239A0h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 822239A0h case   10:*/		return 0x822239A4;
		  /* 822239A4h */ case   11:  		/* cmplw CR6, R11, R8 */
		/* 822239A4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 822239A4h case   11:*/		return 0x822239A8;
		  /* 822239A8h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 822239A8h case   12:*/		if ( regs.CR[6].eq ) { return 0x822239B4;  }
		/* 822239A8h case   12:*/		return 0x822239AC;
		  /* 822239ACh */ case   13:  		/* li R3, 1 */
		/* 822239ACh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822239ACh case   13:*/		return 0x822239B0;
		  /* 822239B0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 822239B0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822239B0h case   14:*/		return 0x822239B4;
	}
	return 0x822239B4;
} // Block from 82223978h-822239B4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822239B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822239B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822239B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822239B4);
		  /* 822239B4h */ case    0:  		/* addi R11, R10, 4 */
		/* 822239B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 822239B4h case    0:*/		return 0x822239B8;
		  /* 822239B8h */ case    1:  		/* b 20 */
		/* 822239B8h case    1:*/		return 0x822239CC;
		/* 822239B8h case    1:*/		return 0x822239BC;
		  /* 822239BCh */ case    2:  		/* lwz R10, <#[R11]> */
		/* 822239BCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822239BCh case    2:*/		return 0x822239C0;
		  /* 822239C0h */ case    3:  		/* cmpwi CR6, R10, -1 */
		/* 822239C0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 822239C0h case    3:*/		return 0x822239C4;
		  /* 822239C4h */ case    4:  		/* bc 4, CR6_EQ, -24 */
		/* 822239C4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822239AC;  }
		/* 822239C4h case    4:*/		return 0x822239C8;
		  /* 822239C8h */ case    5:  		/* addi R11, R11, 4 */
		/* 822239C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822239C8h case    5:*/		return 0x822239CC;
	}
	return 0x822239CC;
} // Block from 822239B4h-822239CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822239CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822239CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822239CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822239CC);
		  /* 822239CCh */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 822239CCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822239CCh case    0:*/		return 0x822239D0;
		  /* 822239D0h */ case    1:  		/* bc 12, CR6_LT, -20 */
		/* 822239D0h case    1:*/		if ( regs.CR[6].lt ) { return 0x822239BC;  }
		/* 822239D0h case    1:*/		return 0x822239D4;
		  /* 822239D4h */ case    2:  		/* lwz R11, <#[R9]> */
		/* 822239D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 822239D4h case    2:*/		return 0x822239D8;
		  /* 822239D8h */ case    3:  		/* and R11, R11, R6 */
		/* 822239D8h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 822239D8h case    3:*/		return 0x822239DC;
		  /* 822239DCh */ case    4:  		/* subf R11, R11, R6 */
		/* 822239DCh case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 822239DCh case    4:*/		return 0x822239E0;
	}
	return 0x822239E0;
} // Block from 822239CCh-822239E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822239E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822239E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822239E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822239E0);
		  /* 822239E0h */ case    0:  		/* addic R10, R11, -1 */
		/* 822239E0h case    0:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 822239E0h case    0:*/		return 0x822239E4;
		  /* 822239E4h */ case    1:  		/* subfe R3, R10, R11 */
		/* 822239E4h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822239E4h case    1:*/		return 0x822239E8;
		  /* 822239E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 822239E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822239E8h case    2:*/		return 0x822239EC;
	}
	return 0x822239EC;
} // Block from 822239E0h-822239ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822239ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822239EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822239EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822239EC);
		  /* 822239ECh */ case    0:  		/* nop */
		/* 822239ECh case    0:*/		cpu::op::nop();
		/* 822239ECh case    0:*/		return 0x822239F0;
	}
	return 0x822239F0;
} // Block from 822239ECh-822239F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822239F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822239F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822239F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822239F0);
		  /* 822239F0h */ case    0:  		/* mfspr R12, LR */
		/* 822239F0h case    0:*/		regs.R12 = regs.LR;
		/* 822239F0h case    0:*/		return 0x822239F4;
		  /* 822239F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822239F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822239F4h case    1:*/		return 0x822239F8;
		  /* 822239F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822239F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822239F8h case    2:*/		return 0x822239FC;
		  /* 822239FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822239FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822239FCh case    3:*/		return 0x82223A00;
		  /* 82223A00h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82223A00h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82223A00h case    4:*/		return 0x82223A04;
		  /* 82223A04h */ case    5:  		/* mr R31, R3 */
		/* 82223A04h case    5:*/		regs.R31 = regs.R3;
		/* 82223A04h case    5:*/		return 0x82223A08;
		  /* 82223A08h */ case    6:  		/* mr R30, R4 */
		/* 82223A08h case    6:*/		regs.R30 = regs.R4;
		/* 82223A08h case    6:*/		return 0x82223A0C;
		  /* 82223A0Ch */ case    7:  		/* b 16 */
		/* 82223A0Ch case    7:*/		return 0x82223A1C;
		/* 82223A0Ch case    7:*/		return 0x82223A10;
		  /* 82223A10h */ case    8:  		/* mr R5, R30 */
		/* 82223A10h case    8:*/		regs.R5 = regs.R30;
		/* 82223A10h case    8:*/		return 0x82223A14;
		  /* 82223A14h */ case    9:  		/* mr R3, R31 */
		/* 82223A14h case    9:*/		regs.R3 = regs.R31;
		/* 82223A14h case    9:*/		return 0x82223A18;
		  /* 82223A18h */ case   10:  		/* bl -700680 */
		/* 82223A18h case   10:*/		regs.LR = 0x82223A1C; return 0x82178910;
		/* 82223A18h case   10:*/		return 0x82223A1C;
	}
	return 0x82223A1C;
} // Block from 822239F0h-82223A1Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82223A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223A1C);
		  /* 82223A1Ch */ case    0:  		/* lwz R4, <#[R31]> */
		/* 82223A1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82223A1Ch case    0:*/		return 0x82223A20;
		  /* 82223A20h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 82223A20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82223A20h case    1:*/		return 0x82223A24;
		  /* 82223A24h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82223A24h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82223A10;  }
		/* 82223A24h case    2:*/		return 0x82223A28;
		  /* 82223A28h */ case    3:  		/* addi R1, R1, 112 */
		/* 82223A28h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82223A28h case    3:*/		return 0x82223A2C;
		  /* 82223A2Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82223A2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82223A2Ch case    4:*/		return 0x82223A30;
		  /* 82223A30h */ case    5:  		/* mtspr LR, R12 */
		/* 82223A30h case    5:*/		regs.LR = regs.R12;
		/* 82223A30h case    5:*/		return 0x82223A34;
		  /* 82223A34h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 82223A34h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82223A34h case    6:*/		return 0x82223A38;
		  /* 82223A38h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 82223A38h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82223A38h case    7:*/		return 0x82223A3C;
		  /* 82223A3Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 82223A3Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82223A3Ch case    8:*/		return 0x82223A40;
	}
	return 0x82223A40;
} // Block from 82223A1Ch-82223A40h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82223A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223A40);
		  /* 82223A40h */ case    0:  		/* mfspr R12, LR */
		/* 82223A40h case    0:*/		regs.R12 = regs.LR;
		/* 82223A40h case    0:*/		return 0x82223A44;
		  /* 82223A44h */ case    1:  		/* bl -1648628 */
		/* 82223A44h case    1:*/		regs.LR = 0x82223A48; return 0x82091250;
		/* 82223A44h case    1:*/		return 0x82223A48;
		  /* 82223A48h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82223A48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82223A48h case    2:*/		return 0x82223A4C;
		  /* 82223A4Ch */ case    3:  		/* mr R26, R3 */
		/* 82223A4Ch case    3:*/		regs.R26 = regs.R3;
		/* 82223A4Ch case    3:*/		return 0x82223A50;
		  /* 82223A50h */ case    4:  		/* mr R27, R4 */
		/* 82223A50h case    4:*/		regs.R27 = regs.R4;
		/* 82223A50h case    4:*/		return 0x82223A54;
		  /* 82223A54h */ case    5:  		/* mr R30, R4 */
		/* 82223A54h case    5:*/		regs.R30 = regs.R4;
		/* 82223A54h case    5:*/		return 0x82223A58;
		  /* 82223A58h */ case    6:  		/* lwz R31, <#[R30]> */
		/* 82223A58h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82223A58h case    6:*/		return 0x82223A5C;
		  /* 82223A5Ch */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 82223A5Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82223A5Ch case    7:*/		return 0x82223A60;
		  /* 82223A60h */ case    8:  		/* bc 12, CR6_EQ, 140 */
		/* 82223A60h case    8:*/		if ( regs.CR[6].eq ) { return 0x82223AEC;  }
		/* 82223A60h case    8:*/		return 0x82223A64;
		  /* 82223A64h */ case    9:  		/* lwz R9, <#[R31]> */
		/* 82223A64h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82223A64h case    9:*/		return 0x82223A68;
		  /* 82223A68h */ case   10:  		/* rlwinm. R10, R9, 2, 31, 31 */
		/* 82223A68h case   10:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R9);
		/* 82223A68h case   10:*/		return 0x82223A6C;
		  /* 82223A6Ch */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 82223A6Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82223A7C;  }
		/* 82223A6Ch case   11:*/		return 0x82223A70;
		  /* 82223A70h */ case   12:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 82223A70h case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 82223A70h case   12:*/		return 0x82223A74;
		  /* 82223A74h */ case   13:  		/* li R11, 1 */
		/* 82223A74h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223A74h case   13:*/		return 0x82223A78;
		  /* 82223A78h */ case   14:  		/* bc 12, CR0_EQ, 8 */
		/* 82223A78h case   14:*/		if ( regs.CR[0].eq ) { return 0x82223A80;  }
		/* 82223A78h case   14:*/		return 0x82223A7C;
	}
	return 0x82223A7C;
} // Block from 82223A40h-82223A7Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82223A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223A7C);
		  /* 82223A7Ch */ case    0:  		/* li R11, 0 */
		/* 82223A7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223A7Ch case    0:*/		return 0x82223A80;
	}
	return 0x82223A80;
} // Block from 82223A7Ch-82223A80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223A80);
		  /* 82223A80h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223A80h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223A80h case    0:*/		return 0x82223A84;
		  /* 82223A84h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 82223A84h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223AD8;  }
		/* 82223A84h case    1:*/		return 0x82223A88;
		  /* 82223A88h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82223A88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82223A88h case    2:*/		return 0x82223A8C;
		  /* 82223A8Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82223A8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82223A9C;  }
		/* 82223A8Ch case    3:*/		return 0x82223A90;
		  /* 82223A90h */ case    4:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 82223A90h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 82223A90h case    4:*/		return 0x82223A94;
		  /* 82223A94h */ case    5:  		/* li R11, 1 */
		/* 82223A94h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223A94h case    5:*/		return 0x82223A98;
		  /* 82223A98h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 82223A98h case    6:*/		if ( regs.CR[0].eq ) { return 0x82223AA0;  }
		/* 82223A98h case    6:*/		return 0x82223A9C;
	}
	return 0x82223A9C;
} // Block from 82223A80h-82223A9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82223A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223A9C);
		  /* 82223A9Ch */ case    0:  		/* li R11, 0 */
		/* 82223A9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223A9Ch case    0:*/		return 0x82223AA0;
	}
	return 0x82223AA0;
} // Block from 82223A9Ch-82223AA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223AA0);
		  /* 82223AA0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223AA0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223AA0h case    0:*/		return 0x82223AA4;
		  /* 82223AA4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223AA4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223AB4;  }
		/* 82223AA4h case    1:*/		return 0x82223AA8;
		  /* 82223AA8h */ case    2:  		/* rlwinm. R11, R9, 0, 7, 18 */
		/* 82223AA8h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R9);
		/* 82223AA8h case    2:*/		return 0x82223AAC;
		  /* 82223AACh */ case    3:  		/* li R11, 1 */
		/* 82223AACh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223AACh case    3:*/		return 0x82223AB0;
		  /* 82223AB0h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82223AB0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82223AB8;  }
		/* 82223AB0h case    4:*/		return 0x82223AB4;
	}
	return 0x82223AB4;
} // Block from 82223AA0h-82223AB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223AB4);
		  /* 82223AB4h */ case    0:  		/* li R11, 0 */
		/* 82223AB4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223AB4h case    0:*/		return 0x82223AB8;
	}
	return 0x82223AB8;
} // Block from 82223AB4h-82223AB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223AB8);
		  /* 82223AB8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223AB8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223AB8h case    0:*/		return 0x82223ABC;
		  /* 82223ABCh */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82223ABCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82223AD8;  }
		/* 82223ABCh case    1:*/		return 0x82223AC0;
	}
	return 0x82223AC0;
} // Block from 82223AB8h-82223AC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223AC0h
// Function '?EncodeTexture@Instruction@D3DXShader@@QAAXPATGPUTEXTURE_FETCH_INSTRUCTION@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223AC0);
		  /* 82223AC0h */ case    0:  		/* rlwinm R11, R9, 19, 20, 31 */
		/* 82223AC0h case    0:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R9);
		/* 82223AC0h case    0:*/		return 0x82223AC4;
		  /* 82223AC4h */ case    1:  		/* lwz R3, <#[R27 + 28]> */
		/* 82223AC4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000001C) );
		/* 82223AC4h case    1:*/		return 0x82223AC8;
		  /* 82223AC8h */ case    2:  		/* mr R6, R26 */
		/* 82223AC8h case    2:*/		regs.R6 = regs.R26;
		/* 82223AC8h case    2:*/		return 0x82223ACC;
		  /* 82223ACCh */ case    3:  		/* mr R5, R27 */
		/* 82223ACCh case    3:*/		regs.R5 = regs.R27;
		/* 82223ACCh case    3:*/		return 0x82223AD0;
		  /* 82223AD0h */ case    4:  		/* addi R4, R11, -1 */
		/* 82223AD0h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 82223AD0h case    4:*/		return 0x82223AD4;
		  /* 82223AD4h */ case    5:  		/* bl 49340 */
		/* 82223AD4h case    5:*/		regs.LR = 0x82223AD8; return 0x8222FB90;
		/* 82223AD4h case    5:*/		return 0x82223AD8;
	}
	return 0x82223AD8;
} // Block from 82223AC0h-82223AD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82223AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223AD8);
		  /* 82223AD8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82223AD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82223AD8h case    0:*/		return 0x82223ADC;
		  /* 82223ADCh */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82223ADCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82223ADCh case    1:*/		return 0x82223AE0;
		  /* 82223AE0h */ case    2:  		/* bc 4, CR6_EQ, -136 */
		/* 82223AE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82223A58;  }
		/* 82223AE0h case    2:*/		return 0x82223AE4;
		  /* 82223AE4h */ case    3:  		/* addi R30, R31, 4 */
		/* 82223AE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 82223AE4h case    3:*/		return 0x82223AE8;
		  /* 82223AE8h */ case    4:  		/* b -144 */
		/* 82223AE8h case    4:*/		return 0x82223A58;
		/* 82223AE8h case    4:*/		return 0x82223AEC;
	}
	return 0x82223AEC;
} // Block from 82223AD8h-82223AECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223AEC);
		  /* 82223AECh */ case    0:  		/* addi R28, R27, 4 */
		/* 82223AECh case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x4);
		/* 82223AECh case    0:*/		return 0x82223AF0;
		  /* 82223AF0h */ case    1:  		/* mr R30, R28 */
		/* 82223AF0h case    1:*/		regs.R30 = regs.R28;
		/* 82223AF0h case    1:*/		return 0x82223AF4;
		  /* 82223AF4h */ case    2:  		/* lwz R31, <#[R30]> */
		/* 82223AF4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82223AF4h case    2:*/		return 0x82223AF8;
		  /* 82223AF8h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82223AF8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82223AF8h case    3:*/		return 0x82223AFC;
		  /* 82223AFCh */ case    4:  		/* bc 12, CR6_EQ, 152 */
		/* 82223AFCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82223B94;  }
		/* 82223AFCh case    4:*/		return 0x82223B00;
		  /* 82223B00h */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 82223B00h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82223B00h case    5:*/		return 0x82223B04;
		  /* 82223B04h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82223B04h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82223B04h case    6:*/		return 0x82223B08;
		  /* 82223B08h */ case    7:  		/* bc 12, CR6_EQ, 120 */
		/* 82223B08h case    7:*/		if ( regs.CR[6].eq ) { return 0x82223B80;  }
		/* 82223B08h case    7:*/		return 0x82223B0C;
		  /* 82223B0Ch */ case    8:  		/* lwz R9, <#[R31]> */
		/* 82223B0Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82223B0Ch case    8:*/		return 0x82223B10;
		  /* 82223B10h */ case    9:  		/* rlwinm. R10, R9, 2, 31, 31 */
		/* 82223B10h case    9:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R9);
		/* 82223B10h case    9:*/		return 0x82223B14;
		  /* 82223B14h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 82223B14h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82223B24;  }
		/* 82223B14h case   10:*/		return 0x82223B18;
		  /* 82223B18h */ case   11:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 82223B18h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 82223B18h case   11:*/		return 0x82223B1C;
		  /* 82223B1Ch */ case   12:  		/* li R11, 1 */
		/* 82223B1Ch case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223B1Ch case   12:*/		return 0x82223B20;
		  /* 82223B20h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 82223B20h case   13:*/		if ( regs.CR[0].eq ) { return 0x82223B28;  }
		/* 82223B20h case   13:*/		return 0x82223B24;
	}
	return 0x82223B24;
} // Block from 82223AECh-82223B24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82223B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B24);
		  /* 82223B24h */ case    0:  		/* li R11, 0 */
		/* 82223B24h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223B24h case    0:*/		return 0x82223B28;
	}
	return 0x82223B28;
} // Block from 82223B24h-82223B28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B28);
		  /* 82223B28h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223B28h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223B28h case    0:*/		return 0x82223B2C;
		  /* 82223B2Ch */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 82223B2Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82223B80;  }
		/* 82223B2Ch case    1:*/		return 0x82223B30;
		  /* 82223B30h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82223B30h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82223B30h case    2:*/		return 0x82223B34;
		  /* 82223B34h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82223B34h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82223B44;  }
		/* 82223B34h case    3:*/		return 0x82223B38;
		  /* 82223B38h */ case    4:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 82223B38h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 82223B38h case    4:*/		return 0x82223B3C;
		  /* 82223B3Ch */ case    5:  		/* li R11, 1 */
		/* 82223B3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223B3Ch case    5:*/		return 0x82223B40;
		  /* 82223B40h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 82223B40h case    6:*/		if ( regs.CR[0].eq ) { return 0x82223B48;  }
		/* 82223B40h case    6:*/		return 0x82223B44;
	}
	return 0x82223B44;
} // Block from 82223B28h-82223B44h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82223B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B44);
		  /* 82223B44h */ case    0:  		/* li R11, 0 */
		/* 82223B44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223B44h case    0:*/		return 0x82223B48;
	}
	return 0x82223B48;
} // Block from 82223B44h-82223B48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B48);
		  /* 82223B48h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223B48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223B48h case    0:*/		return 0x82223B4C;
		  /* 82223B4Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223B4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82223B5C;  }
		/* 82223B4Ch case    1:*/		return 0x82223B50;
		  /* 82223B50h */ case    2:  		/* rlwinm. R11, R9, 0, 7, 18 */
		/* 82223B50h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R9);
		/* 82223B50h case    2:*/		return 0x82223B54;
		  /* 82223B54h */ case    3:  		/* li R11, 1 */
		/* 82223B54h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223B54h case    3:*/		return 0x82223B58;
		  /* 82223B58h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82223B58h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82223B60;  }
		/* 82223B58h case    4:*/		return 0x82223B5C;
	}
	return 0x82223B5C;
} // Block from 82223B48h-82223B5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B5C);
		  /* 82223B5Ch */ case    0:  		/* li R11, 0 */
		/* 82223B5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223B5Ch case    0:*/		return 0x82223B60;
	}
	return 0x82223B60;
} // Block from 82223B5Ch-82223B60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B60);
		  /* 82223B60h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223B60h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223B60h case    0:*/		return 0x82223B64;
		  /* 82223B64h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82223B64h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223B80;  }
		/* 82223B64h case    1:*/		return 0x82223B68;
		  /* 82223B68h */ case    2:  		/* rlwinm R11, R9, 19, 20, 31 */
		/* 82223B68h case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R9);
		/* 82223B68h case    2:*/		return 0x82223B6C;
		  /* 82223B6Ch */ case    3:  		/* lwz R3, <#[R27 + 28]> */
		/* 82223B6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x0000001C) );
		/* 82223B6Ch case    3:*/		return 0x82223B70;
		  /* 82223B70h */ case    4:  		/* mr R6, R26 */
		/* 82223B70h case    4:*/		regs.R6 = regs.R26;
		/* 82223B70h case    4:*/		return 0x82223B74;
		  /* 82223B74h */ case    5:  		/* mr R5, R27 */
		/* 82223B74h case    5:*/		regs.R5 = regs.R27;
		/* 82223B74h case    5:*/		return 0x82223B78;
		  /* 82223B78h */ case    6:  		/* addi R4, R11, -1 */
		/* 82223B78h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 82223B78h case    6:*/		return 0x82223B7C;
		  /* 82223B7Ch */ case    7:  		/* bl 49172 */
		/* 82223B7Ch case    7:*/		regs.LR = 0x82223B80; return 0x8222FB90;
		/* 82223B7Ch case    7:*/		return 0x82223B80;
	}
	return 0x82223B80;
} // Block from 82223B60h-82223B80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82223B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B80);
		  /* 82223B80h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82223B80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82223B80h case    0:*/		return 0x82223B84;
		  /* 82223B84h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82223B84h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82223B84h case    1:*/		return 0x82223B88;
		  /* 82223B88h */ case    2:  		/* bc 4, CR6_EQ, -148 */
		/* 82223B88h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82223AF4;  }
		/* 82223B88h case    2:*/		return 0x82223B8C;
		  /* 82223B8Ch */ case    3:  		/* addi R30, R31, 8 */
		/* 82223B8Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x8);
		/* 82223B8Ch case    3:*/		return 0x82223B90;
		  /* 82223B90h */ case    4:  		/* b -156 */
		/* 82223B90h case    4:*/		return 0x82223AF4;
		/* 82223B90h case    4:*/		return 0x82223B94;
	}
	return 0x82223B94;
} // Block from 82223B80h-82223B94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223B94);
		  /* 82223B94h */ case    0:  		/* lwz R30, <#[R27]> */
		/* 82223B94h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000000) );
		/* 82223B94h case    0:*/		return 0x82223B98;
		  /* 82223B98h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82223B98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82223B98h case    1:*/		return 0x82223B9C;
		  /* 82223B9Ch */ case    2:  		/* bc 12, CR6_EQ, 128 */
		/* 82223B9Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82223C1C;  }
		/* 82223B9Ch case    2:*/		return 0x82223BA0;
		  /* 82223BA0h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 82223BA0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82223BA0h case    3:*/		return 0x82223BA4;
		  /* 82223BA4h */ case    4:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82223BA4h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82223BA4h case    4:*/		return 0x82223BA8;
		  /* 82223BA8h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82223BA8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82223BB8;  }
		/* 82223BA8h case    5:*/		return 0x82223BAC;
		  /* 82223BACh */ case    6:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82223BACh case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82223BACh case    6:*/		return 0x82223BB0;
		  /* 82223BB0h */ case    7:  		/* li R11, 1 */
		/* 82223BB0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223BB0h case    7:*/		return 0x82223BB4;
		  /* 82223BB4h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82223BB4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82223BBC;  }
		/* 82223BB4h case    8:*/		return 0x82223BB8;
	}
	return 0x82223BB8;
} // Block from 82223B94h-82223BB8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82223BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223BB8);
		  /* 82223BB8h */ case    0:  		/* li R11, 0 */
		/* 82223BB8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223BB8h case    0:*/		return 0x82223BBC;
	}
	return 0x82223BBC;
} // Block from 82223BB8h-82223BBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223BBC);
		  /* 82223BBCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223BBCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223BBCh case    0:*/		return 0x82223BC0;
		  /* 82223BC0h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 82223BC0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223C14;  }
		/* 82223BC0h case    1:*/		return 0x82223BC4;
		  /* 82223BC4h */ case    2:  		/* lwz R31, <#[R28]> */
		/* 82223BC4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 82223BC4h case    2:*/		return 0x82223BC8;
		  /* 82223BC8h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82223BC8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82223BC8h case    3:*/		return 0x82223BCC;
		  /* 82223BCCh */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 82223BCCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82223C14;  }
		/* 82223BCCh case    4:*/		return 0x82223BD0;
		  /* 82223BD0h */ case    5:  		/* lwz R3, <#[R31 + 16]> */
		/* 82223BD0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82223BD0h case    5:*/		return 0x82223BD4;
		  /* 82223BD4h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 82223BD4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82223BD4h case    6:*/		return 0x82223BD8;
		  /* 82223BD8h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 82223BD8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82223C0C;  }
		/* 82223BD8h case    7:*/		return 0x82223BDC;
		  /* 82223BDCh */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82223BDCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223BDCh case    8:*/		return 0x82223BE0;
		  /* 82223BE0h */ case    9:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82223BE0h case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82223BE0h case    9:*/		return 0x82223BE4;
		  /* 82223BE4h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 82223BE4h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82223BF4;  }
		/* 82223BE4h case   10:*/		return 0x82223BE8;
		  /* 82223BE8h */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82223BE8h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82223BE8h case   11:*/		return 0x82223BEC;
		  /* 82223BECh */ case   12:  		/* li R11, 1 */
		/* 82223BECh case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223BECh case   12:*/		return 0x82223BF0;
		  /* 82223BF0h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 82223BF0h case   13:*/		if ( regs.CR[0].eq ) { return 0x82223BF8;  }
		/* 82223BF0h case   13:*/		return 0x82223BF4;
	}
	return 0x82223BF4;
} // Block from 82223BBCh-82223BF4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82223BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223BF4);
		  /* 82223BF4h */ case    0:  		/* li R11, 0 */
		/* 82223BF4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223BF4h case    0:*/		return 0x82223BF8;
	}
	return 0x82223BF8;
} // Block from 82223BF4h-82223BF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223BF8);
		  /* 82223BF8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223BF8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223BF8h case    0:*/		return 0x82223BFC;
		  /* 82223BFCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82223BFCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82223C0C;  }
		/* 82223BFCh case    1:*/		return 0x82223C00;
		  /* 82223C00h */ case    2:  		/* mr R5, R26 */
		/* 82223C00h case    2:*/		regs.R5 = regs.R26;
		/* 82223C00h case    2:*/		return 0x82223C04;
		  /* 82223C04h */ case    3:  		/* lwz R4, <#[R30 + 12]> */
		/* 82223C04h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82223C04h case    3:*/		return 0x82223C08;
		  /* 82223C08h */ case    4:  		/* bl -702840 */
		/* 82223C08h case    4:*/		regs.LR = 0x82223C0C; return 0x82178290;
		/* 82223C08h case    4:*/		return 0x82223C0C;
	}
	return 0x82223C0C;
} // Block from 82223BF8h-82223C0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C0C);
		  /* 82223C0Ch */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82223C0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82223C0Ch case    0:*/		return 0x82223C10;
		  /* 82223C10h */ case    1:  		/* b -72 */
		/* 82223C10h case    1:*/		return 0x82223BC8;
		/* 82223C10h case    1:*/		return 0x82223C14;
	}
	return 0x82223C14;
} // Block from 82223C0Ch-82223C14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C14);
		  /* 82223C14h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82223C14h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82223C14h case    0:*/		return 0x82223C18;
		  /* 82223C18h */ case    1:  		/* b -128 */
		/* 82223C18h case    1:*/		return 0x82223B98;
		/* 82223C18h case    1:*/		return 0x82223C1C;
	}
	return 0x82223C1C;
} // Block from 82223C14h-82223C1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C1C);
		  /* 82223C1Ch */ case    0:  		/* lwz R30, <#[R28]> */
		/* 82223C1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 82223C1Ch case    0:*/		return 0x82223C20;
		  /* 82223C20h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82223C20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82223C20h case    1:*/		return 0x82223C24;
		  /* 82223C24h */ case    2:  		/* bc 12, CR6_EQ, 160 */
		/* 82223C24h case    2:*/		if ( regs.CR[6].eq ) { return 0x82223CC4;  }
		/* 82223C24h case    2:*/		return 0x82223C28;
		  /* 82223C28h */ case    3:  		/* lwz R29, <#[R30 + 16]> */
		/* 82223C28h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000010) );
		/* 82223C28h case    3:*/		return 0x82223C2C;
		  /* 82223C2Ch */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82223C2Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82223C2Ch case    4:*/		return 0x82223C30;
		  /* 82223C30h */ case    5:  		/* bc 12, CR6_EQ, 128 */
		/* 82223C30h case    5:*/		if ( regs.CR[6].eq ) { return 0x82223CB0;  }
		/* 82223C30h case    5:*/		return 0x82223C34;
		  /* 82223C34h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 82223C34h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82223C34h case    6:*/		return 0x82223C38;
		  /* 82223C38h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82223C38h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82223C38h case    7:*/		return 0x82223C3C;
		  /* 82223C3Ch */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 82223C3Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x82223C4C;  }
		/* 82223C3Ch case    8:*/		return 0x82223C40;
		  /* 82223C40h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82223C40h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82223C40h case    9:*/		return 0x82223C44;
		  /* 82223C44h */ case   10:  		/* li R11, 1 */
		/* 82223C44h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223C44h case   10:*/		return 0x82223C48;
		  /* 82223C48h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82223C48h case   11:*/		if ( regs.CR[0].eq ) { return 0x82223C50;  }
		/* 82223C48h case   11:*/		return 0x82223C4C;
	}
	return 0x82223C4C;
} // Block from 82223C1Ch-82223C4Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82223C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C4C);
		  /* 82223C4Ch */ case    0:  		/* li R11, 0 */
		/* 82223C4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223C4Ch case    0:*/		return 0x82223C50;
	}
	return 0x82223C50;
} // Block from 82223C4Ch-82223C50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C50);
		  /* 82223C50h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223C50h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223C50h case    0:*/		return 0x82223C54;
		  /* 82223C54h */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 82223C54h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223CB0;  }
		/* 82223C54h case    1:*/		return 0x82223C58;
		  /* 82223C58h */ case    2:  		/* lwz R31, <#[R27]> */
		/* 82223C58h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x00000000) );
		/* 82223C58h case    2:*/		return 0x82223C5C;
		  /* 82223C5Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82223C5Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82223C5Ch case    3:*/		return 0x82223C60;
		  /* 82223C60h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 82223C60h case    4:*/		if ( regs.CR[6].eq ) { return 0x82223CA0;  }
		/* 82223C60h case    4:*/		return 0x82223C64;
		  /* 82223C64h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 82223C64h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82223C64h case    5:*/		return 0x82223C68;
		  /* 82223C68h */ case    6:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82223C68h case    6:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82223C68h case    6:*/		return 0x82223C6C;
		  /* 82223C6Ch */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 82223C6Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82223C7C;  }
		/* 82223C6Ch case    7:*/		return 0x82223C70;
		  /* 82223C70h */ case    8:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82223C70h case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82223C70h case    8:*/		return 0x82223C74;
		  /* 82223C74h */ case    9:  		/* li R11, 1 */
		/* 82223C74h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82223C74h case    9:*/		return 0x82223C78;
		  /* 82223C78h */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 82223C78h case   10:*/		if ( regs.CR[0].eq ) { return 0x82223C80;  }
		/* 82223C78h case   10:*/		return 0x82223C7C;
	}
	return 0x82223C7C;
} // Block from 82223C50h-82223C7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82223C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C7C);
		  /* 82223C7Ch */ case    0:  		/* li R11, 0 */
		/* 82223C7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82223C7Ch case    0:*/		return 0x82223C80;
	}
	return 0x82223C80;
} // Block from 82223C7Ch-82223C80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C80);
		  /* 82223C80h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82223C80h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82223C80h case    0:*/		return 0x82223C84;
		  /* 82223C84h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82223C84h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223C98;  }
		/* 82223C84h case    1:*/		return 0x82223C88;
		  /* 82223C88h */ case    2:  		/* mr R5, R26 */
		/* 82223C88h case    2:*/		regs.R5 = regs.R26;
		/* 82223C88h case    2:*/		return 0x82223C8C;
		  /* 82223C8Ch */ case    3:  		/* lwz R4, <#[R31 + 12]> */
		/* 82223C8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82223C8Ch case    3:*/		return 0x82223C90;
		  /* 82223C90h */ case    4:  		/* mr R3, R29 */
		/* 82223C90h case    4:*/		regs.R3 = regs.R29;
		/* 82223C90h case    4:*/		return 0x82223C94;
		  /* 82223C94h */ case    5:  		/* bl -702980 */
		/* 82223C94h case    5:*/		regs.LR = 0x82223C98; return 0x82178290;
		/* 82223C94h case    5:*/		return 0x82223C98;
	}
	return 0x82223C98;
} // Block from 82223C80h-82223C98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82223C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223C98);
		  /* 82223C98h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 82223C98h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 82223C98h case    0:*/		return 0x82223C9C;
		  /* 82223C9Ch */ case    1:  		/* b -64 */
		/* 82223C9Ch case    1:*/		return 0x82223C5C;
		/* 82223C9Ch case    1:*/		return 0x82223CA0;
	}
	return 0x82223CA0;
} // Block from 82223C98h-82223CA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223CA0);
		  /* 82223CA0h */ case    0:  		/* mr R5, R26 */
		/* 82223CA0h case    0:*/		regs.R5 = regs.R26;
		/* 82223CA0h case    0:*/		return 0x82223CA4;
		  /* 82223CA4h */ case    1:  		/* mr R4, R30 */
		/* 82223CA4h case    1:*/		regs.R4 = regs.R30;
		/* 82223CA4h case    1:*/		return 0x82223CA8;
		  /* 82223CA8h */ case    2:  		/* mr R3, R29 */
		/* 82223CA8h case    2:*/		regs.R3 = regs.R29;
		/* 82223CA8h case    2:*/		return 0x82223CAC;
		  /* 82223CACh */ case    3:  		/* bl -701340 */
		/* 82223CACh case    3:*/		regs.LR = 0x82223CB0; return 0x82178910;
		/* 82223CACh case    3:*/		return 0x82223CB0;
	}
	return 0x82223CB0;
} // Block from 82223CA0h-82223CB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82223CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223CB0);
		  /* 82223CB0h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82223CB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82223CB0h case    0:*/		return 0x82223CB4;
		  /* 82223CB4h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 82223CB4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82223CB4h case    1:*/		return 0x82223CB8;
		  /* 82223CB8h */ case    2:  		/* bc 4, CR6_EQ, -156 */
		/* 82223CB8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82223C1C;  }
		/* 82223CB8h case    2:*/		return 0x82223CBC;
		  /* 82223CBCh */ case    3:  		/* addi R28, R30, 8 */
		/* 82223CBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x8);
		/* 82223CBCh case    3:*/		return 0x82223CC0;
		  /* 82223CC0h */ case    4:  		/* b -164 */
		/* 82223CC0h case    4:*/		return 0x82223C1C;
		/* 82223CC0h case    4:*/		return 0x82223CC4;
	}
	return 0x82223CC4;
} // Block from 82223CB0h-82223CC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223CC4);
		  /* 82223CC4h */ case    0:  		/* addi R1, R1, 144 */
		/* 82223CC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82223CC4h case    0:*/		return 0x82223CC8;
		  /* 82223CC8h */ case    1:  		/* b -1649192 */
		/* 82223CC8h case    1:*/		return 0x820912A0;
		/* 82223CC8h case    1:*/		return 0x82223CCC;
		  /* 82223CCCh */ case    2:  		/* nop */
		/* 82223CCCh case    2:*/		cpu::op::nop();
		/* 82223CCCh case    2:*/		return 0x82223CD0;
	}
	return 0x82223CD0;
} // Block from 82223CC4h-82223CD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223CD0);
		  /* 82223CD0h */ case    0:  		/* mfspr R12, LR */
		/* 82223CD0h case    0:*/		regs.R12 = regs.LR;
		/* 82223CD0h case    0:*/		return 0x82223CD4;
		  /* 82223CD4h */ case    1:  		/* bl -1649292 */
		/* 82223CD4h case    1:*/		regs.LR = 0x82223CD8; return 0x82091248;
		/* 82223CD4h case    1:*/		return 0x82223CD8;
		  /* 82223CD8h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 82223CD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 82223CD8h case    2:*/		return 0x82223CDC;
		  /* 82223CDCh */ case    3:  		/* mr R25, R4 */
		/* 82223CDCh case    3:*/		regs.R25 = regs.R4;
		/* 82223CDCh case    3:*/		return 0x82223CE0;
		  /* 82223CE0h */ case    4:  		/* mr R4, R5 */
		/* 82223CE0h case    4:*/		regs.R4 = regs.R5;
		/* 82223CE0h case    4:*/		return 0x82223CE4;
		  /* 82223CE4h */ case    5:  		/* mr R31, R3 */
		/* 82223CE4h case    5:*/		regs.R31 = regs.R3;
		/* 82223CE4h case    5:*/		return 0x82223CE8;
		  /* 82223CE8h */ case    6:  		/* mr R30, R5 */
		/* 82223CE8h case    6:*/		regs.R30 = regs.R5;
		/* 82223CE8h case    6:*/		return 0x82223CEC;
		  /* 82223CECh */ case    7:  		/* mr R24, R6 */
		/* 82223CECh case    7:*/		regs.R24 = regs.R6;
		/* 82223CECh case    7:*/		return 0x82223CF0;
		  /* 82223CF0h */ case    8:  		/* mr R29, R7 */
		/* 82223CF0h case    8:*/		regs.R29 = regs.R7;
		/* 82223CF0h case    8:*/		return 0x82223CF4;
		  /* 82223CF4h */ case    9:  		/* mr R27, R8 */
		/* 82223CF4h case    9:*/		regs.R27 = regs.R8;
		/* 82223CF4h case    9:*/		return 0x82223CF8;
		  /* 82223CF8h */ case   10:  		/* mr R26, R9 */
		/* 82223CF8h case   10:*/		regs.R26 = regs.R9;
		/* 82223CF8h case   10:*/		return 0x82223CFC;
		  /* 82223CFCh */ case   11:  		/* mr R28, R10 */
		/* 82223CFCh case   11:*/		regs.R28 = regs.R10;
		/* 82223CFCh case   11:*/		return 0x82223D00;
		  /* 82223D00h */ case   12:  		/* bl -228584 */
		/* 82223D00h case   12:*/		regs.LR = 0x82223D04; return 0x821EC018;
		/* 82223D00h case   12:*/		return 0x82223D04;
		  /* 82223D04h */ case   13:  		/* lwz R11, <#[R25 + 44]> */
		/* 82223D04h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000002C) );
		/* 82223D04h case   13:*/		return 0x82223D08;
		  /* 82223D08h */ case   14:  		/* li R6, 0 */
		/* 82223D08h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82223D08h case   14:*/		return 0x82223D0C;
		  /* 82223D0Ch */ case   15:  		/* lwz R25, <#[R3 + 24]> */
		/* 82223D0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R3 + 0x00000018) );
		/* 82223D0Ch case   15:*/		return 0x82223D10;
		  /* 82223D10h */ case   16:  		/* or R11, R11, R24 */
		/* 82223D10h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 82223D10h case   16:*/		return 0x82223D14;
		  /* 82223D14h */ case   17:  		/* rlwinm. R11, R11, 0, 11, 14 */
		/* 82223D14h case   17:*/		cpu::op::rlwinm<1,0,11,14>(regs,&regs.R11,regs.R11);
		/* 82223D14h case   17:*/		return 0x82223D18;
		  /* 82223D18h */ case   18:  		/* bc 12, CR0_EQ, 108 */
		/* 82223D18h case   18:*/		if ( regs.CR[0].eq ) { return 0x82223D84;  }
		/* 82223D18h case   18:*/		return 0x82223D1C;
		  /* 82223D1Ch */ case   19:  		/* mr R24, R11 */
		/* 82223D1Ch case   19:*/		regs.R24 = regs.R11;
		/* 82223D1Ch case   19:*/		return 0x82223D20;
		  /* 82223D20h */ case   20:  		/* addi R11, R24, -1 */
		/* 82223D20h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFFF);
		/* 82223D20h case   20:*/		return 0x82223D24;
		  /* 82223D24h */ case   21:  		/* lis R10, 2 */
		/* 82223D24h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 82223D24h case   21:*/		return 0x82223D28;
		  /* 82223D28h */ case   22:  		/* andc R11, R24, R11 */
		/* 82223D28h case   22:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 82223D28h case   22:*/		return 0x82223D2C;
		  /* 82223D2Ch */ case   23:  		/* subf R24, R11, R24 */
		/* 82223D2Ch case   23:*/		cpu::op::subf<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 82223D2Ch case   23:*/		return 0x82223D30;
		  /* 82223D30h */ case   24:  		/* cmplw CR6, R11, R10 */
		/* 82223D30h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82223D30h case   24:*/		return 0x82223D34;
		  /* 82223D34h */ case   25:  		/* bc 12, CR6_EQ, 44 */
		/* 82223D34h case   25:*/		if ( regs.CR[6].eq ) { return 0x82223D60;  }
		/* 82223D34h case   25:*/		return 0x82223D38;
		  /* 82223D38h */ case   26:  		/* lis R10, 4 */
		/* 82223D38h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x4);
		/* 82223D38h case   26:*/		return 0x82223D3C;
		  /* 82223D3Ch */ case   27:  		/* cmplw CR6, R11, R10 */
		/* 82223D3Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82223D3Ch case   27:*/		return 0x82223D40;
		  /* 82223D40h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 82223D40h case   28:*/		if ( regs.CR[6].eq ) { return 0x82223D58;  }
		/* 82223D40h case   28:*/		return 0x82223D44;
		  /* 82223D44h */ case   29:  		/* lis R10, 8 */
		/* 82223D44h case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 82223D44h case   29:*/		return 0x82223D48;
		  /* 82223D48h */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 82223D48h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82223D48h case   30:*/		return 0x82223D4C;
		  /* 82223D4Ch */ case   31:  		/* bc 4, CR6_EQ, 196 */
		/* 82223D4Ch case   31:*/		if ( !regs.CR[6].eq ) { return 0x82223E10;  }
		/* 82223D4Ch case   31:*/		return 0x82223D50;
		  /* 82223D50h */ case   32:  		/* li R5, 2 */
		/* 82223D50h case   32:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82223D50h case   32:*/		return 0x82223D54;
		  /* 82223D54h */ case   33:  		/* b 16 */
		/* 82223D54h case   33:*/		return 0x82223D64;
		/* 82223D54h case   33:*/		return 0x82223D58;
	}
	return 0x82223D58;
} // Block from 82223CD0h-82223D58h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82223D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223D58);
		  /* 82223D58h */ case    0:  		/* li R5, 1 */
		/* 82223D58h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82223D58h case    0:*/		return 0x82223D5C;
		  /* 82223D5Ch */ case    1:  		/* b 8 */
		/* 82223D5Ch case    1:*/		return 0x82223D64;
		/* 82223D5Ch case    1:*/		return 0x82223D60;
	}
	return 0x82223D60;
} // Block from 82223D58h-82223D60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223D60);
		  /* 82223D60h */ case    0:  		/* li R5, 0 */
		/* 82223D60h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82223D60h case    0:*/		return 0x82223D64;
	}
	return 0x82223D64;
} // Block from 82223D60h-82223D64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82223D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223D64);
		  /* 82223D64h */ case    0:  		/* mr R8, R29 */
		/* 82223D64h case    0:*/		regs.R8 = regs.R29;
		/* 82223D64h case    0:*/		return 0x82223D68;
		  /* 82223D68h */ case    1:  		/* mr R7, R30 */
		/* 82223D68h case    1:*/		regs.R7 = regs.R30;
		/* 82223D68h case    1:*/		return 0x82223D6C;
		  /* 82223D6Ch */ case    2:  		/* mr R4, R28 */
		/* 82223D6Ch case    2:*/		regs.R4 = regs.R28;
		/* 82223D6Ch case    2:*/		return 0x82223D70;
		  /* 82223D70h */ case    3:  		/* mr R3, R31 */
		/* 82223D70h case    3:*/		regs.R3 = regs.R31;
		/* 82223D70h case    3:*/		return 0x82223D74;
		  /* 82223D74h */ case    4:  		/* bl -11548 */
		/* 82223D74h case    4:*/		regs.LR = 0x82223D78; return 0x82221058;
		/* 82223D74h case    4:*/		return 0x82223D78;
		  /* 82223D78h */ case    5:  		/* mr R6, R3 */
		/* 82223D78h case    5:*/		regs.R6 = regs.R3;
		/* 82223D78h case    5:*/		return 0x82223D7C;
		  /* 82223D7Ch */ case    6:  		/* cmplwi CR6, R24, 0 */
		/* 82223D7Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82223D7Ch case    6:*/		return 0x82223D80;
		  /* 82223D80h */ case    7:  		/* bc 4, CR6_EQ, -96 */
		/* 82223D80h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82223D20;  }
		/* 82223D80h case    7:*/		return 0x82223D84;
	}
	return 0x82223D84;
} // Block from 82223D64h-82223D84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82223D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223D84);
		  /* 82223D84h */ case    0:  		/* lwz R3, <#[R1 + 356]> */
		/* 82223D84h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000164) );
		/* 82223D84h case    0:*/		return 0x82223D88;
		  /* 82223D88h */ case    1:  		/* mr R8, R6 */
		/* 82223D88h case    1:*/		regs.R8 = regs.R6;
		/* 82223D88h case    1:*/		return 0x82223D8C;
		  /* 82223D8Ch */ case    2:  		/* lwz R11, <#[R1 + 364]> */
		/* 82223D8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000016C) );
		/* 82223D8Ch case    2:*/		return 0x82223D90;
		  /* 82223D90h */ case    3:  		/* mr R10, R28 */
		/* 82223D90h case    3:*/		regs.R10 = regs.R28;
		/* 82223D90h case    3:*/		return 0x82223D94;
		  /* 82223D94h */ case    4:  		/* mr R9, R30 */
		/* 82223D94h case    4:*/		regs.R9 = regs.R30;
		/* 82223D94h case    4:*/		return 0x82223D98;
		  /* 82223D98h */ case    5:  		/* mr R7, R26 */
		/* 82223D98h case    5:*/		regs.R7 = regs.R26;
		/* 82223D98h case    5:*/		return 0x82223D9C;
		  /* 82223D9Ch */ case    6:  		/* mr R6, R27 */
		/* 82223D9Ch case    6:*/		regs.R6 = regs.R27;
		/* 82223D9Ch case    6:*/		return 0x82223DA0;
		  /* 82223DA0h */ case    7:  		/* stw R3, <#[R1 + 84]> */
		/* 82223DA0h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82223DA0h case    7:*/		return 0x82223DA4;
		  /* 82223DA4h */ case    8:  		/* mr R5, R29 */
		/* 82223DA4h case    8:*/		regs.R5 = regs.R29;
		/* 82223DA4h case    8:*/		return 0x82223DA8;
		  /* 82223DA8h */ case    9:  		/* mr R4, R25 */
		/* 82223DA8h case    9:*/		regs.R4 = regs.R25;
		/* 82223DA8h case    9:*/		return 0x82223DAC;
		  /* 82223DACh */ case   10:  		/* stw R11, <#[R1 + 92]> */
		/* 82223DACh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82223DACh case   10:*/		return 0x82223DB0;
		  /* 82223DB0h */ case   11:  		/* mr R3, R31 */
		/* 82223DB0h case   11:*/		regs.R3 = regs.R31;
		/* 82223DB0h case   11:*/		return 0x82223DB4;
		  /* 82223DB4h */ case   12:  		/* bl -6860 */
		/* 82223DB4h case   12:*/		regs.LR = 0x82223DB8; return 0x822222E8;
		/* 82223DB4h case   12:*/		return 0x82223DB8;
		  /* 82223DB8h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82223DB8h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82223DB8h case   13:*/		return 0x82223DBC;
		  /* 82223DBCh */ case   14:  		/* bc 4, CR0_EQ, 144 */
		/* 82223DBCh case   14:*/		if ( !regs.CR[0].eq ) { return 0x82223E4C;  }
		/* 82223DBCh case   14:*/		return 0x82223DC0;
		  /* 82223DC0h */ case   15:  		/* lwz R11, <#[R31 + 48]> */
		/* 82223DC0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82223DC0h case   15:*/		return 0x82223DC4;
		  /* 82223DC4h */ case   16:  		/* lis R10, -1 */
		/* 82223DC4h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82223DC4h case   16:*/		return 0x82223DC8;
		  /* 82223DC8h */ case   17:  		/* mr R6, R30 */
		/* 82223DC8h case   17:*/		regs.R6 = regs.R30;
		/* 82223DC8h case   17:*/		return 0x82223DCC;
		  /* 82223DCCh */ case   18:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82223DCCh case   18:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82223DCCh case   18:*/		return 0x82223DD0;
		  /* 82223DD0h */ case   19:  		/* mr R7, R29 */
		/* 82223DD0h case   19:*/		regs.R7 = regs.R29;
		/* 82223DD0h case   19:*/		return 0x82223DD4;
		  /* 82223DD4h */ case   20:  		/* subf R11, R10, R11 */
		/* 82223DD4h case   20:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82223DD4h case   20:*/		return 0x82223DD8;
		  /* 82223DD8h */ case   21:  		/* li R5, 100 */
		/* 82223DD8h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 82223DD8h case   21:*/		return 0x82223DDC;
		  /* 82223DDCh */ case   22:  		/* cntlzw R11, R11 */
		/* 82223DDCh case   22:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82223DDCh case   22:*/		return 0x82223DE0;
		  /* 82223DE0h */ case   23:  		/* addi R4, R1, 96 */
		/* 82223DE0h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82223DE0h case   23:*/		return 0x82223DE4;
		  /* 82223DE4h */ case   24:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82223DE4h case   24:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82223DE4h case   24:*/		return 0x82223DE8;
		  /* 82223DE8h */ case   25:  		/* mr R3, R31 */
		/* 82223DE8h case   25:*/		regs.R3 = regs.R31;
		/* 82223DE8h case   25:*/		return 0x82223DEC;
		  /* 82223DECh */ case   26:  		/* subfic R11, R11, 0 */
		/* 82223DECh case   26:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82223DECh case   26:*/		return 0x82223DF0;
		  /* 82223DF0h */ case   27:  		/* subfe R11, R11, R11 */
		/* 82223DF0h case   27:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82223DF0h case   27:*/		return 0x82223DF4;
		  /* 82223DF4h */ case   28:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82223DF4h case   28:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82223DF4h case   28:*/		return 0x82223DF8;
		  /* 82223DF8h */ case   29:  		/* addi R30, R11, 3524 */
		/* 82223DF8h case   29:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xDC4);
		/* 82223DF8h case   29:*/		return 0x82223DFC;
		  /* 82223DFCh */ case   30:  		/* bl -11980 */
		/* 82223DFCh case   30:*/		regs.LR = 0x82223E00; return 0x82220F30;
		/* 82223DFCh case   30:*/		return 0x82223E00;
		  /* 82223E00h */ case   31:  		/* addi R5, R1, 96 */
		/* 82223E00h case   31:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82223E00h case   31:*/		return 0x82223E04;
		  /* 82223E04h */ case   32:  		/* mr R4, R30 */
		/* 82223E04h case   32:*/		regs.R4 = regs.R30;
		/* 82223E04h case   32:*/		return 0x82223E08;
		  /* 82223E08h */ case   33:  		/* mr R3, R31 */
		/* 82223E08h case   33:*/		regs.R3 = regs.R31;
		/* 82223E08h case   33:*/		return 0x82223E0C;
		  /* 82223E0Ch */ case   34:  		/* bl -860068 */
		/* 82223E0Ch case   34:*/		regs.LR = 0x82223E10; return 0x82151E68;
		/* 82223E0Ch case   34:*/		return 0x82223E10;
	}
	return 0x82223E10;
} // Block from 82223D84h-82223E10h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82223E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223E10);
		  /* 82223E10h */ case    0:  		/* lis R10, 16 */
		/* 82223E10h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 82223E10h case    0:*/		return 0x82223E14;
		  /* 82223E14h */ case    1:  		/* mr R3, R31 */
		/* 82223E14h case    1:*/		regs.R3 = regs.R31;
		/* 82223E14h case    1:*/		return 0x82223E18;
		  /* 82223E18h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82223E18h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82223E18h case    2:*/		return 0x82223E1C;
		  /* 82223E1Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82223E1Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82223E28;  }
		/* 82223E1Ch case    3:*/		return 0x82223E20;
		  /* 82223E20h */ case    4:  		/* li R4, 4800 */
		/* 82223E20h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82223E20h case    4:*/		return 0x82223E24;
		  /* 82223E24h */ case    5:  		/* bl -860092 */
		/* 82223E24h case    5:*/		regs.LR = 0x82223E28; return 0x82151E68;
		/* 82223E24h case    5:*/		return 0x82223E28;
	}
	return 0x82223E28;
} // Block from 82223E10h-82223E28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82223E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223E28);
		  /* 82223E28h */ case    0:  		/* mr R7, R29 */
		/* 82223E28h case    0:*/		regs.R7 = regs.R29;
		/* 82223E28h case    0:*/		return 0x82223E2C;
		  /* 82223E2Ch */ case    1:  		/* mr R6, R30 */
		/* 82223E2Ch case    1:*/		regs.R6 = regs.R30;
		/* 82223E2Ch case    1:*/		return 0x82223E30;
		  /* 82223E30h */ case    2:  		/* li R5, 100 */
		/* 82223E30h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 82223E30h case    2:*/		return 0x82223E34;
		  /* 82223E34h */ case    3:  		/* addi R4, R1, 96 */
		/* 82223E34h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82223E34h case    3:*/		return 0x82223E38;
		  /* 82223E38h */ case    4:  		/* bl -12040 */
		/* 82223E38h case    4:*/		regs.LR = 0x82223E3C; return 0x82220F30;
		/* 82223E38h case    4:*/		return 0x82223E3C;
		  /* 82223E3Ch */ case    5:  		/* addi R5, R1, 96 */
		/* 82223E3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82223E3Ch case    5:*/		return 0x82223E40;
		  /* 82223E40h */ case    6:  		/* li R4, 3627 */
		/* 82223E40h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xE2B);
		/* 82223E40h case    6:*/		return 0x82223E44;
		  /* 82223E44h */ case    7:  		/* mr R3, R31 */
		/* 82223E44h case    7:*/		regs.R3 = regs.R31;
		/* 82223E44h case    7:*/		return 0x82223E48;
		  /* 82223E48h */ case    8:  		/* bl -860128 */
		/* 82223E48h case    8:*/		regs.LR = 0x82223E4C; return 0x82151E68;
		/* 82223E48h case    8:*/		return 0x82223E4C;
	}
	return 0x82223E4C;
} // Block from 82223E28h-82223E4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82223E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223E4C);
		  /* 82223E4Ch */ case    0:  		/* addi R1, R1, 272 */
		/* 82223E4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82223E4Ch case    0:*/		return 0x82223E50;
		  /* 82223E50h */ case    1:  		/* b -1649592 */
		/* 82223E50h case    1:*/		return 0x82091298;
		/* 82223E50h case    1:*/		return 0x82223E54;
		  /* 82223E54h */ case    2:  		/* nop */
		/* 82223E54h case    2:*/		cpu::op::nop();
		/* 82223E54h case    2:*/		return 0x82223E58;
	}
	return 0x82223E58;
} // Block from 82223E4Ch-82223E58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223E58);
		  /* 82223E58h */ case    0:  		/* mfspr R12, LR */
		/* 82223E58h case    0:*/		regs.R12 = regs.LR;
		/* 82223E58h case    0:*/		return 0x82223E5C;
		  /* 82223E5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82223E5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82223E5Ch case    1:*/		return 0x82223E60;
		  /* 82223E60h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82223E60h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82223E60h case    2:*/		return 0x82223E64;
		  /* 82223E64h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 82223E64h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82223E64h case    3:*/		return 0x82223E68;
		  /* 82223E68h */ case    4:  		/* stw R9, <#[R1 + 84]> */
		/* 82223E68h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82223E68h case    4:*/		return 0x82223E6C;
		  /* 82223E6Ch */ case    5:  		/* addi R9, R1, 96 */
		/* 82223E6Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 82223E6Ch case    5:*/		return 0x82223E70;
		  /* 82223E70h */ case    6:  		/* mr R31, R8 */
		/* 82223E70h case    6:*/		regs.R31 = regs.R8;
		/* 82223E70h case    6:*/		return 0x82223E74;
		  /* 82223E74h */ case    7:  		/* lis R11, -32216 */
		/* 82223E74h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82223E74h case    7:*/		return 0x82223E78;
		  /* 82223E78h */ case    8:  		/* stw R9, <#[R1 + 92]> */
		/* 82223E78h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82223E78h case    8:*/		return 0x82223E7C;
		  /* 82223E7Ch */ case    9:  		/* mr R10, R31 */
		/* 82223E7Ch case    9:*/		regs.R10 = regs.R31;
		/* 82223E7Ch case    9:*/		return 0x82223E80;
		  /* 82223E80h */ case   10:  		/* addi R8, R11, 10824 */
		/* 82223E80h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x2A48);
		/* 82223E80h case   10:*/		return 0x82223E84;
		  /* 82223E84h */ case   11:  		/* li R9, 20 */
		/* 82223E84h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 82223E84h case   11:*/		return 0x82223E88;
		  /* 82223E88h */ case   12:  		/* bl -440 */
		/* 82223E88h case   12:*/		regs.LR = 0x82223E8C; return 0x82223CD0;
		/* 82223E88h case   12:*/		return 0x82223E8C;
		  /* 82223E8Ch */ case   13:  		/* lwz R11, <#[R31 + 4]> */
		/* 82223E8Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223E8Ch case   13:*/		return 0x82223E90;
		  /* 82223E90h */ case   14:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 82223E90h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 82223E90h case   14:*/		return 0x82223E94;
		  /* 82223E94h */ case   15:  		/* cmplwi CR6, R10, 10 */
		/* 82223E94h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000A);
		/* 82223E94h case   15:*/		return 0x82223E98;
		  /* 82223E98h */ case   16:  		/* bc 4, CR6_EQ, 28 */
		/* 82223E98h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82223EB4;  }
		/* 82223E98h case   16:*/		return 0x82223E9C;
		  /* 82223E9Ch */ case   17:  		/* lbz R10, <#[R1 + 96]> */
		/* 82223E9Ch case   17:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82223E9Ch case   17:*/		return 0x82223EA0;
		  /* 82223EA0h */ case   18:  		/* cmplwi CR0, R10, 0 */
		/* 82223EA0h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82223EA0h case   18:*/		return 0x82223EA4;
		  /* 82223EA4h */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 82223EA4h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82223EB4;  }
		/* 82223EA4h case   19:*/		return 0x82223EA8;
		  /* 82223EA8h */ case   20:  		/* li R10, 1 */
		/* 82223EA8h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82223EA8h case   20:*/		return 0x82223EAC;
		  /* 82223EACh */ case   21:  		/* rlwimi R11, R10, 14, 16, 17 */
		/* 82223EACh case   21:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R11,regs.R10);
		/* 82223EACh case   21:*/		return 0x82223EB0;
		  /* 82223EB0h */ case   22:  		/* stw R11, <#[R31 + 4]> */
		/* 82223EB0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82223EB0h case   22:*/		return 0x82223EB4;
	}
	return 0x82223EB4;
} // Block from 82223E58h-82223EB4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82223EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223EB4);
		  /* 82223EB4h */ case    0:  		/* addi R1, R1, 128 */
		/* 82223EB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82223EB4h case    0:*/		return 0x82223EB8;
		  /* 82223EB8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82223EB8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82223EB8h case    1:*/		return 0x82223EBC;
		  /* 82223EBCh */ case    2:  		/* mtspr LR, R12 */
		/* 82223EBCh case    2:*/		regs.LR = regs.R12;
		/* 82223EBCh case    2:*/		return 0x82223EC0;
		  /* 82223EC0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82223EC0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82223EC0h case    3:*/		return 0x82223EC4;
		  /* 82223EC4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82223EC4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82223EC4h case    4:*/		return 0x82223EC8;
	}
	return 0x82223EC8;
} // Block from 82223EB4h-82223EC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82223EC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223EC8);
		  /* 82223EC8h */ case    0:  		/* lwz R11, <#[R4 + 20]> */
		/* 82223EC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82223EC8h case    0:*/		return 0x82223ECC;
		  /* 82223ECCh */ case    1:  		/* li R7, 1 */
		/* 82223ECCh case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82223ECCh case    1:*/		return 0x82223ED0;
		  /* 82223ED0h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82223ED0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82223ED0h case    2:*/		return 0x82223ED4;
		  /* 82223ED4h */ case    3:  		/* bc 12, CR0_EQ, 40 */
		/* 82223ED4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82223EFC;  }
		/* 82223ED4h case    3:*/		return 0x82223ED8;
		  /* 82223ED8h */ case    4:  		/* lwz R11, <#[R4 + 28]> */
		/* 82223ED8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82223ED8h case    4:*/		return 0x82223EDC;
		  /* 82223EDCh */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82223EDCh case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82223EDCh case    5:*/		return 0x82223EE0;
		  /* 82223EE0h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82223EE0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82223EF0;  }
		/* 82223EE0h case    6:*/		return 0x82223EE4;
		  /* 82223EE4h */ case    7:  		/* lwz R11, <#[R4 + 36]> */
		/* 82223EE4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000024) );
		/* 82223EE4h case    7:*/		return 0x82223EE8;
	}
	return 0x82223EE8;
} // Block from 82223EC8h-82223EE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82223EE8h
// Function '?FindScalarOperandSourceWorker@Dependency@D3DXShader@@QAAXW4Component@2@PAPAVInstruction@2@PAW432@PAIPAVBlock@2@PAV42@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223EE8);
		  /* 82223EE8h */ case    0:  		/* addi R10, R4, 32 */
		/* 82223EE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 82223EE8h case    0:*/		return 0x82223EEC;
		  /* 82223EECh */ case    1:  		/* b 24 */
		/* 82223EECh case    1:*/		return 0x82223F04;
		/* 82223EECh case    1:*/		return 0x82223EF0;
	}
	return 0x82223EF0;
} // Block from 82223EE8h-82223EF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223EF0);
		  /* 82223EF0h */ case    0:  		/* lwz R11, <#[R4 + 28]> */
		/* 82223EF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82223EF0h case    0:*/		return 0x82223EF4;
		  /* 82223EF4h */ case    1:  		/* addi R10, R4, 24 */
		/* 82223EF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x18);
		/* 82223EF4h case    1:*/		return 0x82223EF8;
		  /* 82223EF8h */ case    2:  		/* b 12 */
		/* 82223EF8h case    2:*/		return 0x82223F04;
		/* 82223EF8h case    2:*/		return 0x82223EFC;
	}
	return 0x82223EFC;
} // Block from 82223EF0h-82223EFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223EFC);
		  /* 82223EFCh */ case    0:  		/* lwz R11, <#[R4 + 20]> */
		/* 82223EFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82223EFCh case    0:*/		return 0x82223F00;
		  /* 82223F00h */ case    1:  		/* addi R10, R4, 16 */
		/* 82223F00h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x10);
		/* 82223F00h case    1:*/		return 0x82223F04;
	}
	return 0x82223F04;
} // Block from 82223EFCh-82223F04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F04);
		  /* 82223F04h */ case    0:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 82223F04h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82223F04h case    0:*/		return 0x82223F08;
		  /* 82223F08h */ case    1:  		/* addic R9, R9, -1 */
		/* 82223F08h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82223F08h case    1:*/		return 0x82223F0C;
		  /* 82223F0Ch */ case    2:  		/* subfe R9, R9, R9 */
		/* 82223F0Ch case    2:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82223F0Ch case    2:*/		return 0x82223F10;
		  /* 82223F10h */ case    3:  		/* and R11, R9, R11 */
		/* 82223F10h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82223F10h case    3:*/		return 0x82223F14;
		  /* 82223F14h */ case    4:  		/* b 136 */
		/* 82223F14h case    4:*/		return 0x82223F9C;
		/* 82223F14h case    4:*/		return 0x82223F18;
		  /* 82223F18h */ case    5:  		/* lwz R9, <#[R11 + 20]> */
		/* 82223F18h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82223F18h case    5:*/		return 0x82223F1C;
		  /* 82223F1Ch */ case    6:  		/* lis R8, 8191 */
		/* 82223F1Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0x1FFF);
		/* 82223F1Ch case    6:*/		return 0x82223F20;
		  /* 82223F20h */ case    7:  		/* lwz R6, <#[R11 + 8]> */
		/* 82223F20h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 82223F20h case    7:*/		return 0x82223F24;
		  /* 82223F24h */ case    8:  		/* ori R8, R8, 65535 */
		/* 82223F24h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0xFFFF);
		/* 82223F24h case    8:*/		return 0x82223F28;
		  /* 82223F28h */ case    9:  		/* rlwimi R9, R7, 3, 0, 28 */
		/* 82223F28h case    9:*/		cpu::op::rlwimi<0,3,0,28>(regs,&regs.R9,regs.R7);
		/* 82223F28h case    9:*/		return 0x82223F2C;
		  /* 82223F2Ch */ case   10:  		/* oris R6, R6, 16384 */
		/* 82223F2Ch case   10:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x4000);
		/* 82223F2Ch case   10:*/		return 0x82223F30;
		  /* 82223F30h */ case   11:  		/* stw R9, <#[R11 + 20]> */
		/* 82223F30h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82223F30h case   11:*/		return 0x82223F34;
		  /* 82223F34h */ case   12:  		/* cmplw CR6, R7, R8 */
		/* 82223F34h case   12:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 82223F34h case   12:*/		return 0x82223F38;
		  /* 82223F38h */ case   13:  		/* stw R6, <#[R11 + 8]> */
		/* 82223F38h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000008) );
		/* 82223F38h case   13:*/		return 0x82223F3C;
		  /* 82223F3Ch */ case   14:  		/* bc 4, CR6_LT, 8 */
		/* 82223F3Ch case   14:*/		if ( !regs.CR[6].lt ) { return 0x82223F44;  }
		/* 82223F3Ch case   14:*/		return 0x82223F40;
		  /* 82223F40h */ case   15:  		/* addi R7, R7, 1 */
		/* 82223F40h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82223F40h case   15:*/		return 0x82223F44;
	}
	return 0x82223F44;
} // Block from 82223F04h-82223F44h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82223F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F44);
		  /* 82223F44h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82223F44h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82223F44h case    0:*/		return 0x82223F48;
		  /* 82223F48h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82223F48h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82223F48h case    1:*/		return 0x82223F4C;
		  /* 82223F4Ch */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82223F4Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82223F4Ch case    2:*/		return 0x82223F50;
		  /* 82223F50h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82223F50h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82223F5C;  }
		/* 82223F50h case    3:*/		return 0x82223F54;
		  /* 82223F54h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82223F54h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82223F54h case    4:*/		return 0x82223F58;
		  /* 82223F58h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 82223F58h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82223F18;  }
		/* 82223F58h case    5:*/		return 0x82223F5C;
	}
	return 0x82223F5C;
} // Block from 82223F44h-82223F5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82223F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F5C);
		  /* 82223F5Ch */ case    0:  		/* addi R8, R4, 32 */
		/* 82223F5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x20);
		/* 82223F5Ch case    0:*/		return 0x82223F60;
		  /* 82223F60h */ case    1:  		/* cmplw CR6, R10, R8 */
		/* 82223F60h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82223F60h case    1:*/		return 0x82223F64;
		  /* 82223F64h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 82223F64h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82223F64h case    2:*/		return 0x82223F68;
	}
	return 0x82223F68;
} // Block from 82223F5Ch-82223F68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F68);
		  /* 82223F68h */ case    0:  		/* addi R9, R4, 24 */
		/* 82223F68h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x18);
		/* 82223F68h case    0:*/		return 0x82223F6C;
		  /* 82223F6Ch */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 82223F6Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82223F6Ch case    1:*/		return 0x82223F70;
		  /* 82223F70h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82223F70h case    2:*/		if ( regs.CR[6].eq ) { return 0x82223F8C;  }
		/* 82223F70h case    2:*/		return 0x82223F74;
		  /* 82223F74h */ case    3:  		/* lwz R11, <#[R4 + 28]> */
		/* 82223F74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 82223F74h case    3:*/		return 0x82223F78;
		  /* 82223F78h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82223F78h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82223F78h case    4:*/		return 0x82223F7C;
		  /* 82223F7Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82223F7Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82223F8C;  }
		/* 82223F7Ch case    5:*/		return 0x82223F80;
		  /* 82223F80h */ case    6:  		/* lwz R11, <#[R9 + 4]> */
		/* 82223F80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82223F80h case    6:*/		return 0x82223F84;
		  /* 82223F84h */ case    7:  		/* mr R10, R9 */
		/* 82223F84h case    7:*/		regs.R10 = regs.R9;
		/* 82223F84h case    7:*/		return 0x82223F88;
		  /* 82223F88h */ case    8:  		/* b 12 */
		/* 82223F88h case    8:*/		return 0x82223F94;
		/* 82223F88h case    8:*/		return 0x82223F8C;
	}
	return 0x82223F8C;
} // Block from 82223F68h-82223F8Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82223F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F8C);
		  /* 82223F8Ch */ case    0:  		/* lwz R11, <#[R8 + 4]> */
		/* 82223F8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82223F8Ch case    0:*/		return 0x82223F90;
		  /* 82223F90h */ case    1:  		/* mr R10, R8 */
		/* 82223F90h case    1:*/		regs.R10 = regs.R8;
		/* 82223F90h case    1:*/		return 0x82223F94;
	}
	return 0x82223F94;
} // Block from 82223F8Ch-82223F94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F94);
		  /* 82223F94h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82223F94h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82223F94h case    0:*/		return 0x82223F98;
		  /* 82223F98h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 82223F98h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82223F98h case    1:*/		return 0x82223F9C;
	}
	return 0x82223F9C;
} // Block from 82223F94h-82223F9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82223F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223F9C);
		  /* 82223F9Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82223F9Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82223F9Ch case    0:*/		return 0x82223FA0;
		  /* 82223FA0h */ case    1:  		/* bc 4, CR6_EQ, -136 */
		/* 82223FA0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82223F18;  }
		/* 82223FA0h case    1:*/		return 0x82223FA4;
		  /* 82223FA4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82223FA4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82223FA4h case    2:*/		return 0x82223FA8;
	}
	return 0x82223FA8;
} // Block from 82223F9Ch-82223FA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82223FA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223FA8);
		  /* 82223FA8h */ case    0:  		/* mfspr R12, LR */
		/* 82223FA8h case    0:*/		regs.R12 = regs.LR;
		/* 82223FA8h case    0:*/		return 0x82223FAC;
		  /* 82223FACh */ case    1:  		/* bl -1650024 */
		/* 82223FACh case    1:*/		regs.LR = 0x82223FB0; return 0x82091244;
		/* 82223FACh case    1:*/		return 0x82223FB0;
		  /* 82223FB0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82223FB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82223FB0h case    2:*/		return 0x82223FB4;
		  /* 82223FB4h */ case    3:  		/* lwz R30, <#[R5 + 16]> */
		/* 82223FB4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R5 + 0x00000010) );
		/* 82223FB4h case    3:*/		return 0x82223FB8;
		  /* 82223FB8h */ case    4:  		/* mr R23, R3 */
		/* 82223FB8h case    4:*/		regs.R23 = regs.R3;
		/* 82223FB8h case    4:*/		return 0x82223FBC;
		  /* 82223FBCh */ case    5:  		/* mr R26, R4 */
		/* 82223FBCh case    5:*/		regs.R26 = regs.R4;
		/* 82223FBCh case    5:*/		return 0x82223FC0;
		  /* 82223FC0h */ case    6:  		/* mr R31, R5 */
		/* 82223FC0h case    6:*/		regs.R31 = regs.R5;
		/* 82223FC0h case    6:*/		return 0x82223FC4;
		  /* 82223FC4h */ case    7:  		/* mr R27, R6 */
		/* 82223FC4h case    7:*/		regs.R27 = regs.R6;
		/* 82223FC4h case    7:*/		return 0x82223FC8;
		  /* 82223FC8h */ case    8:  		/* mr R25, R7 */
		/* 82223FC8h case    8:*/		regs.R25 = regs.R7;
		/* 82223FC8h case    8:*/		return 0x82223FCC;
		  /* 82223FCCh */ case    9:  		/* mr R24, R8 */
		/* 82223FCCh case    9:*/		regs.R24 = regs.R8;
		/* 82223FCCh case    9:*/		return 0x82223FD0;
		  /* 82223FD0h */ case   10:  		/* rlwinm. R11, R8, 0, 28, 28 */
		/* 82223FD0h case   10:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R8);
		/* 82223FD0h case   10:*/		return 0x82223FD4;
		  /* 82223FD4h */ case   11:  		/* bc 12, CR0_EQ, 112 */
		/* 82223FD4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82224044;  }
		/* 82223FD4h case   11:*/		return 0x82223FD8;
		  /* 82223FD8h */ case   12:  		/* lwz R11, <#[R30 + 28]> */
		/* 82223FD8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82223FD8h case   12:*/		return 0x82223FDC;
		  /* 82223FDCh */ case   13:  		/* lwz R10, <#[R6 + 28]> */
		/* 82223FDCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000001C) );
		/* 82223FDCh case   13:*/		return 0x82223FE0;
		  /* 82223FE0h */ case   14:  		/* cmpw CR6, R11, R10 */
		/* 82223FE0h case   14:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82223FE0h case   14:*/		return 0x82223FE4;
		  /* 82223FE4h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82223FE4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82223FF0;  }
		/* 82223FE4h case   15:*/		return 0x82223FE8;
		  /* 82223FE8h */ case   16:  		/* li R3, 0 */
		/* 82223FE8h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82223FE8h case   16:*/		return 0x82223FEC;
		  /* 82223FECh */ case   17:  		/* b 800 */
		/* 82223FECh case   17:*/		return 0x8222430C;
		/* 82223FECh case   17:*/		return 0x82223FF0;
	}
	return 0x82223FF0;
} // Block from 82223FA8h-82223FF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82223FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82223FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82223FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82223FF0);
		  /* 82223FF0h */ case    0:  		/* mr R3, R26 */
		/* 82223FF0h case    0:*/		regs.R3 = regs.R26;
		/* 82223FF0h case    0:*/		return 0x82223FF4;
		  /* 82223FF4h */ case    1:  		/* bl -7716 */
		/* 82223FF4h case    1:*/		regs.LR = 0x82223FF8; return 0x822221D0;
		/* 82223FF4h case    1:*/		return 0x82223FF8;
		  /* 82223FF8h */ case    2:  		/* lwz R29, <#[R30]> */
		/* 82223FF8h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000000) );
		/* 82223FF8h case    2:*/		return 0x82223FFC;
		  /* 82223FFCh */ case    3:  		/* mr R28, R3 */
		/* 82223FFCh case    3:*/		regs.R28 = regs.R3;
		/* 82223FFCh case    3:*/		return 0x82224000;
		  /* 82224000h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82224000h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82224000h case    4:*/		return 0x82224004;
		  /* 82224004h */ case    5:  		/* bc 12, CR6_EQ, 64 */
		/* 82224004h case    5:*/		if ( regs.CR[6].eq ) { return 0x82224044;  }
		/* 82224004h case    5:*/		return 0x82224008;
		  /* 82224008h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82224008h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82224008h case    6:*/		return 0x8222400C;
		  /* 8222400Ch */ case    7:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 8222400Ch case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 8222400Ch case    7:*/		return 0x82224010;
		  /* 82224010h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82224010h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222401C;  }
		/* 82224010h case    8:*/		return 0x82224014;
		  /* 82224014h */ case    9:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82224014h case    9:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82224014h case    9:*/		return 0x82224018;
		  /* 82224018h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 82224018h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82224024;  }
		/* 82224018h case   10:*/		return 0x8222401C;
	}
	return 0x8222401C;
} // Block from 82223FF0h-8222401Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8222401Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222401C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222401C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222401C);
		  /* 8222401Ch */ case    0:  		/* lwz R29, <#[R29 + 4]> */
		/* 8222401Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 8222401Ch case    0:*/		return 0x82224020;
		  /* 82224020h */ case    1:  		/* b -32 */
		/* 82224020h case    1:*/		return 0x82224000;
		/* 82224020h case    1:*/		return 0x82224024;
	}
	return 0x82224024;
} // Block from 8222401Ch-82224024h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224024);
		  /* 82224024h */ case    0:  		/* mr R3, R30 */
		/* 82224024h case    0:*/		regs.R3 = regs.R30;
		/* 82224024h case    0:*/		return 0x82224028;
		  /* 82224028h */ case    1:  		/* bl -7768 */
		/* 82224028h case    1:*/		regs.LR = 0x8222402C; return 0x822221D0;
		/* 82224028h case    1:*/		return 0x8222402C;
		  /* 8222402Ch */ case    2:  		/* subf R11, R3, R28 */
		/* 8222402Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R28);
		/* 8222402Ch case    2:*/		return 0x82224030;
		  /* 82224030h */ case    3:  		/* subfic R11, R11, 0 */
		/* 82224030h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82224030h case    3:*/		return 0x82224034;
		  /* 82224034h */ case    4:  		/* subfe R11, R11, R11 */
		/* 82224034h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82224034h case    4:*/		return 0x82224038;
		  /* 82224038h */ case    5:  		/* and R11, R11, R29 */
		/* 82224038h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82224038h case    5:*/		return 0x8222403C;
		  /* 8222403Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8222403Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222403Ch case    6:*/		return 0x82224040;
		  /* 82224040h */ case    7:  		/* bc 4, CR6_EQ, -88 */
		/* 82224040h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 82224040h case    7:*/		return 0x82224044;
	}
	return 0x82224044;
} // Block from 82224024h-82224044h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82224044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224044);
		  /* 82224044h */ case    0:  		/* rlwinm. R11, R24, 0, 27, 27 */
		/* 82224044h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R24);
		/* 82224044h case    0:*/		return 0x82224048;
		  /* 82224048h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 82224048h case    1:*/		if ( regs.CR[0].eq ) { return 0x8222406C;  }
		/* 82224048h case    1:*/		return 0x8222404C;
		  /* 8222404Ch */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222404Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222404Ch case    2:*/		return 0x82224050;
		  /* 82224050h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82224050h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82224050h case    3:*/		return 0x82224054;
		  /* 82224054h */ case    4:  		/* cmplwi CR6, R11, 14336 */
		/* 82224054h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82224054h case    4:*/		return 0x82224058;
		  /* 82224058h */ case    5:  		/* bc 12, CR6_EQ, -112 */
		/* 82224058h case    5:*/		if ( regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 82224058h case    5:*/		return 0x8222405C;
		  /* 8222405Ch */ case    6:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222405Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222405Ch case    6:*/		return 0x82224060;
		  /* 82224060h */ case    7:  		/* lwz R10, <#[R26 + 28]> */
		/* 82224060h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000001C) );
		/* 82224060h case    7:*/		return 0x82224064;
		  /* 82224064h */ case    8:  		/* cmpw CR6, R11, R10 */
		/* 82224064h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82224064h case    8:*/		return 0x82224068;
		  /* 82224068h */ case    9:  		/* bc 4, CR6_EQ, -128 */
		/* 82224068h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 82224068h case    9:*/		return 0x8222406C;
	}
	return 0x8222406C;
} // Block from 82224044h-8222406Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222406Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222406C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222406C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222406C);
		  /* 8222406Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222406Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222406Ch case    0:*/		return 0x82224070;
		  /* 82224070h */ case    1:  		/* rlwinm R29, R11, 25, 25, 31 */
		/* 82224070h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R29,regs.R11);
		/* 82224070h case    1:*/		return 0x82224074;
		  /* 82224074h */ case    2:  		/* cmplwi CR6, R29, 112 */
		/* 82224074h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000070);
		/* 82224074h case    2:*/		return 0x82224078;
		  /* 82224078h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 82224078h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822240A8;  }
		/* 82224078h case    3:*/		return 0x8222407C;
		  /* 8222407Ch */ case    4:  		/* lwz R11, <#[R26 + 28]> */
		/* 8222407Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 8222407Ch case    4:*/		return 0x82224080;
		  /* 82224080h */ case    5:  		/* lwz R10, <#[R30 + 28]> */
		/* 82224080h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82224080h case    5:*/		return 0x82224084;
		  /* 82224084h */ case    6:  		/* cmpw CR6, R10, R11 */
		/* 82224084h case    6:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82224084h case    6:*/		return 0x82224088;
		  /* 82224088h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 82224088h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822240A8;  }
		/* 82224088h case    7:*/		return 0x8222408C;
		  /* 8222408Ch */ case    8:  		/* lwz R10, <#[R27 + 28]> */
		/* 8222408Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x0000001C) );
		/* 8222408Ch case    8:*/		return 0x82224090;
		  /* 82224090h */ case    9:  		/* cmpw CR6, R10, R11 */
		/* 82224090h case    9:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82224090h case    9:*/		return 0x82224094;
		  /* 82224094h */ case   10:  		/* bc 4, CR6_EQ, -172 */
		/* 82224094h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 82224094h case   10:*/		return 0x82224098;
		  /* 82224098h */ case   11:  		/* lwz R11, <#[R27 + 8]> */
		/* 82224098h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82224098h case   11:*/		return 0x8222409C;
		  /* 8222409Ch */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8222409Ch case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8222409Ch case   12:*/		return 0x822240A0;
		  /* 822240A0h */ case   13:  		/* cmplwi CR6, R11, 14336 */
		/* 822240A0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 822240A0h case   13:*/		return 0x822240A4;
		  /* 822240A4h */ case   14:  		/* bc 12, CR6_EQ, -188 */
		/* 822240A4h case   14:*/		if ( regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 822240A4h case   14:*/		return 0x822240A8;
	}
	return 0x822240A8;
} // Block from 8222406Ch-822240A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822240A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822240A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822240A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822240A8);
		  /* 822240A8h */ case    0:  		/* mr R5, R23 */
		/* 822240A8h case    0:*/		regs.R5 = regs.R23;
		/* 822240A8h case    0:*/		return 0x822240AC;
		  /* 822240ACh */ case    1:  		/* mr R4, R27 */
		/* 822240ACh case    1:*/		regs.R4 = regs.R27;
		/* 822240ACh case    1:*/		return 0x822240B0;
		  /* 822240B0h */ case    2:  		/* mr R3, R30 */
		/* 822240B0h case    2:*/		regs.R3 = regs.R30;
		/* 822240B0h case    2:*/		return 0x822240B4;
		  /* 822240B4h */ case    3:  		/* bl -418900 */
		/* 822240B4h case    3:*/		regs.LR = 0x822240B8; return 0x821BDC60;
		/* 822240B4h case    3:*/		return 0x822240B8;
		  /* 822240B8h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822240B8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822240B8h case    4:*/		return 0x822240BC;
		  /* 822240BCh */ case    5:  		/* bc 12, CR0_EQ, -212 */
		/* 822240BCh case    5:*/		if ( regs.CR[0].eq ) { return 0x82223FE8;  }
		/* 822240BCh case    5:*/		return 0x822240C0;
		  /* 822240C0h */ case    6:  		/* cmplwi CR6, R29, 112 */
		/* 822240C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000070);
		/* 822240C0h case    6:*/		return 0x822240C4;
		  /* 822240C4h */ case    7:  		/* bc 4, CR6_EQ, 288 */
		/* 822240C4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822241E4;  }
		/* 822240C4h case    7:*/		return 0x822240C8;
		  /* 822240C8h */ case    8:  		/* lwz R4, <#[R26 + 28]> */
		/* 822240C8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x0000001C) );
		/* 822240C8h case    8:*/		return 0x822240CC;
		  /* 822240CCh */ case    9:  		/* lwz R11, <#[R27 + 28]> */
		/* 822240CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 822240CCh case    9:*/		return 0x822240D0;
		  /* 822240D0h */ case   10:  		/* cmpw CR6, R11, R4 */
		/* 822240D0h case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R4);
		/* 822240D0h case   10:*/		return 0x822240D4;
		  /* 822240D4h */ case   11:  		/* bc 12, CR6_EQ, 272 */
		/* 822240D4h case   11:*/		if ( regs.CR[6].eq ) { return 0x822241E4;  }
		/* 822240D4h case   11:*/		return 0x822240D8;
		  /* 822240D8h */ case   12:  		/* lwz R11, <#[R23 + 4]> */
		/* 822240D8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 822240D8h case   12:*/		return 0x822240DC;
		  /* 822240DCh */ case   13:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 822240DCh case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 822240DCh case   13:*/		return 0x822240E0;
		  /* 822240E0h */ case   14:  		/* addic R10, R10, -1 */
		/* 822240E0h case   14:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 822240E0h case   14:*/		return 0x822240E4;
		  /* 822240E4h */ case   15:  		/* subfe R10, R10, R10 */
		/* 822240E4h case   15:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 822240E4h case   15:*/		return 0x822240E8;
		  /* 822240E8h */ case   16:  		/* and R11, R10, R11 */
		/* 822240E8h case   16:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822240E8h case   16:*/		return 0x822240EC;
		  /* 822240ECh */ case   17:  		/* cmplw CR6, R4, R11 */
		/* 822240ECh case   17:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 822240ECh case   17:*/		return 0x822240F0;
		  /* 822240F0h */ case   18:  		/* bc 12, CR6_EQ, -264 */
		/* 822240F0h case   18:*/		if ( regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 822240F0h case   18:*/		return 0x822240F4;
		  /* 822240F4h */ case   19:  		/* lwz R10, <#[R23 + 40]> */
		/* 822240F4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000028) );
		/* 822240F4h case   19:*/		return 0x822240F8;
		  /* 822240F8h */ case   20:  		/* rlwinm. R11, R10, 0, 17, 17 */
		/* 822240F8h case   20:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R11,regs.R10);
		/* 822240F8h case   20:*/		return 0x822240FC;
		  /* 822240FCh */ case   21:  		/* bc 12, CR0_EQ, 44 */
		/* 822240FCh case   21:*/		if ( regs.CR[0].eq ) { return 0x82224128;  }
		/* 822240FCh case   21:*/		return 0x82224100;
		  /* 82224100h */ case   22:  		/* lwz R11, <#[R27 + 8]> */
		/* 82224100h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82224100h case   22:*/		return 0x82224104;
		  /* 82224104h */ case   23:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82224104h case   23:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82224104h case   23:*/		return 0x82224108;
		  /* 82224108h */ case   24:  		/* cmplwi CR6, R11, 125 */
		/* 82224108h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82224108h case   24:*/		return 0x8222410C;
		  /* 8222410Ch */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 8222410Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x8222411C;  }
		/* 8222410Ch case   25:*/		return 0x82224110;
		  /* 82224110h */ case   26:  		/* cmplwi CR6, R11, 124 */
		/* 82224110h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82224110h case   26:*/		return 0x82224114;
		  /* 82224114h */ case   27:  		/* li R11, 0 */
		/* 82224114h case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82224114h case   27:*/		return 0x82224118;
		  /* 82224118h */ case   28:  		/* bc 4, CR6_EQ, 8 */
		/* 82224118h case   28:*/		if ( !regs.CR[6].eq ) { return 0x82224120;  }
		/* 82224118h case   28:*/		return 0x8222411C;
	}
	return 0x8222411C;
} // Block from 822240A8h-8222411Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 8222411Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222411C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222411C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222411C);
		  /* 8222411Ch */ case    0:  		/* li R11, 1 */
		/* 8222411Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222411Ch case    0:*/		return 0x82224120;
	}
	return 0x82224120;
} // Block from 8222411Ch-82224120h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82224120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224120);
		  /* 82224120h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82224120h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82224120h case    0:*/		return 0x82224124;
		  /* 82224124h */ case    1:  		/* bc 4, CR0_EQ, -316 */
		/* 82224124h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82223FE8;  }
		/* 82224124h case    1:*/		return 0x82224128;
	}
	return 0x82224128;
} // Block from 82224120h-82224128h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224128);
		  /* 82224128h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82224128h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224128h case    0:*/		return 0x8222412C;
		  /* 8222412Ch */ case    1:  		/* lwz R9, <#[R26 + 8]> */
		/* 8222412Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 8222412Ch case    1:*/		return 0x82224130;
		  /* 82224130h */ case    2:  		/* rlwinm R11, R11, 28, 29, 30 */
		/* 82224130h case    2:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R11,regs.R11);
		/* 82224130h case    2:*/		return 0x82224134;
		  /* 82224134h */ case    3:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82224134h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82224134h case    3:*/		return 0x82224138;
		  /* 82224138h */ case    4:  		/* srw R11, R25, R11 */
		/* 82224138h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 82224138h case    4:*/		return 0x8222413C;
		  /* 8222413Ch */ case    5:  		/* rlwinm R6, R11, 0, 30, 31 */
		/* 8222413Ch case    5:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R11);
		/* 8222413Ch case    5:*/		return 0x82224140;
		  /* 82224140h */ case    6:  		/* cmplwi CR6, R9, 14336 */
		/* 82224140h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003800);
		/* 82224140h case    6:*/		return 0x82224144;
		  /* 82224144h */ case    7:  		/* bc 4, CR6_EQ, 60 */
		/* 82224144h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82224180;  }
		/* 82224144h case    7:*/		return 0x82224148;
		  /* 82224148h */ case    8:  		/* lwz R11, <#[R26]> */
		/* 82224148h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82224148h case    8:*/		return 0x8222414C;
		  /* 8222414Ch */ case    9:  		/* lwz R9, <#[R11 + 4]> */
		/* 8222414Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8222414Ch case    9:*/		return 0x82224150;
		  /* 82224150h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 82224150h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82224150h case   10:*/		return 0x82224154;
		  /* 82224154h */ case   11:  		/* bc 4, CR6_EQ, 44 */
		/* 82224154h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82224180;  }
		/* 82224154h case   11:*/		return 0x82224158;
		  /* 82224158h */ case   12:  		/* lwz R9, <#[R11 + 12]> */
		/* 82224158h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82224158h case   12:*/		return 0x8222415C;
		  /* 8222415Ch */ case   13:  		/* cmplw CR6, R9, R27 */
		/* 8222415Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R27);
		/* 8222415Ch case   13:*/		return 0x82224160;
		  /* 82224160h */ case   14:  		/* bc 4, CR6_EQ, 32 */
		/* 82224160h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82224180;  }
		/* 82224160h case   14:*/		return 0x82224164;
		  /* 82224164h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 82224164h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82224164h case   15:*/		return 0x82224168;
		  /* 82224168h */ case   16:  		/* rlwinm R9, R11, 27, 30, 31 */
		/* 82224168h case   16:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R9,regs.R11);
		/* 82224168h case   16:*/		return 0x8222416C;
		  /* 8222416Ch */ case   17:  		/* cmpw CR6, R9, R6 */
		/* 8222416Ch case   17:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R6);
		/* 8222416Ch case   17:*/		return 0x82224170;
		  /* 82224170h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 82224170h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82224180;  }
		/* 82224170h case   18:*/		return 0x82224174;
		  /* 82224174h */ case   19:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82224174h case   19:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82224174h case   19:*/		return 0x82224178;
		  /* 82224178h */ case   20:  		/* cmplw CR6, R11, R24 */
		/* 82224178h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82224178h case   20:*/		return 0x8222417C;
		  /* 8222417Ch */ case   21:  		/* bc 12, CR6_EQ, -404 */
		/* 8222417Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 8222417Ch case   21:*/		return 0x82224180;
	}
	return 0x82224180;
} // Block from 82224128h-82224180h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82224180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224180);
		  /* 82224180h */ case    0:  		/* rlwinm R8, R10, 18, 31, 31 */
		/* 82224180h case    0:*/		cpu::op::rlwinm<0,18,31,31>(regs,&regs.R8,regs.R10);
		/* 82224180h case    0:*/		return 0x82224184;
		  /* 82224184h */ case    1:  		/* mr R7, R24 */
		/* 82224184h case    1:*/		regs.R7 = regs.R24;
		/* 82224184h case    1:*/		return 0x82224188;
		  /* 82224188h */ case    2:  		/* mr R5, R27 */
		/* 82224188h case    2:*/		regs.R5 = regs.R27;
		/* 82224188h case    2:*/		return 0x8222418C;
		  /* 8222418Ch */ case    3:  		/* mr R3, R23 */
		/* 8222418Ch case    3:*/		regs.R3 = regs.R23;
		/* 8222418Ch case    3:*/		return 0x82224190;
		  /* 82224190h */ case    4:  		/* bl -448768 */
		/* 82224190h case    4:*/		regs.LR = 0x82224194; return 0x821B6890;
		/* 82224190h case    4:*/		return 0x82224194;
		  /* 82224194h */ case    5:  		/* cmplw CR6, R26, R3 */
		/* 82224194h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 82224194h case    5:*/		return 0x82224198;
		  /* 82224198h */ case    6:  		/* bc 12, CR6_EQ, -432 */
		/* 82224198h case    6:*/		if ( regs.CR[6].eq ) { return 0x82223FE8;  }
		/* 82224198h case    6:*/		return 0x8222419C;
		  /* 8222419Ch */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8222419Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222419Ch case    7:*/		return 0x822241A0;
		  /* 822241A0h */ case    8:  		/* addi R11, R11, 4 */
		/* 822241A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822241A0h case    8:*/		return 0x822241A4;
		  /* 822241A4h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 822241A4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822241A4h case    9:*/		return 0x822241A8;
		  /* 822241A8h */ case   10:  		/* b 12 */
		/* 822241A8h case   10:*/		return 0x822241B4;
		/* 822241A8h case   10:*/		return 0x822241AC;
		  /* 822241ACh */ case   11:  		/* addi R11, R10, 8 */
		/* 822241ACh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 822241ACh case   11:*/		return 0x822241B0;
		  /* 822241B0h */ case   12:  		/* lwz R10, <#[R10 + 8]> */
		/* 822241B0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 822241B0h case   12:*/		return 0x822241B4;
	}
	return 0x822241B4;
} // Block from 82224180h-822241B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822241B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822241B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822241B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822241B4);
		  /* 822241B4h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 822241B4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 822241B4h case    0:*/		return 0x822241B8;
		  /* 822241B8h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 822241B8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822241AC;  }
		/* 822241B8h case    1:*/		return 0x822241BC;
		  /* 822241BCh */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 822241BCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822241BCh case    2:*/		return 0x822241C0;
		  /* 822241C0h */ case    3:  		/* li R9, 57 */
		/* 822241C0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x39);
		/* 822241C0h case    3:*/		return 0x822241C4;
		  /* 822241C4h */ case    4:  		/* stw R10, <#[R11]> */
		/* 822241C4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822241C4h case    4:*/		return 0x822241C8;
		  /* 822241C8h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 822241C8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822241C8h case    5:*/		return 0x822241CC;
		  /* 822241CCh */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 822241CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822241CCh case    6:*/		return 0x822241D0;
		  /* 822241D0h */ case    7:  		/* stw R31, <#[R3 + 4]> */
		/* 822241D0h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 822241D0h case    7:*/		return 0x822241D4;
		  /* 822241D4h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 822241D4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822241D4h case    8:*/		return 0x822241D8;
		  /* 822241D8h */ case    9:  		/* rlwimi R11, R9, 7, 19, 26 */
		/* 822241D8h case    9:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R9);
		/* 822241D8h case    9:*/		return 0x822241DC;
		  /* 822241DCh */ case   10:  		/* stw R3, <#[R31 + 12]> */
		/* 822241DCh case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 822241DCh case   10:*/		return 0x822241E0;
		  /* 822241E0h */ case   11:  		/* b 292 */
		/* 822241E0h case   11:*/		return 0x82224304;
		/* 822241E0h case   11:*/		return 0x822241E4;
	}
	return 0x822241E4;
} // Block from 822241B4h-822241E4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822241E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822241E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822241E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822241E4);
		  /* 822241E4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822241E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822241E4h case    0:*/		return 0x822241E8;
		  /* 822241E8h */ case    1:  		/* rlwinm. R10, R24, 0, 27, 28 */
		/* 822241E8h case    1:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R24);
		/* 822241E8h case    1:*/		return 0x822241EC;
		  /* 822241ECh */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 822241ECh case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 822241ECh case    2:*/		return 0x822241F0;
		  /* 822241F0h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 822241F0h case    3:*/		if ( regs.CR[0].eq ) { return 0x82224204;  }
		/* 822241F0h case    3:*/		return 0x822241F4;
		  /* 822241F4h */ case    4:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 822241F4h case    4:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 822241F4h case    4:*/		return 0x822241F8;
		  /* 822241F8h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 822241F8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82224204;  }
		/* 822241F8h case    5:*/		return 0x822241FC;
		  /* 822241FCh */ case    6:  		/* li R11, 0 */
		/* 822241FCh case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822241FCh case    6:*/		return 0x82224200;
		  /* 82224200h */ case    7:  		/* b 44 */
		/* 82224200h case    7:*/		return 0x8222422C;
		/* 82224200h case    7:*/		return 0x82224204;
	}
	return 0x82224204;
} // Block from 822241E4h-82224204h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82224204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224204);
		  /* 82224204h */ case    0:  		/* rlwinm. R10, R24, 0, 30, 30 */
		/* 82224204h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R24);
		/* 82224204h case    0:*/		return 0x82224208;
		  /* 82224208h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82224208h case    1:*/		if ( regs.CR[0].eq ) { return 0x82224214;  }
		/* 82224208h case    1:*/		return 0x8222420C;
		  /* 8222420Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8222420Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222420Ch case    2:*/		return 0x82224210;
		  /* 82224210h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 82224210h case    3:*/		if ( !regs.CR[0].eq ) { return 0x822241FC;  }
		/* 82224210h case    3:*/		return 0x82224214;
	}
	return 0x82224214;
} // Block from 82224204h-82224214h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82224214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224214);
		  /* 82224214h */ case    0:  		/* rlwinm. R10, R24, 0, 29, 29 */
		/* 82224214h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R24);
		/* 82224214h case    0:*/		return 0x82224218;
		  /* 82224218h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82224218h case    1:*/		if ( regs.CR[0].eq ) { return 0x82224228;  }
		/* 82224218h case    1:*/		return 0x8222421C;
		  /* 8222421Ch */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8222421Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8222421Ch case    2:*/		return 0x82224220;
		  /* 82224220h */ case    3:  		/* li R11, 0 */
		/* 82224220h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82224220h case    3:*/		return 0x82224224;
		  /* 82224224h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82224224h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8222422C;  }
		/* 82224224h case    4:*/		return 0x82224228;
	}
	return 0x82224228;
} // Block from 82224214h-82224228h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82224228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224228);
		  /* 82224228h */ case    0:  		/* li R11, 1 */
		/* 82224228h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82224228h case    0:*/		return 0x8222422C;
	}
	return 0x8222422C;
} // Block from 82224228h-8222422Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222422Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222422C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222422C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222422C);
		  /* 8222422Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8222422Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8222422Ch case    0:*/		return 0x82224230;
		  /* 82224230h */ case    1:  		/* bc 12, CR0_EQ, -584 */
		/* 82224230h case    1:*/		if ( regs.CR[0].eq ) { return 0x82223FE8;  }
		/* 82224230h case    1:*/		return 0x82224234;
		  /* 82224234h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82224234h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82224234h case    2:*/		return 0x82224238;
		  /* 82224238h */ case    3:  		/* addi R11, R11, 4 */
		/* 82224238h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82224238h case    3:*/		return 0x8222423C;
		  /* 8222423Ch */ case    4:  		/* lwz R10, <#[R11]> */
		/* 8222423Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222423Ch case    4:*/		return 0x82224240;
		  /* 82224240h */ case    5:  		/* b 12 */
		/* 82224240h case    5:*/		return 0x8222424C;
		/* 82224240h case    5:*/		return 0x82224244;
		  /* 82224244h */ case    6:  		/* addi R11, R10, 8 */
		/* 82224244h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82224244h case    6:*/		return 0x82224248;
		  /* 82224248h */ case    7:  		/* lwz R10, <#[R10 + 8]> */
		/* 82224248h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82224248h case    7:*/		return 0x8222424C;
	}
	return 0x8222424C;
} // Block from 8222422Ch-8222424Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222424Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222424C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222424C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222424C);
		  /* 8222424Ch */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8222424Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8222424Ch case    0:*/		return 0x82224250;
		  /* 82224250h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82224250h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82224244;  }
		/* 82224250h case    1:*/		return 0x82224254;
		  /* 82224254h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 82224254h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82224254h case    2:*/		return 0x82224258;
		  /* 82224258h */ case    3:  		/* rlwinm. R8, R24, 0, 29, 29 */
		/* 82224258h case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R8,regs.R24);
		/* 82224258h case    3:*/		return 0x8222425C;
		  /* 8222425Ch */ case    4:  		/* stw R9, <#[R11]> */
		/* 8222425Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222425Ch case    4:*/		return 0x82224260;
		  /* 82224260h */ case    5:  		/* mr R10, R24 */
		/* 82224260h case    5:*/		regs.R10 = regs.R24;
		/* 82224260h case    5:*/		return 0x82224264;
		  /* 82224264h */ case    6:  		/* lwz R11, <#[R27 + 4]> */
		/* 82224264h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82224264h case    6:*/		return 0x82224268;
		  /* 82224268h */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 82224268h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224268h case    7:*/		return 0x8222426C;
		  /* 8222426Ch */ case    8:  		/* stw R31, <#[R27 + 4]> */
		/* 8222426Ch case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x00000004) );
		/* 8222426Ch case    8:*/		return 0x82224270;
		  /* 82224270h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82224270h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224270h case    9:*/		return 0x82224274;
		  /* 82224274h */ case   10:  		/* mr R9, R11 */
		/* 82224274h case   10:*/		regs.R9 = regs.R11;
		/* 82224274h case   10:*/		return 0x82224278;
		  /* 82224278h */ case   11:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 82224278h case   11:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 82224278h case   11:*/		return 0x8222427C;
		  /* 8222427Ch */ case   12:  		/* stw R27, <#[R31 + 12]> */
		/* 8222427Ch case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222427Ch case   12:*/		return 0x82224280;
		  /* 82224280h */ case   13:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82224280h case   13:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82224280h case   13:*/		return 0x82224284;
		  /* 82224284h */ case   14:  		/* rlwinm R8, R9, 27, 29, 30 */
		/* 82224284h case   14:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R8,regs.R9);
		/* 82224284h case   14:*/		return 0x82224288;
		  /* 82224288h */ case   15:  		/* rlwinm R7, R9, 29, 29, 30 */
		/* 82224288h case   15:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R7,regs.R9);
		/* 82224288h case   15:*/		return 0x8222428C;
		  /* 8222428Ch */ case   16:  		/* srw R8, R25, R8 */
		/* 8222428Ch case   16:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R25,regs.R8);
		/* 8222428Ch case   16:*/		return 0x82224290;
		  /* 82224290h */ case   17:  		/* srw R7, R25, R7 */
		/* 82224290h case   17:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R25,regs.R7);
		/* 82224290h case   17:*/		return 0x82224294;
		  /* 82224294h */ case   18:  		/* rlwimi R7, R8, 2, 28, 29 */
		/* 82224294h case   18:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R8);
		/* 82224294h case   18:*/		return 0x82224298;
		  /* 82224298h */ case   19:  		/* rlwinm R8, R9, 31, 29, 30 */
		/* 82224298h case   19:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R8,regs.R9);
		/* 82224298h case   19:*/		return 0x8222429C;
		  /* 8222429Ch */ case   20:  		/* rlwinm R9, R9, 1, 29, 30 */
		/* 8222429Ch case   20:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R9,regs.R9);
		/* 8222429Ch case   20:*/		return 0x822242A0;
		  /* 822242A0h */ case   21:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 822242A0h case   21:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 822242A0h case   21:*/		return 0x822242A4;
		  /* 822242A4h */ case   22:  		/* srw R8, R25, R8 */
		/* 822242A4h case   22:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R25,regs.R8);
		/* 822242A4h case   22:*/		return 0x822242A8;
		  /* 822242A8h */ case   23:  		/* srw R9, R25, R9 */
		/* 822242A8h case   23:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R25,regs.R9);
		/* 822242A8h case   23:*/		return 0x822242AC;
		  /* 822242ACh */ case   24:  		/* rlwimi R8, R7, 2, 0, 29 */
		/* 822242ACh case   24:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R7);
		/* 822242ACh case   24:*/		return 0x822242B0;
		  /* 822242B0h */ case   25:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 822242B0h case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 822242B0h case   25:*/		return 0x822242B4;
		  /* 822242B4h */ case   26:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 822242B4h case   26:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 822242B4h case   26:*/		return 0x822242B8;
		  /* 822242B8h */ case   27:  		/* or R9, R9, R11 */
		/* 822242B8h case   27:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 822242B8h case   27:*/		return 0x822242BC;
		  /* 822242BCh */ case   28:  		/* stw R9, <#[R31]> */
		/* 822242BCh case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 822242BCh case   28:*/		return 0x822242C0;
		  /* 822242C0h */ case   29:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 822242C0h case   29:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 822242C0h case   29:*/		return 0x822242C4;
		  /* 822242C4h */ case   30:  		/* bc 12, CR0_EQ, 16 */
		/* 822242C4h case   30:*/		if ( regs.CR[0].eq ) { return 0x822242D4;  }
		/* 822242C4h case   30:*/		return 0x822242C8;
		  /* 822242C8h */ case   31:  		/* rlwinm. R8, R11, 0, 30, 30 */
		/* 822242C8h case   31:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R8,regs.R11);
		/* 822242C8h case   31:*/		return 0x822242CC;
		  /* 822242CCh */ case   32:  		/* bc 12, CR0_EQ, 8 */
		/* 822242CCh case   32:*/		if ( regs.CR[0].eq ) { return 0x822242D4;  }
		/* 822242CCh case   32:*/		return 0x822242D0;
		  /* 822242D0h */ case   33:  		/* addi R10, R24, -4 */
		/* 822242D0h case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0xFFFFFFFC);
		/* 822242D0h case   33:*/		return 0x822242D4;
	}
	return 0x822242D4;
} // Block from 8222424Ch-822242D4h (34 instructions)

//////////////////////////////////////////////////////
// Block at 822242D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822242D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822242D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822242D4);
		  /* 822242D4h */ case    0:  		/* and R8, R10, R11 */
		/* 822242D4h case    0:*/		cpu::op::and<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 822242D4h case    0:*/		return 0x822242D8;
		  /* 822242D8h */ case    1:  		/* rlwinm. R8, R8, 0, 29, 29 */
		/* 822242D8h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R8,regs.R8);
		/* 822242D8h case    1:*/		return 0x822242DC;
		  /* 822242DCh */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 822242DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x822242E8;  }
		/* 822242DCh case    2:*/		return 0x822242E0;
		  /* 822242E0h */ case    3:  		/* addi R10, R10, -4 */
		/* 822242E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 822242E0h case    3:*/		return 0x822242E4;
		  /* 822242E4h */ case    4:  		/* addi R11, R11, -4 */
		/* 822242E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 822242E4h case    4:*/		return 0x822242E8;
	}
	return 0x822242E8;
} // Block from 822242D4h-822242E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822242E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822242E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822242E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822242E8);
		  /* 822242E8h */ case    0:  		/* rlwinm. R8, R10, 0, 31, 31 */
		/* 822242E8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R10);
		/* 822242E8h case    0:*/		return 0x822242EC;
		  /* 822242ECh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822242ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x822242FC;  }
		/* 822242ECh case    1:*/		return 0x822242F0;
		  /* 822242F0h */ case    2:  		/* rlwinm. R8, R11, 0, 30, 30 */
		/* 822242F0h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R8,regs.R11);
		/* 822242F0h case    2:*/		return 0x822242F4;
		  /* 822242F4h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 822242F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x822242FC;  }
		/* 822242F4h case    3:*/		return 0x822242F8;
		  /* 822242F8h */ case    4:  		/* addi R11, R11, -2 */
		/* 822242F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 822242F8h case    4:*/		return 0x822242FC;
	}
	return 0x822242FC;
} // Block from 822242E8h-822242FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822242FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822242FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822242FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822242FC);
		  /* 822242FCh */ case    0:  		/* or R11, R10, R11 */
		/* 822242FCh case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822242FCh case    0:*/		return 0x82224300;
		  /* 82224300h */ case    1:  		/* rlwimi R11, R9, 0, 0, 26 */
		/* 82224300h case    1:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R11,regs.R9);
		/* 82224300h case    1:*/		return 0x82224304;
	}
	return 0x82224304;
} // Block from 822242FCh-82224304h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224304);
		  /* 82224304h */ case    0:  		/* stw R11, <#[R31]> */
		/* 82224304h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224304h case    0:*/		return 0x82224308;
		  /* 82224308h */ case    1:  		/* li R3, 1 */
		/* 82224308h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82224308h case    1:*/		return 0x8222430C;
	}
	return 0x8222430C;
} // Block from 82224304h-8222430Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222430Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222430C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222430C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222430C);
		  /* 8222430Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 8222430Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8222430Ch case    0:*/		return 0x82224310;
		  /* 82224310h */ case    1:  		/* b -1650812 */
		/* 82224310h case    1:*/		return 0x82091294;
		/* 82224310h case    1:*/		return 0x82224314;
		  /* 82224314h */ case    2:  		/* nop */
		/* 82224314h case    2:*/		cpu::op::nop();
		/* 82224314h case    2:*/		return 0x82224318;
	}
	return 0x82224318;
} // Block from 8222430Ch-82224318h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82224318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224318);
		  /* 82224318h */ case    0:  		/* mfspr R12, LR */
		/* 82224318h case    0:*/		regs.R12 = regs.LR;
		/* 82224318h case    0:*/		return 0x8222431C;
		  /* 8222431Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222431Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222431Ch case    1:*/		return 0x82224320;
		  /* 82224320h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82224320h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82224320h case    2:*/		return 0x82224324;
		  /* 82224324h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82224324h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82224324h case    3:*/		return 0x82224328;
		  /* 82224328h */ case    4:  		/* mr R31, R3 */
		/* 82224328h case    4:*/		regs.R31 = regs.R3;
		/* 82224328h case    4:*/		return 0x8222432C;
		  /* 8222432Ch */ case    5:  		/* rlwimi R8, R7, 5, 24, 26 */
		/* 8222432Ch case    5:*/		cpu::op::rlwimi<0,5,24,26>(regs,&regs.R8,regs.R7);
		/* 8222432Ch case    5:*/		return 0x82224330;
		  /* 82224330h */ case    6:  		/* mr R9, R6 */
		/* 82224330h case    6:*/		regs.R9 = regs.R6;
		/* 82224330h case    6:*/		return 0x82224334;
		  /* 82224334h */ case    7:  		/* andi. R10, R8, 231 */
		/* 82224334h case    7:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R8,0xE7);
		/* 82224334h case    7:*/		return 0x82224338;
		  /* 82224338h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 82224338h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224338h case    8:*/		return 0x8222433C;
		  /* 8222433Ch */ case    9:  		/* rlwimi R9, R10, 7, 0, 24 */
		/* 8222433Ch case    9:*/		cpu::op::rlwimi<0,7,0,24>(regs,&regs.R9,regs.R10);
		/* 8222433Ch case    9:*/		return 0x82224340;
		  /* 82224340h */ case   10:  		/* addi R10, R6, -5 */
		/* 82224340h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFB);
		/* 82224340h case   10:*/		return 0x82224344;
		  /* 82224344h */ case   11:  		/* stw R5, <#[R31 + 28]> */
		/* 82224344h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x0000001C) );
		/* 82224344h case   11:*/		return 0x82224348;
	}
	return 0x82224348;
} // Block from 82224318h-82224348h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82224348h
// Function '?IsAnyBitClear@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224348);
		  /* 82224348h */ case    0:  		/* rlwinm R11, R11, 0, 25, 14 */
		/* 82224348h case    0:*/		cpu::op::rlwinm<0,0,25,14>(regs,&regs.R11,regs.R11);
		/* 82224348h case    0:*/		return 0x8222434C;
		  /* 8222434Ch */ case    1:  		/* rlwinm R9, R9, 7, 0, 24 */
		/* 8222434Ch case    1:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R9,regs.R9);
		/* 8222434Ch case    1:*/		return 0x82224350;
		  /* 82224350h */ case    2:  		/* rlwinm R11, R11, 0, 13, 9 */
		/* 82224350h case    2:*/		cpu::op::rlwinm<0,0,13,9>(regs,&regs.R11,regs.R11);
		/* 82224350h case    2:*/		return 0x82224354;
		  /* 82224354h */ case    3:  		/* mr R3, R4 */
		/* 82224354h case    3:*/		regs.R3 = regs.R4;
		/* 82224354h case    3:*/		return 0x82224358;
		  /* 82224358h */ case    4:  		/* or R11, R9, R11 */
		/* 82224358h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82224358h case    4:*/		return 0x8222435C;
		  /* 8222435Ch */ case    5:  		/* cmplwi CR6, R10, 97 */
		/* 8222435Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000061);
		/* 8222435Ch case    5:*/		return 0x82224360;
		  /* 82224360h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 82224360h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224360h case    6:*/		return 0x82224364;
		  /* 82224364h */ case    7:  		/* bc 12, CR6_GT, 340 */
		/* 82224364h case    7:*/		if ( regs.CR[6].gt ) { return 0x822244B8;  }
		/* 82224364h case    7:*/		return 0x82224368;
		  /* 82224368h */ case    8:  		/* lis R12, -32252 */
		/* 82224368h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82224368h case    8:*/		return 0x8222436C;
		  /* 8222436Ch */ case    9:  		/* addi R12, R12, -640 */
		/* 8222436Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFD80);
		/* 8222436Ch case    9:*/		return 0x82224370;
		  /* 82224370h */ case   10:  		/* lbzx R0, <#[R12 + R10]> */
		/* 82224370h case   10:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R10 + 0x00000000) );
		/* 82224370h case   10:*/		return 0x82224374;
		  /* 82224374h */ case   11:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 82224374h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 82224374h case   11:*/		return 0x82224378;
		  /* 82224378h */ case   12:  		/* lis R12, -32222 */
		/* 82224378h case   12:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8222);
		/* 82224378h case   12:*/		return 0x8222437C;
		  /* 8222437Ch */ case   13:  		/* ori R0, R0, 0 */
		/* 8222437Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8222437Ch case   13:*/		return 0x82224380;
		  /* 82224380h */ case   14:  		/* addi R12, R12, 17296 */
		/* 82224380h case   14:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x4390);
		/* 82224380h case   14:*/		return 0x82224384;
		  /* 82224384h */ case   15:  		/* add R12, R12, R0 */
		/* 82224384h case   15:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82224384h case   15:*/		return 0x82224388;
		  /* 82224388h */ case   16:  		/* mtspr CTR, R12 */
		/* 82224388h case   16:*/		regs.CTR = regs.R12;
		/* 82224388h case   16:*/		return 0x8222438C;
		  /* 8222438Ch */ case   17:  		/* bcctr 20, CR0_LT */
		/* 8222438Ch case   17:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8222438Ch case   17:*/		return 0x82224390;
		  /* 82224390h */ case   18:  		/* lwz R11, <#[R31 + 12]> */
		/* 82224390h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82224390h case   18:*/		return 0x82224394;
		  /* 82224394h */ case   19:  		/* andi. R10, R11, 61166 */
		/* 82224394h case   19:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xEEEE);
		/* 82224394h case   19:*/		return 0x82224398;
		  /* 82224398h */ case   20:  		/* cmplwi CR6, R10, 61166 */
		/* 82224398h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000EEEE);
		/* 82224398h case   20:*/		return 0x8222439C;
		  /* 8222439Ch */ case   21:  		/* bc 12, CR6_EQ, 284 */
		/* 8222439Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x822244B8;  }
		/* 8222439Ch case   21:*/		return 0x822243A0;
		  /* 822243A0h */ case   22:  		/* ori R11, R11, 61166 */
		/* 822243A0h case   22:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xEEEE);
		/* 822243A0h case   22:*/		return 0x822243A4;
		  /* 822243A4h */ case   23:  		/* sth R11, <#[R31 + 14]> */
		/* 822243A4h case   23:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000000E) );
		/* 822243A4h case   23:*/		return 0x822243A8;
		  /* 822243A8h */ case   24:  		/* b 272 */
		/* 822243A8h case   24:*/		return 0x822244B8;
		/* 822243A8h case   24:*/		return 0x822243AC;
		  /* 822243ACh */ case   25:  		/* lwz R11, <#[R31 + 12]> */
		/* 822243ACh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822243ACh case   25:*/		return 0x822243B0;
		  /* 822243B0h */ case   26:  		/* andi. R10, R11, 17476 */
		/* 822243B0h case   26:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x4444);
		/* 822243B0h case   26:*/		return 0x822243B4;
		  /* 822243B4h */ case   27:  		/* cmplwi CR6, R10, 17476 */
		/* 822243B4h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00004444);
		/* 822243B4h case   27:*/		return 0x822243B8;
		  /* 822243B8h */ case   28:  		/* bc 12, CR6_EQ, 256 */
		/* 822243B8h case   28:*/		if ( regs.CR[6].eq ) { return 0x822244B8;  }
		/* 822243B8h case   28:*/		return 0x822243BC;
		  /* 822243BCh */ case   29:  		/* ori R11, R11, 17476 */
		/* 822243BCh case   29:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4444);
		/* 822243BCh case   29:*/		return 0x822243C0;
		  /* 822243C0h */ case   30:  		/* b -28 */
		/* 822243C0h case   30:*/		return 0x822243A4;
		/* 822243C0h case   30:*/		return 0x822243C4;
		  /* 822243C4h */ case   31:  		/* lwz R10, <#[R31 + 12]> */
		/* 822243C4h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 822243C4h case   31:*/		return 0x822243C8;
		  /* 822243C8h */ case   32:  		/* ori R11, R11, 64 */
		/* 822243C8h case   32:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 822243C8h case   32:*/		return 0x822243CC;
		  /* 822243CCh */ case   33:  		/* andi. R9, R10, 61166 */
		/* 822243CCh case   33:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R10,0xEEEE);
		/* 822243CCh case   33:*/		return 0x822243D0;
		  /* 822243D0h */ case   34:  		/* stw R11, <#[R31 + 8]> */
		/* 822243D0h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822243D0h case   34:*/		return 0x822243D4;
		  /* 822243D4h */ case   35:  		/* cmplwi CR6, R9, 61166 */
		/* 822243D4h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000EEEE);
		/* 822243D4h case   35:*/		return 0x822243D8;
		  /* 822243D8h */ case   36:  		/* bc 12, CR6_EQ, 224 */
		/* 822243D8h case   36:*/		if ( regs.CR[6].eq ) { return 0x822244B8;  }
		/* 822243D8h case   36:*/		return 0x822243DC;
		  /* 822243DCh */ case   37:  		/* ori R11, R10, 61166 */
		/* 822243DCh case   37:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0xEEEE);
		/* 822243DCh case   37:*/		return 0x822243E0;
		  /* 822243E0h */ case   38:  		/* b -60 */
		/* 822243E0h case   38:*/		return 0x822243A4;
		/* 822243E0h case   38:*/		return 0x822243E4;
		  /* 822243E4h */ case   39:  		/* lwz R11, <#[R31 + 12]> */
		/* 822243E4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822243E4h case   39:*/		return 0x822243E8;
		  /* 822243E8h */ case   40:  		/* rlwinm R10, R11, 0, 28, 30 */
		/* 822243E8h case   40:*/		cpu::op::rlwinm<0,0,28,30>(regs,&regs.R10,regs.R11);
		/* 822243E8h case   40:*/		return 0x822243EC;
		  /* 822243ECh */ case   41:  		/* cmplwi CR6, R10, 14 */
		/* 822243ECh case   41:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000E);
		/* 822243ECh case   41:*/		return 0x822243F0;
		  /* 822243F0h */ case   42:  		/* bc 12, CR6_EQ, 200 */
		/* 822243F0h case   42:*/		if ( regs.CR[6].eq ) { return 0x822244B8;  }
		/* 822243F0h case   42:*/		return 0x822243F4;
		  /* 822243F4h */ case   43:  		/* ori R11, R11, 14 */
		/* 822243F4h case   43:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 822243F4h case   43:*/		return 0x822243F8;
		  /* 822243F8h */ case   44:  		/* b -84 */
		/* 822243F8h case   44:*/		return 0x822243A4;
		/* 822243F8h case   44:*/		return 0x822243FC;
		  /* 822243FCh */ case   45:  		/* lwz R10, <#[R31 + 12]> */
		/* 822243FCh case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 822243FCh case   45:*/		return 0x82224400;
		  /* 82224400h */ case   46:  		/* ori R11, R11, 64 */
		/* 82224400h case   46:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82224400h case   46:*/		return 0x82224404;
		  /* 82224404h */ case   47:  		/* rlwinm R9, R10, 0, 28, 29 */
		/* 82224404h case   47:*/		cpu::op::rlwinm<0,0,28,29>(regs,&regs.R9,regs.R10);
		/* 82224404h case   47:*/		return 0x82224408;
	}
	return 0x82224408;
} // Block from 82224348h-82224408h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82224408h
// Function '?RemoveAllDependencies@Instruction@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224408);
		  /* 82224408h */ case    0:  		/* stw R11, <#[R31 + 8]> */
		/* 82224408h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224408h case    0:*/		return 0x8222440C;
		  /* 8222440Ch */ case    1:  		/* cmplwi CR6, R9, 12 */
		/* 8222440Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000C);
		/* 8222440Ch case    1:*/		return 0x82224410;
		  /* 82224410h */ case    2:  		/* bc 12, CR6_EQ, 168 */
		/* 82224410h case    2:*/		if ( regs.CR[6].eq ) { return 0x822244B8;  }
		/* 82224410h case    2:*/		return 0x82224414;
		  /* 82224414h */ case    3:  		/* ori R11, R10, 12 */
		/* 82224414h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0xC);
		/* 82224414h case    3:*/		return 0x82224418;
		  /* 82224418h */ case    4:  		/* b -116 */
		/* 82224418h case    4:*/		return 0x822243A4;
		/* 82224418h case    4:*/		return 0x8222441C;
		  /* 8222441Ch */ case    5:  		/* lwz R11, <#[R31 + 12]> */
		/* 8222441Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222441Ch case    5:*/		return 0x82224420;
		  /* 82224420h */ case    6:  		/* andi. R10, R11, 8738 */
		/* 82224420h case    6:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x2222);
		/* 82224420h case    6:*/		return 0x82224424;
		  /* 82224424h */ case    7:  		/* cmplwi CR6, R10, 8738 */
		/* 82224424h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002222);
		/* 82224424h case    7:*/		return 0x82224428;
		  /* 82224428h */ case    8:  		/* bc 12, CR6_EQ, 144 */
		/* 82224428h case    8:*/		if ( regs.CR[6].eq ) { return 0x822244B8;  }
		/* 82224428h case    8:*/		return 0x8222442C;
		  /* 8222442Ch */ case    9:  		/* ori R11, R11, 8738 */
		/* 8222442Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2222);
		/* 8222442Ch case    9:*/		return 0x82224430;
		  /* 82224430h */ case   10:  		/* b -140 */
		/* 82224430h case   10:*/		return 0x822243A4;
		/* 82224430h case   10:*/		return 0x82224434;
		  /* 82224434h */ case   11:  		/* lwz R11, <#[R3 + 40]> */
		/* 82224434h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82224434h case   11:*/		return 0x82224438;
		  /* 82224438h */ case   12:  		/* ori R11, R11, 1024 */
		/* 82224438h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82224438h case   12:*/		return 0x8222443C;
		  /* 8222443Ch */ case   13:  		/* stw R11, <#[R3 + 40]> */
		/* 8222443Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 8222443Ch case   13:*/		return 0x82224440;
		  /* 82224440h */ case   14:  		/* b 120 */
		/* 82224440h case   14:*/		return 0x822244B8;
		/* 82224440h case   14:*/		return 0x82224444;
		  /* 82224444h */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224444h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224444h case   15:*/		return 0x82224448;
		  /* 82224448h */ case   16:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224448h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224448h case   16:*/		return 0x8222444C;
		  /* 8222444Ch */ case   17:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8222444Ch case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8222444Ch case   17:*/		return 0x82224450;
		  /* 82224450h */ case   18:  		/* bl -786464 */
		/* 82224450h case   18:*/		regs.LR = 0x82224454; return 0x82164430;
		/* 82224450h case   18:*/		return 0x82224454;
		  /* 82224454h */ case   19:  		/* addi R11, R31, -20 */
		/* 82224454h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFEC);
		/* 82224454h case   19:*/		return 0x82224458;
	}
	return 0x82224458;
} // Block from 82224408h-82224458h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82224458h
// Function '?DisconnectOrderingDependencies@Compiler@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224458);
		  /* 82224458h */ case    0:  		/* li R10, 57 */
		/* 82224458h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x39);
		/* 82224458h case    0:*/		return 0x8222445C;
		  /* 8222445Ch */ case    1:  		/* add R11, R3, R11 */
		/* 8222445Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8222445Ch case    1:*/		return 0x82224460;
		  /* 82224460h */ case    2:  		/* lwz R9, <#[R11 + 12]> */
		/* 82224460h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82224460h case    2:*/		return 0x82224464;
		  /* 82224464h */ case    3:  		/* rlwimi R9, R10, 19, 7, 14 */
		/* 82224464h case    3:*/		cpu::op::rlwimi<0,19,7,14>(regs,&regs.R9,regs.R10);
		/* 82224464h case    3:*/		return 0x82224468;
		  /* 82224468h */ case    4:  		/* stw R9, <#[R11 + 12]> */
		/* 82224468h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82224468h case    4:*/		return 0x8222446C;
		  /* 8222446Ch */ case    5:  		/* b 76 */
		/* 8222446Ch case    5:*/		return 0x822244B8;
		/* 8222446Ch case    5:*/		return 0x82224470;
		  /* 82224470h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224470h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224470h case    6:*/		return 0x82224474;
		  /* 82224474h */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224474h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224474h case    7:*/		return 0x82224478;
		  /* 82224478h */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82224478h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82224478h case    8:*/		return 0x8222447C;
		  /* 8222447Ch */ case    9:  		/* bl -786508 */
		/* 8222447Ch case    9:*/		regs.LR = 0x82224480; return 0x82164430;
		/* 8222447Ch case    9:*/		return 0x82224480;
		  /* 82224480h */ case   10:  		/* addi R11, R31, -24 */
		/* 82224480h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFE8);
		/* 82224480h case   10:*/		return 0x82224484;
		  /* 82224484h */ case   11:  		/* li R10, 228 */
		/* 82224484h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0xE4);
		/* 82224484h case   11:*/		return 0x82224488;
		  /* 82224488h */ case   12:  		/* add R11, R3, R11 */
		/* 82224488h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82224488h case   12:*/		return 0x8222448C;
		  /* 8222448Ch */ case   13:  		/* lwz R8, <#[R11 + 4]> */
		/* 8222448Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8222448Ch case   13:*/		return 0x82224490;
		  /* 82224490h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 82224490h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82224490h case   14:*/		return 0x82224494;
		  /* 82224494h */ case   15:  		/* stb R10, <#[R11 + 14]> */
		/* 82224494h case   15:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x0000000E) );
		/* 82224494h case   15:*/		return 0x82224498;
		  /* 82224498h */ case   16:  		/* oris R10, R8, 3871 */
		/* 82224498h case   16:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R8,0xF1F);
		/* 82224498h case   16:*/		return 0x8222449C;
		  /* 8222449Ch */ case   17:  		/* oris R9, R9, 8 */
		/* 8222449Ch case   17:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x8);
		/* 8222449Ch case   17:*/		return 0x822244A0;
		  /* 822244A0h */ case   18:  		/* ori R10, R10, 61440 */
		/* 822244A0h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xF000);
		/* 822244A0h case   18:*/		return 0x822244A4;
		  /* 822244A4h */ case   19:  		/* stw R9, <#[R11]> */
		/* 822244A4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822244A4h case   19:*/		return 0x822244A8;
		  /* 822244A8h */ case   20:  		/* stw R10, <#[R11 + 4]> */
		/* 822244A8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822244A8h case   20:*/		return 0x822244AC;
		  /* 822244ACh */ case   21:  		/* b 12 */
		/* 822244ACh case   21:*/		return 0x822244B8;
		/* 822244ACh case   21:*/		return 0x822244B0;
		  /* 822244B0h */ case   22:  		/* ori R11, R11, 64 */
		/* 822244B0h case   22:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 822244B0h case   22:*/		return 0x822244B4;
		  /* 822244B4h */ case   23:  		/* stw R11, <#[R31 + 8]> */
		/* 822244B4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822244B4h case   23:*/		return 0x822244B8;
	}
	return 0x822244B8;
} // Block from 82224458h-822244B8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 822244B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822244B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822244B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822244B8);
		  /* 822244B8h */ case    0:  		/* addi R1, R1, 96 */
		/* 822244B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822244B8h case    0:*/		return 0x822244BC;
		  /* 822244BCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822244BCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822244BCh case    1:*/		return 0x822244C0;
		  /* 822244C0h */ case    2:  		/* mtspr LR, R12 */
		/* 822244C0h case    2:*/		regs.LR = regs.R12;
		/* 822244C0h case    2:*/		return 0x822244C4;
		  /* 822244C4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 822244C4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822244C4h case    3:*/		return 0x822244C8;
		  /* 822244C8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822244C8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822244C8h case    4:*/		return 0x822244CC;
	}
	return 0x822244CC;
} // Block from 822244B8h-822244CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822244CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822244CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822244CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822244CC);
		  /* 822244CCh */ case    0:  		/* nop */
		/* 822244CCh case    0:*/		cpu::op::nop();
		/* 822244CCh case    0:*/		return 0x822244D0;
	}
	return 0x822244D0;
} // Block from 822244CCh-822244D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822244D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822244D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822244D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822244D0);
		  /* 822244D0h */ case    0:  		/* mfspr R12, LR */
		/* 822244D0h case    0:*/		regs.R12 = regs.LR;
		/* 822244D0h case    0:*/		return 0x822244D4;
		  /* 822244D4h */ case    1:  		/* bl -1651324 */
		/* 822244D4h case    1:*/		regs.LR = 0x822244D8; return 0x82091258;
		/* 822244D4h case    1:*/		return 0x822244D8;
		  /* 822244D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822244D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822244D8h case    2:*/		return 0x822244DC;
		  /* 822244DCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 822244DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822244DCh case    3:*/		return 0x822244E0;
		  /* 822244E0h */ case    4:  		/* mr R30, R3 */
		/* 822244E0h case    4:*/		regs.R30 = regs.R3;
		/* 822244E0h case    4:*/		return 0x822244E4;
		  /* 822244E4h */ case    5:  		/* mr R31, R4 */
		/* 822244E4h case    5:*/		regs.R31 = regs.R4;
		/* 822244E4h case    5:*/		return 0x822244E8;
		  /* 822244E8h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 822244E8h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 822244E8h case    6:*/		return 0x822244EC;
		  /* 822244ECh */ case    7:  		/* mr R29, R5 */
		/* 822244ECh case    7:*/		regs.R29 = regs.R5;
		/* 822244ECh case    7:*/		return 0x822244F0;
		  /* 822244F0h */ case    8:  		/* addi R11, R11, -83 */
		/* 822244F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFAD);
		/* 822244F0h case    8:*/		return 0x822244F4;
		  /* 822244F4h */ case    9:  		/* cmplwi CR6, R11, 12 */
		/* 822244F4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 822244F4h case    9:*/		return 0x822244F8;
		  /* 822244F8h */ case   10:  		/* bc 12, CR6_GT, 644 */
		/* 822244F8h case   10:*/		if ( regs.CR[6].gt ) { return 0x8222477C;  }
		/* 822244F8h case   10:*/		return 0x822244FC;
		  /* 822244FCh */ case   11:  		/* lis R12, -32252 */
		/* 822244FCh case   11:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 822244FCh case   11:*/		return 0x82224500;
		  /* 82224500h */ case   12:  		/* addi R12, R12, -536 */
		/* 82224500h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFDE8);
		/* 82224500h case   12:*/		return 0x82224504;
		  /* 82224504h */ case   13:  		/* lbzx R0, <#[R12 + R11]> */
		/* 82224504h case   13:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 82224504h case   13:*/		return 0x82224508;
		  /* 82224508h */ case   14:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 82224508h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 82224508h case   14:*/		return 0x8222450C;
		  /* 8222450Ch */ case   15:  		/* lis R12, -32222 */
		/* 8222450Ch case   15:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8222);
		/* 8222450Ch case   15:*/		return 0x82224510;
		  /* 82224510h */ case   16:  		/* ori R0, R0, 0 */
		/* 82224510h case   16:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82224510h case   16:*/		return 0x82224514;
		  /* 82224514h */ case   17:  		/* addi R12, R12, 17700 */
		/* 82224514h case   17:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x4524);
		/* 82224514h case   17:*/		return 0x82224518;
		  /* 82224518h */ case   18:  		/* add R12, R12, R0 */
		/* 82224518h case   18:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82224518h case   18:*/		return 0x8222451C;
		  /* 8222451Ch */ case   19:  		/* mtspr CTR, R12 */
		/* 8222451Ch case   19:*/		regs.CTR = regs.R12;
		/* 8222451Ch case   19:*/		return 0x82224520;
		  /* 82224520h */ case   20:  		/* bcctr 20, CR0_LT */
		/* 82224520h case   20:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82224520h case   20:*/		return 0x82224524;
		  /* 82224524h */ case   21:  		/* li R4, 4800 */
		/* 82224524h case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82224524h case   21:*/		return 0x82224528;
		  /* 82224528h */ case   22:  		/* mr R3, R29 */
		/* 82224528h case   22:*/		regs.R3 = regs.R29;
		/* 82224528h case   22:*/		return 0x8222452C;
		  /* 8222452Ch */ case   23:  		/* bl -861892 */
		/* 8222452Ch case   23:*/		regs.LR = 0x82224530; return 0x82151E68;
		/* 8222452Ch case   23:*/		return 0x82224530;
		  /* 82224530h */ case   24:  		/* lwz R11, <#[R31 + 4]> */
		/* 82224530h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224530h case   24:*/		return 0x82224534;
		  /* 82224534h */ case   25:  		/* rlwinm R11, R11, 0, 18, 16 */
		/* 82224534h case   25:*/		cpu::op::rlwinm<0,0,18,16>(regs,&regs.R11,regs.R11);
		/* 82224534h case   25:*/		return 0x82224538;
		  /* 82224538h */ case   26:  		/* ori R11, R11, 45056 */
		/* 82224538h case   26:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xB000);
		/* 82224538h case   26:*/		return 0x8222453C;
		  /* 8222453Ch */ case   27:  		/* mr R10, R11 */
		/* 8222453Ch case   27:*/		regs.R10 = regs.R11;
		/* 8222453Ch case   27:*/		return 0x82224540;
		  /* 82224540h */ case   28:  		/* stw R11, <#[R31 + 4]> */
		/* 82224540h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224540h case   28:*/		return 0x82224544;
		  /* 82224544h */ case   29:  		/* lwz R11, <#[R30 + 8]> */
		/* 82224544h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82224544h case   29:*/		return 0x82224548;
		  /* 82224548h */ case   30:  		/* rlwimi R10, R11, 24, 21, 21 */
		/* 82224548h case   30:*/		cpu::op::rlwimi<0,24,21,21>(regs,&regs.R10,regs.R11);
		/* 82224548h case   30:*/		return 0x8222454C;
		  /* 8222454Ch */ case   31:  		/* stw R10, <#[R31 + 4]> */
		/* 8222454Ch case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8222454Ch case   31:*/		return 0x82224550;
		  /* 82224550h */ case   32:  		/* lwz R11, <#[R30 + 8]> */
		/* 82224550h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82224550h case   32:*/		return 0x82224554;
		  /* 82224554h */ case   33:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82224554h case   33:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82224554h case   33:*/		return 0x82224558;
		  /* 82224558h */ case   34:  		/* cmplwi CR6, R11, 11392 */
		/* 82224558h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002C80);
		/* 82224558h case   34:*/		return 0x8222455C;
		  /* 8222455Ch */ case   35:  		/* bc 4, CR6_EQ, 16 */
		/* 8222455Ch case   35:*/		if ( !regs.CR[6].eq ) { return 0x8222456C;  }
		/* 8222455Ch case   35:*/		return 0x82224560;
		  /* 82224560h */ case   36:  		/* lwz R11, <#[R31]> */
		/* 82224560h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224560h case   36:*/		return 0x82224564;
		  /* 82224564h */ case   37:  		/* ori R11, R11, 8192 */
		/* 82224564h case   37:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82224564h case   37:*/		return 0x82224568;
		  /* 82224568h */ case   38:  		/* b 100 */
		/* 82224568h case   38:*/		return 0x822245CC;
		/* 82224568h case   38:*/		return 0x8222456C;
	}
	return 0x8222456C;
} // Block from 822244D0h-8222456Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8222456Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222456C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222456C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222456C);
		  /* 8222456Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222456Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222456Ch case    0:*/		return 0x82224570;
		  /* 82224570h */ case    1:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82224570h case    1:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82224570h case    1:*/		return 0x82224574;
		  /* 82224574h */ case    2:  		/* bc 12, CR0_EQ, 80 */
		/* 82224574h case    2:*/		if ( regs.CR[0].eq ) { return 0x822245C4;  }
		/* 82224574h case    2:*/		return 0x82224578;
		  /* 82224578h */ case    3:  		/* lwz R11, <#[R30 + 44]> */
		/* 82224578h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 82224578h case    3:*/		return 0x8222457C;
		  /* 8222457Ch */ case    4:  		/* lwz R30, <#[R11 + 12]> */
		/* 8222457Ch case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222457Ch case    4:*/		return 0x82224580;
		  /* 82224580h */ case    5:  		/* mr R3, R30 */
		/* 82224580h case    5:*/		regs.R3 = regs.R30;
		/* 82224580h case    5:*/		return 0x82224584;
		  /* 82224584h */ case    6:  		/* bl -787668 */
		/* 82224584h case    6:*/		regs.LR = 0x82224588; return 0x821640B0;
		/* 82224584h case    6:*/		return 0x82224588;
		  /* 82224588h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82224588h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82224588h case    7:*/		return 0x8222458C;
		  /* 8222458Ch */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 8222458Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x822245C4;  }
		/* 8222458Ch case    8:*/		return 0x82224590;
		  /* 82224590h */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 82224590h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82224590h case    9:*/		return 0x82224594;
		  /* 82224594h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82224594h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82224594h case   10:*/		return 0x82224598;
		  /* 82224598h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 82224598h case   11:*/		if ( regs.CR[6].eq ) { return 0x822245B0;  }
		/* 82224598h case   11:*/		return 0x8222459C;
		  /* 8222459Ch */ case   12:  		/* lwz R10, <#[R11]> */
		/* 8222459Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222459Ch case   12:*/		return 0x822245A0;
		  /* 822245A0h */ case   13:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 822245A0h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 822245A0h case   13:*/		return 0x822245A4;
		  /* 822245A4h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 822245A4h case   14:*/		if ( !regs.CR[0].eq ) { return 0x822245B0;  }
		/* 822245A4h case   14:*/		return 0x822245A8;
		  /* 822245A8h */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 822245A8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822245A8h case   15:*/		return 0x822245AC;
		  /* 822245ACh */ case   16:  		/* b -24 */
		/* 822245ACh case   16:*/		return 0x82224594;
		/* 822245ACh case   16:*/		return 0x822245B0;
	}
	return 0x822245B0;
} // Block from 8222456Ch-822245B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822245B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822245B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822245B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822245B0);
		  /* 822245B0h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 822245B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822245B0h case    0:*/		return 0x822245B4;
		  /* 822245B4h */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 822245B4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822245B4h case    1:*/		return 0x822245B8;
		  /* 822245B8h */ case    2:  		/* rlwimi R10, R11, 17, 22, 29 */
		/* 822245B8h case    2:*/		cpu::op::rlwimi<0,17,22,29>(regs,&regs.R10,regs.R11);
		/* 822245B8h case    2:*/		return 0x822245BC;
		  /* 822245BCh */ case    3:  		/* stw R10, <#[R31 + 4]> */
		/* 822245BCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822245BCh case    3:*/		return 0x822245C0;
		  /* 822245C0h */ case    4:  		/* b 16 */
		/* 822245C0h case    4:*/		return 0x822245D0;
		/* 822245C0h case    4:*/		return 0x822245C4;
	}
	return 0x822245C4;
} // Block from 822245B0h-822245C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822245C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822245C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822245C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822245C4);
		  /* 822245C4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822245C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822245C4h case    0:*/		return 0x822245C8;
		  /* 822245C8h */ case    1:  		/* ori R11, R11, 16384 */
		/* 822245C8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 822245C8h case    1:*/		return 0x822245CC;
	}
	return 0x822245CC;
} // Block from 822245C4h-822245CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822245CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822245CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822245CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822245CC);
		  /* 822245CCh */ case    0:  		/* stw R11, <#[R31]> */
		/* 822245CCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822245CCh case    0:*/		return 0x822245D0;
	}
	return 0x822245D0;
} // Block from 822245CCh-822245D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822245D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822245D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822245D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822245D0);
		  /* 822245D0h */ case    0:  		/* li R3, 1 */
		/* 822245D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822245D0h case    0:*/		return 0x822245D4;
		  /* 822245D4h */ case    1:  		/* addi R1, R1, 128 */
		/* 822245D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822245D4h case    1:*/		return 0x822245D8;
		  /* 822245D8h */ case    2:  		/* b -1651504 */
		/* 822245D8h case    2:*/		return 0x820912A8;
		/* 822245D8h case    2:*/		return 0x822245DC;
		  /* 822245DCh */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 822245DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822245DCh case    3:*/		return 0x822245E0;
		  /* 822245E0h */ case    4:  		/* rlwinm R11, R11, 0, 19, 16 */
		/* 822245E0h case    4:*/		cpu::op::rlwinm<0,0,19,16>(regs,&regs.R11,regs.R11);
		/* 822245E0h case    4:*/		return 0x822245E4;
		  /* 822245E4h */ case    5:  		/* ori R11, R11, 36864 */
		/* 822245E4h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x9000);
		/* 822245E4h case    5:*/		return 0x822245E8;
		  /* 822245E8h */ case    6:  		/* mr R10, R11 */
		/* 822245E8h case    6:*/		regs.R10 = regs.R11;
		/* 822245E8h case    6:*/		return 0x822245EC;
		  /* 822245ECh */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 822245ECh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822245ECh case    7:*/		return 0x822245F0;
		  /* 822245F0h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 822245F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822245F0h case    8:*/		return 0x822245F4;
		  /* 822245F4h */ case    9:  		/* rlwimi R10, R11, 24, 21, 21 */
		/* 822245F4h case    9:*/		cpu::op::rlwimi<0,24,21,21>(regs,&regs.R10,regs.R11);
		/* 822245F4h case    9:*/		return 0x822245F8;
		  /* 822245F8h */ case   10:  		/* stw R10, <#[R31 + 4]> */
		/* 822245F8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822245F8h case   10:*/		return 0x822245FC;
		  /* 822245FCh */ case   11:  		/* lwz R11, <#[R30 + 8]> */
		/* 822245FCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822245FCh case   11:*/		return 0x82224600;
		  /* 82224600h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82224600h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82224600h case   12:*/		return 0x82224604;
		  /* 82224604h */ case   13:  		/* cmplwi CR6, R11, 11008 */
		/* 82224604h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002B00);
		/* 82224604h case   13:*/		return 0x82224608;
		  /* 82224608h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 82224608h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224608h case   14:*/		return 0x8222460C;
		  /* 8222460Ch */ case   15:  		/* bc 4, CR6_EQ, -68 */
		/* 8222460Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x822245C8;  }
		/* 8222460Ch case   15:*/		return 0x82224610;
		  /* 82224610h */ case   16:  		/* b -172 */
		/* 82224610h case   16:*/		return 0x82224564;
		/* 82224610h case   16:*/		return 0x82224614;
		  /* 82224614h */ case   17:  		/* lwz R11, <#[R31 + 4]> */
		/* 82224614h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224614h case   17:*/		return 0x82224618;
		  /* 82224618h */ case   18:  		/* li R10, 5 */
		/* 82224618h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 82224618h case   18:*/		return 0x8222461C;
		  /* 8222461Ch */ case   19:  		/* rlwimi R11, R10, 13, 16, 19 */
		/* 8222461Ch case   19:*/		cpu::op::rlwimi<0,13,16,19>(regs,&regs.R11,regs.R10);
		/* 8222461Ch case   19:*/		return 0x82224620;
		  /* 82224620h */ case   20:  		/* b 336 */
		/* 82224620h case   20:*/		return 0x82224770;
		/* 82224620h case   20:*/		return 0x82224624;
		  /* 82224624h */ case   21:  		/* lwz R11, <#[R31 + 4]> */
		/* 82224624h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224624h case   21:*/		return 0x82224628;
		  /* 82224628h */ case   22:  		/* rlwinm R11, R11, 0, 23, 21 */
		/* 82224628h case   22:*/		cpu::op::rlwinm<0,0,23,21>(regs,&regs.R11,regs.R11);
		/* 82224628h case   22:*/		return 0x8222462C;
		  /* 8222462Ch */ case   23:  		/* rlwinm R11, R11, 0, 20, 17 */
		/* 8222462Ch case   23:*/		cpu::op::rlwinm<0,0,20,17>(regs,&regs.R11,regs.R11);
		/* 8222462Ch case   23:*/		return 0x82224630;
		  /* 82224630h */ case   24:  		/* ori R11, R11, 50176 */
		/* 82224630h case   24:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC400);
		/* 82224630h case   24:*/		return 0x82224634;
		  /* 82224634h */ case   25:  		/* b 316 */
		/* 82224634h case   25:*/		return 0x82224770;
		/* 82224634h case   25:*/		return 0x82224638;
		  /* 82224638h */ case   26:  		/* lwz R11, <#[R31 + 4]> */
		/* 82224638h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224638h case   26:*/		return 0x8222463C;
		  /* 8222463Ch */ case   27:  		/* rlwinm R11, R11, 0, 22, 20 */
		/* 8222463Ch case   27:*/		cpu::op::rlwinm<0,0,22,20>(regs,&regs.R11,regs.R11);
		/* 8222463Ch case   27:*/		return 0x82224640;
		  /* 82224640h */ case   28:  		/* rlwinm R11, R11, 0, 20, 17 */
		/* 82224640h case   28:*/		cpu::op::rlwinm<0,0,20,17>(regs,&regs.R11,regs.R11);
		/* 82224640h case   28:*/		return 0x82224644;
		  /* 82224644h */ case   29:  		/* ori R11, R11, 49664 */
		/* 82224644h case   29:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC200);
		/* 82224644h case   29:*/		return 0x82224648;
		  /* 82224648h */ case   30:  		/* b 296 */
		/* 82224648h case   30:*/		return 0x82224770;
		/* 82224648h case   30:*/		return 0x8222464C;
		  /* 8222464Ch */ case   31:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222464Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222464Ch case   31:*/		return 0x82224650;
		  /* 82224650h */ case   32:  		/* li R6, 0 */
		/* 82224650h case   32:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82224650h case   32:*/		return 0x82224654;
		  /* 82224654h */ case   33:  		/* li R5, 0 */
		/* 82224654h case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224654h case   33:*/		return 0x82224658;
		  /* 82224658h */ case   34:  		/* rlwinm R11, R11, 0, 20, 17 */
		/* 82224658h case   34:*/		cpu::op::rlwinm<0,0,20,17>(regs,&regs.R11,regs.R11);
		/* 82224658h case   34:*/		return 0x8222465C;
		  /* 8222465Ch */ case   35:  		/* li R4, 94 */
		/* 8222465Ch case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x5E);
		/* 8222465Ch case   35:*/		return 0x82224660;
		  /* 82224660h */ case   36:  		/* ori R11, R11, 50688 */
		/* 82224660h case   36:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC600);
		/* 82224660h case   36:*/		return 0x82224664;
		  /* 82224664h */ case   37:  		/* mr R3, R29 */
		/* 82224664h case   37:*/		regs.R3 = regs.R29;
		/* 82224664h case   37:*/		return 0x82224668;
		  /* 82224668h */ case   38:  		/* stw R11, <#[R31 + 4]> */
		/* 82224668h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224668h case   38:*/		return 0x8222466C;
		  /* 8222466Ch */ case   39:  		/* bl -787004 */
		/* 8222466Ch case   39:*/		regs.LR = 0x82224670; return 0x82164430;
		/* 8222466Ch case   39:*/		return 0x82224670;
		  /* 82224670h */ case   40:  		/* addi R11, R30, -12 */
		/* 82224670h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF4);
		/* 82224670h case   40:*/		return 0x82224674;
		  /* 82224674h */ case   41:  		/* lwz R10, <#[R31]> */
		/* 82224674h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82224674h case   41:*/		return 0x82224678;
		  /* 82224678h */ case   42:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82224678h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82224678h case   42:*/		return 0x8222467C;
		  /* 8222467Ch */ case   43:  		/* rlwimi R11, R10, 0, 0, 28 */
		/* 8222467Ch case   43:*/		cpu::op::rlwimi<0,0,0,28>(regs,&regs.R11,regs.R10);
		/* 8222467Ch case   43:*/		return 0x82224680;
		  /* 82224680h */ case   44:  		/* stw R11, <#[R31]> */
		/* 82224680h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224680h case   44:*/		return 0x82224684;
		  /* 82224684h */ case   45:  		/* b 240 */
		/* 82224684h case   45:*/		return 0x82224774;
		/* 82224684h case   45:*/		return 0x82224688;
		  /* 82224688h */ case   46:  		/* lwz R11, <#[R31 + 4]> */
		/* 82224688h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224688h case   46:*/		return 0x8222468C;
		  /* 8222468Ch */ case   47:  		/* li R10, 7 */
		/* 8222468Ch case   47:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 8222468Ch case   47:*/		return 0x82224690;
		  /* 82224690h */ case   48:  		/* li R6, 0 */
		/* 82224690h case   48:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82224690h case   48:*/		return 0x82224694;
		  /* 82224694h */ case   49:  		/* rlwimi R11, R10, 12, 16, 19 */
		/* 82224694h case   49:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R10);
		/* 82224694h case   49:*/		return 0x82224698;
		  /* 82224698h */ case   50:  		/* li R5, 0 */
		/* 82224698h case   50:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224698h case   50:*/		return 0x8222469C;
		  /* 8222469Ch */ case   51:  		/* li R4, 84 */
		/* 8222469Ch case   51:*/		cpu::op::li<0>(regs,&regs.R4,0x54);
		/* 8222469Ch case   51:*/		return 0x822246A0;
		  /* 822246A0h */ case   52:  		/* stw R11, <#[R31 + 4]> */
		/* 822246A0h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822246A0h case   52:*/		return 0x822246A4;
		  /* 822246A4h */ case   53:  		/* mr R3, R29 */
		/* 822246A4h case   53:*/		regs.R3 = regs.R29;
		/* 822246A4h case   53:*/		return 0x822246A8;
		  /* 822246A8h */ case   54:  		/* bl -787064 */
		/* 822246A8h case   54:*/		regs.LR = 0x822246AC; return 0x82164430;
		/* 822246A8h case   54:*/		return 0x822246AC;
		  /* 822246ACh */ case   55:  		/* addi R11, R30, -20 */
		/* 822246ACh case   55:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFEC);
		/* 822246ACh case   55:*/		return 0x822246B0;
		  /* 822246B0h */ case   56:  		/* lwz R10, <#[R31]> */
		/* 822246B0h case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822246B0h case   56:*/		return 0x822246B4;
		  /* 822246B4h */ case   57:  		/* lwzx R11, <#[R3 + R11]> */
		/* 822246B4h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 822246B4h case   57:*/		return 0x822246B8;
		  /* 822246B8h */ case   58:  		/* li R3, 1 */
		/* 822246B8h case   58:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822246B8h case   58:*/		return 0x822246BC;
		  /* 822246BCh */ case   59:  		/* rlwimi R10, R11, 16, 11, 15 */
		/* 822246BCh case   59:*/		cpu::op::rlwimi<0,16,11,15>(regs,&regs.R10,regs.R11);
		/* 822246BCh case   59:*/		return 0x822246C0;
		  /* 822246C0h */ case   60:  		/* stw R10, <#[R31]> */
		/* 822246C0h case   60:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822246C0h case   60:*/		return 0x822246C4;
		  /* 822246C4h */ case   61:  		/* b -240 */
		/* 822246C4h case   61:*/		return 0x822245D4;
		/* 822246C4h case   61:*/		return 0x822246C8;
		  /* 822246C8h */ case   62:  		/* li R6, 0 */
		/* 822246C8h case   62:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822246C8h case   62:*/		return 0x822246CC;
		  /* 822246CCh */ case   63:  		/* li R5, 0 */
		/* 822246CCh case   63:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822246CCh case   63:*/		return 0x822246D0;
		  /* 822246D0h */ case   64:  		/* li R4, 85 */
		/* 822246D0h case   64:*/		cpu::op::li<0>(regs,&regs.R4,0x55);
		/* 822246D0h case   64:*/		return 0x822246D4;
		  /* 822246D4h */ case   65:  		/* mr R3, R29 */
		/* 822246D4h case   65:*/		regs.R3 = regs.R29;
		/* 822246D4h case   65:*/		return 0x822246D8;
		  /* 822246D8h */ case   66:  		/* bl -787112 */
		/* 822246D8h case   66:*/		regs.LR = 0x822246DC; return 0x82164430;
		/* 822246D8h case   66:*/		return 0x822246DC;
		  /* 822246DCh */ case   67:  		/* addi R11, R30, -20 */
		/* 822246DCh case   67:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFEC);
		/* 822246DCh case   67:*/		return 0x822246E0;
		  /* 822246E0h */ case   68:  		/* lwz R10, <#[R31 + 4]> */
		/* 822246E0h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822246E0h case   68:*/		return 0x822246E4;
		  /* 822246E4h */ case   69:  		/* li R9, 1 */
		/* 822246E4h case   69:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822246E4h case   69:*/		return 0x822246E8;
	}
	return 0x822246E8;
} // Block from 822245D0h-822246E8h (70 instructions)

//////////////////////////////////////////////////////
// Block at 822246E8h
// Function '?ParseInputSemantic@Compiler@D3DXShader@@AAAXPAVCNodeVariable@2@PAVCNode@2@KIPAUInputSemantic@2@KPAULinkageSemantics@2@PAW4PARAMGEN@2@PA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822246E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822246E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822246E8);
		  /* 822246E8h */ case    0:  		/* add R11, R3, R11 */
		/* 822246E8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 822246E8h case    0:*/		return 0x822246EC;
		  /* 822246ECh */ case    1:  		/* rlwimi R10, R9, 15, 16, 19 */
		/* 822246ECh case    1:*/		cpu::op::rlwimi<0,15,16,19>(regs,&regs.R10,regs.R9);
		/* 822246ECh case    1:*/		return 0x822246F0;
		  /* 822246F0h */ case    2:  		/* mr R3, R29 */
		/* 822246F0h case    2:*/		regs.R3 = regs.R29;
		/* 822246F0h case    2:*/		return 0x822246F4;
		  /* 822246F4h */ case    3:  		/* li R6, 0 */
		/* 822246F4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822246F4h case    3:*/		return 0x822246F8;
		  /* 822246F8h */ case    4:  		/* li R5, 0 */
		/* 822246F8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822246F8h case    4:*/		return 0x822246FC;
		  /* 822246FCh */ case    5:  		/* lwz R9, <#[R11 + 4]> */
		/* 822246FCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 822246FCh case    5:*/		return 0x82224700;
		  /* 82224700h */ case    6:  		/* li R4, 84 */
		/* 82224700h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x54);
		/* 82224700h case    6:*/		return 0x82224704;
		  /* 82224704h */ case    7:  		/* lwz R29, <#[R11]> */
		/* 82224704h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82224704h case    7:*/		return 0x82224708;
		  /* 82224708h */ case    8:  		/* rlwinm R11, R9, 0, 0, 29 */
		/* 82224708h case    8:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R9);
		/* 82224708h case    8:*/		return 0x8222470C;
		  /* 8222470Ch */ case    9:  		/* lwz R28, <#[R11 + 28]> */
		/* 8222470Ch case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000001C) );
		/* 8222470Ch case    9:*/		return 0x82224710;
		  /* 82224710h */ case   10:  		/* stw R10, <#[R31 + 4]> */
		/* 82224710h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82224710h case   10:*/		return 0x82224714;
		  /* 82224714h */ case   11:  		/* bl -787172 */
		/* 82224714h case   11:*/		regs.LR = 0x82224718; return 0x82164430;
		/* 82224714h case   11:*/		return 0x82224718;
		  /* 82224718h */ case   12:  		/* addi R11, R29, -20 */
		/* 82224718h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFEC);
		/* 82224718h case   12:*/		return 0x8222471C;
		  /* 8222471Ch */ case   13:  		/* lwz R10, <#[R31]> */
		/* 8222471Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222471Ch case   13:*/		return 0x82224720;
		  /* 82224720h */ case   14:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82224720h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82224720h case   14:*/		return 0x82224724;
		  /* 82224724h */ case   15:  		/* mr R3, R28 */
		/* 82224724h case   15:*/		regs.R3 = regs.R28;
		/* 82224724h case   15:*/		return 0x82224728;
		  /* 82224728h */ case   16:  		/* rlwimi R10, R11, 16, 11, 15 */
		/* 82224728h case   16:*/		cpu::op::rlwimi<0,16,11,15>(regs,&regs.R10,regs.R11);
		/* 82224728h case   16:*/		return 0x8222472C;
		  /* 8222472Ch */ case   17:  		/* stw R10, <#[R31]> */
		/* 8222472Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222472Ch case   17:*/		return 0x82224730;
		  /* 82224730h */ case   18:  		/* bl -784656 */
		/* 82224730h case   18:*/		regs.LR = 0x82224734; return 0x82164E20;
		/* 82224730h case   18:*/		return 0x82224734;
		  /* 82224734h */ case   19:  		/* lwz R11, <#[R31]> */
		/* 82224734h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224734h case   19:*/		return 0x82224738;
		  /* 82224738h */ case   20:  		/* lwz R10, <#[R31 + 4]> */
		/* 82224738h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82224738h case   20:*/		return 0x8222473C;
		  /* 8222473Ch */ case   21:  		/* rlwimi R11, R3, 0, 19, 31 */
		/* 8222473Ch case   21:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R11,regs.R3);
		/* 8222473Ch case   21:*/		return 0x82224740;
		  /* 82224740h */ case   22:  		/* mr R9, R11 */
		/* 82224740h case   22:*/		regs.R9 = regs.R11;
		/* 82224740h case   22:*/		return 0x82224744;
		  /* 82224744h */ case   23:  		/* stw R11, <#[R31]> */
		/* 82224744h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82224744h case   23:*/		return 0x82224748;
		  /* 82224748h */ case   24:  		/* lwz R11, <#[R30 + 8]> */
		/* 82224748h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82224748h case   24:*/		return 0x8222474C;
		  /* 8222474Ch */ case   25:  		/* rlwimi R9, R11, 4, 10, 10 */
		/* 8222474Ch case   25:*/		cpu::op::rlwimi<0,4,10,10>(regs,&regs.R9,regs.R11);
		/* 8222474Ch case   25:*/		return 0x82224750;
		  /* 82224750h */ case   26:  		/* stw R9, <#[R31]> */
		/* 82224750h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82224750h case   26:*/		return 0x82224754;
		  /* 82224754h */ case   27:  		/* lwz R11, <#[R30 + 8]> */
		/* 82224754h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82224754h case   27:*/		return 0x82224758;
		  /* 82224758h */ case   28:  		/* nor R11, R11, R11 */
		/* 82224758h case   28:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82224758h case   28:*/		return 0x8222475C;
		  /* 8222475Ch */ case   29:  		/* rlwimi R10, R11, 24, 21, 21 */
		/* 8222475Ch case   29:*/		cpu::op::rlwimi<0,24,21,21>(regs,&regs.R10,regs.R11);
		/* 8222475Ch case   29:*/		return 0x82224760;
		  /* 82224760h */ case   30:  		/* stw R10, <#[R31 + 4]> */
		/* 82224760h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82224760h case   30:*/		return 0x82224764;
		  /* 82224764h */ case   31:  		/* b 16 */
		/* 82224764h case   31:*/		return 0x82224774;
		/* 82224764h case   31:*/		return 0x82224768;
		  /* 82224768h */ case   32:  		/* lwz R11, <#[R31 + 4]> */
		/* 82224768h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224768h case   32:*/		return 0x8222476C;
		  /* 8222476Ch */ case   33:  		/* ori R11, R11, 61440 */
		/* 8222476Ch case   33:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xF000);
		/* 8222476Ch case   33:*/		return 0x82224770;
	}
	return 0x82224770;
} // Block from 822246E8h-82224770h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82224770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224770);
		  /* 82224770h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82224770h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82224770h case    0:*/		return 0x82224774;
	}
	return 0x82224774;
} // Block from 82224770h-82224774h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82224774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224774);
		  /* 82224774h */ case    0:  		/* li R3, 0 */
		/* 82224774h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82224774h case    0:*/		return 0x82224778;
		  /* 82224778h */ case    1:  		/* b -420 */
		/* 82224778h case    1:*/		return 0x822245D4;
		/* 82224778h case    1:*/		return 0x8222477C;
	}
	return 0x8222477C;
} // Block from 82224774h-8222477Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222477Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222477C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222477C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222477C);
		  /* 8222477Ch */ case    0:  		/* lis R11, -32252 */
		/* 8222477Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8222477Ch case    0:*/		return 0x82224780;
		  /* 82224780h */ case    1:  		/* li R4, 3500 */
		/* 82224780h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 82224780h case    1:*/		return 0x82224784;
		  /* 82224784h */ case    2:  		/* addi R5, R11, -280 */
		/* 82224784h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFEE8);
		/* 82224784h case    2:*/		return 0x82224788;
		  /* 82224788h */ case    3:  		/* mr R3, R29 */
		/* 82224788h case    3:*/		regs.R3 = regs.R29;
		/* 82224788h case    3:*/		return 0x8222478C;
		  /* 8222478Ch */ case    4:  		/* bl -862500 */
		/* 8222478Ch case    4:*/		regs.LR = 0x82224790; return 0x82151E68;
		/* 8222478Ch case    4:*/		return 0x82224790;
		  /* 82224790h */ case    5:  		/* rlwinm R11, R5, 0, 30, 31 */
		/* 82224790h case    5:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R5);
		/* 82224790h case    5:*/		return 0x82224794;
		  /* 82224794h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 82224794h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82224794h case    6:*/		return 0x82224798;
		  /* 82224798h */ case    7:  		/* bc 12, CR6_LT, 208 */
		/* 82224798h case    7:*/		if ( regs.CR[6].lt ) { return 0x82224868;  }
		/* 82224798h case    7:*/		return 0x8222479C;
		  /* 8222479Ch */ case    8:  		/* bc 12, CR6_EQ, 144 */
		/* 8222479Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8222482C;  }
		/* 8222479Ch case    8:*/		return 0x822247A0;
		  /* 822247A0h */ case    9:  		/* cmplwi CR6, R11, 3 */
		/* 822247A0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 822247A0h case    9:*/		return 0x822247A4;
		  /* 822247A4h */ case   10:  		/* bc 12, CR6_LT, 76 */
		/* 822247A4h case   10:*/		if ( regs.CR[6].lt ) { return 0x822247F0;  }
		/* 822247A4h case   10:*/		return 0x822247A8;
		  /* 822247A8h */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 822247A8h case   11:*/		if ( regs.CR[6].eq ) { return 0x822247B4;  }
		/* 822247A8h case   11:*/		return 0x822247AC;
		  /* 822247ACh */ case   12:  		/* li R4, 4800 */
		/* 822247ACh case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822247ACh case   12:*/		return 0x822247B0;
		  /* 822247B0h */ case   13:  		/* b -862536 */
		/* 822247B0h case   13:*/		return 0x82151E68;
		/* 822247B0h case   13:*/		return 0x822247B4;
	}
	return 0x822247B4;
} // Block from 8222477Ch-822247B4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822247B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822247B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822247B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822247B4);
		  /* 822247B4h */ case    0:  		/* rlwinm R10, R5, 0, 0, 29 */
		/* 822247B4h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R5);
		/* 822247B4h case    0:*/		return 0x822247B8;
		  /* 822247B8h */ case    1:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 822247B8h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 822247B8h case    1:*/		return 0x822247BC;
		  /* 822247BCh */ case    2:  		/* addi R9, R10, -36 */
		/* 822247BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFFFDC);
		/* 822247BCh case    2:*/		return 0x822247C0;
		  /* 822247C0h */ case    3:  		/* addi R11, R11, 36 */
		/* 822247C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 822247C0h case    3:*/		return 0x822247C4;
		  /* 822247C4h */ case    4:  		/* ori R8, R9, 1 */
		/* 822247C4h case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R9,0x1);
		/* 822247C4h case    4:*/		return 0x822247C8;
		  /* 822247C8h */ case    5:  		/* lwz R7, <#[R10]> */
		/* 822247C8h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 822247C8h case    5:*/		return 0x822247CC;
		  /* 822247CCh */ case    6:  		/* addi R6, R11, -36 */
		/* 822247CCh case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 822247CCh case    6:*/		return 0x822247D0;
		  /* 822247D0h */ case    7:  		/* addi R9, R11, 4 */
		/* 822247D0h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 822247D0h case    7:*/		return 0x822247D4;
		  /* 822247D4h */ case    8:  		/* stw R7, <#[R11]> */
		/* 822247D4h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 822247D4h case    8:*/		return 0x822247D8;
		  /* 822247D8h */ case    9:  		/* lwz R7, <#[R10]> */
		/* 822247D8h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 822247D8h case    9:*/		return 0x822247DC;
		  /* 822247DCh */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 822247DCh case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 822247DCh case   10:*/		return 0x822247E0;
		  /* 822247E0h */ case   11:  		/* stw R6, <#[R7]> */
		/* 822247E0h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 822247E0h case   11:*/		return 0x822247E4;
		  /* 822247E4h */ case   12:  		/* stw R8, <#[R11 + 4]> */
		/* 822247E4h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 822247E4h case   12:*/		return 0x822247E8;
		  /* 822247E8h */ case   13:  		/* stw R9, <#[R10]> */
		/* 822247E8h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 822247E8h case   13:*/		return 0x822247EC;
		  /* 822247ECh */ case   14:  		/* bclr 20, CR0_LT */
		/* 822247ECh case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822247ECh case   14:*/		return 0x822247F0;
	}
	return 0x822247F0;
} // Block from 822247B4h-822247F0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822247F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822247F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822247F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822247F0);
		  /* 822247F0h */ case    0:  		/* rlwinm R10, R5, 0, 0, 29 */
		/* 822247F0h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R5);
		/* 822247F0h case    0:*/		return 0x822247F4;
		  /* 822247F4h */ case    1:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 822247F4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 822247F4h case    1:*/		return 0x822247F8;
		  /* 822247F8h */ case    2:  		/* addi R9, R10, 4 */
		/* 822247F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 822247F8h case    2:*/		return 0x822247FC;
		  /* 822247FCh */ case    3:  		/* addi R11, R11, 36 */
		/* 822247FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 822247FCh case    3:*/		return 0x82224800;
		  /* 82224800h */ case    4:  		/* ori R8, R9, 1 */
		/* 82224800h case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R9,0x1);
		/* 82224800h case    4:*/		return 0x82224804;
		  /* 82224804h */ case    5:  		/* lwz R7, <#[R10 + 4]> */
		/* 82224804h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82224804h case    5:*/		return 0x82224808;
		  /* 82224808h */ case    6:  		/* addi R9, R11, 4 */
		/* 82224808h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82224808h case    6:*/		return 0x8222480C;
		  /* 8222480Ch */ case    7:  		/* addi R6, R11, -36 */
		/* 8222480Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 8222480Ch case    7:*/		return 0x82224810;
		  /* 82224810h */ case    8:  		/* stw R7, <#[R11 + 4]> */
		/* 82224810h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82224810h case    8:*/		return 0x82224814;
		  /* 82224814h */ case    9:  		/* lwz R7, <#[R10 + 4]> */
		/* 82224814h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82224814h case    9:*/		return 0x82224818;
		  /* 82224818h */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82224818h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82224818h case   10:*/		return 0x8222481C;
		  /* 8222481Ch */ case   11:  		/* stw R9, <#[R7 + 36]> */
		/* 8222481Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000024) );
		/* 8222481Ch case   11:*/		return 0x82224820;
		  /* 82224820h */ case   12:  		/* stw R8, <#[R11]> */
		/* 82224820h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82224820h case   12:*/		return 0x82224824;
		  /* 82224824h */ case   13:  		/* stw R6, <#[R10 + 4]> */
		/* 82224824h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82224824h case   13:*/		return 0x82224828;
		  /* 82224828h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82224828h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82224828h case   14:*/		return 0x8222482C;
	}
	return 0x8222482C;
} // Block from 822247F0h-8222482Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222482Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222482C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222482C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222482C);
		  /* 8222482Ch */ case    0:  		/* rlwinm R10, R5, 0, 0, 29 */
		/* 8222482Ch case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R5);
		/* 8222482Ch case    0:*/		return 0x82224830;
		  /* 82224830h */ case    1:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 82224830h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 82224830h case    1:*/		return 0x82224834;
		  /* 82224834h */ case    2:  		/* addi R9, R10, 36 */
		/* 82224834h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x24);
		/* 82224834h case    2:*/		return 0x82224838;
		  /* 82224838h */ case    3:  		/* addi R11, R11, 36 */
		/* 82224838h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82224838h case    3:*/		return 0x8222483C;
		  /* 8222483Ch */ case    4:  		/* addi R9, R9, 4 */
		/* 8222483Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8222483Ch case    4:*/		return 0x82224840;
		  /* 82224840h */ case    5:  		/* lwz R7, <#[R10 + 40]> */
		/* 82224840h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000028) );
		/* 82224840h case    5:*/		return 0x82224844;
		  /* 82224844h */ case    6:  		/* addi R8, R11, 4 */
		/* 82224844h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 82224844h case    6:*/		return 0x82224848;
		  /* 82224848h */ case    7:  		/* addi R6, R11, -36 */
		/* 82224848h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 82224848h case    7:*/		return 0x8222484C;
		  /* 8222484Ch */ case    8:  		/* stw R7, <#[R11 + 4]> */
		/* 8222484Ch case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8222484Ch case    8:*/		return 0x82224850;
		  /* 82224850h */ case    9:  		/* lwz R7, <#[R10 + 40]> */
		/* 82224850h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000028) );
		/* 82224850h case    9:*/		return 0x82224854;
		  /* 82224854h */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82224854h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82224854h case   10:*/		return 0x82224858;
		  /* 82224858h */ case   11:  		/* stw R8, <#[R7 + 36]> */
		/* 82224858h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 82224858h case   11:*/		return 0x8222485C;
		  /* 8222485Ch */ case   12:  		/* stw R9, <#[R11]> */
		/* 8222485Ch case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222485Ch case   12:*/		return 0x82224860;
		  /* 82224860h */ case   13:  		/* stw R6, <#[R10 + 40]> */
		/* 82224860h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000028) );
		/* 82224860h case   13:*/		return 0x82224864;
		  /* 82224864h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82224864h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82224864h case   14:*/		return 0x82224868;
	}
	return 0x82224868;
} // Block from 8222482Ch-82224868h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82224868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224868);
		  /* 82224868h */ case    0:  		/* rlwinm R10, R5, 0, 0, 29 */
		/* 82224868h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R5);
		/* 82224868h case    0:*/		return 0x8222486C;
		  /* 8222486Ch */ case    1:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 8222486Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 8222486Ch case    1:*/		return 0x82224870;
	}
	return 0x82224870;
} // Block from 82224868h-82224870h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224870h
// Function '?ParsePixelShaderInputSemantic@Compiler@D3DXShader@@AAAXPAVCNodeVariable@2@PAVCNode@2@KIPAULinkageSemantics@2@PAW4PARAMGEN@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224870);
		  /* 82224870h */ case    0:  		/* addi R9, R10, 36 */
		/* 82224870h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x24);
		/* 82224870h case    0:*/		return 0x82224874;
		  /* 82224874h */ case    1:  		/* addi R11, R11, 36 */
		/* 82224874h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82224874h case    1:*/		return 0x82224878;
		  /* 82224878h */ case    2:  		/* addi R8, R9, -36 */
		/* 82224878h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0xFFFFFFDC);
		/* 82224878h case    2:*/		return 0x8222487C;
		  /* 8222487Ch */ case    3:  		/* lwz R7, <#[R10 + 36]> */
		/* 8222487Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000024) );
		/* 8222487Ch case    3:*/		return 0x82224880;
		  /* 82224880h */ case    4:  		/* addi R6, R11, -36 */
		/* 82224880h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 82224880h case    4:*/		return 0x82224884;
		  /* 82224884h */ case    5:  		/* addi R9, R11, 4 */
		/* 82224884h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82224884h case    5:*/		return 0x82224888;
		  /* 82224888h */ case    6:  		/* stw R7, <#[R11]> */
		/* 82224888h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82224888h case    6:*/		return 0x8222488C;
		  /* 8222488Ch */ case    7:  		/* lwz R7, <#[R10 + 36]> */
		/* 8222488Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000024) );
		/* 8222488Ch case    7:*/		return 0x82224890;
		  /* 82224890h */ case    8:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82224890h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82224890h case    8:*/		return 0x82224894;
		  /* 82224894h */ case    9:  		/* stw R6, <#[R7]> */
		/* 82224894h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 82224894h case    9:*/		return 0x82224898;
		  /* 82224898h */ case   10:  		/* stw R8, <#[R11 + 4]> */
		/* 82224898h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82224898h case   10:*/		return 0x8222489C;
		  /* 8222489Ch */ case   11:  		/* stw R9, <#[R10 + 36]> */
		/* 8222489Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 8222489Ch case   11:*/		return 0x822248A0;
		  /* 822248A0h */ case   12:  		/* bclr 20, CR0_LT */
		/* 822248A0h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822248A0h case   12:*/		return 0x822248A4;
	}
	return 0x822248A4;
} // Block from 82224870h-822248A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822248A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822248A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822248A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822248A4);
		  /* 822248A4h */ case    0:  		/* nop */
		/* 822248A4h case    0:*/		cpu::op::nop();
		/* 822248A4h case    0:*/		return 0x822248A8;
	}
	return 0x822248A8;
} // Block from 822248A4h-822248A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822248A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822248A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822248A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822248A8);
		  /* 822248A8h */ case    0:  		/* mfspr R12, LR */
		/* 822248A8h case    0:*/		regs.R12 = regs.LR;
		/* 822248A8h case    0:*/		return 0x822248AC;
		  /* 822248ACh */ case    1:  		/* bl -1652312 */
		/* 822248ACh case    1:*/		regs.LR = 0x822248B0; return 0x82091254;
		/* 822248ACh case    1:*/		return 0x822248B0;
		  /* 822248B0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822248B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822248B0h case    2:*/		return 0x822248B4;
		  /* 822248B4h */ case    3:  		/* mr R11, R5 */
		/* 822248B4h case    3:*/		regs.R11 = regs.R5;
		/* 822248B4h case    3:*/		return 0x822248B8;
		  /* 822248B8h */ case    4:  		/* mr R5, R6 */
		/* 822248B8h case    4:*/		regs.R5 = regs.R6;
		/* 822248B8h case    4:*/		return 0x822248BC;
		  /* 822248BCh */ case    5:  		/* addi R10, R11, -104 */
		/* 822248BCh case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFF98);
		/* 822248BCh case    5:*/		return 0x822248C0;
		  /* 822248C0h */ case    6:  		/* mr R29, R7 */
		/* 822248C0h case    6:*/		regs.R29 = regs.R7;
		/* 822248C0h case    6:*/		return 0x822248C4;
		  /* 822248C4h */ case    7:  		/* cntlzw R10, R10 */
		/* 822248C4h case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 822248C4h case    7:*/		return 0x822248C8;
		  /* 822248C8h */ case    8:  		/* mr R6, R11 */
		/* 822248C8h case    8:*/		regs.R6 = regs.R11;
		/* 822248C8h case    8:*/		return 0x822248CC;
		  /* 822248CCh */ case    9:  		/* rlwinm R7, R10, 27, 31, 31 */
		/* 822248CCh case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R7,regs.R10);
		/* 822248CCh case    9:*/		return 0x822248D0;
		  /* 822248D0h */ case   10:  		/* mr R28, R8 */
		/* 822248D0h case   10:*/		regs.R28 = regs.R8;
		/* 822248D0h case   10:*/		return 0x822248D4;
		  /* 822248D4h */ case   11:  		/* lwz R8, <#[R1 + 212]> */
		/* 822248D4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000D4) );
		/* 822248D4h case   11:*/		return 0x822248D8;
		  /* 822248D8h */ case   12:  		/* mr R31, R3 */
		/* 822248D8h case   12:*/		regs.R31 = regs.R3;
		/* 822248D8h case   12:*/		return 0x822248DC;
		  /* 822248DCh */ case   13:  		/* mr R30, R4 */
		/* 822248DCh case   13:*/		regs.R30 = regs.R4;
		/* 822248DCh case   13:*/		return 0x822248E0;
	}
	return 0x822248E0;
} // Block from 822248A8h-822248E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822248E0h
// Function '?SetInstructionSequence@Compiler@D3DXShader@@QAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822248E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822248E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822248E0);
		  /* 822248E0h */ case    0:  		/* mr R27, R9 */
		/* 822248E0h case    0:*/		regs.R27 = regs.R9;
		/* 822248E0h case    0:*/		return 0x822248E4;
		  /* 822248E4h */ case    1:  		/* bl -1484 */
		/* 822248E4h case    1:*/		regs.LR = 0x822248E8; return 0x82224318;
		/* 822248E4h case    1:*/		return 0x822248E8;
		  /* 822248E8h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 822248E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822248E8h case    2:*/		return 0x822248EC;
		  /* 822248ECh */ case    3:  		/* mr R3, R30 */
		/* 822248ECh case    3:*/		regs.R3 = regs.R30;
		/* 822248ECh case    3:*/		return 0x822248F0;
		  /* 822248F0h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 822248F0h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 822248F0h case    4:*/		return 0x822248F4;
		  /* 822248F4h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 822248F4h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 822248F4h case    5:*/		return 0x822248F8;
		  /* 822248F8h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 822248F8h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 822248F8h case    6:*/		return 0x822248FC;
		  /* 822248FCh */ case    7:  		/* bl -787660 */
		/* 822248FCh case    7:*/		regs.LR = 0x82224900; return 0x82164430;
		/* 822248FCh case    7:*/		return 0x82224900;
		  /* 82224900h */ case    8:  		/* addi R10, R31, -8 */
		/* 82224900h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF8);
		/* 82224900h case    8:*/		return 0x82224904;
		  /* 82224904h */ case    9:  		/* lwz R11, <#[R1 + 220]> */
		/* 82224904h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000DC) );
		/* 82224904h case    9:*/		return 0x82224908;
		  /* 82224908h */ case   10:  		/* add R10, R3, R10 */
		/* 82224908h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 82224908h case   10:*/		return 0x8222490C;
		  /* 8222490Ch */ case   11:  		/* rlwimi R28, R11, 14, 16, 17 */
		/* 8222490Ch case   11:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R28,regs.R11);
		/* 8222490Ch case   11:*/		return 0x82224910;
		  /* 82224910h */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 82224910h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82224910h case   12:*/		return 0x82224914;
		  /* 82224914h */ case   13:  		/* lwz R9, <#[R10]> */
		/* 82224914h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82224914h case   13:*/		return 0x82224918;
		  /* 82224918h */ case   14:  		/* lwz R8, <#[R10 + 4]> */
		/* 82224918h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82224918h case   14:*/		return 0x8222491C;
		  /* 8222491Ch */ case   15:  		/* rlwimi R9, R28, 15, 1, 16 */
		/* 8222491Ch case   15:*/		cpu::op::rlwimi<0,15,1,16>(regs,&regs.R9,regs.R28);
		/* 8222491Ch case   15:*/		return 0x82224920;
		  /* 82224920h */ case   16:  		/* rlwimi R8, R27, 0, 28, 31 */
		/* 82224920h case   16:*/		cpu::op::rlwimi<0,0,28,31>(regs,&regs.R8,regs.R27);
		/* 82224920h case   16:*/		return 0x82224924;
		  /* 82224924h */ case   17:  		/* rlwimi R9, R29, 0, 17, 31 */
		/* 82224924h case   17:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R9,regs.R29);
		/* 82224924h case   17:*/		return 0x82224928;
		  /* 82224928h */ case   18:  		/* oris R8, R8, 16 */
		/* 82224928h case   18:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x10);
		/* 82224928h case   18:*/		return 0x8222492C;
		  /* 8222492Ch */ case   19:  		/* stw R9, <#[R10]> */
		/* 8222492Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222492Ch case   19:*/		return 0x82224930;
		  /* 82224930h */ case   20:  		/* stw R8, <#[R10 + 4]> */
		/* 82224930h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82224930h case   20:*/		return 0x82224934;
		  /* 82224934h */ case   21:  		/* bc 12, CR6_EQ, 68 */
		/* 82224934h case   21:*/		if ( regs.CR[6].eq ) { return 0x82224978;  }
		/* 82224934h case   21:*/		return 0x82224938;
		  /* 82224938h */ case   22:  		/* cmpwi CR6, R11, 2 */
		/* 82224938h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 82224938h case   22:*/		return 0x8222493C;
		  /* 8222493Ch */ case   23:  		/* bc 12, CR6_EQ, 36 */
		/* 8222493Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82224960;  }
		/* 8222493Ch case   23:*/		return 0x82224940;
		  /* 82224940h */ case   24:  		/* cmpwi CR6, R11, 3 */
		/* 82224940h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82224940h case   24:*/		return 0x82224944;
		  /* 82224944h */ case   25:  		/* bc 4, CR6_EQ, 76 */
		/* 82224944h case   25:*/		if ( !regs.CR[6].eq ) { return 0x82224990;  }
		/* 82224944h case   25:*/		return 0x82224948;
		  /* 82224948h */ case   26:  		/* lwz R11, <#[R31 + 12]> */
		/* 82224948h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82224948h case   26:*/		return 0x8222494C;
		  /* 8222494Ch */ case   27:  		/* andi. R10, R11, 26214 */
		/* 8222494Ch case   27:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x6666);
		/* 8222494Ch case   27:*/		return 0x82224950;
		  /* 82224950h */ case   28:  		/* cmplwi CR6, R10, 26214 */
		/* 82224950h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00006666);
		/* 82224950h case   28:*/		return 0x82224954;
		  /* 82224954h */ case   29:  		/* bc 12, CR6_EQ, 60 */
		/* 82224954h case   29:*/		if ( regs.CR[6].eq ) { return 0x82224990;  }
		/* 82224954h case   29:*/		return 0x82224958;
		  /* 82224958h */ case   30:  		/* ori R11, R11, 26214 */
		/* 82224958h case   30:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x6666);
		/* 82224958h case   30:*/		return 0x8222495C;
		  /* 8222495Ch */ case   31:  		/* b 48 */
		/* 8222495Ch case   31:*/		return 0x8222498C;
		/* 8222495Ch case   31:*/		return 0x82224960;
	}
	return 0x82224960;
} // Block from 822248E0h-82224960h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82224960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224960);
		  /* 82224960h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82224960h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82224960h case    0:*/		return 0x82224964;
		  /* 82224964h */ case    1:  		/* andi. R10, R11, 17476 */
		/* 82224964h case    1:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x4444);
		/* 82224964h case    1:*/		return 0x82224968;
		  /* 82224968h */ case    2:  		/* cmplwi CR6, R10, 17476 */
		/* 82224968h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00004444);
		/* 82224968h case    2:*/		return 0x8222496C;
		  /* 8222496Ch */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 8222496Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82224990;  }
		/* 8222496Ch case    3:*/		return 0x82224970;
		  /* 82224970h */ case    4:  		/* ori R11, R11, 17476 */
		/* 82224970h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4444);
		/* 82224970h case    4:*/		return 0x82224974;
		  /* 82224974h */ case    5:  		/* b 24 */
		/* 82224974h case    5:*/		return 0x8222498C;
		/* 82224974h case    5:*/		return 0x82224978;
	}
	return 0x82224978;
} // Block from 82224960h-82224978h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82224978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224978);
		  /* 82224978h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82224978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82224978h case    0:*/		return 0x8222497C;
		  /* 8222497Ch */ case    1:  		/* andi. R10, R11, 61166 */
		/* 8222497Ch case    1:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xEEEE);
		/* 8222497Ch case    1:*/		return 0x82224980;
		  /* 82224980h */ case    2:  		/* cmplwi CR6, R10, 61166 */
		/* 82224980h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000EEEE);
		/* 82224980h case    2:*/		return 0x82224984;
		  /* 82224984h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82224984h case    3:*/		if ( regs.CR[6].eq ) { return 0x82224990;  }
		/* 82224984h case    3:*/		return 0x82224988;
		  /* 82224988h */ case    4:  		/* ori R11, R11, 61166 */
		/* 82224988h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xEEEE);
		/* 82224988h case    4:*/		return 0x8222498C;
	}
	return 0x8222498C;
} // Block from 82224978h-8222498Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222498Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222498C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222498C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222498C);
		  /* 8222498Ch */ case    0:  		/* sth R11, <#[R31 + 14]> */
		/* 8222498Ch case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000000E) );
		/* 8222498Ch case    0:*/		return 0x82224990;
	}
	return 0x82224990;
} // Block from 8222498Ch-82224990h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82224990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224990);
		  /* 82224990h */ case    0:  		/* addi R1, R1, 128 */
		/* 82224990h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82224990h case    0:*/		return 0x82224994;
		  /* 82224994h */ case    1:  		/* b -1652464 */
		/* 82224994h case    1:*/		return 0x820912A4;
		/* 82224994h case    1:*/		return 0x82224998;
	}
	return 0x82224998;
} // Block from 82224990h-82224998h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224998h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224998);
		  /* 82224998h */ case    0:  		/* mfspr R12, LR */
		/* 82224998h case    0:*/		regs.R12 = regs.LR;
		/* 82224998h case    0:*/		return 0x8222499C;
		  /* 8222499Ch */ case    1:  		/* bl -1652560 */
		/* 8222499Ch case    1:*/		regs.LR = 0x822249A0; return 0x8209124C;
		/* 8222499Ch case    1:*/		return 0x822249A0;
		  /* 822249A0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822249A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822249A0h case    2:*/		return 0x822249A4;
		  /* 822249A4h */ case    3:  		/* mr R27, R6 */
		/* 822249A4h case    3:*/		regs.R27 = regs.R6;
		/* 822249A4h case    3:*/		return 0x822249A8;
		  /* 822249A8h */ case    4:  		/* mr R28, R4 */
		/* 822249A8h case    4:*/		regs.R28 = regs.R4;
		/* 822249A8h case    4:*/		return 0x822249AC;
		  /* 822249ACh */ case    5:  		/* mr R31, R5 */
		/* 822249ACh case    5:*/		regs.R31 = regs.R5;
		/* 822249ACh case    5:*/		return 0x822249B0;
		  /* 822249B0h */ case    6:  		/* mr R6, R8 */
		/* 822249B0h case    6:*/		regs.R6 = regs.R8;
		/* 822249B0h case    6:*/		return 0x822249B4;
		  /* 822249B4h */ case    7:  		/* mr R5, R7 */
		/* 822249B4h case    7:*/		regs.R5 = regs.R7;
		/* 822249B4h case    7:*/		return 0x822249B8;
		  /* 822249B8h */ case    8:  		/* mr R4, R27 */
		/* 822249B8h case    8:*/		regs.R4 = regs.R27;
		/* 822249B8h case    8:*/		return 0x822249BC;
		  /* 822249BCh */ case    9:  		/* mr R29, R3 */
		/* 822249BCh case    9:*/		regs.R29 = regs.R3;
		/* 822249BCh case    9:*/		return 0x822249C0;
	}
	return 0x822249C0;
} // Block from 82224998h-822249C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822249C0h
// Function '?SimplifyVectorDependent@Compiler@D3DXShader@@QAA_NPAVInstruction@2@PAVDependency@2@0II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822249C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822249C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822249C0);
		  /* 822249C0h */ case    0:  		/* mr R26, R7 */
		/* 822249C0h case    0:*/		regs.R26 = regs.R7;
		/* 822249C0h case    0:*/		return 0x822249C4;
		  /* 822249C4h */ case    1:  		/* mr R25, R8 */
		/* 822249C4h case    1:*/		regs.R25 = regs.R8;
		/* 822249C4h case    1:*/		return 0x822249C8;
		  /* 822249C8h */ case    2:  		/* bl -787864 */
		/* 822249C8h case    2:*/		regs.LR = 0x822249CC; return 0x82164430;
		/* 822249C8h case    2:*/		return 0x822249CC;
		  /* 822249CCh */ case    3:  		/* mr R4, R3 */
		/* 822249CCh case    3:*/		regs.R4 = regs.R3;
		/* 822249CCh case    3:*/		return 0x822249D0;
		  /* 822249D0h */ case    4:  		/* mr R3, R29 */
		/* 822249D0h case    4:*/		regs.R3 = regs.R29;
		/* 822249D0h case    4:*/		return 0x822249D4;
		  /* 822249D4h */ case    5:  		/* li R5, 35 */
		/* 822249D4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 822249D4h case    5:*/		return 0x822249D8;
		  /* 822249D8h */ case    6:  		/* bl -753200 */
		/* 822249D8h case    6:*/		regs.LR = 0x822249DC; return 0x8216CBA8;
		/* 822249D8h case    6:*/		return 0x822249DC;
		  /* 822249DCh */ case    7:  		/* mr R8, R25 */
		/* 822249DCh case    7:*/		regs.R8 = regs.R25;
		/* 822249DCh case    7:*/		return 0x822249E0;
		  /* 822249E0h */ case    8:  		/* mr R7, R26 */
		/* 822249E0h case    8:*/		regs.R7 = regs.R26;
		/* 822249E0h case    8:*/		return 0x822249E4;
		  /* 822249E4h */ case    9:  		/* mr R6, R27 */
		/* 822249E4h case    9:*/		regs.R6 = regs.R27;
		/* 822249E4h case    9:*/		return 0x822249E8;
		  /* 822249E8h */ case   10:  		/* mr R5, R28 */
		/* 822249E8h case   10:*/		regs.R5 = regs.R28;
		/* 822249E8h case   10:*/		return 0x822249EC;
		  /* 822249ECh */ case   11:  		/* mr R4, R29 */
		/* 822249ECh case   11:*/		regs.R4 = regs.R29;
		/* 822249ECh case   11:*/		return 0x822249F0;
		  /* 822249F0h */ case   12:  		/* mr R30, R3 */
		/* 822249F0h case   12:*/		regs.R30 = regs.R3;
		/* 822249F0h case   12:*/		return 0x822249F4;
		  /* 822249F4h */ case   13:  		/* bl -1756 */
		/* 822249F4h case   13:*/		regs.LR = 0x822249F8; return 0x82224318;
		/* 822249F4h case   13:*/		return 0x822249F8;
		  /* 822249F8h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 822249F8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822249F8h case   14:*/		return 0x822249FC;
		  /* 822249FCh */ case   15:  		/* bc 12, CR6_EQ, 56 */
		/* 822249FCh case   15:*/		if ( regs.CR[6].eq ) { return 0x82224A34;  }
		/* 822249FCh case   15:*/		return 0x82224A00;
		  /* 82224A00h */ case   16:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82224A00h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82224A00h case   16:*/		return 0x82224A04;
		  /* 82224A04h */ case   17:  		/* lwz R9, <#[R31]> */
		/* 82224A04h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82224A04h case   17:*/		return 0x82224A08;
		  /* 82224A08h */ case   18:  		/* addi R10, R31, -36 */
		/* 82224A08h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82224A08h case   18:*/		return 0x82224A0C;
		  /* 82224A0Ch */ case   19:  		/* addi R11, R11, 36 */
		/* 82224A0Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82224A0Ch case   19:*/		return 0x82224A10;
		  /* 82224A10h */ case   20:  		/* ori R8, R10, 1 */
		/* 82224A10h case   20:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82224A10h case   20:*/		return 0x82224A14;
		  /* 82224A14h */ case   21:  		/* addi R7, R11, -36 */
		/* 82224A14h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82224A14h case   21:*/		return 0x82224A18;
		  /* 82224A18h */ case   22:  		/* addi R10, R11, 4 */
		/* 82224A18h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82224A18h case   22:*/		return 0x82224A1C;
		  /* 82224A1Ch */ case   23:  		/* stw R9, <#[R11]> */
		/* 82224A1Ch case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82224A1Ch case   23:*/		return 0x82224A20;
		  /* 82224A20h */ case   24:  		/* lwz R9, <#[R31]> */
		/* 82224A20h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82224A20h case   24:*/		return 0x82224A24;
		  /* 82224A24h */ case   25:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82224A24h case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82224A24h case   25:*/		return 0x82224A28;
		  /* 82224A28h */ case   26:  		/* stw R7, <#[R9]> */
		/* 82224A28h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82224A28h case   26:*/		return 0x82224A2C;
		  /* 82224A2Ch */ case   27:  		/* stw R8, <#[R11 + 4]> */
		/* 82224A2Ch case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82224A2Ch case   27:*/		return 0x82224A30;
		  /* 82224A30h */ case   28:  		/* stw R10, <#[R31]> */
		/* 82224A30h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82224A30h case   28:*/		return 0x82224A34;
	}
	return 0x82224A34;
} // Block from 822249C0h-82224A34h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82224A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224A34);
		  /* 82224A34h */ case    0:  		/* mr R3, R30 */
		/* 82224A34h case    0:*/		regs.R3 = regs.R30;
		/* 82224A34h case    0:*/		return 0x82224A38;
		  /* 82224A38h */ case    1:  		/* addi R1, R1, 144 */
		/* 82224A38h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82224A38h case    1:*/		return 0x82224A3C;
		  /* 82224A3Ch */ case    2:  		/* b -1652640 */
		/* 82224A3Ch case    2:*/		return 0x8209129C;
		/* 82224A3Ch case    2:*/		return 0x82224A40;
	}
	return 0x82224A40;
} // Block from 82224A34h-82224A40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82224A40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224A40);
		  /* 82224A40h */ case    0:  		/* mfspr R12, LR */
		/* 82224A40h case    0:*/		regs.R12 = regs.LR;
		/* 82224A40h case    0:*/		return 0x82224A44;
		  /* 82224A44h */ case    1:  		/* bl -1652716 */
		/* 82224A44h case    1:*/		regs.LR = 0x82224A48; return 0x82091258;
		/* 82224A44h case    1:*/		return 0x82224A48;
		  /* 82224A48h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82224A48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82224A48h case    2:*/		return 0x82224A4C;
		  /* 82224A4Ch */ case    3:  		/* mr R30, R4 */
		/* 82224A4Ch case    3:*/		regs.R30 = regs.R4;
		/* 82224A4Ch case    3:*/		return 0x82224A50;
		  /* 82224A50h */ case    4:  		/* li R6, 1 */
		/* 82224A50h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82224A50h case    4:*/		return 0x82224A54;
		  /* 82224A54h */ case    5:  		/* li R5, 0 */
		/* 82224A54h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224A54h case    5:*/		return 0x82224A58;
		  /* 82224A58h */ case    6:  		/* li R4, 112 */
		/* 82224A58h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 82224A58h case    6:*/		return 0x82224A5C;
		  /* 82224A5Ch */ case    7:  		/* mr R28, R3 */
		/* 82224A5Ch case    7:*/		regs.R28 = regs.R3;
		/* 82224A5Ch case    7:*/		return 0x82224A60;
		  /* 82224A60h */ case    8:  		/* bl -788016 */
		/* 82224A60h case    8:*/		regs.LR = 0x82224A64; return 0x82164430;
		/* 82224A60h case    8:*/		return 0x82224A64;
		  /* 82224A64h */ case    9:  		/* mr R29, R3 */
		/* 82224A64h case    9:*/		regs.R29 = regs.R3;
		/* 82224A64h case    9:*/		return 0x82224A68;
		  /* 82224A68h */ case   10:  		/* addi R4, R3, 4 */
		/* 82224A68h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 82224A68h case   10:*/		return 0x82224A6C;
		  /* 82224A6Ch */ case   11:  		/* li R5, 35 */
		/* 82224A6Ch case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 82224A6Ch case   11:*/		return 0x82224A70;
		  /* 82224A70h */ case   12:  		/* mr R3, R28 */
		/* 82224A70h case   12:*/		regs.R3 = regs.R28;
		/* 82224A70h case   12:*/		return 0x82224A74;
		  /* 82224A74h */ case   13:  		/* bl -753356 */
		/* 82224A74h case   13:*/		regs.LR = 0x82224A78; return 0x8216CBA8;
		/* 82224A74h case   13:*/		return 0x82224A78;
		  /* 82224A78h */ case   14:  		/* addi R31, R3, 4 */
		/* 82224A78h case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 82224A78h case   14:*/		return 0x82224A7C;
		  /* 82224A7Ch */ case   15:  		/* li R8, 1 */
		/* 82224A7Ch case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82224A7Ch case   15:*/		return 0x82224A80;
		  /* 82224A80h */ case   16:  		/* mr R3, R31 */
		/* 82224A80h case   16:*/		regs.R3 = regs.R31;
		/* 82224A80h case   16:*/		return 0x82224A84;
		  /* 82224A84h */ case   17:  		/* li R7, 0 */
		/* 82224A84h case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82224A84h case   17:*/		return 0x82224A88;
		  /* 82224A88h */ case   18:  		/* li R6, 112 */
		/* 82224A88h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x70);
		/* 82224A88h case   18:*/		return 0x82224A8C;
		  /* 82224A8Ch */ case   19:  		/* mr R5, R30 */
		/* 82224A8Ch case   19:*/		regs.R5 = regs.R30;
		/* 82224A8Ch case   19:*/		return 0x82224A90;
		  /* 82224A90h */ case   20:  		/* mr R4, R28 */
		/* 82224A90h case   20:*/		regs.R4 = regs.R28;
		/* 82224A90h case   20:*/		return 0x82224A94;
		  /* 82224A94h */ case   21:  		/* bl -1916 */
		/* 82224A94h case   21:*/		regs.LR = 0x82224A98; return 0x82224318;
		/* 82224A94h case   21:*/		return 0x82224A98;
		  /* 82224A98h */ case   22:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82224A98h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82224A98h case   22:*/		return 0x82224A9C;
		  /* 82224A9Ch */ case   23:  		/* lwz R6, <#[R30 + 16]> */
		/* 82224A9Ch case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000010) );
		/* 82224A9Ch case   23:*/		return 0x82224AA0;
		  /* 82224AA0h */ case   24:  		/* addi R10, R30, 16 */
		/* 82224AA0h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x10);
		/* 82224AA0h case   24:*/		return 0x82224AA4;
		  /* 82224AA4h */ case   25:  		/* addi R11, R11, 36 */
		/* 82224AA4h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82224AA4h case   25:*/		return 0x82224AA8;
		  /* 82224AA8h */ case   26:  		/* addi R10, R10, -36 */
		/* 82224AA8h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82224AA8h case   26:*/		return 0x82224AAC;
		  /* 82224AACh */ case   27:  		/* addi R8, R11, -36 */
		/* 82224AACh case   27:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82224AACh case   27:*/		return 0x82224AB0;
		  /* 82224AB0h */ case   28:  		/* ori R7, R10, 1 */
		/* 82224AB0h case   28:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 82224AB0h case   28:*/		return 0x82224AB4;
		  /* 82224AB4h */ case   29:  		/* addi R10, R11, 4 */
		/* 82224AB4h case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82224AB4h case   29:*/		return 0x82224AB8;
		  /* 82224AB8h */ case   30:  		/* stw R6, <#[R11]> */
		/* 82224AB8h case   30:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82224AB8h case   30:*/		return 0x82224ABC;
		  /* 82224ABCh */ case   31:  		/* add R9, R29, R31 */
		/* 82224ABCh case   31:*/		cpu::op::add<0>(regs,&regs.R9,regs.R29,regs.R31);
		/* 82224ABCh case   31:*/		return 0x82224AC0;
		  /* 82224AC0h */ case   32:  		/* mr R3, R31 */
		/* 82224AC0h case   32:*/		regs.R3 = regs.R31;
		/* 82224AC0h case   32:*/		return 0x82224AC4;
		  /* 82224AC4h */ case   33:  		/* addi R9, R9, -4 */
		/* 82224AC4h case   33:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 82224AC4h case   33:*/		return 0x82224AC8;
		  /* 82224AC8h */ case   34:  		/* lwz R6, <#[R30 + 16]> */
		/* 82224AC8h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000010) );
		/* 82224AC8h case   34:*/		return 0x82224ACC;
		  /* 82224ACCh */ case   35:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82224ACCh case   35:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82224ACCh case   35:*/		return 0x82224AD0;
		  /* 82224AD0h */ case   36:  		/* stw R8, <#[R6]> */
		/* 82224AD0h case   36:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 82224AD0h case   36:*/		return 0x82224AD4;
		  /* 82224AD4h */ case   37:  		/* stw R7, <#[R11 + 4]> */
		/* 82224AD4h case   37:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82224AD4h case   37:*/		return 0x82224AD8;
		  /* 82224AD8h */ case   38:  		/* stw R10, <#[R30 + 16]> */
		/* 82224AD8h case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82224AD8h case   38:*/		return 0x82224ADC;
		  /* 82224ADCh */ case   39:  		/* lwz R11, <#[R31 + 8]> */
		/* 82224ADCh case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224ADCh case   39:*/		return 0x82224AE0;
		  /* 82224AE0h */ case   40:  		/* oris R11, R11, 128 */
		/* 82224AE0h case   40:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82224AE0h case   40:*/		return 0x82224AE4;
		  /* 82224AE4h */ case   41:  		/* stw R11, <#[R31 + 8]> */
		/* 82224AE4h case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224AE4h case   41:*/		return 0x82224AE8;
		  /* 82224AE8h */ case   42:  		/* lwz R11, <#[R28 + 104]> */
		/* 82224AE8h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000068) );
		/* 82224AE8h case   42:*/		return 0x82224AEC;
		  /* 82224AECh */ case   43:  		/* stw R31, <#[R11]> */
		/* 82224AECh case   43:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82224AECh case   43:*/		return 0x82224AF0;
		  /* 82224AF0h */ case   44:  		/* stw R9, <#[R28 + 104]> */
		/* 82224AF0h case   44:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000068) );
		/* 82224AF0h case   44:*/		return 0x82224AF4;
		  /* 82224AF4h */ case   45:  		/* addi R1, R1, 128 */
		/* 82224AF4h case   45:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82224AF4h case   45:*/		return 0x82224AF8;
		  /* 82224AF8h */ case   46:  		/* b -1652816 */
		/* 82224AF8h case   46:*/		return 0x820912A8;
		/* 82224AF8h case   46:*/		return 0x82224AFC;
		  /* 82224AFCh */ case   47:  		/* nop */
		/* 82224AFCh case   47:*/		cpu::op::nop();
		/* 82224AFCh case   47:*/		return 0x82224B00;
	}
	return 0x82224B00;
} // Block from 82224A40h-82224B00h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82224B00h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224B00);
		  /* 82224B00h */ case    0:  		/* mfspr R12, LR */
		/* 82224B00h case    0:*/		regs.R12 = regs.LR;
		/* 82224B00h case    0:*/		return 0x82224B04;
		  /* 82224B04h */ case    1:  		/* bl -1652912 */
		/* 82224B04h case    1:*/		regs.LR = 0x82224B08; return 0x82091254;
		/* 82224B04h case    1:*/		return 0x82224B08;
		  /* 82224B08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82224B08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82224B08h case    2:*/		return 0x82224B0C;
		  /* 82224B0Ch */ case    3:  		/* mr R31, R5 */
		/* 82224B0Ch case    3:*/		regs.R31 = regs.R5;
		/* 82224B0Ch case    3:*/		return 0x82224B10;
		  /* 82224B10h */ case    4:  		/* mr R28, R4 */
		/* 82224B10h case    4:*/		regs.R28 = regs.R4;
		/* 82224B10h case    4:*/		return 0x82224B14;
		  /* 82224B14h */ case    5:  		/* mr R27, R6 */
		/* 82224B14h case    5:*/		regs.R27 = regs.R6;
		/* 82224B14h case    5:*/		return 0x82224B18;
		  /* 82224B18h */ case    6:  		/* mr R5, R6 */
		/* 82224B18h case    6:*/		regs.R5 = regs.R6;
		/* 82224B18h case    6:*/		return 0x82224B1C;
		  /* 82224B1Ch */ case    7:  		/* li R6, 4 */
		/* 82224B1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 82224B1Ch case    7:*/		return 0x82224B20;
		  /* 82224B20h */ case    8:  		/* li R4, 110 */
		/* 82224B20h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x6E);
		/* 82224B20h case    8:*/		return 0x82224B24;
		  /* 82224B24h */ case    9:  		/* mr R29, R3 */
		/* 82224B24h case    9:*/		regs.R29 = regs.R3;
		/* 82224B24h case    9:*/		return 0x82224B28;
		  /* 82224B28h */ case   10:  		/* bl -788216 */
		/* 82224B28h case   10:*/		regs.LR = 0x82224B2C; return 0x82164430;
		/* 82224B28h case   10:*/		return 0x82224B2C;
		  /* 82224B2Ch */ case   11:  		/* mr R4, R3 */
		/* 82224B2Ch case   11:*/		regs.R4 = regs.R3;
		/* 82224B2Ch case   11:*/		return 0x82224B30;
		  /* 82224B30h */ case   12:  		/* mr R3, R29 */
		/* 82224B30h case   12:*/		regs.R3 = regs.R29;
		/* 82224B30h case   12:*/		return 0x82224B34;
		  /* 82224B34h */ case   13:  		/* li R5, 35 */
		/* 82224B34h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 82224B34h case   13:*/		return 0x82224B38;
		  /* 82224B38h */ case   14:  		/* bl -753552 */
		/* 82224B38h case   14:*/		regs.LR = 0x82224B3C; return 0x8216CBA8;
		/* 82224B38h case   14:*/		return 0x82224B3C;
		  /* 82224B3Ch */ case   15:  		/* mr R8, R27 */
		/* 82224B3Ch case   15:*/		regs.R8 = regs.R27;
		/* 82224B3Ch case   15:*/		return 0x82224B40;
		  /* 82224B40h */ case   16:  		/* mr R7, R27 */
		/* 82224B40h case   16:*/		regs.R7 = regs.R27;
		/* 82224B40h case   16:*/		return 0x82224B44;
		  /* 82224B44h */ case   17:  		/* li R6, 110 */
		/* 82224B44h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x6E);
		/* 82224B44h case   17:*/		return 0x82224B48;
		  /* 82224B48h */ case   18:  		/* mr R5, R28 */
		/* 82224B48h case   18:*/		regs.R5 = regs.R28;
		/* 82224B48h case   18:*/		return 0x82224B4C;
		  /* 82224B4Ch */ case   19:  		/* mr R4, R29 */
		/* 82224B4Ch case   19:*/		regs.R4 = regs.R29;
		/* 82224B4Ch case   19:*/		return 0x82224B50;
		  /* 82224B50h */ case   20:  		/* mr R30, R3 */
		/* 82224B50h case   20:*/		regs.R30 = regs.R3;
		/* 82224B50h case   20:*/		return 0x82224B54;
		  /* 82224B54h */ case   21:  		/* bl -2108 */
		/* 82224B54h case   21:*/		regs.LR = 0x82224B58; return 0x82224318;
		/* 82224B54h case   21:*/		return 0x82224B58;
		  /* 82224B58h */ case   22:  		/* cmplwi CR6, R31, 0 */
		/* 82224B58h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82224B58h case   22:*/		return 0x82224B5C;
		  /* 82224B5Ch */ case   23:  		/* bc 12, CR6_EQ, 56 */
		/* 82224B5Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82224B94;  }
		/* 82224B5Ch case   23:*/		return 0x82224B60;
		  /* 82224B60h */ case   24:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82224B60h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82224B60h case   24:*/		return 0x82224B64;
		  /* 82224B64h */ case   25:  		/* lwz R9, <#[R31]> */
		/* 82224B64h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82224B64h case   25:*/		return 0x82224B68;
		  /* 82224B68h */ case   26:  		/* addi R10, R31, -36 */
		/* 82224B68h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 82224B68h case   26:*/		return 0x82224B6C;
		  /* 82224B6Ch */ case   27:  		/* addi R11, R11, 36 */
		/* 82224B6Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82224B6Ch case   27:*/		return 0x82224B70;
		  /* 82224B70h */ case   28:  		/* ori R8, R10, 1 */
		/* 82224B70h case   28:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82224B70h case   28:*/		return 0x82224B74;
		  /* 82224B74h */ case   29:  		/* addi R7, R11, -36 */
		/* 82224B74h case   29:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82224B74h case   29:*/		return 0x82224B78;
		  /* 82224B78h */ case   30:  		/* addi R10, R11, 4 */
		/* 82224B78h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82224B78h case   30:*/		return 0x82224B7C;
		  /* 82224B7Ch */ case   31:  		/* stw R9, <#[R11]> */
		/* 82224B7Ch case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82224B7Ch case   31:*/		return 0x82224B80;
		  /* 82224B80h */ case   32:  		/* lwz R9, <#[R31]> */
		/* 82224B80h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82224B80h case   32:*/		return 0x82224B84;
		  /* 82224B84h */ case   33:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82224B84h case   33:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82224B84h case   33:*/		return 0x82224B88;
		  /* 82224B88h */ case   34:  		/* stw R7, <#[R9]> */
		/* 82224B88h case   34:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82224B88h case   34:*/		return 0x82224B8C;
		  /* 82224B8Ch */ case   35:  		/* stw R8, <#[R11 + 4]> */
		/* 82224B8Ch case   35:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82224B8Ch case   35:*/		return 0x82224B90;
		  /* 82224B90h */ case   36:  		/* stw R10, <#[R31]> */
		/* 82224B90h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82224B90h case   36:*/		return 0x82224B94;
	}
	return 0x82224B94;
} // Block from 82224B00h-82224B94h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82224B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224B94);
		  /* 82224B94h */ case    0:  		/* mr R3, R30 */
		/* 82224B94h case    0:*/		regs.R3 = regs.R30;
		/* 82224B94h case    0:*/		return 0x82224B98;
		  /* 82224B98h */ case    1:  		/* addi R1, R1, 128 */
		/* 82224B98h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82224B98h case    1:*/		return 0x82224B9C;
		  /* 82224B9Ch */ case    2:  		/* b -1652984 */
		/* 82224B9Ch case    2:*/		return 0x820912A4;
		/* 82224B9Ch case    2:*/		return 0x82224BA0;
	}
	return 0x82224BA0;
} // Block from 82224B94h-82224BA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82224BA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224BA0);
		  /* 82224BA0h */ case    0:  		/* mfspr R12, LR */
		/* 82224BA0h case    0:*/		regs.R12 = regs.LR;
		/* 82224BA0h case    0:*/		return 0x82224BA4;
		  /* 82224BA4h */ case    1:  		/* bl -1653080 */
		/* 82224BA4h case    1:*/		regs.LR = 0x82224BA8; return 0x8209124C;
		/* 82224BA4h case    1:*/		return 0x82224BA8;
		  /* 82224BA8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82224BA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82224BA8h case    2:*/		return 0x82224BAC;
		  /* 82224BACh */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 82224BACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82224BACh case    3:*/		return 0x82224BB0;
		  /* 82224BB0h */ case    4:  		/* mr R29, R4 */
		/* 82224BB0h case    4:*/		regs.R29 = regs.R4;
		/* 82224BB0h case    4:*/		return 0x82224BB4;
		  /* 82224BB4h */ case    5:  		/* mr R30, R3 */
		/* 82224BB4h case    5:*/		regs.R30 = regs.R3;
		/* 82224BB4h case    5:*/		return 0x82224BB8;
		  /* 82224BB8h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224BB8h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224BB8h case    6:*/		return 0x82224BBC;
		  /* 82224BBCh */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224BBCh case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224BBCh case    7:*/		return 0x82224BC0;
		  /* 82224BC0h */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82224BC0h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82224BC0h case    8:*/		return 0x82224BC4;
		  /* 82224BC4h */ case    9:  		/* bl -788372 */
		/* 82224BC4h case    9:*/		regs.LR = 0x82224BC8; return 0x82164430;
		/* 82224BC4h case    9:*/		return 0x82224BC8;
		  /* 82224BC8h */ case   10:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224BC8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224BC8h case   10:*/		return 0x82224BCC;
		  /* 82224BCCh */ case   11:  		/* mr R28, R3 */
		/* 82224BCCh case   11:*/		regs.R28 = regs.R3;
		/* 82224BCCh case   11:*/		return 0x82224BD0;
		  /* 82224BD0h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82224BD0h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82224BD0h case   12:*/		return 0x82224BD4;
		  /* 82224BD4h */ case   13:  		/* mr R4, R3 */
		/* 82224BD4h case   13:*/		regs.R4 = regs.R3;
		/* 82224BD4h case   13:*/		return 0x82224BD8;
		  /* 82224BD8h */ case   14:  		/* cmplwi CR6, R11, 14336 */
		/* 82224BD8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82224BD8h case   14:*/		return 0x82224BDC;
		  /* 82224BDCh */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 82224BDCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82224BE4;  }
		/* 82224BDCh case   15:*/		return 0x82224BE0;
		  /* 82224BE0h */ case   16:  		/* addi R4, R3, 4 */
		/* 82224BE0h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 82224BE0h case   16:*/		return 0x82224BE4;
	}
	return 0x82224BE4;
} // Block from 82224BA0h-82224BE4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82224BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224BE4);
		  /* 82224BE4h */ case    0:  		/* li R5, 35 */
		/* 82224BE4h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 82224BE4h case    0:*/		return 0x82224BE8;
		  /* 82224BE8h */ case    1:  		/* mr R3, R30 */
		/* 82224BE8h case    1:*/		regs.R3 = regs.R30;
		/* 82224BE8h case    1:*/		return 0x82224BEC;
		  /* 82224BECh */ case    2:  		/* bl -753732 */
		/* 82224BECh case    2:*/		regs.LR = 0x82224BF0; return 0x8216CBA8;
		/* 82224BECh case    2:*/		return 0x82224BF0;
		  /* 82224BF0h */ case    3:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224BF0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224BF0h case    3:*/		return 0x82224BF4;
		  /* 82224BF4h */ case    4:  		/* mr R31, R3 */
		/* 82224BF4h case    4:*/		regs.R31 = regs.R3;
		/* 82224BF4h case    4:*/		return 0x82224BF8;
		  /* 82224BF8h */ case    5:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82224BF8h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82224BF8h case    5:*/		return 0x82224BFC;
		  /* 82224BFCh */ case    6:  		/* cmplwi CR6, R11, 14336 */
		/* 82224BFCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82224BFCh case    6:*/		return 0x82224C00;
		  /* 82224C00h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82224C00h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82224C08;  }
		/* 82224C00h case    7:*/		return 0x82224C04;
		  /* 82224C04h */ case    8:  		/* addi R31, R31, 4 */
		/* 82224C04h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82224C04h case    8:*/		return 0x82224C08;
	}
	return 0x82224C08;
} // Block from 82224BE4h-82224C08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82224C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224C08);
		  /* 82224C08h */ case    0:  		/* mr R5, R28 */
		/* 82224C08h case    0:*/		regs.R5 = regs.R28;
		/* 82224C08h case    0:*/		return 0x82224C0C;
		  /* 82224C0Ch */ case    1:  		/* mr R4, R29 */
		/* 82224C0Ch case    1:*/		regs.R4 = regs.R29;
		/* 82224C0Ch case    1:*/		return 0x82224C10;
		  /* 82224C10h */ case    2:  		/* mr R3, R31 */
		/* 82224C10h case    2:*/		regs.R3 = regs.R31;
		/* 82224C10h case    2:*/		return 0x82224C14;
		  /* 82224C14h */ case    3:  		/* bl -1651300 */
		/* 82224C14h case    3:*/		regs.LR = 0x82224C18; return 0x820919B0;
		/* 82224C14h case    3:*/		return 0x82224C18;
		  /* 82224C18h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 82224C18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224C18h case    4:*/		return 0x82224C1C;
		  /* 82224C1Ch */ case    5:  		/* li R27, 0 */
		/* 82224C1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82224C1Ch case    5:*/		return 0x82224C20;
		  /* 82224C20h */ case    6:  		/* rlwinm R11, R11, 0, 10, 8 */
		/* 82224C20h case    6:*/		cpu::op::rlwinm<0,0,10,8>(regs,&regs.R11,regs.R11);
		/* 82224C20h case    6:*/		return 0x82224C24;
		  /* 82224C24h */ case    7:  		/* stw R27, <#[R31 + 4]> */
		/* 82224C24h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000004) );
		/* 82224C24h case    7:*/		return 0x82224C28;
		  /* 82224C28h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 82224C28h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224C28h case    8:*/		return 0x82224C2C;
		  /* 82224C2Ch */ case    9:  		/* stw R27, <#[R31]> */
		/* 82224C2Ch case    9:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 82224C2Ch case    9:*/		return 0x82224C30;
		  /* 82224C30h */ case   10:  		/* sth R27, <#[R31 + 14]> */
		/* 82224C30h case   10:*/		cpu::mem::store16( regs, regs.R27, (uint32)(regs.R31 + 0x0000000E) );
		/* 82224C30h case   10:*/		return 0x82224C34;
		  /* 82224C34h */ case   11:  		/* stw R27, <#[R31 + 32]> */
		/* 82224C34h case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000020) );
		/* 82224C34h case   11:*/		return 0x82224C38;
		  /* 82224C38h */ case   12:  		/* lwz R11, <#[R30 + 40]> */
		/* 82224C38h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 82224C38h case   12:*/		return 0x82224C3C;
		  /* 82224C3Ch */ case   13:  		/* nor R11, R11, R11 */
		/* 82224C3Ch case   13:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82224C3Ch case   13:*/		return 0x82224C40;
		  /* 82224C40h */ case   14:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 82224C40h case   14:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 82224C40h case   14:*/		return 0x82224C44;
		  /* 82224C44h */ case   15:  		/* bc 12, CR0_EQ, 148 */
		/* 82224C44h case   15:*/		if ( regs.CR[0].eq ) { return 0x82224CD8;  }
		/* 82224C44h case   15:*/		return 0x82224C48;
		  /* 82224C48h */ case   16:  		/* lwz R11, <#[R29 + 16]> */
		/* 82224C48h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82224C48h case   16:*/		return 0x82224C4C;
		  /* 82224C4Ch */ case   17:  		/* mr R10, R27 */
		/* 82224C4Ch case   17:*/		regs.R10 = regs.R27;
		/* 82224C4Ch case   17:*/		return 0x82224C50;
		  /* 82224C50h */ case   18:  		/* b 24 */
		/* 82224C50h case   18:*/		return 0x82224C68;
		/* 82224C50h case   18:*/		return 0x82224C54;
		  /* 82224C54h */ case   19:  		/* lwz R9, <#[R11]> */
		/* 82224C54h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82224C54h case   19:*/		return 0x82224C58;
		  /* 82224C58h */ case   20:  		/* cmpwi CR6, R9, 0 */
		/* 82224C58h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82224C58h case   20:*/		return 0x82224C5C;
		  /* 82224C5Ch */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 82224C5Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82224C64;  }
		/* 82224C5Ch case   21:*/		return 0x82224C60;
		  /* 82224C60h */ case   22:  		/* li R10, 1 */
		/* 82224C60h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82224C60h case   22:*/		return 0x82224C64;
	}
	return 0x82224C64;
} // Block from 82224C08h-82224C64h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82224C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224C64);
		  /* 82224C64h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82224C64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82224C64h case    0:*/		return 0x82224C68;
	}
	return 0x82224C68;
} // Block from 82224C64h-82224C68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82224C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224C68);
		  /* 82224C68h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82224C68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82224C68h case    0:*/		return 0x82224C6C;
		  /* 82224C6Ch */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82224C6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82224C54;  }
		/* 82224C6Ch case    1:*/		return 0x82224C70;
		  /* 82224C70h */ case    2:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 82224C70h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 82224C70h case    2:*/		return 0x82224C74;
		  /* 82224C74h */ case    3:  		/* bc 12, CR0_EQ, 100 */
		/* 82224C74h case    3:*/		if ( regs.CR[0].eq ) { return 0x82224CD8;  }
		/* 82224C74h case    3:*/		return 0x82224C78;
		  /* 82224C78h */ case    4:  		/* stw R27, <#[R31 + 16]> */
		/* 82224C78h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000010) );
		/* 82224C78h case    4:*/		return 0x82224C7C;
		  /* 82224C7Ch */ case    5:  		/* lwz R28, <#[R29 + 16]> */
		/* 82224C7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000010) );
		/* 82224C7Ch case    5:*/		return 0x82224C80;
		  /* 82224C80h */ case    6:  		/* b 80 */
		/* 82224C80h case    6:*/		return 0x82224CD0;
		/* 82224C80h case    6:*/		return 0x82224C84;
		  /* 82224C84h */ case    7:  		/* lwz R11, <#[R28]> */
		/* 82224C84h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82224C84h case    7:*/		return 0x82224C88;
		  /* 82224C88h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 82224C88h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82224C88h case    8:*/		return 0x82224C8C;
		  /* 82224C8Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 82224C8Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x82224C9C;  }
		/* 82224C8Ch case    9:*/		return 0x82224C90;
		  /* 82224C90h */ case   10:  		/* bc 4, CR6_EQ, 212 */
		/* 82224C90h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82224D64;  }
		/* 82224C90h case   10:*/		return 0x82224C94;
		  /* 82224C94h */ case   11:  		/* li R26, 72 */
		/* 82224C94h case   11:*/		cpu::op::li<0>(regs,&regs.R26,0x48);
		/* 82224C94h case   11:*/		return 0x82224C98;
		  /* 82224C98h */ case   12:  		/* b 8 */
		/* 82224C98h case   12:*/		return 0x82224CA0;
		/* 82224C98h case   12:*/		return 0x82224C9C;
	}
	return 0x82224C9C;
} // Block from 82224C68h-82224C9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82224C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224C9C);
		  /* 82224C9Ch */ case    0:  		/* li R26, 12 */
		/* 82224C9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0xC);
		/* 82224C9Ch case    0:*/		return 0x82224CA0;
	}
	return 0x82224CA0;
} // Block from 82224C9Ch-82224CA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82224CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224CA0);
		  /* 82224CA0h */ case    0:  		/* li R5, 0 */
		/* 82224CA0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224CA0h case    0:*/		return 0x82224CA4;
		  /* 82224CA4h */ case    1:  		/* mr R4, R26 */
		/* 82224CA4h case    1:*/		regs.R4 = regs.R26;
		/* 82224CA4h case    1:*/		return 0x82224CA8;
		  /* 82224CA8h */ case    2:  		/* mr R3, R30 */
		/* 82224CA8h case    2:*/		regs.R3 = regs.R30;
		/* 82224CA8h case    2:*/		return 0x82224CAC;
		  /* 82224CACh */ case    3:  		/* bl -753924 */
		/* 82224CACh case    3:*/		regs.LR = 0x82224CB0; return 0x8216CBA8;
		/* 82224CACh case    3:*/		return 0x82224CB0;
		  /* 82224CB0h */ case    4:  		/* mr R5, R26 */
		/* 82224CB0h case    4:*/		regs.R5 = regs.R26;
		/* 82224CB0h case    4:*/		return 0x82224CB4;
		  /* 82224CB4h */ case    5:  		/* mr R4, R28 */
		/* 82224CB4h case    5:*/		regs.R4 = regs.R28;
		/* 82224CB4h case    5:*/		return 0x82224CB8;
		  /* 82224CB8h */ case    6:  		/* mr R25, R3 */
		/* 82224CB8h case    6:*/		regs.R25 = regs.R3;
		/* 82224CB8h case    6:*/		return 0x82224CBC;
		  /* 82224CBCh */ case    7:  		/* bl -1651468 */
		/* 82224CBCh case    7:*/		regs.LR = 0x82224CC0; return 0x820919B0;
		/* 82224CBCh case    7:*/		return 0x82224CC0;
		  /* 82224CC0h */ case    8:  		/* lwz R11, <#[R31 + 16]> */
		/* 82224CC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82224CC0h case    8:*/		return 0x82224CC4;
		  /* 82224CC4h */ case    9:  		/* stw R11, <#[R25 + 4]> */
		/* 82224CC4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82224CC4h case    9:*/		return 0x82224CC8;
		  /* 82224CC8h */ case   10:  		/* stw R25, <#[R31 + 16]> */
		/* 82224CC8h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000010) );
		/* 82224CC8h case   10:*/		return 0x82224CCC;
		  /* 82224CCCh */ case   11:  		/* lwz R28, <#[R28 + 4]> */
		/* 82224CCCh case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000004) );
		/* 82224CCCh case   11:*/		return 0x82224CD0;
	}
	return 0x82224CD0;
} // Block from 82224CA0h-82224CD0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82224CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224CD0);
		  /* 82224CD0h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82224CD0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82224CD0h case    0:*/		return 0x82224CD4;
		  /* 82224CD4h */ case    1:  		/* bc 4, CR6_EQ, -80 */
		/* 82224CD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82224C84;  }
		/* 82224CD4h case    1:*/		return 0x82224CD8;
	}
	return 0x82224CD8;
} // Block from 82224CD0h-82224CD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224CD8);
		  /* 82224CD8h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224CD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224CD8h case    0:*/		return 0x82224CDC;
		  /* 82224CDCh */ case    1:  		/* li R4, 0 */
		/* 82224CDCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82224CDCh case    1:*/		return 0x82224CE0;
		  /* 82224CE0h */ case    2:  		/* addi R3, R31, 44 */
		/* 82224CE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2C);
		/* 82224CE0h case    2:*/		return 0x82224CE4;
		  /* 82224CE4h */ case    3:  		/* rlwinm R5, R11, 15, 27, 29 */
		/* 82224CE4h case    3:*/		cpu::op::rlwinm<0,15,27,29>(regs,&regs.R5,regs.R11);
		/* 82224CE4h case    3:*/		return 0x82224CE8;
		  /* 82224CE8h */ case    4:  		/* bl -1653160 */
		/* 82224CE8h case    4:*/		regs.LR = 0x82224CEC; return 0x82091340;
		/* 82224CE8h case    4:*/		return 0x82224CEC;
		  /* 82224CECh */ case    5:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224CECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224CECh case    5:*/		return 0x82224CF0;
		  /* 82224CF0h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82224CF0h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82224CF0h case    6:*/		return 0x82224CF4;
		  /* 82224CF4h */ case    7:  		/* cmplwi CR6, R11, 112 */
		/* 82224CF4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 82224CF4h case    7:*/		return 0x82224CF8;
		  /* 82224CF8h */ case    8:  		/* bc 4, CR6_EQ, 120 */
		/* 82224CF8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82224D70;  }
		/* 82224CF8h case    8:*/		return 0x82224CFC;
		  /* 82224CFCh */ case    9:  		/* li R6, 1 */
		/* 82224CFCh case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82224CFCh case    9:*/		return 0x82224D00;
		  /* 82224D00h */ case   10:  		/* li R5, 0 */
		/* 82224D00h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224D00h case   10:*/		return 0x82224D04;
		  /* 82224D04h */ case   11:  		/* li R4, 112 */
		/* 82224D04h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 82224D04h case   11:*/		return 0x82224D08;
		  /* 82224D08h */ case   12:  		/* mr R3, R30 */
		/* 82224D08h case   12:*/		regs.R3 = regs.R30;
		/* 82224D08h case   12:*/		return 0x82224D0C;
		  /* 82224D0Ch */ case   13:  		/* bl -788700 */
		/* 82224D0Ch case   13:*/		regs.LR = 0x82224D10; return 0x82164430;
		/* 82224D0Ch case   13:*/		return 0x82224D10;
		  /* 82224D10h */ case   14:  		/* add R11, R3, R31 */
		/* 82224D10h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 82224D10h case   14:*/		return 0x82224D14;
		  /* 82224D14h */ case   15:  		/* lwz R7, <#[R30 + 104]> */
		/* 82224D14h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000068) );
		/* 82224D14h case   15:*/		return 0x82224D18;
		  /* 82224D18h */ case   16:  		/* add R10, R3, R29 */
		/* 82224D18h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R29);
		/* 82224D18h case   16:*/		return 0x82224D1C;
		  /* 82224D1Ch */ case   17:  		/* addi R9, R11, -8 */
		/* 82224D1Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFF8);
		/* 82224D1Ch case   17:*/		return 0x82224D20;
		  /* 82224D20h */ case   18:  		/* addi R8, R10, -8 */
		/* 82224D20h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFF8);
		/* 82224D20h case   18:*/		return 0x82224D24;
		  /* 82224D24h */ case   19:  		/* addi R9, R9, 4 */
		/* 82224D24h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82224D24h case   19:*/		return 0x82224D28;
		  /* 82224D28h */ case   20:  		/* stw R31, <#[R7]> */
		/* 82224D28h case   20:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R7 + 0x00000000) );
		/* 82224D28h case   20:*/		return 0x82224D2C;
		  /* 82224D2Ch */ case   21:  		/* stw R9, <#[R30 + 104]> */
		/* 82224D2Ch case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000068) );
		/* 82224D2Ch case   21:*/		return 0x82224D30;
	}
	return 0x82224D30;
} // Block from 82224CD8h-82224D30h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82224D30h
// Function '?Init@Instruction@D3DXShader@@QAAXPAVCompiler@2@PAVBlock@2@W4Opcode@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224D30);
		  /* 82224D30h */ case    0:  		/* stw R27, <#[R11 - 4]> */
		/* 82224D30h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82224D30h case    0:*/		return 0x82224D34;
		  /* 82224D34h */ case    1:  		/* lwz R8, <#[R10 - 8]> */
		/* 82224D34h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 82224D34h case    1:*/		return 0x82224D38;
		  /* 82224D38h */ case    2:  		/* lwz R9, <#[R11 - 8]> */
		/* 82224D38h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82224D38h case    2:*/		return 0x82224D3C;
		  /* 82224D3Ch */ case    3:  		/* rlwimi R9, R8, 0, 17, 31 */
		/* 82224D3Ch case    3:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R9,regs.R8);
		/* 82224D3Ch case    3:*/		return 0x82224D40;
		  /* 82224D40h */ case    4:  		/* mr R8, R9 */
		/* 82224D40h case    4:*/		regs.R8 = regs.R9;
		/* 82224D40h case    4:*/		return 0x82224D44;
		  /* 82224D44h */ case    5:  		/* stw R9, <#[R11 - 8]> */
		/* 82224D44h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82224D44h case    5:*/		return 0x82224D48;
		  /* 82224D48h */ case    6:  		/* lwz R9, <#[R10 - 8]> */
		/* 82224D48h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 82224D48h case    6:*/		return 0x82224D4C;
		  /* 82224D4Ch */ case    7:  		/* rlwimi R8, R9, 0, 3, 16 */
		/* 82224D4Ch case    7:*/		cpu::op::rlwimi<0,0,3,16>(regs,&regs.R8,regs.R9);
		/* 82224D4Ch case    7:*/		return 0x82224D50;
		  /* 82224D50h */ case    8:  		/* stw R8, <#[R11 - 8]> */
		/* 82224D50h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82224D50h case    8:*/		return 0x82224D54;
		  /* 82224D54h */ case    9:  		/* lwz R10, <#[R10 - 8]> */
		/* 82224D54h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 82224D54h case    9:*/		return 0x82224D58;
		  /* 82224D58h */ case   10:  		/* rlwimi R10, R8, 0, 3, 1 */
		/* 82224D58h case   10:*/		cpu::op::rlwimi<0,0,3,1>(regs,&regs.R10,regs.R8);
		/* 82224D58h case   10:*/		return 0x82224D5C;
		  /* 82224D5Ch */ case   11:  		/* stw R10, <#[R11 - 8]> */
		/* 82224D5Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82224D5Ch case   11:*/		return 0x82224D60;
		  /* 82224D60h */ case   12:  		/* b 320 */
		/* 82224D60h case   12:*/		return 0x82224EA0;
		/* 82224D60h case   12:*/		return 0x82224D64;
	}
	return 0x82224D64;
} // Block from 82224D30h-82224D64h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82224D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224D64);
		  /* 82224D64h */ case    0:  		/* li R4, 4800 */
		/* 82224D64h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82224D64h case    0:*/		return 0x82224D68;
		  /* 82224D68h */ case    1:  		/* mr R3, R30 */
		/* 82224D68h case    1:*/		regs.R3 = regs.R30;
		/* 82224D68h case    1:*/		return 0x82224D6C;
		  /* 82224D6Ch */ case    2:  		/* bl -864004 */
		/* 82224D6Ch case    2:*/		regs.LR = 0x82224D70; return 0x82151E68;
		/* 82224D6Ch case    2:*/		return 0x82224D70;
	}
	return 0x82224D70;
} // Block from 82224D64h-82224D70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82224D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224D70);
		  /* 82224D70h */ case    0:  		/* cmplwi CR6, R11, 119 */
		/* 82224D70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000077);
		/* 82224D70h case    0:*/		return 0x82224D74;
		  /* 82224D74h */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 82224D74h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82224DB0;  }
		/* 82224D74h case    1:*/		return 0x82224D78;
		  /* 82224D78h */ case    2:  		/* li R6, 0 */
		/* 82224D78h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82224D78h case    2:*/		return 0x82224D7C;
		  /* 82224D7Ch */ case    3:  		/* li R5, 0 */
		/* 82224D7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224D7Ch case    3:*/		return 0x82224D80;
		  /* 82224D80h */ case    4:  		/* li R4, 119 */
		/* 82224D80h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x77);
		/* 82224D80h case    4:*/		return 0x82224D84;
		  /* 82224D84h */ case    5:  		/* mr R3, R30 */
		/* 82224D84h case    5:*/		regs.R3 = regs.R30;
		/* 82224D84h case    5:*/		return 0x82224D88;
		  /* 82224D88h */ case    6:  		/* bl -788824 */
		/* 82224D88h case    6:*/		regs.LR = 0x82224D8C; return 0x82164430;
		/* 82224D88h case    6:*/		return 0x82224D8C;
		  /* 82224D8Ch */ case    7:  		/* addi R11, R31, -12 */
		/* 82224D8Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF4);
		/* 82224D8Ch case    7:*/		return 0x82224D90;
		  /* 82224D90h */ case    8:  		/* li R5, 0 */
		/* 82224D90h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224D90h case    8:*/		return 0x82224D94;
		  /* 82224D94h */ case    9:  		/* add R29, R3, R11 */
		/* 82224D94h case    9:*/		cpu::op::add<0>(regs,&regs.R29,regs.R3,regs.R11);
		/* 82224D94h case    9:*/		return 0x82224D98;
		  /* 82224D98h */ case   10:  		/* mr R3, R30 */
		/* 82224D98h case   10:*/		regs.R3 = regs.R30;
		/* 82224D98h case   10:*/		return 0x82224D9C;
		  /* 82224D9Ch */ case   11:  		/* lwz R11, <#[R29 + 4]> */
		/* 82224D9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82224D9Ch case   11:*/		return 0x82224DA0;
		  /* 82224DA0h */ case   12:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82224DA0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82224DA0h case   12:*/		return 0x82224DA4;
		  /* 82224DA4h */ case   13:  		/* bl -624508 */
		/* 82224DA4h case   13:*/		regs.LR = 0x82224DA8; return 0x8218C628;
		/* 82224DA4h case   13:*/		return 0x82224DA8;
		  /* 82224DA8h */ case   14:  		/* stw R3, <#[R29 + 8]> */
		/* 82224DA8h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000008) );
		/* 82224DA8h case   14:*/		return 0x82224DAC;
		  /* 82224DACh */ case   15:  		/* b 244 */
		/* 82224DACh case   15:*/		return 0x82224EA0;
		/* 82224DACh case   15:*/		return 0x82224DB0;
	}
	return 0x82224DB0;
} // Block from 82224D70h-82224DB0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82224DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224DB0);
		  /* 82224DB0h */ case    0:  		/* cmplwi CR6, R11, 97 */
		/* 82224DB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 82224DB0h case    0:*/		return 0x82224DB4;
		  /* 82224DB4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82224DB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82224DC8;  }
		/* 82224DB4h case    1:*/		return 0x82224DB8;
		  /* 82224DB8h */ case    2:  		/* cmplwi CR6, R11, 99 */
		/* 82224DB8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 82224DB8h case    2:*/		return 0x82224DBC;
		  /* 82224DBCh */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82224DBCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82224DC8;  }
		/* 82224DBCh case    3:*/		return 0x82224DC0;
		  /* 82224DC0h */ case    4:  		/* cmplwi CR6, R11, 100 */
		/* 82224DC0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 82224DC0h case    4:*/		return 0x82224DC4;
		  /* 82224DC4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 82224DC4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82224DCC;  }
		/* 82224DC4h case    5:*/		return 0x82224DC8;
	}
	return 0x82224DC8;
} // Block from 82224DB0h-82224DC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82224DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224DC8);
		  /* 82224DC8h */ case    0:  		/* li R27, 1 */
		/* 82224DC8h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82224DC8h case    0:*/		return 0x82224DCC;
	}
	return 0x82224DCC;
} // Block from 82224DC8h-82224DCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82224DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224DCC);
		  /* 82224DCCh */ case    0:  		/* rlwinm. R10, R27, 0, 24, 31 */
		/* 82224DCCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R27);
		/* 82224DCCh case    0:*/		return 0x82224DD0;
		  /* 82224DD0h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 82224DD0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82224E20;  }
		/* 82224DD0h case    1:*/		return 0x82224DD4;
		  /* 82224DD4h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224DD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224DD4h case    2:*/		return 0x82224DD8;
		  /* 82224DD8h */ case    3:  		/* mr R3, R30 */
		/* 82224DD8h case    3:*/		regs.R3 = regs.R30;
		/* 82224DD8h case    3:*/		return 0x82224DDC;
		  /* 82224DDCh */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224DDCh case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224DDCh case    4:*/		return 0x82224DE0;
		  /* 82224DE0h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224DE0h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224DE0h case    5:*/		return 0x82224DE4;
		  /* 82224DE4h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82224DE4h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82224DE4h case    6:*/		return 0x82224DE8;
		  /* 82224DE8h */ case    7:  		/* bl -788920 */
		/* 82224DE8h case    7:*/		regs.LR = 0x82224DEC; return 0x82164430;
		/* 82224DE8h case    7:*/		return 0x82224DEC;
		  /* 82224DECh */ case    8:  		/* addi R11, R29, -24 */
		/* 82224DECh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFE8);
		/* 82224DECh case    8:*/		return 0x82224DF0;
		  /* 82224DF0h */ case    9:  		/* add R28, R3, R11 */
		/* 82224DF0h case    9:*/		cpu::op::add<0>(regs,&regs.R28,regs.R3,regs.R11);
		/* 82224DF0h case    9:*/		return 0x82224DF4;
		  /* 82224DF4h */ case   10:  		/* lwz R11, <#[R28 + 20]> */
		/* 82224DF4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 82224DF4h case   10:*/		return 0x82224DF8;
		  /* 82224DF8h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82224DF8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82224DF8h case   11:*/		return 0x82224DFC;
		  /* 82224DFCh */ case   12:  		/* bc 12, CR6_EQ, 164 */
		/* 82224DFCh case   12:*/		if ( regs.CR[6].eq ) { return 0x82224EA0;  }
		/* 82224DFCh case   12:*/		return 0x82224E00;
		  /* 82224E00h */ case   13:  		/* lwz R29, <#[R11 + 4]> */
		/* 82224E00h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 82224E00h case   13:*/		return 0x82224E04;
		  /* 82224E04h */ case   14:  		/* li R5, 0 */
		/* 82224E04h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224E04h case   14:*/		return 0x82224E08;
		  /* 82224E08h */ case   15:  		/* mr R3, R30 */
		/* 82224E08h case   15:*/		regs.R3 = regs.R30;
		/* 82224E08h case   15:*/		return 0x82224E0C;
		  /* 82224E0Ch */ case   16:  		/* addi R11, R29, 2 */
		/* 82224E0Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x2);
		/* 82224E0Ch case   16:*/		return 0x82224E10;
		  /* 82224E10h */ case   17:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82224E10h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82224E10h case   17:*/		return 0x82224E14;
		  /* 82224E14h */ case   18:  		/* bl -624620 */
		/* 82224E14h case   18:*/		regs.LR = 0x82224E18; return 0x8218C628;
		/* 82224E14h case   18:*/		return 0x82224E18;
		  /* 82224E18h */ case   19:  		/* lwz R11, <#[R28 + 20]> */
		/* 82224E18h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 82224E18h case   19:*/		return 0x82224E1C;
		  /* 82224E1Ch */ case   20:  		/* b 84 */
		/* 82224E1Ch case   20:*/		return 0x82224E70;
		/* 82224E1Ch case   20:*/		return 0x82224E20;
	}
	return 0x82224E20;
} // Block from 82224DCCh-82224E20h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82224E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224E20);
		  /* 82224E20h */ case    0:  		/* cmplwi CR6, R11, 96 */
		/* 82224E20h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 82224E20h case    0:*/		return 0x82224E24;
		  /* 82224E24h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 82224E24h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82224EA0;  }
		/* 82224E24h case    1:*/		return 0x82224E28;
		  /* 82224E28h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224E28h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224E28h case    2:*/		return 0x82224E2C;
		  /* 82224E2Ch */ case    3:  		/* mr R3, R30 */
		/* 82224E2Ch case    3:*/		regs.R3 = regs.R30;
		/* 82224E2Ch case    3:*/		return 0x82224E30;
		  /* 82224E30h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224E30h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224E30h case    4:*/		return 0x82224E34;
		  /* 82224E34h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224E34h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224E34h case    5:*/		return 0x82224E38;
		  /* 82224E38h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82224E38h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82224E38h case    6:*/		return 0x82224E3C;
		  /* 82224E3Ch */ case    7:  		/* bl -789004 */
		/* 82224E3Ch case    7:*/		regs.LR = 0x82224E40; return 0x82164430;
		/* 82224E3Ch case    7:*/		return 0x82224E40;
		  /* 82224E40h */ case    8:  		/* addi R11, R29, -20 */
		/* 82224E40h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFEC);
		/* 82224E40h case    8:*/		return 0x82224E44;
		  /* 82224E44h */ case    9:  		/* add R28, R3, R11 */
		/* 82224E44h case    9:*/		cpu::op::add<0>(regs,&regs.R28,regs.R3,regs.R11);
		/* 82224E44h case    9:*/		return 0x82224E48;
		  /* 82224E48h */ case   10:  		/* lwz R11, <#[R28 + 16]> */
		/* 82224E48h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82224E48h case   10:*/		return 0x82224E4C;
		  /* 82224E4Ch */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82224E4Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82224E4Ch case   11:*/		return 0x82224E50;
		  /* 82224E50h */ case   12:  		/* bc 12, CR6_EQ, 80 */
		/* 82224E50h case   12:*/		if ( regs.CR[6].eq ) { return 0x82224EA0;  }
		/* 82224E50h case   12:*/		return 0x82224E54;
		  /* 82224E54h */ case   13:  		/* lwz R29, <#[R11 + 4]> */
		/* 82224E54h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 82224E54h case   13:*/		return 0x82224E58;
		  /* 82224E58h */ case   14:  		/* li R5, 0 */
		/* 82224E58h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82224E58h case   14:*/		return 0x82224E5C;
		  /* 82224E5Ch */ case   15:  		/* mr R3, R30 */
		/* 82224E5Ch case   15:*/		regs.R3 = regs.R30;
		/* 82224E5Ch case   15:*/		return 0x82224E60;
		  /* 82224E60h */ case   16:  		/* addi R11, R29, 2 */
		/* 82224E60h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x2);
		/* 82224E60h case   16:*/		return 0x82224E64;
		  /* 82224E64h */ case   17:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82224E64h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82224E64h case   17:*/		return 0x82224E68;
		  /* 82224E68h */ case   18:  		/* bl -624704 */
		/* 82224E68h case   18:*/		regs.LR = 0x82224E6C; return 0x8218C628;
		/* 82224E68h case   18:*/		return 0x82224E6C;
		  /* 82224E6Ch */ case   19:  		/* lwz R11, <#[R28 + 16]> */
		/* 82224E6Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82224E6Ch case   19:*/		return 0x82224E70;
	}
	return 0x82224E70;
} // Block from 82224E20h-82224E70h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82224E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224E70);
		  /* 82224E70h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82224E70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82224E70h case    0:*/		return 0x82224E74;
		  /* 82224E74h */ case    1:  		/* mr R28, R3 */
		/* 82224E74h case    1:*/		regs.R28 = regs.R3;
		/* 82224E74h case    1:*/		return 0x82224E78;
		  /* 82224E78h */ case    2:  		/* stw R29, <#[R3 + 4]> */
		/* 82224E78h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		/* 82224E78h case    2:*/		return 0x82224E7C;
		  /* 82224E7Ch */ case    3:  		/* stw R11, <#[R3]> */
		/* 82224E7Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82224E7Ch case    3:*/		return 0x82224E80;
		  /* 82224E80h */ case    4:  		/* mr R3, R30 */
		/* 82224E80h case    4:*/		regs.R3 = regs.R30;
		/* 82224E80h case    4:*/		return 0x82224E84;
		  /* 82224E84h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 82224E84h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82224E84h case    5:*/		return 0x82224E88;
		  /* 82224E88h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224E88h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224E88h case    6:*/		return 0x82224E8C;
		  /* 82224E8Ch */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224E8Ch case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224E8Ch case    7:*/		return 0x82224E90;
		  /* 82224E90h */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82224E90h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82224E90h case    8:*/		return 0x82224E94;
		  /* 82224E94h */ case    9:  		/* bl -789092 */
		/* 82224E94h case    9:*/		regs.LR = 0x82224E98; return 0x82164430;
		/* 82224E94h case    9:*/		return 0x82224E98;
		  /* 82224E98h */ case   10:  		/* addi R11, R31, -4 */
		/* 82224E98h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 82224E98h case   10:*/		return 0x82224E9C;
		  /* 82224E9Ch */ case   11:  		/* stwx R28, <#[R3 + R11]> */
		/* 82224E9Ch case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82224E9Ch case   11:*/		return 0x82224EA0;
	}
	return 0x82224EA0;
} // Block from 82224E70h-82224EA0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82224EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224EA0);
		  /* 82224EA0h */ case    0:  		/* mr R3, R31 */
		/* 82224EA0h case    0:*/		regs.R3 = regs.R31;
		/* 82224EA0h case    0:*/		return 0x82224EA4;
		  /* 82224EA4h */ case    1:  		/* addi R1, R1, 144 */
		/* 82224EA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82224EA4h case    1:*/		return 0x82224EA8;
		  /* 82224EA8h */ case    2:  		/* b -1653772 */
		/* 82224EA8h case    2:*/		return 0x8209129C;
		/* 82224EA8h case    2:*/		return 0x82224EAC;
		  /* 82224EACh */ case    3:  		/* nop */
		/* 82224EACh case    3:*/		cpu::op::nop();
		/* 82224EACh case    3:*/		return 0x82224EB0;
	}
	return 0x82224EB0;
} // Block from 82224EA0h-82224EB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82224EB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224EB0);
		  /* 82224EB0h */ case    0:  		/* mfspr R12, LR */
		/* 82224EB0h case    0:*/		regs.R12 = regs.LR;
		/* 82224EB0h case    0:*/		return 0x82224EB4;
		  /* 82224EB4h */ case    1:  		/* bl -1653852 */
		/* 82224EB4h case    1:*/		regs.LR = 0x82224EB8; return 0x82091258;
		/* 82224EB4h case    1:*/		return 0x82224EB8;
		  /* 82224EB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82224EB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82224EB8h case    2:*/		return 0x82224EBC;
		  /* 82224EBCh */ case    3:  		/* lwz R29, <#[R5 + 12]> */
		/* 82224EBCh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R5 + 0x0000000C) );
		/* 82224EBCh case    3:*/		return 0x82224EC0;
		  /* 82224EC0h */ case    4:  		/* mr R31, R3 */
		/* 82224EC0h case    4:*/		regs.R31 = regs.R3;
		/* 82224EC0h case    4:*/		return 0x82224EC4;
		  /* 82224EC4h */ case    5:  		/* mr R30, R4 */
		/* 82224EC4h case    5:*/		regs.R30 = regs.R4;
		/* 82224EC4h case    5:*/		return 0x82224EC8;
		  /* 82224EC8h */ case    6:  		/* mr R28, R5 */
		/* 82224EC8h case    6:*/		regs.R28 = regs.R5;
		/* 82224EC8h case    6:*/		return 0x82224ECC;
		  /* 82224ECCh */ case    7:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224ECCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224ECCh case    7:*/		return 0x82224ED0;
		  /* 82224ED0h */ case    8:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82224ED0h case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82224ED0h case    8:*/		return 0x82224ED4;
		  /* 82224ED4h */ case    9:  		/* cmplwi CR6, R11, 15872 */
		/* 82224ED4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 82224ED4h case    9:*/		return 0x82224ED8;
		  /* 82224ED8h */ case   10:  		/* bc 4, CR6_EQ, 232 */
		/* 82224ED8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82224FC0;  }
		/* 82224ED8h case   10:*/		return 0x82224EDC;
		  /* 82224EDCh */ case   11:  		/* lwz R11, <#[R29 + 8]> */
		/* 82224EDCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82224EDCh case   11:*/		return 0x82224EE0;
		  /* 82224EE0h */ case   12:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82224EE0h case   12:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82224EE0h case   12:*/		return 0x82224EE4;
		  /* 82224EE4h */ case   13:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82224EE4h case   13:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82224EE4h case   13:*/		return 0x82224EE8;
	}
	return 0x82224EE8;
} // Block from 82224EB0h-82224EE8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82224EE8h
// Function '?EncodeControl@Instruction@D3DXShader@@QAA_NPATGPUFLOW_INSTRUCTION@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224EE8);
		  /* 82224EE8h */ case    0:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82224EE8h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82224EE8h case    0:*/		return 0x82224EEC;
		  /* 82224EECh */ case    1:  		/* bl -789180 */
		/* 82224EECh case    1:*/		regs.LR = 0x82224EF0; return 0x82164430;
		/* 82224EECh case    1:*/		return 0x82224EF0;
		  /* 82224EF0h */ case    2:  		/* addi R10, R29, -8 */
		/* 82224EF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFF8);
		/* 82224EF0h case    2:*/		return 0x82224EF4;
		  /* 82224EF4h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 82224EF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82224EF4h case    3:*/		return 0x82224EF8;
		  /* 82224EF8h */ case    4:  		/* lwzx R10, <#[R3 + R10]> */
		/* 82224EF8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 82224EF8h case    4:*/		return 0x82224EFC;
		  /* 82224EFCh */ case    5:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 82224EFCh case    5:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 82224EFCh case    5:*/		return 0x82224F00;
		  /* 82224F00h */ case    6:  		/* mulli R10, R10, 40 */
		/* 82224F00h case    6:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 82224F00h case    6:*/		return 0x82224F04;
		  /* 82224F04h */ case    7:  		/* add R11, R10, R11 */
		/* 82224F04h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82224F04h case    7:*/		return 0x82224F08;
		  /* 82224F08h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82224F08h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82224F08h case    8:*/		return 0x82224F0C;
		  /* 82224F0Ch */ case    9:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 82224F0Ch case    9:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 82224F0Ch case    9:*/		return 0x82224F10;
		  /* 82224F10h */ case   10:  		/* cmplwi CR6, R11, 48 */
		/* 82224F10h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 82224F10h case   10:*/		return 0x82224F14;
		  /* 82224F14h */ case   11:  		/* bc 4, CR6_EQ, 172 */
		/* 82224F14h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82224FC0;  }
		/* 82224F14h case   11:*/		return 0x82224F18;
		  /* 82224F18h */ case   12:  		/* mr R4, R30 */
		/* 82224F18h case   12:*/		regs.R4 = regs.R30;
		/* 82224F18h case   12:*/		return 0x82224F1C;
		  /* 82224F1Ch */ case   13:  		/* mr R3, R31 */
		/* 82224F1Ch case   13:*/		regs.R3 = regs.R31;
		/* 82224F1Ch case   13:*/		return 0x82224F20;
		  /* 82224F20h */ case   14:  		/* bl -896 */
		/* 82224F20h case   14:*/		regs.LR = 0x82224F24; return 0x82224BA0;
		/* 82224F20h case   14:*/		return 0x82224F24;
		  /* 82224F24h */ case   15:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82224F24h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82224F24h case   15:*/		return 0x82224F28;
		  /* 82224F28h */ case   16:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 82224F28h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 82224F28h case   16:*/		return 0x82224F2C;
		  /* 82224F2Ch */ case   17:  		/* addi R11, R11, 36 */
		/* 82224F2Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82224F2Ch case   17:*/		return 0x82224F30;
		  /* 82224F30h */ case   18:  		/* addi R10, R10, 36 */
		/* 82224F30h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82224F30h case   18:*/		return 0x82224F34;
		  /* 82224F34h */ case   19:  		/* addi R8, R11, -36 */
		/* 82224F34h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82224F34h case   19:*/		return 0x82224F38;
		  /* 82224F38h */ case   20:  		/* addi R6, R10, -36 */
		/* 82224F38h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 82224F38h case   20:*/		return 0x82224F3C;
		  /* 82224F3Ch */ case   21:  		/* addi R9, R10, 4 */
		/* 82224F3Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 82224F3Ch case   21:*/		return 0x82224F40;
		  /* 82224F40h */ case   22:  		/* lwz R7, <#[R11]> */
		/* 82224F40h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82224F40h case   22:*/		return 0x82224F44;
		  /* 82224F44h */ case   23:  		/* mr R4, R28 */
		/* 82224F44h case   23:*/		regs.R4 = regs.R28;
		/* 82224F44h case   23:*/		return 0x82224F48;
		  /* 82224F48h */ case   24:  		/* mr R31, R3 */
		/* 82224F48h case   24:*/		regs.R31 = regs.R3;
		/* 82224F48h case   24:*/		return 0x82224F4C;
		  /* 82224F4Ch */ case   25:  		/* stw R7, <#[R10]> */
		/* 82224F4Ch case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 82224F4Ch case   25:*/		return 0x82224F50;
		  /* 82224F50h */ case   26:  		/* lwz R7, <#[R11]> */
		/* 82224F50h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82224F50h case   26:*/		return 0x82224F54;
		  /* 82224F54h */ case   27:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82224F54h case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82224F54h case   27:*/		return 0x82224F58;
		  /* 82224F58h */ case   28:  		/* stw R6, <#[R7]> */
		/* 82224F58h case   28:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 82224F58h case   28:*/		return 0x82224F5C;
		  /* 82224F5Ch */ case   29:  		/* stw R8, <#[R10 + 4]> */
		/* 82224F5Ch case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82224F5Ch case   29:*/		return 0x82224F60;
		  /* 82224F60h */ case   30:  		/* stw R9, <#[R11]> */
		/* 82224F60h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82224F60h case   30:*/		return 0x82224F64;
		  /* 82224F64h */ case   31:  		/* bl -707996 */
		/* 82224F64h case   31:*/		regs.LR = 0x82224F68; return 0x821781C8;
		/* 82224F64h case   31:*/		return 0x82224F68;
		  /* 82224F68h */ case   32:  		/* stw R3, <#[R31 + 44]> */
		/* 82224F68h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82224F68h case   32:*/		return 0x82224F6C;
		  /* 82224F6Ch */ case   33:  		/* mr R3, R31 */
		/* 82224F6Ch case   33:*/		regs.R3 = regs.R31;
		/* 82224F6Ch case   33:*/		return 0x82224F70;
		  /* 82224F70h */ case   34:  		/* lwz R4, <#[R30 + 48]> */
		/* 82224F70h case   34:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 82224F70h case   34:*/		return 0x82224F74;
		  /* 82224F74h */ case   35:  		/* bl -708012 */
		/* 82224F74h case   35:*/		regs.LR = 0x82224F78; return 0x821781C8;
		/* 82224F74h case   35:*/		return 0x82224F78;
		  /* 82224F78h */ case   36:  		/* stw R3, <#[R31 + 48]> */
		/* 82224F78h case   36:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82224F78h case   36:*/		return 0x82224F7C;
		  /* 82224F7Ch */ case   37:  		/* lwz R29, <#[R30]> */
		/* 82224F7Ch case   37:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000000) );
		/* 82224F7Ch case   37:*/		return 0x82224F80;
		  /* 82224F80h */ case   38:  		/* cmplwi CR6, R29, 0 */
		/* 82224F80h case   38:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82224F80h case   38:*/		return 0x82224F84;
		  /* 82224F84h */ case   39:  		/* bc 12, CR6_EQ, 48 */
		/* 82224F84h case   39:*/		if ( regs.CR[6].eq ) { return 0x82224FB4;  }
		/* 82224F84h case   39:*/		return 0x82224F88;
		  /* 82224F88h */ case   40:  		/* lwz R11, <#[R30 + 44]> */
		/* 82224F88h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 82224F88h case   40:*/		return 0x82224F8C;
		  /* 82224F8Ch */ case   41:  		/* cmplw CR6, R29, R11 */
		/* 82224F8Ch case   41:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82224F8Ch case   41:*/		return 0x82224F90;
		  /* 82224F90h */ case   42:  		/* bc 12, CR6_EQ, 28 */
		/* 82224F90h case   42:*/		if ( regs.CR[6].eq ) { return 0x82224FAC;  }
		/* 82224F90h case   42:*/		return 0x82224F94;
		  /* 82224F94h */ case   43:  		/* lwz R11, <#[R30 + 48]> */
		/* 82224F94h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 82224F94h case   43:*/		return 0x82224F98;
		  /* 82224F98h */ case   44:  		/* cmplw CR6, R29, R11 */
		/* 82224F98h case   44:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82224F98h case   44:*/		return 0x82224F9C;
		  /* 82224F9Ch */ case   45:  		/* bc 12, CR6_EQ, 16 */
		/* 82224F9Ch case   45:*/		if ( regs.CR[6].eq ) { return 0x82224FAC;  }
		/* 82224F9Ch case   45:*/		return 0x82224FA0;
		  /* 82224FA0h */ case   46:  		/* mr R4, R29 */
		/* 82224FA0h case   46:*/		regs.R4 = regs.R29;
		/* 82224FA0h case   46:*/		return 0x82224FA4;
		  /* 82224FA4h */ case   47:  		/* mr R3, R31 */
		/* 82224FA4h case   47:*/		regs.R3 = regs.R31;
		/* 82224FA4h case   47:*/		return 0x82224FA8;
		  /* 82224FA8h */ case   48:  		/* bl -708064 */
		/* 82224FA8h case   48:*/		regs.LR = 0x82224FAC; return 0x821781C8;
		/* 82224FA8h case   48:*/		return 0x82224FAC;
	}
	return 0x82224FAC;
} // Block from 82224EE8h-82224FACh (49 instructions)

//////////////////////////////////////////////////////
// Block at 82224FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224FAC);
		  /* 82224FACh */ case    0:  		/* lwz R29, <#[R29 + 4]> */
		/* 82224FACh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 82224FACh case    0:*/		return 0x82224FB0;
		  /* 82224FB0h */ case    1:  		/* b -48 */
		/* 82224FB0h case    1:*/		return 0x82224F80;
		/* 82224FB0h case    1:*/		return 0x82224FB4;
	}
	return 0x82224FB4;
} // Block from 82224FACh-82224FB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82224FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224FB4);
		  /* 82224FB4h */ case    0:  		/* mr R3, R31 */
		/* 82224FB4h case    0:*/		regs.R3 = regs.R31;
		/* 82224FB4h case    0:*/		return 0x82224FB8;
		  /* 82224FB8h */ case    1:  		/* addi R1, R1, 128 */
		/* 82224FB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82224FB8h case    1:*/		return 0x82224FBC;
		  /* 82224FBCh */ case    2:  		/* b -1654036 */
		/* 82224FBCh case    2:*/		return 0x820912A8;
		/* 82224FBCh case    2:*/		return 0x82224FC0;
	}
	return 0x82224FC0;
} // Block from 82224FB4h-82224FC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82224FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224FC0);
		  /* 82224FC0h */ case    0:  		/* li R4, 4801 */
		/* 82224FC0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 82224FC0h case    0:*/		return 0x82224FC4;
		  /* 82224FC4h */ case    1:  		/* mr R3, R31 */
		/* 82224FC4h case    1:*/		regs.R3 = regs.R31;
		/* 82224FC4h case    1:*/		return 0x82224FC8;
		  /* 82224FC8h */ case    2:  		/* bl -864608 */
		/* 82224FC8h case    2:*/		regs.LR = 0x82224FCC; return 0x82151E68;
		/* 82224FC8h case    2:*/		return 0x82224FCC;
		  /* 82224FCCh */ case    3:  		/* nop */
		/* 82224FCCh case    3:*/		cpu::op::nop();
		/* 82224FCCh case    3:*/		return 0x82224FD0;
	}
	return 0x82224FD0;
} // Block from 82224FC0h-82224FD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82224FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82224FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82224FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82224FD0);
		  /* 82224FD0h */ case    0:  		/* mfspr R12, LR */
		/* 82224FD0h case    0:*/		regs.R12 = regs.LR;
		/* 82224FD0h case    0:*/		return 0x82224FD4;
		  /* 82224FD4h */ case    1:  		/* bl -1654164 */
		/* 82224FD4h case    1:*/		regs.LR = 0x82224FD8; return 0x82091240;
		/* 82224FD4h case    1:*/		return 0x82224FD8;
		  /* 82224FD8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82224FD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82224FD8h case    2:*/		return 0x82224FDC;
		  /* 82224FDCh */ case    3:  		/* std R4, <#[R1 + 208]> */
		/* 82224FDCh case    3:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x000000D0) );
		/* 82224FDCh case    3:*/		return 0x82224FE0;
		  /* 82224FE0h */ case    4:  		/* mr R31, R3 */
		/* 82224FE0h case    4:*/		regs.R31 = regs.R3;
		/* 82224FE0h case    4:*/		return 0x82224FE4;
		  /* 82224FE4h */ case    5:  		/* lwz R28, <#[R1 + 212]> */
		/* 82224FE4h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000D4) );
		/* 82224FE4h case    5:*/		return 0x82224FE8;
		  /* 82224FE8h */ case    6:  		/* rlwinm R25, R28, 0, 27, 31 */
		/* 82224FE8h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R25,regs.R28);
		/* 82224FE8h case    6:*/		return 0x82224FEC;
		  /* 82224FECh */ case    7:  		/* std R5, <#[R1 + 216]> */
		/* 82224FECh case    7:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x000000D8) );
		/* 82224FECh case    7:*/		return 0x82224FF0;
		  /* 82224FF0h */ case    8:  		/* mr R23, R6 */
		/* 82224FF0h case    8:*/		regs.R23 = regs.R6;
		/* 82224FF0h case    8:*/		return 0x82224FF4;
		  /* 82224FF4h */ case    9:  		/* li R22, 1 */
		/* 82224FF4h case    9:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82224FF4h case    9:*/		return 0x82224FF8;
		  /* 82224FF8h */ case   10:  		/* mr R29, R6 */
		/* 82224FF8h case   10:*/		regs.R29 = regs.R6;
		/* 82224FF8h case   10:*/		return 0x82224FFC;
		  /* 82224FFCh */ case   11:  		/* rlwinm R24, R28, 27, 28, 31 */
		/* 82224FFCh case   11:*/		cpu::op::rlwinm<0,27,28,31>(regs,&regs.R24,regs.R28);
		/* 82224FFCh case   11:*/		return 0x82225000;
		  /* 82225000h */ case   12:  		/* mr R27, R25 */
		/* 82225000h case   12:*/		regs.R27 = regs.R25;
		/* 82225000h case   12:*/		return 0x82225004;
		  /* 82225004h */ case   13:  		/* li R26, 0 */
		/* 82225004h case   13:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82225004h case   13:*/		return 0x82225008;
		  /* 82225008h */ case   14:  		/* cmplwi CR6, R25, 16 */
		/* 82225008h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000010);
		/* 82225008h case   14:*/		return 0x8222500C;
		  /* 8222500Ch */ case   15:  		/* bc 12, CR6_EQ, 40 */
		/* 8222500Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82225034;  }
		/* 8222500Ch case   15:*/		return 0x82225010;
		  /* 82225010h */ case   16:  		/* cmplwi CR6, R25, 14 */
		/* 82225010h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x0000000E);
		/* 82225010h case   16:*/		return 0x82225014;
		  /* 82225014h */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 82225014h case   17:*/		if ( regs.CR[6].eq ) { return 0x82225034;  }
		/* 82225014h case   17:*/		return 0x82225018;
		  /* 82225018h */ case   18:  		/* cmplwi CR6, R25, 15 */
		/* 82225018h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x0000000F);
		/* 82225018h case   18:*/		return 0x8222501C;
		  /* 8222501Ch */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 8222501Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82225034;  }
		/* 8222501Ch case   19:*/		return 0x82225020;
		  /* 82225020h */ case   20:  		/* cmplwi CR6, R25, 18 */
		/* 82225020h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000012);
		/* 82225020h case   20:*/		return 0x82225024;
		  /* 82225024h */ case   21:  		/* bc 12, CR6_EQ, 16 */
		/* 82225024h case   21:*/		if ( regs.CR[6].eq ) { return 0x82225034;  }
		/* 82225024h case   21:*/		return 0x82225028;
		  /* 82225028h */ case   22:  		/* li R27, 16 */
		/* 82225028h case   22:*/		cpu::op::li<0>(regs,&regs.R27,0x10);
		/* 82225028h case   22:*/		return 0x8222502C;
		  /* 8222502Ch */ case   23:  		/* mr R29, R22 */
		/* 8222502Ch case   23:*/		regs.R29 = regs.R22;
		/* 8222502Ch case   23:*/		return 0x82225030;
		  /* 82225030h */ case   24:  		/* mr R26, R22 */
		/* 82225030h case   24:*/		regs.R26 = regs.R22;
		/* 82225030h case   24:*/		return 0x82225034;
	}
	return 0x82225034;
} // Block from 82224FD0h-82225034h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82225034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225034);
		  /* 82225034h */ case    0:  		/* cmplwi CR6, R29, 4 */
		/* 82225034h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 82225034h case    0:*/		return 0x82225038;
		  /* 82225038h */ case    1:  		/* bc 4, CR6_GT, 16 */
		/* 82225038h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82225048;  }
		/* 82225038h case    1:*/		return 0x8222503C;
		  /* 8222503Ch */ case    2:  		/* li R4, 4801 */
		/* 8222503Ch case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8222503Ch case    2:*/		return 0x82225040;
		  /* 82225040h */ case    3:  		/* mr R3, R31 */
		/* 82225040h case    3:*/		regs.R3 = regs.R31;
		/* 82225040h case    3:*/		return 0x82225044;
		  /* 82225044h */ case    4:  		/* bl -864732 */
		/* 82225044h case    4:*/		regs.LR = 0x82225048; return 0x82151E68;
		/* 82225044h case    4:*/		return 0x82225048;
	}
	return 0x82225048;
} // Block from 82225034h-82225048h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82225048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225048);
		  /* 82225048h */ case    0:  		/* lwz R10, <#[R31 + 536]> */
		/* 82225048h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000218) );
		/* 82225048h case    0:*/		return 0x8222504C;
		  /* 8222504Ch */ case    1:  		/* li R11, 0 */
		/* 8222504Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222504Ch case    1:*/		return 0x82225050;
		  /* 82225050h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82225050h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82225050h case    2:*/		return 0x82225054;
		  /* 82225054h */ case    3:  		/* bc 4, CR6_GT, 124 */
		/* 82225054h case    3:*/		if ( !regs.CR[6].gt ) { return 0x822250D0;  }
		/* 82225054h case    3:*/		return 0x82225058;
		  /* 82225058h */ case    4:  		/* addi R10, R31, 348 */
		/* 82225058h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x15C);
		/* 82225058h case    4:*/		return 0x8222505C;
		  /* 8222505Ch */ case    5:  		/* lwz R9, <#[R10]> */
		/* 8222505Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222505Ch case    5:*/		return 0x82225060;
		  /* 82225060h */ case    6:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82225060h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82225060h case    6:*/		return 0x82225064;
		  /* 82225064h */ case    7:  		/* cmplw CR6, R27, R9 */
		/* 82225064h case    7:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R9);
		/* 82225064h case    7:*/		return 0x82225068;
		  /* 82225068h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 82225068h case    8:*/		if ( regs.CR[6].eq ) { return 0x82225084;  }
		/* 82225068h case    8:*/		return 0x8222506C;
		  /* 8222506Ch */ case    9:  		/* lwz R9, <#[R31 + 536]> */
		/* 8222506Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000218) );
		/* 8222506Ch case    9:*/		return 0x82225070;
		  /* 82225070h */ case   10:  		/* addi R11, R11, 1 */
		/* 82225070h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82225070h case   10:*/		return 0x82225074;
		  /* 82225074h */ case   11:  		/* addi R10, R10, 12 */
		/* 82225074h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82225074h case   11:*/		return 0x82225078;
		  /* 82225078h */ case   12:  		/* cmplw CR6, R11, R9 */
		/* 82225078h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82225078h case   12:*/		return 0x8222507C;
		  /* 8222507Ch */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 8222507Ch case   13:*/		if ( regs.CR[6].lt ) { return 0x8222505C;  }
		/* 8222507Ch case   13:*/		return 0x82225080;
		  /* 82225080h */ case   14:  		/* b 80 */
		/* 82225080h case   14:*/		return 0x822250D0;
		/* 82225080h case   14:*/		return 0x82225084;
	}
	return 0x82225084;
} // Block from 82225048h-82225084h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82225084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225084);
		  /* 82225084h */ case    0:  		/* addi R10, R11, 29 */
		/* 82225084h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1D);
		/* 82225084h case    0:*/		return 0x82225088;
		  /* 82225088h */ case    1:  		/* mulli R11, R11, 12 */
		/* 82225088h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82225088h case    1:*/		return 0x8222508C;
		  /* 8222508Ch */ case    2:  		/* mulli R10, R10, 12 */
		/* 8222508Ch case    2:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8222508Ch case    2:*/		return 0x82225090;
		  /* 82225090h */ case    3:  		/* lwzx R9, <#[R10 + R31]> */
		/* 82225090h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82225090h case    3:*/		return 0x82225094;
		  /* 82225094h */ case    4:  		/* add R11, R11, R31 */
		/* 82225094h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82225094h case    4:*/		return 0x82225098;
		  /* 82225098h */ case    5:  		/* rlwinm. R9, R9, 0, 12, 12 */
		/* 82225098h case    5:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R9,regs.R9);
		/* 82225098h case    5:*/		return 0x8222509C;
		  /* 8222509Ch */ case    6:  		/* lwz R30, <#[R11 + 352]> */
		/* 8222509Ch case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000160) );
		/* 8222509Ch case    6:*/		return 0x822250A0;
		  /* 822250A0h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 822250A0h case    7:*/		if ( regs.CR[0].eq ) { return 0x822250C8;  }
		/* 822250A0h case    7:*/		return 0x822250A4;
		  /* 822250A4h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 822250A4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822250A4h case    8:*/		return 0x822250A8;
		  /* 822250A8h */ case    9:  		/* rlwinm R9, R11, 18, 29, 31 */
		/* 822250A8h case    9:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R11);
		/* 822250A8h case    9:*/		return 0x822250AC;
		  /* 822250ACh */ case   10:  		/* cmplw CR6, R29, R9 */
		/* 822250ACh case   10:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R9);
		/* 822250ACh case   10:*/		return 0x822250B0;
		  /* 822250B0h */ case   11:  		/* bc 4, CR6_GT, 24 */
		/* 822250B0h case   11:*/		if ( !regs.CR[6].gt ) { return 0x822250C8;  }
		/* 822250B0h case   11:*/		return 0x822250B4;
		  /* 822250B4h */ case   12:  		/* rlwimi R11, R29, 14, 15, 17 */
		/* 822250B4h case   12:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R29);
		/* 822250B4h case   12:*/		return 0x822250B8;
		  /* 822250B8h */ case   13:  		/* stw R11, <#[R30 + 8]> */
		/* 822250B8h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 822250B8h case   13:*/		return 0x822250BC;
		  /* 822250BCh */ case   14:  		/* lwzx R11, <#[R10 + R31]> */
		/* 822250BCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 822250BCh case   14:*/		return 0x822250C0;
		  /* 822250C0h */ case   15:  		/* rlwinm R11, R11, 0, 13, 11 */
		/* 822250C0h case   15:*/		cpu::op::rlwinm<0,0,13,11>(regs,&regs.R11,regs.R11);
		/* 822250C0h case   15:*/		return 0x822250C4;
		  /* 822250C4h */ case   16:  		/* stwx R11, <#[R10 + R31]> */
		/* 822250C4h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 822250C4h case   16:*/		return 0x822250C8;
	}
	return 0x822250C8;
} // Block from 82225084h-822250C8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822250C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822250C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822250C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822250C8);
		  /* 822250C8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 822250C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822250C8h case    0:*/		return 0x822250CC;
		  /* 822250CCh */ case    1:  		/* bc 4, CR6_EQ, 456 */
		/* 822250CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82225294;  }
		/* 822250CCh case    1:*/		return 0x822250D0;
	}
	return 0x822250D0;
} // Block from 822250C8h-822250D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822250D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822250D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822250D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822250D0);
		  /* 822250D0h */ case    0:  		/* mr R6, R29 */
		/* 822250D0h case    0:*/		regs.R6 = regs.R29;
		/* 822250D0h case    0:*/		return 0x822250D4;
		  /* 822250D4h */ case    1:  		/* li R5, 0 */
		/* 822250D4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822250D4h case    1:*/		return 0x822250D8;
		  /* 822250D8h */ case    2:  		/* li R4, 113 */
		/* 822250D8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x71);
		/* 822250D8h case    2:*/		return 0x822250DC;
		  /* 822250DCh */ case    3:  		/* mr R3, R31 */
		/* 822250DCh case    3:*/		regs.R3 = regs.R31;
		/* 822250DCh case    3:*/		return 0x822250E0;
		  /* 822250E0h */ case    4:  		/* bl -789680 */
		/* 822250E0h case    4:*/		regs.LR = 0x822250E4; return 0x82164430;
		/* 822250E0h case    4:*/		return 0x822250E4;
		  /* 822250E4h */ case    5:  		/* mr R4, R3 */
		/* 822250E4h case    5:*/		regs.R4 = regs.R3;
		/* 822250E4h case    5:*/		return 0x822250E8;
		  /* 822250E8h */ case    6:  		/* mr R3, R31 */
		/* 822250E8h case    6:*/		regs.R3 = regs.R31;
		/* 822250E8h case    6:*/		return 0x822250EC;
		  /* 822250ECh */ case    7:  		/* li R5, 35 */
		/* 822250ECh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 822250ECh case    7:*/		return 0x822250F0;
		  /* 822250F0h */ case    8:  		/* bl -755016 */
		/* 822250F0h case    8:*/		regs.LR = 0x822250F4; return 0x8216CBA8;
		/* 822250F0h case    8:*/		return 0x822250F4;
		  /* 822250F4h */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 822250F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822250F4h case    9:*/		return 0x822250F8;
		  /* 822250F8h */ case   10:  		/* mr R8, R29 */
		/* 822250F8h case   10:*/		regs.R8 = regs.R29;
		/* 822250F8h case   10:*/		return 0x822250FC;
		  /* 822250FCh */ case   11:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 822250FCh case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 822250FCh case   11:*/		return 0x82225100;
		  /* 82225100h */ case   12:  		/* li R7, 0 */
		/* 82225100h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82225100h case   12:*/		return 0x82225104;
		  /* 82225104h */ case   13:  		/* addic R10, R10, -1 */
		/* 82225104h case   13:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82225104h case   13:*/		return 0x82225108;
		  /* 82225108h */ case   14:  		/* li R6, 113 */
		/* 82225108h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x71);
		/* 82225108h case   14:*/		return 0x8222510C;
		  /* 8222510Ch */ case   15:  		/* subfe R10, R10, R10 */
		/* 8222510Ch case   15:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222510Ch case   15:*/		return 0x82225110;
		  /* 82225110h */ case   16:  		/* mr R4, R31 */
		/* 82225110h case   16:*/		regs.R4 = regs.R31;
		/* 82225110h case   16:*/		return 0x82225114;
		  /* 82225114h */ case   17:  		/* and R5, R10, R11 */
		/* 82225114h case   17:*/		cpu::op::and<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 82225114h case   17:*/		return 0x82225118;
		  /* 82225118h */ case   18:  		/* mr R30, R3 */
		/* 82225118h case   18:*/		regs.R30 = regs.R3;
		/* 82225118h case   18:*/		return 0x8222511C;
		  /* 8222511Ch */ case   19:  		/* bl -3588 */
		/* 8222511Ch case   19:*/		regs.LR = 0x82225120; return 0x82224318;
		/* 8222511Ch case   19:*/		return 0x82225120;
		  /* 82225120h */ case   20:  		/* lwz R10, <#[R30 + 8]> */
		/* 82225120h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82225120h case   20:*/		return 0x82225124;
		  /* 82225124h */ case   21:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82225124h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82225124h case   21:*/		return 0x82225128;
		  /* 82225128h */ case   22:  		/* oris R10, R10, 128 */
		/* 82225128h case   22:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x80);
		/* 82225128h case   22:*/		return 0x8222512C;
		  /* 8222512Ch */ case   23:  		/* addi R11, R11, 36 */
		/* 8222512Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8222512Ch case   23:*/		return 0x82225130;
		  /* 82225130h */ case   24:  		/* stw R10, <#[R30 + 8]> */
		/* 82225130h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82225130h case   24:*/		return 0x82225134;
		  /* 82225134h */ case   25:  		/* addi R7, R11, -36 */
		/* 82225134h case   25:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82225134h case   25:*/		return 0x82225138;
		  /* 82225138h */ case   26:  		/* addi R9, R11, 4 */
		/* 82225138h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82225138h case   26:*/		return 0x8222513C;
		  /* 8222513Ch */ case   27:  		/* lwz R10, <#[R31 + 4]> */
		/* 8222513Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8222513Ch case   27:*/		return 0x82225140;
		  /* 82225140h */ case   28:  		/* rlwinm R8, R10, 0, 31, 31 */
		/* 82225140h case   28:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R10);
		/* 82225140h case   28:*/		return 0x82225144;
		  /* 82225144h */ case   29:  		/* addic R8, R8, -1 */
		/* 82225144h case   29:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82225144h case   29:*/		return 0x82225148;
		  /* 82225148h */ case   30:  		/* subfe R8, R8, R8 */
		/* 82225148h case   30:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 82225148h case   30:*/		return 0x8222514C;
		  /* 8222514Ch */ case   31:  		/* and R10, R8, R10 */
		/* 8222514Ch case   31:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8222514Ch case   31:*/		return 0x82225150;
		  /* 82225150h */ case   32:  		/* addi R8, R10, 16 */
		/* 82225150h case   32:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x10);
		/* 82225150h case   32:*/		return 0x82225154;
		  /* 82225154h */ case   33:  		/* addi R8, R8, -36 */
		/* 82225154h case   33:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFDC);
		/* 82225154h case   33:*/		return 0x82225158;
		  /* 82225158h */ case   34:  		/* lwz R6, <#[R10 + 16]> */
		/* 82225158h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82225158h case   34:*/		return 0x8222515C;
		  /* 8222515Ch */ case   35:  		/* stw R6, <#[R11]> */
		/* 8222515Ch case   35:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8222515Ch case   35:*/		return 0x82225160;
		  /* 82225160h */ case   36:  		/* ori R8, R8, 1 */
		/* 82225160h case   36:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82225160h case   36:*/		return 0x82225164;
		  /* 82225164h */ case   37:  		/* lwz R6, <#[R10 + 16]> */
		/* 82225164h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82225164h case   37:*/		return 0x82225168;
		  /* 82225168h */ case   38:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82225168h case   38:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82225168h case   38:*/		return 0x8222516C;
		  /* 8222516Ch */ case   39:  		/* stw R7, <#[R6]> */
		/* 8222516Ch case   39:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8222516Ch case   39:*/		return 0x82225170;
		  /* 82225170h */ case   40:  		/* stw R8, <#[R11 + 4]> */
		/* 82225170h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82225170h case   40:*/		return 0x82225174;
		  /* 82225174h */ case   41:  		/* stw R9, <#[R10 + 16]> */
		/* 82225174h case   41:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 82225174h case   41:*/		return 0x82225178;
		  /* 82225178h */ case   42:  		/* lwz R11, <#[R30 + 12]> */
		/* 82225178h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82225178h case   42:*/		return 0x8222517C;
		  /* 8222517Ch */ case   43:  		/* lwz R10, <#[R30 + 8]> */
		/* 8222517Ch case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8222517Ch case   43:*/		return 0x82225180;
		  /* 82225180h */ case   44:  		/* oris R10, R10, 2048 */
		/* 82225180h case   44:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 82225180h case   44:*/		return 0x82225184;
		  /* 82225184h */ case   45:  		/* andi. R9, R11, 34952 */
		/* 82225184h case   45:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R11,0x8888);
		/* 82225184h case   45:*/		return 0x82225188;
		  /* 82225188h */ case   46:  		/* stw R10, <#[R30 + 8]> */
		/* 82225188h case   46:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82225188h case   46:*/		return 0x8222518C;
		  /* 8222518Ch */ case   47:  		/* cmplwi CR6, R9, 34952 */
		/* 8222518Ch case   47:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00008888);
		/* 8222518Ch case   47:*/		return 0x82225190;
		  /* 82225190h */ case   48:  		/* bc 12, CR6_EQ, 12 */
		/* 82225190h case   48:*/		if ( regs.CR[6].eq ) { return 0x8222519C;  }
		/* 82225190h case   48:*/		return 0x82225194;
		  /* 82225194h */ case   49:  		/* ori R11, R11, 34952 */
		/* 82225194h case   49:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8888);
		/* 82225194h case   49:*/		return 0x82225198;
		  /* 82225198h */ case   50:  		/* sth R11, <#[R30 + 14]> */
		/* 82225198h case   50:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x0000000E) );
		/* 82225198h case   50:*/		return 0x8222519C;
	}
	return 0x8222519C;
} // Block from 822250D0h-8222519Ch (51 instructions)

//////////////////////////////////////////////////////
// Block at 8222519Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222519C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222519C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222519C);
		  /* 8222519Ch */ case    0:  		/* lwz R11, <#[R31 + 536]> */
		/* 8222519Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 8222519Ch case    0:*/		return 0x822251A0;
		  /* 822251A0h */ case    1:  		/* cmplwi CR6, R11, 16 */
		/* 822251A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 822251A0h case    1:*/		return 0x822251A4;
		  /* 822251A4h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 822251A4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822251B4;  }
		/* 822251A4h case    2:*/		return 0x822251A8;
	}
	return 0x822251A8;
} // Block from 8222519Ch-822251A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822251A8h
// Function '?PlaceInstruction@Compiler@D3DXShader@@QAAXPAVInstruction@2@UInstructionPlacementPoint@12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822251A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822251A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822251A8);
		  /* 822251A8h */ case    0:  		/* li R4, 4800 */
		/* 822251A8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822251A8h case    0:*/		return 0x822251AC;
		  /* 822251ACh */ case    1:  		/* mr R3, R31 */
		/* 822251ACh case    1:*/		regs.R3 = regs.R31;
		/* 822251ACh case    1:*/		return 0x822251B0;
		  /* 822251B0h */ case    2:  		/* bl -865096 */
		/* 822251B0h case    2:*/		regs.LR = 0x822251B4; return 0x82151E68;
		/* 822251B0h case    2:*/		return 0x822251B4;
	}
	return 0x822251B4;
} // Block from 822251A8h-822251B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822251B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822251B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822251B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822251B4);
		  /* 822251B4h */ case    0:  		/* cmplw CR6, R27, R25 */
		/* 822251B4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 822251B4h case    0:*/		return 0x822251B8;
		  /* 822251B8h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 822251B8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822251D0;  }
		/* 822251B8h case    1:*/		return 0x822251BC;
		  /* 822251BCh */ case    2:  		/* cmplwi CR6, R24, 0 */
		/* 822251BCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 822251BCh case    2:*/		return 0x822251C0;
		  /* 822251C0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 822251C0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822251D0;  }
		/* 822251C0h case    3:*/		return 0x822251C4;
		  /* 822251C4h */ case    4:  		/* li R4, 4800 */
		/* 822251C4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822251C4h case    4:*/		return 0x822251C8;
		  /* 822251C8h */ case    5:  		/* mr R3, R31 */
		/* 822251C8h case    5:*/		regs.R3 = regs.R31;
		/* 822251C8h case    5:*/		return 0x822251CC;
		  /* 822251CCh */ case    6:  		/* bl -865124 */
		/* 822251CCh case    6:*/		regs.LR = 0x822251D0; return 0x82151E68;
		/* 822251CCh case    6:*/		return 0x822251D0;
	}
	return 0x822251D0;
} // Block from 822251B4h-822251D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822251D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822251D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822251D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822251D0);
		  /* 822251D0h */ case    0:  		/* mulli R11, R11, 12 */
		/* 822251D0h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822251D0h case    0:*/		return 0x822251D4;
		  /* 822251D4h */ case    1:  		/* add R11, R11, R31 */
		/* 822251D4h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 822251D4h case    1:*/		return 0x822251D8;
		  /* 822251D8h */ case    2:  		/* rlwinm R9, R26, 0, 24, 31 */
		/* 822251D8h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R26);
		/* 822251D8h case    2:*/		return 0x822251DC;
		  /* 822251DCh */ case    3:  		/* cmplwi CR6, R27, 16 */
		/* 822251DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000010);
		/* 822251DCh case    3:*/		return 0x822251E0;
		  /* 822251E0h */ case    4:  		/* stw R30, <#[R11 + 352]> */
		/* 822251E0h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000160) );
		/* 822251E0h case    4:*/		return 0x822251E4;
		  /* 822251E4h */ case    5:  		/* slw R11, R22, R29 */
		/* 822251E4h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R29);
		/* 822251E4h case    5:*/		return 0x822251E8;
		  /* 822251E8h */ case    6:  		/* addi R10, R11, -1 */
		/* 822251E8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 822251E8h case    6:*/		return 0x822251EC;
		  /* 822251ECh */ case    7:  		/* lwz R11, <#[R31 + 536]> */
		/* 822251ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 822251ECh case    7:*/		return 0x822251F0;
		  /* 822251F0h */ case    8:  		/* addi R11, R11, 29 */
		/* 822251F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D);
		/* 822251F0h case    8:*/		return 0x822251F4;
		  /* 822251F4h */ case    9:  		/* mulli R11, R11, 12 */
		/* 822251F4h case    9:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822251F4h case    9:*/		return 0x822251F8;
		  /* 822251F8h */ case   10:  		/* lwzx R8, <#[R11 + R31]> */
		/* 822251F8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822251F8h case   10:*/		return 0x822251FC;
		  /* 822251FCh */ case   11:  		/* rlwimi R8, R27, 0, 27, 31 */
		/* 822251FCh case   11:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R8,regs.R27);
		/* 822251FCh case   11:*/		return 0x82225200;
		  /* 82225200h */ case   12:  		/* stwx R8, <#[R11 + R31]> */
		/* 82225200h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225200h case   12:*/		return 0x82225204;
		  /* 82225204h */ case   13:  		/* lwz R11, <#[R31 + 536]> */
		/* 82225204h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 82225204h case   13:*/		return 0x82225208;
		  /* 82225208h */ case   14:  		/* addi R11, R11, 29 */
		/* 82225208h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D);
		/* 82225208h case   14:*/		return 0x8222520C;
		  /* 8222520Ch */ case   15:  		/* mulli R11, R11, 12 */
		/* 8222520Ch case   15:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8222520Ch case   15:*/		return 0x82225210;
		  /* 82225210h */ case   16:  		/* lwzx R8, <#[R11 + R31]> */
		/* 82225210h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225210h case   16:*/		return 0x82225214;
		  /* 82225214h */ case   17:  		/* rlwinm R8, R8, 0, 27, 22 */
		/* 82225214h case   17:*/		cpu::op::rlwinm<0,0,27,22>(regs,&regs.R8,regs.R8);
		/* 82225214h case   17:*/		return 0x82225218;
		  /* 82225218h */ case   18:  		/* stwx R8, <#[R11 + R31]> */
		/* 82225218h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225218h case   18:*/		return 0x8222521C;
		  /* 8222521Ch */ case   19:  		/* lwz R11, <#[R31 + 536]> */
		/* 8222521Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 8222521Ch case   19:*/		return 0x82225220;
		  /* 82225220h */ case   20:  		/* addi R11, R11, 29 */
		/* 82225220h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D);
		/* 82225220h case   20:*/		return 0x82225224;
		  /* 82225224h */ case   21:  		/* mulli R11, R11, 12 */
		/* 82225224h case   21:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82225224h case   21:*/		return 0x82225228;
		  /* 82225228h */ case   22:  		/* lwzx R8, <#[R11 + R31]> */
		/* 82225228h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225228h case   22:*/		return 0x8222522C;
		  /* 8222522Ch */ case   23:  		/* rlwimi R8, R10, 9, 19, 22 */
		/* 8222522Ch case   23:*/		cpu::op::rlwimi<0,9,19,22>(regs,&regs.R8,regs.R10);
		/* 8222522Ch case   23:*/		return 0x82225230;
		  /* 82225230h */ case   24:  		/* stwx R8, <#[R11 + R31]> */
		/* 82225230h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225230h case   24:*/		return 0x82225234;
		  /* 82225234h */ case   25:  		/* lwz R11, <#[R31 + 536]> */
		/* 82225234h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 82225234h case   25:*/		return 0x82225238;
		  /* 82225238h */ case   26:  		/* addi R11, R11, 29 */
		/* 82225238h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D);
		/* 82225238h case   26:*/		return 0x8222523C;
		  /* 8222523Ch */ case   27:  		/* mulli R11, R11, 12 */
		/* 8222523Ch case   27:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8222523Ch case   27:*/		return 0x82225240;
		  /* 82225240h */ case   28:  		/* lwzx R10, <#[R11 + R31]> */
		/* 82225240h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225240h case   28:*/		return 0x82225244;
		  /* 82225244h */ case   29:  		/* rlwimi R28, R10, 0, 19, 17 */
		/* 82225244h case   29:*/		cpu::op::rlwimi<0,0,19,17>(regs,&regs.R28,regs.R10);
		/* 82225244h case   29:*/		return 0x82225248;
		  /* 82225248h */ case   30:  		/* stwx R28, <#[R11 + R31]> */
		/* 82225248h case   30:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225248h case   30:*/		return 0x8222524C;
		  /* 8222524Ch */ case   31:  		/* lwz R11, <#[R31 + 536]> */
		/* 8222524Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 8222524Ch case   31:*/		return 0x82225250;
		  /* 82225250h */ case   32:  		/* addi R11, R11, 29 */
		/* 82225250h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1D);
		/* 82225250h case   32:*/		return 0x82225254;
		  /* 82225254h */ case   33:  		/* mulli R11, R11, 12 */
		/* 82225254h case   33:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82225254h case   33:*/		return 0x82225258;
		  /* 82225258h */ case   34:  		/* lwzx R10, <#[R11 + R31]> */
		/* 82225258h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225258h case   34:*/		return 0x8222525C;
		  /* 8222525Ch */ case   35:  		/* rlwimi R10, R9, 19, 12, 12 */
		/* 8222525Ch case   35:*/		cpu::op::rlwimi<0,19,12,12>(regs,&regs.R10,regs.R9);
		/* 8222525Ch case   35:*/		return 0x82225260;
		  /* 82225260h */ case   36:  		/* stwx R10, <#[R11 + R31]> */
		/* 82225260h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82225260h case   36:*/		return 0x82225264;
		  /* 82225264h */ case   37:  		/* lwz R11, <#[R31 + 536]> */
		/* 82225264h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 82225264h case   37:*/		return 0x82225268;
		  /* 82225268h */ case   38:  		/* mulli R11, R11, 12 */
		/* 82225268h case   38:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82225268h case   38:*/		return 0x8222526C;
		  /* 8222526Ch */ case   39:  		/* add R11, R11, R31 */
		/* 8222526Ch case   39:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8222526Ch case   39:*/		return 0x82225270;
		  /* 82225270h */ case   40:  		/* bc 4, CR6_EQ, 16 */
		/* 82225270h case   40:*/		if ( !regs.CR[6].eq ) { return 0x82225280;  }
		/* 82225270h case   40:*/		return 0x82225274;
		  /* 82225274h */ case   41:  		/* lis R10, -32252 */
		/* 82225274h case   41:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82225274h case   41:*/		return 0x82225278;
		  /* 82225278h */ case   42:  		/* addi R10, R10, -16096 */
		/* 82225278h case   42:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFC120);
		/* 82225278h case   42:*/		return 0x8222527C;
		  /* 8222527Ch */ case   43:  		/* b 8 */
		/* 8222527Ch case   43:*/		return 0x82225284;
		/* 8222527Ch case   43:*/		return 0x82225280;
	}
	return 0x82225280;
} // Block from 822251D0h-82225280h (44 instructions)

//////////////////////////////////////////////////////
// Block at 82225280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225280);
		  /* 82225280h */ case    0:  		/* lwz R10, <#[R1 + 208]> */
		/* 82225280h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000D0) );
		/* 82225280h case    0:*/		return 0x82225284;
	}
	return 0x82225284;
} // Block from 82225280h-82225284h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225284);
		  /* 82225284h */ case    0:  		/* stw R10, <#[R11 + 344]> */
		/* 82225284h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000158) );
		/* 82225284h case    0:*/		return 0x82225288;
		  /* 82225288h */ case    1:  		/* lwz R11, <#[R31 + 536]> */
		/* 82225288h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 82225288h case    1:*/		return 0x8222528C;
		  /* 8222528Ch */ case    2:  		/* addi R11, R11, 1 */
		/* 8222528Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222528Ch case    2:*/		return 0x82225290;
		  /* 82225290h */ case    3:  		/* stw R11, <#[R31 + 536]> */
		/* 82225290h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 82225290h case    3:*/		return 0x82225294;
	}
	return 0x82225294;
} // Block from 82225284h-82225294h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225294);
		  /* 82225294h */ case    0:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 82225294h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 82225294h case    0:*/		return 0x82225298;
		  /* 82225298h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 82225298h case    1:*/		if ( !regs.CR[0].eq ) { return 0x822252B4;  }
		/* 82225298h case    1:*/		return 0x8222529C;
		  /* 8222529Ch */ case    2:  		/* lwz R11, <#[R31 + 56]> */
		/* 8222529Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8222529Ch case    2:*/		return 0x822252A0;
		  /* 822252A0h */ case    3:  		/* mr R29, R30 */
		/* 822252A0h case    3:*/		regs.R29 = regs.R30;
		/* 822252A0h case    3:*/		return 0x822252A4;
		  /* 822252A4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 822252A4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822252A4h case    4:*/		return 0x822252A8;
		  /* 822252A8h */ case    5:  		/* bc 12, CR6_EQ, 248 */
		/* 822252A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x822253A0;  }
		/* 822252A8h case    5:*/		return 0x822252AC;
		  /* 822252ACh */ case    6:  		/* stw R22, <#[R11 + 28]> */
		/* 822252ACh case    6:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x0000001C) );
		/* 822252ACh case    6:*/		return 0x822252B0;
		  /* 822252B0h */ case    7:  		/* b 240 */
		/* 822252B0h case    7:*/		return 0x822253A0;
		/* 822252B0h case    7:*/		return 0x822252B4;
	}
	return 0x822252B4;
} // Block from 82225294h-822252B4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822252B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822252B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822252B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822252B4);
		  /* 822252B4h */ case    0:  		/* mr R6, R23 */
		/* 822252B4h case    0:*/		regs.R6 = regs.R23;
		/* 822252B4h case    0:*/		return 0x822252B8;
		  /* 822252B8h */ case    1:  		/* li R5, 1 */
		/* 822252B8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822252B8h case    1:*/		return 0x822252BC;
		  /* 822252BCh */ case    2:  		/* li R4, 96 */
		/* 822252BCh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x60);
		/* 822252BCh case    2:*/		return 0x822252C0;
	}
	return 0x822252C0;
} // Block from 822252B4h-822252C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822252C0h
// Function '?InitVARIABLE@Instruction@D3DXShader@@QAAXPAVCompiler@2@W4Opcode@2@PAVBlock@2@IIIIIW4VariableComponentType@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822252C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822252C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822252C0);
		  /* 822252C0h */ case    0:  		/* mr R3, R31 */
		/* 822252C0h case    0:*/		regs.R3 = regs.R31;
		/* 822252C0h case    0:*/		return 0x822252C4;
		  /* 822252C4h */ case    1:  		/* bl -790164 */
		/* 822252C4h case    1:*/		regs.LR = 0x822252C8; return 0x82164430;
		/* 822252C4h case    1:*/		return 0x822252C8;
		  /* 822252C8h */ case    2:  		/* mr R4, R3 */
		/* 822252C8h case    2:*/		regs.R4 = regs.R3;
		/* 822252C8h case    2:*/		return 0x822252CC;
		  /* 822252CCh */ case    3:  		/* mr R3, R31 */
		/* 822252CCh case    3:*/		regs.R3 = regs.R31;
		/* 822252CCh case    3:*/		return 0x822252D0;
		  /* 822252D0h */ case    4:  		/* li R5, 35 */
		/* 822252D0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 822252D0h case    4:*/		return 0x822252D4;
		  /* 822252D4h */ case    5:  		/* bl -755500 */
		/* 822252D4h case    5:*/		regs.LR = 0x822252D8; return 0x8216CBA8;
		/* 822252D4h case    5:*/		return 0x822252D8;
		  /* 822252D8h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 822252D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822252D8h case    6:*/		return 0x822252DC;
		  /* 822252DCh */ case    7:  		/* mr R8, R23 */
		/* 822252DCh case    7:*/		regs.R8 = regs.R23;
		/* 822252DCh case    7:*/		return 0x822252E0;
		  /* 822252E0h */ case    8:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 822252E0h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 822252E0h case    8:*/		return 0x822252E4;
		  /* 822252E4h */ case    9:  		/* li R7, 1 */
		/* 822252E4h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 822252E4h case    9:*/		return 0x822252E8;
		  /* 822252E8h */ case   10:  		/* addic R10, R10, -1 */
		/* 822252E8h case   10:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 822252E8h case   10:*/		return 0x822252EC;
		  /* 822252ECh */ case   11:  		/* li R6, 96 */
		/* 822252ECh case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x60);
		/* 822252ECh case   11:*/		return 0x822252F0;
		  /* 822252F0h */ case   12:  		/* subfe R10, R10, R10 */
		/* 822252F0h case   12:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 822252F0h case   12:*/		return 0x822252F4;
		  /* 822252F4h */ case   13:  		/* mr R4, R31 */
		/* 822252F4h case   13:*/		regs.R4 = regs.R31;
		/* 822252F4h case   13:*/		return 0x822252F8;
		  /* 822252F8h */ case   14:  		/* and R5, R10, R11 */
		/* 822252F8h case   14:*/		cpu::op::and<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 822252F8h case   14:*/		return 0x822252FC;
		  /* 822252FCh */ case   15:  		/* mr R29, R3 */
		/* 822252FCh case   15:*/		regs.R29 = regs.R3;
		/* 822252FCh case   15:*/		return 0x82225300;
		  /* 82225300h */ case   16:  		/* bl -4072 */
		/* 82225300h case   16:*/		regs.LR = 0x82225304; return 0x82224318;
		/* 82225300h case   16:*/		return 0x82225304;
		  /* 82225304h */ case   17:  		/* lwz R11, <#[R29 + 8]> */
		/* 82225304h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82225304h case   17:*/		return 0x82225308;
		  /* 82225308h */ case   18:  		/* mr R3, R31 */
		/* 82225308h case   18:*/		regs.R3 = regs.R31;
		/* 82225308h case   18:*/		return 0x8222530C;
		  /* 8222530Ch */ case   19:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8222530Ch case   19:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8222530Ch case   19:*/		return 0x82225310;
		  /* 82225310h */ case   20:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82225310h case   20:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82225310h case   20:*/		return 0x82225314;
		  /* 82225314h */ case   21:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82225314h case   21:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82225314h case   21:*/		return 0x82225318;
		  /* 82225318h */ case   22:  		/* bl -790248 */
		/* 82225318h case   22:*/		regs.LR = 0x8222531C; return 0x82164430;
		/* 82225318h case   22:*/		return 0x8222531C;
		  /* 8222531Ch */ case   23:  		/* addi R11, R29, -20 */
		/* 8222531Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFEC);
		/* 8222531Ch case   23:*/		return 0x82225320;
		  /* 82225320h */ case   24:  		/* rlwimi R24, R25, 4, 0, 27 */
		/* 82225320h case   24:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R24,regs.R25);
		/* 82225320h case   24:*/		return 0x82225324;
		  /* 82225324h */ case   25:  		/* add R11, R3, R11 */
		/* 82225324h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82225324h case   25:*/		return 0x82225328;
		  /* 82225328h */ case   26:  		/* mr R4, R30 */
		/* 82225328h case   26:*/		regs.R4 = regs.R30;
		/* 82225328h case   26:*/		return 0x8222532C;
		  /* 8222532Ch */ case   27:  		/* mr R3, R31 */
		/* 8222532Ch case   27:*/		regs.R3 = regs.R31;
		/* 8222532Ch case   27:*/		return 0x82225330;
		  /* 82225330h */ case   28:  		/* lwz R9, <#[R11]> */
		/* 82225330h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82225330h case   28:*/		return 0x82225334;
		  /* 82225334h */ case   29:  		/* stb R24, <#[R11 + 15]> */
		/* 82225334h case   29:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R11 + 0x0000000F) );
		/* 82225334h case   29:*/		return 0x82225338;
		  /* 82225338h */ case   30:  		/* oris R10, R9, 8 */
		/* 82225338h case   30:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82225338h case   30:*/		return 0x8222533C;
		  /* 8222533Ch */ case   31:  		/* stw R10, <#[R11]> */
		/* 8222533Ch case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222533Ch case   31:*/		return 0x82225340;
		  /* 82225340h */ case   32:  		/* bl -709440 */
		/* 82225340h case   32:*/		regs.LR = 0x82225344; return 0x82178000;
		/* 82225340h case   32:*/		return 0x82225344;
		  /* 82225344h */ case   33:  		/* mr R4, R3 */
		/* 82225344h case   33:*/		regs.R4 = regs.R3;
		/* 82225344h case   33:*/		return 0x82225348;
		  /* 82225348h */ case   34:  		/* mr R3, R29 */
		/* 82225348h case   34:*/		regs.R3 = regs.R29;
		/* 82225348h case   34:*/		return 0x8222534C;
		  /* 8222534Ch */ case   35:  		/* bl -708996 */
		/* 8222534Ch case   35:*/		regs.LR = 0x82225350; return 0x821781C8;
		/* 8222534Ch case   35:*/		return 0x82225350;
		  /* 82225350h */ case   36:  		/* stw R3, <#[R29 + 44]> */
		/* 82225350h case   36:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82225350h case   36:*/		return 0x82225354;
		  /* 82225354h */ case   37:  		/* lwz R10, <#[R31 + 4]> */
		/* 82225354h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82225354h case   37:*/		return 0x82225358;
		  /* 82225358h */ case   38:  		/* rlwinm R11, R10, 0, 31, 31 */
		/* 82225358h case   38:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R10);
		/* 82225358h case   38:*/		return 0x8222535C;
		  /* 8222535Ch */ case   39:  		/* addic R11, R11, -1 */
		/* 8222535Ch case   39:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8222535Ch case   39:*/		return 0x82225360;
		  /* 82225360h */ case   40:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82225360h case   40:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82225360h case   40:*/		return 0x82225364;
		  /* 82225364h */ case   41:  		/* subfe R9, R9, R9 */
		/* 82225364h case   41:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 82225364h case   41:*/		return 0x82225368;
		  /* 82225368h */ case   42:  		/* addi R11, R11, 36 */
		/* 82225368h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82225368h case   42:*/		return 0x8222536C;
		  /* 8222536Ch */ case   43:  		/* and R10, R9, R10 */
		/* 8222536Ch case   43:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8222536Ch case   43:*/		return 0x82225370;
		  /* 82225370h */ case   44:  		/* addi R7, R11, -36 */
		/* 82225370h case   44:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82225370h case   44:*/		return 0x82225374;
		  /* 82225374h */ case   45:  		/* addi R8, R10, 24 */
		/* 82225374h case   45:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x18);
		/* 82225374h case   45:*/		return 0x82225378;
		  /* 82225378h */ case   46:  		/* addi R9, R11, 4 */
		/* 82225378h case   46:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82225378h case   46:*/		return 0x8222537C;
		  /* 8222537Ch */ case   47:  		/* addi R8, R8, -36 */
		/* 8222537Ch case   47:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFDC);
		/* 8222537Ch case   47:*/		return 0x82225380;
		  /* 82225380h */ case   48:  		/* lwz R6, <#[R10 + 24]> */
		/* 82225380h case   48:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000018) );
		/* 82225380h case   48:*/		return 0x82225384;
		  /* 82225384h */ case   49:  		/* stw R6, <#[R11]> */
		/* 82225384h case   49:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82225384h case   49:*/		return 0x82225388;
		  /* 82225388h */ case   50:  		/* ori R8, R8, 1 */
		/* 82225388h case   50:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82225388h case   50:*/		return 0x8222538C;
		  /* 8222538Ch */ case   51:  		/* lwz R6, <#[R10 + 24]> */
		/* 8222538Ch case   51:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000018) );
		/* 8222538Ch case   51:*/		return 0x82225390;
		  /* 82225390h */ case   52:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82225390h case   52:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82225390h case   52:*/		return 0x82225394;
		  /* 82225394h */ case   53:  		/* stw R7, <#[R6]> */
		/* 82225394h case   53:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 82225394h case   53:*/		return 0x82225398;
		  /* 82225398h */ case   54:  		/* stw R8, <#[R11 + 4]> */
		/* 82225398h case   54:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82225398h case   54:*/		return 0x8222539C;
		  /* 8222539Ch */ case   55:  		/* stw R9, <#[R10 + 24]> */
		/* 8222539Ch case   55:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 8222539Ch case   55:*/		return 0x822253A0;
	}
	return 0x822253A0;
} // Block from 822252C0h-822253A0h (56 instructions)

//////////////////////////////////////////////////////
// Block at 822253A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822253A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822253A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822253A0);
		  /* 822253A0h */ case    0:  		/* cmplwi CR6, R25, 14 */
		/* 822253A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x0000000E);
		/* 822253A0h case    0:*/		return 0x822253A4;
		  /* 822253A4h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 822253A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x822253F8;  }
		/* 822253A4h case    1:*/		return 0x822253A8;
		  /* 822253A8h */ case    2:  		/* cmplwi CR6, R25, 15 */
		/* 822253A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x0000000F);
		/* 822253A8h case    2:*/		return 0x822253AC;
		  /* 822253ACh */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 822253ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x822253D4;  }
		/* 822253ACh case    3:*/		return 0x822253B0;
	}
	return 0x822253B0;
} // Block from 822253A0h-822253B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822253B0h
// Function '?MakeInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@W4Opcode@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822253B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822253B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822253B0);
		  /* 822253B0h */ case    0:  		/* cmplwi CR6, R25, 18 */
		/* 822253B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000012);
		/* 822253B0h case    0:*/		return 0x822253B4;
		  /* 822253B4h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 822253B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82225430;  }
		/* 822253B4h case    1:*/		return 0x822253B8;
		  /* 822253B8h */ case    2:  		/* lwz R11, <#[R29 + 12]> */
		/* 822253B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822253B8h case    2:*/		return 0x822253BC;
		  /* 822253BCh */ case    3:  		/* andi. R10, R11, 61166 */
		/* 822253BCh case    3:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xEEEE);
		/* 822253BCh case    3:*/		return 0x822253C0;
		  /* 822253C0h */ case    4:  		/* cmplwi CR6, R10, 61166 */
		/* 822253C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000EEEE);
		/* 822253C0h case    4:*/		return 0x822253C4;
		  /* 822253C4h */ case    5:  		/* bc 12, CR6_EQ, 108 */
		/* 822253C4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82225430;  }
		/* 822253C4h case    5:*/		return 0x822253C8;
		  /* 822253C8h */ case    6:  		/* ori R11, R11, 61166 */
		/* 822253C8h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xEEEE);
		/* 822253C8h case    6:*/		return 0x822253CC;
		  /* 822253CCh */ case    7:  		/* sth R11, <#[R29 + 14]> */
		/* 822253CCh case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x0000000E) );
		/* 822253CCh case    7:*/		return 0x822253D0;
		  /* 822253D0h */ case    8:  		/* b 96 */
		/* 822253D0h case    8:*/		return 0x82225430;
		/* 822253D0h case    8:*/		return 0x822253D4;
	}
	return 0x822253D4;
} // Block from 822253B0h-822253D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822253D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822253D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822253D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822253D4);
		  /* 822253D4h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 822253D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822253D4h case    0:*/		return 0x822253D8;
		  /* 822253D8h */ case    1:  		/* andi. R10, R11, 61166 */
		/* 822253D8h case    1:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xEEEE);
		/* 822253D8h case    1:*/		return 0x822253DC;
		  /* 822253DCh */ case    2:  		/* cmplwi CR6, R10, 61166 */
		/* 822253DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000EEEE);
		/* 822253DCh case    2:*/		return 0x822253E0;
		  /* 822253E0h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 822253E0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822253EC;  }
		/* 822253E0h case    3:*/		return 0x822253E4;
		  /* 822253E4h */ case    4:  		/* ori R11, R11, 61166 */
		/* 822253E4h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xEEEE);
		/* 822253E4h case    4:*/		return 0x822253E8;
		  /* 822253E8h */ case    5:  		/* sth R11, <#[R29 + 14]> */
		/* 822253E8h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x0000000E) );
		/* 822253E8h case    5:*/		return 0x822253EC;
	}
	return 0x822253EC;
} // Block from 822253D4h-822253ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822253ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822253EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822253EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822253EC);
		  /* 822253ECh */ case    0:  		/* lis R11, -32252 */
		/* 822253ECh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822253ECh case    0:*/		return 0x822253F0;
		  /* 822253F0h */ case    1:  		/* lfd FR2, <#[R11 - 248]> */
		/* 822253F0h case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0xFFFFFF08) );
		/* 822253F0h case    1:*/		return 0x822253F4;
		  /* 822253F4h */ case    2:  		/* b 36 */
		/* 822253F4h case    2:*/		return 0x82225418;
		/* 822253F4h case    2:*/		return 0x822253F8;
	}
	return 0x822253F8;
} // Block from 822253ECh-822253F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822253F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822253F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822253F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822253F8);
		  /* 822253F8h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 822253F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822253F8h case    0:*/		return 0x822253FC;
		  /* 822253FCh */ case    1:  		/* andi. R10, R11, 43690 */
		/* 822253FCh case    1:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xAAAA);
		/* 822253FCh case    1:*/		return 0x82225400;
		  /* 82225400h */ case    2:  		/* cmplwi CR6, R10, 43690 */
		/* 82225400h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000AAAA);
		/* 82225400h case    2:*/		return 0x82225404;
		  /* 82225404h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82225404h case    3:*/		if ( regs.CR[6].eq ) { return 0x82225410;  }
		/* 82225404h case    3:*/		return 0x82225408;
		  /* 82225408h */ case    4:  		/* ori R11, R11, 43690 */
		/* 82225408h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xAAAA);
		/* 82225408h case    4:*/		return 0x8222540C;
		  /* 8222540Ch */ case    5:  		/* sth R11, <#[R29 + 14]> */
		/* 8222540Ch case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x0000000E) );
		/* 8222540Ch case    5:*/		return 0x82225410;
	}
	return 0x82225410;
} // Block from 822253F8h-82225410h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225410);
		  /* 82225410h */ case    0:  		/* lis R11, -32256 */
		/* 82225410h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82225410h case    0:*/		return 0x82225414;
		  /* 82225414h */ case    1:  		/* lfd FR2, <#[R11 + 1848]> */
		/* 82225414h case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000738) );
		/* 82225414h case    1:*/		return 0x82225418;
	}
	return 0x82225418;
} // Block from 82225410h-82225418h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82225418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225418);
		  /* 82225418h */ case    0:  		/* lis R10, -32256 */
		/* 82225418h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82225418h case    0:*/		return 0x8222541C;
		  /* 8222541Ch */ case    1:  		/* mr R7, R31 */
		/* 8222541Ch case    1:*/		regs.R7 = regs.R31;
		/* 8222541Ch case    1:*/		return 0x82225420;
		  /* 82225420h */ case    2:  		/* li R4, 0 */
		/* 82225420h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82225420h case    2:*/		return 0x82225424;
		  /* 82225424h */ case    3:  		/* mr R3, R29 */
		/* 82225424h case    3:*/		regs.R3 = regs.R29;
		/* 82225424h case    3:*/		return 0x82225428;
		  /* 82225428h */ case    4:  		/* lfd FR1, <#[R10 + 1808]> */
		/* 82225428h case    4:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00000710) );
		/* 82225428h case    4:*/		return 0x8222542C;
		  /* 8222542Ch */ case    5:  		/* bl -10508 */
		/* 8222542Ch case    5:*/		regs.LR = 0x82225430; return 0x82222B20;
		/* 8222542Ch case    5:*/		return 0x82225430;
	}
	return 0x82225430;
} // Block from 82225418h-82225430h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225430);
		  /* 82225430h */ case    0:  		/* mr R3, R29 */
		/* 82225430h case    0:*/		regs.R3 = regs.R29;
		/* 82225430h case    0:*/		return 0x82225434;
		  /* 82225434h */ case    1:  		/* addi R1, R1, 176 */
		/* 82225434h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82225434h case    1:*/		return 0x82225438;
		  /* 82225438h */ case    2:  		/* b -1655208 */
		/* 82225438h case    2:*/		return 0x82091290;
		/* 82225438h case    2:*/		return 0x8222543C;
		  /* 8222543Ch */ case    3:  		/* nop */
		/* 8222543Ch case    3:*/		cpu::op::nop();
		/* 8222543Ch case    3:*/		return 0x82225440;
	}
	return 0x82225440;
} // Block from 82225430h-82225440h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225440h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225440);
		  /* 82225440h */ case    0:  		/* mfspr R12, LR */
		/* 82225440h case    0:*/		regs.R12 = regs.LR;
		/* 82225440h case    0:*/		return 0x82225444;
		  /* 82225444h */ case    1:  		/* bl -1655300 */
		/* 82225444h case    1:*/		regs.LR = 0x82225448; return 0x82091240;
		/* 82225444h case    1:*/		return 0x82225448;
		  /* 82225448h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82225448h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82225448h case    2:*/		return 0x8222544C;
		  /* 8222544Ch */ case    3:  		/* lwz R10, <#[R3 + 12]> */
		/* 8222544Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8222544Ch case    3:*/		return 0x82225450;
		  /* 82225450h */ case    4:  		/* mulli R11, R4, 40 */
		/* 82225450h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x28);
		/* 82225450h case    4:*/		return 0x82225454;
		  /* 82225454h */ case    5:  		/* add R30, R11, R10 */
		/* 82225454h case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 82225454h case    5:*/		return 0x82225458;
	}
	return 0x82225458;
} // Block from 82225440h-82225458h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225458h
// Function '?MakeInstr_PHI@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225458);
		  /* 82225458h */ case    0:  		/* mr R31, R3 */
		/* 82225458h case    0:*/		regs.R31 = regs.R3;
		/* 82225458h case    0:*/		return 0x8222545C;
		  /* 8222545Ch */ case    1:  		/* mr R24, R4 */
		/* 8222545Ch case    1:*/		regs.R24 = regs.R4;
		/* 8222545Ch case    1:*/		return 0x82225460;
		  /* 82225460h */ case    2:  		/* mr R29, R5 */
		/* 82225460h case    2:*/		regs.R29 = regs.R5;
		/* 82225460h case    2:*/		return 0x82225464;
		  /* 82225464h */ case    3:  		/* mr R28, R6 */
		/* 82225464h case    3:*/		regs.R28 = regs.R6;
		/* 82225464h case    3:*/		return 0x82225468;
		  /* 82225468h */ case    4:  		/* lwz R11, <#[R30 + 28]> */
		/* 82225468h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82225468h case    4:*/		return 0x8222546C;
		  /* 8222546Ch */ case    5:  		/* mr R26, R7 */
		/* 8222546Ch case    5:*/		regs.R26 = regs.R7;
		/* 8222546Ch case    5:*/		return 0x82225470;
		  /* 82225470h */ case    6:  		/* mr R23, R8 */
		/* 82225470h case    6:*/		regs.R23 = regs.R8;
		/* 82225470h case    6:*/		return 0x82225474;
		  /* 82225474h */ case    7:  		/* mr R22, R9 */
		/* 82225474h case    7:*/		regs.R22 = regs.R9;
		/* 82225474h case    7:*/		return 0x82225478;
		  /* 82225478h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82225478h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82225478h case    8:*/		return 0x8222547C;
		  /* 8222547Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8222547Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82225484;  }
		/* 8222547Ch case    9:*/		return 0x82225480;
		  /* 82225480h */ case   10:  		/* bl -621328 */
		/* 82225480h case   10:*/		regs.LR = 0x82225484; return 0x8218D970;
		/* 82225480h case   10:*/		return 0x82225484;
	}
	return 0x82225484;
} // Block from 82225458h-82225484h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82225484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225484);
		  /* 82225484h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82225484h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82225484h case    0:*/		return 0x82225488;
		  /* 82225488h */ case    1:  		/* rlwinm. R7, R28, 0, 24, 31 */
		/* 82225488h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R7,regs.R28);
		/* 82225488h case    1:*/		return 0x8222548C;
		  /* 8222548Ch */ case    2:  		/* mr R25, R29 */
		/* 8222548Ch case    2:*/		regs.R25 = regs.R29;
		/* 8222548Ch case    2:*/		return 0x82225490;
		  /* 82225490h */ case    3:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 82225490h case    3:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 82225490h case    3:*/		return 0x82225494;
		  /* 82225494h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82225494h case    4:*/		if ( regs.CR[0].eq ) { return 0x822254A8;  }
		/* 82225494h case    4:*/		return 0x82225498;
		  /* 82225498h */ case    5:  		/* lwz R10, <#[R30 + 28]> */
		/* 82225498h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82225498h case    5:*/		return 0x8222549C;
		  /* 8222549Ch */ case    6:  		/* rlwinm R9, R29, 3, 0, 28 */
		/* 8222549Ch case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R29);
		/* 8222549Ch case    6:*/		return 0x822254A0;
		  /* 822254A0h */ case    7:  		/* lwzx R10, <#[R9 + R10]> */
		/* 822254A0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 822254A0h case    7:*/		return 0x822254A4;
		  /* 822254A4h */ case    8:  		/* rlwinm R25, R10, 28, 18, 31 */
		/* 822254A4h case    8:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R25,regs.R10);
		/* 822254A4h case    8:*/		return 0x822254A8;
	}
	return 0x822254A8;
} // Block from 82225484h-822254A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822254A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822254A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822254A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822254A8);
		  /* 822254A8h */ case    0:  		/* li R28, -1 */
		/* 822254A8h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 822254A8h case    0:*/		return 0x822254AC;
		  /* 822254ACh */ case    1:  		/* li R27, 0 */
		/* 822254ACh case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 822254ACh case    1:*/		return 0x822254B0;
		  /* 822254B0h */ case    2:  		/* li R29, 0 */
		/* 822254B0h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822254B0h case    2:*/		return 0x822254B4;
		  /* 822254B4h */ case    3:  		/* li R10, 0 */
		/* 822254B4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822254B4h case    3:*/		return 0x822254B8;
		  /* 822254B8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 822254B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822254B8h case    4:*/		return 0x822254BC;
		  /* 822254BCh */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 822254BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82225508;  }
		/* 822254BCh case    5:*/		return 0x822254C0;
		  /* 822254C0h */ case    6:  		/* lwz R8, <#[R30 + 28]> */
		/* 822254C0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 822254C0h case    6:*/		return 0x822254C4;
		  /* 822254C4h */ case    7:  		/* li R9, 0 */
		/* 822254C4h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822254C4h case    7:*/		return 0x822254C8;
		  /* 822254C8h */ case    8:  		/* mtspr CTR, R11 */
		/* 822254C8h case    8:*/		regs.CTR = regs.R11;
		/* 822254C8h case    8:*/		return 0x822254CC;
		  /* 822254CCh */ case    9:  		/* lwzx R11, <#[R9 + R8]> */
		/* 822254CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 822254CCh case    9:*/		return 0x822254D0;
		  /* 822254D0h */ case   10:  		/* rlwinm R6, R11, 28, 18, 31 */
		/* 822254D0h case   10:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R6,regs.R11);
		/* 822254D0h case   10:*/		return 0x822254D4;
		  /* 822254D4h */ case   11:  		/* cmplw CR6, R6, R25 */
		/* 822254D4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R25);
		/* 822254D4h case   11:*/		return 0x822254D8;
		  /* 822254D8h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 822254D8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x822254F4;  }
		/* 822254D8h case   12:*/		return 0x822254DC;
		  /* 822254DCh */ case   13:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 822254DCh case   13:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 822254DCh case   13:*/		return 0x822254E0;
		  /* 822254E0h */ case   14:  		/* addi R29, R29, 1 */
		/* 822254E0h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 822254E0h case   14:*/		return 0x822254E4;
		  /* 822254E4h */ case   15:  		/* or R27, R11, R27 */
		/* 822254E4h case   15:*/		cpu::op::or<0>(regs,&regs.R27,regs.R11,regs.R27);
		/* 822254E4h case   15:*/		return 0x822254E8;
		  /* 822254E8h */ case   16:  		/* cmplw CR6, R10, R28 */
		/* 822254E8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 822254E8h case   16:*/		return 0x822254EC;
		  /* 822254ECh */ case   17:  		/* bc 4, CR6_LT, 8 */
		/* 822254ECh case   17:*/		if ( !regs.CR[6].lt ) { return 0x822254F4;  }
		/* 822254ECh case   17:*/		return 0x822254F0;
		  /* 822254F0h */ case   18:  		/* mr R28, R10 */
		/* 822254F0h case   18:*/		regs.R28 = regs.R10;
		/* 822254F0h case   18:*/		return 0x822254F4;
	}
	return 0x822254F4;
} // Block from 822254A8h-822254F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 822254F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822254F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822254F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822254F4);
		  /* 822254F4h */ case    0:  		/* addi R10, R10, 1 */
		/* 822254F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822254F4h case    0:*/		return 0x822254F8;
		  /* 822254F8h */ case    1:  		/* addi R9, R9, 8 */
		/* 822254F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 822254F8h case    1:*/		return 0x822254FC;
		  /* 822254FCh */ case    2:  		/* bc 16, CR0_LT, -48 */
		/* 822254FCh case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822254CC;  }
		/* 822254FCh case    2:*/		return 0x82225500;
		  /* 82225500h */ case    3:  		/* cmplwi CR6, R27, 0 */
		/* 82225500h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82225500h case    3:*/		return 0x82225504;
		  /* 82225504h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 82225504h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82225524;  }
		/* 82225504h case    4:*/		return 0x82225508;
	}
	return 0x82225508;
} // Block from 822254F4h-82225508h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82225508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225508);
		  /* 82225508h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 82225508h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82225508h case    0:*/		return 0x8222550C;
		  /* 8222550Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8222550Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82225518;  }
		/* 8222550Ch case    1:*/		return 0x82225510;
		  /* 82225510h */ case    2:  		/* li R3, 0 */
		/* 82225510h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82225510h case    2:*/		return 0x82225514;
		  /* 82225514h */ case    3:  		/* b 184 */
		/* 82225514h case    3:*/		return 0x822255CC;
		/* 82225514h case    3:*/		return 0x82225518;
	}
	return 0x82225518;
} // Block from 82225508h-82225518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225518h
// Function '?MakeInstr_MERGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225518);
		  /* 82225518h */ case    0:  		/* li R4, 4800 */
		/* 82225518h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82225518h case    0:*/		return 0x8222551C;
		  /* 8222551Ch */ case    1:  		/* mr R3, R31 */
		/* 8222551Ch case    1:*/		regs.R3 = regs.R31;
		/* 8222551Ch case    1:*/		return 0x82225520;
		  /* 82225520h */ case    2:  		/* bl -865976 */
		/* 82225520h case    2:*/		regs.LR = 0x82225524; return 0x82151E68;
		/* 82225520h case    2:*/		return 0x82225524;
	}
	return 0x82225524;
} // Block from 82225518h-82225524h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82225524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225524);
		  /* 82225524h */ case    0:  		/* addi R11, R26, -104 */
		/* 82225524h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFF98);
		/* 82225524h case    0:*/		return 0x82225528;
		  /* 82225528h */ case    1:  		/* mr R6, R29 */
		/* 82225528h case    1:*/		regs.R6 = regs.R29;
		/* 82225528h case    1:*/		return 0x8222552C;
		  /* 8222552Ch */ case    2:  		/* cntlzw R11, R11 */
		/* 8222552Ch case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8222552Ch case    2:*/		return 0x82225530;
		  /* 82225530h */ case    3:  		/* mr R4, R26 */
		/* 82225530h case    3:*/		regs.R4 = regs.R26;
		/* 82225530h case    3:*/		return 0x82225534;
		  /* 82225534h */ case    4:  		/* rlwinm R5, R11, 27, 31, 31 */
		/* 82225534h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R5,regs.R11);
		/* 82225534h case    4:*/		return 0x82225538;
		  /* 82225538h */ case    5:  		/* mr R3, R31 */
		/* 82225538h case    5:*/		regs.R3 = regs.R31;
		/* 82225538h case    5:*/		return 0x8222553C;
		  /* 8222553Ch */ case    6:  		/* bl -790796 */
		/* 8222553Ch case    6:*/		regs.LR = 0x82225540; return 0x82164430;
		/* 8222553Ch case    6:*/		return 0x82225540;
		  /* 82225540h */ case    7:  		/* mr R4, R3 */
		/* 82225540h case    7:*/		regs.R4 = regs.R3;
		/* 82225540h case    7:*/		return 0x82225544;
		  /* 82225544h */ case    8:  		/* mr R3, R31 */
		/* 82225544h case    8:*/		regs.R3 = regs.R31;
		/* 82225544h case    8:*/		return 0x82225548;
		  /* 82225548h */ case    9:  		/* li R5, 35 */
		/* 82225548h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 82225548h case    9:*/		return 0x8222554C;
		  /* 8222554Ch */ case   10:  		/* bl -756132 */
		/* 8222554Ch case   10:*/		regs.LR = 0x82225550; return 0x8216CBA8;
		/* 8222554Ch case   10:*/		return 0x82225550;
		  /* 82225550h */ case   11:  		/* lwz R11, <#[R30 + 28]> */
		/* 82225550h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82225550h case   11:*/		return 0x82225554;
		  /* 82225554h */ case   12:  		/* rlwinm R8, R28, 3, 0, 28 */
		/* 82225554h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R28);
		/* 82225554h case   12:*/		return 0x82225558;
		  /* 82225558h */ case   13:  		/* stw R29, <#[R1 + 84]> */
		/* 82225558h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 82225558h case   13:*/		return 0x8222555C;
		  /* 8222555Ch */ case   14:  		/* mr R10, R28 */
		/* 8222555Ch case   14:*/		regs.R10 = regs.R28;
		/* 8222555Ch case   14:*/		return 0x82225560;
		  /* 82225560h */ case   15:  		/* mr R9, R27 */
		/* 82225560h case   15:*/		regs.R9 = regs.R27;
		/* 82225560h case   15:*/		return 0x82225564;
		  /* 82225564h */ case   16:  		/* mr R7, R24 */
		/* 82225564h case   16:*/		regs.R7 = regs.R24;
		/* 82225564h case   16:*/		return 0x82225568;
		  /* 82225568h */ case   17:  		/* mr R6, R23 */
		/* 82225568h case   17:*/		regs.R6 = regs.R23;
		/* 82225568h case   17:*/		return 0x8222556C;
		  /* 8222556Ch */ case   18:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8222556Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8222556Ch case   18:*/		return 0x82225570;
		  /* 82225570h */ case   19:  		/* mr R8, R25 */
		/* 82225570h case   19:*/		regs.R8 = regs.R25;
		/* 82225570h case   19:*/		return 0x82225574;
		  /* 82225574h */ case   20:  		/* mr R5, R26 */
		/* 82225574h case   20:*/		regs.R5 = regs.R26;
		/* 82225574h case   20:*/		return 0x82225578;
		  /* 82225578h */ case   21:  		/* rlwinm R11, R11, 14, 30, 31 */
		/* 82225578h case   21:*/		cpu::op::rlwinm<0,14,30,31>(regs,&regs.R11,regs.R11);
		/* 82225578h case   21:*/		return 0x8222557C;
		  /* 8222557Ch */ case   22:  		/* mr R4, R31 */
		/* 8222557Ch case   22:*/		regs.R4 = regs.R31;
		/* 8222557Ch case   22:*/		return 0x82225580;
		  /* 82225580h */ case   23:  		/* mr R29, R3 */
		/* 82225580h case   23:*/		regs.R29 = regs.R3;
		/* 82225580h case   23:*/		return 0x82225584;
		  /* 82225584h */ case   24:  		/* stw R11, <#[R1 + 92]> */
		/* 82225584h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82225584h case   24:*/		return 0x82225588;
		  /* 82225588h */ case   25:  		/* bl -3296 */
		/* 82225588h case   25:*/		regs.LR = 0x8222558C; return 0x822248A8;
		/* 82225588h case   25:*/		return 0x8222558C;
		  /* 8222558Ch */ case   26:  		/* mr R5, R22 */
		/* 8222558Ch case   26:*/		regs.R5 = regs.R22;
		/* 8222558Ch case   26:*/		return 0x82225590;
		  /* 82225590h */ case   27:  		/* mr R4, R29 */
		/* 82225590h case   27:*/		regs.R4 = regs.R29;
		/* 82225590h case   27:*/		return 0x82225594;
		  /* 82225594h */ case   28:  		/* mr R3, R31 */
		/* 82225594h case   28:*/		regs.R3 = regs.R31;
		/* 82225594h case   28:*/		return 0x82225598;
		  /* 82225598h */ case   29:  		/* bl -3592 */
		/* 82225598h case   29:*/		regs.LR = 0x8222559C; return 0x82224790;
		/* 82225598h case   29:*/		return 0x8222559C;
		  /* 8222559Ch */ case   30:  		/* lwz R11, <#[R30 + 4]> */
		/* 8222559Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8222559Ch case   30:*/		return 0x822255A0;
		  /* 822255A0h */ case   31:  		/* rlwinm. R11, R11, 28, 29, 31 */
		/* 822255A0h case   31:*/		cpu::op::rlwinm<1,28,29,31>(regs,&regs.R11,regs.R11);
		/* 822255A0h case   31:*/		return 0x822255A4;
		  /* 822255A4h */ case   32:  		/* bc 4, CR0_EQ, 16 */
		/* 822255A4h case   32:*/		if ( !regs.CR[0].eq ) { return 0x822255B4;  }
		/* 822255A4h case   32:*/		return 0x822255A8;
		  /* 822255A8h */ case   33:  		/* lwz R11, <#[R31 + 40]> */
		/* 822255A8h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 822255A8h case   33:*/		return 0x822255AC;
		  /* 822255ACh */ case   34:  		/* oris R11, R11, 2 */
		/* 822255ACh case   34:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822255ACh case   34:*/		return 0x822255B0;
		  /* 822255B0h */ case   35:  		/* b 20 */
		/* 822255B0h case   35:*/		return 0x822255C4;
		/* 822255B0h case   35:*/		return 0x822255B4;
	}
	return 0x822255B4;
} // Block from 82225524h-822255B4h (36 instructions)

//////////////////////////////////////////////////////
// Block at 822255B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822255B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822255B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822255B4);
		  /* 822255B4h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 822255B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822255B4h case    0:*/		return 0x822255B8;
	}
	return 0x822255B8;
} // Block from 822255B4h-822255B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822255B8h
// Function '?Clone@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822255B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822255B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822255B8);
		  /* 822255B8h */ case    0:  		/* bc 4, CR6_EQ, 16 */
		/* 822255B8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x822255C8;  }
		/* 822255B8h case    0:*/		return 0x822255BC;
		  /* 822255BCh */ case    1:  		/* lwz R11, <#[R31 + 40]> */
		/* 822255BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 822255BCh case    1:*/		return 0x822255C0;
		  /* 822255C0h */ case    2:  		/* ori R11, R11, 1 */
		/* 822255C0h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822255C0h case    2:*/		return 0x822255C4;
	}
	return 0x822255C4;
} // Block from 822255B8h-822255C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822255C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822255C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822255C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822255C4);
		  /* 822255C4h */ case    0:  		/* stw R11, <#[R31 + 40]> */
		/* 822255C4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 822255C4h case    0:*/		return 0x822255C8;
	}
	return 0x822255C8;
} // Block from 822255C4h-822255C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822255C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822255C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822255C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822255C8);
		  /* 822255C8h */ case    0:  		/* mr R3, R29 */
		/* 822255C8h case    0:*/		regs.R3 = regs.R29;
		/* 822255C8h case    0:*/		return 0x822255CC;
	}
	return 0x822255CC;
} // Block from 822255C8h-822255CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822255CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822255CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822255CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822255CC);
		  /* 822255CCh */ case    0:  		/* addi R1, R1, 192 */
		/* 822255CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 822255CCh case    0:*/		return 0x822255D0;
		  /* 822255D0h */ case    1:  		/* b -1655616 */
		/* 822255D0h case    1:*/		return 0x82091290;
		/* 822255D0h case    1:*/		return 0x822255D4;
		  /* 822255D4h */ case    2:  		/* nop */
		/* 822255D4h case    2:*/		cpu::op::nop();
		/* 822255D4h case    2:*/		return 0x822255D8;
	}
	return 0x822255D8;
} // Block from 822255CCh-822255D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822255D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822255D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822255D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822255D8);
		  /* 822255D8h */ case    0:  		/* mfspr R12, LR */
		/* 822255D8h case    0:*/		regs.R12 = regs.LR;
		/* 822255D8h case    0:*/		return 0x822255DC;
		  /* 822255DCh */ case    1:  		/* bl -1655700 */
		/* 822255DCh case    1:*/		regs.LR = 0x822255E0; return 0x82091248;
		/* 822255DCh case    1:*/		return 0x822255E0;
		  /* 822255E0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 822255E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 822255E0h case    2:*/		return 0x822255E4;
		  /* 822255E4h */ case    3:  		/* lwz R27, <#[R3 + 16]> */
		/* 822255E4h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000010) );
		/* 822255E4h case    3:*/		return 0x822255E8;
		  /* 822255E8h */ case    4:  		/* mr R26, R4 */
		/* 822255E8h case    4:*/		regs.R26 = regs.R4;
		/* 822255E8h case    4:*/		return 0x822255EC;
		  /* 822255ECh */ case    5:  		/* mr R29, R3 */
		/* 822255ECh case    5:*/		regs.R29 = regs.R3;
		/* 822255ECh case    5:*/		return 0x822255F0;
		  /* 822255F0h */ case    6:  		/* addi R25, R27, 1 */
		/* 822255F0h case    6:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R27,0x1);
		/* 822255F0h case    6:*/		return 0x822255F4;
		  /* 822255F4h */ case    7:  		/* mr R24, R5 */
		/* 822255F4h case    7:*/		regs.R24 = regs.R5;
		/* 822255F4h case    7:*/		return 0x822255F8;
		  /* 822255F8h */ case    8:  		/* mulli R4, R25, 40 */
		/* 822255F8h case    8:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R25,0x28);
		/* 822255F8h case    8:*/		return 0x822255FC;
		  /* 822255FCh */ case    9:  		/* addi R30, R3, 812 */
		/* 822255FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x32C);
		/* 822255FCh case    9:*/		return 0x82225600;
		  /* 82225600h */ case   10:  		/* cmplwi CR6, R4, 132 */
		/* 82225600h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 82225600h case   10:*/		return 0x82225604;
		  /* 82225604h */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 82225604h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82225618;  }
		/* 82225604h case   11:*/		return 0x82225608;
		  /* 82225608h */ case   12:  		/* mr R3, R30 */
		/* 82225608h case   12:*/		regs.R3 = regs.R30;
		/* 82225608h case   12:*/		return 0x8222560C;
		  /* 8222560Ch */ case   13:  		/* bl -788220 */
		/* 8222560Ch case   13:*/		regs.LR = 0x82225610; return 0x82164F10;
		/* 8222560Ch case   13:*/		return 0x82225610;
		  /* 82225610h */ case   14:  		/* mr R28, R3 */
		/* 82225610h case   14:*/		regs.R28 = regs.R3;
		/* 82225610h case   14:*/		return 0x82225614;
		  /* 82225614h */ case   15:  		/* b 112 */
		/* 82225614h case   15:*/		return 0x82225684;
		/* 82225614h case   15:*/		return 0x82225618;
	}
	return 0x82225618;
} // Block from 822255D8h-82225618h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82225618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225618);
		  /* 82225618h */ case    0:  		/* lwz R10, <#[R30 + 140]> */
		/* 82225618h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000008C) );
		/* 82225618h case    0:*/		return 0x8222561C;
		  /* 8222561Ch */ case    1:  		/* lwz R11, <#[R30 + 144]> */
		/* 8222561Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000090) );
		/* 8222561Ch case    1:*/		return 0x82225620;
		  /* 82225620h */ case    2:  		/* subf R10, R11, R10 */
		/* 82225620h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82225620h case    2:*/		return 0x82225624;
		  /* 82225624h */ case    3:  		/* addi R10, R10, 4096 */
		/* 82225624h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 82225624h case    3:*/		return 0x82225628;
		  /* 82225628h */ case    4:  		/* cmplw CR6, R10, R4 */
		/* 82225628h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 82225628h case    4:*/		return 0x8222562C;
		  /* 8222562Ch */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8222562Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8222563C;  }
		/* 8222562Ch case    5:*/		return 0x82225630;
		  /* 82225630h */ case    6:  		/* add R10, R11, R4 */
		/* 82225630h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 82225630h case    6:*/		return 0x82225634;
		  /* 82225634h */ case    7:  		/* stw R10, <#[R30 + 144]> */
		/* 82225634h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000090) );
		/* 82225634h case    7:*/		return 0x82225638;
		  /* 82225638h */ case    8:  		/* b 72 */
		/* 82225638h case    8:*/		return 0x82225680;
		/* 82225638h case    8:*/		return 0x8222563C;
	}
	return 0x8222563C;
} // Block from 82225618h-8222563Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222563Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222563C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222563C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222563C);
		  /* 8222563Ch */ case    0:  		/* rlwinm R11, R4, 30, 2, 31 */
		/* 8222563Ch case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R4);
		/* 8222563Ch case    0:*/		return 0x82225640;
		  /* 82225640h */ case    1:  		/* addi R11, R11, -1 */
		/* 82225640h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82225640h case    1:*/		return 0x82225644;
		  /* 82225644h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82225644h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82225644h case    2:*/		return 0x82225648;
		  /* 82225648h */ case    3:  		/* lwzx R31, <#[R11 + R30]> */
		/* 82225648h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82225648h case    3:*/		return 0x8222564C;
		  /* 8222564Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8222564Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8222564Ch case    4:*/		return 0x82225650;
		  /* 82225650h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82225650h case    5:*/		if ( regs.CR[6].eq ) { return 0x82225674;  }
		/* 82225650h case    5:*/		return 0x82225654;
		  /* 82225654h */ case    6:  		/* lwz R10, <#[R31]> */
		/* 82225654h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82225654h case    6:*/		return 0x82225658;
		  /* 82225658h */ case    7:  		/* mr R5, R4 */
		/* 82225658h case    7:*/		regs.R5 = regs.R4;
		/* 82225658h case    7:*/		return 0x8222565C;
		  /* 8222565Ch */ case    8:  		/* li R4, 0 */
		/* 8222565Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8222565Ch case    8:*/		return 0x82225660;
		  /* 82225660h */ case    9:  		/* mr R3, R31 */
		/* 82225660h case    9:*/		regs.R3 = regs.R31;
		/* 82225660h case    9:*/		return 0x82225664;
		  /* 82225664h */ case   10:  		/* stwx R10, <#[R11 + R30]> */
		/* 82225664h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82225664h case   10:*/		return 0x82225668;
		  /* 82225668h */ case   11:  		/* bl -1655592 */
		/* 82225668h case   11:*/		regs.LR = 0x8222566C; return 0x82091340;
		/* 82225668h case   11:*/		return 0x8222566C;
		  /* 8222566Ch */ case   12:  		/* mr R11, R31 */
		/* 8222566Ch case   12:*/		regs.R11 = regs.R31;
		/* 8222566Ch case   12:*/		return 0x82225670;
		  /* 82225670h */ case   13:  		/* b 16 */
		/* 82225670h case   13:*/		return 0x82225680;
		/* 82225670h case   13:*/		return 0x82225674;
	}
	return 0x82225674;
} // Block from 8222563Ch-82225674h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82225674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225674);
		  /* 82225674h */ case    0:  		/* mr R3, R30 */
		/* 82225674h case    0:*/		regs.R3 = regs.R30;
		/* 82225674h case    0:*/		return 0x82225678;
		  /* 82225678h */ case    1:  		/* bl -790664 */
		/* 82225678h case    1:*/		regs.LR = 0x8222567C; return 0x821645F0;
		/* 82225678h case    1:*/		return 0x8222567C;
		  /* 8222567Ch */ case    2:  		/* mr R11, R3 */
		/* 8222567Ch case    2:*/		regs.R11 = regs.R3;
		/* 8222567Ch case    2:*/		return 0x82225680;
	}
	return 0x82225680;
} // Block from 82225674h-82225680h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82225680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225680);
		  /* 82225680h */ case    0:  		/* mr R28, R11 */
		/* 82225680h case    0:*/		regs.R28 = regs.R11;
		/* 82225680h case    0:*/		return 0x82225684;
	}
	return 0x82225684;
} // Block from 82225680h-82225684h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225684);
		  /* 82225684h */ case    0:  		/* mulli R5, R27, 40 */
		/* 82225684h case    0:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R27,0x28);
		/* 82225684h case    0:*/		return 0x82225688;
		  /* 82225688h */ case    1:  		/* lwz R4, <#[R29 + 12]> */
		/* 82225688h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x0000000C) );
		/* 82225688h case    1:*/		return 0x8222568C;
		  /* 8222568Ch */ case    2:  		/* mr R3, R28 */
		/* 8222568Ch case    2:*/		regs.R3 = regs.R28;
		/* 8222568Ch case    2:*/		return 0x82225690;
		  /* 82225690h */ case    3:  		/* add R31, R5, R28 */
		/* 82225690h case    3:*/		cpu::op::add<0>(regs,&regs.R31,regs.R5,regs.R28);
		/* 82225690h case    3:*/		return 0x82225694;
		  /* 82225694h */ case    4:  		/* bl -1653988 */
		/* 82225694h case    4:*/		regs.LR = 0x82225698; return 0x820919B0;
		/* 82225694h case    4:*/		return 0x82225698;
		  /* 82225698h */ case    5:  		/* li R5, 40 */
		/* 82225698h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x28);
		/* 82225698h case    5:*/		return 0x8222569C;
		  /* 8222569Ch */ case    6:  		/* mr R4, R26 */
		/* 8222569Ch case    6:*/		regs.R4 = regs.R26;
		/* 8222569Ch case    6:*/		return 0x822256A0;
		  /* 822256A0h */ case    7:  		/* mr R3, R31 */
		/* 822256A0h case    7:*/		regs.R3 = regs.R31;
		/* 822256A0h case    7:*/		return 0x822256A4;
		  /* 822256A4h */ case    8:  		/* bl -1654004 */
		/* 822256A4h case    8:*/		regs.LR = 0x822256A8; return 0x820919B0;
		/* 822256A4h case    8:*/		return 0x822256A8;
		  /* 822256A8h */ case    9:  		/* lwz R10, <#[R29 + 20]> */
		/* 822256A8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 822256A8h case    9:*/		return 0x822256AC;
		  /* 822256ACh */ case   10:  		/* lwz R11, <#[R29 + 12]> */
		/* 822256ACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 822256ACh case   10:*/		return 0x822256B0;
		  /* 822256B0h */ case   11:  		/* mulli R10, R10, 40 */
		/* 822256B0h case   11:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 822256B0h case   11:*/		return 0x822256B4;
		  /* 822256B4h */ case   12:  		/* cmplwi CR6, R10, 132 */
		/* 822256B4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000084);
		/* 822256B4h case   12:*/		return 0x822256B8;
		  /* 822256B8h */ case   13:  		/* bc 4, CR6_GT, 56 */
		/* 822256B8h case   13:*/		if ( !regs.CR[6].gt ) { return 0x822256F0;  }
		/* 822256B8h case   13:*/		return 0x822256BC;
		  /* 822256BCh */ case   14:  		/* addi R3, R11, -12 */
		/* 822256BCh case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF4);
		/* 822256BCh case   14:*/		return 0x822256C0;
		  /* 822256C0h */ case   15:  		/* lis R4, 24973 */
		/* 822256C0h case   15:*/		cpu::op::lis<0>(regs,&regs.R4,0x618D);
		/* 822256C0h case   15:*/		return 0x822256C4;
		  /* 822256C4h */ case   16:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 822256C4h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 822256C4h case   16:*/		return 0x822256C8;
		  /* 822256C8h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 822256C8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822256C8h case   17:*/		return 0x822256CC;
		  /* 822256CCh */ case   18:  		/* lwz R9, <#[R11]> */
		/* 822256CCh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822256CCh case   18:*/		return 0x822256D0;
		  /* 822256D0h */ case   19:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 822256D0h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 822256D0h case   19:*/		return 0x822256D4;
		  /* 822256D4h */ case   20:  		/* stw R9, <#[R10]> */
		/* 822256D4h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 822256D4h case   20:*/		return 0x822256D8;
		  /* 822256D8h */ case   21:  		/* lwz R10, <#[R11 + 4]> */
		/* 822256D8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 822256D8h case   21:*/		return 0x822256DC;
		  /* 822256DCh */ case   22:  		/* lwz R11, <#[R11]> */
		/* 822256DCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822256DCh case   22:*/		return 0x822256E0;
		  /* 822256E0h */ case   23:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 822256E0h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 822256E0h case   23:*/		return 0x822256E4;
		  /* 822256E4h */ case   24:  		/* stw R10, <#[R11]> */
		/* 822256E4h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822256E4h case   24:*/		return 0x822256E8;
		  /* 822256E8h */ case   25:  		/* bl -1692592 */
		/* 822256E8h case   25:*/		regs.LR = 0x822256EC; return 0x82088338;
		/* 822256E8h case   25:*/		return 0x822256EC;
		  /* 822256ECh */ case   26:  		/* b 28 */
		/* 822256ECh case   26:*/		return 0x82225708;
		/* 822256ECh case   26:*/		return 0x822256F0;
	}
	return 0x822256F0;
} // Block from 82225684h-822256F0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 822256F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822256F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822256F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822256F0);
		  /* 822256F0h */ case    0:  		/* rlwinm R10, R10, 30, 2, 31 */
		/* 822256F0h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R10);
		/* 822256F0h case    0:*/		return 0x822256F4;
		  /* 822256F4h */ case    1:  		/* addi R10, R10, -1 */
		/* 822256F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 822256F4h case    1:*/		return 0x822256F8;
		  /* 822256F8h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822256F8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822256F8h case    2:*/		return 0x822256FC;
		  /* 822256FCh */ case    3:  		/* lwzx R9, <#[R10 + R30]> */
		/* 822256FCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 822256FCh case    3:*/		return 0x82225700;
		  /* 82225700h */ case    4:  		/* stw R9, <#[R11]> */
		/* 82225700h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82225700h case    4:*/		return 0x82225704;
		  /* 82225704h */ case    5:  		/* stwx R11, <#[R10 + R30]> */
		/* 82225704h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82225704h case    5:*/		return 0x82225708;
	}
	return 0x82225708;
} // Block from 822256F0h-82225708h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225708);
		  /* 82225708h */ case    0:  		/* stw R25, <#[R29 + 16]> */
		/* 82225708h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R29 + 0x00000010) );
		/* 82225708h case    0:*/		return 0x8222570C;
		  /* 8222570Ch */ case    1:  		/* li R11, 0 */
		/* 8222570Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222570Ch case    1:*/		return 0x82225710;
		  /* 82225710h */ case    2:  		/* stw R28, <#[R29 + 12]> */
		/* 82225710h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + 0x0000000C) );
		/* 82225710h case    2:*/		return 0x82225714;
		  /* 82225714h */ case    3:  		/* stw R25, <#[R29 + 20]> */
		/* 82225714h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R29 + 0x00000014) );
		/* 82225714h case    3:*/		return 0x82225718;
		  /* 82225718h */ case    4:  		/* lwz R10, <#[R31 + 28]> */
		/* 82225718h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 82225718h case    4:*/		return 0x8222571C;
		  /* 8222571Ch */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8222571Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222571Ch case    5:*/		return 0x82225720;
		  /* 82225720h */ case    6:  		/* lwz R10, <#[R31 + 4]> */
		/* 82225720h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82225720h case    6:*/		return 0x82225724;
		  /* 82225724h */ case    7:  		/* rlwimi R10, R24, 4, 25, 27 */
		/* 82225724h case    7:*/		cpu::op::rlwimi<0,4,25,27>(regs,&regs.R10,regs.R24);
		/* 82225724h case    7:*/		return 0x82225728;
		  /* 82225728h */ case    8:  		/* stw R11, <#[R31 + 24]> */
		/* 82225728h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82225728h case    8:*/		return 0x8222572C;
		  /* 8222572Ch */ case    9:  		/* stw R10, <#[R31 + 4]> */
		/* 8222572Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8222572Ch case    9:*/		return 0x82225730;
		  /* 82225730h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 82225730h case   10:*/		if ( regs.CR[6].eq ) { return 0x82225750;  }
		/* 82225730h case   10:*/		return 0x82225734;
		  /* 82225734h */ case   11:  		/* stw R11, <#[R31 + 28]> */
		/* 82225734h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82225734h case   11:*/		return 0x82225738;
		  /* 82225738h */ case   12:  		/* li R11, 40 */
		/* 82225738h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x28);
		/* 82225738h case   12:*/		return 0x8222573C;
		  /* 8222573Ch */ case   13:  		/* lwz R10, <#[R29 + 12]> */
		/* 8222573Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 8222573Ch case   13:*/		return 0x82225740;
		  /* 82225740h */ case   14:  		/* subf R10, R10, R31 */
		/* 82225740h case   14:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82225740h case   14:*/		return 0x82225744;
		  /* 82225744h */ case   15:  		/* mr R3, R29 */
		/* 82225744h case   15:*/		regs.R3 = regs.R29;
		/* 82225744h case   15:*/		return 0x82225748;
		  /* 82225748h */ case   16:  		/* divw R4, R10, R11 */
		/* 82225748h case   16:*/		cpu::op::divw<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 82225748h case   16:*/		return 0x8222574C;
		  /* 8222574Ch */ case   17:  		/* bl -622044 */
		/* 8222574Ch case   17:*/		regs.LR = 0x82225750; return 0x8218D970;
		/* 8222574Ch case   17:*/		return 0x82225750;
	}
	return 0x82225750;
} // Block from 82225708h-82225750h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82225750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225750);
		  /* 82225750h */ case    0:  		/* mr R3, R31 */
		/* 82225750h case    0:*/		regs.R3 = regs.R31;
		/* 82225750h case    0:*/		return 0x82225754;
		  /* 82225754h */ case    1:  		/* addi R1, R1, 160 */
		/* 82225754h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82225754h case    1:*/		return 0x82225758;
		  /* 82225758h */ case    2:  		/* b -1656000 */
		/* 82225758h case    2:*/		return 0x82091298;
		/* 82225758h case    2:*/		return 0x8222575C;
		  /* 8222575Ch */ case    3:  		/* nop */
		/* 8222575Ch case    3:*/		cpu::op::nop();
		/* 8222575Ch case    3:*/		return 0x82225760;
	}
	return 0x82225760;
} // Block from 82225750h-82225760h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225760h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225760);
		  /* 82225760h */ case    0:  		/* mfspr R12, LR */
		/* 82225760h case    0:*/		regs.R12 = regs.LR;
		/* 82225760h case    0:*/		return 0x82225764;
		  /* 82225764h */ case    1:  		/* bl -1656092 */
		/* 82225764h case    1:*/		regs.LR = 0x82225768; return 0x82091248;
		/* 82225764h case    1:*/		return 0x82225768;
		  /* 82225768h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82225768h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82225768h case    2:*/		return 0x8222576C;
		  /* 8222576Ch */ case    3:  		/* lwz R29, <#[R3 + 20]> */
		/* 8222576Ch case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 8222576Ch case    3:*/		return 0x82225770;
		  /* 82225770h */ case    4:  		/* mr R27, R4 */
		/* 82225770h case    4:*/		regs.R27 = regs.R4;
		/* 82225770h case    4:*/		return 0x82225774;
		  /* 82225774h */ case    5:  		/* mr R25, R3 */
		/* 82225774h case    5:*/		regs.R25 = regs.R3;
		/* 82225774h case    5:*/		return 0x82225778;
		  /* 82225778h */ case    6:  		/* addi R28, R29, 1 */
		/* 82225778h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x1);
		/* 82225778h case    6:*/		return 0x8222577C;
		  /* 8222577Ch */ case    7:  		/* mr R26, R5 */
		/* 8222577Ch case    7:*/		regs.R26 = regs.R5;
		/* 8222577Ch case    7:*/		return 0x82225780;
		  /* 82225780h */ case    8:  		/* mulli R4, R28, 40 */
		/* 82225780h case    8:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R28,0x28);
		/* 82225780h case    8:*/		return 0x82225784;
		  /* 82225784h */ case    9:  		/* mr R24, R6 */
		/* 82225784h case    9:*/		regs.R24 = regs.R6;
		/* 82225784h case    9:*/		return 0x82225788;
		  /* 82225788h */ case   10:  		/* addi R31, R3, 812 */
		/* 82225788h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x32C);
		/* 82225788h case   10:*/		return 0x8222578C;
		  /* 8222578Ch */ case   11:  		/* cmplwi CR6, R4, 132 */
		/* 8222578Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 8222578Ch case   11:*/		return 0x82225790;
		  /* 82225790h */ case   12:  		/* bc 4, CR6_GT, 16 */
		/* 82225790h case   12:*/		if ( !regs.CR[6].gt ) { return 0x822257A0;  }
		/* 82225790h case   12:*/		return 0x82225794;
		  /* 82225794h */ case   13:  		/* mr R3, R31 */
		/* 82225794h case   13:*/		regs.R3 = regs.R31;
		/* 82225794h case   13:*/		return 0x82225798;
		  /* 82225798h */ case   14:  		/* bl -788616 */
		/* 82225798h case   14:*/		regs.LR = 0x8222579C; return 0x82164F10;
		/* 82225798h case   14:*/		return 0x8222579C;
		  /* 8222579Ch */ case   15:  		/* b 104 */
		/* 8222579Ch case   15:*/		return 0x82225804;
		/* 8222579Ch case   15:*/		return 0x822257A0;
	}
	return 0x822257A0;
} // Block from 82225760h-822257A0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822257A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822257A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822257A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822257A0);
		  /* 822257A0h */ case    0:  		/* lwz R10, <#[R31 + 140]> */
		/* 822257A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 822257A0h case    0:*/		return 0x822257A4;
		  /* 822257A4h */ case    1:  		/* lwz R11, <#[R31 + 144]> */
		/* 822257A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 822257A4h case    1:*/		return 0x822257A8;
		  /* 822257A8h */ case    2:  		/* subf R10, R11, R10 */
		/* 822257A8h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822257A8h case    2:*/		return 0x822257AC;
		  /* 822257ACh */ case    3:  		/* addi R10, R10, 4096 */
		/* 822257ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 822257ACh case    3:*/		return 0x822257B0;
		  /* 822257B0h */ case    4:  		/* cmplw CR6, R10, R4 */
		/* 822257B0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 822257B0h case    4:*/		return 0x822257B4;
		  /* 822257B4h */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 822257B4h case    5:*/		if ( regs.CR[6].lt ) { return 0x822257C8;  }
		/* 822257B4h case    5:*/		return 0x822257B8;
		  /* 822257B8h */ case    6:  		/* add R10, R11, R4 */
		/* 822257B8h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 822257B8h case    6:*/		return 0x822257BC;
		  /* 822257BCh */ case    7:  		/* mr R30, R11 */
		/* 822257BCh case    7:*/		regs.R30 = regs.R11;
		/* 822257BCh case    7:*/		return 0x822257C0;
		  /* 822257C0h */ case    8:  		/* stw R10, <#[R31 + 144]> */
		/* 822257C0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000090) );
		/* 822257C0h case    8:*/		return 0x822257C4;
		  /* 822257C4h */ case    9:  		/* b 68 */
		/* 822257C4h case    9:*/		return 0x82225808;
		/* 822257C4h case    9:*/		return 0x822257C8;
	}
	return 0x822257C8;
} // Block from 822257A0h-822257C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822257C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822257C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822257C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822257C8);
		  /* 822257C8h */ case    0:  		/* rlwinm R11, R4, 30, 2, 31 */
		/* 822257C8h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R4);
		/* 822257C8h case    0:*/		return 0x822257CC;
		  /* 822257CCh */ case    1:  		/* addi R11, R11, -1 */
		/* 822257CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822257CCh case    1:*/		return 0x822257D0;
		  /* 822257D0h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822257D0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822257D0h case    2:*/		return 0x822257D4;
		  /* 822257D4h */ case    3:  		/* lwzx R30, <#[R11 + R31]> */
		/* 822257D4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822257D4h case    3:*/		return 0x822257D8;
		  /* 822257D8h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 822257D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822257D8h case    4:*/		return 0x822257DC;
		  /* 822257DCh */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 822257DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x822257FC;  }
		/* 822257DCh case    5:*/		return 0x822257E0;
		  /* 822257E0h */ case    6:  		/* lwz R10, <#[R30]> */
		/* 822257E0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822257E0h case    6:*/		return 0x822257E4;
		  /* 822257E4h */ case    7:  		/* mr R5, R4 */
		/* 822257E4h case    7:*/		regs.R5 = regs.R4;
		/* 822257E4h case    7:*/		return 0x822257E8;
		  /* 822257E8h */ case    8:  		/* li R4, 0 */
		/* 822257E8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822257E8h case    8:*/		return 0x822257EC;
		  /* 822257ECh */ case    9:  		/* mr R3, R30 */
		/* 822257ECh case    9:*/		regs.R3 = regs.R30;
		/* 822257ECh case    9:*/		return 0x822257F0;
		  /* 822257F0h */ case   10:  		/* stwx R10, <#[R11 + R31]> */
		/* 822257F0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822257F0h case   10:*/		return 0x822257F4;
		  /* 822257F4h */ case   11:  		/* bl -1655988 */
		/* 822257F4h case   11:*/		regs.LR = 0x822257F8; return 0x82091340;
		/* 822257F4h case   11:*/		return 0x822257F8;
		  /* 822257F8h */ case   12:  		/* b 16 */
		/* 822257F8h case   12:*/		return 0x82225808;
		/* 822257F8h case   12:*/		return 0x822257FC;
	}
	return 0x822257FC;
} // Block from 822257C8h-822257FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 822257FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822257FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822257FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822257FC);
		  /* 822257FCh */ case    0:  		/* mr R3, R31 */
		/* 822257FCh case    0:*/		regs.R3 = regs.R31;
		/* 822257FCh case    0:*/		return 0x82225800;
		  /* 82225800h */ case    1:  		/* bl -791056 */
		/* 82225800h case    1:*/		regs.LR = 0x82225804; return 0x821645F0;
		/* 82225800h case    1:*/		return 0x82225804;
	}
	return 0x82225804;
} // Block from 822257FCh-82225804h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82225804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225804);
		  /* 82225804h */ case    0:  		/* mr R30, R3 */
		/* 82225804h case    0:*/		regs.R30 = regs.R3;
		/* 82225804h case    0:*/		return 0x82225808;
	}
	return 0x82225808;
} // Block from 82225804h-82225808h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225808);
		  /* 82225808h */ case    0:  		/* mulli R5, R29, 40 */
		/* 82225808h case    0:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R29,0x28);
		/* 82225808h case    0:*/		return 0x8222580C;
		  /* 8222580Ch */ case    1:  		/* lwz R4, <#[R25 + 12]> */
		/* 8222580Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x0000000C) );
		/* 8222580Ch case    1:*/		return 0x82225810;
		  /* 82225810h */ case    2:  		/* mr R3, R30 */
		/* 82225810h case    2:*/		regs.R3 = regs.R30;
		/* 82225810h case    2:*/		return 0x82225814;
		  /* 82225814h */ case    3:  		/* add R29, R5, R30 */
		/* 82225814h case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R5,regs.R30);
		/* 82225814h case    3:*/		return 0x82225818;
		  /* 82225818h */ case    4:  		/* bl -1654376 */
		/* 82225818h case    4:*/		regs.LR = 0x8222581C; return 0x820919B0;
		/* 82225818h case    4:*/		return 0x8222581C;
		  /* 8222581Ch */ case    5:  		/* lwz R10, <#[R25 + 20]> */
		/* 8222581Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000014) );
		/* 8222581Ch case    5:*/		return 0x82225820;
		  /* 82225820h */ case    6:  		/* lwz R11, <#[R25 + 12]> */
		/* 82225820h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 82225820h case    6:*/		return 0x82225824;
		  /* 82225824h */ case    7:  		/* mulli R10, R10, 40 */
		/* 82225824h case    7:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 82225824h case    7:*/		return 0x82225828;
		  /* 82225828h */ case    8:  		/* cmplwi CR6, R10, 132 */
		/* 82225828h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000084);
		/* 82225828h case    8:*/		return 0x8222582C;
		  /* 8222582Ch */ case    9:  		/* bc 4, CR6_GT, 56 */
		/* 8222582Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x82225864;  }
		/* 8222582Ch case    9:*/		return 0x82225830;
		  /* 82225830h */ case   10:  		/* addi R3, R11, -12 */
		/* 82225830h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF4);
		/* 82225830h case   10:*/		return 0x82225834;
		  /* 82225834h */ case   11:  		/* lis R4, 24973 */
		/* 82225834h case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x618D);
		/* 82225834h case   11:*/		return 0x82225838;
		  /* 82225838h */ case   12:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 82225838h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 82225838h case   12:*/		return 0x8222583C;
		  /* 8222583Ch */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 8222583Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8222583Ch case   13:*/		return 0x82225840;
		  /* 82225840h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 82225840h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82225840h case   14:*/		return 0x82225844;
		  /* 82225844h */ case   15:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82225844h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82225844h case   15:*/		return 0x82225848;
		  /* 82225848h */ case   16:  		/* stw R9, <#[R10]> */
		/* 82225848h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82225848h case   16:*/		return 0x8222584C;
		  /* 8222584Ch */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 8222584Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8222584Ch case   17:*/		return 0x82225850;
		  /* 82225850h */ case   18:  		/* lwz R11, <#[R11]> */
		/* 82225850h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82225850h case   18:*/		return 0x82225854;
		  /* 82225854h */ case   19:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82225854h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82225854h case   19:*/		return 0x82225858;
		  /* 82225858h */ case   20:  		/* stw R10, <#[R11]> */
		/* 82225858h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82225858h case   20:*/		return 0x8222585C;
		  /* 8222585Ch */ case   21:  		/* bl -1692964 */
		/* 8222585Ch case   21:*/		regs.LR = 0x82225860; return 0x82088338;
		/* 8222585Ch case   21:*/		return 0x82225860;
		  /* 82225860h */ case   22:  		/* b 28 */
		/* 82225860h case   22:*/		return 0x8222587C;
		/* 82225860h case   22:*/		return 0x82225864;
	}
	return 0x82225864;
} // Block from 82225808h-82225864h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82225864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225864);
		  /* 82225864h */ case    0:  		/* rlwinm R10, R10, 30, 2, 31 */
		/* 82225864h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R10);
		/* 82225864h case    0:*/		return 0x82225868;
		  /* 82225868h */ case    1:  		/* addi R10, R10, -1 */
		/* 82225868h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82225868h case    1:*/		return 0x8222586C;
		  /* 8222586Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8222586Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8222586Ch case    2:*/		return 0x82225870;
		  /* 82225870h */ case    3:  		/* lwzx R9, <#[R10 + R31]> */
		/* 82225870h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82225870h case    3:*/		return 0x82225874;
		  /* 82225874h */ case    4:  		/* stw R9, <#[R11]> */
		/* 82225874h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82225874h case    4:*/		return 0x82225878;
		  /* 82225878h */ case    5:  		/* stwx R11, <#[R10 + R31]> */
		/* 82225878h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82225878h case    5:*/		return 0x8222587C;
	}
	return 0x8222587C;
} // Block from 82225864h-8222587Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8222587Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222587C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222587C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222587C);
		  /* 8222587Ch */ case    0:  		/* rlwimi R27, R26, 3, 15, 28 */
		/* 8222587Ch case    0:*/		cpu::op::rlwimi<0,3,15,28>(regs,&regs.R27,regs.R26);
		/* 8222587Ch case    0:*/		return 0x82225880;
		  /* 82225880h */ case    1:  		/* stw R30, <#[R25 + 12]> */
		/* 82225880h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R25 + 0x0000000C) );
		/* 82225880h case    1:*/		return 0x82225884;
		  /* 82225884h */ case    2:  		/* stw R28, <#[R25 + 20]> */
		/* 82225884h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R25 + 0x00000014) );
		/* 82225884h case    2:*/		return 0x82225888;
		  /* 82225888h */ case    3:  		/* rlwinm R4, R26, 3, 0, 28 */
		/* 82225888h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R26);
		/* 82225888h case    3:*/		return 0x8222588C;
		  /* 8222588Ch */ case    4:  		/* stw R28, <#[R25 + 16]> */
		/* 8222588Ch case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R25 + 0x00000010) );
		/* 8222588Ch case    4:*/		return 0x82225890;
		  /* 82225890h */ case    5:  		/* lwz R11, <#[R29]> */
		/* 82225890h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82225890h case    5:*/		return 0x82225894;
		  /* 82225894h */ case    6:  		/* rlwimi R27, R11, 0, 0, 14 */
		/* 82225894h case    6:*/		cpu::op::rlwimi<0,0,0,14>(regs,&regs.R27,regs.R11);
		/* 82225894h case    6:*/		return 0x82225898;
		  /* 82225898h */ case    7:  		/* cmplwi CR6, R4, 132 */
		/* 82225898h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 82225898h case    7:*/		return 0x8222589C;
		  /* 8222589Ch */ case    8:  		/* stw R27, <#[R29]> */
		/* 8222589Ch case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000000) );
		/* 8222589Ch case    8:*/		return 0x822258A0;
		  /* 822258A0h */ case    9:  		/* bc 4, CR6_GT, 16 */
		/* 822258A0h case    9:*/		if ( !regs.CR[6].gt ) { return 0x822258B0;  }
		/* 822258A0h case    9:*/		return 0x822258A4;
		  /* 822258A4h */ case   10:  		/* mr R3, R31 */
		/* 822258A4h case   10:*/		regs.R3 = regs.R31;
		/* 822258A4h case   10:*/		return 0x822258A8;
		  /* 822258A8h */ case   11:  		/* bl -788888 */
		/* 822258A8h case   11:*/		regs.LR = 0x822258AC; return 0x82164F10;
		/* 822258A8h case   11:*/		return 0x822258AC;
		  /* 822258ACh */ case   12:  		/* b 104 */
		/* 822258ACh case   12:*/		return 0x82225914;
		/* 822258ACh case   12:*/		return 0x822258B0;
	}
	return 0x822258B0;
} // Block from 8222587Ch-822258B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822258B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822258B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822258B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822258B0);
		  /* 822258B0h */ case    0:  		/* lwz R10, <#[R31 + 140]> */
		/* 822258B0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 822258B0h case    0:*/		return 0x822258B4;
		  /* 822258B4h */ case    1:  		/* lwz R11, <#[R31 + 144]> */
		/* 822258B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 822258B4h case    1:*/		return 0x822258B8;
		  /* 822258B8h */ case    2:  		/* subf R10, R11, R10 */
		/* 822258B8h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822258B8h case    2:*/		return 0x822258BC;
		  /* 822258BCh */ case    3:  		/* addi R10, R10, 4096 */
		/* 822258BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 822258BCh case    3:*/		return 0x822258C0;
		  /* 822258C0h */ case    4:  		/* cmplw CR6, R10, R4 */
		/* 822258C0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 822258C0h case    4:*/		return 0x822258C4;
		  /* 822258C4h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 822258C4h case    5:*/		if ( regs.CR[6].lt ) { return 0x822258D4;  }
		/* 822258C4h case    5:*/		return 0x822258C8;
	}
	return 0x822258C8;
} // Block from 822258B0h-822258C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822258C8h
// Function '?CloneFetchWithDifferentSampler@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822258C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822258C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822258C8);
		  /* 822258C8h */ case    0:  		/* add R10, R11, R4 */
		/* 822258C8h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 822258C8h case    0:*/		return 0x822258CC;
		  /* 822258CCh */ case    1:  		/* stw R10, <#[R31 + 144]> */
		/* 822258CCh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000090) );
		/* 822258CCh case    1:*/		return 0x822258D0;
		  /* 822258D0h */ case    2:  		/* b 72 */
		/* 822258D0h case    2:*/		return 0x82225918;
		/* 822258D0h case    2:*/		return 0x822258D4;
	}
	return 0x822258D4;
} // Block from 822258C8h-822258D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822258D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822258D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822258D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822258D4);
		  /* 822258D4h */ case    0:  		/* rlwinm R11, R4, 30, 2, 31 */
		/* 822258D4h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R4);
		/* 822258D4h case    0:*/		return 0x822258D8;
		  /* 822258D8h */ case    1:  		/* addi R11, R11, -1 */
		/* 822258D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822258D8h case    1:*/		return 0x822258DC;
		  /* 822258DCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822258DCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822258DCh case    2:*/		return 0x822258E0;
		  /* 822258E0h */ case    3:  		/* lwzx R30, <#[R11 + R31]> */
		/* 822258E0h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822258E0h case    3:*/		return 0x822258E4;
		  /* 822258E4h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 822258E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822258E4h case    4:*/		return 0x822258E8;
		  /* 822258E8h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 822258E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8222590C;  }
		/* 822258E8h case    5:*/		return 0x822258EC;
		  /* 822258ECh */ case    6:  		/* lwz R10, <#[R30]> */
		/* 822258ECh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822258ECh case    6:*/		return 0x822258F0;
		  /* 822258F0h */ case    7:  		/* mr R5, R4 */
		/* 822258F0h case    7:*/		regs.R5 = regs.R4;
		/* 822258F0h case    7:*/		return 0x822258F4;
		  /* 822258F4h */ case    8:  		/* li R4, 0 */
		/* 822258F4h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822258F4h case    8:*/		return 0x822258F8;
		  /* 822258F8h */ case    9:  		/* mr R3, R30 */
		/* 822258F8h case    9:*/		regs.R3 = regs.R30;
		/* 822258F8h case    9:*/		return 0x822258FC;
		  /* 822258FCh */ case   10:  		/* stwx R10, <#[R11 + R31]> */
		/* 822258FCh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822258FCh case   10:*/		return 0x82225900;
		  /* 82225900h */ case   11:  		/* bl -1656256 */
		/* 82225900h case   11:*/		regs.LR = 0x82225904; return 0x82091340;
		/* 82225900h case   11:*/		return 0x82225904;
		  /* 82225904h */ case   12:  		/* mr R11, R30 */
		/* 82225904h case   12:*/		regs.R11 = regs.R30;
		/* 82225904h case   12:*/		return 0x82225908;
		  /* 82225908h */ case   13:  		/* b 16 */
		/* 82225908h case   13:*/		return 0x82225918;
		/* 82225908h case   13:*/		return 0x8222590C;
	}
	return 0x8222590C;
} // Block from 822258D4h-8222590Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8222590Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222590C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222590C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222590C);
		  /* 8222590Ch */ case    0:  		/* mr R3, R31 */
		/* 8222590Ch case    0:*/		regs.R3 = regs.R31;
		/* 8222590Ch case    0:*/		return 0x82225910;
		  /* 82225910h */ case    1:  		/* bl -791328 */
		/* 82225910h case    1:*/		regs.LR = 0x82225914; return 0x821645F0;
		/* 82225910h case    1:*/		return 0x82225914;
	}
	return 0x82225914;
} // Block from 8222590Ch-82225914h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82225914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225914);
		  /* 82225914h */ case    0:  		/* mr R11, R3 */
		/* 82225914h case    0:*/		regs.R11 = regs.R3;
		/* 82225914h case    0:*/		return 0x82225918;
	}
	return 0x82225918;
} // Block from 82225914h-82225918h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225918);
		  /* 82225918h */ case    0:  		/* stw R11, <#[R29 + 28]> */
		/* 82225918h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 82225918h case    0:*/		return 0x8222591C;
		  /* 8222591Ch */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 8222591Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8222591Ch case    1:*/		return 0x82225920;
		  /* 82225920h */ case    2:  		/* bc 12, CR6_EQ, 284 */
		/* 82225920h case    2:*/		if ( regs.CR[6].eq ) { return 0x82225A3C;  }
		/* 82225920h case    2:*/		return 0x82225924;
		  /* 82225924h */ case    3:  		/* li R30, 0 */
		/* 82225924h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82225924h case    3:*/		return 0x82225928;
		  /* 82225928h */ case    4:  		/* lwz R11, <#[R25 + 16]> */
		/* 82225928h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82225928h case    4:*/		return 0x8222592C;
		  /* 8222592Ch */ case    5:  		/* mr R3, R25 */
		/* 8222592Ch case    5:*/		regs.R3 = regs.R25;
		/* 8222592Ch case    5:*/		return 0x82225930;
		  /* 82225930h */ case    6:  		/* cmplw CR6, R30, R11 */
		/* 82225930h case    6:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82225930h case    6:*/		return 0x82225934;
		  /* 82225934h */ case    7:  		/* bc 4, CR6_LT, 244 */
		/* 82225934h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82225A28;  }
		/* 82225934h case    7:*/		return 0x82225938;
		  /* 82225938h */ case    8:  		/* mr R4, R30 */
		/* 82225938h case    8:*/		regs.R4 = regs.R30;
		/* 82225938h case    8:*/		return 0x8222593C;
		  /* 8222593Ch */ case    9:  		/* bl -233212 */
		/* 8222593Ch case    9:*/		regs.LR = 0x82225940; return 0x821ECA40;
		/* 8222593Ch case    9:*/		return 0x82225940;
		  /* 82225940h */ case   10:  		/* mr R4, R24 */
		/* 82225940h case   10:*/		regs.R4 = regs.R24;
		/* 82225940h case   10:*/		return 0x82225944;
		  /* 82225944h */ case   11:  		/* bl -1647892 */
		/* 82225944h case   11:*/		regs.LR = 0x82225948; return 0x82093430;
		/* 82225944h case   11:*/		return 0x82225948;
		  /* 82225948h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 82225948h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82225948h case   12:*/		return 0x8222594C;
		  /* 8222594Ch */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 8222594Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82225958;  }
		/* 8222594Ch case   13:*/		return 0x82225950;
		  /* 82225950h */ case   14:  		/* addi R30, R30, 1 */
		/* 82225950h case   14:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82225950h case   14:*/		return 0x82225954;
		  /* 82225954h */ case   15:  		/* b -44 */
		/* 82225954h case   15:*/		return 0x82225928;
		/* 82225954h case   15:*/		return 0x82225958;
	}
	return 0x82225958;
} // Block from 82225918h-82225958h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82225958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225958);
		  /* 82225958h */ case    0:  		/* mr R11, R24 */
		/* 82225958h case    0:*/		regs.R11 = regs.R24;
		/* 82225958h case    0:*/		return 0x8222595C;
		  /* 8222595Ch */ case    1:  		/* lbz R10, <#[R11]> */
		/* 8222595Ch case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222595Ch case    1:*/		return 0x82225960;
		  /* 82225960h */ case    2:  		/* addi R11, R11, 1 */
		/* 82225960h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82225960h case    2:*/		return 0x82225964;
		  /* 82225964h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82225964h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82225964h case    3:*/		return 0x82225968;
		  /* 82225968h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82225968h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8222595C;  }
		/* 82225968h case    4:*/		return 0x8222596C;
		  /* 8222596Ch */ case    5:  		/* subf R11, R24, R11 */
		/* 8222596Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 8222596Ch case    5:*/		return 0x82225970;
		  /* 82225970h */ case    6:  		/* addi R11, R11, -1 */
		/* 82225970h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82225970h case    6:*/		return 0x82225974;
		  /* 82225974h */ case    7:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82225974h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82225974h case    7:*/		return 0x82225978;
		  /* 82225978h */ case    8:  		/* addi R4, R11, 2 */
		/* 82225978h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x2);
		/* 82225978h case    8:*/		return 0x8222597C;
		  /* 8222597Ch */ case    9:  		/* cmplwi CR6, R4, 132 */
		/* 8222597Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 8222597Ch case    9:*/		return 0x82225980;
		  /* 82225980h */ case   10:  		/* bc 4, CR6_GT, 16 */
		/* 82225980h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82225990;  }
		/* 82225980h case   10:*/		return 0x82225984;
		  /* 82225984h */ case   11:  		/* mr R3, R31 */
		/* 82225984h case   11:*/		regs.R3 = regs.R31;
		/* 82225984h case   11:*/		return 0x82225988;
		  /* 82225988h */ case   12:  		/* bl -789112 */
		/* 82225988h case   12:*/		regs.LR = 0x8222598C; return 0x82164F10;
		/* 82225988h case   12:*/		return 0x8222598C;
		  /* 8222598Ch */ case   13:  		/* b 108 */
		/* 8222598Ch case   13:*/		return 0x822259F8;
		/* 8222598Ch case   13:*/		return 0x82225990;
	}
	return 0x82225990;
} // Block from 82225958h-82225990h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82225990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225990);
		  /* 82225990h */ case    0:  		/* lwz R10, <#[R31 + 140]> */
		/* 82225990h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 82225990h case    0:*/		return 0x82225994;
		  /* 82225994h */ case    1:  		/* lwz R11, <#[R31 + 144]> */
		/* 82225994h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 82225994h case    1:*/		return 0x82225998;
		  /* 82225998h */ case    2:  		/* subf R10, R11, R10 */
		/* 82225998h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82225998h case    2:*/		return 0x8222599C;
		  /* 8222599Ch */ case    3:  		/* addi R10, R10, 4096 */
		/* 8222599Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 8222599Ch case    3:*/		return 0x822259A0;
		  /* 822259A0h */ case    4:  		/* cmplw CR6, R10, R4 */
		/* 822259A0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 822259A0h case    4:*/		return 0x822259A4;
		  /* 822259A4h */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 822259A4h case    5:*/		if ( regs.CR[6].lt ) { return 0x822259B8;  }
		/* 822259A4h case    5:*/		return 0x822259A8;
		  /* 822259A8h */ case    6:  		/* add R10, R11, R4 */
		/* 822259A8h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 822259A8h case    6:*/		return 0x822259AC;
		  /* 822259ACh */ case    7:  		/* mr R3, R11 */
		/* 822259ACh case    7:*/		regs.R3 = regs.R11;
		/* 822259ACh case    7:*/		return 0x822259B0;
		  /* 822259B0h */ case    8:  		/* stw R10, <#[R31 + 144]> */
		/* 822259B0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000090) );
		/* 822259B0h case    8:*/		return 0x822259B4;
		  /* 822259B4h */ case    9:  		/* b 68 */
		/* 822259B4h case    9:*/		return 0x822259F8;
		/* 822259B4h case    9:*/		return 0x822259B8;
	}
	return 0x822259B8;
} // Block from 82225990h-822259B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822259B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822259B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822259B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822259B8);
		  /* 822259B8h */ case    0:  		/* rlwinm R11, R4, 30, 2, 31 */
		/* 822259B8h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R4);
		/* 822259B8h case    0:*/		return 0x822259BC;
		  /* 822259BCh */ case    1:  		/* addi R11, R11, -1 */
		/* 822259BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822259BCh case    1:*/		return 0x822259C0;
		  /* 822259C0h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822259C0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822259C0h case    2:*/		return 0x822259C4;
		  /* 822259C4h */ case    3:  		/* lwzx R30, <#[R11 + R31]> */
		/* 822259C4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822259C4h case    3:*/		return 0x822259C8;
		  /* 822259C8h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 822259C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822259C8h case    4:*/		return 0x822259CC;
		  /* 822259CCh */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 822259CCh case    5:*/		if ( regs.CR[6].eq ) { return 0x822259F0;  }
		/* 822259CCh case    5:*/		return 0x822259D0;
		  /* 822259D0h */ case    6:  		/* lwz R10, <#[R30]> */
		/* 822259D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822259D0h case    6:*/		return 0x822259D4;
		  /* 822259D4h */ case    7:  		/* mr R5, R4 */
		/* 822259D4h case    7:*/		regs.R5 = regs.R4;
		/* 822259D4h case    7:*/		return 0x822259D8;
		  /* 822259D8h */ case    8:  		/* li R4, 0 */
		/* 822259D8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822259D8h case    8:*/		return 0x822259DC;
		  /* 822259DCh */ case    9:  		/* mr R3, R30 */
		/* 822259DCh case    9:*/		regs.R3 = regs.R30;
		/* 822259DCh case    9:*/		return 0x822259E0;
		  /* 822259E0h */ case   10:  		/* stwx R10, <#[R11 + R31]> */
		/* 822259E0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 822259E0h case   10:*/		return 0x822259E4;
		  /* 822259E4h */ case   11:  		/* bl -1656484 */
		/* 822259E4h case   11:*/		regs.LR = 0x822259E8; return 0x82091340;
		/* 822259E4h case   11:*/		return 0x822259E8;
	}
	return 0x822259E8;
} // Block from 822259B8h-822259E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822259E8h
// Function '?CreateVertexShaderInputInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@ULinkageSemantics@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822259E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822259E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822259E8);
		  /* 822259E8h */ case    0:  		/* mr R3, R30 */
		/* 822259E8h case    0:*/		regs.R3 = regs.R30;
		/* 822259E8h case    0:*/		return 0x822259EC;
		  /* 822259ECh */ case    1:  		/* b 12 */
		/* 822259ECh case    1:*/		return 0x822259F8;
		/* 822259ECh case    1:*/		return 0x822259F0;
	}
	return 0x822259F0;
} // Block from 822259E8h-822259F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822259F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822259F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822259F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822259F0);
		  /* 822259F0h */ case    0:  		/* mr R3, R31 */
		/* 822259F0h case    0:*/		regs.R3 = regs.R31;
		/* 822259F0h case    0:*/		return 0x822259F4;
		  /* 822259F4h */ case    1:  		/* bl -791556 */
		/* 822259F4h case    1:*/		regs.LR = 0x822259F8; return 0x821645F0;
		/* 822259F4h case    1:*/		return 0x822259F8;
	}
	return 0x822259F8;
} // Block from 822259F0h-822259F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822259F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822259F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822259F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822259F8);
		  /* 822259F8h */ case    0:  		/* li R11, 36 */
		/* 822259F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x24);
		/* 822259F8h case    0:*/		return 0x822259FC;
		  /* 822259FCh */ case    1:  		/* subf R10, R24, R3 */
		/* 822259FCh case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R24,regs.R3);
		/* 822259FCh case    1:*/		return 0x82225A00;
		  /* 82225A00h */ case    2:  		/* stb R11, <#[R3]> */
		/* 82225A00h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82225A00h case    2:*/		return 0x82225A04;
		  /* 82225A04h */ case    3:  		/* mr R11, R24 */
		/* 82225A04h case    3:*/		regs.R11 = regs.R24;
		/* 82225A04h case    3:*/		return 0x82225A08;
		  /* 82225A08h */ case    4:  		/* addi R10, R10, 1 */
		/* 82225A08h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82225A08h case    4:*/		return 0x82225A0C;
		  /* 82225A0Ch */ case    5:  		/* lbz R9, <#[R11]> */
		/* 82225A0Ch case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82225A0Ch case    5:*/		return 0x82225A10;
		  /* 82225A10h */ case    6:  		/* extsb. R8, R9 */
		/* 82225A10h case    6:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R9);
		/* 82225A10h case    6:*/		return 0x82225A14;
		  /* 82225A14h */ case    7:  		/* stbx R9, <#[R10 + R11]> */
		/* 82225A14h case    7:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82225A14h case    7:*/		return 0x82225A18;
		  /* 82225A18h */ case    8:  		/* addi R11, R11, 1 */
		/* 82225A18h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82225A18h case    8:*/		return 0x82225A1C;
		  /* 82225A1Ch */ case    9:  		/* bc 4, CR0_EQ, -16 */
		/* 82225A1Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x82225A0C;  }
		/* 82225A1Ch case    9:*/		return 0x82225A20;
		  /* 82225A20h */ case   10:  		/* mr R24, R3 */
		/* 82225A20h case   10:*/		regs.R24 = regs.R3;
		/* 82225A20h case   10:*/		return 0x82225A24;
		  /* 82225A24h */ case   11:  		/* b -256 */
		/* 82225A24h case   11:*/		return 0x82225924;
		/* 82225A24h case   11:*/		return 0x82225A28;
	}
	return 0x82225A28;
} // Block from 822259F8h-82225A28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82225A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225A28);
		  /* 82225A28h */ case    0:  		/* li R6, 0 */
		/* 82225A28h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82225A28h case    0:*/		return 0x82225A2C;
		  /* 82225A2Ch */ case    1:  		/* mr R5, R24 */
		/* 82225A2Ch case    1:*/		regs.R5 = regs.R24;
		/* 82225A2Ch case    1:*/		return 0x82225A30;
		  /* 82225A30h */ case    2:  		/* li R4, 1 */
		/* 82225A30h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82225A30h case    2:*/		return 0x82225A34;
		  /* 82225A34h */ case    3:  		/* bl -232236 */
		/* 82225A34h case    3:*/		regs.LR = 0x82225A38; return 0x821ECF08;
		/* 82225A34h case    3:*/		return 0x82225A38;
		  /* 82225A38h */ case    4:  		/* stw R3, <#[R29 + 12]> */
		/* 82225A38h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000000C) );
		/* 82225A38h case    4:*/		return 0x82225A3C;
	}
	return 0x82225A3C;
} // Block from 82225A28h-82225A3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82225A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225A3C);
		  /* 82225A3Ch */ case    0:  		/* mr R3, R29 */
		/* 82225A3Ch case    0:*/		regs.R3 = regs.R29;
		/* 82225A3Ch case    0:*/		return 0x82225A40;
		  /* 82225A40h */ case    1:  		/* addi R1, R1, 160 */
		/* 82225A40h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82225A40h case    1:*/		return 0x82225A44;
		  /* 82225A44h */ case    2:  		/* b -1656748 */
		/* 82225A44h case    2:*/		return 0x82091298;
		/* 82225A44h case    2:*/		return 0x82225A48;
	}
	return 0x82225A48;
} // Block from 82225A3Ch-82225A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82225A48h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225A48);
		  /* 82225A48h */ case    0:  		/* mfspr R12, LR */
		/* 82225A48h case    0:*/		regs.R12 = regs.LR;
		/* 82225A48h case    0:*/		return 0x82225A4C;
		  /* 82225A4Ch */ case    1:  		/* bl -1656840 */
		/* 82225A4Ch case    1:*/		regs.LR = 0x82225A50; return 0x82091244;
		/* 82225A4Ch case    1:*/		return 0x82225A50;
		  /* 82225A50h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82225A50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82225A50h case    2:*/		return 0x82225A54;
		  /* 82225A54h */ case    3:  		/* mr R27, R5 */
		/* 82225A54h case    3:*/		regs.R27 = regs.R5;
		/* 82225A54h case    3:*/		return 0x82225A58;
		  /* 82225A58h */ case    4:  		/* mr R25, R3 */
		/* 82225A58h case    4:*/		regs.R25 = regs.R3;
		/* 82225A58h case    4:*/		return 0x82225A5C;
		  /* 82225A5Ch */ case    5:  		/* mr R31, R4 */
		/* 82225A5Ch case    5:*/		regs.R31 = regs.R4;
		/* 82225A5Ch case    5:*/		return 0x82225A60;
		  /* 82225A60h */ case    6:  		/* mr R5, R4 */
		/* 82225A60h case    6:*/		regs.R5 = regs.R4;
		/* 82225A60h case    6:*/		return 0x82225A64;
		  /* 82225A64h */ case    7:  		/* mr R4, R6 */
		/* 82225A64h case    7:*/		regs.R4 = regs.R6;
		/* 82225A64h case    7:*/		return 0x82225A68;
		  /* 82225A68h */ case    8:  		/* mr R3, R27 */
		/* 82225A68h case    8:*/		regs.R3 = regs.R27;
		/* 82225A68h case    8:*/		return 0x82225A6C;
		  /* 82225A6Ch */ case    9:  		/* mr R29, R6 */
		/* 82225A6Ch case    9:*/		regs.R29 = regs.R6;
		/* 82225A6Ch case    9:*/		return 0x82225A70;
		  /* 82225A70h */ case   10:  		/* mr R26, R7 */
		/* 82225A70h case   10:*/		regs.R26 = regs.R7;
		/* 82225A70h case   10:*/		return 0x82225A74;
		  /* 82225A74h */ case   11:  		/* bl -217284 */
		/* 82225A74h case   11:*/		regs.LR = 0x82225A78; return 0x821F09B0;
		/* 82225A74h case   11:*/		return 0x82225A78;
		  /* 82225A78h */ case   12:  		/* rlwinm R24, R26, 3, 0, 28 */
		/* 82225A78h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R24,regs.R26);
		/* 82225A78h case   12:*/		return 0x82225A7C;
		  /* 82225A7Ch */ case   13:  		/* add R23, R24, R3 */
		/* 82225A7Ch case   13:*/		cpu::op::add<0>(regs,&regs.R23,regs.R24,regs.R3);
		/* 82225A7Ch case   13:*/		return 0x82225A80;
		  /* 82225A80h */ case   14:  		/* lwzx R11, <#[R24 + R3]> */
		/* 82225A80h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R3 + 0x00000000) );
		/* 82225A80h case   14:*/		return 0x82225A84;
		  /* 82225A84h */ case   15:  		/* lwz R10, <#[R23 + 4]> */
		/* 82225A84h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82225A84h case   15:*/		return 0x82225A88;
		  /* 82225A88h */ case   16:  		/* stw R11, <#[R25]> */
		/* 82225A88h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82225A88h case   16:*/		return 0x82225A8C;
		  /* 82225A8Ch */ case   17:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 82225A8Ch case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 82225A8Ch case   17:*/		return 0x82225A90;
		  /* 82225A90h */ case   18:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82225A90h case   18:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82225A90h case   18:*/		return 0x82225A94;
		  /* 82225A94h */ case   19:  		/* stw R10, <#[R25 + 4]> */
		/* 82225A94h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 82225A94h case   19:*/		return 0x82225A98;
		  /* 82225A98h */ case   20:  		/* cmpwi CR6, R11, 1 */
		/* 82225A98h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82225A98h case   20:*/		return 0x82225A9C;
		  /* 82225A9Ch */ case   21:  		/* bc 4, CR6_EQ, 76 */
		/* 82225A9Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x82225AE8;  }
		/* 82225A9Ch case   21:*/		return 0x82225AA0;
		  /* 82225AA0h */ case   22:  		/* lwz R30, <#[R25]> */
		/* 82225AA0h case   22:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000000) );
		/* 82225AA0h case   22:*/		return 0x82225AA4;
		  /* 82225AA4h */ case   23:  		/* lwz R11, <#[R30 + 8]> */
		/* 82225AA4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82225AA4h case   23:*/		return 0x82225AA8;
		  /* 82225AA8h */ case   24:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82225AA8h case   24:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82225AA8h case   24:*/		return 0x82225AAC;
		  /* 82225AACh */ case   25:  		/* cmplwi CR6, R11, 14336 */
		/* 82225AACh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82225AACh case   25:*/		return 0x82225AB0;
		  /* 82225AB0h */ case   26:  		/* bc 4, CR6_EQ, 56 */
		/* 82225AB0h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82225AE8;  }
		/* 82225AB0h case   26:*/		return 0x82225AB4;
		  /* 82225AB4h */ case   27:  		/* li R6, 1 */
		/* 82225AB4h case   27:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82225AB4h case   27:*/		return 0x82225AB8;
		  /* 82225AB8h */ case   28:  		/* li R5, 0 */
		/* 82225AB8h case   28:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82225AB8h case   28:*/		return 0x82225ABC;
		  /* 82225ABCh */ case   29:  		/* li R4, 112 */
		/* 82225ABCh case   29:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 82225ABCh case   29:*/		return 0x82225AC0;
		  /* 82225AC0h */ case   30:  		/* mr R3, R31 */
		/* 82225AC0h case   30:*/		regs.R3 = regs.R31;
		/* 82225AC0h case   30:*/		return 0x82225AC4;
		  /* 82225AC4h */ case   31:  		/* bl -792212 */
		/* 82225AC4h case   31:*/		regs.LR = 0x82225AC8; return 0x82164430;
		/* 82225AC4h case   31:*/		return 0x82225AC8;
		  /* 82225AC8h */ case   32:  		/* addi R11, R30, -8 */
		/* 82225AC8h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 82225AC8h case   32:*/		return 0x82225ACC;
		  /* 82225ACCh */ case   33:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82225ACCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82225ACCh case   33:*/		return 0x82225AD0;
		  /* 82225AD0h */ case   34:  		/* rlwinm R10, R11, 0, 17, 31 */
		/* 82225AD0h case   34:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R11);
		/* 82225AD0h case   34:*/		return 0x82225AD4;
		  /* 82225AD4h */ case   35:  		/* cmplw CR6, R29, R10 */
		/* 82225AD4h case   35:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82225AD4h case   35:*/		return 0x82225AD8;
		  /* 82225AD8h */ case   36:  		/* bc 4, CR6_EQ, 16 */
		/* 82225AD8h case   36:*/		if ( !regs.CR[6].eq ) { return 0x82225AE8;  }
		/* 82225AD8h case   36:*/		return 0x82225ADC;
		  /* 82225ADCh */ case   37:  		/* rlwinm R11, R11, 17, 18, 31 */
		/* 82225ADCh case   37:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R11,regs.R11);
		/* 82225ADCh case   37:*/		return 0x82225AE0;
		  /* 82225AE0h */ case   38:  		/* cmplw CR6, R26, R11 */
		/* 82225AE0h case   38:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82225AE0h case   38:*/		return 0x82225AE4;
		  /* 82225AE4h */ case   39:  		/* bc 12, CR6_EQ, 548 */
		/* 82225AE4h case   39:*/		if ( regs.CR[6].eq ) { return 0x82225D08;  }
		/* 82225AE4h case   39:*/		return 0x82225AE8;
	}
	return 0x82225AE8;
} // Block from 82225A48h-82225AE8h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82225AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225AE8);
		  /* 82225AE8h */ case    0:  		/* lwz R30, <#[R27 + 20]> */
		/* 82225AE8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000014) );
		/* 82225AE8h case    0:*/		return 0x82225AEC;
		  /* 82225AECh */ case    1:  		/* addi R11, R27, 16 */
		/* 82225AECh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x10);
		/* 82225AECh case    1:*/		return 0x82225AF0;
		  /* 82225AF0h */ case    2:  		/* rlwinm. R10, R30, 0, 31, 31 */
		/* 82225AF0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R30);
		/* 82225AF0h case    2:*/		return 0x82225AF4;
		  /* 82225AF4h */ case    3:  		/* addi R28, R11, 4 */
		/* 82225AF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x4);
		/* 82225AF4h case    3:*/		return 0x82225AF8;
		  /* 82225AF8h */ case    4:  		/* bc 4, CR0_EQ, 104 */
		/* 82225AF8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82225B60;  }
		/* 82225AF8h case    4:*/		return 0x82225AFC;
		  /* 82225AFCh */ case    5:  		/* cmplwi CR0, R30, 0 */
		/* 82225AFCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 82225AFCh case    5:*/		return 0x82225B00;
		  /* 82225B00h */ case    6:  		/* bc 12, CR0_EQ, 96 */
		/* 82225B00h case    6:*/		if ( regs.CR[0].eq ) { return 0x82225B60;  }
		/* 82225B00h case    6:*/		return 0x82225B04;
		  /* 82225B04h */ case    7:  		/* lwz R11, <#[R30 + 8]> */
		/* 82225B04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82225B04h case    7:*/		return 0x82225B08;
		  /* 82225B08h */ case    8:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82225B08h case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82225B08h case    8:*/		return 0x82225B0C;
		  /* 82225B0Ch */ case    9:  		/* cmplwi CR6, R11, 14336 */
		/* 82225B0Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 82225B0Ch case    9:*/		return 0x82225B10;
		  /* 82225B10h */ case   10:  		/* bc 4, CR6_EQ, 56 */
		/* 82225B10h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82225B48;  }
		/* 82225B10h case   10:*/		return 0x82225B14;
		  /* 82225B14h */ case   11:  		/* li R6, 1 */
		/* 82225B14h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82225B14h case   11:*/		return 0x82225B18;
		  /* 82225B18h */ case   12:  		/* li R5, 0 */
		/* 82225B18h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82225B18h case   12:*/		return 0x82225B1C;
		  /* 82225B1Ch */ case   13:  		/* li R4, 112 */
		/* 82225B1Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 82225B1Ch case   13:*/		return 0x82225B20;
		  /* 82225B20h */ case   14:  		/* mr R3, R31 */
		/* 82225B20h case   14:*/		regs.R3 = regs.R31;
		/* 82225B20h case   14:*/		return 0x82225B24;
		  /* 82225B24h */ case   15:  		/* bl -792308 */
		/* 82225B24h case   15:*/		regs.LR = 0x82225B28; return 0x82164430;
		/* 82225B24h case   15:*/		return 0x82225B28;
		  /* 82225B28h */ case   16:  		/* addi R11, R30, -8 */
		/* 82225B28h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 82225B28h case   16:*/		return 0x82225B2C;
		  /* 82225B2Ch */ case   17:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82225B2Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82225B2Ch case   17:*/		return 0x82225B30;
		  /* 82225B30h */ case   18:  		/* rlwinm R10, R11, 0, 17, 31 */
		/* 82225B30h case   18:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R11);
		/* 82225B30h case   18:*/		return 0x82225B34;
		  /* 82225B34h */ case   19:  		/* cmplw CR6, R10, R29 */
		/* 82225B34h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 82225B34h case   19:*/		return 0x82225B38;
		  /* 82225B38h */ case   20:  		/* bc 4, CR6_EQ, 16 */
		/* 82225B38h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82225B48;  }
		/* 82225B38h case   20:*/		return 0x82225B3C;
		  /* 82225B3Ch */ case   21:  		/* rlwinm R11, R11, 17, 18, 31 */
		/* 82225B3Ch case   21:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R11,regs.R11);
		/* 82225B3Ch case   21:*/		return 0x82225B40;
		  /* 82225B40h */ case   22:  		/* cmplw CR6, R11, R26 */
		/* 82225B40h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82225B40h case   22:*/		return 0x82225B44;
		  /* 82225B44h */ case   23:  		/* bc 12, CR6_EQ, 392 */
		/* 82225B44h case   23:*/		if ( regs.CR[6].eq ) { return 0x82225CCC;  }
		/* 82225B44h case   23:*/		return 0x82225B48;
	}
	return 0x82225B48;
} // Block from 82225AE8h-82225B48h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82225B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225B48);
		  /* 82225B48h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82225B48h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82225B48h case    0:*/		return 0x82225B4C;
		  /* 82225B4Ch */ case    1:  		/* lwz R30, <#[R11 + 40]> */
		/* 82225B4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000028) );
		/* 82225B4Ch case    1:*/		return 0x82225B50;
		  /* 82225B50h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82225B50h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82225B50h case    2:*/		return 0x82225B54;
		  /* 82225B54h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82225B54h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82225B60;  }
		/* 82225B54h case    3:*/		return 0x82225B58;
		  /* 82225B58h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82225B58h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82225B58h case    4:*/		return 0x82225B5C;
		  /* 82225B5Ch */ case    5:  		/* bc 4, CR6_EQ, -88 */
		/* 82225B5Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82225B04;  }
		/* 82225B5Ch case    5:*/		return 0x82225B60;
	}
	return 0x82225B60;
} // Block from 82225B48h-82225B60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225B60);
		  /* 82225B60h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82225B60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82225B60h case    0:*/		return 0x82225B64;
		  /* 82225B64h */ case    1:  		/* mr R4, R27 */
		/* 82225B64h case    1:*/		regs.R4 = regs.R27;
		/* 82225B64h case    1:*/		return 0x82225B68;
		  /* 82225B68h */ case    2:  		/* mr R3, R31 */
		/* 82225B68h case    2:*/		regs.R3 = regs.R31;
		/* 82225B68h case    2:*/		return 0x82225B6C;
		  /* 82225B6Ch */ case    3:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82225B6Ch case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82225B6Ch case    3:*/		return 0x82225B70;
		  /* 82225B70h */ case    4:  		/* addic R10, R10, -1 */
		/* 82225B70h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82225B70h case    4:*/		return 0x82225B74;
		  /* 82225B74h */ case    5:  		/* subfe R10, R10, R10 */
		/* 82225B74h case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82225B74h case    5:*/		return 0x82225B78;
		  /* 82225B78h */ case    6:  		/* and R11, R10, R11 */
		/* 82225B78h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82225B78h case    6:*/		return 0x82225B7C;
		  /* 82225B7Ch */ case    7:  		/* cmplw CR6, R27, R11 */
		/* 82225B7Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82225B7Ch case    7:*/		return 0x82225B80;
		  /* 82225B80h */ case    8:  		/* bc 4, CR6_EQ, 124 */
		/* 82225B80h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82225BFC;  }
		/* 82225B80h case    8:*/		return 0x82225B84;
		  /* 82225B84h */ case    9:  		/* li R8, 1 */
		/* 82225B84h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82225B84h case    9:*/		return 0x82225B88;
		  /* 82225B88h */ case   10:  		/* li R7, 0 */
		/* 82225B88h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82225B88h case   10:*/		return 0x82225B8C;
		  /* 82225B8Ch */ case   11:  		/* li R6, 116 */
		/* 82225B8Ch case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x74);
		/* 82225B8Ch case   11:*/		return 0x82225B90;
		  /* 82225B90h */ case   12:  		/* li R5, 0 */
		/* 82225B90h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82225B90h case   12:*/		return 0x82225B94;
		  /* 82225B94h */ case   13:  		/* bl -4604 */
		/* 82225B94h case   13:*/		regs.LR = 0x82225B98; return 0x82224998;
		/* 82225B94h case   13:*/		return 0x82225B98;
		  /* 82225B98h */ case   14:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 82225B98h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 82225B98h case   14:*/		return 0x82225B9C;
		  /* 82225B9Ch */ case   15:  		/* lwz R9, <#[R28]> */
		/* 82225B9Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 82225B9Ch case   15:*/		return 0x82225BA0;
		  /* 82225BA0h */ case   16:  		/* ori R8, R28, 1 */
		/* 82225BA0h case   16:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R28,0x1);
		/* 82225BA0h case   16:*/		return 0x82225BA4;
		  /* 82225BA4h */ case   17:  		/* addi R11, R11, 36 */
		/* 82225BA4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82225BA4h case   17:*/		return 0x82225BA8;
		  /* 82225BA8h */ case   18:  		/* mr R30, R3 */
		/* 82225BA8h case   18:*/		regs.R30 = regs.R3;
		/* 82225BA8h case   18:*/		return 0x82225BAC;
		  /* 82225BACh */ case   19:  		/* addi R10, R11, 4 */
		/* 82225BACh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82225BACh case   19:*/		return 0x82225BB0;
		  /* 82225BB0h */ case   20:  		/* addi R7, R11, -36 */
		/* 82225BB0h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82225BB0h case   20:*/		return 0x82225BB4;
		  /* 82225BB4h */ case   21:  		/* li R6, 1 */
		/* 82225BB4h case   21:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82225BB4h case   21:*/		return 0x82225BB8;
		  /* 82225BB8h */ case   22:  		/* stw R9, <#[R11 + 4]> */
		/* 82225BB8h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82225BB8h case   22:*/		return 0x82225BBC;
		  /* 82225BBCh */ case   23:  		/* li R5, 0 */
		/* 82225BBCh case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82225BBCh case   23:*/		return 0x82225BC0;
		  /* 82225BC0h */ case   24:  		/* lwz R9, <#[R28]> */
		/* 82225BC0h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 82225BC0h case   24:*/		return 0x82225BC4;
		  /* 82225BC4h */ case   25:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82225BC4h case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82225BC4h case   25:*/		return 0x82225BC8;
		  /* 82225BC8h */ case   26:  		/* stw R10, <#[R9 + 36]> */
		/* 82225BC8h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000024) );
		/* 82225BC8h case   26:*/		return 0x82225BCC;
		  /* 82225BCCh */ case   27:  		/* li R4, 116 */
		/* 82225BCCh case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x74);
		/* 82225BCCh case   27:*/		return 0x82225BD0;
		  /* 82225BD0h */ case   28:  		/* mr R3, R31 */
		/* 82225BD0h case   28:*/		regs.R3 = regs.R31;
		/* 82225BD0h case   28:*/		return 0x82225BD4;
		  /* 82225BD4h */ case   29:  		/* stw R8, <#[R11]> */
		/* 82225BD4h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82225BD4h case   29:*/		return 0x82225BD8;
		  /* 82225BD8h */ case   30:  		/* stw R7, <#[R28]> */
		/* 82225BD8h case   30:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R28 + 0x00000000) );
		/* 82225BD8h case   30:*/		return 0x82225BDC;
		  /* 82225BDCh */ case   31:  		/* bl -792492 */
		/* 82225BDCh case   31:*/		regs.LR = 0x82225BE0; return 0x82164430;
		/* 82225BDCh case   31:*/		return 0x82225BE0;
		  /* 82225BE0h */ case   32:  		/* addi R11, R30, -4 */
		/* 82225BE0h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 82225BE0h case   32:*/		return 0x82225BE4;
		  /* 82225BE4h */ case   33:  		/* add R11, R3, R11 */
		/* 82225BE4h case   33:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82225BE4h case   33:*/		return 0x82225BE8;
		  /* 82225BE8h */ case   34:  		/* lwz R10, <#[R11]> */
		/* 82225BE8h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82225BE8h case   34:*/		return 0x82225BEC;
		  /* 82225BECh */ case   35:  		/* rlwimi R10, R26, 15, 3, 16 */
		/* 82225BECh case   35:*/		cpu::op::rlwimi<0,15,3,16>(regs,&regs.R10,regs.R26);
		/* 82225BECh case   35:*/		return 0x82225BF0;
		  /* 82225BF0h */ case   36:  		/* rlwimi R10, R29, 0, 17, 31 */
		/* 82225BF0h case   36:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R10,regs.R29);
		/* 82225BF0h case   36:*/		return 0x82225BF4;
		  /* 82225BF4h */ case   37:  		/* stw R10, <#[R11]> */
		/* 82225BF4h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82225BF4h case   37:*/		return 0x82225BF8;
		  /* 82225BF8h */ case   38:  		/* b 212 */
		/* 82225BF8h case   38:*/		return 0x82225CCC;
		/* 82225BF8h case   38:*/		return 0x82225BFC;
	}
	return 0x82225BFC;
} // Block from 82225B60h-82225BFCh (39 instructions)

//////////////////////////////////////////////////////
// Block at 82225BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225BFC);
		  /* 82225BFCh */ case    0:  		/* bl -4540 */
		/* 82225BFCh case    0:*/		regs.LR = 0x82225C00; return 0x82224A40;
		/* 82225BFCh case    0:*/		return 0x82225C00;
		  /* 82225C00h */ case    1:  		/* mr R30, R3 */
		/* 82225C00h case    1:*/		regs.R30 = regs.R3;
		/* 82225C00h case    1:*/		return 0x82225C04;
		  /* 82225C04h */ case    2:  		/* li R6, 1 */
		/* 82225C04h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82225C04h case    2:*/		return 0x82225C08;
		  /* 82225C08h */ case    3:  		/* li R5, 0 */
		/* 82225C08h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82225C08h case    3:*/		return 0x82225C0C;
		  /* 82225C0Ch */ case    4:  		/* li R4, 112 */
		/* 82225C0Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 82225C0Ch case    4:*/		return 0x82225C10;
		  /* 82225C10h */ case    5:  		/* mr R3, R31 */
		/* 82225C10h case    5:*/		regs.R3 = regs.R31;
		/* 82225C10h case    5:*/		return 0x82225C14;
		  /* 82225C14h */ case    6:  		/* bl -792548 */
		/* 82225C14h case    6:*/		regs.LR = 0x82225C18; return 0x82164430;
		/* 82225C14h case    6:*/		return 0x82225C18;
		  /* 82225C18h */ case    7:  		/* addi R11, R30, -8 */
		/* 82225C18h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 82225C18h case    7:*/		return 0x82225C1C;
		  /* 82225C1Ch */ case    8:  		/* lis R10, 8192 */
		/* 82225C1Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x2000);
		/* 82225C1Ch case    8:*/		return 0x82225C20;
		  /* 82225C20h */ case    9:  		/* add R11, R3, R11 */
		/* 82225C20h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82225C20h case    9:*/		return 0x82225C24;
		  /* 82225C24h */ case   10:  		/* rlwimi R10, R26, 15, 3, 16 */
		/* 82225C24h case   10:*/		cpu::op::rlwimi<0,15,3,16>(regs,&regs.R10,regs.R26);
		/* 82225C24h case   10:*/		return 0x82225C28;
		  /* 82225C28h */ case   11:  		/* rlwinm R9, R29, 0, 17, 31 */
		/* 82225C28h case   11:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R9,regs.R29);
		/* 82225C28h case   11:*/		return 0x82225C2C;
		  /* 82225C2Ch */ case   12:  		/* mulli R28, R29, 40 */
		/* 82225C2Ch case   12:*/		cpu::op::mulli<0>(regs,&regs.R28,regs.R29,0x28);
		/* 82225C2Ch case   12:*/		return 0x82225C30;
		  /* 82225C30h */ case   13:  		/* lwz R8, <#[R11]> */
		/* 82225C30h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82225C30h case   13:*/		return 0x82225C34;
		  /* 82225C34h */ case   14:  		/* rlwinm R8, R8, 0, 0, 2 */
		/* 82225C34h case   14:*/		cpu::op::rlwinm<0,0,0,2>(regs,&regs.R8,regs.R8);
		/* 82225C34h case   14:*/		return 0x82225C38;
		  /* 82225C38h */ case   15:  		/* or R10, R10, R8 */
		/* 82225C38h case   15:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82225C38h case   15:*/		return 0x82225C3C;
		  /* 82225C3Ch */ case   16:  		/* or R10, R10, R9 */
		/* 82225C3Ch case   16:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82225C3Ch case   16:*/		return 0x82225C40;
		  /* 82225C40h */ case   17:  		/* stw R10, <#[R11]> */
		/* 82225C40h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82225C40h case   17:*/		return 0x82225C44;
		  /* 82225C44h */ case   18:  		/* lwz R11, <#[R31 + 12]> */
		/* 82225C44h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82225C44h case   18:*/		return 0x82225C48;
		  /* 82225C48h */ case   19:  		/* add R11, R28, R11 */
		/* 82225C48h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 82225C48h case   19:*/		return 0x82225C4C;
		  /* 82225C4Ch */ case   20:  		/* lwz R10, <#[R11 + 28]> */
		/* 82225C4Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82225C4Ch case   20:*/		return 0x82225C50;
		  /* 82225C50h */ case   21:  		/* cmplwi CR6, R10, 0 */
		/* 82225C50h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82225C50h case   21:*/		return 0x82225C54;
		  /* 82225C54h */ case   22:  		/* bc 4, CR6_EQ, 28 */
		/* 82225C54h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82225C70;  }
		/* 82225C54h case   22:*/		return 0x82225C58;
		  /* 82225C58h */ case   23:  		/* lwz R11, <#[R11 + 4]> */
		/* 82225C58h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82225C58h case   23:*/		return 0x82225C5C;
		  /* 82225C5Ch */ case   24:  		/* rlwinm. R11, R11, 0, 5, 5 */
		/* 82225C5Ch case   24:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R11);
		/* 82225C5Ch case   24:*/		return 0x82225C60;
		  /* 82225C60h */ case   25:  		/* bc 12, CR0_EQ, 16 */
		/* 82225C60h case   25:*/		if ( regs.CR[0].eq ) { return 0x82225C70;  }
		/* 82225C60h case   25:*/		return 0x82225C64;
		  /* 82225C64h */ case   26:  		/* mr R4, R29 */
		/* 82225C64h case   26:*/		regs.R4 = regs.R29;
		/* 82225C64h case   26:*/		return 0x82225C68;
		  /* 82225C68h */ case   27:  		/* mr R3, R31 */
		/* 82225C68h case   27:*/		regs.R3 = regs.R31;
		/* 82225C68h case   27:*/		return 0x82225C6C;
		  /* 82225C6Ch */ case   28:  		/* bl -623356 */
		/* 82225C6Ch case   28:*/		regs.LR = 0x82225C70; return 0x8218D970;
		/* 82225C6Ch case   28:*/		return 0x82225C70;
	}
	return 0x82225C70;
} // Block from 82225BFCh-82225C70h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82225C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225C70);
		  /* 82225C70h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82225C70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82225C70h case    0:*/		return 0x82225C74;
		  /* 82225C74h */ case    1:  		/* add R11, R28, R11 */
		/* 82225C74h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 82225C74h case    1:*/		return 0x82225C78;
		  /* 82225C78h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 82225C78h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82225C78h case    2:*/		return 0x82225C7C;
		  /* 82225C7Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82225C7Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82225C7Ch case    3:*/		return 0x82225C80;
		  /* 82225C80h */ case    4:  		/* bc 12, CR6_EQ, 76 */
		/* 82225C80h case    4:*/		if ( regs.CR[6].eq ) { return 0x82225CCC;  }
		/* 82225C80h case    4:*/		return 0x82225C84;
		  /* 82225C84h */ case    5:  		/* lwzx R11, <#[R11 + R24]> */
		/* 82225C84h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82225C84h case    5:*/		return 0x82225C88;
		  /* 82225C88h */ case    6:  		/* rlwinm R11, R11, 14, 30, 31 */
		/* 82225C88h case    6:*/		cpu::op::rlwinm<0,14,30,31>(regs,&regs.R11,regs.R11);
		/* 82225C88h case    6:*/		return 0x82225C8C;
		  /* 82225C8Ch */ case    7:  		/* cmplwi CR6, R11, 2 */
		/* 82225C8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82225C8Ch case    7:*/		return 0x82225C90;
		  /* 82225C90h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 82225C90h case    8:*/		if ( regs.CR[6].eq ) { return 0x82225CB4;  }
		/* 82225C90h case    8:*/		return 0x82225C94;
		  /* 82225C94h */ case    9:  		/* cmplwi CR6, R11, 3 */
		/* 82225C94h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82225C94h case    9:*/		return 0x82225C98;
		  /* 82225C98h */ case   10:  		/* bc 4, CR6_EQ, 52 */
		/* 82225C98h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82225CCC;  }
		/* 82225C98h case   10:*/		return 0x82225C9C;
		  /* 82225C9Ch */ case   11:  		/* lwz R11, <#[R30 + 12]> */
		/* 82225C9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82225C9Ch case   11:*/		return 0x82225CA0;
		  /* 82225CA0h */ case   12:  		/* rlwinm R10, R11, 0, 29, 30 */
		/* 82225CA0h case   12:*/		cpu::op::rlwinm<0,0,29,30>(regs,&regs.R10,regs.R11);
		/* 82225CA0h case   12:*/		return 0x82225CA4;
		  /* 82225CA4h */ case   13:  		/* cmplwi CR6, R10, 6 */
		/* 82225CA4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000006);
		/* 82225CA4h case   13:*/		return 0x82225CA8;
		  /* 82225CA8h */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 82225CA8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82225CCC;  }
		/* 82225CA8h case   14:*/		return 0x82225CAC;
		  /* 82225CACh */ case   15:  		/* ori R11, R11, 6 */
		/* 82225CACh case   15:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x6);
		/* 82225CACh case   15:*/		return 0x82225CB0;
		  /* 82225CB0h */ case   16:  		/* b 24 */
		/* 82225CB0h case   16:*/		return 0x82225CC8;
		/* 82225CB0h case   16:*/		return 0x82225CB4;
	}
	return 0x82225CB4;
} // Block from 82225C70h-82225CB4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82225CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225CB4);
		  /* 82225CB4h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82225CB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82225CB4h case    0:*/		return 0x82225CB8;
		  /* 82225CB8h */ case    1:  		/* rlwinm R10, R11, 0, 29, 29 */
		/* 82225CB8h case    1:*/		cpu::op::rlwinm<0,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82225CB8h case    1:*/		return 0x82225CBC;
		  /* 82225CBCh */ case    2:  		/* cmplwi CR6, R10, 4 */
		/* 82225CBCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 82225CBCh case    2:*/		return 0x82225CC0;
		  /* 82225CC0h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82225CC0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82225CCC;  }
		/* 82225CC0h case    3:*/		return 0x82225CC4;
		  /* 82225CC4h */ case    4:  		/* ori R11, R11, 4 */
		/* 82225CC4h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82225CC4h case    4:*/		return 0x82225CC8;
	}
	return 0x82225CC8;
} // Block from 82225CB4h-82225CC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82225CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225CC8);
		  /* 82225CC8h */ case    0:  		/* sth R11, <#[R30 + 14]> */
		/* 82225CC8h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x0000000E) );
		/* 82225CC8h case    0:*/		return 0x82225CCC;
	}
	return 0x82225CCC;
} // Block from 82225CC8h-82225CCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225CCC);
		  /* 82225CCCh */ case    0:  		/* lwz R10, <#[R25]> */
		/* 82225CCCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 82225CCCh case    0:*/		return 0x82225CD0;
		  /* 82225CD0h */ case    1:  		/* li R11, 1 */
		/* 82225CD0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82225CD0h case    1:*/		return 0x82225CD4;
		  /* 82225CD4h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82225CD4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82225CD4h case    2:*/		return 0x82225CD8;
		  /* 82225CD8h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82225CD8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82225CE8;  }
		/* 82225CD8h case    3:*/		return 0x82225CDC;
		  /* 82225CDCh */ case    4:  		/* lwz R10, <#[R25 + 4]> */
		/* 82225CDCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 82225CDCh case    4:*/		return 0x82225CE0;
		  /* 82225CE0h */ case    5:  		/* rlwinm. R10, R10, 0, 30, 31 */
		/* 82225CE0h case    5:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82225CE0h case    5:*/		return 0x82225CE4;
		  /* 82225CE4h */ case    6:  		/* bc 4, CR0_EQ, 20 */
		/* 82225CE4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82225CF8;  }
		/* 82225CE4h case    6:*/		return 0x82225CE8;
	}
	return 0x82225CE8;
} // Block from 82225CCCh-82225CE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82225CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225CE8);
		  /* 82225CE8h */ case    0:  		/* lwz R10, <#[R23 + 4]> */
		/* 82225CE8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82225CE8h case    0:*/		return 0x82225CEC;
		  /* 82225CECh */ case    1:  		/* stw R30, <#[R23]> */
		/* 82225CECh case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000000) );
		/* 82225CECh case    1:*/		return 0x82225CF0;
		  /* 82225CF0h */ case    2:  		/* rlwimi R10, R11, 0, 16, 14 */
		/* 82225CF0h case    2:*/		cpu::op::rlwimi<0,0,16,14>(regs,&regs.R10,regs.R11);
		/* 82225CF0h case    2:*/		return 0x82225CF4;
		  /* 82225CF4h */ case    3:  		/* stw R10, <#[R23 + 4]> */
		/* 82225CF4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 82225CF4h case    3:*/		return 0x82225CF8;
	}
	return 0x82225CF8;
} // Block from 82225CE8h-82225CF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225CF8);
		  /* 82225CF8h */ case    0:  		/* lwz R10, <#[R25 + 4]> */
		/* 82225CF8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 82225CF8h case    0:*/		return 0x82225CFC;
		  /* 82225CFCh */ case    1:  		/* stw R30, <#[R25]> */
		/* 82225CFCh case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R25 + 0x00000000) );
		/* 82225CFCh case    1:*/		return 0x82225D00;
		  /* 82225D00h */ case    2:  		/* rlwimi R10, R11, 0, 16, 14 */
		/* 82225D00h case    2:*/		cpu::op::rlwimi<0,0,16,14>(regs,&regs.R10,regs.R11);
		/* 82225D00h case    2:*/		return 0x82225D04;
		  /* 82225D04h */ case    3:  		/* stw R10, <#[R25 + 4]> */
		/* 82225D04h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 82225D04h case    3:*/		return 0x82225D08;
	}
	return 0x82225D08;
} // Block from 82225CF8h-82225D08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225D08);
		  /* 82225D08h */ case    0:  		/* mr R3, R25 */
		/* 82225D08h case    0:*/		regs.R3 = regs.R25;
		/* 82225D08h case    0:*/		return 0x82225D0C;
		  /* 82225D0Ch */ case    1:  		/* addi R1, R1, 160 */
		/* 82225D0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82225D0Ch case    1:*/		return 0x82225D10;
		  /* 82225D10h */ case    2:  		/* b -1657468 */
		/* 82225D10h case    2:*/		return 0x82091294;
		/* 82225D10h case    2:*/		return 0x82225D14;
		  /* 82225D14h */ case    3:  		/* nop */
		/* 82225D14h case    3:*/		cpu::op::nop();
		/* 82225D14h case    3:*/		return 0x82225D18;
	}
	return 0x82225D18;
} // Block from 82225D08h-82225D18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225D18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225D18);
		  /* 82225D18h */ case    0:  		/* mfspr R12, LR */
		/* 82225D18h case    0:*/		regs.R12 = regs.LR;
		/* 82225D18h case    0:*/		return 0x82225D1C;
		  /* 82225D1Ch */ case    1:  		/* bl -1657564 */
		/* 82225D1Ch case    1:*/		regs.LR = 0x82225D20; return 0x82091240;
		/* 82225D1Ch case    1:*/		return 0x82225D20;
		  /* 82225D20h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82225D20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82225D20h case    2:*/		return 0x82225D24;
		  /* 82225D24h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 82225D24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82225D24h case    3:*/		return 0x82225D28;
		  /* 82225D28h */ case    4:  		/* mr R24, R3 */
		/* 82225D28h case    4:*/		regs.R24 = regs.R3;
		/* 82225D28h case    4:*/		return 0x82225D2C;
		  /* 82225D2Ch */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 82225D2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82225D2Ch case    5:*/		return 0x82225D30;
		  /* 82225D30h */ case    6:  		/* mr R22, R4 */
		/* 82225D30h case    6:*/		regs.R22 = regs.R4;
		/* 82225D30h case    6:*/		return 0x82225D34;
		  /* 82225D34h */ case    7:  		/* mr R6, R5 */
		/* 82225D34h case    7:*/		regs.R6 = regs.R5;
		/* 82225D34h case    7:*/		return 0x82225D38;
		  /* 82225D38h */ case    8:  		/* xor R11, R11, R10 */
		/* 82225D38h case    8:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82225D38h case    8:*/		return 0x82225D3C;
		  /* 82225D3Ch */ case    9:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82225D3Ch case    9:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82225D3Ch case    9:*/		return 0x82225D40;
		  /* 82225D40h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 82225D40h case   10:*/		if ( regs.CR[0].eq ) { return 0x82225D4C;  }
		/* 82225D40h case   10:*/		return 0x82225D44;
		  /* 82225D44h */ case   11:  		/* li R3, 0 */
		/* 82225D44h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82225D44h case   11:*/		return 0x82225D48;
		  /* 82225D48h */ case   12:  		/* b 568 */
		/* 82225D48h case   12:*/		return 0x82225F80;
		/* 82225D48h case   12:*/		return 0x82225D4C;
	}
	return 0x82225D4C;
} // Block from 82225D18h-82225D4Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82225D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225D4C);
		  /* 82225D4Ch */ case    0:  		/* lwz R11, <#[R24]> */
		/* 82225D4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82225D4Ch case    0:*/		return 0x82225D50;
		  /* 82225D50h */ case    1:  		/* li R23, 0 */
		/* 82225D50h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82225D50h case    1:*/		return 0x82225D54;
		  /* 82225D54h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82225D54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82225D54h case    2:*/		return 0x82225D58;
		  /* 82225D58h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82225D58h case    3:*/		if ( regs.CR[6].eq ) { return 0x82225D68;  }
		/* 82225D58h case    3:*/		return 0x82225D5C;
		  /* 82225D5Ch */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82225D5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82225D5Ch case    4:*/		return 0x82225D60;
		  /* 82225D60h */ case    5:  		/* addi R23, R23, 1 */
		/* 82225D60h case    5:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82225D60h case    5:*/		return 0x82225D64;
		  /* 82225D64h */ case    6:  		/* b -16 */
		/* 82225D64h case    6:*/		return 0x82225D54;
		/* 82225D64h case    6:*/		return 0x82225D68;
	}
	return 0x82225D68;
} // Block from 82225D4Ch-82225D68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82225D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225D68);
		  /* 82225D68h */ case    0:  		/* lis R11, -32231 */
		/* 82225D68h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8219);
		/* 82225D68h case    0:*/		return 0x82225D6C;
		  /* 82225D6Ch */ case    1:  		/* mr R4, R23 */
		/* 82225D6Ch case    1:*/		regs.R4 = regs.R23;
		/* 82225D6Ch case    1:*/		return 0x82225D70;
		  /* 82225D70h */ case    2:  		/* addi R5, R11, 28352 */
		/* 82225D70h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6EC0);
		/* 82225D70h case    2:*/		return 0x82225D74;
		  /* 82225D74h */ case    3:  		/* addi R3, R1, 80 */
		/* 82225D74h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82225D74h case    3:*/		return 0x82225D78;
		  /* 82225D78h */ case    4:  		/* bl -588408 */
		/* 82225D78h case    4:*/		regs.LR = 0x82225D7C; return 0x82196300;
		/* 82225D78h case    4:*/		return 0x82225D7C;
		  /* 82225D7Ch */ case    5:  		/* lwz R29, <#[R22]> */
		/* 82225D7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R22 + 0x00000000) );
		/* 82225D7Ch case    5:*/		return 0x82225D80;
		  /* 82225D80h */ case    6:  		/* cmplwi CR6, R29, 0 */
		/* 82225D80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82225D80h case    6:*/		return 0x82225D84;
		  /* 82225D84h */ case    7:  		/* bc 12, CR6_EQ, 200 */
		/* 82225D84h case    7:*/		if ( regs.CR[6].eq ) { return 0x82225E4C;  }
		/* 82225D84h case    7:*/		return 0x82225D88;
		  /* 82225D88h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 82225D88h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82225D88h case    8:*/		return 0x82225D8C;
		  /* 82225D8Ch */ case    9:  		/* li R28, 0 */
		/* 82225D8Ch case    9:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82225D8Ch case    9:*/		return 0x82225D90;
		  /* 82225D90h */ case   10:  		/* lwz R25, <#[R29 + 12]> */
		/* 82225D90h case   10:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R29 + 0x0000000C) );
		/* 82225D90h case   10:*/		return 0x82225D94;
		  /* 82225D94h */ case   11:  		/* li R30, 1 */
		/* 82225D94h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82225D94h case   11:*/		return 0x82225D98;
		  /* 82225D98h */ case   12:  		/* lwz R31, <#[R24]> */
		/* 82225D98h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000000) );
		/* 82225D98h case   12:*/		return 0x82225D9C;
		  /* 82225D9Ch */ case   13:  		/* rlwinm R27, R11, 2, 31, 31 */
		/* 82225D9Ch case   13:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R27,regs.R11);
		/* 82225D9Ch case   13:*/		return 0x82225DA0;
		  /* 82225DA0h */ case   14:  		/* rlwinm R26, R11, 7, 29, 31 */
		/* 82225DA0h case   14:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R26,regs.R11);
		/* 82225DA0h case   14:*/		return 0x82225DA4;
		  /* 82225DA4h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 82225DA4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82225DA4h case   15:*/		return 0x82225DA8;
		  /* 82225DA8h */ case   16:  		/* bc 12, CR6_EQ, 148 */
		/* 82225DA8h case   16:*/		if ( regs.CR[6].eq ) { return 0x82225E3C;  }
		/* 82225DA8h case   16:*/		return 0x82225DAC;
		  /* 82225DACh */ case   17:  		/* lwz R11, <#[R31]> */
		/* 82225DACh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82225DACh case   17:*/		return 0x82225DB0;
		  /* 82225DB0h */ case   18:  		/* rlwinm R10, R27, 0, 24, 31 */
		/* 82225DB0h case   18:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R27);
		/* 82225DB0h case   18:*/		return 0x82225DB4;
		  /* 82225DB4h */ case   19:  		/* rlwinm R9, R11, 2, 31, 31 */
		/* 82225DB4h case   19:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R9,regs.R11);
		/* 82225DB4h case   19:*/		return 0x82225DB8;
		  /* 82225DB8h */ case   20:  		/* cmplw CR6, R9, R10 */
		/* 82225DB8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82225DB8h case   20:*/		return 0x82225DBC;
		  /* 82225DBCh */ case   21:  		/* bc 4, CR6_EQ, 116 */
		/* 82225DBCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x82225E30;  }
		/* 82225DBCh case   21:*/		return 0x82225DC0;
		  /* 82225DC0h */ case   22:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82225DC0h case   22:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82225DC0h case   22:*/		return 0x82225DC4;
		  /* 82225DC4h */ case   23:  		/* cmplw CR6, R11, R26 */
		/* 82225DC4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82225DC4h case   23:*/		return 0x82225DC8;
		  /* 82225DC8h */ case   24:  		/* bc 4, CR6_EQ, 104 */
		/* 82225DC8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82225E30;  }
		/* 82225DC8h case   24:*/		return 0x82225DCC;
		  /* 82225DCCh */ case   25:  		/* cmplwi CR6, R26, 0 */
		/* 82225DCCh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82225DCCh case   25:*/		return 0x82225DD0;
		  /* 82225DD0h */ case   26:  		/* bc 12, CR6_EQ, 28 */
		/* 82225DD0h case   26:*/		if ( regs.CR[6].eq ) { return 0x82225DEC;  }
		/* 82225DD0h case   26:*/		return 0x82225DD4;
		  /* 82225DD4h */ case   27:  		/* mr R4, R29 */
		/* 82225DD4h case   27:*/		regs.R4 = regs.R29;
		/* 82225DD4h case   27:*/		return 0x82225DD8;
		  /* 82225DD8h */ case   28:  		/* mr R3, R31 */
		/* 82225DD8h case   28:*/		regs.R3 = regs.R31;
		/* 82225DD8h case   28:*/		return 0x82225DDC;
		  /* 82225DDCh */ case   29:  		/* bl -15612 */
		/* 82225DDCh case   29:*/		regs.LR = 0x82225DE0; return 0x822220E0;
		/* 82225DDCh case   29:*/		return 0x82225DE0;
		  /* 82225DE0h */ case   30:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225DE0h case   30:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225DE0h case   30:*/		return 0x82225DE4;
		  /* 82225DE4h */ case   31:  		/* bc 4, CR0_EQ, 20 */
		/* 82225DE4h case   31:*/		if ( !regs.CR[0].eq ) { return 0x82225DF8;  }
		/* 82225DE4h case   31:*/		return 0x82225DE8;
		  /* 82225DE8h */ case   32:  		/* b 72 */
		/* 82225DE8h case   32:*/		return 0x82225E30;
		/* 82225DE8h case   32:*/		return 0x82225DEC;
	}
	return 0x82225DEC;
} // Block from 82225D68h-82225DECh (33 instructions)

//////////////////////////////////////////////////////
// Block at 82225DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225DEC);
		  /* 82225DECh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82225DECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82225DECh case    0:*/		return 0x82225DF0;
		  /* 82225DF0h */ case    1:  		/* cmplw CR6, R11, R25 */
		/* 82225DF0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 82225DF0h case    1:*/		return 0x82225DF4;
		  /* 82225DF4h */ case    2:  		/* bc 4, CR6_EQ, 60 */
		/* 82225DF4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82225E30;  }
		/* 82225DF4h case    2:*/		return 0x82225DF8;
	}
	return 0x82225DF8;
} // Block from 82225DECh-82225DF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82225DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225DF8);
		  /* 82225DF8h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82225DF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82225DF8h case    0:*/		return 0x82225DFC;
		  /* 82225DFCh */ case    1:  		/* nor R10, R11, R11 */
		/* 82225DFCh case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82225DFCh case    1:*/		return 0x82225E00;
		  /* 82225E00h */ case    2:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82225E00h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82225E00h case    2:*/		return 0x82225E04;
		  /* 82225E04h */ case    3:  		/* addi R10, R11, 4 */
		/* 82225E04h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82225E04h case    3:*/		return 0x82225E08;
		  /* 82225E08h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82225E08h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82225E10;  }
		/* 82225E08h case    4:*/		return 0x82225E0C;
		  /* 82225E0Ch */ case    5:  		/* addi R10, R1, 80 */
		/* 82225E0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82225E0Ch case    5:*/		return 0x82225E10;
	}
	return 0x82225E10;
} // Block from 82225DF8h-82225E10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225E10);
		  /* 82225E10h */ case    0:  		/* rlwinm R11, R30, 29, 3, 29 */
		/* 82225E10h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R30);
		/* 82225E10h case    0:*/		return 0x82225E14;
		  /* 82225E14h */ case    1:  		/* li R8, 1 */
		/* 82225E14h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82225E14h case    1:*/		return 0x82225E18;
		  /* 82225E18h */ case    2:  		/* rlwinm R9, R30, 0, 27, 31 */
		/* 82225E18h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R30);
		/* 82225E18h case    2:*/		return 0x82225E1C;
		  /* 82225E1Ch */ case    3:  		/* li R28, 1 */
		/* 82225E1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82225E1Ch case    3:*/		return 0x82225E20;
		  /* 82225E20h */ case    4:  		/* slw R9, R8, R9 */
		/* 82225E20h case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82225E20h case    4:*/		return 0x82225E24;
		  /* 82225E24h */ case    5:  		/* lwzx R8, <#[R11 + R10]> */
		/* 82225E24h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82225E24h case    5:*/		return 0x82225E28;
		  /* 82225E28h */ case    6:  		/* or R9, R9, R8 */
		/* 82225E28h case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82225E28h case    6:*/		return 0x82225E2C;
		  /* 82225E2Ch */ case    7:  		/* stwx R9, <#[R11 + R10]> */
		/* 82225E2Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82225E2Ch case    7:*/		return 0x82225E30;
	}
	return 0x82225E30;
} // Block from 82225E10h-82225E30h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82225E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225E30);
		  /* 82225E30h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 82225E30h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 82225E30h case    0:*/		return 0x82225E34;
		  /* 82225E34h */ case    1:  		/* addi R30, R30, 1 */
		/* 82225E34h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82225E34h case    1:*/		return 0x82225E38;
		  /* 82225E38h */ case    2:  		/* b -148 */
		/* 82225E38h case    2:*/		return 0x82225DA4;
		/* 82225E38h case    2:*/		return 0x82225E3C;
	}
	return 0x82225E3C;
} // Block from 82225E30h-82225E3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82225E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225E3C);
		  /* 82225E3Ch */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82225E3Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82225E3Ch case    0:*/		return 0x82225E40;
		  /* 82225E40h */ case    1:  		/* bc 12, CR0_EQ, -252 */
		/* 82225E40h case    1:*/		if ( regs.CR[0].eq ) { return 0x82225D44;  }
		/* 82225E40h case    1:*/		return 0x82225E44;
		  /* 82225E44h */ case    2:  		/* lwz R29, <#[R29 + 4]> */
		/* 82225E44h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 82225E44h case    2:*/		return 0x82225E48;
		  /* 82225E48h */ case    3:  		/* b -200 */
		/* 82225E48h case    3:*/		return 0x82225D80;
		/* 82225E48h case    3:*/		return 0x82225E4C;
	}
	return 0x82225E4C;
} // Block from 82225E3Ch-82225E4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225E4C);
		  /* 82225E4Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 82225E4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82225E4Ch case    0:*/		return 0x82225E50;
		  /* 82225E50h */ case    1:  		/* bc 12, CR6_EQ, 300 */
		/* 82225E50h case    1:*/		if ( regs.CR[6].eq ) { return 0x82225F7C;  }
		/* 82225E50h case    1:*/		return 0x82225E54;
		  /* 82225E54h */ case    2:  		/* addi R5, R23, -1 */
		/* 82225E54h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R23,0xFFFFFFFF);
		/* 82225E54h case    2:*/		return 0x82225E58;
	}
	return 0x82225E58;
} // Block from 82225E4Ch-82225E58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82225E58h
// Function '?CreateVariableInstrWorker@Compiler@D3DXShader@@QAAPAVInstruction@2@II_NW4Opcode@2@PAVBlock@2@UInstructionPlacementPoint@12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225E58);
		  /* 82225E58h */ case    0:  		/* li R4, 0 */
		/* 82225E58h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82225E58h case    0:*/		return 0x82225E5C;
		  /* 82225E5Ch */ case    1:  		/* addi R3, R1, 80 */
		/* 82225E5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82225E5Ch case    1:*/		return 0x82225E60;
		  /* 82225E60h */ case    2:  		/* bl -9520 */
		/* 82225E60h case    2:*/		regs.LR = 0x82225E64; return 0x82223930;
		/* 82225E60h case    2:*/		return 0x82225E64;
		  /* 82225E64h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225E64h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225E64h case    3:*/		return 0x82225E68;
		  /* 82225E68h */ case    4:  		/* bc 4, CR0_EQ, -292 */
		/* 82225E68h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82225D44;  }
		/* 82225E68h case    4:*/		return 0x82225E6C;
		  /* 82225E6Ch */ case    5:  		/* lwz R11, <#[R24 + 8]> */
		/* 82225E6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82225E6Ch case    5:*/		return 0x82225E70;
		  /* 82225E70h */ case    6:  		/* li R31, 0 */
		/* 82225E70h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82225E70h case    6:*/		return 0x82225E74;
		  /* 82225E74h */ case    7:  		/* rlwinm. R11, R11, 25, 25, 31 */
		/* 82225E74h case    7:*/		cpu::op::rlwinm<1,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82225E74h case    7:*/		return 0x82225E78;
		  /* 82225E78h */ case    8:  		/* bc 12, CR0_EQ, 52 */
		/* 82225E78h case    8:*/		if ( regs.CR[0].eq ) { return 0x82225EAC;  }
		/* 82225E78h case    8:*/		return 0x82225E7C;
		  /* 82225E7Ch */ case    9:  		/* cmplwi CR6, R11, 5 */
		/* 82225E7Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82225E7Ch case    9:*/		return 0x82225E80;
		  /* 82225E80h */ case   10:  		/* bc 4, CR6_GT, 36 */
		/* 82225E80h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82225EA4;  }
		/* 82225E80h case   10:*/		return 0x82225E84;
		  /* 82225E84h */ case   11:  		/* cmplwi CR6, R11, 8 */
		/* 82225E84h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 82225E84h case   11:*/		return 0x82225E88;
		  /* 82225E88h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 82225E88h case   12:*/		if ( regs.CR[6].eq ) { return 0x82225EA4;  }
		/* 82225E88h case   12:*/		return 0x82225E8C;
		  /* 82225E8Ch */ case   13:  		/* cmplwi CR6, R11, 12 */
		/* 82225E8Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 82225E8Ch case   13:*/		return 0x82225E90;
		  /* 82225E90h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82225E90h case   14:*/		if ( regs.CR[6].eq ) { return 0x82225EA4;  }
		/* 82225E90h case   14:*/		return 0x82225E94;
		  /* 82225E94h */ case   15:  		/* cmplwi CR6, R11, 15 */
		/* 82225E94h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82225E94h case   15:*/		return 0x82225E98;
		  /* 82225E98h */ case   16:  		/* bc 4, CR6_GT, 20 */
		/* 82225E98h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82225EAC;  }
		/* 82225E98h case   16:*/		return 0x82225E9C;
		  /* 82225E9Ch */ case   17:  		/* cmplwi CR6, R11, 18 */
		/* 82225E9Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 82225E9Ch case   17:*/		return 0x82225EA0;
		  /* 82225EA0h */ case   18:  		/* bc 12, CR6_GT, 12 */
		/* 82225EA0h case   18:*/		if ( regs.CR[6].gt ) { return 0x82225EAC;  }
		/* 82225EA0h case   18:*/		return 0x82225EA4;
	}
	return 0x82225EA4;
} // Block from 82225E58h-82225EA4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82225EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225EA4);
		  /* 82225EA4h */ case    0:  		/* li R11, 1 */
		/* 82225EA4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82225EA4h case    0:*/		return 0x82225EA8;
		  /* 82225EA8h */ case    1:  		/* b 8 */
		/* 82225EA8h case    1:*/		return 0x82225EB0;
		/* 82225EA8h case    1:*/		return 0x82225EAC;
	}
	return 0x82225EAC;
} // Block from 82225EA4h-82225EACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82225EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225EAC);
		  /* 82225EACh */ case    0:  		/* li R11, 0 */
		/* 82225EACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82225EACh case    0:*/		return 0x82225EB0;
	}
	return 0x82225EB0;
} // Block from 82225EACh-82225EB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225EB0);
		  /* 82225EB0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82225EB0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82225EB0h case    0:*/		return 0x82225EB4;
		  /* 82225EB4h */ case    1:  		/* bc 12, CR0_EQ, 88 */
		/* 82225EB4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82225F0C;  }
		/* 82225EB4h case    1:*/		return 0x82225EB8;
		  /* 82225EB8h */ case    2:  		/* lwz R4, <#[R22 + 44]> */
		/* 82225EB8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x0000002C) );
		/* 82225EB8h case    2:*/		return 0x82225EBC;
		  /* 82225EBCh */ case    3:  		/* li R31, 2 */
		/* 82225EBCh case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 82225EBCh case    3:*/		return 0x82225EC0;
		  /* 82225EC0h */ case    4:  		/* lwz R3, <#[R24 + 44]> */
		/* 82225EC0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000002C) );
		/* 82225EC0h case    4:*/		return 0x82225EC4;
		  /* 82225EC4h */ case    5:  		/* bl -15844 */
		/* 82225EC4h case    5:*/		regs.LR = 0x82225EC8; return 0x822220E0;
		/* 82225EC4h case    5:*/		return 0x82225EC8;
		  /* 82225EC8h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225EC8h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225EC8h case    6:*/		return 0x82225ECC;
		  /* 82225ECCh */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82225ECCh case    7:*/		if ( regs.CR[0].eq ) { return 0x82225EE4;  }
		/* 82225ECCh case    7:*/		return 0x82225ED0;
		  /* 82225ED0h */ case    8:  		/* lwz R4, <#[R22 + 48]> */
		/* 82225ED0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000030) );
		/* 82225ED0h case    8:*/		return 0x82225ED4;
		  /* 82225ED4h */ case    9:  		/* lwz R3, <#[R24 + 48]> */
		/* 82225ED4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000030) );
		/* 82225ED4h case    9:*/		return 0x82225ED8;
		  /* 82225ED8h */ case   10:  		/* bl -15864 */
		/* 82225ED8h case   10:*/		regs.LR = 0x82225EDC; return 0x822220E0;
		/* 82225ED8h case   10:*/		return 0x82225EDC;
		  /* 82225EDCh */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225EDCh case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225EDCh case   11:*/		return 0x82225EE0;
		  /* 82225EE0h */ case   12:  		/* bc 4, CR0_EQ, 44 */
		/* 82225EE0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82225F0C;  }
		/* 82225EE0h case   12:*/		return 0x82225EE4;
	}
	return 0x82225EE4;
} // Block from 82225EB0h-82225EE4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82225EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225EE4);
		  /* 82225EE4h */ case    0:  		/* lwz R4, <#[R22 + 44]> */
		/* 82225EE4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x0000002C) );
		/* 82225EE4h case    0:*/		return 0x82225EE8;
		  /* 82225EE8h */ case    1:  		/* lwz R3, <#[R24 + 48]> */
		/* 82225EE8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000030) );
		/* 82225EE8h case    1:*/		return 0x82225EEC;
		  /* 82225EECh */ case    2:  		/* bl -15884 */
		/* 82225EECh case    2:*/		regs.LR = 0x82225EF0; return 0x822220E0;
		/* 82225EECh case    2:*/		return 0x82225EF0;
		  /* 82225EF0h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225EF0h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225EF0h case    3:*/		return 0x82225EF4;
		  /* 82225EF4h */ case    4:  		/* bc 12, CR0_EQ, -432 */
		/* 82225EF4h case    4:*/		if ( regs.CR[0].eq ) { return 0x82225D44;  }
		/* 82225EF4h case    4:*/		return 0x82225EF8;
		  /* 82225EF8h */ case    5:  		/* lwz R4, <#[R22 + 48]> */
		/* 82225EF8h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000030) );
		/* 82225EF8h case    5:*/		return 0x82225EFC;
		  /* 82225EFCh */ case    6:  		/* lwz R3, <#[R24 + 44]> */
		/* 82225EFCh case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000002C) );
		/* 82225EFCh case    6:*/		return 0x82225F00;
		  /* 82225F00h */ case    7:  		/* bl -15904 */
		/* 82225F00h case    7:*/		regs.LR = 0x82225F04; return 0x822220E0;
		/* 82225F00h case    7:*/		return 0x82225F04;
		  /* 82225F04h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225F04h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225F04h case    8:*/		return 0x82225F08;
		  /* 82225F08h */ case    9:  		/* bc 12, CR0_EQ, -452 */
		/* 82225F08h case    9:*/		if ( regs.CR[0].eq ) { return 0x82225D44;  }
		/* 82225F08h case    9:*/		return 0x82225F0C;
	}
	return 0x82225F0C;
} // Block from 82225EE4h-82225F0Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82225F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225F0C);
		  /* 82225F0Ch */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 82225F0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82225F0Ch case    0:*/		return 0x82225F10;
		  /* 82225F10h */ case    1:  		/* mr R29, R31 */
		/* 82225F10h case    1:*/		regs.R29 = regs.R31;
		/* 82225F10h case    1:*/		return 0x82225F14;
		  /* 82225F14h */ case    2:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82225F14h case    2:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82225F14h case    2:*/		return 0x82225F18;
		  /* 82225F18h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82225F18h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82225F18h case    3:*/		return 0x82225F1C;
		  /* 82225F1Ch */ case    4:  		/* bc 4, CR6_LT, 96 */
		/* 82225F1Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x82225F7C;  }
		/* 82225F1Ch case    4:*/		return 0x82225F20;
		  /* 82225F20h */ case    5:  		/* addi R11, R31, 11 */
		/* 82225F20h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xB);
		/* 82225F20h case    5:*/		return 0x82225F24;
		  /* 82225F24h */ case    6:  		/* subf R30, R22, R24 */
		/* 82225F24h case    6:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R22,regs.R24);
		/* 82225F24h case    6:*/		return 0x82225F28;
		  /* 82225F28h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82225F28h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82225F28h case    7:*/		return 0x82225F2C;
		  /* 82225F2Ch */ case    8:  		/* add R31, R11, R22 */
		/* 82225F2Ch case    8:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R22);
		/* 82225F2Ch case    8:*/		return 0x82225F30;
		  /* 82225F30h */ case    9:  		/* lwzx R3, <#[R30 + R31]> */
		/* 82225F30h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 82225F30h case    9:*/		return 0x82225F34;
		  /* 82225F34h */ case   10:  		/* lwz R4, <#[R31]> */
		/* 82225F34h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82225F34h case   10:*/		return 0x82225F38;
		  /* 82225F38h */ case   11:  		/* lwz R11, <#[R3]> */
		/* 82225F38h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82225F38h case   11:*/		return 0x82225F3C;
		  /* 82225F3Ch */ case   12:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82225F3Ch case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82225F3Ch case   12:*/		return 0x82225F40;
		  /* 82225F40h */ case   13:  		/* bc 12, CR0_EQ, 20 */
		/* 82225F40h case   13:*/		if ( regs.CR[0].eq ) { return 0x82225F54;  }
		/* 82225F40h case   13:*/		return 0x82225F44;
		  /* 82225F44h */ case   14:  		/* bl -15972 */
		/* 82225F44h case   14:*/		regs.LR = 0x82225F48; return 0x822220E0;
		/* 82225F44h case   14:*/		return 0x82225F48;
		  /* 82225F48h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82225F48h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82225F48h case   15:*/		return 0x82225F4C;
		  /* 82225F4Ch */ case   16:  		/* bc 12, CR0_EQ, -520 */
		/* 82225F4Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x82225D44;  }
		/* 82225F4Ch case   16:*/		return 0x82225F50;
		  /* 82225F50h */ case   17:  		/* b 20 */
		/* 82225F50h case   17:*/		return 0x82225F64;
		/* 82225F50h case   17:*/		return 0x82225F54;
	}
	return 0x82225F54;
} // Block from 82225F0Ch-82225F54h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82225F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225F54);
		  /* 82225F54h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 82225F54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82225F54h case    0:*/		return 0x82225F58;
		  /* 82225F58h */ case    1:  		/* lwz R10, <#[R4 + 12]> */
		/* 82225F58h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 82225F58h case    1:*/		return 0x82225F5C;
		  /* 82225F5Ch */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 82225F5Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82225F5Ch case    2:*/		return 0x82225F60;
		  /* 82225F60h */ case    3:  		/* bc 4, CR6_EQ, -540 */
		/* 82225F60h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82225D44;  }
		/* 82225F60h case    3:*/		return 0x82225F64;
	}
	return 0x82225F64;
} // Block from 82225F54h-82225F64h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82225F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225F64);
		  /* 82225F64h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 82225F64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82225F64h case    0:*/		return 0x82225F68;
		  /* 82225F68h */ case    1:  		/* addi R29, R29, 1 */
		/* 82225F68h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82225F68h case    1:*/		return 0x82225F6C;
		  /* 82225F6Ch */ case    2:  		/* addi R31, R31, 4 */
		/* 82225F6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82225F6Ch case    2:*/		return 0x82225F70;
		  /* 82225F70h */ case    3:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82225F70h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82225F70h case    3:*/		return 0x82225F74;
		  /* 82225F74h */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 82225F74h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82225F74h case    4:*/		return 0x82225F78;
		  /* 82225F78h */ case    5:  		/* bc 12, CR6_LT, -72 */
		/* 82225F78h case    5:*/		if ( regs.CR[6].lt ) { return 0x82225F30;  }
		/* 82225F78h case    5:*/		return 0x82225F7C;
	}
	return 0x82225F7C;
} // Block from 82225F64h-82225F7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82225F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225F7C);
		  /* 82225F7Ch */ case    0:  		/* li R3, 1 */
		/* 82225F7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82225F7Ch case    0:*/		return 0x82225F80;
	}
	return 0x82225F80;
} // Block from 82225F7Ch-82225F80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82225F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225F80);
		  /* 82225F80h */ case    0:  		/* addi R1, R1, 176 */
		/* 82225F80h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82225F80h case    0:*/		return 0x82225F84;
		  /* 82225F84h */ case    1:  		/* b -1658100 */
		/* 82225F84h case    1:*/		return 0x82091290;
		/* 82225F84h case    1:*/		return 0x82225F88;
	}
	return 0x82225F88;
} // Block from 82225F80h-82225F88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82225F88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225F88);
		  /* 82225F88h */ case    0:  		/* mfspr R12, LR */
		/* 82225F88h case    0:*/		regs.R12 = regs.LR;
		/* 82225F88h case    0:*/		return 0x82225F8C;
		  /* 82225F8Ch */ case    1:  		/* bl -1658160 */
		/* 82225F8Ch case    1:*/		regs.LR = 0x82225F90; return 0x8209125C;
		/* 82225F8Ch case    1:*/		return 0x82225F90;
		  /* 82225F90h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82225F90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82225F90h case    2:*/		return 0x82225F94;
		  /* 82225F94h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82225F94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82225F94h case    3:*/		return 0x82225F98;
		  /* 82225F98h */ case    4:  		/* mr R30, R3 */
		/* 82225F98h case    4:*/		regs.R30 = regs.R3;
		/* 82225F98h case    4:*/		return 0x82225F9C;
		  /* 82225F9Ch */ case    5:  		/* mr R31, R4 */
		/* 82225F9Ch case    5:*/		regs.R31 = regs.R4;
		/* 82225F9Ch case    5:*/		return 0x82225FA0;
		  /* 82225FA0h */ case    6:  		/* li R29, 0 */
		/* 82225FA0h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82225FA0h case    6:*/		return 0x82225FA4;
		  /* 82225FA4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82225FA4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82225FA4h case    7:*/		return 0x82225FA8;
		  /* 82225FA8h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 82225FA8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82225FC4;  }
		/* 82225FA8h case    8:*/		return 0x82225FAC;
		  /* 82225FACh */ case    9:  		/* lwz R10, <#[R11]> */
		/* 82225FACh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82225FACh case    9:*/		return 0x82225FB0;
		  /* 82225FB0h */ case   10:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82225FB0h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82225FB0h case   10:*/		return 0x82225FB4;
		  /* 82225FB4h */ case   11:  		/* bc 4, CR0_EQ, 8 */
		/* 82225FB4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82225FBC;  }
		/* 82225FB4h case   11:*/		return 0x82225FB8;
		  /* 82225FB8h */ case   12:  		/* addi R29, R29, 1 */
		/* 82225FB8h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82225FB8h case   12:*/		return 0x82225FBC;
	}
	return 0x82225FBC;
} // Block from 82225F88h-82225FBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82225FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225FBC);
		  /* 82225FBCh */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82225FBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82225FBCh case    0:*/		return 0x82225FC0;
		  /* 82225FC0h */ case    1:  		/* b -28 */
		/* 82225FC0h case    1:*/		return 0x82225FA4;
		/* 82225FC0h case    1:*/		return 0x82225FC4;
	}
	return 0x82225FC4;
} // Block from 82225FBCh-82225FC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82225FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225FC4);
		  /* 82225FC4h */ case    0:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 82225FC4h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 82225FC4h case    0:*/		return 0x82225FC8;
		  /* 82225FC8h */ case    1:  		/* lis R10, -32231 */
		/* 82225FC8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8219);
		/* 82225FC8h case    1:*/		return 0x82225FCC;
		  /* 82225FCCh */ case    2:  		/* mr R4, R29 */
		/* 82225FCCh case    2:*/		regs.R4 = regs.R29;
		/* 82225FCCh case    2:*/		return 0x82225FD0;
		  /* 82225FD0h */ case    3:  		/* addi R5, R10, 28352 */
		/* 82225FD0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6EC0);
		/* 82225FD0h case    3:*/		return 0x82225FD4;
		  /* 82225FD4h */ case    4:  		/* addi R3, R1, 80 */
		/* 82225FD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82225FD4h case    4:*/		return 0x82225FD8;
		  /* 82225FD8h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 82225FD8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82225FD8h case    5:*/		return 0x82225FDC;
		  /* 82225FDCh */ case    6:  		/* lwz R6, <#[R11 + 148]> */
		/* 82225FDCh case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000094) );
		/* 82225FDCh case    6:*/		return 0x82225FE0;
		  /* 82225FE0h */ case    7:  		/* bl -589024 */
		/* 82225FE0h case    7:*/		regs.LR = 0x82225FE4; return 0x82196300;
		/* 82225FE0h case    7:*/		return 0x82225FE4;
		  /* 82225FE4h */ case    8:  		/* lwz R6, <#[R31]> */
		/* 82225FE4h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82225FE4h case    8:*/		return 0x82225FE8;
		  /* 82225FE8h */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 82225FE8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82225FE8h case    9:*/		return 0x82225FEC;
		  /* 82225FECh */ case   10:  		/* bc 12, CR6_EQ, 156 */
		/* 82225FECh case   10:*/		if ( regs.CR[6].eq ) { return 0x82226088;  }
		/* 82225FECh case   10:*/		return 0x82225FF0;
	}
	return 0x82225FF0;
} // Block from 82225FC4h-82225FF0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82225FF0h
// Function '?CloneUserVariable@Compiler@D3DXShader@@QAAPAUVariable@2@PAU32@W4_D3DXREGISTER_SET@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82225FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82225FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82225FF0);
		  /* 82225FF0h */ case    0:  		/* lwz R11, <#[R6]> */
		/* 82225FF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82225FF0h case    0:*/		return 0x82225FF4;
		  /* 82225FF4h */ case    1:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82225FF4h case    1:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82225FF4h case    1:*/		return 0x82225FF8;
		  /* 82225FF8h */ case    2:  		/* bc 4, CR0_EQ, 128 */
		/* 82225FF8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82226078;  }
		/* 82225FF8h case    2:*/		return 0x82225FFC;
		  /* 82225FFCh */ case    3:  		/* lwz R5, <#[R6 + 12]> */
		/* 82225FFCh case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + 0x0000000C) );
		/* 82225FFCh case    3:*/		return 0x82226000;
		  /* 82226000h */ case    4:  		/* li R8, 0 */
		/* 82226000h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82226000h case    4:*/		return 0x82226004;
		  /* 82226004h */ case    5:  		/* lwz R7, <#[R30]> */
		/* 82226004h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 82226004h case    5:*/		return 0x82226008;
		  /* 82226008h */ case    6:  		/* li R9, 1 */
		/* 82226008h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82226008h case    6:*/		return 0x8222600C;
		  /* 8222600Ch */ case    7:  		/* cmplwi CR6, R7, 0 */
		/* 8222600Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8222600Ch case    7:*/		return 0x82226010;
		  /* 82226010h */ case    8:  		/* bc 12, CR6_EQ, 96 */
		/* 82226010h case    8:*/		if ( regs.CR[6].eq ) { return 0x82226070;  }
		/* 82226010h case    8:*/		return 0x82226014;
		  /* 82226014h */ case    9:  		/* lwz R11, <#[R7]> */
		/* 82226014h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82226014h case    9:*/		return 0x82226018;
		  /* 82226018h */ case   10:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82226018h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82226018h case   10:*/		return 0x8222601C;
		  /* 8222601Ch */ case   11:  		/* bc 4, CR0_EQ, 76 */
		/* 8222601Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82226068;  }
		/* 8222601Ch case   11:*/		return 0x82226020;
		  /* 82226020h */ case   12:  		/* lwz R11, <#[R7 + 12]> */
		/* 82226020h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 82226020h case   12:*/		return 0x82226024;
		  /* 82226024h */ case   13:  		/* cmplw CR6, R11, R5 */
		/* 82226024h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 82226024h case   13:*/		return 0x82226028;
		  /* 82226028h */ case   14:  		/* bc 4, CR6_EQ, 60 */
		/* 82226028h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82226064;  }
		/* 82226028h case   14:*/		return 0x8222602C;
		  /* 8222602Ch */ case   15:  		/* lwz R11, <#[R1 + 80]> */
		/* 8222602Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222602Ch case   15:*/		return 0x82226030;
		  /* 82226030h */ case   16:  		/* nor R10, R11, R11 */
		/* 82226030h case   16:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82226030h case   16:*/		return 0x82226034;
		  /* 82226034h */ case   17:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82226034h case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82226034h case   17:*/		return 0x82226038;
		  /* 82226038h */ case   18:  		/* addi R10, R11, 4 */
		/* 82226038h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82226038h case   18:*/		return 0x8222603C;
		  /* 8222603Ch */ case   19:  		/* bc 4, CR0_EQ, 8 */
		/* 8222603Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x82226044;  }
		/* 8222603Ch case   19:*/		return 0x82226040;
		  /* 82226040h */ case   20:  		/* addi R10, R1, 80 */
		/* 82226040h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82226040h case   20:*/		return 0x82226044;
	}
	return 0x82226044;
} // Block from 82225FF0h-82226044h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82226044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226044);
		  /* 82226044h */ case    0:  		/* rlwinm R11, R9, 29, 3, 29 */
		/* 82226044h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R9);
		/* 82226044h case    0:*/		return 0x82226048;
		  /* 82226048h */ case    1:  		/* li R3, 1 */
		/* 82226048h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82226048h case    1:*/		return 0x8222604C;
		  /* 8222604Ch */ case    2:  		/* rlwinm R4, R9, 0, 27, 31 */
		/* 8222604Ch case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R9);
		/* 8222604Ch case    2:*/		return 0x82226050;
		  /* 82226050h */ case    3:  		/* li R8, 1 */
		/* 82226050h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82226050h case    3:*/		return 0x82226054;
		  /* 82226054h */ case    4:  		/* slw R4, R3, R4 */
		/* 82226054h case    4:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R3,regs.R4);
		/* 82226054h case    4:*/		return 0x82226058;
		  /* 82226058h */ case    5:  		/* lwzx R3, <#[R11 + R10]> */
		/* 82226058h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82226058h case    5:*/		return 0x8222605C;
		  /* 8222605Ch */ case    6:  		/* or R4, R4, R3 */
		/* 8222605Ch case    6:*/		cpu::op::or<0>(regs,&regs.R4,regs.R4,regs.R3);
		/* 8222605Ch case    6:*/		return 0x82226060;
		  /* 82226060h */ case    7:  		/* stwx R4, <#[R11 + R10]> */
		/* 82226060h case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82226060h case    7:*/		return 0x82226064;
	}
	return 0x82226064;
} // Block from 82226044h-82226064h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82226064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226064);
		  /* 82226064h */ case    0:  		/* addi R9, R9, 1 */
		/* 82226064h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82226064h case    0:*/		return 0x82226068;
	}
	return 0x82226068;
} // Block from 82226064h-82226068h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82226068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226068);
		  /* 82226068h */ case    0:  		/* lwz R7, <#[R7 + 4]> */
		/* 82226068h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 82226068h case    0:*/		return 0x8222606C;
		  /* 8222606Ch */ case    1:  		/* b -96 */
		/* 8222606Ch case    1:*/		return 0x8222600C;
		/* 8222606Ch case    1:*/		return 0x82226070;
	}
	return 0x82226070;
} // Block from 82226068h-82226070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226070);
		  /* 82226070h */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 82226070h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 82226070h case    0:*/		return 0x82226074;
		  /* 82226074h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82226074h case    1:*/		if ( regs.CR[0].eq ) { return 0x82226080;  }
		/* 82226074h case    1:*/		return 0x82226078;
	}
	return 0x82226078;
} // Block from 82226070h-82226078h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226078);
		  /* 82226078h */ case    0:  		/* lwz R6, <#[R6 + 4]> */
		/* 82226078h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 82226078h case    0:*/		return 0x8222607C;
		  /* 8222607Ch */ case    1:  		/* b -148 */
		/* 8222607Ch case    1:*/		return 0x82225FE8;
		/* 8222607Ch case    1:*/		return 0x82226080;
	}
	return 0x82226080;
} // Block from 82226078h-82226080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226080);
		  /* 82226080h */ case    0:  		/* li R3, 0 */
		/* 82226080h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82226080h case    0:*/		return 0x82226084;
		  /* 82226084h */ case    1:  		/* b 48 */
		/* 82226084h case    1:*/		return 0x822260B4;
		/* 82226084h case    1:*/		return 0x82226088;
	}
	return 0x82226088;
} // Block from 82226080h-82226088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226088);
		  /* 82226088h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82226088h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82226088h case    0:*/		return 0x8222608C;
		  /* 8222608Ch */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8222608Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x822260AC;  }
		/* 8222608Ch case    1:*/		return 0x82226090;
		  /* 82226090h */ case    2:  		/* addi R5, R29, -1 */
		/* 82226090h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0xFFFFFFFF);
		/* 82226090h case    2:*/		return 0x82226094;
		  /* 82226094h */ case    3:  		/* li R4, 0 */
		/* 82226094h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82226094h case    3:*/		return 0x82226098;
		  /* 82226098h */ case    4:  		/* addi R3, R1, 80 */
		/* 82226098h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82226098h case    4:*/		return 0x8222609C;
		  /* 8222609Ch */ case    5:  		/* bl -10092 */
		/* 8222609Ch case    5:*/		regs.LR = 0x822260A0; return 0x82223930;
		/* 8222609Ch case    5:*/		return 0x822260A0;
		  /* 822260A0h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822260A0h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822260A0h case    6:*/		return 0x822260A4;
		  /* 822260A4h */ case    7:  		/* li R11, 0 */
		/* 822260A4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822260A4h case    7:*/		return 0x822260A8;
		  /* 822260A8h */ case    8:  		/* bc 4, CR0_EQ, 8 */
		/* 822260A8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x822260B0;  }
		/* 822260A8h case    8:*/		return 0x822260AC;
	}
	return 0x822260AC;
} // Block from 82226088h-822260ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822260ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822260AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822260AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822260AC);
		  /* 822260ACh */ case    0:  		/* li R11, 1 */
		/* 822260ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822260ACh case    0:*/		return 0x822260B0;
	}
	return 0x822260B0;
} // Block from 822260ACh-822260B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822260B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822260B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822260B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822260B0);
		  /* 822260B0h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 822260B0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 822260B0h case    0:*/		return 0x822260B4;
	}
	return 0x822260B4;
} // Block from 822260B0h-822260B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822260B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822260B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822260B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822260B4);
		  /* 822260B4h */ case    0:  		/* addi R1, R1, 128 */
		/* 822260B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822260B4h case    0:*/		return 0x822260B8;
		  /* 822260B8h */ case    1:  		/* b -1658380 */
		/* 822260B8h case    1:*/		return 0x820912AC;
		/* 822260B8h case    1:*/		return 0x822260BC;
		  /* 822260BCh */ case    2:  		/* nop */
		/* 822260BCh case    2:*/		cpu::op::nop();
		/* 822260BCh case    2:*/		return 0x822260C0;
	}
	return 0x822260C0;
} // Block from 822260B4h-822260C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822260C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822260C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822260C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822260C0);
		  /* 822260C0h */ case    0:  		/* mr R11, R3 */
		/* 822260C0h case    0:*/		regs.R11 = regs.R3;
		/* 822260C0h case    0:*/		return 0x822260C4;
		  /* 822260C4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 822260C4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 822260C4h case    1:*/		return 0x822260C8;
		  /* 822260C8h */ case    2:  		/* lwz R11, <#[R11 + 36]> */
		/* 822260C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 822260C8h case    2:*/		return 0x822260CC;
		  /* 822260CCh */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 822260CCh case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 822260CCh case    3:*/		return 0x822260D0;
		  /* 822260D0h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 822260D0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x822260F0;  }
		/* 822260D0h case    4:*/		return 0x822260D4;
		  /* 822260D4h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 822260D4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 822260D4h case    5:*/		return 0x822260D8;
		  /* 822260D8h */ case    6:  		/* addic. R11, R11, -40 */
		/* 822260D8h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 822260D8h case    6:*/		return 0x822260DC;
		  /* 822260DCh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 822260DCh case    7:*/		if ( regs.CR[0].eq ) { return 0x822260F0;  }
		/* 822260DCh case    7:*/		return 0x822260E0;
		  /* 822260E0h */ case    8:  		/* cmplw CR6, R11, R4 */
		/* 822260E0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 822260E0h case    8:*/		return 0x822260E4;
		  /* 822260E4h */ case    9:  		/* bc 4, CR6_EQ, -32 */
		/* 822260E4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x822260C4;  }
		/* 822260E4h case    9:*/		return 0x822260E8;
		  /* 822260E8h */ case   10:  		/* li R3, 1 */
		/* 822260E8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822260E8h case   10:*/		return 0x822260EC;
		  /* 822260ECh */ case   11:  		/* bclr 20, CR0_LT */
		/* 822260ECh case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822260ECh case   11:*/		return 0x822260F0;
	}
	return 0x822260F0;
} // Block from 822260C0h-822260F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822260F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822260F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822260F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822260F0);
		  /* 822260F0h */ case    0:  		/* li R3, 0 */
		/* 822260F0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822260F0h case    0:*/		return 0x822260F4;
		  /* 822260F4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 822260F4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822260F4h case    1:*/		return 0x822260F8;
	}
	return 0x822260F8;
} // Block from 822260F0h-822260F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822260F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822260F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822260F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822260F8);
		  /* 822260F8h */ case    0:  		/* mfspr R12, LR */
		/* 822260F8h case    0:*/		regs.R12 = regs.LR;
		/* 822260F8h case    0:*/		return 0x822260FC;
		  /* 822260FCh */ case    1:  		/* bl -1658532 */
		/* 822260FCh case    1:*/		regs.LR = 0x82226100; return 0x82091258;
		/* 822260FCh case    1:*/		return 0x82226100;
		  /* 82226100h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82226100h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82226100h case    2:*/		return 0x82226104;
		  /* 82226104h */ case    3:  		/* mr R29, R5 */
		/* 82226104h case    3:*/		regs.R29 = regs.R5;
		/* 82226104h case    3:*/		return 0x82226108;
		  /* 82226108h */ case    4:  		/* li R8, 1 */
		/* 82226108h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82226108h case    4:*/		return 0x8222610C;
		  /* 8222610Ch */ case    5:  		/* li R7, 1 */
		/* 8222610Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8222610Ch case    5:*/		return 0x82226110;
		  /* 82226110h */ case    6:  		/* li R6, 49 */
		/* 82226110h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x31);
		/* 82226110h case    6:*/		return 0x82226114;
		  /* 82226114h */ case    7:  		/* li R5, 0 */
		/* 82226114h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226114h case    7:*/		return 0x82226118;
		  /* 82226118h */ case    8:  		/* mr R28, R3 */
		/* 82226118h case    8:*/		regs.R28 = regs.R3;
		/* 82226118h case    8:*/		return 0x8222611C;
		  /* 8222611Ch */ case    9:  		/* mr R31, R4 */
		/* 8222611Ch case    9:*/		regs.R31 = regs.R4;
		/* 8222611Ch case    9:*/		return 0x82226120;
		  /* 82226120h */ case   10:  		/* bl -6024 */
		/* 82226120h case   10:*/		regs.LR = 0x82226124; return 0x82224998;
		/* 82226120h case   10:*/		return 0x82226124;
		  /* 82226124h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 82226124h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82226124h case   11:*/		return 0x82226128;
		  /* 82226128h */ case   12:  		/* mr R30, R3 */
		/* 82226128h case   12:*/		regs.R30 = regs.R3;
		/* 82226128h case   12:*/		return 0x8222612C;
		  /* 8222612Ch */ case   13:  		/* mr R4, R29 */
		/* 8222612Ch case   13:*/		regs.R4 = regs.R29;
		/* 8222612Ch case   13:*/		return 0x82226130;
		  /* 82226130h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82226130h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226130h case   14:*/		return 0x82226134;
		  /* 82226134h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82226134h case   15:*/		if ( regs.CR[6].eq ) { return 0x82226148;  }
		/* 82226134h case   15:*/		return 0x82226138;
		  /* 82226138h */ case   16:  		/* mr R3, R28 */
		/* 82226138h case   16:*/		regs.R3 = regs.R28;
		/* 82226138h case   16:*/		return 0x8222613C;
		  /* 8222613Ch */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 8222613Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 8222613Ch case   17:*/		return 0x82226140;
		  /* 82226140h */ case   18:  		/* bl -741456 */
		/* 82226140h case   18:*/		regs.LR = 0x82226144; return 0x821710F0;
		/* 82226140h case   18:*/		return 0x82226144;
		  /* 82226144h */ case   19:  		/* mr R4, R3 */
		/* 82226144h case   19:*/		regs.R4 = regs.R3;
		/* 82226144h case   19:*/		return 0x82226148;
	}
	return 0x82226148;
} // Block from 822260F8h-82226148h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82226148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226148);
		  /* 82226148h */ case    0:  		/* mr R3, R30 */
		/* 82226148h case    0:*/		regs.R3 = regs.R30;
		/* 82226148h case    0:*/		return 0x8222614C;
		  /* 8222614Ch */ case    1:  		/* bl -712580 */
		/* 8222614Ch case    1:*/		regs.LR = 0x82226150; return 0x821781C8;
		/* 8222614Ch case    1:*/		return 0x82226150;
		  /* 82226150h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82226150h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82226150h case    2:*/		return 0x82226154;
		  /* 82226154h */ case    3:  		/* stw R3, <#[R30 + 44]> */
		/* 82226154h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 82226154h case    3:*/		return 0x82226158;
		  /* 82226158h */ case    4:  		/* addi R10, R31, 24 */
		/* 82226158h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 82226158h case    4:*/		return 0x8222615C;
		  /* 8222615Ch */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 8222615Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8222615Ch case    5:*/		return 0x82226160;
		  /* 82226160h */ case    6:  		/* addi R11, R11, 36 */
		/* 82226160h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226160h case    6:*/		return 0x82226164;
		  /* 82226164h */ case    7:  		/* stw R9, <#[R11]> */
		/* 82226164h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82226164h case    7:*/		return 0x82226168;
		  /* 82226168h */ case    8:  		/* addi R10, R10, -36 */
		/* 82226168h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82226168h case    8:*/		return 0x8222616C;
		  /* 8222616Ch */ case    9:  		/* lwz R9, <#[R31 + 24]> */
		/* 8222616Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8222616Ch case    9:*/		return 0x82226170;
		  /* 82226170h */ case   10:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82226170h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82226170h case   10:*/		return 0x82226174;
		  /* 82226174h */ case   11:  		/* addi R8, R11, -36 */
		/* 82226174h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82226174h case   11:*/		return 0x82226178;
	}
	return 0x82226178;
} // Block from 82226148h-82226178h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82226178h
// Function '?CreateInternalVariable@Compiler@D3DXShader@@QAAPAUVariable@2@W4VariableKind@2@IPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226178);
		  /* 82226178h */ case    0:  		/* ori R7, R10, 1 */
		/* 82226178h case    0:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 82226178h case    0:*/		return 0x8222617C;
		  /* 8222617Ch */ case    1:  		/* addi R10, R11, 4 */
		/* 8222617Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8222617Ch case    1:*/		return 0x82226180;
		  /* 82226180h */ case    2:  		/* stw R8, <#[R9]> */
		/* 82226180h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82226180h case    2:*/		return 0x82226184;
		  /* 82226184h */ case    3:  		/* stw R7, <#[R11 + 4]> */
		/* 82226184h case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226184h case    3:*/		return 0x82226188;
		  /* 82226188h */ case    4:  		/* mr R3, R30 */
		/* 82226188h case    4:*/		regs.R3 = regs.R30;
		/* 82226188h case    4:*/		return 0x8222618C;
		  /* 8222618Ch */ case    5:  		/* stw R10, <#[R31 + 24]> */
		/* 8222618Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8222618Ch case    5:*/		return 0x82226190;
		  /* 82226190h */ case    6:  		/* addi R1, R1, 128 */
		/* 82226190h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82226190h case    6:*/		return 0x82226194;
		  /* 82226194h */ case    7:  		/* b -1658604 */
		/* 82226194h case    7:*/		return 0x820912A8;
		/* 82226194h case    7:*/		return 0x82226198;
	}
	return 0x82226198;
} // Block from 82226178h-82226198h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82226198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226198);
		  /* 82226198h */ case    0:  		/* mfspr R12, LR */
		/* 82226198h case    0:*/		regs.R12 = regs.LR;
		/* 82226198h case    0:*/		return 0x8222619C;
		  /* 8222619Ch */ case    1:  		/* bl -1658692 */
		/* 8222619Ch case    1:*/		regs.LR = 0x822261A0; return 0x82091258;
		/* 8222619Ch case    1:*/		return 0x822261A0;
		  /* 822261A0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822261A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822261A0h case    2:*/		return 0x822261A4;
		  /* 822261A4h */ case    3:  		/* mr R29, R5 */
		/* 822261A4h case    3:*/		regs.R29 = regs.R5;
		/* 822261A4h case    3:*/		return 0x822261A8;
		  /* 822261A8h */ case    4:  		/* li R8, 1 */
		/* 822261A8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 822261A8h case    4:*/		return 0x822261AC;
		  /* 822261ACh */ case    5:  		/* li R7, 1 */
		/* 822261ACh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 822261ACh case    5:*/		return 0x822261B0;
		  /* 822261B0h */ case    6:  		/* li R6, 59 */
		/* 822261B0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3B);
		/* 822261B0h case    6:*/		return 0x822261B4;
		  /* 822261B4h */ case    7:  		/* li R5, 0 */
		/* 822261B4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822261B4h case    7:*/		return 0x822261B8;
		  /* 822261B8h */ case    8:  		/* mr R28, R3 */
		/* 822261B8h case    8:*/		regs.R28 = regs.R3;
		/* 822261B8h case    8:*/		return 0x822261BC;
		  /* 822261BCh */ case    9:  		/* mr R31, R4 */
		/* 822261BCh case    9:*/		regs.R31 = regs.R4;
		/* 822261BCh case    9:*/		return 0x822261C0;
		  /* 822261C0h */ case   10:  		/* bl -6184 */
		/* 822261C0h case   10:*/		regs.LR = 0x822261C4; return 0x82224998;
		/* 822261C0h case   10:*/		return 0x822261C4;
		  /* 822261C4h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 822261C4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 822261C4h case   11:*/		return 0x822261C8;
		  /* 822261C8h */ case   12:  		/* mr R30, R3 */
		/* 822261C8h case   12:*/		regs.R30 = regs.R3;
		/* 822261C8h case   12:*/		return 0x822261CC;
		  /* 822261CCh */ case   13:  		/* mr R4, R29 */
		/* 822261CCh case   13:*/		regs.R4 = regs.R29;
		/* 822261CCh case   13:*/		return 0x822261D0;
		  /* 822261D0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 822261D0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822261D0h case   14:*/		return 0x822261D4;
		  /* 822261D4h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 822261D4h case   15:*/		if ( regs.CR[6].eq ) { return 0x822261E8;  }
		/* 822261D4h case   15:*/		return 0x822261D8;
		  /* 822261D8h */ case   16:  		/* mr R3, R28 */
		/* 822261D8h case   16:*/		regs.R3 = regs.R28;
		/* 822261D8h case   16:*/		return 0x822261DC;
		  /* 822261DCh */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 822261DCh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 822261DCh case   17:*/		return 0x822261E0;
		  /* 822261E0h */ case   18:  		/* bl -741616 */
		/* 822261E0h case   18:*/		regs.LR = 0x822261E4; return 0x821710F0;
		/* 822261E0h case   18:*/		return 0x822261E4;
		  /* 822261E4h */ case   19:  		/* mr R4, R3 */
		/* 822261E4h case   19:*/		regs.R4 = regs.R3;
		/* 822261E4h case   19:*/		return 0x822261E8;
	}
	return 0x822261E8;
} // Block from 82226198h-822261E8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822261E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822261E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822261E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822261E8);
		  /* 822261E8h */ case    0:  		/* mr R3, R30 */
		/* 822261E8h case    0:*/		regs.R3 = regs.R30;
		/* 822261E8h case    0:*/		return 0x822261EC;
		  /* 822261ECh */ case    1:  		/* bl -712740 */
		/* 822261ECh case    1:*/		regs.LR = 0x822261F0; return 0x821781C8;
		/* 822261ECh case    1:*/		return 0x822261F0;
		  /* 822261F0h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 822261F0h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 822261F0h case    2:*/		return 0x822261F4;
		  /* 822261F4h */ case    3:  		/* stw R3, <#[R30 + 44]> */
		/* 822261F4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 822261F4h case    3:*/		return 0x822261F8;
		  /* 822261F8h */ case    4:  		/* addi R10, R31, 24 */
		/* 822261F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 822261F8h case    4:*/		return 0x822261FC;
		  /* 822261FCh */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 822261FCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 822261FCh case    5:*/		return 0x82226200;
		  /* 82226200h */ case    6:  		/* addi R11, R11, 36 */
		/* 82226200h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226200h case    6:*/		return 0x82226204;
		  /* 82226204h */ case    7:  		/* stw R9, <#[R11]> */
		/* 82226204h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82226204h case    7:*/		return 0x82226208;
		  /* 82226208h */ case    8:  		/* addi R10, R10, -36 */
		/* 82226208h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82226208h case    8:*/		return 0x8222620C;
		  /* 8222620Ch */ case    9:  		/* lwz R9, <#[R31 + 24]> */
		/* 8222620Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8222620Ch case    9:*/		return 0x82226210;
		  /* 82226210h */ case   10:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82226210h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82226210h case   10:*/		return 0x82226214;
		  /* 82226214h */ case   11:  		/* addi R8, R11, -36 */
		/* 82226214h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82226214h case   11:*/		return 0x82226218;
		  /* 82226218h */ case   12:  		/* ori R7, R10, 1 */
		/* 82226218h case   12:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 82226218h case   12:*/		return 0x8222621C;
		  /* 8222621Ch */ case   13:  		/* addi R10, R11, 4 */
		/* 8222621Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8222621Ch case   13:*/		return 0x82226220;
		  /* 82226220h */ case   14:  		/* stw R8, <#[R9]> */
		/* 82226220h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82226220h case   14:*/		return 0x82226224;
		  /* 82226224h */ case   15:  		/* stw R7, <#[R11 + 4]> */
		/* 82226224h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226224h case   15:*/		return 0x82226228;
		  /* 82226228h */ case   16:  		/* mr R3, R30 */
		/* 82226228h case   16:*/		regs.R3 = regs.R30;
		/* 82226228h case   16:*/		return 0x8222622C;
		  /* 8222622Ch */ case   17:  		/* stw R10, <#[R31 + 24]> */
		/* 8222622Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8222622Ch case   17:*/		return 0x82226230;
		  /* 82226230h */ case   18:  		/* addi R1, R1, 128 */
		/* 82226230h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82226230h case   18:*/		return 0x82226234;
		  /* 82226234h */ case   19:  		/* b -1658764 */
		/* 82226234h case   19:*/		return 0x820912A8;
		/* 82226234h case   19:*/		return 0x82226238;
	}
	return 0x82226238;
} // Block from 822261E8h-82226238h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82226238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226238);
		  /* 82226238h */ case    0:  		/* mfspr R12, LR */
		/* 82226238h case    0:*/		regs.R12 = regs.LR;
		/* 82226238h case    0:*/		return 0x8222623C;
		  /* 8222623Ch */ case    1:  		/* bl -1658852 */
		/* 8222623Ch case    1:*/		regs.LR = 0x82226240; return 0x82091258;
		/* 8222623Ch case    1:*/		return 0x82226240;
		  /* 82226240h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82226240h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82226240h case    2:*/		return 0x82226244;
		  /* 82226244h */ case    3:  		/* mr R29, R5 */
		/* 82226244h case    3:*/		regs.R29 = regs.R5;
		/* 82226244h case    3:*/		return 0x82226248;
		  /* 82226248h */ case    4:  		/* li R8, 1 */
		/* 82226248h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82226248h case    4:*/		return 0x8222624C;
		  /* 8222624Ch */ case    5:  		/* li R7, 1 */
		/* 8222624Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8222624Ch case    5:*/		return 0x82226250;
		  /* 82226250h */ case    6:  		/* li R6, 60 */
		/* 82226250h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3C);
		/* 82226250h case    6:*/		return 0x82226254;
		  /* 82226254h */ case    7:  		/* li R5, 0 */
		/* 82226254h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226254h case    7:*/		return 0x82226258;
		  /* 82226258h */ case    8:  		/* mr R28, R3 */
		/* 82226258h case    8:*/		regs.R28 = regs.R3;
		/* 82226258h case    8:*/		return 0x8222625C;
		  /* 8222625Ch */ case    9:  		/* mr R31, R4 */
		/* 8222625Ch case    9:*/		regs.R31 = regs.R4;
		/* 8222625Ch case    9:*/		return 0x82226260;
		  /* 82226260h */ case   10:  		/* bl -6344 */
		/* 82226260h case   10:*/		regs.LR = 0x82226264; return 0x82224998;
		/* 82226260h case   10:*/		return 0x82226264;
		  /* 82226264h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 82226264h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82226264h case   11:*/		return 0x82226268;
		  /* 82226268h */ case   12:  		/* mr R30, R3 */
		/* 82226268h case   12:*/		regs.R30 = regs.R3;
		/* 82226268h case   12:*/		return 0x8222626C;
		  /* 8222626Ch */ case   13:  		/* mr R4, R29 */
		/* 8222626Ch case   13:*/		regs.R4 = regs.R29;
		/* 8222626Ch case   13:*/		return 0x82226270;
		  /* 82226270h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82226270h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226270h case   14:*/		return 0x82226274;
		  /* 82226274h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82226274h case   15:*/		if ( regs.CR[6].eq ) { return 0x82226288;  }
		/* 82226274h case   15:*/		return 0x82226278;
		  /* 82226278h */ case   16:  		/* mr R3, R28 */
		/* 82226278h case   16:*/		regs.R3 = regs.R28;
		/* 82226278h case   16:*/		return 0x8222627C;
		  /* 8222627Ch */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 8222627Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 8222627Ch case   17:*/		return 0x82226280;
		  /* 82226280h */ case   18:  		/* bl -741776 */
		/* 82226280h case   18:*/		regs.LR = 0x82226284; return 0x821710F0;
		/* 82226280h case   18:*/		return 0x82226284;
		  /* 82226284h */ case   19:  		/* mr R4, R3 */
		/* 82226284h case   19:*/		regs.R4 = regs.R3;
		/* 82226284h case   19:*/		return 0x82226288;
	}
	return 0x82226288;
} // Block from 82226238h-82226288h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82226288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226288);
		  /* 82226288h */ case    0:  		/* mr R3, R30 */
		/* 82226288h case    0:*/		regs.R3 = regs.R30;
		/* 82226288h case    0:*/		return 0x8222628C;
		  /* 8222628Ch */ case    1:  		/* bl -712900 */
		/* 8222628Ch case    1:*/		regs.LR = 0x82226290; return 0x821781C8;
		/* 8222628Ch case    1:*/		return 0x82226290;
		  /* 82226290h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82226290h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82226290h case    2:*/		return 0x82226294;
		  /* 82226294h */ case    3:  		/* stw R3, <#[R30 + 44]> */
		/* 82226294h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 82226294h case    3:*/		return 0x82226298;
		  /* 82226298h */ case    4:  		/* addi R10, R31, 24 */
		/* 82226298h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 82226298h case    4:*/		return 0x8222629C;
		  /* 8222629Ch */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 8222629Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8222629Ch case    5:*/		return 0x822262A0;
		  /* 822262A0h */ case    6:  		/* addi R11, R11, 36 */
		/* 822262A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 822262A0h case    6:*/		return 0x822262A4;
		  /* 822262A4h */ case    7:  		/* stw R9, <#[R11]> */
		/* 822262A4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822262A4h case    7:*/		return 0x822262A8;
		  /* 822262A8h */ case    8:  		/* addi R10, R10, -36 */
		/* 822262A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 822262A8h case    8:*/		return 0x822262AC;
		  /* 822262ACh */ case    9:  		/* lwz R9, <#[R31 + 24]> */
		/* 822262ACh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 822262ACh case    9:*/		return 0x822262B0;
		  /* 822262B0h */ case   10:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 822262B0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 822262B0h case   10:*/		return 0x822262B4;
		  /* 822262B4h */ case   11:  		/* addi R8, R11, -36 */
		/* 822262B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 822262B4h case   11:*/		return 0x822262B8;
		  /* 822262B8h */ case   12:  		/* ori R7, R10, 1 */
		/* 822262B8h case   12:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 822262B8h case   12:*/		return 0x822262BC;
		  /* 822262BCh */ case   13:  		/* addi R10, R11, 4 */
		/* 822262BCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 822262BCh case   13:*/		return 0x822262C0;
		  /* 822262C0h */ case   14:  		/* stw R8, <#[R9]> */
		/* 822262C0h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 822262C0h case   14:*/		return 0x822262C4;
		  /* 822262C4h */ case   15:  		/* stw R7, <#[R11 + 4]> */
		/* 822262C4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 822262C4h case   15:*/		return 0x822262C8;
		  /* 822262C8h */ case   16:  		/* mr R3, R30 */
		/* 822262C8h case   16:*/		regs.R3 = regs.R30;
		/* 822262C8h case   16:*/		return 0x822262CC;
		  /* 822262CCh */ case   17:  		/* stw R10, <#[R31 + 24]> */
		/* 822262CCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 822262CCh case   17:*/		return 0x822262D0;
		  /* 822262D0h */ case   18:  		/* addi R1, R1, 128 */
		/* 822262D0h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822262D0h case   18:*/		return 0x822262D4;
		  /* 822262D4h */ case   19:  		/* b -1658924 */
		/* 822262D4h case   19:*/		return 0x820912A8;
		/* 822262D4h case   19:*/		return 0x822262D8;
	}
	return 0x822262D8;
} // Block from 82226288h-822262D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822262D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822262D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822262D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822262D8);
		  /* 822262D8h */ case    0:  		/* mfspr R12, LR */
		/* 822262D8h case    0:*/		regs.R12 = regs.LR;
		/* 822262D8h case    0:*/		return 0x822262DC;
		  /* 822262DCh */ case    1:  		/* bl -1659012 */
		/* 822262DCh case    1:*/		regs.LR = 0x822262E0; return 0x82091258;
		/* 822262DCh case    1:*/		return 0x822262E0;
		  /* 822262E0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822262E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822262E0h case    2:*/		return 0x822262E4;
		  /* 822262E4h */ case    3:  		/* mr R29, R5 */
		/* 822262E4h case    3:*/		regs.R29 = regs.R5;
		/* 822262E4h case    3:*/		return 0x822262E8;
		  /* 822262E8h */ case    4:  		/* li R8, 1 */
		/* 822262E8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 822262E8h case    4:*/		return 0x822262EC;
		  /* 822262ECh */ case    5:  		/* li R7, 1 */
		/* 822262ECh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 822262ECh case    5:*/		return 0x822262F0;
		  /* 822262F0h */ case    6:  		/* li R6, 61 */
		/* 822262F0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3D);
		/* 822262F0h case    6:*/		return 0x822262F4;
		  /* 822262F4h */ case    7:  		/* li R5, 0 */
		/* 822262F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822262F4h case    7:*/		return 0x822262F8;
		  /* 822262F8h */ case    8:  		/* mr R28, R3 */
		/* 822262F8h case    8:*/		regs.R28 = regs.R3;
		/* 822262F8h case    8:*/		return 0x822262FC;
		  /* 822262FCh */ case    9:  		/* mr R31, R4 */
		/* 822262FCh case    9:*/		regs.R31 = regs.R4;
		/* 822262FCh case    9:*/		return 0x82226300;
		  /* 82226300h */ case   10:  		/* bl -6504 */
		/* 82226300h case   10:*/		regs.LR = 0x82226304; return 0x82224998;
		/* 82226300h case   10:*/		return 0x82226304;
		  /* 82226304h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 82226304h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82226304h case   11:*/		return 0x82226308;
		  /* 82226308h */ case   12:  		/* mr R30, R3 */
		/* 82226308h case   12:*/		regs.R30 = regs.R3;
		/* 82226308h case   12:*/		return 0x8222630C;
		  /* 8222630Ch */ case   13:  		/* mr R4, R29 */
		/* 8222630Ch case   13:*/		regs.R4 = regs.R29;
		/* 8222630Ch case   13:*/		return 0x82226310;
		  /* 82226310h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82226310h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226310h case   14:*/		return 0x82226314;
		  /* 82226314h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82226314h case   15:*/		if ( regs.CR[6].eq ) { return 0x82226328;  }
		/* 82226314h case   15:*/		return 0x82226318;
		  /* 82226318h */ case   16:  		/* mr R3, R28 */
		/* 82226318h case   16:*/		regs.R3 = regs.R28;
		/* 82226318h case   16:*/		return 0x8222631C;
		  /* 8222631Ch */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 8222631Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 8222631Ch case   17:*/		return 0x82226320;
		  /* 82226320h */ case   18:  		/* bl -741936 */
		/* 82226320h case   18:*/		regs.LR = 0x82226324; return 0x821710F0;
		/* 82226320h case   18:*/		return 0x82226324;
		  /* 82226324h */ case   19:  		/* mr R4, R3 */
		/* 82226324h case   19:*/		regs.R4 = regs.R3;
		/* 82226324h case   19:*/		return 0x82226328;
	}
	return 0x82226328;
} // Block from 822262D8h-82226328h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82226328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226328);
		  /* 82226328h */ case    0:  		/* mr R3, R30 */
		/* 82226328h case    0:*/		regs.R3 = regs.R30;
		/* 82226328h case    0:*/		return 0x8222632C;
		  /* 8222632Ch */ case    1:  		/* bl -713060 */
		/* 8222632Ch case    1:*/		regs.LR = 0x82226330; return 0x821781C8;
		/* 8222632Ch case    1:*/		return 0x82226330;
		  /* 82226330h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82226330h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82226330h case    2:*/		return 0x82226334;
		  /* 82226334h */ case    3:  		/* stw R3, <#[R30 + 44]> */
		/* 82226334h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 82226334h case    3:*/		return 0x82226338;
		  /* 82226338h */ case    4:  		/* addi R10, R31, 24 */
		/* 82226338h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 82226338h case    4:*/		return 0x8222633C;
		  /* 8222633Ch */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 8222633Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8222633Ch case    5:*/		return 0x82226340;
		  /* 82226340h */ case    6:  		/* addi R11, R11, 36 */
		/* 82226340h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226340h case    6:*/		return 0x82226344;
		  /* 82226344h */ case    7:  		/* stw R9, <#[R11]> */
		/* 82226344h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82226344h case    7:*/		return 0x82226348;
		  /* 82226348h */ case    8:  		/* addi R10, R10, -36 */
		/* 82226348h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82226348h case    8:*/		return 0x8222634C;
		  /* 8222634Ch */ case    9:  		/* lwz R9, <#[R31 + 24]> */
		/* 8222634Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8222634Ch case    9:*/		return 0x82226350;
		  /* 82226350h */ case   10:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82226350h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82226350h case   10:*/		return 0x82226354;
		  /* 82226354h */ case   11:  		/* addi R8, R11, -36 */
		/* 82226354h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82226354h case   11:*/		return 0x82226358;
		  /* 82226358h */ case   12:  		/* ori R7, R10, 1 */
		/* 82226358h case   12:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 82226358h case   12:*/		return 0x8222635C;
		  /* 8222635Ch */ case   13:  		/* addi R10, R11, 4 */
		/* 8222635Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8222635Ch case   13:*/		return 0x82226360;
		  /* 82226360h */ case   14:  		/* stw R8, <#[R9]> */
		/* 82226360h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82226360h case   14:*/		return 0x82226364;
		  /* 82226364h */ case   15:  		/* stw R7, <#[R11 + 4]> */
		/* 82226364h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226364h case   15:*/		return 0x82226368;
		  /* 82226368h */ case   16:  		/* mr R3, R30 */
		/* 82226368h case   16:*/		regs.R3 = regs.R30;
		/* 82226368h case   16:*/		return 0x8222636C;
		  /* 8222636Ch */ case   17:  		/* stw R10, <#[R31 + 24]> */
		/* 8222636Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8222636Ch case   17:*/		return 0x82226370;
		  /* 82226370h */ case   18:  		/* addi R1, R1, 128 */
		/* 82226370h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82226370h case   18:*/		return 0x82226374;
		  /* 82226374h */ case   19:  		/* b -1659084 */
		/* 82226374h case   19:*/		return 0x820912A8;
		/* 82226374h case   19:*/		return 0x82226378;
	}
	return 0x82226378;
} // Block from 82226328h-82226378h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82226378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226378);
		  /* 82226378h */ case    0:  		/* mfspr R12, LR */
		/* 82226378h case    0:*/		regs.R12 = regs.LR;
		/* 82226378h case    0:*/		return 0x8222637C;
		  /* 8222637Ch */ case    1:  		/* bl -1659172 */
		/* 8222637Ch case    1:*/		regs.LR = 0x82226380; return 0x82091258;
		/* 8222637Ch case    1:*/		return 0x82226380;
		  /* 82226380h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82226380h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82226380h case    2:*/		return 0x82226384;
		  /* 82226384h */ case    3:  		/* mr R29, R5 */
		/* 82226384h case    3:*/		regs.R29 = regs.R5;
		/* 82226384h case    3:*/		return 0x82226388;
		  /* 82226388h */ case    4:  		/* li R8, 1 */
		/* 82226388h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82226388h case    4:*/		return 0x8222638C;
		  /* 8222638Ch */ case    5:  		/* li R7, 1 */
		/* 8222638Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8222638Ch case    5:*/		return 0x82226390;
		  /* 82226390h */ case    6:  		/* li R6, 62 */
		/* 82226390h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3E);
		/* 82226390h case    6:*/		return 0x82226394;
		  /* 82226394h */ case    7:  		/* li R5, 0 */
		/* 82226394h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226394h case    7:*/		return 0x82226398;
		  /* 82226398h */ case    8:  		/* mr R28, R3 */
		/* 82226398h case    8:*/		regs.R28 = regs.R3;
		/* 82226398h case    8:*/		return 0x8222639C;
		  /* 8222639Ch */ case    9:  		/* mr R31, R4 */
		/* 8222639Ch case    9:*/		regs.R31 = regs.R4;
		/* 8222639Ch case    9:*/		return 0x822263A0;
		  /* 822263A0h */ case   10:  		/* bl -6664 */
		/* 822263A0h case   10:*/		regs.LR = 0x822263A4; return 0x82224998;
		/* 822263A0h case   10:*/		return 0x822263A4;
		  /* 822263A4h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 822263A4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 822263A4h case   11:*/		return 0x822263A8;
		  /* 822263A8h */ case   12:  		/* mr R30, R3 */
		/* 822263A8h case   12:*/		regs.R30 = regs.R3;
		/* 822263A8h case   12:*/		return 0x822263AC;
		  /* 822263ACh */ case   13:  		/* mr R4, R29 */
		/* 822263ACh case   13:*/		regs.R4 = regs.R29;
		/* 822263ACh case   13:*/		return 0x822263B0;
		  /* 822263B0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 822263B0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822263B0h case   14:*/		return 0x822263B4;
		  /* 822263B4h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 822263B4h case   15:*/		if ( regs.CR[6].eq ) { return 0x822263C8;  }
		/* 822263B4h case   15:*/		return 0x822263B8;
		  /* 822263B8h */ case   16:  		/* mr R3, R28 */
		/* 822263B8h case   16:*/		regs.R3 = regs.R28;
		/* 822263B8h case   16:*/		return 0x822263BC;
		  /* 822263BCh */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 822263BCh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 822263BCh case   17:*/		return 0x822263C0;
		  /* 822263C0h */ case   18:  		/* bl -742096 */
		/* 822263C0h case   18:*/		regs.LR = 0x822263C4; return 0x821710F0;
		/* 822263C0h case   18:*/		return 0x822263C4;
		  /* 822263C4h */ case   19:  		/* mr R4, R3 */
		/* 822263C4h case   19:*/		regs.R4 = regs.R3;
		/* 822263C4h case   19:*/		return 0x822263C8;
	}
	return 0x822263C8;
} // Block from 82226378h-822263C8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822263C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822263C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822263C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822263C8);
		  /* 822263C8h */ case    0:  		/* mr R3, R30 */
		/* 822263C8h case    0:*/		regs.R3 = regs.R30;
		/* 822263C8h case    0:*/		return 0x822263CC;
		  /* 822263CCh */ case    1:  		/* bl -713220 */
		/* 822263CCh case    1:*/		regs.LR = 0x822263D0; return 0x821781C8;
		/* 822263CCh case    1:*/		return 0x822263D0;
		  /* 822263D0h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 822263D0h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 822263D0h case    2:*/		return 0x822263D4;
		  /* 822263D4h */ case    3:  		/* stw R3, <#[R30 + 44]> */
		/* 822263D4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 822263D4h case    3:*/		return 0x822263D8;
		  /* 822263D8h */ case    4:  		/* addi R10, R31, 24 */
		/* 822263D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 822263D8h case    4:*/		return 0x822263DC;
		  /* 822263DCh */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 822263DCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 822263DCh case    5:*/		return 0x822263E0;
		  /* 822263E0h */ case    6:  		/* addi R11, R11, 36 */
		/* 822263E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 822263E0h case    6:*/		return 0x822263E4;
		  /* 822263E4h */ case    7:  		/* stw R9, <#[R11]> */
		/* 822263E4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822263E4h case    7:*/		return 0x822263E8;
		  /* 822263E8h */ case    8:  		/* addi R10, R10, -36 */
		/* 822263E8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 822263E8h case    8:*/		return 0x822263EC;
		  /* 822263ECh */ case    9:  		/* lwz R9, <#[R31 + 24]> */
		/* 822263ECh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 822263ECh case    9:*/		return 0x822263F0;
		  /* 822263F0h */ case   10:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 822263F0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 822263F0h case   10:*/		return 0x822263F4;
		  /* 822263F4h */ case   11:  		/* addi R8, R11, -36 */
		/* 822263F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 822263F4h case   11:*/		return 0x822263F8;
		  /* 822263F8h */ case   12:  		/* ori R7, R10, 1 */
		/* 822263F8h case   12:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 822263F8h case   12:*/		return 0x822263FC;
		  /* 822263FCh */ case   13:  		/* addi R10, R11, 4 */
		/* 822263FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 822263FCh case   13:*/		return 0x82226400;
		  /* 82226400h */ case   14:  		/* stw R8, <#[R9]> */
		/* 82226400h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82226400h case   14:*/		return 0x82226404;
		  /* 82226404h */ case   15:  		/* stw R7, <#[R11 + 4]> */
		/* 82226404h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226404h case   15:*/		return 0x82226408;
		  /* 82226408h */ case   16:  		/* mr R3, R30 */
		/* 82226408h case   16:*/		regs.R3 = regs.R30;
		/* 82226408h case   16:*/		return 0x8222640C;
		  /* 8222640Ch */ case   17:  		/* stw R10, <#[R31 + 24]> */
		/* 8222640Ch case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8222640Ch case   17:*/		return 0x82226410;
		  /* 82226410h */ case   18:  		/* addi R1, R1, 128 */
		/* 82226410h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82226410h case   18:*/		return 0x82226414;
		  /* 82226414h */ case   19:  		/* b -1659244 */
		/* 82226414h case   19:*/		return 0x820912A8;
		/* 82226414h case   19:*/		return 0x82226418;
	}
	return 0x82226418;
} // Block from 822263C8h-82226418h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82226418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226418);
		  /* 82226418h */ case    0:  		/* mfspr R12, LR */
		/* 82226418h case    0:*/		regs.R12 = regs.LR;
		/* 82226418h case    0:*/		return 0x8222641C;
		  /* 8222641Ch */ case    1:  		/* bl -1659336 */
		/* 8222641Ch case    1:*/		regs.LR = 0x82226420; return 0x82091254;
		/* 8222641Ch case    1:*/		return 0x82226420;
		  /* 82226420h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82226420h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82226420h case    2:*/		return 0x82226424;
		  /* 82226424h */ case    3:  		/* mr R30, R5 */
		/* 82226424h case    3:*/		regs.R30 = regs.R5;
		/* 82226424h case    3:*/		return 0x82226428;
		  /* 82226428h */ case    4:  		/* mr R31, R6 */
		/* 82226428h case    4:*/		regs.R31 = regs.R6;
		/* 82226428h case    4:*/		return 0x8222642C;
		  /* 8222642Ch */ case    5:  		/* mr R27, R7 */
		/* 8222642Ch case    5:*/		regs.R27 = regs.R7;
		/* 8222642Ch case    5:*/		return 0x82226430;
		  /* 82226430h */ case    6:  		/* li R8, 4 */
		/* 82226430h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82226430h case    6:*/		return 0x82226434;
		  /* 82226434h */ case    7:  		/* li R7, 2 */
		/* 82226434h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82226434h case    7:*/		return 0x82226438;
		  /* 82226438h */ case    8:  		/* li R6, 97 */
		/* 82226438h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x61);
		/* 82226438h case    8:*/		return 0x8222643C;
		  /* 8222643Ch */ case    9:  		/* li R5, 0 */
		/* 8222643Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222643Ch case    9:*/		return 0x82226440;
		  /* 82226440h */ case   10:  		/* mr R28, R3 */
		/* 82226440h case   10:*/		regs.R28 = regs.R3;
		/* 82226440h case   10:*/		return 0x82226444;
		  /* 82226444h */ case   11:  		/* bl -6828 */
		/* 82226444h case   11:*/		regs.LR = 0x82226448; return 0x82224998;
		/* 82226444h case   11:*/		return 0x82226448;
		  /* 82226448h */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 82226448h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82226448h case   12:*/		return 0x8222644C;
		  /* 8222644Ch */ case   13:  		/* mr R29, R3 */
		/* 8222644Ch case   13:*/		regs.R29 = regs.R3;
		/* 8222644Ch case   13:*/		return 0x82226450;
		  /* 82226450h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82226450h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226450h case   14:*/		return 0x82226454;
		  /* 82226454h */ case   15:  		/* mr R4, R31 */
		/* 82226454h case   15:*/		regs.R4 = regs.R31;
		/* 82226454h case   15:*/		return 0x82226458;
		  /* 82226458h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 82226458h case   16:*/		if ( regs.CR[6].eq ) { return 0x8222646C;  }
		/* 82226458h case   16:*/		return 0x8222645C;
		  /* 8222645Ch */ case   17:  		/* mr R3, R28 */
		/* 8222645Ch case   17:*/		regs.R3 = regs.R28;
		/* 8222645Ch case   17:*/		return 0x82226460;
	}
	return 0x82226460;
} // Block from 82226418h-82226460h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82226460h
// Function '?GetOrCreatePHI@Compiler@D3DXShader@@QAA?AVResult@2@PAVBlock@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226460);
		  /* 82226460h */ case    0:  		/* lwz R5, <#[R31 + 12]> */
		/* 82226460h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82226460h case    0:*/		return 0x82226464;
		  /* 82226464h */ case    1:  		/* bl -742260 */
		/* 82226464h case    1:*/		regs.LR = 0x82226468; return 0x821710F0;
		/* 82226464h case    1:*/		return 0x82226468;
		  /* 82226468h */ case    2:  		/* mr R4, R3 */
		/* 82226468h case    2:*/		regs.R4 = regs.R3;
		/* 82226468h case    2:*/		return 0x8222646C;
	}
	return 0x8222646C;
} // Block from 82226460h-8222646Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222646Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222646C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222646C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222646C);
		  /* 8222646Ch */ case    0:  		/* mr R3, R29 */
		/* 8222646Ch case    0:*/		regs.R3 = regs.R29;
		/* 8222646Ch case    0:*/		return 0x82226470;
		  /* 82226470h */ case    1:  		/* bl -713384 */
		/* 82226470h case    1:*/		regs.LR = 0x82226474; return 0x821781C8;
		/* 82226470h case    1:*/		return 0x82226474;
		  /* 82226474h */ case    2:  		/* stw R3, <#[R29 + 44]> */
		/* 82226474h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 82226474h case    2:*/		return 0x82226478;
		  /* 82226478h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 82226478h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82226478h case    3:*/		return 0x8222647C;
		  /* 8222647Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8222647Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222647Ch case    4:*/		return 0x82226480;
		  /* 82226480h */ case    5:  		/* mr R4, R27 */
		/* 82226480h case    5:*/		regs.R4 = regs.R27;
		/* 82226480h case    5:*/		return 0x82226484;
		  /* 82226484h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82226484h case    6:*/		if ( regs.CR[6].eq ) { return 0x82226498;  }
		/* 82226484h case    6:*/		return 0x82226488;
		  /* 82226488h */ case    7:  		/* mr R3, R28 */
		/* 82226488h case    7:*/		regs.R3 = regs.R28;
		/* 82226488h case    7:*/		return 0x8222648C;
		  /* 8222648Ch */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 8222648Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 8222648Ch case    8:*/		return 0x82226490;
		  /* 82226490h */ case    9:  		/* bl -742304 */
		/* 82226490h case    9:*/		regs.LR = 0x82226494; return 0x821710F0;
		/* 82226490h case    9:*/		return 0x82226494;
		  /* 82226494h */ case   10:  		/* mr R4, R3 */
		/* 82226494h case   10:*/		regs.R4 = regs.R3;
		/* 82226494h case   10:*/		return 0x82226498;
	}
	return 0x82226498;
} // Block from 8222646Ch-82226498h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82226498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226498);
		  /* 82226498h */ case    0:  		/* mr R3, R29 */
		/* 82226498h case    0:*/		regs.R3 = regs.R29;
		/* 82226498h case    0:*/		return 0x8222649C;
		  /* 8222649Ch */ case    1:  		/* bl -713428 */
		/* 8222649Ch case    1:*/		regs.LR = 0x822264A0; return 0x821781C8;
		/* 8222649Ch case    1:*/		return 0x822264A0;
		  /* 822264A0h */ case    2:  		/* stw R3, <#[R29 + 48]> */
		/* 822264A0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 822264A0h case    2:*/		return 0x822264A4;
		  /* 822264A4h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 822264A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822264A4h case    3:*/		return 0x822264A8;
		  /* 822264A8h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 822264A8h case    4:*/		if ( regs.CR[6].eq ) { return 0x822264E0;  }
		/* 822264A8h case    4:*/		return 0x822264AC;
		  /* 822264ACh */ case    5:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 822264ACh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 822264ACh case    5:*/		return 0x822264B0;
		  /* 822264B0h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 822264B0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 822264B0h case    6:*/		return 0x822264B4;
		  /* 822264B4h */ case    7:  		/* addi R10, R30, -36 */
		/* 822264B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFDC);
		/* 822264B4h case    7:*/		return 0x822264B8;
		  /* 822264B8h */ case    8:  		/* addi R11, R11, 36 */
		/* 822264B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 822264B8h case    8:*/		return 0x822264BC;
		  /* 822264BCh */ case    9:  		/* ori R8, R10, 1 */
		/* 822264BCh case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 822264BCh case    9:*/		return 0x822264C0;
		  /* 822264C0h */ case   10:  		/* addi R7, R11, -36 */
		/* 822264C0h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 822264C0h case   10:*/		return 0x822264C4;
		  /* 822264C4h */ case   11:  		/* addi R10, R11, 4 */
		/* 822264C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 822264C4h case   11:*/		return 0x822264C8;
		  /* 822264C8h */ case   12:  		/* stw R9, <#[R11]> */
		/* 822264C8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822264C8h case   12:*/		return 0x822264CC;
		  /* 822264CCh */ case   13:  		/* lwz R9, <#[R30]> */
		/* 822264CCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 822264CCh case   13:*/		return 0x822264D0;
		  /* 822264D0h */ case   14:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 822264D0h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 822264D0h case   14:*/		return 0x822264D4;
		  /* 822264D4h */ case   15:  		/* stw R7, <#[R9]> */
		/* 822264D4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 822264D4h case   15:*/		return 0x822264D8;
		  /* 822264D8h */ case   16:  		/* stw R8, <#[R11 + 4]> */
		/* 822264D8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 822264D8h case   16:*/		return 0x822264DC;
		  /* 822264DCh */ case   17:  		/* stw R10, <#[R30]> */
		/* 822264DCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822264DCh case   17:*/		return 0x822264E0;
	}
	return 0x822264E0;
} // Block from 82226498h-822264E0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 822264E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822264E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822264E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822264E0);
		  /* 822264E0h */ case    0:  		/* mr R3, R29 */
		/* 822264E0h case    0:*/		regs.R3 = regs.R29;
		/* 822264E0h case    0:*/		return 0x822264E4;
		  /* 822264E4h */ case    1:  		/* addi R1, R1, 128 */
		/* 822264E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822264E4h case    1:*/		return 0x822264E8;
		  /* 822264E8h */ case    2:  		/* b -1659460 */
		/* 822264E8h case    2:*/		return 0x820912A4;
		/* 822264E8h case    2:*/		return 0x822264EC;
		  /* 822264ECh */ case    3:  		/* nop */
		/* 822264ECh case    3:*/		cpu::op::nop();
		/* 822264ECh case    3:*/		return 0x822264F0;
	}
	return 0x822264F0;
} // Block from 822264E0h-822264F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822264F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822264F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822264F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822264F0);
		  /* 822264F0h */ case    0:  		/* mfspr R12, LR */
		/* 822264F0h case    0:*/		regs.R12 = regs.LR;
		/* 822264F0h case    0:*/		return 0x822264F4;
		  /* 822264F4h */ case    1:  		/* bl -1659552 */
		/* 822264F4h case    1:*/		regs.LR = 0x822264F8; return 0x82091254;
		/* 822264F4h case    1:*/		return 0x822264F8;
		  /* 822264F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822264F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822264F8h case    2:*/		return 0x822264FC;
		  /* 822264FCh */ case    3:  		/* mr R27, R5 */
		/* 822264FCh case    3:*/		regs.R27 = regs.R5;
		/* 822264FCh case    3:*/		return 0x82226500;
		  /* 82226500h */ case    4:  		/* mr R29, R6 */
		/* 82226500h case    4:*/		regs.R29 = regs.R6;
		/* 82226500h case    4:*/		return 0x82226504;
		  /* 82226504h */ case    5:  		/* li R8, 4 */
		/* 82226504h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82226504h case    5:*/		return 0x82226508;
		  /* 82226508h */ case    6:  		/* li R7, 2 */
		/* 82226508h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82226508h case    6:*/		return 0x8222650C;
		  /* 8222650Ch */ case    7:  		/* li R6, 1 */
		/* 8222650Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8222650Ch case    7:*/		return 0x82226510;
		  /* 82226510h */ case    8:  		/* li R5, 0 */
		/* 82226510h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226510h case    8:*/		return 0x82226514;
		  /* 82226514h */ case    9:  		/* mr R28, R3 */
		/* 82226514h case    9:*/		regs.R28 = regs.R3;
		/* 82226514h case    9:*/		return 0x82226518;
		  /* 82226518h */ case   10:  		/* mr R30, R4 */
		/* 82226518h case   10:*/		regs.R30 = regs.R4;
		/* 82226518h case   10:*/		return 0x8222651C;
		  /* 8222651Ch */ case   11:  		/* bl -7044 */
		/* 8222651Ch case   11:*/		regs.LR = 0x82226520; return 0x82224998;
		/* 8222651Ch case   11:*/		return 0x82226520;
		  /* 82226520h */ case   12:  		/* mr R31, R3 */
		/* 82226520h case   12:*/		regs.R31 = regs.R3;
		/* 82226520h case   12:*/		return 0x82226524;
		  /* 82226524h */ case   13:  		/* mr R4, R27 */
		/* 82226524h case   13:*/		regs.R4 = regs.R27;
		/* 82226524h case   13:*/		return 0x82226528;
		  /* 82226528h */ case   14:  		/* mr R3, R28 */
		/* 82226528h case   14:*/		regs.R3 = regs.R28;
		/* 82226528h case   14:*/		return 0x8222652C;
		  /* 8222652Ch */ case   15:  		/* bl -714028 */
		/* 8222652Ch case   15:*/		regs.LR = 0x82226530; return 0x82178000;
		/* 8222652Ch case   15:*/		return 0x82226530;
		  /* 82226530h */ case   16:  		/* mr R4, R3 */
		/* 82226530h case   16:*/		regs.R4 = regs.R3;
		/* 82226530h case   16:*/		return 0x82226534;
		  /* 82226534h */ case   17:  		/* mr R3, R31 */
		/* 82226534h case   17:*/		regs.R3 = regs.R31;
		/* 82226534h case   17:*/		return 0x82226538;
		  /* 82226538h */ case   18:  		/* bl -713584 */
		/* 82226538h case   18:*/		regs.LR = 0x8222653C; return 0x821781C8;
		/* 82226538h case   18:*/		return 0x8222653C;
		  /* 8222653Ch */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 8222653Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8222653Ch case   19:*/		return 0x82226540;
		  /* 82226540h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 82226540h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82226540h case   20:*/		return 0x82226544;
		  /* 82226544h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 82226544h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226544h case   21:*/		return 0x82226548;
		  /* 82226548h */ case   22:  		/* mr R4, R29 */
		/* 82226548h case   22:*/		regs.R4 = regs.R29;
		/* 82226548h case   22:*/		return 0x8222654C;
		  /* 8222654Ch */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 8222654Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82226560;  }
		/* 8222654Ch case   23:*/		return 0x82226550;
		  /* 82226550h */ case   24:  		/* mr R3, R28 */
		/* 82226550h case   24:*/		regs.R3 = regs.R28;
		/* 82226550h case   24:*/		return 0x82226554;
		  /* 82226554h */ case   25:  		/* lwz R5, <#[R29 + 12]> */
		/* 82226554h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 82226554h case   25:*/		return 0x82226558;
		  /* 82226558h */ case   26:  		/* bl -742504 */
		/* 82226558h case   26:*/		regs.LR = 0x8222655C; return 0x821710F0;
		/* 82226558h case   26:*/		return 0x8222655C;
		  /* 8222655Ch */ case   27:  		/* mr R4, R3 */
		/* 8222655Ch case   27:*/		regs.R4 = regs.R3;
		/* 8222655Ch case   27:*/		return 0x82226560;
	}
	return 0x82226560;
} // Block from 822264F0h-82226560h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82226560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226560);
		  /* 82226560h */ case    0:  		/* mr R3, R31 */
		/* 82226560h case    0:*/		regs.R3 = regs.R31;
		/* 82226560h case    0:*/		return 0x82226564;
		  /* 82226564h */ case    1:  		/* bl -713628 */
		/* 82226564h case    1:*/		regs.LR = 0x82226568; return 0x821781C8;
		/* 82226564h case    1:*/		return 0x82226568;
		  /* 82226568h */ case    2:  		/* lwz R9, <#[R31 + 44]> */
		/* 82226568h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000002C) );
		/* 82226568h case    2:*/		return 0x8222656C;
		  /* 8222656Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 8222656Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8222656Ch case    3:*/		return 0x82226570;
		  /* 82226570h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82226570h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82226570h case    4:*/		return 0x82226574;
		  /* 82226574h */ case    5:  		/* lwz R8, <#[R31 + 8]> */
		/* 82226574h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82226574h case    5:*/		return 0x82226578;
		  /* 82226578h */ case    6:  		/* addi R10, R30, 24 */
		/* 82226578h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x18);
		/* 82226578h case    6:*/		return 0x8222657C;
		  /* 8222657Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 8222657Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8222657Ch case    7:*/		return 0x82226580;
		  /* 82226580h */ case    8:  		/* addi R10, R10, -36 */
		/* 82226580h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82226580h case    8:*/		return 0x82226584;
		  /* 82226584h */ case    9:  		/* lwz R9, <#[R9]> */
		/* 82226584h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82226584h case    9:*/		return 0x82226588;
		  /* 82226588h */ case   10:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 82226588h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 82226588h case   10:*/		return 0x8222658C;
		  /* 8222658Ch */ case   11:  		/* rlwimi R8, R9, 14, 15, 17 */
		/* 8222658Ch case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R8,regs.R9);
		/* 8222658Ch case   11:*/		return 0x82226590;
		  /* 82226590h */ case   12:  		/* addi R9, R11, -36 */
		/* 82226590h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 82226590h case   12:*/		return 0x82226594;
		  /* 82226594h */ case   13:  		/* stw R8, <#[R31 + 8]> */
		/* 82226594h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82226594h case   13:*/		return 0x82226598;
		  /* 82226598h */ case   14:  		/* ori R8, R10, 1 */
		/* 82226598h case   14:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82226598h case   14:*/		return 0x8222659C;
		  /* 8222659Ch */ case   15:  		/* lwz R7, <#[R30 + 24]> */
		/* 8222659Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000018) );
		/* 8222659Ch case   15:*/		return 0x822265A0;
		  /* 822265A0h */ case   16:  		/* addi R10, R11, 4 */
		/* 822265A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 822265A0h case   16:*/		return 0x822265A4;
		  /* 822265A4h */ case   17:  		/* stw R7, <#[R11]> */
		/* 822265A4h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 822265A4h case   17:*/		return 0x822265A8;
		  /* 822265A8h */ case   18:  		/* mr R3, R31 */
		/* 822265A8h case   18:*/		regs.R3 = regs.R31;
		/* 822265A8h case   18:*/		return 0x822265AC;
		  /* 822265ACh */ case   19:  		/* lwz R7, <#[R30 + 24]> */
		/* 822265ACh case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000018) );
		/* 822265ACh case   19:*/		return 0x822265B0;
		  /* 822265B0h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 822265B0h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 822265B0h case   20:*/		return 0x822265B4;
		  /* 822265B4h */ case   21:  		/* stw R9, <#[R7]> */
		/* 822265B4h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 822265B4h case   21:*/		return 0x822265B8;
		  /* 822265B8h */ case   22:  		/* stw R8, <#[R11 + 4]> */
		/* 822265B8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 822265B8h case   22:*/		return 0x822265BC;
		  /* 822265BCh */ case   23:  		/* stw R10, <#[R30 + 24]> */
		/* 822265BCh case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 822265BCh case   23:*/		return 0x822265C0;
		  /* 822265C0h */ case   24:  		/* addi R1, R1, 128 */
		/* 822265C0h case   24:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822265C0h case   24:*/		return 0x822265C4;
		  /* 822265C4h */ case   25:  		/* b -1659680 */
		/* 822265C4h case   25:*/		return 0x820912A4;
		/* 822265C4h case   25:*/		return 0x822265C8;
	}
	return 0x822265C8;
} // Block from 82226560h-822265C8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822265C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822265C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822265C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822265C8);
		  /* 822265C8h */ case    0:  		/* mfspr R12, LR */
		/* 822265C8h case    0:*/		regs.R12 = regs.LR;
		/* 822265C8h case    0:*/		return 0x822265CC;
		  /* 822265CCh */ case    1:  		/* bl -1659764 */
		/* 822265CCh case    1:*/		regs.LR = 0x822265D0; return 0x82091258;
		/* 822265CCh case    1:*/		return 0x822265D0;
		  /* 822265D0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822265D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822265D0h case    2:*/		return 0x822265D4;
		  /* 822265D4h */ case    3:  		/* mr R29, R5 */
		/* 822265D4h case    3:*/		regs.R29 = regs.R5;
		/* 822265D4h case    3:*/		return 0x822265D8;
		  /* 822265D8h */ case    4:  		/* std R6, <#[R1 + 168]> */
		/* 822265D8h case    4:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x000000A8) );
		/* 822265D8h case    4:*/		return 0x822265DC;
		  /* 822265DCh */ case    5:  		/* li R8, 4 */
		/* 822265DCh case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 822265DCh case    5:*/		return 0x822265E0;
		  /* 822265E0h */ case    6:  		/* li R7, 2 */
		/* 822265E0h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 822265E0h case    6:*/		return 0x822265E4;
		  /* 822265E4h */ case    7:  		/* li R6, 2 */
		/* 822265E4h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 822265E4h case    7:*/		return 0x822265E8;
		  /* 822265E8h */ case    8:  		/* li R5, 0 */
		/* 822265E8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822265E8h case    8:*/		return 0x822265EC;
		  /* 822265ECh */ case    9:  		/* mr R30, R3 */
		/* 822265ECh case    9:*/		regs.R30 = regs.R3;
		/* 822265ECh case    9:*/		return 0x822265F0;
		  /* 822265F0h */ case   10:  		/* mr R31, R4 */
		/* 822265F0h case   10:*/		regs.R31 = regs.R4;
		/* 822265F0h case   10:*/		return 0x822265F4;
		  /* 822265F4h */ case   11:  		/* bl -7260 */
		/* 822265F4h case   11:*/		regs.LR = 0x822265F8; return 0x82224998;
		/* 822265F4h case   11:*/		return 0x822265F8;
		  /* 822265F8h */ case   12:  		/* mr R28, R3 */
		/* 822265F8h case   12:*/		regs.R28 = regs.R3;
		/* 822265F8h case   12:*/		return 0x822265FC;
		  /* 822265FCh */ case   13:  		/* mr R3, R30 */
		/* 822265FCh case   13:*/		regs.R3 = regs.R30;
		/* 822265FCh case   13:*/		return 0x82226600;
		  /* 82226600h */ case   14:  		/* mr R4, R29 */
		/* 82226600h case   14:*/		regs.R4 = regs.R29;
		/* 82226600h case   14:*/		return 0x82226604;
		  /* 82226604h */ case   15:  		/* bl -714244 */
		/* 82226604h case   15:*/		regs.LR = 0x82226608; return 0x82178000;
		/* 82226604h case   15:*/		return 0x82226608;
		  /* 82226608h */ case   16:  		/* mr R4, R3 */
		/* 82226608h case   16:*/		regs.R4 = regs.R3;
		/* 82226608h case   16:*/		return 0x8222660C;
		  /* 8222660Ch */ case   17:  		/* mr R3, R28 */
		/* 8222660Ch case   17:*/		regs.R3 = regs.R28;
		/* 8222660Ch case   17:*/		return 0x82226610;
		  /* 82226610h */ case   18:  		/* bl -713800 */
		/* 82226610h case   18:*/		regs.LR = 0x82226614; return 0x821781C8;
		/* 82226610h case   18:*/		return 0x82226614;
		  /* 82226614h */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 82226614h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 82226614h case   19:*/		return 0x82226618;
		  /* 82226618h */ case   20:  		/* addi R4, R1, 168 */
		/* 82226618h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA8);
		/* 82226618h case   20:*/		return 0x8222661C;
		  /* 8222661Ch */ case   21:  		/* mr R3, R30 */
		/* 8222661Ch case   21:*/		regs.R3 = regs.R30;
		/* 8222661Ch case   21:*/		return 0x82226620;
		  /* 82226620h */ case   22:  		/* bl -213664 */
		/* 82226620h case   22:*/		regs.LR = 0x82226624; return 0x821F2380;
		/* 82226620h case   22:*/		return 0x82226624;
		  /* 82226624h */ case   23:  		/* mr R4, R3 */
		/* 82226624h case   23:*/		regs.R4 = regs.R3;
		/* 82226624h case   23:*/		return 0x82226628;
		  /* 82226628h */ case   24:  		/* mr R3, R28 */
		/* 82226628h case   24:*/		regs.R3 = regs.R28;
		/* 82226628h case   24:*/		return 0x8222662C;
		  /* 8222662Ch */ case   25:  		/* bl -713828 */
		/* 8222662Ch case   25:*/		regs.LR = 0x82226630; return 0x821781C8;
		/* 8222662Ch case   25:*/		return 0x82226630;
		  /* 82226630h */ case   26:  		/* lwz R9, <#[R28 + 44]> */
		/* 82226630h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000002C) );
		/* 82226630h case   26:*/		return 0x82226634;
		  /* 82226634h */ case   27:  		/* stw R3, <#[R28 + 48]> */
		/* 82226634h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 82226634h case   27:*/		return 0x82226638;
		  /* 82226638h */ case   28:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82226638h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82226638h case   28:*/		return 0x8222663C;
		  /* 8222663Ch */ case   29:  		/* lwz R8, <#[R28 + 8]> */
		/* 8222663Ch case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000008) );
		/* 8222663Ch case   29:*/		return 0x82226640;
		  /* 82226640h */ case   30:  		/* addi R10, R31, 24 */
		/* 82226640h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 82226640h case   30:*/		return 0x82226644;
		  /* 82226644h */ case   31:  		/* addi R11, R11, 36 */
		/* 82226644h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226644h case   31:*/		return 0x82226648;
		  /* 82226648h */ case   32:  		/* addi R10, R10, -36 */
		/* 82226648h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82226648h case   32:*/		return 0x8222664C;
		  /* 8222664Ch */ case   33:  		/* lwz R9, <#[R9]> */
		/* 8222664Ch case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8222664Ch case   33:*/		return 0x82226650;
		  /* 82226650h */ case   34:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 82226650h case   34:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 82226650h case   34:*/		return 0x82226654;
		  /* 82226654h */ case   35:  		/* rlwimi R8, R9, 14, 15, 17 */
		/* 82226654h case   35:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R8,regs.R9);
		/* 82226654h case   35:*/		return 0x82226658;
		  /* 82226658h */ case   36:  		/* addi R9, R11, -36 */
		/* 82226658h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 82226658h case   36:*/		return 0x8222665C;
		  /* 8222665Ch */ case   37:  		/* stw R8, <#[R28 + 8]> */
		/* 8222665Ch case   37:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R28 + 0x00000008) );
		/* 8222665Ch case   37:*/		return 0x82226660;
		  /* 82226660h */ case   38:  		/* ori R8, R10, 1 */
		/* 82226660h case   38:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82226660h case   38:*/		return 0x82226664;
		  /* 82226664h */ case   39:  		/* lwz R7, <#[R31 + 24]> */
		/* 82226664h case   39:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 82226664h case   39:*/		return 0x82226668;
		  /* 82226668h */ case   40:  		/* addi R10, R11, 4 */
		/* 82226668h case   40:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82226668h case   40:*/		return 0x8222666C;
		  /* 8222666Ch */ case   41:  		/* stw R7, <#[R11]> */
		/* 8222666Ch case   41:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8222666Ch case   41:*/		return 0x82226670;
		  /* 82226670h */ case   42:  		/* mr R3, R28 */
		/* 82226670h case   42:*/		regs.R3 = regs.R28;
		/* 82226670h case   42:*/		return 0x82226674;
		  /* 82226674h */ case   43:  		/* lwz R7, <#[R31 + 24]> */
		/* 82226674h case   43:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 82226674h case   43:*/		return 0x82226678;
		  /* 82226678h */ case   44:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82226678h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82226678h case   44:*/		return 0x8222667C;
		  /* 8222667Ch */ case   45:  		/* stw R9, <#[R7]> */
		/* 8222667Ch case   45:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 8222667Ch case   45:*/		return 0x82226680;
		  /* 82226680h */ case   46:  		/* stw R8, <#[R11 + 4]> */
		/* 82226680h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82226680h case   46:*/		return 0x82226684;
		  /* 82226684h */ case   47:  		/* stw R10, <#[R31 + 24]> */
		/* 82226684h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82226684h case   47:*/		return 0x82226688;
		  /* 82226688h */ case   48:  		/* addi R1, R1, 128 */
		/* 82226688h case   48:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82226688h case   48:*/		return 0x8222668C;
		  /* 8222668Ch */ case   49:  		/* b -1659876 */
		/* 8222668Ch case   49:*/		return 0x820912A8;
		/* 8222668Ch case   49:*/		return 0x82226690;
	}
	return 0x82226690;
} // Block from 822265C8h-82226690h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82226690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226690);
		  /* 82226690h */ case    0:  		/* mfspr R12, LR */
		/* 82226690h case    0:*/		regs.R12 = regs.LR;
		/* 82226690h case    0:*/		return 0x82226694;
		  /* 82226694h */ case    1:  		/* bl -1659964 */
		/* 82226694h case    1:*/		regs.LR = 0x82226698; return 0x82091258;
		/* 82226694h case    1:*/		return 0x82226698;
		  /* 82226698h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82226698h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82226698h case    2:*/		return 0x8222669C;
		  /* 8222669Ch */ case    3:  		/* mr R29, R5 */
		/* 8222669Ch case    3:*/		regs.R29 = regs.R5;
		/* 8222669Ch case    3:*/		return 0x822266A0;
		  /* 822266A0h */ case    4:  		/* std R6, <#[R1 + 168]> */
		/* 822266A0h case    4:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x000000A8) );
		/* 822266A0h case    4:*/		return 0x822266A4;
		  /* 822266A4h */ case    5:  		/* li R8, 4 */
		/* 822266A4h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 822266A4h case    5:*/		return 0x822266A8;
		  /* 822266A8h */ case    6:  		/* li R7, 2 */
		/* 822266A8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 822266A8h case    6:*/		return 0x822266AC;
		  /* 822266ACh */ case    7:  		/* li R6, 7 */
		/* 822266ACh case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 822266ACh case    7:*/		return 0x822266B0;
		  /* 822266B0h */ case    8:  		/* li R5, 0 */
		/* 822266B0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822266B0h case    8:*/		return 0x822266B4;
		  /* 822266B4h */ case    9:  		/* mr R30, R3 */
		/* 822266B4h case    9:*/		regs.R30 = regs.R3;
		/* 822266B4h case    9:*/		return 0x822266B8;
		  /* 822266B8h */ case   10:  		/* mr R31, R4 */
		/* 822266B8h case   10:*/		regs.R31 = regs.R4;
		/* 822266B8h case   10:*/		return 0x822266BC;
		  /* 822266BCh */ case   11:  		/* bl -7460 */
		/* 822266BCh case   11:*/		regs.LR = 0x822266C0; return 0x82224998;
		/* 822266BCh case   11:*/		return 0x822266C0;
		  /* 822266C0h */ case   12:  		/* mr R28, R3 */
		/* 822266C0h case   12:*/		regs.R28 = regs.R3;
		/* 822266C0h case   12:*/		return 0x822266C4;
		  /* 822266C4h */ case   13:  		/* mr R3, R30 */
		/* 822266C4h case   13:*/		regs.R3 = regs.R30;
		/* 822266C4h case   13:*/		return 0x822266C8;
		  /* 822266C8h */ case   14:  		/* mr R4, R29 */
		/* 822266C8h case   14:*/		regs.R4 = regs.R29;
		/* 822266C8h case   14:*/		return 0x822266CC;
		  /* 822266CCh */ case   15:  		/* bl -714444 */
		/* 822266CCh case   15:*/		regs.LR = 0x822266D0; return 0x82178000;
		/* 822266CCh case   15:*/		return 0x822266D0;
		  /* 822266D0h */ case   16:  		/* mr R4, R3 */
		/* 822266D0h case   16:*/		regs.R4 = regs.R3;
		/* 822266D0h case   16:*/		return 0x822266D4;
		  /* 822266D4h */ case   17:  		/* mr R3, R28 */
		/* 822266D4h case   17:*/		regs.R3 = regs.R28;
		/* 822266D4h case   17:*/		return 0x822266D8;
		  /* 822266D8h */ case   18:  		/* bl -714000 */
		/* 822266D8h case   18:*/		regs.LR = 0x822266DC; return 0x821781C8;
		/* 822266D8h case   18:*/		return 0x822266DC;
		  /* 822266DCh */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 822266DCh case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 822266DCh case   19:*/		return 0x822266E0;
		  /* 822266E0h */ case   20:  		/* addi R4, R1, 168 */
		/* 822266E0h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA8);
		/* 822266E0h case   20:*/		return 0x822266E4;
		  /* 822266E4h */ case   21:  		/* mr R3, R30 */
		/* 822266E4h case   21:*/		regs.R3 = regs.R30;
		/* 822266E4h case   21:*/		return 0x822266E8;
		  /* 822266E8h */ case   22:  		/* bl -213864 */
		/* 822266E8h case   22:*/		regs.LR = 0x822266EC; return 0x821F2380;
		/* 822266E8h case   22:*/		return 0x822266EC;
		  /* 822266ECh */ case   23:  		/* mr R4, R3 */
		/* 822266ECh case   23:*/		regs.R4 = regs.R3;
		/* 822266ECh case   23:*/		return 0x822266F0;
		  /* 822266F0h */ case   24:  		/* mr R3, R28 */
		/* 822266F0h case   24:*/		regs.R3 = regs.R28;
		/* 822266F0h case   24:*/		return 0x822266F4;
		  /* 822266F4h */ case   25:  		/* bl -714028 */
		/* 822266F4h case   25:*/		regs.LR = 0x822266F8; return 0x821781C8;
		/* 822266F4h case   25:*/		return 0x822266F8;
		  /* 822266F8h */ case   26:  		/* lwz R9, <#[R28 + 44]> */
		/* 822266F8h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000002C) );
		/* 822266F8h case   26:*/		return 0x822266FC;
		  /* 822266FCh */ case   27:  		/* stw R3, <#[R28 + 48]> */
		/* 822266FCh case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 822266FCh case   27:*/		return 0x82226700;
		  /* 82226700h */ case   28:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82226700h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82226700h case   28:*/		return 0x82226704;
		  /* 82226704h */ case   29:  		/* lwz R8, <#[R28 + 8]> */
		/* 82226704h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000008) );
		/* 82226704h case   29:*/		return 0x82226708;
		  /* 82226708h */ case   30:  		/* addi R10, R31, 24 */
		/* 82226708h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 82226708h case   30:*/		return 0x8222670C;
		  /* 8222670Ch */ case   31:  		/* addi R11, R11, 36 */
		/* 8222670Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8222670Ch case   31:*/		return 0x82226710;
		  /* 82226710h */ case   32:  		/* addi R10, R10, -36 */
		/* 82226710h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 82226710h case   32:*/		return 0x82226714;
		  /* 82226714h */ case   33:  		/* lwz R9, <#[R9]> */
		/* 82226714h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82226714h case   33:*/		return 0x82226718;
		  /* 82226718h */ case   34:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 82226718h case   34:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 82226718h case   34:*/		return 0x8222671C;
		  /* 8222671Ch */ case   35:  		/* rlwimi R8, R9, 14, 15, 17 */
		/* 8222671Ch case   35:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R8,regs.R9);
		/* 8222671Ch case   35:*/		return 0x82226720;
		  /* 82226720h */ case   36:  		/* addi R9, R11, -36 */
		/* 82226720h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 82226720h case   36:*/		return 0x82226724;
		  /* 82226724h */ case   37:  		/* stw R8, <#[R28 + 8]> */
		/* 82226724h case   37:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R28 + 0x00000008) );
		/* 82226724h case   37:*/		return 0x82226728;
		  /* 82226728h */ case   38:  		/* ori R8, R10, 1 */
		/* 82226728h case   38:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 82226728h case   38:*/		return 0x8222672C;
		  /* 8222672Ch */ case   39:  		/* lwz R7, <#[R31 + 24]> */
		/* 8222672Ch case   39:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 8222672Ch case   39:*/		return 0x82226730;
	}
	return 0x82226730;
} // Block from 82226690h-82226730h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82226730h
// Function '?HasIdenticalDependencies@Instruction@D3DXShader@@QAA_NPAV12@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226730);
		  /* 82226730h */ case    0:  		/* addi R10, R11, 4 */
		/* 82226730h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82226730h case    0:*/		return 0x82226734;
		  /* 82226734h */ case    1:  		/* stw R7, <#[R11]> */
		/* 82226734h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82226734h case    1:*/		return 0x82226738;
		  /* 82226738h */ case    2:  		/* mr R3, R28 */
		/* 82226738h case    2:*/		regs.R3 = regs.R28;
		/* 82226738h case    2:*/		return 0x8222673C;
		  /* 8222673Ch */ case    3:  		/* lwz R7, <#[R31 + 24]> */
		/* 8222673Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 8222673Ch case    3:*/		return 0x82226740;
		  /* 82226740h */ case    4:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82226740h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82226740h case    4:*/		return 0x82226744;
		  /* 82226744h */ case    5:  		/* stw R9, <#[R7]> */
		/* 82226744h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 82226744h case    5:*/		return 0x82226748;
		  /* 82226748h */ case    6:  		/* stw R8, <#[R11 + 4]> */
		/* 82226748h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82226748h case    6:*/		return 0x8222674C;
		  /* 8222674Ch */ case    7:  		/* stw R10, <#[R31 + 24]> */
		/* 8222674Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8222674Ch case    7:*/		return 0x82226750;
		  /* 82226750h */ case    8:  		/* addi R1, R1, 128 */
		/* 82226750h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82226750h case    8:*/		return 0x82226754;
		  /* 82226754h */ case    9:  		/* b -1660076 */
		/* 82226754h case    9:*/		return 0x820912A8;
		/* 82226754h case    9:*/		return 0x82226758;
	}
	return 0x82226758;
} // Block from 82226730h-82226758h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82226758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226758);
		  /* 82226758h */ case    0:  		/* mfspr R12, LR */
		/* 82226758h case    0:*/		regs.R12 = regs.LR;
		/* 82226758h case    0:*/		return 0x8222675C;
		  /* 8222675Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222675Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222675Ch case    1:*/		return 0x82226760;
		  /* 82226760h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82226760h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82226760h case    2:*/		return 0x82226764;
		  /* 82226764h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82226764h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82226764h case    3:*/		return 0x82226768;
		  /* 82226768h */ case    4:  		/* mr R31, R3 */
		/* 82226768h case    4:*/		regs.R31 = regs.R3;
		/* 82226768h case    4:*/		return 0x8222676C;
		  /* 8222676Ch */ case    5:  		/* rlwinm R4, R3, 30, 30, 31 */
		/* 8222676Ch case    5:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R4,regs.R3);
		/* 8222676Ch case    5:*/		return 0x82226770;
		  /* 82226770h */ case    6:  		/* rlwinm R3, R3, 0, 30, 31 */
		/* 82226770h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R3);
		/* 82226770h case    6:*/		return 0x82226774;
		  /* 82226774h */ case    7:  		/* bl -430004 */
		/* 82226774h case    7:*/		regs.LR = 0x82226778; return 0x821BD7C0;
		/* 82226774h case    7:*/		return 0x82226778;
		  /* 82226778h */ case    8:  		/* rlwinm R4, R31, 28, 30, 31 */
		/* 82226778h case    8:*/		cpu::op::rlwinm<0,28,30,31>(regs,&regs.R4,regs.R31);
		/* 82226778h case    8:*/		return 0x8222677C;
		  /* 8222677Ch */ case    9:  		/* bl -430012 */
		/* 8222677Ch case    9:*/		regs.LR = 0x82226780; return 0x821BD7C0;
		/* 8222677Ch case    9:*/		return 0x82226780;
		  /* 82226780h */ case   10:  		/* rlwinm R4, R31, 26, 30, 31 */
		/* 82226780h case   10:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R4,regs.R31);
		/* 82226780h case   10:*/		return 0x82226784;
		  /* 82226784h */ case   11:  		/* bl -430020 */
		/* 82226784h case   11:*/		regs.LR = 0x82226788; return 0x821BD7C0;
		/* 82226784h case   11:*/		return 0x82226788;
		  /* 82226788h */ case   12:  		/* addi R1, R1, 96 */
		/* 82226788h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82226788h case   12:*/		return 0x8222678C;
		  /* 8222678Ch */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222678Ch case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222678Ch case   13:*/		return 0x82226790;
		  /* 82226790h */ case   14:  		/* mtspr LR, R12 */
		/* 82226790h case   14:*/		regs.LR = regs.R12;
		/* 82226790h case   14:*/		return 0x82226794;
		  /* 82226794h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82226794h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82226794h case   15:*/		return 0x82226798;
		  /* 82226798h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82226798h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82226798h case   16:*/		return 0x8222679C;
	}
	return 0x8222679C;
} // Block from 82226758h-8222679Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8222679Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222679C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222679C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222679C);
		  /* 8222679Ch */ case    0:  		/* nop */
		/* 8222679Ch case    0:*/		cpu::op::nop();
		/* 8222679Ch case    0:*/		return 0x822267A0;
	}
	return 0x822267A0;
} // Block from 8222679Ch-822267A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822267A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822267A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822267A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822267A0);
		  /* 822267A0h */ case    0:  		/* mfspr R12, LR */
		/* 822267A0h case    0:*/		regs.R12 = regs.LR;
		/* 822267A0h case    0:*/		return 0x822267A4;
		  /* 822267A4h */ case    1:  		/* bl -1660232 */
		/* 822267A4h case    1:*/		regs.LR = 0x822267A8; return 0x8209125C;
		/* 822267A4h case    1:*/		return 0x822267A8;
		  /* 822267A8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 822267A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822267A8h case    2:*/		return 0x822267AC;
		  /* 822267ACh */ case    3:  		/* lwz R11, <#[R4]> */
		/* 822267ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 822267ACh case    3:*/		return 0x822267B0;
		  /* 822267B0h */ case    4:  		/* mr R29, R3 */
		/* 822267B0h case    4:*/		regs.R29 = regs.R3;
		/* 822267B0h case    4:*/		return 0x822267B4;
		  /* 822267B4h */ case    5:  		/* mr R31, R4 */
		/* 822267B4h case    5:*/		regs.R31 = regs.R4;
		/* 822267B4h case    5:*/		return 0x822267B8;
		  /* 822267B8h */ case    6:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 822267B8h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 822267B8h case    6:*/		return 0x822267BC;
		  /* 822267BCh */ case    7:  		/* mr R30, R5 */
		/* 822267BCh case    7:*/		regs.R30 = regs.R5;
		/* 822267BCh case    7:*/		return 0x822267C0;
		  /* 822267C0h */ case    8:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 822267C0h case    8:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 822267C0h case    8:*/		return 0x822267C4;
		  /* 822267C4h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 822267C4h case    9:*/		if ( regs.CR[0].eq ) { return 0x822267D8;  }
		/* 822267C4h case    9:*/		return 0x822267C8;
		  /* 822267C8h */ case   10:  		/* rlwinm. R10, R5, 0, 27, 28 */
		/* 822267C8h case   10:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R5);
		/* 822267C8h case   10:*/		return 0x822267CC;
		  /* 822267CCh */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 822267CCh case   11:*/		if ( regs.CR[0].eq ) { return 0x822267D8;  }
		/* 822267CCh case   11:*/		return 0x822267D0;
		  /* 822267D0h */ case   12:  		/* li R11, 0 */
		/* 822267D0h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822267D0h case   12:*/		return 0x822267D4;
		  /* 822267D4h */ case   13:  		/* b 44 */
		/* 822267D4h case   13:*/		return 0x82226800;
		/* 822267D4h case   13:*/		return 0x822267D8;
	}
	return 0x822267D8;
} // Block from 822267A0h-822267D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822267D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822267D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822267D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822267D8);
		  /* 822267D8h */ case    0:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 822267D8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 822267D8h case    0:*/		return 0x822267DC;
		  /* 822267DCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 822267DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x822267E8;  }
		/* 822267DCh case    1:*/		return 0x822267E0;
		  /* 822267E0h */ case    2:  		/* rlwinm. R10, R30, 0, 31, 31 */
		/* 822267E0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R30);
		/* 822267E0h case    2:*/		return 0x822267E4;
		  /* 822267E4h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 822267E4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x822267D0;  }
		/* 822267E4h case    3:*/		return 0x822267E8;
	}
	return 0x822267E8;
} // Block from 822267D8h-822267E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822267E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822267E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822267E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822267E8);
		  /* 822267E8h */ case    0:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 822267E8h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 822267E8h case    0:*/		return 0x822267EC;
		  /* 822267ECh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822267ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x822267FC;  }
		/* 822267ECh case    1:*/		return 0x822267F0;
		  /* 822267F0h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 822267F0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 822267F0h case    2:*/		return 0x822267F4;
		  /* 822267F4h */ case    3:  		/* li R11, 0 */
		/* 822267F4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822267F4h case    3:*/		return 0x822267F8;
		  /* 822267F8h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 822267F8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82226800;  }
		/* 822267F8h case    4:*/		return 0x822267FC;
	}
	return 0x822267FC;
} // Block from 822267E8h-822267FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822267FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822267FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822267FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822267FC);
		  /* 822267FCh */ case    0:  		/* li R11, 1 */
		/* 822267FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822267FCh case    0:*/		return 0x82226800;
	}
	return 0x82226800;
} // Block from 822267FCh-82226800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82226800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226800);
		  /* 82226800h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82226800h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82226800h case    0:*/		return 0x82226804;
		  /* 82226804h */ case    1:  		/* bc 4, CR0_EQ, 52 */
		/* 82226804h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82226838;  }
		/* 82226804h case    1:*/		return 0x82226808;
		  /* 82226808h */ case    2:  		/* mr R5, R31 */
		/* 82226808h case    2:*/		regs.R5 = regs.R31;
		/* 82226808h case    2:*/		return 0x8222680C;
		  /* 8222680Ch */ case    3:  		/* mr R4, R31 */
		/* 8222680Ch case    3:*/		regs.R4 = regs.R31;
		/* 8222680Ch case    3:*/		return 0x82226810;
		  /* 82226810h */ case    4:  		/* mr R3, R29 */
		/* 82226810h case    4:*/		regs.R3 = regs.R29;
		/* 82226810h case    4:*/		return 0x82226814;
		  /* 82226814h */ case    5:  		/* bl -230636 */
		/* 82226814h case    5:*/		regs.LR = 0x82226818; return 0x821EE328;
		/* 82226814h case    5:*/		return 0x82226818;
		  /* 82226818h */ case    6:  		/* mr R4, R3 */
		/* 82226818h case    6:*/		regs.R4 = regs.R3;
		/* 82226818h case    6:*/		return 0x8222681C;
		  /* 8222681Ch */ case    7:  		/* mr R3, R29 */
		/* 8222681Ch case    7:*/		regs.R3 = regs.R29;
		/* 8222681Ch case    7:*/		return 0x82226820;
		  /* 82226820h */ case    8:  		/* bl -714784 */
		/* 82226820h case    8:*/		regs.LR = 0x82226824; return 0x82178000;
		/* 82226820h case    8:*/		return 0x82226824;
		  /* 82226824h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82226824h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82226824h case    9:*/		return 0x82226828;
		  /* 82226828h */ case   10:  		/* lwz R10, <#[R3]> */
		/* 82226828h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82226828h case   10:*/		return 0x8222682C;
		  /* 8222682Ch */ case   11:  		/* mr R31, R3 */
		/* 8222682Ch case   11:*/		regs.R31 = regs.R3;
		/* 8222682Ch case   11:*/		return 0x82226830;
		  /* 82226830h */ case   12:  		/* rlwimi R10, R11, 0, 4, 6 */
		/* 82226830h case   12:*/		cpu::op::rlwimi<0,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82226830h case   12:*/		return 0x82226834;
		  /* 82226834h */ case   13:  		/* stw R10, <#[R3]> */
		/* 82226834h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82226834h case   13:*/		return 0x82226838;
	}
	return 0x82226838;
} // Block from 82226800h-82226838h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82226838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226838);
		  /* 82226838h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 82226838h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82226838h case    0:*/		return 0x8222683C;
		  /* 8222683Ch */ case    1:  		/* mr R9, R30 */
		/* 8222683Ch case    1:*/		regs.R9 = regs.R30;
		/* 8222683Ch case    1:*/		return 0x82226840;
		  /* 82226840h */ case    2:  		/* rlwinm. R8, R10, 0, 29, 29 */
		/* 82226840h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R8,regs.R10);
		/* 82226840h case    2:*/		return 0x82226844;
		  /* 82226844h */ case    3:  		/* rlwinm R11, R10, 0, 27, 31 */
		/* 82226844h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R10);
		/* 82226844h case    3:*/		return 0x82226848;
		  /* 82226848h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82226848h case    4:*/		if ( regs.CR[0].eq ) { return 0x82226858;  }
		/* 82226848h case    4:*/		return 0x8222684C;
		  /* 8222684Ch */ case    5:  		/* rlwinm. R8, R30, 0, 30, 30 */
		/* 8222684Ch case    5:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R8,regs.R30);
		/* 8222684Ch case    5:*/		return 0x82226850;
		  /* 82226850h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 82226850h case    6:*/		if ( regs.CR[0].eq ) { return 0x82226858;  }
		/* 82226850h case    6:*/		return 0x82226854;
		  /* 82226854h */ case    7:  		/* addi R11, R11, -4 */
		/* 82226854h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82226854h case    7:*/		return 0x82226858;
	}
	return 0x82226858;
} // Block from 82226838h-82226858h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82226858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226858);
		  /* 82226858h */ case    0:  		/* and R8, R11, R30 */
		/* 82226858h case    0:*/		cpu::op::and<0>(regs,&regs.R8,regs.R11,regs.R30);
		/* 82226858h case    0:*/		return 0x8222685C;
		  /* 8222685Ch */ case    1:  		/* rlwinm. R8, R8, 0, 29, 29 */
		/* 8222685Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R8,regs.R8);
		/* 8222685Ch case    1:*/		return 0x82226860;
		  /* 82226860h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82226860h case    2:*/		if ( regs.CR[0].eq ) { return 0x8222686C;  }
		/* 82226860h case    2:*/		return 0x82226864;
		  /* 82226864h */ case    3:  		/* addi R11, R11, -4 */
		/* 82226864h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82226864h case    3:*/		return 0x82226868;
		  /* 82226868h */ case    4:  		/* addi R9, R30, -4 */
		/* 82226868h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFFFFC);
		/* 82226868h case    4:*/		return 0x8222686C;
	}
	return 0x8222686C;
} // Block from 82226858h-8222686Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222686Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222686C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222686C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222686C);
		  /* 8222686Ch */ case    0:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 8222686Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 8222686Ch case    0:*/		return 0x82226870;
		  /* 82226870h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82226870h case    1:*/		if ( regs.CR[0].eq ) { return 0x82226880;  }
		/* 82226870h case    1:*/		return 0x82226874;
		  /* 82226874h */ case    2:  		/* rlwinm. R8, R9, 0, 30, 30 */
		/* 82226874h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R8,regs.R9);
		/* 82226874h case    2:*/		return 0x82226878;
		  /* 82226878h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82226878h case    3:*/		if ( regs.CR[0].eq ) { return 0x82226880;  }
		/* 82226878h case    3:*/		return 0x8222687C;
		  /* 8222687Ch */ case    4:  		/* addi R9, R9, -2 */
		/* 8222687Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFE);
		/* 8222687Ch case    4:*/		return 0x82226880;
	}
	return 0x82226880;
} // Block from 8222686Ch-82226880h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226880);
		  /* 82226880h */ case    0:  		/* rlwinm R7, R10, 27, 24, 31 */
		/* 82226880h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R10);
		/* 82226880h case    0:*/		return 0x82226884;
		  /* 82226884h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 82226884h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82226884h case    1:*/		return 0x82226888;
		  /* 82226888h */ case    2:  		/* rlwinm R5, R10, 7, 29, 31 */
		/* 82226888h case    2:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R10);
		/* 82226888h case    2:*/		return 0x8222688C;
		  /* 8222688Ch */ case    3:  		/* or R6, R11, R9 */
		/* 8222688Ch case    3:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R9);
		/* 8222688Ch case    3:*/		return 0x82226890;
		  /* 82226890h */ case    4:  		/* mr R3, R29 */
		/* 82226890h case    4:*/		regs.R3 = regs.R29;
		/* 82226890h case    4:*/		return 0x82226894;
		  /* 82226894h */ case    5:  		/* bl -18004 */
		/* 82226894h case    5:*/		regs.LR = 0x82226898; return 0x82222240;
		/* 82226894h case    5:*/		return 0x82226898;
		  /* 82226898h */ case    6:  		/* addi R1, R1, 112 */
		/* 82226898h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82226898h case    6:*/		return 0x8222689C;
		  /* 8222689Ch */ case    7:  		/* b -1660400 */
		/* 8222689Ch case    7:*/		return 0x820912AC;
		/* 8222689Ch case    7:*/		return 0x822268A0;
	}
	return 0x822268A0;
} // Block from 82226880h-822268A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822268A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822268A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822268A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822268A0);
		  /* 822268A0h */ case    0:  		/* mfspr R12, LR */
		/* 822268A0h case    0:*/		regs.R12 = regs.LR;
		/* 822268A0h case    0:*/		return 0x822268A4;
		  /* 822268A4h */ case    1:  		/* bl -1660500 */
		/* 822268A4h case    1:*/		regs.LR = 0x822268A8; return 0x82091250;
		/* 822268A4h case    1:*/		return 0x822268A8;
		  /* 822268A8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822268A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822268A8h case    2:*/		return 0x822268AC;
		  /* 822268ACh */ case    3:  		/* lwz R30, <#[R4 + 12]> */
		/* 822268ACh case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x0000000C) );
		/* 822268ACh case    3:*/		return 0x822268B0;
		  /* 822268B0h */ case    4:  		/* mr R31, R3 */
		/* 822268B0h case    4:*/		regs.R31 = regs.R3;
		/* 822268B0h case    4:*/		return 0x822268B4;
		  /* 822268B4h */ case    5:  		/* mr R27, R4 */
		/* 822268B4h case    5:*/		regs.R27 = regs.R4;
		/* 822268B4h case    5:*/		return 0x822268B8;
		  /* 822268B8h */ case    6:  		/* mr R29, R5 */
		/* 822268B8h case    6:*/		regs.R29 = regs.R5;
		/* 822268B8h case    6:*/		return 0x822268BC;
		  /* 822268BCh */ case    7:  		/* mr R26, R6 */
		/* 822268BCh case    7:*/		regs.R26 = regs.R6;
		/* 822268BCh case    7:*/		return 0x822268C0;
		  /* 822268C0h */ case    8:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 822268C0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 822268C0h case    8:*/		return 0x822268C4;
		  /* 822268C4h */ case    9:  		/* bc 12, CR0_EQ, 120 */
		/* 822268C4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8222693C;  }
		/* 822268C4h case    9:*/		return 0x822268C8;
		  /* 822268C8h */ case   10:  		/* mr R7, R4 */
		/* 822268C8h case   10:*/		regs.R7 = regs.R4;
		/* 822268C8h case   10:*/		return 0x822268CC;
		  /* 822268CCh */ case   11:  		/* lwz R4, <#[R3 + 564]> */
		/* 822268CCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 822268CCh case   11:*/		return 0x822268D0;
		  /* 822268D0h */ case   12:  		/* li R5, 0 */
		/* 822268D0h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822268D0h case   12:*/		return 0x822268D4;
		  /* 822268D4h */ case   13:  		/* mr R6, R7 */
		/* 822268D4h case   13:*/		regs.R6 = regs.R7;
		/* 822268D4h case   13:*/		return 0x822268D8;
		  /* 822268D8h */ case   14:  		/* bl -707232 */
		/* 822268D8h case   14:*/		regs.LR = 0x822268DC; return 0x82179E38;
		/* 822268D8h case   14:*/		return 0x822268DC;
		  /* 822268DCh */ case   15:  		/* mr R30, R3 */
		/* 822268DCh case   15:*/		regs.R30 = regs.R3;
		/* 822268DCh case   15:*/		return 0x822268E0;
		  /* 822268E0h */ case   16:  		/* mr R3, R31 */
		/* 822268E0h case   16:*/		regs.R3 = regs.R31;
		/* 822268E0h case   16:*/		return 0x822268E4;
		  /* 822268E4h */ case   17:  		/* mr R4, R30 */
		/* 822268E4h case   17:*/		regs.R4 = regs.R30;
		/* 822268E4h case   17:*/		return 0x822268E8;
		  /* 822268E8h */ case   18:  		/* bl -714984 */
		/* 822268E8h case   18:*/		regs.LR = 0x822268EC; return 0x82178000;
		/* 822268E8h case   18:*/		return 0x822268EC;
		  /* 822268ECh */ case   19:  		/* lwz R10, <#[R27]> */
		/* 822268ECh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 822268ECh case   19:*/		return 0x822268F0;
		  /* 822268F0h */ case   20:  		/* lwz R8, <#[R3]> */
		/* 822268F0h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 822268F0h case   20:*/		return 0x822268F4;
		  /* 822268F4h */ case   21:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 822268F4h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 822268F4h case   21:*/		return 0x822268F8;
		  /* 822268F8h */ case   22:  		/* mr R27, R3 */
		/* 822268F8h case   22:*/		regs.R27 = regs.R3;
		/* 822268F8h case   22:*/		return 0x822268FC;
		  /* 822268FCh */ case   23:  		/* rlwimi R10, R8, 0, 7, 3 */
		/* 822268FCh case   23:*/		cpu::op::rlwimi<0,0,7,3>(regs,&regs.R10,regs.R8);
		/* 822268FCh case   23:*/		return 0x82226900;
		  /* 82226900h */ case   24:  		/* addi R11, R11, 36 */
		/* 82226900h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226900h case   24:*/		return 0x82226904;
		  /* 82226904h */ case   25:  		/* stw R10, <#[R3]> */
		/* 82226904h case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82226904h case   25:*/		return 0x82226908;
		  /* 82226908h */ case   26:  		/* lwz R10, <#[R31 + 564]> */
		/* 82226908h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 82226908h case   26:*/		return 0x8222690C;
		  /* 8222690Ch */ case   27:  		/* addi R10, R10, 24 */
		/* 8222690Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 8222690Ch case   27:*/		return 0x82226910;
		  /* 82226910h */ case   28:  		/* lwz R8, <#[R10]> */
		/* 82226910h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82226910h case   28:*/		return 0x82226914;
		  /* 82226914h */ case   29:  		/* addi R6, R10, -36 */
		/* 82226914h case   29:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 82226914h case   29:*/		return 0x82226918;
		  /* 82226918h */ case   30:  		/* stw R8, <#[R11]> */
		/* 82226918h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82226918h case   30:*/		return 0x8222691C;
		  /* 8222691Ch */ case   31:  		/* addi R7, R11, -36 */
		/* 8222691Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8222691Ch case   31:*/		return 0x82226920;
		  /* 82226920h */ case   32:  		/* lwz R8, <#[R10]> */
		/* 82226920h case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82226920h case   32:*/		return 0x82226924;
		  /* 82226924h */ case   33:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 82226924h case   33:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 82226924h case   33:*/		return 0x82226928;
		  /* 82226928h */ case   34:  		/* ori R6, R6, 1 */
		/* 82226928h case   34:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82226928h case   34:*/		return 0x8222692C;
		  /* 8222692Ch */ case   35:  		/* stw R7, <#[R8]> */
		/* 8222692Ch case   35:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 8222692Ch case   35:*/		return 0x82226930;
		  /* 82226930h */ case   36:  		/* addi R9, R11, 4 */
		/* 82226930h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82226930h case   36:*/		return 0x82226934;
		  /* 82226934h */ case   37:  		/* stw R6, <#[R11 + 4]> */
		/* 82226934h case   37:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82226934h case   37:*/		return 0x82226938;
		  /* 82226938h */ case   38:  		/* stw R9, <#[R10]> */
		/* 82226938h case   38:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82226938h case   38:*/		return 0x8222693C;
	}
	return 0x8222693C;
} // Block from 822268A0h-8222693Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8222693Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222693C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222693C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222693C);
		  /* 8222693Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222693Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222693Ch case    0:*/		return 0x82226940;
		  /* 82226940h */ case    1:  		/* lis R10, -28311 */
		/* 82226940h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 82226940h case    1:*/		return 0x82226944;
		  /* 82226944h */ case    2:  		/* lis R9, 0 */
		/* 82226944h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x0);
		/* 82226944h case    2:*/		return 0x82226948;
		  /* 82226948h */ case    3:  		/* ori R8, R11, 32 */
		/* 82226948h case    3:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0x20);
		/* 82226948h case    3:*/		return 0x8222694C;
		  /* 8222694Ch */ case    4:  		/* li R11, 1 */
		/* 8222694Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222694Ch case    4:*/		return 0x82226950;
		  /* 82226950h */ case    5:  		/* stw R8, <#[R30 + 8]> */
		/* 82226950h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 82226950h case    5:*/		return 0x82226954;
		  /* 82226954h */ case    6:  		/* ori R10, R10, 5192 */
		/* 82226954h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82226954h case    6:*/		return 0x82226958;
		  /* 82226958h */ case    7:  		/* lwz R7, <#[R27]> */
		/* 82226958h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000000) );
		/* 82226958h case    7:*/		return 0x8222695C;
		  /* 8222695Ch */ case    8:  		/* rlwinm R7, R7, 7, 29, 31 */
		/* 8222695Ch case    8:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R7);
		/* 8222695Ch case    8:*/		return 0x82226960;
		  /* 82226960h */ case    9:  		/* slw R11, R11, R7 */
		/* 82226960h case    9:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82226960h case    9:*/		return 0x82226964;
		  /* 82226964h */ case   10:  		/* ori R9, R9, 36262 */
		/* 82226964h case   10:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x8DA6);
		/* 82226964h case   10:*/		return 0x82226968;
		  /* 82226968h */ case   11:  		/* addi R11, R11, -1 */
		/* 82226968h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82226968h case   11:*/		return 0x8222696C;
		  /* 8222696Ch */ case   12:  		/* rldimi R10, R9, 32, 0 */
		/* 8222696Ch case   12:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 8222696Ch case   12:*/		return 0x82226970;
		  /* 82226970h */ case   13:  		/* rldicl R9, R11, 0, 32 */
		/* 82226970h case   13:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 82226970h case   13:*/		return 0x82226974;
		  /* 82226974h */ case   14:  		/* li R5, 228 */
		/* 82226974h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xE4);
		/* 82226974h case   14:*/		return 0x82226978;
		  /* 82226978h */ case   15:  		/* srd R10, R10, R9 */
		/* 82226978h case   15:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82226978h case   15:*/		return 0x8222697C;
		  /* 8222697Ch */ case   16:  		/* srd R10, R10, R9 */
		/* 8222697Ch case   16:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8222697Ch case   16:*/		return 0x82226980;
		  /* 82226980h */ case   17:  		/* srd R10, R10, R9 */
		/* 82226980h case   17:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82226980h case   17:*/		return 0x82226984;
		  /* 82226984h */ case   18:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 82226984h case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 82226984h case   18:*/		return 0x82226988;
		  /* 82226988h */ case   19:  		/* mr R4, R29 */
		/* 82226988h case   19:*/		regs.R4 = regs.R29;
		/* 82226988h case   19:*/		return 0x8222698C;
		  /* 8222698Ch */ case   20:  		/* rlwimi R11, R10, 13, 16, 18 */
		/* 8222698Ch case   20:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R11,regs.R10);
		/* 8222698Ch case   20:*/		return 0x82226990;
		  /* 82226990h */ case   21:  		/* mr R3, R30 */
		/* 82226990h case   21:*/		regs.R3 = regs.R30;
		/* 82226990h case   21:*/		return 0x82226994;
		  /* 82226994h */ case   22:  		/* rlwimi R8, R11, 1, 27, 30 */
		/* 82226994h case   22:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R8,regs.R11);
		/* 82226994h case   22:*/		return 0x82226998;
		  /* 82226998h */ case   23:  		/* rlwimi R8, R11, 1, 15, 17 */
		/* 82226998h case   23:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R8,regs.R11);
		/* 82226998h case   23:*/		return 0x8222699C;
		  /* 8222699Ch */ case   24:  		/* stw R8, <#[R30 + 8]> */
		/* 8222699Ch case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 8222699Ch case   24:*/		return 0x822269A0;
	}
	return 0x822269A0;
} // Block from 8222693Ch-822269A0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 822269A0h
// Function '?HasIdenticalNonVectorDependencies@Instruction@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822269A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822269A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822269A0);
		  /* 822269A0h */ case    0:  		/* bl -17528 */
		/* 822269A0h case    0:*/		regs.LR = 0x822269A4; return 0x82222528;
		/* 822269A0h case    0:*/		return 0x822269A4;
		  /* 822269A4h */ case    1:  		/* lwz R10, <#[R31 + 48]> */
		/* 822269A4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 822269A4h case    1:*/		return 0x822269A8;
		  /* 822269A8h */ case    2:  		/* lis R11, -1 */
		/* 822269A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 822269A8h case    2:*/		return 0x822269AC;
		  /* 822269ACh */ case    3:  		/* rlwinm R10, R10, 0, 0, 15 */
		/* 822269ACh case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R10,regs.R10);
		/* 822269ACh case    3:*/		return 0x822269B0;
		  /* 822269B0h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 822269B0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 822269B0h case    4:*/		return 0x822269B4;
		  /* 822269B4h */ case    5:  		/* bc 4, CR6_EQ, 300 */
		/* 822269B4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82226AE0;  }
		/* 822269B4h case    5:*/		return 0x822269B8;
		  /* 822269B8h */ case    6:  		/* rlwinm R10, R29, 28, 4, 31 */
		/* 822269B8h case    6:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R29);
		/* 822269B8h case    6:*/		return 0x822269BC;
		  /* 822269BCh */ case    7:  		/* li R11, 0 */
		/* 822269BCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822269BCh case    7:*/		return 0x822269C0;
		  /* 822269C0h */ case    8:  		/* cmplwi CR6, R10, 61 */
		/* 822269C0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003D);
		/* 822269C0h case    8:*/		return 0x822269C4;
		  /* 822269C4h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 822269C4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x822269D8;  }
		/* 822269C4h case    9:*/		return 0x822269C8;
		  /* 822269C8h */ case   10:  		/* lwz R10, <#[R27]> */
		/* 822269C8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 822269C8h case   10:*/		return 0x822269CC;
		  /* 822269CCh */ case   11:  		/* ori R10, R10, 1 */
		/* 822269CCh case   11:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822269CCh case   11:*/		return 0x822269D0;
		  /* 822269D0h */ case   12:  		/* stw R10, <#[R27]> */
		/* 822269D0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 822269D0h case   12:*/		return 0x822269D4;
		  /* 822269D4h */ case   13:  		/* b 12 */
		/* 822269D4h case   13:*/		return 0x822269E0;
		/* 822269D4h case   13:*/		return 0x822269D8;
	}
	return 0x822269D8;
} // Block from 822269A0h-822269D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822269D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822269D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822269D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822269D8);
		  /* 822269D8h */ case    0:  		/* cmplwi CR6, R10, 3 */
		/* 822269D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 822269D8h case    0:*/		return 0x822269DC;
		  /* 822269DCh */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 822269DCh case    1:*/		if ( regs.CR[6].gt ) { return 0x822269E4;  }
		/* 822269DCh case    1:*/		return 0x822269E0;
	}
	return 0x822269E0;
} // Block from 822269D8h-822269E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822269E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822269E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822269E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822269E0);
		  /* 822269E0h */ case    0:  		/* li R11, 1 */
		/* 822269E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822269E0h case    0:*/		return 0x822269E4;
	}
	return 0x822269E4;
} // Block from 822269E0h-822269E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822269E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822269E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822269E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822269E4);
		  /* 822269E4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822269E4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822269E4h case    0:*/		return 0x822269E8;
		  /* 822269E8h */ case    1:  		/* bc 12, CR0_EQ, 248 */
		/* 822269E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82226AE0;  }
		/* 822269E8h case    1:*/		return 0x822269EC;
		  /* 822269ECh */ case    2:  		/* lwz R4, <#[R31 + 564]> */
		/* 822269ECh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 822269ECh case    2:*/		return 0x822269F0;
		  /* 822269F0h */ case    3:  		/* lwz R28, <#[R4 + 92]> */
		/* 822269F0h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x0000005C) );
		/* 822269F0h case    3:*/		return 0x822269F4;
		  /* 822269F4h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 822269F4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 822269F4h case    4:*/		return 0x822269F8;
		  /* 822269F8h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 822269F8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82226A0C;  }
		/* 822269F8h case    5:*/		return 0x822269FC;
		  /* 822269FCh */ case    6:  		/* lwz R11, <#[R28 + 8]> */
		/* 822269FCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 822269FCh case    6:*/		return 0x82226A00;
		  /* 82226A00h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82226A00h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82226A00h case    7:*/		return 0x82226A04;
		  /* 82226A04h */ case    8:  		/* cmplwi CR6, R11, 14976 */
		/* 82226A04h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 82226A04h case    8:*/		return 0x82226A08;
		  /* 82226A08h */ case    9:  		/* bc 12, CR6_EQ, 200 */
		/* 82226A08h case    9:*/		if ( regs.CR[6].eq ) { return 0x82226AD0;  }
		/* 82226A08h case    9:*/		return 0x82226A0C;
	}
	return 0x82226A0C;
} // Block from 822269E4h-82226A0Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82226A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226A0C);
		  /* 82226A0Ch */ case    0:  		/* li R8, 0 */
		/* 82226A0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82226A0Ch case    0:*/		return 0x82226A10;
		  /* 82226A10h */ case    1:  		/* li R7, 0 */
		/* 82226A10h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82226A10h case    1:*/		return 0x82226A14;
		  /* 82226A14h */ case    2:  		/* li R6, 117 */
		/* 82226A14h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 82226A14h case    2:*/		return 0x82226A18;
		  /* 82226A18h */ case    3:  		/* li R5, 0 */
		/* 82226A18h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226A18h case    3:*/		return 0x82226A1C;
		  /* 82226A1Ch */ case    4:  		/* mr R3, R31 */
		/* 82226A1Ch case    4:*/		regs.R3 = regs.R31;
		/* 82226A1Ch case    4:*/		return 0x82226A20;
		  /* 82226A20h */ case    5:  		/* bl -8328 */
		/* 82226A20h case    5:*/		regs.LR = 0x82226A24; return 0x82224998;
		/* 82226A20h case    5:*/		return 0x82226A24;
		  /* 82226A24h */ case    6:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 82226A24h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 82226A24h case    6:*/		return 0x82226A28;
		  /* 82226A28h */ case    7:  		/* mr R29, R3 */
		/* 82226A28h case    7:*/		regs.R29 = regs.R3;
		/* 82226A28h case    7:*/		return 0x82226A2C;
		  /* 82226A2Ch */ case    8:  		/* addi R10, R10, 36 */
		/* 82226A2Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82226A2Ch case    8:*/		return 0x82226A30;
		  /* 82226A30h */ case    9:  		/* cmplwi CR6, R28, 0 */
		/* 82226A30h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82226A30h case    9:*/		return 0x82226A34;
		  /* 82226A34h */ case   10:  		/* addi R8, R10, 4 */
		/* 82226A34h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82226A34h case   10:*/		return 0x82226A38;
		  /* 82226A38h */ case   11:  		/* bc 4, CR6_EQ, 56 */
		/* 82226A38h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82226A70;  }
		/* 82226A38h case   11:*/		return 0x82226A3C;
		  /* 82226A3Ch */ case   12:  		/* lwz R11, <#[R31 + 564]> */
		/* 82226A3Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 82226A3Ch case   12:*/		return 0x82226A40;
		  /* 82226A40h */ case   13:  		/* addi R6, R10, -36 */
		/* 82226A40h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 82226A40h case   13:*/		return 0x82226A44;
		  /* 82226A44h */ case   14:  		/* addi R11, R11, 24 */
		/* 82226A44h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82226A44h case   14:*/		return 0x82226A48;
		  /* 82226A48h */ case   15:  		/* addi R9, R11, 4 */
		/* 82226A48h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82226A48h case   15:*/		return 0x82226A4C;
		  /* 82226A4Ch */ case   16:  		/* ori R9, R9, 1 */
		/* 82226A4Ch case   16:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82226A4Ch case   16:*/		return 0x82226A50;
		  /* 82226A50h */ case   17:  		/* lwz R7, <#[R11 + 4]> */
		/* 82226A50h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226A50h case   17:*/		return 0x82226A54;
		  /* 82226A54h */ case   18:  		/* stw R7, <#[R10 + 4]> */
		/* 82226A54h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 82226A54h case   18:*/		return 0x82226A58;
		  /* 82226A58h */ case   19:  		/* lwz R7, <#[R11 + 4]> */
		/* 82226A58h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226A58h case   19:*/		return 0x82226A5C;
		  /* 82226A5Ch */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 82226A5Ch case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 82226A5Ch case   20:*/		return 0x82226A60;
		  /* 82226A60h */ case   21:  		/* stw R8, <#[R7 + 36]> */
		/* 82226A60h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 82226A60h case   21:*/		return 0x82226A64;
		  /* 82226A64h */ case   22:  		/* stw R9, <#[R10]> */
		/* 82226A64h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82226A64h case   22:*/		return 0x82226A68;
		  /* 82226A68h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 82226A68h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82226A68h case   23:*/		return 0x82226A6C;
		  /* 82226A6Ch */ case   24:  		/* b 48 */
		/* 82226A6Ch case   24:*/		return 0x82226A9C;
		/* 82226A6Ch case   24:*/		return 0x82226A70;
	}
	return 0x82226A70;
} // Block from 82226A0Ch-82226A70h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82226A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226A70);
		  /* 82226A70h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 82226A70h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 82226A70h case    0:*/		return 0x82226A74;
		  /* 82226A74h */ case    1:  		/* addi R7, R10, -36 */
		/* 82226A74h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 82226A74h case    1:*/		return 0x82226A78;
		  /* 82226A78h */ case    2:  		/* addi R11, R11, 36 */
		/* 82226A78h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226A78h case    2:*/		return 0x82226A7C;
		  /* 82226A7Ch */ case    3:  		/* addi R9, R11, 4 */
		/* 82226A7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82226A7Ch case    3:*/		return 0x82226A80;
		  /* 82226A80h */ case    4:  		/* lwz R6, <#[R11 + 4]> */
		/* 82226A80h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82226A80h case    4:*/		return 0x82226A84;
		  /* 82226A84h */ case    5:  		/* stw R6, <#[R10 + 4]> */
		/* 82226A84h case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82226A84h case    5:*/		return 0x82226A88;
		  /* 82226A88h */ case    6:  		/* lwz R6, <#[R11 + 4]> */
		/* 82226A88h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82226A88h case    6:*/		return 0x82226A8C;
		  /* 82226A8Ch */ case    7:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82226A8Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82226A8Ch case    7:*/		return 0x82226A90;
		  /* 82226A90h */ case    8:  		/* stw R8, <#[R6 + 36]> */
		/* 82226A90h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 82226A90h case    8:*/		return 0x82226A94;
		  /* 82226A94h */ case    9:  		/* stw R9, <#[R10]> */
		/* 82226A94h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82226A94h case    9:*/		return 0x82226A98;
		  /* 82226A98h */ case   10:  		/* stw R7, <#[R11 + 4]> */
		/* 82226A98h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82226A98h case   10:*/		return 0x82226A9C;
	}
	return 0x82226A9C;
} // Block from 82226A70h-82226A9Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82226A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226A9C);
		  /* 82226A9Ch */ case    0:  		/* lwz R28, <#[R31 + 564]> */
		/* 82226A9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000234) );
		/* 82226A9Ch case    0:*/		return 0x82226AA0;
		  /* 82226AA0h */ case    1:  		/* lwz R5, <#[R28 + 92]> */
		/* 82226AA0h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000005C) );
		/* 82226AA0h case    1:*/		return 0x82226AA4;
		  /* 82226AA4h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 82226AA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82226AA4h case    2:*/		return 0x82226AA8;
		  /* 82226AA8h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82226AA8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82226ABC;  }
		/* 82226AA8h case    3:*/		return 0x82226AAC;
		  /* 82226AACh */ case    4:  		/* mr R6, R31 */
		/* 82226AACh case    4:*/		regs.R6 = regs.R31;
		/* 82226AACh case    4:*/		return 0x82226AB0;
		  /* 82226AB0h */ case    5:  		/* li R4, 0 */
		/* 82226AB0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82226AB0h case    5:*/		return 0x82226AB4;
		  /* 82226AB4h */ case    6:  		/* mr R3, R29 */
		/* 82226AB4h case    6:*/		regs.R3 = regs.R29;
		/* 82226AB4h case    6:*/		return 0x82226AB8;
		  /* 82226AB8h */ case    7:  		/* bl -713024 */
		/* 82226AB8h case    7:*/		regs.LR = 0x82226ABC; return 0x82178978;
		/* 82226AB8h case    7:*/		return 0x82226ABC;
	}
	return 0x82226ABC;
} // Block from 82226A9Ch-82226ABCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82226ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226ABC);
		  /* 82226ABCh */ case    0:  		/* stw R29, <#[R28 + 92]> */
		/* 82226ABCh case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x0000005C) );
		/* 82226ABCh case    0:*/		return 0x82226AC0;
		  /* 82226AC0h */ case    1:  		/* mr R28, R29 */
		/* 82226AC0h case    1:*/		regs.R28 = regs.R29;
		/* 82226AC0h case    1:*/		return 0x82226AC4;
		  /* 82226AC4h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 82226AC4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82226AC4h case    2:*/		return 0x82226AC8;
		  /* 82226AC8h */ case    3:  		/* oris R11, R11, 512 */
		/* 82226AC8h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82226AC8h case    3:*/		return 0x82226ACC;
		  /* 82226ACCh */ case    4:  		/* stw R11, <#[R29 + 8]> */
		/* 82226ACCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82226ACCh case    4:*/		return 0x82226AD0;
	}
	return 0x82226AD0;
} // Block from 82226ABCh-82226AD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226AD0);
		  /* 82226AD0h */ case    0:  		/* mr R5, R31 */
		/* 82226AD0h case    0:*/		regs.R5 = regs.R31;
		/* 82226AD0h case    0:*/		return 0x82226AD4;
		  /* 82226AD4h */ case    1:  		/* mr R4, R28 */
		/* 82226AD4h case    1:*/		regs.R4 = regs.R28;
		/* 82226AD4h case    1:*/		return 0x82226AD8;
	}
	return 0x82226AD8;
} // Block from 82226AD0h-82226AD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226AD8h
// Function '?IsLocatedAfter@Instruction@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226AD8);
		  /* 82226AD8h */ case    0:  		/* mr R3, R30 */
		/* 82226AD8h case    0:*/		regs.R3 = regs.R30;
		/* 82226AD8h case    0:*/		return 0x82226ADC;
		  /* 82226ADCh */ case    1:  		/* bl -714828 */
		/* 82226ADCh case    1:*/		regs.LR = 0x82226AE0; return 0x82178290;
		/* 82226ADCh case    1:*/		return 0x82226AE0;
	}
	return 0x82226AE0;
} // Block from 82226AD8h-82226AE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226AE0);
		  /* 82226AE0h */ case    0:  		/* mr R4, R27 */
		/* 82226AE0h case    0:*/		regs.R4 = regs.R27;
		/* 82226AE0h case    0:*/		return 0x82226AE4;
		  /* 82226AE4h */ case    1:  		/* mr R3, R26 */
		/* 82226AE4h case    1:*/		regs.R3 = regs.R26;
		/* 82226AE4h case    1:*/		return 0x82226AE8;
		  /* 82226AE8h */ case    2:  		/* bl -715040 */
		/* 82226AE8h case    2:*/		regs.LR = 0x82226AEC; return 0x821781C8;
		/* 82226AE8h case    2:*/		return 0x82226AEC;
		  /* 82226AECh */ case    3:  		/* mr R3, R27 */
		/* 82226AECh case    3:*/		regs.R3 = regs.R27;
		/* 82226AECh case    3:*/		return 0x82226AF0;
		  /* 82226AF0h */ case    4:  		/* addi R1, R1, 144 */
		/* 82226AF0h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82226AF0h case    4:*/		return 0x82226AF4;
		  /* 82226AF4h */ case    5:  		/* b -1661012 */
		/* 82226AF4h case    5:*/		return 0x820912A0;
		/* 82226AF4h case    5:*/		return 0x82226AF8;
	}
	return 0x82226AF8;
} // Block from 82226AE0h-82226AF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82226AF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226AF8);
		  /* 82226AF8h */ case    0:  		/* mfspr R12, LR */
		/* 82226AF8h case    0:*/		regs.R12 = regs.LR;
		/* 82226AF8h case    0:*/		return 0x82226AFC;
		  /* 82226AFCh */ case    1:  		/* bl -1661100 */
		/* 82226AFCh case    1:*/		regs.LR = 0x82226B00; return 0x82091250;
		/* 82226AFCh case    1:*/		return 0x82226B00;
		  /* 82226B00h */ case    2:  		/* stfd FR31, <#[R1 - 64]> */
		/* 82226B00h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82226B00h case    2:*/		return 0x82226B04;
		  /* 82226B04h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 82226B04h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82226B04h case    3:*/		return 0x82226B08;
		  /* 82226B08h */ case    4:  		/* mr R29, R6 */
		/* 82226B08h case    4:*/		regs.R29 = regs.R6;
		/* 82226B08h case    4:*/		return 0x82226B0C;
		  /* 82226B0Ch */ case    5:  		/* stw R6, <#[R1 + 204]> */
		/* 82226B0Ch case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000000CC) );
		/* 82226B0Ch case    5:*/		return 0x82226B10;
	}
	return 0x82226B10;
} // Block from 82226AF8h-82226B10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82226B10h
// Function '?MakeInstr_S_RECIP_CLAMPED@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226B10);
		  /* 82226B10h */ case    0:  		/* mr R31, R4 */
		/* 82226B10h case    0:*/		regs.R31 = regs.R4;
		/* 82226B10h case    0:*/		return 0x82226B14;
		  /* 82226B14h */ case    1:  		/* mr R26, R5 */
		/* 82226B14h case    1:*/		regs.R26 = regs.R5;
		/* 82226B14h case    1:*/		return 0x82226B18;
		  /* 82226B18h */ case    2:  		/* mr R6, R4 */
		/* 82226B18h case    2:*/		regs.R6 = regs.R4;
		/* 82226B18h case    2:*/		return 0x82226B1C;
		  /* 82226B1Ch */ case    3:  		/* li R5, 0 */
		/* 82226B1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226B1Ch case    3:*/		return 0x82226B20;
		  /* 82226B20h */ case    4:  		/* li R4, 125 */
		/* 82226B20h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x7D);
		/* 82226B20h case    4:*/		return 0x82226B24;
		  /* 82226B24h */ case    5:  		/* mr R30, R3 */
		/* 82226B24h case    5:*/		regs.R30 = regs.R3;
		/* 82226B24h case    5:*/		return 0x82226B28;
		  /* 82226B28h */ case    6:  		/* bl -796408 */
		/* 82226B28h case    6:*/		regs.LR = 0x82226B2C; return 0x82164430;
		/* 82226B28h case    6:*/		return 0x82226B2C;
		  /* 82226B2Ch */ case    7:  		/* mr R4, R3 */
		/* 82226B2Ch case    7:*/		regs.R4 = regs.R3;
		/* 82226B2Ch case    7:*/		return 0x82226B30;
		  /* 82226B30h */ case    8:  		/* mr R3, R30 */
		/* 82226B30h case    8:*/		regs.R3 = regs.R30;
		/* 82226B30h case    8:*/		return 0x82226B34;
		  /* 82226B34h */ case    9:  		/* li R5, 35 */
		/* 82226B34h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 82226B34h case    9:*/		return 0x82226B38;
		  /* 82226B38h */ case   10:  		/* bl -761744 */
		/* 82226B38h case   10:*/		regs.LR = 0x82226B3C; return 0x8216CBA8;
		/* 82226B38h case   10:*/		return 0x82226B3C;
		  /* 82226B3Ch */ case   11:  		/* lwz R11, <#[R30 + 4]> */
		/* 82226B3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82226B3Ch case   11:*/		return 0x82226B40;
		  /* 82226B40h */ case   12:  		/* mr R8, R31 */
		/* 82226B40h case   12:*/		regs.R8 = regs.R31;
		/* 82226B40h case   12:*/		return 0x82226B44;
		  /* 82226B44h */ case   13:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82226B44h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82226B44h case   13:*/		return 0x82226B48;
		  /* 82226B48h */ case   14:  		/* li R7, 0 */
		/* 82226B48h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82226B48h case   14:*/		return 0x82226B4C;
		  /* 82226B4Ch */ case   15:  		/* addic R10, R10, -1 */
		/* 82226B4Ch case   15:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82226B4Ch case   15:*/		return 0x82226B50;
		  /* 82226B50h */ case   16:  		/* li R6, 125 */
		/* 82226B50h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x7D);
		/* 82226B50h case   16:*/		return 0x82226B54;
		  /* 82226B54h */ case   17:  		/* subfe R10, R10, R10 */
		/* 82226B54h case   17:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82226B54h case   17:*/		return 0x82226B58;
		  /* 82226B58h */ case   18:  		/* mr R4, R30 */
		/* 82226B58h case   18:*/		regs.R4 = regs.R30;
		/* 82226B58h case   18:*/		return 0x82226B5C;
		  /* 82226B5Ch */ case   19:  		/* and R5, R10, R11 */
		/* 82226B5Ch case   19:*/		cpu::op::and<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 82226B5Ch case   19:*/		return 0x82226B60;
		  /* 82226B60h */ case   20:  		/* mr R27, R3 */
		/* 82226B60h case   20:*/		regs.R27 = regs.R3;
		/* 82226B60h case   20:*/		return 0x82226B64;
		  /* 82226B64h */ case   21:  		/* bl -10316 */
		/* 82226B64h case   21:*/		regs.LR = 0x82226B68; return 0x82224318;
		/* 82226B64h case   21:*/		return 0x82226B68;
		  /* 82226B68h */ case   22:  		/* cmplwi CR6, R31, 0 */
		/* 82226B68h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82226B68h case   22:*/		return 0x82226B6C;
		  /* 82226B6Ch */ case   23:  		/* bc 12, CR6_EQ, 28 */
		/* 82226B6Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82226B88;  }
		/* 82226B6Ch case   23:*/		return 0x82226B70;
		  /* 82226B70h */ case   24:  		/* addi R11, R26, -4 */
		/* 82226B70h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFFC);
		/* 82226B70h case   24:*/		return 0x82226B74;
		  /* 82226B74h */ case   25:  		/* mtspr CTR, R31 */
		/* 82226B74h case   25:*/		regs.CTR = regs.R31;
		/* 82226B74h case   25:*/		return 0x82226B78;
		  /* 82226B78h */ case   26:  		/* addi R10, R27, 40 */
		/* 82226B78h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x28);
		/* 82226B78h case   26:*/		return 0x82226B7C;
		  /* 82226B7Ch */ case   27:  		/* lfsu FR0, <#[R11 + 4]> */
		/* 82226B7Ch case   27:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82226B7Ch case   27:*/		return 0x82226B80;
		  /* 82226B80h */ case   28:  		/* stfsu FR0, <#[R10 + 4]> */
		/* 82226B80h case   28:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82226B80h case   28:*/		return 0x82226B84;
		  /* 82226B84h */ case   29:  		/* bc 16, CR0_LT, -8 */
		/* 82226B84h case   29:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82226B7C;  }
		/* 82226B84h case   29:*/		return 0x82226B88;
	}
	return 0x82226B88;
} // Block from 82226B10h-82226B88h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82226B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226B88);
		  /* 82226B88h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82226B88h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82226B88h case    0:*/		return 0x82226B8C;
		  /* 82226B8Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82226B8Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82226B9C;  }
		/* 82226B8Ch case    1:*/		return 0x82226B90;
		  /* 82226B90h */ case    2:  		/* lwz R10, <#[R27 + 20]> */
		/* 82226B90h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 82226B90h case    2:*/		return 0x82226B94;
		  /* 82226B94h */ case    3:  		/* rlwimi R10, R11, 2, 22, 29 */
		/* 82226B94h case    3:*/		cpu::op::rlwimi<0,2,22,29>(regs,&regs.R10,regs.R11);
		/* 82226B94h case    3:*/		return 0x82226B98;
		  /* 82226B98h */ case    4:  		/* stw R10, <#[R27 + 20]> */
		/* 82226B98h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 82226B98h case    4:*/		return 0x82226B9C;
	}
	return 0x82226B9C;
} // Block from 82226B88h-82226B9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226B9C);
		  /* 82226B9Ch */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 82226B9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82226B9Ch case    0:*/		return 0x82226BA0;
		  /* 82226BA0h */ case    1:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 82226BA0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 82226BA0h case    1:*/		return 0x82226BA4;
		  /* 82226BA4h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82226BA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82226BA4h case    2:*/		return 0x82226BA8;
		  /* 82226BA8h */ case    3:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 82226BA8h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82226BA8h case    3:*/		return 0x82226BAC;
		  /* 82226BACh */ case    4:  		/* addi R11, R11, 36 */
		/* 82226BACh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82226BACh case    4:*/		return 0x82226BB0;
	}
	return 0x82226BB0;
} // Block from 82226B9Ch-82226BB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226BB0h
// Function '?MakeInstr_S_PRED_SETE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226BB0);
		  /* 82226BB0h */ case    0:  		/* addic R9, R9, -1 */
		/* 82226BB0h case    0:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82226BB0h case    0:*/		return 0x82226BB4;
		  /* 82226BB4h */ case    1:  		/* addi R7, R11, -36 */
		/* 82226BB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 82226BB4h case    1:*/		return 0x82226BB8;
		  /* 82226BB8h */ case    2:  		/* subfe R8, R9, R9 */
		/* 82226BB8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R9,regs.R9);
		/* 82226BB8h case    2:*/		return 0x82226BBC;
		  /* 82226BBCh */ case    3:  		/* addi R9, R11, 4 */
		/* 82226BBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82226BBCh case    3:*/		return 0x82226BC0;
		  /* 82226BC0h */ case    4:  		/* and R10, R8, R10 */
		/* 82226BC0h case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82226BC0h case    4:*/		return 0x82226BC4;
		  /* 82226BC4h */ case    5:  		/* addi R8, R10, 16 */
		/* 82226BC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x10);
		/* 82226BC4h case    5:*/		return 0x82226BC8;
		  /* 82226BC8h */ case    6:  		/* addi R8, R8, -36 */
		/* 82226BC8h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFDC);
		/* 82226BC8h case    6:*/		return 0x82226BCC;
		  /* 82226BCCh */ case    7:  		/* lwz R6, <#[R10 + 16]> */
		/* 82226BCCh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82226BCCh case    7:*/		return 0x82226BD0;
		  /* 82226BD0h */ case    8:  		/* ori R8, R8, 1 */
		/* 82226BD0h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82226BD0h case    8:*/		return 0x82226BD4;
		  /* 82226BD4h */ case    9:  		/* stw R6, <#[R11]> */
		/* 82226BD4h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82226BD4h case    9:*/		return 0x82226BD8;
		  /* 82226BD8h */ case   10:  		/* lwz R6, <#[R10 + 16]> */
		/* 82226BD8h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82226BD8h case   10:*/		return 0x82226BDC;
		  /* 82226BDCh */ case   11:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 82226BDCh case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 82226BDCh case   11:*/		return 0x82226BE0;
		  /* 82226BE0h */ case   12:  		/* stw R7, <#[R6]> */
		/* 82226BE0h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 82226BE0h case   12:*/		return 0x82226BE4;
		  /* 82226BE4h */ case   13:  		/* stw R8, <#[R11 + 4]> */
		/* 82226BE4h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82226BE4h case   13:*/		return 0x82226BE8;
		  /* 82226BE8h */ case   14:  		/* stw R9, <#[R10 + 16]> */
		/* 82226BE8h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 82226BE8h case   14:*/		return 0x82226BEC;
		  /* 82226BECh */ case   15:  		/* bc 12, CR6_EQ, 288 */
		/* 82226BECh case   15:*/		if ( regs.CR[6].eq ) { return 0x82226D0C;  }
		/* 82226BECh case   15:*/		return 0x82226BF0;
		  /* 82226BF0h */ case   16:  		/* lis R11, -32256 */
		/* 82226BF0h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82226BF0h case   16:*/		return 0x82226BF4;
		  /* 82226BF4h */ case   17:  		/* li R29, 0 */
		/* 82226BF4h case   17:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82226BF4h case   17:*/		return 0x82226BF8;
		  /* 82226BF8h */ case   18:  		/* li R28, 0 */
		/* 82226BF8h case   18:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82226BF8h case   18:*/		return 0x82226BFC;
		  /* 82226BFCh */ case   19:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 82226BFCh case   19:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 82226BFCh case   19:*/		return 0x82226C00;
		  /* 82226C00h */ case   20:  		/* addi R11, R28, 1 */
		/* 82226C00h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 82226C00h case   20:*/		return 0x82226C04;
		  /* 82226C04h */ case   21:  		/* addi R9, R1, 204 */
		/* 82226C04h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xCC);
		/* 82226C04h case   21:*/		return 0x82226C08;
		  /* 82226C08h */ case   22:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82226C08h case   22:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82226C08h case   22:*/		return 0x82226C0C;
		  /* 82226C0Ch */ case   23:  		/* rlwinm R10, R28, 29, 3, 29 */
		/* 82226C0Ch case   23:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R28);
		/* 82226C0Ch case   23:*/		return 0x82226C10;
		  /* 82226C10h */ case   24:  		/* li R8, 2 */
		/* 82226C10h case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82226C10h case   24:*/		return 0x82226C14;
		  /* 82226C14h */ case   25:  		/* rlwinm R7, R28, 0, 27, 31 */
		/* 82226C14h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R28);
		/* 82226C14h case   25:*/		return 0x82226C18;
		  /* 82226C18h */ case   26:  		/* slw R11, R8, R11 */
		/* 82226C18h case   26:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82226C18h case   26:*/		return 0x82226C1C;
		  /* 82226C1Ch */ case   27:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82226C1Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82226C1Ch case   27:*/		return 0x82226C20;
		  /* 82226C20h */ case   28:  		/* addi R11, R11, -1 */
		/* 82226C20h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82226C20h case   28:*/		return 0x82226C24;
		  /* 82226C24h */ case   29:  		/* li R9, -1 */
		/* 82226C24h case   29:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 82226C24h case   29:*/		return 0x82226C28;
		  /* 82226C28h */ case   30:  		/* and R11, R11, R10 */
		/* 82226C28h case   30:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82226C28h case   30:*/		return 0x82226C2C;
		  /* 82226C2Ch */ case   31:  		/* slw R10, R9, R7 */
		/* 82226C2Ch case   31:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R9,regs.R7);
		/* 82226C2Ch case   31:*/		return 0x82226C30;
		  /* 82226C30h */ case   32:  		/* and R11, R11, R10 */
		/* 82226C30h case   32:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82226C30h case   32:*/		return 0x82226C34;
		  /* 82226C34h */ case   33:  		/* li R30, 0 */
		/* 82226C34h case   33:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82226C34h case   33:*/		return 0x82226C38;
		  /* 82226C38h */ case   34:  		/* srw. R11, R11, R7 */
		/* 82226C38h case   34:*/		cpu::op::srw<1>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82226C38h case   34:*/		return 0x82226C3C;
		  /* 82226C3Ch */ case   35:  		/* bc 12, CR0_EQ, 64 */
		/* 82226C3Ch case   35:*/		if ( regs.CR[0].eq ) { return 0x82226C7C;  }
		/* 82226C3Ch case   35:*/		return 0x82226C40;
		  /* 82226C40h */ case   36:  		/* cmplwi CR6, R11, 1 */
		/* 82226C40h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82226C40h case   36:*/		return 0x82226C44;
		  /* 82226C44h */ case   37:  		/* lwzx R11, <#[R29 + R26]> */
		/* 82226C44h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R26 + 0x00000000) );
		/* 82226C44h case   37:*/		return 0x82226C48;
		  /* 82226C48h */ case   38:  		/* li R30, 12 */
		/* 82226C48h case   38:*/		cpu::op::li<0>(regs,&regs.R30,0xC);
		/* 82226C48h case   38:*/		return 0x82226C4C;
		  /* 82226C4Ch */ case   39:  		/* bc 4, CR6_EQ, 28 */
		/* 82226C4Ch case   39:*/		if ( !regs.CR[6].eq ) { return 0x82226C68;  }
		/* 82226C4Ch case   39:*/		return 0x82226C50;
	}
	return 0x82226C50;
} // Block from 82226BB0h-82226C50h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82226C50h
// Function '?MakeInstr_S_PRED_SETNE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226C50);
		  /* 82226C50h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82226C50h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82226C50h case    0:*/		return 0x82226C54;
		  /* 82226C54h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 82226C54h case    1:*/		if ( regs.CR[6].lt ) { return 0x82226C60;  }
		/* 82226C54h case    1:*/		return 0x82226C58;
		  /* 82226C58h */ case    2:  		/* li R30, 14 */
		/* 82226C58h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0xE);
		/* 82226C58h case    2:*/		return 0x82226C5C;
		  /* 82226C5Ch */ case    3:  		/* bc 12, CR6_GT, 128 */
		/* 82226C5Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x82226CDC;  }
		/* 82226C5Ch case    3:*/		return 0x82226C60;
	}
	return 0x82226C60;
} // Block from 82226C50h-82226C60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82226C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226C60);
		  /* 82226C60h */ case    0:  		/* ori R30, R30, 1 */
		/* 82226C60h case    0:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82226C60h case    0:*/		return 0x82226C64;
		  /* 82226C64h */ case    1:  		/* b 120 */
		/* 82226C64h case    1:*/		return 0x82226CDC;
		/* 82226C64h case    1:*/		return 0x82226C68;
	}
	return 0x82226C68;
} // Block from 82226C60h-82226C68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82226C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226C68);
		  /* 82226C68h */ case    0:  		/* li R30, 14 */
		/* 82226C68h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xE);
		/* 82226C68h case    0:*/		return 0x82226C6C;
		  /* 82226C6Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82226C6Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226C6Ch case    1:*/		return 0x82226C70;
		  /* 82226C70h */ case    2:  		/* bc 4, CR6_EQ, 108 */
		/* 82226C70h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82226CDC;  }
		/* 82226C70h case    2:*/		return 0x82226C74;
		  /* 82226C74h */ case    3:  		/* li R30, 15 */
		/* 82226C74h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0xF);
		/* 82226C74h case    3:*/		return 0x82226C78;
		  /* 82226C78h */ case    4:  		/* b 100 */
		/* 82226C78h case    4:*/		return 0x82226CDC;
		/* 82226C78h case    4:*/		return 0x82226C7C;
	}
	return 0x82226C7C;
} // Block from 82226C68h-82226C7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226C7C);
		  /* 82226C7Ch */ case    0:  		/* lfsx FR1, <#[R29 + R26]> */
		/* 82226C7Ch case    0:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R29 + regs.R26 + 0x00000000) );
		/* 82226C7Ch case    0:*/		return 0x82226C80;
		  /* 82226C80h */ case    1:  		/* fcmpu CR6, FR1, FR31 */
		/* 82226C80h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82226C80h case    1:*/		return 0x82226C84;
		  /* 82226C84h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82226C84h case    2:*/		if ( regs.CR[6].lt ) { return 0x82226C8C;  }
		/* 82226C84h case    2:*/		return 0x82226C88;
		  /* 82226C88h */ case    3:  		/* li R30, 2 */
		/* 82226C88h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82226C88h case    3:*/		return 0x82226C8C;
	}
	return 0x82226C8C;
} // Block from 82226C7Ch-82226C8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82226C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226C8C);
		  /* 82226C8Ch */ case    0:  		/* fcmpu CR6, FR1, FR31 */
		/* 82226C8Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82226C8Ch case    0:*/		return 0x82226C90;
		  /* 82226C90h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 82226C90h case    1:*/		if ( regs.CR[6].gt ) { return 0x82226C98;  }
		/* 82226C90h case    1:*/		return 0x82226C94;
		  /* 82226C94h */ case    2:  		/* ori R30, R30, 1 */
		/* 82226C94h case    2:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82226C94h case    2:*/		return 0x82226C98;
	}
	return 0x82226C98;
} // Block from 82226C8Ch-82226C98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82226C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226C98);
		  /* 82226C98h */ case    0:  		/* lfsx FR0, <#[R29 + R26]> */
		/* 82226C98h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R29 + regs.R26 + 0x00000000) );
		/* 82226C98h case    0:*/		return 0x82226C9C;
		  /* 82226C9Ch */ case    1:  		/* fctiwz FR13, FR0 */
		/* 82226C9Ch case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR0);
		/* 82226C9Ch case    1:*/		return 0x82226CA0;
		  /* 82226CA0h */ case    2:  		/* stfd FR13, <#[R1 + 80]> */
		/* 82226CA0h case    2:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82226CA0h case    2:*/		return 0x82226CA4;
		  /* 82226CA4h */ case    3:  		/* lwa R11, <#[R1 + 84]> */
		/* 82226CA4h case    3:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82226CA4h case    3:*/		return 0x82226CA8;
		  /* 82226CA8h */ case    4:  		/* std R11, <#[R1 + 88]> */
		/* 82226CA8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82226CA8h case    4:*/		return 0x82226CAC;
		  /* 82226CACh */ case    5:  		/* lfd FR13, <#[R1 + 88]> */
		/* 82226CACh case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82226CACh case    5:*/		return 0x82226CB0;
		  /* 82226CB0h */ case    6:  		/* fcfid FR13, FR13 */
		/* 82226CB0h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82226CB0h case    6:*/		return 0x82226CB4;
		  /* 82226CB4h */ case    7:  		/* frsp FR13, FR13 */
		/* 82226CB4h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82226CB4h case    7:*/		return 0x82226CB8;
		  /* 82226CB8h */ case    8:  		/* fcmpu CR6, FR13, FR0 */
		/* 82226CB8h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82226CB8h case    8:*/		return 0x82226CBC;
		  /* 82226CBCh */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82226CBCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82226CC4;  }
		/* 82226CBCh case    9:*/		return 0x82226CC0;
		  /* 82226CC0h */ case   10:  		/* ori R30, R30, 4 */
		/* 82226CC0h case   10:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82226CC0h case   10:*/		return 0x82226CC4;
	}
	return 0x82226CC4;
} // Block from 82226C98h-82226CC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82226CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226CC4);
		  /* 82226CC4h */ case    0:  		/* bl -1633420 */
		/* 82226CC4h case    0:*/		regs.LR = 0x82226CC8; return 0x82098038;
		/* 82226CC4h case    0:*/		return 0x82226CC8;
		  /* 82226CC8h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 82226CC8h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82226CC8h case    1:*/		return 0x82226CCC;
		  /* 82226CCCh */ case    2:  		/* bc 4, CR0_GT, 12 */
		/* 82226CCCh case    2:*/		if ( !regs.CR[0].gt ) { return 0x82226CD8;  }
		/* 82226CCCh case    2:*/		return 0x82226CD0;
		  /* 82226CD0h */ case    3:  		/* cmpwi CR6, R3, 2 */
		/* 82226CD0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82226CD0h case    3:*/		return 0x82226CD4;
		  /* 82226CD4h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82226CD4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82226CDC;  }
		/* 82226CD4h case    4:*/		return 0x82226CD8;
	}
	return 0x82226CD8;
} // Block from 82226CC4h-82226CD8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226CD8);
		  /* 82226CD8h */ case    0:  		/* ori R30, R30, 8 */
		/* 82226CD8h case    0:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x8);
		/* 82226CD8h case    0:*/		return 0x82226CDC;
	}
	return 0x82226CDC;
} // Block from 82226CD8h-82226CDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82226CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226CDC);
		  /* 82226CDCh */ case    0:  		/* lwz R10, <#[R27 + 12]> */
		/* 82226CDCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x0000000C) );
		/* 82226CDCh case    0:*/		return 0x82226CE0;
		  /* 82226CE0h */ case    1:  		/* slw R11, R30, R29 */
		/* 82226CE0h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R29);
		/* 82226CE0h case    1:*/		return 0x82226CE4;
		  /* 82226CE4h */ case    2:  		/* and R9, R10, R11 */
		/* 82226CE4h case    2:*/		cpu::op::and<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82226CE4h case    2:*/		return 0x82226CE8;
		  /* 82226CE8h */ case    3:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 82226CE8h case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 82226CE8h case    3:*/		return 0x82226CEC;
		  /* 82226CECh */ case    4:  		/* cmplw CR6, R9, R11 */
		/* 82226CECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82226CECh case    4:*/		return 0x82226CF0;
	}
	return 0x82226CF0;
} // Block from 82226CDCh-82226CF0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226CF0h
// Function '?MakeInstr_S_PRED_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226CF0);
		  /* 82226CF0h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 82226CF0h case    0:*/		if ( regs.CR[6].eq ) { return 0x82226CFC;  }
		/* 82226CF0h case    0:*/		return 0x82226CF4;
		  /* 82226CF4h */ case    1:  		/* or R11, R10, R11 */
		/* 82226CF4h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82226CF4h case    1:*/		return 0x82226CF8;
		  /* 82226CF8h */ case    2:  		/* sth R11, <#[R27 + 14]> */
		/* 82226CF8h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R27 + 0x0000000E) );
		/* 82226CF8h case    2:*/		return 0x82226CFC;
	}
	return 0x82226CFC;
} // Block from 82226CF0h-82226CFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82226CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226CFC);
		  /* 82226CFCh */ case    0:  		/* addic. R31, R31, -1 */
		/* 82226CFCh case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82226CFCh case    0:*/		return 0x82226D00;
		  /* 82226D00h */ case    1:  		/* addi R28, R28, 2 */
		/* 82226D00h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x2);
		/* 82226D00h case    1:*/		return 0x82226D04;
		  /* 82226D04h */ case    2:  		/* addi R29, R29, 4 */
		/* 82226D04h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82226D04h case    2:*/		return 0x82226D08;
		  /* 82226D08h */ case    3:  		/* bc 4, CR0_EQ, -264 */
		/* 82226D08h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82226C00;  }
		/* 82226D08h case    3:*/		return 0x82226D0C;
	}
	return 0x82226D0C;
} // Block from 82226CFCh-82226D0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82226D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226D0C);
		  /* 82226D0Ch */ case    0:  		/* mr R3, R27 */
		/* 82226D0Ch case    0:*/		regs.R3 = regs.R27;
		/* 82226D0Ch case    0:*/		return 0x82226D10;
		  /* 82226D10h */ case    1:  		/* addi R1, R1, 160 */
		/* 82226D10h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82226D10h case    1:*/		return 0x82226D14;
		  /* 82226D14h */ case    2:  		/* lfd FR31, <#[R1 - 64]> */
		/* 82226D14h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82226D14h case    2:*/		return 0x82226D18;
		  /* 82226D18h */ case    3:  		/* b -1661560 */
		/* 82226D18h case    3:*/		return 0x820912A0;
		/* 82226D18h case    3:*/		return 0x82226D1C;
		  /* 82226D1Ch */ case    4:  		/* nop */
		/* 82226D1Ch case    4:*/		cpu::op::nop();
		/* 82226D1Ch case    4:*/		return 0x82226D20;
	}
	return 0x82226D20;
} // Block from 82226D0Ch-82226D20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226D20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226D20);
		  /* 82226D20h */ case    0:  		/* mfspr R12, LR */
		/* 82226D20h case    0:*/		regs.R12 = regs.LR;
		/* 82226D20h case    0:*/		return 0x82226D24;
		  /* 82226D24h */ case    1:  		/* bl -1661656 */
		/* 82226D24h case    1:*/		regs.LR = 0x82226D28; return 0x8209124C;
		/* 82226D24h case    1:*/		return 0x82226D28;
		  /* 82226D28h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82226D28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82226D28h case    2:*/		return 0x82226D2C;
		  /* 82226D2Ch */ case    3:  		/* mr R31, R3 */
		/* 82226D2Ch case    3:*/		regs.R31 = regs.R3;
		/* 82226D2Ch case    3:*/		return 0x82226D30;
		  /* 82226D30h */ case    4:  		/* mr R26, R4 */
		/* 82226D30h case    4:*/		regs.R26 = regs.R4;
		/* 82226D30h case    4:*/		return 0x82226D34;
		  /* 82226D34h */ case    5:  		/* mr R25, R5 */
		/* 82226D34h case    5:*/		regs.R25 = regs.R5;
		/* 82226D34h case    5:*/		return 0x82226D38;
		  /* 82226D38h */ case    6:  		/* mr R27, R6 */
		/* 82226D38h case    6:*/		regs.R27 = regs.R6;
		/* 82226D38h case    6:*/		return 0x82226D3C;
		  /* 82226D3Ch */ case    7:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 82226D3Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 82226D3Ch case    7:*/		return 0x82226D40;
		  /* 82226D40h */ case    8:  		/* bc 12, CR0_EQ, 60 */
		/* 82226D40h case    8:*/		if ( regs.CR[0].eq ) { return 0x82226D7C;  }
		/* 82226D40h case    8:*/		return 0x82226D44;
		  /* 82226D44h */ case    9:  		/* lwz R11, <#[R3 + 12]> */
		/* 82226D44h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82226D44h case    9:*/		return 0x82226D48;
		  /* 82226D48h */ case   10:  		/* mulli R30, R4, 40 */
		/* 82226D48h case   10:*/		cpu::op::mulli<0>(regs,&regs.R30,regs.R4,0x28);
		/* 82226D48h case   10:*/		return 0x82226D4C;
		  /* 82226D4Ch */ case   11:  		/* add R11, R11, R30 */
		/* 82226D4Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82226D4Ch case   11:*/		return 0x82226D50;
		  /* 82226D50h */ case   12:  		/* lwz R11, <#[R11 + 28]> */
		/* 82226D50h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82226D50h case   12:*/		return 0x82226D54;
		  /* 82226D54h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82226D54h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82226D54h case   13:*/		return 0x82226D58;
		  /* 82226D58h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 82226D58h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82226D60;  }
		/* 82226D58h case   14:*/		return 0x82226D5C;
		  /* 82226D5Ch */ case   15:  		/* bl -627692 */
		/* 82226D5Ch case   15:*/		regs.LR = 0x82226D60; return 0x8218D970;
		/* 82226D5Ch case   15:*/		return 0x82226D60;
	}
	return 0x82226D60;
} // Block from 82226D20h-82226D60h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82226D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226D60);
		  /* 82226D60h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82226D60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82226D60h case    0:*/		return 0x82226D64;
		  /* 82226D64h */ case    1:  		/* rlwinm R10, R25, 3, 0, 28 */
		/* 82226D64h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R25);
		/* 82226D64h case    1:*/		return 0x82226D68;
		  /* 82226D68h */ case    2:  		/* li R27, 0 */
		/* 82226D68h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82226D68h case    2:*/		return 0x82226D6C;
		  /* 82226D6Ch */ case    3:  		/* add R11, R11, R30 */
		/* 82226D6Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82226D6Ch case    3:*/		return 0x82226D70;
		  /* 82226D70h */ case    4:  		/* lwz R11, <#[R11 + 28]> */
		/* 82226D70h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82226D70h case    4:*/		return 0x82226D74;
		  /* 82226D74h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82226D74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82226D74h case    5:*/		return 0x82226D78;
		  /* 82226D78h */ case    6:  		/* rlwinm R25, R11, 28, 18, 31 */
		/* 82226D78h case    6:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R25,regs.R11);
		/* 82226D78h case    6:*/		return 0x82226D7C;
	}
	return 0x82226D7C;
} // Block from 82226D60h-82226D7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82226D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226D7C);
		  /* 82226D7Ch */ case    0:  		/* lwz R29, <#[R31 + 4]> */
		/* 82226D7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 82226D7Ch case    0:*/		return 0x82226D80;
		  /* 82226D80h */ case    1:  		/* rlwinm R28, R29, 0, 31, 31 */
		/* 82226D80h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R28,regs.R29);
		/* 82226D80h case    1:*/		return 0x82226D84;
		  /* 82226D84h */ case    2:  		/* addic R11, R28, -1 */
		/* 82226D84h case    2:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 82226D84h case    2:*/		return 0x82226D88;
		  /* 82226D88h */ case    3:  		/* subfe R11, R11, R11 */
		/* 82226D88h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82226D88h case    3:*/		return 0x82226D8C;
		  /* 82226D8Ch */ case    4:  		/* and R11, R11, R29 */
		/* 82226D8Ch case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82226D8Ch case    4:*/		return 0x82226D90;
	}
	return 0x82226D90;
} // Block from 82226D7Ch-82226D90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226D90h
// Function '?MakeInstr_S_PRED_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226D90);
		  /* 82226D90h */ case    0:  		/* lwz R30, <#[R11 + 20]> */
		/* 82226D90h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000014) );
		/* 82226D90h case    0:*/		return 0x82226D94;
		  /* 82226D94h */ case    1:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82226D94h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82226D94h case    1:*/		return 0x82226D98;
		  /* 82226D98h */ case    2:  		/* bc 4, CR0_EQ, 108 */
		/* 82226D98h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82226E04;  }
		/* 82226D98h case    2:*/		return 0x82226D9C;
		  /* 82226D9Ch */ case    3:  		/* cmplwi CR0, R30, 0 */
		/* 82226D9Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 82226D9Ch case    3:*/		return 0x82226DA0;
		  /* 82226DA0h */ case    4:  		/* bc 12, CR0_EQ, 100 */
		/* 82226DA0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82226E04;  }
		/* 82226DA0h case    4:*/		return 0x82226DA4;
		  /* 82226DA4h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 82226DA4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82226DA4h case    5:*/		return 0x82226DA8;
		  /* 82226DA8h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82226DA8h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82226DA8h case    6:*/		return 0x82226DAC;
		  /* 82226DACh */ case    7:  		/* cmplwi CR6, R11, 15872 */
		/* 82226DACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 82226DACh case    7:*/		return 0x82226DB0;
		  /* 82226DB0h */ case    8:  		/* bc 4, CR6_EQ, 60 */
		/* 82226DB0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82226DEC;  }
		/* 82226DB0h case    8:*/		return 0x82226DB4;
		  /* 82226DB4h */ case    9:  		/* lwz R11, <#[R30 + 8]> */
		/* 82226DB4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82226DB4h case    9:*/		return 0x82226DB8;
		  /* 82226DB8h */ case   10:  		/* mr R3, R31 */
		/* 82226DB8h case   10:*/		regs.R3 = regs.R31;
		/* 82226DB8h case   10:*/		return 0x82226DBC;
		  /* 82226DBCh */ case   11:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82226DBCh case   11:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82226DBCh case   11:*/		return 0x82226DC0;
		  /* 82226DC0h */ case   12:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82226DC0h case   12:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82226DC0h case   12:*/		return 0x82226DC4;
		  /* 82226DC4h */ case   13:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82226DC4h case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82226DC4h case   13:*/		return 0x82226DC8;
		  /* 82226DC8h */ case   14:  		/* bl -797080 */
		/* 82226DC8h case   14:*/		regs.LR = 0x82226DCC; return 0x82164430;
		/* 82226DC8h case   14:*/		return 0x82226DCC;
		  /* 82226DCCh */ case   15:  		/* addi R11, R30, -8 */
		/* 82226DCCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 82226DCCh case   15:*/		return 0x82226DD0;
		  /* 82226DD0h */ case   16:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82226DD0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82226DD0h case   16:*/		return 0x82226DD4;
		  /* 82226DD4h */ case   17:  		/* rlwinm R10, R11, 0, 17, 31 */
		/* 82226DD4h case   17:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R11);
		/* 82226DD4h case   17:*/		return 0x82226DD8;
		  /* 82226DD8h */ case   18:  		/* cmplw CR6, R10, R26 */
		/* 82226DD8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 82226DD8h case   18:*/		return 0x82226DDC;
		  /* 82226DDCh */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 82226DDCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x82226DEC;  }
		/* 82226DDCh case   19:*/		return 0x82226DE0;
		  /* 82226DE0h */ case   20:  		/* rlwinm R11, R11, 17, 18, 31 */
		/* 82226DE0h case   20:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R11,regs.R11);
		/* 82226DE0h case   20:*/		return 0x82226DE4;
		  /* 82226DE4h */ case   21:  		/* cmplw CR6, R11, R25 */
		/* 82226DE4h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 82226DE4h case   21:*/		return 0x82226DE8;
		  /* 82226DE8h */ case   22:  		/* bc 12, CR6_EQ, 92 */
		/* 82226DE8h case   22:*/		if ( regs.CR[6].eq ) { return 0x82226E44;  }
		/* 82226DE8h case   22:*/		return 0x82226DEC;
	}
	return 0x82226DEC;
} // Block from 82226D90h-82226DECh (23 instructions)

//////////////////////////////////////////////////////
// Block at 82226DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226DEC);
		  /* 82226DECh */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82226DECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82226DECh case    0:*/		return 0x82226DF0;
		  /* 82226DF0h */ case    1:  		/* lwz R30, <#[R11 + 40]> */
		/* 82226DF0h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000028) );
		/* 82226DF0h case    1:*/		return 0x82226DF4;
		  /* 82226DF4h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82226DF4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82226DF4h case    2:*/		return 0x82226DF8;
		  /* 82226DF8h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82226DF8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82226E04;  }
		/* 82226DF8h case    3:*/		return 0x82226DFC;
		  /* 82226DFCh */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82226DFCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82226DFCh case    4:*/		return 0x82226E00;
		  /* 82226E00h */ case    5:  		/* bc 4, CR6_EQ, -92 */
		/* 82226E00h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82226DA4;  }
		/* 82226E00h case    5:*/		return 0x82226E04;
	}
	return 0x82226E04;
} // Block from 82226DECh-82226E04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82226E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226E04);
		  /* 82226E04h */ case    0:  		/* addic R11, R28, -1 */
		/* 82226E04h case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 82226E04h case    0:*/		return 0x82226E08;
		  /* 82226E08h */ case    1:  		/* li R7, 124 */
		/* 82226E08h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x7C);
		/* 82226E08h case    1:*/		return 0x82226E0C;
		  /* 82226E0Ch */ case    2:  		/* subfe R11, R11, R11 */
		/* 82226E0Ch case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82226E0Ch case    2:*/		return 0x82226E10;
		  /* 82226E10h */ case    3:  		/* addic R10, R28, -1 */
		/* 82226E10h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R28,0xFFFFFFFF);
		/* 82226E10h case    3:*/		return 0x82226E14;
		  /* 82226E14h */ case    4:  		/* and R11, R11, R29 */
		/* 82226E14h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82226E14h case    4:*/		return 0x82226E18;
		  /* 82226E18h */ case    5:  		/* subfe R10, R10, R10 */
		/* 82226E18h case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82226E18h case    5:*/		return 0x82226E1C;
		  /* 82226E1Ch */ case    6:  		/* addi R11, R11, 16 */
		/* 82226E1Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82226E1Ch case    6:*/		return 0x82226E20;
		  /* 82226E20h */ case    7:  		/* and R8, R10, R29 */
		/* 82226E20h case    7:*/		cpu::op::and<0>(regs,&regs.R8,regs.R10,regs.R29);
		/* 82226E20h case    7:*/		return 0x82226E24;
		  /* 82226E24h */ case    8:  		/* ori R9, R11, 3 */
		/* 82226E24h case    8:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R11,0x3);
		/* 82226E24h case    8:*/		return 0x82226E28;
		  /* 82226E28h */ case    9:  		/* mr R6, R27 */
		/* 82226E28h case    9:*/		regs.R6 = regs.R27;
		/* 82226E28h case    9:*/		return 0x82226E2C;
		  /* 82226E2Ch */ case   10:  		/* mr R5, R25 */
		/* 82226E2Ch case   10:*/		regs.R5 = regs.R25;
		/* 82226E2Ch case   10:*/		return 0x82226E30;
	}
	return 0x82226E30;
} // Block from 82226E04h-82226E30h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82226E30h
// Function '?MakeInstr_T_TFETCH@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226E30);
		  /* 82226E30h */ case    0:  		/* mr R4, R26 */
		/* 82226E30h case    0:*/		regs.R4 = regs.R26;
		/* 82226E30h case    0:*/		return 0x82226E34;
		  /* 82226E34h */ case    1:  		/* mr R3, R31 */
		/* 82226E34h case    1:*/		regs.R3 = regs.R31;
		/* 82226E34h case    1:*/		return 0x82226E38;
		  /* 82226E38h */ case    2:  		/* bl -6648 */
		/* 82226E38h case    2:*/		regs.LR = 0x82226E3C; return 0x82225440;
		/* 82226E38h case    2:*/		return 0x82226E3C;
		  /* 82226E3Ch */ case    3:  		/* addi R1, R1, 144 */
		/* 82226E3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82226E3Ch case    3:*/		return 0x82226E40;
		  /* 82226E40h */ case    4:  		/* b -1661860 */
		/* 82226E40h case    4:*/		return 0x8209129C;
		/* 82226E40h case    4:*/		return 0x82226E44;
	}
	return 0x82226E44;
} // Block from 82226E30h-82226E44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226E44);
		  /* 82226E44h */ case    0:  		/* mr R3, R30 */
		/* 82226E44h case    0:*/		regs.R3 = regs.R30;
		/* 82226E44h case    0:*/		return 0x82226E48;
		  /* 82226E48h */ case    1:  		/* b -12 */
		/* 82226E48h case    1:*/		return 0x82226E3C;
		/* 82226E48h case    1:*/		return 0x82226E4C;
		  /* 82226E4Ch */ case    2:  		/* nop */
		/* 82226E4Ch case    2:*/		cpu::op::nop();
		/* 82226E4Ch case    2:*/		return 0x82226E50;
	}
	return 0x82226E50;
} // Block from 82226E44h-82226E50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82226E50h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226E50);
		  /* 82226E50h */ case    0:  		/* mfspr R12, LR */
		/* 82226E50h case    0:*/		regs.R12 = regs.LR;
		/* 82226E50h case    0:*/		return 0x82226E54;
		  /* 82226E54h */ case    1:  		/* bl -1661964 */
		/* 82226E54h case    1:*/		regs.LR = 0x82226E58; return 0x82091248;
		/* 82226E54h case    1:*/		return 0x82226E58;
		  /* 82226E58h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82226E58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82226E58h case    2:*/		return 0x82226E5C;
		  /* 82226E5Ch */ case    3:  		/* stfs FR2, <#[R1 + 244]> */
		/* 82226E5Ch case    3:*/		cpu::mem::store32f( regs, regs.FR2, (uint32)(regs.R1 + 0x000000F4) );
		/* 82226E5Ch case    3:*/		return 0x82226E60;
		  /* 82226E60h */ case    4:  		/* lwz R9, <#[R1 + 244]> */
		/* 82226E60h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000F4) );
		/* 82226E60h case    4:*/		return 0x82226E64;
		  /* 82226E64h */ case    5:  		/* stfs FR3, <#[R1 + 252]> */
		/* 82226E64h case    5:*/		cpu::mem::store32f( regs, regs.FR3, (uint32)(regs.R1 + 0x000000FC) );
		/* 82226E64h case    5:*/		return 0x82226E68;
		  /* 82226E68h */ case    6:  		/* lwz R11, <#[R1 + 252]> */
		/* 82226E68h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000FC) );
		/* 82226E68h case    6:*/		return 0x82226E6C;
		  /* 82226E6Ch */ case    7:  		/* stfs FR4, <#[R1 + 260]> */
		/* 82226E6Ch case    7:*/		cpu::mem::store32f( regs, regs.FR4, (uint32)(regs.R1 + 0x00000104) );
		/* 82226E6Ch case    7:*/		return 0x82226E70;
		  /* 82226E70h */ case    8:  		/* lwz R10, <#[R1 + 260]> */
		/* 82226E70h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 82226E70h case    8:*/		return 0x82226E74;
		  /* 82226E74h */ case    9:  		/* add R11, R10, R11 */
		/* 82226E74h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82226E74h case    9:*/		return 0x82226E78;
		  /* 82226E78h */ case   10:  		/* stfs FR1, <#[R1 + 236]> */
		/* 82226E78h case   10:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x000000EC) );
		/* 82226E78h case   10:*/		return 0x82226E7C;
		  /* 82226E7Ch */ case   11:  		/* add R11, R11, R9 */
		/* 82226E7Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82226E7Ch case   11:*/		return 0x82226E80;
		  /* 82226E80h */ case   12:  		/* lwz R10, <#[R1 + 236]> */
		/* 82226E80h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000EC) );
		/* 82226E80h case   12:*/		return 0x82226E84;
		  /* 82226E84h */ case   13:  		/* li R8, 7 */
		/* 82226E84h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x7);
		/* 82226E84h case   13:*/		return 0x82226E88;
		  /* 82226E88h */ case   14:  		/* stfs FR1, <#[R1 + 96]> */
		/* 82226E88h case   14:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000060) );
		/* 82226E88h case   14:*/		return 0x82226E8C;
		  /* 82226E8Ch */ case   15:  		/* add R11, R11, R10 */
		/* 82226E8Ch case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82226E8Ch case   15:*/		return 0x82226E90;
		  /* 82226E90h */ case   16:  		/* stfs FR3, <#[R1 + 104]> */
		/* 82226E90h case   16:*/		cpu::mem::store32f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000068) );
		/* 82226E90h case   16:*/		return 0x82226E94;
		  /* 82226E94h */ case   17:  		/* divwu R10, R11, R8 */
		/* 82226E94h case   17:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R8);
		/* 82226E94h case   17:*/		return 0x82226E98;
		  /* 82226E98h */ case   18:  		/* stfs FR2, <#[R1 + 100]> */
		/* 82226E98h case   18:*/		cpu::mem::store32f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000064) );
		/* 82226E98h case   18:*/		return 0x82226E9C;
		  /* 82226E9Ch */ case   19:  		/* mr R31, R4 */
		/* 82226E9Ch case   19:*/		regs.R31 = regs.R4;
		/* 82226E9Ch case   19:*/		return 0x82226EA0;
		  /* 82226EA0h */ case   20:  		/* stfs FR4, <#[R1 + 108]> */
		/* 82226EA0h case   20:*/		cpu::mem::store32f( regs, regs.FR4, (uint32)(regs.R1 + 0x0000006C) );
		/* 82226EA0h case   20:*/		return 0x82226EA4;
		  /* 82226EA4h */ case   21:  		/* mulli R10, R10, 7 */
		/* 82226EA4h case   21:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x7);
		/* 82226EA4h case   21:*/		return 0x82226EA8;
		  /* 82226EA8h */ case   22:  		/* subf R11, R10, R11 */
		/* 82226EA8h case   22:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82226EA8h case   22:*/		return 0x82226EAC;
		  /* 82226EACh */ case   23:  		/* mr R27, R3 */
		/* 82226EACh case   23:*/		regs.R27 = regs.R3;
		/* 82226EACh case   23:*/		return 0x82226EB0;
		  /* 82226EB0h */ case   24:  		/* addi R11, R11, 15 */
		/* 82226EB0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xF);
		/* 82226EB0h case   24:*/		return 0x82226EB4;
		  /* 82226EB4h */ case   25:  		/* mr R29, R5 */
		/* 82226EB4h case   25:*/		regs.R29 = regs.R5;
		/* 82226EB4h case   25:*/		return 0x82226EB8;
		  /* 82226EB8h */ case   26:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82226EB8h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82226EB8h case   26:*/		return 0x82226EBC;
		  /* 82226EBCh */ case   27:  		/* lwzx R4, <#[R28 + R4]> */
		/* 82226EBCh case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + regs.R4 + 0x00000000) );
		/* 82226EBCh case   27:*/		return 0x82226EC0;
		  /* 82226EC0h */ case   28:  		/* cmplwi CR6, R4, 0 */
		/* 82226EC0h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82226EC0h case   28:*/		return 0x82226EC4;
		  /* 82226EC4h */ case   29:  		/* bc 12, CR6_EQ, 188 */
		/* 82226EC4h case   29:*/		if ( regs.CR[6].eq ) { return 0x82226F80;  }
		/* 82226EC4h case   29:*/		return 0x82226EC8;
		  /* 82226EC8h */ case   30:  		/* li R25, 1 */
		/* 82226EC8h case   30:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82226EC8h case   30:*/		return 0x82226ECC;
		  /* 82226ECCh */ case   31:  		/* lwz R11, <#[R4 + 20]> */
		/* 82226ECCh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82226ECCh case   31:*/		return 0x82226ED0;
		  /* 82226ED0h */ case   32:  		/* rlwinm. R11, R11, 0, 22, 29 */
		/* 82226ED0h case   32:*/		cpu::op::rlwinm<1,0,22,29>(regs,&regs.R11,regs.R11);
		/* 82226ED0h case   32:*/		return 0x82226ED4;
		  /* 82226ED4h */ case   33:  		/* bc 4, CR0_EQ, 160 */
		/* 82226ED4h case   33:*/		if ( !regs.CR[0].eq ) { return 0x82226F74;  }
		/* 82226ED4h case   33:*/		return 0x82226ED8;
		  /* 82226ED8h */ case   34:  		/* lwz R11, <#[R4 + 8]> */
		/* 82226ED8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82226ED8h case   34:*/		return 0x82226EDC;
		  /* 82226EDCh */ case   35:  		/* rlwinm R26, R11, 18, 29, 31 */
		/* 82226EDCh case   35:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R26,regs.R11);
		/* 82226EDCh case   35:*/		return 0x82226EE0;
		  /* 82226EE0h */ case   36:  		/* cmplw CR6, R26, R29 */
		/* 82226EE0h case   36:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R29);
		/* 82226EE0h case   36:*/		return 0x82226EE4;
		  /* 82226EE4h */ case   37:  		/* bc 12, CR6_LT, 144 */
		/* 82226EE4h case   37:*/		if ( regs.CR[6].lt ) { return 0x82226F74;  }
		/* 82226EE4h case   37:*/		return 0x82226EE8;
		  /* 82226EE8h */ case   38:  		/* li R5, 0 */
		/* 82226EE8h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82226EE8h case   38:*/		return 0x82226EEC;
		  /* 82226EECh */ case   39:  		/* li R30, 0 */
		/* 82226EECh case   39:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82226EECh case   39:*/		return 0x82226EF0;
		  /* 82226EF0h */ case   40:  		/* li R7, 0 */
		/* 82226EF0h case   40:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82226EF0h case   40:*/		return 0x82226EF4;
		  /* 82226EF4h */ case   41:  		/* cmplwi CR6, R26, 0 */
		/* 82226EF4h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82226EF4h case   41:*/		return 0x82226EF8;
		  /* 82226EF8h */ case   42:  		/* bc 12, CR6_EQ, 104 */
		/* 82226EF8h case   42:*/		if ( regs.CR[6].eq ) { return 0x82226F60;  }
		/* 82226EF8h case   42:*/		return 0x82226EFC;
		  /* 82226EFCh */ case   43:  		/* addi R6, R4, 44 */
		/* 82226EFCh case   43:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R4,0x2C);
		/* 82226EFCh case   43:*/		return 0x82226F00;
		  /* 82226F00h */ case   44:  		/* li R9, 4 */
		/* 82226F00h case   44:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82226F00h case   44:*/		return 0x82226F04;
		  /* 82226F04h */ case   45:  		/* lwz R3, <#[R6]> */
		/* 82226F04h case   45:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + 0x00000000) );
		/* 82226F04h case   45:*/		return 0x82226F08;
	}
	return 0x82226F08;
} // Block from 82226E50h-82226F08h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82226F08h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226F08);
		  /* 82226F08h */ case    0:  		/* li R10, 0 */
		/* 82226F08h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82226F08h case    0:*/		return 0x82226F0C;
		  /* 82226F0Ch */ case    1:  		/* li R11, 0 */
		/* 82226F0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82226F0Ch case    1:*/		return 0x82226F10;
		  /* 82226F10h */ case    2:  		/* addi R8, R1, 96 */
		/* 82226F10h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82226F10h case    2:*/		return 0x82226F14;
		  /* 82226F14h */ case    3:  		/* mtspr CTR, R9 */
		/* 82226F14h case    3:*/		regs.CTR = regs.R9;
		/* 82226F14h case    3:*/		return 0x82226F18;
		  /* 82226F18h */ case    4:  		/* lwz R9, <#[R8]> */
		/* 82226F18h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82226F18h case    4:*/		return 0x82226F1C;
		  /* 82226F1Ch */ case    5:  		/* cmpw CR6, R3, R9 */
		/* 82226F1Ch case    5:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R9);
		/* 82226F1Ch case    5:*/		return 0x82226F20;
		  /* 82226F20h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 82226F20h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82226F40;  }
		/* 82226F20h case    6:*/		return 0x82226F24;
		  /* 82226F24h */ case    7:  		/* li R9, 3 */
		/* 82226F24h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 82226F24h case    7:*/		return 0x82226F28;
		  /* 82226F28h */ case    8:  		/* slw R24, R25, R10 */
		/* 82226F28h case    8:*/		cpu::op::slw<0>(regs,&regs.R24,regs.R25,regs.R10);
		/* 82226F28h case    8:*/		return 0x82226F2C;
		  /* 82226F2Ch */ case    9:  		/* slw R9, R9, R11 */
		/* 82226F2Ch case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82226F2Ch case    9:*/		return 0x82226F30;
		  /* 82226F30h */ case   10:  		/* andc R9, R30, R9 */
		/* 82226F30h case   10:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 82226F30h case   10:*/		return 0x82226F34;
		  /* 82226F34h */ case   11:  		/* slw R30, R7, R11 */
		/* 82226F34h case   11:*/		cpu::op::slw<0>(regs,&regs.R30,regs.R7,regs.R11);
		/* 82226F34h case   11:*/		return 0x82226F38;
		  /* 82226F38h */ case   12:  		/* or R5, R24, R5 */
		/* 82226F38h case   12:*/		cpu::op::or<0>(regs,&regs.R5,regs.R24,regs.R5);
		/* 82226F38h case   12:*/		return 0x82226F3C;
		  /* 82226F3Ch */ case   13:  		/* or R30, R9, R30 */
		/* 82226F3Ch case   13:*/		cpu::op::or<0>(regs,&regs.R30,regs.R9,regs.R30);
		/* 82226F3Ch case   13:*/		return 0x82226F40;
	}
	return 0x82226F40;
} // Block from 82226F08h-82226F40h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82226F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226F40);
		  /* 82226F40h */ case    0:  		/* addi R10, R10, 1 */
		/* 82226F40h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82226F40h case    0:*/		return 0x82226F44;
		  /* 82226F44h */ case    1:  		/* addi R8, R8, 4 */
		/* 82226F44h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82226F44h case    1:*/		return 0x82226F48;
		  /* 82226F48h */ case    2:  		/* addi R11, R11, 2 */
		/* 82226F48h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82226F48h case    2:*/		return 0x82226F4C;
		  /* 82226F4Ch */ case    3:  		/* bc 16, CR0_LT, -52 */
		/* 82226F4Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82226F18;  }
		/* 82226F4Ch case    3:*/		return 0x82226F50;
		  /* 82226F50h */ case    4:  		/* addi R7, R7, 1 */
		/* 82226F50h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82226F50h case    4:*/		return 0x82226F54;
		  /* 82226F54h */ case    5:  		/* addi R6, R6, 4 */
		/* 82226F54h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 82226F54h case    5:*/		return 0x82226F58;
		  /* 82226F58h */ case    6:  		/* cmplw CR6, R7, R26 */
		/* 82226F58h case    6:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 82226F58h case    6:*/		return 0x82226F5C;
		  /* 82226F5Ch */ case    7:  		/* bc 12, CR6_LT, -92 */
		/* 82226F5Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x82226F00;  }
		/* 82226F5Ch case    7:*/		return 0x82226F60;
	}
	return 0x82226F60;
} // Block from 82226F40h-82226F60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82226F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226F60);
		  /* 82226F60h */ case    0:  		/* slw R11, R25, R29 */
		/* 82226F60h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R29);
		/* 82226F60h case    0:*/		return 0x82226F64;
		  /* 82226F64h */ case    1:  		/* addi R10, R5, 1 */
		/* 82226F64h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x1);
		/* 82226F64h case    1:*/		return 0x82226F68;
		  /* 82226F68h */ case    2:  		/* addi R11, R11, -1 */
		/* 82226F68h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82226F68h case    2:*/		return 0x82226F6C;
		  /* 82226F6Ch */ case    3:  		/* and. R11, R11, R10 */
		/* 82226F6Ch case    3:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82226F6Ch case    3:*/		return 0x82226F70;
		  /* 82226F70h */ case    4:  		/* bc 12, CR0_EQ, 116 */
		/* 82226F70h case    4:*/		if ( regs.CR[0].eq ) { return 0x82226FE4;  }
		/* 82226F70h case    4:*/		return 0x82226F74;
	}
	return 0x82226F74;
} // Block from 82226F60h-82226F74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82226F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226F74);
		  /* 82226F74h */ case    0:  		/* lwz R4, <#[R4 + 32]> */
		/* 82226F74h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000020) );
		/* 82226F74h case    0:*/		return 0x82226F78;
		  /* 82226F78h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 82226F78h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82226F78h case    1:*/		return 0x82226F7C;
		  /* 82226F7Ch */ case    2:  		/* bc 4, CR6_EQ, -176 */
		/* 82226F7Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82226ECC;  }
		/* 82226F7Ch case    2:*/		return 0x82226F80;
	}
	return 0x82226F80;
} // Block from 82226F74h-82226F80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82226F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226F80);
		  /* 82226F80h */ case    0:  		/* addi R11, R1, 80 */
		/* 82226F80h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82226F80h case    0:*/		return 0x82226F84;
		  /* 82226F84h */ case    1:  		/* li R10, 0 */
		/* 82226F84h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82226F84h case    1:*/		return 0x82226F88;
		  /* 82226F88h */ case    2:  		/* addi R5, R1, 96 */
		/* 82226F88h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82226F88h case    2:*/		return 0x82226F8C;
		  /* 82226F8Ch */ case    3:  		/* mr R4, R29 */
		/* 82226F8Ch case    3:*/		regs.R4 = regs.R29;
		/* 82226F8Ch case    3:*/		return 0x82226F90;
		  /* 82226F90h */ case    4:  		/* mr R3, R31 */
		/* 82226F90h case    4:*/		regs.R3 = regs.R31;
		/* 82226F90h case    4:*/		return 0x82226F94;
		  /* 82226F94h */ case    5:  		/* stw R10, <#[R11]> */
		/* 82226F94h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82226F94h case    5:*/		return 0x82226F98;
		  /* 82226F98h */ case    6:  		/* lwz R6, <#[R1 + 80]> */
		/* 82226F98h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82226F98h case    6:*/		return 0x82226F9C;
		  /* 82226F9Ch */ case    7:  		/* bl -1188 */
		/* 82226F9Ch case    7:*/		regs.LR = 0x82226FA0; return 0x82226AF8;
		/* 82226F9Ch case    7:*/		return 0x82226FA0;
		  /* 82226FA0h */ case    8:  		/* lwz R11, <#[R1 + 84]> */
		/* 82226FA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82226FA0h case    8:*/		return 0x82226FA4;
		  /* 82226FA4h */ case    9:  		/* mr R10, R3 */
		/* 82226FA4h case    9:*/		regs.R10 = regs.R3;
		/* 82226FA4h case    9:*/		return 0x82226FA8;
		  /* 82226FA8h */ case   10:  		/* stw R3, <#[R1 + 80]> */
		/* 82226FA8h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82226FA8h case   10:*/		return 0x82226FAC;
		  /* 82226FACh */ case   11:  		/* rlwinm R11, R11, 0, 15, 15 */
		/* 82226FACh case   11:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R11,regs.R11);
		/* 82226FACh case   11:*/		return 0x82226FB0;
		  /* 82226FB0h */ case   12:  		/* lwzx R9, <#[R28 + R31]> */
		/* 82226FB0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82226FB0h case   12:*/		return 0x82226FB4;
		  /* 82226FB4h */ case   13:  		/* ori R11, R11, 1 */
		/* 82226FB4h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82226FB4h case   13:*/		return 0x82226FB8;
		  /* 82226FB8h */ case   14:  		/* stw R11, <#[R1 + 84]> */
		/* 82226FB8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82226FB8h case   14:*/		return 0x82226FBC;
		  /* 82226FBCh */ case   15:  		/* ld R8, <#[R1 + 80]> */
		/* 82226FBCh case   15:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82226FBCh case   15:*/		return 0x82226FC0;
		  /* 82226FC0h */ case   16:  		/* stw R9, <#[R3 + 32]> */
		/* 82226FC0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000020) );
		/* 82226FC0h case   16:*/		return 0x82226FC4;
		  /* 82226FC4h */ case   17:  		/* stwx R3, <#[R28 + R31]> */
		/* 82226FC4h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82226FC4h case   17:*/		return 0x82226FC8;
		  /* 82226FC8h */ case   18:  		/* lwz R11, <#[R31 + 88]> */
		/* 82226FC8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 82226FC8h case   18:*/		return 0x82226FCC;
		  /* 82226FCCh */ case   19:  		/* addi R11, R11, 1 */
		/* 82226FCCh case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82226FCCh case   19:*/		return 0x82226FD0;
		  /* 82226FD0h */ case   20:  		/* std R8, <#[R27]> */
		/* 82226FD0h case   20:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R27 + 0x00000000) );
		/* 82226FD0h case   20:*/		return 0x82226FD4;
		  /* 82226FD4h */ case   21:  		/* stw R11, <#[R31 + 88]> */
		/* 82226FD4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 82226FD4h case   21:*/		return 0x82226FD8;
		  /* 82226FD8h */ case   22:  		/* mr R3, R27 */
		/* 82226FD8h case   22:*/		regs.R3 = regs.R27;
		/* 82226FD8h case   22:*/		return 0x82226FDC;
		  /* 82226FDCh */ case   23:  		/* addi R1, R1, 192 */
		/* 82226FDCh case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82226FDCh case   23:*/		return 0x82226FE0;
	}
	return 0x82226FE0;
} // Block from 82226F80h-82226FE0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82226FE0h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV32@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226FE0);
		  /* 82226FE0h */ case    0:  		/* b -1662280 */
		/* 82226FE0h case    0:*/		return 0x82091298;
		/* 82226FE0h case    0:*/		return 0x82226FE4;
	}
	return 0x82226FE4;
} // Block from 82226FE0h-82226FE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82226FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82226FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82226FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82226FE4);
		  /* 82226FE4h */ case    0:  		/* mr R3, R31 */
		/* 82226FE4h case    0:*/		regs.R3 = regs.R31;
		/* 82226FE4h case    0:*/		return 0x82226FE8;
		  /* 82226FE8h */ case    1:  		/* bl -716776 */
		/* 82226FE8h case    1:*/		regs.LR = 0x82226FEC; return 0x82178000;
		/* 82226FE8h case    1:*/		return 0x82226FEC;
		  /* 82226FECh */ case    2:  		/* rlwinm R8, R30, 0, 24, 31 */
		/* 82226FECh case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R30);
		/* 82226FECh case    2:*/		return 0x82226FF0;
		  /* 82226FF0h */ case    3:  		/* rlwinm R10, R29, 20, 9, 11 */
		/* 82226FF0h case    3:*/		cpu::op::rlwinm<0,20,9,11>(regs,&regs.R10,regs.R29);
		/* 82226FF0h case    3:*/		return 0x82226FF4;
		  /* 82226FF4h */ case    4:  		/* lwz R9, <#[R1 + 84]> */
		/* 82226FF4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82226FF4h case    4:*/		return 0x82226FF8;
		  /* 82226FF8h */ case    5:  		/* stw R3, <#[R1 + 80]> */
		/* 82226FF8h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82226FF8h case    5:*/		return 0x82226FFC;
		  /* 82226FFCh */ case    6:  		/* mr R11, R3 */
		/* 82226FFCh case    6:*/		regs.R11 = regs.R3;
		/* 82226FFCh case    6:*/		return 0x82227000;
		  /* 82227000h */ case    7:  		/* or R10, R10, R8 */
		/* 82227000h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82227000h case    7:*/		return 0x82227004;
		  /* 82227004h */ case    8:  		/* lwz R8, <#[R3]> */
		/* 82227004h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 82227004h case    8:*/		return 0x82227008;
		  /* 82227008h */ case    9:  		/* rlwinm R9, R9, 0, 15, 15 */
		/* 82227008h case    9:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R9,regs.R9);
		/* 82227008h case    9:*/		return 0x8222700C;
		  /* 8222700Ch */ case   10:  		/* rlwinm R8, R8, 0, 27, 18 */
		/* 8222700Ch case   10:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R8,regs.R8);
		/* 8222700Ch case   10:*/		return 0x82227010;
		  /* 82227010h */ case   11:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82227010h case   11:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82227010h case   11:*/		return 0x82227014;
		  /* 82227014h */ case   12:  		/* rlwinm R8, R8, 0, 7, 3 */
		/* 82227014h case   12:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R8,regs.R8);
		/* 82227014h case   12:*/		return 0x82227018;
		  /* 82227018h */ case   13:  		/* ori R9, R9, 2 */
		/* 82227018h case   13:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2);
		/* 82227018h case   13:*/		return 0x8222701C;
		  /* 8222701Ch */ case   14:  		/* or R10, R10, R8 */
		/* 8222701Ch case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8222701Ch case   14:*/		return 0x82227020;
		  /* 82227020h */ case   15:  		/* stw R9, <#[R1 + 84]> */
		/* 82227020h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82227020h case   15:*/		return 0x82227024;
		  /* 82227024h */ case   16:  		/* ld R9, <#[R1 + 80]> */
		/* 82227024h case   16:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82227024h case   16:*/		return 0x82227028;
		  /* 82227028h */ case   17:  		/* std R9, <#[R27]> */
		/* 82227028h case   17:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 82227028h case   17:*/		return 0x8222702C;
		  /* 8222702Ch */ case   18:  		/* stw R10, <#[R3]> */
		/* 8222702Ch case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8222702Ch case   18:*/		return 0x82227030;
		  /* 82227030h */ case   19:  		/* b -88 */
		/* 82227030h case   19:*/		return 0x82226FD8;
		/* 82227030h case   19:*/		return 0x82227034;
		  /* 82227034h */ case   20:  		/* nop */
		/* 82227034h case   20:*/		cpu::op::nop();
		/* 82227034h case   20:*/		return 0x82227038;
	}
	return 0x82227038;
} // Block from 82226FE4h-82227038h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82227038h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227038);
		  /* 82227038h */ case    0:  		/* mfspr R12, LR */
		/* 82227038h case    0:*/		regs.R12 = regs.LR;
		/* 82227038h case    0:*/		return 0x8222703C;
		  /* 8222703Ch */ case    1:  		/* bl -1662452 */
		/* 8222703Ch case    1:*/		regs.LR = 0x82227040; return 0x82091248;
		/* 8222703Ch case    1:*/		return 0x82227040;
		  /* 82227040h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82227040h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82227040h case    2:*/		return 0x82227044;
		  /* 82227044h */ case    3:  		/* mr R30, R3 */
		/* 82227044h case    3:*/		regs.R30 = regs.R3;
		/* 82227044h case    3:*/		return 0x82227048;
		  /* 82227048h */ case    4:  		/* mr R27, R4 */
		/* 82227048h case    4:*/		regs.R27 = regs.R4;
		/* 82227048h case    4:*/		return 0x8222704C;
		  /* 8222704Ch */ case    5:  		/* mr R26, R5 */
		/* 8222704Ch case    5:*/		regs.R26 = regs.R5;
		/* 8222704Ch case    5:*/		return 0x82227050;
		  /* 82227050h */ case    6:  		/* mr R24, R6 */
		/* 82227050h case    6:*/		regs.R24 = regs.R6;
		/* 82227050h case    6:*/		return 0x82227054;
		  /* 82227054h */ case    7:  		/* rlwinm R11, R6, 0, 24, 31 */
		/* 82227054h case    7:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R6);
		/* 82227054h case    7:*/		return 0x82227058;
		  /* 82227058h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 82227058h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82227058h case    8:*/		return 0x8222705C;
		  /* 8222705Ch */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 8222705Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82227074;  }
		/* 8222705Ch case    9:*/		return 0x82227060;
		  /* 82227060h */ case   10:  		/* addi R10, R5, -4 */
		/* 82227060h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFFFFFFC);
		/* 82227060h case   10:*/		return 0x82227064;
		  /* 82227064h */ case   11:  		/* mtspr CTR, R4 */
		/* 82227064h case   11:*/		regs.CTR = regs.R4;
		/* 82227064h case   11:*/		return 0x82227068;
		  /* 82227068h */ case   12:  		/* lwzu R9, <#[R10 + 4]> */
		/* 82227068h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82227068h case   12:*/		return 0x8222706C;
		  /* 8222706Ch */ case   13:  		/* add R11, R9, R11 */
		/* 8222706Ch case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8222706Ch case   13:*/		return 0x82227070;
		  /* 82227070h */ case   14:  		/* bc 16, CR0_LT, -8 */
		/* 82227070h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82227068;  }
		/* 82227070h case   14:*/		return 0x82227074;
	}
	return 0x82227074;
} // Block from 82227038h-82227074h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82227074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227074);
		  /* 82227074h */ case    0:  		/* li R10, 7 */
		/* 82227074h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 82227074h case    0:*/		return 0x82227078;
		  /* 82227078h */ case    1:  		/* divwu R10, R11, R10 */
		/* 82227078h case    1:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82227078h case    1:*/		return 0x8222707C;
		  /* 8222707Ch */ case    2:  		/* mulli R10, R10, 7 */
		/* 8222707Ch case    2:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x7);
		/* 8222707Ch case    2:*/		return 0x82227080;
		  /* 82227080h */ case    3:  		/* subf R11, R10, R11 */
		/* 82227080h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82227080h case    3:*/		return 0x82227084;
		  /* 82227084h */ case    4:  		/* addi R11, R11, 15 */
		/* 82227084h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xF);
		/* 82227084h case    4:*/		return 0x82227088;
		  /* 82227088h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82227088h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82227088h case    5:*/		return 0x8222708C;
		  /* 8222708Ch */ case    6:  		/* add R28, R11, R30 */
		/* 8222708Ch case    6:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R30);
		/* 8222708Ch case    6:*/		return 0x82227090;
		  /* 82227090h */ case    7:  		/* mr R29, R28 */
		/* 82227090h case    7:*/		regs.R29 = regs.R28;
		/* 82227090h case    7:*/		return 0x82227094;
		  /* 82227094h */ case    8:  		/* lwzx R31, <#[R11 + R30]> */
		/* 82227094h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82227094h case    8:*/		return 0x82227098;
		  /* 82227098h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 82227098h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82227098h case    9:*/		return 0x8222709C;
		  /* 8222709Ch */ case   10:  		/* bc 12, CR6_EQ, 228 */
		/* 8222709Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82227180;  }
		/* 8222709Ch case   10:*/		return 0x822270A0;
		  /* 822270A0h */ case   11:  		/* rlwinm R25, R24, 0, 24, 31 */
		/* 822270A0h case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R25,regs.R24);
		/* 822270A0h case   11:*/		return 0x822270A4;
		  /* 822270A4h */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 822270A4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822270A4h case   12:*/		return 0x822270A8;
	}
	return 0x822270A8;
} // Block from 82227074h-822270A8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822270A8h
// Function '?MakeInstr_V_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV32@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822270A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822270A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822270A8);
		  /* 822270A8h */ case    0:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 822270A8h case    0:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 822270A8h case    0:*/		return 0x822270AC;
		  /* 822270ACh */ case    1:  		/* cmplwi CR6, R10, 14720 */
		/* 822270ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003980);
		/* 822270ACh case    1:*/		return 0x822270B0;
		  /* 822270B0h */ case    2:  		/* bc 4, CR6_EQ, 88 */
		/* 822270B0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82227108;  }
		/* 822270B0h case    2:*/		return 0x822270B4;
		  /* 822270B4h */ case    3:  		/* lwz R11, <#[R31 + 32]> */
		/* 822270B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 822270B4h case    3:*/		return 0x822270B8;
		  /* 822270B8h */ case    4:  		/* stw R11, <#[R29]> */
		/* 822270B8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 822270B8h case    4:*/		return 0x822270BC;
		  /* 822270BCh */ case    5:  		/* lwz R11, <#[R30 + 40]> */
		/* 822270BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 822270BCh case    5:*/		return 0x822270C0;
		  /* 822270C0h */ case    6:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 822270C0h case    6:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 822270C0h case    6:*/		return 0x822270C4;
		  /* 822270C4h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 822270C4h case    7:*/		if ( regs.CR[0].eq ) { return 0x822270D8;  }
		/* 822270C4h case    7:*/		return 0x822270C8;
		  /* 822270C8h */ case    8:  		/* lwz R11, <#[R30 + 540]> */
		/* 822270C8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000021C) );
		/* 822270C8h case    8:*/		return 0x822270CC;
		  /* 822270CCh */ case    9:  		/* stw R11, <#[R31 + 32]> */
		/* 822270CCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 822270CCh case    9:*/		return 0x822270D0;
		  /* 822270D0h */ case   10:  		/* stw R31, <#[R30 + 540]> */
		/* 822270D0h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000021C) );
		/* 822270D0h case   10:*/		return 0x822270D4;
		  /* 822270D4h */ case   11:  		/* b 160 */
		/* 822270D4h case   11:*/		return 0x82227174;
		/* 822270D4h case   11:*/		return 0x822270D8;
	}
	return 0x822270D8;
} // Block from 822270A8h-822270D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822270D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822270D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822270D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822270D8);
		  /* 822270D8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822270D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822270D8h case    0:*/		return 0x822270DC;
		  /* 822270DCh */ case    1:  		/* mr R3, R30 */
		/* 822270DCh case    1:*/		regs.R3 = regs.R30;
		/* 822270DCh case    1:*/		return 0x822270E0;
		  /* 822270E0h */ case    2:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 822270E0h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 822270E0h case    2:*/		return 0x822270E4;
		  /* 822270E4h */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 822270E4h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 822270E4h case    3:*/		return 0x822270E8;
		  /* 822270E8h */ case    4:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 822270E8h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 822270E8h case    4:*/		return 0x822270EC;
		  /* 822270ECh */ case    5:  		/* bl -797884 */
		/* 822270ECh case    5:*/		regs.LR = 0x822270F0; return 0x82164430;
		/* 822270ECh case    5:*/		return 0x822270F0;
		  /* 822270F0h */ case    6:  		/* mr R5, R3 */
		/* 822270F0h case    6:*/		regs.R5 = regs.R3;
		/* 822270F0h case    6:*/		return 0x822270F4;
		  /* 822270F4h */ case    7:  		/* mr R4, R31 */
		/* 822270F4h case    7:*/		regs.R4 = regs.R31;
		/* 822270F4h case    7:*/		return 0x822270F8;
		  /* 822270F8h */ case    8:  		/* mr R3, R30 */
		/* 822270F8h case    8:*/		regs.R3 = regs.R30;
		/* 822270F8h case    8:*/		return 0x822270FC;
		  /* 822270FCh */ case    9:  		/* li R6, 35 */
		/* 822270FCh case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x23);
		/* 822270FCh case    9:*/		return 0x82227100;
		  /* 82227100h */ case   10:  		/* bl -795752 */
		/* 82227100h case   10:*/		regs.LR = 0x82227104; return 0x82164C98;
		/* 82227100h case   10:*/		return 0x82227104;
		  /* 82227104h */ case   11:  		/* b 112 */
		/* 82227104h case   11:*/		return 0x82227174;
		/* 82227104h case   11:*/		return 0x82227108;
	}
	return 0x82227108;
} // Block from 822270D8h-82227108h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82227108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227108);
		  /* 82227108h */ case    0:  		/* lwz R10, <#[R30 + 40]> */
		/* 82227108h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 82227108h case    0:*/		return 0x8222710C;
		  /* 8222710Ch */ case    1:  		/* nor R10, R10, R10 */
		/* 8222710Ch case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222710Ch case    1:*/		return 0x82227110;
		  /* 82227110h */ case    2:  		/* rlwinm. R10, R10, 18, 31, 31 */
		/* 82227110h case    2:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R10,regs.R10);
		/* 82227110h case    2:*/		return 0x82227114;
		  /* 82227114h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 82227114h case    3:*/		if ( regs.CR[0].eq ) { return 0x82227128;  }
		/* 82227114h case    3:*/		return 0x82227118;
		  /* 82227118h */ case    4:  		/* lwz R10, <#[R31 + 20]> */
		/* 82227118h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82227118h case    4:*/		return 0x8222711C;
		  /* 8222711Ch */ case    5:  		/* rlwinm R10, R10, 30, 24, 31 */
		/* 8222711Ch case    5:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R10,regs.R10);
		/* 8222711Ch case    5:*/		return 0x82227120;
		  /* 82227120h */ case    6:  		/* cmplw CR6, R25, R10 */
		/* 82227120h case    6:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 82227120h case    6:*/		return 0x82227124;
		  /* 82227124h */ case    7:  		/* bc 4, CR6_EQ, 76 */
		/* 82227124h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82227170;  }
		/* 82227124h case    7:*/		return 0x82227128;
	}
	return 0x82227128;
} // Block from 82227108h-82227128h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82227128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227128);
		  /* 82227128h */ case    0:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82227128h case    0:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82227128h case    0:*/		return 0x8222712C;
		  /* 8222712Ch */ case    1:  		/* cmplw CR6, R11, R27 */
		/* 8222712Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 8222712Ch case    1:*/		return 0x82227130;
		  /* 82227130h */ case    2:  		/* bc 12, CR6_LT, 64 */
		/* 82227130h case    2:*/		if ( regs.CR[6].lt ) { return 0x82227170;  }
		/* 82227130h case    2:*/		return 0x82227134;
		  /* 82227134h */ case    3:  		/* li R7, 1 */
		/* 82227134h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82227134h case    3:*/		return 0x82227138;
		  /* 82227138h */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 82227138h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82227138h case    4:*/		return 0x8222713C;
		  /* 8222713Ch */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 8222713Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82227168;  }
		/* 8222713Ch case    5:*/		return 0x82227140;
		  /* 82227140h */ case    6:  		/* addi R10, R26, -4 */
		/* 82227140h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0xFFFFFFFC);
		/* 82227140h case    6:*/		return 0x82227144;
		  /* 82227144h */ case    7:  		/* mtspr CTR, R27 */
		/* 82227144h case    7:*/		regs.CTR = regs.R27;
		/* 82227144h case    7:*/		return 0x82227148;
		  /* 82227148h */ case    8:  		/* addi R11, R31, 40 */
		/* 82227148h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x28);
		/* 82227148h case    8:*/		return 0x8222714C;
		  /* 8222714Ch */ case    9:  		/* lwzu R9, <#[R11 + 4]> */
		/* 8222714Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8222714Ch case    9:*/		return 0x82227150;
		  /* 82227150h */ case   10:  		/* lwzu R8, <#[R10 + 4]> */
		/* 82227150h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82227150h case   10:*/		return 0x82227154;
		  /* 82227154h */ case   11:  		/* subf R9, R8, R9 */
		/* 82227154h case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82227154h case   11:*/		return 0x82227158;
		  /* 82227158h */ case   12:  		/* cntlzw R9, R9 */
		/* 82227158h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 82227158h case   12:*/		return 0x8222715C;
		  /* 8222715Ch */ case   13:  		/* rlwinm R9, R9, 27, 31, 31 */
		/* 8222715Ch case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R9,regs.R9);
		/* 8222715Ch case   13:*/		return 0x82227160;
		  /* 82227160h */ case   14:  		/* and R7, R9, R7 */
		/* 82227160h case   14:*/		cpu::op::and<0>(regs,&regs.R7,regs.R9,regs.R7);
		/* 82227160h case   14:*/		return 0x82227164;
		  /* 82227164h */ case   15:  		/* bc 16, CR0_LT, -24 */
		/* 82227164h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8222714C;  }
		/* 82227164h case   15:*/		return 0x82227168;
	}
	return 0x82227168;
} // Block from 82227128h-82227168h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82227168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227168);
		  /* 82227168h */ case    0:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 82227168h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 82227168h case    0:*/		return 0x8222716C;
		  /* 8222716Ch */ case    1:  		/* bc 4, CR0_EQ, 68 */
		/* 8222716Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x822271B0;  }
		/* 8222716Ch case    1:*/		return 0x82227170;
	}
	return 0x82227170;
} // Block from 82227168h-82227170h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82227170h
// Function '?ComputeQuaternaryOperatorPrecision@Compiler@D3DXShader@@SA?AW4ConstantValueType@2@V?$BitFieldSet@V?$FixedSizeBitSet@I$00@D3DXShader@@II$01@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227170);
		  /* 82227170h */ case    0:  		/* addi R29, R31, 32 */
		/* 82227170h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x20);
		/* 82227170h case    0:*/		return 0x82227174;
	}
	return 0x82227174;
} // Block from 82227170h-82227174h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227174);
		  /* 82227174h */ case    0:  		/* lwz R31, <#[R29]> */
		/* 82227174h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 82227174h case    0:*/		return 0x82227178;
		  /* 82227178h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82227178h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82227178h case    1:*/		return 0x8222717C;
		  /* 8222717Ch */ case    2:  		/* bc 4, CR6_EQ, -216 */
		/* 8222717Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x822270A4;  }
		/* 8222717Ch case    2:*/		return 0x82227180;
	}
	return 0x82227180;
} // Block from 82227174h-82227180h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82227180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227180);
		  /* 82227180h */ case    0:  		/* mr R6, R24 */
		/* 82227180h case    0:*/		regs.R6 = regs.R24;
		/* 82227180h case    0:*/		return 0x82227184;
		  /* 82227184h */ case    1:  		/* mr R5, R26 */
		/* 82227184h case    1:*/		regs.R5 = regs.R26;
		/* 82227184h case    1:*/		return 0x82227188;
		  /* 82227188h */ case    2:  		/* mr R4, R27 */
		/* 82227188h case    2:*/		regs.R4 = regs.R27;
		/* 82227188h case    2:*/		return 0x8222718C;
		  /* 8222718Ch */ case    3:  		/* mr R3, R30 */
		/* 8222718Ch case    3:*/		regs.R3 = regs.R30;
		/* 8222718Ch case    3:*/		return 0x82227190;
		  /* 82227190h */ case    4:  		/* bl -1688 */
		/* 82227190h case    4:*/		regs.LR = 0x82227194; return 0x82226AF8;
		/* 82227190h case    4:*/		return 0x82227194;
		  /* 82227194h */ case    5:  		/* lwz R11, <#[R28]> */
		/* 82227194h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82227194h case    5:*/		return 0x82227198;
		  /* 82227198h */ case    6:  		/* stw R11, <#[R3 + 32]> */
		/* 82227198h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82227198h case    6:*/		return 0x8222719C;
		  /* 8222719Ch */ case    7:  		/* stw R3, <#[R28]> */
		/* 8222719Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 8222719Ch case    7:*/		return 0x822271A0;
		  /* 822271A0h */ case    8:  		/* lwz R11, <#[R30 + 88]> */
		/* 822271A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000058) );
		/* 822271A0h case    8:*/		return 0x822271A4;
		  /* 822271A4h */ case    9:  		/* addi R11, R11, 1 */
		/* 822271A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822271A4h case    9:*/		return 0x822271A8;
		  /* 822271A8h */ case   10:  		/* stw R11, <#[R30 + 88]> */
		/* 822271A8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000058) );
		/* 822271A8h case   10:*/		return 0x822271AC;
		  /* 822271ACh */ case   11:  		/* b 8 */
		/* 822271ACh case   11:*/		return 0x822271B4;
		/* 822271ACh case   11:*/		return 0x822271B0;
	}
	return 0x822271B0;
} // Block from 82227180h-822271B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822271B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822271B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822271B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822271B0);
		  /* 822271B0h */ case    0:  		/* mr R3, R31 */
		/* 822271B0h case    0:*/		regs.R3 = regs.R31;
		/* 822271B0h case    0:*/		return 0x822271B4;
	}
	return 0x822271B4;
} // Block from 822271B0h-822271B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822271B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822271B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822271B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822271B4);
		  /* 822271B4h */ case    0:  		/* addi R1, R1, 160 */
		/* 822271B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822271B4h case    0:*/		return 0x822271B8;
	}
	return 0x822271B8;
} // Block from 822271B4h-822271B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822271B8h
// Function '?GetDependencyWithModifiers@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822271B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822271B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822271B8);
		  /* 822271B8h */ case    0:  		/* b -1662752 */
		/* 822271B8h case    0:*/		return 0x82091298;
		/* 822271B8h case    0:*/		return 0x822271BC;
		  /* 822271BCh */ case    1:  		/* nop */
		/* 822271BCh case    1:*/		cpu::op::nop();
		/* 822271BCh case    1:*/		return 0x822271C0;
	}
	return 0x822271C0;
} // Block from 822271B8h-822271C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822271C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822271C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822271C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822271C0);
		  /* 822271C0h */ case    0:  		/* mfspr R12, LR */
		/* 822271C0h case    0:*/		regs.R12 = regs.LR;
		/* 822271C0h case    0:*/		return 0x822271C4;
		  /* 822271C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822271C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822271C4h case    1:*/		return 0x822271C8;
		  /* 822271C8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822271C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822271C8h case    2:*/		return 0x822271CC;
		  /* 822271CCh */ case    3:  		/* addi R10, R1, 80 */
		/* 822271CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 822271CCh case    3:*/		return 0x822271D0;
		  /* 822271D0h */ case    4:  		/* li R11, 0 */
		/* 822271D0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822271D0h case    4:*/		return 0x822271D4;
		  /* 822271D4h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 822271D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 822271D4h case    5:*/		return 0x822271D8;
		  /* 822271D8h */ case    6:  		/* stw R11, <#[R10]> */
		/* 822271D8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 822271D8h case    6:*/		return 0x822271DC;
		  /* 822271DCh */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 822271DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x8222721C;  }
		/* 822271DCh case    7:*/		return 0x822271E0;
		  /* 822271E0h */ case    8:  		/* addi R9, R1, 92 */
		/* 822271E0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x5C);
		/* 822271E0h case    8:*/		return 0x822271E4;
		  /* 822271E4h */ case    9:  		/* mtspr CTR, R4 */
		/* 822271E4h case    9:*/		regs.CTR = regs.R4;
		/* 822271E4h case    9:*/		return 0x822271E8;
		  /* 822271E8h */ case   10:  		/* addi R10, R5, -4 */
		/* 822271E8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFFFFFFC);
		/* 822271E8h case   10:*/		return 0x822271EC;
		  /* 822271ECh */ case   11:  		/* rlwinm R7, R11, 29, 3, 29 */
		/* 822271ECh case   11:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R7,regs.R11);
		/* 822271ECh case   11:*/		return 0x822271F0;
		  /* 822271F0h */ case   12:  		/* lfs FR0, <#[R10 + 4]> */
		/* 822271F0h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		/* 822271F0h case   12:*/		return 0x822271F4;
		  /* 822271F4h */ case   13:  		/* addi R8, R1, 80 */
		/* 822271F4h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 822271F4h case   13:*/		return 0x822271F8;
		  /* 822271F8h */ case   14:  		/* lwzu R6, <#[R10 + 8]> */
		/* 822271F8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 822271F8h case   14:*/		return 0x822271FC;
		  /* 822271FCh */ case   15:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 822271FCh case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 822271FCh case   15:*/		return 0x82227200;
		  /* 82227200h */ case   16:  		/* stfsu FR0, <#[R9 + 4]> */
		/* 82227200h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82227200h case   16:*/		return 0x82227204;
		  /* 82227204h */ case   17:  		/* addi R11, R11, 2 */
		/* 82227204h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82227204h case   17:*/		return 0x82227208;
		  /* 82227208h */ case   18:  		/* slw R6, R6, R5 */
		/* 82227208h case   18:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 82227208h case   18:*/		return 0x8222720C;
		  /* 8222720Ch */ case   19:  		/* lwzx R5, <#[R7 + R8]> */
		/* 8222720Ch case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8222720Ch case   19:*/		return 0x82227210;
		  /* 82227210h */ case   20:  		/* or R6, R6, R5 */
		/* 82227210h case   20:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 82227210h case   20:*/		return 0x82227214;
		  /* 82227214h */ case   21:  		/* stwx R6, <#[R7 + R8]> */
		/* 82227214h case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82227214h case   21:*/		return 0x82227218;
		  /* 82227218h */ case   22:  		/* bc 16, CR0_LT, -44 */
		/* 82227218h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822271EC;  }
		/* 82227218h case   22:*/		return 0x8222721C;
	}
	return 0x8222721C;
} // Block from 822271C0h-8222721Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8222721Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222721C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222721C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222721C);
		  /* 8222721Ch */ case    0:  		/* addi R5, R1, 96 */
		/* 8222721Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8222721Ch case    0:*/		return 0x82227220;
		  /* 82227220h */ case    1:  		/* lwz R6, <#[R1 + 80]> */
		/* 82227220h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82227220h case    1:*/		return 0x82227224;
		  /* 82227224h */ case    2:  		/* bl -492 */
		/* 82227224h case    2:*/		regs.LR = 0x82227228; return 0x82227038;
		/* 82227224h case    2:*/		return 0x82227228;
		  /* 82227228h */ case    3:  		/* addi R1, R1, 128 */
		/* 82227228h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82227228h case    3:*/		return 0x8222722C;
		  /* 8222722Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222722Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222722Ch case    4:*/		return 0x82227230;
		  /* 82227230h */ case    5:  		/* mtspr LR, R12 */
		/* 82227230h case    5:*/		regs.LR = regs.R12;
		/* 82227230h case    5:*/		return 0x82227234;
		  /* 82227234h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82227234h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82227234h case    6:*/		return 0x82227238;
	}
	return 0x82227238;
} // Block from 8222721Ch-82227238h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82227238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227238);
		  /* 82227238h */ case    0:  		/* mfspr R12, LR */
		/* 82227238h case    0:*/		regs.R12 = regs.LR;
		/* 82227238h case    0:*/		return 0x8222723C;
		  /* 8222723Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222723Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222723Ch case    1:*/		return 0x82227240;
		  /* 82227240h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82227240h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82227240h case    2:*/		return 0x82227244;
		  /* 82227244h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82227244h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82227244h case    3:*/		return 0x82227248;
		  /* 82227248h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 82227248h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82227248h case    4:*/		return 0x8222724C;
		  /* 8222724Ch */ case    5:  		/* mr R10, R5 */
		/* 8222724Ch case    5:*/		regs.R10 = regs.R5;
		/* 8222724Ch case    5:*/		return 0x82227250;
		  /* 82227250h */ case    6:  		/* stw R6, <#[R1 + 188]> */
		/* 82227250h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000000BC) );
		/* 82227250h case    6:*/		return 0x82227254;
		  /* 82227254h */ case    7:  		/* li R7, 0 */
		/* 82227254h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82227254h case    7:*/		return 0x82227258;
		  /* 82227258h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 82227258h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82227258h case    8:*/		return 0x8222725C;
		  /* 8222725Ch */ case    9:  		/* bc 12, CR6_EQ, 168 */
		/* 8222725Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82227304;  }
		/* 8222725Ch case    9:*/		return 0x82227260;
		  /* 82227260h */ case   10:  		/* li R11, 0 */
		/* 82227260h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82227260h case   10:*/		return 0x82227264;
		  /* 82227264h */ case   11:  		/* addi R9, R1, 96 */
		/* 82227264h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 82227264h case   11:*/		return 0x82227268;
		  /* 82227268h */ case   12:  		/* addi R8, R11, 1 */
		/* 82227268h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 82227268h case   12:*/		return 0x8222726C;
		  /* 8222726Ch */ case   13:  		/* li R5, 2 */
		/* 8222726Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8222726Ch case   13:*/		return 0x82227270;
		  /* 82227270h */ case   14:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 82227270h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 82227270h case   14:*/		return 0x82227274;
		  /* 82227274h */ case   15:  		/* rlwinm R31, R11, 29, 3, 29 */
		/* 82227274h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R31,regs.R11);
		/* 82227274h case   15:*/		return 0x82227278;
		  /* 82227278h */ case   16:  		/* addi R30, R1, 188 */
		/* 82227278h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0xBC);
		/* 82227278h case   16:*/		return 0x8222727C;
		  /* 8222727Ch */ case   17:  		/* slw R8, R5, R8 */
		/* 8222727Ch case   17:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 8222727Ch case   17:*/		return 0x82227280;
		  /* 82227280h */ case   18:  		/* lwzx R5, <#[R31 + R30]> */
		/* 82227280h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 82227280h case   18:*/		return 0x82227284;
		  /* 82227284h */ case   19:  		/* addi R8, R8, -1 */
		/* 82227284h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82227284h case   19:*/		return 0x82227288;
		  /* 82227288h */ case   20:  		/* rlwinm R31, R11, 0, 27, 31 */
		/* 82227288h case   20:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R31,regs.R11);
		/* 82227288h case   20:*/		return 0x8222728C;
		  /* 8222728Ch */ case   21:  		/* li R30, -1 */
		/* 8222728Ch case   21:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 8222728Ch case   21:*/		return 0x82227290;
		  /* 82227290h */ case   22:  		/* and R8, R8, R5 */
		/* 82227290h case   22:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 82227290h case   22:*/		return 0x82227294;
		  /* 82227294h */ case   23:  		/* slw R5, R30, R31 */
		/* 82227294h case   23:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R30,regs.R31);
		/* 82227294h case   23:*/		return 0x82227298;
		  /* 82227298h */ case   24:  		/* and R8, R8, R5 */
		/* 82227298h case   24:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 82227298h case   24:*/		return 0x8222729C;
		  /* 8222729Ch */ case   25:  		/* srw R8, R8, R31 */
		/* 8222729Ch case   25:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R31);
		/* 8222729Ch case   25:*/		return 0x822272A0;
		  /* 822272A0h */ case   26:  		/* cmplwi CR6, R8, 1 */
		/* 822272A0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 822272A0h case   26:*/		return 0x822272A4;
		  /* 822272A4h */ case   27:  		/* bc 12, CR6_LT, 60 */
		/* 822272A4h case   27:*/		if ( regs.CR[6].lt ) { return 0x822272E0;  }
		/* 822272A4h case   27:*/		return 0x822272A8;
		  /* 822272A8h */ case   28:  		/* bc 12, CR6_EQ, 32 */
		/* 822272A8h case   28:*/		if ( regs.CR[6].eq ) { return 0x822272C8;  }
		/* 822272A8h case   28:*/		return 0x822272AC;
		  /* 822272ACh */ case   29:  		/* cmplwi CR6, R8, 3 */
		/* 822272ACh case   29:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000003);
		/* 822272ACh case   29:*/		return 0x822272B0;
		  /* 822272B0h */ case   30:  		/* bc 4, CR6_LT, 116 */
		/* 822272B0h case   30:*/		if ( !regs.CR[6].lt ) { return 0x82227324;  }
		/* 822272B0h case   30:*/		return 0x822272B4;
		  /* 822272B4h */ case   31:  		/* lfd FR0, <#[R10]> */
		/* 822272B4h case   31:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 822272B4h case   31:*/		return 0x822272B8;
	}
	return 0x822272B8;
} // Block from 82227238h-822272B8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 822272B8h
// Function '?ConvertToExport@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@IPAVInstruction@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822272B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822272B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822272B8);
		  /* 822272B8h */ case    0:  		/* fctidz FR0, FR0 */
		/* 822272B8h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 822272B8h case    0:*/		return 0x822272BC;
		  /* 822272BCh */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 822272BCh case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822272BCh case    1:*/		return 0x822272C0;
		  /* 822272C0h */ case    2:  		/* lwz R8, <#[R1 + 84]> */
		/* 822272C0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 822272C0h case    2:*/		return 0x822272C4;
		  /* 822272C4h */ case    3:  		/* b 20 */
		/* 822272C4h case    3:*/		return 0x822272D8;
		/* 822272C4h case    3:*/		return 0x822272C8;
	}
	return 0x822272C8;
} // Block from 822272B8h-822272C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822272C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822272C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822272C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822272C8);
		  /* 822272C8h */ case    0:  		/* lfd FR0, <#[R10]> */
		/* 822272C8h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 822272C8h case    0:*/		return 0x822272CC;
		  /* 822272CCh */ case    1:  		/* fctiwz FR0, FR0 */
		/* 822272CCh case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822272CCh case    1:*/		return 0x822272D0;
		  /* 822272D0h */ case    2:  		/* stfd FR0, <#[R1 + 80]> */
		/* 822272D0h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822272D0h case    2:*/		return 0x822272D4;
		  /* 822272D4h */ case    3:  		/* lwz R8, <#[R1 + 84]> */
		/* 822272D4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 822272D4h case    3:*/		return 0x822272D8;
	}
	return 0x822272D8;
} // Block from 822272C8h-822272D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822272D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822272D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822272D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822272D8);
		  /* 822272D8h */ case    0:  		/* stw R8, <#[R9]> */
		/* 822272D8h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 822272D8h case    0:*/		return 0x822272DC;
		  /* 822272DCh */ case    1:  		/* b 16 */
		/* 822272DCh case    1:*/		return 0x822272EC;
		/* 822272DCh case    1:*/		return 0x822272E0;
	}
	return 0x822272E0;
} // Block from 822272D8h-822272E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822272E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822272E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822272E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822272E0);
		  /* 822272E0h */ case    0:  		/* lfd FR0, <#[R10]> */
		/* 822272E0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 822272E0h case    0:*/		return 0x822272E4;
		  /* 822272E4h */ case    1:  		/* frsp FR0, FR0 */
		/* 822272E4h case    1:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822272E4h case    1:*/		return 0x822272E8;
		  /* 822272E8h */ case    2:  		/* stfs FR0, <#[R9]> */
		/* 822272E8h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R9 + 0x00000000) );
		/* 822272E8h case    2:*/		return 0x822272EC;
	}
	return 0x822272EC;
} // Block from 822272E0h-822272ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822272ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822272EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822272EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822272EC);
		  /* 822272ECh */ case    0:  		/* addi R7, R7, 1 */
		/* 822272ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 822272ECh case    0:*/		return 0x822272F0;
		  /* 822272F0h */ case    1:  		/* addi R11, R11, 2 */
		/* 822272F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822272F0h case    1:*/		return 0x822272F4;
		  /* 822272F4h */ case    2:  		/* addi R10, R10, 8 */
		/* 822272F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 822272F4h case    2:*/		return 0x822272F8;
		  /* 822272F8h */ case    3:  		/* addi R9, R9, 4 */
		/* 822272F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 822272F8h case    3:*/		return 0x822272FC;
		  /* 822272FCh */ case    4:  		/* cmplw CR6, R7, R4 */
		/* 822272FCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 822272FCh case    4:*/		return 0x82227300;
		  /* 82227300h */ case    5:  		/* bc 12, CR6_LT, -152 */
		/* 82227300h case    5:*/		if ( regs.CR[6].lt ) { return 0x82227268;  }
		/* 82227300h case    5:*/		return 0x82227304;
	}
	return 0x82227304;
} // Block from 822272ECh-82227304h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82227304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227304);
		  /* 82227304h */ case    0:  		/* addi R5, R1, 96 */
		/* 82227304h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82227304h case    0:*/		return 0x82227308;
		  /* 82227308h */ case    1:  		/* bl -720 */
		/* 82227308h case    1:*/		regs.LR = 0x8222730C; return 0x82227038;
		/* 82227308h case    1:*/		return 0x8222730C;
		  /* 8222730Ch */ case    2:  		/* addi R1, R1, 144 */
		/* 8222730Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8222730Ch case    2:*/		return 0x82227310;
		  /* 82227310h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82227310h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82227310h case    3:*/		return 0x82227314;
		  /* 82227314h */ case    4:  		/* mtspr LR, R12 */
		/* 82227314h case    4:*/		regs.LR = regs.R12;
		/* 82227314h case    4:*/		return 0x82227318;
		  /* 82227318h */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 82227318h case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82227318h case    5:*/		return 0x8222731C;
		  /* 8222731Ch */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 8222731Ch case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222731Ch case    6:*/		return 0x82227320;
		  /* 82227320h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82227320h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82227320h case    7:*/		return 0x82227324;
	}
	return 0x82227324;
} // Block from 82227304h-82227324h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82227324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227324);
		  /* 82227324h */ case    0:  		/* li R4, 4800 */
		/* 82227324h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82227324h case    0:*/		return 0x82227328;
		  /* 82227328h */ case    1:  		/* bl -873664 */
		/* 82227328h case    1:*/		regs.LR = 0x8222732C; return 0x82151E68;
		/* 82227328h case    1:*/		return 0x8222732C;
		  /* 8222732Ch */ case    2:  		/* nop */
		/* 8222732Ch case    2:*/		cpu::op::nop();
		/* 8222732Ch case    2:*/		return 0x82227330;
	}
	return 0x82227330;
} // Block from 82227324h-82227330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82227330h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227330);
		  /* 82227330h */ case    0:  		/* mfspr R12, LR */
		/* 82227330h case    0:*/		regs.R12 = regs.LR;
		/* 82227330h case    0:*/		return 0x82227334;
		  /* 82227334h */ case    1:  		/* bl -1663192 */
		/* 82227334h case    1:*/		regs.LR = 0x82227338; return 0x8209125C;
		/* 82227334h case    1:*/		return 0x82227338;
		  /* 82227338h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82227338h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82227338h case    2:*/		return 0x8222733C;
		  /* 8222733Ch */ case    3:  		/* addi R10, R1, 80 */
		/* 8222733Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8222733Ch case    3:*/		return 0x82227340;
		  /* 82227340h */ case    4:  		/* lwz R11, <#[R4 + 20]> */
		/* 82227340h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82227340h case    4:*/		return 0x82227344;
		  /* 82227344h */ case    5:  		/* li R9, 0 */
		/* 82227344h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82227344h case    5:*/		return 0x82227348;
		  /* 82227348h */ case    6:  		/* rlwinm R8, R11, 30, 24, 31 */
		/* 82227348h case    6:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R8,regs.R11);
		/* 82227348h case    6:*/		return 0x8222734C;
		  /* 8222734Ch */ case    7:  		/* rlwinm R11, R5, 1, 0, 30 */
		/* 8222734Ch case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R5);
		/* 8222734Ch case    7:*/		return 0x82227350;
		  /* 82227350h */ case    8:  		/* li R7, 2 */
		/* 82227350h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82227350h case    8:*/		return 0x82227354;
		  /* 82227354h */ case    9:  		/* stw R9, <#[R10]> */
		/* 82227354h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82227354h case    9:*/		return 0x82227358;
		  /* 82227358h */ case   10:  		/* addi R11, R11, 1 */
		/* 82227358h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82227358h case   10:*/		return 0x8222735C;
		  /* 8222735Ch */ case   11:  		/* rlwinm R10, R5, 30, 3, 29 */
		/* 8222735Ch case   11:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R10,regs.R5);
		/* 8222735Ch case   11:*/		return 0x82227360;
		  /* 82227360h */ case   12:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82227360h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82227360h case   12:*/		return 0x82227364;
		  /* 82227364h */ case   13:  		/* addi R9, R1, 80 */
		/* 82227364h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 82227364h case   13:*/		return 0x82227368;
		  /* 82227368h */ case   14:  		/* slw R11, R7, R11 */
		/* 82227368h case   14:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82227368h case   14:*/		return 0x8222736C;
		  /* 8222736Ch */ case   15:  		/* lwz R7, <#[R1 + 80]> */
		/* 8222736Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8222736Ch case   15:*/		return 0x82227370;
		  /* 82227370h */ case   16:  		/* mr R29, R6 */
		/* 82227370h case   16:*/		regs.R29 = regs.R6;
		/* 82227370h case   16:*/		return 0x82227374;
		  /* 82227374h */ case   17:  		/* addi R11, R11, -1 */
		/* 82227374h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82227374h case   17:*/		return 0x82227378;
		  /* 82227378h */ case   18:  		/* or R8, R8, R7 */
		/* 82227378h case   18:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82227378h case   18:*/		return 0x8222737C;
		  /* 8222737Ch */ case   19:  		/* rlwinm R6, R5, 1, 27, 30 */
		/* 8222737Ch case   19:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R6,regs.R5);
		/* 8222737Ch case   19:*/		return 0x82227380;
		  /* 82227380h */ case   20:  		/* stw R8, <#[R1 + 80]> */
		/* 82227380h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82227380h case   20:*/		return 0x82227384;
		  /* 82227384h */ case   21:  		/* li R7, -1 */
		/* 82227384h case   21:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 82227384h case   21:*/		return 0x82227388;
		  /* 82227388h */ case   22:  		/* mr R31, R3 */
		/* 82227388h case   22:*/		regs.R31 = regs.R3;
		/* 82227388h case   22:*/		return 0x8222738C;
		  /* 8222738Ch */ case   23:  		/* slw R8, R7, R6 */
		/* 8222738Ch case   23:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R6);
		/* 8222738Ch case   23:*/		return 0x82227390;
		  /* 82227390h */ case   24:  		/* mr R30, R4 */
		/* 82227390h case   24:*/		regs.R30 = regs.R4;
		/* 82227390h case   24:*/		return 0x82227394;
		  /* 82227394h */ case   25:  		/* cmplwi CR6, R29, 0 */
		/* 82227394h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82227394h case   25:*/		return 0x82227398;
		  /* 82227398h */ case   26:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82227398h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82227398h case   26:*/		return 0x8222739C;
		  /* 8222739Ch */ case   27:  		/* and R11, R11, R10 */
		/* 8222739Ch case   27:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8222739Ch case   27:*/		return 0x822273A0;
		  /* 822273A0h */ case   28:  		/* and R11, R11, R8 */
		/* 822273A0h case   28:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 822273A0h case   28:*/		return 0x822273A4;
		  /* 822273A4h */ case   29:  		/* srw R11, R11, R6 */
		/* 822273A4h case   29:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 822273A4h case   29:*/		return 0x822273A8;
		  /* 822273A8h */ case   30:  		/* stw R11, <#[R3 + 4]> */
		/* 822273A8h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822273A8h case   30:*/		return 0x822273AC;
		  /* 822273ACh */ case   31:  		/* bc 4, CR6_EQ, 20 */
		/* 822273ACh case   31:*/		if ( !regs.CR[6].eq ) { return 0x822273C0;  }
		/* 822273ACh case   31:*/		return 0x822273B0;
		  /* 822273B0h */ case   32:  		/* addi R11, R5, 11 */
		/* 822273B0h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xB);
		/* 822273B0h case   32:*/		return 0x822273B4;
		  /* 822273B4h */ case   33:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822273B4h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822273B4h case   33:*/		return 0x822273B8;
		  /* 822273B8h */ case   34:  		/* lfsx FR0, <#[R11 + R4]> */
		/* 822273B8h case   34:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 822273B8h case   34:*/		return 0x822273BC;
		  /* 822273BCh */ case   35:  		/* b 116 */
		/* 822273BCh case   35:*/		return 0x82227430;
		/* 822273BCh case   35:*/		return 0x822273C0;
	}
	return 0x822273C0;
} // Block from 82227330h-822273C0h (36 instructions)

//////////////////////////////////////////////////////
// Block at 822273C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822273C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822273C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822273C0);
		  /* 822273C0h */ case    0:  		/* mr R4, R5 */
		/* 822273C0h case    0:*/		regs.R4 = regs.R5;
		/* 822273C0h case    0:*/		return 0x822273C4;
		  /* 822273C4h */ case    1:  		/* mr R3, R30 */
		/* 822273C4h case    1:*/		regs.R3 = regs.R30;
		/* 822273C4h case    1:*/		return 0x822273C8;
		  /* 822273C8h */ case    2:  		/* bl -435320 */
		/* 822273C8h case    2:*/		regs.LR = 0x822273CC; return 0x821BCF50;
		/* 822273C8h case    2:*/		return 0x822273CC;
		  /* 822273CCh */ case    3:  		/* mr R5, R29 */
		/* 822273CCh case    3:*/		regs.R5 = regs.R29;
		/* 822273CCh case    3:*/		return 0x822273D0;
		  /* 822273D0h */ case    4:  		/* lwz R4, <#[R31 + 4]> */
		/* 822273D0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 822273D0h case    4:*/		return 0x822273D4;
		  /* 822273D4h */ case    5:  		/* bl -24412 */
		/* 822273D4h case    5:*/		regs.LR = 0x822273D8; return 0x82221478;
		/* 822273D4h case    5:*/		return 0x822273D8;
		  /* 822273D8h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 822273D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822273D8h case    6:*/		return 0x822273DC;
		  /* 822273DCh */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 822273DCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822273DCh case    7:*/		return 0x822273E0;
		  /* 822273E0h */ case    8:  		/* bc 12, CR6_LT, 76 */
		/* 822273E0h case    8:*/		if ( regs.CR[6].lt ) { return 0x8222742C;  }
		/* 822273E0h case    8:*/		return 0x822273E4;
		  /* 822273E4h */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 822273E4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82227414;  }
		/* 822273E4h case    9:*/		return 0x822273E8;
		  /* 822273E8h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 822273E8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 822273E8h case   10:*/		return 0x822273EC;
		  /* 822273ECh */ case   11:  		/* bc 12, CR6_LT, 24 */
		/* 822273ECh case   11:*/		if ( regs.CR[6].lt ) { return 0x82227404;  }
		/* 822273ECh case   11:*/		return 0x822273F0;
		  /* 822273F0h */ case   12:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 822273F0h case   12:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 822273F0h case   12:*/		return 0x822273F4;
		  /* 822273F4h */ case   13:  		/* li R4, 4800 */
		/* 822273F4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822273F4h case   13:*/		return 0x822273F8;
		  /* 822273F8h */ case   14:  		/* lwz R11, <#[R11]> */
		/* 822273F8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822273F8h case   14:*/		return 0x822273FC;
		  /* 822273FCh */ case   15:  		/* lwz R3, <#[R11 + 148]> */
		/* 822273FCh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 822273FCh case   15:*/		return 0x82227400;
		  /* 82227400h */ case   16:  		/* bl -873880 */
		/* 82227400h case   16:*/		regs.LR = 0x82227404; return 0x82151E68;
		/* 82227400h case   16:*/		return 0x82227404;
	}
	return 0x82227404;
} // Block from 822273C0h-82227404h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82227404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227404);
		  /* 82227404h */ case    0:  		/* fctidz FR0, FR1 */
		/* 82227404h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 82227404h case    0:*/		return 0x82227408;
		  /* 82227408h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82227408h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82227408h case    1:*/		return 0x8222740C;
		  /* 8222740Ch */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 8222740Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8222740Ch case    2:*/		return 0x82227410;
		  /* 82227410h */ case    3:  		/* b 16 */
		/* 82227410h case    3:*/		return 0x82227420;
		/* 82227410h case    3:*/		return 0x82227414;
	}
	return 0x82227414;
} // Block from 82227404h-82227414h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82227414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227414);
		  /* 82227414h */ case    0:  		/* fctiwz FR0, FR1 */
		/* 82227414h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR1);
		/* 82227414h case    0:*/		return 0x82227418;
		  /* 82227418h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82227418h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82227418h case    1:*/		return 0x8222741C;
		  /* 8222741Ch */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 8222741Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8222741Ch case    2:*/		return 0x82227420;
	}
	return 0x82227420;
} // Block from 82227414h-82227420h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82227420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227420);
		  /* 82227420h */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 82227420h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227420h case    0:*/		return 0x82227424;
		  /* 82227424h */ case    1:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82227424h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82227424h case    1:*/		return 0x82227428;
		  /* 82227428h */ case    2:  		/* b 8 */
		/* 82227428h case    2:*/		return 0x82227430;
		/* 82227428h case    2:*/		return 0x8222742C;
	}
	return 0x8222742C;
} // Block from 82227420h-8222742Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222742Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222742C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222742C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222742C);
		  /* 8222742Ch */ case    0:  		/* frsp FR0, FR1 */
		/* 8222742Ch case    0:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 8222742Ch case    0:*/		return 0x82227430;
	}
	return 0x82227430;
} // Block from 8222742Ch-82227430h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227430);
		  /* 82227430h */ case    0:  		/* stfs FR0, <#[R31]> */
		/* 82227430h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 82227430h case    0:*/		return 0x82227434;
		  /* 82227434h */ case    1:  		/* mr R3, R31 */
		/* 82227434h case    1:*/		regs.R3 = regs.R31;
		/* 82227434h case    1:*/		return 0x82227438;
		  /* 82227438h */ case    2:  		/* addi R1, R1, 128 */
		/* 82227438h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82227438h case    2:*/		return 0x8222743C;
		  /* 8222743Ch */ case    3:  		/* b -1663376 */
		/* 8222743Ch case    3:*/		return 0x820912AC;
		/* 8222743Ch case    3:*/		return 0x82227440;
	}
	return 0x82227440;
} // Block from 82227430h-82227440h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82227440h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227440);
		  /* 82227440h */ case    0:  		/* mfspr R12, LR */
		/* 82227440h case    0:*/		regs.R12 = regs.LR;
		/* 82227440h case    0:*/		return 0x82227444;
		  /* 82227444h */ case    1:  		/* bl -1663524 */
		/* 82227444h case    1:*/		regs.LR = 0x82227448; return 0x82091220;
		/* 82227444h case    1:*/		return 0x82227448;
		  /* 82227448h */ case    2:  		/* stfd FR29, <#[R1 - 176]> */
		/* 82227448h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 82227448h case    2:*/		return 0x8222744C;
		  /* 8222744Ch */ case    3:  		/* stfd FR30, <#[R1 - 168]> */
		/* 8222744Ch case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 8222744Ch case    3:*/		return 0x82227450;
		  /* 82227450h */ case    4:  		/* stfd FR31, <#[R1 - 160]> */
		/* 82227450h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82227450h case    4:*/		return 0x82227454;
		  /* 82227454h */ case    5:  		/* stwu R1, <#[R1 - 448]> */
		/* 82227454h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE40);
		/* 82227454h case    5:*/		return 0x82227458;
		  /* 82227458h */ case    6:  		/* mr R18, R4 */
		/* 82227458h case    6:*/		regs.R18 = regs.R4;
		/* 82227458h case    6:*/		return 0x8222745C;
		  /* 8222745Ch */ case    7:  		/* li R31, 0 */
		/* 8222745Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8222745Ch case    7:*/		return 0x82227460;
		  /* 82227460h */ case    8:  		/* mr R30, R5 */
		/* 82227460h case    8:*/		regs.R30 = regs.R5;
		/* 82227460h case    8:*/		return 0x82227464;
		  /* 82227464h */ case    9:  		/* std R31, <#[R4]> */
		/* 82227464h case    9:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R4 + 0x00000000) );
		/* 82227464h case    9:*/		return 0x82227468;
		  /* 82227468h */ case   10:  		/* mr R14, R3 */
		/* 82227468h case   10:*/		regs.R14 = regs.R3;
		/* 82227468h case   10:*/		return 0x8222746C;
		  /* 8222746Ch */ case   11:  		/* li R5, 128 */
		/* 8222746Ch case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8222746Ch case   11:*/		return 0x82227470;
		  /* 82227470h */ case   12:  		/* std R31, <#[R18 + 8]> */
		/* 82227470h case   12:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R18 + 0x00000008) );
		/* 82227470h case   12:*/		return 0x82227474;
		  /* 82227474h */ case   13:  		/* li R4, 0 */
		/* 82227474h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82227474h case   13:*/		return 0x82227478;
		  /* 82227478h */ case   14:  		/* std R31, <#[R18 + 16]> */
		/* 82227478h case   14:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R18 + 0x00000010) );
		/* 82227478h case   14:*/		return 0x8222747C;
		  /* 8222747Ch */ case   15:  		/* addi R3, R1, 144 */
		/* 8222747Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 8222747Ch case   15:*/		return 0x82227480;
		  /* 82227480h */ case   16:  		/* std R31, <#[R18 + 24]> */
		/* 82227480h case   16:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R18 + 0x00000018) );
		/* 82227480h case   16:*/		return 0x82227484;
		  /* 82227484h */ case   17:  		/* stw R31, <#[R30]> */
		/* 82227484h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82227484h case   17:*/		return 0x82227488;
		  /* 82227488h */ case   18:  		/* mr R27, R31 */
		/* 82227488h case   18:*/		regs.R27 = regs.R31;
		/* 82227488h case   18:*/		return 0x8222748C;
		  /* 8222748Ch */ case   19:  		/* bl -1663308 */
		/* 8222748Ch case   19:*/		regs.LR = 0x82227490; return 0x82091340;
		/* 8222748Ch case   19:*/		return 0x82227490;
		  /* 82227490h */ case   20:  		/* addi R11, R1, 80 */
		/* 82227490h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82227490h case   20:*/		return 0x82227494;
		  /* 82227494h */ case   21:  		/* lwz R10, <#[R14 + 8]> */
		/* 82227494h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82227494h case   21:*/		return 0x82227498;
		  /* 82227498h */ case   22:  		/* mr R21, R31 */
		/* 82227498h case   22:*/		regs.R21 = regs.R31;
		/* 82227498h case   22:*/		return 0x8222749C;
		  /* 8222749Ch */ case   23:  		/* mr R23, R31 */
		/* 8222749Ch case   23:*/		regs.R23 = regs.R31;
		/* 8222749Ch case   23:*/		return 0x822274A0;
		  /* 822274A0h */ case   24:  		/* addi R15, R14, 44 */
		/* 822274A0h case   24:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R14,0x2C);
		/* 822274A0h case   24:*/		return 0x822274A4;
		  /* 822274A4h */ case   25:  		/* rlwinm R17, R10, 13, 29, 31 */
		/* 822274A4h case   25:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R17,regs.R10);
		/* 822274A4h case   25:*/		return 0x822274A8;
		  /* 822274A8h */ case   26:  		/* stw R31, <#[R11]> */
		/* 822274A8h case   26:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 822274A8h case   26:*/		return 0x822274AC;
		  /* 822274ACh */ case   27:  		/* li R28, 1 */
		/* 822274ACh case   27:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 822274ACh case   27:*/		return 0x822274B0;
		  /* 822274B0h */ case   28:  		/* li R16, 2 */
		/* 822274B0h case   28:*/		cpu::op::li<0>(regs,&regs.R16,0x2);
		/* 822274B0h case   28:*/		return 0x822274B4;
		  /* 822274B4h */ case   29:  		/* li R29, -1 */
		/* 822274B4h case   29:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 822274B4h case   29:*/		return 0x822274B8;
		  /* 822274B8h */ case   30:  		/* lwz R26, <#[R14 + 8]> */
		/* 822274B8h case   30:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R14 + 0x00000008) );
		/* 822274B8h case   30:*/		return 0x822274BC;
		  /* 822274BCh */ case   31:  		/* rlwinm R11, R26, 13, 29, 31 */
		/* 822274BCh case   31:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R26);
		/* 822274BCh case   31:*/		return 0x822274C0;
		  /* 822274C0h */ case   32:  		/* cmplw CR6, R21, R11 */
		/* 822274C0h case   32:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 822274C0h case   32:*/		return 0x822274C4;
		  /* 822274C4h */ case   33:  		/* bc 4, CR6_LT, 320 */
		/* 822274C4h case   33:*/		if ( !regs.CR[6].lt ) { return 0x82227604;  }
		/* 822274C4h case   33:*/		return 0x822274C8;
		  /* 822274C8h */ case   34:  		/* lwzx R19, <#[R15 + R23]> */
		/* 822274C8h case   34:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R15 + regs.R23 + 0x00000000) );
		/* 822274C8h case   34:*/		return 0x822274CC;
		  /* 822274CCh */ case   35:  		/* lwz R11, <#[R19]> */
		/* 822274CCh case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 822274CCh case   35:*/		return 0x822274D0;
		  /* 822274D0h */ case   36:  		/* rlwinm. R20, R11, 7, 29, 31 */
		/* 822274D0h case   36:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R20,regs.R11);
		/* 822274D0h case   36:*/		return 0x822274D4;
		  /* 822274D4h */ case   37:  		/* bc 12, CR0_EQ, 7268 */
		/* 822274D4h case   37:*/		if ( regs.CR[0].eq ) { return 0x82229138;  }
		/* 822274D4h case   37:*/		return 0x822274D8;
		  /* 822274D8h */ case   38:  		/* mr R24, R31 */
		/* 822274D8h case   38:*/		regs.R24 = regs.R31;
		/* 822274D8h case   38:*/		return 0x822274DC;
		  /* 822274DCh */ case   39:  		/* cmplwi CR0, R20, 0 */
		/* 822274DCh case   39:*/		cpu::op::cmplwi<0>(regs,regs.R20,0x00000000);
		/* 822274DCh case   39:*/		return 0x822274E0;
		  /* 822274E0h */ case   40:  		/* bc 12, CR0_EQ, 280 */
		/* 822274E0h case   40:*/		if ( regs.CR[0].eq ) { return 0x822275F8;  }
		/* 822274E0h case   40:*/		return 0x822274E4;
		  /* 822274E4h */ case   41:  		/* mr R26, R31 */
		/* 822274E4h case   41:*/		regs.R26 = regs.R31;
		/* 822274E4h case   41:*/		return 0x822274E8;
		  /* 822274E8h */ case   42:  		/* li R10, 0 */
		/* 822274E8h case   42:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822274E8h case   42:*/		return 0x822274EC;
		  /* 822274ECh */ case   43:  		/* mr R9, R14 */
		/* 822274ECh case   43:*/		regs.R9 = regs.R14;
		/* 822274ECh case   43:*/		return 0x822274F0;
		  /* 822274F0h */ case   44:  		/* li R8, 0 */
		/* 822274F0h case   44:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822274F0h case   44:*/		return 0x822274F4;
		  /* 822274F4h */ case   45:  		/* addi R7, R1, 96 */
		/* 822274F4h case   45:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 822274F4h case   45:*/		return 0x822274F8;
		  /* 822274F8h */ case   46:  		/* addi R6, R1, 128 */
		/* 822274F8h case   46:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 822274F8h case   46:*/		return 0x822274FC;
		  /* 822274FCh */ case   47:  		/* addi R5, R1, 132 */
		/* 822274FCh case   47:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x84);
		/* 822274FCh case   47:*/		return 0x82227500;
		  /* 82227500h */ case   48:  		/* mr R4, R24 */
		/* 82227500h case   48:*/		regs.R4 = regs.R24;
		/* 82227500h case   48:*/		return 0x82227504;
		  /* 82227504h */ case   49:  		/* mr R3, R19 */
		/* 82227504h case   49:*/		regs.R3 = regs.R19;
		/* 82227504h case   49:*/		return 0x82227508;
		  /* 82227508h */ case   50:  		/* bl -16440 */
		/* 82227508h case   50:*/		regs.LR = 0x8222750C; return 0x822234D0;
		/* 82227508h case   50:*/		return 0x8222750C;
		  /* 8222750Ch */ case   51:  		/* lwz R22, <#[R1 + 96]> */
		/* 8222750Ch case   51:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8222750Ch case   51:*/		return 0x82227510;
	}
	return 0x82227510;
} // Block from 82227440h-82227510h (52 instructions)

//////////////////////////////////////////////////////
// Block at 82227510h
// Function '?MakeInstr_CONSTANT@Compiler@D3DXShader@@QAAPAVInstruction@2@IQAMV?$BitFieldSet@V?$FixedSizeBitSet@I$00@D3DXShader@@II$01@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227510);
		  /* 82227510h */ case    0:  		/* rlwinm. R11, R22, 0, 27, 28 */
		/* 82227510h case    0:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R22);
		/* 82227510h case    0:*/		return 0x82227514;
		  /* 82227514h */ case    1:  		/* bc 4, CR0_EQ, 7204 */
		/* 82227514h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82229138;  }
		/* 82227514h case    1:*/		return 0x82227518;
		  /* 82227518h */ case    2:  		/* lwz R3, <#[R1 + 132]> */
		/* 82227518h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000084) );
		/* 82227518h case    2:*/		return 0x8222751C;
		  /* 8222751Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8222751Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8222751Ch case    3:*/		return 0x82227520;
		  /* 82227520h */ case    4:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82227520h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82227520h case    4:*/		return 0x82227524;
		  /* 82227524h */ case    5:  		/* cmplwi CR6, R11, 16000 */
		/* 82227524h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 82227524h case    5:*/		return 0x82227528;
		  /* 82227528h */ case    6:  		/* bc 4, CR6_EQ, 192 */
		/* 82227528h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822275E8;  }
		/* 82227528h case    6:*/		return 0x8222752C;
		  /* 8222752Ch */ case    7:  		/* rlwinm R9, R3, 0, 0, 19 */
		/* 8222752Ch case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R9,regs.R3);
		/* 8222752Ch case    7:*/		return 0x82227530;
		  /* 82227530h */ case    8:  		/* lwz R4, <#[R1 + 128]> */
		/* 82227530h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000080) );
		/* 82227530h case    8:*/		return 0x82227534;
		  /* 82227534h */ case    9:  		/* addi R11, R1, 80 */
		/* 82227534h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82227534h case    9:*/		return 0x82227538;
		  /* 82227538h */ case   10:  		/* rlwinm R10, R23, 29, 3, 29 */
		/* 82227538h case   10:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R23);
		/* 82227538h case   10:*/		return 0x8222753C;
		  /* 8222753Ch */ case   11:  		/* slw R7, R28, R24 */
		/* 8222753Ch case   11:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R28,regs.R24);
		/* 8222753Ch case   11:*/		return 0x82227540;
		  /* 82227540h */ case   12:  		/* lwz R9, <#[R9]> */
		/* 82227540h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 82227540h case   12:*/		return 0x82227544;
		  /* 82227544h */ case   13:  		/* rlwinm R8, R23, 0, 27, 31 */
		/* 82227544h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R23);
		/* 82227544h case   13:*/		return 0x82227548;
		  /* 82227548h */ case   14:  		/* slw R8, R7, R8 */
		/* 82227548h case   14:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 82227548h case   14:*/		return 0x8222754C;
		  /* 8222754Ch */ case   15:  		/* lwzx R7, <#[R10 + R11]> */
		/* 8222754Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8222754Ch case   15:*/		return 0x82227550;
		  /* 82227550h */ case   16:  		/* lwz R9, <#[R9 + 148]> */
		/* 82227550h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000094) );
		/* 82227550h case   16:*/		return 0x82227554;
		  /* 82227554h */ case   17:  		/* or R8, R8, R7 */
		/* 82227554h case   17:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82227554h case   17:*/		return 0x82227558;
		  /* 82227558h */ case   18:  		/* stwx R8, <#[R10 + R11]> */
		/* 82227558h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82227558h case   18:*/		return 0x8222755C;
		  /* 8222755Ch */ case   19:  		/* lwz R9, <#[R9 + 40]> */
		/* 8222755Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000028) );
		/* 8222755Ch case   19:*/		return 0x82227560;
		  /* 82227560h */ case   20:  		/* nor R11, R9, R9 */
		/* 82227560h case   20:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R9,regs.R9);
		/* 82227560h case   20:*/		return 0x82227564;
		  /* 82227564h */ case   21:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 82227564h case   21:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 82227564h case   21:*/		return 0x82227568;
		  /* 82227568h */ case   22:  		/* bc 4, CR0_EQ, 12 */
		/* 82227568h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82227574;  }
		/* 82227568h case   22:*/		return 0x8222756C;
		  /* 8222756Ch */ case   23:  		/* mr R25, R31 */
		/* 8222756Ch case   23:*/		regs.R25 = regs.R31;
		/* 8222756Ch case   23:*/		return 0x82227570;
		  /* 82227570h */ case   24:  		/* b 24 */
		/* 82227570h case   24:*/		return 0x82227588;
		/* 82227570h case   24:*/		return 0x82227574;
	}
	return 0x82227574;
} // Block from 82227510h-82227574h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82227574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227574);
		  /* 82227574h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 82227574h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82227574h case    0:*/		return 0x82227578;
		  /* 82227578h */ case    1:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 82227578h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 82227578h case    1:*/		return 0x8222757C;
		  /* 8222757Ch */ case    2:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 8222757Ch case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 8222757Ch case    2:*/		return 0x82227580;
		  /* 82227580h */ case    3:  		/* srw R11, R11, R10 */
		/* 82227580h case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82227580h case    3:*/		return 0x82227584;
		  /* 82227584h */ case    4:  		/* rlwinm R25, R11, 0, 30, 31 */
		/* 82227584h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R25,regs.R11);
		/* 82227584h case    4:*/		return 0x82227588;
	}
	return 0x82227588;
} // Block from 82227574h-82227588h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82227588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227588);
		  /* 82227588h */ case    0:  		/* rlwinm R11, R26, 27, 5, 31 */
		/* 82227588h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R26);
		/* 82227588h case    0:*/		return 0x8222758C;
		  /* 8222758Ch */ case    1:  		/* addi R10, R26, 1 */
		/* 8222758Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0x1);
		/* 8222758Ch case    1:*/		return 0x82227590;
		  /* 82227590h */ case    2:  		/* add R9, R11, R21 */
		/* 82227590h case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R21);
		/* 82227590h case    2:*/		return 0x82227594;
		  /* 82227594h */ case    3:  		/* rlwinm R8, R10, 0, 27, 31 */
		/* 82227594h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R10);
		/* 82227594h case    3:*/		return 0x82227598;
		  /* 82227598h */ case    4:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82227598h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82227598h case    4:*/		return 0x8222759C;
		  /* 8222759Ch */ case    5:  		/* addi R11, R1, 112 */
		/* 8222759Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8222759Ch case    5:*/		return 0x822275A0;
		  /* 822275A0h */ case    6:  		/* slw R9, R16, R8 */
		/* 822275A0h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R16,regs.R8);
		/* 822275A0h case    6:*/		return 0x822275A4;
		  /* 822275A4h */ case    7:  		/* rlwinm R7, R26, 0, 27, 31 */
		/* 822275A4h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R26);
		/* 822275A4h case    7:*/		return 0x822275A8;
		  /* 822275A8h */ case    8:  		/* lwzx R8, <#[R10 + R11]> */
		/* 822275A8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822275A8h case    8:*/		return 0x822275AC;
		  /* 822275ACh */ case    9:  		/* addi R9, R9, -1 */
		/* 822275ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 822275ACh case    9:*/		return 0x822275B0;
		  /* 822275B0h */ case   10:  		/* slw R6, R29, R7 */
		/* 822275B0h case   10:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R29,regs.R7);
		/* 822275B0h case   10:*/		return 0x822275B4;
		  /* 822275B4h */ case   11:  		/* and R9, R9, R6 */
		/* 822275B4h case   11:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 822275B4h case   11:*/		return 0x822275B8;
		  /* 822275B8h */ case   12:  		/* slw R7, R25, R7 */
		/* 822275B8h case   12:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R25,regs.R7);
		/* 822275B8h case   12:*/		return 0x822275BC;
		  /* 822275BCh */ case   13:  		/* andc R9, R8, R9 */
		/* 822275BCh case   13:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822275BCh case   13:*/		return 0x822275C0;
		  /* 822275C0h */ case   14:  		/* or R9, R9, R7 */
		/* 822275C0h case   14:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 822275C0h case   14:*/		return 0x822275C4;
		  /* 822275C4h */ case   15:  		/* stwx R9, <#[R10 + R11]> */
		/* 822275C4h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822275C4h case   15:*/		return 0x822275C8;
		  /* 822275C8h */ case   16:  		/* bl -435832 */
		/* 822275C8h case   16:*/		regs.LR = 0x822275CC; return 0x821BCF50;
		/* 822275C8h case   16:*/		return 0x822275CC;
		  /* 822275CCh */ case   17:  		/* mr R5, R22 */
		/* 822275CCh case   17:*/		regs.R5 = regs.R22;
		/* 822275CCh case   17:*/		return 0x822275D0;
		  /* 822275D0h */ case   18:  		/* mr R4, R25 */
		/* 822275D0h case   18:*/		regs.R4 = regs.R25;
		/* 822275D0h case   18:*/		return 0x822275D4;
		  /* 822275D4h */ case   19:  		/* bl -24924 */
		/* 822275D4h case   19:*/		regs.LR = 0x822275D8; return 0x82221478;
		/* 822275D4h case   19:*/		return 0x822275D8;
		  /* 822275D8h */ case   20:  		/* add R11, R23, R24 */
		/* 822275D8h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R23,regs.R24);
		/* 822275D8h case   20:*/		return 0x822275DC;
		  /* 822275DCh */ case   21:  		/* addi R10, R1, 144 */
		/* 822275DCh case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 822275DCh case   21:*/		return 0x822275E0;
		  /* 822275E0h */ case   22:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 822275E0h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 822275E0h case   22:*/		return 0x822275E4;
		  /* 822275E4h */ case   23:  		/* stfdx FR1, <#[R11 + R10]> */
		/* 822275E4h case   23:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822275E4h case   23:*/		return 0x822275E8;
	}
	return 0x822275E8;
} // Block from 82227588h-822275E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 822275E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822275E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822275E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822275E8);
		  /* 822275E8h */ case    0:  		/* addi R24, R24, 1 */
		/* 822275E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 822275E8h case    0:*/		return 0x822275EC;
		  /* 822275ECh */ case    1:  		/* addi R26, R26, 2 */
		/* 822275ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x2);
		/* 822275ECh case    1:*/		return 0x822275F0;
		  /* 822275F0h */ case    2:  		/* cmplw CR6, R24, R20 */
		/* 822275F0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R20);
		/* 822275F0h case    2:*/		return 0x822275F4;
		  /* 822275F4h */ case    3:  		/* bc 12, CR6_LT, -268 */
		/* 822275F4h case    3:*/		if ( regs.CR[6].lt ) { return 0x822274E8;  }
		/* 822275F4h case    3:*/		return 0x822275F8;
	}
	return 0x822275F8;
} // Block from 822275E8h-822275F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822275F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822275F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822275F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822275F8);
		  /* 822275F8h */ case    0:  		/* addi R21, R21, 1 */
		/* 822275F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 822275F8h case    0:*/		return 0x822275FC;
		  /* 822275FCh */ case    1:  		/* addi R23, R23, 4 */
		/* 822275FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 822275FCh case    1:*/		return 0x82227600;
		  /* 82227600h */ case    2:  		/* b -328 */
		/* 82227600h case    2:*/		return 0x822274B8;
		/* 82227600h case    2:*/		return 0x82227604;
	}
	return 0x82227604;
} // Block from 822275F8h-82227604h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82227604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227604);
		  /* 82227604h */ case    0:  		/* mr R3, R14 */
		/* 82227604h case    0:*/		regs.R3 = regs.R14;
		/* 82227604h case    0:*/		return 0x82227608;
		  /* 82227608h */ case    1:  		/* bl -747608 */
		/* 82227608h case    1:*/		regs.LR = 0x8222760C; return 0x82170DB0;
		/* 82227608h case    1:*/		return 0x8222760C;
		  /* 8222760Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222760Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222760Ch case    2:*/		return 0x82227610;
		  /* 82227610h */ case    3:  		/* bc 12, CR0_EQ, 1716 */
		/* 82227610h case    3:*/		if ( regs.CR[0].eq ) { return 0x82227CC4;  }
		/* 82227610h case    3:*/		return 0x82227614;
		  /* 82227614h */ case    4:  		/* lwz R10, <#[R15]> */
		/* 82227614h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 82227614h case    4:*/		return 0x82227618;
		  /* 82227618h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 82227618h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227618h case    5:*/		return 0x8222761C;
		  /* 8222761Ch */ case    6:  		/* rlwinm R25, R11, 0, 28, 31 */
		/* 8222761Ch case    6:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R25,regs.R11);
		/* 8222761Ch case    6:*/		return 0x82227620;
		  /* 82227620h */ case    7:  		/* rlwinm R24, R11, 28, 28, 31 */
		/* 82227620h case    7:*/		cpu::op::rlwinm<0,28,28,31>(regs,&regs.R24,regs.R11);
		/* 82227620h case    7:*/		return 0x82227624;
		  /* 82227624h */ case    8:  		/* lwz R11, <#[R10]> */
		/* 82227624h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82227624h case    8:*/		return 0x82227628;
		  /* 82227628h */ case    9:  		/* rlwinm. R23, R11, 7, 29, 31 */
		/* 82227628h case    9:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R23,regs.R11);
		/* 82227628h case    9:*/		return 0x8222762C;
		  /* 8222762Ch */ case   10:  		/* bc 12, CR0_EQ, 7092 */
		/* 8222762Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 8222762Ch case   10:*/		return 0x82227630;
		  /* 82227630h */ case   11:  		/* lis R11, -32256 */
		/* 82227630h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82227630h case   11:*/		return 0x82227634;
		  /* 82227634h */ case   12:  		/* lis R10, -32256 */
		/* 82227634h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82227634h case   12:*/		return 0x82227638;
		  /* 82227638h */ case   13:  		/* lfd FR30, <#[R11 + 1848]> */
		/* 82227638h case   13:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000738) );
		/* 82227638h case   13:*/		return 0x8222763C;
		  /* 8222763Ch */ case   14:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 8222763Ch case   14:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 8222763Ch case   14:*/		return 0x82227640;
		  /* 82227640h */ case   15:  		/* lwz R10, <#[R14 + 8]> */
		/* 82227640h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82227640h case   15:*/		return 0x82227644;
		  /* 82227644h */ case   16:  		/* and R11, R28, R25 */
		/* 82227644h case   16:*/		cpu::op::and<0>(regs,&regs.R11,regs.R28,regs.R25);
		/* 82227644h case   16:*/		return 0x82227648;
		  /* 82227648h */ case   17:  		/* and R9, R28, R24 */
		/* 82227648h case   17:*/		cpu::op::and<0>(regs,&regs.R9,regs.R28,regs.R24);
		/* 82227648h case   17:*/		return 0x8222764C;
		  /* 8222764Ch */ case   18:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 8222764Ch case   18:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 8222764Ch case   18:*/		return 0x82227650;
		  /* 82227650h */ case   19:  		/* addi R10, R10, -1 */
		/* 82227650h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82227650h case   19:*/		return 0x82227654;
		  /* 82227654h */ case   20:  		/* cmplwi CR6, R10, 27 */
		/* 82227654h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001B);
		/* 82227654h case   20:*/		return 0x82227658;
		  /* 82227658h */ case   21:  		/* bc 12, CR6_GT, 1544 */
		/* 82227658h case   21:*/		if ( regs.CR[6].gt ) { return 0x82227C60;  }
		/* 82227658h case   21:*/		return 0x8222765C;
		  /* 8222765Ch */ case   22:  		/* lis R12, -32252 */
		/* 8222765Ch case   22:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 8222765Ch case   22:*/		return 0x82227660;
		  /* 82227660h */ case   23:  		/* rlwinm R0, R10, 1, 0, 30 */
		/* 82227660h case   23:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R10);
		/* 82227660h case   23:*/		return 0x82227664;
		  /* 82227664h */ case   24:  		/* addi R12, R12, -392 */
		/* 82227664h case   24:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFE78);
		/* 82227664h case   24:*/		return 0x82227668;
		  /* 82227668h */ case   25:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82227668h case   25:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82227668h case   25:*/		return 0x8222766C;
		  /* 8222766Ch */ case   26:  		/* lis R12, -32222 */
		/* 8222766Ch case   26:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8222);
		/* 8222766Ch case   26:*/		return 0x82227670;
		  /* 82227670h */ case   27:  		/* addi R12, R12, 30340 */
		/* 82227670h case   27:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x7684);
		/* 82227670h case   27:*/		return 0x82227674;
		  /* 82227674h */ case   28:  		/* ori R0, R0, 0 */
		/* 82227674h case   28:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82227674h case   28:*/		return 0x82227678;
		  /* 82227678h */ case   29:  		/* add R12, R12, R0 */
		/* 82227678h case   29:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82227678h case   29:*/		return 0x8222767C;
		  /* 8222767Ch */ case   30:  		/* mtspr CTR, R12 */
		/* 8222767Ch case   30:*/		regs.CTR = regs.R12;
		/* 8222767Ch case   30:*/		return 0x82227680;
		  /* 82227680h */ case   31:  		/* bcctr 20, CR0_LT */
		/* 82227680h case   31:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82227680h case   31:*/		return 0x82227684;
		  /* 82227684h */ case   32:  		/* cmplwi CR6, R11, 0 */
		/* 82227684h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227684h case   32:*/		return 0x82227688;
		  /* 82227688h */ case   33:  		/* bc 12, CR6_EQ, 1496 */
		/* 82227688h case   33:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227688h case   33:*/		return 0x8222768C;
		  /* 8222768Ch */ case   34:  		/* cmplwi CR6, R9, 0 */
		/* 8222768Ch case   34:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8222768Ch case   34:*/		return 0x82227690;
		  /* 82227690h */ case   35:  		/* bc 12, CR6_EQ, 1488 */
		/* 82227690h case   35:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227690h case   35:*/		return 0x82227694;
		  /* 82227694h */ case   36:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 82227694h case   36:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 82227694h case   36:*/		return 0x82227698;
		  /* 82227698h */ case   37:  		/* addi R11, R1, 176 */
		/* 82227698h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xB0);
		/* 82227698h case   37:*/		return 0x8222769C;
		  /* 8222769Ch */ case   38:  		/* addi R10, R1, 144 */
		/* 8222769Ch case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8222769Ch case   38:*/		return 0x822276A0;
		  /* 822276A0h */ case   39:  		/* lfdx FR0, <#[R26 + R11]> */
		/* 822276A0h case   39:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 822276A0h case   39:*/		return 0x822276A4;
		  /* 822276A4h */ case   40:  		/* lfdx FR13, <#[R26 + R10]> */
		/* 822276A4h case   40:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + regs.R10 + 0x00000000) );
		/* 822276A4h case   40:*/		return 0x822276A8;
		  /* 822276A8h */ case   41:  		/* fadd FR1, FR0, FR13 */
		/* 822276A8h case   41:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 822276A8h case   41:*/		return 0x822276AC;
		  /* 822276ACh */ case   42:  		/* bl -436252 */
		/* 822276ACh case   42:*/		regs.LR = 0x822276B0; return 0x821BCE90;
		/* 822276ACh case   42:*/		return 0x822276B0;
		  /* 822276B0h */ case   43:  		/* stfdx FR1, <#[R26 + R18]> */
		/* 822276B0h case   43:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R26 + regs.R18 + 0x00000000) );
		/* 822276B0h case   43:*/		return 0x822276B4;
		  /* 822276B4h */ case   44:  		/* rlwinm R26, R31, 30, 3, 29 */
		/* 822276B4h case   44:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R26,regs.R31);
		/* 822276B4h case   44:*/		return 0x822276B8;
		  /* 822276B8h */ case   45:  		/* addi R9, R1, 112 */
		/* 822276B8h case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 822276B8h case   45:*/		return 0x822276BC;
		  /* 822276BCh */ case   46:  		/* addi R10, R1, 116 */
		/* 822276BCh case   46:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x74);
		/* 822276BCh case   46:*/		return 0x822276C0;
		  /* 822276C0h */ case   47:  		/* lwzx R9, <#[R26 + R9]> */
		/* 822276C0h case   47:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + regs.R9 + 0x00000000) );
		/* 822276C0h case   47:*/		return 0x822276C4;
		  /* 822276C4h */ case   48:  		/* b 1360 */
		/* 822276C4h case   48:*/		return 0x82227C14;
		/* 822276C4h case   48:*/		return 0x822276C8;
		  /* 822276C8h */ case   49:  		/* cmplwi CR6, R11, 0 */
		/* 822276C8h case   49:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822276C8h case   49:*/		return 0x822276CC;
		  /* 822276CCh */ case   50:  		/* bc 12, CR6_EQ, 64 */
		/* 822276CCh case   50:*/		if ( regs.CR[6].eq ) { return 0x8222770C;  }
		/* 822276CCh case   50:*/		return 0x822276D0;
		  /* 822276D0h */ case   51:  		/* cmplwi CR6, R9, 0 */
		/* 822276D0h case   51:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 822276D0h case   51:*/		return 0x822276D4;
		  /* 822276D4h */ case   52:  		/* bc 12, CR6_EQ, 64 */
		/* 822276D4h case   52:*/		if ( regs.CR[6].eq ) { return 0x82227714;  }
		/* 822276D4h case   52:*/		return 0x822276D8;
		  /* 822276D8h */ case   53:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 822276D8h case   53:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 822276D8h case   53:*/		return 0x822276DC;
		  /* 822276DCh */ case   54:  		/* addi R11, R1, 144 */
		/* 822276DCh case   54:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 822276DCh case   54:*/		return 0x822276E0;
		  /* 822276E0h */ case   55:  		/* addi R10, R1, 176 */
		/* 822276E0h case   55:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB0);
		/* 822276E0h case   55:*/		return 0x822276E4;
		  /* 822276E4h */ case   56:  		/* lfdx FR13, <#[R26 + R11]> */
		/* 822276E4h case   56:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 822276E4h case   56:*/		return 0x822276E8;
		  /* 822276E8h */ case   57:  		/* lfdx FR0, <#[R26 + R10]> */
		/* 822276E8h case   57:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + regs.R10 + 0x00000000) );
		/* 822276E8h case   57:*/		return 0x822276EC;
		  /* 822276ECh */ case   58:  		/* fcmpu CR6, FR13, FR31 */
		/* 822276ECh case   58:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 822276ECh case   58:*/		return 0x822276F0;
		  /* 822276F0h */ case   59:  		/* bc 12, CR6_EQ, 20 */
		/* 822276F0h case   59:*/		if ( regs.CR[6].eq ) { return 0x82227704;  }
		/* 822276F0h case   59:*/		return 0x822276F4;
		  /* 822276F4h */ case   60:  		/* fcmpu CR6, FR0, FR31 */
		/* 822276F4h case   60:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 822276F4h case   60:*/		return 0x822276F8;
		  /* 822276F8h */ case   61:  		/* bc 12, CR6_EQ, 12 */
		/* 822276F8h case   61:*/		if ( regs.CR[6].eq ) { return 0x82227704;  }
		/* 822276F8h case   61:*/		return 0x822276FC;
		  /* 822276FCh */ case   62:  		/* fmul FR1, FR13, FR0 */
		/* 822276FCh case   62:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 822276FCh case   62:*/		return 0x82227700;
		  /* 82227700h */ case   63:  		/* b -84 */
		/* 82227700h case   63:*/		return 0x822276AC;
		/* 82227700h case   63:*/		return 0x82227704;
	}
	return 0x82227704;
} // Block from 82227604h-82227704h (64 instructions)

//////////////////////////////////////////////////////
// Block at 82227704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227704);
		  /* 82227704h */ case    0:  		/* fmr FR1, FR31 */
		/* 82227704h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82227704h case    0:*/		return 0x82227708;
		  /* 82227708h */ case    1:  		/* b -88 */
		/* 82227708h case    1:*/		return 0x822276B0;
		/* 82227708h case    1:*/		return 0x8222770C;
	}
	return 0x8222770C;
} // Block from 82227704h-8222770Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222770Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222770C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222770C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222770C);
		  /* 8222770Ch */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8222770Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8222770Ch case    0:*/		return 0x82227710;
		  /* 82227710h */ case    1:  		/* bc 12, CR6_EQ, 1360 */
		/* 82227710h case    1:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227710h case    1:*/		return 0x82227714;
	}
	return 0x82227714;
} // Block from 8222770Ch-82227714h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82227714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227714);
		  /* 82227714h */ case    0:  		/* cntlzw R11, R11 */
		/* 82227714h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82227714h case    0:*/		return 0x82227718;
		  /* 82227718h */ case    1:  		/* addi R10, R1, 144 */
		/* 82227718h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227718h case    1:*/		return 0x8222771C;
		  /* 8222771Ch */ case    2:  		/* rlwinm R11, R11, 29, 29, 29 */
		/* 8222771Ch case    2:*/		cpu::op::rlwinm<0,29,29,29>(regs,&regs.R11,regs.R11);
		/* 8222771Ch case    2:*/		return 0x82227720;
		  /* 82227720h */ case    3:  		/* add R11, R11, R31 */
		/* 82227720h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82227720h case    3:*/		return 0x82227724;
		  /* 82227724h */ case    4:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82227724h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82227724h case    4:*/		return 0x82227728;
		  /* 82227728h */ case    5:  		/* lfdx FR1, <#[R11 + R10]> */
		/* 82227728h case    5:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227728h case    5:*/		return 0x8222772C;
		  /* 8222772Ch */ case    6:  		/* bl -1636084 */
		/* 8222772Ch case    6:*/		regs.LR = 0x82227730; return 0x82098038;
		/* 8222772Ch case    6:*/		return 0x82227730;
		  /* 82227730h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82227730h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82227730h case    7:*/		return 0x82227734;
		  /* 82227734h */ case    8:  		/* bc 4, CR0_GT, 1324 */
		/* 82227734h case    8:*/		if ( !regs.CR[0].gt ) { return 0x82227C60;  }
		/* 82227734h case    8:*/		return 0x82227738;
	}
	return 0x82227738;
} // Block from 82227714h-82227738h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82227738h
// Function '?GetOrCreateUniformVariableInstrWorker@Compiler@D3DXShader@@QAAPAVInstruction@2@II_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227738);
		  /* 82227738h */ case    0:  		/* cmpwi CR6, R3, 2 */
		/* 82227738h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82227738h case    0:*/		return 0x8222773C;
		  /* 8222773Ch */ case    1:  		/* bc 12, CR6_GT, 1316 */
		/* 8222773Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x82227C60;  }
		/* 8222773Ch case    1:*/		return 0x82227740;
		  /* 82227740h */ case    2:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 82227740h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 82227740h case    2:*/		return 0x82227744;
		  /* 82227744h */ case    3:  		/* lis R10, -64 */
		/* 82227744h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFC0);
		/* 82227744h case    3:*/		return 0x82227748;
		  /* 82227748h */ case    4:  		/* or R27, R28, R27 */
		/* 82227748h case    4:*/		cpu::op::or<0>(regs,&regs.R27,regs.R28,regs.R27);
		/* 82227748h case    4:*/		return 0x8222774C;
		  /* 8222774Ch */ case    5:  		/* stw R10, <#[R1 + 132]> */
		/* 8222774Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 8222774Ch case    5:*/		return 0x82227750;
		  /* 82227750h */ case    6:  		/* lfs FR0, <#[R1 + 132]> */
		/* 82227750h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000084) );
		/* 82227750h case    6:*/		return 0x82227754;
		  /* 82227754h */ case    7:  		/* stfdx FR0, <#[R11 + R18]> */
		/* 82227754h case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82227754h case    7:*/		return 0x82227758;
		  /* 82227758h */ case    8:  		/* b 1288 */
		/* 82227758h case    8:*/		return 0x82227C60;
		/* 82227758h case    8:*/		return 0x8222775C;
		  /* 8222775Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8222775Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222775Ch case    9:*/		return 0x82227760;
		  /* 82227760h */ case   10:  		/* bc 12, CR6_EQ, 1280 */
		/* 82227760h case   10:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227760h case   10:*/		return 0x82227764;
		  /* 82227764h */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 82227764h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227764h case   11:*/		return 0x82227768;
		  /* 82227768h */ case   12:  		/* bc 12, CR6_EQ, 1272 */
		/* 82227768h case   12:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227768h case   12:*/		return 0x8222776C;
		  /* 8222776Ch */ case   13:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 8222776Ch case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 8222776Ch case   13:*/		return 0x82227770;
		  /* 82227770h */ case   14:  		/* addi R10, R1, 144 */
		/* 82227770h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227770h case   14:*/		return 0x82227774;
		  /* 82227774h */ case   15:  		/* addi R9, R1, 176 */
		/* 82227774h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 82227774h case   15:*/		return 0x82227778;
		  /* 82227778h */ case   16:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 82227778h case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227778h case   16:*/		return 0x8222777C;
		  /* 8222777Ch */ case   17:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 8222777Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8222777Ch case   17:*/		return 0x82227780;
		  /* 82227780h */ case   18:  		/* fcmpu CR6, FR0, FR13 */
		/* 82227780h case   18:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82227780h case   18:*/		return 0x82227784;
		  /* 82227784h */ case   19:  		/* bc 4, CR6_LT, 12 */
		/* 82227784h case   19:*/		if ( !regs.CR[6].lt ) { return 0x82227790;  }
		/* 82227784h case   19:*/		return 0x82227788;
		  /* 82227788h */ case   20:  		/* stfdx FR0, <#[R11 + R18]> */
		/* 82227788h case   20:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82227788h case   20:*/		return 0x8222778C;
		  /* 8222778Ch */ case   21:  		/* b -216 */
		/* 8222778Ch case   21:*/		return 0x822276B4;
		/* 8222778Ch case   21:*/		return 0x82227790;
	}
	return 0x82227790;
} // Block from 82227738h-82227790h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82227790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227790);
		  /* 82227790h */ case    0:  		/* stfdx FR13, <#[R11 + R18]> */
		/* 82227790h case    0:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82227790h case    0:*/		return 0x82227794;
		  /* 82227794h */ case    1:  		/* b -224 */
		/* 82227794h case    1:*/		return 0x822276B4;
		/* 82227794h case    1:*/		return 0x82227798;
		  /* 82227798h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82227798h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227798h case    2:*/		return 0x8222779C;
		  /* 8222779Ch */ case    3:  		/* bc 12, CR6_EQ, 1220 */
		/* 8222779Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 8222779Ch case    3:*/		return 0x822277A0;
		  /* 822277A0h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 822277A0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 822277A0h case    4:*/		return 0x822277A4;
		  /* 822277A4h */ case    5:  		/* bc 12, CR6_EQ, 1212 */
		/* 822277A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 822277A4h case    5:*/		return 0x822277A8;
		  /* 822277A8h */ case    6:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 822277A8h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 822277A8h case    6:*/		return 0x822277AC;
		  /* 822277ACh */ case    7:  		/* addi R10, R1, 144 */
		/* 822277ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 822277ACh case    7:*/		return 0x822277B0;
		  /* 822277B0h */ case    8:  		/* addi R9, R1, 176 */
		/* 822277B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 822277B0h case    8:*/		return 0x822277B4;
		  /* 822277B4h */ case    9:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 822277B4h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822277B4h case    9:*/		return 0x822277B8;
		  /* 822277B8h */ case   10:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 822277B8h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822277B8h case   10:*/		return 0x822277BC;
		  /* 822277BCh */ case   11:  		/* fcmpu CR6, FR0, FR13 */
		/* 822277BCh case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822277BCh case   11:*/		return 0x822277C0;
		  /* 822277C0h */ case   12:  		/* bc 12, CR6_LT, -48 */
		/* 822277C0h case   12:*/		if ( regs.CR[6].lt ) { return 0x82227790;  }
		/* 822277C0h case   12:*/		return 0x822277C4;
		  /* 822277C4h */ case   13:  		/* b -60 */
		/* 822277C4h case   13:*/		return 0x82227788;
		/* 822277C4h case   13:*/		return 0x822277C8;
		  /* 822277C8h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 822277C8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822277C8h case   14:*/		return 0x822277CC;
		  /* 822277CCh */ case   15:  		/* bc 12, CR6_EQ, 1172 */
		/* 822277CCh case   15:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 822277CCh case   15:*/		return 0x822277D0;
		  /* 822277D0h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 822277D0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 822277D0h case   16:*/		return 0x822277D4;
		  /* 822277D4h */ case   17:  		/* bc 12, CR6_EQ, 1164 */
		/* 822277D4h case   17:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 822277D4h case   17:*/		return 0x822277D8;
		  /* 822277D8h */ case   18:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 822277D8h case   18:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 822277D8h case   18:*/		return 0x822277DC;
		  /* 822277DCh */ case   19:  		/* addi R10, R1, 144 */
		/* 822277DCh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 822277DCh case   19:*/		return 0x822277E0;
		  /* 822277E0h */ case   20:  		/* addi R9, R1, 176 */
		/* 822277E0h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 822277E0h case   20:*/		return 0x822277E4;
		  /* 822277E4h */ case   21:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 822277E4h case   21:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822277E4h case   21:*/		return 0x822277E8;
		  /* 822277E8h */ case   22:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 822277E8h case   22:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822277E8h case   22:*/		return 0x822277EC;
		  /* 822277ECh */ case   23:  		/* fcmpu CR6, FR0, FR13 */
		/* 822277ECh case   23:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822277ECh case   23:*/		return 0x822277F0;
		  /* 822277F0h */ case   24:  		/* bc 4, CR6_EQ, 12 */
		/* 822277F0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x822277FC;  }
		/* 822277F0h case   24:*/		return 0x822277F4;
		  /* 822277F4h */ case   25:  		/* stfdx FR30, <#[R11 + R18]> */
		/* 822277F4h case   25:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 822277F4h case   25:*/		return 0x822277F8;
		  /* 822277F8h */ case   26:  		/* b -324 */
		/* 822277F8h case   26:*/		return 0x822276B4;
		/* 822277F8h case   26:*/		return 0x822277FC;
	}
	return 0x822277FC;
} // Block from 82227790h-822277FCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 822277FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822277FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822277FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822277FC);
		  /* 822277FCh */ case    0:  		/* stfdx FR31, <#[R11 + R18]> */
		/* 822277FCh case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 822277FCh case    0:*/		return 0x82227800;
		  /* 82227800h */ case    1:  		/* b -332 */
		/* 82227800h case    1:*/		return 0x822276B4;
		/* 82227800h case    1:*/		return 0x82227804;
		  /* 82227804h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82227804h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227804h case    2:*/		return 0x82227808;
		  /* 82227808h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 82227808h case    3:*/		if ( regs.CR[6].eq ) { return 0x82227834;  }
		/* 82227808h case    3:*/		return 0x8222780C;
		  /* 8222780Ch */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 8222780Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8222780Ch case    4:*/		return 0x82227810;
		  /* 82227810h */ case    5:  		/* bc 12, CR6_EQ, 1104 */
		/* 82227810h case    5:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227810h case    5:*/		return 0x82227814;
		  /* 82227814h */ case    6:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 82227814h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 82227814h case    6:*/		return 0x82227818;
		  /* 82227818h */ case    7:  		/* addi R10, R1, 144 */
		/* 82227818h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227818h case    7:*/		return 0x8222781C;
		  /* 8222781Ch */ case    8:  		/* addi R9, R1, 176 */
		/* 8222781Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 8222781Ch case    8:*/		return 0x82227820;
		  /* 82227820h */ case    9:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 82227820h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227820h case    9:*/		return 0x82227824;
		  /* 82227824h */ case   10:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 82227824h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82227824h case   10:*/		return 0x82227828;
		  /* 82227828h */ case   11:  		/* fcmpu CR6, FR0, FR13 */
		/* 82227828h case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82227828h case   11:*/		return 0x8222782C;
		  /* 8222782Ch */ case   12:  		/* bc 4, CR6_GT, -48 */
		/* 8222782Ch case   12:*/		if ( !regs.CR[6].gt ) { return 0x822277FC;  }
		/* 8222782Ch case   12:*/		return 0x82227830;
		  /* 82227830h */ case   13:  		/* b -60 */
		/* 82227830h case   13:*/		return 0x822277F4;
		/* 82227830h case   13:*/		return 0x82227834;
	}
	return 0x82227834;
} // Block from 822277FCh-82227834h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82227834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227834);
		  /* 82227834h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82227834h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227834h case    0:*/		return 0x82227838;
		  /* 82227838h */ case    1:  		/* bc 12, CR6_EQ, 1064 */
		/* 82227838h case    1:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227838h case    1:*/		return 0x8222783C;
		  /* 8222783Ch */ case    2:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 8222783Ch case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 8222783Ch case    2:*/		return 0x82227840;
		  /* 82227840h */ case    3:  		/* addi R11, R1, 176 */
		/* 82227840h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xB0);
		/* 82227840h case    3:*/		return 0x82227844;
		  /* 82227844h */ case    4:  		/* lfdx FR0, <#[R26 + R11]> */
		/* 82227844h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82227844h case    4:*/		return 0x82227848;
		  /* 82227848h */ case    5:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227848h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227848h case    5:*/		return 0x8222784C;
		  /* 8222784Ch */ case    6:  		/* bc 4, CR6_EQ, 1044 */
		/* 8222784Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82227C60;  }
		/* 8222784Ch case    6:*/		return 0x82227850;
		  /* 82227850h */ case    7:  		/* li R10, 0 */
		/* 82227850h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82227850h case    7:*/		return 0x82227854;
		  /* 82227854h */ case    8:  		/* lwz R3, <#[R15]> */
		/* 82227854h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000000) );
		/* 82227854h case    8:*/		return 0x82227858;
		  /* 82227858h */ case    9:  		/* mr R9, R14 */
		/* 82227858h case    9:*/		regs.R9 = regs.R14;
		/* 82227858h case    9:*/		return 0x8222785C;
		  /* 8222785Ch */ case   10:  		/* li R8, 0 */
		/* 8222785Ch case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8222785Ch case   10:*/		return 0x82227860;
		  /* 82227860h */ case   11:  		/* addi R7, R1, 96 */
		/* 82227860h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82227860h case   11:*/		return 0x82227864;
		  /* 82227864h */ case   12:  		/* addi R6, R1, 128 */
		/* 82227864h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 82227864h case   12:*/		return 0x82227868;
	}
	return 0x82227868;
} // Block from 82227834h-82227868h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82227868h
// Function '?GetOrCreateConstant@Compiler@D3DXShader@@QAA?AVResult@2@IMMMM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227868);
		  /* 82227868h */ case    0:  		/* addi R5, R1, 136 */
		/* 82227868h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x88);
		/* 82227868h case    0:*/		return 0x8222786C;
		  /* 8222786Ch */ case    1:  		/* mr R4, R31 */
		/* 8222786Ch case    1:*/		regs.R4 = regs.R31;
		/* 8222786Ch case    1:*/		return 0x82227870;
		  /* 82227870h */ case    2:  		/* bl -17312 */
		/* 82227870h case    2:*/		regs.LR = 0x82227874; return 0x822234D0;
		/* 82227870h case    2:*/		return 0x82227874;
		  /* 82227874h */ case    3:  		/* lwz R11, <#[R1 + 96]> */
		/* 82227874h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82227874h case    3:*/		return 0x82227878;
		  /* 82227878h */ case    4:  		/* rlwinm R11, R11, 0, 27, 30 */
		/* 82227878h case    4:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R11,regs.R11);
		/* 82227878h case    4:*/		return 0x8222787C;
		  /* 8222787Ch */ case    5:  		/* cmplwi CR6, R11, 6 */
		/* 8222787Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 8222787Ch case    5:*/		return 0x82227880;
		  /* 82227880h */ case    6:  		/* bc 4, CR6_EQ, 992 */
		/* 82227880h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227880h case    6:*/		return 0x82227884;
		  /* 82227884h */ case    7:  		/* lwz R3, <#[R1 + 136]> */
		/* 82227884h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000088) );
		/* 82227884h case    7:*/		return 0x82227888;
		  /* 82227888h */ case    8:  		/* stfdx FR31, <#[R26 + R18]> */
		/* 82227888h case    8:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R26 + regs.R18 + 0x00000000) );
		/* 82227888h case    8:*/		return 0x8222788C;
		  /* 8222788Ch */ case    9:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 8222788Ch case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 8222788Ch case    9:*/		return 0x82227890;
		  /* 82227890h */ case   10:  		/* lwz R4, <#[R1 + 128]> */
		/* 82227890h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000080) );
		/* 82227890h case   10:*/		return 0x82227894;
		  /* 82227894h */ case   11:  		/* rlwinm R26, R31, 30, 3, 29 */
		/* 82227894h case   11:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R26,regs.R31);
		/* 82227894h case   11:*/		return 0x82227898;
		  /* 82227898h */ case   12:  		/* addi R11, R11, 1 */
		/* 82227898h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82227898h case   12:*/		return 0x8222789C;
		  /* 8222789Ch */ case   13:  		/* addi R10, R1, 116 */
		/* 8222789Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x74);
		/* 8222789Ch case   13:*/		return 0x822278A0;
		  /* 822278A0h */ case   14:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 822278A0h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 822278A0h case   14:*/		return 0x822278A4;
		  /* 822278A4h */ case   15:  		/* rlwinm R22, R31, 1, 27, 30 */
		/* 822278A4h case   15:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R22,regs.R31);
		/* 822278A4h case   15:*/		return 0x822278A8;
		  /* 822278A8h */ case   16:  		/* slw R11, R16, R11 */
		/* 822278A8h case   16:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R11);
		/* 822278A8h case   16:*/		return 0x822278AC;
		  /* 822278ACh */ case   17:  		/* lwzx R10, <#[R10 + R26]> */
		/* 822278ACh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 822278ACh case   17:*/		return 0x822278B0;
		  /* 822278B0h */ case   18:  		/* addi R11, R11, -1 */
		/* 822278B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822278B0h case   18:*/		return 0x822278B4;
		  /* 822278B4h */ case   19:  		/* slw R9, R29, R22 */
		/* 822278B4h case   19:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R29,regs.R22);
		/* 822278B4h case   19:*/		return 0x822278B8;
		  /* 822278B8h */ case   20:  		/* and R11, R11, R10 */
		/* 822278B8h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822278B8h case   20:*/		return 0x822278BC;
		  /* 822278BCh */ case   21:  		/* or R27, R28, R27 */
		/* 822278BCh case   21:*/		cpu::op::or<0>(regs,&regs.R27,regs.R28,regs.R27);
		/* 822278BCh case   21:*/		return 0x822278C0;
		  /* 822278C0h */ case   22:  		/* and R21, R11, R9 */
		/* 822278C0h case   22:*/		cpu::op::and<0>(regs,&regs.R21,regs.R11,regs.R9);
		/* 822278C0h case   22:*/		return 0x822278C4;
		  /* 822278C4h */ case   23:  		/* bl -434580 */
		/* 822278C4h case   23:*/		regs.LR = 0x822278C8; return 0x821BD730;
		/* 822278C4h case   23:*/		return 0x822278C8;
		  /* 822278C8h */ case   24:  		/* srw R4, R21, R22 */
		/* 822278C8h case   24:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R21,regs.R22);
		/* 822278C8h case   24:*/		return 0x822278CC;
		  /* 822278CCh */ case   25:  		/* b 896 */
		/* 822278CCh case   25:*/		return 0x82227C4C;
		/* 822278CCh case   25:*/		return 0x822278D0;
		  /* 822278D0h */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 822278D0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822278D0h case   26:*/		return 0x822278D4;
		  /* 822278D4h */ case   27:  		/* bc 12, CR6_EQ, 44 */
		/* 822278D4h case   27:*/		if ( regs.CR[6].eq ) { return 0x82227900;  }
		/* 822278D4h case   27:*/		return 0x822278D8;
		  /* 822278D8h */ case   28:  		/* cmplwi CR6, R9, 0 */
		/* 822278D8h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 822278D8h case   28:*/		return 0x822278DC;
		  /* 822278DCh */ case   29:  		/* bc 12, CR6_EQ, 900 */
		/* 822278DCh case   29:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 822278DCh case   29:*/		return 0x822278E0;
		  /* 822278E0h */ case   30:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 822278E0h case   30:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 822278E0h case   30:*/		return 0x822278E4;
		  /* 822278E4h */ case   31:  		/* addi R10, R1, 144 */
		/* 822278E4h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 822278E4h case   31:*/		return 0x822278E8;
		  /* 822278E8h */ case   32:  		/* addi R9, R1, 176 */
		/* 822278E8h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 822278E8h case   32:*/		return 0x822278EC;
		  /* 822278ECh */ case   33:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 822278ECh case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822278ECh case   33:*/		return 0x822278F0;
		  /* 822278F0h */ case   34:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 822278F0h case   34:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822278F0h case   34:*/		return 0x822278F4;
		  /* 822278F4h */ case   35:  		/* fcmpu CR6, FR0, FR13 */
		/* 822278F4h case   35:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822278F4h case   35:*/		return 0x822278F8;
		  /* 822278F8h */ case   36:  		/* bc 12, CR6_LT, -252 */
		/* 822278F8h case   36:*/		if ( regs.CR[6].lt ) { return 0x822277FC;  }
		/* 822278F8h case   36:*/		return 0x822278FC;
		  /* 822278FCh */ case   37:  		/* b -264 */
		/* 822278FCh case   37:*/		return 0x822277F4;
		/* 822278FCh case   37:*/		return 0x82227900;
	}
	return 0x82227900;
} // Block from 82227868h-82227900h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82227900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227900);
		  /* 82227900h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82227900h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227900h case    0:*/		return 0x82227904;
		  /* 82227904h */ case    1:  		/* bc 12, CR6_EQ, 860 */
		/* 82227904h case    1:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227904h case    1:*/		return 0x82227908;
		  /* 82227908h */ case    2:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 82227908h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 82227908h case    2:*/		return 0x8222790C;
		  /* 8222790Ch */ case    3:  		/* addi R11, R1, 176 */
		/* 8222790Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xB0);
		/* 8222790Ch case    3:*/		return 0x82227910;
		  /* 82227910h */ case    4:  		/* lfdx FR0, <#[R26 + R11]> */
		/* 82227910h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82227910h case    4:*/		return 0x82227914;
		  /* 82227914h */ case    5:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227914h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227914h case    5:*/		return 0x82227918;
		  /* 82227918h */ case    6:  		/* bc 4, CR6_EQ, 840 */
		/* 82227918h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227918h case    6:*/		return 0x8222791C;
		  /* 8222791Ch */ case    7:  		/* li R10, 0 */
		/* 8222791Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222791Ch case    7:*/		return 0x82227920;
		  /* 82227920h */ case    8:  		/* lwz R3, <#[R15]> */
		/* 82227920h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000000) );
		/* 82227920h case    8:*/		return 0x82227924;
		  /* 82227924h */ case    9:  		/* mr R9, R14 */
		/* 82227924h case    9:*/		regs.R9 = regs.R14;
		/* 82227924h case    9:*/		return 0x82227928;
		  /* 82227928h */ case   10:  		/* li R8, 0 */
		/* 82227928h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82227928h case   10:*/		return 0x8222792C;
		  /* 8222792Ch */ case   11:  		/* addi R7, R1, 96 */
		/* 8222792Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 8222792Ch case   11:*/		return 0x82227930;
		  /* 82227930h */ case   12:  		/* addi R6, R1, 128 */
		/* 82227930h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 82227930h case   12:*/		return 0x82227934;
		  /* 82227934h */ case   13:  		/* addi R5, R1, 104 */
		/* 82227934h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 82227934h case   13:*/		return 0x82227938;
		  /* 82227938h */ case   14:  		/* mr R4, R31 */
		/* 82227938h case   14:*/		regs.R4 = regs.R31;
		/* 82227938h case   14:*/		return 0x8222793C;
		  /* 8222793Ch */ case   15:  		/* bl -17516 */
		/* 8222793Ch case   15:*/		regs.LR = 0x82227940; return 0x822234D0;
		/* 8222793Ch case   15:*/		return 0x82227940;
		  /* 82227940h */ case   16:  		/* lwz R11, <#[R1 + 96]> */
		/* 82227940h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82227940h case   16:*/		return 0x82227944;
		  /* 82227944h */ case   17:  		/* rlwinm R11, R11, 0, 27, 30 */
		/* 82227944h case   17:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R11,regs.R11);
		/* 82227944h case   17:*/		return 0x82227948;
		  /* 82227948h */ case   18:  		/* cmplwi CR6, R11, 2 */
		/* 82227948h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82227948h case   18:*/		return 0x8222794C;
		  /* 8222794Ch */ case   19:  		/* bc 4, CR6_EQ, 788 */
		/* 8222794Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x82227C60;  }
		/* 8222794Ch case   19:*/		return 0x82227950;
		  /* 82227950h */ case   20:  		/* lwz R3, <#[R1 + 104]> */
		/* 82227950h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 82227950h case   20:*/		return 0x82227954;
		  /* 82227954h */ case   21:  		/* stfdx FR30, <#[R26 + R18]> */
		/* 82227954h case   21:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R26 + regs.R18 + 0x00000000) );
		/* 82227954h case   21:*/		return 0x82227958;
		  /* 82227958h */ case   22:  		/* b -204 */
		/* 82227958h case   22:*/		return 0x8222788C;
		/* 82227958h case   22:*/		return 0x8222795C;
		  /* 8222795Ch */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 8222795Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222795Ch case   23:*/		return 0x82227960;
		  /* 82227960h */ case   24:  		/* bc 12, CR6_EQ, 768 */
		/* 82227960h case   24:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227960h case   24:*/		return 0x82227964;
		  /* 82227964h */ case   25:  		/* cmplwi CR6, R9, 0 */
		/* 82227964h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227964h case   25:*/		return 0x82227968;
		  /* 82227968h */ case   26:  		/* bc 12, CR6_EQ, 760 */
		/* 82227968h case   26:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227968h case   26:*/		return 0x8222796C;
		  /* 8222796Ch */ case   27:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 8222796Ch case   27:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 8222796Ch case   27:*/		return 0x82227970;
		  /* 82227970h */ case   28:  		/* addi R10, R1, 144 */
		/* 82227970h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227970h case   28:*/		return 0x82227974;
		  /* 82227974h */ case   29:  		/* addi R9, R1, 176 */
		/* 82227974h case   29:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 82227974h case   29:*/		return 0x82227978;
		  /* 82227978h */ case   30:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 82227978h case   30:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227978h case   30:*/		return 0x8222797C;
		  /* 8222797Ch */ case   31:  		/* lfdx FR13, <#[R11 + R9]> */
		/* 8222797Ch case   31:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8222797Ch case   31:*/		return 0x82227980;
		  /* 82227980h */ case   32:  		/* fcmpu CR6, FR0, FR13 */
		/* 82227980h case   32:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82227980h case   32:*/		return 0x82227984;
		  /* 82227984h */ case   33:  		/* bc 12, CR6_EQ, -392 */
		/* 82227984h case   33:*/		if ( regs.CR[6].eq ) { return 0x822277FC;  }
		/* 82227984h case   33:*/		return 0x82227988;
		  /* 82227988h */ case   34:  		/* b -404 */
		/* 82227988h case   34:*/		return 0x822277F4;
		/* 82227988h case   34:*/		return 0x8222798C;
		  /* 8222798Ch */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 8222798Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222798Ch case   35:*/		return 0x82227990;
		  /* 82227990h */ case   36:  		/* bc 12, CR6_EQ, 720 */
		/* 82227990h case   36:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227990h case   36:*/		return 0x82227994;
		  /* 82227994h */ case   37:  		/* addi R11, R1, 144 */
		/* 82227994h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82227994h case   37:*/		return 0x82227998;
		  /* 82227998h */ case   38:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 82227998h case   38:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 82227998h case   38:*/		return 0x8222799C;
		  /* 8222799Ch */ case   39:  		/* lfdx FR29, <#[R26 + R11]> */
		/* 8222799Ch case   39:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 8222799Ch case   39:*/		return 0x822279A0;
		  /* 822279A0h */ case   40:  		/* fmr FR1, FR29 */
		/* 822279A0h case   40:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 822279A0h case   40:*/		return 0x822279A4;
		  /* 822279A4h */ case   41:  		/* bl -436932 */
		/* 822279A4h case   41:*/		regs.LR = 0x822279A8; return 0x821BCEE0;
		/* 822279A4h case   41:*/		return 0x822279A8;
		  /* 822279A8h */ case   42:  		/* bl -1636872 */
		/* 822279A8h case   42:*/		regs.LR = 0x822279AC; return 0x82097FA0;
		/* 822279A8h case   42:*/		return 0x822279AC;
		  /* 822279ACh */ case   43:  		/* fadd FR1, FR1, FR29 */
		/* 822279ACh case   43:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR29);
		/* 822279ACh case   43:*/		return 0x822279B0;
		  /* 822279B0h */ case   44:  		/* bl -437024 */
		/* 822279B0h case   44:*/		regs.LR = 0x822279B4; return 0x821BCE90;
		/* 822279B0h case   44:*/		return 0x822279B4;
		  /* 822279B4h */ case   45:  		/* stfdx FR1, <#[R26 + R18]> */
		/* 822279B4h case   45:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R26 + regs.R18 + 0x00000000) );
		/* 822279B4h case   45:*/		return 0x822279B8;
		  /* 822279B8h */ case   46:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 822279B8h case   46:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 822279B8h case   46:*/		return 0x822279BC;
		  /* 822279BCh */ case   47:  		/* addi R9, R1, 112 */
		/* 822279BCh case   47:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 822279BCh case   47:*/		return 0x822279C0;
		  /* 822279C0h */ case   48:  		/* addi R11, R11, 1 */
		/* 822279C0h case   48:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822279C0h case   48:*/		return 0x822279C4;
		  /* 822279C4h */ case   49:  		/* rlwinm R10, R31, 30, 3, 29 */
		/* 822279C4h case   49:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R10,regs.R31);
		/* 822279C4h case   49:*/		return 0x822279C8;
		  /* 822279C8h */ case   50:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 822279C8h case   50:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 822279C8h case   50:*/		return 0x822279CC;
		  /* 822279CCh */ case   51:  		/* rlwinm R8, R31, 1, 27, 30 */
		/* 822279CCh case   51:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R8,regs.R31);
		/* 822279CCh case   51:*/		return 0x822279D0;
		  /* 822279D0h */ case   52:  		/* slw R11, R16, R11 */
		/* 822279D0h case   52:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R11);
		/* 822279D0h case   52:*/		return 0x822279D4;
		  /* 822279D4h */ case   53:  		/* lwzx R10, <#[R10 + R9]> */
		/* 822279D4h case   53:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 822279D4h case   53:*/		return 0x822279D8;
		  /* 822279D8h */ case   54:  		/* addi R11, R11, -1 */
		/* 822279D8h case   54:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 822279D8h case   54:*/		return 0x822279DC;
		  /* 822279DCh */ case   55:  		/* slw R9, R29, R8 */
		/* 822279DCh case   55:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R29,regs.R8);
		/* 822279DCh case   55:*/		return 0x822279E0;
		  /* 822279E0h */ case   56:  		/* and R10, R11, R10 */
		/* 822279E0h case   56:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822279E0h case   56:*/		return 0x822279E4;
		  /* 822279E4h */ case   57:  		/* rlwinm R11, R31, 30, 3, 29 */
		/* 822279E4h case   57:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R11,regs.R31);
		/* 822279E4h case   57:*/		return 0x822279E8;
		  /* 822279E8h */ case   58:  		/* and R10, R10, R9 */
		/* 822279E8h case   58:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822279E8h case   58:*/		return 0x822279EC;
		  /* 822279ECh */ case   59:  		/* or R27, R28, R27 */
		/* 822279ECh case   59:*/		cpu::op::or<0>(regs,&regs.R27,regs.R28,regs.R27);
		/* 822279ECh case   59:*/		return 0x822279F0;
		  /* 822279F0h */ case   60:  		/* srw R10, R10, R8 */
		/* 822279F0h case   60:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 822279F0h case   60:*/		return 0x822279F4;
		  /* 822279F4h */ case   61:  		/* lwzx R9, <#[R11 + R30]> */
		/* 822279F4h case   61:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 822279F4h case   61:*/		return 0x822279F8;
		  /* 822279F8h */ case   62:  		/* slw R10, R10, R8 */
		/* 822279F8h case   62:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 822279F8h case   62:*/		return 0x822279FC;
		  /* 822279FCh */ case   63:  		/* or R10, R10, R9 */
		/* 822279FCh case   63:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822279FCh case   63:*/		return 0x82227A00;
		  /* 82227A00h */ case   64:  		/* stwx R10, <#[R11 + R30]> */
		/* 82227A00h case   64:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82227A00h case   64:*/		return 0x82227A04;
		  /* 82227A04h */ case   65:  		/* b 604 */
		/* 82227A04h case   65:*/		return 0x82227C60;
		/* 82227A04h case   65:*/		return 0x82227A08;
		  /* 82227A08h */ case   66:  		/* cmplwi CR6, R11, 0 */
		/* 82227A08h case   66:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227A08h case   66:*/		return 0x82227A0C;
		  /* 82227A0Ch */ case   67:  		/* bc 12, CR6_EQ, 596 */
		/* 82227A0Ch case   67:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227A0Ch case   67:*/		return 0x82227A10;
		  /* 82227A10h */ case   68:  		/* addi R11, R1, 144 */
		/* 82227A10h case   68:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82227A10h case   68:*/		return 0x82227A14;
		  /* 82227A14h */ case   69:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 82227A14h case   69:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 82227A14h case   69:*/		return 0x82227A18;
		  /* 82227A18h */ case   70:  		/* addi R4, R1, 88 */
		/* 82227A18h case   70:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82227A18h case   70:*/		return 0x82227A1C;
		  /* 82227A1Ch */ case   71:  		/* lfdx FR1, <#[R26 + R11]> */
		/* 82227A1Ch case   71:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82227A1Ch case   71:*/		return 0x82227A20;
		  /* 82227A20h */ case   72:  		/* bl 268928 */
		/* 82227A20h case   72:*/		regs.LR = 0x82227A24; return 0x822694A0;
		/* 82227A20h case   72:*/		return 0x82227A24;
		  /* 82227A24h */ case   73:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82227A24h case   73:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82227A24h case   73:*/		return 0x82227A28;
		  /* 82227A28h */ case   74:  		/* stfdx FR0, <#[R26 + R18]> */
		/* 82227A28h case   74:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R26 + regs.R18 + 0x00000000) );
		/* 82227A28h case   74:*/		return 0x82227A2C;
		  /* 82227A2Ch */ case   75:  		/* b -116 */
		/* 82227A2Ch case   75:*/		return 0x822279B8;
		/* 82227A2Ch case   75:*/		return 0x82227A30;
		  /* 82227A30h */ case   76:  		/* cmplwi CR6, R11, 0 */
		/* 82227A30h case   76:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227A30h case   76:*/		return 0x82227A34;
		  /* 82227A34h */ case   77:  		/* bc 12, CR6_EQ, 556 */
		/* 82227A34h case   77:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227A34h case   77:*/		return 0x82227A38;
		  /* 82227A38h */ case   78:  		/* addi R11, R1, 144 */
		/* 82227A38h case   78:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82227A38h case   78:*/		return 0x82227A3C;
		  /* 82227A3Ch */ case   79:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 82227A3Ch case   79:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 82227A3Ch case   79:*/		return 0x82227A40;
		  /* 82227A40h */ case   80:  		/* lfdx FR1, <#[R26 + R11]> */
		/* 82227A40h case   80:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82227A40h case   80:*/		return 0x82227A44;
		  /* 82227A44h */ case   81:  		/* bl -437092 */
		/* 82227A44h case   81:*/		regs.LR = 0x82227A48; return 0x821BCEE0;
		/* 82227A44h case   81:*/		return 0x82227A48;
		  /* 82227A48h */ case   82:  		/* b -148 */
		/* 82227A48h case   82:*/		return 0x822279B4;
		/* 82227A48h case   82:*/		return 0x82227A4C;
		  /* 82227A4Ch */ case   83:  		/* cmplwi CR6, R11, 0 */
		/* 82227A4Ch case   83:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227A4Ch case   83:*/		return 0x82227A50;
	}
	return 0x82227A50;
} // Block from 82227900h-82227A50h (84 instructions)

//////////////////////////////////////////////////////
// Block at 82227A50h
// Function '?GetOrCreateConstantInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@IQAMV?$BitFieldSet@V?$FixedSizeBitSet@I$00@D3DXShader@@II$01@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227A50);
		  /* 82227A50h */ case    0:  		/* bc 12, CR6_EQ, 528 */
		/* 82227A50h case    0:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227A50h case    0:*/		return 0x82227A54;
		  /* 82227A54h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82227A54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227A54h case    1:*/		return 0x82227A58;
		  /* 82227A58h */ case    2:  		/* bc 12, CR6_EQ, 520 */
		/* 82227A58h case    2:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227A58h case    2:*/		return 0x82227A5C;
		  /* 82227A5Ch */ case    3:  		/* addi R11, R31, 8 */
		/* 82227A5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8);
		/* 82227A5Ch case    3:*/		return 0x82227A60;
		  /* 82227A60h */ case    4:  		/* addi R10, R1, 80 */
		/* 82227A60h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82227A60h case    4:*/		return 0x82227A64;
		  /* 82227A64h */ case    5:  		/* rlwinm R9, R11, 29, 3, 29 */
		/* 82227A64h case    5:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R11);
		/* 82227A64h case    5:*/		return 0x82227A68;
		  /* 82227A68h */ case    6:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82227A68h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82227A68h case    6:*/		return 0x82227A6C;
		  /* 82227A6Ch */ case    7:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82227A6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82227A6Ch case    7:*/		return 0x82227A70;
		  /* 82227A70h */ case    8:  		/* srw R11, R10, R11 */
		/* 82227A70h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82227A70h case    8:*/		return 0x82227A74;
		  /* 82227A74h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82227A74h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82227A74h case    9:*/		return 0x82227A78;
		  /* 82227A78h */ case   10:  		/* bc 12, CR0_EQ, 488 */
		/* 82227A78h case   10:*/		if ( regs.CR[0].eq ) { return 0x82227C60;  }
		/* 82227A78h case   10:*/		return 0x82227A7C;
		  /* 82227A7Ch */ case   11:  		/* rlwinm R26, R31, 3, 0, 28 */
		/* 82227A7Ch case   11:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R26,regs.R31);
		/* 82227A7Ch case   11:*/		return 0x82227A80;
		  /* 82227A80h */ case   12:  		/* addi R11, R1, 144 */
		/* 82227A80h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82227A80h case   12:*/		return 0x82227A84;
		  /* 82227A84h */ case   13:  		/* addi R10, R1, 176 */
		/* 82227A84h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB0);
		/* 82227A84h case   13:*/		return 0x82227A88;
		  /* 82227A88h */ case   14:  		/* lfdx FR13, <#[R26 + R11]> */
		/* 82227A88h case   14:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82227A88h case   14:*/		return 0x82227A8C;
		  /* 82227A8Ch */ case   15:  		/* lfdx FR0, <#[R26 + R10]> */
		/* 82227A8Ch case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + regs.R10 + 0x00000000) );
		/* 82227A8Ch case   15:*/		return 0x82227A90;
		  /* 82227A90h */ case   16:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227A90h case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227A90h case   16:*/		return 0x82227A94;
		  /* 82227A94h */ case   17:  		/* bc 12, CR6_EQ, 24 */
		/* 82227A94h case   17:*/		if ( regs.CR[6].eq ) { return 0x82227AAC;  }
		/* 82227A94h case   17:*/		return 0x82227A98;
		  /* 82227A98h */ case   18:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227A98h case   18:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227A98h case   18:*/		return 0x82227A9C;
		  /* 82227A9Ch */ case   19:  		/* bc 12, CR6_EQ, 16 */
		/* 82227A9Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82227AAC;  }
		/* 82227A9Ch case   19:*/		return 0x82227AA0;
		  /* 82227AA0h */ case   20:  		/* fmul FR1, FR0, FR13 */
		/* 82227AA0h case   20:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 82227AA0h case   20:*/		return 0x82227AA4;
		  /* 82227AA4h */ case   21:  		/* bl -437268 */
		/* 82227AA4h case   21:*/		regs.LR = 0x82227AA8; return 0x821BCE90;
		/* 82227AA4h case   21:*/		return 0x82227AA8;
		  /* 82227AA8h */ case   22:  		/* b 8 */
		/* 82227AA8h case   22:*/		return 0x82227AB0;
		/* 82227AA8h case   22:*/		return 0x82227AAC;
	}
	return 0x82227AAC;
} // Block from 82227A50h-82227AACh (23 instructions)

//////////////////////////////////////////////////////
// Block at 82227AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227AAC);
		  /* 82227AACh */ case    0:  		/* fmr FR1, FR31 */
		/* 82227AACh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82227AACh case    0:*/		return 0x82227AB0;
	}
	return 0x82227AB0;
} // Block from 82227AACh-82227AB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227AB0);
		  /* 82227AB0h */ case    0:  		/* addi R11, R1, 208 */
		/* 82227AB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82227AB0h case    0:*/		return 0x82227AB4;
		  /* 82227AB4h */ case    1:  		/* lfdx FR0, <#[R26 + R11]> */
		/* 82227AB4h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 82227AB4h case    1:*/		return 0x82227AB8;
		  /* 82227AB8h */ case    2:  		/* fadd FR1, FR0, FR1 */
		/* 82227AB8h case    2:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR0,regs.FR1);
		/* 82227AB8h case    2:*/		return 0x82227ABC;
		  /* 82227ABCh */ case    3:  		/* bl -437292 */
		/* 82227ABCh case    3:*/		regs.LR = 0x82227AC0; return 0x821BCE90;
		/* 82227ABCh case    3:*/		return 0x82227AC0;
		  /* 82227AC0h */ case    4:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 82227AC0h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 82227AC0h case    4:*/		return 0x82227AC4;
		  /* 82227AC4h */ case    5:  		/* stfdx FR1, <#[R26 + R18]> */
		/* 82227AC4h case    5:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R26 + regs.R18 + 0x00000000) );
		/* 82227AC4h case    5:*/		return 0x82227AC8;
		  /* 82227AC8h */ case    6:  		/* rlwinm R22, R31, 1, 27, 30 */
		/* 82227AC8h case    6:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R22,regs.R31);
		/* 82227AC8h case    6:*/		return 0x82227ACC;
		  /* 82227ACCh */ case    7:  		/* addi R11, R11, 1 */
		/* 82227ACCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82227ACCh case    7:*/		return 0x82227AD0;
		  /* 82227AD0h */ case    8:  		/* rlwinm R26, R31, 30, 3, 29 */
		/* 82227AD0h case    8:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R26,regs.R31);
		/* 82227AD0h case    8:*/		return 0x82227AD4;
		  /* 82227AD4h */ case    9:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82227AD4h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82227AD4h case    9:*/		return 0x82227AD8;
		  /* 82227AD8h */ case   10:  		/* addi R10, R1, 116 */
		/* 82227AD8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x74);
		/* 82227AD8h case   10:*/		return 0x82227ADC;
		  /* 82227ADCh */ case   11:  		/* slw R11, R16, R11 */
		/* 82227ADCh case   11:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R11);
		/* 82227ADCh case   11:*/		return 0x82227AE0;
		  /* 82227AE0h */ case   12:  		/* addi R9, R1, 112 */
		/* 82227AE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 82227AE0h case   12:*/		return 0x82227AE4;
		  /* 82227AE4h */ case   13:  		/* lwzx R10, <#[R10 + R26]> */
		/* 82227AE4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82227AE4h case   13:*/		return 0x82227AE8;
		  /* 82227AE8h */ case   14:  		/* addi R11, R11, -1 */
		/* 82227AE8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82227AE8h case   14:*/		return 0x82227AEC;
		  /* 82227AECh */ case   15:  		/* slw R8, R29, R22 */
		/* 82227AECh case   15:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R29,regs.R22);
		/* 82227AECh case   15:*/		return 0x82227AF0;
		  /* 82227AF0h */ case   16:  		/* addi R7, R1, 120 */
		/* 82227AF0h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 82227AF0h case   16:*/		return 0x82227AF4;
		  /* 82227AF4h */ case   17:  		/* lwzx R9, <#[R26 + R9]> */
		/* 82227AF4h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + regs.R9 + 0x00000000) );
		/* 82227AF4h case   17:*/		return 0x82227AF8;
		  /* 82227AF8h */ case   18:  		/* and R11, R11, R8 */
		/* 82227AF8h case   18:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82227AF8h case   18:*/		return 0x82227AFC;
		  /* 82227AFCh */ case   19:  		/* or R27, R28, R27 */
		/* 82227AFCh case   19:*/		cpu::op::or<0>(regs,&regs.R27,regs.R28,regs.R27);
		/* 82227AFCh case   19:*/		return 0x82227B00;
		  /* 82227B00h */ case   20:  		/* and R10, R10, R11 */
		/* 82227B00h case   20:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82227B00h case   20:*/		return 0x82227B04;
		  /* 82227B04h */ case   21:  		/* and R9, R9, R11 */
		/* 82227B04h case   21:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82227B04h case   21:*/		return 0x82227B08;
		  /* 82227B08h */ case   22:  		/* lwzx R8, <#[R7 + R26]> */
		/* 82227B08h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R26 + 0x00000000) );
		/* 82227B08h case   22:*/		return 0x82227B0C;
		  /* 82227B0Ch */ case   23:  		/* srw R4, R10, R22 */
		/* 82227B0Ch case   23:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R10,regs.R22);
		/* 82227B0Ch case   23:*/		return 0x82227B10;
		  /* 82227B10h */ case   24:  		/* srw R3, R9, R22 */
		/* 82227B10h case   24:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R9,regs.R22);
		/* 82227B10h case   24:*/		return 0x82227B14;
		  /* 82227B14h */ case   25:  		/* and R21, R8, R11 */
		/* 82227B14h case   25:*/		cpu::op::and<0>(regs,&regs.R21,regs.R8,regs.R11);
		/* 82227B14h case   25:*/		return 0x82227B18;
		  /* 82227B18h */ case   26:  		/* bl -435032 */
		/* 82227B18h case   26:*/		regs.LR = 0x82227B1C; return 0x821BD7C0;
		/* 82227B18h case   26:*/		return 0x82227B1C;
		  /* 82227B1Ch */ case   27:  		/* b -596 */
		/* 82227B1Ch case   27:*/		return 0x822278C8;
		/* 82227B1Ch case   27:*/		return 0x82227B20;
		  /* 82227B20h */ case   28:  		/* cmplwi CR6, R11, 0 */
		/* 82227B20h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227B20h case   28:*/		return 0x82227B24;
		  /* 82227B24h */ case   29:  		/* bc 12, CR6_EQ, 144 */
		/* 82227B24h case   29:*/		if ( regs.CR[6].eq ) { return 0x82227BB4;  }
		/* 82227B24h case   29:*/		return 0x82227B28;
		  /* 82227B28h */ case   30:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 82227B28h case   30:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 82227B28h case   30:*/		return 0x82227B2C;
		  /* 82227B2Ch */ case   31:  		/* addi R10, R1, 144 */
		/* 82227B2Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227B2Ch case   31:*/		return 0x82227B30;
		  /* 82227B30h */ case   32:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 82227B30h case   32:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227B30h case   32:*/		return 0x82227B34;
		  /* 82227B34h */ case   33:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227B34h case   33:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227B34h case   33:*/		return 0x82227B38;
		  /* 82227B38h */ case   34:  		/* bc 12, CR6_EQ, 376 */
		/* 82227B38h case   34:*/		if ( regs.CR[6].eq ) { return 0x82227CB0;  }
		/* 82227B38h case   34:*/		return 0x82227B3C;
		  /* 82227B3Ch */ case   35:  		/* addi R10, R31, 8 */
		/* 82227B3Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8);
		/* 82227B3Ch case   35:*/		return 0x82227B40;
		  /* 82227B40h */ case   36:  		/* addi R8, R1, 80 */
		/* 82227B40h case   36:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82227B40h case   36:*/		return 0x82227B44;
		  /* 82227B44h */ case   37:  		/* rlwinm R7, R10, 29, 3, 29 */
		/* 82227B44h case   37:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R7,regs.R10);
		/* 82227B44h case   37:*/		return 0x82227B48;
		  /* 82227B48h */ case   38:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82227B48h case   38:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82227B48h case   38:*/		return 0x82227B4C;
		  /* 82227B4Ch */ case   39:  		/* lwzx R8, <#[R7 + R8]> */
		/* 82227B4Ch case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82227B4Ch case   39:*/		return 0x82227B50;
		  /* 82227B50h */ case   40:  		/* srw R10, R8, R10 */
		/* 82227B50h case   40:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82227B50h case   40:*/		return 0x82227B54;
		  /* 82227B54h */ case   41:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82227B54h case   41:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82227B54h case   41:*/		return 0x82227B58;
		  /* 82227B58h */ case   42:  		/* bc 12, CR0_EQ, 92 */
		/* 82227B58h case   42:*/		if ( regs.CR[0].eq ) { return 0x82227BB4;  }
		/* 82227B58h case   42:*/		return 0x82227B5C;
		  /* 82227B5Ch */ case   43:  		/* addi R8, R1, 208 */
		/* 82227B5Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 82227B5Ch case   43:*/		return 0x82227B60;
		  /* 82227B60h */ case   44:  		/* addi R6, R1, 120 */
		/* 82227B60h case   44:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x78);
		/* 82227B60h case   44:*/		return 0x82227B64;
		  /* 82227B64h */ case   45:  		/* rlwinm R10, R31, 1, 0, 30 */
		/* 82227B64h case   45:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R31);
		/* 82227B64h case   45:*/		return 0x82227B68;
		  /* 82227B68h */ case   46:  		/* lfdx FR0, <#[R11 + R8]> */
		/* 82227B68h case   46:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82227B68h case   46:*/		return 0x82227B6C;
		  /* 82227B6Ch */ case   47:  		/* stfdx FR0, <#[R11 + R18]> */
		/* 82227B6Ch case   47:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82227B6Ch case   47:*/		return 0x82227B70;
		  /* 82227B70h */ case   48:  		/* rlwinm R7, R31, 30, 3, 29 */
		/* 82227B70h case   48:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R7,regs.R31);
		/* 82227B70h case   48:*/		return 0x82227B74;
		  /* 82227B74h */ case   49:  		/* addi R10, R10, 1 */
		/* 82227B74h case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82227B74h case   49:*/		return 0x82227B78;
		  /* 82227B78h */ case   50:  		/* rlwinm R8, R31, 1, 27, 30 */
		/* 82227B78h case   50:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R8,regs.R31);
		/* 82227B78h case   50:*/		return 0x82227B7C;
		  /* 82227B7Ch */ case   51:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82227B7Ch case   51:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82227B7Ch case   51:*/		return 0x82227B80;
		  /* 82227B80h */ case   52:  		/* or R27, R28, R27 */
		/* 82227B80h case   52:*/		cpu::op::or<0>(regs,&regs.R27,regs.R28,regs.R27);
		/* 82227B80h case   52:*/		return 0x82227B84;
		  /* 82227B84h */ case   53:  		/* slw R11, R16, R10 */
		/* 82227B84h case   53:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R10);
		/* 82227B84h case   53:*/		return 0x82227B88;
		  /* 82227B88h */ case   54:  		/* lwzx R10, <#[R7 + R6]> */
		/* 82227B88h case   54:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 82227B88h case   54:*/		return 0x82227B8C;
		  /* 82227B8Ch */ case   55:  		/* addi R11, R11, -1 */
		/* 82227B8Ch case   55:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82227B8Ch case   55:*/		return 0x82227B90;
		  /* 82227B90h */ case   56:  		/* slw R7, R29, R8 */
		/* 82227B90h case   56:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R29,regs.R8);
		/* 82227B90h case   56:*/		return 0x82227B94;
		  /* 82227B94h */ case   57:  		/* and R10, R11, R10 */
		/* 82227B94h case   57:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82227B94h case   57:*/		return 0x82227B98;
		  /* 82227B98h */ case   58:  		/* rlwinm R11, R31, 30, 3, 29 */
		/* 82227B98h case   58:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R11,regs.R31);
		/* 82227B98h case   58:*/		return 0x82227B9C;
		  /* 82227B9Ch */ case   59:  		/* and R10, R10, R7 */
		/* 82227B9Ch case   59:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82227B9Ch case   59:*/		return 0x82227BA0;
		  /* 82227BA0h */ case   60:  		/* srw R10, R10, R8 */
		/* 82227BA0h case   60:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82227BA0h case   60:*/		return 0x82227BA4;
		  /* 82227BA4h */ case   61:  		/* lwzx R7, <#[R11 + R30]> */
		/* 82227BA4h case   61:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82227BA4h case   61:*/		return 0x82227BA8;
		  /* 82227BA8h */ case   62:  		/* slw R10, R10, R8 */
		/* 82227BA8h case   62:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82227BA8h case   62:*/		return 0x82227BAC;
		  /* 82227BACh */ case   63:  		/* or R10, R10, R7 */
		/* 82227BACh case   63:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82227BACh case   63:*/		return 0x82227BB0;
		  /* 82227BB0h */ case   64:  		/* stwx R10, <#[R11 + R30]> */
		/* 82227BB0h case   64:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82227BB0h case   64:*/		return 0x82227BB4;
	}
	return 0x82227BB4;
} // Block from 82227AB0h-82227BB4h (65 instructions)

//////////////////////////////////////////////////////
// Block at 82227BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227BB4);
		  /* 82227BB4h */ case    0:  		/* and. R11, R28, R27 */
		/* 82227BB4h case    0:*/		cpu::op::and<1>(regs,&regs.R11,regs.R28,regs.R27);
		/* 82227BB4h case    0:*/		return 0x82227BB8;
		  /* 82227BB8h */ case    1:  		/* bc 4, CR0_EQ, 168 */
		/* 82227BB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82227C60;  }
		/* 82227BB8h case    1:*/		return 0x82227BBC;
		  /* 82227BBCh */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82227BBCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227BBCh case    2:*/		return 0x82227BC0;
		  /* 82227BC0h */ case    3:  		/* bc 12, CR6_EQ, 160 */
		/* 82227BC0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227BC0h case    3:*/		return 0x82227BC4;
		  /* 82227BC4h */ case    4:  		/* addi R11, R31, 8 */
		/* 82227BC4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8);
		/* 82227BC4h case    4:*/		return 0x82227BC8;
		  /* 82227BC8h */ case    5:  		/* addi R10, R1, 80 */
		/* 82227BC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82227BC8h case    5:*/		return 0x82227BCC;
		  /* 82227BCCh */ case    6:  		/* rlwinm R9, R11, 29, 3, 29 */
		/* 82227BCCh case    6:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R11);
		/* 82227BCCh case    6:*/		return 0x82227BD0;
		  /* 82227BD0h */ case    7:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82227BD0h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82227BD0h case    7:*/		return 0x82227BD4;
		  /* 82227BD4h */ case    8:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82227BD4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82227BD4h case    8:*/		return 0x82227BD8;
	}
	return 0x82227BD8;
} // Block from 82227BB4h-82227BD8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82227BD8h
// Function '?GetOrCreateConstantInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@IQAUCONSTVALDATA@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227BD8);
		  /* 82227BD8h */ case    0:  		/* srw R11, R10, R11 */
		/* 82227BD8h case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82227BD8h case    0:*/		return 0x82227BDC;
		  /* 82227BDCh */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82227BDCh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82227BDCh case    1:*/		return 0x82227BE0;
		  /* 82227BE0h */ case    2:  		/* bc 12, CR0_EQ, 128 */
		/* 82227BE0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82227C60;  }
		/* 82227BE0h case    2:*/		return 0x82227BE4;
		  /* 82227BE4h */ case    3:  		/* rlwinm R10, R31, 3, 0, 28 */
		/* 82227BE4h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R31);
		/* 82227BE4h case    3:*/		return 0x82227BE8;
		  /* 82227BE8h */ case    4:  		/* addi R11, R1, 176 */
		/* 82227BE8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xB0);
		/* 82227BE8h case    4:*/		return 0x82227BEC;
		  /* 82227BECh */ case    5:  		/* addi R9, R1, 208 */
		/* 82227BECh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xD0);
		/* 82227BECh case    5:*/		return 0x82227BF0;
		  /* 82227BF0h */ case    6:  		/* lfdx FR0, <#[R10 + R11]> */
		/* 82227BF0h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82227BF0h case    6:*/		return 0x82227BF4;
		  /* 82227BF4h */ case    7:  		/* lfdx FR13, <#[R10 + R9]> */
		/* 82227BF4h case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82227BF4h case    7:*/		return 0x82227BF8;
		  /* 82227BF8h */ case    8:  		/* fcmpu CR6, FR0, FR13 */
		/* 82227BF8h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82227BF8h case    8:*/		return 0x82227BFC;
		  /* 82227BFCh */ case    9:  		/* bc 4, CR6_EQ, 100 */
		/* 82227BFCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82227C60;  }
		/* 82227BFCh case    9:*/		return 0x82227C00;
		  /* 82227C00h */ case   10:  		/* rlwinm R26, R31, 30, 3, 29 */
		/* 82227C00h case   10:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R26,regs.R31);
		/* 82227C00h case   10:*/		return 0x82227C04;
		  /* 82227C04h */ case   11:  		/* stfdx FR0, <#[R10 + R18]> */
		/* 82227C04h case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R10 + regs.R18 + 0x00000000) );
		/* 82227C04h case   11:*/		return 0x82227C08;
		  /* 82227C08h */ case   12:  		/* addi R9, R1, 116 */
		/* 82227C08h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x74);
		/* 82227C08h case   12:*/		return 0x82227C0C;
		  /* 82227C0Ch */ case   13:  		/* addi R10, R1, 120 */
		/* 82227C0Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x78);
		/* 82227C0Ch case   13:*/		return 0x82227C10;
		  /* 82227C10h */ case   14:  		/* lwzx R9, <#[R9 + R26]> */
		/* 82227C10h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R26 + 0x00000000) );
		/* 82227C10h case   14:*/		return 0x82227C14;
	}
	return 0x82227C14;
} // Block from 82227BD8h-82227C14h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82227C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227C14);
		  /* 82227C14h */ case    0:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 82227C14h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 82227C14h case    0:*/		return 0x82227C18;
		  /* 82227C18h */ case    1:  		/* lwzx R10, <#[R10 + R26]> */
		/* 82227C18h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82227C18h case    1:*/		return 0x82227C1C;
		  /* 82227C1Ch */ case    2:  		/* rlwinm R22, R31, 1, 27, 30 */
		/* 82227C1Ch case    2:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R22,regs.R31);
		/* 82227C1Ch case    2:*/		return 0x82227C20;
		  /* 82227C20h */ case    3:  		/* addi R11, R11, 1 */
		/* 82227C20h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82227C20h case    3:*/		return 0x82227C24;
		  /* 82227C24h */ case    4:  		/* slw R8, R29, R22 */
		/* 82227C24h case    4:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R29,regs.R22);
		/* 82227C24h case    4:*/		return 0x82227C28;
		  /* 82227C28h */ case    5:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82227C28h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82227C28h case    5:*/		return 0x82227C2C;
		  /* 82227C2Ch */ case    6:  		/* or R27, R28, R27 */
		/* 82227C2Ch case    6:*/		cpu::op::or<0>(regs,&regs.R27,regs.R28,regs.R27);
		/* 82227C2Ch case    6:*/		return 0x82227C30;
		  /* 82227C30h */ case    7:  		/* slw R11, R16, R11 */
		/* 82227C30h case    7:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R11);
		/* 82227C30h case    7:*/		return 0x82227C34;
		  /* 82227C34h */ case    8:  		/* addi R11, R11, -1 */
		/* 82227C34h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82227C34h case    8:*/		return 0x82227C38;
		  /* 82227C38h */ case    9:  		/* and R11, R11, R8 */
		/* 82227C38h case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82227C38h case    9:*/		return 0x82227C3C;
		  /* 82227C3Ch */ case   10:  		/* and R10, R10, R11 */
		/* 82227C3Ch case   10:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82227C3Ch case   10:*/		return 0x82227C40;
		  /* 82227C40h */ case   11:  		/* and R11, R9, R11 */
		/* 82227C40h case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82227C40h case   11:*/		return 0x82227C44;
		  /* 82227C44h */ case   12:  		/* srw R4, R10, R22 */
		/* 82227C44h case   12:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R10,regs.R22);
		/* 82227C44h case   12:*/		return 0x82227C48;
		  /* 82227C48h */ case   13:  		/* srw R3, R11, R22 */
		/* 82227C48h case   13:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R11,regs.R22);
		/* 82227C48h case   13:*/		return 0x82227C4C;
	}
	return 0x82227C4C;
} // Block from 82227C14h-82227C4Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82227C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227C4C);
		  /* 82227C4Ch */ case    0:  		/* bl -435340 */
		/* 82227C4Ch case    0:*/		regs.LR = 0x82227C50; return 0x821BD7C0;
		/* 82227C4Ch case    0:*/		return 0x82227C50;
	}
	return 0x82227C50;
} // Block from 82227C4Ch-82227C50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227C50h
// Function '?GetOrCreateConstantInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@IQANV?$BitFieldSet@V?$FixedSizeBitSet@I$00@D3DXShader@@II$01@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227C50);
		  /* 82227C50h */ case    0:  		/* lwzx R11, <#[R26 + R30]> */
		/* 82227C50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + regs.R30 + 0x00000000) );
		/* 82227C50h case    0:*/		return 0x82227C54;
		  /* 82227C54h */ case    1:  		/* slw R10, R3, R22 */
		/* 82227C54h case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R3,regs.R22);
		/* 82227C54h case    1:*/		return 0x82227C58;
		  /* 82227C58h */ case    2:  		/* or R11, R10, R11 */
		/* 82227C58h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82227C58h case    2:*/		return 0x82227C5C;
		  /* 82227C5Ch */ case    3:  		/* stwx R11, <#[R26 + R30]> */
		/* 82227C5Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + regs.R30 + 0x00000000) );
		/* 82227C5Ch case    3:*/		return 0x82227C60;
	}
	return 0x82227C60;
} // Block from 82227C50h-82227C60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82227C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227C60);
		  /* 82227C60h */ case    0:  		/* addi R31, R31, 1 */
		/* 82227C60h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82227C60h case    0:*/		return 0x82227C64;
		  /* 82227C64h */ case    1:  		/* rlwinm R28, R28, 1, 0, 30 */
		/* 82227C64h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R28,regs.R28);
		/* 82227C64h case    1:*/		return 0x82227C68;
		  /* 82227C68h */ case    2:  		/* cmplw CR6, R31, R23 */
		/* 82227C68h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R23);
		/* 82227C68h case    2:*/		return 0x82227C6C;
		  /* 82227C6Ch */ case    3:  		/* bc 12, CR6_LT, -1580 */
		/* 82227C6Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82227640;  }
		/* 82227C6Ch case    3:*/		return 0x82227C70;
		  /* 82227C70h */ case    4:  		/* b 5488 */
		/* 82227C70h case    4:*/		return 0x822291E0;
		/* 82227C70h case    4:*/		return 0x82227C74;
		  /* 82227C74h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82227C74h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227C74h case    5:*/		return 0x82227C78;
		  /* 82227C78h */ case    6:  		/* bc 12, CR6_EQ, -196 */
		/* 82227C78h case    6:*/		if ( regs.CR[6].eq ) { return 0x82227BB4;  }
		/* 82227C78h case    6:*/		return 0x82227C7C;
		  /* 82227C7Ch */ case    7:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 82227C7Ch case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 82227C7Ch case    7:*/		return 0x82227C80;
		  /* 82227C80h */ case    8:  		/* addi R10, R1, 144 */
		/* 82227C80h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227C80h case    8:*/		return 0x82227C84;
		  /* 82227C84h */ case    9:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 82227C84h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227C84h case    9:*/		return 0x82227C88;
		  /* 82227C88h */ case   10:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227C88h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227C88h case   10:*/		return 0x82227C8C;
		  /* 82227C8Ch */ case   11:  		/* bc 4, CR6_LT, 36 */
		/* 82227C8Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x82227CB0;  }
		/* 82227C8Ch case   11:*/		return 0x82227C90;
		  /* 82227C90h */ case   12:  		/* b -340 */
		/* 82227C90h case   12:*/		return 0x82227B3C;
		/* 82227C90h case   12:*/		return 0x82227C94;
		  /* 82227C94h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82227C94h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82227C94h case   13:*/		return 0x82227C98;
		  /* 82227C98h */ case   14:  		/* bc 12, CR6_EQ, -228 */
		/* 82227C98h case   14:*/		if ( regs.CR[6].eq ) { return 0x82227BB4;  }
		/* 82227C98h case   14:*/		return 0x82227C9C;
		  /* 82227C9Ch */ case   15:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 82227C9Ch case   15:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 82227C9Ch case   15:*/		return 0x82227CA0;
		  /* 82227CA0h */ case   16:  		/* addi R10, R1, 144 */
		/* 82227CA0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82227CA0h case   16:*/		return 0x82227CA4;
		  /* 82227CA4h */ case   17:  		/* lfdx FR0, <#[R11 + R10]> */
		/* 82227CA4h case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82227CA4h case   17:*/		return 0x82227CA8;
		  /* 82227CA8h */ case   18:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227CA8h case   18:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227CA8h case   18:*/		return 0x82227CAC;
		  /* 82227CACh */ case   19:  		/* bc 4, CR6_GT, -368 */
		/* 82227CACh case   19:*/		if ( !regs.CR[6].gt ) { return 0x82227B3C;  }
		/* 82227CACh case   19:*/		return 0x82227CB0;
	}
	return 0x82227CB0;
} // Block from 82227C60h-82227CB0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82227CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227CB0);
		  /* 82227CB0h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82227CB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82227CB0h case    0:*/		return 0x82227CB4;
		  /* 82227CB4h */ case    1:  		/* bc 12, CR6_EQ, -256 */
		/* 82227CB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82227BB4;  }
		/* 82227CB4h case    1:*/		return 0x82227CB8;
		  /* 82227CB8h */ case    2:  		/* addi R8, R1, 176 */
		/* 82227CB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xB0);
		/* 82227CB8h case    2:*/		return 0x82227CBC;
		  /* 82227CBCh */ case    3:  		/* addi R6, R1, 116 */
		/* 82227CBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x74);
		/* 82227CBCh case    3:*/		return 0x82227CC0;
		  /* 82227CC0h */ case    4:  		/* b -348 */
		/* 82227CC0h case    4:*/		return 0x82227B64;
		/* 82227CC0h case    4:*/		return 0x82227CC4;
	}
	return 0x82227CC4;
} // Block from 82227CB0h-82227CC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82227CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227CC4);
		  /* 82227CC4h */ case    0:  		/* rlwinm R11, R26, 25, 25, 31 */
		/* 82227CC4h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R26);
		/* 82227CC4h case    0:*/		return 0x82227CC8;
		  /* 82227CC8h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 82227CC8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82227CC8h case    1:*/		return 0x82227CCC;
		  /* 82227CCCh */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 82227CCCh case    2:*/		if ( regs.CR[6].lt ) { return 0x82227CDC;  }
		/* 82227CCCh case    2:*/		return 0x82227CD0;
		  /* 82227CD0h */ case    3:  		/* cmplwi CR6, R11, 31 */
		/* 82227CD0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82227CD0h case    3:*/		return 0x82227CD4;
		  /* 82227CD4h */ case    4:  		/* mr R10, R28 */
		/* 82227CD4h case    4:*/		regs.R10 = regs.R28;
		/* 82227CD4h case    4:*/		return 0x82227CD8;
		  /* 82227CD8h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 82227CD8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82227CE0;  }
		/* 82227CD8h case    5:*/		return 0x82227CDC;
	}
	return 0x82227CDC;
} // Block from 82227CC4h-82227CDCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82227CDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227CDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227CDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227CDC);
		  /* 82227CDCh */ case    0:  		/* mr R10, R31 */
		/* 82227CDCh case    0:*/		regs.R10 = regs.R31;
		/* 82227CDCh case    0:*/		return 0x82227CE0;
	}
	return 0x82227CE0;
} // Block from 82227CDCh-82227CE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227CE0);
		  /* 82227CE0h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82227CE0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82227CE0h case    0:*/		return 0x82227CE4;
		  /* 82227CE4h */ case    1:  		/* bc 12, CR0_EQ, 1004 */
		/* 82227CE4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822280D0;  }
		/* 82227CE4h case    1:*/		return 0x82227CE8;
		  /* 82227CE8h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 82227CE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82227CE8h case    2:*/		return 0x82227CEC;
		  /* 82227CECh */ case    3:  		/* bc 12, CR6_EQ, 732 */
		/* 82227CECh case    3:*/		if ( regs.CR[6].eq ) { return 0x82227FC8;  }
		/* 82227CECh case    3:*/		return 0x82227CF0;
		  /* 82227CF0h */ case    4:  		/* cmplwi CR6, R11, 17 */
		/* 82227CF0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 82227CF0h case    4:*/		return 0x82227CF4;
		  /* 82227CF4h */ case    5:  		/* bc 12, CR6_EQ, 536 */
		/* 82227CF4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82227F0C;  }
		/* 82227CF4h case    5:*/		return 0x82227CF8;
		  /* 82227CF8h */ case    6:  		/* cmplwi CR6, R11, 18 */
		/* 82227CF8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 82227CF8h case    6:*/		return 0x82227CFC;
		  /* 82227CFCh */ case    7:  		/* bc 12, CR6_EQ, 336 */
		/* 82227CFCh case    7:*/		if ( regs.CR[6].eq ) { return 0x82227E4C;  }
		/* 82227CFCh case    7:*/		return 0x82227D00;
		  /* 82227D00h */ case    8:  		/* cmplwi CR6, R11, 19 */
		/* 82227D00h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 82227D00h case    8:*/		return 0x82227D04;
		  /* 82227D04h */ case    9:  		/* bc 12, CR6_EQ, 5172 */
		/* 82227D04h case    9:*/		if ( regs.CR[6].eq ) { return 0x82229138;  }
		/* 82227D04h case    9:*/		return 0x82227D08;
		  /* 82227D08h */ case   10:  		/* cmplwi CR6, R11, 20 */
		/* 82227D08h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000014);
		/* 82227D08h case   10:*/		return 0x82227D0C;
		  /* 82227D0Ch */ case   11:  		/* bc 12, CR6_EQ, 208 */
		/* 82227D0Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82227DDC;  }
		/* 82227D0Ch case   11:*/		return 0x82227D10;
		  /* 82227D10h */ case   12:  		/* cmplwi CR6, R11, 29 */
		/* 82227D10h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001D);
		/* 82227D10h case   12:*/		return 0x82227D14;
		  /* 82227D14h */ case   13:  		/* bc 4, CR6_EQ, 5324 */
		/* 82227D14h case   13:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227D14h case   13:*/		return 0x82227D18;
		  /* 82227D18h */ case   14:  		/* lwz R11, <#[R1 + 80]> */
		/* 82227D18h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227D18h case   14:*/		return 0x82227D1C;
		  /* 82227D1Ch */ case   15:  		/* rlwinm. R10, R11, 25, 31, 31 */
		/* 82227D1Ch case   15:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R10,regs.R11);
		/* 82227D1Ch case   15:*/		return 0x82227D20;
		  /* 82227D20h */ case   16:  		/* bc 12, CR0_EQ, 36 */
		/* 82227D20h case   16:*/		if ( regs.CR[0].eq ) { return 0x82227D44;  }
		/* 82227D20h case   16:*/		return 0x82227D24;
		  /* 82227D24h */ case   17:  		/* lwz R10, <#[R1 + 116]> */
		/* 82227D24h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 82227D24h case   17:*/		return 0x82227D28;
		  /* 82227D28h */ case   18:  		/* lfd FR0, <#[R1 + 200]> */
		/* 82227D28h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C8) );
		/* 82227D28h case   18:*/		return 0x82227D2C;
		  /* 82227D2Ch */ case   19:  		/* stfd FR0, <#[R18 + 24]> */
		/* 82227D2Ch case   19:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R18 + 0x00000018) );
		/* 82227D2Ch case   19:*/		return 0x82227D30;
		  /* 82227D30h */ case   20:  		/* lwz R9, <#[R30]> */
		/* 82227D30h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82227D30h case   20:*/		return 0x82227D34;
		  /* 82227D34h */ case   21:  		/* rlwinm R10, R10, 0, 24, 25 */
		/* 82227D34h case   21:*/		cpu::op::rlwinm<0,0,24,25>(regs,&regs.R10,regs.R10);
		/* 82227D34h case   21:*/		return 0x82227D38;
		  /* 82227D38h */ case   22:  		/* li R27, 8 */
		/* 82227D38h case   22:*/		cpu::op::li<0>(regs,&regs.R27,0x8);
		/* 82227D38h case   22:*/		return 0x82227D3C;
		  /* 82227D3Ch */ case   23:  		/* or R10, R10, R9 */
		/* 82227D3Ch case   23:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82227D3Ch case   23:*/		return 0x82227D40;
		  /* 82227D40h */ case   24:  		/* stw R10, <#[R30]> */
		/* 82227D40h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82227D40h case   24:*/		return 0x82227D44;
	}
	return 0x82227D44;
} // Block from 82227CE0h-82227D44h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82227D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227D44);
		  /* 82227D44h */ case    0:  		/* rlwinm. R10, R11, 30, 31, 31 */
		/* 82227D44h case    0:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R11);
		/* 82227D44h case    0:*/		return 0x82227D48;
	}
	return 0x82227D48;
} // Block from 82227D44h-82227D48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227D48h
// Function '?GetModifiedConstantData@Instruction@D3DXShader@@QAA?AUCONSTVALDATA@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227D48);
		  /* 82227D48h */ case    0:  		/* bc 12, CR0_EQ, 36 */
		/* 82227D48h case    0:*/		if ( regs.CR[0].eq ) { return 0x82227D6C;  }
		/* 82227D48h case    0:*/		return 0x82227D4C;
		  /* 82227D4Ch */ case    1:  		/* lwz R10, <#[R1 + 112]> */
		/* 82227D4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 82227D4Ch case    1:*/		return 0x82227D50;
		  /* 82227D50h */ case    2:  		/* lfd FR0, <#[R1 + 160]> */
		/* 82227D50h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000A0) );
		/* 82227D50h case    2:*/		return 0x82227D54;
		  /* 82227D54h */ case    3:  		/* stfd FR0, <#[R18 + 16]> */
		/* 82227D54h case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R18 + 0x00000010) );
		/* 82227D54h case    3:*/		return 0x82227D58;
		  /* 82227D58h */ case    4:  		/* lwz R9, <#[R30]> */
		/* 82227D58h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82227D58h case    4:*/		return 0x82227D5C;
		  /* 82227D5Ch */ case    5:  		/* rlwinm R10, R10, 0, 26, 27 */
		/* 82227D5Ch case    5:*/		cpu::op::rlwinm<0,0,26,27>(regs,&regs.R10,regs.R10);
		/* 82227D5Ch case    5:*/		return 0x82227D60;
		  /* 82227D60h */ case    6:  		/* ori R27, R27, 4 */
		/* 82227D60h case    6:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82227D60h case    6:*/		return 0x82227D64;
		  /* 82227D64h */ case    7:  		/* or R10, R10, R9 */
		/* 82227D64h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82227D64h case    7:*/		return 0x82227D68;
		  /* 82227D68h */ case    8:  		/* stw R10, <#[R30]> */
		/* 82227D68h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82227D68h case    8:*/		return 0x82227D6C;
	}
	return 0x82227D6C;
} // Block from 82227D48h-82227D6Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82227D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227D6C);
		  /* 82227D6Ch */ case    0:  		/* rlwinm. R10, R11, 31, 31, 31 */
		/* 82227D6Ch case    0:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R11);
		/* 82227D6Ch case    0:*/		return 0x82227D70;
		  /* 82227D70h */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 82227D70h case    1:*/		if ( regs.CR[0].eq ) { return 0x82227DD4;  }
		/* 82227D70h case    1:*/		return 0x82227D74;
		  /* 82227D74h */ case    2:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82227D74h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82227D74h case    2:*/		return 0x82227D78;
		  /* 82227D78h */ case    3:  		/* bc 12, CR0_EQ, 92 */
		/* 82227D78h case    3:*/		if ( regs.CR[0].eq ) { return 0x82227DD4;  }
		/* 82227D78h case    3:*/		return 0x82227D7C;
		  /* 82227D7Ch */ case    4:  		/* lis R11, -32256 */
		/* 82227D7Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82227D7Ch case    4:*/		return 0x82227D80;
		  /* 82227D80h */ case    5:  		/* lfd FR12, <#[R1 + 152]> */
		/* 82227D80h case    5:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000098) );
		/* 82227D80h case    5:*/		return 0x82227D84;
		  /* 82227D84h */ case    6:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82227D84h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82227D84h case    6:*/		return 0x82227D88;
		  /* 82227D88h */ case    7:  		/* fcmpu CR6, FR12, FR0 */
		/* 82227D88h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82227D88h case    7:*/		return 0x82227D8C;
		  /* 82227D8Ch */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 82227D8Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82227DA8;  }
		/* 82227D8Ch case    8:*/		return 0x82227D90;
		  /* 82227D90h */ case    9:  		/* lfd FR13, <#[R1 + 184]> */
		/* 82227D90h case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000B8) );
		/* 82227D90h case    9:*/		return 0x82227D94;
		  /* 82227D94h */ case   10:  		/* fcmpu CR6, FR13, FR0 */
		/* 82227D94h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82227D94h case   10:*/		return 0x82227D98;
		  /* 82227D98h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 82227D98h case   11:*/		if ( regs.CR[6].eq ) { return 0x82227DA8;  }
		/* 82227D98h case   11:*/		return 0x82227D9C;
		  /* 82227D9Ch */ case   12:  		/* fmul FR1, FR12, FR13 */
		/* 82227D9Ch case   12:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR12,regs.FR13);
		/* 82227D9Ch case   12:*/		return 0x82227DA0;
		  /* 82227DA0h */ case   13:  		/* bl -438032 */
		/* 82227DA0h case   13:*/		regs.LR = 0x82227DA4; return 0x821BCE90;
		/* 82227DA0h case   13:*/		return 0x82227DA4;
		  /* 82227DA4h */ case   14:  		/* fmr FR0, FR1 */
		/* 82227DA4h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR1);
		/* 82227DA4h case   14:*/		return 0x82227DA8;
	}
	return 0x82227DA8;
} // Block from 82227D6Ch-82227DA8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82227DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227DA8);
		  /* 82227DA8h */ case    0:  		/* stfd FR0, <#[R18 + 8]> */
		/* 82227DA8h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R18 + 0x00000008) );
		/* 82227DA8h case    0:*/		return 0x82227DAC;
		  /* 82227DACh */ case    1:  		/* lwz R11, <#[R1 + 116]> */
		/* 82227DACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 82227DACh case    1:*/		return 0x82227DB0;
		  /* 82227DB0h */ case    2:  		/* lwz R10, <#[R1 + 112]> */
		/* 82227DB0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 82227DB0h case    2:*/		return 0x82227DB4;
		  /* 82227DB4h */ case    3:  		/* ori R27, R27, 2 */
		/* 82227DB4h case    3:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x2);
		/* 82227DB4h case    3:*/		return 0x82227DB8;
		  /* 82227DB8h */ case    4:  		/* rlwinm R4, R11, 30, 30, 31 */
		/* 82227DB8h case    4:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R4,regs.R11);
		/* 82227DB8h case    4:*/		return 0x82227DBC;
		  /* 82227DBCh */ case    5:  		/* rlwinm R3, R10, 30, 30, 31 */
		/* 82227DBCh case    5:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R3,regs.R10);
		/* 82227DBCh case    5:*/		return 0x82227DC0;
		  /* 82227DC0h */ case    6:  		/* bl -435712 */
		/* 82227DC0h case    6:*/		regs.LR = 0x82227DC4; return 0x821BD7C0;
		/* 82227DC0h case    6:*/		return 0x82227DC4;
		  /* 82227DC4h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 82227DC4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82227DC4h case    7:*/		return 0x82227DC8;
		  /* 82227DC8h */ case    8:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82227DC8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82227DC8h case    8:*/		return 0x82227DCC;
		  /* 82227DCCh */ case    9:  		/* or R11, R10, R11 */
		/* 82227DCCh case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82227DCCh case    9:*/		return 0x82227DD0;
		  /* 82227DD0h */ case   10:  		/* stw R11, <#[R30]> */
		/* 82227DD0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82227DD0h case   10:*/		return 0x82227DD4;
	}
	return 0x82227DD4;
} // Block from 82227DA8h-82227DD4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82227DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227DD4);
		  /* 82227DD4h */ case    0:  		/* ori R27, R27, 1 */
		/* 82227DD4h case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82227DD4h case    0:*/		return 0x82227DD8;
		  /* 82227DD8h */ case    1:  		/* b 1852 */
		/* 82227DD8h case    1:*/		return 0x82228514;
		/* 82227DD8h case    1:*/		return 0x82227DDC;
	}
	return 0x82227DDC;
} // Block from 82227DD4h-82227DDCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82227DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227DDC);
		  /* 82227DDCh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82227DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227DDCh case    0:*/		return 0x82227DE0;
		  /* 82227DE0h */ case    1:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82227DE0h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82227DE0h case    1:*/		return 0x82227DE4;
		  /* 82227DE4h */ case    2:  		/* cmplwi CR6, R11, 15 */
		/* 82227DE4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82227DE4h case    2:*/		return 0x82227DE8;
		  /* 82227DE8h */ case    3:  		/* bc 4, CR6_EQ, 5112 */
		/* 82227DE8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227DE8h case    3:*/		return 0x82227DEC;
		  /* 82227DECh */ case    4:  		/* lfd FR0, <#[R1 + 160]> */
		/* 82227DECh case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000A0) );
		/* 82227DECh case    4:*/		return 0x82227DF0;
		  /* 82227DF0h */ case    5:  		/* lfd FR13, <#[R1 + 168]> */
		/* 82227DF0h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000A8) );
		/* 82227DF0h case    5:*/		return 0x82227DF4;
		  /* 82227DF4h */ case    6:  		/* lfd FR12, <#[R1 + 152]> */
		/* 82227DF4h case    6:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000098) );
		/* 82227DF4h case    6:*/		return 0x82227DF8;
		  /* 82227DF8h */ case    7:  		/* fcmpu CR6, FR0, FR13 */
		/* 82227DF8h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82227DF8h case    7:*/		return 0x82227DFC;
		  /* 82227DFCh */ case    8:  		/* bc 12, CR6_LT, 12 */
		/* 82227DFCh case    8:*/		if ( regs.CR[6].lt ) { return 0x82227E08;  }
		/* 82227DFCh case    8:*/		return 0x82227E00;
		  /* 82227E00h */ case    9:  		/* fmr FR13, FR0 */
		/* 82227E00h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR0);
		/* 82227E00h case    9:*/		return 0x82227E04;
		  /* 82227E04h */ case   10:  		/* b 8 */
		/* 82227E04h case   10:*/		return 0x82227E0C;
		/* 82227E04h case   10:*/		return 0x82227E08;
	}
	return 0x82227E08;
} // Block from 82227DDCh-82227E08h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82227E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E08);
		  /* 82227E08h */ case    0:  		/* fmr FR0, FR13 */
		/* 82227E08h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 82227E08h case    0:*/		return 0x82227E0C;
	}
	return 0x82227E0C;
} // Block from 82227E08h-82227E0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E0C);
		  /* 82227E0Ch */ case    0:  		/* fcmpu CR6, FR12, FR0 */
		/* 82227E0Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82227E0Ch case    0:*/		return 0x82227E10;
		  /* 82227E10h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 82227E10h case    1:*/		if ( regs.CR[6].lt ) { return 0x82227E1C;  }
		/* 82227E10h case    1:*/		return 0x82227E14;
		  /* 82227E14h */ case    2:  		/* fmr FR13, FR12 */
		/* 82227E14h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR12);
		/* 82227E14h case    2:*/		return 0x82227E18;
		  /* 82227E18h */ case    3:  		/* b 8 */
		/* 82227E18h case    3:*/		return 0x82227E20;
		/* 82227E18h case    3:*/		return 0x82227E1C;
	}
	return 0x82227E1C;
} // Block from 82227E0Ch-82227E1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82227E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E1C);
		  /* 82227E1Ch */ case    0:  		/* fmr FR12, FR0 */
		/* 82227E1Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR12,regs.FR0);
		/* 82227E1Ch case    0:*/		return 0x82227E20;
	}
	return 0x82227E20;
} // Block from 82227E1Ch-82227E20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E20);
		  /* 82227E20h */ case    0:  		/* lfd FR0, <#[R1 + 144]> */
		/* 82227E20h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000090) );
		/* 82227E20h case    0:*/		return 0x82227E24;
		  /* 82227E24h */ case    1:  		/* fcmpu CR6, FR0, FR12 */
		/* 82227E24h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82227E24h case    1:*/		return 0x82227E28;
		  /* 82227E28h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82227E28h case    2:*/		if ( regs.CR[6].lt ) { return 0x82227E30;  }
		/* 82227E28h case    2:*/		return 0x82227E2C;
		  /* 82227E2Ch */ case    3:  		/* fmr FR13, FR0 */
		/* 82227E2Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR0);
		/* 82227E2Ch case    3:*/		return 0x82227E30;
	}
	return 0x82227E30;
} // Block from 82227E20h-82227E30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82227E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E30);
		  /* 82227E30h */ case    0:  		/* stfd FR13, <#[R18]> */
		/* 82227E30h case    0:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R18 + 0x00000000) );
		/* 82227E30h case    0:*/		return 0x82227E34;
		  /* 82227E34h */ case    1:  		/* lwz R3, <#[R1 + 112]> */
		/* 82227E34h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 82227E34h case    1:*/		return 0x82227E38;
		  /* 82227E38h */ case    2:  		/* mr R27, R28 */
		/* 82227E38h case    2:*/		regs.R27 = regs.R28;
		/* 82227E38h case    2:*/		return 0x82227E3C;
		  /* 82227E3Ch */ case    3:  		/* bl -5860 */
		/* 82227E3Ch case    3:*/		regs.LR = 0x82227E40; return 0x82226758;
		/* 82227E3Ch case    3:*/		return 0x82227E40;
		  /* 82227E40h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 82227E40h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82227E40h case    4:*/		return 0x82227E44;
		  /* 82227E44h */ case    5:  		/* or R11, R11, R3 */
		/* 82227E44h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82227E44h case    5:*/		return 0x82227E48;
		  /* 82227E48h */ case    6:  		/* b 4624 */
		/* 82227E48h case    6:*/		return 0x82229058;
		/* 82227E48h case    6:*/		return 0x82227E4C;
	}
	return 0x82227E4C;
} // Block from 82227E30h-82227E4Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82227E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E4C);
		  /* 82227E4Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82227E4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227E4Ch case    0:*/		return 0x82227E50;
		  /* 82227E50h */ case    1:  		/* rlwinm R10, R11, 0, 28, 31 */
		/* 82227E50h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82227E50h case    1:*/		return 0x82227E54;
		  /* 82227E54h */ case    2:  		/* cmplwi CR6, R10, 3 */
		/* 82227E54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 82227E54h case    2:*/		return 0x82227E58;
	}
	return 0x82227E58;
} // Block from 82227E4Ch-82227E58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82227E58h
// Function '?ComputeConstantOutputs@Instruction@D3DXShader@@QAAIQANPAV?$BitFieldSet@V?$FixedSizeBitSet@I$00@D3DXShader@@II$01@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227E58);
		  /* 82227E58h */ case    0:  		/* bc 4, CR6_EQ, 5000 */
		/* 82227E58h case    0:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227E58h case    0:*/		return 0x82227E5C;
		  /* 82227E5Ch */ case    1:  		/* rlwinm R10, R11, 0, 24, 27 */
		/* 82227E5Ch case    1:*/		cpu::op::rlwinm<0,0,24,27>(regs,&regs.R10,regs.R11);
		/* 82227E5Ch case    1:*/		return 0x82227E60;
		  /* 82227E60h */ case    2:  		/* cmplwi CR6, R10, 48 */
		/* 82227E60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000030);
		/* 82227E60h case    2:*/		return 0x82227E64;
		  /* 82227E64h */ case    3:  		/* bc 4, CR6_EQ, 4988 */
		/* 82227E64h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227E64h case    3:*/		return 0x82227E68;
		  /* 82227E68h */ case    4:  		/* rlwinm R11, R11, 0, 20, 23 */
		/* 82227E68h case    4:*/		cpu::op::rlwinm<0,0,20,23>(regs,&regs.R11,regs.R11);
		/* 82227E68h case    4:*/		return 0x82227E6C;
		  /* 82227E6Ch */ case    5:  		/* cmplwi CR6, R11, 256 */
		/* 82227E6Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 82227E6Ch case    5:*/		return 0x82227E70;
		  /* 82227E70h */ case    6:  		/* bc 4, CR6_EQ, 4976 */
		/* 82227E70h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227E70h case    6:*/		return 0x82227E74;
		  /* 82227E74h */ case    7:  		/* lis R11, -32256 */
		/* 82227E74h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82227E74h case    7:*/		return 0x82227E78;
		  /* 82227E78h */ case    8:  		/* lfd FR13, <#[R1 + 152]> */
		/* 82227E78h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000098) );
		/* 82227E78h case    8:*/		return 0x82227E7C;
		  /* 82227E7Ch */ case    9:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82227E7Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82227E7Ch case    9:*/		return 0x82227E80;
		  /* 82227E80h */ case   10:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227E80h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227E80h case   10:*/		return 0x82227E84;
		  /* 82227E84h */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 82227E84h case   11:*/		if ( regs.CR[6].eq ) { return 0x82227EA0;  }
		/* 82227E84h case   11:*/		return 0x82227E88;
		  /* 82227E88h */ case   12:  		/* lfd FR0, <#[R1 + 184]> */
		/* 82227E88h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B8) );
		/* 82227E88h case   12:*/		return 0x82227E8C;
		  /* 82227E8Ch */ case   13:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227E8Ch case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227E8Ch case   13:*/		return 0x82227E90;
		  /* 82227E90h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 82227E90h case   14:*/		if ( regs.CR[6].eq ) { return 0x82227EA0;  }
		/* 82227E90h case   14:*/		return 0x82227E94;
		  /* 82227E94h */ case   15:  		/* fmul FR1, FR13, FR0 */
		/* 82227E94h case   15:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82227E94h case   15:*/		return 0x82227E98;
		  /* 82227E98h */ case   16:  		/* bl -438280 */
		/* 82227E98h case   16:*/		regs.LR = 0x82227E9C; return 0x821BCE90;
		/* 82227E98h case   16:*/		return 0x82227E9C;
		  /* 82227E9Ch */ case   17:  		/* b 8 */
		/* 82227E9Ch case   17:*/		return 0x82227EA4;
		/* 82227E9Ch case   17:*/		return 0x82227EA0;
	}
	return 0x82227EA0;
} // Block from 82227E58h-82227EA0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82227EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227EA0);
		  /* 82227EA0h */ case    0:  		/* fmr FR1, FR31 */
		/* 82227EA0h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82227EA0h case    0:*/		return 0x82227EA4;
	}
	return 0x82227EA4;
} // Block from 82227EA0h-82227EA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227EA4);
		  /* 82227EA4h */ case    0:  		/* lfd FR0, <#[R1 + 208]> */
		/* 82227EA4h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000D0) );
		/* 82227EA4h case    0:*/		return 0x82227EA8;
		  /* 82227EA8h */ case    1:  		/* fadd FR1, FR1, FR0 */
		/* 82227EA8h case    1:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR0);
		/* 82227EA8h case    1:*/		return 0x82227EAC;
		  /* 82227EACh */ case    2:  		/* bl -438300 */
		/* 82227EACh case    2:*/		regs.LR = 0x82227EB0; return 0x821BCE90;
		/* 82227EACh case    2:*/		return 0x82227EB0;
		  /* 82227EB0h */ case    3:  		/* lfd FR13, <#[R1 + 144]> */
		/* 82227EB0h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000090) );
		/* 82227EB0h case    3:*/		return 0x82227EB4;
		  /* 82227EB4h */ case    4:  		/* fmr FR30, FR1 */
		/* 82227EB4h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82227EB4h case    4:*/		return 0x82227EB8;
		  /* 82227EB8h */ case    5:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227EB8h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227EB8h case    5:*/		return 0x82227EBC;
		  /* 82227EBCh */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 82227EBCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82227ED8;  }
		/* 82227EBCh case    6:*/		return 0x82227EC0;
		  /* 82227EC0h */ case    7:  		/* lfd FR0, <#[R1 + 176]> */
		/* 82227EC0h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B0) );
		/* 82227EC0h case    7:*/		return 0x82227EC4;
		  /* 82227EC4h */ case    8:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227EC4h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227EC4h case    8:*/		return 0x82227EC8;
		  /* 82227EC8h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 82227EC8h case    9:*/		if ( regs.CR[6].eq ) { return 0x82227ED8;  }
		/* 82227EC8h case    9:*/		return 0x82227ECC;
		  /* 82227ECCh */ case   10:  		/* fmul FR1, FR13, FR0 */
		/* 82227ECCh case   10:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82227ECCh case   10:*/		return 0x82227ED0;
		  /* 82227ED0h */ case   11:  		/* bl -438336 */
		/* 82227ED0h case   11:*/		regs.LR = 0x82227ED4; return 0x821BCE90;
		/* 82227ED0h case   11:*/		return 0x82227ED4;
		  /* 82227ED4h */ case   12:  		/* b 8 */
		/* 82227ED4h case   12:*/		return 0x82227EDC;
		/* 82227ED4h case   12:*/		return 0x82227ED8;
	}
	return 0x82227ED8;
} // Block from 82227EA4h-82227ED8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82227ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227ED8);
		  /* 82227ED8h */ case    0:  		/* fmr FR1, FR31 */
		/* 82227ED8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82227ED8h case    0:*/		return 0x82227EDC;
	}
	return 0x82227EDC;
} // Block from 82227ED8h-82227EDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227EDC);
		  /* 82227EDCh */ case    0:  		/* fadd FR1, FR1, FR30 */
		/* 82227EDCh case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 82227EDCh case    0:*/		return 0x82227EE0;
		  /* 82227EE0h */ case    1:  		/* bl -438352 */
		/* 82227EE0h case    1:*/		regs.LR = 0x82227EE4; return 0x821BCE90;
		/* 82227EE0h case    1:*/		return 0x82227EE4;
		  /* 82227EE4h */ case    2:  		/* stfd FR1, <#[R18]> */
		/* 82227EE4h case    2:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R18 + 0x00000000) );
		/* 82227EE4h case    2:*/		return 0x82227EE8;
		  /* 82227EE8h */ case    3:  		/* lwz R11, <#[R1 + 120]> */
		/* 82227EE8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 82227EE8h case    3:*/		return 0x82227EEC;
		  /* 82227EECh */ case    4:  		/* li R4, 2 */
		/* 82227EECh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82227EECh case    4:*/		return 0x82227EF0;
		  /* 82227EF0h */ case    5:  		/* addi R3, R1, 112 */
		/* 82227EF0h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82227EF0h case    5:*/		return 0x82227EF4;
		  /* 82227EF4h */ case    6:  		/* mr R27, R28 */
		/* 82227EF4h case    6:*/		regs.R27 = regs.R28;
		/* 82227EF4h case    6:*/		return 0x82227EF8;
		  /* 82227EF8h */ case    7:  		/* rlwinm R31, R11, 0, 30, 31 */
		/* 82227EF8h case    7:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R11);
		/* 82227EF8h case    7:*/		return 0x82227EFC;
		  /* 82227EFCh */ case    8:  		/* bl -386756 */
		/* 82227EFCh case    8:*/		regs.LR = 0x82227F00; return 0x821C9838;
		/* 82227EFCh case    8:*/		return 0x82227F00;
		  /* 82227F00h */ case    9:  		/* mr R4, R31 */
		/* 82227F00h case    9:*/		regs.R4 = regs.R31;
		/* 82227F00h case    9:*/		return 0x82227F04;
		  /* 82227F04h */ case   10:  		/* bl -436036 */
		/* 82227F04h case   10:*/		regs.LR = 0x82227F08; return 0x821BD7C0;
		/* 82227F04h case   10:*/		return 0x82227F08;
		  /* 82227F08h */ case   11:  		/* b 444 */
		/* 82227F08h case   11:*/		return 0x822280C4;
		/* 82227F08h case   11:*/		return 0x82227F0C;
	}
	return 0x82227F0C;
} // Block from 82227EDCh-82227F0Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82227F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227F0C);
		  /* 82227F0Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82227F0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227F0Ch case    0:*/		return 0x82227F10;
		  /* 82227F10h */ case    1:  		/* rlwinm R10, R11, 0, 28, 31 */
		/* 82227F10h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82227F10h case    1:*/		return 0x82227F14;
		  /* 82227F14h */ case    2:  		/* cmplwi CR6, R10, 7 */
		/* 82227F14h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 82227F14h case    2:*/		return 0x82227F18;
		  /* 82227F18h */ case    3:  		/* bc 4, CR6_EQ, 4808 */
		/* 82227F18h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227F18h case    3:*/		return 0x82227F1C;
		  /* 82227F1Ch */ case    4:  		/* rlwinm R11, R11, 0, 24, 27 */
		/* 82227F1Ch case    4:*/		cpu::op::rlwinm<0,0,24,27>(regs,&regs.R11,regs.R11);
		/* 82227F1Ch case    4:*/		return 0x82227F20;
		  /* 82227F20h */ case    5:  		/* cmplwi CR6, R11, 112 */
		/* 82227F20h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 82227F20h case    5:*/		return 0x82227F24;
		  /* 82227F24h */ case    6:  		/* bc 4, CR6_EQ, 4796 */
		/* 82227F24h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227F24h case    6:*/		return 0x82227F28;
		  /* 82227F28h */ case    7:  		/* lis R11, -32256 */
		/* 82227F28h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82227F28h case    7:*/		return 0x82227F2C;
		  /* 82227F2Ch */ case    8:  		/* lfd FR13, <#[R1 + 160]> */
		/* 82227F2Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000A0) );
		/* 82227F2Ch case    8:*/		return 0x82227F30;
		  /* 82227F30h */ case    9:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82227F30h case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82227F30h case    9:*/		return 0x82227F34;
		  /* 82227F34h */ case   10:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227F34h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227F34h case   10:*/		return 0x82227F38;
		  /* 82227F38h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82227F38h case   11:*/		if ( regs.CR[6].eq ) { return 0x82227F58;  }
		/* 82227F38h case   11:*/		return 0x82227F3C;
		  /* 82227F3Ch */ case   12:  		/* lfd FR0, <#[R1 + 192]> */
		/* 82227F3Ch case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C0) );
		/* 82227F3Ch case   12:*/		return 0x82227F40;
		  /* 82227F40h */ case   13:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227F40h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227F40h case   13:*/		return 0x82227F44;
		  /* 82227F44h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82227F44h case   14:*/		if ( regs.CR[6].eq ) { return 0x82227F58;  }
		/* 82227F44h case   14:*/		return 0x82227F48;
		  /* 82227F48h */ case   15:  		/* fmul FR1, FR13, FR0 */
		/* 82227F48h case   15:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82227F48h case   15:*/		return 0x82227F4C;
		  /* 82227F4Ch */ case   16:  		/* bl -438460 */
		/* 82227F4Ch case   16:*/		regs.LR = 0x82227F50; return 0x821BCE90;
		/* 82227F4Ch case   16:*/		return 0x82227F50;
		  /* 82227F50h */ case   17:  		/* fmr FR30, FR1 */
		/* 82227F50h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82227F50h case   17:*/		return 0x82227F54;
		  /* 82227F54h */ case   18:  		/* b 8 */
		/* 82227F54h case   18:*/		return 0x82227F5C;
		/* 82227F54h case   18:*/		return 0x82227F58;
	}
	return 0x82227F58;
} // Block from 82227F0Ch-82227F58h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82227F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227F58);
		  /* 82227F58h */ case    0:  		/* fmr FR30, FR31 */
		/* 82227F58h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR31);
		/* 82227F58h case    0:*/		return 0x82227F5C;
	}
	return 0x82227F5C;
} // Block from 82227F58h-82227F5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227F5C);
		  /* 82227F5Ch */ case    0:  		/* lfd FR13, <#[R1 + 152]> */
		/* 82227F5Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000098) );
		/* 82227F5Ch case    0:*/		return 0x82227F60;
		  /* 82227F60h */ case    1:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227F60h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227F60h case    1:*/		return 0x82227F64;
		  /* 82227F64h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82227F64h case    2:*/		if ( regs.CR[6].eq ) { return 0x82227F80;  }
		/* 82227F64h case    2:*/		return 0x82227F68;
		  /* 82227F68h */ case    3:  		/* lfd FR0, <#[R1 + 184]> */
		/* 82227F68h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B8) );
		/* 82227F68h case    3:*/		return 0x82227F6C;
		  /* 82227F6Ch */ case    4:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227F6Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227F6Ch case    4:*/		return 0x82227F70;
		  /* 82227F70h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82227F70h case    5:*/		if ( regs.CR[6].eq ) { return 0x82227F80;  }
		/* 82227F70h case    5:*/		return 0x82227F74;
		  /* 82227F74h */ case    6:  		/* fmul FR1, FR13, FR0 */
		/* 82227F74h case    6:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82227F74h case    6:*/		return 0x82227F78;
		  /* 82227F78h */ case    7:  		/* bl -438504 */
		/* 82227F78h case    7:*/		regs.LR = 0x82227F7C; return 0x821BCE90;
		/* 82227F78h case    7:*/		return 0x82227F7C;
		  /* 82227F7Ch */ case    8:  		/* b 8 */
		/* 82227F7Ch case    8:*/		return 0x82227F84;
		/* 82227F7Ch case    8:*/		return 0x82227F80;
	}
	return 0x82227F80;
} // Block from 82227F5Ch-82227F80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82227F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227F80);
		  /* 82227F80h */ case    0:  		/* fmr FR1, FR31 */
		/* 82227F80h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82227F80h case    0:*/		return 0x82227F84;
	}
	return 0x82227F84;
} // Block from 82227F80h-82227F84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227F84);
		  /* 82227F84h */ case    0:  		/* fadd FR1, FR1, FR30 */
		/* 82227F84h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 82227F84h case    0:*/		return 0x82227F88;
		  /* 82227F88h */ case    1:  		/* bl -438520 */
		/* 82227F88h case    1:*/		regs.LR = 0x82227F8C; return 0x821BCE90;
		/* 82227F88h case    1:*/		return 0x82227F8C;
		  /* 82227F8Ch */ case    2:  		/* lfd FR0, <#[R1 + 144]> */
		/* 82227F8Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000090) );
		/* 82227F8Ch case    2:*/		return 0x82227F90;
		  /* 82227F90h */ case    3:  		/* fmr FR30, FR1 */
		/* 82227F90h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82227F90h case    3:*/		return 0x82227F94;
		  /* 82227F94h */ case    4:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227F94h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227F94h case    4:*/		return 0x82227F98;
		  /* 82227F98h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82227F98h case    5:*/		if ( regs.CR[6].eq ) { return 0x82227FB4;  }
		/* 82227F98h case    5:*/		return 0x82227F9C;
		  /* 82227F9Ch */ case    6:  		/* lfd FR13, <#[R1 + 176]> */
		/* 82227F9Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000B0) );
		/* 82227F9Ch case    6:*/		return 0x82227FA0;
		  /* 82227FA0h */ case    7:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227FA0h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227FA0h case    7:*/		return 0x82227FA4;
		  /* 82227FA4h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82227FA4h case    8:*/		if ( regs.CR[6].eq ) { return 0x82227FB4;  }
		/* 82227FA4h case    8:*/		return 0x82227FA8;
		  /* 82227FA8h */ case    9:  		/* fmul FR1, FR0, FR13 */
		/* 82227FA8h case    9:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 82227FA8h case    9:*/		return 0x82227FAC;
		  /* 82227FACh */ case   10:  		/* bl -438556 */
		/* 82227FACh case   10:*/		regs.LR = 0x82227FB0; return 0x821BCE90;
		/* 82227FACh case   10:*/		return 0x82227FB0;
		  /* 82227FB0h */ case   11:  		/* b 8 */
		/* 82227FB0h case   11:*/		return 0x82227FB8;
		/* 82227FB0h case   11:*/		return 0x82227FB4;
	}
	return 0x82227FB4;
} // Block from 82227F84h-82227FB4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82227FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227FB4);
		  /* 82227FB4h */ case    0:  		/* fmr FR1, FR31 */
		/* 82227FB4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82227FB4h case    0:*/		return 0x82227FB8;
	}
	return 0x82227FB8;
} // Block from 82227FB4h-82227FB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82227FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227FB8);
		  /* 82227FB8h */ case    0:  		/* fadd FR1, FR1, FR30 */
		/* 82227FB8h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 82227FB8h case    0:*/		return 0x82227FBC;
		  /* 82227FBCh */ case    1:  		/* bl -438572 */
		/* 82227FBCh case    1:*/		regs.LR = 0x82227FC0; return 0x821BCE90;
		/* 82227FBCh case    1:*/		return 0x82227FC0;
		  /* 82227FC0h */ case    2:  		/* li R4, 3 */
		/* 82227FC0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82227FC0h case    2:*/		return 0x82227FC4;
		  /* 82227FC4h */ case    3:  		/* b 240 */
		/* 82227FC4h case    3:*/		return 0x822280B4;
		/* 82227FC4h case    3:*/		return 0x82227FC8;
	}
	return 0x82227FC8;
} // Block from 82227FB8h-82227FC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82227FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82227FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82227FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82227FC8);
		  /* 82227FC8h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82227FC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82227FC8h case    0:*/		return 0x82227FCC;
		  /* 82227FCCh */ case    1:  		/* rlwinm R10, R11, 0, 28, 31 */
		/* 82227FCCh case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82227FCCh case    1:*/		return 0x82227FD0;
		  /* 82227FD0h */ case    2:  		/* cmplwi CR6, R10, 15 */
		/* 82227FD0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000F);
		/* 82227FD0h case    2:*/		return 0x82227FD4;
		  /* 82227FD4h */ case    3:  		/* bc 4, CR6_EQ, 4620 */
		/* 82227FD4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227FD4h case    3:*/		return 0x82227FD8;
		  /* 82227FD8h */ case    4:  		/* rlwinm R11, R11, 0, 24, 27 */
		/* 82227FD8h case    4:*/		cpu::op::rlwinm<0,0,24,27>(regs,&regs.R11,regs.R11);
		/* 82227FD8h case    4:*/		return 0x82227FDC;
		  /* 82227FDCh */ case    5:  		/* cmplwi CR6, R11, 240 */
		/* 82227FDCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000F0);
		/* 82227FDCh case    5:*/		return 0x82227FE0;
		  /* 82227FE0h */ case    6:  		/* bc 4, CR6_EQ, 4608 */
		/* 82227FE0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82227FE0h case    6:*/		return 0x82227FE4;
		  /* 82227FE4h */ case    7:  		/* lis R11, -32256 */
		/* 82227FE4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82227FE4h case    7:*/		return 0x82227FE8;
		  /* 82227FE8h */ case    8:  		/* lfd FR13, <#[R1 + 168]> */
		/* 82227FE8h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000A8) );
		/* 82227FE8h case    8:*/		return 0x82227FEC;
		  /* 82227FECh */ case    9:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82227FECh case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82227FECh case    9:*/		return 0x82227FF0;
		  /* 82227FF0h */ case   10:  		/* fcmpu CR6, FR13, FR31 */
		/* 82227FF0h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82227FF0h case   10:*/		return 0x82227FF4;
		  /* 82227FF4h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82227FF4h case   11:*/		if ( regs.CR[6].eq ) { return 0x82228014;  }
		/* 82227FF4h case   11:*/		return 0x82227FF8;
		  /* 82227FF8h */ case   12:  		/* lfd FR0, <#[R1 + 200]> */
		/* 82227FF8h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C8) );
		/* 82227FF8h case   12:*/		return 0x82227FFC;
		  /* 82227FFCh */ case   13:  		/* fcmpu CR6, FR0, FR31 */
		/* 82227FFCh case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82227FFCh case   13:*/		return 0x82228000;
		  /* 82228000h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82228000h case   14:*/		if ( regs.CR[6].eq ) { return 0x82228014;  }
		/* 82228000h case   14:*/		return 0x82228004;
		  /* 82228004h */ case   15:  		/* fmul FR1, FR13, FR0 */
		/* 82228004h case   15:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82228004h case   15:*/		return 0x82228008;
		  /* 82228008h */ case   16:  		/* bl -438648 */
		/* 82228008h case   16:*/		regs.LR = 0x8222800C; return 0x821BCE90;
		/* 82228008h case   16:*/		return 0x8222800C;
		  /* 8222800Ch */ case   17:  		/* fmr FR30, FR1 */
		/* 8222800Ch case   17:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 8222800Ch case   17:*/		return 0x82228010;
		  /* 82228010h */ case   18:  		/* b 8 */
		/* 82228010h case   18:*/		return 0x82228018;
		/* 82228010h case   18:*/		return 0x82228014;
	}
	return 0x82228014;
} // Block from 82227FC8h-82228014h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82228014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228014);
		  /* 82228014h */ case    0:  		/* fmr FR30, FR31 */
		/* 82228014h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR31);
		/* 82228014h case    0:*/		return 0x82228018;
	}
	return 0x82228018;
} // Block from 82228014h-82228018h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82228018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228018);
		  /* 82228018h */ case    0:  		/* lfd FR13, <#[R1 + 160]> */
		/* 82228018h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000A0) );
		/* 82228018h case    0:*/		return 0x8222801C;
		  /* 8222801Ch */ case    1:  		/* fcmpu CR6, FR13, FR31 */
		/* 8222801Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 8222801Ch case    1:*/		return 0x82228020;
		  /* 82228020h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82228020h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222803C;  }
		/* 82228020h case    2:*/		return 0x82228024;
		  /* 82228024h */ case    3:  		/* lfd FR0, <#[R1 + 192]> */
		/* 82228024h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C0) );
		/* 82228024h case    3:*/		return 0x82228028;
		  /* 82228028h */ case    4:  		/* fcmpu CR6, FR0, FR31 */
		/* 82228028h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82228028h case    4:*/		return 0x8222802C;
		  /* 8222802Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8222802Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8222803C;  }
		/* 8222802Ch case    5:*/		return 0x82228030;
		  /* 82228030h */ case    6:  		/* fmul FR1, FR13, FR0 */
		/* 82228030h case    6:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82228030h case    6:*/		return 0x82228034;
		  /* 82228034h */ case    7:  		/* bl -438692 */
		/* 82228034h case    7:*/		regs.LR = 0x82228038; return 0x821BCE90;
		/* 82228034h case    7:*/		return 0x82228038;
		  /* 82228038h */ case    8:  		/* b 8 */
		/* 82228038h case    8:*/		return 0x82228040;
		/* 82228038h case    8:*/		return 0x8222803C;
	}
	return 0x8222803C;
} // Block from 82228018h-8222803Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222803Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222803C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222803C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222803C);
		  /* 8222803Ch */ case    0:  		/* fmr FR1, FR31 */
		/* 8222803Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8222803Ch case    0:*/		return 0x82228040;
	}
	return 0x82228040;
} // Block from 8222803Ch-82228040h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82228040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228040);
		  /* 82228040h */ case    0:  		/* fadd FR1, FR1, FR30 */
		/* 82228040h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 82228040h case    0:*/		return 0x82228044;
		  /* 82228044h */ case    1:  		/* bl -438708 */
		/* 82228044h case    1:*/		regs.LR = 0x82228048; return 0x821BCE90;
		/* 82228044h case    1:*/		return 0x82228048;
		  /* 82228048h */ case    2:  		/* lfd FR0, <#[R1 + 152]> */
		/* 82228048h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000098) );
		/* 82228048h case    2:*/		return 0x8222804C;
		  /* 8222804Ch */ case    3:  		/* fmr FR30, FR1 */
		/* 8222804Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 8222804Ch case    3:*/		return 0x82228050;
		  /* 82228050h */ case    4:  		/* fcmpu CR6, FR0, FR31 */
		/* 82228050h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82228050h case    4:*/		return 0x82228054;
		  /* 82228054h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82228054h case    5:*/		if ( regs.CR[6].eq ) { return 0x82228070;  }
		/* 82228054h case    5:*/		return 0x82228058;
		  /* 82228058h */ case    6:  		/* lfd FR13, <#[R1 + 184]> */
		/* 82228058h case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000B8) );
		/* 82228058h case    6:*/		return 0x8222805C;
		  /* 8222805Ch */ case    7:  		/* fcmpu CR6, FR13, FR31 */
		/* 8222805Ch case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 8222805Ch case    7:*/		return 0x82228060;
		  /* 82228060h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82228060h case    8:*/		if ( regs.CR[6].eq ) { return 0x82228070;  }
		/* 82228060h case    8:*/		return 0x82228064;
		  /* 82228064h */ case    9:  		/* fmul FR1, FR0, FR13 */
		/* 82228064h case    9:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 82228064h case    9:*/		return 0x82228068;
		  /* 82228068h */ case   10:  		/* bl -438744 */
		/* 82228068h case   10:*/		regs.LR = 0x8222806C; return 0x821BCE90;
		/* 82228068h case   10:*/		return 0x8222806C;
		  /* 8222806Ch */ case   11:  		/* b 8 */
		/* 8222806Ch case   11:*/		return 0x82228074;
		/* 8222806Ch case   11:*/		return 0x82228070;
	}
	return 0x82228070;
} // Block from 82228040h-82228070h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82228070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228070);
		  /* 82228070h */ case    0:  		/* fmr FR1, FR31 */
		/* 82228070h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82228070h case    0:*/		return 0x82228074;
	}
	return 0x82228074;
} // Block from 82228070h-82228074h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82228074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228074);
		  /* 82228074h */ case    0:  		/* fadd FR1, FR1, FR30 */
		/* 82228074h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 82228074h case    0:*/		return 0x82228078;
		  /* 82228078h */ case    1:  		/* bl -438760 */
		/* 82228078h case    1:*/		regs.LR = 0x8222807C; return 0x821BCE90;
		/* 82228078h case    1:*/		return 0x8222807C;
		  /* 8222807Ch */ case    2:  		/* lfd FR0, <#[R1 + 144]> */
		/* 8222807Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000090) );
		/* 8222807Ch case    2:*/		return 0x82228080;
		  /* 82228080h */ case    3:  		/* fmr FR30, FR1 */
		/* 82228080h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82228080h case    3:*/		return 0x82228084;
		  /* 82228084h */ case    4:  		/* fcmpu CR6, FR0, FR31 */
		/* 82228084h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82228084h case    4:*/		return 0x82228088;
		  /* 82228088h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82228088h case    5:*/		if ( regs.CR[6].eq ) { return 0x822280A4;  }
		/* 82228088h case    5:*/		return 0x8222808C;
		  /* 8222808Ch */ case    6:  		/* lfd FR13, <#[R1 + 176]> */
		/* 8222808Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000B0) );
		/* 8222808Ch case    6:*/		return 0x82228090;
		  /* 82228090h */ case    7:  		/* fcmpu CR6, FR13, FR31 */
		/* 82228090h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82228090h case    7:*/		return 0x82228094;
		  /* 82228094h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82228094h case    8:*/		if ( regs.CR[6].eq ) { return 0x822280A4;  }
		/* 82228094h case    8:*/		return 0x82228098;
		  /* 82228098h */ case    9:  		/* fmul FR1, FR0, FR13 */
		/* 82228098h case    9:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR13);
		/* 82228098h case    9:*/		return 0x8222809C;
		  /* 8222809Ch */ case   10:  		/* bl -438796 */
		/* 8222809Ch case   10:*/		regs.LR = 0x822280A0; return 0x821BCE90;
		/* 8222809Ch case   10:*/		return 0x822280A0;
		  /* 822280A0h */ case   11:  		/* b 8 */
		/* 822280A0h case   11:*/		return 0x822280A8;
		/* 822280A0h case   11:*/		return 0x822280A4;
	}
	return 0x822280A4;
} // Block from 82228074h-822280A4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822280A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280A4);
		  /* 822280A4h */ case    0:  		/* fmr FR1, FR31 */
		/* 822280A4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822280A4h case    0:*/		return 0x822280A8;
	}
	return 0x822280A8;
} // Block from 822280A4h-822280A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822280A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280A8);
		  /* 822280A8h */ case    0:  		/* fadd FR1, FR1, FR30 */
		/* 822280A8h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 822280A8h case    0:*/		return 0x822280AC;
		  /* 822280ACh */ case    1:  		/* bl -438812 */
		/* 822280ACh case    1:*/		regs.LR = 0x822280B0; return 0x821BCE90;
		/* 822280ACh case    1:*/		return 0x822280B0;
		  /* 822280B0h */ case    2:  		/* li R4, 4 */
		/* 822280B0h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 822280B0h case    2:*/		return 0x822280B4;
	}
	return 0x822280B4;
} // Block from 822280A8h-822280B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822280B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280B4);
		  /* 822280B4h */ case    0:  		/* stfd FR1, <#[R18]> */
		/* 822280B4h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R18 + 0x00000000) );
		/* 822280B4h case    0:*/		return 0x822280B8;
		  /* 822280B8h */ case    1:  		/* addi R3, R1, 112 */
		/* 822280B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 822280B8h case    1:*/		return 0x822280BC;
		  /* 822280BCh */ case    2:  		/* mr R27, R28 */
		/* 822280BCh case    2:*/		regs.R27 = regs.R28;
		/* 822280BCh case    2:*/		return 0x822280C0;
		  /* 822280C0h */ case    3:  		/* bl -387208 */
		/* 822280C0h case    3:*/		regs.LR = 0x822280C4; return 0x821C9838;
		/* 822280C0h case    3:*/		return 0x822280C4;
	}
	return 0x822280C4;
} // Block from 822280B4h-822280C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822280C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280C4);
		  /* 822280C4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 822280C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822280C4h case    0:*/		return 0x822280C8;
		  /* 822280C8h */ case    1:  		/* or R11, R3, R11 */
		/* 822280C8h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 822280C8h case    1:*/		return 0x822280CC;
		  /* 822280CCh */ case    2:  		/* b 3980 */
		/* 822280CCh case    2:*/		return 0x82229058;
		/* 822280CCh case    2:*/		return 0x822280D0;
	}
	return 0x822280D0;
} // Block from 822280C4h-822280D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822280D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280D0);
		  /* 822280D0h */ case    0:  		/* cmplwi CR6, R11, 32 */
		/* 822280D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 822280D0h case    0:*/		return 0x822280D4;
		  /* 822280D4h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 822280D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x822280E4;  }
		/* 822280D4h case    1:*/		return 0x822280D8;
		  /* 822280D8h */ case    2:  		/* cmplwi CR6, R11, 82 */
		/* 822280D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 822280D8h case    2:*/		return 0x822280DC;
		  /* 822280DCh */ case    3:  		/* mr R10, R28 */
		/* 822280DCh case    3:*/		regs.R10 = regs.R28;
		/* 822280DCh case    3:*/		return 0x822280E0;
		  /* 822280E0h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 822280E0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x822280E8;  }
		/* 822280E0h case    4:*/		return 0x822280E4;
	}
	return 0x822280E4;
} // Block from 822280D0h-822280E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822280E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280E4);
		  /* 822280E4h */ case    0:  		/* mr R10, R31 */
		/* 822280E4h case    0:*/		regs.R10 = regs.R31;
		/* 822280E4h case    0:*/		return 0x822280E8;
	}
	return 0x822280E8;
} // Block from 822280E4h-822280E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822280E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822280E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822280E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822280E8);
		  /* 822280E8h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822280E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822280E8h case    0:*/		return 0x822280EC;
		  /* 822280ECh */ case    1:  		/* bc 12, CR0_EQ, 1080 */
		/* 822280ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x82228524;  }
		/* 822280ECh case    1:*/		return 0x822280F0;
		  /* 822280F0h */ case    2:  		/* lwz R9, <#[R1 + 80]> */
		/* 822280F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 822280F0h case    2:*/		return 0x822280F4;
		  /* 822280F4h */ case    3:  		/* rlwinm. R10, R9, 0, 31, 31 */
		/* 822280F4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R9);
		/* 822280F4h case    3:*/		return 0x822280F8;
		  /* 822280F8h */ case    4:  		/* bc 12, CR0_EQ, 972 */
		/* 822280F8h case    4:*/		if ( regs.CR[0].eq ) { return 0x822284C4;  }
		/* 822280F8h case    4:*/		return 0x822280FC;
		  /* 822280FCh */ case    5:  		/* lwz R10, <#[R1 + 112]> */
		/* 822280FCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 822280FCh case    5:*/		return 0x82228100;
		  /* 82228100h */ case    6:  		/* lfd FR1, <#[R1 + 144]> */
		/* 82228100h case    6:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000090) );
		/* 82228100h case    6:*/		return 0x82228104;
		  /* 82228104h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 82228104h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228104h case    7:*/		return 0x82228108;
		  /* 82228108h */ case    8:  		/* fmr FR31, FR1 */
		/* 82228108h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82228108h case    8:*/		return 0x8222810C;
		  /* 8222810Ch */ case    9:  		/* rlwinm R3, R10, 0, 30, 31 */
		/* 8222810Ch case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R10);
		/* 8222810Ch case    9:*/		return 0x82228110;
		  /* 82228110h */ case   10:  		/* mr R27, R28 */
		/* 82228110h case   10:*/		regs.R27 = regs.R28;
		/* 82228110h case   10:*/		return 0x82228114;
		  /* 82228114h */ case   11:  		/* or R11, R11, R3 */
		/* 82228114h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82228114h case   11:*/		return 0x82228118;
		  /* 82228118h */ case   12:  		/* stw R11, <#[R30]> */
		/* 82228118h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228118h case   12:*/		return 0x8222811C;
		  /* 8222811Ch */ case   13:  		/* lwz R11, <#[R14 + 8]> */
		/* 8222811Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 8222811Ch case   13:*/		return 0x82228120;
		  /* 82228120h */ case   14:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82228120h case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82228120h case   14:*/		return 0x82228124;
		  /* 82228124h */ case   15:  		/* addi R11, R11, -37 */
		/* 82228124h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFDB);
		/* 82228124h case   15:*/		return 0x82228128;
		  /* 82228128h */ case   16:  		/* cmplwi CR6, R11, 44 */
		/* 82228128h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 82228128h case   16:*/		return 0x8222812C;
		  /* 8222812Ch */ case   17:  		/* bc 12, CR6_GT, 4108 */
		/* 8222812Ch case   17:*/		if ( regs.CR[6].gt ) { return 0x82229138;  }
		/* 8222812Ch case   17:*/		return 0x82228130;
		  /* 82228130h */ case   18:  		/* lis R12, -32252 */
		/* 82228130h case   18:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82228130h case   18:*/		return 0x82228134;
		  /* 82228134h */ case   19:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 82228134h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 82228134h case   19:*/		return 0x82228138;
		  /* 82228138h */ case   20:  		/* addi R12, R12, -488 */
		/* 82228138h case   20:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFE18);
		/* 82228138h case   20:*/		return 0x8222813C;
		  /* 8222813Ch */ case   21:  		/* lhzx R0, <#[R12 + R0]> */
		/* 8222813Ch case   21:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 8222813Ch case   21:*/		return 0x82228140;
		  /* 82228140h */ case   22:  		/* lis R12, -32221 */
		/* 82228140h case   22:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8223);
		/* 82228140h case   22:*/		return 0x82228144;
		  /* 82228144h */ case   23:  		/* addi R12, R12, -32424 */
		/* 82228144h case   23:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFF8158);
		/* 82228144h case   23:*/		return 0x82228148;
		  /* 82228148h */ case   24:  		/* ori R0, R0, 0 */
		/* 82228148h case   24:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82228148h case   24:*/		return 0x8222814C;
		  /* 8222814Ch */ case   25:  		/* add R12, R12, R0 */
		/* 8222814Ch case   25:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 8222814Ch case   25:*/		return 0x82228150;
		  /* 82228150h */ case   26:  		/* mtspr CTR, R12 */
		/* 82228150h case   26:*/		regs.CTR = regs.R12;
		/* 82228150h case   26:*/		return 0x82228154;
		  /* 82228154h */ case   27:  		/* bcctr 20, CR0_LT */
		/* 82228154h case   27:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82228154h case   27:*/		return 0x82228158;
		  /* 82228158h */ case   28:  		/* lis R11, -32256 */
		/* 82228158h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228158h case   28:*/		return 0x8222815C;
		  /* 8222815Ch */ case   29:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 8222815Ch case   29:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 8222815Ch case   29:*/		return 0x82228160;
		  /* 82228160h */ case   30:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228160h case   30:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228160h case   30:*/		return 0x82228164;
		  /* 82228164h */ case   31:  		/* bc 12, CR6_EQ, 552 */
		/* 82228164h case   31:*/		if ( regs.CR[6].eq ) { return 0x8222838C;  }
		/* 82228164h case   31:*/		return 0x82228168;
		  /* 82228168h */ case   32:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228168h case   32:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228168h case   32:*/		return 0x8222816C;
		  /* 8222816Ch */ case   33:  		/* bc 4, CR6_LT, 12 */
		/* 8222816Ch case   33:*/		if ( !regs.CR[6].lt ) { return 0x82228178;  }
		/* 8222816Ch case   33:*/		return 0x82228170;
		  /* 82228170h */ case   34:  		/* lwz R11, <#[R30]> */
		/* 82228170h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228170h case   34:*/		return 0x82228174;
		  /* 82228174h */ case   35:  		/* stw R11, <#[R30]> */
		/* 82228174h case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228174h case   35:*/		return 0x82228178;
	}
	return 0x82228178;
} // Block from 822280E8h-82228178h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82228178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228178);
		  /* 82228178h */ case    0:  		/* bl -30392 */
		/* 82228178h case    0:*/		regs.LR = 0x8222817C; return 0x82220AC0;
		/* 82228178h case    0:*/		return 0x8222817C;
		  /* 8222817Ch */ case    1:  		/* fmr FR31, FR1 */
		/* 8222817Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8222817Ch case    1:*/		return 0x82228180;
		  /* 82228180h */ case    2:  		/* b 828 */
		/* 82228180h case    2:*/		return 0x822284BC;
		/* 82228180h case    2:*/		return 0x82228184;
		  /* 82228184h */ case    3:  		/* lis R11, -32256 */
		/* 82228184h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228184h case    3:*/		return 0x82228188;
		  /* 82228188h */ case    4:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82228188h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82228188h case    4:*/		return 0x8222818C;
		  /* 8222818Ch */ case    5:  		/* lis R11, -32256 */
		/* 8222818Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222818Ch case    5:*/		return 0x82228190;
		  /* 82228190h */ case    6:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228190h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228190h case    6:*/		return 0x82228194;
		  /* 82228194h */ case    7:  		/* bc 12, CR6_EQ, 656 */
		/* 82228194h case    7:*/		if ( regs.CR[6].eq ) { return 0x82228424;  }
		/* 82228194h case    7:*/		return 0x82228198;
		  /* 82228198h */ case    8:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82228198h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82228198h case    8:*/		return 0x8222819C;
		  /* 8222819Ch */ case    9:  		/* fcmpu CR6, FR1, FR0 */
		/* 8222819Ch case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 8222819Ch case    9:*/		return 0x822281A0;
		  /* 822281A0h */ case   10:  		/* bc 12, CR6_GT, 12 */
		/* 822281A0h case   10:*/		if ( regs.CR[6].gt ) { return 0x822281AC;  }
		/* 822281A0h case   10:*/		return 0x822281A4;
		  /* 822281A4h */ case   11:  		/* lwz R11, <#[R30]> */
		/* 822281A4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822281A4h case   11:*/		return 0x822281A8;
		  /* 822281A8h */ case   12:  		/* stw R11, <#[R30]> */
		/* 822281A8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822281A8h case   12:*/		return 0x822281AC;
	}
	return 0x822281AC;
} // Block from 82228178h-822281ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 822281ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822281AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822281AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822281AC);
		  /* 822281ACh */ case    0:  		/* bl -30308 */
		/* 822281ACh case    0:*/		regs.LR = 0x822281B0; return 0x82220B48;
		/* 822281ACh case    0:*/		return 0x822281B0;
		  /* 822281B0h */ case    1:  		/* fmr FR31, FR1 */
		/* 822281B0h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 822281B0h case    1:*/		return 0x822281B4;
		  /* 822281B4h */ case    2:  		/* bl -1638780 */
		/* 822281B4h case    2:*/		regs.LR = 0x822281B8; return 0x82098038;
		/* 822281B4h case    2:*/		return 0x822281B8;
		  /* 822281B8h */ case    3:  		/* cmpwi CR6, R3, 4 */
		/* 822281B8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 822281B8h case    3:*/		return 0x822281BC;
		  /* 822281BCh */ case    4:  		/* bc 4, CR6_EQ, 768 */
		/* 822281BCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x822284BC;  }
		/* 822281BCh case    4:*/		return 0x822281C0;
		  /* 822281C0h */ case    5:  		/* lis R11, -32252 */
		/* 822281C0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 822281C0h case    5:*/		return 0x822281C4;
		  /* 822281C4h */ case    6:  		/* lfd FR31, <#[R11 - 15792]> */
		/* 822281C4h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0xFFFFC250) );
		/* 822281C4h case    6:*/		return 0x822281C8;
		  /* 822281C8h */ case    7:  		/* lwz R10, <#[R30]> */
		/* 822281C8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822281C8h case    7:*/		return 0x822281CC;
		  /* 822281CCh */ case    8:  		/* stw R10, <#[R30]> */
		/* 822281CCh case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822281CCh case    8:*/		return 0x822281D0;
		  /* 822281D0h */ case    9:  		/* b 748 */
		/* 822281D0h case    9:*/		return 0x822284BC;
		/* 822281D0h case    9:*/		return 0x822281D4;
		  /* 822281D4h */ case   10:  		/* lis R11, -32256 */
		/* 822281D4h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822281D4h case   10:*/		return 0x822281D8;
		  /* 822281D8h */ case   11:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 822281D8h case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 822281D8h case   11:*/		return 0x822281DC;
		  /* 822281DCh */ case   12:  		/* lis R11, -32256 */
		/* 822281DCh case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822281DCh case   12:*/		return 0x822281E0;
		  /* 822281E0h */ case   13:  		/* fcmpu CR6, FR1, FR0 */
		/* 822281E0h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822281E0h case   13:*/		return 0x822281E4;
		  /* 822281E4h */ case   14:  		/* bc 12, CR6_EQ, 576 */
		/* 822281E4h case   14:*/		if ( regs.CR[6].eq ) { return 0x82228424;  }
		/* 822281E4h case   14:*/		return 0x822281E8;
		  /* 822281E8h */ case   15:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 822281E8h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 822281E8h case   15:*/		return 0x822281EC;
		  /* 822281ECh */ case   16:  		/* fcmpu CR6, FR1, FR0 */
		/* 822281ECh case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822281ECh case   16:*/		return 0x822281F0;
		  /* 822281F0h */ case   17:  		/* bc 12, CR6_GT, 12 */
		/* 822281F0h case   17:*/		if ( regs.CR[6].gt ) { return 0x822281FC;  }
		/* 822281F0h case   17:*/		return 0x822281F4;
		  /* 822281F4h */ case   18:  		/* lwz R11, <#[R30]> */
		/* 822281F4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822281F4h case   18:*/		return 0x822281F8;
		  /* 822281F8h */ case   19:  		/* stw R11, <#[R30]> */
		/* 822281F8h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822281F8h case   19:*/		return 0x822281FC;
	}
	return 0x822281FC;
} // Block from 822281ACh-822281FCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 822281FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822281FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822281FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822281FC);
		  /* 822281FCh */ case    0:  		/* bl -30388 */
		/* 822281FCh case    0:*/		regs.LR = 0x82228200; return 0x82220B48;
		/* 822281FCh case    0:*/		return 0x82228200;
		  /* 82228200h */ case    1:  		/* b -132 */
		/* 82228200h case    1:*/		return 0x8222817C;
		/* 82228200h case    1:*/		return 0x82228204;
		  /* 82228204h */ case    2:  		/* lis R11, -32256 */
		/* 82228204h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228204h case    2:*/		return 0x82228208;
		  /* 82228208h */ case    3:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82228208h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82228208h case    3:*/		return 0x8222820C;
		  /* 8222820Ch */ case    4:  		/* fcmpu CR6, FR1, FR0 */
		/* 8222820Ch case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 8222820Ch case    4:*/		return 0x82228210;
		  /* 82228210h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82228210h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8222821C;  }
		/* 82228210h case    5:*/		return 0x82228214;
		  /* 82228214h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 82228214h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228214h case    6:*/		return 0x82228218;
		  /* 82228218h */ case    7:  		/* stw R11, <#[R30]> */
		/* 82228218h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228218h case    7:*/		return 0x8222821C;
	}
	return 0x8222821C;
} // Block from 822281FCh-8222821Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222821Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222821C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222821C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222821C);
		  /* 8222821Ch */ case    0:  		/* bl -29916 */
		/* 8222821Ch case    0:*/		regs.LR = 0x82228220; return 0x82220D40;
		/* 8222821Ch case    0:*/		return 0x82228220;
		  /* 82228220h */ case    1:  		/* fmr FR31, FR1 */
		/* 82228220h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82228220h case    1:*/		return 0x82228224;
		  /* 82228224h */ case    2:  		/* bl -1638892 */
		/* 82228224h case    2:*/		regs.LR = 0x82228228; return 0x82098038;
		/* 82228224h case    2:*/		return 0x82228228;
		  /* 82228228h */ case    3:  		/* cmpwi CR6, R3, 4 */
		/* 82228228h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 82228228h case    3:*/		return 0x8222822C;
		  /* 8222822Ch */ case    4:  		/* bc 12, CR6_EQ, -108 */
		/* 8222822Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x822281C0;  }
		/* 8222822Ch case    4:*/		return 0x82228230;
		  /* 82228230h */ case    5:  		/* cmpwi CR6, R3, 512 */
		/* 82228230h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000200);
		/* 82228230h case    5:*/		return 0x82228234;
		  /* 82228234h */ case    6:  		/* bc 4, CR6_EQ, 648 */
		/* 82228234h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822284BC;  }
		/* 82228234h case    6:*/		return 0x82228238;
		  /* 82228238h */ case    7:  		/* lis R11, -32252 */
		/* 82228238h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82228238h case    7:*/		return 0x8222823C;
		  /* 8222823Ch */ case    8:  		/* lfd FR31, <#[R11 - 15800]> */
		/* 8222823Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0xFFFFC248) );
		/* 8222823Ch case    8:*/		return 0x82228240;
		  /* 82228240h */ case    9:  		/* b -120 */
		/* 82228240h case    9:*/		return 0x822281C8;
		/* 82228240h case    9:*/		return 0x82228244;
		  /* 82228244h */ case   10:  		/* lis R11, -32256 */
		/* 82228244h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228244h case   10:*/		return 0x82228248;
		  /* 82228248h */ case   11:  		/* lfd FR30, <#[R11 + 1808]> */
		/* 82228248h case   11:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000710) );
		/* 82228248h case   11:*/		return 0x8222824C;
		  /* 8222824Ch */ case   12:  		/* fcmpu CR6, FR1, FR30 */
		/* 8222824Ch case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR30);
		/* 8222824Ch case   12:*/		return 0x82228250;
		  /* 82228250h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 82228250h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8222825C;  }
		/* 82228250h case   13:*/		return 0x82228254;
		  /* 82228254h */ case   14:  		/* lwz R11, <#[R30]> */
		/* 82228254h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228254h case   14:*/		return 0x82228258;
		  /* 82228258h */ case   15:  		/* stw R11, <#[R30]> */
		/* 82228258h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228258h case   15:*/		return 0x8222825C;
	}
	return 0x8222825C;
} // Block from 8222821Ch-8222825Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8222825Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222825C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222825C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222825C);
		  /* 8222825Ch */ case    0:  		/* bl -29980 */
		/* 8222825Ch case    0:*/		regs.LR = 0x82228260; return 0x82220D40;
		/* 8222825Ch case    0:*/		return 0x82228260;
		  /* 82228260h */ case    1:  		/* fmr FR31, FR1 */
		/* 82228260h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82228260h case    1:*/		return 0x82228264;
		  /* 82228264h */ case    2:  		/* bl -1638956 */
		/* 82228264h case    2:*/		regs.LR = 0x82228268; return 0x82098038;
		/* 82228264h case    2:*/		return 0x82228268;
		  /* 82228268h */ case    3:  		/* cmpwi CR6, R3, 4 */
		/* 82228268h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 82228268h case    3:*/		return 0x8222826C;
		  /* 8222826Ch */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 8222826Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82228280;  }
		/* 8222826Ch case    4:*/		return 0x82228270;
		  /* 82228270h */ case    5:  		/* cmpwi CR6, R3, 512 */
		/* 82228270h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000200);
		/* 82228270h case    5:*/		return 0x82228274;
		  /* 82228274h */ case    6:  		/* bc 4, CR6_EQ, 584 */
		/* 82228274h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822284BC;  }
		/* 82228274h case    6:*/		return 0x82228278;
		  /* 82228278h */ case    7:  		/* fmr FR31, FR30 */
		/* 82228278h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR30);
		/* 82228278h case    7:*/		return 0x8222827C;
		  /* 8222827Ch */ case    8:  		/* b 576 */
		/* 8222827Ch case    8:*/		return 0x822284BC;
		/* 8222827Ch case    8:*/		return 0x82228280;
	}
	return 0x82228280;
} // Block from 8222825Ch-82228280h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82228280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228280);
		  /* 82228280h */ case    0:  		/* lis R10, -32768 */
		/* 82228280h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82228280h case    0:*/		return 0x82228284;
		  /* 82228284h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82228284h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228284h case    1:*/		return 0x82228288;
		  /* 82228288h */ case    2:  		/* stw R10, <#[R1 + 104]> */
		/* 82228288h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82228288h case    2:*/		return 0x8222828C;
		  /* 8222828Ch */ case    3:  		/* lfs FR31, <#[R1 + 104]> */
		/* 8222828Ch case    3:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 8222828Ch case    3:*/		return 0x82228290;
		  /* 82228290h */ case    4:  		/* b 552 */
		/* 82228290h case    4:*/		return 0x822284B8;
		/* 82228290h case    4:*/		return 0x82228294;
		  /* 82228294h */ case    5:  		/* lis R10, -32256 */
		/* 82228294h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82228294h case    5:*/		return 0x82228298;
		  /* 82228298h */ case    6:  		/* lwz R11, <#[R14 + 20]> */
		/* 82228298h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000014) );
		/* 82228298h case    6:*/		return 0x8222829C;
		  /* 8222829Ch */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8222829Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8222829Ch case    7:*/		return 0x822282A0;
		  /* 822282A0h */ case    8:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 822282A0h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 822282A0h case    8:*/		return 0x822282A4;
		  /* 822282A4h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 822282A4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x822282B0;  }
		/* 822282A4h case    9:*/		return 0x822282A8;
		  /* 822282A8h */ case   10:  		/* fcmpu CR6, FR1, FR0 */
		/* 822282A8h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822282A8h case   10:*/		return 0x822282AC;
		  /* 822282ACh */ case   11:  		/* bc 12, CR6_EQ, 528 */
		/* 822282ACh case   11:*/		if ( regs.CR[6].eq ) { return 0x822284BC;  }
		/* 822282ACh case   11:*/		return 0x822282B0;
	}
	return 0x822282B0;
} // Block from 82228280h-822282B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822282B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822282B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822282B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822282B0);
		  /* 822282B0h */ case    0:  		/* fcmpu CR6, FR1, FR0 */
		/* 822282B0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822282B0h case    0:*/		return 0x822282B4;
		  /* 822282B4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 822282B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822282C0;  }
		/* 822282B4h case    1:*/		return 0x822282B8;
		  /* 822282B8h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 822282B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822282B8h case    2:*/		return 0x822282BC;
		  /* 822282BCh */ case    3:  		/* stw R11, <#[R30]> */
		/* 822282BCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822282BCh case    3:*/		return 0x822282C0;
	}
	return 0x822282C0;
} // Block from 822282B0h-822282C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822282C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822282C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822282C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822282C0);
		  /* 822282C0h */ case    0:  		/* bl -30080 */
		/* 822282C0h case    0:*/		regs.LR = 0x822282C4; return 0x82220D40;
		/* 822282C0h case    0:*/		return 0x822282C4;
		  /* 822282C4h */ case    1:  		/* b -328 */
		/* 822282C4h case    1:*/		return 0x8222817C;
		/* 822282C4h case    1:*/		return 0x822282C8;
		  /* 822282C8h */ case    2:  		/* lis R11, -32256 */
		/* 822282C8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822282C8h case    2:*/		return 0x822282CC;
		  /* 822282CCh */ case    3:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 822282CCh case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 822282CCh case    3:*/		return 0x822282D0;
		  /* 822282D0h */ case    4:  		/* fcmpu CR6, FR1, FR0 */
		/* 822282D0h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822282D0h case    4:*/		return 0x822282D4;
		  /* 822282D4h */ case    5:  		/* bc 12, CR6_GT, 12 */
		/* 822282D4h case    5:*/		if ( regs.CR[6].gt ) { return 0x822282E0;  }
		/* 822282D4h case    5:*/		return 0x822282D8;
		  /* 822282D8h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 822282D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822282D8h case    6:*/		return 0x822282DC;
		  /* 822282DCh */ case    7:  		/* stw R11, <#[R30]> */
		/* 822282DCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822282DCh case    7:*/		return 0x822282E0;
	}
	return 0x822282E0;
} // Block from 822282C0h-822282E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822282E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822282E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822282E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822282E0);
		  /* 822282E0h */ case    0:  		/* bl -30320 */
		/* 822282E0h case    0:*/		regs.LR = 0x822282E4; return 0x82220C70;
		/* 822282E0h case    0:*/		return 0x822282E4;
		  /* 822282E4h */ case    1:  		/* b -196 */
		/* 822282E4h case    1:*/		return 0x82228220;
		/* 822282E4h case    1:*/		return 0x822282E8;
		  /* 822282E8h */ case    2:  		/* lis R11, -32256 */
		/* 822282E8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822282E8h case    2:*/		return 0x822282EC;
		  /* 822282ECh */ case    3:  		/* lfd FR30, <#[R11 + 1808]> */
		/* 822282ECh case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000710) );
		/* 822282ECh case    3:*/		return 0x822282F0;
		  /* 822282F0h */ case    4:  		/* fcmpu CR6, FR1, FR30 */
		/* 822282F0h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR30);
		/* 822282F0h case    4:*/		return 0x822282F4;
		  /* 822282F4h */ case    5:  		/* bc 12, CR6_GT, 12 */
		/* 822282F4h case    5:*/		if ( regs.CR[6].gt ) { return 0x82228300;  }
		/* 822282F4h case    5:*/		return 0x822282F8;
		  /* 822282F8h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 822282F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822282F8h case    6:*/		return 0x822282FC;
		  /* 822282FCh */ case    7:  		/* stw R11, <#[R30]> */
		/* 822282FCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822282FCh case    7:*/		return 0x82228300;
	}
	return 0x82228300;
} // Block from 822282E0h-82228300h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228300);
		  /* 82228300h */ case    0:  		/* bl -30352 */
		/* 82228300h case    0:*/		regs.LR = 0x82228304; return 0x82220C70;
		/* 82228300h case    0:*/		return 0x82228304;
		  /* 82228304h */ case    1:  		/* fmr FR31, FR1 */
		/* 82228304h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82228304h case    1:*/		return 0x82228308;
		  /* 82228308h */ case    2:  		/* bl -1639120 */
		/* 82228308h case    2:*/		regs.LR = 0x8222830C; return 0x82098038;
		/* 82228308h case    2:*/		return 0x8222830C;
		  /* 8222830Ch */ case    3:  		/* cmpwi CR6, R3, 4 */
		/* 8222830Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 8222830Ch case    3:*/		return 0x82228310;
		  /* 82228310h */ case    4:  		/* bc 4, CR6_EQ, -160 */
		/* 82228310h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82228270;  }
		/* 82228310h case    4:*/		return 0x82228314;
		  /* 82228314h */ case    5:  		/* lwz R10, <#[R30]> */
		/* 82228314h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82228314h case    5:*/		return 0x82228318;
		  /* 82228318h */ case    6:  		/* lis R11, -32768 */
		/* 82228318h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 82228318h case    6:*/		return 0x8222831C;
		  /* 8222831Ch */ case    7:  		/* stw R11, <#[R1 + 104]> */
		/* 8222831Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8222831Ch case    7:*/		return 0x82228320;
		  /* 82228320h */ case    8:  		/* lfs FR31, <#[R1 + 104]> */
		/* 82228320h case    8:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000068) );
		/* 82228320h case    8:*/		return 0x82228324;
		  /* 82228324h */ case    9:  		/* stw R10, <#[R30]> */
		/* 82228324h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82228324h case    9:*/		return 0x82228328;
		  /* 82228328h */ case   10:  		/* b 404 */
		/* 82228328h case   10:*/		return 0x822284BC;
		/* 82228328h case   10:*/		return 0x8222832C;
		  /* 8222832Ch */ case   11:  		/* lis R11, -32256 */
		/* 8222832Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222832Ch case   11:*/		return 0x82228330;
		  /* 82228330h */ case   12:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82228330h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82228330h case   12:*/		return 0x82228334;
		  /* 82228334h */ case   13:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228334h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228334h case   13:*/		return 0x82228338;
		  /* 82228338h */ case   14:  		/* bc 12, CR6_GT, 12 */
		/* 82228338h case   14:*/		if ( regs.CR[6].gt ) { return 0x82228344;  }
		/* 82228338h case   14:*/		return 0x8222833C;
		  /* 8222833Ch */ case   15:  		/* lwz R11, <#[R30]> */
		/* 8222833Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222833Ch case   15:*/		return 0x82228340;
		  /* 82228340h */ case   16:  		/* stw R11, <#[R30]> */
		/* 82228340h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228340h case   16:*/		return 0x82228344;
	}
	return 0x82228344;
} // Block from 82228300h-82228344h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82228344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228344);
		  /* 82228344h */ case    0:  		/* bl -30420 */
		/* 82228344h case    0:*/		regs.LR = 0x82228348; return 0x82220C70;
		/* 82228344h case    0:*/		return 0x82228348;
		  /* 82228348h */ case    1:  		/* b -460 */
		/* 82228348h case    1:*/		return 0x8222817C;
		/* 82228348h case    1:*/		return 0x8222834C;
		  /* 8222834Ch */ case    2:  		/* lis R11, -32256 */
		/* 8222834Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222834Ch case    2:*/		return 0x82228350;
		  /* 82228350h */ case    3:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82228350h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82228350h case    3:*/		return 0x82228354;
		  /* 82228354h */ case    4:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228354h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228354h case    4:*/		return 0x82228358;
		  /* 82228358h */ case    5:  		/* bc 12, CR6_GT, 12 */
		/* 82228358h case    5:*/		if ( regs.CR[6].gt ) { return 0x82228364;  }
		/* 82228358h case    5:*/		return 0x8222835C;
		  /* 8222835Ch */ case    6:  		/* lwz R11, <#[R30]> */
		/* 8222835Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222835Ch case    6:*/		return 0x82228360;
		  /* 82228360h */ case    7:  		/* stw R11, <#[R30]> */
		/* 82228360h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228360h case    7:*/		return 0x82228364;
	}
	return 0x82228364;
} // Block from 82228344h-82228364h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228364);
		  /* 82228364h */ case    0:  		/* bl -30596 */
		/* 82228364h case    0:*/		regs.LR = 0x82228368; return 0x82220BE0;
		/* 82228364h case    0:*/		return 0x82228368;
		  /* 82228368h */ case    1:  		/* b -492 */
		/* 82228368h case    1:*/		return 0x8222817C;
		/* 82228368h case    1:*/		return 0x8222836C;
		  /* 8222836Ch */ case    2:  		/* bl -262052 */
		/* 8222836Ch case    2:*/		regs.LR = 0x82228370; return 0x821E83C8;
		/* 8222836Ch case    2:*/		return 0x82228370;
		  /* 82228370h */ case    3:  		/* b -500 */
		/* 82228370h case    3:*/		return 0x8222817C;
		/* 82228370h case    3:*/		return 0x82228374;
		  /* 82228374h */ case    4:  		/* bl -261900 */
		/* 82228374h case    4:*/		regs.LR = 0x82228378; return 0x821E8468;
		/* 82228374h case    4:*/		return 0x82228378;
		  /* 82228378h */ case    5:  		/* b -508 */
		/* 82228378h case    5:*/		return 0x8222817C;
		/* 82228378h case    5:*/		return 0x8222837C;
		  /* 8222837Ch */ case    6:  		/* lis R11, -32256 */
		/* 8222837Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222837Ch case    6:*/		return 0x82228380;
		  /* 82228380h */ case    7:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82228380h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82228380h case    7:*/		return 0x82228384;
		  /* 82228384h */ case    8:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228384h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228384h case    8:*/		return 0x82228388;
		  /* 82228388h */ case    9:  		/* bc 12, CR6_EQ, 308 */
		/* 82228388h case    9:*/		if ( regs.CR[6].eq ) { return 0x822284BC;  }
		/* 82228388h case    9:*/		return 0x8222838C;
	}
	return 0x8222838C;
} // Block from 82228364h-8222838Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222838Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222838C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222838C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222838C);
		  /* 8222838Ch */ case    0:  		/* lis R11, -32256 */
		/* 8222838Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222838Ch case    0:*/		return 0x82228390;
		  /* 82228390h */ case    1:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 82228390h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 82228390h case    1:*/		return 0x82228394;
		  /* 82228394h */ case    2:  		/* b 296 */
		/* 82228394h case    2:*/		return 0x822284BC;
		/* 82228394h case    2:*/		return 0x82228398;
		  /* 82228398h */ case    3:  		/* lis R11, -32256 */
		/* 82228398h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228398h case    3:*/		return 0x8222839C;
		  /* 8222839Ch */ case    4:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 8222839Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 8222839Ch case    4:*/		return 0x822283A0;
		  /* 822283A0h */ case    5:  		/* fcmpu CR6, FR1, FR31 */
		/* 822283A0h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 822283A0h case    5:*/		return 0x822283A4;
		  /* 822283A4h */ case    6:  		/* bc 4, CR6_EQ, 280 */
		/* 822283A4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822284BC;  }
		/* 822283A4h case    6:*/		return 0x822283A8;
		  /* 822283A8h */ case    7:  		/* b -28 */
		/* 822283A8h case    7:*/		return 0x8222838C;
		/* 822283A8h case    7:*/		return 0x822283AC;
		  /* 822283ACh */ case    8:  		/* lis R11, -32256 */
		/* 822283ACh case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822283ACh case    8:*/		return 0x822283B0;
		  /* 822283B0h */ case    9:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 822283B0h case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 822283B0h case    9:*/		return 0x822283B4;
		  /* 822283B4h */ case   10:  		/* fcmpu CR6, FR1, FR31 */
		/* 822283B4h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 822283B4h case   10:*/		return 0x822283B8;
		  /* 822283B8h */ case   11:  		/* bc 12, CR6_GT, 260 */
		/* 822283B8h case   11:*/		if ( regs.CR[6].gt ) { return 0x822284BC;  }
		/* 822283B8h case   11:*/		return 0x822283BC;
		  /* 822283BCh */ case   12:  		/* b -48 */
		/* 822283BCh case   12:*/		return 0x8222838C;
		/* 822283BCh case   12:*/		return 0x822283C0;
		  /* 822283C0h */ case   13:  		/* lis R11, -32256 */
		/* 822283C0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822283C0h case   13:*/		return 0x822283C4;
		  /* 822283C4h */ case   14:  		/* lis R10, -32256 */
		/* 822283C4h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 822283C4h case   14:*/		return 0x822283C8;
		  /* 822283C8h */ case   15:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 822283C8h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 822283C8h case   15:*/		return 0x822283CC;
		  /* 822283CCh */ case   16:  		/* lfd FR13, <#[R10 + 1848]> */
		/* 822283CCh case   16:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000738) );
		/* 822283CCh case   16:*/		return 0x822283D0;
		  /* 822283D0h */ case   17:  		/* fsel FR31, FR1, FR0, FR13 */
		/* 822283D0h case   17:*/		cpu::op::fsel<0>(regs,&regs.FR31,regs.FR1,regs.FR0,regs.FR13);
		/* 822283D0h case   17:*/		return 0x822283D4;
		  /* 822283D4h */ case   18:  		/* b 232 */
		/* 822283D4h case   18:*/		return 0x822284BC;
		/* 822283D4h case   18:*/		return 0x822283D8;
		  /* 822283D8h */ case   19:  		/* lis R11, -32256 */
		/* 822283D8h case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822283D8h case   19:*/		return 0x822283DC;
		  /* 822283DCh */ case   20:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 822283DCh case   20:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 822283DCh case   20:*/		return 0x822283E0;
		  /* 822283E0h */ case   21:  		/* fcmpu CR6, FR1, FR31 */
		/* 822283E0h case   21:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 822283E0h case   21:*/		return 0x822283E4;
		  /* 822283E4h */ case   22:  		/* b -92 */
		/* 822283E4h case   22:*/		return 0x82228388;
		/* 822283E4h case   22:*/		return 0x822283E8;
		  /* 822283E8h */ case   23:  		/* lis R11, -32256 */
		/* 822283E8h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822283E8h case   23:*/		return 0x822283EC;
		  /* 822283ECh */ case   24:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 822283ECh case   24:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 822283ECh case   24:*/		return 0x822283F0;
		  /* 822283F0h */ case   25:  		/* fcmpu CR6, FR1, FR31 */
		/* 822283F0h case   25:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 822283F0h case   25:*/		return 0x822283F4;
		  /* 822283F4h */ case   26:  		/* bc 4, CR6_GT, 200 */
		/* 822283F4h case   26:*/		if ( !regs.CR[6].gt ) { return 0x822284BC;  }
		/* 822283F4h case   26:*/		return 0x822283F8;
		  /* 822283F8h */ case   27:  		/* b -108 */
		/* 822283F8h case   27:*/		return 0x8222838C;
		/* 822283F8h case   27:*/		return 0x822283FC;
		  /* 822283FCh */ case   28:  		/* lis R11, -32256 */
		/* 822283FCh case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822283FCh case   28:*/		return 0x82228400;
		  /* 82228400h */ case   29:  		/* lis R10, -32256 */
		/* 82228400h case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82228400h case   29:*/		return 0x82228404;
		  /* 82228404h */ case   30:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82228404h case   30:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82228404h case   30:*/		return 0x82228408;
		  /* 82228408h */ case   31:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 82228408h case   31:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 82228408h case   31:*/		return 0x8222840C;
		  /* 8222840Ch */ case   32:  		/* b -60 */
		/* 8222840Ch case   32:*/		return 0x822283D0;
		/* 8222840Ch case   32:*/		return 0x82228410;
		  /* 82228410h */ case   33:  		/* lis R11, -32256 */
		/* 82228410h case   33:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228410h case   33:*/		return 0x82228414;
		  /* 82228414h */ case   34:  		/* lfd FR31, <#[R11 + 1848]> */
		/* 82228414h case   34:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000738) );
		/* 82228414h case   34:*/		return 0x82228418;
		  /* 82228418h */ case   35:  		/* fcmpu CR6, FR1, FR31 */
		/* 82228418h case   35:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82228418h case   35:*/		return 0x8222841C;
		  /* 8222841Ch */ case   36:  		/* bc 12, CR6_EQ, 160 */
		/* 8222841Ch case   36:*/		if ( regs.CR[6].eq ) { return 0x822284BC;  }
		/* 8222841Ch case   36:*/		return 0x82228420;
		  /* 82228420h */ case   37:  		/* lis R11, -32256 */
		/* 82228420h case   37:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228420h case   37:*/		return 0x82228424;
	}
	return 0x82228424;
} // Block from 8222838Ch-82228424h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82228424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228424);
		  /* 82228424h */ case    0:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82228424h case    0:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82228424h case    0:*/		return 0x82228428;
		  /* 82228428h */ case    1:  		/* b 148 */
		/* 82228428h case    1:*/		return 0x822284BC;
		/* 82228428h case    1:*/		return 0x8222842C;
		  /* 8222842Ch */ case    2:  		/* rlwinm. R11, R9, 31, 31, 31 */
		/* 8222842Ch case    2:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R9);
		/* 8222842Ch case    2:*/		return 0x82228430;
		  /* 82228430h */ case    3:  		/* bc 12, CR0_EQ, 140 */
		/* 82228430h case    3:*/		if ( regs.CR[0].eq ) { return 0x822284BC;  }
		/* 82228430h case    3:*/		return 0x82228434;
		  /* 82228434h */ case    4:  		/* lis R11, -32256 */
		/* 82228434h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228434h case    4:*/		return 0x82228438;
		  /* 82228438h */ case    5:  		/* lfd FR30, <#[R11 + 4736]> */
		/* 82228438h case    5:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00001280) );
		/* 82228438h case    5:*/		return 0x8222843C;
		  /* 8222843Ch */ case    6:  		/* fadd FR1, FR1, FR30 */
		/* 8222843Ch case    6:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 8222843Ch case    6:*/		return 0x82228440;
		  /* 82228440h */ case    7:  		/* bl -439648 */
		/* 82228440h case    7:*/		regs.LR = 0x82228444; return 0x821BCEE0;
		/* 82228440h case    7:*/		return 0x82228444;
		  /* 82228444h */ case    8:  		/* lfd FR0, <#[R1 + 152]> */
		/* 82228444h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000098) );
		/* 82228444h case    8:*/		return 0x82228448;
		  /* 82228448h */ case    9:  		/* fmr FR31, FR1 */
		/* 82228448h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82228448h case    9:*/		return 0x8222844C;
		  /* 8222844Ch */ case   10:  		/* fadd FR1, FR0, FR30 */
		/* 8222844Ch case   10:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR0,regs.FR30);
		/* 8222844Ch case   10:*/		return 0x82228450;
		  /* 82228450h */ case   11:  		/* bl -439664 */
		/* 82228450h case   11:*/		regs.LR = 0x82228454; return 0x821BCEE0;
		/* 82228450h case   11:*/		return 0x82228454;
		  /* 82228454h */ case   12:  		/* fcmpu CR6, FR1, FR31 */
		/* 82228454h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82228454h case   12:*/		return 0x82228458;
		  /* 82228458h */ case   13:  		/* bc 4, CR6_GT, 8 */
		/* 82228458h case   13:*/		if ( !regs.CR[6].gt ) { return 0x82228460;  }
		/* 82228458h case   13:*/		return 0x8222845C;
		  /* 8222845Ch */ case   14:  		/* fmr FR31, FR1 */
		/* 8222845Ch case   14:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8222845Ch case   14:*/		return 0x82228460;
	}
	return 0x82228460;
} // Block from 82228424h-82228460h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82228460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228460);
		  /* 82228460h */ case    0:  		/* lis R11, -32252 */
		/* 82228460h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82228460h case    0:*/		return 0x82228464;
		  /* 82228464h */ case    1:  		/* lfd FR13, <#[R11 - 240]> */
		/* 82228464h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFFF10) );
		/* 82228464h case    1:*/		return 0x82228468;
		  /* 82228468h */ case    2:  		/* fcmpu CR6, FR31, FR13 */
		/* 82228468h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR13);
		/* 82228468h case    2:*/		return 0x8222846C;
		  /* 8222846Ch */ case    3:  		/* bc 12, CR6_LT, 20 */
		/* 8222846Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82228480;  }
		/* 8222846Ch case    3:*/		return 0x82228470;
		  /* 82228470h */ case    4:  		/* lis R11, -32252 */
		/* 82228470h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82228470h case    4:*/		return 0x82228474;
		  /* 82228474h */ case    5:  		/* lfd FR0, <#[R11 - 15784]> */
		/* 82228474h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFC258) );
		/* 82228474h case    5:*/		return 0x82228478;
		  /* 82228478h */ case    6:  		/* fcmpu CR6, FR31, FR0 */
		/* 82228478h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82228478h case    6:*/		return 0x8222847C;
		  /* 8222847Ch */ case    7:  		/* bc 4, CR6_GT, 64 */
		/* 8222847Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x822284BC;  }
		/* 8222847Ch case    7:*/		return 0x82228480;
	}
	return 0x82228480;
} // Block from 82228460h-82228480h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228480);
		  /* 82228480h */ case    0:  		/* fmr FR31, FR13 */
		/* 82228480h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR13);
		/* 82228480h case    0:*/		return 0x82228484;
		  /* 82228484h */ case    1:  		/* b 56 */
		/* 82228484h case    1:*/		return 0x822284BC;
		/* 82228484h case    1:*/		return 0x82228488;
		  /* 82228488h */ case    2:  		/* rlwinm. R11, R9, 31, 31, 31 */
		/* 82228488h case    2:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R9);
		/* 82228488h case    2:*/		return 0x8222848C;
		  /* 8222848Ch */ case    3:  		/* bc 12, CR0_EQ, 48 */
		/* 8222848Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x822284BC;  }
		/* 8222848Ch case    3:*/		return 0x82228490;
		  /* 82228490h */ case    4:  		/* lfd FR0, <#[R1 + 152]> */
		/* 82228490h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000098) );
		/* 82228490h case    4:*/		return 0x82228494;
		  /* 82228494h */ case    5:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228494h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228494h case    5:*/		return 0x82228498;
		  /* 82228498h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 82228498h case    6:*/		if ( regs.CR[6].lt ) { return 0x822284A4;  }
		/* 82228498h case    6:*/		return 0x8222849C;
		  /* 8222849Ch */ case    7:  		/* stfd FR0, <#[R18]> */
		/* 8222849Ch case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R18 + 0x00000000) );
		/* 8222849Ch case    7:*/		return 0x822284A0;
		  /* 822284A0h */ case    8:  		/* b 8 */
		/* 822284A0h case    8:*/		return 0x822284A8;
		/* 822284A0h case    8:*/		return 0x822284A4;
	}
	return 0x822284A4;
} // Block from 82228480h-822284A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822284A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822284A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822284A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822284A4);
		  /* 822284A4h */ case    0:  		/* stfd FR1, <#[R18]> */
		/* 822284A4h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R18 + 0x00000000) );
		/* 822284A4h case    0:*/		return 0x822284A8;
	}
	return 0x822284A8;
} // Block from 822284A4h-822284A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822284A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822284A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822284A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822284A8);
		  /* 822284A8h */ case    0:  		/* rlwinm R4, R10, 30, 30, 31 */
		/* 822284A8h case    0:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R4,regs.R10);
		/* 822284A8h case    0:*/		return 0x822284AC;
		  /* 822284ACh */ case    1:  		/* bl -437484 */
		/* 822284ACh case    1:*/		regs.LR = 0x822284B0; return 0x821BD7C0;
		/* 822284ACh case    1:*/		return 0x822284B0;
		  /* 822284B0h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 822284B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822284B0h case    2:*/		return 0x822284B4;
		  /* 822284B4h */ case    3:  		/* or R11, R3, R11 */
		/* 822284B4h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 822284B4h case    3:*/		return 0x822284B8;
	}
	return 0x822284B8;
} // Block from 822284A8h-822284B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822284B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822284B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822284B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822284B8);
		  /* 822284B8h */ case    0:  		/* stw R11, <#[R30]> */
		/* 822284B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822284B8h case    0:*/		return 0x822284BC;
	}
	return 0x822284BC;
} // Block from 822284B8h-822284BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822284BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822284BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822284BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822284BC);
		  /* 822284BCh */ case    0:  		/* stfd FR31, <#[R18]> */
		/* 822284BCh case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R18 + 0x00000000) );
		/* 822284BCh case    0:*/		return 0x822284C0;
		  /* 822284C0h */ case    1:  		/* b 3360 */
		/* 822284C0h case    1:*/		return 0x822291E0;
		/* 822284C0h case    1:*/		return 0x822284C4;
	}
	return 0x822284C4;
} // Block from 822284BCh-822284C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822284C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822284C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822284C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822284C4);
		  /* 822284C4h */ case    0:  		/* cmplwi CR6, R11, 41 */
		/* 822284C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000029);
		/* 822284C4h case    0:*/		return 0x822284C8;
		  /* 822284C8h */ case    1:  		/* bc 4, CR6_EQ, 3352 */
		/* 822284C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 822284C8h case    1:*/		return 0x822284CC;
		  /* 822284CCh */ case    2:  		/* lwz R11, <#[R15]> */
		/* 822284CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 822284CCh case    2:*/		return 0x822284D0;
		  /* 822284D0h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 822284D0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822284D0h case    3:*/		return 0x822284D4;
		  /* 822284D4h */ case    4:  		/* rlwinm R10, R10, 0, 27, 30 */
		/* 822284D4h case    4:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R10,regs.R10);
		/* 822284D4h case    4:*/		return 0x822284D8;
		  /* 822284D8h */ case    5:  		/* cmplwi CR6, R10, 2 */
		/* 822284D8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 822284D8h case    5:*/		return 0x822284DC;
		  /* 822284DCh */ case    6:  		/* bc 4, CR6_EQ, 3332 */
		/* 822284DCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 822284DCh case    6:*/		return 0x822284E0;
		  /* 822284E0h */ case    7:  		/* lwz R3, <#[R11 + 12]> */
		/* 822284E0h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 822284E0h case    7:*/		return 0x822284E4;
		  /* 822284E4h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 822284E4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822284E4h case    8:*/		return 0x822284E8;
		  /* 822284E8h */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 822284E8h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 822284E8h case    9:*/		return 0x822284EC;
		  /* 822284ECh */ case   10:  		/* cmplwi CR6, R11, 15360 */
		/* 822284ECh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 822284ECh case   10:*/		return 0x822284F0;
		  /* 822284F0h */ case   11:  		/* bc 4, CR6_EQ, 3312 */
		/* 822284F0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 822284F0h case   11:*/		return 0x822284F4;
		  /* 822284F4h */ case   12:  		/* rlwinm R11, R14, 0, 0, 19 */
		/* 822284F4h case   12:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R14);
		/* 822284F4h case   12:*/		return 0x822284F8;
		  /* 822284F8h */ case   13:  		/* lwz R11, <#[R11]> */
		/* 822284F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822284F8h case   13:*/		return 0x822284FC;
		  /* 822284FCh */ case   14:  		/* lwz R4, <#[R11 + 148]> */
		/* 822284FCh case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000094) );
		/* 822284FCh case   14:*/		return 0x82228500;
		  /* 82228500h */ case   15:  		/* bl -598424 */
		/* 82228500h case   15:*/		regs.LR = 0x82228504; return 0x82196368;
		/* 82228500h case   15:*/		return 0x82228504;
		  /* 82228504h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 82228504h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82228504h case   16:*/		return 0x82228508;
		  /* 82228508h */ case   17:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82228508h case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82228508h case   17:*/		return 0x8222850C;
		  /* 8222850Ch */ case   18:  		/* bc 12, CR0_EQ, 3284 */
		/* 8222850Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 8222850Ch case   18:*/		return 0x82228510;
		  /* 82228510h */ case   19:  		/* mr R27, R28 */
		/* 82228510h case   19:*/		regs.R27 = regs.R28;
		/* 82228510h case   19:*/		return 0x82228514;
	}
	return 0x82228514;
} // Block from 822284C4h-82228514h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82228514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228514);
		  /* 82228514h */ case    0:  		/* lis R11, -32256 */
		/* 82228514h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228514h case    0:*/		return 0x82228518;
		  /* 82228518h */ case    1:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82228518h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82228518h case    1:*/		return 0x8222851C;
		  /* 8222851Ch */ case    2:  		/* stfd FR0, <#[R18]> */
		/* 8222851Ch case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R18 + 0x00000000) );
		/* 8222851Ch case    2:*/		return 0x82228520;
		  /* 82228520h */ case    3:  		/* b 3264 */
		/* 82228520h case    3:*/		return 0x822291E0;
		/* 82228520h case    3:*/		return 0x82228524;
	}
	return 0x82228524;
} // Block from 82228514h-82228524h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82228524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228524);
		  /* 82228524h */ case    0:  		/* cmplwi CR6, R11, 107 */
		/* 82228524h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006B);
		/* 82228524h case    0:*/		return 0x82228528;
		  /* 82228528h */ case    1:  		/* bc 12, CR6_GT, 2740 */
		/* 82228528h case    1:*/		if ( regs.CR[6].gt ) { return 0x82228FDC;  }
		/* 82228528h case    1:*/		return 0x8222852C;
		  /* 8222852Ch */ case    2:  		/* bc 12, CR6_EQ, 2624 */
		/* 8222852Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82228F6C;  }
		/* 8222852Ch case    2:*/		return 0x82228530;
		  /* 82228530h */ case    3:  		/* cmplwi CR6, R11, 96 */
		/* 82228530h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 82228530h case    3:*/		return 0x82228534;
		  /* 82228534h */ case    4:  		/* bc 12, CR6_EQ, 2436 */
		/* 82228534h case    4:*/		if ( regs.CR[6].eq ) { return 0x82228EB8;  }
		/* 82228534h case    4:*/		return 0x82228538;
		  /* 82228538h */ case    5:  		/* cmplwi CR6, R11, 97 */
		/* 82228538h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 82228538h case    5:*/		return 0x8222853C;
		  /* 8222853Ch */ case    6:  		/* bc 12, CR6_EQ, 2320 */
		/* 8222853Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82228E4C;  }
		/* 8222853Ch case    6:*/		return 0x82228540;
		  /* 82228540h */ case    7:  		/* cmplwi CR6, R11, 100 */
		/* 82228540h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 82228540h case    7:*/		return 0x82228544;
		  /* 82228544h */ case    8:  		/* bc 12, CR6_EQ, 2216 */
		/* 82228544h case    8:*/		if ( regs.CR[6].eq ) { return 0x82228DEC;  }
		/* 82228544h case    8:*/		return 0x82228548;
		  /* 82228548h */ case    9:  		/* cmplwi CR6, R11, 103 */
		/* 82228548h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000067);
		/* 82228548h case    9:*/		return 0x8222854C;
		  /* 8222854Ch */ case   10:  		/* bc 4, CR6_EQ, 3220 */
		/* 8222854Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 8222854Ch case   10:*/		return 0x82228550;
		  /* 82228550h */ case   11:  		/* rlwinm R25, R14, 0, 0, 19 */
		/* 82228550h case   11:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R25,regs.R14);
		/* 82228550h case   11:*/		return 0x82228554;
		  /* 82228554h */ case   12:  		/* mr R3, R14 */
		/* 82228554h case   12:*/		regs.R3 = regs.R14;
		/* 82228554h case   12:*/		return 0x82228558;
		  /* 82228558h */ case   13:  		/* lwz R11, <#[R25]> */
		/* 82228558h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82228558h case   13:*/		return 0x8222855C;
		  /* 8222855Ch */ case   14:  		/* lwz R4, <#[R11 + 148]> */
		/* 8222855Ch case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000094) );
		/* 8222855Ch case   14:*/		return 0x82228560;
		  /* 82228560h */ case   15:  		/* bl -436992 */
		/* 82228560h case   15:*/		regs.LR = 0x82228564; return 0x821BDA60;
		/* 82228560h case   15:*/		return 0x82228564;
		  /* 82228564h */ case   16:  		/* cmplwi CR6, R3, 14 */
		/* 82228564h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000000E);
		/* 82228564h case   16:*/		return 0x82228568;
		  /* 82228568h */ case   17:  		/* bc 12, CR6_GT, 3192 */
		/* 82228568h case   17:*/		if ( regs.CR[6].gt ) { return 0x822291E0;  }
		/* 82228568h case   17:*/		return 0x8222856C;
		  /* 8222856Ch */ case   18:  		/* lis R12, -32252 */
		/* 8222856Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 8222856Ch case   18:*/		return 0x82228570;
		  /* 82228570h */ case   19:  		/* rlwinm R0, R3, 1, 0, 30 */
		/* 82228570h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R3);
		/* 82228570h case   19:*/		return 0x82228574;
		  /* 82228574h */ case   20:  		/* addi R12, R12, -520 */
		/* 82228574h case   20:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFFDF8);
		/* 82228574h case   20:*/		return 0x82228578;
		  /* 82228578h */ case   21:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82228578h case   21:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82228578h case   21:*/		return 0x8222857C;
		  /* 8222857Ch */ case   22:  		/* lis R12, -32221 */
		/* 8222857Ch case   22:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8223);
		/* 8222857Ch case   22:*/		return 0x82228580;
		  /* 82228580h */ case   23:  		/* addi R12, R12, -31340 */
		/* 82228580h case   23:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFF8594);
		/* 82228580h case   23:*/		return 0x82228584;
		  /* 82228584h */ case   24:  		/* ori R0, R0, 0 */
		/* 82228584h case   24:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82228584h case   24:*/		return 0x82228588;
		  /* 82228588h */ case   25:  		/* add R12, R12, R0 */
		/* 82228588h case   25:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82228588h case   25:*/		return 0x8222858C;
		  /* 8222858Ch */ case   26:  		/* mtspr CTR, R12 */
		/* 8222858Ch case   26:*/		regs.CTR = regs.R12;
		/* 8222858Ch case   26:*/		return 0x82228590;
		  /* 82228590h */ case   27:  		/* bcctr 20, CR0_LT */
		/* 82228590h case   27:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82228590h case   27:*/		return 0x82228594;
		  /* 82228594h */ case   28:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228594h case   28:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228594h case   28:*/		return 0x82228598;
		  /* 82228598h */ case   29:  		/* mr R8, R31 */
		/* 82228598h case   29:*/		regs.R8 = regs.R31;
		/* 82228598h case   29:*/		return 0x8222859C;
		  /* 8222859Ch */ case   30:  		/* bc 12, CR0_EQ, 3140 */
		/* 8222859Ch case   30:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 8222859Ch case   30:*/		return 0x822285A0;
		  /* 822285A0h */ case   31:  		/* addi R9, R1, 144 */
		/* 822285A0h case   31:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 822285A0h case   31:*/		return 0x822285A4;
		  /* 822285A4h */ case   32:  		/* mr R10, R31 */
		/* 822285A4h case   32:*/		regs.R10 = regs.R31;
		/* 822285A4h case   32:*/		return 0x822285A8;
		  /* 822285A8h */ case   33:  		/* mr R11, R18 */
		/* 822285A8h case   33:*/		regs.R11 = regs.R18;
		/* 822285A8h case   33:*/		return 0x822285AC;
		  /* 822285ACh */ case   34:  		/* subf R7, R18, R9 */
		/* 822285ACh case   34:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R18,regs.R9);
		/* 822285ACh case   34:*/		return 0x822285B0;
		  /* 822285B0h */ case   35:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 822285B0h case   35:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 822285B0h case   35:*/		return 0x822285B4;
		  /* 822285B4h */ case   36:  		/* addi R6, R1, 80 */
		/* 822285B4h case   36:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 822285B4h case   36:*/		return 0x822285B8;
		  /* 822285B8h */ case   37:  		/* rlwinm R5, R8, 0, 27, 31 */
		/* 822285B8h case   37:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R8);
		/* 822285B8h case   37:*/		return 0x822285BC;
		  /* 822285BCh */ case   38:  		/* lwzx R9, <#[R9 + R6]> */
		/* 822285BCh case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 822285BCh case   38:*/		return 0x822285C0;
		  /* 822285C0h */ case   39:  		/* srw R9, R9, R5 */
		/* 822285C0h case   39:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 822285C0h case   39:*/		return 0x822285C4;
		  /* 822285C4h */ case   40:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 822285C4h case   40:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 822285C4h case   40:*/		return 0x822285C8;
		  /* 822285C8h */ case   41:  		/* bc 12, CR0_EQ, 76 */
		/* 822285C8h case   41:*/		if ( regs.CR[0].eq ) { return 0x82228614;  }
		/* 822285C8h case   41:*/		return 0x822285CC;
		  /* 822285CCh */ case   42:  		/* lfdx FR0, <#[R7 + R11]> */
		/* 822285CCh case   42:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 822285CCh case   42:*/		return 0x822285D0;
		  /* 822285D0h */ case   43:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 822285D0h case   43:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 822285D0h case   43:*/		return 0x822285D4;
		  /* 822285D4h */ case   44:  		/* fctiwz FR0, FR0 */
		/* 822285D4h case   44:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822285D4h case   44:*/		return 0x822285D8;
		  /* 822285D8h */ case   45:  		/* stfd FR0, <#[R1 + 88]> */
		/* 822285D8h case   45:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822285D8h case   45:*/		return 0x822285DC;
		  /* 822285DCh */ case   46:  		/* slw R5, R28, R8 */
		/* 822285DCh case   46:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R28,regs.R8);
		/* 822285DCh case   46:*/		return 0x822285E0;
		  /* 822285E0h */ case   47:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 822285E0h case   47:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 822285E0h case   47:*/		return 0x822285E4;
		  /* 822285E4h */ case   48:  		/* or R27, R5, R27 */
		/* 822285E4h case   48:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R27);
		/* 822285E4h case   48:*/		return 0x822285E8;
		  /* 822285E8h */ case   49:  		/* slw R6, R31, R6 */
		/* 822285E8h case   49:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R31,regs.R6);
		/* 822285E8h case   49:*/		return 0x822285EC;
		  /* 822285ECh */ case   50:  		/* lwa R4, <#[R1 + 92]> */
		/* 822285ECh case   50:*/		cpu::mem::load32a( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 822285ECh case   50:*/		return 0x822285F0;
		  /* 822285F0h */ case   51:  		/* std R4, <#[R1 + 104]> */
		/* 822285F0h case   51:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 822285F0h case   51:*/		return 0x822285F4;
		  /* 822285F4h */ case   52:  		/* lfd FR0, <#[R1 + 104]> */
		/* 822285F4h case   52:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 822285F4h case   52:*/		return 0x822285F8;
		  /* 822285F8h */ case   53:  		/* fcfid FR0, FR0 */
		/* 822285F8h case   53:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822285F8h case   53:*/		return 0x822285FC;
		  /* 822285FCh */ case   54:  		/* mr R5, R4 */
		/* 822285FCh case   54:*/		regs.R5 = regs.R4;
		/* 822285FCh case   54:*/		return 0x82228600;
		  /* 82228600h */ case   55:  		/* frsp FR0, FR0 */
		/* 82228600h case   55:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82228600h case   55:*/		return 0x82228604;
		  /* 82228604h */ case   56:  		/* stfd FR0, <#[R11]> */
		/* 82228604h case   56:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82228604h case   56:*/		return 0x82228608;
		  /* 82228608h */ case   57:  		/* lwzx R5, <#[R9 + R30]> */
		/* 82228608h case   57:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82228608h case   57:*/		return 0x8222860C;
		  /* 8222860Ch */ case   58:  		/* or R6, R6, R5 */
		/* 8222860Ch case   58:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 8222860Ch case   58:*/		return 0x82228610;
		  /* 82228610h */ case   59:  		/* stwx R6, <#[R9 + R30]> */
		/* 82228610h case   59:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82228610h case   59:*/		return 0x82228614;
	}
	return 0x82228614;
} // Block from 82228524h-82228614h (60 instructions)

//////////////////////////////////////////////////////
// Block at 82228614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228614);
		  /* 82228614h */ case    0:  		/* lwz R9, <#[R14 + 8]> */
		/* 82228614h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 82228614h case    0:*/		return 0x82228618;
		  /* 82228618h */ case    1:  		/* addi R8, R8, 1 */
		/* 82228618h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82228618h case    1:*/		return 0x8222861C;
		  /* 8222861Ch */ case    2:  		/* addi R11, R11, 8 */
		/* 8222861Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8222861Ch case    2:*/		return 0x82228620;
		  /* 82228620h */ case    3:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 82228620h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 82228620h case    3:*/		return 0x82228624;
		  /* 82228624h */ case    4:  		/* addi R10, R10, 2 */
		/* 82228624h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82228624h case    4:*/		return 0x82228628;
		  /* 82228628h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 82228628h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82228628h case    5:*/		return 0x8222862C;
		  /* 8222862Ch */ case    6:  		/* bc 12, CR6_LT, -124 */
		/* 8222862Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x822285B0;  }
		/* 8222862Ch case    6:*/		return 0x82228630;
		  /* 82228630h */ case    7:  		/* b 2992 */
		/* 82228630h case    7:*/		return 0x822291E0;
		/* 82228630h case    7:*/		return 0x82228634;
		  /* 82228634h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228634h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228634h case    8:*/		return 0x82228638;
		  /* 82228638h */ case    9:  		/* mr R8, R31 */
		/* 82228638h case    9:*/		regs.R8 = regs.R31;
		/* 82228638h case    9:*/		return 0x8222863C;
		  /* 8222863Ch */ case   10:  		/* bc 12, CR0_EQ, 2980 */
		/* 8222863Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 8222863Ch case   10:*/		return 0x82228640;
		  /* 82228640h */ case   11:  		/* addi R9, R1, 144 */
		/* 82228640h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 82228640h case   11:*/		return 0x82228644;
		  /* 82228644h */ case   12:  		/* mr R10, R31 */
		/* 82228644h case   12:*/		regs.R10 = regs.R31;
		/* 82228644h case   12:*/		return 0x82228648;
		  /* 82228648h */ case   13:  		/* mr R11, R18 */
		/* 82228648h case   13:*/		regs.R11 = regs.R18;
		/* 82228648h case   13:*/		return 0x8222864C;
		  /* 8222864Ch */ case   14:  		/* subf R7, R18, R9 */
		/* 8222864Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R18,regs.R9);
		/* 8222864Ch case   14:*/		return 0x82228650;
		  /* 82228650h */ case   15:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 82228650h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 82228650h case   15:*/		return 0x82228654;
		  /* 82228654h */ case   16:  		/* addi R6, R1, 80 */
		/* 82228654h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82228654h case   16:*/		return 0x82228658;
		  /* 82228658h */ case   17:  		/* rlwinm R5, R8, 0, 27, 31 */
		/* 82228658h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R8);
		/* 82228658h case   17:*/		return 0x8222865C;
		  /* 8222865Ch */ case   18:  		/* lwzx R9, <#[R9 + R6]> */
		/* 8222865Ch case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 8222865Ch case   18:*/		return 0x82228660;
		  /* 82228660h */ case   19:  		/* srw R9, R9, R5 */
		/* 82228660h case   19:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82228660h case   19:*/		return 0x82228664;
		  /* 82228664h */ case   20:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82228664h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82228664h case   20:*/		return 0x82228668;
		  /* 82228668h */ case   21:  		/* bc 12, CR0_EQ, 76 */
		/* 82228668h case   21:*/		if ( regs.CR[0].eq ) { return 0x822286B4;  }
		/* 82228668h case   21:*/		return 0x8222866C;
		  /* 8222866Ch */ case   22:  		/* lfdx FR0, <#[R11 + R7]> */
		/* 8222866Ch case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8222866Ch case   22:*/		return 0x82228670;
		  /* 82228670h */ case   23:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 82228670h case   23:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 82228670h case   23:*/		return 0x82228674;
		  /* 82228674h */ case   24:  		/* fctidz FR0, FR0 */
		/* 82228674h case   24:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228674h case   24:*/		return 0x82228678;
		  /* 82228678h */ case   25:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228678h case   25:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228678h case   25:*/		return 0x8222867C;
		  /* 8222867Ch */ case   26:  		/* slw R5, R28, R8 */
		/* 8222867Ch case   26:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R28,regs.R8);
		/* 8222867Ch case   26:*/		return 0x82228680;
		  /* 82228680h */ case   27:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 82228680h case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 82228680h case   27:*/		return 0x82228684;
		  /* 82228684h */ case   28:  		/* or R27, R5, R27 */
		/* 82228684h case   28:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R27);
		/* 82228684h case   28:*/		return 0x82228688;
		  /* 82228688h */ case   29:  		/* slw R6, R31, R6 */
		/* 82228688h case   29:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R31,regs.R6);
		/* 82228688h case   29:*/		return 0x8222868C;
		  /* 8222868Ch */ case   30:  		/* lwz R4, <#[R1 + 92]> */
		/* 8222868Ch case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 8222868Ch case   30:*/		return 0x82228690;
		  /* 82228690h */ case   31:  		/* mr R5, R4 */
		/* 82228690h case   31:*/		regs.R5 = regs.R4;
		/* 82228690h case   31:*/		return 0x82228694;
		  /* 82228694h */ case   32:  		/* std R4, <#[R1 + 104]> */
		/* 82228694h case   32:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82228694h case   32:*/		return 0x82228698;
		  /* 82228698h */ case   33:  		/* lfd FR0, <#[R1 + 104]> */
		/* 82228698h case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82228698h case   33:*/		return 0x8222869C;
		  /* 8222869Ch */ case   34:  		/* fcfid FR0, FR0 */
		/* 8222869Ch case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8222869Ch case   34:*/		return 0x822286A0;
		  /* 822286A0h */ case   35:  		/* frsp FR0, FR0 */
		/* 822286A0h case   35:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822286A0h case   35:*/		return 0x822286A4;
		  /* 822286A4h */ case   36:  		/* stfd FR0, <#[R11]> */
		/* 822286A4h case   36:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 822286A4h case   36:*/		return 0x822286A8;
		  /* 822286A8h */ case   37:  		/* lwzx R5, <#[R9 + R30]> */
		/* 822286A8h case   37:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 822286A8h case   37:*/		return 0x822286AC;
		  /* 822286ACh */ case   38:  		/* or R6, R6, R5 */
		/* 822286ACh case   38:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 822286ACh case   38:*/		return 0x822286B0;
		  /* 822286B0h */ case   39:  		/* stwx R6, <#[R9 + R30]> */
		/* 822286B0h case   39:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 822286B0h case   39:*/		return 0x822286B4;
	}
	return 0x822286B4;
} // Block from 82228614h-822286B4h (40 instructions)

//////////////////////////////////////////////////////
// Block at 822286B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822286B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822286B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822286B4);
		  /* 822286B4h */ case    0:  		/* lwz R9, <#[R14 + 8]> */
		/* 822286B4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 822286B4h case    0:*/		return 0x822286B8;
		  /* 822286B8h */ case    1:  		/* addi R8, R8, 1 */
		/* 822286B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 822286B8h case    1:*/		return 0x822286BC;
		  /* 822286BCh */ case    2:  		/* addi R11, R11, 8 */
		/* 822286BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 822286BCh case    2:*/		return 0x822286C0;
		  /* 822286C0h */ case    3:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 822286C0h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 822286C0h case    3:*/		return 0x822286C4;
		  /* 822286C4h */ case    4:  		/* addi R10, R10, 2 */
		/* 822286C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822286C4h case    4:*/		return 0x822286C8;
		  /* 822286C8h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 822286C8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 822286C8h case    5:*/		return 0x822286CC;
		  /* 822286CCh */ case    6:  		/* bc 12, CR6_LT, -124 */
		/* 822286CCh case    6:*/		if ( regs.CR[6].lt ) { return 0x82228650;  }
		/* 822286CCh case    6:*/		return 0x822286D0;
		  /* 822286D0h */ case    7:  		/* b 2832 */
		/* 822286D0h case    7:*/		return 0x822291E0;
		/* 822286D0h case    7:*/		return 0x822286D4;
		  /* 822286D4h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 822286D4h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 822286D4h case    8:*/		return 0x822286D8;
		  /* 822286D8h */ case    9:  		/* mr R8, R31 */
		/* 822286D8h case    9:*/		regs.R8 = regs.R31;
		/* 822286D8h case    9:*/		return 0x822286DC;
		  /* 822286DCh */ case   10:  		/* bc 12, CR0_EQ, 2820 */
		/* 822286DCh case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 822286DCh case   10:*/		return 0x822286E0;
		  /* 822286E0h */ case   11:  		/* addi R9, R1, 144 */
		/* 822286E0h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 822286E0h case   11:*/		return 0x822286E4;
		  /* 822286E4h */ case   12:  		/* mr R10, R31 */
		/* 822286E4h case   12:*/		regs.R10 = regs.R31;
		/* 822286E4h case   12:*/		return 0x822286E8;
		  /* 822286E8h */ case   13:  		/* mr R11, R18 */
		/* 822286E8h case   13:*/		regs.R11 = regs.R18;
		/* 822286E8h case   13:*/		return 0x822286EC;
		  /* 822286ECh */ case   14:  		/* subf R7, R18, R9 */
		/* 822286ECh case   14:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R18,regs.R9);
		/* 822286ECh case   14:*/		return 0x822286F0;
		  /* 822286F0h */ case   15:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 822286F0h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 822286F0h case   15:*/		return 0x822286F4;
		  /* 822286F4h */ case   16:  		/* addi R6, R1, 80 */
		/* 822286F4h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 822286F4h case   16:*/		return 0x822286F8;
		  /* 822286F8h */ case   17:  		/* rlwinm R5, R8, 0, 27, 31 */
		/* 822286F8h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R8);
		/* 822286F8h case   17:*/		return 0x822286FC;
		  /* 822286FCh */ case   18:  		/* lwzx R9, <#[R9 + R6]> */
		/* 822286FCh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 822286FCh case   18:*/		return 0x82228700;
		  /* 82228700h */ case   19:  		/* srw R9, R9, R5 */
		/* 82228700h case   19:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82228700h case   19:*/		return 0x82228704;
		  /* 82228704h */ case   20:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82228704h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82228704h case   20:*/		return 0x82228708;
		  /* 82228708h */ case   21:  		/* bc 12, CR0_EQ, 72 */
		/* 82228708h case   21:*/		if ( regs.CR[0].eq ) { return 0x82228750;  }
		/* 82228708h case   21:*/		return 0x8222870C;
		  /* 8222870Ch */ case   22:  		/* lfdx FR0, <#[R11 + R7]> */
		/* 8222870Ch case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8222870Ch case   22:*/		return 0x82228710;
		  /* 82228710h */ case   23:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 82228710h case   23:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 82228710h case   23:*/		return 0x82228714;
		  /* 82228714h */ case   24:  		/* fctiwz FR0, FR0 */
		/* 82228714h case   24:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228714h case   24:*/		return 0x82228718;
		  /* 82228718h */ case   25:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228718h case   25:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228718h case   25:*/		return 0x8222871C;
		  /* 8222871Ch */ case   26:  		/* slw R5, R28, R8 */
		/* 8222871Ch case   26:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R28,regs.R8);
		/* 8222871Ch case   26:*/		return 0x82228720;
		  /* 82228720h */ case   27:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 82228720h case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 82228720h case   27:*/		return 0x82228724;
		  /* 82228724h */ case   28:  		/* or R27, R5, R27 */
		/* 82228724h case   28:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R27);
		/* 82228724h case   28:*/		return 0x82228728;
		  /* 82228728h */ case   29:  		/* slw R6, R16, R6 */
		/* 82228728h case   29:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R16,regs.R6);
		/* 82228728h case   29:*/		return 0x8222872C;
		  /* 8222872Ch */ case   30:  		/* lwz R4, <#[R1 + 92]> */
		/* 8222872Ch case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 8222872Ch case   30:*/		return 0x82228730;
		  /* 82228730h */ case   31:  		/* mr R5, R4 */
		/* 82228730h case   31:*/		regs.R5 = regs.R4;
		/* 82228730h case   31:*/		return 0x82228734;
		  /* 82228734h */ case   32:  		/* std R4, <#[R1 + 104]> */
		/* 82228734h case   32:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82228734h case   32:*/		return 0x82228738;
		  /* 82228738h */ case   33:  		/* lfd FR0, <#[R1 + 104]> */
		/* 82228738h case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82228738h case   33:*/		return 0x8222873C;
		  /* 8222873Ch */ case   34:  		/* fcfid FR0, FR0 */
		/* 8222873Ch case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8222873Ch case   34:*/		return 0x82228740;
		  /* 82228740h */ case   35:  		/* stfd FR0, <#[R11]> */
		/* 82228740h case   35:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82228740h case   35:*/		return 0x82228744;
		  /* 82228744h */ case   36:  		/* lwzx R5, <#[R9 + R30]> */
		/* 82228744h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82228744h case   36:*/		return 0x82228748;
		  /* 82228748h */ case   37:  		/* or R6, R6, R5 */
		/* 82228748h case   37:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 82228748h case   37:*/		return 0x8222874C;
		  /* 8222874Ch */ case   38:  		/* stwx R6, <#[R9 + R30]> */
		/* 8222874Ch case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 8222874Ch case   38:*/		return 0x82228750;
	}
	return 0x82228750;
} // Block from 822286B4h-82228750h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82228750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228750);
		  /* 82228750h */ case    0:  		/* lwz R9, <#[R14 + 8]> */
		/* 82228750h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 82228750h case    0:*/		return 0x82228754;
		  /* 82228754h */ case    1:  		/* addi R8, R8, 1 */
		/* 82228754h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82228754h case    1:*/		return 0x82228758;
		  /* 82228758h */ case    2:  		/* addi R11, R11, 8 */
		/* 82228758h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82228758h case    2:*/		return 0x8222875C;
		  /* 8222875Ch */ case    3:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 8222875Ch case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 8222875Ch case    3:*/		return 0x82228760;
		  /* 82228760h */ case    4:  		/* addi R10, R10, 2 */
		/* 82228760h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82228760h case    4:*/		return 0x82228764;
		  /* 82228764h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 82228764h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82228764h case    5:*/		return 0x82228768;
		  /* 82228768h */ case    6:  		/* bc 12, CR6_LT, -120 */
		/* 82228768h case    6:*/		if ( regs.CR[6].lt ) { return 0x822286F0;  }
		/* 82228768h case    6:*/		return 0x8222876C;
		  /* 8222876Ch */ case    7:  		/* b 2676 */
		/* 8222876Ch case    7:*/		return 0x822291E0;
		/* 8222876Ch case    7:*/		return 0x82228770;
		  /* 82228770h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228770h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228770h case    8:*/		return 0x82228774;
		  /* 82228774h */ case    9:  		/* mr R8, R31 */
		/* 82228774h case    9:*/		regs.R8 = regs.R31;
		/* 82228774h case    9:*/		return 0x82228778;
		  /* 82228778h */ case   10:  		/* bc 12, CR0_EQ, 2664 */
		/* 82228778h case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228778h case   10:*/		return 0x8222877C;
		  /* 8222877Ch */ case   11:  		/* addi R9, R1, 144 */
		/* 8222877Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 8222877Ch case   11:*/		return 0x82228780;
		  /* 82228780h */ case   12:  		/* mr R10, R31 */
		/* 82228780h case   12:*/		regs.R10 = regs.R31;
		/* 82228780h case   12:*/		return 0x82228784;
		  /* 82228784h */ case   13:  		/* mr R11, R18 */
		/* 82228784h case   13:*/		regs.R11 = regs.R18;
		/* 82228784h case   13:*/		return 0x82228788;
		  /* 82228788h */ case   14:  		/* subf R7, R18, R9 */
		/* 82228788h case   14:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R18,regs.R9);
		/* 82228788h case   14:*/		return 0x8222878C;
		  /* 8222878Ch */ case   15:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 8222878Ch case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 8222878Ch case   15:*/		return 0x82228790;
		  /* 82228790h */ case   16:  		/* addi R6, R1, 80 */
		/* 82228790h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82228790h case   16:*/		return 0x82228794;
		  /* 82228794h */ case   17:  		/* rlwinm R5, R8, 0, 27, 31 */
		/* 82228794h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R8);
		/* 82228794h case   17:*/		return 0x82228798;
		  /* 82228798h */ case   18:  		/* lwzx R9, <#[R9 + R6]> */
		/* 82228798h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 82228798h case   18:*/		return 0x8222879C;
		  /* 8222879Ch */ case   19:  		/* srw R9, R9, R5 */
		/* 8222879Ch case   19:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 8222879Ch case   19:*/		return 0x822287A0;
		  /* 822287A0h */ case   20:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 822287A0h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 822287A0h case   20:*/		return 0x822287A4;
		  /* 822287A4h */ case   21:  		/* bc 12, CR0_EQ, 72 */
		/* 822287A4h case   21:*/		if ( regs.CR[0].eq ) { return 0x822287EC;  }
		/* 822287A4h case   21:*/		return 0x822287A8;
		  /* 822287A8h */ case   22:  		/* lfdx FR0, <#[R11 + R7]> */
		/* 822287A8h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 822287A8h case   22:*/		return 0x822287AC;
		  /* 822287ACh */ case   23:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 822287ACh case   23:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 822287ACh case   23:*/		return 0x822287B0;
		  /* 822287B0h */ case   24:  		/* fctidz FR0, FR0 */
		/* 822287B0h case   24:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 822287B0h case   24:*/		return 0x822287B4;
		  /* 822287B4h */ case   25:  		/* stfd FR0, <#[R1 + 88]> */
		/* 822287B4h case   25:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822287B4h case   25:*/		return 0x822287B8;
		  /* 822287B8h */ case   26:  		/* slw R5, R28, R8 */
		/* 822287B8h case   26:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R28,regs.R8);
		/* 822287B8h case   26:*/		return 0x822287BC;
		  /* 822287BCh */ case   27:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 822287BCh case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 822287BCh case   27:*/		return 0x822287C0;
		  /* 822287C0h */ case   28:  		/* or R27, R5, R27 */
		/* 822287C0h case   28:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R27);
		/* 822287C0h case   28:*/		return 0x822287C4;
		  /* 822287C4h */ case   29:  		/* slw R6, R28, R6 */
		/* 822287C4h case   29:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R28,regs.R6);
		/* 822287C4h case   29:*/		return 0x822287C8;
		  /* 822287C8h */ case   30:  		/* lwa R4, <#[R1 + 92]> */
		/* 822287C8h case   30:*/		cpu::mem::load32a( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 822287C8h case   30:*/		return 0x822287CC;
		  /* 822287CCh */ case   31:  		/* std R4, <#[R1 + 104]> */
		/* 822287CCh case   31:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 822287CCh case   31:*/		return 0x822287D0;
		  /* 822287D0h */ case   32:  		/* mr R5, R4 */
		/* 822287D0h case   32:*/		regs.R5 = regs.R4;
		/* 822287D0h case   32:*/		return 0x822287D4;
		  /* 822287D4h */ case   33:  		/* lfd FR0, <#[R1 + 104]> */
		/* 822287D4h case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 822287D4h case   33:*/		return 0x822287D8;
		  /* 822287D8h */ case   34:  		/* fcfid FR0, FR0 */
		/* 822287D8h case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822287D8h case   34:*/		return 0x822287DC;
		  /* 822287DCh */ case   35:  		/* stfd FR0, <#[R11]> */
		/* 822287DCh case   35:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 822287DCh case   35:*/		return 0x822287E0;
		  /* 822287E0h */ case   36:  		/* lwzx R5, <#[R9 + R30]> */
		/* 822287E0h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 822287E0h case   36:*/		return 0x822287E4;
		  /* 822287E4h */ case   37:  		/* or R6, R6, R5 */
		/* 822287E4h case   37:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 822287E4h case   37:*/		return 0x822287E8;
		  /* 822287E8h */ case   38:  		/* stwx R6, <#[R9 + R30]> */
		/* 822287E8h case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 822287E8h case   38:*/		return 0x822287EC;
	}
	return 0x822287EC;
} // Block from 82228750h-822287ECh (39 instructions)

//////////////////////////////////////////////////////
// Block at 822287ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822287EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822287EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822287EC);
		  /* 822287ECh */ case    0:  		/* lwz R9, <#[R14 + 8]> */
		/* 822287ECh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 822287ECh case    0:*/		return 0x822287F0;
		  /* 822287F0h */ case    1:  		/* addi R8, R8, 1 */
		/* 822287F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 822287F0h case    1:*/		return 0x822287F4;
		  /* 822287F4h */ case    2:  		/* addi R11, R11, 8 */
		/* 822287F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 822287F4h case    2:*/		return 0x822287F8;
		  /* 822287F8h */ case    3:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 822287F8h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 822287F8h case    3:*/		return 0x822287FC;
		  /* 822287FCh */ case    4:  		/* addi R10, R10, 2 */
		/* 822287FCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822287FCh case    4:*/		return 0x82228800;
		  /* 82228800h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 82228800h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82228800h case    5:*/		return 0x82228804;
		  /* 82228804h */ case    6:  		/* bc 12, CR6_LT, -120 */
		/* 82228804h case    6:*/		if ( regs.CR[6].lt ) { return 0x8222878C;  }
		/* 82228804h case    6:*/		return 0x82228808;
		  /* 82228808h */ case    7:  		/* b 2520 */
		/* 82228808h case    7:*/		return 0x822291E0;
		/* 82228808h case    7:*/		return 0x8222880C;
		  /* 8222880Ch */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 8222880Ch case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 8222880Ch case    8:*/		return 0x82228810;
		  /* 82228810h */ case    9:  		/* mr R8, R31 */
		/* 82228810h case    9:*/		regs.R8 = regs.R31;
		/* 82228810h case    9:*/		return 0x82228814;
		  /* 82228814h */ case   10:  		/* bc 12, CR0_EQ, 2508 */
		/* 82228814h case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228814h case   10:*/		return 0x82228818;
		  /* 82228818h */ case   11:  		/* addi R9, R1, 144 */
		/* 82228818h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 82228818h case   11:*/		return 0x8222881C;
		  /* 8222881Ch */ case   12:  		/* mr R10, R31 */
		/* 8222881Ch case   12:*/		regs.R10 = regs.R31;
		/* 8222881Ch case   12:*/		return 0x82228820;
		  /* 82228820h */ case   13:  		/* mr R11, R18 */
		/* 82228820h case   13:*/		regs.R11 = regs.R18;
		/* 82228820h case   13:*/		return 0x82228824;
		  /* 82228824h */ case   14:  		/* subf R7, R18, R9 */
		/* 82228824h case   14:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R18,regs.R9);
		/* 82228824h case   14:*/		return 0x82228828;
		  /* 82228828h */ case   15:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 82228828h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 82228828h case   15:*/		return 0x8222882C;
		  /* 8222882Ch */ case   16:  		/* addi R6, R1, 80 */
		/* 8222882Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8222882Ch case   16:*/		return 0x82228830;
		  /* 82228830h */ case   17:  		/* rlwinm R5, R8, 0, 27, 31 */
		/* 82228830h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R8);
		/* 82228830h case   17:*/		return 0x82228834;
		  /* 82228834h */ case   18:  		/* lwzx R9, <#[R9 + R6]> */
		/* 82228834h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 82228834h case   18:*/		return 0x82228838;
		  /* 82228838h */ case   19:  		/* srw R9, R9, R5 */
		/* 82228838h case   19:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82228838h case   19:*/		return 0x8222883C;
		  /* 8222883Ch */ case   20:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 8222883Ch case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 8222883Ch case   20:*/		return 0x82228840;
		  /* 82228840h */ case   21:  		/* bc 12, CR0_EQ, 72 */
		/* 82228840h case   21:*/		if ( regs.CR[0].eq ) { return 0x82228888;  }
		/* 82228840h case   21:*/		return 0x82228844;
		  /* 82228844h */ case   22:  		/* lfdx FR0, <#[R11 + R7]> */
		/* 82228844h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82228844h case   22:*/		return 0x82228848;
		  /* 82228848h */ case   23:  		/* slw R5, R28, R8 */
		/* 82228848h case   23:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R28,regs.R8);
		/* 82228848h case   23:*/		return 0x8222884C;
		  /* 8222884Ch */ case   24:  		/* frsp FR0, FR0 */
		/* 8222884Ch case   24:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8222884Ch case   24:*/		return 0x82228850;
		  /* 82228850h */ case   25:  		/* or R27, R5, R27 */
		/* 82228850h case   25:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R27);
		/* 82228850h case   25:*/		return 0x82228854;
		  /* 82228854h */ case   26:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 82228854h case   26:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 82228854h case   26:*/		return 0x82228858;
		  /* 82228858h */ case   27:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 82228858h case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 82228858h case   27:*/		return 0x8222885C;
		  /* 8222885Ch */ case   28:  		/* slw R6, R28, R6 */
		/* 8222885Ch case   28:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R28,regs.R6);
		/* 8222885Ch case   28:*/		return 0x82228860;
		  /* 82228860h */ case   29:  		/* fctiwz FR0, FR0 */
		/* 82228860h case   29:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228860h case   29:*/		return 0x82228864;
		  /* 82228864h */ case   30:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228864h case   30:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228864h case   30:*/		return 0x82228868;
		  /* 82228868h */ case   31:  		/* lwa R5, <#[R1 + 92]> */
		/* 82228868h case   31:*/		cpu::mem::load32a( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228868h case   31:*/		return 0x8222886C;
		  /* 8222886Ch */ case   32:  		/* std R5, <#[R1 + 104]> */
		/* 8222886Ch case   32:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 8222886Ch case   32:*/		return 0x82228870;
		  /* 82228870h */ case   33:  		/* lfd FR0, <#[R1 + 104]> */
		/* 82228870h case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82228870h case   33:*/		return 0x82228874;
		  /* 82228874h */ case   34:  		/* fcfid FR0, FR0 */
		/* 82228874h case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82228874h case   34:*/		return 0x82228878;
		  /* 82228878h */ case   35:  		/* stfd FR0, <#[R11]> */
		/* 82228878h case   35:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82228878h case   35:*/		return 0x8222887C;
		  /* 8222887Ch */ case   36:  		/* lwzx R5, <#[R9 + R30]> */
		/* 8222887Ch case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 8222887Ch case   36:*/		return 0x82228880;
		  /* 82228880h */ case   37:  		/* or R6, R6, R5 */
		/* 82228880h case   37:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 82228880h case   37:*/		return 0x82228884;
		  /* 82228884h */ case   38:  		/* stwx R6, <#[R9 + R30]> */
		/* 82228884h case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82228884h case   38:*/		return 0x82228888;
	}
	return 0x82228888;
} // Block from 822287ECh-82228888h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82228888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228888);
		  /* 82228888h */ case    0:  		/* lwz R9, <#[R14 + 8]> */
		/* 82228888h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 82228888h case    0:*/		return 0x8222888C;
		  /* 8222888Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 8222888Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8222888Ch case    1:*/		return 0x82228890;
		  /* 82228890h */ case    2:  		/* addi R11, R11, 8 */
		/* 82228890h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82228890h case    2:*/		return 0x82228894;
		  /* 82228894h */ case    3:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 82228894h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 82228894h case    3:*/		return 0x82228898;
		  /* 82228898h */ case    4:  		/* addi R10, R10, 2 */
		/* 82228898h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82228898h case    4:*/		return 0x8222889C;
		  /* 8222889Ch */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 8222889Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8222889Ch case    5:*/		return 0x822288A0;
		  /* 822288A0h */ case    6:  		/* bc 12, CR6_LT, -120 */
		/* 822288A0h case    6:*/		if ( regs.CR[6].lt ) { return 0x82228828;  }
		/* 822288A0h case    6:*/		return 0x822288A4;
		  /* 822288A4h */ case    7:  		/* b 2364 */
		/* 822288A4h case    7:*/		return 0x822291E0;
		/* 822288A4h case    7:*/		return 0x822288A8;
		  /* 822288A8h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 822288A8h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 822288A8h case    8:*/		return 0x822288AC;
		  /* 822288ACh */ case    9:  		/* mr R8, R31 */
		/* 822288ACh case    9:*/		regs.R8 = regs.R31;
		/* 822288ACh case    9:*/		return 0x822288B0;
		  /* 822288B0h */ case   10:  		/* bc 12, CR0_EQ, 2352 */
		/* 822288B0h case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 822288B0h case   10:*/		return 0x822288B4;
		  /* 822288B4h */ case   11:  		/* addi R9, R1, 144 */
		/* 822288B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 822288B4h case   11:*/		return 0x822288B8;
		  /* 822288B8h */ case   12:  		/* mr R10, R31 */
		/* 822288B8h case   12:*/		regs.R10 = regs.R31;
		/* 822288B8h case   12:*/		return 0x822288BC;
		  /* 822288BCh */ case   13:  		/* mr R11, R18 */
		/* 822288BCh case   13:*/		regs.R11 = regs.R18;
		/* 822288BCh case   13:*/		return 0x822288C0;
		  /* 822288C0h */ case   14:  		/* subf R7, R18, R9 */
		/* 822288C0h case   14:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R18,regs.R9);
		/* 822288C0h case   14:*/		return 0x822288C4;
		  /* 822288C4h */ case   15:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 822288C4h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 822288C4h case   15:*/		return 0x822288C8;
		  /* 822288C8h */ case   16:  		/* addi R6, R1, 80 */
		/* 822288C8h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 822288C8h case   16:*/		return 0x822288CC;
		  /* 822288CCh */ case   17:  		/* rlwinm R5, R8, 0, 27, 31 */
		/* 822288CCh case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R8);
		/* 822288CCh case   17:*/		return 0x822288D0;
		  /* 822288D0h */ case   18:  		/* lwzx R9, <#[R9 + R6]> */
		/* 822288D0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 822288D0h case   18:*/		return 0x822288D4;
		  /* 822288D4h */ case   19:  		/* srw R9, R9, R5 */
		/* 822288D4h case   19:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 822288D4h case   19:*/		return 0x822288D8;
		  /* 822288D8h */ case   20:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 822288D8h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 822288D8h case   20:*/		return 0x822288DC;
		  /* 822288DCh */ case   21:  		/* bc 12, CR0_EQ, 72 */
		/* 822288DCh case   21:*/		if ( regs.CR[0].eq ) { return 0x82228924;  }
		/* 822288DCh case   21:*/		return 0x822288E0;
		  /* 822288E0h */ case   22:  		/* lfdx FR0, <#[R11 + R7]> */
		/* 822288E0h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 822288E0h case   22:*/		return 0x822288E4;
		  /* 822288E4h */ case   23:  		/* slw R5, R28, R8 */
		/* 822288E4h case   23:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R28,regs.R8);
		/* 822288E4h case   23:*/		return 0x822288E8;
		  /* 822288E8h */ case   24:  		/* fctidz FR0, FR0 */
		/* 822288E8h case   24:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 822288E8h case   24:*/		return 0x822288EC;
		  /* 822288ECh */ case   25:  		/* stfd FR0, <#[R1 + 88]> */
		/* 822288ECh case   25:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822288ECh case   25:*/		return 0x822288F0;
		  /* 822288F0h */ case   26:  		/* or R27, R5, R27 */
		/* 822288F0h case   26:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R27);
		/* 822288F0h case   26:*/		return 0x822288F4;
		  /* 822288F4h */ case   27:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 822288F4h case   27:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 822288F4h case   27:*/		return 0x822288F8;
		  /* 822288F8h */ case   28:  		/* rlwinm R6, R10, 0, 27, 31 */
		/* 822288F8h case   28:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R10);
		/* 822288F8h case   28:*/		return 0x822288FC;
		  /* 822288FCh */ case   29:  		/* slw R6, R16, R6 */
		/* 822288FCh case   29:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R16,regs.R6);
		/* 822288FCh case   29:*/		return 0x82228900;
		  /* 82228900h */ case   30:  		/* ld R4, <#[R1 + 88]> */
		/* 82228900h case   30:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 82228900h case   30:*/		return 0x82228904;
		  /* 82228904h */ case   31:  		/* rlwinm R5, R4, 0, 0, 31 */
		/* 82228904h case   31:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R4);
		/* 82228904h case   31:*/		return 0x82228908;
		  /* 82228908h */ case   32:  		/* std R5, <#[R1 + 104]> */
		/* 82228908h case   32:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 82228908h case   32:*/		return 0x8222890C;
		  /* 8222890Ch */ case   33:  		/* lfd FR0, <#[R1 + 104]> */
		/* 8222890Ch case   33:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 8222890Ch case   33:*/		return 0x82228910;
		  /* 82228910h */ case   34:  		/* fcfid FR0, FR0 */
		/* 82228910h case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82228910h case   34:*/		return 0x82228914;
		  /* 82228914h */ case   35:  		/* stfd FR0, <#[R11]> */
		/* 82228914h case   35:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82228914h case   35:*/		return 0x82228918;
		  /* 82228918h */ case   36:  		/* lwzx R5, <#[R9 + R30]> */
		/* 82228918h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82228918h case   36:*/		return 0x8222891C;
		  /* 8222891Ch */ case   37:  		/* or R6, R6, R5 */
		/* 8222891Ch case   37:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 8222891Ch case   37:*/		return 0x82228920;
		  /* 82228920h */ case   38:  		/* stwx R6, <#[R9 + R30]> */
		/* 82228920h case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82228920h case   38:*/		return 0x82228924;
	}
	return 0x82228924;
} // Block from 82228888h-82228924h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82228924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228924);
		  /* 82228924h */ case    0:  		/* lwz R9, <#[R14 + 8]> */
		/* 82228924h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 82228924h case    0:*/		return 0x82228928;
		  /* 82228928h */ case    1:  		/* addi R8, R8, 1 */
		/* 82228928h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82228928h case    1:*/		return 0x8222892C;
		  /* 8222892Ch */ case    2:  		/* addi R11, R11, 8 */
		/* 8222892Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8222892Ch case    2:*/		return 0x82228930;
		  /* 82228930h */ case    3:  		/* rlwinm R9, R9, 18, 29, 31 */
		/* 82228930h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R9);
		/* 82228930h case    3:*/		return 0x82228934;
		  /* 82228934h */ case    4:  		/* addi R10, R10, 2 */
		/* 82228934h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82228934h case    4:*/		return 0x82228938;
		  /* 82228938h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 82228938h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82228938h case    5:*/		return 0x8222893C;
		  /* 8222893Ch */ case    6:  		/* bc 12, CR6_LT, -120 */
		/* 8222893Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x822288C4;  }
		/* 8222893Ch case    6:*/		return 0x82228940;
		  /* 82228940h */ case    7:  		/* b 2208 */
		/* 82228940h case    7:*/		return 0x822291E0;
		/* 82228940h case    7:*/		return 0x82228944;
		  /* 82228944h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228944h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228944h case    8:*/		return 0x82228948;
		  /* 82228948h */ case    9:  		/* mr R7, R31 */
		/* 82228948h case    9:*/		regs.R7 = regs.R31;
		/* 82228948h case    9:*/		return 0x8222894C;
		  /* 8222894Ch */ case   10:  		/* bc 12, CR0_EQ, 2196 */
		/* 8222894Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 8222894Ch case   10:*/		return 0x82228950;
		  /* 82228950h */ case   11:  		/* addi R11, R1, 144 */
		/* 82228950h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82228950h case   11:*/		return 0x82228954;
		  /* 82228954h */ case   12:  		/* mr R9, R31 */
		/* 82228954h case   12:*/		regs.R9 = regs.R31;
		/* 82228954h case   12:*/		return 0x82228958;
		  /* 82228958h */ case   13:  		/* mr R6, R18 */
		/* 82228958h case   13:*/		regs.R6 = regs.R18;
		/* 82228958h case   13:*/		return 0x8222895C;
		  /* 8222895Ch */ case   14:  		/* subf R5, R18, R11 */
		/* 8222895Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R18,regs.R11);
		/* 8222895Ch case   14:*/		return 0x82228960;
		  /* 82228960h */ case   15:  		/* rlwinm R11, R7, 29, 3, 29 */
		/* 82228960h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R7);
		/* 82228960h case   15:*/		return 0x82228964;
		  /* 82228964h */ case   16:  		/* addi R10, R1, 80 */
		/* 82228964h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82228964h case   16:*/		return 0x82228968;
		  /* 82228968h */ case   17:  		/* rlwinm R8, R7, 0, 27, 31 */
		/* 82228968h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R7);
		/* 82228968h case   17:*/		return 0x8222896C;
		  /* 8222896Ch */ case   18:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8222896Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8222896Ch case   18:*/		return 0x82228970;
		  /* 82228970h */ case   19:  		/* srw R11, R11, R8 */
		/* 82228970h case   19:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82228970h case   19:*/		return 0x82228974;
		  /* 82228974h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82228974h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82228974h case   20:*/		return 0x82228978;
		  /* 82228978h */ case   21:  		/* bc 12, CR0_EQ, 156 */
		/* 82228978h case   21:*/		if ( regs.CR[0].eq ) { return 0x82228A14;  }
		/* 82228978h case   21:*/		return 0x8222897C;
		  /* 8222897Ch */ case   22:  		/* addi R10, R9, 1 */
		/* 8222897Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x1);
		/* 8222897Ch case   22:*/		return 0x82228980;
		  /* 82228980h */ case   23:  		/* lfdx FR0, <#[R6 + R5]> */
		/* 82228980h case   23:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R5 + 0x00000000) );
		/* 82228980h case   23:*/		return 0x82228984;
		  /* 82228984h */ case   24:  		/* rlwinm R11, R9, 29, 3, 29 */
		/* 82228984h case   24:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R9);
		/* 82228984h case   24:*/		return 0x82228988;
		  /* 82228988h */ case   25:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82228988h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82228988h case   25:*/		return 0x8222898C;
		  /* 8222898Ch */ case   26:  		/* addi R4, R1, 112 */
		/* 8222898Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 8222898Ch case   26:*/		return 0x82228990;
		  /* 82228990h */ case   27:  		/* slw R8, R16, R10 */
		/* 82228990h case   27:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R16,regs.R10);
		/* 82228990h case   27:*/		return 0x82228994;
		  /* 82228994h */ case   28:  		/* lwzx R4, <#[R11 + R4]> */
		/* 82228994h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82228994h case   28:*/		return 0x82228998;
		  /* 82228998h */ case   29:  		/* addi R8, R8, -1 */
		/* 82228998h case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82228998h case   29:*/		return 0x8222899C;
		  /* 8222899Ch */ case   30:  		/* rlwinm R10, R9, 0, 27, 31 */
		/* 8222899Ch case   30:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R9);
		/* 8222899Ch case   30:*/		return 0x822289A0;
		  /* 822289A0h */ case   31:  		/* and R8, R8, R4 */
		/* 822289A0h case   31:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R4);
		/* 822289A0h case   31:*/		return 0x822289A4;
		  /* 822289A4h */ case   32:  		/* slw R3, R29, R10 */
		/* 822289A4h case   32:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R29,regs.R10);
		/* 822289A4h case   32:*/		return 0x822289A8;
		  /* 822289A8h */ case   33:  		/* and R8, R8, R3 */
		/* 822289A8h case   33:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R3);
		/* 822289A8h case   33:*/		return 0x822289AC;
		  /* 822289ACh */ case   34:  		/* srw R8, R8, R10 */
		/* 822289ACh case   34:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 822289ACh case   34:*/		return 0x822289B0;
		  /* 822289B0h */ case   35:  		/* cmplwi CR6, R8, 2 */
		/* 822289B0h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000002);
		/* 822289B0h case   35:*/		return 0x822289B4;
		  /* 822289B4h */ case   36:  		/* bc 4, CR6_EQ, 36 */
		/* 822289B4h case   36:*/		if ( !regs.CR[6].eq ) { return 0x822289D8;  }
		/* 822289B4h case   36:*/		return 0x822289B8;
		  /* 822289B8h */ case   37:  		/* fctidz FR0, FR0 */
		/* 822289B8h case   37:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 822289B8h case   37:*/		return 0x822289BC;
		  /* 822289BCh */ case   38:  		/* stfd FR0, <#[R1 + 88]> */
		/* 822289BCh case   38:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822289BCh case   38:*/		return 0x822289C0;
		  /* 822289C0h */ case   39:  		/* lwz R4, <#[R1 + 92]> */
		/* 822289C0h case   39:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 822289C0h case   39:*/		return 0x822289C4;
		  /* 822289C4h */ case   40:  		/* nor R4, R4, R4 */
		/* 822289C4h case   40:*/		cpu::op::nor<0>(regs,&regs.R4,regs.R4,regs.R4);
		/* 822289C4h case   40:*/		return 0x822289C8;
		  /* 822289C8h */ case   41:  		/* rldicl R4, R4, 0, 32 */
		/* 822289C8h case   41:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R4,regs.R4);
		/* 822289C8h case   41:*/		return 0x822289CC;
		  /* 822289CCh */ case   42:  		/* std R4, <#[R1 + 104]> */
		/* 822289CCh case   42:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 822289CCh case   42:*/		return 0x822289D0;
		  /* 822289D0h */ case   43:  		/* lfd FR0, <#[R1 + 104]> */
		/* 822289D0h case   43:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 822289D0h case   43:*/		return 0x822289D4;
		  /* 822289D4h */ case   44:  		/* b 32 */
		/* 822289D4h case   44:*/		return 0x822289F4;
		/* 822289D4h case   44:*/		return 0x822289D8;
	}
	return 0x822289D8;
} // Block from 82228924h-822289D8h (45 instructions)

//////////////////////////////////////////////////////
// Block at 822289D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822289D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822289D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822289D8);
		  /* 822289D8h */ case    0:  		/* fctiwz FR0, FR0 */
		/* 822289D8h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 822289D8h case    0:*/		return 0x822289DC;
		  /* 822289DCh */ case    1:  		/* stfd FR0, <#[R1 + 88]> */
		/* 822289DCh case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 822289DCh case    1:*/		return 0x822289E0;
		  /* 822289E0h */ case    2:  		/* lwz R4, <#[R1 + 92]> */
		/* 822289E0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 822289E0h case    2:*/		return 0x822289E4;
		  /* 822289E4h */ case    3:  		/* nor R4, R4, R4 */
		/* 822289E4h case    3:*/		cpu::op::nor<0>(regs,&regs.R4,regs.R4,regs.R4);
		/* 822289E4h case    3:*/		return 0x822289E8;
		  /* 822289E8h */ case    4:  		/* extsw R4, R4 */
		/* 822289E8h case    4:*/		cpu::op::extsw<0>(regs,&regs.R4,regs.R4);
		/* 822289E8h case    4:*/		return 0x822289EC;
		  /* 822289ECh */ case    5:  		/* std R4, <#[R1 + 136]> */
		/* 822289ECh case    5:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 822289ECh case    5:*/		return 0x822289F0;
		  /* 822289F0h */ case    6:  		/* lfd FR0, <#[R1 + 136]> */
		/* 822289F0h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 822289F0h case    6:*/		return 0x822289F4;
	}
	return 0x822289F4;
} // Block from 822289D8h-822289F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822289F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822289F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822289F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822289F4);
		  /* 822289F4h */ case    0:  		/* fcfid FR0, FR0 */
		/* 822289F4h case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822289F4h case    0:*/		return 0x822289F8;
		  /* 822289F8h */ case    1:  		/* stfd FR0, <#[R6]> */
		/* 822289F8h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R6 + 0x00000000) );
		/* 822289F8h case    1:*/		return 0x822289FC;
		  /* 822289FCh */ case    2:  		/* slw R10, R8, R10 */
		/* 822289FCh case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 822289FCh case    2:*/		return 0x82228A00;
		  /* 82228A00h */ case    3:  		/* slw R8, R28, R7 */
		/* 82228A00h case    3:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R28,regs.R7);
		/* 82228A00h case    3:*/		return 0x82228A04;
		  /* 82228A04h */ case    4:  		/* lwzx R4, <#[R11 + R30]> */
		/* 82228A04h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82228A04h case    4:*/		return 0x82228A08;
		  /* 82228A08h */ case    5:  		/* or R27, R8, R27 */
		/* 82228A08h case    5:*/		cpu::op::or<0>(regs,&regs.R27,regs.R8,regs.R27);
		/* 82228A08h case    5:*/		return 0x82228A0C;
		  /* 82228A0Ch */ case    6:  		/* or R10, R10, R4 */
		/* 82228A0Ch case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 82228A0Ch case    6:*/		return 0x82228A10;
		  /* 82228A10h */ case    7:  		/* stwx R10, <#[R11 + R30]> */
		/* 82228A10h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82228A10h case    7:*/		return 0x82228A14;
	}
	return 0x82228A14;
} // Block from 822289F4h-82228A14h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228A14);
		  /* 82228A14h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82228A14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82228A14h case    0:*/		return 0x82228A18;
		  /* 82228A18h */ case    1:  		/* addi R7, R7, 1 */
		/* 82228A18h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82228A18h case    1:*/		return 0x82228A1C;
		  /* 82228A1Ch */ case    2:  		/* addi R6, R6, 8 */
		/* 82228A1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x8);
		/* 82228A1Ch case    2:*/		return 0x82228A20;
		  /* 82228A20h */ case    3:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82228A20h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82228A20h case    3:*/		return 0x82228A24;
		  /* 82228A24h */ case    4:  		/* addi R9, R9, 2 */
		/* 82228A24h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 82228A24h case    4:*/		return 0x82228A28;
		  /* 82228A28h */ case    5:  		/* cmplw CR6, R7, R11 */
		/* 82228A28h case    5:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82228A28h case    5:*/		return 0x82228A2C;
		  /* 82228A2Ch */ case    6:  		/* bc 12, CR6_LT, -204 */
		/* 82228A2Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82228960;  }
		/* 82228A2Ch case    6:*/		return 0x82228A30;
		  /* 82228A30h */ case    7:  		/* b 1968 */
		/* 82228A30h case    7:*/		return 0x822291E0;
		/* 82228A30h case    7:*/		return 0x82228A34;
		  /* 82228A34h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228A34h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228A34h case    8:*/		return 0x82228A38;
		  /* 82228A38h */ case    9:  		/* mr R5, R31 */
		/* 82228A38h case    9:*/		regs.R5 = regs.R31;
		/* 82228A38h case    9:*/		return 0x82228A3C;
		  /* 82228A3Ch */ case   10:  		/* bc 12, CR0_EQ, 1956 */
		/* 82228A3Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228A3Ch case   10:*/		return 0x82228A40;
		  /* 82228A40h */ case   11:  		/* addi R11, R1, 144 */
		/* 82228A40h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82228A40h case   11:*/		return 0x82228A44;
		  /* 82228A44h */ case   12:  		/* mr R8, R31 */
		/* 82228A44h case   12:*/		regs.R8 = regs.R31;
		/* 82228A44h case   12:*/		return 0x82228A48;
		  /* 82228A48h */ case   13:  		/* addi R9, R1, 144 */
		/* 82228A48h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x90);
		/* 82228A48h case   13:*/		return 0x82228A4C;
		  /* 82228A4Ch */ case   14:  		/* subf R4, R11, R18 */
		/* 82228A4Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R18);
		/* 82228A4Ch case   14:*/		return 0x82228A50;
		  /* 82228A50h */ case   15:  		/* rlwinm R11, R5, 29, 3, 29 */
		/* 82228A50h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R5);
		/* 82228A50h case   15:*/		return 0x82228A54;
		  /* 82228A54h */ case   16:  		/* addi R10, R1, 80 */
		/* 82228A54h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82228A54h case   16:*/		return 0x82228A58;
		  /* 82228A58h */ case   17:  		/* rlwinm R7, R5, 0, 27, 31 */
		/* 82228A58h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R5);
		/* 82228A58h case   17:*/		return 0x82228A5C;
		  /* 82228A5Ch */ case   18:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82228A5Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82228A5Ch case   18:*/		return 0x82228A60;
		  /* 82228A60h */ case   19:  		/* srw R11, R11, R7 */
		/* 82228A60h case   19:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82228A60h case   19:*/		return 0x82228A64;
		  /* 82228A64h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82228A64h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82228A64h case   20:*/		return 0x82228A68;
		  /* 82228A68h */ case   21:  		/* bc 12, CR0_EQ, 204 */
		/* 82228A68h case   21:*/		if ( regs.CR[0].eq ) { return 0x82228B34;  }
		/* 82228A68h case   21:*/		return 0x82228A6C;
		  /* 82228A6Ch */ case   22:  		/* addi R11, R5, 4 */
		/* 82228A6Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x4);
		/* 82228A6Ch case   22:*/		return 0x82228A70;
		  /* 82228A70h */ case   23:  		/* addi R10, R1, 80 */
		/* 82228A70h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82228A70h case   23:*/		return 0x82228A74;
		  /* 82228A74h */ case   24:  		/* rlwinm R7, R11, 29, 3, 29 */
		/* 82228A74h case   24:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R7,regs.R11);
		/* 82228A74h case   24:*/		return 0x82228A78;
		  /* 82228A78h */ case   25:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82228A78h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82228A78h case   25:*/		return 0x82228A7C;
		  /* 82228A7Ch */ case   26:  		/* lwzx R10, <#[R7 + R10]> */
		/* 82228A7Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82228A7Ch case   26:*/		return 0x82228A80;
		  /* 82228A80h */ case   27:  		/* srw R11, R10, R11 */
		/* 82228A80h case   27:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82228A80h case   27:*/		return 0x82228A84;
		  /* 82228A84h */ case   28:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82228A84h case   28:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82228A84h case   28:*/		return 0x82228A88;
		  /* 82228A88h */ case   29:  		/* bc 12, CR0_EQ, 172 */
		/* 82228A88h case   29:*/		if ( regs.CR[0].eq ) { return 0x82228B34;  }
		/* 82228A88h case   29:*/		return 0x82228A8C;
		  /* 82228A8Ch */ case   30:  		/* lfd FR0, <#[R9 + 32]> */
		/* 82228A8Ch case   30:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 82228A8Ch case   30:*/		return 0x82228A90;
		  /* 82228A90h */ case   31:  		/* addi R11, R8, 1 */
		/* 82228A90h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x1);
		/* 82228A90h case   31:*/		return 0x82228A94;
		  /* 82228A94h */ case   32:  		/* fctidz FR0, FR0 */
		/* 82228A94h case   32:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228A94h case   32:*/		return 0x82228A98;
		  /* 82228A98h */ case   33:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228A98h case   33:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228A98h case   33:*/		return 0x82228A9C;
		  /* 82228A9Ch */ case   34:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82228A9Ch case   34:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82228A9Ch case   34:*/		return 0x82228AA0;
		  /* 82228AA0h */ case   35:  		/* lfd FR0, <#[R9]> */
		/* 82228AA0h case   35:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000000) );
		/* 82228AA0h case   35:*/		return 0x82228AA4;
		  /* 82228AA4h */ case   36:  		/* addi R6, R1, 112 */
		/* 82228AA4h case   36:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 82228AA4h case   36:*/		return 0x82228AA8;
		  /* 82228AA8h */ case   37:  		/* rlwinm R10, R8, 29, 3, 29 */
		/* 82228AA8h case   37:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R8);
		/* 82228AA8h case   37:*/		return 0x82228AAC;
		  /* 82228AACh */ case   38:  		/* slw R7, R16, R11 */
		/* 82228AACh case   38:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R16,regs.R11);
		/* 82228AACh case   38:*/		return 0x82228AB0;
		  /* 82228AB0h */ case   39:  		/* lwzx R3, <#[R10 + R6]> */
		/* 82228AB0h case   39:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82228AB0h case   39:*/		return 0x82228AB4;
		  /* 82228AB4h */ case   40:  		/* addi R7, R7, -1 */
		/* 82228AB4h case   40:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 82228AB4h case   40:*/		return 0x82228AB8;
		  /* 82228AB8h */ case   41:  		/* rlwinm R11, R8, 0, 27, 31 */
		/* 82228AB8h case   41:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R8);
		/* 82228AB8h case   41:*/		return 0x82228ABC;
		  /* 82228ABCh */ case   42:  		/* lwz R6, <#[R1 + 92]> */
		/* 82228ABCh case   42:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228ABCh case   42:*/		return 0x82228AC0;
		  /* 82228AC0h */ case   43:  		/* and R7, R7, R3 */
		/* 82228AC0h case   43:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R3);
		/* 82228AC0h case   43:*/		return 0x82228AC4;
		  /* 82228AC4h */ case   44:  		/* slw R31, R29, R11 */
		/* 82228AC4h case   44:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R29,regs.R11);
		/* 82228AC4h case   44:*/		return 0x82228AC8;
		  /* 82228AC8h */ case   45:  		/* and R7, R7, R31 */
		/* 82228AC8h case   45:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R31);
		/* 82228AC8h case   45:*/		return 0x82228ACC;
		  /* 82228ACCh */ case   46:  		/* srw R7, R7, R11 */
		/* 82228ACCh case   46:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 82228ACCh case   46:*/		return 0x82228AD0;
		  /* 82228AD0h */ case   47:  		/* cmplwi CR6, R7, 2 */
		/* 82228AD0h case   47:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000002);
		/* 82228AD0h case   47:*/		return 0x82228AD4;
		  /* 82228AD4h */ case   48:  		/* bc 4, CR6_EQ, 36 */
		/* 82228AD4h case   48:*/		if ( !regs.CR[6].eq ) { return 0x82228AF8;  }
		/* 82228AD4h case   48:*/		return 0x82228AD8;
		  /* 82228AD8h */ case   49:  		/* fctidz FR0, FR0 */
		/* 82228AD8h case   49:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228AD8h case   49:*/		return 0x82228ADC;
		  /* 82228ADCh */ case   50:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228ADCh case   50:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228ADCh case   50:*/		return 0x82228AE0;
		  /* 82228AE0h */ case   51:  		/* lwz R3, <#[R1 + 92]> */
		/* 82228AE0h case   51:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228AE0h case   51:*/		return 0x82228AE4;
		  /* 82228AE4h */ case   52:  		/* srw R6, R3, R6 */
		/* 82228AE4h case   52:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R3,regs.R6);
		/* 82228AE4h case   52:*/		return 0x82228AE8;
		  /* 82228AE8h */ case   53:  		/* rldicl R6, R6, 0, 32 */
		/* 82228AE8h case   53:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R6,regs.R6);
		/* 82228AE8h case   53:*/		return 0x82228AEC;
		  /* 82228AECh */ case   54:  		/* std R6, <#[R1 + 104]> */
		/* 82228AECh case   54:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000068) );
		/* 82228AECh case   54:*/		return 0x82228AF0;
		  /* 82228AF0h */ case   55:  		/* lfd FR0, <#[R1 + 104]> */
		/* 82228AF0h case   55:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82228AF0h case   55:*/		return 0x82228AF4;
		  /* 82228AF4h */ case   56:  		/* b 32 */
		/* 82228AF4h case   56:*/		return 0x82228B14;
		/* 82228AF4h case   56:*/		return 0x82228AF8;
	}
	return 0x82228AF8;
} // Block from 82228A14h-82228AF8h (57 instructions)

//////////////////////////////////////////////////////
// Block at 82228AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228AF8);
		  /* 82228AF8h */ case    0:  		/* fctiwz FR0, FR0 */
		/* 82228AF8h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228AF8h case    0:*/		return 0x82228AFC;
		  /* 82228AFCh */ case    1:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228AFCh case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228AFCh case    1:*/		return 0x82228B00;
		  /* 82228B00h */ case    2:  		/* lwz R3, <#[R1 + 92]> */
		/* 82228B00h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228B00h case    2:*/		return 0x82228B04;
		  /* 82228B04h */ case    3:  		/* sraw R6, R3, R6 */
		/* 82228B04h case    3:*/		cpu::op::sraw<0>(regs,&regs.R6,regs.R3,regs.R6);
		/* 82228B04h case    3:*/		return 0x82228B08;
		  /* 82228B08h */ case    4:  		/* extsw R6, R6 */
		/* 82228B08h case    4:*/		cpu::op::extsw<0>(regs,&regs.R6,regs.R6);
		/* 82228B08h case    4:*/		return 0x82228B0C;
		  /* 82228B0Ch */ case    5:  		/* std R6, <#[R1 + 136]> */
		/* 82228B0Ch case    5:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000088) );
		/* 82228B0Ch case    5:*/		return 0x82228B10;
		  /* 82228B10h */ case    6:  		/* lfd FR0, <#[R1 + 136]> */
		/* 82228B10h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 82228B10h case    6:*/		return 0x82228B14;
	}
	return 0x82228B14;
} // Block from 82228AF8h-82228B14h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82228B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228B14);
		  /* 82228B14h */ case    0:  		/* fcfid FR0, FR0 */
		/* 82228B14h case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82228B14h case    0:*/		return 0x82228B18;
		  /* 82228B18h */ case    1:  		/* stfdx FR0, <#[R4 + R9]> */
		/* 82228B18h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 82228B18h case    1:*/		return 0x82228B1C;
		  /* 82228B1Ch */ case    2:  		/* slw R11, R7, R11 */
		/* 82228B1Ch case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82228B1Ch case    2:*/		return 0x82228B20;
		  /* 82228B20h */ case    3:  		/* slw R7, R28, R5 */
		/* 82228B20h case    3:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R28,regs.R5);
		/* 82228B20h case    3:*/		return 0x82228B24;
		  /* 82228B24h */ case    4:  		/* lwzx R6, <#[R10 + R30]> */
		/* 82228B24h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82228B24h case    4:*/		return 0x82228B28;
		  /* 82228B28h */ case    5:  		/* or R27, R7, R27 */
		/* 82228B28h case    5:*/		cpu::op::or<0>(regs,&regs.R27,regs.R7,regs.R27);
		/* 82228B28h case    5:*/		return 0x82228B2C;
		  /* 82228B2Ch */ case    6:  		/* or R11, R11, R6 */
		/* 82228B2Ch case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82228B2Ch case    6:*/		return 0x82228B30;
		  /* 82228B30h */ case    7:  		/* stwx R11, <#[R10 + R30]> */
		/* 82228B30h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82228B30h case    7:*/		return 0x82228B34;
	}
	return 0x82228B34;
} // Block from 82228B14h-82228B34h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228B34);
		  /* 82228B34h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82228B34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82228B34h case    0:*/		return 0x82228B38;
		  /* 82228B38h */ case    1:  		/* addi R5, R5, 1 */
		/* 82228B38h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82228B38h case    1:*/		return 0x82228B3C;
		  /* 82228B3Ch */ case    2:  		/* addi R9, R9, 8 */
		/* 82228B3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 82228B3Ch case    2:*/		return 0x82228B40;
		  /* 82228B40h */ case    3:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82228B40h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82228B40h case    3:*/		return 0x82228B44;
		  /* 82228B44h */ case    4:  		/* addi R8, R8, 2 */
		/* 82228B44h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x2);
		/* 82228B44h case    4:*/		return 0x82228B48;
		  /* 82228B48h */ case    5:  		/* cmplw CR6, R5, R11 */
		/* 82228B48h case    5:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82228B48h case    5:*/		return 0x82228B4C;
		  /* 82228B4Ch */ case    6:  		/* bc 12, CR6_LT, -252 */
		/* 82228B4Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82228A50;  }
		/* 82228B4Ch case    6:*/		return 0x82228B50;
		  /* 82228B50h */ case    7:  		/* b 1680 */
		/* 82228B50h case    7:*/		return 0x822291E0;
		/* 82228B50h case    7:*/		return 0x82228B54;
		  /* 82228B54h */ case    8:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228B54h case    8:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228B54h case    8:*/		return 0x82228B58;
		  /* 82228B58h */ case    9:  		/* mr R7, R31 */
		/* 82228B58h case    9:*/		regs.R7 = regs.R31;
		/* 82228B58h case    9:*/		return 0x82228B5C;
		  /* 82228B5Ch */ case   10:  		/* bc 12, CR0_EQ, 1668 */
		/* 82228B5Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228B5Ch case   10:*/		return 0x82228B60;
		  /* 82228B60h */ case   11:  		/* addi R10, R1, 176 */
		/* 82228B60h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB0);
		/* 82228B60h case   11:*/		return 0x82228B64;
		  /* 82228B64h */ case   12:  		/* mr R11, R31 */
		/* 82228B64h case   12:*/		regs.R11 = regs.R31;
		/* 82228B64h case   12:*/		return 0x82228B68;
		  /* 82228B68h */ case   13:  		/* addi R9, R1, 176 */
		/* 82228B68h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xB0);
		/* 82228B68h case   13:*/		return 0x82228B6C;
		  /* 82228B6Ch */ case   14:  		/* subf R6, R10, R18 */
		/* 82228B6Ch case   14:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R10,regs.R18);
		/* 82228B6Ch case   14:*/		return 0x82228B70;
		  /* 82228B70h */ case   15:  		/* rlwinm R10, R7, 29, 3, 29 */
		/* 82228B70h case   15:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R7);
		/* 82228B70h case   15:*/		return 0x82228B74;
		  /* 82228B74h */ case   16:  		/* addi R8, R1, 80 */
		/* 82228B74h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82228B74h case   16:*/		return 0x82228B78;
		  /* 82228B78h */ case   17:  		/* rlwinm R5, R7, 0, 27, 31 */
		/* 82228B78h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R7);
		/* 82228B78h case   17:*/		return 0x82228B7C;
		  /* 82228B7Ch */ case   18:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82228B7Ch case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82228B7Ch case   18:*/		return 0x82228B80;
		  /* 82228B80h */ case   19:  		/* srw R10, R10, R5 */
		/* 82228B80h case   19:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82228B80h case   19:*/		return 0x82228B84;
		  /* 82228B84h */ case   20:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82228B84h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82228B84h case   20:*/		return 0x82228B88;
		  /* 82228B88h */ case   21:  		/* bc 12, CR0_EQ, 220 */
		/* 82228B88h case   21:*/		if ( regs.CR[0].eq ) { return 0x82228C64;  }
		/* 82228B88h case   21:*/		return 0x82228B8C;
		  /* 82228B8Ch */ case   22:  		/* addi R10, R7, 4 */
		/* 82228B8Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0x4);
		/* 82228B8Ch case   22:*/		return 0x82228B90;
		  /* 82228B90h */ case   23:  		/* addi R8, R1, 80 */
		/* 82228B90h case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82228B90h case   23:*/		return 0x82228B94;
		  /* 82228B94h */ case   24:  		/* rlwinm R5, R10, 29, 3, 29 */
		/* 82228B94h case   24:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R5,regs.R10);
		/* 82228B94h case   24:*/		return 0x82228B98;
		  /* 82228B98h */ case   25:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82228B98h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82228B98h case   25:*/		return 0x82228B9C;
		  /* 82228B9Ch */ case   26:  		/* lwzx R8, <#[R5 + R8]> */
		/* 82228B9Ch case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 82228B9Ch case   26:*/		return 0x82228BA0;
		  /* 82228BA0h */ case   27:  		/* srw R10, R8, R10 */
		/* 82228BA0h case   27:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82228BA0h case   27:*/		return 0x82228BA4;
		  /* 82228BA4h */ case   28:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82228BA4h case   28:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82228BA4h case   28:*/		return 0x82228BA8;
		  /* 82228BA8h */ case   29:  		/* bc 12, CR0_EQ, 188 */
		/* 82228BA8h case   29:*/		if ( regs.CR[0].eq ) { return 0x82228C64;  }
		/* 82228BA8h case   29:*/		return 0x82228BAC;
		  /* 82228BACh */ case   30:  		/* lfd FR0, <#[R9 - 32]> */
		/* 82228BACh case   30:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0xFFFFFFE0) );
		/* 82228BACh case   30:*/		return 0x82228BB0;
		  /* 82228BB0h */ case   31:  		/* cmpwi CR6, R3, 7 */
		/* 82228BB0h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000007);
		/* 82228BB0h case   31:*/		return 0x82228BB4;
		  /* 82228BB4h */ case   32:  		/* fctidz FR0, FR0 */
		/* 82228BB4h case   32:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228BB4h case   32:*/		return 0x82228BB8;
		  /* 82228BB8h */ case   33:  		/* stfd FR0, <#[R1 + 104]> */
		/* 82228BB8h case   33:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82228BB8h case   33:*/		return 0x82228BBC;
		  /* 82228BBCh */ case   34:  		/* lfd FR0, <#[R9]> */
		/* 82228BBCh case   34:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000000) );
		/* 82228BBCh case   34:*/		return 0x82228BC0;
		  /* 82228BC0h */ case   35:  		/* fctidz FR0, FR0 */
		/* 82228BC0h case   35:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228BC0h case   35:*/		return 0x82228BC4;
		  /* 82228BC4h */ case   36:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228BC4h case   36:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228BC4h case   36:*/		return 0x82228BC8;
		  /* 82228BC8h */ case   37:  		/* lwz R8, <#[R1 + 92]> */
		/* 82228BC8h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228BC8h case   37:*/		return 0x82228BCC;
		  /* 82228BCCh */ case   38:  		/* lwz R10, <#[R1 + 108]> */
		/* 82228BCCh case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 82228BCCh case   38:*/		return 0x82228BD0;
		  /* 82228BD0h */ case   39:  		/* bc 12, CR6_EQ, 52 */
		/* 82228BD0h case   39:*/		if ( regs.CR[6].eq ) { return 0x82228C04;  }
		/* 82228BD0h case   39:*/		return 0x82228BD4;
		  /* 82228BD4h */ case   40:  		/* cmpwi CR6, R3, 9 */
		/* 82228BD4h case   40:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000009);
		/* 82228BD4h case   40:*/		return 0x82228BD8;
		  /* 82228BD8h */ case   41:  		/* bc 12, CR6_EQ, 36 */
		/* 82228BD8h case   41:*/		if ( regs.CR[6].eq ) { return 0x82228BFC;  }
		/* 82228BD8h case   41:*/		return 0x82228BDC;
		  /* 82228BDCh */ case   42:  		/* cmpwi CR6, R3, 10 */
		/* 82228BDCh case   42:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000000A);
		/* 82228BDCh case   42:*/		return 0x82228BE0;
		  /* 82228BE0h */ case   43:  		/* bc 12, CR6_EQ, 20 */
		/* 82228BE0h case   43:*/		if ( regs.CR[6].eq ) { return 0x82228BF4;  }
		/* 82228BE0h case   43:*/		return 0x82228BE4;
		  /* 82228BE4h */ case   44:  		/* cmpwi CR6, R3, 11 */
		/* 82228BE4h case   44:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000000B);
		/* 82228BE4h case   44:*/		return 0x82228BE8;
		  /* 82228BE8h */ case   45:  		/* bc 4, CR6_EQ, 156 */
		/* 82228BE8h case   45:*/		if ( !regs.CR[6].eq ) { return 0x82228C84;  }
		/* 82228BE8h case   45:*/		return 0x82228BEC;
		  /* 82228BECh */ case   46:  		/* xor R10, R8, R10 */
		/* 82228BECh case   46:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82228BECh case   46:*/		return 0x82228BF0;
		  /* 82228BF0h */ case   47:  		/* b 24 */
		/* 82228BF0h case   47:*/		return 0x82228C08;
		/* 82228BF0h case   47:*/		return 0x82228BF4;
	}
	return 0x82228BF4;
} // Block from 82228B34h-82228BF4h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82228BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228BF4);
		  /* 82228BF4h */ case    0:  		/* or R10, R8, R10 */
		/* 82228BF4h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82228BF4h case    0:*/		return 0x82228BF8;
		  /* 82228BF8h */ case    1:  		/* b 16 */
		/* 82228BF8h case    1:*/		return 0x82228C08;
		/* 82228BF8h case    1:*/		return 0x82228BFC;
	}
	return 0x82228BFC;
} // Block from 82228BF4h-82228BFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82228BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228BFC);
		  /* 82228BFCh */ case    0:  		/* and R10, R8, R10 */
		/* 82228BFCh case    0:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82228BFCh case    0:*/		return 0x82228C00;
		  /* 82228C00h */ case    1:  		/* b 8 */
		/* 82228C00h case    1:*/		return 0x82228C08;
		/* 82228C00h case    1:*/		return 0x82228C04;
	}
	return 0x82228C04;
} // Block from 82228BFCh-82228C04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82228C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228C04);
		  /* 82228C04h */ case    0:  		/* slw R10, R10, R8 */
		/* 82228C04h case    0:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82228C04h case    0:*/		return 0x82228C08;
	}
	return 0x82228C08;
} // Block from 82228C04h-82228C08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82228C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228C08);
		  /* 82228C08h */ case    0:  		/* rldicl R10, R10, 0, 32 */
		/* 82228C08h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82228C08h case    0:*/		return 0x82228C0C;
		  /* 82228C0Ch */ case    1:  		/* addi R8, R11, 1 */
		/* 82228C0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 82228C0Ch case    1:*/		return 0x82228C10;
		  /* 82228C10h */ case    2:  		/* std R10, <#[R1 + 136]> */
		/* 82228C10h case    2:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 82228C10h case    2:*/		return 0x82228C14;
		  /* 82228C14h */ case    3:  		/* rlwinm R5, R11, 29, 3, 29 */
		/* 82228C14h case    3:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R5,regs.R11);
		/* 82228C14h case    3:*/		return 0x82228C18;
		  /* 82228C18h */ case    4:  		/* rlwinm R10, R8, 0, 27, 31 */
		/* 82228C18h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R8);
		/* 82228C18h case    4:*/		return 0x82228C1C;
		  /* 82228C1Ch */ case    5:  		/* addi R8, R1, 112 */
		/* 82228C1Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x70);
		/* 82228C1Ch case    5:*/		return 0x82228C20;
		  /* 82228C20h */ case    6:  		/* slw R10, R16, R10 */
		/* 82228C20h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R16,regs.R10);
		/* 82228C20h case    6:*/		return 0x82228C24;
		  /* 82228C24h */ case    7:  		/* lwzx R8, <#[R5 + R8]> */
		/* 82228C24h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 82228C24h case    7:*/		return 0x82228C28;
		  /* 82228C28h */ case    8:  		/* addi R10, R10, -1 */
		/* 82228C28h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82228C28h case    8:*/		return 0x82228C2C;
		  /* 82228C2Ch */ case    9:  		/* lfd FR0, <#[R1 + 136]> */
		/* 82228C2Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 82228C2Ch case    9:*/		return 0x82228C30;
		  /* 82228C30h */ case   10:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 82228C30h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 82228C30h case   10:*/		return 0x82228C34;
		  /* 82228C34h */ case   11:  		/* fcfid FR0, FR0 */
		/* 82228C34h case   11:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82228C34h case   11:*/		return 0x82228C38;
		  /* 82228C38h */ case   12:  		/* stfdx FR0, <#[R6 + R9]> */
		/* 82228C38h case   12:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 82228C38h case   12:*/		return 0x82228C3C;
		  /* 82228C3Ch */ case   13:  		/* and R10, R10, R8 */
		/* 82228C3Ch case   13:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82228C3Ch case   13:*/		return 0x82228C40;
		  /* 82228C40h */ case   14:  		/* slw R8, R29, R4 */
		/* 82228C40h case   14:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R29,regs.R4);
		/* 82228C40h case   14:*/		return 0x82228C44;
		  /* 82228C44h */ case   15:  		/* and R10, R10, R8 */
		/* 82228C44h case   15:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82228C44h case   15:*/		return 0x82228C48;
		  /* 82228C48h */ case   16:  		/* slw R8, R28, R7 */
		/* 82228C48h case   16:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R28,regs.R7);
		/* 82228C48h case   16:*/		return 0x82228C4C;
		  /* 82228C4Ch */ case   17:  		/* srw R10, R10, R4 */
		/* 82228C4Ch case   17:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 82228C4Ch case   17:*/		return 0x82228C50;
		  /* 82228C50h */ case   18:  		/* lwzx R31, <#[R5 + R30]> */
		/* 82228C50h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + regs.R30 + 0x00000000) );
		/* 82228C50h case   18:*/		return 0x82228C54;
		  /* 82228C54h */ case   19:  		/* slw R10, R10, R4 */
		/* 82228C54h case   19:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 82228C54h case   19:*/		return 0x82228C58;
		  /* 82228C58h */ case   20:  		/* or R10, R10, R31 */
		/* 82228C58h case   20:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82228C58h case   20:*/		return 0x82228C5C;
		  /* 82228C5Ch */ case   21:  		/* or R27, R8, R27 */
		/* 82228C5Ch case   21:*/		cpu::op::or<0>(regs,&regs.R27,regs.R8,regs.R27);
		/* 82228C5Ch case   21:*/		return 0x82228C60;
		  /* 82228C60h */ case   22:  		/* stwx R10, <#[R5 + R30]> */
		/* 82228C60h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + regs.R30 + 0x00000000) );
		/* 82228C60h case   22:*/		return 0x82228C64;
	}
	return 0x82228C64;
} // Block from 82228C08h-82228C64h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82228C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228C64);
		  /* 82228C64h */ case    0:  		/* lwz R10, <#[R14 + 8]> */
		/* 82228C64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82228C64h case    0:*/		return 0x82228C68;
		  /* 82228C68h */ case    1:  		/* addi R7, R7, 1 */
		/* 82228C68h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82228C68h case    1:*/		return 0x82228C6C;
		  /* 82228C6Ch */ case    2:  		/* addi R9, R9, 8 */
		/* 82228C6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 82228C6Ch case    2:*/		return 0x82228C70;
		  /* 82228C70h */ case    3:  		/* rlwinm R10, R10, 18, 29, 31 */
		/* 82228C70h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R10);
		/* 82228C70h case    3:*/		return 0x82228C74;
		  /* 82228C74h */ case    4:  		/* addi R11, R11, 2 */
		/* 82228C74h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82228C74h case    4:*/		return 0x82228C78;
		  /* 82228C78h */ case    5:  		/* cmplw CR6, R7, R10 */
		/* 82228C78h case    5:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82228C78h case    5:*/		return 0x82228C7C;
		  /* 82228C7Ch */ case    6:  		/* bc 12, CR6_LT, -268 */
		/* 82228C7Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82228B70;  }
		/* 82228C7Ch case    6:*/		return 0x82228C80;
		  /* 82228C80h */ case    7:  		/* b 1376 */
		/* 82228C80h case    7:*/		return 0x822291E0;
		/* 82228C80h case    7:*/		return 0x82228C84;
	}
	return 0x82228C84;
} // Block from 82228C64h-82228C84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228C84);
		  /* 82228C84h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 82228C84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82228C84h case    0:*/		return 0x82228C88;
		  /* 82228C88h */ case    1:  		/* li R4, 4800 */
		/* 82228C88h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82228C88h case    1:*/		return 0x82228C8C;
		  /* 82228C8Ch */ case    2:  		/* lwz R3, <#[R11 + 148]> */
		/* 82228C8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82228C8Ch case    2:*/		return 0x82228C90;
		  /* 82228C90h */ case    3:  		/* bl -880168 */
		/* 82228C90h case    3:*/		regs.LR = 0x82228C94; return 0x82151E68;
		/* 82228C90h case    3:*/		return 0x82228C94;
		  /* 82228C94h */ case    4:  		/* rlwinm. R11, R26, 0, 15, 17 */
		/* 82228C94h case    4:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R26);
		/* 82228C94h case    4:*/		return 0x82228C98;
		  /* 82228C98h */ case    5:  		/* mr R5, R31 */
		/* 82228C98h case    5:*/		regs.R5 = regs.R31;
		/* 82228C98h case    5:*/		return 0x82228C9C;
		  /* 82228C9Ch */ case    6:  		/* bc 12, CR0_EQ, 1348 */
		/* 82228C9Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228C9Ch case    6:*/		return 0x82228CA0;
		  /* 82228CA0h */ case    7:  		/* addi R11, R1, 144 */
		/* 82228CA0h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82228CA0h case    7:*/		return 0x82228CA4;
		  /* 82228CA4h */ case    8:  		/* mr R7, R31 */
		/* 82228CA4h case    8:*/		regs.R7 = regs.R31;
		/* 82228CA4h case    8:*/		return 0x82228CA8;
		  /* 82228CA8h */ case    9:  		/* mr R10, R18 */
		/* 82228CA8h case    9:*/		regs.R10 = regs.R18;
		/* 82228CA8h case    9:*/		return 0x82228CAC;
		  /* 82228CACh */ case   10:  		/* subf R6, R18, R11 */
		/* 82228CACh case   10:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R18,regs.R11);
		/* 82228CACh case   10:*/		return 0x82228CB0;
		  /* 82228CB0h */ case   11:  		/* rlwinm R11, R5, 29, 3, 29 */
		/* 82228CB0h case   11:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R5);
		/* 82228CB0h case   11:*/		return 0x82228CB4;
		  /* 82228CB4h */ case   12:  		/* addi R9, R1, 80 */
		/* 82228CB4h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 82228CB4h case   12:*/		return 0x82228CB8;
		  /* 82228CB8h */ case   13:  		/* rlwinm R8, R5, 0, 27, 31 */
		/* 82228CB8h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R5);
		/* 82228CB8h case   13:*/		return 0x82228CBC;
		  /* 82228CBCh */ case   14:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82228CBCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82228CBCh case   14:*/		return 0x82228CC0;
		  /* 82228CC0h */ case   15:  		/* srw R11, R11, R8 */
		/* 82228CC0h case   15:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82228CC0h case   15:*/		return 0x82228CC4;
		  /* 82228CC4h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82228CC4h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82228CC4h case   16:*/		return 0x82228CC8;
		  /* 82228CC8h */ case   17:  		/* bc 12, CR0_EQ, 228 */
		/* 82228CC8h case   17:*/		if ( regs.CR[0].eq ) { return 0x82228DAC;  }
		/* 82228CC8h case   17:*/		return 0x82228CCC;
		  /* 82228CCCh */ case   18:  		/* addi R9, R7, 1 */
		/* 82228CCCh case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x1);
		/* 82228CCCh case   18:*/		return 0x82228CD0;
		  /* 82228CD0h */ case   19:  		/* rlwinm R11, R7, 29, 3, 29 */
		/* 82228CD0h case   19:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R7);
		/* 82228CD0h case   19:*/		return 0x82228CD4;
		  /* 82228CD4h */ case   20:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82228CD4h case   20:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82228CD4h case   20:*/		return 0x82228CD8;
		  /* 82228CD8h */ case   21:  		/* addi R4, R1, 112 */
		/* 82228CD8h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 82228CD8h case   21:*/		return 0x82228CDC;
		  /* 82228CDCh */ case   22:  		/* slw R8, R16, R9 */
		/* 82228CDCh case   22:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R16,regs.R9);
		/* 82228CDCh case   22:*/		return 0x82228CE0;
		  /* 82228CE0h */ case   23:  		/* lwzx R4, <#[R11 + R4]> */
		/* 82228CE0h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82228CE0h case   23:*/		return 0x82228CE4;
		  /* 82228CE4h */ case   24:  		/* addi R8, R8, -1 */
		/* 82228CE4h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82228CE4h case   24:*/		return 0x82228CE8;
		  /* 82228CE8h */ case   25:  		/* rlwinm R9, R7, 0, 27, 31 */
		/* 82228CE8h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R7);
		/* 82228CE8h case   25:*/		return 0x82228CEC;
		  /* 82228CECh */ case   26:  		/* and R8, R8, R4 */
		/* 82228CECh case   26:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R4);
		/* 82228CECh case   26:*/		return 0x82228CF0;
		  /* 82228CF0h */ case   27:  		/* slw R26, R29, R9 */
		/* 82228CF0h case   27:*/		cpu::op::slw<0>(regs,&regs.R26,regs.R29,regs.R9);
		/* 82228CF0h case   27:*/		return 0x82228CF4;
		  /* 82228CF4h */ case   28:  		/* and R8, R8, R26 */
		/* 82228CF4h case   28:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R26);
		/* 82228CF4h case   28:*/		return 0x82228CF8;
		  /* 82228CF8h */ case   29:  		/* srw R8, R8, R9 */
		/* 82228CF8h case   29:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 82228CF8h case   29:*/		return 0x82228CFC;
		  /* 82228CFCh */ case   30:  		/* cmplwi CR6, R8, 1 */
		/* 82228CFCh case   30:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 82228CFCh case   30:*/		return 0x82228D00;
		  /* 82228D00h */ case   31:  		/* bc 12, CR6_LT, 60 */
		/* 82228D00h case   31:*/		if ( regs.CR[6].lt ) { return 0x82228D3C;  }
		/* 82228D00h case   31:*/		return 0x82228D04;
		  /* 82228D04h */ case   32:  		/* bc 12, CR6_EQ, 32 */
		/* 82228D04h case   32:*/		if ( regs.CR[6].eq ) { return 0x82228D24;  }
		/* 82228D04h case   32:*/		return 0x82228D08;
		  /* 82228D08h */ case   33:  		/* cmplwi CR6, R8, 3 */
		/* 82228D08h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000003);
		/* 82228D08h case   33:*/		return 0x82228D0C;
		  /* 82228D0Ch */ case   34:  		/* bc 4, CR6_LT, 192 */
		/* 82228D0Ch case   34:*/		if ( !regs.CR[6].lt ) { return 0x82228DCC;  }
		/* 82228D0Ch case   34:*/		return 0x82228D10;
		  /* 82228D10h */ case   35:  		/* lfdx FR0, <#[R6 + R10]> */
		/* 82228D10h case   35:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82228D10h case   35:*/		return 0x82228D14;
		  /* 82228D14h */ case   36:  		/* fctidz FR0, FR0 */
		/* 82228D14h case   36:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228D14h case   36:*/		return 0x82228D18;
		  /* 82228D18h */ case   37:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228D18h case   37:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228D18h case   37:*/		return 0x82228D1C;
		  /* 82228D1Ch */ case   38:  		/* lwz R8, <#[R1 + 92]> */
		/* 82228D1Ch case   38:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228D1Ch case   38:*/		return 0x82228D20;
		  /* 82228D20h */ case   39:  		/* b 20 */
		/* 82228D20h case   39:*/		return 0x82228D34;
		/* 82228D20h case   39:*/		return 0x82228D24;
	}
	return 0x82228D24;
} // Block from 82228C84h-82228D24h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82228D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228D24);
		  /* 82228D24h */ case    0:  		/* lfdx FR0, <#[R6 + R10]> */
		/* 82228D24h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82228D24h case    0:*/		return 0x82228D28;
		  /* 82228D28h */ case    1:  		/* fctiwz FR0, FR0 */
		/* 82228D28h case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82228D28h case    1:*/		return 0x82228D2C;
		  /* 82228D2Ch */ case    2:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82228D2Ch case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82228D2Ch case    2:*/		return 0x82228D30;
		  /* 82228D30h */ case    3:  		/* lwz R8, <#[R1 + 92]> */
		/* 82228D30h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 82228D30h case    3:*/		return 0x82228D34;
	}
	return 0x82228D34;
} // Block from 82228D24h-82228D34h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82228D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228D34);
		  /* 82228D34h */ case    0:  		/* stw R8, <#[R1 + 96]> */
		/* 82228D34h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82228D34h case    0:*/		return 0x82228D38;
		  /* 82228D38h */ case    1:  		/* b 20 */
		/* 82228D38h case    1:*/		return 0x82228D4C;
		/* 82228D38h case    1:*/		return 0x82228D3C;
	}
	return 0x82228D3C;
} // Block from 82228D34h-82228D3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82228D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228D3C);
		  /* 82228D3Ch */ case    0:  		/* lfdx FR0, <#[R6 + R10]> */
		/* 82228D3Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82228D3Ch case    0:*/		return 0x82228D40;
		  /* 82228D40h */ case    1:  		/* frsp FR0, FR0 */
		/* 82228D40h case    1:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82228D40h case    1:*/		return 0x82228D44;
		  /* 82228D44h */ case    2:  		/* stfs FR0, <#[R1 + 96]> */
		/* 82228D44h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82228D44h case    2:*/		return 0x82228D48;
		  /* 82228D48h */ case    3:  		/* lwz R8, <#[R1 + 96]> */
		/* 82228D48h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82228D48h case    3:*/		return 0x82228D4C;
	}
	return 0x82228D4C;
} // Block from 82228D3Ch-82228D4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82228D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228D4C);
		  /* 82228D4Ch */ case    0:  		/* cmpwi CR6, R3, 12 */
		/* 82228D4Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000000C);
		/* 82228D4Ch case    0:*/		return 0x82228D50;
		  /* 82228D50h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82228D50h case    1:*/		if ( regs.CR[6].eq ) { return 0x82228D94;  }
		/* 82228D50h case    1:*/		return 0x82228D54;
		  /* 82228D54h */ case    2:  		/* cmpwi CR6, R3, 13 */
		/* 82228D54h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000000D);
		/* 82228D54h case    2:*/		return 0x82228D58;
		  /* 82228D58h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82228D58h case    3:*/		if ( regs.CR[6].eq ) { return 0x82228D80;  }
		/* 82228D58h case    3:*/		return 0x82228D5C;
		  /* 82228D5Ch */ case    4:  		/* cmpwi CR6, R3, 14 */
		/* 82228D5Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000000E);
		/* 82228D5Ch case    4:*/		return 0x82228D60;
		  /* 82228D60h */ case    5:  		/* bc 4, CR6_EQ, 124 */
		/* 82228D60h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82228DDC;  }
		/* 82228D60h case    5:*/		return 0x82228D64;
		  /* 82228D64h */ case    6:  		/* rldicl R8, R8, 0, 32 */
		/* 82228D64h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R8);
		/* 82228D64h case    6:*/		return 0x82228D68;
		  /* 82228D68h */ case    7:  		/* slw R9, R16, R9 */
		/* 82228D68h case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R16,regs.R9);
		/* 82228D68h case    7:*/		return 0x82228D6C;
		  /* 82228D6Ch */ case    8:  		/* std R8, <#[R1 + 104]> */
		/* 82228D6Ch case    8:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 82228D6Ch case    8:*/		return 0x82228D70;
		  /* 82228D70h */ case    9:  		/* lfd FR0, <#[R1 + 104]> */
		/* 82228D70h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82228D70h case    9:*/		return 0x82228D74;
		  /* 82228D74h */ case   10:  		/* fcfid FR0, FR0 */
		/* 82228D74h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82228D74h case   10:*/		return 0x82228D78;
		  /* 82228D78h */ case   11:  		/* stfd FR0, <#[R10]> */
		/* 82228D78h case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 82228D78h case   11:*/		return 0x82228D7C;
		  /* 82228D7Ch */ case   12:  		/* b 36 */
		/* 82228D7Ch case   12:*/		return 0x82228DA0;
		/* 82228D7Ch case   12:*/		return 0x82228D80;
	}
	return 0x82228D80;
} // Block from 82228D4Ch-82228D80h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82228D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228D80);
		  /* 82228D80h */ case    0:  		/* extsw R8, R8 */
		/* 82228D80h case    0:*/		cpu::op::extsw<0>(regs,&regs.R8,regs.R8);
		/* 82228D80h case    0:*/		return 0x82228D84;
		  /* 82228D84h */ case    1:  		/* slw R9, R28, R9 */
		/* 82228D84h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R28,regs.R9);
		/* 82228D84h case    1:*/		return 0x82228D88;
		  /* 82228D88h */ case    2:  		/* std R8, <#[R1 + 136]> */
		/* 82228D88h case    2:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000088) );
		/* 82228D88h case    2:*/		return 0x82228D8C;
		  /* 82228D8Ch */ case    3:  		/* lfd FR0, <#[R1 + 136]> */
		/* 82228D8Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 82228D8Ch case    3:*/		return 0x82228D90;
		  /* 82228D90h */ case    4:  		/* b -28 */
		/* 82228D90h case    4:*/		return 0x82228D74;
		/* 82228D90h case    4:*/		return 0x82228D94;
	}
	return 0x82228D94;
} // Block from 82228D80h-82228D94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82228D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228D94);
		  /* 82228D94h */ case    0:  		/* lfs FR0, <#[R1 + 96]> */
		/* 82228D94h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82228D94h case    0:*/		return 0x82228D98;
		  /* 82228D98h */ case    1:  		/* slw R9, R31, R9 */
		/* 82228D98h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 82228D98h case    1:*/		return 0x82228D9C;
		  /* 82228D9Ch */ case    2:  		/* stfd FR0, <#[R10]> */
		/* 82228D9Ch case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 82228D9Ch case    2:*/		return 0x82228DA0;
	}
	return 0x82228DA0;
} // Block from 82228D94h-82228DA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82228DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228DA0);
		  /* 82228DA0h */ case    0:  		/* lwzx R8, <#[R11 + R30]> */
		/* 82228DA0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82228DA0h case    0:*/		return 0x82228DA4;
		  /* 82228DA4h */ case    1:  		/* or R9, R9, R8 */
		/* 82228DA4h case    1:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82228DA4h case    1:*/		return 0x82228DA8;
		  /* 82228DA8h */ case    2:  		/* stwx R9, <#[R11 + R30]> */
		/* 82228DA8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82228DA8h case    2:*/		return 0x82228DAC;
	}
	return 0x82228DAC;
} // Block from 82228DA0h-82228DACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82228DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228DAC);
		  /* 82228DACh */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82228DACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82228DACh case    0:*/		return 0x82228DB0;
		  /* 82228DB0h */ case    1:  		/* addi R5, R5, 1 */
		/* 82228DB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82228DB0h case    1:*/		return 0x82228DB4;
		  /* 82228DB4h */ case    2:  		/* addi R10, R10, 8 */
		/* 82228DB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82228DB4h case    2:*/		return 0x82228DB8;
		  /* 82228DB8h */ case    3:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82228DB8h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82228DB8h case    3:*/		return 0x82228DBC;
		  /* 82228DBCh */ case    4:  		/* addi R7, R7, 2 */
		/* 82228DBCh case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x2);
		/* 82228DBCh case    4:*/		return 0x82228DC0;
		  /* 82228DC0h */ case    5:  		/* cmplw CR6, R5, R11 */
		/* 82228DC0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82228DC0h case    5:*/		return 0x82228DC4;
		  /* 82228DC4h */ case    6:  		/* bc 12, CR6_LT, -276 */
		/* 82228DC4h case    6:*/		if ( regs.CR[6].lt ) { return 0x82228CB0;  }
		/* 82228DC4h case    6:*/		return 0x82228DC8;
		  /* 82228DC8h */ case    7:  		/* b 1048 */
		/* 82228DC8h case    7:*/		return 0x822291E0;
		/* 82228DC8h case    7:*/		return 0x82228DCC;
	}
	return 0x82228DCC;
} // Block from 82228DACh-82228DCCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82228DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228DCC);
		  /* 82228DCCh */ case    0:  		/* lwz R11, <#[R25]> */
		/* 82228DCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82228DCCh case    0:*/		return 0x82228DD0;
		  /* 82228DD0h */ case    1:  		/* li R4, 4800 */
		/* 82228DD0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82228DD0h case    1:*/		return 0x82228DD4;
		  /* 82228DD4h */ case    2:  		/* lwz R3, <#[R11 + 148]> */
		/* 82228DD4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82228DD4h case    2:*/		return 0x82228DD8;
		  /* 82228DD8h */ case    3:  		/* bl -880496 */
		/* 82228DD8h case    3:*/		regs.LR = 0x82228DDC; return 0x82151E68;
		/* 82228DD8h case    3:*/		return 0x82228DDC;
	}
	return 0x82228DDC;
} // Block from 82228DCCh-82228DDCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82228DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228DDC);
		  /* 82228DDCh */ case    0:  		/* lwz R11, <#[R25]> */
		/* 82228DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82228DDCh case    0:*/		return 0x82228DE0;
		  /* 82228DE0h */ case    1:  		/* li R4, 4800 */
		/* 82228DE0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82228DE0h case    1:*/		return 0x82228DE4;
		  /* 82228DE4h */ case    2:  		/* lwz R3, <#[R11 + 148]> */
		/* 82228DE4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82228DE4h case    2:*/		return 0x82228DE8;
		  /* 82228DE8h */ case    3:  		/* bl -880512 */
		/* 82228DE8h case    3:*/		regs.LR = 0x82228DEC; return 0x82151E68;
		/* 82228DE8h case    3:*/		return 0x82228DEC;
	}
	return 0x82228DEC;
} // Block from 82228DDCh-82228DECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82228DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228DEC);
		  /* 82228DECh */ case    0:  		/* mr R9, R16 */
		/* 82228DECh case    0:*/		regs.R9 = regs.R16;
		/* 82228DECh case    0:*/		return 0x82228DF0;
		  /* 82228DF0h */ case    1:  		/* mtspr CTR, R16 */
		/* 82228DF0h case    1:*/		regs.CTR = regs.R16;
		/* 82228DF0h case    1:*/		return 0x82228DF4;
		  /* 82228DF4h */ case    2:  		/* lis R9, -32256 */
		/* 82228DF4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82228DF4h case    2:*/		return 0x82228DF8;
		  /* 82228DF8h */ case    3:  		/* mr R8, R31 */
		/* 82228DF8h case    3:*/		regs.R8 = regs.R31;
		/* 82228DF8h case    3:*/		return 0x82228DFC;
		  /* 82228DFCh */ case    4:  		/* mr R10, R31 */
		/* 82228DFCh case    4:*/		regs.R10 = regs.R31;
		/* 82228DFCh case    4:*/		return 0x82228E00;
		  /* 82228E00h */ case    5:  		/* mr R11, R18 */
		/* 82228E00h case    5:*/		regs.R11 = regs.R18;
		/* 82228E00h case    5:*/		return 0x82228E04;
		  /* 82228E04h */ case    6:  		/* lfd FR0, <#[R9 + 1808]> */
		/* 82228E04h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000710) );
		/* 82228E04h case    6:*/		return 0x82228E08;
		  /* 82228E08h */ case    7:  		/* rlwinm R9, R8, 29, 3, 29 */
		/* 82228E08h case    7:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R8);
		/* 82228E08h case    7:*/		return 0x82228E0C;
		  /* 82228E0Ch */ case    8:  		/* addi R7, R1, 80 */
		/* 82228E0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82228E0Ch case    8:*/		return 0x82228E10;
		  /* 82228E10h */ case    9:  		/* rlwinm R6, R8, 0, 27, 31 */
		/* 82228E10h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R8);
		/* 82228E10h case    9:*/		return 0x82228E14;
		  /* 82228E14h */ case   10:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82228E14h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82228E14h case   10:*/		return 0x82228E18;
		  /* 82228E18h */ case   11:  		/* srw R9, R9, R6 */
		/* 82228E18h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82228E18h case   11:*/		return 0x82228E1C;
		  /* 82228E1Ch */ case   12:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82228E1Ch case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82228E1Ch case   12:*/		return 0x82228E20;
		  /* 82228E20h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82228E20h case   13:*/		if ( regs.CR[0].eq ) { return 0x82228E38;  }
		/* 82228E20h case   13:*/		return 0x82228E24;
		  /* 82228E24h */ case   14:  		/* li R9, 3 */
		/* 82228E24h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 82228E24h case   14:*/		return 0x82228E28;
		  /* 82228E28h */ case   15:  		/* stfd FR0, <#[R11]> */
		/* 82228E28h case   15:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82228E28h case   15:*/		return 0x82228E2C;
		  /* 82228E2Ch */ case   16:  		/* stfd FR0, <#[R11 + 8]> */
		/* 82228E2Ch case   16:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 82228E2Ch case   16:*/		return 0x82228E30;
		  /* 82228E30h */ case   17:  		/* slw R9, R9, R10 */
		/* 82228E30h case   17:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82228E30h case   17:*/		return 0x82228E34;
		  /* 82228E34h */ case   18:  		/* or R27, R9, R27 */
		/* 82228E34h case   18:*/		cpu::op::or<0>(regs,&regs.R27,regs.R9,regs.R27);
		/* 82228E34h case   18:*/		return 0x82228E38;
	}
	return 0x82228E38;
} // Block from 82228DECh-82228E38h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82228E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228E38);
		  /* 82228E38h */ case    0:  		/* addi R8, R8, 1 */
		/* 82228E38h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82228E38h case    0:*/		return 0x82228E3C;
		  /* 82228E3Ch */ case    1:  		/* addi R11, R11, 16 */
		/* 82228E3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82228E3Ch case    1:*/		return 0x82228E40;
		  /* 82228E40h */ case    2:  		/* addi R10, R10, 2 */
		/* 82228E40h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82228E40h case    2:*/		return 0x82228E44;
		  /* 82228E44h */ case    3:  		/* bc 16, CR0_LT, -60 */
		/* 82228E44h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82228E08;  }
		/* 82228E44h case    3:*/		return 0x82228E48;
		  /* 82228E48h */ case    4:  		/* b 920 */
		/* 82228E48h case    4:*/		return 0x822291E0;
		/* 82228E48h case    4:*/		return 0x82228E4C;
	}
	return 0x82228E4C;
} // Block from 82228E38h-82228E4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82228E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228E4C);
		  /* 82228E4Ch */ case    0:  		/* rlwinm R11, R14, 0, 0, 19 */
		/* 82228E4Ch case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R14);
		/* 82228E4Ch case    0:*/		return 0x82228E50;
		  /* 82228E50h */ case    1:  		/* mr R3, R14 */
		/* 82228E50h case    1:*/		regs.R3 = regs.R14;
		/* 82228E50h case    1:*/		return 0x82228E54;
		  /* 82228E54h */ case    2:  		/* lwz R31, <#[R11]> */
		/* 82228E54h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82228E54h case    2:*/		return 0x82228E58;
		  /* 82228E58h */ case    3:  		/* lwz R30, <#[R31 + 148]> */
		/* 82228E58h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000094) );
		/* 82228E58h case    3:*/		return 0x82228E5C;
		  /* 82228E5Ch */ case    4:  		/* mr R4, R30 */
		/* 82228E5Ch case    4:*/		regs.R4 = regs.R30;
		/* 82228E5Ch case    4:*/		return 0x82228E60;
		  /* 82228E60h */ case    5:  		/* bl -724744 */
		/* 82228E60h case    5:*/		regs.LR = 0x82228E64; return 0x82177F58;
		/* 82228E60h case    5:*/		return 0x82228E64;
		  /* 82228E64h */ case    6:  		/* lwz R11, <#[R30 + 40]> */
		/* 82228E64h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 82228E64h case    6:*/		return 0x82228E68;
		  /* 82228E68h */ case    7:  		/* lwz R10, <#[R3 + 12]> */
		/* 82228E68h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82228E68h case    7:*/		return 0x82228E6C;
		  /* 82228E6Ch */ case    8:  		/* nor R11, R11, R11 */
		/* 82228E6Ch case    8:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82228E6Ch case    8:*/		return 0x82228E70;
		  /* 82228E70h */ case    9:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 82228E70h case    9:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 82228E70h case    9:*/		return 0x82228E74;
		  /* 82228E74h */ case   10:  		/* rlwinm R11, R10, 28, 28, 31 */
		/* 82228E74h case   10:*/		cpu::op::rlwinm<0,28,28,31>(regs,&regs.R11,regs.R10);
		/* 82228E74h case   10:*/		return 0x82228E78;
		  /* 82228E78h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 82228E78h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82228E88;  }
		/* 82228E78h case   11:*/		return 0x82228E7C;
		  /* 82228E7Ch */ case   12:  		/* rlwinm R10, R26, 31, 1, 31 */
		/* 82228E7Ch case   12:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R26);
		/* 82228E7Ch case   12:*/		return 0x82228E80;
		  /* 82228E80h */ case   13:  		/* and R11, R10, R11 */
		/* 82228E80h case   13:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82228E80h case   13:*/		return 0x82228E84;
		  /* 82228E84h */ case   14:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82228E84h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82228E84h case   14:*/		return 0x82228E88;
	}
	return 0x82228E88;
} // Block from 82228E4Ch-82228E88h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82228E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228E88);
		  /* 82228E88h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82228E88h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82228E88h case    0:*/		return 0x82228E8C;
		  /* 82228E8Ch */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82228E8Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82228EAC;  }
		/* 82228E8Ch case    1:*/		return 0x82228E90;
		  /* 82228E90h */ case    2:  		/* cntlzw R10, R11 */
		/* 82228E90h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 82228E90h case    2:*/		return 0x82228E94;
		  /* 82228E94h */ case    3:  		/* lis R9, -32256 */
		/* 82228E94h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82228E94h case    3:*/		return 0x82228E98;
		  /* 82228E98h */ case    4:  		/* subfic R10, R10, 31 */
		/* 82228E98h case    4:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 82228E98h case    4:*/		return 0x82228E9C;
		  /* 82228E9Ch */ case    5:  		/* mr R27, R11 */
		/* 82228E9Ch case    5:*/		regs.R27 = regs.R11;
		/* 82228E9Ch case    5:*/		return 0x82228EA0;
		  /* 82228EA0h */ case    6:  		/* rlwinm R11, R10, 3, 0, 28 */
		/* 82228EA0h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R10);
		/* 82228EA0h case    6:*/		return 0x82228EA4;
		  /* 82228EA4h */ case    7:  		/* lfd FR0, <#[R9 + 1848]> */
		/* 82228EA4h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000738) );
		/* 82228EA4h case    7:*/		return 0x82228EA8;
		  /* 82228EA8h */ case    8:  		/* stfdx FR0, <#[R11 + R18]> */
		/* 82228EA8h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82228EA8h case    8:*/		return 0x82228EAC;
	}
	return 0x82228EAC;
} // Block from 82228E88h-82228EACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82228EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228EAC);
		  /* 82228EACh */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 82228EACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82228EACh case    0:*/		return 0x82228EB0;
		  /* 82228EB0h */ case    1:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82228EB0h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82228EB0h case    1:*/		return 0x82228EB4;
		  /* 82228EB4h */ case    2:  		/* b 108 */
		/* 82228EB4h case    2:*/		return 0x82228F20;
		/* 82228EB4h case    2:*/		return 0x82228EB8;
	}
	return 0x82228EB8;
} // Block from 82228EACh-82228EB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82228EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228EB8);
		  /* 82228EB8h */ case    0:  		/* rlwinm R11, R14, 0, 0, 19 */
		/* 82228EB8h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R14);
		/* 82228EB8h case    0:*/		return 0x82228EBC;
		  /* 82228EBCh */ case    1:  		/* mr R3, R14 */
		/* 82228EBCh case    1:*/		regs.R3 = regs.R14;
		/* 82228EBCh case    1:*/		return 0x82228EC0;
		  /* 82228EC0h */ case    2:  		/* lwz R31, <#[R11]> */
		/* 82228EC0h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82228EC0h case    2:*/		return 0x82228EC4;
		  /* 82228EC4h */ case    3:  		/* lwz R30, <#[R31 + 148]> */
		/* 82228EC4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000094) );
		/* 82228EC4h case    3:*/		return 0x82228EC8;
		  /* 82228EC8h */ case    4:  		/* mr R4, R30 */
		/* 82228EC8h case    4:*/		regs.R4 = regs.R30;
		/* 82228EC8h case    4:*/		return 0x82228ECC;
		  /* 82228ECCh */ case    5:  		/* bl -804820 */
		/* 82228ECCh case    5:*/		regs.LR = 0x82228ED0; return 0x821646F8;
		/* 82228ECCh case    5:*/		return 0x82228ED0;
		  /* 82228ED0h */ case    6:  		/* lwz R11, <#[R30 + 40]> */
		/* 82228ED0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 82228ED0h case    6:*/		return 0x82228ED4;
		  /* 82228ED4h */ case    7:  		/* lwz R10, <#[R3 + 12]> */
		/* 82228ED4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82228ED4h case    7:*/		return 0x82228ED8;
		  /* 82228ED8h */ case    8:  		/* nor R11, R11, R11 */
		/* 82228ED8h case    8:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82228ED8h case    8:*/		return 0x82228EDC;
		  /* 82228EDCh */ case    9:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 82228EDCh case    9:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 82228EDCh case    9:*/		return 0x82228EE0;
		  /* 82228EE0h */ case   10:  		/* rlwinm R11, R10, 20, 28, 31 */
		/* 82228EE0h case   10:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R10);
		/* 82228EE0h case   10:*/		return 0x82228EE4;
		  /* 82228EE4h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 82228EE4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82228EF4;  }
		/* 82228EE4h case   11:*/		return 0x82228EE8;
		  /* 82228EE8h */ case   12:  		/* rlwinm R10, R26, 31, 1, 31 */
		/* 82228EE8h case   12:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R26);
		/* 82228EE8h case   12:*/		return 0x82228EEC;
		  /* 82228EECh */ case   13:  		/* and R11, R10, R11 */
		/* 82228EECh case   13:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82228EECh case   13:*/		return 0x82228EF0;
		  /* 82228EF0h */ case   14:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82228EF0h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82228EF0h case   14:*/		return 0x82228EF4;
	}
	return 0x82228EF4;
} // Block from 82228EB8h-82228EF4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82228EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228EF4);
		  /* 82228EF4h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82228EF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82228EF4h case    0:*/		return 0x82228EF8;
		  /* 82228EF8h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82228EF8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82228F18;  }
		/* 82228EF8h case    1:*/		return 0x82228EFC;
		  /* 82228EFCh */ case    2:  		/* cntlzw R10, R11 */
		/* 82228EFCh case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 82228EFCh case    2:*/		return 0x82228F00;
		  /* 82228F00h */ case    3:  		/* lis R9, -32256 */
		/* 82228F00h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82228F00h case    3:*/		return 0x82228F04;
		  /* 82228F04h */ case    4:  		/* subfic R10, R10, 31 */
		/* 82228F04h case    4:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 82228F04h case    4:*/		return 0x82228F08;
		  /* 82228F08h */ case    5:  		/* mr R27, R11 */
		/* 82228F08h case    5:*/		regs.R27 = regs.R11;
		/* 82228F08h case    5:*/		return 0x82228F0C;
		  /* 82228F0Ch */ case    6:  		/* rlwinm R11, R10, 3, 0, 28 */
		/* 82228F0Ch case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R10);
		/* 82228F0Ch case    6:*/		return 0x82228F10;
		  /* 82228F10h */ case    7:  		/* lfd FR0, <#[R9 + 1848]> */
		/* 82228F10h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000738) );
		/* 82228F10h case    7:*/		return 0x82228F14;
		  /* 82228F14h */ case    8:  		/* stfdx FR0, <#[R11 + R18]> */
		/* 82228F14h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82228F14h case    8:*/		return 0x82228F18;
	}
	return 0x82228F18;
} // Block from 82228EF4h-82228F18h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82228F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228F18);
		  /* 82228F18h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 82228F18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82228F18h case    0:*/		return 0x82228F1C;
		  /* 82228F1Ch */ case    1:  		/* rlwinm R11, R11, 24, 28, 31 */
		/* 82228F1Ch case    1:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R11,regs.R11);
		/* 82228F1Ch case    1:*/		return 0x82228F20;
	}
	return 0x82228F20;
} // Block from 82228F18h-82228F20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82228F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228F20);
		  /* 82228F20h */ case    0:  		/* lwz R10, <#[R31 + 148]> */
		/* 82228F20h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000094) );
		/* 82228F20h case    0:*/		return 0x82228F24;
		  /* 82228F24h */ case    1:  		/* lwz R10, <#[R10 + 40]> */
		/* 82228F24h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 82228F24h case    1:*/		return 0x82228F28;
		  /* 82228F28h */ case    2:  		/* nor R10, R10, R10 */
		/* 82228F28h case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82228F28h case    2:*/		return 0x82228F2C;
		  /* 82228F2Ch */ case    3:  		/* rlwinm. R10, R10, 18, 31, 31 */
		/* 82228F2Ch case    3:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R10,regs.R10);
		/* 82228F2Ch case    3:*/		return 0x82228F30;
		  /* 82228F30h */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 82228F30h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82228F44;  }
		/* 82228F30h case    4:*/		return 0x82228F34;
		  /* 82228F34h */ case    5:  		/* lwz R10, <#[R14 + 8]> */
		/* 82228F34h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82228F34h case    5:*/		return 0x82228F38;
		  /* 82228F38h */ case    6:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 82228F38h case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 82228F38h case    6:*/		return 0x82228F3C;
		  /* 82228F3Ch */ case    7:  		/* and R11, R10, R11 */
		/* 82228F3Ch case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82228F3Ch case    7:*/		return 0x82228F40;
		  /* 82228F40h */ case    8:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82228F40h case    8:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82228F40h case    8:*/		return 0x82228F44;
	}
	return 0x82228F44;
} // Block from 82228F20h-82228F44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82228F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228F44);
		  /* 82228F44h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82228F44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82228F44h case    0:*/		return 0x82228F48;
		  /* 82228F48h */ case    1:  		/* bc 12, CR6_EQ, 664 */
		/* 82228F48h case    1:*/		if ( regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82228F48h case    1:*/		return 0x82228F4C;
		  /* 82228F4Ch */ case    2:  		/* cntlzw R10, R11 */
		/* 82228F4Ch case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 82228F4Ch case    2:*/		return 0x82228F50;
		  /* 82228F50h */ case    3:  		/* lis R9, -32256 */
		/* 82228F50h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82228F50h case    3:*/		return 0x82228F54;
		  /* 82228F54h */ case    4:  		/* subfic R10, R10, 31 */
		/* 82228F54h case    4:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x1F);
		/* 82228F54h case    4:*/		return 0x82228F58;
		  /* 82228F58h */ case    5:  		/* or R27, R11, R27 */
		/* 82228F58h case    5:*/		cpu::op::or<0>(regs,&regs.R27,regs.R11,regs.R27);
		/* 82228F58h case    5:*/		return 0x82228F5C;
		  /* 82228F5Ch */ case    6:  		/* rlwinm R11, R10, 3, 0, 28 */
		/* 82228F5Ch case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R10);
		/* 82228F5Ch case    6:*/		return 0x82228F60;
		  /* 82228F60h */ case    7:  		/* lfd FR0, <#[R9 + 1808]> */
		/* 82228F60h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000710) );
		/* 82228F60h case    7:*/		return 0x82228F64;
		  /* 82228F64h */ case    8:  		/* stfdx FR0, <#[R11 + R18]> */
		/* 82228F64h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 82228F64h case    8:*/		return 0x82228F68;
		  /* 82228F68h */ case    9:  		/* b 632 */
		/* 82228F68h case    9:*/		return 0x822291E0;
		/* 82228F68h case    9:*/		return 0x82228F6C;
	}
	return 0x82228F6C;
} // Block from 82228F44h-82228F6Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82228F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228F6C);
		  /* 82228F6Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82228F6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82228F6Ch case    0:*/		return 0x82228F70;
		  /* 82228F70h */ case    1:  		/* rlwinm. R10, R11, 28, 31, 31 */
		/* 82228F70h case    1:*/		cpu::op::rlwinm<1,28,31,31>(regs,&regs.R10,regs.R11);
		/* 82228F70h case    1:*/		return 0x82228F74;
		  /* 82228F74h */ case    2:  		/* bc 12, CR0_EQ, 620 */
		/* 82228F74h case    2:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228F74h case    2:*/		return 0x82228F78;
		  /* 82228F78h */ case    3:  		/* lis R10, -32256 */
		/* 82228F78h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82228F78h case    3:*/		return 0x82228F7C;
		  /* 82228F7Ch */ case    4:  		/* lfd FR2, <#[R1 + 176]> */
		/* 82228F7Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R1 + 0x000000B0) );
		/* 82228F7Ch case    4:*/		return 0x82228F80;
		  /* 82228F80h */ case    5:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 82228F80h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 82228F80h case    5:*/		return 0x82228F84;
		  /* 82228F84h */ case    6:  		/* fcmpu CR6, FR2, FR0 */
		/* 82228F84h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR2,regs.FR0);
		/* 82228F84h case    6:*/		return 0x82228F88;
		  /* 82228F88h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82228F88h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82228FB0;  }
		/* 82228F88h case    7:*/		return 0x82228F8C;
		  /* 82228F8Ch */ case    8:  		/* lis R11, -32256 */
		/* 82228F8Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82228F8Ch case    8:*/		return 0x82228F90;
		  /* 82228F90h */ case    9:  		/* lwz R10, <#[R1 + 116]> */
		/* 82228F90h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 82228F90h case    9:*/		return 0x82228F94;
		  /* 82228F94h */ case   10:  		/* mr R27, R28 */
		/* 82228F94h case   10:*/		regs.R27 = regs.R28;
		/* 82228F94h case   10:*/		return 0x82228F98;
		  /* 82228F98h */ case   11:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82228F98h case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82228F98h case   11:*/		return 0x82228F9C;
		  /* 82228F9Ch */ case   12:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82228F9Ch case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82228F9Ch case   12:*/		return 0x82228FA0;
		  /* 82228FA0h */ case   13:  		/* stfd FR0, <#[R18]> */
		/* 82228FA0h case   13:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R18 + 0x00000000) );
		/* 82228FA0h case   13:*/		return 0x82228FA4;
		  /* 82228FA4h */ case   14:  		/* lwz R11, <#[R30]> */
		/* 82228FA4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82228FA4h case   14:*/		return 0x82228FA8;
		  /* 82228FA8h */ case   15:  		/* or R11, R10, R11 */
		/* 82228FA8h case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82228FA8h case   15:*/		return 0x82228FAC;
		  /* 82228FACh */ case   16:  		/* b 172 */
		/* 82228FACh case   16:*/		return 0x82229058;
		/* 82228FACh case   16:*/		return 0x82228FB0;
	}
	return 0x82228FB0;
} // Block from 82228F6Ch-82228FB0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82228FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228FB0);
		  /* 82228FB0h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82228FB0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82228FB0h case    0:*/		return 0x82228FB4;
		  /* 82228FB4h */ case    1:  		/* bc 12, CR0_EQ, 556 */
		/* 82228FB4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82228FB4h case    1:*/		return 0x82228FB8;
		  /* 82228FB8h */ case    2:  		/* lfd FR1, <#[R1 + 144]> */
		/* 82228FB8h case    2:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000090) );
		/* 82228FB8h case    2:*/		return 0x82228FBC;
		  /* 82228FBCh */ case    3:  		/* fcmpu CR6, FR1, FR0 */
		/* 82228FBCh case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82228FBCh case    3:*/		return 0x82228FC0;
		  /* 82228FC0h */ case    4:  		/* bc 12, CR6_LT, 544 */
		/* 82228FC0h case    4:*/		if ( regs.CR[6].lt ) { return 0x822291E0;  }
		/* 82228FC0h case    4:*/		return 0x82228FC4;
		  /* 82228FC4h */ case    5:  		/* bl -1665548 */
		/* 82228FC4h case    5:*/		regs.LR = 0x82228FC8; return 0x820925B8;
		/* 82228FC4h case    5:*/		return 0x82228FC8;
		  /* 82228FC8h */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 82228FC8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82228FC8h case    6:*/		return 0x82228FCC;
		  /* 82228FCCh */ case    7:  		/* stfd FR1, <#[R18]> */
		/* 82228FCCh case    7:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R18 + 0x00000000) );
		/* 82228FCCh case    7:*/		return 0x82228FD0;
		  /* 82228FD0h */ case    8:  		/* mr R27, R28 */
		/* 82228FD0h case    8:*/		regs.R27 = regs.R28;
		/* 82228FD0h case    8:*/		return 0x82228FD4;
		  /* 82228FD4h */ case    9:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82228FD4h case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82228FD4h case    9:*/		return 0x82228FD8;
		  /* 82228FD8h */ case   10:  		/* b 120 */
		/* 82228FD8h case   10:*/		return 0x82229050;
		/* 82228FD8h case   10:*/		return 0x82228FDC;
	}
	return 0x82228FDC;
} // Block from 82228FB0h-82228FDCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82228FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82228FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82228FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82228FDC);
		  /* 82228FDCh */ case    0:  		/* cmplwi CR6, R11, 110 */
		/* 82228FDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 82228FDCh case    0:*/		return 0x82228FE0;
		  /* 82228FE0h */ case    1:  		/* bc 12, CR6_EQ, 376 */
		/* 82228FE0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82229158;  }
		/* 82228FE0h case    1:*/		return 0x82228FE4;
		  /* 82228FE4h */ case    2:  		/* cmplwi CR6, R11, 112 */
		/* 82228FE4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 82228FE4h case    2:*/		return 0x82228FE8;
		  /* 82228FE8h */ case    3:  		/* bc 12, CR6_EQ, 120 */
		/* 82228FE8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82229060;  }
		/* 82228FE8h case    3:*/		return 0x82228FEC;
		  /* 82228FECh */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 82228FECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82228FECh case    4:*/		return 0x82228FF0;
		  /* 82228FF0h */ case    5:  		/* bc 4, CR6_EQ, 496 */
		/* 82228FF0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82228FF0h case    5:*/		return 0x82228FF4;
		  /* 82228FF4h */ case    6:  		/* rlwinm. R11, R26, 18, 29, 31 */
		/* 82228FF4h case    6:*/		cpu::op::rlwinm<1,18,29,31>(regs,&regs.R11,regs.R26);
		/* 82228FF4h case    6:*/		return 0x82228FF8;
		  /* 82228FF8h */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 82228FF8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82229024;  }
		/* 82228FF8h case    7:*/		return 0x82228FFC;
		  /* 82228FFCh */ case    8:  		/* addi R29, R18, -8 */
		/* 82228FFCh case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R18,0xFFFFFFF8);
		/* 82228FFCh case    8:*/		return 0x82229000;
		  /* 82229000h */ case    9:  		/* mr R4, R31 */
		/* 82229000h case    9:*/		regs.R4 = regs.R31;
		/* 82229000h case    9:*/		return 0x82229004;
		  /* 82229004h */ case   10:  		/* mr R3, R14 */
		/* 82229004h case   10:*/		regs.R3 = regs.R14;
		/* 82229004h case   10:*/		return 0x82229008;
		  /* 82229008h */ case   11:  		/* bl -442552 */
		/* 82229008h case   11:*/		regs.LR = 0x8222900C; return 0x821BCF50;
		/* 82229008h case   11:*/		return 0x8222900C;
		  /* 8222900Ch */ case   12:  		/* stfdu FR1, <#[R29 + 8]> */
		/* 8222900Ch case   12:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R29 + 0x00000008) );
		regs.R29 = (uint32)(regs.R29 + 0x00000008);
		/* 8222900Ch case   12:*/		return 0x82229010;
		  /* 82229010h */ case   13:  		/* addi R31, R31, 1 */
		/* 82229010h case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82229010h case   13:*/		return 0x82229014;
		  /* 82229014h */ case   14:  		/* lwz R11, <#[R14 + 8]> */
		/* 82229014h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82229014h case   14:*/		return 0x82229018;
		  /* 82229018h */ case   15:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82229018h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82229018h case   15:*/		return 0x8222901C;
		  /* 8222901Ch */ case   16:  		/* cmplw CR6, R31, R11 */
		/* 8222901Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8222901Ch case   16:*/		return 0x82229020;
		  /* 82229020h */ case   17:  		/* bc 12, CR6_LT, -32 */
		/* 82229020h case   17:*/		if ( regs.CR[6].lt ) { return 0x82229000;  }
		/* 82229020h case   17:*/		return 0x82229024;
	}
	return 0x82229024;
} // Block from 82228FDCh-82229024h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82229024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229024);
		  /* 82229024h */ case    0:  		/* rlwinm R10, R14, 0, 0, 19 */
		/* 82229024h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R14);
		/* 82229024h case    0:*/		return 0x82229028;
		  /* 82229028h */ case    1:  		/* slw R11, R28, R11 */
		/* 82229028h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 82229028h case    1:*/		return 0x8222902C;
		  /* 8222902Ch */ case    2:  		/* lwz R10, <#[R10]> */
		/* 8222902Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8222902Ch case    2:*/		return 0x82229030;
		  /* 82229030h */ case    3:  		/* addi R27, R11, -1 */
		/* 82229030h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFFFFF);
		/* 82229030h case    3:*/		return 0x82229034;
		  /* 82229034h */ case    4:  		/* lwz R11, <#[R10 + 148]> */
		/* 82229034h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000094) );
		/* 82229034h case    4:*/		return 0x82229038;
		  /* 82229038h */ case    5:  		/* lwz R11, <#[R11 + 40]> */
		/* 82229038h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82229038h case    5:*/		return 0x8222903C;
		  /* 8222903Ch */ case    6:  		/* nor R11, R11, R11 */
		/* 8222903Ch case    6:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8222903Ch case    6:*/		return 0x82229040;
		  /* 82229040h */ case    7:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 82229040h case    7:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 82229040h case    7:*/		return 0x82229044;
		  /* 82229044h */ case    8:  		/* bc 12, CR0_EQ, 412 */
		/* 82229044h case    8:*/		if ( regs.CR[0].eq ) { return 0x822291E0;  }
		/* 82229044h case    8:*/		return 0x82229048;
		  /* 82229048h */ case    9:  		/* lwz R11, <#[R14 + 20]> */
		/* 82229048h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000014) );
		/* 82229048h case    9:*/		return 0x8222904C;
		  /* 8222904Ch */ case   10:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 8222904Ch case   10:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 8222904Ch case   10:*/		return 0x82229050;
	}
	return 0x82229050;
} // Block from 82229024h-82229050h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82229050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229050);
		  /* 82229050h */ case    0:  		/* lwz R10, <#[R30]> */
		/* 82229050h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82229050h case    0:*/		return 0x82229054;
		  /* 82229054h */ case    1:  		/* or R11, R11, R10 */
		/* 82229054h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82229054h case    1:*/		return 0x82229058;
	}
	return 0x82229058;
} // Block from 82229050h-82229058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229058);
		  /* 82229058h */ case    0:  		/* stw R11, <#[R30]> */
		/* 82229058h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82229058h case    0:*/		return 0x8222905C;
		  /* 8222905Ch */ case    1:  		/* b 388 */
		/* 8222905Ch case    1:*/		return 0x822291E0;
		/* 8222905Ch case    1:*/		return 0x82229060;
	}
	return 0x82229060;
} // Block from 82229058h-82229060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229060);
		  /* 82229060h */ case    0:  		/* lis R11, -32256 */
		/* 82229060h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82229060h case    0:*/		return 0x82229064;
		  /* 82229064h */ case    1:  		/* lwz R27, <#[R14]> */
		/* 82229064h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R14 + 0x00000000) );
		/* 82229064h case    1:*/		return 0x82229068;
		  /* 82229068h */ case    2:  		/* mr R24, R31 */
		/* 82229068h case    2:*/		regs.R24 = regs.R31;
		/* 82229068h case    2:*/		return 0x8222906C;
		  /* 8222906Ch */ case    3:  		/* mr R25, R31 */
		/* 8222906Ch case    3:*/		regs.R25 = regs.R31;
		/* 8222906Ch case    3:*/		return 0x82229070;
		  /* 82229070h */ case    4:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82229070h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82229070h case    4:*/		return 0x82229074;
		  /* 82229074h */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 82229074h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82229074h case    5:*/		return 0x82229078;
		  /* 82229078h */ case    6:  		/* bc 12, CR6_EQ, 184 */
		/* 82229078h case    6:*/		if ( regs.CR[6].eq ) { return 0x82229130;  }
		/* 82229078h case    6:*/		return 0x8222907C;
		  /* 8222907Ch */ case    7:  		/* li R10, 0 */
		/* 8222907Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222907Ch case    7:*/		return 0x82229080;
		  /* 82229080h */ case    8:  		/* mr R9, R14 */
		/* 82229080h case    8:*/		regs.R9 = regs.R14;
		/* 82229080h case    8:*/		return 0x82229084;
		  /* 82229084h */ case    9:  		/* li R8, 0 */
		/* 82229084h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82229084h case    9:*/		return 0x82229088;
		  /* 82229088h */ case   10:  		/* addi R7, R1, 96 */
		/* 82229088h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82229088h case   10:*/		return 0x8222908C;
		  /* 8222908Ch */ case   11:  		/* addi R6, R1, 128 */
		/* 8222908Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 8222908Ch case   11:*/		return 0x82229090;
		  /* 82229090h */ case   12:  		/* addi R5, R1, 132 */
		/* 82229090h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x84);
		/* 82229090h case   12:*/		return 0x82229094;
		  /* 82229094h */ case   13:  		/* li R4, 0 */
		/* 82229094h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82229094h case   13:*/		return 0x82229098;
		  /* 82229098h */ case   14:  		/* mr R3, R27 */
		/* 82229098h case   14:*/		regs.R3 = regs.R27;
		/* 82229098h case   14:*/		return 0x8222909C;
		  /* 8222909Ch */ case   15:  		/* bl -23500 */
		/* 8222909Ch case   15:*/		regs.LR = 0x822290A0; return 0x822234D0;
		/* 8222909Ch case   15:*/		return 0x822290A0;
		  /* 822290A0h */ case   16:  		/* lwz R29, <#[R1 + 132]> */
		/* 822290A0h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000084) );
		/* 822290A0h case   16:*/		return 0x822290A4;
		  /* 822290A4h */ case   17:  		/* lwz R11, <#[R29 + 8]> */
		/* 822290A4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 822290A4h case   17:*/		return 0x822290A8;
		  /* 822290A8h */ case   18:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 822290A8h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 822290A8h case   18:*/		return 0x822290AC;
		  /* 822290ACh */ case   19:  		/* cmplwi CR6, R11, 16000 */
		/* 822290ACh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 822290ACh case   19:*/		return 0x822290B0;
		  /* 822290B0h */ case   20:  		/* bc 4, CR6_EQ, 136 */
		/* 822290B0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82229138;  }
		/* 822290B0h case   20:*/		return 0x822290B4;
		  /* 822290B4h */ case   21:  		/* lwz R26, <#[R1 + 128]> */
		/* 822290B4h case   21:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 822290B4h case   21:*/		return 0x822290B8;
		  /* 822290B8h */ case   22:  		/* mr R3, R29 */
		/* 822290B8h case   22:*/		regs.R3 = regs.R29;
		/* 822290B8h case   22:*/		return 0x822290BC;
		  /* 822290BCh */ case   23:  		/* lwz R5, <#[R1 + 96]> */
		/* 822290BCh case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 822290BCh case   23:*/		return 0x822290C0;
		  /* 822290C0h */ case   24:  		/* mr R4, R26 */
		/* 822290C0h case   24:*/		regs.R4 = regs.R26;
		/* 822290C0h case   24:*/		return 0x822290C4;
		  /* 822290C4h */ case   25:  		/* bl -31268 */
		/* 822290C4h case   25:*/		regs.LR = 0x822290C8; return 0x822216A0;
		/* 822290C4h case   25:*/		return 0x822290C8;
		  /* 822290C8h */ case   26:  		/* rlwinm R11, R29, 0, 0, 19 */
		/* 822290C8h case   26:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R29);
		/* 822290C8h case   26:*/		return 0x822290CC;
		  /* 822290CCh */ case   27:  		/* lwz R11, <#[R11]> */
		/* 822290CCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822290CCh case   27:*/		return 0x822290D0;
		  /* 822290D0h */ case   28:  		/* lwz R11, <#[R11 + 148]> */
		/* 822290D0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000094) );
		/* 822290D0h case   28:*/		return 0x822290D4;
		  /* 822290D4h */ case   29:  		/* lwz R11, <#[R11 + 40]> */
		/* 822290D4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 822290D4h case   29:*/		return 0x822290D8;
		  /* 822290D8h */ case   30:  		/* nor R11, R11, R11 */
		/* 822290D8h case   30:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822290D8h case   30:*/		return 0x822290DC;
		  /* 822290DCh */ case   31:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 822290DCh case   31:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 822290DCh case   31:*/		return 0x822290E0;
		  /* 822290E0h */ case   32:  		/* bc 4, CR0_EQ, 12 */
		/* 822290E0h case   32:*/		if ( !regs.CR[0].eq ) { return 0x822290EC;  }
		/* 822290E0h case   32:*/		return 0x822290E4;
		  /* 822290E4h */ case   33:  		/* mr R11, R31 */
		/* 822290E4h case   33:*/		regs.R11 = regs.R31;
		/* 822290E4h case   33:*/		return 0x822290E8;
		  /* 822290E8h */ case   34:  		/* b 24 */
		/* 822290E8h case   34:*/		return 0x82229100;
		/* 822290E8h case   34:*/		return 0x822290EC;
	}
	return 0x822290EC;
} // Block from 82229060h-822290ECh (35 instructions)

//////////////////////////////////////////////////////
// Block at 822290ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822290EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822290EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822290EC);
		  /* 822290ECh */ case    0:  		/* lwz R11, <#[R29 + 20]> */
		/* 822290ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 822290ECh case    0:*/		return 0x822290F0;
		  /* 822290F0h */ case    1:  		/* rlwinm R10, R26, 1, 0, 30 */
		/* 822290F0h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R26);
		/* 822290F0h case    1:*/		return 0x822290F4;
		  /* 822290F4h */ case    2:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 822290F4h case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 822290F4h case    2:*/		return 0x822290F8;
		  /* 822290F8h */ case    3:  		/* srw R11, R11, R10 */
		/* 822290F8h case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822290F8h case    3:*/		return 0x822290FC;
		  /* 822290FCh */ case    4:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 822290FCh case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 822290FCh case    4:*/		return 0x82229100;
	}
	return 0x82229100;
} // Block from 822290ECh-82229100h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82229100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229100);
		  /* 82229100h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82229100h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82229100h case    0:*/		return 0x82229104;
		  /* 82229104h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 82229104h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82229118;  }
		/* 82229104h case    1:*/		return 0x82229108;
		  /* 82229108h */ case    2:  		/* mr R24, R27 */
		/* 82229108h case    2:*/		regs.R24 = regs.R27;
		/* 82229108h case    2:*/		return 0x8222910C;
		  /* 8222910Ch */ case    3:  		/* fmr FR31, FR1 */
		/* 8222910Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8222910Ch case    3:*/		return 0x82229110;
		  /* 82229110h */ case    4:  		/* mr R25, R11 */
		/* 82229110h case    4:*/		regs.R25 = regs.R11;
		/* 82229110h case    4:*/		return 0x82229114;
		  /* 82229114h */ case    5:  		/* b 20 */
		/* 82229114h case    5:*/		return 0x82229128;
		/* 82229114h case    5:*/		return 0x82229118;
	}
	return 0x82229118;
} // Block from 82229100h-82229118h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82229118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229118);
		  /* 82229118h */ case    0:  		/* fcmpu CR6, FR31, FR1 */
		/* 82229118h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR1);
		/* 82229118h case    0:*/		return 0x8222911C;
		  /* 8222911Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 8222911Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82229138;  }
		/* 8222911Ch case    1:*/		return 0x82229120;
		  /* 82229120h */ case    2:  		/* cmpw CR6, R25, R11 */
		/* 82229120h case    2:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 82229120h case    2:*/		return 0x82229124;
		  /* 82229124h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 82229124h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82229138;  }
		/* 82229124h case    3:*/		return 0x82229128;
	}
	return 0x82229128;
} // Block from 82229118h-82229128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82229128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229128);
		  /* 82229128h */ case    0:  		/* lwz R27, <#[R27 + 4]> */
		/* 82229128h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000004) );
		/* 82229128h case    0:*/		return 0x8222912C;
		  /* 8222912Ch */ case    1:  		/* b -184 */
		/* 8222912Ch case    1:*/		return 0x82229074;
		/* 8222912Ch case    1:*/		return 0x82229130;
	}
	return 0x82229130;
} // Block from 82229128h-82229130h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229130);
		  /* 82229130h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82229130h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82229130h case    0:*/		return 0x82229134;
		  /* 82229134h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82229134h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82229140;  }
		/* 82229134h case    1:*/		return 0x82229138;
	}
	return 0x82229138;
} // Block from 82229130h-82229138h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229138);
		  /* 82229138h */ case    0:  		/* li R3, 0 */
		/* 82229138h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82229138h case    0:*/		return 0x8222913C;
		  /* 8222913Ch */ case    1:  		/* b 168 */
		/* 8222913Ch case    1:*/		return 0x822291E4;
		/* 8222913Ch case    1:*/		return 0x82229140;
	}
	return 0x82229140;
} // Block from 82229138h-82229140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229140);
		  /* 82229140h */ case    0:  		/* stfd FR31, <#[R18]> */
		/* 82229140h case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R18 + 0x00000000) );
		/* 82229140h case    0:*/		return 0x82229144;
		  /* 82229144h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82229144h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82229144h case    1:*/		return 0x82229148;
		  /* 82229148h */ case    2:  		/* or R11, R25, R11 */
		/* 82229148h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 82229148h case    2:*/		return 0x8222914C;
		  /* 8222914Ch */ case    3:  		/* stw R11, <#[R30]> */
		/* 8222914Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222914Ch case    3:*/		return 0x82229150;
		  /* 82229150h */ case    4:  		/* mr R27, R28 */
		/* 82229150h case    4:*/		regs.R27 = regs.R28;
		/* 82229150h case    4:*/		return 0x82229154;
		  /* 82229154h */ case    5:  		/* b 140 */
		/* 82229154h case    5:*/		return 0x822291E0;
		/* 82229154h case    5:*/		return 0x82229158;
	}
	return 0x82229158;
} // Block from 82229140h-82229158h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82229158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229158);
		  /* 82229158h */ case    0:  		/* mr R6, R31 */
		/* 82229158h case    0:*/		regs.R6 = regs.R31;
		/* 82229158h case    0:*/		return 0x8222915C;
		  /* 8222915Ch */ case    1:  		/* cmplwi CR6, R17, 0 */
		/* 8222915Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 8222915Ch case    1:*/		return 0x82229160;
		  /* 82229160h */ case    2:  		/* bc 12, CR6_EQ, 128 */
		/* 82229160h case    2:*/		if ( regs.CR[6].eq ) { return 0x822291E0;  }
		/* 82229160h case    2:*/		return 0x82229164;
		  /* 82229164h */ case    3:  		/* mr R10, R31 */
		/* 82229164h case    3:*/		regs.R10 = regs.R31;
		/* 82229164h case    3:*/		return 0x82229168;
		  /* 82229168h */ case    4:  		/* mtspr CTR, R17 */
		/* 82229168h case    4:*/		regs.CTR = regs.R17;
		/* 82229168h case    4:*/		return 0x8222916C;
		  /* 8222916Ch */ case    5:  		/* mr R11, R31 */
		/* 8222916Ch case    5:*/		regs.R11 = regs.R31;
		/* 8222916Ch case    5:*/		return 0x82229170;
		  /* 82229170h */ case    6:  		/* mr R7, R18 */
		/* 82229170h case    6:*/		regs.R7 = regs.R18;
		/* 82229170h case    6:*/		return 0x82229174;
		  /* 82229174h */ case    7:  		/* addi R8, R1, 144 */
		/* 82229174h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x90);
		/* 82229174h case    7:*/		return 0x82229178;
		  /* 82229178h */ case    8:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 82229178h case    8:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 82229178h case    8:*/		return 0x8222917C;
		  /* 8222917Ch */ case    9:  		/* addi R5, R1, 80 */
		/* 8222917Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8222917Ch case    9:*/		return 0x82229180;
		  /* 82229180h */ case   10:  		/* rlwinm R4, R10, 0, 27, 31 */
		/* 82229180h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R10);
		/* 82229180h case   10:*/		return 0x82229184;
		  /* 82229184h */ case   11:  		/* lwzx R9, <#[R9 + R5]> */
		/* 82229184h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 82229184h case   11:*/		return 0x82229188;
		  /* 82229188h */ case   12:  		/* srw R9, R9, R4 */
		/* 82229188h case   12:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R4);
		/* 82229188h case   12:*/		return 0x8222918C;
		  /* 8222918Ch */ case   13:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 8222918Ch case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 8222918Ch case   13:*/		return 0x82229190;
		  /* 82229190h */ case   14:  		/* bc 12, CR0_EQ, 56 */
		/* 82229190h case   14:*/		if ( regs.CR[0].eq ) { return 0x822291C8;  }
		/* 82229190h case   14:*/		return 0x82229194;
		  /* 82229194h */ case   15:  		/* lfd FR0, <#[R8]> */
		/* 82229194h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000000) );
		/* 82229194h case   15:*/		return 0x82229198;
		  /* 82229198h */ case   16:  		/* addi R5, R1, 112 */
		/* 82229198h case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 82229198h case   16:*/		return 0x8222919C;
		  /* 8222919Ch */ case   17:  		/* stfd FR0, <#[R7]> */
		/* 8222919Ch case   17:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R7 + 0x00000000) );
		/* 8222919Ch case   17:*/		return 0x822291A0;
		  /* 822291A0h */ case   18:  		/* rlwinm R9, R11, 29, 3, 29 */
		/* 822291A0h case   18:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R11);
		/* 822291A0h case   18:*/		return 0x822291A4;
		  /* 822291A4h */ case   19:  		/* slw R3, R28, R6 */
		/* 822291A4h case   19:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R28,regs.R6);
		/* 822291A4h case   19:*/		return 0x822291A8;
		  /* 822291A8h */ case   20:  		/* lwzx R5, <#[R10 + R5]> */
		/* 822291A8h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 822291A8h case   20:*/		return 0x822291AC;
		  /* 822291ACh */ case   21:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 822291ACh case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 822291ACh case   21:*/		return 0x822291B0;
		  /* 822291B0h */ case   22:  		/* or R27, R3, R27 */
		/* 822291B0h case   22:*/		cpu::op::or<0>(regs,&regs.R27,regs.R3,regs.R27);
		/* 822291B0h case   22:*/		return 0x822291B4;
		  /* 822291B4h */ case   23:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 822291B4h case   23:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 822291B4h case   23:*/		return 0x822291B8;
		  /* 822291B8h */ case   24:  		/* lwzx R3, <#[R9 + R30]> */
		/* 822291B8h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 822291B8h case   24:*/		return 0x822291BC;
		  /* 822291BCh */ case   25:  		/* slw R5, R5, R4 */
		/* 822291BCh case   25:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R5,regs.R4);
		/* 822291BCh case   25:*/		return 0x822291C0;
		  /* 822291C0h */ case   26:  		/* or R5, R5, R3 */
		/* 822291C0h case   26:*/		cpu::op::or<0>(regs,&regs.R5,regs.R5,regs.R3);
		/* 822291C0h case   26:*/		return 0x822291C4;
		  /* 822291C4h */ case   27:  		/* stwx R5, <#[R9 + R30]> */
		/* 822291C4h case   27:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 822291C4h case   27:*/		return 0x822291C8;
	}
	return 0x822291C8;
} // Block from 82229158h-822291C8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822291C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822291C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822291C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822291C8);
		  /* 822291C8h */ case    0:  		/* addi R6, R6, 1 */
		/* 822291C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 822291C8h case    0:*/		return 0x822291CC;
		  /* 822291CCh */ case    1:  		/* addi R8, R8, 32 */
		/* 822291CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x20);
		/* 822291CCh case    1:*/		return 0x822291D0;
		  /* 822291D0h */ case    2:  		/* addi R7, R7, 8 */
		/* 822291D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x8);
		/* 822291D0h case    2:*/		return 0x822291D4;
		  /* 822291D4h */ case    3:  		/* addi R11, R11, 2 */
		/* 822291D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822291D4h case    3:*/		return 0x822291D8;
		  /* 822291D8h */ case    4:  		/* addi R10, R10, 4 */
		/* 822291D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 822291D8h case    4:*/		return 0x822291DC;
		  /* 822291DCh */ case    5:  		/* bc 16, CR0_LT, -100 */
		/* 822291DCh case    5:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82229178;  }
		/* 822291DCh case    5:*/		return 0x822291E0;
	}
	return 0x822291E0;
} // Block from 822291C8h-822291E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822291E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822291E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822291E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822291E0);
		  /* 822291E0h */ case    0:  		/* mr R3, R27 */
		/* 822291E0h case    0:*/		regs.R3 = regs.R27;
		/* 822291E0h case    0:*/		return 0x822291E4;
	}
	return 0x822291E4;
} // Block from 822291E0h-822291E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822291E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822291E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822291E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822291E4);
		  /* 822291E4h */ case    0:  		/* addi R1, R1, 448 */
		/* 822291E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1C0);
		/* 822291E4h case    0:*/		return 0x822291E8;
		  /* 822291E8h */ case    1:  		/* lfd FR29, <#[R1 - 176]> */
		/* 822291E8h case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 822291E8h case    1:*/		return 0x822291EC;
		  /* 822291ECh */ case    2:  		/* lfd FR30, <#[R1 - 168]> */
		/* 822291ECh case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 822291ECh case    2:*/		return 0x822291F0;
		  /* 822291F0h */ case    3:  		/* lfd FR31, <#[R1 - 160]> */
		/* 822291F0h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 822291F0h case    3:*/		return 0x822291F4;
		  /* 822291F4h */ case    4:  		/* b -1671044 */
		/* 822291F4h case    4:*/		return 0x82091270;
		/* 822291F4h case    4:*/		return 0x822291F8;
	}
	return 0x822291F8;
} // Block from 822291E4h-822291F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822291F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822291F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822291F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822291F8);
		  /* 822291F8h */ case    0:  		/* mfspr R12, LR */
		/* 822291F8h case    0:*/		regs.R12 = regs.LR;
		/* 822291F8h case    0:*/		return 0x822291FC;
		  /* 822291FCh */ case    1:  		/* bl -1671072 */
		/* 822291FCh case    1:*/		regs.LR = 0x82229200; return 0x8209125C;
		/* 822291FCh case    1:*/		return 0x82229200;
		  /* 82229200h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82229200h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82229200h case    2:*/		return 0x82229204;
		  /* 82229204h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 82229204h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82229204h case    3:*/		return 0x82229208;
		  /* 82229208h */ case    4:  		/* mr R31, R3 */
		/* 82229208h case    4:*/		regs.R31 = regs.R3;
		/* 82229208h case    4:*/		return 0x8222920C;
		  /* 8222920Ch */ case    5:  		/* mr R30, R4 */
		/* 8222920Ch case    5:*/		regs.R30 = regs.R4;
		/* 8222920Ch case    5:*/		return 0x82229210;
		  /* 82229210h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82229210h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82229210h case    6:*/		return 0x82229214;
		  /* 82229214h */ case    7:  		/* li R29, 0 */
		/* 82229214h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82229214h case    7:*/		return 0x82229218;
		  /* 82229218h */ case    8:  		/* cmplwi CR6, R11, 59 */
		/* 82229218h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003B);
		/* 82229218h case    8:*/		return 0x8222921C;
		  /* 8222921Ch */ case    9:  		/* bc 12, CR6_EQ, 144 */
		/* 8222921Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x822292AC;  }
		/* 8222921Ch case    9:*/		return 0x82229220;
		  /* 82229220h */ case   10:  		/* cmplwi CR6, R11, 60 */
		/* 82229220h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003C);
		/* 82229220h case   10:*/		return 0x82229224;
		  /* 82229224h */ case   11:  		/* bc 12, CR6_EQ, 116 */
		/* 82229224h case   11:*/		if ( regs.CR[6].eq ) { return 0x82229298;  }
		/* 82229224h case   11:*/		return 0x82229228;
		  /* 82229228h */ case   12:  		/* cmplwi CR6, R11, 61 */
		/* 82229228h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 82229228h case   12:*/		return 0x8222922C;
		  /* 8222922Ch */ case   13:  		/* bc 12, CR6_EQ, 60 */
		/* 8222922Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82229268;  }
		/* 8222922Ch case   13:*/		return 0x82229230;
		  /* 82229230h */ case   14:  		/* cmplwi CR6, R11, 62 */
		/* 82229230h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003E);
		/* 82229230h case   14:*/		return 0x82229234;
		  /* 82229234h */ case   15:  		/* bc 4, CR6_EQ, 140 */
		/* 82229234h case   15:*/		if ( !regs.CR[6].eq ) { return 0x822292C0;  }
		/* 82229234h case   15:*/		return 0x82229238;
		  /* 82229238h */ case   16:  		/* lwz R4, <#[R3 + 44]> */
		/* 82229238h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x0000002C) );
		/* 82229238h case   16:*/		return 0x8222923C;
		  /* 8222923Ch */ case   17:  		/* mr R3, R30 */
		/* 8222923Ch case   17:*/		regs.R3 = regs.R30;
		/* 8222923Ch case   17:*/		return 0x82229240;
		  /* 82229240h */ case   18:  		/* lwz R5, <#[R4 + 12]> */
		/* 82229240h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 82229240h case   18:*/		return 0x82229244;
		  /* 82229244h */ case   19:  		/* bl -754004 */
		/* 82229244h case   19:*/		regs.LR = 0x82229248; return 0x821710F0;
		/* 82229244h case   19:*/		return 0x82229248;
		  /* 82229248h */ case   20:  		/* li R4, 4 */
		/* 82229248h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82229248h case   20:*/		return 0x8222924C;
		  /* 8222924Ch */ case   21:  		/* mr R29, R3 */
		/* 8222924Ch case   21:*/		regs.R29 = regs.R3;
		/* 8222924Ch case   21:*/		return 0x82229250;
		  /* 82229250h */ case   22:  		/* bl -726928 */
		/* 82229250h case   22:*/		regs.LR = 0x82229254; return 0x82177AC0;
		/* 82229250h case   22:*/		return 0x82229254;
		  /* 82229254h */ case   23:  		/* mr R5, R29 */
		/* 82229254h case   23:*/		regs.R5 = regs.R29;
		/* 82229254h case   23:*/		return 0x82229258;
		  /* 82229258h */ case   24:  		/* mr R3, R30 */
		/* 82229258h case   24:*/		regs.R3 = regs.R30;
		/* 82229258h case   24:*/		return 0x8222925C;
		  /* 8222925Ch */ case   25:  		/* lwz R4, <#[R31 + 28]> */
		/* 8222925Ch case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 8222925Ch case   25:*/		return 0x82229260;
		  /* 82229260h */ case   26:  		/* bl -12168 */
		/* 82229260h case   26:*/		regs.LR = 0x82229264; return 0x822262D8;
		/* 82229260h case   26:*/		return 0x82229264;
		  /* 82229264h */ case   27:  		/* b 88 */
		/* 82229264h case   27:*/		return 0x822292BC;
		/* 82229264h case   27:*/		return 0x82229268;
	}
	return 0x82229268;
} // Block from 822291F8h-82229268h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82229268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229268);
		  /* 82229268h */ case    0:  		/* lwz R4, <#[R31 + 44]> */
		/* 82229268h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000002C) );
		/* 82229268h case    0:*/		return 0x8222926C;
		  /* 8222926Ch */ case    1:  		/* mr R3, R30 */
		/* 8222926Ch case    1:*/		regs.R3 = regs.R30;
		/* 8222926Ch case    1:*/		return 0x82229270;
		  /* 82229270h */ case    2:  		/* lwz R5, <#[R4 + 12]> */
		/* 82229270h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 82229270h case    2:*/		return 0x82229274;
		  /* 82229274h */ case    3:  		/* bl -754052 */
		/* 82229274h case    3:*/		regs.LR = 0x82229278; return 0x821710F0;
		/* 82229274h case    3:*/		return 0x82229278;
		  /* 82229278h */ case    4:  		/* li R4, 4 */
		/* 82229278h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82229278h case    4:*/		return 0x8222927C;
		  /* 8222927Ch */ case    5:  		/* mr R29, R3 */
		/* 8222927Ch case    5:*/		regs.R29 = regs.R3;
		/* 8222927Ch case    5:*/		return 0x82229280;
		  /* 82229280h */ case    6:  		/* bl -726976 */
		/* 82229280h case    6:*/		regs.LR = 0x82229284; return 0x82177AC0;
		/* 82229280h case    6:*/		return 0x82229284;
		  /* 82229284h */ case    7:  		/* mr R5, R29 */
		/* 82229284h case    7:*/		regs.R5 = regs.R29;
		/* 82229284h case    7:*/		return 0x82229288;
		  /* 82229288h */ case    8:  		/* mr R3, R30 */
		/* 82229288h case    8:*/		regs.R3 = regs.R30;
		/* 82229288h case    8:*/		return 0x8222928C;
		  /* 8222928Ch */ case    9:  		/* lwz R4, <#[R31 + 28]> */
		/* 8222928Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 8222928Ch case    9:*/		return 0x82229290;
		  /* 82229290h */ case   10:  		/* bl -12056 */
		/* 82229290h case   10:*/		regs.LR = 0x82229294; return 0x82226378;
		/* 82229290h case   10:*/		return 0x82229294;
		  /* 82229294h */ case   11:  		/* b 40 */
		/* 82229294h case   11:*/		return 0x822292BC;
		/* 82229294h case   11:*/		return 0x82229298;
	}
	return 0x82229298;
} // Block from 82229268h-82229298h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82229298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229298);
		  /* 82229298h */ case    0:  		/* mr R3, R30 */
		/* 82229298h case    0:*/		regs.R3 = regs.R30;
		/* 82229298h case    0:*/		return 0x8222929C;
		  /* 8222929Ch */ case    1:  		/* lwz R5, <#[R31 + 44]> */
		/* 8222929Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000002C) );
		/* 8222929Ch case    1:*/		return 0x822292A0;
		  /* 822292A0h */ case    2:  		/* lwz R4, <#[R31 + 28]> */
		/* 822292A0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 822292A0h case    2:*/		return 0x822292A4;
		  /* 822292A4h */ case    3:  		/* bl -12556 */
		/* 822292A4h case    3:*/		regs.LR = 0x822292A8; return 0x82226198;
		/* 822292A4h case    3:*/		return 0x822292A8;
		  /* 822292A8h */ case    4:  		/* b 20 */
		/* 822292A8h case    4:*/		return 0x822292BC;
		/* 822292A8h case    4:*/		return 0x822292AC;
	}
	return 0x822292AC;
} // Block from 82229298h-822292ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822292ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822292AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822292AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822292AC);
		  /* 822292ACh */ case    0:  		/* mr R3, R30 */
		/* 822292ACh case    0:*/		regs.R3 = regs.R30;
		/* 822292ACh case    0:*/		return 0x822292B0;
		  /* 822292B0h */ case    1:  		/* lwz R5, <#[R31 + 44]> */
		/* 822292B0h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000002C) );
		/* 822292B0h case    1:*/		return 0x822292B4;
		  /* 822292B4h */ case    2:  		/* lwz R4, <#[R31 + 28]> */
		/* 822292B4h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 822292B4h case    2:*/		return 0x822292B8;
		  /* 822292B8h */ case    3:  		/* bl -12416 */
		/* 822292B8h case    3:*/		regs.LR = 0x822292BC; return 0x82226238;
		/* 822292B8h case    3:*/		return 0x822292BC;
	}
	return 0x822292BC;
} // Block from 822292ACh-822292BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822292BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822292BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822292BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822292BC);
		  /* 822292BCh */ case    0:  		/* mr R29, R3 */
		/* 822292BCh case    0:*/		regs.R29 = regs.R3;
		/* 822292BCh case    0:*/		return 0x822292C0;
	}
	return 0x822292C0;
} // Block from 822292BCh-822292C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822292C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822292C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822292C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822292C0);
		  /* 822292C0h */ case    0:  		/* lwz R31, <#[R31]> */
		/* 822292C0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000000) );
		/* 822292C0h case    0:*/		return 0x822292C4;
		  /* 822292C4h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 822292C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822292C4h case    1:*/		return 0x822292C8;
		  /* 822292C8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 822292C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x822292EC;  }
		/* 822292C8h case    2:*/		return 0x822292CC;
		  /* 822292CCh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 822292CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822292CCh case    3:*/		return 0x822292D0;
		  /* 822292D0h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 822292D0h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 822292D0h case    4:*/		return 0x822292D4;
		  /* 822292D4h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 822292D4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x822292E4;  }
		/* 822292D4h case    5:*/		return 0x822292D8;
		  /* 822292D8h */ case    6:  		/* mr R4, R31 */
		/* 822292D8h case    6:*/		regs.R4 = regs.R31;
		/* 822292D8h case    6:*/		return 0x822292DC;
		  /* 822292DCh */ case    7:  		/* mr R3, R29 */
		/* 822292DCh case    7:*/		regs.R3 = regs.R29;
		/* 822292DCh case    7:*/		return 0x822292E0;
		  /* 822292E0h */ case    8:  		/* bl -725272 */
		/* 822292E0h case    8:*/		regs.LR = 0x822292E4; return 0x821781C8;
		/* 822292E0h case    8:*/		return 0x822292E4;
	}
	return 0x822292E4;
} // Block from 822292C0h-822292E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822292E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822292E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822292E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822292E4);
		  /* 822292E4h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 822292E4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 822292E4h case    0:*/		return 0x822292E8;
		  /* 822292E8h */ case    1:  		/* b -36 */
		/* 822292E8h case    1:*/		return 0x822292C4;
		/* 822292E8h case    1:*/		return 0x822292EC;
	}
	return 0x822292EC;
} // Block from 822292E4h-822292ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822292ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822292EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822292EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822292EC);
		  /* 822292ECh */ case    0:  		/* mr R3, R29 */
		/* 822292ECh case    0:*/		regs.R3 = regs.R29;
		/* 822292ECh case    0:*/		return 0x822292F0;
		  /* 822292F0h */ case    1:  		/* addi R1, R1, 112 */
		/* 822292F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822292F0h case    1:*/		return 0x822292F4;
		  /* 822292F4h */ case    2:  		/* b -1671240 */
		/* 822292F4h case    2:*/		return 0x820912AC;
		/* 822292F4h case    2:*/		return 0x822292F8;
	}
	return 0x822292F8;
} // Block from 822292ECh-822292F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822292F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822292F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822292F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822292F8);
		  /* 822292F8h */ case    0:  		/* mfspr R12, LR */
		/* 822292F8h case    0:*/		regs.R12 = regs.LR;
		/* 822292F8h case    0:*/		return 0x822292FC;
		  /* 822292FCh */ case    1:  		/* bl -1671344 */
		/* 822292FCh case    1:*/		regs.LR = 0x82229300; return 0x8209124C;
		/* 822292FCh case    1:*/		return 0x82229300;
		  /* 82229300h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82229300h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82229300h case    2:*/		return 0x82229304;
		  /* 82229304h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 82229304h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82229304h case    3:*/		return 0x82229308;
		  /* 82229308h */ case    4:  		/* mr R26, R3 */
		/* 82229308h case    4:*/		regs.R26 = regs.R3;
		/* 82229308h case    4:*/		return 0x8222930C;
		  /* 8222930Ch */ case    5:  		/* mr R31, R4 */
		/* 8222930Ch case    5:*/		regs.R31 = regs.R4;
		/* 8222930Ch case    5:*/		return 0x82229310;
		  /* 82229310h */ case    6:  		/* mr R25, R5 */
		/* 82229310h case    6:*/		regs.R25 = regs.R5;
		/* 82229310h case    6:*/		return 0x82229314;
		  /* 82229314h */ case    7:  		/* rlwinm. R11, R11, 15, 31, 31 */
		/* 82229314h case    7:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R11);
		/* 82229314h case    7:*/		return 0x82229318;
		  /* 82229318h */ case    8:  		/* bc 12, CR0_EQ, 36 */
		/* 82229318h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222933C;  }
		/* 82229318h case    8:*/		return 0x8222931C;
		  /* 8222931Ch */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 8222931Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8222931Ch case    9:*/		return 0x82229320;
		  /* 82229320h */ case   10:  		/* oris R11, R11, 4096 */
		/* 82229320h case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82229320h case   10:*/		return 0x82229324;
		  /* 82229324h */ case   11:  		/* mr R10, R11 */
		/* 82229324h case   11:*/		regs.R10 = regs.R11;
		/* 82229324h case   11:*/		return 0x82229328;
		  /* 82229328h */ case   12:  		/* stw R11, <#[R4 + 4]> */
		/* 82229328h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82229328h case   12:*/		return 0x8222932C;
		  /* 8222932Ch */ case   13:  		/* lwz R11, <#[R3 + 8]> */
		/* 8222932Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8222932Ch case   13:*/		return 0x82229330;
		  /* 82229330h */ case   14:  		/* rlwimi R10, R11, 9, 4, 4 */
		/* 82229330h case   14:*/		cpu::op::rlwimi<0,9,4,4>(regs,&regs.R10,regs.R11);
		/* 82229330h case   14:*/		return 0x82229334;
		  /* 82229334h */ case   15:  		/* stw R10, <#[R4 + 4]> */
		/* 82229334h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82229334h case   15:*/		return 0x82229338;
		  /* 82229338h */ case   16:  		/* b 68 */
		/* 82229338h case   16:*/		return 0x8222937C;
		/* 82229338h case   16:*/		return 0x8222933C;
	}
	return 0x8222933C;
} // Block from 822292F8h-8222933Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8222933Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222933C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222933C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222933C);
		  /* 8222933Ch */ case    0:  		/* mr R3, R26 */
		/* 8222933Ch case    0:*/		regs.R3 = regs.R26;
		/* 8222933Ch case    0:*/		return 0x82229340;
		  /* 82229340h */ case    1:  		/* bl -807424 */
		/* 82229340h case    1:*/		regs.LR = 0x82229344; return 0x82164140;
		/* 82229340h case    1:*/		return 0x82229344;
		  /* 82229344h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229344h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229344h case    2:*/		return 0x82229348;
		  /* 82229348h */ case    3:  		/* bc 4, CR0_EQ, 52 */
		/* 82229348h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8222937C;  }
		/* 82229348h case    3:*/		return 0x8222934C;
		  /* 8222934Ch */ case    4:  		/* lwz R11, <#[R26 + 28]> */
		/* 8222934Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 8222934Ch case    4:*/		return 0x82229350;
		  /* 82229350h */ case    5:  		/* lwz R11, <#[R11 + 76]> */
		/* 82229350h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82229350h case    5:*/		return 0x82229354;
		  /* 82229354h */ case    6:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82229354h case    6:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82229354h case    6:*/		return 0x82229358;
		  /* 82229358h */ case    7:  		/* bc 12, CR0_EQ, 36 */
		/* 82229358h case    7:*/		if ( regs.CR[0].eq ) { return 0x8222937C;  }
		/* 82229358h case    7:*/		return 0x8222935C;
		  /* 8222935Ch */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222935Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222935Ch case    8:*/		return 0x82229360;
		  /* 82229360h */ case    9:  		/* oris R11, R11, 4096 */
		/* 82229360h case    9:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82229360h case    9:*/		return 0x82229364;
		  /* 82229364h */ case   10:  		/* stw R11, <#[R31 + 4]> */
		/* 82229364h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82229364h case   10:*/		return 0x82229368;
		  /* 82229368h */ case   11:  		/* lwz R10, <#[R26 + 28]> */
		/* 82229368h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000001C) );
		/* 82229368h case   11:*/		return 0x8222936C;
		  /* 8222936Ch */ case   12:  		/* lwz R10, <#[R10 + 76]> */
		/* 8222936Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 8222936Ch case   12:*/		return 0x82229370;
		  /* 82229370h */ case   13:  		/* rlwinm R10, R10, 9, 24, 31 */
		/* 82229370h case   13:*/		cpu::op::rlwinm<0,9,24,31>(regs,&regs.R10,regs.R10);
		/* 82229370h case   13:*/		return 0x82229374;
		  /* 82229374h */ case   14:  		/* rlwimi R11, R10, 27, 4, 4 */
		/* 82229374h case   14:*/		cpu::op::rlwimi<0,27,4,4>(regs,&regs.R11,regs.R10);
		/* 82229374h case   14:*/		return 0x82229378;
		  /* 82229378h */ case   15:  		/* stw R11, <#[R31 + 4]> */
		/* 82229378h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82229378h case   15:*/		return 0x8222937C;
	}
	return 0x8222937C;
} // Block from 8222933Ch-8222937Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8222937Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222937C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222937C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222937C);
		  /* 8222937Ch */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 8222937Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8222937Ch case    0:*/		return 0x82229380;
		  /* 82229380h */ case    1:  		/* rlwinm. R11, R10, 0, 3, 3 */
		/* 82229380h case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R10);
		/* 82229380h case    1:*/		return 0x82229384;
		  /* 82229384h */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 82229384h case    2:*/		if ( regs.CR[0].eq ) { return 0x822293D0;  }
		/* 82229384h case    2:*/		return 0x82229388;
		  /* 82229388h */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229388h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229388h case    3:*/		return 0x8222938C;
		  /* 8222938Ch */ case    4:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8222938Ch case    4:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8222938Ch case    4:*/		return 0x82229390;
		  /* 82229390h */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 82229390h case    5:*/		if ( regs.CR[0].eq ) { return 0x822293D0;  }
		/* 82229390h case    5:*/		return 0x82229394;
		  /* 82229394h */ case    6:  		/* lwz R11, <#[R26 + 4]> */
		/* 82229394h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82229394h case    6:*/		return 0x82229398;
		  /* 82229398h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82229398h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82229398h case    7:*/		return 0x8222939C;
		  /* 8222939Ch */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 8222939Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x822293B4;  }
		/* 8222939Ch case    8:*/		return 0x822293A0;
		  /* 822293A0h */ case    9:  		/* lwz R9, <#[R11]> */
		/* 822293A0h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822293A0h case    9:*/		return 0x822293A4;
		  /* 822293A4h */ case   10:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 822293A4h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 822293A4h case   10:*/		return 0x822293A8;
		  /* 822293A8h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 822293A8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x822293B4;  }
		/* 822293A8h case   11:*/		return 0x822293AC;
		  /* 822293ACh */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 822293ACh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822293ACh case   12:*/		return 0x822293B0;
		  /* 822293B0h */ case   13:  		/* b -24 */
		/* 822293B0h case   13:*/		return 0x82229398;
		/* 822293B0h case   13:*/		return 0x822293B4;
	}
	return 0x822293B4;
} // Block from 8222937Ch-822293B4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822293B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822293B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822293B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822293B4);
		  /* 822293B4h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 822293B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822293B4h case    0:*/		return 0x822293B8;
		  /* 822293B8h */ case    1:  		/* lis R9, 64 */
		/* 822293B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x40);
		/* 822293B8h case    1:*/		return 0x822293BC;
		  /* 822293BCh */ case    2:  		/* rlwinm R11, R11, 0, 7, 14 */
		/* 822293BCh case    2:*/		cpu::op::rlwinm<0,0,7,14>(regs,&regs.R11,regs.R11);
		/* 822293BCh case    2:*/		return 0x822293C0;
		  /* 822293C0h */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 822293C0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822293C0h case    3:*/		return 0x822293C4;
		  /* 822293C4h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 822293C4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822293D0;  }
		/* 822293C4h case    4:*/		return 0x822293C8;
		  /* 822293C8h */ case    5:  		/* rlwinm R11, R10, 0, 5, 2 */
		/* 822293C8h case    5:*/		cpu::op::rlwinm<0,0,5,2>(regs,&regs.R11,regs.R10);
		/* 822293C8h case    5:*/		return 0x822293CC;
		  /* 822293CCh */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 822293CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822293CCh case    6:*/		return 0x822293D0;
	}
	return 0x822293D0;
} // Block from 822293B4h-822293D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822293D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822293D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822293D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822293D0);
		  /* 822293D0h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 822293D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822293D0h case    0:*/		return 0x822293D4;
		  /* 822293D4h */ case    1:  		/* li R28, 0 */
		/* 822293D4h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 822293D4h case    1:*/		return 0x822293D8;
		  /* 822293D8h */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 822293D8h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 822293D8h case    2:*/		return 0x822293DC;
		  /* 822293DCh */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 822293DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 822293DCh case    3:*/		return 0x822293E0;
		  /* 822293E0h */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 822293E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x822293F0;  }
		/* 822293E0h case    4:*/		return 0x822293E4;
		  /* 822293E4h */ case    5:  		/* cmplwi CR6, R11, 31 */
		/* 822293E4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 822293E4h case    5:*/		return 0x822293E8;
		  /* 822293E8h */ case    6:  		/* li R11, 1 */
		/* 822293E8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822293E8h case    6:*/		return 0x822293EC;
		  /* 822293ECh */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 822293ECh case    7:*/		if ( !regs.CR[6].gt ) { return 0x822293F4;  }
		/* 822293ECh case    7:*/		return 0x822293F0;
	}
	return 0x822293F0;
} // Block from 822293D0h-822293F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822293F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822293F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822293F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822293F0);
		  /* 822293F0h */ case    0:  		/* mr R11, R28 */
		/* 822293F0h case    0:*/		regs.R11 = regs.R28;
		/* 822293F0h case    0:*/		return 0x822293F4;
	}
	return 0x822293F4;
} // Block from 822293F0h-822293F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822293F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822293F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822293F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822293F4);
		  /* 822293F4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822293F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822293F4h case    0:*/		return 0x822293F8;
		  /* 822293F8h */ case    1:  		/* bc 12, CR0_EQ, 736 */
		/* 822293F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x822296D8;  }
		/* 822293F8h case    1:*/		return 0x822293FC;
		  /* 822293FCh */ case    2:  		/* lwz R11, <#[R26 + 8]> */
		/* 822293FCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822293FCh case    2:*/		return 0x82229400;
		  /* 82229400h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 82229400h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82229400h case    3:*/		return 0x82229404;
		  /* 82229404h */ case    4:  		/* rlwinm R11, R11, 25, 7, 31 */
		/* 82229404h case    4:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R11,regs.R11);
		/* 82229404h case    4:*/		return 0x82229408;
		  /* 82229408h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 82229408h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82229408h case    5:*/		return 0x8222940C;
		  /* 8222940Ch */ case    6:  		/* rlwinm R10, R10, 0, 6, 31 */
		/* 8222940Ch case    6:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R10,regs.R10);
		/* 8222940Ch case    6:*/		return 0x82229410;
		  /* 82229410h */ case    7:  		/* addi R8, R11, -1 */
		/* 82229410h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82229410h case    7:*/		return 0x82229414;
		  /* 82229414h */ case    8:  		/* oris R11, R10, 51200 */
		/* 82229414h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0xC800);
		/* 82229414h case    8:*/		return 0x82229418;
		  /* 82229418h */ case    9:  		/* rlwimi R9, R8, 24, 3, 7 */
		/* 82229418h case    9:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R9,regs.R8);
		/* 82229418h case    9:*/		return 0x8222941C;
		  /* 8222941Ch */ case   10:  		/* stw R11, <#[R31]> */
		/* 8222941Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8222941Ch case   10:*/		return 0x82229420;
		  /* 82229420h */ case   11:  		/* stw R9, <#[R31 + 8]> */
		/* 82229420h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82229420h case   11:*/		return 0x82229424;
		  /* 82229424h */ case   12:  		/* lwz R10, <#[R26 + 8]> */
		/* 82229424h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82229424h case   12:*/		return 0x82229428;
		  /* 82229428h */ case   13:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82229428h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82229428h case   13:*/		return 0x8222942C;
		  /* 8222942Ch */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 8222942Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x82229438;  }
		/* 8222942Ch case   14:*/		return 0x82229430;
		  /* 82229430h */ case   15:  		/* oris R11, R11, 256 */
		/* 82229430h case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82229430h case   15:*/		return 0x82229434;
		  /* 82229434h */ case   16:  		/* stw R11, <#[R31]> */
		/* 82229434h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229434h case   16:*/		return 0x82229438;
	}
	return 0x82229438;
} // Block from 822293F4h-82229438h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82229438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229438);
		  /* 82229438h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229438h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229438h case    0:*/		return 0x8222943C;
		  /* 8222943Ch */ case    1:  		/* lwz R10, <#[R31]> */
		/* 8222943Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222943Ch case    1:*/		return 0x82229440;
		  /* 82229440h */ case    2:  		/* rlwimi R10, R11, 15, 12, 15 */
		/* 82229440h case    2:*/		cpu::op::rlwimi<0,15,12,15>(regs,&regs.R10,regs.R11);
		/* 82229440h case    2:*/		return 0x82229444;
		  /* 82229444h */ case    3:  		/* stw R10, <#[R31]> */
		/* 82229444h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82229444h case    3:*/		return 0x82229448;
		  /* 82229448h */ case    4:  		/* lwz R11, <#[R26 + 4]> */
		/* 82229448h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82229448h case    4:*/		return 0x8222944C;
		  /* 8222944Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8222944Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222944Ch case    5:*/		return 0x82229450;
		  /* 82229450h */ case    6:  		/* bc 12, CR6_EQ, 100 */
		/* 82229450h case    6:*/		if ( regs.CR[6].eq ) { return 0x822294B4;  }
		/* 82229450h case    6:*/		return 0x82229454;
		  /* 82229454h */ case    7:  		/* lwz R10, <#[R11 + 16]> */
		/* 82229454h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82229454h case    7:*/		return 0x82229458;
		  /* 82229458h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82229458h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82229458h case    8:*/		return 0x8222945C;
		  /* 8222945Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8222945Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8222946C;  }
		/* 8222945Ch case    9:*/		return 0x82229460;
		  /* 82229460h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 82229460h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82229460h case   10:*/		return 0x82229464;
		  /* 82229464h */ case   11:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82229464h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82229464h case   11:*/		return 0x82229468;
		  /* 82229468h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82229468h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82229474;  }
		/* 82229468h case   12:*/		return 0x8222946C;
	}
	return 0x8222946C;
} // Block from 82229438h-8222946Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222946Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222946C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222946C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222946C);
		  /* 8222946Ch */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222946Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222946Ch case    0:*/		return 0x82229470;
		  /* 82229470h */ case    1:  		/* b -36 */
		/* 82229470h case    1:*/		return 0x8222944C;
		/* 82229470h case    1:*/		return 0x82229474;
	}
	return 0x82229474;
} // Block from 8222946Ch-82229474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229474);
		  /* 82229474h */ case    0:  		/* lwz R10, <#[R26 + 8]> */
		/* 82229474h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82229474h case    0:*/		return 0x82229478;
		  /* 82229478h */ case    1:  		/* rlwinm. R10, R10, 27, 31, 31 */
		/* 82229478h case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R10);
		/* 82229478h case    1:*/		return 0x8222947C;
		  /* 8222947Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8222947Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8222948C;  }
		/* 8222947Ch case    2:*/		return 0x82229480;
		  /* 82229480h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 82229480h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82229480h case    3:*/		return 0x82229484;
		  /* 82229484h */ case    4:  		/* ori R10, R10, 32768 */
		/* 82229484h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 82229484h case    4:*/		return 0x82229488;
		  /* 82229488h */ case    5:  		/* stw R10, <#[R31]> */
		/* 82229488h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82229488h case    5:*/		return 0x8222948C;
	}
	return 0x8222948C;
} // Block from 82229474h-8222948Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8222948Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222948C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222948C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222948C);
		  /* 8222948Ch */ case    0:  		/* lwz R10, <#[R11]> */
		/* 8222948Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222948Ch case    0:*/		return 0x82229490;
		  /* 82229490h */ case    1:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 82229490h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 82229490h case    1:*/		return 0x82229494;
		  /* 82229494h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82229494h case    2:*/		if ( regs.CR[0].eq ) { return 0x822294A4;  }
		/* 82229494h case    2:*/		return 0x82229498;
		  /* 82229498h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 82229498h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82229498h case    3:*/		return 0x8222949C;
		  /* 8222949Ch */ case    4:  		/* ori R10, R10, 64 */
		/* 8222949Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 8222949Ch case    4:*/		return 0x822294A0;
		  /* 822294A0h */ case    5:  		/* stw R10, <#[R31]> */
		/* 822294A0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822294A0h case    5:*/		return 0x822294A4;
	}
	return 0x822294A4;
} // Block from 8222948Ch-822294A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822294A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822294A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822294A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822294A4);
		  /* 822294A4h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 822294A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822294A4h case    0:*/		return 0x822294A8;
		  /* 822294A8h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 822294A8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822294A8h case    1:*/		return 0x822294AC;
		  /* 822294ACh */ case    2:  		/* rlwimi R10, R11, 15, 26, 31 */
		/* 822294ACh case    2:*/		cpu::op::rlwimi<0,15,26,31>(regs,&regs.R10,regs.R11);
		/* 822294ACh case    2:*/		return 0x822294B0;
		  /* 822294B0h */ case    3:  		/* stw R10, <#[R31]> */
		/* 822294B0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822294B0h case    3:*/		return 0x822294B4;
	}
	return 0x822294B4;
} // Block from 822294A4h-822294B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822294B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822294B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822294B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822294B4);
		  /* 822294B4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822294B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822294B4h case    0:*/		return 0x822294B8;
		  /* 822294B8h */ case    1:  		/* lis R10, 8 */
		/* 822294B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 822294B8h case    1:*/		return 0x822294BC;
		  /* 822294BCh */ case    2:  		/* mr R30, R28 */
		/* 822294BCh case    2:*/		regs.R30 = regs.R28;
		/* 822294BCh case    2:*/		return 0x822294C0;
		  /* 822294C0h */ case    3:  		/* oris R11, R11, 57344 */
		/* 822294C0h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0xE000);
		/* 822294C0h case    3:*/		return 0x822294C4;
		  /* 822294C4h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 822294C4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822294C4h case    4:*/		return 0x822294C8;
		  /* 822294C8h */ case    5:  		/* lwz R11, <#[R26 + 8]> */
		/* 822294C8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822294C8h case    5:*/		return 0x822294CC;
		  /* 822294CCh */ case    6:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 822294CCh case    6:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 822294CCh case    6:*/		return 0x822294D0;
		  /* 822294D0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 822294D0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822294D0h case    7:*/		return 0x822294D4;
		  /* 822294D4h */ case    8:  		/* bc 12, CR6_LT, 92 */
		/* 822294D4h case    8:*/		if ( regs.CR[6].lt ) { return 0x82229530;  }
		/* 822294D4h case    8:*/		return 0x822294D8;
		  /* 822294D8h */ case    9:  		/* stw R28, <#[R1 + 80]> */
		/* 822294D8h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 822294D8h case    9:*/		return 0x822294DC;
		  /* 822294DCh */ case   10:  		/* addi R7, R1, 80 */
		/* 822294DCh case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 822294DCh case   10:*/		return 0x822294E0;
		  /* 822294E0h */ case   11:  		/* li R6, 0 */
		/* 822294E0h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822294E0h case   11:*/		return 0x822294E4;
		  /* 822294E4h */ case   12:  		/* mr R5, R31 */
		/* 822294E4h case   12:*/		regs.R5 = regs.R31;
		/* 822294E4h case   12:*/		return 0x822294E8;
		  /* 822294E8h */ case   13:  		/* li R4, 0 */
		/* 822294E8h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822294E8h case   13:*/		return 0x822294EC;
		  /* 822294ECh */ case   14:  		/* mr R3, R26 */
		/* 822294ECh case   14:*/		regs.R3 = regs.R26;
		/* 822294ECh case   14:*/		return 0x822294F0;
		  /* 822294F0h */ case   15:  		/* bl -30584 */
		/* 822294F0h case   15:*/		regs.LR = 0x822294F4; return 0x82221D78;
		/* 822294F0h case   15:*/		return 0x822294F4;
		  /* 822294F4h */ case   16:  		/* lwz R11, <#[R1 + 80]> */
		/* 822294F4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822294F4h case   16:*/		return 0x822294F8;
		  /* 822294F8h */ case   17:  		/* lwz R10, <#[R31 + 4]> */
		/* 822294F8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822294F8h case   17:*/		return 0x822294FC;
		  /* 822294FCh */ case   18:  		/* mr R30, R3 */
		/* 822294FCh case   18:*/		regs.R30 = regs.R3;
		/* 822294FCh case   18:*/		return 0x82229500;
		  /* 82229500h */ case   19:  		/* rlwinm R9, R11, 31, 24, 31 */
		/* 82229500h case   19:*/		cpu::op::rlwinm<0,31,24,31>(regs,&regs.R9,regs.R11);
		/* 82229500h case   19:*/		return 0x82229504;
		  /* 82229504h */ case   20:  		/* lwz R8, <#[R31 + 8]> */
		/* 82229504h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82229504h case   20:*/		return 0x82229508;
		  /* 82229508h */ case   21:  		/* rlwimi R10, R11, 26, 5, 5 */
		/* 82229508h case   21:*/		cpu::op::rlwimi<0,26,5,5>(regs,&regs.R10,regs.R11);
		/* 82229508h case   21:*/		return 0x8222950C;
		  /* 8222950Ch */ case   22:  		/* rlwimi R8, R11, 21, 0, 0 */
		/* 8222950Ch case   22:*/		cpu::op::rlwimi<0,21,0,0>(regs,&regs.R8,regs.R11);
		/* 8222950Ch case   22:*/		return 0x82229510;
		  /* 82229510h */ case   23:  		/* stw R10, <#[R31 + 4]> */
		/* 82229510h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229510h case   23:*/		return 0x82229514;
		  /* 82229514h */ case   24:  		/* rlwinm R10, R11, 21, 24, 31 */
		/* 82229514h case   24:*/		cpu::op::rlwinm<0,21,24,31>(regs,&regs.R10,regs.R11);
		/* 82229514h case   24:*/		return 0x82229518;
		  /* 82229518h */ case   25:  		/* stb R9, <#[R31 + 5]> */
		/* 82229518h case   25:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000005) );
		/* 82229518h case   25:*/		return 0x8222951C;
		  /* 8222951Ch */ case   26:  		/* lwz R9, <#[R31 + 4]> */
		/* 8222951Ch case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8222951Ch case   26:*/		return 0x82229520;
		  /* 82229520h */ case   27:  		/* rlwimi R9, R11, 22, 0, 0 */
		/* 82229520h case   27:*/		cpu::op::rlwimi<0,22,0,0>(regs,&regs.R9,regs.R11);
		/* 82229520h case   27:*/		return 0x82229524;
		  /* 82229524h */ case   28:  		/* stw R8, <#[R31 + 8]> */
		/* 82229524h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82229524h case   28:*/		return 0x82229528;
		  /* 82229528h */ case   29:  		/* stb R10, <#[R31 + 9]> */
		/* 82229528h case   29:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000009) );
		/* 82229528h case   29:*/		return 0x8222952C;
		  /* 8222952Ch */ case   30:  		/* stw R9, <#[R31 + 4]> */
		/* 8222952Ch case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8222952Ch case   30:*/		return 0x82229530;
	}
	return 0x82229530;
} // Block from 822294B4h-82229530h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82229530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229530);
		  /* 82229530h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229530h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229530h case    0:*/		return 0x82229534;
		  /* 82229534h */ case    1:  		/* lis R10, 16 */
		/* 82229534h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 82229534h case    1:*/		return 0x82229538;
		  /* 82229538h */ case    2:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 82229538h case    2:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82229538h case    2:*/		return 0x8222953C;
		  /* 8222953Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8222953Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8222953Ch case    3:*/		return 0x82229540;
		  /* 82229540h */ case    4:  		/* bc 12, CR6_LT, 116 */
		/* 82229540h case    4:*/		if ( regs.CR[6].lt ) { return 0x822295B4;  }
		/* 82229540h case    4:*/		return 0x82229544;
		  /* 82229544h */ case    5:  		/* stw R28, <#[R1 + 80]> */
		/* 82229544h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82229544h case    5:*/		return 0x82229548;
		  /* 82229548h */ case    6:  		/* addi R7, R1, 80 */
		/* 82229548h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82229548h case    6:*/		return 0x8222954C;
		  /* 8222954Ch */ case    7:  		/* mr R6, R30 */
		/* 8222954Ch case    7:*/		regs.R6 = regs.R30;
		/* 8222954Ch case    7:*/		return 0x82229550;
		  /* 82229550h */ case    8:  		/* mr R5, R31 */
		/* 82229550h case    8:*/		regs.R5 = regs.R31;
		/* 82229550h case    8:*/		return 0x82229554;
		  /* 82229554h */ case    9:  		/* li R4, 1 */
		/* 82229554h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82229554h case    9:*/		return 0x82229558;
		  /* 82229558h */ case   10:  		/* mr R3, R26 */
		/* 82229558h case   10:*/		regs.R3 = regs.R26;
		/* 82229558h case   10:*/		return 0x8222955C;
		  /* 8222955Ch */ case   11:  		/* bl -30692 */
		/* 8222955Ch case   11:*/		regs.LR = 0x82229560; return 0x82221D78;
		/* 8222955Ch case   11:*/		return 0x82229560;
		  /* 82229560h */ case   12:  		/* lwz R11, <#[R1 + 80]> */
		/* 82229560h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82229560h case   12:*/		return 0x82229564;
		  /* 82229564h */ case   13:  		/* lwz R10, <#[R31 + 4]> */
		/* 82229564h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229564h case   13:*/		return 0x82229568;
		  /* 82229568h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 82229568h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82229568h case   14:*/		return 0x8222956C;
		  /* 8222956Ch */ case   15:  		/* lwz R9, <#[R31 + 8]> */
		/* 8222956Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8222956Ch case   15:*/		return 0x82229570;
		  /* 82229570h */ case   16:  		/* rlwinm R8, R11, 31, 24, 31 */
		/* 82229570h case   16:*/		cpu::op::rlwinm<0,31,24,31>(regs,&regs.R8,regs.R11);
		/* 82229570h case   16:*/		return 0x82229574;
		  /* 82229574h */ case   17:  		/* rlwimi R10, R11, 25, 6, 6 */
		/* 82229574h case   17:*/		cpu::op::rlwimi<0,25,6,6>(regs,&regs.R10,regs.R11);
		/* 82229574h case   17:*/		return 0x82229578;
		  /* 82229578h */ case   18:  		/* rlwimi R9, R11, 20, 1, 1 */
		/* 82229578h case   18:*/		cpu::op::rlwimi<0,20,1,1>(regs,&regs.R9,regs.R11);
		/* 82229578h case   18:*/		return 0x8222957C;
		  /* 8222957Ch */ case   19:  		/* rlwinm R7, R11, 21, 24, 31 */
		/* 8222957Ch case   19:*/		cpu::op::rlwinm<0,21,24,31>(regs,&regs.R7,regs.R11);
		/* 8222957Ch case   19:*/		return 0x82229580;
		  /* 82229580h */ case   20:  		/* stw R10, <#[R31 + 4]> */
		/* 82229580h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229580h case   20:*/		return 0x82229584;
		  /* 82229584h */ case   21:  		/* stw R9, <#[R31 + 8]> */
		/* 82229584h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82229584h case   21:*/		return 0x82229588;
		  /* 82229588h */ case   22:  		/* stb R8, <#[R31 + 6]> */
		/* 82229588h case   22:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 82229588h case   22:*/		return 0x8222958C;
		  /* 8222958Ch */ case   23:  		/* stb R7, <#[R31 + 10]> */
		/* 8222958Ch case   23:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R31 + 0x0000000A) );
		/* 8222958Ch case   23:*/		return 0x82229590;
		  /* 82229590h */ case   24:  		/* bc 12, CR0_EQ, 32 */
		/* 82229590h case   24:*/		if ( regs.CR[0].eq ) { return 0x822295B0;  }
		/* 82229590h case   24:*/		return 0x82229594;
		  /* 82229594h */ case   25:  		/* lwz R10, <#[R31 + 4]> */
		/* 82229594h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229594h case   25:*/		return 0x82229598;
		  /* 82229598h */ case   26:  		/* cmplwi CR6, R30, 0 */
		/* 82229598h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82229598h case   26:*/		return 0x8222959C;
		  /* 8222959Ch */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 8222959Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x822295A8;  }
		/* 8222959Ch case   27:*/		return 0x822295A0;
		  /* 822295A0h */ case   28:  		/* rlwimi R10, R11, 21, 1, 1 */
		/* 822295A0h case   28:*/		cpu::op::rlwimi<0,21,1,1>(regs,&regs.R10,regs.R11);
		/* 822295A0h case   28:*/		return 0x822295A4;
		  /* 822295A4h */ case   29:  		/* b 8 */
		/* 822295A4h case   29:*/		return 0x822295AC;
		/* 822295A4h case   29:*/		return 0x822295A8;
	}
	return 0x822295A8;
} // Block from 82229530h-822295A8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 822295A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822295A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822295A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822295A8);
		  /* 822295A8h */ case    0:  		/* rlwimi R10, R11, 22, 0, 0 */
		/* 822295A8h case    0:*/		cpu::op::rlwimi<0,22,0,0>(regs,&regs.R10,regs.R11);
		/* 822295A8h case    0:*/		return 0x822295AC;
	}
	return 0x822295AC;
} // Block from 822295A8h-822295ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822295ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822295AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822295AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822295AC);
		  /* 822295ACh */ case    0:  		/* stw R10, <#[R31 + 4]> */
		/* 822295ACh case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822295ACh case    0:*/		return 0x822295B0;
	}
	return 0x822295B0;
} // Block from 822295ACh-822295B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822295B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822295B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822295B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822295B0);
		  /* 822295B0h */ case    0:  		/* add R30, R3, R30 */
		/* 822295B0h case    0:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 822295B0h case    0:*/		return 0x822295B4;
	}
	return 0x822295B4;
} // Block from 822295B0h-822295B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822295B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822295B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822295B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822295B4);
		  /* 822295B4h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 822295B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822295B4h case    0:*/		return 0x822295B8;
		  /* 822295B8h */ case    1:  		/* lis R10, 24 */
		/* 822295B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x18);
		/* 822295B8h case    1:*/		return 0x822295BC;
		  /* 822295BCh */ case    2:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 822295BCh case    2:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 822295BCh case    2:*/		return 0x822295C0;
		  /* 822295C0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 822295C0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822295C0h case    3:*/		return 0x822295C4;
		  /* 822295C4h */ case    4:  		/* bc 12, CR6_LT, 112 */
		/* 822295C4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82229634;  }
		/* 822295C4h case    4:*/		return 0x822295C8;
		  /* 822295C8h */ case    5:  		/* stw R28, <#[R1 + 80]> */
		/* 822295C8h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 822295C8h case    5:*/		return 0x822295CC;
		  /* 822295CCh */ case    6:  		/* addi R7, R1, 80 */
		/* 822295CCh case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 822295CCh case    6:*/		return 0x822295D0;
		  /* 822295D0h */ case    7:  		/* mr R6, R30 */
		/* 822295D0h case    7:*/		regs.R6 = regs.R30;
		/* 822295D0h case    7:*/		return 0x822295D4;
		  /* 822295D4h */ case    8:  		/* mr R5, R31 */
		/* 822295D4h case    8:*/		regs.R5 = regs.R31;
		/* 822295D4h case    8:*/		return 0x822295D8;
		  /* 822295D8h */ case    9:  		/* li R4, 2 */
		/* 822295D8h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 822295D8h case    9:*/		return 0x822295DC;
		  /* 822295DCh */ case   10:  		/* mr R3, R26 */
		/* 822295DCh case   10:*/		regs.R3 = regs.R26;
		/* 822295DCh case   10:*/		return 0x822295E0;
		  /* 822295E0h */ case   11:  		/* bl -30824 */
		/* 822295E0h case   11:*/		regs.LR = 0x822295E4; return 0x82221D78;
		/* 822295E0h case   11:*/		return 0x822295E4;
		  /* 822295E4h */ case   12:  		/* lwz R11, <#[R1 + 80]> */
		/* 822295E4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822295E4h case   12:*/		return 0x822295E8;
		  /* 822295E8h */ case   13:  		/* lwz R10, <#[R31 + 4]> */
		/* 822295E8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 822295E8h case   13:*/		return 0x822295EC;
		  /* 822295ECh */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 822295ECh case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822295ECh case   14:*/		return 0x822295F0;
		  /* 822295F0h */ case   15:  		/* lwz R9, <#[R31 + 8]> */
		/* 822295F0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 822295F0h case   15:*/		return 0x822295F4;
		  /* 822295F4h */ case   16:  		/* rlwinm R8, R11, 31, 24, 31 */
		/* 822295F4h case   16:*/		cpu::op::rlwinm<0,31,24,31>(regs,&regs.R8,regs.R11);
		/* 822295F4h case   16:*/		return 0x822295F8;
		  /* 822295F8h */ case   17:  		/* rlwimi R10, R11, 24, 7, 7 */
		/* 822295F8h case   17:*/		cpu::op::rlwimi<0,24,7,7>(regs,&regs.R10,regs.R11);
		/* 822295F8h case   17:*/		return 0x822295FC;
		  /* 822295FCh */ case   18:  		/* rlwimi R9, R11, 19, 2, 2 */
		/* 822295FCh case   18:*/		cpu::op::rlwimi<0,19,2,2>(regs,&regs.R9,regs.R11);
		/* 822295FCh case   18:*/		return 0x82229600;
		  /* 82229600h */ case   19:  		/* rlwinm R7, R11, 21, 24, 31 */
		/* 82229600h case   19:*/		cpu::op::rlwinm<0,21,24,31>(regs,&regs.R7,regs.R11);
		/* 82229600h case   19:*/		return 0x82229604;
		  /* 82229604h */ case   20:  		/* stw R10, <#[R31 + 4]> */
		/* 82229604h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229604h case   20:*/		return 0x82229608;
		  /* 82229608h */ case   21:  		/* stw R9, <#[R31 + 8]> */
		/* 82229608h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82229608h case   21:*/		return 0x8222960C;
		  /* 8222960Ch */ case   22:  		/* stb R8, <#[R31 + 7]> */
		/* 8222960Ch case   22:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R31 + 0x00000007) );
		/* 8222960Ch case   22:*/		return 0x82229610;
		  /* 82229610h */ case   23:  		/* stb R7, <#[R31 + 11]> */
		/* 82229610h case   23:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R31 + 0x0000000B) );
		/* 82229610h case   23:*/		return 0x82229614;
		  /* 82229614h */ case   24:  		/* bc 12, CR0_EQ, 32 */
		/* 82229614h case   24:*/		if ( regs.CR[0].eq ) { return 0x82229634;  }
		/* 82229614h case   24:*/		return 0x82229618;
		  /* 82229618h */ case   25:  		/* lwz R10, <#[R31 + 4]> */
		/* 82229618h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229618h case   25:*/		return 0x8222961C;
		  /* 8222961Ch */ case   26:  		/* cmplwi CR6, R30, 0 */
		/* 8222961Ch case   26:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8222961Ch case   26:*/		return 0x82229620;
		  /* 82229620h */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 82229620h case   27:*/		if ( regs.CR[6].eq ) { return 0x8222962C;  }
		/* 82229620h case   27:*/		return 0x82229624;
		  /* 82229624h */ case   28:  		/* rlwimi R10, R11, 21, 1, 1 */
		/* 82229624h case   28:*/		cpu::op::rlwimi<0,21,1,1>(regs,&regs.R10,regs.R11);
		/* 82229624h case   28:*/		return 0x82229628;
		  /* 82229628h */ case   29:  		/* b 8 */
		/* 82229628h case   29:*/		return 0x82229630;
		/* 82229628h case   29:*/		return 0x8222962C;
	}
	return 0x8222962C;
} // Block from 822295B4h-8222962Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 8222962Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222962C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222962C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222962C);
		  /* 8222962Ch */ case    0:  		/* rlwimi R10, R11, 22, 0, 0 */
		/* 8222962Ch case    0:*/		cpu::op::rlwimi<0,22,0,0>(regs,&regs.R10,regs.R11);
		/* 8222962Ch case    0:*/		return 0x82229630;
	}
	return 0x82229630;
} // Block from 8222962Ch-82229630h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82229630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229630);
		  /* 82229630h */ case    0:  		/* stw R10, <#[R31 + 4]> */
		/* 82229630h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82229630h case    0:*/		return 0x82229634;
	}
	return 0x82229634;
} // Block from 82229630h-82229634h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82229634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229634);
		  /* 82229634h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82229634h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82229634h case    0:*/		return 0x82229638;
		  /* 82229638h */ case    1:  		/* rlwinm. R10, R11, 0, 2, 2 */
		/* 82229638h case    1:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R11);
		/* 82229638h case    1:*/		return 0x8222963C;
		  /* 8222963Ch */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 8222963Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82229664;  }
		/* 8222963Ch case    2:*/		return 0x82229640;
		  /* 82229640h */ case    3:  		/* rlwinm. R10, R11, 0, 0, 0 */
		/* 82229640h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R11);
		/* 82229640h case    3:*/		return 0x82229644;
		  /* 82229644h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 82229644h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82229664;  }
		/* 82229644h case    4:*/		return 0x82229648;
		  /* 82229648h */ case    5:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82229648h case    5:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82229648h case    5:*/		return 0x8222964C;
		  /* 8222964Ch */ case    6:  		/* bc 4, CR0_EQ, 24 */
		/* 8222964Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x82229664;  }
		/* 8222964Ch case    6:*/		return 0x82229650;
		  /* 82229650h */ case    7:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 82229650h case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 82229650h case    7:*/		return 0x82229654;
		  /* 82229654h */ case    8:  		/* li R4, 4800 */
		/* 82229654h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82229654h case    8:*/		return 0x82229658;
		  /* 82229658h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82229658h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82229658h case    9:*/		return 0x8222965C;
		  /* 8222965Ch */ case   10:  		/* lwz R3, <#[R11 + 148]> */
		/* 8222965Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 8222965Ch case   10:*/		return 0x82229660;
		  /* 82229660h */ case   11:  		/* bl -882680 */
		/* 82229660h case   11:*/		regs.LR = 0x82229664; return 0x82151E68;
		/* 82229660h case   11:*/		return 0x82229664;
	}
	return 0x82229664;
} // Block from 82229634h-82229664h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82229664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229664);
		  /* 82229664h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229664h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229664h case    0:*/		return 0x82229668;
		  /* 82229668h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82229668h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82229668h case    1:*/		return 0x8222966C;
		  /* 8222966Ch */ case    2:  		/* cmplwi CR6, R11, 21 */
		/* 8222966Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8222966Ch case    2:*/		return 0x82229670;
		  /* 82229670h */ case    3:  		/* bc 12, CR6_LT, 1008 */
		/* 82229670h case    3:*/		if ( regs.CR[6].lt ) { return 0x82229A60;  }
		/* 82229670h case    3:*/		return 0x82229674;
		  /* 82229674h */ case    4:  		/* cmplwi CR6, R11, 24 */
		/* 82229674h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 82229674h case    4:*/		return 0x82229678;
		  /* 82229678h */ case    5:  		/* bc 12, CR6_GT, 1000 */
		/* 82229678h case    5:*/		if ( regs.CR[6].gt ) { return 0x82229A60;  }
		/* 82229678h case    5:*/		return 0x8222967C;
		  /* 8222967Ch */ case    6:  		/* lbz R11, <#[R31 + 5]> */
		/* 8222967Ch case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 8222967Ch case    6:*/		return 0x82229680;
		  /* 82229680h */ case    7:  		/* lbz R10, <#[R31 + 6]> */
		/* 82229680h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 82229680h case    7:*/		return 0x82229684;
		  /* 82229684h */ case    8:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82229684h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82229684h case    8:*/		return 0x82229688;
		  /* 82229688h */ case    9:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82229688h case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82229688h case    9:*/		return 0x8222968C;
		  /* 8222968Ch */ case   10:  		/* addi R9, R11, -2 */
		/* 8222968Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFE);
		/* 8222968Ch case   10:*/		return 0x82229690;
		  /* 82229690h */ case   11:  		/* addi R8, R11, -1 */
		/* 82229690h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82229690h case   11:*/		return 0x82229694;
		  /* 82229694h */ case   12:  		/* addi R7, R10, -2 */
		/* 82229694h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFFE);
		/* 82229694h case   12:*/		return 0x82229698;
		  /* 82229698h */ case   13:  		/* addi R6, R10, -1 */
		/* 82229698h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFFF);
		/* 82229698h case   13:*/		return 0x8222969C;
		  /* 8222969Ch */ case   14:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 8222969Ch case   14:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 8222969Ch case   14:*/		return 0x822296A0;
		  /* 822296A0h */ case   15:  		/* rlwimi R6, R7, 2, 28, 29 */
		/* 822296A0h case   15:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R7);
		/* 822296A0h case   15:*/		return 0x822296A4;
		  /* 822296A4h */ case   16:  		/* addi R9, R11, 1 */
		/* 822296A4h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 822296A4h case   16:*/		return 0x822296A8;
		  /* 822296A8h */ case   17:  		/* addi R7, R10, 1 */
		/* 822296A8h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x1);
		/* 822296A8h case   17:*/		return 0x822296AC;
		  /* 822296ACh */ case   18:  		/* rlwinm R8, R8, 2, 26, 29 */
		/* 822296ACh case   18:*/		cpu::op::rlwinm<0,2,26,29>(regs,&regs.R8,regs.R8);
		/* 822296ACh case   18:*/		return 0x822296B0;
		  /* 822296B0h */ case   19:  		/* rlwinm R9, R9, 6, 24, 25 */
		/* 822296B0h case   19:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R9,regs.R9);
		/* 822296B0h case   19:*/		return 0x822296B4;
		  /* 822296B4h */ case   20:  		/* rlwinm R6, R6, 2, 26, 29 */
		/* 822296B4h case   20:*/		cpu::op::rlwinm<0,2,26,29>(regs,&regs.R6,regs.R6);
		/* 822296B4h case   20:*/		return 0x822296B8;
		  /* 822296B8h */ case   21:  		/* rlwinm R7, R7, 6, 24, 25 */
		/* 822296B8h case   21:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R7,regs.R7);
		/* 822296B8h case   21:*/		return 0x822296BC;
		  /* 822296BCh */ case   22:  		/* or R9, R8, R9 */
		/* 822296BCh case   22:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822296BCh case   22:*/		return 0x822296C0;
		  /* 822296C0h */ case   23:  		/* or R8, R6, R7 */
		/* 822296C0h case   23:*/		cpu::op::or<0>(regs,&regs.R8,regs.R6,regs.R7);
		/* 822296C0h case   23:*/		return 0x822296C4;
		  /* 822296C4h */ case   24:  		/* or R11, R9, R11 */
		/* 822296C4h case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822296C4h case   24:*/		return 0x822296C8;
		  /* 822296C8h */ case   25:  		/* or R10, R8, R10 */
		/* 822296C8h case   25:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 822296C8h case   25:*/		return 0x822296CC;
		  /* 822296CCh */ case   26:  		/* stb R11, <#[R31 + 5]> */
		/* 822296CCh case   26:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000005) );
		/* 822296CCh case   26:*/		return 0x822296D0;
		  /* 822296D0h */ case   27:  		/* stb R10, <#[R31 + 6]> */
		/* 822296D0h case   27:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 822296D0h case   27:*/		return 0x822296D4;
		  /* 822296D4h */ case   28:  		/* b 908 */
		/* 822296D4h case   28:*/		return 0x82229A60;
		/* 822296D4h case   28:*/		return 0x822296D8;
	}
	return 0x822296D8;
} // Block from 82229664h-822296D8h (29 instructions)

//////////////////////////////////////////////////////
// Block at 822296D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822296D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822296D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822296D8);
		  /* 822296D8h */ case    0:  		/* rlwinm. R27, R25, 0, 24, 31 */
		/* 822296D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R27,regs.R25);
		/* 822296D8h case    0:*/		return 0x822296DC;
		  /* 822296DCh */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 822296DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x822296EC;  }
		/* 822296DCh case    1:*/		return 0x822296E0;
		  /* 822296E0h */ case    2:  		/* li R11, 226 */
		/* 822296E0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xE2);
		/* 822296E0h case    2:*/		return 0x822296E4;
		  /* 822296E4h */ case    3:  		/* stb R11, <#[R31 + 8]> */
		/* 822296E4h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822296E4h case    3:*/		return 0x822296E8;
		  /* 822296E8h */ case    4:  		/* b 80 */
		/* 822296E8h case    4:*/		return 0x82229738;
		/* 822296E8h case    4:*/		return 0x822296EC;
	}
	return 0x822296EC;
} // Block from 822296D8h-822296ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822296ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822296EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822296EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822296EC);
		  /* 822296ECh */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 822296ECh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 822296ECh case    0:*/		return 0x822296F0;
		  /* 822296F0h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 822296F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 822296F0h case    1:*/		return 0x822296F4;
		  /* 822296F4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 822296F4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 822296F4h case    2:*/		return 0x822296F8;
		  /* 822296F8h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 822296F8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82229704;  }
		/* 822296F8h case    3:*/		return 0x822296FC;
		  /* 822296FCh */ case    4:  		/* mr R11, R28 */
		/* 822296FCh case    4:*/		regs.R11 = regs.R28;
		/* 822296FCh case    4:*/		return 0x82229700;
		  /* 82229700h */ case    5:  		/* b 12 */
		/* 82229700h case    5:*/		return 0x8222970C;
		/* 82229700h case    5:*/		return 0x82229704;
	}
	return 0x82229704;
} // Block from 822296ECh-82229704h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82229704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229704);
		  /* 82229704h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82229704h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82229704h case    0:*/		return 0x82229708;
		  /* 82229708h */ case    1:  		/* addi R11, R11, -40 */
		/* 82229708h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82229708h case    1:*/		return 0x8222970C;
	}
	return 0x8222970C;
} // Block from 82229704h-8222970Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222970Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222970C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222970C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222970C);
		  /* 8222970Ch */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222970Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222970Ch case    0:*/		return 0x82229710;
		  /* 82229710h */ case    1:  		/* rlwinm. R11, R11, 13, 29, 31 */
		/* 82229710h case    1:*/		cpu::op::rlwinm<1,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82229710h case    1:*/		return 0x82229714;
		  /* 82229714h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 82229714h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82229724;  }
		/* 82229714h case    2:*/		return 0x82229718;
		  /* 82229718h */ case    3:  		/* lwz R10, <#[R31 + 8]> */
		/* 82229718h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82229718h case    3:*/		return 0x8222971C;
		  /* 8222971Ch */ case    4:  		/* oris R10, R10, 32768 */
		/* 8222971Ch case    4:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 8222971Ch case    4:*/		return 0x82229720;
		  /* 82229720h */ case    5:  		/* stw R10, <#[R31 + 8]> */
		/* 82229720h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82229720h case    5:*/		return 0x82229724;
	}
	return 0x82229724;
} // Block from 8222970Ch-82229724h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82229724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229724);
		  /* 82229724h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 82229724h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82229724h case    0:*/		return 0x82229728;
		  /* 82229728h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82229728h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82229738;  }
		/* 82229728h case    1:*/		return 0x8222972C;
		  /* 8222972Ch */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8222972Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8222972Ch case    2:*/		return 0x82229730;
		  /* 82229730h */ case    3:  		/* oris R11, R11, 16384 */
		/* 82229730h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82229730h case    3:*/		return 0x82229734;
		  /* 82229734h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 82229734h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82229734h case    4:*/		return 0x82229738;
	}
	return 0x82229738;
} // Block from 82229724h-82229738h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82229738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229738);
		  /* 82229738h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229738h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229738h case    0:*/		return 0x8222973C;
		  /* 8222973Ch */ case    1:  		/* lwz R10, <#[R31]> */
		/* 8222973Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222973Ch case    1:*/		return 0x82229740;
		  /* 82229740h */ case    2:  		/* rlwinm R11, R11, 25, 7, 31 */
		/* 82229740h case    2:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R11,regs.R11);
		/* 82229740h case    2:*/		return 0x82229744;
		  /* 82229744h */ case    3:  		/* addi R11, R11, -32 */
		/* 82229744h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFE0);
		/* 82229744h case    3:*/		return 0x82229748;
		  /* 82229748h */ case    4:  		/* rlwimi R10, R11, 26, 0, 5 */
		/* 82229748h case    4:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R10,regs.R11);
		/* 82229748h case    4:*/		return 0x8222974C;
		  /* 8222974Ch */ case    5:  		/* stw R10, <#[R31]> */
		/* 8222974Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222974Ch case    5:*/		return 0x82229750;
		  /* 82229750h */ case    6:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229750h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229750h case    6:*/		return 0x82229754;
		  /* 82229754h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82229754h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82229754h case    7:*/		return 0x82229758;
		  /* 82229758h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82229758h case    8:*/		if ( regs.CR[0].eq ) { return 0x82229768;  }
		/* 82229758h case    8:*/		return 0x8222975C;
		  /* 8222975Ch */ case    9:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 8222975Ch case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 8222975Ch case    9:*/		return 0x82229760;
		  /* 82229760h */ case   10:  		/* oris R11, R11, 512 */
		/* 82229760h case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82229760h case   10:*/		return 0x82229764;
		  /* 82229764h */ case   11:  		/* stw R11, <#[R31]> */
		/* 82229764h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229764h case   11:*/		return 0x82229768;
	}
	return 0x82229768;
} // Block from 82229738h-82229768h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82229768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229768);
		  /* 82229768h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229768h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229768h case    0:*/		return 0x8222976C;
		  /* 8222976Ch */ case    1:  		/* lwz R10, <#[R31]> */
		/* 8222976Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8222976Ch case    1:*/		return 0x82229770;
		  /* 82229770h */ case    2:  		/* rlwinm R11, R11, 19, 0, 12 */
		/* 82229770h case    2:*/		cpu::op::rlwinm<0,19,0,12>(regs,&regs.R11,regs.R11);
		/* 82229770h case    2:*/		return 0x82229774;
		  /* 82229774h */ case    3:  		/* or R11, R11, R10 */
		/* 82229774h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82229774h case    3:*/		return 0x82229778;
		  /* 82229778h */ case    4:  		/* rlwimi R11, R10, 0, 12, 7 */
		/* 82229778h case    4:*/		cpu::op::rlwimi<0,0,12,7>(regs,&regs.R11,regs.R10);
		/* 82229778h case    4:*/		return 0x8222977C;
		  /* 8222977Ch */ case    5:  		/* stw R11, <#[R31]> */
		/* 8222977Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8222977Ch case    5:*/		return 0x82229780;
		  /* 82229780h */ case    6:  		/* lwz R11, <#[R26 + 4]> */
		/* 82229780h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82229780h case    6:*/		return 0x82229784;
		  /* 82229784h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82229784h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82229784h case    7:*/		return 0x82229788;
		  /* 82229788h */ case    8:  		/* bc 12, CR6_EQ, 120 */
		/* 82229788h case    8:*/		if ( regs.CR[6].eq ) { return 0x82229800;  }
		/* 82229788h case    8:*/		return 0x8222978C;
		  /* 8222978Ch */ case    9:  		/* lwz R10, <#[R11 + 16]> */
		/* 8222978Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8222978Ch case    9:*/		return 0x82229790;
		  /* 82229790h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82229790h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82229790h case   10:*/		return 0x82229794;
		  /* 82229794h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 82229794h case   11:*/		if ( regs.CR[6].eq ) { return 0x822297A4;  }
		/* 82229794h case   11:*/		return 0x82229798;
		  /* 82229798h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 82229798h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82229798h case   12:*/		return 0x8222979C;
		  /* 8222979Ch */ case   13:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 8222979Ch case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 8222979Ch case   13:*/		return 0x822297A0;
		  /* 822297A0h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 822297A0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x822297AC;  }
		/* 822297A0h case   14:*/		return 0x822297A4;
	}
	return 0x822297A4;
} // Block from 82229768h-822297A4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822297A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822297A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822297A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822297A4);
		  /* 822297A4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 822297A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822297A4h case    0:*/		return 0x822297A8;
		  /* 822297A8h */ case    1:  		/* b -36 */
		/* 822297A8h case    1:*/		return 0x82229784;
		/* 822297A8h case    1:*/		return 0x822297AC;
	}
	return 0x822297AC;
} // Block from 822297A4h-822297ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822297ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822297AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822297AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822297AC);
		  /* 822297ACh */ case    0:  		/* lwz R9, <#[R26 + 8]> */
		/* 822297ACh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000008) );
		/* 822297ACh case    0:*/		return 0x822297B0;
		  /* 822297B0h */ case    1:  		/* rlwinm. R9, R9, 27, 31, 31 */
		/* 822297B0h case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R9);
		/* 822297B0h case    1:*/		return 0x822297B4;
		  /* 822297B4h */ case    2:  		/* bc 12, CR0_EQ, 36 */
		/* 822297B4h case    2:*/		if ( regs.CR[0].eq ) { return 0x822297D8;  }
		/* 822297B4h case    2:*/		return 0x822297B8;
		  /* 822297B8h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 822297B8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822297B8h case    3:*/		return 0x822297BC;
		  /* 822297BCh */ case    4:  		/* ori R10, R10, 32768 */
		/* 822297BCh case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 822297BCh case    4:*/		return 0x822297C0;
		  /* 822297C0h */ case    5:  		/* stw R10, <#[R31]> */
		/* 822297C0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822297C0h case    5:*/		return 0x822297C4;
		  /* 822297C4h */ case    6:  		/* mr R9, R10 */
		/* 822297C4h case    6:*/		regs.R9 = regs.R10;
		/* 822297C4h case    6:*/		return 0x822297C8;
		  /* 822297C8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 822297C8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822297C8h case    7:*/		return 0x822297CC;
		  /* 822297CCh */ case    8:  		/* rlwimi R9, R11, 15, 26, 31 */
		/* 822297CCh case    8:*/		cpu::op::rlwimi<0,15,26,31>(regs,&regs.R9,regs.R11);
		/* 822297CCh case    8:*/		return 0x822297D0;
		  /* 822297D0h */ case    9:  		/* stw R9, <#[R31]> */
		/* 822297D0h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 822297D0h case    9:*/		return 0x822297D4;
		  /* 822297D4h */ case   10:  		/* b 136 */
		/* 822297D4h case   10:*/		return 0x8222985C;
		/* 822297D4h case   10:*/		return 0x822297D8;
	}
	return 0x822297D8;
} // Block from 822297ACh-822297D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822297D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822297D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822297D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822297D8);
		  /* 822297D8h */ case    0:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 822297D8h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 822297D8h case    0:*/		return 0x822297DC;
		  /* 822297DCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 822297DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x822297EC;  }
		/* 822297DCh case    1:*/		return 0x822297E0;
		  /* 822297E0h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 822297E0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822297E0h case    2:*/		return 0x822297E4;
		  /* 822297E4h */ case    3:  		/* ori R10, R10, 16384 */
		/* 822297E4h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 822297E4h case    3:*/		return 0x822297E8;
		  /* 822297E8h */ case    4:  		/* stw R10, <#[R31]> */
		/* 822297E8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822297E8h case    4:*/		return 0x822297EC;
	}
	return 0x822297EC;
} // Block from 822297D8h-822297ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822297ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822297EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822297EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822297EC);
		  /* 822297ECh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 822297ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822297ECh case    0:*/		return 0x822297F0;
		  /* 822297F0h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 822297F0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822297F0h case    1:*/		return 0x822297F4;
		  /* 822297F4h */ case    2:  		/* rlwimi R10, R11, 23, 18, 23 */
		/* 822297F4h case    2:*/		cpu::op::rlwimi<0,23,18,23>(regs,&regs.R10,regs.R11);
		/* 822297F4h case    2:*/		return 0x822297F8;
		  /* 822297F8h */ case    3:  		/* stw R10, <#[R31]> */
		/* 822297F8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 822297F8h case    3:*/		return 0x822297FC;
		  /* 822297FCh */ case    4:  		/* b 96 */
		/* 822297FCh case    4:*/		return 0x8222985C;
		/* 822297FCh case    4:*/		return 0x82229800;
	}
	return 0x82229800;
} // Block from 822297ECh-82229800h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82229800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229800);
		  /* 82229800h */ case    0:  		/* mr R3, R26 */
		/* 82229800h case    0:*/		regs.R3 = regs.R26;
		/* 82229800h case    0:*/		return 0x82229804;
		  /* 82229804h */ case    1:  		/* bl -808644 */
		/* 82229804h case    1:*/		regs.LR = 0x82229808; return 0x82164140;
		/* 82229804h case    1:*/		return 0x82229808;
		  /* 82229808h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229808h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229808h case    2:*/		return 0x8222980C;
		  /* 8222980Ch */ case    3:  		/* bc 12, CR0_EQ, 80 */
		/* 8222980Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8222985C;  }
		/* 8222980Ch case    3:*/		return 0x82229810;
		  /* 82229810h */ case    4:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229810h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229810h case    4:*/		return 0x82229814;
		  /* 82229814h */ case    5:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82229814h case    5:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82229814h case    5:*/		return 0x82229818;
		  /* 82229818h */ case    6:  		/* bc 12, CR0_EQ, 184 */
		/* 82229818h case    6:*/		if ( regs.CR[0].eq ) { return 0x822298D0;  }
		/* 82229818h case    6:*/		return 0x8222981C;
		  /* 8222981Ch */ case    7:  		/* lwz R30, <#[R26 + 44]> */
		/* 8222981Ch case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x0000002C) );
		/* 8222981Ch case    7:*/		return 0x82229820;
		  /* 82229820h */ case    8:  		/* mr R3, R30 */
		/* 82229820h case    8:*/		regs.R3 = regs.R30;
		/* 82229820h case    8:*/		return 0x82229824;
		  /* 82229824h */ case    9:  		/* bl -806900 */
		/* 82229824h case    9:*/		regs.LR = 0x82229828; return 0x82164830;
		/* 82229824h case    9:*/		return 0x82229828;
		  /* 82229828h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229828h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229828h case   10:*/		return 0x8222982C;
		  /* 8222982Ch */ case   11:  		/* bc 12, CR0_EQ, 48 */
		/* 8222982Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8222985C;  }
		/* 8222982Ch case   11:*/		return 0x82229830;
		  /* 82229830h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 82229830h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82229830h case   12:*/		return 0x82229834;
		  /* 82229834h */ case   13:  		/* lwz R10, <#[R31]> */
		/* 82229834h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82229834h case   13:*/		return 0x82229838;
		  /* 82229838h */ case   14:  		/* rlwinm R11, R11, 19, 20, 31 */
		/* 82229838h case   14:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R11);
		/* 82229838h case   14:*/		return 0x8222983C;
		  /* 8222983Ch */ case   15:  		/* rlwinm R10, R10, 0, 24, 17 */
		/* 8222983Ch case   15:*/		cpu::op::rlwinm<0,0,24,17>(regs,&regs.R10,regs.R10);
		/* 8222983Ch case   15:*/		return 0x82229840;
		  /* 82229840h */ case   16:  		/* rlwinm R9, R11, 16, 12, 15 */
		/* 82229840h case   16:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R9,regs.R11);
		/* 82229840h case   16:*/		return 0x82229844;
		  /* 82229844h */ case   17:  		/* rlwinm R11, R11, 0, 22, 27 */
		/* 82229844h case   17:*/		cpu::op::rlwinm<0,0,22,27>(regs,&regs.R11,regs.R11);
		/* 82229844h case   17:*/		return 0x82229848;
		  /* 82229848h */ case   18:  		/* rlwinm R10, R10, 0, 12, 7 */
		/* 82229848h case   18:*/		cpu::op::rlwinm<0,0,12,7>(regs,&regs.R10,regs.R10);
		/* 82229848h case   18:*/		return 0x8222984C;
		  /* 8222984Ch */ case   19:  		/* or R11, R9, R11 */
		/* 8222984Ch case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8222984Ch case   19:*/		return 0x82229850;
		  /* 82229850h */ case   20:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 82229850h case   20:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 82229850h case   20:*/		return 0x82229854;
		  /* 82229854h */ case   21:  		/* or R11, R11, R10 */
		/* 82229854h case   21:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82229854h case   21:*/		return 0x82229858;
		  /* 82229858h */ case   22:  		/* stw R11, <#[R31]> */
		/* 82229858h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229858h case   22:*/		return 0x8222985C;
	}
	return 0x8222985C;
} // Block from 82229800h-8222985Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8222985Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222985C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222985C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222985C);
		  /* 8222985Ch */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 8222985Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8222985Ch case    0:*/		return 0x82229860;
		  /* 82229860h */ case    1:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82229860h case    1:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82229860h case    1:*/		return 0x82229864;
		  /* 82229864h */ case    2:  		/* bc 12, CR0_EQ, 508 */
		/* 82229864h case    2:*/		if ( regs.CR[0].eq ) { return 0x82229A60;  }
		/* 82229864h case    2:*/		return 0x82229868;
		  /* 82229868h */ case    3:  		/* mr R29, R28 */
		/* 82229868h case    3:*/		regs.R29 = regs.R28;
		/* 82229868h case    3:*/		return 0x8222986C;
		  /* 8222986Ch */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 8222986Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8222986Ch case    4:*/		return 0x82229870;
		  /* 82229870h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82229870h case    5:*/		if ( regs.CR[6].eq ) { return 0x82229890;  }
		/* 82229870h case    5:*/		return 0x82229874;
		  /* 82229874h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82229874h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82229874h case    6:*/		return 0x82229878;
		  /* 82229878h */ case    7:  		/* rlwinm. R10, R11, 0, 0, 0 */
		/* 82229878h case    7:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R11);
		/* 82229878h case    7:*/		return 0x8222987C;
		  /* 8222987Ch */ case    8:  		/* bc 4, CR0_EQ, 8 */
		/* 8222987Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x82229884;  }
		/* 8222987Ch case    8:*/		return 0x82229880;
		  /* 82229880h */ case    9:  		/* li R29, 1 */
		/* 82229880h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82229880h case    9:*/		return 0x82229884;
	}
	return 0x82229884;
} // Block from 8222985Ch-82229884h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82229884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229884);
		  /* 82229884h */ case    0:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82229884h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82229884h case    0:*/		return 0x82229888;
		  /* 82229888h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 82229888h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82229890;  }
		/* 82229888h case    1:*/		return 0x8222988C;
		  /* 8222988Ch */ case    2:  		/* addi R29, R29, 1 */
		/* 8222988Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8222988Ch case    2:*/		return 0x82229890;
	}
	return 0x82229890;
} // Block from 82229884h-82229890h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82229890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229890);
		  /* 82229890h */ case    0:  		/* stw R28, <#[R1 + 80]> */
		/* 82229890h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82229890h case    0:*/		return 0x82229894;
		  /* 82229894h */ case    1:  		/* addi R7, R1, 80 */
		/* 82229894h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82229894h case    1:*/		return 0x82229898;
		  /* 82229898h */ case    2:  		/* mr R6, R29 */
		/* 82229898h case    2:*/		regs.R6 = regs.R29;
		/* 82229898h case    2:*/		return 0x8222989C;
		  /* 8222989Ch */ case    3:  		/* mr R5, R31 */
		/* 8222989Ch case    3:*/		regs.R5 = regs.R31;
		/* 8222989Ch case    3:*/		return 0x822298A0;
		  /* 822298A0h */ case    4:  		/* li R4, 0 */
		/* 822298A0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822298A0h case    4:*/		return 0x822298A4;
		  /* 822298A4h */ case    5:  		/* mr R3, R26 */
		/* 822298A4h case    5:*/		regs.R3 = regs.R26;
		/* 822298A4h case    5:*/		return 0x822298A8;
		  /* 822298A8h */ case    6:  		/* bl -31536 */
		/* 822298A8h case    6:*/		regs.LR = 0x822298AC; return 0x82221D78;
		/* 822298A8h case    6:*/		return 0x822298AC;
		  /* 822298ACh */ case    7:  		/* lwz R30, <#[R1 + 80]> */
		/* 822298ACh case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 822298ACh case    7:*/		return 0x822298B0;
		  /* 822298B0h */ case    8:  		/* add R6, R3, R29 */
		/* 822298B0h case    8:*/		cpu::op::add<0>(regs,&regs.R6,regs.R3,regs.R29);
		/* 822298B0h case    8:*/		return 0x822298B4;
		  /* 822298B4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 822298B4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822298B4h case    9:*/		return 0x822298B8;
		  /* 822298B8h */ case   10:  		/* bc 12, CR0_EQ, 84 */
		/* 822298B8h case   10:*/		if ( regs.CR[0].eq ) { return 0x8222990C;  }
		/* 822298B8h case   10:*/		return 0x822298BC;
		  /* 822298BCh */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 822298BCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822298BCh case   11:*/		return 0x822298C0;
		  /* 822298C0h */ case   12:  		/* cmplwi CR6, R6, 2 */
		/* 822298C0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000002);
		/* 822298C0h case   12:*/		return 0x822298C4;
		  /* 822298C4h */ case   13:  		/* bc 4, CR6_EQ, 64 */
		/* 822298C4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82229904;  }
		/* 822298C4h case   13:*/		return 0x822298C8;
		  /* 822298C8h */ case   14:  		/* rlwimi R11, R30, 21, 1, 1 */
		/* 822298C8h case   14:*/		cpu::op::rlwimi<0,21,1,1>(regs,&regs.R11,regs.R30);
		/* 822298C8h case   14:*/		return 0x822298CC;
		  /* 822298CCh */ case   15:  		/* b 60 */
		/* 822298CCh case   15:*/		return 0x82229908;
		/* 822298CCh case   15:*/		return 0x822298D0;
	}
	return 0x822298D0;
} // Block from 82229890h-822298D0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822298D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822298D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822298D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822298D0);
		  /* 822298D0h */ case    0:  		/* lwz R30, <#[R26]> */
		/* 822298D0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 822298D0h case    0:*/		return 0x822298D4;
		  /* 822298D4h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 822298D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822298D4h case    1:*/		return 0x822298D8;
		  /* 822298D8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 822298D8h case    2:*/		if ( regs.CR[6].eq ) { return 0x822298F0;  }
		/* 822298D8h case    2:*/		return 0x822298DC;
		  /* 822298DCh */ case    3:  		/* lwz R11, <#[R30]> */
		/* 822298DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822298DCh case    3:*/		return 0x822298E0;
		  /* 822298E0h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 822298E0h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 822298E0h case    4:*/		return 0x822298E4;
		  /* 822298E4h */ case    5:  		/* bc 4, CR0_EQ, -196 */
		/* 822298E4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82229820;  }
		/* 822298E4h case    5:*/		return 0x822298E8;
		  /* 822298E8h */ case    6:  		/* lwz R30, <#[R30 + 4]> */
		/* 822298E8h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 822298E8h case    6:*/		return 0x822298EC;
		  /* 822298ECh */ case    7:  		/* b -24 */
		/* 822298ECh case    7:*/		return 0x822298D4;
		/* 822298ECh case    7:*/		return 0x822298F0;
	}
	return 0x822298F0;
} // Block from 822298D0h-822298F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822298F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822298F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822298F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822298F0);
		  /* 822298F0h */ case    0:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 822298F0h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 822298F0h case    0:*/		return 0x822298F4;
		  /* 822298F4h */ case    1:  		/* li R4, 4800 */
		/* 822298F4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 822298F4h case    1:*/		return 0x822298F8;
		  /* 822298F8h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 822298F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822298F8h case    2:*/		return 0x822298FC;
		  /* 822298FCh */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 822298FCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 822298FCh case    3:*/		return 0x82229900;
		  /* 82229900h */ case    4:  		/* bl -883352 */
		/* 82229900h case    4:*/		regs.LR = 0x82229904; return 0x82151E68;
		/* 82229900h case    4:*/		return 0x82229904;
	}
	return 0x82229904;
} // Block from 822298F0h-82229904h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82229904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229904);
		  /* 82229904h */ case    0:  		/* rlwimi R11, R30, 22, 0, 0 */
		/* 82229904h case    0:*/		cpu::op::rlwimi<0,22,0,0>(regs,&regs.R11,regs.R30);
		/* 82229904h case    0:*/		return 0x82229908;
	}
	return 0x82229908;
} // Block from 82229904h-82229908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82229908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229908);
		  /* 82229908h */ case    0:  		/* stw R11, <#[R31 + 4]> */
		/* 82229908h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82229908h case    0:*/		return 0x8222990C;
	}
	return 0x8222990C;
} // Block from 82229908h-8222990Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222990Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222990C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222990C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222990C);
		  /* 8222990Ch */ case    0:  		/* lwz R5, <#[R31 + 4]> */
		/* 8222990Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000004) );
		/* 8222990Ch case    0:*/		return 0x82229910;
		  /* 82229910h */ case    1:  		/* rlwinm R11, R30, 21, 24, 31 */
		/* 82229910h case    1:*/		cpu::op::rlwinm<0,21,24,31>(regs,&regs.R11,regs.R30);
		/* 82229910h case    1:*/		return 0x82229914;
		  /* 82229914h */ case    2:  		/* lis R4, 16 */
		/* 82229914h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x10);
		/* 82229914h case    2:*/		return 0x82229918;
		  /* 82229918h */ case    3:  		/* rlwimi R5, R30, 24, 7, 7 */
		/* 82229918h case    3:*/		cpu::op::rlwimi<0,24,7,7>(regs,&regs.R5,regs.R30);
		/* 82229918h case    3:*/		return 0x8222991C;
		  /* 8222991Ch */ case    4:  		/* stb R11, <#[R31 + 11]> */
		/* 8222991Ch case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000000B) );
		/* 8222991Ch case    4:*/		return 0x82229920;
		  /* 82229920h */ case    5:  		/* stw R5, <#[R31 + 4]> */
		/* 82229920h case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000004) );
		/* 82229920h case    5:*/		return 0x82229924;
		  /* 82229924h */ case    6:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229924h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229924h case    6:*/		return 0x82229928;
		  /* 82229928h */ case    7:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 82229928h case    7:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82229928h case    7:*/		return 0x8222992C;
		  /* 8222992Ch */ case    8:  		/* cmplw CR6, R11, R4 */
		/* 8222992Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8222992Ch case    8:*/		return 0x82229930;
		  /* 82229930h */ case    9:  		/* bc 12, CR6_LT, 120 */
		/* 82229930h case    9:*/		if ( regs.CR[6].lt ) { return 0x822299A8;  }
		/* 82229930h case    9:*/		return 0x82229934;
		  /* 82229934h */ case   10:  		/* stw R28, <#[R1 + 80]> */
		/* 82229934h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82229934h case   10:*/		return 0x82229938;
		  /* 82229938h */ case   11:  		/* addi R7, R1, 80 */
		/* 82229938h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82229938h case   11:*/		return 0x8222993C;
		  /* 8222993Ch */ case   12:  		/* mr R5, R31 */
		/* 8222993Ch case   12:*/		regs.R5 = regs.R31;
		/* 8222993Ch case   12:*/		return 0x82229940;
		  /* 82229940h */ case   13:  		/* li R4, 1 */
		/* 82229940h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82229940h case   13:*/		return 0x82229944;
		  /* 82229944h */ case   14:  		/* mr R3, R26 */
		/* 82229944h case   14:*/		regs.R3 = regs.R26;
		/* 82229944h case   14:*/		return 0x82229948;
		  /* 82229948h */ case   15:  		/* bl -31696 */
		/* 82229948h case   15:*/		regs.LR = 0x8222994C; return 0x82221D78;
		/* 82229948h case   15:*/		return 0x8222994C;
		  /* 8222994Ch */ case   16:  		/* lwz R10, <#[R1 + 80]> */
		/* 8222994Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8222994Ch case   16:*/		return 0x82229950;
		  /* 82229950h */ case   17:  		/* rlwinm. R9, R10, 21, 31, 31 */
		/* 82229950h case   17:*/		cpu::op::rlwinm<1,21,31,31>(regs,&regs.R9,regs.R10);
		/* 82229950h case   17:*/		return 0x82229954;
		  /* 82229954h */ case   18:  		/* rlwinm R11, R10, 21, 24, 31 */
		/* 82229954h case   18:*/		cpu::op::rlwinm<0,21,24,31>(regs,&regs.R11,regs.R10);
		/* 82229954h case   18:*/		return 0x82229958;
		  /* 82229958h */ case   19:  		/* bc 12, CR0_EQ, 24 */
		/* 82229958h case   19:*/		if ( regs.CR[0].eq ) { return 0x82229970;  }
		/* 82229958h case   19:*/		return 0x8222995C;
		  /* 8222995Ch */ case   20:  		/* lwz R9, <#[R31]> */
		/* 8222995Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8222995Ch case   20:*/		return 0x82229960;
		  /* 82229960h */ case   21:  		/* rlwinm R8, R9, 0, 0, 5 */
		/* 82229960h case   21:*/		cpu::op::rlwinm<0,0,0,5>(regs,&regs.R8,regs.R9);
		/* 82229960h case   21:*/		return 0x82229964;
		  /* 82229964h */ case   22:  		/* addis R8, R8, 1024 */
		/* 82229964h case   22:*/		cpu::op::addis<0>(regs,&regs.R8,regs.R8,0x400);
		/* 82229964h case   22:*/		return 0x82229968;
		  /* 82229968h */ case   23:  		/* rlwimi R8, R9, 0, 6, 31 */
		/* 82229968h case   23:*/		cpu::op::rlwimi<0,0,6,31>(regs,&regs.R8,regs.R9);
		/* 82229968h case   23:*/		return 0x8222996C;
		  /* 8222996Ch */ case   24:  		/* stw R8, <#[R31]> */
		/* 8222996Ch case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8222996Ch case   24:*/		return 0x82229970;
	}
	return 0x82229970;
} // Block from 8222990Ch-82229970h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82229970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229970);
		  /* 82229970h */ case    0:  		/* rlwinm R7, R11, 30, 28, 29 */
		/* 82229970h case    0:*/		cpu::op::rlwinm<0,30,28,29>(regs,&regs.R7,regs.R11);
		/* 82229970h case    0:*/		return 0x82229974;
		  /* 82229974h */ case    1:  		/* lwz R8, <#[R31 + 8]> */
		/* 82229974h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82229974h case    1:*/		return 0x82229978;
		  /* 82229978h */ case    2:  		/* rlwinm R6, R11, 30, 30, 31 */
		/* 82229978h case    2:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R6,regs.R11);
		/* 82229978h case    2:*/		return 0x8222997C;
		  /* 8222997Ch */ case    3:  		/* rlwinm R9, R30, 31, 30, 31 */
		/* 8222997Ch case    3:*/		cpu::op::rlwinm<0,31,30,31>(regs,&regs.R9,regs.R30);
		/* 8222997Ch case    3:*/		return 0x82229980;
		  /* 82229980h */ case    4:  		/* or R7, R7, R6 */
		/* 82229980h case    4:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 82229980h case    4:*/		return 0x82229984;
		  /* 82229984h */ case    5:  		/* addi R9, R9, 1 */
		/* 82229984h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82229984h case    5:*/		return 0x82229988;
		  /* 82229988h */ case    6:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82229988h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82229988h case    6:*/		return 0x8222998C;
		  /* 8222998Ch */ case    7:  		/* rlwinm R9, R9, 6, 24, 25 */
		/* 8222998Ch case    7:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R9,regs.R9);
		/* 8222998Ch case    7:*/		return 0x82229990;
		  /* 82229990h */ case    8:  		/* rlwimi R8, R11, 28, 2, 2 */
		/* 82229990h case    8:*/		cpu::op::rlwimi<0,28,2,2>(regs,&regs.R8,regs.R11);
		/* 82229990h case    8:*/		return 0x82229994;
		  /* 82229994h */ case    9:  		/* rlwinm R10, R10, 31, 30, 31 */
		/* 82229994h case    9:*/		cpu::op::rlwinm<0,31,30,31>(regs,&regs.R10,regs.R10);
		/* 82229994h case    9:*/		return 0x82229998;
		  /* 82229998h */ case   10:  		/* or R9, R7, R9 */
		/* 82229998h case   10:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82229998h case   10:*/		return 0x8222999C;
		  /* 8222999Ch */ case   11:  		/* stw R8, <#[R31 + 8]> */
		/* 8222999Ch case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8222999Ch case   11:*/		return 0x822299A0;
		  /* 822299A0h */ case   12:  		/* or R11, R9, R10 */
		/* 822299A0h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 822299A0h case   12:*/		return 0x822299A4;
		  /* 822299A4h */ case   13:  		/* b 184 */
		/* 822299A4h case   13:*/		return 0x82229A5C;
		/* 822299A4h case   13:*/		return 0x822299A8;
	}
	return 0x822299A8;
} // Block from 82229970h-822299A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822299A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822299A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822299A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822299A8);
		  /* 822299A8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822299A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822299A8h case    0:*/		return 0x822299AC;
		  /* 822299ACh */ case    1:  		/* rlwinm R3, R30, 31, 24, 31 */
		/* 822299ACh case    1:*/		cpu::op::rlwinm<0,31,24,31>(regs,&regs.R3,regs.R30);
		/* 822299ACh case    1:*/		return 0x822299B0;
		  /* 822299B0h */ case    2:  		/* rlwimi R11, R30, 19, 2, 2 */
		/* 822299B0h case    2:*/		cpu::op::rlwimi<0,19,2,2>(regs,&regs.R11,regs.R30);
		/* 822299B0h case    2:*/		return 0x822299B4;
		  /* 822299B4h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 822299B4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822299B4h case    3:*/		return 0x822299B8;
		  /* 822299B8h */ case    4:  		/* bl -31880 */
		/* 822299B8h case    4:*/		regs.LR = 0x822299BC; return 0x82221D30;
		/* 822299B8h case    4:*/		return 0x822299BC;
		  /* 822299BCh */ case    5:  		/* mr R6, R3 */
		/* 822299BCh case    5:*/		regs.R6 = regs.R3;
		/* 822299BCh case    5:*/		return 0x822299C0;
		  /* 822299C0h */ case    6:  		/* cmplwi CR6, R27, 0 */
		/* 822299C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 822299C0h case    6:*/		return 0x822299C4;
		  /* 822299C4h */ case    7:  		/* bc 12, CR6_EQ, 112 */
		/* 822299C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82229A34;  }
		/* 822299C4h case    7:*/		return 0x822299C8;
		  /* 822299C8h */ case    8:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 822299C8h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 822299C8h case    8:*/		return 0x822299CC;
		  /* 822299CCh */ case    9:  		/* lwz R11, <#[R11 + 36]> */
		/* 822299CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 822299CCh case    9:*/		return 0x822299D0;
		  /* 822299D0h */ case   10:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 822299D0h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 822299D0h case   10:*/		return 0x822299D4;
		  /* 822299D4h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 822299D4h case   11:*/		if ( regs.CR[0].eq ) { return 0x822299E0;  }
		/* 822299D4h case   11:*/		return 0x822299D8;
		  /* 822299D8h */ case   12:  		/* mr R11, R28 */
		/* 822299D8h case   12:*/		regs.R11 = regs.R28;
		/* 822299D8h case   12:*/		return 0x822299DC;
		  /* 822299DCh */ case   13:  		/* b 12 */
		/* 822299DCh case   13:*/		return 0x822299E8;
		/* 822299DCh case   13:*/		return 0x822299E0;
	}
	return 0x822299E0;
} // Block from 822299A8h-822299E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822299E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822299E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822299E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822299E0);
		  /* 822299E0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 822299E0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 822299E0h case    0:*/		return 0x822299E4;
		  /* 822299E4h */ case    1:  		/* addi R11, R11, -40 */
		/* 822299E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 822299E4h case    1:*/		return 0x822299E8;
	}
	return 0x822299E8;
} // Block from 822299E0h-822299E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822299E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822299E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822299E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822299E8);
		  /* 822299E8h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 822299E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822299E8h case    0:*/		return 0x822299EC;
		  /* 822299ECh */ case    1:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 822299ECh case    1:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 822299ECh case    1:*/		return 0x822299F0;
		  /* 822299F0h */ case    2:  		/* cmplw CR6, R11, R4 */
		/* 822299F0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 822299F0h case    2:*/		return 0x822299F4;
		  /* 822299F4h */ case    3:  		/* bc 4, CR6_GT, 64 */
		/* 822299F4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82229A34;  }
		/* 822299F4h case    3:*/		return 0x822299F8;
		  /* 822299F8h */ case    4:  		/* rlwinm R3, R5, 0, 24, 31 */
		/* 822299F8h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R5);
		/* 822299F8h case    4:*/		return 0x822299FC;
		  /* 822299FCh */ case    5:  		/* bl -31948 */
		/* 822299FCh case    5:*/		regs.LR = 0x82229A00; return 0x82221D30;
		/* 822299FCh case    5:*/		return 0x82229A00;
		  /* 82229A00h */ case    6:  		/* rlwinm R11, R6, 30, 2, 31 */
		/* 82229A00h case    6:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R6);
		/* 82229A00h case    6:*/		return 0x82229A04;
		  /* 82229A04h */ case    7:  		/* rlwinm R10, R3, 30, 2, 31 */
		/* 82229A04h case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R3);
		/* 82229A04h case    7:*/		return 0x82229A08;
		  /* 82229A08h */ case    8:  		/* addi R11, R11, -2 */
		/* 82229A08h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 82229A08h case    8:*/		return 0x82229A0C;
		  /* 82229A0Ch */ case    9:  		/* addi R10, R10, -1 */
		/* 82229A0Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82229A0Ch case    9:*/		return 0x82229A10;
		  /* 82229A10h */ case   10:  		/* rlwinm R9, R6, 0, 30, 31 */
		/* 82229A10h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R6);
		/* 82229A10h case   10:*/		return 0x82229A14;
		  /* 82229A14h */ case   11:  		/* rlwimi R10, R11, 2, 28, 29 */
		/* 82229A14h case   11:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R10,regs.R11);
		/* 82229A14h case   11:*/		return 0x82229A18;
		  /* 82229A18h */ case   12:  		/* addi R9, R9, 1 */
		/* 82229A18h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82229A18h case   12:*/		return 0x82229A1C;
		  /* 82229A1Ch */ case   13:  		/* rlwinm R10, R10, 2, 26, 29 */
		/* 82229A1Ch case   13:*/		cpu::op::rlwinm<0,2,26,29>(regs,&regs.R10,regs.R10);
		/* 82229A1Ch case   13:*/		return 0x82229A20;
		  /* 82229A20h */ case   14:  		/* rlwinm R11, R9, 6, 24, 25 */
		/* 82229A20h case   14:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R11,regs.R9);
		/* 82229A20h case   14:*/		return 0x82229A24;
		  /* 82229A24h */ case   15:  		/* rlwinm R9, R3, 0, 30, 31 */
		/* 82229A24h case   15:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R3);
		/* 82229A24h case   15:*/		return 0x82229A28;
		  /* 82229A28h */ case   16:  		/* or R11, R10, R11 */
		/* 82229A28h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82229A28h case   16:*/		return 0x82229A2C;
		  /* 82229A2Ch */ case   17:  		/* or R11, R11, R9 */
		/* 82229A2Ch case   17:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82229A2Ch case   17:*/		return 0x82229A30;
		  /* 82229A30h */ case   18:  		/* b 44 */
		/* 82229A30h case   18:*/		return 0x82229A5C;
		/* 82229A30h case   18:*/		return 0x82229A34;
	}
	return 0x82229A34;
} // Block from 822299E8h-82229A34h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82229A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229A34);
		  /* 82229A34h */ case    0:  		/* rlwinm R11, R6, 0, 30, 31 */
		/* 82229A34h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R6);
		/* 82229A34h case    0:*/		return 0x82229A38;
		  /* 82229A38h */ case    1:  		/* rlwinm R10, R6, 30, 30, 31 */
		/* 82229A38h case    1:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R10,regs.R6);
		/* 82229A38h case    1:*/		return 0x82229A3C;
		  /* 82229A3Ch */ case    2:  		/* addi R9, R11, -2 */
		/* 82229A3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFE);
		/* 82229A3Ch case    2:*/		return 0x82229A40;
		  /* 82229A40h */ case    3:  		/* addi R8, R10, -1 */
		/* 82229A40h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 82229A40h case    3:*/		return 0x82229A44;
		  /* 82229A44h */ case    4:  		/* addi R11, R11, 1 */
		/* 82229A44h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82229A44h case    4:*/		return 0x82229A48;
		  /* 82229A48h */ case    5:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82229A48h case    5:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82229A48h case    5:*/		return 0x82229A4C;
		  /* 82229A4Ch */ case    6:  		/* rlwinm R11, R11, 6, 24, 25 */
		/* 82229A4Ch case    6:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R11,regs.R11);
		/* 82229A4Ch case    6:*/		return 0x82229A50;
		  /* 82229A50h */ case    7:  		/* rlwinm R9, R8, 2, 26, 29 */
		/* 82229A50h case    7:*/		cpu::op::rlwinm<0,2,26,29>(regs,&regs.R9,regs.R8);
		/* 82229A50h case    7:*/		return 0x82229A54;
		  /* 82229A54h */ case    8:  		/* or R11, R9, R11 */
		/* 82229A54h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82229A54h case    8:*/		return 0x82229A58;
		  /* 82229A58h */ case    9:  		/* or R11, R11, R10 */
		/* 82229A58h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82229A58h case    9:*/		return 0x82229A5C;
	}
	return 0x82229A5C;
} // Block from 82229A34h-82229A5Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82229A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229A5C);
		  /* 82229A5Ch */ case    0:  		/* stb R11, <#[R31 + 7]> */
		/* 82229A5Ch case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000007) );
		/* 82229A5Ch case    0:*/		return 0x82229A60;
	}
	return 0x82229A60;
} // Block from 82229A5Ch-82229A60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82229A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229A60);
		  /* 82229A60h */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 82229A60h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 82229A60h case    0:*/		return 0x82229A64;
		  /* 82229A64h */ case    1:  		/* bc 4, CR0_EQ, 176 */
		/* 82229A64h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82229B14;  }
		/* 82229A64h case    1:*/		return 0x82229A68;
		  /* 82229A68h */ case    2:  		/* lwz R11, <#[R26 + 8]> */
		/* 82229A68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82229A68h case    2:*/		return 0x82229A6C;
		  /* 82229A6Ch */ case    3:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82229A6Ch case    3:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82229A6Ch case    3:*/		return 0x82229A70;
		  /* 82229A70h */ case    4:  		/* bc 12, CR0_EQ, 164 */
		/* 82229A70h case    4:*/		if ( regs.CR[0].eq ) { return 0x82229B14;  }
		/* 82229A70h case    4:*/		return 0x82229A74;
		  /* 82229A74h */ case    5:  		/* lwz R27, <#[R26 + 4]> */
		/* 82229A74h case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R26 + 0x00000004) );
		/* 82229A74h case    5:*/		return 0x82229A78;
		  /* 82229A78h */ case    6:  		/* cmplwi CR6, R27, 0 */
		/* 82229A78h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82229A78h case    6:*/		return 0x82229A7C;
		  /* 82229A7Ch */ case    7:  		/* bc 12, CR6_EQ, 36 */
		/* 82229A7Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82229AA0;  }
		/* 82229A7Ch case    7:*/		return 0x82229A80;
		  /* 82229A80h */ case    8:  		/* lwz R11, <#[R27 + 16]> */
		/* 82229A80h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82229A80h case    8:*/		return 0x82229A84;
		  /* 82229A84h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82229A84h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82229A84h case    9:*/		return 0x82229A88;
		  /* 82229A88h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 82229A88h case   10:*/		if ( regs.CR[6].eq ) { return 0x82229A98;  }
		/* 82229A88h case   10:*/		return 0x82229A8C;
		  /* 82229A8Ch */ case   11:  		/* lwz R11, <#[R27]> */
		/* 82229A8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82229A8Ch case   11:*/		return 0x82229A90;
		  /* 82229A90h */ case   12:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82229A90h case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82229A90h case   12:*/		return 0x82229A94;
		  /* 82229A94h */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 82229A94h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82229AA0;  }
		/* 82229A94h case   13:*/		return 0x82229A98;
	}
	return 0x82229A98;
} // Block from 82229A60h-82229A98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82229A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229A98);
		  /* 82229A98h */ case    0:  		/* lwz R27, <#[R27 + 8]> */
		/* 82229A98h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000008) );
		/* 82229A98h case    0:*/		return 0x82229A9C;
		  /* 82229A9Ch */ case    1:  		/* b -36 */
		/* 82229A9Ch case    1:*/		return 0x82229A78;
		/* 82229A9Ch case    1:*/		return 0x82229AA0;
	}
	return 0x82229AA0;
} // Block from 82229A98h-82229AA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229AA0);
		  /* 82229AA0h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 82229AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82229AA0h case    0:*/		return 0x82229AA4;
		  /* 82229AA4h */ case    1:  		/* mr R29, R28 */
		/* 82229AA4h case    1:*/		regs.R29 = regs.R28;
		/* 82229AA4h case    1:*/		return 0x82229AA8;
		  /* 82229AA8h */ case    2:  		/* lwz R30, <#[R11]> */
		/* 82229AA8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82229AA8h case    2:*/		return 0x82229AAC;
		  /* 82229AACh */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 82229AACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82229AACh case    3:*/		return 0x82229AB0;
		  /* 82229AB0h */ case    4:  		/* bc 12, CR6_EQ, 136 */
		/* 82229AB0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82229B38;  }
		/* 82229AB0h case    4:*/		return 0x82229AB4;
		  /* 82229AB4h */ case    5:  		/* lwz R10, <#[R30]> */
		/* 82229AB4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82229AB4h case    5:*/		return 0x82229AB8;
		  /* 82229AB8h */ case    6:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82229AB8h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82229AB8h case    6:*/		return 0x82229ABC;
		  /* 82229ABCh */ case    7:  		/* bc 12, CR0_EQ, 116 */
		/* 82229ABCh case    7:*/		if ( regs.CR[0].eq ) { return 0x82229B30;  }
		/* 82229ABCh case    7:*/		return 0x82229AC0;
		  /* 82229AC0h */ case    8:  		/* lwz R3, <#[R30 + 12]> */
		/* 82229AC0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82229AC0h case    8:*/		return 0x82229AC4;
		  /* 82229AC4h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 82229AC4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82229AC4h case    9:*/		return 0x82229AC8;
		  /* 82229AC8h */ case   10:  		/* rlwinm. R9, R11, 27, 31, 31 */
		/* 82229AC8h case   10:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R11);
		/* 82229AC8h case   10:*/		return 0x82229ACC;
		  /* 82229ACCh */ case   11:  		/* bc 12, CR0_EQ, 100 */
		/* 82229ACCh case   11:*/		if ( regs.CR[0].eq ) { return 0x82229B30;  }
		/* 82229ACCh case   11:*/		return 0x82229AD0;
		  /* 82229AD0h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 82229AD0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82229AD0h case   12:*/		return 0x82229AD4;
		  /* 82229AD4h */ case   13:  		/* rlwinm R10, R10, 15, 17, 31 */
		/* 82229AD4h case   13:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R10,regs.R10);
		/* 82229AD4h case   13:*/		return 0x82229AD8;
		  /* 82229AD8h */ case   14:  		/* rlwinm R9, R9, 0, 26, 31 */
		/* 82229AD8h case   14:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R9,regs.R9);
		/* 82229AD8h case   14:*/		return 0x82229ADC;
		  /* 82229ADCh */ case   15:  		/* xor R10, R10, R9 */
		/* 82229ADCh case   15:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82229ADCh case   15:*/		return 0x82229AE0;
		  /* 82229AE0h */ case   16:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82229AE0h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82229AE0h case   16:*/		return 0x82229AE4;
		  /* 82229AE4h */ case   17:  		/* bc 4, CR0_EQ, 76 */
		/* 82229AE4h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82229B30;  }
		/* 82229AE4h case   17:*/		return 0x82229AE8;
		  /* 82229AE8h */ case   18:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82229AE8h case   18:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82229AE8h case   18:*/		return 0x82229AEC;
		  /* 82229AECh */ case   19:  		/* cmplwi CR6, R11, 121 */
		/* 82229AECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000079);
		/* 82229AECh case   19:*/		return 0x82229AF0;
		  /* 82229AF0h */ case   20:  		/* bc 12, CR6_EQ, 44 */
		/* 82229AF0h case   20:*/		if ( regs.CR[6].eq ) { return 0x82229B1C;  }
		/* 82229AF0h case   20:*/		return 0x82229AF4;
		  /* 82229AF4h */ case   21:  		/* cmplwi CR6, R11, 122 */
		/* 82229AF4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007A);
		/* 82229AF4h case   21:*/		return 0x82229AF8;
		  /* 82229AF8h */ case   22:  		/* bc 12, CR6_EQ, 36 */
		/* 82229AF8h case   22:*/		if ( regs.CR[6].eq ) { return 0x82229B1C;  }
		/* 82229AF8h case   22:*/		return 0x82229AFC;
		  /* 82229AFCh */ case   23:  		/* cmplw CR6, R3, R26 */
		/* 82229AFCh case   23:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R26);
		/* 82229AFCh case   23:*/		return 0x82229B00;
		  /* 82229B00h */ case   24:  		/* bc 12, CR6_EQ, 48 */
		/* 82229B00h case   24:*/		if ( regs.CR[6].eq ) { return 0x82229B30;  }
		/* 82229B00h case   24:*/		return 0x82229B04;
		  /* 82229B04h */ case   25:  		/* mr R4, R26 */
		/* 82229B04h case   25:*/		regs.R4 = regs.R26;
		/* 82229B04h case   25:*/		return 0x82229B08;
		  /* 82229B08h */ case   26:  		/* bl -754240 */
		/* 82229B08h case   26:*/		regs.LR = 0x82229B0C; return 0x821718C8;
		/* 82229B08h case   26:*/		return 0x82229B0C;
		  /* 82229B0Ch */ case   27:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229B0Ch case   27:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229B0Ch case   27:*/		return 0x82229B10;
		  /* 82229B10h */ case   28:  		/* bc 12, CR0_EQ, 32 */
		/* 82229B10h case   28:*/		if ( regs.CR[0].eq ) { return 0x82229B30;  }
		/* 82229B10h case   28:*/		return 0x82229B14;
	}
	return 0x82229B14;
} // Block from 82229AA0h-82229B14h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82229B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229B14);
		  /* 82229B14h */ case    0:  		/* addi R1, R1, 160 */
		/* 82229B14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82229B14h case    0:*/		return 0x82229B18;
		  /* 82229B18h */ case    1:  		/* b -1673340 */
		/* 82229B18h case    1:*/		return 0x8209129C;
		/* 82229B18h case    1:*/		return 0x82229B1C;
	}
	return 0x82229B1C;
} // Block from 82229B14h-82229B1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229B1C);
		  /* 82229B1Ch */ case    0:  		/* addi R11, R11, -122 */
		/* 82229B1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFF86);
		/* 82229B1Ch case    0:*/		return 0x82229B20;
		  /* 82229B20h */ case    1:  		/* li R28, 1 */
		/* 82229B20h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82229B20h case    1:*/		return 0x82229B24;
		  /* 82229B24h */ case    2:  		/* cntlzw R11, R11 */
		/* 82229B24h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82229B24h case    2:*/		return 0x82229B28;
		  /* 82229B28h */ case    3:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82229B28h case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82229B28h case    3:*/		return 0x82229B2C;
		  /* 82229B2Ch */ case    4:  		/* or R29, R11, R29 */
		/* 82229B2Ch case    4:*/		cpu::op::or<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 82229B2Ch case    4:*/		return 0x82229B30;
	}
	return 0x82229B30;
} // Block from 82229B1Ch-82229B30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82229B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229B30);
		  /* 82229B30h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82229B30h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82229B30h case    0:*/		return 0x82229B34;
		  /* 82229B34h */ case    1:  		/* b -136 */
		/* 82229B34h case    1:*/		return 0x82229AAC;
		/* 82229B34h case    1:*/		return 0x82229B38;
	}
	return 0x82229B38;
} // Block from 82229B30h-82229B38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229B38);
		  /* 82229B38h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82229B38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82229B38h case    0:*/		return 0x82229B3C;
		  /* 82229B3Ch */ case    1:  		/* bc 12, CR0_EQ, -40 */
		/* 82229B3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82229B14;  }
		/* 82229B3Ch case    1:*/		return 0x82229B40;
		  /* 82229B40h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 82229B40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229B40h case    2:*/		return 0x82229B44;
		  /* 82229B44h */ case    3:  		/* rlwinm. R10, R29, 0, 24, 31 */
		/* 82229B44h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R29);
		/* 82229B44h case    3:*/		return 0x82229B48;
		  /* 82229B48h */ case    4:  		/* ori R11, R11, 16384 */
		/* 82229B48h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82229B48h case    4:*/		return 0x82229B4C;
		  /* 82229B4Ch */ case    5:  		/* stw R11, <#[R31]> */
		/* 82229B4Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229B4Ch case    5:*/		return 0x82229B50;
		  /* 82229B50h */ case    6:  		/* bc 12, CR0_EQ, -60 */
		/* 82229B50h case    6:*/		if ( regs.CR[0].eq ) { return 0x82229B14;  }
		/* 82229B50h case    6:*/		return 0x82229B54;
		  /* 82229B54h */ case    7:  		/* lwz R11, <#[R27 + 16]> */
		/* 82229B54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82229B54h case    7:*/		return 0x82229B58;
		  /* 82229B58h */ case    8:  		/* lwz R9, <#[R11]> */
		/* 82229B58h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82229B58h case    8:*/		return 0x82229B5C;
		  /* 82229B5Ch */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 82229B5Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82229B5Ch case    9:*/		return 0x82229B60;
		  /* 82229B60h */ case   10:  		/* bc 12, CR6_EQ, -76 */
		/* 82229B60h case   10:*/		if ( regs.CR[6].eq ) { return 0x82229B14;  }
		/* 82229B60h case   10:*/		return 0x82229B64;
		  /* 82229B64h */ case   11:  		/* lwz R10, <#[R9]> */
		/* 82229B64h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82229B64h case   11:*/		return 0x82229B68;
		  /* 82229B68h */ case   12:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82229B68h case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82229B68h case   12:*/		return 0x82229B6C;
		  /* 82229B6Ch */ case   13:  		/* bc 12, CR0_EQ, 76 */
		/* 82229B6Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82229BB8;  }
		/* 82229B6Ch case   13:*/		return 0x82229B70;
		  /* 82229B70h */ case   14:  		/* lwz R11, <#[R9 + 12]> */
		/* 82229B70h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82229B70h case   14:*/		return 0x82229B74;
		  /* 82229B74h */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 82229B74h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82229B74h case   15:*/		return 0x82229B78;
		  /* 82229B78h */ case   16:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82229B78h case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82229B78h case   16:*/		return 0x82229B7C;
		  /* 82229B7Ch */ case   17:  		/* cmplwi CR6, R11, 15616 */
		/* 82229B7Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003D00);
		/* 82229B7Ch case   17:*/		return 0x82229B80;
		  /* 82229B80h */ case   18:  		/* bc 4, CR6_EQ, 56 */
		/* 82229B80h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82229BB8;  }
		/* 82229B80h case   18:*/		return 0x82229B84;
		  /* 82229B84h */ case   19:  		/* lwz R11, <#[R31]> */
		/* 82229B84h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229B84h case   19:*/		return 0x82229B88;
		  /* 82229B88h */ case   20:  		/* rlwinm R8, R10, 15, 24, 31 */
		/* 82229B88h case   20:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R8,regs.R10);
		/* 82229B88h case   20:*/		return 0x82229B8C;
		  /* 82229B8Ch */ case   21:  		/* rlwinm R10, R10, 19, 20, 31 */
		/* 82229B8Ch case   21:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R10,regs.R10);
		/* 82229B8Ch case   21:*/		return 0x82229B90;
		  /* 82229B90h */ case   22:  		/* rlwinm R7, R11, 0, 26, 31 */
		/* 82229B90h case   22:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R7,regs.R11);
		/* 82229B90h case   22:*/		return 0x82229B94;
		  /* 82229B94h */ case   23:  		/* cmplw CR6, R8, R7 */
		/* 82229B94h case   23:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82229B94h case   23:*/		return 0x82229B98;
		  /* 82229B98h */ case   24:  		/* bc 4, CR6_EQ, 32 */
		/* 82229B98h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82229BB8;  }
		/* 82229B98h case   24:*/		return 0x82229B9C;
		  /* 82229B9Ch */ case   25:  		/* rlwinm R8, R10, 20, 8, 11 */
		/* 82229B9Ch case   25:*/		cpu::op::rlwinm<0,20,8,11>(regs,&regs.R8,regs.R10);
		/* 82229B9Ch case   25:*/		return 0x82229BA0;
		  /* 82229BA0h */ case   26:  		/* rlwinm R10, R10, 16, 12, 15 */
		/* 82229BA0h case   26:*/		cpu::op::rlwinm<0,16,12,15>(regs,&regs.R10,regs.R10);
		/* 82229BA0h case   26:*/		return 0x82229BA4;
		  /* 82229BA4h */ case   27:  		/* or R8, R8, R11 */
		/* 82229BA4h case   27:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 82229BA4h case   27:*/		return 0x82229BA8;
		  /* 82229BA8h */ case   28:  		/* rlwimi R8, R11, 0, 12, 7 */
		/* 82229BA8h case   28:*/		cpu::op::rlwimi<0,0,12,7>(regs,&regs.R8,regs.R11);
		/* 82229BA8h case   28:*/		return 0x82229BAC;
		  /* 82229BACh */ case   29:  		/* or R11, R10, R8 */
		/* 82229BACh case   29:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R8);
		/* 82229BACh case   29:*/		return 0x82229BB0;
		  /* 82229BB0h */ case   30:  		/* rlwimi R11, R8, 0, 16, 11 */
		/* 82229BB0h case   30:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R11,regs.R8);
		/* 82229BB0h case   30:*/		return 0x82229BB4;
		  /* 82229BB4h */ case   31:  		/* stw R11, <#[R31]> */
		/* 82229BB4h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229BB4h case   31:*/		return 0x82229BB8;
	}
	return 0x82229BB8;
} // Block from 82229B38h-82229BB8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82229BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229BB8);
		  /* 82229BB8h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 82229BB8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82229BB8h case    0:*/		return 0x82229BBC;
		  /* 82229BBCh */ case    1:  		/* b -96 */
		/* 82229BBCh case    1:*/		return 0x82229B5C;
		/* 82229BBCh case    1:*/		return 0x82229BC0;
	}
	return 0x82229BC0;
} // Block from 82229BB8h-82229BC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229BC0);
		  /* 82229BC0h */ case    0:  		/* mfspr R12, LR */
		/* 82229BC0h case    0:*/		regs.R12 = regs.LR;
		/* 82229BC0h case    0:*/		return 0x82229BC4;
		  /* 82229BC4h */ case    1:  		/* bl -1673576 */
		/* 82229BC4h case    1:*/		regs.LR = 0x82229BC8; return 0x8209125C;
		/* 82229BC4h case    1:*/		return 0x82229BC8;
		  /* 82229BC8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82229BC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82229BC8h case    2:*/		return 0x82229BCC;
		  /* 82229BCCh */ case    3:  		/* mr R29, R3 */
		/* 82229BCCh case    3:*/		regs.R29 = regs.R3;
		/* 82229BCCh case    3:*/		return 0x82229BD0;
		  /* 82229BD0h */ case    4:  		/* mr R3, R4 */
		/* 82229BD0h case    4:*/		regs.R3 = regs.R4;
		/* 82229BD0h case    4:*/		return 0x82229BD4;
		  /* 82229BD4h */ case    5:  		/* mr R30, R4 */
		/* 82229BD4h case    5:*/		regs.R30 = regs.R4;
		/* 82229BD4h case    5:*/		return 0x82229BD8;
		  /* 82229BD8h */ case    6:  		/* mr R31, R5 */
		/* 82229BD8h case    6:*/		regs.R31 = regs.R5;
		/* 82229BD8h case    6:*/		return 0x82229BDC;
		  /* 82229BDCh */ case    7:  		/* bl -754548 */
		/* 82229BDCh case    7:*/		regs.LR = 0x82229BE0; return 0x82171868;
		/* 82229BDCh case    7:*/		return 0x82229BE0;
		  /* 82229BE0h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229BE0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229BE0h case    8:*/		return 0x82229BE4;
		  /* 82229BE4h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 82229BE4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82229BF0;  }
		/* 82229BE4h case    9:*/		return 0x82229BE8;
		  /* 82229BE8h */ case   10:  		/* li R3, 1 */
		/* 82229BE8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82229BE8h case   10:*/		return 0x82229BEC;
		  /* 82229BECh */ case   11:  		/* b 132 */
		/* 82229BECh case   11:*/		return 0x82229C70;
		/* 82229BECh case   11:*/		return 0x82229BF0;
	}
	return 0x82229BF0;
} // Block from 82229BC0h-82229BF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82229BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229BF0);
		  /* 82229BF0h */ case    0:  		/* rlwinm R11, R31, 0, 30, 31 */
		/* 82229BF0h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R31);
		/* 82229BF0h case    0:*/		return 0x82229BF4;
		  /* 82229BF4h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 82229BF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82229BF4h case    1:*/		return 0x82229BF8;
		  /* 82229BF8h */ case    2:  		/* bc 12, CR6_LT, 76 */
		/* 82229BF8h case    2:*/		if ( regs.CR[6].lt ) { return 0x82229C44;  }
		/* 82229BF8h case    2:*/		return 0x82229BFC;
		  /* 82229BFCh */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 82229BFCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82229C20;  }
		/* 82229BFCh case    3:*/		return 0x82229C00;
		  /* 82229C00h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 82229C00h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82229C00h case    4:*/		return 0x82229C04;
		  /* 82229C04h */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 82229C04h case    5:*/		if ( regs.CR[6].lt ) { return 0x82229C18;  }
		/* 82229C04h case    5:*/		return 0x82229C08;
		  /* 82229C08h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 82229C08h case    6:*/		if ( regs.CR[6].eq ) { return 0x82229BE8;  }
		/* 82229C08h case    6:*/		return 0x82229C0C;
		  /* 82229C0Ch */ case    7:  		/* li R4, 4800 */
		/* 82229C0Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82229C0Ch case    7:*/		return 0x82229C10;
	}
	return 0x82229C10;
} // Block from 82229BF0h-82229C10h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82229C10h
// Function '?FlipCondition@Instruction@D3DXShader@@QAAPAV12@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C10);
		  /* 82229C10h */ case    0:  		/* mr R3, R29 */
		/* 82229C10h case    0:*/		regs.R3 = regs.R29;
		/* 82229C10h case    0:*/		return 0x82229C14;
		  /* 82229C14h */ case    1:  		/* bl -884140 */
		/* 82229C14h case    1:*/		regs.LR = 0x82229C18; return 0x82151E68;
		/* 82229C14h case    1:*/		return 0x82229C18;
	}
	return 0x82229C18;
} // Block from 82229C10h-82229C18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C18);
		  /* 82229C18h */ case    0:  		/* li R3, 0 */
		/* 82229C18h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82229C18h case    0:*/		return 0x82229C1C;
		  /* 82229C1Ch */ case    1:  		/* b 84 */
		/* 82229C1Ch case    1:*/		return 0x82229C70;
		/* 82229C1Ch case    1:*/		return 0x82229C20;
	}
	return 0x82229C20;
} // Block from 82229C18h-82229C20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C20);
		  /* 82229C20h */ case    0:  		/* rlwinm R29, R31, 0, 0, 29 */
		/* 82229C20h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R29,regs.R31);
		/* 82229C20h case    0:*/		return 0x82229C24;
		  /* 82229C24h */ case    1:  		/* mr R3, R29 */
		/* 82229C24h case    1:*/		regs.R3 = regs.R29;
		/* 82229C24h case    1:*/		return 0x82229C28;
		  /* 82229C28h */ case    2:  		/* bl -754624 */
		/* 82229C28h case    2:*/		regs.LR = 0x82229C2C; return 0x82171868;
		/* 82229C28h case    2:*/		return 0x82229C2C;
		  /* 82229C2Ch */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229C2Ch case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229C2Ch case    3:*/		return 0x82229C30;
		  /* 82229C30h */ case    4:  		/* bc 12, CR0_EQ, -24 */
		/* 82229C30h case    4:*/		if ( regs.CR[0].eq ) { return 0x82229C18;  }
		/* 82229C30h case    4:*/		return 0x82229C34;
		  /* 82229C34h */ case    5:  		/* rlwinm R11, R31, 0, 0, 29 */
		/* 82229C34h case    5:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R31);
		/* 82229C34h case    5:*/		return 0x82229C38;
		  /* 82229C38h */ case    6:  		/* cmplw CR6, R11, R30 */
		/* 82229C38h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82229C38h case    6:*/		return 0x82229C3C;
		  /* 82229C3Ch */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82229C3Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82229C64;  }
		/* 82229C3Ch case    7:*/		return 0x82229C40;
		  /* 82229C40h */ case    8:  		/* b -88 */
		/* 82229C40h case    8:*/		return 0x82229BE8;
		/* 82229C40h case    8:*/		return 0x82229C44;
	}
	return 0x82229C44;
} // Block from 82229C20h-82229C44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82229C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C44);
		  /* 82229C44h */ case    0:  		/* rlwinm R29, R31, 0, 0, 29 */
		/* 82229C44h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R29,regs.R31);
		/* 82229C44h case    0:*/		return 0x82229C48;
		  /* 82229C48h */ case    1:  		/* mr R3, R29 */
		/* 82229C48h case    1:*/		regs.R3 = regs.R29;
		/* 82229C48h case    1:*/		return 0x82229C4C;
		  /* 82229C4Ch */ case    2:  		/* bl -754660 */
		/* 82229C4Ch case    2:*/		regs.LR = 0x82229C50; return 0x82171868;
		/* 82229C4Ch case    2:*/		return 0x82229C50;
		  /* 82229C50h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229C50h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229C50h case    3:*/		return 0x82229C54;
		  /* 82229C54h */ case    4:  		/* bc 12, CR0_EQ, -60 */
		/* 82229C54h case    4:*/		if ( regs.CR[0].eq ) { return 0x82229C18;  }
		/* 82229C54h case    4:*/		return 0x82229C58;
		  /* 82229C58h */ case    5:  		/* rlwinm R11, R31, 0, 0, 29 */
		/* 82229C58h case    5:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R31);
		/* 82229C58h case    5:*/		return 0x82229C5C;
		  /* 82229C5Ch */ case    6:  		/* cmplw CR6, R11, R30 */
		/* 82229C5Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82229C5Ch case    6:*/		return 0x82229C60;
		  /* 82229C60h */ case    7:  		/* bc 12, CR6_EQ, -72 */
		/* 82229C60h case    7:*/		if ( regs.CR[6].eq ) { return 0x82229C18;  }
		/* 82229C60h case    7:*/		return 0x82229C64;
	}
	return 0x82229C64;
} // Block from 82229C44h-82229C64h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82229C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C64);
		  /* 82229C64h */ case    0:  		/* mr R4, R29 */
		/* 82229C64h case    0:*/		regs.R4 = regs.R29;
		/* 82229C64h case    0:*/		return 0x82229C68;
		  /* 82229C68h */ case    1:  		/* mr R3, R30 */
		/* 82229C68h case    1:*/		regs.R3 = regs.R30;
		/* 82229C68h case    1:*/		return 0x82229C6C;
		  /* 82229C6Ch */ case    2:  		/* bl -754596 */
		/* 82229C6Ch case    2:*/		regs.LR = 0x82229C70; return 0x821718C8;
		/* 82229C6Ch case    2:*/		return 0x82229C70;
	}
	return 0x82229C70;
} // Block from 82229C64h-82229C70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82229C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C70);
		  /* 82229C70h */ case    0:  		/* addi R1, R1, 112 */
		/* 82229C70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82229C70h case    0:*/		return 0x82229C74;
		  /* 82229C74h */ case    1:  		/* b -1673672 */
		/* 82229C74h case    1:*/		return 0x820912AC;
		/* 82229C74h case    1:*/		return 0x82229C78;
	}
	return 0x82229C78;
} // Block from 82229C70h-82229C78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229C78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229C78);
		  /* 82229C78h */ case    0:  		/* mfspr R12, LR */
		/* 82229C78h case    0:*/		regs.R12 = regs.LR;
		/* 82229C78h case    0:*/		return 0x82229C7C;
		  /* 82229C7Ch */ case    1:  		/* bl -1673788 */
		/* 82229C7Ch case    1:*/		regs.LR = 0x82229C80; return 0x82091240;
		/* 82229C7Ch case    1:*/		return 0x82229C80;
		  /* 82229C80h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82229C80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82229C80h case    2:*/		return 0x82229C84;
		  /* 82229C84h */ case    3:  		/* mr R22, R4 */
		/* 82229C84h case    3:*/		regs.R22 = regs.R4;
		/* 82229C84h case    3:*/		return 0x82229C88;
		  /* 82229C88h */ case    4:  		/* mr R4, R6 */
		/* 82229C88h case    4:*/		regs.R4 = regs.R6;
		/* 82229C88h case    4:*/		return 0x82229C8C;
		  /* 82229C8Ch */ case    5:  		/* mr R23, R5 */
		/* 82229C8Ch case    5:*/		regs.R23 = regs.R5;
		/* 82229C8Ch case    5:*/		return 0x82229C90;
		  /* 82229C90h */ case    6:  		/* lwz R5, <#[R6 + 12]> */
		/* 82229C90h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + 0x0000000C) );
		/* 82229C90h case    6:*/		return 0x82229C94;
		  /* 82229C94h */ case    7:  		/* mr R25, R3 */
		/* 82229C94h case    7:*/		regs.R25 = regs.R3;
		/* 82229C94h case    7:*/		return 0x82229C98;
		  /* 82229C98h */ case    8:  		/* mr R30, R6 */
		/* 82229C98h case    8:*/		regs.R30 = regs.R6;
		/* 82229C98h case    8:*/		return 0x82229C9C;
		  /* 82229C9Ch */ case    9:  		/* bl -756652 */
		/* 82229C9Ch case    9:*/		regs.LR = 0x82229CA0; return 0x821710F0;
		/* 82229C9Ch case    9:*/		return 0x82229CA0;
		  /* 82229CA0h */ case   10:  		/* lwz R10, <#[R30]> */
		/* 82229CA0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82229CA0h case   10:*/		return 0x82229CA4;
		  /* 82229CA4h */ case   11:  		/* mr R31, R3 */
		/* 82229CA4h case   11:*/		regs.R31 = regs.R3;
		/* 82229CA4h case   11:*/		return 0x82229CA8;
		  /* 82229CA8h */ case   12:  		/* li R11, 0 */
		/* 82229CA8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82229CA8h case   12:*/		return 0x82229CAC;
		  /* 82229CACh */ case   13:  		/* rlwinm. R8, R10, 0, 4, 6 */
		/* 82229CACh case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R10);
		/* 82229CACh case   13:*/		return 0x82229CB0;
		  /* 82229CB0h */ case   14:  		/* li R9, 0 */
		/* 82229CB0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82229CB0h case   14:*/		return 0x82229CB4;
		  /* 82229CB4h */ case   15:  		/* bc 12, CR0_EQ, 56 */
		/* 82229CB4h case   15:*/		if ( regs.CR[0].eq ) { return 0x82229CEC;  }
		/* 82229CB4h case   15:*/		return 0x82229CB8;
		  /* 82229CB8h */ case   16:  		/* rlwinm R7, R10, 0, 0, 31 */
		/* 82229CB8h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R10);
		/* 82229CB8h case   16:*/		return 0x82229CBC;
		  /* 82229CBCh */ case   17:  		/* rlwinm R8, R10, 27, 24, 31 */
		/* 82229CBCh case   17:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R10);
		/* 82229CBCh case   17:*/		return 0x82229CC0;
		  /* 82229CC0h */ case   18:  		/* li R10, 0 */
		/* 82229CC0h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82229CC0h case   18:*/		return 0x82229CC4;
		  /* 82229CC4h */ case   19:  		/* rlwinm R7, R7, 7, 29, 31 */
		/* 82229CC4h case   19:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R7);
		/* 82229CC4h case   19:*/		return 0x82229CC8;
		  /* 82229CC8h */ case   20:  		/* srw R6, R8, R10 */
		/* 82229CC8h case   20:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R8,regs.R10);
		/* 82229CC8h case   20:*/		return 0x82229CCC;
		  /* 82229CCCh */ case   21:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 82229CCCh case   21:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 82229CCCh case   21:*/		return 0x82229CD0;
		  /* 82229CD0h */ case   22:  		/* li R5, 1 */
		/* 82229CD0h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82229CD0h case   22:*/		return 0x82229CD4;
		  /* 82229CD4h */ case   23:  		/* addi R9, R9, 1 */
		/* 82229CD4h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82229CD4h case   23:*/		return 0x82229CD8;
		  /* 82229CD8h */ case   24:  		/* slw R6, R5, R6 */
		/* 82229CD8h case   24:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 82229CD8h case   24:*/		return 0x82229CDC;
		  /* 82229CDCh */ case   25:  		/* or R11, R6, R11 */
		/* 82229CDCh case   25:*/		cpu::op::or<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82229CDCh case   25:*/		return 0x82229CE0;
		  /* 82229CE0h */ case   26:  		/* addi R10, R10, 2 */
		/* 82229CE0h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82229CE0h case   26:*/		return 0x82229CE4;
		  /* 82229CE4h */ case   27:  		/* cmplw CR6, R9, R7 */
		/* 82229CE4h case   27:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82229CE4h case   27:*/		return 0x82229CE8;
		  /* 82229CE8h */ case   28:  		/* bc 12, CR6_LT, -32 */
		/* 82229CE8h case   28:*/		if ( regs.CR[6].lt ) { return 0x82229CC8;  }
		/* 82229CE8h case   28:*/		return 0x82229CEC;
	}
	return 0x82229CEC;
} // Block from 82229C78h-82229CECh (29 instructions)

//////////////////////////////////////////////////////
// Block at 82229CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229CEC);
		  /* 82229CECh */ case    0:  		/* lis R10, -28311 */
		/* 82229CECh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 82229CECh case    0:*/		return 0x82229CF0;
		  /* 82229CF0h */ case    1:  		/* lwz R9, <#[R31]> */
		/* 82229CF0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82229CF0h case    1:*/		return 0x82229CF4;
		  /* 82229CF4h */ case    2:  		/* lis R8, 0 */
		/* 82229CF4h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 82229CF4h case    2:*/		return 0x82229CF8;
		  /* 82229CF8h */ case    3:  		/* ori R10, R10, 5192 */
		/* 82229CF8h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82229CF8h case    3:*/		return 0x82229CFC;
		  /* 82229CFCh */ case    4:  		/* ori R8, R8, 36262 */
		/* 82229CFCh case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x8DA6);
		/* 82229CFCh case    4:*/		return 0x82229D00;
		  /* 82229D00h */ case    5:  		/* rldicl R7, R11, 0, 32 */
		/* 82229D00h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R11);
		/* 82229D00h case    5:*/		return 0x82229D04;
		  /* 82229D04h */ case    6:  		/* rldimi R10, R8, 32, 0 */
		/* 82229D04h case    6:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R8);
		/* 82229D04h case    6:*/		return 0x82229D08;
		  /* 82229D08h */ case    7:  		/* li R26, 3 */
		/* 82229D08h case    7:*/		cpu::op::li<0>(regs,&regs.R26,0x3);
		/* 82229D08h case    7:*/		return 0x82229D0C;
		  /* 82229D0Ch */ case    8:  		/* srd R10, R10, R7 */
		/* 82229D0Ch case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82229D0Ch case    8:*/		return 0x82229D10;
	}
	return 0x82229D10;
} // Block from 82229CECh-82229D10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82229D10h
// Function '?EncodeALU@Instruction@D3DXShader@@QAAXPATGPUALU_INSTRUCTION@@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229D10);
		  /* 82229D10h */ case    0:  		/* srd R10, R10, R7 */
		/* 82229D10h case    0:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82229D10h case    0:*/		return 0x82229D14;
		  /* 82229D14h */ case    1:  		/* srd R10, R10, R7 */
		/* 82229D14h case    1:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82229D14h case    1:*/		return 0x82229D18;
		  /* 82229D18h */ case    2:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 82229D18h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 82229D18h case    2:*/		return 0x82229D1C;
		  /* 82229D1Ch */ case    3:  		/* li R27, 0 */
		/* 82229D1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82229D1Ch case    3:*/		return 0x82229D20;
		  /* 82229D20h */ case    4:  		/* rlwimi R9, R10, 25, 4, 6 */
		/* 82229D20h case    4:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R9,regs.R10);
		/* 82229D20h case    4:*/		return 0x82229D24;
		  /* 82229D24h */ case    5:  		/* li R29, 0 */
		/* 82229D24h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82229D24h case    5:*/		return 0x82229D28;
		  /* 82229D28h */ case    6:  		/* stw R9, <#[R31]> */
		/* 82229D28h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82229D28h case    6:*/		return 0x82229D2C;
		  /* 82229D2Ch */ case    7:  		/* li R9, 0 */
		/* 82229D2Ch case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82229D2Ch case    7:*/		return 0x82229D30;
		  /* 82229D30h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82229D30h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82229D30h case    8:*/		return 0x82229D34;
		  /* 82229D34h */ case    9:  		/* bc 12, CR6_EQ, 76 */
		/* 82229D34h case    9:*/		if ( regs.CR[6].eq ) { return 0x82229D80;  }
		/* 82229D34h case    9:*/		return 0x82229D38;
		  /* 82229D38h */ case   10:  		/* li R10, 0 */
		/* 82229D38h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82229D38h case   10:*/		return 0x82229D3C;
		  /* 82229D3Ch */ case   11:  		/* addi R8, R11, -1 */
		/* 82229D3Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82229D3Ch case   11:*/		return 0x82229D40;
		  /* 82229D40h */ case   12:  		/* slw R7, R26, R10 */
		/* 82229D40h case   12:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R26,regs.R10);
		/* 82229D40h case   12:*/		return 0x82229D44;
		  /* 82229D44h */ case   13:  		/* andc R8, R11, R8 */
		/* 82229D44h case   13:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 82229D44h case   13:*/		return 0x82229D48;
		  /* 82229D48h */ case   14:  		/* andc R7, R27, R7 */
		/* 82229D48h case   14:*/		cpu::op::andc<0>(regs,&regs.R7,regs.R27,regs.R7);
		/* 82229D48h case   14:*/		return 0x82229D4C;
		  /* 82229D4Ch */ case   15:  		/* cntlzw R6, R8 */
		/* 82229D4Ch case   15:*/		cpu::op::cntlzw<0>(regs,&regs.R6,regs.R8);
		/* 82229D4Ch case   15:*/		return 0x82229D50;
		  /* 82229D50h */ case   16:  		/* subf. R11, R8, R11 */
		/* 82229D50h case   16:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82229D50h case   16:*/		return 0x82229D54;
		  /* 82229D54h */ case   17:  		/* subfic R8, R6, 31 */
		/* 82229D54h case   17:*/		cpu::op::subfic<0>(regs,&regs.R8,regs.R6,0x1F);
		/* 82229D54h case   17:*/		return 0x82229D58;
		  /* 82229D58h */ case   18:  		/* rlwinm R6, R8, 1, 0, 30 */
		/* 82229D58h case   18:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R6,regs.R8);
		/* 82229D58h case   18:*/		return 0x82229D5C;
		  /* 82229D5Ch */ case   19:  		/* slw R8, R8, R10 */
		/* 82229D5Ch case   19:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82229D5Ch case   19:*/		return 0x82229D60;
		  /* 82229D60h */ case   20:  		/* slw R5, R26, R6 */
		/* 82229D60h case   20:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R26,regs.R6);
		/* 82229D60h case   20:*/		return 0x82229D64;
		  /* 82229D64h */ case   21:  		/* slw R6, R9, R6 */
		/* 82229D64h case   21:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 82229D64h case   21:*/		return 0x82229D68;
		  /* 82229D68h */ case   22:  		/* andc R5, R29, R5 */
		/* 82229D68h case   22:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R29,regs.R5);
		/* 82229D68h case   22:*/		return 0x82229D6C;
		  /* 82229D6Ch */ case   23:  		/* or R27, R7, R8 */
		/* 82229D6Ch case   23:*/		cpu::op::or<0>(regs,&regs.R27,regs.R7,regs.R8);
		/* 82229D6Ch case   23:*/		return 0x82229D70;
		  /* 82229D70h */ case   24:  		/* or R29, R5, R6 */
		/* 82229D70h case   24:*/		cpu::op::or<0>(regs,&regs.R29,regs.R5,regs.R6);
		/* 82229D70h case   24:*/		return 0x82229D74;
		  /* 82229D74h */ case   25:  		/* addi R9, R9, 1 */
		/* 82229D74h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82229D74h case   25:*/		return 0x82229D78;
		  /* 82229D78h */ case   26:  		/* addi R10, R10, 2 */
		/* 82229D78h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82229D78h case   26:*/		return 0x82229D7C;
		  /* 82229D7Ch */ case   27:  		/* bc 4, CR0_EQ, -64 */
		/* 82229D7Ch case   27:*/		if ( !regs.CR[0].eq ) { return 0x82229D3C;  }
		/* 82229D7Ch case   27:*/		return 0x82229D80;
	}
	return 0x82229D80;
} // Block from 82229D10h-82229D80h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82229D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229D80);
		  /* 82229D80h */ case    0:  		/* lwz R11, <#[R25 + 40]> */
		/* 82229D80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000028) );
		/* 82229D80h case    0:*/		return 0x82229D84;
		  /* 82229D84h */ case    1:  		/* lwz R24, <#[R30 + 12]> */
		/* 82229D84h case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R30 + 0x0000000C) );
		/* 82229D84h case    1:*/		return 0x82229D88;
		  /* 82229D88h */ case    2:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 82229D88h case    2:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 82229D88h case    2:*/		return 0x82229D8C;
		  /* 82229D8Ch */ case    3:  		/* bc 12, CR0_EQ, 320 */
		/* 82229D8Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82229ECC;  }
		/* 82229D8Ch case    3:*/		return 0x82229D90;
		  /* 82229D90h */ case    4:  		/* lwz R11, <#[R24 + 28]> */
		/* 82229D90h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000001C) );
		/* 82229D90h case    4:*/		return 0x82229D94;
		  /* 82229D94h */ case    5:  		/* cmplw CR6, R11, R22 */
		/* 82229D94h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 82229D94h case    5:*/		return 0x82229D98;
		  /* 82229D98h */ case    6:  		/* bc 4, CR6_EQ, 308 */
		/* 82229D98h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82229ECC;  }
		/* 82229D98h case    6:*/		return 0x82229D9C;
		  /* 82229D9Ch */ case    7:  		/* lwz R11, <#[R24 + 4]> */
		/* 82229D9Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 82229D9Ch case    7:*/		return 0x82229DA0;
		  /* 82229DA0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82229DA0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82229DA0h case    8:*/		return 0x82229DA4;
		  /* 82229DA4h */ case    9:  		/* bc 12, CR6_EQ, 60 */
		/* 82229DA4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82229DE0;  }
		/* 82229DA4h case    9:*/		return 0x82229DA8;
		  /* 82229DA8h */ case   10:  		/* lwz R10, <#[R11 + 16]> */
		/* 82229DA8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82229DA8h case   10:*/		return 0x82229DAC;
		  /* 82229DACh */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 82229DACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82229DACh case   11:*/		return 0x82229DB0;
		  /* 82229DB0h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 82229DB0h case   12:*/		if ( regs.CR[6].eq ) { return 0x82229DD0;  }
		/* 82229DB0h case   12:*/		return 0x82229DB4;
		  /* 82229DB4h */ case   13:  		/* lwz R9, <#[R10 + 8]> */
		/* 82229DB4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82229DB4h case   13:*/		return 0x82229DB8;
		  /* 82229DB8h */ case   14:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82229DB8h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82229DB8h case   14:*/		return 0x82229DBC;
		  /* 82229DBCh */ case   15:  		/* cmplwi CR6, R9, 14080 */
		/* 82229DBCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 82229DBCh case   15:*/		return 0x82229DC0;
		  /* 82229DC0h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 82229DC0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82229DD0;  }
		/* 82229DC0h case   16:*/		return 0x82229DC4;
		  /* 82229DC4h */ case   17:  		/* lwz R9, <#[R11]> */
		/* 82229DC4h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82229DC4h case   17:*/		return 0x82229DC8;
		  /* 82229DC8h */ case   18:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82229DC8h case   18:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82229DC8h case   18:*/		return 0x82229DCC;
		  /* 82229DCCh */ case   19:  		/* bc 4, CR0_EQ, 12 */
		/* 82229DCCh case   19:*/		if ( !regs.CR[0].eq ) { return 0x82229DD8;  }
		/* 82229DCCh case   19:*/		return 0x82229DD0;
	}
	return 0x82229DD0;
} // Block from 82229D80h-82229DD0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82229DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229DD0);
		  /* 82229DD0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82229DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82229DD0h case    0:*/		return 0x82229DD4;
		  /* 82229DD4h */ case    1:  		/* b -52 */
		/* 82229DD4h case    1:*/		return 0x82229DA0;
		/* 82229DD4h case    1:*/		return 0x82229DD8;
	}
	return 0x82229DD8;
} // Block from 82229DD0h-82229DD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229DD8);
		  /* 82229DD8h */ case    0:  		/* mr R28, R10 */
		/* 82229DD8h case    0:*/		regs.R28 = regs.R10;
		/* 82229DD8h case    0:*/		return 0x82229DDC;
		  /* 82229DDCh */ case    1:  		/* b 8 */
		/* 82229DDCh case    1:*/		return 0x82229DE4;
		/* 82229DDCh case    1:*/		return 0x82229DE0;
	}
	return 0x82229DE0;
} // Block from 82229DD8h-82229DE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229DE0);
		  /* 82229DE0h */ case    0:  		/* li R28, 0 */
		/* 82229DE0h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82229DE0h case    0:*/		return 0x82229DE4;
	}
	return 0x82229DE4;
} // Block from 82229DE0h-82229DE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82229DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229DE4);
		  /* 82229DE4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82229DE4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82229DE4h case    0:*/		return 0x82229DE8;
		  /* 82229DE8h */ case    1:  		/* bc 12, CR6_EQ, 228 */
		/* 82229DE8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82229ECC;  }
		/* 82229DE8h case    1:*/		return 0x82229DEC;
		  /* 82229DECh */ case    2:  		/* mr R5, R23 */
		/* 82229DECh case    2:*/		regs.R5 = regs.R23;
		/* 82229DECh case    2:*/		return 0x82229DF0;
		  /* 82229DF0h */ case    3:  		/* mr R4, R28 */
		/* 82229DF0h case    3:*/		regs.R4 = regs.R28;
		/* 82229DF0h case    3:*/		return 0x82229DF4;
		  /* 82229DF4h */ case    4:  		/* mr R3, R25 */
		/* 82229DF4h case    4:*/		regs.R3 = regs.R25;
		/* 82229DF4h case    4:*/		return 0x82229DF8;
		  /* 82229DF8h */ case    5:  		/* bl -568 */
		/* 82229DF8h case    5:*/		regs.LR = 0x82229DFC; return 0x82229BC0;
		/* 82229DF8h case    5:*/		return 0x82229DFC;
		  /* 82229DFCh */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82229DFCh case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82229DFCh case    6:*/		return 0x82229E00;
		  /* 82229E00h */ case    7:  		/* bc 12, CR0_EQ, 204 */
		/* 82229E00h case    7:*/		if ( regs.CR[0].eq ) { return 0x82229ECC;  }
		/* 82229E00h case    7:*/		return 0x82229E04;
		  /* 82229E04h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82229E04h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229E04h case    8:*/		return 0x82229E08;
		  /* 82229E08h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82229E08h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82229E08h case    9:*/		return 0x82229E0C;
		  /* 82229E0Ch */ case   10:  		/* bc 12, CR0_EQ, 124 */
		/* 82229E0Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82229E88;  }
		/* 82229E0Ch case   10:*/		return 0x82229E10;
		  /* 82229E10h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 82229E10h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229E10h case   11:*/		return 0x82229E14;
		  /* 82229E14h */ case   12:  		/* addi R7, R28, 44 */
		/* 82229E14h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R28,0x2C);
		/* 82229E14h case   12:*/		return 0x82229E18;
		  /* 82229E18h */ case   13:  		/* lwz R9, <#[R28 + 8]> */
		/* 82229E18h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 82229E18h case   13:*/		return 0x82229E1C;
		  /* 82229E1Ch */ case   14:  		/* li R10, 0 */
		/* 82229E1Ch case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82229E1Ch case   14:*/		return 0x82229E20;
		  /* 82229E20h */ case   15:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82229E20h case   15:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82229E20h case   15:*/		return 0x82229E24;
		  /* 82229E24h */ case   16:  		/* rlwinm R6, R9, 13, 29, 31 */
		/* 82229E24h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R6,regs.R9);
		/* 82229E24h case   16:*/		return 0x82229E28;
		  /* 82229E28h */ case   17:  		/* mtspr CTR, R11 */
		/* 82229E28h case   17:*/		regs.CTR = regs.R11;
		/* 82229E28h case   17:*/		return 0x82229E2C;
		  /* 82229E2Ch */ case   18:  		/* li R9, 0 */
		/* 82229E2Ch case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82229E2Ch case   18:*/		return 0x82229E30;
		  /* 82229E30h */ case   19:  		/* mr R8, R7 */
		/* 82229E30h case   19:*/		regs.R8 = regs.R7;
		/* 82229E30h case   19:*/		return 0x82229E34;
		  /* 82229E34h */ case   20:  		/* cmplw CR6, R9, R6 */
		/* 82229E34h case   20:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82229E34h case   20:*/		return 0x82229E38;
		  /* 82229E38h */ case   21:  		/* bc 4, CR6_LT, 72 */
		/* 82229E38h case   21:*/		if ( !regs.CR[6].lt ) { return 0x82229E80;  }
		/* 82229E38h case   21:*/		return 0x82229E3C;
		  /* 82229E3Ch */ case   22:  		/* lwz R11, <#[R8]> */
		/* 82229E3Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82229E3Ch case   22:*/		return 0x82229E40;
		  /* 82229E40h */ case   23:  		/* lwz R5, <#[R11 + 12]> */
		/* 82229E40h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 82229E40h case   23:*/		return 0x82229E44;
		  /* 82229E44h */ case   24:  		/* cmplw CR6, R5, R24 */
		/* 82229E44h case   24:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R24);
		/* 82229E44h case   24:*/		return 0x82229E48;
		  /* 82229E48h */ case   25:  		/* bc 4, CR6_EQ, 28 */
		/* 82229E48h case   25:*/		if ( !regs.CR[6].eq ) { return 0x82229E64;  }
		/* 82229E48h case   25:*/		return 0x82229E4C;
		  /* 82229E4Ch */ case   26:  		/* lwz R11, <#[R11]> */
		/* 82229E4Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82229E4Ch case   26:*/		return 0x82229E50;
		  /* 82229E50h */ case   27:  		/* srw R5, R27, R10 */
		/* 82229E50h case   27:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R27,regs.R10);
		/* 82229E50h case   27:*/		return 0x82229E54;
		  /* 82229E54h */ case   28:  		/* rlwinm R11, R11, 27, 5, 31 */
		/* 82229E54h case   28:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R11);
		/* 82229E54h case   28:*/		return 0x82229E58;
		  /* 82229E58h */ case   29:  		/* xor R11, R5, R11 */
		/* 82229E58h case   29:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82229E58h case   29:*/		return 0x82229E5C;
		  /* 82229E5Ch */ case   30:  		/* rlwinm. R11, R11, 0, 30, 31 */
		/* 82229E5Ch case   30:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82229E5Ch case   30:*/		return 0x82229E60;
		  /* 82229E60h */ case   31:  		/* bc 12, CR0_EQ, 16 */
		/* 82229E60h case   31:*/		if ( regs.CR[0].eq ) { return 0x82229E70;  }
		/* 82229E60h case   31:*/		return 0x82229E64;
	}
	return 0x82229E64;
} // Block from 82229DE4h-82229E64h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82229E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229E64);
		  /* 82229E64h */ case    0:  		/* addi R9, R9, 1 */
		/* 82229E64h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82229E64h case    0:*/		return 0x82229E68;
		  /* 82229E68h */ case    1:  		/* addi R8, R8, 4 */
		/* 82229E68h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82229E68h case    1:*/		return 0x82229E6C;
		  /* 82229E6Ch */ case    2:  		/* b -56 */
		/* 82229E6Ch case    2:*/		return 0x82229E34;
		/* 82229E6Ch case    2:*/		return 0x82229E70;
	}
	return 0x82229E70;
} // Block from 82229E64h-82229E70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82229E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229E70);
		  /* 82229E70h */ case    0:  		/* slw R11, R26, R10 */
		/* 82229E70h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R26,regs.R10);
		/* 82229E70h case    0:*/		return 0x82229E74;
		  /* 82229E74h */ case    1:  		/* slw R9, R9, R10 */
		/* 82229E74h case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82229E74h case    1:*/		return 0x82229E78;
		  /* 82229E78h */ case    2:  		/* andc R11, R27, R11 */
		/* 82229E78h case    2:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82229E78h case    2:*/		return 0x82229E7C;
		  /* 82229E7Ch */ case    3:  		/* or R27, R11, R9 */
		/* 82229E7Ch case    3:*/		cpu::op::or<0>(regs,&regs.R27,regs.R11,regs.R9);
		/* 82229E7Ch case    3:*/		return 0x82229E80;
	}
	return 0x82229E80;
} // Block from 82229E70h-82229E80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82229E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229E80);
		  /* 82229E80h */ case    0:  		/* addi R10, R10, 2 */
		/* 82229E80h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82229E80h case    0:*/		return 0x82229E84;
		  /* 82229E84h */ case    1:  		/* bc 16, CR0_LT, -88 */
		/* 82229E84h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82229E2C;  }
		/* 82229E84h case    1:*/		return 0x82229E88;
	}
	return 0x82229E88;
} // Block from 82229E80h-82229E88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229E88);
		  /* 82229E88h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82229E88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82229E88h case    0:*/		return 0x82229E8C;
		  /* 82229E8Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 82229E8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82229E8Ch case    1:*/		return 0x82229E90;
		  /* 82229E90h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82229E90h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82229E90h case    2:*/		return 0x82229E94;
		  /* 82229E94h */ case    3:  		/* b 12 */
		/* 82229E94h case    3:*/		return 0x82229EA0;
		/* 82229E94h case    3:*/		return 0x82229E98;
		  /* 82229E98h */ case    4:  		/* addi R11, R10, 8 */
		/* 82229E98h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82229E98h case    4:*/		return 0x82229E9C;
		  /* 82229E9Ch */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 82229E9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82229E9Ch case    5:*/		return 0x82229EA0;
	}
	return 0x82229EA0;
} // Block from 82229E88h-82229EA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82229EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229EA0);
		  /* 82229EA0h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 82229EA0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82229EA0h case    0:*/		return 0x82229EA4;
		  /* 82229EA4h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82229EA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82229E98;  }
		/* 82229EA4h case    1:*/		return 0x82229EA8;
		  /* 82229EA8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82229EA8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82229EA8h case    2:*/		return 0x82229EAC;
		  /* 82229EACh */ case    3:  		/* stw R10, <#[R11]> */
		/* 82229EACh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82229EACh case    3:*/		return 0x82229EB0;
		  /* 82229EB0h */ case    4:  		/* lwz R11, <#[R28 + 4]> */
		/* 82229EB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82229EB0h case    4:*/		return 0x82229EB4;
		  /* 82229EB4h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82229EB4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82229EB4h case    5:*/		return 0x82229EB8;
		  /* 82229EB8h */ case    6:  		/* stw R31, <#[R28 + 4]> */
		/* 82229EB8h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000004) );
		/* 82229EB8h case    6:*/		return 0x82229EBC;
		  /* 82229EBCh */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82229EBCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229EBCh case    7:*/		return 0x82229EC0;
		  /* 82229EC0h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82229EC0h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82229EC0h case    8:*/		return 0x82229EC4;
		  /* 82229EC4h */ case    9:  		/* stw R28, <#[R31 + 12]> */
		/* 82229EC4h case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 82229EC4h case    9:*/		return 0x82229EC8;
		  /* 82229EC8h */ case   10:  		/* stw R11, <#[R31]> */
		/* 82229EC8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229EC8h case   10:*/		return 0x82229ECC;
	}
	return 0x82229ECC;
} // Block from 82229EA0h-82229ECCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82229ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229ECC);
		  /* 82229ECCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82229ECCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229ECCh case    0:*/		return 0x82229ED0;
		  /* 82229ED0h */ case    1:  		/* mr R7, R31 */
		/* 82229ED0h case    1:*/		regs.R7 = regs.R31;
		/* 82229ED0h case    1:*/		return 0x82229ED4;
		  /* 82229ED4h */ case    2:  		/* mr R6, R31 */
		/* 82229ED4h case    2:*/		regs.R6 = regs.R31;
		/* 82229ED4h case    2:*/		return 0x82229ED8;
		  /* 82229ED8h */ case    3:  		/* rlwimi R11, R27, 5, 19, 26 */
		/* 82229ED8h case    3:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R27);
		/* 82229ED8h case    3:*/		return 0x82229EDC;
		  /* 82229EDCh */ case    4:  		/* li R5, 0 */
		/* 82229EDCh case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82229EDCh case    4:*/		return 0x82229EE0;
		  /* 82229EE0h */ case    5:  		/* stw R11, <#[R31]> */
		/* 82229EE0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82229EE0h case    5:*/		return 0x82229EE4;
		  /* 82229EE4h */ case    6:  		/* mr R4, R22 */
		/* 82229EE4h case    6:*/		regs.R4 = regs.R22;
		/* 82229EE4h case    6:*/		return 0x82229EE8;
		  /* 82229EE8h */ case    7:  		/* mr R3, R25 */
		/* 82229EE8h case    7:*/		regs.R3 = regs.R25;
		/* 82229EE8h case    7:*/		return 0x82229EEC;
		  /* 82229EECh */ case    8:  		/* bl -721076 */
		/* 82229EECh case    8:*/		regs.LR = 0x82229EF0; return 0x82179E38;
		/* 82229EECh case    8:*/		return 0x82229EF0;
		  /* 82229EF0h */ case    9:  		/* mr R31, R3 */
		/* 82229EF0h case    9:*/		regs.R31 = regs.R3;
		/* 82229EF0h case    9:*/		return 0x82229EF4;
		  /* 82229EF4h */ case   10:  		/* mr R4, R3 */
		/* 82229EF4h case   10:*/		regs.R4 = regs.R3;
		/* 82229EF4h case   10:*/		return 0x82229EF8;
		  /* 82229EF8h */ case   11:  		/* mr R5, R23 */
		/* 82229EF8h case   11:*/		regs.R5 = regs.R23;
		/* 82229EF8h case   11:*/		return 0x82229EFC;
		  /* 82229EFCh */ case   12:  		/* mr R3, R25 */
		/* 82229EFCh case   12:*/		regs.R3 = regs.R25;
		/* 82229EFCh case   12:*/		return 0x82229F00;
		  /* 82229F00h */ case   13:  		/* bl -22384 */
		/* 82229F00h case   13:*/		regs.LR = 0x82229F04; return 0x82224790;
		/* 82229F00h case   13:*/		return 0x82229F04;
		  /* 82229F04h */ case   14:  		/* lwz R10, <#[R30]> */
		/* 82229F04h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82229F04h case   14:*/		return 0x82229F08;
		  /* 82229F08h */ case   15:  		/* lwz R11, <#[R30 + 12]> */
		/* 82229F08h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82229F08h case   15:*/		return 0x82229F0C;
		  /* 82229F0Ch */ case   16:  		/* rlwinm R10, R10, 0, 0, 26 */
		/* 82229F0Ch case   16:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R10,regs.R10);
		/* 82229F0Ch case   16:*/		return 0x82229F10;
		  /* 82229F10h */ case   17:  		/* addi R11, R11, 4 */
		/* 82229F10h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82229F10h case   17:*/		return 0x82229F14;
		  /* 82229F14h */ case   18:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 82229F14h case   18:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 82229F14h case   18:*/		return 0x82229F18;
		  /* 82229F18h */ case   19:  		/* rlwinm R8, R10, 24, 29, 30 */
		/* 82229F18h case   19:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R10);
		/* 82229F18h case   19:*/		return 0x82229F1C;
		  /* 82229F1Ch */ case   20:  		/* srw R9, R29, R9 */
		/* 82229F1Ch case   20:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 82229F1Ch case   20:*/		return 0x82229F20;
		  /* 82229F20h */ case   21:  		/* srw R8, R29, R8 */
		/* 82229F20h case   21:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R8);
		/* 82229F20h case   21:*/		return 0x82229F24;
		  /* 82229F24h */ case   22:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82229F24h case   22:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82229F24h case   22:*/		return 0x82229F28;
		  /* 82229F28h */ case   23:  		/* rlwinm R9, R10, 26, 29, 30 */
		/* 82229F28h case   23:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R10);
		/* 82229F28h case   23:*/		return 0x82229F2C;
		  /* 82229F2Ch */ case   24:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 82229F2Ch case   24:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 82229F2Ch case   24:*/		return 0x82229F30;
		  /* 82229F30h */ case   25:  		/* srw R9, R29, R9 */
		/* 82229F30h case   25:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 82229F30h case   25:*/		return 0x82229F34;
		  /* 82229F34h */ case   26:  		/* rlwinm R7, R10, 28, 29, 30 */
		/* 82229F34h case   26:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R10);
		/* 82229F34h case   26:*/		return 0x82229F38;
		  /* 82229F38h */ case   27:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 82229F38h case   27:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82229F38h case   27:*/		return 0x82229F3C;
		  /* 82229F3Ch */ case   28:  		/* srw R8, R29, R7 */
		/* 82229F3Ch case   28:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R7);
		/* 82229F3Ch case   28:*/		return 0x82229F40;
		  /* 82229F40h */ case   29:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 82229F40h case   29:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82229F40h case   29:*/		return 0x82229F44;
		  /* 82229F44h */ case   30:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 82229F44h case   30:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 82229F44h case   30:*/		return 0x82229F48;
		  /* 82229F48h */ case   31:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 82229F48h case   31:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 82229F48h case   31:*/		return 0x82229F4C;
		  /* 82229F4Ch */ case   32:  		/* or R10, R9, R10 */
		/* 82229F4Ch case   32:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82229F4Ch case   32:*/		return 0x82229F50;
		  /* 82229F50h */ case   33:  		/* stw R10, <#[R30]> */
		/* 82229F50h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82229F50h case   33:*/		return 0x82229F54;
		  /* 82229F54h */ case   34:  		/* lwz R10, <#[R11]> */
		/* 82229F54h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82229F54h case   34:*/		return 0x82229F58;
		  /* 82229F58h */ case   35:  		/* b 12 */
		/* 82229F58h case   35:*/		return 0x82229F64;
		/* 82229F58h case   35:*/		return 0x82229F5C;
		  /* 82229F5Ch */ case   36:  		/* addi R11, R10, 8 */
		/* 82229F5Ch case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82229F5Ch case   36:*/		return 0x82229F60;
		  /* 82229F60h */ case   37:  		/* lwz R10, <#[R10 + 8]> */
		/* 82229F60h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82229F60h case   37:*/		return 0x82229F64;
	}
	return 0x82229F64;
} // Block from 82229ECCh-82229F64h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82229F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229F64);
		  /* 82229F64h */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 82229F64h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 82229F64h case    0:*/		return 0x82229F68;
		  /* 82229F68h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82229F68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82229F5C;  }
		/* 82229F68h case    1:*/		return 0x82229F6C;
		  /* 82229F6Ch */ case    2:  		/* lwz R10, <#[R30 + 8]> */
		/* 82229F6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82229F6Ch case    2:*/		return 0x82229F70;
		  /* 82229F70h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82229F70h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82229F70h case    3:*/		return 0x82229F74;
		  /* 82229F74h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 82229F74h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82229F74h case    4:*/		return 0x82229F78;
		  /* 82229F78h */ case    5:  		/* stw R11, <#[R30 + 8]> */
		/* 82229F78h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82229F78h case    5:*/		return 0x82229F7C;
		  /* 82229F7Ch */ case    6:  		/* stw R30, <#[R31 + 4]> */
		/* 82229F7Ch case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 82229F7Ch case    6:*/		return 0x82229F80;
		  /* 82229F80h */ case    7:  		/* stw R31, <#[R30 + 12]> */
		/* 82229F80h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000000C) );
		/* 82229F80h case    7:*/		return 0x82229F84;
		  /* 82229F84h */ case    8:  		/* lwz R11, <#[R24 + 8]> */
		/* 82229F84h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82229F84h case    8:*/		return 0x82229F88;
		  /* 82229F88h */ case    9:  		/* rlwinm. R11, R11, 0, 27, 30 */
		/* 82229F88h case    9:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R11,regs.R11);
		/* 82229F88h case    9:*/		return 0x82229F8C;
		  /* 82229F8Ch */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 82229F8Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82229F98;  }
		/* 82229F8Ch case   10:*/		return 0x82229F90;
		  /* 82229F90h */ case   11:  		/* mr R3, R31 */
		/* 82229F90h case   11:*/		regs.R3 = regs.R31;
		/* 82229F90h case   11:*/		return 0x82229F94;
		  /* 82229F94h */ case   12:  		/* bl -728092 */
		/* 82229F94h case   12:*/		regs.LR = 0x82229F98; return 0x82178378;
		/* 82229F94h case   12:*/		return 0x82229F98;
	}
	return 0x82229F98;
} // Block from 82229F64h-82229F98h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82229F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229F98);
		  /* 82229F98h */ case    0:  		/* lbz R11, <#[R24 + 8]> */
		/* 82229F98h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82229F98h case    0:*/		return 0x82229F9C;
		  /* 82229F9Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82229F9Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82229F9Ch case    1:*/		return 0x82229FA0;
		  /* 82229FA0h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 82229FA0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82229FB8;  }
		/* 82229FA0h case    2:*/		return 0x82229FA4;
		  /* 82229FA4h */ case    3:  		/* mr R3, R31 */
		/* 82229FA4h case    3:*/		regs.R3 = regs.R31;
		/* 82229FA4h case    3:*/		return 0x82229FA8;
		  /* 82229FA8h */ case    4:  		/* bl -632096 */
		/* 82229FA8h case    4:*/		regs.LR = 0x82229FAC; return 0x8218FA88;
		/* 82229FA8h case    4:*/		return 0x82229FAC;
		  /* 82229FACh */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 82229FACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82229FACh case    5:*/		return 0x82229FB0;
		  /* 82229FB0h */ case    6:  		/* oris R11, R11, 256 */
		/* 82229FB0h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82229FB0h case    6:*/		return 0x82229FB4;
		  /* 82229FB4h */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 82229FB4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82229FB4h case    7:*/		return 0x82229FB8;
	}
	return 0x82229FB8;
} // Block from 82229F98h-82229FB8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82229FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229FB8);
		  /* 82229FB8h */ case    0:  		/* addi R1, R1, 176 */
		/* 82229FB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82229FB8h case    0:*/		return 0x82229FBC;
		  /* 82229FBCh */ case    1:  		/* b -1674540 */
		/* 82229FBCh case    1:*/		return 0x82091290;
		/* 82229FBCh case    1:*/		return 0x82229FC0;
	}
	return 0x82229FC0;
} // Block from 82229FB8h-82229FC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82229FC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229FC0);
		  /* 82229FC0h */ case    0:  		/* mfspr R12, LR */
		/* 82229FC0h case    0:*/		regs.R12 = regs.LR;
		/* 82229FC0h case    0:*/		return 0x82229FC4;
		  /* 82229FC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82229FC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82229FC4h case    1:*/		return 0x82229FC8;
		  /* 82229FC8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82229FC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82229FC8h case    2:*/		return 0x82229FCC;
		  /* 82229FCCh */ case    3:  		/* bl -852 */
		/* 82229FCCh case    3:*/		regs.LR = 0x82229FD0; return 0x82229C78;
		/* 82229FCCh case    3:*/		return 0x82229FD0;
		  /* 82229FD0h */ case    4:  		/* li R3, 0 */
		/* 82229FD0h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82229FD0h case    4:*/		return 0x82229FD4;
		  /* 82229FD4h */ case    5:  		/* addi R1, R1, 96 */
		/* 82229FD4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82229FD4h case    5:*/		return 0x82229FD8;
		  /* 82229FD8h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82229FD8h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82229FD8h case    6:*/		return 0x82229FDC;
		  /* 82229FDCh */ case    7:  		/* mtspr LR, R12 */
		/* 82229FDCh case    7:*/		regs.LR = regs.R12;
		/* 82229FDCh case    7:*/		return 0x82229FE0;
		  /* 82229FE0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82229FE0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82229FE0h case    8:*/		return 0x82229FE4;
	}
	return 0x82229FE4;
} // Block from 82229FC0h-82229FE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82229FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229FE4);
		  /* 82229FE4h */ case    0:  		/* nop */
		/* 82229FE4h case    0:*/		cpu::op::nop();
		/* 82229FE4h case    0:*/		return 0x82229FE8;
	}
	return 0x82229FE8;
} // Block from 82229FE4h-82229FE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82229FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82229FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82229FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82229FE8);
		  /* 82229FE8h */ case    0:  		/* mfspr R12, LR */
		/* 82229FE8h case    0:*/		regs.R12 = regs.LR;
		/* 82229FE8h case    0:*/		return 0x82229FEC;
		  /* 82229FECh */ case    1:  		/* bl -1674664 */
		/* 82229FECh case    1:*/		regs.LR = 0x82229FF0; return 0x82091244;
		/* 82229FECh case    1:*/		return 0x82229FF0;
		  /* 82229FF0h */ case    2:  		/* stfd FR31, <#[R1 - 88]> */
		/* 82229FF0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 82229FF0h case    2:*/		return 0x82229FF4;
		  /* 82229FF4h */ case    3:  		/* stwu R1, <#[R1 - 192]> */
		/* 82229FF4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82229FF4h case    3:*/		return 0x82229FF8;
		  /* 82229FF8h */ case    4:  		/* std R4, <#[R1 + 224]> */
		/* 82229FF8h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x000000E0) );
		/* 82229FF8h case    4:*/		return 0x82229FFC;
		  /* 82229FFCh */ case    5:  		/* mr R31, R3 */
		/* 82229FFCh case    5:*/		regs.R31 = regs.R3;
		/* 82229FFCh case    5:*/		return 0x8222A000;
		  /* 8222A000h */ case    6:  		/* lwz R27, <#[R1 + 228]> */
		/* 8222A000h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000E4) );
		/* 8222A000h case    6:*/		return 0x8222A004;
		  /* 8222A004h */ case    7:  		/* rlwinm R11, R27, 0, 27, 31 */
		/* 8222A004h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R27);
		/* 8222A004h case    7:*/		return 0x8222A008;
		  /* 8222A008h */ case    8:  		/* std R5, <#[R1 + 232]> */
		/* 8222A008h case    8:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x000000E8) );
		/* 8222A008h case    8:*/		return 0x8222A00C;
		  /* 8222A00Ch */ case    9:  		/* mr R23, R6 */
		/* 8222A00Ch case    9:*/		regs.R23 = regs.R6;
		/* 8222A00Ch case    9:*/		return 0x8222A010;
		  /* 8222A010h */ case   10:  		/* mr R25, R7 */
		/* 8222A010h case   10:*/		regs.R25 = regs.R7;
		/* 8222A010h case   10:*/		return 0x8222A014;
		  /* 8222A014h */ case   11:  		/* mr R26, R8 */
		/* 8222A014h case   11:*/		regs.R26 = regs.R8;
		/* 8222A014h case   11:*/		return 0x8222A018;
		  /* 8222A018h */ case   12:  		/* mr R24, R9 */
		/* 8222A018h case   12:*/		regs.R24 = regs.R9;
		/* 8222A018h case   12:*/		return 0x8222A01C;
		  /* 8222A01Ch */ case   13:  		/* li R30, 0 */
		/* 8222A01Ch case   13:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8222A01Ch case   13:*/		return 0x8222A020;
		  /* 8222A020h */ case   14:  		/* cmplwi CR6, R11, 17 */
		/* 8222A020h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 8222A020h case   14:*/		return 0x8222A024;
		  /* 8222A024h */ case   15:  		/* bc 4, CR6_EQ, 100 */
		/* 8222A024h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8222A088;  }
		/* 8222A024h case   15:*/		return 0x8222A028;
		  /* 8222A028h */ case   16:  		/* lwz R10, <#[R3 + 536]> */
		/* 8222A028h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000218) );
		/* 8222A028h case   16:*/		return 0x8222A02C;
		  /* 8222A02Ch */ case   17:  		/* li R11, 0 */
		/* 8222A02Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222A02Ch case   17:*/		return 0x8222A030;
		  /* 8222A030h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 8222A030h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222A030h case   18:*/		return 0x8222A034;
		  /* 8222A034h */ case   19:  		/* bc 4, CR6_GT, 84 */
		/* 8222A034h case   19:*/		if ( !regs.CR[6].gt ) { return 0x8222A088;  }
		/* 8222A034h case   19:*/		return 0x8222A038;
		  /* 8222A038h */ case   20:  		/* addi R10, R3, 348 */
		/* 8222A038h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x15C);
		/* 8222A038h case   20:*/		return 0x8222A03C;
		  /* 8222A03Ch */ case   21:  		/* lwz R9, <#[R10]> */
		/* 8222A03Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222A03Ch case   21:*/		return 0x8222A040;
		  /* 8222A040h */ case   22:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8222A040h case   22:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8222A040h case   22:*/		return 0x8222A044;
		  /* 8222A044h */ case   23:  		/* cmplwi CR6, R9, 17 */
		/* 8222A044h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000011);
		/* 8222A044h case   23:*/		return 0x8222A048;
		  /* 8222A048h */ case   24:  		/* bc 12, CR6_EQ, 28 */
		/* 8222A048h case   24:*/		if ( regs.CR[6].eq ) { return 0x8222A064;  }
		/* 8222A048h case   24:*/		return 0x8222A04C;
		  /* 8222A04Ch */ case   25:  		/* lwz R9, <#[R31 + 536]> */
		/* 8222A04Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000218) );
		/* 8222A04Ch case   25:*/		return 0x8222A050;
		  /* 8222A050h */ case   26:  		/* addi R11, R11, 1 */
		/* 8222A050h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222A050h case   26:*/		return 0x8222A054;
		  /* 8222A054h */ case   27:  		/* addi R10, R10, 12 */
		/* 8222A054h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8222A054h case   27:*/		return 0x8222A058;
		  /* 8222A058h */ case   28:  		/* cmplw CR6, R11, R9 */
		/* 8222A058h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8222A058h case   28:*/		return 0x8222A05C;
		  /* 8222A05Ch */ case   29:  		/* bc 12, CR6_LT, -32 */
		/* 8222A05Ch case   29:*/		if ( regs.CR[6].lt ) { return 0x8222A03C;  }
		/* 8222A05Ch case   29:*/		return 0x8222A060;
		  /* 8222A060h */ case   30:  		/* b 40 */
		/* 8222A060h case   30:*/		return 0x8222A088;
		/* 8222A060h case   30:*/		return 0x8222A064;
	}
	return 0x8222A064;
} // Block from 82229FE8h-8222A064h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8222A064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A064);
		  /* 8222A064h */ case    0:  		/* addi R9, R11, 29 */
		/* 8222A064h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1D);
		/* 8222A064h case    0:*/		return 0x8222A068;
		  /* 8222A068h */ case    1:  		/* mulli R10, R11, 12 */
		/* 8222A068h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0xC);
		/* 8222A068h case    1:*/		return 0x8222A06C;
		  /* 8222A06Ch */ case    2:  		/* mulli R11, R9, 12 */
		/* 8222A06Ch case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R9,0xC);
		/* 8222A06Ch case    2:*/		return 0x8222A070;
		  /* 8222A070h */ case    3:  		/* lwzx R9, <#[R11 + R31]> */
		/* 8222A070h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8222A070h case    3:*/		return 0x8222A074;
		  /* 8222A074h */ case    4:  		/* add R10, R10, R31 */
		/* 8222A074h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 8222A074h case    4:*/		return 0x8222A078;
		  /* 8222A078h */ case    5:  		/* rlwinm R8, R27, 0, 15, 15 */
		/* 8222A078h case    5:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R8,regs.R27);
		/* 8222A078h case    5:*/		return 0x8222A07C;
		  /* 8222A07Ch */ case    6:  		/* or R9, R8, R9 */
		/* 8222A07Ch case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8222A07Ch case    6:*/		return 0x8222A080;
		  /* 8222A080h */ case    7:  		/* lwz R30, <#[R10 + 352]> */
		/* 8222A080h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000160) );
		/* 8222A080h case    7:*/		return 0x8222A084;
		  /* 8222A084h */ case    8:  		/* stwx R9, <#[R11 + R31]> */
		/* 8222A084h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8222A084h case    8:*/		return 0x8222A088;
	}
	return 0x8222A088;
} // Block from 8222A064h-8222A088h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222A088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A088);
		  /* 8222A088h */ case    0:  		/* mr R28, R23 */
		/* 8222A088h case    0:*/		regs.R28 = regs.R23;
		/* 8222A088h case    0:*/		return 0x8222A08C;
		  /* 8222A08Ch */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 8222A08Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8222A08Ch case    1:*/		return 0x8222A090;
		  /* 8222A090h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 8222A090h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222A098;  }
		/* 8222A090h case    2:*/		return 0x8222A094;
		  /* 8222A094h */ case    3:  		/* li R28, 4 */
		/* 8222A094h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x4);
		/* 8222A094h case    3:*/		return 0x8222A098;
	}
	return 0x8222A098;
} // Block from 8222A088h-8222A098h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222A098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A098);
		  /* 8222A098h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8222A098h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8222A098h case    0:*/		return 0x8222A09C;
		  /* 8222A09Ch */ case    1:  		/* bc 4, CR6_EQ, 356 */
		/* 8222A09Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222A200;  }
		/* 8222A09Ch case    1:*/		return 0x8222A0A0;
		  /* 8222A0A0h */ case    2:  		/* lwz R11, <#[R31 + 536]> */
		/* 8222A0A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 8222A0A0h case    2:*/		return 0x8222A0A4;
		  /* 8222A0A4h */ case    3:  		/* mr R3, R31 */
		/* 8222A0A4h case    3:*/		regs.R3 = regs.R31;
		/* 8222A0A4h case    3:*/		return 0x8222A0A8;
		  /* 8222A0A8h */ case    4:  		/* cmplwi CR6, R11, 16 */
		/* 8222A0A8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8222A0A8h case    4:*/		return 0x8222A0AC;
		  /* 8222A0ACh */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8222A0ACh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8222A0B8;  }
		/* 8222A0ACh case    5:*/		return 0x8222A0B0;
		  /* 8222A0B0h */ case    6:  		/* li R4, 3530 */
		/* 8222A0B0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xDCA);
		/* 8222A0B0h case    6:*/		return 0x8222A0B4;
		  /* 8222A0B4h */ case    7:  		/* bl -885324 */
		/* 8222A0B4h case    7:*/		regs.LR = 0x8222A0B8; return 0x82151E68;
		/* 8222A0B4h case    7:*/		return 0x8222A0B8;
	}
	return 0x8222A0B8;
} // Block from 8222A098h-8222A0B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222A0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A0B8);
		  /* 8222A0B8h */ case    0:  		/* lwz R30, <#[R1 + 232]> */
		/* 8222A0B8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000E8) );
		/* 8222A0B8h case    0:*/		return 0x8222A0BC;
		  /* 8222A0BCh */ case    1:  		/* li R8, 0 */
		/* 8222A0BCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8222A0BCh case    1:*/		return 0x8222A0C0;
		  /* 8222A0C0h */ case    2:  		/* li R7, 0 */
		/* 8222A0C0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8222A0C0h case    2:*/		return 0x8222A0C4;
		  /* 8222A0C4h */ case    3:  		/* li R6, 0 */
		/* 8222A0C4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8222A0C4h case    3:*/		return 0x8222A0C8;
		  /* 8222A0C8h */ case    4:  		/* rldicr R5, R30, 32, 63 */
		/* 8222A0C8h case    4:*/		cpu::op::rldicr<0,32,63>(regs,&regs.R5,regs.R30);
		/* 8222A0C8h case    4:*/		return 0x8222A0CC;
		  /* 8222A0CCh */ case    5:  		/* bl -36324 */
		/* 8222A0CCh case    5:*/		regs.LR = 0x8222A0D0; return 0x822212E8;
		/* 8222A0CCh case    5:*/		return 0x8222A0D0;
		  /* 8222A0D0h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222A0D0h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222A0D0h case    6:*/		return 0x8222A0D4;
		  /* 8222A0D4h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8222A0D4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8222A0E0;  }
		/* 8222A0D4h case    7:*/		return 0x8222A0D8;
		  /* 8222A0D8h */ case    8:  		/* li R3, 0 */
		/* 8222A0D8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8222A0D8h case    8:*/		return 0x8222A0DC;
		  /* 8222A0DCh */ case    9:  		/* b 868 */
		/* 8222A0DCh case    9:*/		return 0x8222A440;
		/* 8222A0DCh case    9:*/		return 0x8222A0E0;
	}
	return 0x8222A0E0;
} // Block from 8222A0B8h-8222A0E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222A0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A0E0);
		  /* 8222A0E0h */ case    0:  		/* lwz R11, <#[R31 + 536]> */
		/* 8222A0E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 8222A0E0h case    0:*/		return 0x8222A0E4;
		  /* 8222A0E4h */ case    1:  		/* li R6, 1 */
		/* 8222A0E4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8222A0E4h case    1:*/		return 0x8222A0E8;
		  /* 8222A0E8h */ case    2:  		/* lwz R9, <#[R1 + 224]> */
		/* 8222A0E8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000E0) );
		/* 8222A0E8h case    2:*/		return 0x8222A0EC;
		  /* 8222A0ECh */ case    3:  		/* li R5, 0 */
		/* 8222A0ECh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222A0ECh case    3:*/		return 0x8222A0F0;
		  /* 8222A0F0h */ case    4:  		/* mulli R10, R11, 12 */
		/* 8222A0F0h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0xC);
		/* 8222A0F0h case    4:*/		return 0x8222A0F4;
		  /* 8222A0F4h */ case    5:  		/* add R29, R10, R31 */
		/* 8222A0F4h case    5:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R31);
		/* 8222A0F4h case    5:*/		return 0x8222A0F8;
		  /* 8222A0F8h */ case    6:  		/* addi R11, R11, 1 */
		/* 8222A0F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222A0F8h case    6:*/		return 0x8222A0FC;
		  /* 8222A0FCh */ case    7:  		/* li R4, 113 */
		/* 8222A0FCh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x71);
		/* 8222A0FCh case    7:*/		return 0x8222A100;
		  /* 8222A100h */ case    8:  		/* mr R3, R31 */
		/* 8222A100h case    8:*/		regs.R3 = regs.R31;
		/* 8222A100h case    8:*/		return 0x8222A104;
		  /* 8222A104h */ case    9:  		/* stw R11, <#[R31 + 536]> */
		/* 8222A104h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000218) );
		/* 8222A104h case    9:*/		return 0x8222A108;
		  /* 8222A108h */ case   10:  		/* stw R9, <#[R29 + 344]> */
		/* 8222A108h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000158) );
		/* 8222A108h case   10:*/		return 0x8222A10C;
		  /* 8222A10Ch */ case   11:  		/* stw R27, <#[R29 + 348]> */
		/* 8222A10Ch case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x0000015C) );
		/* 8222A10Ch case   11:*/		return 0x8222A110;
		  /* 8222A110h */ case   12:  		/* stw R30, <#[R29 + 352]> */
		/* 8222A110h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000160) );
		/* 8222A110h case   12:*/		return 0x8222A114;
		  /* 8222A114h */ case   13:  		/* bl -810212 */
		/* 8222A114h case   13:*/		regs.LR = 0x8222A118; return 0x82164430;
		/* 8222A114h case   13:*/		return 0x8222A118;
		  /* 8222A118h */ case   14:  		/* mr R4, R3 */
		/* 8222A118h case   14:*/		regs.R4 = regs.R3;
		/* 8222A118h case   14:*/		return 0x8222A11C;
		  /* 8222A11Ch */ case   15:  		/* mr R3, R31 */
		/* 8222A11Ch case   15:*/		regs.R3 = regs.R31;
		/* 8222A11Ch case   15:*/		return 0x8222A120;
		  /* 8222A120h */ case   16:  		/* li R5, 35 */
		/* 8222A120h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 8222A120h case   16:*/		return 0x8222A124;
		  /* 8222A124h */ case   17:  		/* bl -775548 */
		/* 8222A124h case   17:*/		regs.LR = 0x8222A128; return 0x8216CBA8;
		/* 8222A124h case   17:*/		return 0x8222A128;
		  /* 8222A128h */ case   18:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A128h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A128h case   18:*/		return 0x8222A12C;
		  /* 8222A12Ch */ case   19:  		/* mr R8, R28 */
		/* 8222A12Ch case   19:*/		regs.R8 = regs.R28;
		/* 8222A12Ch case   19:*/		return 0x8222A130;
		  /* 8222A130h */ case   20:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A130h case   20:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A130h case   20:*/		return 0x8222A134;
		  /* 8222A134h */ case   21:  		/* li R7, 0 */
		/* 8222A134h case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8222A134h case   21:*/		return 0x8222A138;
		  /* 8222A138h */ case   22:  		/* addic R10, R10, -1 */
		/* 8222A138h case   22:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A138h case   22:*/		return 0x8222A13C;
		  /* 8222A13Ch */ case   23:  		/* li R6, 113 */
		/* 8222A13Ch case   23:*/		cpu::op::li<0>(regs,&regs.R6,0x71);
		/* 8222A13Ch case   23:*/		return 0x8222A140;
		  /* 8222A140h */ case   24:  		/* subfe R10, R10, R10 */
		/* 8222A140h case   24:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A140h case   24:*/		return 0x8222A144;
		  /* 8222A144h */ case   25:  		/* mr R4, R31 */
		/* 8222A144h case   25:*/		regs.R4 = regs.R31;
		/* 8222A144h case   25:*/		return 0x8222A148;
		  /* 8222A148h */ case   26:  		/* and R5, R10, R11 */
		/* 8222A148h case   26:*/		cpu::op::and<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 8222A148h case   26:*/		return 0x8222A14C;
		  /* 8222A14Ch */ case   27:  		/* mr R30, R3 */
		/* 8222A14Ch case   27:*/		regs.R30 = regs.R3;
		/* 8222A14Ch case   27:*/		return 0x8222A150;
		  /* 8222A150h */ case   28:  		/* bl -24120 */
		/* 8222A150h case   28:*/		regs.LR = 0x8222A154; return 0x82224318;
		/* 8222A150h case   28:*/		return 0x8222A154;
		  /* 8222A154h */ case   29:  		/* rlwinm. R10, R26, 0, 24, 31 */
		/* 8222A154h case   29:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R26);
		/* 8222A154h case   29:*/		return 0x8222A158;
		  /* 8222A158h */ case   30:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8222A158h case   30:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8222A158h case   30:*/		return 0x8222A15C;
		  /* 8222A15Ch */ case   31:  		/* addi R11, R11, 36 */
		/* 8222A15Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8222A15Ch case   31:*/		return 0x8222A160;
		  /* 8222A160h */ case   32:  		/* lwz R10, <#[R30 + 8]> */
		/* 8222A160h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8222A160h case   32:*/		return 0x8222A164;
		  /* 8222A164h */ case   33:  		/* addi R7, R11, -36 */
		/* 8222A164h case   33:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8222A164h case   33:*/		return 0x8222A168;
		  /* 8222A168h */ case   34:  		/* addi R9, R11, 4 */
		/* 8222A168h case   34:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8222A168h case   34:*/		return 0x8222A16C;
		  /* 8222A16Ch */ case   35:  		/* oris R10, R10, 128 */
		/* 8222A16Ch case   35:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x80);
		/* 8222A16Ch case   35:*/		return 0x8222A170;
		  /* 8222A170h */ case   36:  		/* stw R10, <#[R30 + 8]> */
		/* 8222A170h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8222A170h case   36:*/		return 0x8222A174;
		  /* 8222A174h */ case   37:  		/* lwz R10, <#[R31 + 4]> */
		/* 8222A174h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A174h case   37:*/		return 0x8222A178;
		  /* 8222A178h */ case   38:  		/* rlwinm R8, R10, 0, 31, 31 */
		/* 8222A178h case   38:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R10);
		/* 8222A178h case   38:*/		return 0x8222A17C;
		  /* 8222A17Ch */ case   39:  		/* addic R8, R8, -1 */
		/* 8222A17Ch case   39:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 8222A17Ch case   39:*/		return 0x8222A180;
		  /* 8222A180h */ case   40:  		/* subfe R8, R8, R8 */
		/* 8222A180h case   40:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 8222A180h case   40:*/		return 0x8222A184;
		  /* 8222A184h */ case   41:  		/* and R10, R8, R10 */
		/* 8222A184h case   41:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8222A184h case   41:*/		return 0x8222A188;
		  /* 8222A188h */ case   42:  		/* addi R8, R10, 16 */
		/* 8222A188h case   42:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x10);
		/* 8222A188h case   42:*/		return 0x8222A18C;
		  /* 8222A18Ch */ case   43:  		/* addi R8, R8, -36 */
		/* 8222A18Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFDC);
		/* 8222A18Ch case   43:*/		return 0x8222A190;
		  /* 8222A190h */ case   44:  		/* lwz R6, <#[R10 + 16]> */
		/* 8222A190h case   44:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 8222A190h case   44:*/		return 0x8222A194;
		  /* 8222A194h */ case   45:  		/* stw R6, <#[R11]> */
		/* 8222A194h case   45:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8222A194h case   45:*/		return 0x8222A198;
		  /* 8222A198h */ case   46:  		/* ori R8, R8, 1 */
		/* 8222A198h case   46:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8222A198h case   46:*/		return 0x8222A19C;
		  /* 8222A19Ch */ case   47:  		/* lwz R6, <#[R10 + 16]> */
		/* 8222A19Ch case   47:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 8222A19Ch case   47:*/		return 0x8222A1A0;
		  /* 8222A1A0h */ case   48:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8222A1A0h case   48:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8222A1A0h case   48:*/		return 0x8222A1A4;
		  /* 8222A1A4h */ case   49:  		/* stw R7, <#[R6]> */
		/* 8222A1A4h case   49:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8222A1A4h case   49:*/		return 0x8222A1A8;
		  /* 8222A1A8h */ case   50:  		/* stw R8, <#[R11 + 4]> */
		/* 8222A1A8h case   50:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8222A1A8h case   50:*/		return 0x8222A1AC;
		  /* 8222A1ACh */ case   51:  		/* stw R9, <#[R10 + 16]> */
		/* 8222A1ACh case   51:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8222A1ACh case   51:*/		return 0x8222A1B0;
		  /* 8222A1B0h */ case   52:  		/* stw R30, <#[R29 + 352]> */
		/* 8222A1B0h case   52:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000160) );
		/* 8222A1B0h case   52:*/		return 0x8222A1B4;
		  /* 8222A1B4h */ case   53:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222A1B4h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222A1B4h case   53:*/		return 0x8222A1B8;
		  /* 8222A1B8h */ case   54:  		/* oris R11, R11, 2048 */
		/* 8222A1B8h case   54:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x800);
		/* 8222A1B8h case   54:*/		return 0x8222A1BC;
		  /* 8222A1BCh */ case   55:  		/* stw R11, <#[R30 + 8]> */
		/* 8222A1BCh case   55:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222A1BCh case   55:*/		return 0x8222A1C0;
		  /* 8222A1C0h */ case   56:  		/* bc 12, CR0_EQ, 64 */
		/* 8222A1C0h case   56:*/		if ( regs.CR[0].eq ) { return 0x8222A200;  }
		/* 8222A1C0h case   56:*/		return 0x8222A1C4;
		  /* 8222A1C4h */ case   57:  		/* cmpwi CR6, R25, 0 */
		/* 8222A1C4h case   57:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8222A1C4h case   57:*/		return 0x8222A1C8;
		  /* 8222A1C8h */ case   58:  		/* bc 4, CR6_EQ, 56 */
		/* 8222A1C8h case   58:*/		if ( !regs.CR[6].eq ) { return 0x8222A200;  }
		/* 8222A1C8h case   58:*/		return 0x8222A1CC;
		  /* 8222A1CCh */ case   59:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 8222A1CCh case   59:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 8222A1CCh case   59:*/		return 0x8222A1D0;
		  /* 8222A1D0h */ case   60:  		/* lwz R11, <#[R30 + 12]> */
		/* 8222A1D0h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8222A1D0h case   60:*/		return 0x8222A1D4;
		  /* 8222A1D4h */ case   61:  		/* bc 12, CR0_EQ, 24 */
		/* 8222A1D4h case   61:*/		if ( regs.CR[0].eq ) { return 0x8222A1EC;  }
		/* 8222A1D4h case   61:*/		return 0x8222A1D8;
		  /* 8222A1D8h */ case   62:  		/* andi. R10, R11, 17476 */
		/* 8222A1D8h case   62:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x4444);
		/* 8222A1D8h case   62:*/		return 0x8222A1DC;
		  /* 8222A1DCh */ case   63:  		/* cmplwi CR6, R10, 17476 */
		/* 8222A1DCh case   63:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00004444);
		/* 8222A1DCh case   63:*/		return 0x8222A1E0;
		  /* 8222A1E0h */ case   64:  		/* bc 12, CR6_EQ, 32 */
		/* 8222A1E0h case   64:*/		if ( regs.CR[6].eq ) { return 0x8222A200;  }
		/* 8222A1E0h case   64:*/		return 0x8222A1E4;
		  /* 8222A1E4h */ case   65:  		/* ori R11, R11, 17476 */
		/* 8222A1E4h case   65:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4444);
		/* 8222A1E4h case   65:*/		return 0x8222A1E8;
		  /* 8222A1E8h */ case   66:  		/* b 20 */
		/* 8222A1E8h case   66:*/		return 0x8222A1FC;
		/* 8222A1E8h case   66:*/		return 0x8222A1EC;
	}
	return 0x8222A1EC;
} // Block from 8222A0E0h-8222A1ECh (67 instructions)

//////////////////////////////////////////////////////
// Block at 8222A1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A1EC);
		  /* 8222A1ECh */ case    0:  		/* andi. R10, R11, 26214 */
		/* 8222A1ECh case    0:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x6666);
		/* 8222A1ECh case    0:*/		return 0x8222A1F0;
		  /* 8222A1F0h */ case    1:  		/* cmplwi CR6, R10, 26214 */
		/* 8222A1F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00006666);
		/* 8222A1F0h case    1:*/		return 0x8222A1F4;
		  /* 8222A1F4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8222A1F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222A200;  }
		/* 8222A1F4h case    2:*/		return 0x8222A1F8;
		  /* 8222A1F8h */ case    3:  		/* ori R11, R11, 26214 */
		/* 8222A1F8h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x6666);
		/* 8222A1F8h case    3:*/		return 0x8222A1FC;
	}
	return 0x8222A1FC;
} // Block from 8222A1ECh-8222A1FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222A1FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A1FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A1FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A1FC);
		  /* 8222A1FCh */ case    0:  		/* sth R11, <#[R30 + 14]> */
		/* 8222A1FCh case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R30 + 0x0000000E) );
		/* 8222A1FCh case    0:*/		return 0x8222A200;
	}
	return 0x8222A200;
} // Block from 8222A1FCh-8222A200h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222A200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A200);
		  /* 8222A200h */ case    0:  		/* mr R4, R30 */
		/* 8222A200h case    0:*/		regs.R4 = regs.R30;
		/* 8222A200h case    0:*/		return 0x8222A204;
		  /* 8222A204h */ case    1:  		/* mr R3, R31 */
		/* 8222A204h case    1:*/		regs.R3 = regs.R31;
		/* 8222A204h case    1:*/		return 0x8222A208;
		  /* 8222A208h */ case    2:  		/* bl -729608 */
		/* 8222A208h case    2:*/		regs.LR = 0x8222A20C; return 0x82178000;
		/* 8222A208h case    2:*/		return 0x8222A20C;
		  /* 8222A20Ch */ case    3:  		/* mr R5, R3 */
		/* 8222A20Ch case    3:*/		regs.R5 = regs.R3;
		/* 8222A20Ch case    3:*/		return 0x8222A210;
		  /* 8222A210h */ case    4:  		/* cmpwi CR6, R25, 1 */
		/* 8222A210h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000001);
		/* 8222A210h case    4:*/		return 0x8222A214;
		  /* 8222A214h */ case    5:  		/* mr R3, R31 */
		/* 8222A214h case    5:*/		regs.R3 = regs.R31;
		/* 8222A214h case    5:*/		return 0x8222A218;
		  /* 8222A218h */ case    6:  		/* bc 12, CR6_EQ, 492 */
		/* 8222A218h case    6:*/		if ( regs.CR[6].eq ) { return 0x8222A404;  }
		/* 8222A218h case    6:*/		return 0x8222A21C;
		  /* 8222A21Ch */ case    7:  		/* cmpwi CR6, R25, 2 */
		/* 8222A21Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000002);
		/* 8222A21Ch case    7:*/		return 0x8222A220;
		  /* 8222A220h */ case    8:  		/* bc 12, CR6_EQ, 400 */
		/* 8222A220h case    8:*/		if ( regs.CR[6].eq ) { return 0x8222A3B0;  }
		/* 8222A220h case    8:*/		return 0x8222A224;
		  /* 8222A224h */ case    9:  		/* cmpwi CR6, R25, 3 */
		/* 8222A224h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000003);
		/* 8222A224h case    9:*/		return 0x8222A228;
		  /* 8222A228h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 8222A228h case   10:*/		if ( regs.CR[6].eq ) { return 0x8222A28C;  }
		/* 8222A228h case   10:*/		return 0x8222A22C;
		  /* 8222A22Ch */ case   11:  		/* cmpwi CR6, R25, 4 */
		/* 8222A22Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000004);
		/* 8222A22Ch case   11:*/		return 0x8222A230;
		  /* 8222A230h */ case   12:  		/* mr R4, R30 */
		/* 8222A230h case   12:*/		regs.R4 = regs.R30;
		/* 8222A230h case   12:*/		return 0x8222A234;
		  /* 8222A234h */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 8222A234h case   13:*/		if ( regs.CR[6].eq ) { return 0x8222A248;  }
		/* 8222A234h case   13:*/		return 0x8222A238;
		  /* 8222A238h */ case   14:  		/* bl -729656 */
		/* 8222A238h case   14:*/		regs.LR = 0x8222A23C; return 0x82178000;
		/* 8222A238h case   14:*/		return 0x8222A23C;
		  /* 8222A23Ch */ case   15:  		/* mr R6, R3 */
		/* 8222A23Ch case   15:*/		regs.R6 = regs.R3;
		/* 8222A23Ch case   15:*/		return 0x8222A240;
		  /* 8222A240h */ case   16:  		/* mr R5, R3 */
		/* 8222A240h case   16:*/		regs.R5 = regs.R3;
		/* 8222A240h case   16:*/		return 0x8222A244;
		  /* 8222A244h */ case   17:  		/* b 480 */
		/* 8222A244h case   17:*/		return 0x8222A424;
		/* 8222A244h case   17:*/		return 0x8222A248;
	}
	return 0x8222A248;
} // Block from 8222A200h-8222A248h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8222A248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A248);
		  /* 8222A248h */ case    0:  		/* bl -729672 */
		/* 8222A248h case    0:*/		regs.LR = 0x8222A24C; return 0x82178000;
		/* 8222A248h case    0:*/		return 0x8222A24C;
		  /* 8222A24Ch */ case    1:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A24Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A24Ch case    1:*/		return 0x8222A250;
		  /* 8222A250h */ case    2:  		/* mr R6, R3 */
		/* 8222A250h case    2:*/		regs.R6 = regs.R3;
		/* 8222A250h case    2:*/		return 0x8222A254;
		  /* 8222A254h */ case    3:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A254h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A254h case    3:*/		return 0x8222A258;
		  /* 8222A258h */ case    4:  		/* mr R5, R3 */
		/* 8222A258h case    4:*/		regs.R5 = regs.R3;
		/* 8222A258h case    4:*/		return 0x8222A25C;
		  /* 8222A25Ch */ case    5:  		/* addic R10, R10, -1 */
		/* 8222A25Ch case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A25Ch case    5:*/		return 0x8222A260;
		  /* 8222A260h */ case    6:  		/* mr R3, R31 */
		/* 8222A260h case    6:*/		regs.R3 = regs.R31;
		/* 8222A260h case    6:*/		return 0x8222A264;
		  /* 8222A264h */ case    7:  		/* subfe R10, R10, R10 */
		/* 8222A264h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A264h case    7:*/		return 0x8222A268;
		  /* 8222A268h */ case    8:  		/* and R4, R10, R11 */
		/* 8222A268h case    8:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8222A268h case    8:*/		return 0x8222A26C;
		  /* 8222A26Ch */ case    9:  		/* bl -472156 */
		/* 8222A26Ch case    9:*/		regs.LR = 0x8222A270; return 0x821B6E10;
		/* 8222A26Ch case    9:*/		return 0x8222A270;
		  /* 8222A270h */ case   10:  		/* lwz R11, <#[R3 + 12]> */
		/* 8222A270h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8222A270h case   10:*/		return 0x8222A274;
		  /* 8222A274h */ case   11:  		/* andi. R10, R11, 61166 */
		/* 8222A274h case   11:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xEEEE);
		/* 8222A274h case   11:*/		return 0x8222A278;
		  /* 8222A278h */ case   12:  		/* cmplwi CR6, R10, 61166 */
		/* 8222A278h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000EEEE);
		/* 8222A278h case   12:*/		return 0x8222A27C;
		  /* 8222A27Ch */ case   13:  		/* bc 12, CR6_EQ, 452 */
		/* 8222A27Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8222A440;  }
		/* 8222A27Ch case   13:*/		return 0x8222A280;
		  /* 8222A280h */ case   14:  		/* ori R11, R11, 61166 */
		/* 8222A280h case   14:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xEEEE);
		/* 8222A280h case   14:*/		return 0x8222A284;
		  /* 8222A284h */ case   15:  		/* sth R11, <#[R3 + 14]> */
		/* 8222A284h case   15:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x0000000E) );
		/* 8222A284h case   15:*/		return 0x8222A288;
		  /* 8222A288h */ case   16:  		/* b 440 */
		/* 8222A288h case   16:*/		return 0x8222A440;
		/* 8222A288h case   16:*/		return 0x8222A28C;
	}
	return 0x8222A28C;
} // Block from 8222A248h-8222A28Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8222A28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A28C);
		  /* 8222A28Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A28Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A28Ch case    0:*/		return 0x8222A290;
		  /* 8222A290h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A290h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A290h case    1:*/		return 0x8222A294;
		  /* 8222A294h */ case    2:  		/* addic R10, R10, -1 */
		/* 8222A294h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A294h case    2:*/		return 0x8222A298;
		  /* 8222A298h */ case    3:  		/* subfe R10, R10, R10 */
		/* 8222A298h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A298h case    3:*/		return 0x8222A29C;
		  /* 8222A29Ch */ case    4:  		/* and R4, R10, R11 */
		/* 8222A29Ch case    4:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8222A29Ch case    4:*/		return 0x8222A2A0;
		  /* 8222A2A0h */ case    5:  		/* bl -16808 */
		/* 8222A2A0h case    5:*/		regs.LR = 0x8222A2A4; return 0x822260F8;
		/* 8222A2A0h case    5:*/		return 0x8222A2A4;
		  /* 8222A2A4h */ case    6:  		/* lis R11, -32256 */
		/* 8222A2A4h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222A2A4h case    6:*/		return 0x8222A2A8;
		  /* 8222A2A8h */ case    7:  		/* mr R30, R3 */
		/* 8222A2A8h case    7:*/		regs.R30 = regs.R3;
		/* 8222A2A8h case    7:*/		return 0x8222A2AC;
		  /* 8222A2ACh */ case    8:  		/* li R5, 1 */
		/* 8222A2ACh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8222A2ACh case    8:*/		return 0x8222A2B0;
		  /* 8222A2B0h */ case    9:  		/* mr R4, R31 */
		/* 8222A2B0h case    9:*/		regs.R4 = regs.R31;
		/* 8222A2B0h case    9:*/		return 0x8222A2B4;
		  /* 8222A2B4h */ case   10:  		/* addi R3, R1, 80 */
		/* 8222A2B4h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8222A2B4h case   10:*/		return 0x8222A2B8;
		  /* 8222A2B8h */ case   11:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 8222A2B8h case   11:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 8222A2B8h case   11:*/		return 0x8222A2BC;
		  /* 8222A2BCh */ case   12:  		/* fmr FR4, FR31 */
		/* 8222A2BCh case   12:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8222A2BCh case   12:*/		return 0x8222A2C0;
		  /* 8222A2C0h */ case   13:  		/* fmr FR3, FR31 */
		/* 8222A2C0h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 8222A2C0h case   13:*/		return 0x8222A2C4;
		  /* 8222A2C4h */ case   14:  		/* fmr FR2, FR31 */
		/* 8222A2C4h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 8222A2C4h case   14:*/		return 0x8222A2C8;
		  /* 8222A2C8h */ case   15:  		/* fmr FR1, FR31 */
		/* 8222A2C8h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8222A2C8h case   15:*/		return 0x8222A2CC;
		  /* 8222A2CCh */ case   16:  		/* bl -13436 */
		/* 8222A2CCh case   16:*/		regs.LR = 0x8222A2D0; return 0x82226E50;
		/* 8222A2CCh case   16:*/		return 0x8222A2D0;
		  /* 8222A2D0h */ case   17:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A2D0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A2D0h case   17:*/		return 0x8222A2D4;
		  /* 8222A2D4h */ case   18:  		/* mr R5, R30 */
		/* 8222A2D4h case   18:*/		regs.R5 = regs.R30;
		/* 8222A2D4h case   18:*/		return 0x8222A2D8;
		  /* 8222A2D8h */ case   19:  		/* mr R3, R31 */
		/* 8222A2D8h case   19:*/		regs.R3 = regs.R31;
		/* 8222A2D8h case   19:*/		return 0x8222A2DC;
		  /* 8222A2DCh */ case   20:  		/* ld R6, <#[R1 + 80]> */
		/* 8222A2DCh case   20:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8222A2DCh case   20:*/		return 0x8222A2E0;
		  /* 8222A2E0h */ case   21:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A2E0h case   21:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A2E0h case   21:*/		return 0x8222A2E4;
		  /* 8222A2E4h */ case   22:  		/* addic R10, R10, -1 */
		/* 8222A2E4h case   22:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A2E4h case   22:*/		return 0x8222A2E8;
		  /* 8222A2E8h */ case   23:  		/* subfe R10, R10, R10 */
		/* 8222A2E8h case   23:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A2E8h case   23:*/		return 0x8222A2EC;
		  /* 8222A2ECh */ case   24:  		/* and R4, R10, R11 */
		/* 8222A2ECh case   24:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8222A2ECh case   24:*/		return 0x8222A2F0;
		  /* 8222A2F0h */ case   25:  		/* bl -15456 */
		/* 8222A2F0h case   25:*/		regs.LR = 0x8222A2F4; return 0x82226690;
		/* 8222A2F0h case   25:*/		return 0x8222A2F4;
		  /* 8222A2F4h */ case   26:  		/* lis R11, -32256 */
		/* 8222A2F4h case   26:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222A2F4h case   26:*/		return 0x8222A2F8;
		  /* 8222A2F8h */ case   27:  		/* mr R30, R3 */
		/* 8222A2F8h case   27:*/		regs.R30 = regs.R3;
		/* 8222A2F8h case   27:*/		return 0x8222A2FC;
		  /* 8222A2FCh */ case   28:  		/* fmr FR4, FR31 */
		/* 8222A2FCh case   28:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8222A2FCh case   28:*/		return 0x8222A300;
		  /* 8222A300h */ case   29:  		/* li R5, 1 */
		/* 8222A300h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8222A300h case   29:*/		return 0x8222A304;
		  /* 8222A304h */ case   30:  		/* fmr FR3, FR31 */
		/* 8222A304h case   30:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 8222A304h case   30:*/		return 0x8222A308;
		  /* 8222A308h */ case   31:  		/* mr R4, R31 */
		/* 8222A308h case   31:*/		regs.R4 = regs.R31;
		/* 8222A308h case   31:*/		return 0x8222A30C;
		  /* 8222A30Ch */ case   32:  		/* fmr FR2, FR31 */
		/* 8222A30Ch case   32:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 8222A30Ch case   32:*/		return 0x8222A310;
		  /* 8222A310h */ case   33:  		/* addi R3, R1, 80 */
		/* 8222A310h case   33:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8222A310h case   33:*/		return 0x8222A314;
		  /* 8222A314h */ case   34:  		/* lfs FR1, <#[R11 + 2752]> */
		/* 8222A314h case   34:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000AC0) );
		/* 8222A314h case   34:*/		return 0x8222A318;
		  /* 8222A318h */ case   35:  		/* bl -13512 */
		/* 8222A318h case   35:*/		regs.LR = 0x8222A31C; return 0x82226E50;
		/* 8222A318h case   35:*/		return 0x8222A31C;
		  /* 8222A31Ch */ case   36:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A31Ch case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A31Ch case   36:*/		return 0x8222A320;
		  /* 8222A320h */ case   37:  		/* mr R5, R30 */
		/* 8222A320h case   37:*/		regs.R5 = regs.R30;
		/* 8222A320h case   37:*/		return 0x8222A324;
		  /* 8222A324h */ case   38:  		/* ld R6, <#[R1 + 80]> */
		/* 8222A324h case   38:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8222A324h case   38:*/		return 0x8222A328;
		  /* 8222A328h */ case   39:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A328h case   39:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A328h case   39:*/		return 0x8222A32C;
		  /* 8222A32Ch */ case   40:  		/* mr R3, R31 */
		/* 8222A32Ch case   40:*/		regs.R3 = regs.R31;
		/* 8222A32Ch case   40:*/		return 0x8222A330;
		  /* 8222A330h */ case   41:  		/* addic R10, R10, -1 */
		/* 8222A330h case   41:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A330h case   41:*/		return 0x8222A334;
		  /* 8222A334h */ case   42:  		/* subfe R10, R10, R10 */
		/* 8222A334h case   42:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A334h case   42:*/		return 0x8222A338;
		  /* 8222A338h */ case   43:  		/* and R4, R10, R11 */
		/* 8222A338h case   43:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8222A338h case   43:*/		return 0x8222A33C;
		  /* 8222A33Ch */ case   44:  		/* bl -15732 */
		/* 8222A33Ch case   44:*/		regs.LR = 0x8222A340; return 0x822265C8;
		/* 8222A33Ch case   44:*/		return 0x8222A340;
		  /* 8222A340h */ case   45:  		/* lis R11, -32256 */
		/* 8222A340h case   45:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8222A340h case   45:*/		return 0x8222A344;
		  /* 8222A344h */ case   46:  		/* mr R30, R3 */
		/* 8222A344h case   46:*/		regs.R30 = regs.R3;
		/* 8222A344h case   46:*/		return 0x8222A348;
		  /* 8222A348h */ case   47:  		/* fmr FR4, FR31 */
		/* 8222A348h case   47:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 8222A348h case   47:*/		return 0x8222A34C;
		  /* 8222A34Ch */ case   48:  		/* li R5, 1 */
		/* 8222A34Ch case   48:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8222A34Ch case   48:*/		return 0x8222A350;
		  /* 8222A350h */ case   49:  		/* fmr FR3, FR31 */
		/* 8222A350h case   49:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 8222A350h case   49:*/		return 0x8222A354;
		  /* 8222A354h */ case   50:  		/* mr R4, R31 */
		/* 8222A354h case   50:*/		regs.R4 = regs.R31;
		/* 8222A354h case   50:*/		return 0x8222A358;
		  /* 8222A358h */ case   51:  		/* fmr FR2, FR31 */
		/* 8222A358h case   51:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 8222A358h case   51:*/		return 0x8222A35C;
		  /* 8222A35Ch */ case   52:  		/* addi R3, R1, 80 */
		/* 8222A35Ch case   52:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8222A35Ch case   52:*/		return 0x8222A360;
		  /* 8222A360h */ case   53:  		/* lfs FR1, <#[R11 + 1792]> */
		/* 8222A360h case   53:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000700) );
		/* 8222A360h case   53:*/		return 0x8222A364;
		  /* 8222A364h */ case   54:  		/* bl -13588 */
		/* 8222A364h case   54:*/		regs.LR = 0x8222A368; return 0x82226E50;
		/* 8222A364h case   54:*/		return 0x8222A368;
		  /* 8222A368h */ case   55:  		/* ld R11, <#[R1 + 80]> */
		/* 8222A368h case   55:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222A368h case   55:*/		return 0x8222A36C;
		  /* 8222A36Ch */ case   56:  		/* addi R4, R1, 88 */
		/* 8222A36Ch case   56:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 8222A36Ch case   56:*/		return 0x8222A370;
		  /* 8222A370h */ case   57:  		/* mr R3, R31 */
		/* 8222A370h case   57:*/		regs.R3 = regs.R31;
		/* 8222A370h case   57:*/		return 0x8222A374;
		  /* 8222A374h */ case   58:  		/* std R11, <#[R1 + 88]> */
		/* 8222A374h case   58:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8222A374h case   58:*/		return 0x8222A378;
		  /* 8222A378h */ case   59:  		/* bl -229368 */
		/* 8222A378h case   59:*/		regs.LR = 0x8222A37C; return 0x821F2380;
		/* 8222A378h case   59:*/		return 0x8222A37C;
		  /* 8222A37Ch */ case   60:  		/* li R4, 4 */
		/* 8222A37Ch case   60:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8222A37Ch case   60:*/		return 0x8222A380;
		  /* 8222A380h */ case   61:  		/* mr R29, R3 */
		/* 8222A380h case   61:*/		regs.R29 = regs.R3;
		/* 8222A380h case   61:*/		return 0x8222A384;
		  /* 8222A384h */ case   62:  		/* bl -731332 */
		/* 8222A384h case   62:*/		regs.LR = 0x8222A388; return 0x82177AC0;
		/* 8222A384h case   62:*/		return 0x8222A388;
		  /* 8222A388h */ case   63:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A388h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A388h case   63:*/		return 0x8222A38C;
		  /* 8222A38Ch */ case   64:  		/* mr R6, R29 */
		/* 8222A38Ch case   64:*/		regs.R6 = regs.R29;
		/* 8222A38Ch case   64:*/		return 0x8222A390;
		  /* 8222A390h */ case   65:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A390h case   65:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A390h case   65:*/		return 0x8222A394;
		  /* 8222A394h */ case   66:  		/* mr R5, R30 */
		/* 8222A394h case   66:*/		regs.R5 = regs.R30;
		/* 8222A394h case   66:*/		return 0x8222A398;
		  /* 8222A398h */ case   67:  		/* addic R10, R10, -1 */
		/* 8222A398h case   67:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A398h case   67:*/		return 0x8222A39C;
		  /* 8222A39Ch */ case   68:  		/* mr R3, R31 */
		/* 8222A39Ch case   68:*/		regs.R3 = regs.R31;
		/* 8222A39Ch case   68:*/		return 0x8222A3A0;
		  /* 8222A3A0h */ case   69:  		/* subfe R10, R10, R10 */
		/* 8222A3A0h case   69:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A3A0h case   69:*/		return 0x8222A3A4;
		  /* 8222A3A4h */ case   70:  		/* and R4, R10, R11 */
		/* 8222A3A4h case   70:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8222A3A4h case   70:*/		return 0x8222A3A8;
		  /* 8222A3A8h */ case   71:  		/* bl -16056 */
		/* 8222A3A8h case   71:*/		regs.LR = 0x8222A3AC; return 0x822264F0;
		/* 8222A3A8h case   71:*/		return 0x8222A3AC;
		  /* 8222A3ACh */ case   72:  		/* b 148 */
		/* 8222A3ACh case   72:*/		return 0x8222A440;
		/* 8222A3ACh case   72:*/		return 0x8222A3B0;
	}
	return 0x8222A3B0;
} // Block from 8222A28Ch-8222A3B0h (73 instructions)

//////////////////////////////////////////////////////
// Block at 8222A3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A3B0);
		  /* 8222A3B0h */ case    0:  		/* cmplwi CR6, R23, 2 */
		/* 8222A3B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000002);
		/* 8222A3B0h case    0:*/		return 0x8222A3B4;
		  /* 8222A3B4h */ case    1:  		/* bc 4, CR6_GT, 24 */
		/* 8222A3B4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8222A3CC;  }
		/* 8222A3B4h case    1:*/		return 0x8222A3B8;
		  /* 8222A3B8h */ case    2:  		/* lis R11, -32252 */
		/* 8222A3B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8222A3B8h case    2:*/		return 0x8222A3BC;
		  /* 8222A3BCh */ case    3:  		/* li R6, 2 */
		/* 8222A3BCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 8222A3BCh case    3:*/		return 0x8222A3C0;
		  /* 8222A3C0h */ case    4:  		/* addi R5, R11, -744 */
		/* 8222A3C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFD18);
		/* 8222A3C0h case    4:*/		return 0x8222A3C4;
		  /* 8222A3C4h */ case    5:  		/* li R4, 3634 */
		/* 8222A3C4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xE32);
		/* 8222A3C4h case    5:*/		return 0x8222A3C8;
		  /* 8222A3C8h */ case    6:  		/* bl -886112 */
		/* 8222A3C8h case    6:*/		regs.LR = 0x8222A3CC; return 0x82151E68;
		/* 8222A3C8h case    6:*/		return 0x8222A3CC;
	}
	return 0x8222A3CC;
} // Block from 8222A3B0h-8222A3CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222A3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A3CC);
		  /* 8222A3CCh */ case    0:  		/* mr R4, R30 */
		/* 8222A3CCh case    0:*/		regs.R4 = regs.R30;
		/* 8222A3CCh case    0:*/		return 0x8222A3D0;
		  /* 8222A3D0h */ case    1:  		/* bl -730064 */
		/* 8222A3D0h case    1:*/		regs.LR = 0x8222A3D4; return 0x82178000;
		/* 8222A3D0h case    1:*/		return 0x8222A3D4;
		  /* 8222A3D4h */ case    2:  		/* lwz R10, <#[R3]> */
		/* 8222A3D4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8222A3D4h case    2:*/		return 0x8222A3D8;
		  /* 8222A3D8h */ case    3:  		/* li R11, 1 */
		/* 8222A3D8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222A3D8h case    3:*/		return 0x8222A3DC;
		  /* 8222A3DCh */ case    4:  		/* li R4, 0 */
		/* 8222A3DCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8222A3DCh case    4:*/		return 0x8222A3E0;
		  /* 8222A3E0h */ case    5:  		/* rlwimi R10, R11, 26, 4, 6 */
		/* 8222A3E0h case    5:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R10,regs.R11);
		/* 8222A3E0h case    5:*/		return 0x8222A3E4;
		  /* 8222A3E4h */ case    6:  		/* mr R30, R3 */
		/* 8222A3E4h case    6:*/		regs.R30 = regs.R3;
		/* 8222A3E4h case    6:*/		return 0x8222A3E8;
		  /* 8222A3E8h */ case    7:  		/* stw R10, <#[R3]> */
		/* 8222A3E8h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8222A3E8h case    7:*/		return 0x8222A3EC;
		  /* 8222A3ECh */ case    8:  		/* bl -731436 */
		/* 8222A3ECh case    8:*/		regs.LR = 0x8222A3F0; return 0x82177AC0;
		/* 8222A3ECh case    8:*/		return 0x8222A3F0;
		  /* 8222A3F0h */ case    9:  		/* lwz R10, <#[R30]> */
		/* 8222A3F0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8222A3F0h case    9:*/		return 0x8222A3F4;
		  /* 8222A3F4h */ case   10:  		/* li R11, 119 */
		/* 8222A3F4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x77);
		/* 8222A3F4h case   10:*/		return 0x8222A3F8;
		  /* 8222A3F8h */ case   11:  		/* rlwimi R10, R11, 6, 19, 26 */
		/* 8222A3F8h case   11:*/		cpu::op::rlwimi<0,6,19,26>(regs,&regs.R10,regs.R11);
		/* 8222A3F8h case   11:*/		return 0x8222A3FC;
		  /* 8222A3FCh */ case   12:  		/* stw R10, <#[R30]> */
		/* 8222A3FCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8222A3FCh case   12:*/		return 0x8222A400;
		  /* 8222A400h */ case   13:  		/* b 16 */
		/* 8222A400h case   13:*/		return 0x8222A410;
		/* 8222A400h case   13:*/		return 0x8222A404;
	}
	return 0x8222A404;
} // Block from 8222A3CCh-8222A404h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8222A404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A404);
		  /* 8222A404h */ case    0:  		/* mr R4, R30 */
		/* 8222A404h case    0:*/		regs.R4 = regs.R30;
		/* 8222A404h case    0:*/		return 0x8222A408;
		  /* 8222A408h */ case    1:  		/* bl -730120 */
		/* 8222A408h case    1:*/		regs.LR = 0x8222A40C; return 0x82178000;
		/* 8222A408h case    1:*/		return 0x8222A40C;
		  /* 8222A40Ch */ case    2:  		/* mr R30, R3 */
		/* 8222A40Ch case    2:*/		regs.R30 = regs.R3;
		/* 8222A40Ch case    2:*/		return 0x8222A410;
	}
	return 0x8222A410;
} // Block from 8222A404h-8222A410h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222A410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A410);
		  /* 8222A410h */ case    0:  		/* li R4, 2 */
		/* 8222A410h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8222A410h case    0:*/		return 0x8222A414;
		  /* 8222A414h */ case    1:  		/* mr R3, R30 */
		/* 8222A414h case    1:*/		regs.R3 = regs.R30;
		/* 8222A414h case    1:*/		return 0x8222A418;
		  /* 8222A418h */ case    2:  		/* bl -731480 */
		/* 8222A418h case    2:*/		regs.LR = 0x8222A41C; return 0x82177AC0;
		/* 8222A418h case    2:*/		return 0x8222A41C;
		  /* 8222A41Ch */ case    3:  		/* mr R6, R30 */
		/* 8222A41Ch case    3:*/		regs.R6 = regs.R30;
		/* 8222A41Ch case    3:*/		return 0x8222A420;
		  /* 8222A420h */ case    4:  		/* mr R5, R30 */
		/* 8222A420h case    4:*/		regs.R5 = regs.R30;
		/* 8222A420h case    4:*/		return 0x8222A424;
	}
	return 0x8222A424;
} // Block from 8222A410h-8222A424h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222A424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A424);
		  /* 8222A424h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222A424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222A424h case    0:*/		return 0x8222A428;
		  /* 8222A428h */ case    1:  		/* mr R3, R31 */
		/* 8222A428h case    1:*/		regs.R3 = regs.R31;
		/* 8222A428h case    1:*/		return 0x8222A42C;
		  /* 8222A42Ch */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222A42Ch case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222A42Ch case    2:*/		return 0x8222A430;
		  /* 8222A430h */ case    3:  		/* addic R10, R10, -1 */
		/* 8222A430h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222A430h case    3:*/		return 0x8222A434;
		  /* 8222A434h */ case    4:  		/* subfe R10, R10, R10 */
		/* 8222A434h case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8222A434h case    4:*/		return 0x8222A438;
		  /* 8222A438h */ case    5:  		/* and R4, R10, R11 */
		/* 8222A438h case    5:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8222A438h case    5:*/		return 0x8222A43C;
		  /* 8222A43Ch */ case    6:  		/* bl -472620 */
		/* 8222A43Ch case    6:*/		regs.LR = 0x8222A440; return 0x821B6E10;
		/* 8222A43Ch case    6:*/		return 0x8222A440;
	}
	return 0x8222A440;
} // Block from 8222A424h-8222A440h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222A440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A440);
		  /* 8222A440h */ case    0:  		/* addi R1, R1, 192 */
		/* 8222A440h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8222A440h case    0:*/		return 0x8222A444;
		  /* 8222A444h */ case    1:  		/* lfd FR31, <#[R1 - 88]> */
		/* 8222A444h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 8222A444h case    1:*/		return 0x8222A448;
		  /* 8222A448h */ case    2:  		/* b -1675700 */
		/* 8222A448h case    2:*/		return 0x82091294;
		/* 8222A448h case    2:*/		return 0x8222A44C;
		  /* 8222A44Ch */ case    3:  		/* nop */
		/* 8222A44Ch case    3:*/		cpu::op::nop();
		/* 8222A44Ch case    3:*/		return 0x8222A450;
	}
	return 0x8222A450;
} // Block from 8222A440h-8222A450h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222A450h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A450);
		  /* 8222A450h */ case    0:  		/* mfspr R12, LR */
		/* 8222A450h case    0:*/		regs.R12 = regs.LR;
		/* 8222A450h case    0:*/		return 0x8222A454;
		  /* 8222A454h */ case    1:  		/* bl -1675796 */
		/* 8222A454h case    1:*/		regs.LR = 0x8222A458; return 0x82091240;
		/* 8222A454h case    1:*/		return 0x8222A458;
		  /* 8222A458h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8222A458h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8222A458h case    2:*/		return 0x8222A45C;
		  /* 8222A45Ch */ case    3:  		/* lwz R11, <#[R4 + 12]> */
		/* 8222A45Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8222A45Ch case    3:*/		return 0x8222A460;
		  /* 8222A460h */ case    4:  		/* mulli R22, R5, 40 */
		/* 8222A460h case    4:*/		cpu::op::mulli<0>(regs,&regs.R22,regs.R5,0x28);
		/* 8222A460h case    4:*/		return 0x8222A464;
		  /* 8222A464h */ case    5:  		/* add R30, R22, R11 */
		/* 8222A464h case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R22,regs.R11);
		/* 8222A464h case    5:*/		return 0x8222A468;
		  /* 8222A468h */ case    6:  		/* mr R24, R3 */
		/* 8222A468h case    6:*/		regs.R24 = regs.R3;
		/* 8222A468h case    6:*/		return 0x8222A46C;
		  /* 8222A46Ch */ case    7:  		/* mr R31, R4 */
		/* 8222A46Ch case    7:*/		regs.R31 = regs.R4;
		/* 8222A46Ch case    7:*/		return 0x8222A470;
		  /* 8222A470h */ case    8:  		/* mr R26, R5 */
		/* 8222A470h case    8:*/		regs.R26 = regs.R5;
		/* 8222A470h case    8:*/		return 0x8222A474;
		  /* 8222A474h */ case    9:  		/* mr R27, R6 */
		/* 8222A474h case    9:*/		regs.R27 = regs.R6;
		/* 8222A474h case    9:*/		return 0x8222A478;
		  /* 8222A478h */ case   10:  		/* lwz R11, <#[R30 + 24]> */
		/* 8222A478h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8222A478h case   10:*/		return 0x8222A47C;
		  /* 8222A47Ch */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8222A47Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222A47Ch case   11:*/		return 0x8222A480;
		  /* 8222A480h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 8222A480h case   12:*/		if ( regs.CR[6].eq ) { return 0x8222A4A8;  }
		/* 8222A480h case   12:*/		return 0x8222A484;
		  /* 8222A484h */ case   13:  		/* rlwinm R10, R6, 3, 0, 28 */
		/* 8222A484h case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R6);
		/* 8222A484h case   13:*/		return 0x8222A488;
		  /* 8222A488h */ case   14:  		/* add R9, R10, R11 */
		/* 8222A488h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8222A488h case   14:*/		return 0x8222A48C;
		  /* 8222A48Ch */ case   15:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8222A48Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8222A48Ch case   15:*/		return 0x8222A490;
		  /* 8222A490h */ case   16:  		/* lwz R10, <#[R9 + 4]> */
		/* 8222A490h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8222A490h case   16:*/		return 0x8222A494;
		  /* 8222A494h */ case   17:  		/* stw R11, <#[R3]> */
		/* 8222A494h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8222A494h case   17:*/		return 0x8222A498;
		  /* 8222A498h */ case   18:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8222A498h case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8222A498h case   18:*/		return 0x8222A49C;
		  /* 8222A49Ch */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 8222A49Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222A49Ch case   19:*/		return 0x8222A4A0;
		  /* 8222A4A0h */ case   20:  		/* stw R10, <#[R3 + 4]> */
		/* 8222A4A0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8222A4A0h case   20:*/		return 0x8222A4A4;
		  /* 8222A4A4h */ case   21:  		/* bc 4, CR6_EQ, 524 */
		/* 8222A4A4h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8222A6B0;  }
		/* 8222A4A4h case   21:*/		return 0x8222A4A8;
	}
	return 0x8222A4A8;
} // Block from 8222A450h-8222A4A8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8222A4A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A4A8);
		  /* 8222A4A8h */ case    0:  		/* addi R10, R1, 96 */
		/* 8222A4A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8222A4A8h case    0:*/		return 0x8222A4AC;
		  /* 8222A4ACh */ case    1:  		/* addi R9, R1, 104 */
		/* 8222A4ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x68);
		/* 8222A4ACh case    1:*/		return 0x8222A4B0;
		  /* 8222A4B0h */ case    2:  		/* addi R8, R1, 108 */
		/* 8222A4B0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x6C);
		/* 8222A4B0h case    2:*/		return 0x8222A4B4;
		  /* 8222A4B4h */ case    3:  		/* addi R7, R1, 100 */
		/* 8222A4B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x64);
		/* 8222A4B4h case    3:*/		return 0x8222A4B8;
		  /* 8222A4B8h */ case    4:  		/* addi R6, R1, 112 */
		/* 8222A4B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8222A4B8h case    4:*/		return 0x8222A4BC;
		  /* 8222A4BCh */ case    5:  		/* mr R5, R27 */
		/* 8222A4BCh case    5:*/		regs.R5 = regs.R27;
		/* 8222A4BCh case    5:*/		return 0x8222A4C0;
		  /* 8222A4C0h */ case    6:  		/* mr R4, R26 */
		/* 8222A4C0h case    6:*/		regs.R4 = regs.R26;
		/* 8222A4C0h case    6:*/		return 0x8222A4C4;
		  /* 8222A4C4h */ case    7:  		/* mr R3, R31 */
		/* 8222A4C4h case    7:*/		regs.R3 = regs.R31;
		/* 8222A4C4h case    7:*/		return 0x8222A4C8;
		  /* 8222A4C8h */ case    8:  		/* bl -37856 */
		/* 8222A4C8h case    8:*/		regs.LR = 0x8222A4CC; return 0x822210E8;
		/* 8222A4C8h case    8:*/		return 0x8222A4CC;
		  /* 8222A4CCh */ case    9:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222A4CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222A4CCh case    9:*/		return 0x8222A4D0;
		  /* 8222A4D0h */ case   10:  		/* rlwinm R23, R27, 3, 0, 28 */
		/* 8222A4D0h case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R23,regs.R27);
		/* 8222A4D0h case   10:*/		return 0x8222A4D4;
		  /* 8222A4D4h */ case   11:  		/* lwz R8, <#[R30 + 16]> */
		/* 8222A4D4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 8222A4D4h case   11:*/		return 0x8222A4D8;
		  /* 8222A4D8h */ case   12:  		/* li R10, 2 */
		/* 8222A4D8h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8222A4D8h case   12:*/		return 0x8222A4DC;
		  /* 8222A4DCh */ case   13:  		/* lwz R4, <#[R30 + 20]> */
		/* 8222A4DCh case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000014) );
		/* 8222A4DCh case   13:*/		return 0x8222A4E0;
		  /* 8222A4E0h */ case   14:  		/* li R9, -1 */
		/* 8222A4E0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8222A4E0h case   14:*/		return 0x8222A4E4;
		  /* 8222A4E4h */ case   15:  		/* li R6, 0 */
		/* 8222A4E4h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8222A4E4h case   15:*/		return 0x8222A4E8;
		  /* 8222A4E8h */ case   16:  		/* mr R3, R31 */
		/* 8222A4E8h case   16:*/		regs.R3 = regs.R31;
		/* 8222A4E8h case   16:*/		return 0x8222A4EC;
		  /* 8222A4ECh */ case   17:  		/* lwz R5, <#[R8 + 60]> */
		/* 8222A4ECh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x0000003C) );
		/* 8222A4ECh case   17:*/		return 0x8222A4F0;
		  /* 8222A4F0h */ case   18:  		/* lwzx R11, <#[R23 + R11]> */
		/* 8222A4F0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R11 + 0x00000000) );
		/* 8222A4F0h case   18:*/		return 0x8222A4F4;
		  /* 8222A4F4h */ case   19:  		/* rlwinm R11, R11, 14, 30, 31 */
		/* 8222A4F4h case   19:*/		cpu::op::rlwinm<0,14,30,31>(regs,&regs.R11,regs.R11);
		/* 8222A4F4h case   19:*/		return 0x8222A4F8;
		  /* 8222A4F8h */ case   20:  		/* addi R8, R11, -2 */
		/* 8222A4F8h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFE);
		/* 8222A4F8h case   20:*/		return 0x8222A4FC;
		  /* 8222A4FCh */ case   21:  		/* subfc R11, R10, R11 */
		/* 8222A4FCh case   21:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8222A4FCh case   21:*/		return 0x8222A500;
		  /* 8222A500h */ case   22:  		/* cntlzw R10, R8 */
		/* 8222A500h case   22:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R8);
		/* 8222A500h case   22:*/		return 0x8222A504;
		  /* 8222A504h */ case   23:  		/* subfze R28, R9 */
		/* 8222A504h case   23:*/		cpu::op::subfze<0>(regs,&regs.R28,regs.R9);
		/* 8222A504h case   23:*/		return 0x8222A508;
		  /* 8222A508h */ case   24:  		/* rlwinm R25, R10, 27, 31, 31 */
		/* 8222A508h case   24:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R25,regs.R10);
		/* 8222A508h case   24:*/		return 0x8222A50C;
		  /* 8222A50Ch */ case   25:  		/* bl -642460 */
		/* 8222A50Ch case   25:*/		regs.LR = 0x8222A510; return 0x8218D770;
		/* 8222A50Ch case   25:*/		return 0x8222A510;
		  /* 8222A510h */ case   26:  		/* mr R4, R27 */
		/* 8222A510h case   26:*/		regs.R4 = regs.R27;
		/* 8222A510h case   26:*/		return 0x8222A514;
		  /* 8222A514h */ case   27:  		/* mr R29, R3 */
		/* 8222A514h case   27:*/		regs.R29 = regs.R3;
		/* 8222A514h case   27:*/		return 0x8222A518;
		  /* 8222A518h */ case   28:  		/* bl -38680 */
		/* 8222A518h case   28:*/		regs.LR = 0x8222A51C; return 0x82220E00;
		/* 8222A518h case   28:*/		return 0x8222A51C;
		  /* 8222A51Ch */ case   29:  		/* mr R3, R29 */
		/* 8222A51Ch case   29:*/		regs.R3 = regs.R29;
		/* 8222A51Ch case   29:*/		return 0x8222A520;
		  /* 8222A520h */ case   30:  		/* bl -209184 */
		/* 8222A520h case   30:*/		regs.LR = 0x8222A524; return 0x821F7400;
		/* 8222A520h case   30:*/		return 0x8222A524;
		  /* 8222A524h */ case   31:  		/* lwz R5, <#[R29 + 8]> */
		/* 8222A524h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x00000008) );
		/* 8222A524h case   31:*/		return 0x8222A528;
		  /* 8222A528h */ case   32:  		/* mr R3, R31 */
		/* 8222A528h case   32:*/		regs.R3 = regs.R31;
		/* 8222A528h case   32:*/		return 0x8222A52C;
		  /* 8222A52Ch */ case   33:  		/* cmpwi CR6, R5, 0 */
		/* 8222A52Ch case   33:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8222A52Ch case   33:*/		return 0x8222A530;
		  /* 8222A530h */ case   34:  		/* bc 4, CR6_EQ, 44 */
		/* 8222A530h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8222A55C;  }
		/* 8222A530h case   34:*/		return 0x8222A534;
		  /* 8222A534h */ case   35:  		/* mr R4, R26 */
		/* 8222A534h case   35:*/		regs.R4 = regs.R26;
		/* 8222A534h case   35:*/		return 0x8222A538;
		  /* 8222A538h */ case   36:  		/* bl -252664 */
		/* 8222A538h case   36:*/		regs.LR = 0x8222A53C; return 0x821ECA40;
		/* 8222A538h case   36:*/		return 0x8222A53C;
		  /* 8222A53Ch */ case   37:  		/* mr R30, R3 */
		/* 8222A53Ch case   37:*/		regs.R30 = regs.R3;
		/* 8222A53Ch case   37:*/		return 0x8222A540;
		  /* 8222A540h */ case   38:  		/* mr R3, R31 */
		/* 8222A540h case   38:*/		regs.R3 = regs.R31;
		/* 8222A540h case   38:*/		return 0x8222A544;
		  /* 8222A544h */ case   39:  		/* bl -256460 */
		/* 8222A544h case   39:*/		regs.LR = 0x8222A548; return 0x821EBB78;
		/* 8222A544h case   39:*/		return 0x8222A548;
		  /* 8222A548h */ case   40:  		/* mr R5, R3 */
		/* 8222A548h case   40:*/		regs.R5 = regs.R3;
		/* 8222A548h case   40:*/		return 0x8222A54C;
		  /* 8222A54Ch */ case   41:  		/* li R4, 3502 */
		/* 8222A54Ch case   41:*/		cpu::op::li<0>(regs,&regs.R4,0xDAE);
		/* 8222A54Ch case   41:*/		return 0x8222A550;
		  /* 8222A550h */ case   42:  		/* mr R3, R31 */
		/* 8222A550h case   42:*/		regs.R3 = regs.R31;
		/* 8222A550h case   42:*/		return 0x8222A554;
		  /* 8222A554h */ case   43:  		/* mr R6, R30 */
		/* 8222A554h case   43:*/		regs.R6 = regs.R30;
		/* 8222A554h case   43:*/		return 0x8222A558;
		  /* 8222A558h */ case   44:  		/* bl -886512 */
		/* 8222A558h case   44:*/		regs.LR = 0x8222A55C; return 0x82151E68;
		/* 8222A558h case   44:*/		return 0x8222A55C;
	}
	return 0x8222A55C;
} // Block from 8222A4A8h-8222A55Ch (45 instructions)

//////////////////////////////////////////////////////
// Block at 8222A55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A55C);
		  /* 8222A55Ch */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222A55Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222A55Ch case    0:*/		return 0x8222A560;
		  /* 8222A560h */ case    1:  		/* lwzx R7, <#[R23 + R11]> */
		/* 8222A560h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R23 + regs.R11 + 0x00000000) );
		/* 8222A560h case    1:*/		return 0x8222A564;
		  /* 8222A564h */ case    2:  		/* rlwinm. R11, R7, 0, 5, 5 */
		/* 8222A564h case    2:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R7);
		/* 8222A564h case    2:*/		return 0x8222A568;
		  /* 8222A568h */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 8222A568h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8222A584;  }
		/* 8222A568h case    3:*/		return 0x8222A56C;
		  /* 8222A56Ch */ case    4:  		/* mr R4, R5 */
		/* 8222A56Ch case    4:*/		regs.R4 = regs.R5;
		/* 8222A56Ch case    4:*/		return 0x8222A570;
		  /* 8222A570h */ case    5:  		/* bl -255320 */
		/* 8222A570h case    5:*/		regs.LR = 0x8222A574; return 0x821EC018;
		/* 8222A570h case    5:*/		return 0x8222A574;
		  /* 8222A574h */ case    6:  		/* lwz R5, <#[R3 + 24]> */
		/* 8222A574h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 8222A574h case    6:*/		return 0x8222A578;
		  /* 8222A578h */ case    7:  		/* li R4, 4502 */
		/* 8222A578h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1196);
		/* 8222A578h case    7:*/		return 0x8222A57C;
		  /* 8222A57Ch */ case    8:  		/* mr R3, R31 */
		/* 8222A57Ch case    8:*/		regs.R3 = regs.R31;
		/* 8222A57Ch case    8:*/		return 0x8222A580;
		  /* 8222A580h */ case    9:  		/* bl -886552 */
		/* 8222A580h case    9:*/		regs.LR = 0x8222A584; return 0x82151E68;
		/* 8222A580h case    9:*/		return 0x8222A584;
	}
	return 0x8222A584;
} // Block from 8222A55Ch-8222A584h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222A584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A584);
		  /* 8222A584h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 8222A584h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8222A584h case    0:*/		return 0x8222A588;
		  /* 8222A588h */ case    1:  		/* lis R10, -1 */
		/* 8222A588h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8222A588h case    1:*/		return 0x8222A58C;
		  /* 8222A58Ch */ case    2:  		/* lwz R4, <#[R30 + 16]> */
		/* 8222A58Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 8222A58Ch case    2:*/		return 0x8222A590;
		  /* 8222A590h */ case    3:  		/* rlwinm R7, R7, 5, 28, 31 */
		/* 8222A590h case    3:*/		cpu::op::rlwinm<0,5,28,31>(regs,&regs.R7,regs.R7);
		/* 8222A590h case    3:*/		return 0x8222A594;
		  /* 8222A594h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8222A594h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8222A594h case    4:*/		return 0x8222A598;
		  /* 8222A598h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 8222A598h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8222A598h case    5:*/		return 0x8222A59C;
		  /* 8222A59Ch */ case    6:  		/* li R11, 0 */
		/* 8222A59Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222A59Ch case    6:*/		return 0x8222A5A0;
		  /* 8222A5A0h */ case    7:  		/* stw R11, <#[R1 + 120]> */
		/* 8222A5A0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8222A5A0h case    7:*/		return 0x8222A5A4;
		  /* 8222A5A4h */ case    8:  		/* bc 12, CR6_EQ, 280 */
		/* 8222A5A4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8222A6BC;  }
		/* 8222A5A4h case    8:*/		return 0x8222A5A8;
		  /* 8222A5A8h */ case    9:  		/* addi R9, R1, 124 */
		/* 8222A5A8h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x7C);
		/* 8222A5A8h case    9:*/		return 0x8222A5AC;
		  /* 8222A5ACh */ case   10:  		/* stw R11, <#[R1 + 92]> */
		/* 8222A5ACh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8222A5ACh case   10:*/		return 0x8222A5B0;
		  /* 8222A5B0h */ case   11:  		/* lis R10, -32216 */
		/* 8222A5B0h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8222A5B0h case   11:*/		return 0x8222A5B4;
		  /* 8222A5B4h */ case   12:  		/* addi R6, R1, 100 */
		/* 8222A5B4h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 8222A5B4h case   12:*/		return 0x8222A5B8;
		  /* 8222A5B8h */ case   13:  		/* addi R8, R10, 10568 */
		/* 8222A5B8h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x2948);
		/* 8222A5B8h case   13:*/		return 0x8222A5BC;
		  /* 8222A5BCh */ case   14:  		/* stw R6, <#[R1 + 84]> */
		/* 8222A5BCh case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8222A5BCh case   14:*/		return 0x8222A5C0;
		  /* 8222A5C0h */ case   15:  		/* addi R10, R1, 120 */
		/* 8222A5C0h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x78);
		/* 8222A5C0h case   15:*/		return 0x8222A5C4;
		  /* 8222A5C4h */ case   16:  		/* stw R11, <#[R9]> */
		/* 8222A5C4h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8222A5C4h case   16:*/		return 0x8222A5C8;
		  /* 8222A5C8h */ case   17:  		/* li R6, 0 */
		/* 8222A5C8h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8222A5C8h case   17:*/		return 0x8222A5CC;
		  /* 8222A5CCh */ case   18:  		/* stw R11, <#[R9 + 4]> */
		/* 8222A5CCh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8222A5CCh case   18:*/		return 0x8222A5D0;
		  /* 8222A5D0h */ case   19:  		/* li R9, 21 */
		/* 8222A5D0h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x15);
		/* 8222A5D0h case   19:*/		return 0x8222A5D4;
		  /* 8222A5D4h */ case   20:  		/* bl -26884 */
		/* 8222A5D4h case   20:*/		regs.LR = 0x8222A5D8; return 0x82223CD0;
		/* 8222A5D4h case   20:*/		return 0x8222A5D8;
	}
	return 0x8222A5D8;
} // Block from 8222A584h-8222A5D8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8222A5D8h
// Function '?WillBePlacedAfter@Compiler@D3DXShader@@QAA_NPAVInstruction@2@UInstructionPlacementPoint@12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A5D8);
		  /* 8222A5D8h */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 8222A5D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 8222A5D8h case    0:*/		return 0x8222A5DC;
		  /* 8222A5DCh */ case    1:  		/* mr R3, R31 */
		/* 8222A5DCh case    1:*/		regs.R3 = regs.R31;
		/* 8222A5DCh case    1:*/		return 0x8222A5E0;
		  /* 8222A5E0h */ case    2:  		/* lwz R6, <#[R1 + 96]> */
		/* 8222A5E0h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 8222A5E0h case    2:*/		return 0x8222A5E4;
		  /* 8222A5E4h */ case    3:  		/* rldicr R5, R11, 32, 63 */
		/* 8222A5E4h case    3:*/		cpu::op::rldicr<0,32,63>(regs,&regs.R5,regs.R11);
		/* 8222A5E4h case    3:*/		return 0x8222A5E8;
		  /* 8222A5E8h */ case    4:  		/* ld R4, <#[R1 + 120]> */
		/* 8222A5E8h case    4:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R1 + 0x00000078) );
		/* 8222A5E8h case    4:*/		return 0x8222A5EC;
		  /* 8222A5ECh */ case    5:  		/* bl -22044 */
		/* 8222A5ECh case    5:*/		regs.LR = 0x8222A5F0; return 0x82224FD0;
		/* 8222A5ECh case    5:*/		return 0x8222A5F0;
		  /* 8222A5F0h */ case    6:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 8222A5F0h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 8222A5F0h case    6:*/		return 0x8222A5F4;
		  /* 8222A5F4h */ case    7:  		/* mr R28, R3 */
		/* 8222A5F4h case    7:*/		regs.R28 = regs.R3;
		/* 8222A5F4h case    7:*/		return 0x8222A5F8;
		  /* 8222A5F8h */ case    8:  		/* bc 12, CR0_EQ, 56 */
		/* 8222A5F8h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222A630;  }
		/* 8222A5F8h case    8:*/		return 0x8222A5FC;
		  /* 8222A5FCh */ case    9:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 8222A5FCh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 8222A5FCh case    9:*/		return 0x8222A600;
		  /* 8222A600h */ case   10:  		/* lwz R11, <#[R3 + 12]> */
		/* 8222A600h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8222A600h case   10:*/		return 0x8222A604;
		  /* 8222A604h */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 8222A604h case   11:*/		if ( regs.CR[0].eq ) { return 0x8222A61C;  }
		/* 8222A604h case   11:*/		return 0x8222A608;
		  /* 8222A608h */ case   12:  		/* andi. R10, R11, 17476 */
		/* 8222A608h case   12:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x4444);
		/* 8222A608h case   12:*/		return 0x8222A60C;
		  /* 8222A60Ch */ case   13:  		/* cmplwi CR6, R10, 17476 */
		/* 8222A60Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00004444);
		/* 8222A60Ch case   13:*/		return 0x8222A610;
		  /* 8222A610h */ case   14:  		/* bc 12, CR6_EQ, 32 */
		/* 8222A610h case   14:*/		if ( regs.CR[6].eq ) { return 0x8222A630;  }
		/* 8222A610h case   14:*/		return 0x8222A614;
		  /* 8222A614h */ case   15:  		/* ori R11, R11, 17476 */
		/* 8222A614h case   15:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4444);
		/* 8222A614h case   15:*/		return 0x8222A618;
		  /* 8222A618h */ case   16:  		/* b 20 */
		/* 8222A618h case   16:*/		return 0x8222A62C;
		/* 8222A618h case   16:*/		return 0x8222A61C;
	}
	return 0x8222A61C;
} // Block from 8222A5D8h-8222A61Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8222A61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A61C);
		  /* 8222A61Ch */ case    0:  		/* andi. R10, R11, 26214 */
		/* 8222A61Ch case    0:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x6666);
		/* 8222A61Ch case    0:*/		return 0x8222A620;
		  /* 8222A620h */ case    1:  		/* cmplwi CR6, R10, 26214 */
		/* 8222A620h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00006666);
		/* 8222A620h case    1:*/		return 0x8222A624;
		  /* 8222A624h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8222A624h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222A630;  }
		/* 8222A624h case    2:*/		return 0x8222A628;
		  /* 8222A628h */ case    3:  		/* ori R11, R11, 26214 */
		/* 8222A628h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x6666);
		/* 8222A628h case    3:*/		return 0x8222A62C;
	}
	return 0x8222A62C;
} // Block from 8222A61Ch-8222A62Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222A62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A62C);
		  /* 8222A62Ch */ case    0:  		/* sth R11, <#[R28 + 14]> */
		/* 8222A62Ch case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R28 + 0x0000000E) );
		/* 8222A62Ch case    0:*/		return 0x8222A630;
	}
	return 0x8222A630;
} // Block from 8222A62Ch-8222A630h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222A630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A630);
		  /* 8222A630h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8222A630h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222A630h case    0:*/		return 0x8222A634;
		  /* 8222A634h */ case    1:  		/* add R11, R22, R11 */
		/* 8222A634h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R22,regs.R11);
		/* 8222A634h case    1:*/		return 0x8222A638;
		  /* 8222A638h */ case    2:  		/* lwz R10, <#[R11 + 24]> */
		/* 8222A638h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 8222A638h case    2:*/		return 0x8222A63C;
		  /* 8222A63Ch */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 8222A63Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222A63Ch case    3:*/		return 0x8222A640;
		  /* 8222A640h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 8222A640h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8222A664;  }
		/* 8222A640h case    4:*/		return 0x8222A644;
		  /* 8222A644h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 8222A644h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8222A644h case    5:*/		return 0x8222A648;
		  /* 8222A648h */ case    6:  		/* li R5, 0 */
		/* 8222A648h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222A648h case    6:*/		return 0x8222A64C;
		  /* 8222A64Ch */ case    7:  		/* mr R3, R31 */
		/* 8222A64Ch case    7:*/		regs.R3 = regs.R31;
		/* 8222A64Ch case    7:*/		return 0x8222A650;
		  /* 8222A650h */ case    8:  		/* rlwinm R4, R11, 0, 15, 28 */
		/* 8222A650h case    8:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R4,regs.R11);
		/* 8222A650h case    8:*/		return 0x8222A654;
		  /* 8222A654h */ case    9:  		/* bl -647212 */
		/* 8222A654h case    9:*/		regs.LR = 0x8222A658; return 0x8218C628;
		/* 8222A654h case    9:*/		return 0x8222A658;
		  /* 8222A658h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 8222A658h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222A658h case   10:*/		return 0x8222A65C;
		  /* 8222A65Ch */ case   11:  		/* add R11, R22, R11 */
		/* 8222A65Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R22,regs.R11);
		/* 8222A65Ch case   11:*/		return 0x8222A660;
		  /* 8222A660h */ case   12:  		/* stw R3, <#[R11 + 24]> */
		/* 8222A660h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 8222A660h case   12:*/		return 0x8222A664;
	}
	return 0x8222A664;
} // Block from 8222A630h-8222A664h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222A664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A664);
		  /* 8222A664h */ case    0:  		/* mr R8, R28 */
		/* 8222A664h case    0:*/		regs.R8 = regs.R28;
		/* 8222A664h case    0:*/		return 0x8222A668;
		  /* 8222A668h */ case    1:  		/* lwz R7, <#[R1 + 104]> */
		/* 8222A668h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000068) );
		/* 8222A668h case    1:*/		return 0x8222A66C;
		  /* 8222A66Ch */ case    2:  		/* mr R4, R30 */
		/* 8222A66Ch case    2:*/		regs.R4 = regs.R30;
		/* 8222A66Ch case    2:*/		return 0x8222A670;
		  /* 8222A670h */ case    3:  		/* lwz R6, <#[R1 + 108]> */
		/* 8222A670h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000006C) );
		/* 8222A670h case    3:*/		return 0x8222A674;
		  /* 8222A674h */ case    4:  		/* mr R3, R31 */
		/* 8222A674h case    4:*/		regs.R3 = regs.R31;
		/* 8222A674h case    4:*/		return 0x8222A678;
		  /* 8222A678h */ case    5:  		/* lwz R5, <#[R1 + 112]> */
		/* 8222A678h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000070) );
		/* 8222A678h case    5:*/		return 0x8222A67C;
		  /* 8222A67Ch */ case    6:  		/* bl -37972 */
		/* 8222A67Ch case    6:*/		regs.LR = 0x8222A680; return 0x82221228;
		/* 8222A67Ch case    6:*/		return 0x8222A680;
		  /* 8222A680h */ case    7:  		/* addi R11, R31, 972 */
		/* 8222A680h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3CC);
		/* 8222A680h case    7:*/		return 0x8222A684;
		  /* 8222A684h */ case    8:  		/* lwz R10, <#[R31 + 1008]> */
		/* 8222A684h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000003F0) );
		/* 8222A684h case    8:*/		return 0x8222A688;
		  /* 8222A688h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 8222A688h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222A688h case    9:*/		return 0x8222A68C;
		  /* 8222A68Ch */ case   10:  		/* add R11, R22, R11 */
		/* 8222A68Ch case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R22,regs.R11);
		/* 8222A68Ch case   10:*/		return 0x8222A690;
	}
	return 0x8222A690;
} // Block from 8222A664h-8222A690h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8222A690h
// Function '?InsertNewCopy@Compiler@D3DXShader@@QAAXPAVBlock@2@UInstructionPlacementPoint@12@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A690);
		  /* 8222A690h */ case    0:  		/* lwz R11, <#[R11 + 24]> */
		/* 8222A690h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8222A690h case    0:*/		return 0x8222A694;
		  /* 8222A694h */ case    1:  		/* add R9, R11, R23 */
		/* 8222A694h case    1:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R23);
		/* 8222A694h case    1:*/		return 0x8222A698;
		  /* 8222A698h */ case    2:  		/* lwzx R11, <#[R11 + R23]> */
		/* 8222A698h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 8222A698h case    2:*/		return 0x8222A69C;
		  /* 8222A69Ch */ case    3:  		/* lwz R9, <#[R9 + 4]> */
		/* 8222A69Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8222A69Ch case    3:*/		return 0x8222A6A0;
		  /* 8222A6A0h */ case    4:  		/* stw R10, <#[R29]> */
		/* 8222A6A0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8222A6A0h case    4:*/		return 0x8222A6A4;
		  /* 8222A6A4h */ case    5:  		/* stw R29, <#[R31 + 1008]> */
		/* 8222A6A4h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000003F0) );
		/* 8222A6A4h case    5:*/		return 0x8222A6A8;
		  /* 8222A6A8h */ case    6:  		/* stw R11, <#[R24]> */
		/* 8222A6A8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8222A6A8h case    6:*/		return 0x8222A6AC;
		  /* 8222A6ACh */ case    7:  		/* stw R9, <#[R24 + 4]> */
		/* 8222A6ACh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R24 + 0x00000004) );
		/* 8222A6ACh case    7:*/		return 0x8222A6B0;
	}
	return 0x8222A6B0;
} // Block from 8222A690h-8222A6B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222A6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A6B0);
		  /* 8222A6B0h */ case    0:  		/* mr R3, R24 */
		/* 8222A6B0h case    0:*/		regs.R3 = regs.R24;
		/* 8222A6B0h case    0:*/		return 0x8222A6B4;
		  /* 8222A6B4h */ case    1:  		/* addi R1, R1, 224 */
		/* 8222A6B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8222A6B4h case    1:*/		return 0x8222A6B8;
		  /* 8222A6B8h */ case    2:  		/* b -1676328 */
		/* 8222A6B8h case    2:*/		return 0x82091290;
		/* 8222A6B8h case    2:*/		return 0x8222A6BC;
	}
	return 0x8222A6BC;
} // Block from 8222A6B0h-8222A6BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222A6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A6BC);
		  /* 8222A6BCh */ case    0:  		/* addi R10, R1, 124 */
		/* 8222A6BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x7C);
		/* 8222A6BCh case    0:*/		return 0x8222A6C0;
		  /* 8222A6C0h */ case    1:  		/* lwz R6, <#[R29 + 24]> */
		/* 8222A6C0h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000018) );
		/* 8222A6C0h case    1:*/		return 0x8222A6C4;
		  /* 8222A6C4h */ case    2:  		/* addi R9, R1, 100 */
		/* 8222A6C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 8222A6C4h case    2:*/		return 0x8222A6C8;
		  /* 8222A6C8h */ case    3:  		/* addi R8, R1, 120 */
		/* 8222A6C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x78);
		/* 8222A6C8h case    3:*/		return 0x8222A6CC;
		  /* 8222A6CCh */ case    4:  		/* stw R11, <#[R10]> */
		/* 8222A6CCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8222A6CCh case    4:*/		return 0x8222A6D0;
		  /* 8222A6D0h */ case    5:  		/* stw R11, <#[R10 + 4]> */
		/* 8222A6D0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8222A6D0h case    5:*/		return 0x8222A6D4;
		  /* 8222A6D4h */ case    6:  		/* bl -26748 */
		/* 8222A6D4h case    6:*/		regs.LR = 0x8222A6D8; return 0x82223E58;
		/* 8222A6D4h case    6:*/		return 0x8222A6D8;
		  /* 8222A6D8h */ case    7:  		/* lwz R11, <#[R1 + 124]> */
		/* 8222A6D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 8222A6D8h case    7:*/		return 0x8222A6DC;
		  /* 8222A6DCh */ case    8:  		/* lwz R10, <#[R30 + 4]> */
		/* 8222A6DCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8222A6DCh case    8:*/		return 0x8222A6E0;
		  /* 8222A6E0h */ case    9:  		/* mr R9, R25 */
		/* 8222A6E0h case    9:*/		regs.R9 = regs.R25;
		/* 8222A6E0h case    9:*/		return 0x8222A6E4;
		  /* 8222A6E4h */ case   10:  		/* mr R8, R28 */
		/* 8222A6E4h case   10:*/		regs.R8 = regs.R28;
		/* 8222A6E4h case   10:*/		return 0x8222A6E8;
		  /* 8222A6E8h */ case   11:  		/* lwz R7, <#[R1 + 100]> */
		/* 8222A6E8h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000064) );
		/* 8222A6E8h case   11:*/		return 0x8222A6EC;
		  /* 8222A6ECh */ case   12:  		/* rlwimi R11, R10, 20, 14, 14 */
		/* 8222A6ECh case   12:*/		cpu::op::rlwimi<0,20,14,14>(regs,&regs.R11,regs.R10);
		/* 8222A6ECh case   12:*/		return 0x8222A6F0;
		  /* 8222A6F0h */ case   13:  		/* lwz R6, <#[R1 + 96]> */
		/* 8222A6F0h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 8222A6F0h case   13:*/		return 0x8222A6F4;
		  /* 8222A6F4h */ case   14:  		/* mr R3, R31 */
		/* 8222A6F4h case   14:*/		regs.R3 = regs.R31;
		/* 8222A6F4h case   14:*/		return 0x8222A6F8;
		  /* 8222A6F8h */ case   15:  		/* stw R11, <#[R1 + 124]> */
		/* 8222A6F8h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 8222A6F8h case   15:*/		return 0x8222A6FC;
		  /* 8222A6FCh */ case   16:  		/* lwz R26, <#[R1 + 128]> */
		/* 8222A6FCh case   16:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 8222A6FCh case   16:*/		return 0x8222A700;
		  /* 8222A700h */ case   17:  		/* ld R25, <#[R1 + 120]> */
		/* 8222A700h case   17:*/		cpu::mem::load64( regs, &regs.R25, (uint32)(regs.R1 + 0x00000078) );
		/* 8222A700h case   17:*/		return 0x8222A704;
		  /* 8222A704h */ case   18:  		/* mr R4, R25 */
		/* 8222A704h case   18:*/		regs.R4 = regs.R25;
		/* 8222A704h case   18:*/		return 0x8222A708;
		  /* 8222A708h */ case   19:  		/* rldicr R5, R26, 32, 63 */
		/* 8222A708h case   19:*/		cpu::op::rldicr<0,32,63>(regs,&regs.R5,regs.R26);
		/* 8222A708h case   19:*/		return 0x8222A70C;
		  /* 8222A70Ch */ case   20:  		/* bl -1828 */
		/* 8222A70Ch case   20:*/		regs.LR = 0x8222A710; return 0x82229FE8;
		/* 8222A70Ch case   20:*/		return 0x8222A710;
		  /* 8222A710h */ case   21:  		/* or. R28, R3, R3 */
		/* 8222A710h case   21:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 8222A710h case   21:*/		return 0x8222A714;
		  /* 8222A714h */ case   22:  		/* bc 4, CR0_EQ, -228 */
		/* 8222A714h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8222A630;  }
		/* 8222A714h case   22:*/		return 0x8222A718;
		  /* 8222A718h */ case   23:  		/* mr R8, R27 */
		/* 8222A718h case   23:*/		regs.R8 = regs.R27;
		/* 8222A718h case   23:*/		return 0x8222A71C;
		  /* 8222A71Ch */ case   24:  		/* mr R7, R30 */
		/* 8222A71Ch case   24:*/		regs.R7 = regs.R30;
		/* 8222A71Ch case   24:*/		return 0x8222A720;
		  /* 8222A720h */ case   25:  		/* mr R6, R29 */
		/* 8222A720h case   25:*/		regs.R6 = regs.R29;
		/* 8222A720h case   25:*/		return 0x8222A724;
		  /* 8222A724h */ case   26:  		/* mr R4, R25 */
		/* 8222A724h case   26:*/		regs.R4 = regs.R25;
		/* 8222A724h case   26:*/		return 0x8222A728;
		  /* 8222A728h */ case   27:  		/* rldicr R5, R26, 32, 31 */
		/* 8222A728h case   27:*/		cpu::op::rldicr<0,32,31>(regs,&regs.R5,regs.R26);
		/* 8222A728h case   27:*/		return 0x8222A72C;
		  /* 8222A72Ch */ case   28:  		/* mr R3, R31 */
		/* 8222A72Ch case   28:*/		regs.R3 = regs.R31;
		/* 8222A72Ch case   28:*/		return 0x8222A730;
		  /* 8222A730h */ case   29:  		/* bl -37960 */
		/* 8222A730h case   29:*/		regs.LR = 0x8222A734; return 0x822212E8;
		/* 8222A730h case   29:*/		return 0x8222A734;
		  /* 8222A734h */ case   30:  		/* li R4, 4800 */
		/* 8222A734h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222A734h case   30:*/		return 0x8222A738;
		  /* 8222A738h */ case   31:  		/* mr R3, R31 */
		/* 8222A738h case   31:*/		regs.R3 = regs.R31;
		/* 8222A738h case   31:*/		return 0x8222A73C;
		  /* 8222A73Ch */ case   32:  		/* bl -886996 */
		/* 8222A73Ch case   32:*/		regs.LR = 0x8222A740; return 0x82151E68;
		/* 8222A73Ch case   32:*/		return 0x8222A740;
	}
	return 0x8222A740;
} // Block from 8222A6BCh-8222A740h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8222A740h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A740);
		  /* 8222A740h */ case    0:  		/* mfspr R12, LR */
		/* 8222A740h case    0:*/		regs.R12 = regs.LR;
		/* 8222A740h case    0:*/		return 0x8222A744;
		  /* 8222A744h */ case    1:  		/* bl -1676528 */
		/* 8222A744h case    1:*/		regs.LR = 0x8222A748; return 0x82091254;
		/* 8222A744h case    1:*/		return 0x8222A748;
		  /* 8222A748h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 8222A748h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8222A748h case    2:*/		return 0x8222A74C;
		  /* 8222A74Ch */ case    3:  		/* mr R30, R6 */
		/* 8222A74Ch case    3:*/		regs.R30 = regs.R6;
		/* 8222A74Ch case    3:*/		return 0x8222A750;
		  /* 8222A750h */ case    4:  		/* li R6, 0 */
		/* 8222A750h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8222A750h case    4:*/		return 0x8222A754;
		  /* 8222A754h */ case    5:  		/* mr R31, R3 */
		/* 8222A754h case    5:*/		regs.R31 = regs.R3;
		/* 8222A754h case    5:*/		return 0x8222A758;
		  /* 8222A758h */ case    6:  		/* mr R29, R5 */
		/* 8222A758h case    6:*/		regs.R29 = regs.R5;
		/* 8222A758h case    6:*/		return 0x8222A75C;
		  /* 8222A75Ch */ case    7:  		/* mr R27, R7 */
		/* 8222A75Ch case    7:*/		regs.R27 = regs.R7;
		/* 8222A75Ch case    7:*/		return 0x8222A760;
		  /* 8222A760h */ case    8:  		/* cmpwi CR6, R4, -1 */
		/* 8222A760h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 8222A760h case    8:*/		return 0x8222A764;
		  /* 8222A764h */ case    9:  		/* mr R3, R6 */
		/* 8222A764h case    9:*/		regs.R3 = regs.R6;
		/* 8222A764h case    9:*/		return 0x8222A768;
		  /* 8222A768h */ case   10:  		/* bc 12, CR6_EQ, 92 */
		/* 8222A768h case   10:*/		if ( regs.CR[6].eq ) { return 0x8222A7C4;  }
		/* 8222A768h case   10:*/		return 0x8222A76C;
		  /* 8222A76Ch */ case   11:  		/* lwz R7, <#[R31 + 536]> */
		/* 8222A76Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000218) );
		/* 8222A76Ch case   11:*/		return 0x8222A770;
		  /* 8222A770h */ case   12:  		/* mr R11, R6 */
		/* 8222A770h case   12:*/		regs.R11 = regs.R6;
		/* 8222A770h case   12:*/		return 0x8222A774;
		  /* 8222A774h */ case   13:  		/* cmplwi CR6, R7, 0 */
		/* 8222A774h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8222A774h case   13:*/		return 0x8222A778;
		  /* 8222A778h */ case   14:  		/* bc 12, CR6_EQ, 76 */
		/* 8222A778h case   14:*/		if ( regs.CR[6].eq ) { return 0x8222A7C4;  }
		/* 8222A778h case   14:*/		return 0x8222A77C;
		  /* 8222A77Ch */ case   15:  		/* addi R10, R31, 348 */
		/* 8222A77Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x15C);
		/* 8222A77Ch case   15:*/		return 0x8222A780;
		  /* 8222A780h */ case   16:  		/* lwz R9, <#[R10]> */
		/* 8222A780h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222A780h case   16:*/		return 0x8222A784;
		  /* 8222A784h */ case   17:  		/* rlwinm R5, R9, 0, 27, 31 */
		/* 8222A784h case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R9);
		/* 8222A784h case   17:*/		return 0x8222A788;
		  /* 8222A788h */ case   18:  		/* cmplw CR6, R4, R5 */
		/* 8222A788h case   18:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 8222A788h case   18:*/		return 0x8222A78C;
		  /* 8222A78Ch */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 8222A78Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x8222A79C;  }
		/* 8222A78Ch case   19:*/		return 0x8222A790;
		  /* 8222A790h */ case   20:  		/* rlwinm R9, R9, 27, 28, 31 */
		/* 8222A790h case   20:*/		cpu::op::rlwinm<0,27,28,31>(regs,&regs.R9,regs.R9);
		/* 8222A790h case   20:*/		return 0x8222A794;
		  /* 8222A794h */ case   21:  		/* cmplw CR6, R29, R9 */
		/* 8222A794h case   21:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R9);
		/* 8222A794h case   21:*/		return 0x8222A798;
		  /* 8222A798h */ case   22:  		/* bc 12, CR6_EQ, 24 */
		/* 8222A798h case   22:*/		if ( regs.CR[6].eq ) { return 0x8222A7B0;  }
		/* 8222A798h case   22:*/		return 0x8222A79C;
	}
	return 0x8222A79C;
} // Block from 8222A740h-8222A79Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8222A79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A79C);
		  /* 8222A79Ch */ case    0:  		/* addi R11, R11, 1 */
		/* 8222A79Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222A79Ch case    0:*/		return 0x8222A7A0;
		  /* 8222A7A0h */ case    1:  		/* addi R10, R10, 12 */
		/* 8222A7A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8222A7A0h case    1:*/		return 0x8222A7A4;
		  /* 8222A7A4h */ case    2:  		/* cmplw CR6, R11, R7 */
		/* 8222A7A4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8222A7A4h case    2:*/		return 0x8222A7A8;
		  /* 8222A7A8h */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 8222A7A8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8222A780;  }
		/* 8222A7A8h case    3:*/		return 0x8222A7AC;
		  /* 8222A7ACh */ case    4:  		/* b 24 */
		/* 8222A7ACh case    4:*/		return 0x8222A7C4;
		/* 8222A7ACh case    4:*/		return 0x8222A7B0;
	}
	return 0x8222A7B0;
} // Block from 8222A79Ch-8222A7B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222A7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A7B0);
		  /* 8222A7B0h */ case    0:  		/* mulli R11, R11, 12 */
		/* 8222A7B0h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8222A7B0h case    0:*/		return 0x8222A7B4;
		  /* 8222A7B4h */ case    1:  		/* add R11, R11, R31 */
		/* 8222A7B4h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8222A7B4h case    1:*/		return 0x8222A7B8;
		  /* 8222A7B8h */ case    2:  		/* lwz R3, <#[R11 + 352]> */
		/* 8222A7B8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000160) );
		/* 8222A7B8h case    2:*/		return 0x8222A7BC;
		  /* 8222A7BCh */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 8222A7BCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8222A7BCh case    3:*/		return 0x8222A7C0;
		  /* 8222A7C0h */ case    4:  		/* bc 4, CR6_EQ, 432 */
		/* 8222A7C0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8222A970;  }
		/* 8222A7C0h case    4:*/		return 0x8222A7C4;
	}
	return 0x8222A7C4;
} // Block from 8222A7B0h-8222A7C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222A7C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A7C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A7C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A7C4);
		  /* 8222A7C4h */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 8222A7C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 8222A7C4h case    0:*/		return 0x8222A7C8;
		  /* 8222A7C8h */ case    1:  		/* bc 12, CR0_EQ, 424 */
		/* 8222A7C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8222A970;  }
		/* 8222A7C8h case    1:*/		return 0x8222A7CC;
		  /* 8222A7CCh */ case    2:  		/* addi R11, R1, 108 */
		/* 8222A7CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x6C);
		/* 8222A7CCh case    2:*/		return 0x8222A7D0;
		  /* 8222A7D0h */ case    3:  		/* lwz R10, <#[R31 + 48]> */
		/* 8222A7D0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8222A7D0h case    3:*/		return 0x8222A7D4;
		  /* 8222A7D4h */ case    4:  		/* lis R28, -1 */
		/* 8222A7D4h case    4:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8222A7D4h case    4:*/		return 0x8222A7D8;
		  /* 8222A7D8h */ case    5:  		/* stw R6, <#[R1 + 104]> */
		/* 8222A7D8h case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000068) );
		/* 8222A7D8h case    5:*/		return 0x8222A7DC;
		  /* 8222A7DCh */ case    6:  		/* rlwinm R10, R10, 0, 0, 15 */
		/* 8222A7DCh case    6:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R10,regs.R10);
		/* 8222A7DCh case    6:*/		return 0x8222A7E0;
		  /* 8222A7E0h */ case    7:  		/* stb R6, <#[R1 + 96]> */
		/* 8222A7E0h case    7:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 8222A7E0h case    7:*/		return 0x8222A7E4;
		  /* 8222A7E4h */ case    8:  		/* cmplw CR6, R10, R28 */
		/* 8222A7E4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 8222A7E4h case    8:*/		return 0x8222A7E8;
		  /* 8222A7E8h */ case    9:  		/* stw R6, <#[R11]> */
		/* 8222A7E8h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8222A7E8h case    9:*/		return 0x8222A7EC;
		  /* 8222A7ECh */ case   10:  		/* stw R6, <#[R11 + 4]> */
		/* 8222A7ECh case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8222A7ECh case   10:*/		return 0x8222A7F0;
		  /* 8222A7F0h */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 8222A7F0h case   11:*/		if ( regs.CR[6].eq ) { return 0x8222A804;  }
		/* 8222A7F0h case   11:*/		return 0x8222A7F4;
		  /* 8222A7F4h */ case   12:  		/* lis R11, -32216 */
		/* 8222A7F4h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8222A7F4h case   12:*/		return 0x8222A7F8;
		  /* 8222A7F8h */ case   13:  		/* li R7, 21 */
		/* 8222A7F8h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x15);
		/* 8222A7F8h case   13:*/		return 0x8222A7FC;
		  /* 8222A7FCh */ case   14:  		/* addi R6, R11, 10568 */
		/* 8222A7FCh case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2948);
		/* 8222A7FCh case   14:*/		return 0x8222A800;
		  /* 8222A800h */ case   15:  		/* b 16 */
		/* 8222A800h case   15:*/		return 0x8222A810;
		/* 8222A800h case   15:*/		return 0x8222A804;
	}
	return 0x8222A804;
} // Block from 8222A7C4h-8222A804h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8222A804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A804);
		  /* 8222A804h */ case    0:  		/* lis R11, -32216 */
		/* 8222A804h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8222A804h case    0:*/		return 0x8222A808;
		  /* 8222A808h */ case    1:  		/* li R7, 20 */
		/* 8222A808h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x14);
		/* 8222A808h case    1:*/		return 0x8222A80C;
		  /* 8222A80Ch */ case    2:  		/* addi R6, R11, 10824 */
		/* 8222A80Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2A48);
		/* 8222A80Ch case    2:*/		return 0x8222A810;
	}
	return 0x8222A810;
} // Block from 8222A804h-8222A810h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222A810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A810);
		  /* 8222A810h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8222A810h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8222A810h case    0:*/		return 0x8222A814;
		  /* 8222A814h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 8222A814h case    1:*/		if ( regs.CR[6].eq ) { return 0x8222A858;  }
		/* 8222A814h case    1:*/		return 0x8222A818;
		  /* 8222A818h */ case    2:  		/* addi R8, R1, 100 */
		/* 8222A818h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x64);
		/* 8222A818h case    2:*/		return 0x8222A81C;
		  /* 8222A81Ch */ case    3:  		/* addi R11, R1, 96 */
		/* 8222A81Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8222A81Ch case    3:*/		return 0x8222A820;
		  /* 8222A820h */ case    4:  		/* stw R8, <#[R1 + 84]> */
		/* 8222A820h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8222A820h case    4:*/		return 0x8222A824;
		  /* 8222A824h */ case    5:  		/* addi R10, R1, 104 */
		/* 8222A824h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 8222A824h case    5:*/		return 0x8222A828;
		  /* 8222A828h */ case    6:  		/* li R9, 0 */
		/* 8222A828h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8222A828h case    6:*/		return 0x8222A82C;
		  /* 8222A82Ch */ case    7:  		/* stw R11, <#[R1 + 92]> */
		/* 8222A82Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8222A82Ch case    7:*/		return 0x8222A830;
		  /* 8222A830h */ case    8:  		/* li R8, 0 */
		/* 8222A830h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8222A830h case    8:*/		return 0x8222A834;
		  /* 8222A834h */ case    9:  		/* li R5, 0 */
		/* 8222A834h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222A834h case    9:*/		return 0x8222A838;
		  /* 8222A838h */ case   10:  		/* mr R4, R30 */
		/* 8222A838h case   10:*/		regs.R4 = regs.R30;
		/* 8222A838h case   10:*/		return 0x8222A83C;
		  /* 8222A83Ch */ case   11:  		/* mr R3, R31 */
		/* 8222A83Ch case   11:*/		regs.R3 = regs.R31;
		/* 8222A83Ch case   11:*/		return 0x8222A840;
		  /* 8222A840h */ case   12:  		/* bl -34136 */
		/* 8222A840h case   12:*/		regs.LR = 0x8222A844; return 0x822222E8;
		/* 8222A840h case   12:*/		return 0x8222A844;
		  /* 8222A844h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222A844h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222A844h case   13:*/		return 0x8222A848;
		  /* 8222A848h */ case   14:  		/* bc 4, CR0_EQ, 256 */
		/* 8222A848h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8222A948;  }
		/* 8222A848h case   14:*/		return 0x8222A84C;
		  /* 8222A84Ch */ case   15:  		/* li R4, 4800 */
		/* 8222A84Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222A84Ch case   15:*/		return 0x8222A850;
		  /* 8222A850h */ case   16:  		/* mr R3, R31 */
		/* 8222A850h case   16:*/		regs.R3 = regs.R31;
		/* 8222A850h case   16:*/		return 0x8222A854;
		  /* 8222A854h */ case   17:  		/* bl -887276 */
		/* 8222A854h case   17:*/		regs.LR = 0x8222A858; return 0x82151E68;
		/* 8222A854h case   17:*/		return 0x8222A858;
	}
	return 0x8222A858;
} // Block from 8222A810h-8222A858h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8222A858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A858);
		  /* 8222A858h */ case    0:  		/* mulli R11, R7, 12 */
		/* 8222A858h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R7,0xC);
		/* 8222A858h case    0:*/		return 0x8222A85C;
		  /* 8222A85Ch */ case    1:  		/* add R11, R11, R6 */
		/* 8222A85Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8222A85Ch case    1:*/		return 0x8222A860;
		  /* 8222A860h */ case    2:  		/* mr R30, R6 */
		/* 8222A860h case    2:*/		regs.R30 = regs.R6;
		/* 8222A860h case    2:*/		return 0x8222A864;
		  /* 8222A864h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8222A864h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8222A864h case    3:*/		return 0x8222A868;
		  /* 8222A868h */ case    4:  		/* bc 4, CR6_LT, 32 */
		/* 8222A868h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8222A888;  }
		/* 8222A868h case    4:*/		return 0x8222A86C;
		  /* 8222A86Ch */ case    5:  		/* lwz R10, <#[R30 + 4]> */
		/* 8222A86Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8222A86Ch case    5:*/		return 0x8222A870;
		  /* 8222A870h */ case    6:  		/* rlwinm R10, R10, 9, 27, 31 */
		/* 8222A870h case    6:*/		cpu::op::rlwinm<0,9,27,31>(regs,&regs.R10,regs.R10);
		/* 8222A870h case    6:*/		return 0x8222A874;
		  /* 8222A874h */ case    7:  		/* cmplw CR6, R4, R10 */
		/* 8222A874h case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8222A874h case    7:*/		return 0x8222A878;
		  /* 8222A878h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8222A878h case    8:*/		if ( regs.CR[6].eq ) { return 0x8222A888;  }
		/* 8222A878h case    8:*/		return 0x8222A87C;
		  /* 8222A87Ch */ case    9:  		/* addi R30, R30, 12 */
		/* 8222A87Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xC);
		/* 8222A87Ch case    9:*/		return 0x8222A880;
		  /* 8222A880h */ case   10:  		/* cmplw CR6, R30, R11 */
		/* 8222A880h case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8222A880h case   10:*/		return 0x8222A884;
		  /* 8222A884h */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 8222A884h case   11:*/		if ( regs.CR[6].lt ) { return 0x8222A86C;  }
		/* 8222A884h case   11:*/		return 0x8222A888;
	}
	return 0x8222A888;
} // Block from 8222A858h-8222A888h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8222A888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A888);
		  /* 8222A888h */ case    0:  		/* cmplw CR6, R30, R11 */
		/* 8222A888h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8222A888h case    0:*/		return 0x8222A88C;
		  /* 8222A88Ch */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 8222A88Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8222A89C;  }
		/* 8222A88Ch case    1:*/		return 0x8222A890;
		  /* 8222A890h */ case    2:  		/* li R4, 4800 */
		/* 8222A890h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222A890h case    2:*/		return 0x8222A894;
		  /* 8222A894h */ case    3:  		/* mr R3, R31 */
		/* 8222A894h case    3:*/		regs.R3 = regs.R31;
		/* 8222A894h case    3:*/		return 0x8222A898;
		  /* 8222A898h */ case    4:  		/* bl -887344 */
		/* 8222A898h case    4:*/		regs.LR = 0x8222A89C; return 0x82151E68;
		/* 8222A898h case    4:*/		return 0x8222A89C;
	}
	return 0x8222A89C;
} // Block from 8222A888h-8222A89Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222A89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A89C);
		  /* 8222A89Ch */ case    0:  		/* lwz R6, <#[R30]> */
		/* 8222A89Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000000) );
		/* 8222A89Ch case    0:*/		return 0x8222A8A0;
		  /* 8222A8A0h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 8222A8A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8222A8A0h case    1:*/		return 0x8222A8A4;
		  /* 8222A8A4h */ case    2:  		/* bc 12, CR6_EQ, 120 */
		/* 8222A8A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222A91C;  }
		/* 8222A8A4h case    2:*/		return 0x8222A8A8;
		  /* 8222A8A8h */ case    3:  		/* lis R11, -32252 */
		/* 8222A8A8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8222A8A8h case    3:*/		return 0x8222A8AC;
		  /* 8222A8ACh */ case    4:  		/* mr R7, R29 */
		/* 8222A8ACh case    4:*/		regs.R7 = regs.R29;
		/* 8222A8ACh case    4:*/		return 0x8222A8B0;
		  /* 8222A8B0h */ case    5:  		/* addi R5, R11, -16884 */
		/* 8222A8B0h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBE0C);
		/* 8222A8B0h case    5:*/		return 0x8222A8B4;
		  /* 8222A8B4h */ case    6:  		/* li R4, 100 */
		/* 8222A8B4h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x64);
		/* 8222A8B4h case    6:*/		return 0x8222A8B8;
		  /* 8222A8B8h */ case    7:  		/* addi R3, R1, 128 */
		/* 8222A8B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8222A8B8h case    7:*/		return 0x8222A8BC;
		  /* 8222A8BCh */ case    8:  		/* bl 255212 */
		/* 8222A8BCh case    8:*/		regs.LR = 0x8222A8C0; return 0x82268DA8;
		/* 8222A8BCh case    8:*/		return 0x8222A8C0;
		  /* 8222A8C0h */ case    9:  		/* addi R11, R1, 128 */
		/* 8222A8C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8222A8C0h case    9:*/		return 0x8222A8C4;
		  /* 8222A8C4h */ case   10:  		/* mr R10, R11 */
		/* 8222A8C4h case   10:*/		regs.R10 = regs.R11;
		/* 8222A8C4h case   10:*/		return 0x8222A8C8;
		  /* 8222A8C8h */ case   11:  		/* lbz R9, <#[R11]> */
		/* 8222A8C8h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222A8C8h case   11:*/		return 0x8222A8CC;
		  /* 8222A8CCh */ case   12:  		/* addi R11, R11, 1 */
		/* 8222A8CCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222A8CCh case   12:*/		return 0x8222A8D0;
		  /* 8222A8D0h */ case   13:  		/* cmplwi CR6, R9, 0 */
		/* 8222A8D0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8222A8D0h case   13:*/		return 0x8222A8D4;
		  /* 8222A8D4h */ case   14:  		/* bc 4, CR6_EQ, -12 */
		/* 8222A8D4h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8222A8C8;  }
		/* 8222A8D4h case   14:*/		return 0x8222A8D8;
		  /* 8222A8D8h */ case   15:  		/* subf R11, R10, R11 */
		/* 8222A8D8h case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8222A8D8h case   15:*/		return 0x8222A8DC;
		  /* 8222A8DCh */ case   16:  		/* li R5, 0 */
		/* 8222A8DCh case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222A8DCh case   16:*/		return 0x8222A8E0;
		  /* 8222A8E0h */ case   17:  		/* addi R11, R11, -1 */
		/* 8222A8E0h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8222A8E0h case   17:*/		return 0x8222A8E4;
		  /* 8222A8E4h */ case   18:  		/* mr R3, R31 */
		/* 8222A8E4h case   18:*/		regs.R3 = regs.R31;
		/* 8222A8E4h case   18:*/		return 0x8222A8E8;
		  /* 8222A8E8h */ case   19:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8222A8E8h case   19:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8222A8E8h case   19:*/		return 0x8222A8EC;
		  /* 8222A8ECh */ case   20:  		/* addi R11, R11, 4 */
		/* 8222A8ECh case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8222A8ECh case   20:*/		return 0x8222A8F0;
		  /* 8222A8F0h */ case   21:  		/* rlwinm R4, R11, 0, 0, 29 */
		/* 8222A8F0h case   21:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R11);
		/* 8222A8F0h case   21:*/		return 0x8222A8F4;
		  /* 8222A8F4h */ case   22:  		/* bl -647884 */
		/* 8222A8F4h case   22:*/		regs.LR = 0x8222A8F8; return 0x8218C628;
		/* 8222A8F4h case   22:*/		return 0x8222A8F8;
		  /* 8222A8F8h */ case   23:  		/* addi R10, R1, 128 */
		/* 8222A8F8h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8222A8F8h case   23:*/		return 0x8222A8FC;
		  /* 8222A8FCh */ case   24:  		/* mr R6, R3 */
		/* 8222A8FCh case   24:*/		regs.R6 = regs.R3;
		/* 8222A8FCh case   24:*/		return 0x8222A900;
		  /* 8222A900h */ case   25:  		/* addi R11, R1, 128 */
		/* 8222A900h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8222A900h case   25:*/		return 0x8222A904;
		  /* 8222A904h */ case   26:  		/* subf R10, R10, R3 */
		/* 8222A904h case   26:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8222A904h case   26:*/		return 0x8222A908;
		  /* 8222A908h */ case   27:  		/* lbz R9, <#[R11]> */
		/* 8222A908h case   27:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222A908h case   27:*/		return 0x8222A90C;
		  /* 8222A90Ch */ case   28:  		/* extsb. R8, R9 */
		/* 8222A90Ch case   28:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R9);
		/* 8222A90Ch case   28:*/		return 0x8222A910;
		  /* 8222A910h */ case   29:  		/* stbx R9, <#[R10 + R11]> */
		/* 8222A910h case   29:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8222A910h case   29:*/		return 0x8222A914;
		  /* 8222A914h */ case   30:  		/* addi R11, R11, 1 */
		/* 8222A914h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222A914h case   30:*/		return 0x8222A918;
		  /* 8222A918h */ case   31:  		/* bc 4, CR0_EQ, -16 */
		/* 8222A918h case   31:*/		if ( !regs.CR[0].eq ) { return 0x8222A908;  }
		/* 8222A918h case   31:*/		return 0x8222A91C;
	}
	return 0x8222A91C;
} // Block from 8222A89Ch-8222A91Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 8222A91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A91C);
		  /* 8222A91Ch */ case    0:  		/* addi R8, R1, 100 */
		/* 8222A91Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x64);
		/* 8222A91Ch case    0:*/		return 0x8222A920;
		  /* 8222A920h */ case    1:  		/* addi R7, R1, 104 */
		/* 8222A920h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x68);
		/* 8222A920h case    1:*/		return 0x8222A924;
		  /* 8222A924h */ case    2:  		/* mr R5, R29 */
		/* 8222A924h case    2:*/		regs.R5 = regs.R29;
		/* 8222A924h case    2:*/		return 0x8222A928;
		  /* 8222A928h */ case    3:  		/* mr R4, R30 */
		/* 8222A928h case    3:*/		regs.R4 = regs.R30;
		/* 8222A928h case    3:*/		return 0x8222A92C;
		  /* 8222A92Ch */ case    4:  		/* mr R3, R31 */
		/* 8222A92Ch case    4:*/		regs.R3 = regs.R31;
		/* 8222A92Ch case    4:*/		return 0x8222A930;
		  /* 8222A930h */ case    5:  		/* bl -39600 */
		/* 8222A930h case    5:*/		regs.LR = 0x8222A934; return 0x82220E80;
		/* 8222A930h case    5:*/		return 0x8222A934;
		  /* 8222A934h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222A934h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222A934h case    6:*/		return 0x8222A938;
		  /* 8222A938h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 8222A938h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8222A948;  }
		/* 8222A938h case    7:*/		return 0x8222A93C;
		  /* 8222A93Ch */ case    8:  		/* li R4, 4800 */
		/* 8222A93Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222A93Ch case    8:*/		return 0x8222A940;
		  /* 8222A940h */ case    9:  		/* mr R3, R31 */
		/* 8222A940h case    9:*/		regs.R3 = regs.R31;
		/* 8222A940h case    9:*/		return 0x8222A944;
		  /* 8222A944h */ case   10:  		/* bl -887516 */
		/* 8222A944h case   10:*/		regs.LR = 0x8222A948; return 0x82151E68;
		/* 8222A944h case   10:*/		return 0x8222A948;
	}
	return 0x8222A948;
} // Block from 8222A91Ch-8222A948h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8222A948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A948);
		  /* 8222A948h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 8222A948h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8222A948h case    0:*/		return 0x8222A94C;
		  /* 8222A94Ch */ case    1:  		/* mr R6, R27 */
		/* 8222A94Ch case    1:*/		regs.R6 = regs.R27;
		/* 8222A94Ch case    1:*/		return 0x8222A950;
		  /* 8222A950h */ case    2:  		/* ld R4, <#[R1 + 104]> */
		/* 8222A950h case    2:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 8222A950h case    2:*/		return 0x8222A954;
		  /* 8222A954h */ case    3:  		/* mr R3, R31 */
		/* 8222A954h case    3:*/		regs.R3 = regs.R31;
		/* 8222A954h case    3:*/		return 0x8222A958;
		  /* 8222A958h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8222A958h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8222A958h case    4:*/		return 0x8222A95C;
		  /* 8222A95Ch */ case    5:  		/* cmplw CR6, R11, R28 */
		/* 8222A95Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 8222A95Ch case    5:*/		return 0x8222A960;
		  /* 8222A960h */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 8222A960h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8222A960h case    6:*/		return 0x8222A964;
		  /* 8222A964h */ case    7:  		/* rldicr R5, R11, 32, 63 */
		/* 8222A964h case    7:*/		cpu::op::rldicr<0,32,63>(regs,&regs.R5,regs.R11);
		/* 8222A964h case    7:*/		return 0x8222A968;
		  /* 8222A968h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8222A968h case    8:*/		if ( regs.CR[6].eq ) { return 0x8222A978;  }
		/* 8222A968h case    8:*/		return 0x8222A96C;
		  /* 8222A96Ch */ case    9:  		/* bl -22940 */
		/* 8222A96Ch case    9:*/		regs.LR = 0x8222A970; return 0x82224FD0;
		/* 8222A96Ch case    9:*/		return 0x8222A970;
	}
	return 0x8222A970;
} // Block from 8222A948h-8222A970h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222A970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A970);
		  /* 8222A970h */ case    0:  		/* addi R1, R1, 288 */
		/* 8222A970h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8222A970h case    0:*/		return 0x8222A974;
		  /* 8222A974h */ case    1:  		/* b -1677008 */
		/* 8222A974h case    1:*/		return 0x820912A4;
		/* 8222A974h case    1:*/		return 0x8222A978;
	}
	return 0x8222A978;
} // Block from 8222A970h-8222A978h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222A978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A978);
		  /* 8222A978h */ case    0:  		/* li R9, 0 */
		/* 8222A978h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8222A978h case    0:*/		return 0x8222A97C;
		  /* 8222A97Ch */ case    1:  		/* lwz R7, <#[R1 + 100]> */
		/* 8222A97Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000064) );
		/* 8222A97Ch case    1:*/		return 0x8222A980;
		  /* 8222A980h */ case    2:  		/* li R8, 0 */
		/* 8222A980h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8222A980h case    2:*/		return 0x8222A984;
		  /* 8222A984h */ case    3:  		/* bl -2460 */
		/* 8222A984h case    3:*/		regs.LR = 0x8222A988; return 0x82229FE8;
		/* 8222A984h case    3:*/		return 0x8222A988;
		  /* 8222A988h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8222A988h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8222A988h case    4:*/		return 0x8222A98C;
		  /* 8222A98Ch */ case    5:  		/* bc 4, CR0_EQ, -28 */
		/* 8222A98Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8222A970;  }
		/* 8222A98Ch case    5:*/		return 0x8222A990;
		  /* 8222A990h */ case    6:  		/* li R4, 4800 */
		/* 8222A990h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222A990h case    6:*/		return 0x8222A994;
		  /* 8222A994h */ case    7:  		/* mr R3, R31 */
		/* 8222A994h case    7:*/		regs.R3 = regs.R31;
		/* 8222A994h case    7:*/		return 0x8222A998;
		  /* 8222A998h */ case    8:  		/* bl -887600 */
		/* 8222A998h case    8:*/		regs.LR = 0x8222A99C; return 0x82151E68;
		/* 8222A998h case    8:*/		return 0x8222A99C;
		  /* 8222A99Ch */ case    9:  		/* nop */
		/* 8222A99Ch case    9:*/		cpu::op::nop();
		/* 8222A99Ch case    9:*/		return 0x8222A9A0;
	}
	return 0x8222A9A0;
} // Block from 8222A978h-8222A9A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222A9A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A9A0);
		  /* 8222A9A0h */ case    0:  		/* mfspr R12, LR */
		/* 8222A9A0h case    0:*/		regs.R12 = regs.LR;
		/* 8222A9A0h case    0:*/		return 0x8222A9A4;
		  /* 8222A9A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222A9A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222A9A4h case    1:*/		return 0x8222A9A8;
		  /* 8222A9A8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8222A9A8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8222A9A8h case    2:*/		return 0x8222A9AC;
		  /* 8222A9ACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8222A9ACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222A9ACh case    3:*/		return 0x8222A9B0;
		  /* 8222A9B0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8222A9B0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8222A9B0h case    4:*/		return 0x8222A9B4;
		  /* 8222A9B4h */ case    5:  		/* lwz R11, <#[R3 + 648]> */
		/* 8222A9B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000288) );
		/* 8222A9B4h case    5:*/		return 0x8222A9B8;
		  /* 8222A9B8h */ case    6:  		/* mr R31, R3 */
		/* 8222A9B8h case    6:*/		regs.R31 = regs.R3;
		/* 8222A9B8h case    6:*/		return 0x8222A9BC;
		  /* 8222A9BCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8222A9BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222A9BCh case    7:*/		return 0x8222A9C0;
		  /* 8222A9C0h */ case    8:  		/* bc 4, CR6_EQ, 172 */
		/* 8222A9C0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8222AA6C;  }
		/* 8222A9C0h case    8:*/		return 0x8222A9C4;
		  /* 8222A9C4h */ case    9:  		/* lis R11, -32252 */
		/* 8222A9C4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8222A9C4h case    9:*/		return 0x8222A9C8;
		  /* 8222A9C8h */ case   10:  		/* li R5, 3 */
		/* 8222A9C8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8222A9C8h case   10:*/		return 0x8222A9CC;
		  /* 8222A9CCh */ case   11:  		/* addi R6, R11, -232 */
		/* 8222A9CCh case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFF18);
		/* 8222A9CCh case   11:*/		return 0x8222A9D0;
		  /* 8222A9D0h */ case   12:  		/* li R4, 1 */
		/* 8222A9D0h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8222A9D0h case   12:*/		return 0x8222A9D4;
		  /* 8222A9D4h */ case   13:  		/* bl -21108 */
		/* 8222A9D4h case   13:*/		regs.LR = 0x8222A9D8; return 0x82225760;
		/* 8222A9D4h case   13:*/		return 0x8222A9D8;
	}
	return 0x8222A9D8;
} // Block from 8222A9A0h-8222A9D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8222A9D8h
// Function '?InsertCopy@Compiler@D3DXShader@@QAA_NPAVBlock@2@UInstructionPlacementPoint@12@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222A9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222A9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222A9D8);
		  /* 8222A9D8h */ case    0:  		/* mr R30, R3 */
		/* 8222A9D8h case    0:*/		regs.R30 = regs.R3;
		/* 8222A9D8h case    0:*/		return 0x8222A9DC;
		  /* 8222A9DCh */ case    1:  		/* lwz R10, <#[R3 + 4]> */
		/* 8222A9DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8222A9DCh case    1:*/		return 0x8222A9E0;
		  /* 8222A9E0h */ case    2:  		/* li R11, 1 */
		/* 8222A9E0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222A9E0h case    2:*/		return 0x8222A9E4;
		  /* 8222A9E4h */ case    3:  		/* li R6, 3 */
		/* 8222A9E4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 8222A9E4h case    3:*/		return 0x8222A9E8;
		  /* 8222A9E8h */ case    4:  		/* rlwimi R10, R11, 5, 25, 27 */
		/* 8222A9E8h case    4:*/		cpu::op::rlwimi<0,5,25,27>(regs,&regs.R10,regs.R11);
		/* 8222A9E8h case    4:*/		return 0x8222A9EC;
		  /* 8222A9ECh */ case    5:  		/* li R5, 1 */
		/* 8222A9ECh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8222A9ECh case    5:*/		return 0x8222A9F0;
		  /* 8222A9F0h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 8222A9F0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8222A9F0h case    6:*/		return 0x8222A9F4;
		  /* 8222A9F4h */ case    7:  		/* li R4, 10 */
		/* 8222A9F4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 8222A9F4h case    7:*/		return 0x8222A9F8;
		  /* 8222A9F8h */ case    8:  		/* stw R10, <#[R30 + 4]> */
		/* 8222A9F8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8222A9F8h case    8:*/		return 0x8222A9FC;
		  /* 8222A9FCh */ case    9:  		/* rlwimi R10, R11, 16, 7, 15 */
		/* 8222A9FCh case    9:*/		cpu::op::rlwimi<0,16,7,15>(regs,&regs.R10,regs.R11);
		/* 8222A9FCh case    9:*/		return 0x8222AA00;
	}
	return 0x8222AA00;
} // Block from 8222A9D8h-8222AA00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222AA00h
// Function '?CreatePixelShaderInputInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@ULinkageSemantics@2@IW4PARAMGEN@2@_N2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AA00);
		  /* 8222AA00h */ case    0:  		/* oris R9, R9, 8 */
		/* 8222AA00h case    0:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x8);
		/* 8222AA00h case    0:*/		return 0x8222AA04;
		  /* 8222AA04h */ case    1:  		/* lwz R8, <#[R30 + 28]> */
		/* 8222AA04h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222AA04h case    1:*/		return 0x8222AA08;
		  /* 8222AA08h */ case    2:  		/* mr R3, R31 */
		/* 8222AA08h case    2:*/		regs.R3 = regs.R31;
		/* 8222AA08h case    2:*/		return 0x8222AA0C;
		  /* 8222AA0Ch */ case    3:  		/* stw R9, <#[R30]> */
		/* 8222AA0Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8222AA0Ch case    3:*/		return 0x8222AA10;
		  /* 8222AA10h */ case    4:  		/* lwz R7, <#[R31 + 56]> */
		/* 8222AA10h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000038) );
		/* 8222AA10h case    4:*/		return 0x8222AA14;
		  /* 8222AA14h */ case    5:  		/* lhz R7, <#[R7 + 64]> */
		/* 8222AA14h case    5:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000040) );
		/* 8222AA14h case    5:*/		return 0x8222AA18;
		  /* 8222AA18h */ case    6:  		/* rlwimi R9, R7, 20, 3, 11 */
		/* 8222AA18h case    6:*/		cpu::op::rlwimi<0,20,3,11>(regs,&regs.R9,regs.R7);
		/* 8222AA18h case    6:*/		return 0x8222AA1C;
		  /* 8222AA1Ch */ case    7:  		/* stw R10, <#[R30 + 4]> */
		/* 8222AA1Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8222AA1Ch case    7:*/		return 0x8222AA20;
		  /* 8222AA20h */ case    8:  		/* stw R9, <#[R30]> */
		/* 8222AA20h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8222AA20h case    8:*/		return 0x8222AA24;
		  /* 8222AA24h */ case    9:  		/* lwz R10, <#[R8]> */
		/* 8222AA24h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8222AA24h case    9:*/		return 0x8222AA28;
		  /* 8222AA28h */ case   10:  		/* rlwimi R10, R11, 0, 28, 31 */
		/* 8222AA28h case   10:*/		cpu::op::rlwimi<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 8222AA28h case   10:*/		return 0x8222AA2C;
		  /* 8222AA2Ch */ case   11:  		/* stw R10, <#[R8]> */
		/* 8222AA2Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8222AA2Ch case   11:*/		return 0x8222AA30;
		  /* 8222AA30h */ case   12:  		/* lwz R10, <#[R30 + 28]> */
		/* 8222AA30h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222AA30h case   12:*/		return 0x8222AA34;
		  /* 8222AA34h */ case   13:  		/* lwz R9, <#[R10 + 8]> */
		/* 8222AA34h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8222AA34h case   13:*/		return 0x8222AA38;
		  /* 8222AA38h */ case   14:  		/* rlwimi R9, R11, 1, 28, 31 */
		/* 8222AA38h case   14:*/		cpu::op::rlwimi<0,1,28,31>(regs,&regs.R9,regs.R11);
		/* 8222AA38h case   14:*/		return 0x8222AA3C;
		  /* 8222AA3Ch */ case   15:  		/* stw R9, <#[R10 + 8]> */
		/* 8222AA3Ch case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8222AA3Ch case   15:*/		return 0x8222AA40;
		  /* 8222AA40h */ case   16:  		/* lwz R10, <#[R30 + 28]> */
		/* 8222AA40h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222AA40h case   16:*/		return 0x8222AA44;
		  /* 8222AA44h */ case   17:  		/* lwz R9, <#[R10 + 16]> */
		/* 8222AA44h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8222AA44h case   17:*/		return 0x8222AA48;
		  /* 8222AA48h */ case   18:  		/* rlwimi R9, R11, 2, 28, 31 */
		/* 8222AA48h case   18:*/		cpu::op::rlwimi<0,2,28,31>(regs,&regs.R9,regs.R11);
		/* 8222AA48h case   18:*/		return 0x8222AA4C;
		  /* 8222AA4Ch */ case   19:  		/* stw R9, <#[R10 + 16]> */
		/* 8222AA4Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8222AA4Ch case   19:*/		return 0x8222AA50;
		  /* 8222AA50h */ case   20:  		/* bl -250896 */
		/* 8222AA50h case   20:*/		regs.LR = 0x8222AA54; return 0x821ED640;
		/* 8222AA50h case   20:*/		return 0x8222AA54;
		  /* 8222AA54h */ case   21:  		/* stw R3, <#[R30 + 20]> */
		/* 8222AA54h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 8222AA54h case   21:*/		return 0x8222AA58;
		  /* 8222AA58h */ case   22:  		/* lwz R11, <#[R31 + 12]> */
		/* 8222AA58h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222AA58h case   22:*/		return 0x8222AA5C;
		  /* 8222AA5Ch */ case   23:  		/* subf R11, R11, R30 */
		/* 8222AA5Ch case   23:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8222AA5Ch case   23:*/		return 0x8222AA60;
		  /* 8222AA60h */ case   24:  		/* li R10, 40 */
		/* 8222AA60h case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x28);
		/* 8222AA60h case   24:*/		return 0x8222AA64;
		  /* 8222AA64h */ case   25:  		/* divw R11, R11, R10 */
		/* 8222AA64h case   25:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8222AA64h case   25:*/		return 0x8222AA68;
		  /* 8222AA68h */ case   26:  		/* stw R11, <#[R31 + 648]> */
		/* 8222AA68h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000288) );
		/* 8222AA68h case   26:*/		return 0x8222AA6C;
	}
	return 0x8222AA6C;
} // Block from 8222AA00h-8222AA6Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8222AA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AA6C);
		  /* 8222AA6Ch */ case    0:  		/* li R6, 1 */
		/* 8222AA6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8222AA6Ch case    0:*/		return 0x8222AA70;
		  /* 8222AA70h */ case    1:  		/* lwz R4, <#[R31 + 648]> */
		/* 8222AA70h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000288) );
		/* 8222AA70h case    1:*/		return 0x8222AA74;
		  /* 8222AA74h */ case    2:  		/* li R5, 0 */
		/* 8222AA74h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222AA74h case    2:*/		return 0x8222AA78;
		  /* 8222AA78h */ case    3:  		/* mr R3, R31 */
		/* 8222AA78h case    3:*/		regs.R3 = regs.R31;
		/* 8222AA78h case    3:*/		return 0x8222AA7C;
		  /* 8222AA7Ch */ case    4:  		/* bl -15708 */
		/* 8222AA7Ch case    4:*/		regs.LR = 0x8222AA80; return 0x82226D20;
		/* 8222AA7Ch case    4:*/		return 0x8222AA80;
		  /* 8222AA80h */ case    5:  		/* addi R1, R1, 112 */
		/* 8222AA80h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8222AA80h case    5:*/		return 0x8222AA84;
		  /* 8222AA84h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222AA84h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AA84h case    6:*/		return 0x8222AA88;
		  /* 8222AA88h */ case    7:  		/* mtspr LR, R12 */
		/* 8222AA88h case    7:*/		regs.LR = regs.R12;
		/* 8222AA88h case    7:*/		return 0x8222AA8C;
		  /* 8222AA8Ch */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 8222AA8Ch case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8222AA8Ch case    8:*/		return 0x8222AA90;
		  /* 8222AA90h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 8222AA90h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222AA90h case    9:*/		return 0x8222AA94;
		  /* 8222AA94h */ case   10:  		/* bclr 20, CR0_LT */
		/* 8222AA94h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222AA94h case   10:*/		return 0x8222AA98;
	}
	return 0x8222AA98;
} // Block from 8222AA6Ch-8222AA98h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8222AA98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AA98);
		  /* 8222AA98h */ case    0:  		/* mfspr R12, LR */
		/* 8222AA98h case    0:*/		regs.R12 = regs.LR;
		/* 8222AA98h case    0:*/		return 0x8222AA9C;
		  /* 8222AA9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222AA9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AA9Ch case    1:*/		return 0x8222AAA0;
		  /* 8222AAA0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8222AAA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8222AAA0h case    2:*/		return 0x8222AAA4;
		  /* 8222AAA4h */ case    3:  		/* addi R11, R1, 80 */
		/* 8222AAA4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8222AAA4h case    3:*/		return 0x8222AAA8;
		  /* 8222AAA8h */ case    4:  		/* stw R4, <#[R1 + 156]> */
		/* 8222AAA8h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000009C) );
		/* 8222AAA8h case    4:*/		return 0x8222AAAC;
		  /* 8222AAACh */ case    5:  		/* li R10, 0 */
		/* 8222AAACh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222AAACh case    5:*/		return 0x8222AAB0;
		  /* 8222AAB0h */ case    6:  		/* lfs FR0, <#[R1 + 156]> */
		/* 8222AAB0h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000009C) );
		/* 8222AAB0h case    6:*/		return 0x8222AAB4;
		  /* 8222AAB4h */ case    7:  		/* lis R9, -32256 */
		/* 8222AAB4h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8222AAB4h case    7:*/		return 0x8222AAB8;
		  /* 8222AAB8h */ case    8:  		/* stfs FR0, <#[R1 + 96]> */
		/* 8222AAB8h case    8:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 8222AAB8h case    8:*/		return 0x8222AABC;
		  /* 8222AABCh */ case    9:  		/* stw R10, <#[R11]> */
		/* 8222AABCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222AABCh case    9:*/		return 0x8222AAC0;
		  /* 8222AAC0h */ case   10:  		/* lfs FR0, <#[R9 + 1816]> */
		/* 8222AAC0h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000718) );
		/* 8222AAC0h case   10:*/		return 0x8222AAC4;
		  /* 8222AAC4h */ case   11:  		/* rlwinm R8, R5, 0, 24, 31 */
		/* 8222AAC4h case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R5);
		/* 8222AAC4h case   11:*/		return 0x8222AAC8;
		  /* 8222AAC8h */ case   12:  		/* stfs FR0, <#[R1 + 100]> */
		/* 8222AAC8h case   12:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000064) );
		/* 8222AAC8h case   12:*/		return 0x8222AACC;
		  /* 8222AACCh */ case   13:  		/* addi R5, R1, 96 */
		/* 8222AACCh case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8222AACCh case   13:*/		return 0x8222AAD0;
		  /* 8222AAD0h */ case   14:  		/* stfs FR0, <#[R1 + 104]> */
		/* 8222AAD0h case   14:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 8222AAD0h case   14:*/		return 0x8222AAD4;
		  /* 8222AAD4h */ case   15:  		/* cntlzw R11, R8 */
		/* 8222AAD4h case   15:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R8);
		/* 8222AAD4h case   15:*/		return 0x8222AAD8;
		  /* 8222AAD8h */ case   16:  		/* stfs FR0, <#[R1 + 108]> */
		/* 8222AAD8h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 8222AAD8h case   16:*/		return 0x8222AADC;
		  /* 8222AADCh */ case   17:  		/* li R4, 1 */
		/* 8222AADCh case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8222AADCh case   17:*/		return 0x8222AAE0;
		  /* 8222AAE0h */ case   18:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8222AAE0h case   18:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8222AAE0h case   18:*/		return 0x8222AAE4;
		  /* 8222AAE4h */ case   19:  		/* addi R11, R11, 1 */
		/* 8222AAE4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222AAE4h case   19:*/		return 0x8222AAE8;
		  /* 8222AAE8h */ case   20:  		/* lwz R10, <#[R1 + 80]> */
		/* 8222AAE8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AAE8h case   20:*/		return 0x8222AAEC;
		  /* 8222AAECh */ case   21:  		/* or R6, R11, R10 */
		/* 8222AAECh case   21:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 8222AAECh case   21:*/		return 0x8222AAF0;
		  /* 8222AAF0h */ case   22:  		/* bl -15032 */
		/* 8222AAF0h case   22:*/		regs.LR = 0x8222AAF4; return 0x82227038;
		/* 8222AAF0h case   22:*/		return 0x8222AAF4;
		  /* 8222AAF4h */ case   23:  		/* addi R1, R1, 128 */
		/* 8222AAF4h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8222AAF4h case   23:*/		return 0x8222AAF8;
		  /* 8222AAF8h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222AAF8h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AAF8h case   24:*/		return 0x8222AAFC;
		  /* 8222AAFCh */ case   25:  		/* mtspr LR, R12 */
		/* 8222AAFCh case   25:*/		regs.LR = regs.R12;
		/* 8222AAFCh case   25:*/		return 0x8222AB00;
		  /* 8222AB00h */ case   26:  		/* bclr 20, CR0_LT */
		/* 8222AB00h case   26:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222AB00h case   26:*/		return 0x8222AB04;
	}
	return 0x8222AB04;
} // Block from 8222AA98h-8222AB04h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8222AB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AB04);
		  /* 8222AB04h */ case    0:  		/* nop */
		/* 8222AB04h case    0:*/		cpu::op::nop();
		/* 8222AB04h case    0:*/		return 0x8222AB08;
	}
	return 0x8222AB08;
} // Block from 8222AB04h-8222AB08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222AB08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AB08);
		  /* 8222AB08h */ case    0:  		/* mfspr R12, LR */
		/* 8222AB08h case    0:*/		regs.R12 = regs.LR;
		/* 8222AB08h case    0:*/		return 0x8222AB0C;
		  /* 8222AB0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222AB0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AB0Ch case    1:*/		return 0x8222AB10;
		  /* 8222AB10h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8222AB10h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222AB10h case    2:*/		return 0x8222AB14;
		  /* 8222AB14h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8222AB14h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8222AB14h case    3:*/		return 0x8222AB18;
		  /* 8222AB18h */ case    4:  		/* mr R31, R3 */
		/* 8222AB18h case    4:*/		regs.R31 = regs.R3;
		/* 8222AB18h case    4:*/		return 0x8222AB1C;
		  /* 8222AB1Ch */ case    5:  		/* mr R3, R4 */
		/* 8222AB1Ch case    5:*/		regs.R3 = regs.R4;
		/* 8222AB1Ch case    5:*/		return 0x8222AB20;
		  /* 8222AB20h */ case    6:  		/* mr R4, R5 */
		/* 8222AB20h case    6:*/		regs.R4 = regs.R5;
		/* 8222AB20h case    6:*/		return 0x8222AB24;
		  /* 8222AB24h */ case    7:  		/* mr R5, R6 */
		/* 8222AB24h case    7:*/		regs.R5 = regs.R6;
		/* 8222AB24h case    7:*/		return 0x8222AB28;
		  /* 8222AB28h */ case    8:  		/* bl -144 */
		/* 8222AB28h case    8:*/		regs.LR = 0x8222AB2C; return 0x8222AA98;
		/* 8222AB28h case    8:*/		return 0x8222AB2C;
		  /* 8222AB2Ch */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222AB2Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222AB2Ch case    9:*/		return 0x8222AB30;
		  /* 8222AB30h */ case   10:  		/* li R10, 1 */
		/* 8222AB30h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8222AB30h case   10:*/		return 0x8222AB34;
		  /* 8222AB34h */ case   11:  		/* stw R3, <#[R31]> */
		/* 8222AB34h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8222AB34h case   11:*/		return 0x8222AB38;
		  /* 8222AB38h */ case   12:  		/* mr R3, R31 */
		/* 8222AB38h case   12:*/		regs.R3 = regs.R31;
		/* 8222AB38h case   12:*/		return 0x8222AB3C;
		  /* 8222AB3Ch */ case   13:  		/* rlwimi R11, R10, 0, 16, 14 */
		/* 8222AB3Ch case   13:*/		cpu::op::rlwimi<0,0,16,14>(regs,&regs.R11,regs.R10);
		/* 8222AB3Ch case   13:*/		return 0x8222AB40;
		  /* 8222AB40h */ case   14:  		/* stw R11, <#[R31 + 4]> */
		/* 8222AB40h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222AB40h case   14:*/		return 0x8222AB44;
		  /* 8222AB44h */ case   15:  		/* addi R1, R1, 96 */
		/* 8222AB44h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8222AB44h case   15:*/		return 0x8222AB48;
		  /* 8222AB48h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222AB48h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AB48h case   16:*/		return 0x8222AB4C;
		  /* 8222AB4Ch */ case   17:  		/* mtspr LR, R12 */
		/* 8222AB4Ch case   17:*/		regs.LR = regs.R12;
		/* 8222AB4Ch case   17:*/		return 0x8222AB50;
		  /* 8222AB50h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 8222AB50h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222AB50h case   18:*/		return 0x8222AB54;
		  /* 8222AB54h */ case   19:  		/* bclr 20, CR0_LT */
		/* 8222AB54h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222AB54h case   19:*/		return 0x8222AB58;
	}
	return 0x8222AB58;
} // Block from 8222AB08h-8222AB58h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8222AB58h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AB58);
		  /* 8222AB58h */ case    0:  		/* mfspr R12, LR */
		/* 8222AB58h case    0:*/		regs.R12 = regs.LR;
		/* 8222AB58h case    0:*/		return 0x8222AB5C;
		  /* 8222AB5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222AB5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AB5Ch case    1:*/		return 0x8222AB60;
		  /* 8222AB60h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8222AB60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8222AB60h case    2:*/		return 0x8222AB64;
		  /* 8222AB64h */ case    3:  		/* addi R11, R1, 80 */
		/* 8222AB64h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8222AB64h case    3:*/		return 0x8222AB68;
		  /* 8222AB68h */ case    4:  		/* stfs FR1, <#[R1 + 96]> */
		/* 8222AB68h case    4:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000060) );
		/* 8222AB68h case    4:*/		return 0x8222AB6C;
		  /* 8222AB6Ch */ case    5:  		/* li R10, 0 */
		/* 8222AB6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222AB6Ch case    5:*/		return 0x8222AB70;
		  /* 8222AB70h */ case    6:  		/* stfs FR2, <#[R1 + 100]> */
		/* 8222AB70h case    6:*/		cpu::mem::store32f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000064) );
		/* 8222AB70h case    6:*/		return 0x8222AB74;
		  /* 8222AB74h */ case    7:  		/* stfs FR3, <#[R1 + 104]> */
		/* 8222AB74h case    7:*/		cpu::mem::store32f( regs, regs.FR3, (uint32)(regs.R1 + 0x00000068) );
		/* 8222AB74h case    7:*/		return 0x8222AB78;
		  /* 8222AB78h */ case    8:  		/* addi R5, R1, 96 */
		/* 8222AB78h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8222AB78h case    8:*/		return 0x8222AB7C;
		  /* 8222AB7Ch */ case    9:  		/* stfs FR4, <#[R1 + 108]> */
		/* 8222AB7Ch case    9:*/		cpu::mem::store32f( regs, regs.FR4, (uint32)(regs.R1 + 0x0000006C) );
		/* 8222AB7Ch case    9:*/		return 0x8222AB80;
		  /* 8222AB80h */ case   10:  		/* stw R10, <#[R11]> */
		/* 8222AB80h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222AB80h case   10:*/		return 0x8222AB84;
		  /* 8222AB84h */ case   11:  		/* lwz R6, <#[R1 + 80]> */
		/* 8222AB84h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AB84h case   11:*/		return 0x8222AB88;
		  /* 8222AB88h */ case   12:  		/* bl -15184 */
		/* 8222AB88h case   12:*/		regs.LR = 0x8222AB8C; return 0x82227038;
		/* 8222AB88h case   12:*/		return 0x8222AB8C;
		  /* 8222AB8Ch */ case   13:  		/* addi R1, R1, 128 */
		/* 8222AB8Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8222AB8Ch case   13:*/		return 0x8222AB90;
		  /* 8222AB90h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222AB90h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AB90h case   14:*/		return 0x8222AB94;
		  /* 8222AB94h */ case   15:  		/* mtspr LR, R12 */
		/* 8222AB94h case   15:*/		regs.LR = regs.R12;
		/* 8222AB94h case   15:*/		return 0x8222AB98;
		  /* 8222AB98h */ case   16:  		/* bclr 20, CR0_LT */
		/* 8222AB98h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222AB98h case   16:*/		return 0x8222AB9C;
	}
	return 0x8222AB9C;
} // Block from 8222AB58h-8222AB9Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8222AB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AB9C);
		  /* 8222AB9Ch */ case    0:  		/* nop */
		/* 8222AB9Ch case    0:*/		cpu::op::nop();
		/* 8222AB9Ch case    0:*/		return 0x8222ABA0;
	}
	return 0x8222ABA0;
} // Block from 8222AB9Ch-8222ABA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222ABA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ABA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ABA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ABA0);
		  /* 8222ABA0h */ case    0:  		/* mfspr R12, LR */
		/* 8222ABA0h case    0:*/		regs.R12 = regs.LR;
		/* 8222ABA0h case    0:*/		return 0x8222ABA4;
		  /* 8222ABA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222ABA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222ABA4h case    1:*/		return 0x8222ABA8;
		  /* 8222ABA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8222ABA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8222ABA8h case    2:*/		return 0x8222ABAC;
		  /* 8222ABACh */ case    3:  		/* cmplwi CR6, R5, 1 */
		/* 8222ABACh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 8222ABACh case    3:*/		return 0x8222ABB0;
		  /* 8222ABB0h */ case    4:  		/* bc 12, CR6_LT, 68 */
		/* 8222ABB0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8222ABF4;  }
		/* 8222ABB0h case    4:*/		return 0x8222ABB4;
		  /* 8222ABB4h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 8222ABB4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8222ABDC;  }
		/* 8222ABB4h case    5:*/		return 0x8222ABB8;
		  /* 8222ABB8h */ case    6:  		/* cmplwi CR6, R5, 3 */
		/* 8222ABB8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000003);
		/* 8222ABB8h case    6:*/		return 0x8222ABBC;
		  /* 8222ABBCh */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 8222ABBCh case    7:*/		if ( regs.CR[6].lt ) { return 0x8222ABC8;  }
		/* 8222ABBCh case    7:*/		return 0x8222ABC0;
		  /* 8222ABC0h */ case    8:  		/* li R4, 4800 */
		/* 8222ABC0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222ABC0h case    8:*/		return 0x8222ABC4;
		  /* 8222ABC4h */ case    9:  		/* bl -888156 */
		/* 8222ABC4h case    9:*/		regs.LR = 0x8222ABC8; return 0x82151E68;
		/* 8222ABC4h case    9:*/		return 0x8222ABC8;
	}
	return 0x8222ABC8;
} // Block from 8222ABA0h-8222ABC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222ABC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ABC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ABC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ABC8);
		  /* 8222ABC8h */ case    0:  		/* fctidz FR0, FR1 */
		/* 8222ABC8h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 8222ABC8h case    0:*/		return 0x8222ABCC;
		  /* 8222ABCCh */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 8222ABCCh case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8222ABCCh case    1:*/		return 0x8222ABD0;
		  /* 8222ABD0h */ case    2:  		/* lwz R4, <#[R1 + 84]> */
		/* 8222ABD0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8222ABD0h case    2:*/		return 0x8222ABD4;
		  /* 8222ABD4h */ case    3:  		/* li R5, 0 */
		/* 8222ABD4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222ABD4h case    3:*/		return 0x8222ABD8;
		  /* 8222ABD8h */ case    4:  		/* b 20 */
		/* 8222ABD8h case    4:*/		return 0x8222ABEC;
		/* 8222ABD8h case    4:*/		return 0x8222ABDC;
	}
	return 0x8222ABDC;
} // Block from 8222ABC8h-8222ABDCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222ABDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ABDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ABDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ABDC);
		  /* 8222ABDCh */ case    0:  		/* fctiwz FR0, FR1 */
		/* 8222ABDCh case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR1);
		/* 8222ABDCh case    0:*/		return 0x8222ABE0;
		  /* 8222ABE0h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 8222ABE0h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8222ABE0h case    1:*/		return 0x8222ABE4;
		  /* 8222ABE4h */ case    2:  		/* li R5, 1 */
		/* 8222ABE4h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8222ABE4h case    2:*/		return 0x8222ABE8;
		  /* 8222ABE8h */ case    3:  		/* lwz R4, <#[R1 + 84]> */
		/* 8222ABE8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8222ABE8h case    3:*/		return 0x8222ABEC;
	}
	return 0x8222ABEC;
} // Block from 8222ABDCh-8222ABECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222ABECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ABEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ABEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ABEC);
		  /* 8222ABECh */ case    0:  		/* bl -340 */
		/* 8222ABECh case    0:*/		regs.LR = 0x8222ABF0; return 0x8222AA98;
		/* 8222ABECh case    0:*/		return 0x8222ABF0;
		  /* 8222ABF0h */ case    1:  		/* b 120 */
		/* 8222ABF0h case    1:*/		return 0x8222AC68;
		/* 8222ABF0h case    1:*/		return 0x8222ABF4;
	}
	return 0x8222ABF4;
} // Block from 8222ABECh-8222ABF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222ABF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ABF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ABF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ABF4);
		  /* 8222ABF4h */ case    0:  		/* frsp FR0, FR1 */
		/* 8222ABF4h case    0:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 8222ABF4h case    0:*/		return 0x8222ABF8;
		  /* 8222ABF8h */ case    1:  		/* stfs FR0, <#[R1 + 80]> */
		/* 8222ABF8h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8222ABF8h case    1:*/		return 0x8222ABFC;
		  /* 8222ABFCh */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 8222ABFCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222ABFCh case    2:*/		return 0x8222AC00;
		  /* 8222AC00h */ case    3:  		/* stfs FR0, <#[R1 + 80]> */
		/* 8222AC00h case    3:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AC00h case    3:*/		return 0x8222AC04;
		  /* 8222AC04h */ case    4:  		/* rlwinm. R10, R11, 0, 1, 31 */
		/* 8222AC04h case    4:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R10,regs.R11);
		/* 8222AC04h case    4:*/		return 0x8222AC08;
		  /* 8222AC08h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 8222AC08h case    5:*/		if ( regs.CR[0].eq ) { return 0x8222AC18;  }
		/* 8222AC08h case    5:*/		return 0x8222AC0C;
		  /* 8222AC0Ch */ case    6:  		/* rlwinm. R11, R11, 0, 1, 8 */
		/* 8222AC0Ch case    6:*/		cpu::op::rlwinm<1,0,1,8>(regs,&regs.R11,regs.R11);
		/* 8222AC0Ch case    6:*/		return 0x8222AC10;
		  /* 8222AC10h */ case    7:  		/* li R11, 0 */
		/* 8222AC10h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222AC10h case    7:*/		return 0x8222AC14;
		  /* 8222AC14h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8222AC14h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222AC1C;  }
		/* 8222AC14h case    8:*/		return 0x8222AC18;
	}
	return 0x8222AC18;
} // Block from 8222ABF4h-8222AC18h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222AC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AC18);
		  /* 8222AC18h */ case    0:  		/* li R11, 1 */
		/* 8222AC18h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222AC18h case    0:*/		return 0x8222AC1C;
	}
	return 0x8222AC1C;
} // Block from 8222AC18h-8222AC1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222AC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AC1C);
		  /* 8222AC1Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8222AC1Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8222AC1Ch case    0:*/		return 0x8222AC20;
		  /* 8222AC20h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 8222AC20h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8222AC34;  }
		/* 8222AC20h case    1:*/		return 0x8222AC24;
		  /* 8222AC24h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 8222AC24h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AC24h case    2:*/		return 0x8222AC28;
		  /* 8222AC28h */ case    3:  		/* rlwinm R11, R11, 0, 0, 0 */
		/* 8222AC28h case    3:*/		cpu::op::rlwinm<0,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8222AC28h case    3:*/		return 0x8222AC2C;
		  /* 8222AC2Ch */ case    4:  		/* stw R11, <#[R1 + 80]> */
		/* 8222AC2Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AC2Ch case    4:*/		return 0x8222AC30;
		  /* 8222AC30h */ case    5:  		/* lfs FR0, <#[R1 + 80]> */
		/* 8222AC30h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AC30h case    5:*/		return 0x8222AC34;
	}
	return 0x8222AC34;
} // Block from 8222AC1Ch-8222AC34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8222AC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AC34);
		  /* 8222AC34h */ case    0:  		/* addi R11, R1, 80 */
		/* 8222AC34h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8222AC34h case    0:*/		return 0x8222AC38;
		  /* 8222AC38h */ case    1:  		/* stfs FR0, <#[R1 + 96]> */
		/* 8222AC38h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 8222AC38h case    1:*/		return 0x8222AC3C;
		  /* 8222AC3Ch */ case    2:  		/* lis R10, -32256 */
		/* 8222AC3Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8222AC3Ch case    2:*/		return 0x8222AC40;
		  /* 8222AC40h */ case    3:  		/* li R9, 0 */
		/* 8222AC40h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8222AC40h case    3:*/		return 0x8222AC44;
		  /* 8222AC44h */ case    4:  		/* addi R5, R1, 96 */
		/* 8222AC44h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8222AC44h case    4:*/		return 0x8222AC48;
		  /* 8222AC48h */ case    5:  		/* li R4, 1 */
		/* 8222AC48h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8222AC48h case    5:*/		return 0x8222AC4C;
		  /* 8222AC4Ch */ case    6:  		/* stw R9, <#[R11]> */
		/* 8222AC4Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222AC4Ch case    6:*/		return 0x8222AC50;
		  /* 8222AC50h */ case    7:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 8222AC50h case    7:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 8222AC50h case    7:*/		return 0x8222AC54;
		  /* 8222AC54h */ case    8:  		/* stfs FR0, <#[R1 + 100]> */
		/* 8222AC54h case    8:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000064) );
		/* 8222AC54h case    8:*/		return 0x8222AC58;
		  /* 8222AC58h */ case    9:  		/* stfs FR0, <#[R1 + 104]> */
		/* 8222AC58h case    9:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 8222AC58h case    9:*/		return 0x8222AC5C;
		  /* 8222AC5Ch */ case   10:  		/* stfs FR0, <#[R1 + 108]> */
		/* 8222AC5Ch case   10:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 8222AC5Ch case   10:*/		return 0x8222AC60;
		  /* 8222AC60h */ case   11:  		/* lwz R6, <#[R1 + 80]> */
		/* 8222AC60h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8222AC60h case   11:*/		return 0x8222AC64;
		  /* 8222AC64h */ case   12:  		/* bl -15404 */
		/* 8222AC64h case   12:*/		regs.LR = 0x8222AC68; return 0x82227038;
		/* 8222AC64h case   12:*/		return 0x8222AC68;
	}
	return 0x8222AC68;
} // Block from 8222AC34h-8222AC68h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222AC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AC68);
		  /* 8222AC68h */ case    0:  		/* addi R1, R1, 128 */
		/* 8222AC68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8222AC68h case    0:*/		return 0x8222AC6C;
		  /* 8222AC6Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222AC6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222AC6Ch case    1:*/		return 0x8222AC70;
		  /* 8222AC70h */ case    2:  		/* mtspr LR, R12 */
		/* 8222AC70h case    2:*/		regs.LR = regs.R12;
		/* 8222AC70h case    2:*/		return 0x8222AC74;
		  /* 8222AC74h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8222AC74h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222AC74h case    3:*/		return 0x8222AC78;
	}
	return 0x8222AC78;
} // Block from 8222AC68h-8222AC78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222AC78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AC78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AC78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AC78);
		  /* 8222AC78h */ case    0:  		/* mfspr R12, LR */
		/* 8222AC78h case    0:*/		regs.R12 = regs.LR;
		/* 8222AC78h case    0:*/		return 0x8222AC7C;
		  /* 8222AC7Ch */ case    1:  		/* bl -1677872 */
		/* 8222AC7Ch case    1:*/		regs.LR = 0x8222AC80; return 0x8209124C;
		/* 8222AC7Ch case    1:*/		return 0x8222AC80;
		  /* 8222AC80h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8222AC80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8222AC80h case    2:*/		return 0x8222AC84;
		  /* 8222AC84h */ case    3:  		/* mr R26, R5 */
		/* 8222AC84h case    3:*/		regs.R26 = regs.R5;
		/* 8222AC84h case    3:*/		return 0x8222AC88;
		  /* 8222AC88h */ case    4:  		/* lwz R5, <#[R6 + 4]> */
		/* 8222AC88h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + 0x00000004) );
		/* 8222AC88h case    4:*/		return 0x8222AC8C;
		  /* 8222AC8Ch */ case    5:  		/* mr R28, R3 */
		/* 8222AC8Ch case    5:*/		regs.R28 = regs.R3;
		/* 8222AC8Ch case    5:*/		return 0x8222AC90;
		  /* 8222AC90h */ case    6:  		/* mr R27, R4 */
		/* 8222AC90h case    6:*/		regs.R27 = regs.R4;
		/* 8222AC90h case    6:*/		return 0x8222AC94;
		  /* 8222AC94h */ case    7:  		/* addi R25, R6, 4 */
		/* 8222AC94h case    7:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R6,0x4);
		/* 8222AC94h case    7:*/		return 0x8222AC98;
		  /* 8222AC98h */ case    8:  		/* li R30, 0 */
		/* 8222AC98h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8222AC98h case    8:*/		return 0x8222AC9C;
		  /* 8222AC9Ch */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 8222AC9Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8222AC9Ch case    9:*/		return 0x8222ACA0;
		  /* 8222ACA0h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 8222ACA0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8222AD04;  }
		/* 8222ACA0h case   10:*/		return 0x8222ACA4;
		  /* 8222ACA4h */ case   11:  		/* lwz R11, <#[R5 + 16]> */
		/* 8222ACA4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 8222ACA4h case   11:*/		return 0x8222ACA8;
		  /* 8222ACA8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8222ACA8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222ACA8h case   12:*/		return 0x8222ACAC;
		  /* 8222ACACh */ case   13:  		/* bc 12, CR6_EQ, 80 */
		/* 8222ACACh case   13:*/		if ( regs.CR[6].eq ) { return 0x8222ACFC;  }
		/* 8222ACACh case   13:*/		return 0x8222ACB0;
		  /* 8222ACB0h */ case   14:  		/* lwz R7, <#[R5]> */
		/* 8222ACB0h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000000) );
		/* 8222ACB0h case   14:*/		return 0x8222ACB4;
		  /* 8222ACB4h */ case   15:  		/* rlwinm. R8, R7, 7, 29, 31 */
		/* 8222ACB4h case   15:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R7);
		/* 8222ACB4h case   15:*/		return 0x8222ACB8;
		  /* 8222ACB8h */ case   16:  		/* bc 12, CR0_EQ, 68 */
		/* 8222ACB8h case   16:*/		if ( regs.CR[0].eq ) { return 0x8222ACFC;  }
		/* 8222ACB8h case   16:*/		return 0x8222ACBC;
		  /* 8222ACBCh */ case   17:  		/* li R9, 0 */
		/* 8222ACBCh case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8222ACBCh case   17:*/		return 0x8222ACC0;
		  /* 8222ACC0h */ case   18:  		/* li R11, 0 */
		/* 8222ACC0h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222ACC0h case   18:*/		return 0x8222ACC4;
		  /* 8222ACC4h */ case   19:  		/* cmplwi CR6, R8, 0 */
		/* 8222ACC4h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8222ACC4h case   19:*/		return 0x8222ACC8;
		  /* 8222ACC8h */ case   20:  		/* bc 12, CR6_EQ, 48 */
		/* 8222ACC8h case   20:*/		if ( regs.CR[6].eq ) { return 0x8222ACF8;  }
		/* 8222ACC8h case   20:*/		return 0x8222ACCC;
		  /* 8222ACCCh */ case   21:  		/* li R10, 0 */
		/* 8222ACCCh case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222ACCCh case   21:*/		return 0x8222ACD0;
		  /* 8222ACD0h */ case   22:  		/* rlwinm R4, R7, 27, 24, 31 */
		/* 8222ACD0h case   22:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R4,regs.R7);
		/* 8222ACD0h case   22:*/		return 0x8222ACD4;
		  /* 8222ACD4h */ case   23:  		/* li R3, 1 */
		/* 8222ACD4h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8222ACD4h case   23:*/		return 0x8222ACD8;
		  /* 8222ACD8h */ case   24:  		/* srw R4, R4, R10 */
		/* 8222ACD8h case   24:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R4,regs.R10);
		/* 8222ACD8h case   24:*/		return 0x8222ACDC;
		  /* 8222ACDCh */ case   25:  		/* rlwinm R4, R4, 0, 30, 31 */
		/* 8222ACDCh case   25:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R4);
		/* 8222ACDCh case   25:*/		return 0x8222ACE0;
		  /* 8222ACE0h */ case   26:  		/* addi R11, R11, 1 */
		/* 8222ACE0h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222ACE0h case   26:*/		return 0x8222ACE4;
		  /* 8222ACE4h */ case   27:  		/* slw R4, R3, R4 */
		/* 8222ACE4h case   27:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R3,regs.R4);
		/* 8222ACE4h case   27:*/		return 0x8222ACE8;
		  /* 8222ACE8h */ case   28:  		/* or R9, R4, R9 */
		/* 8222ACE8h case   28:*/		cpu::op::or<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 8222ACE8h case   28:*/		return 0x8222ACEC;
		  /* 8222ACECh */ case   29:  		/* addi R10, R10, 2 */
		/* 8222ACECh case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8222ACECh case   29:*/		return 0x8222ACF0;
		  /* 8222ACF0h */ case   30:  		/* cmplw CR6, R11, R8 */
		/* 8222ACF0h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8222ACF0h case   30:*/		return 0x8222ACF4;
		  /* 8222ACF4h */ case   31:  		/* bc 12, CR6_LT, -36 */
		/* 8222ACF4h case   31:*/		if ( regs.CR[6].lt ) { return 0x8222ACD0;  }
		/* 8222ACF4h case   31:*/		return 0x8222ACF8;
	}
	return 0x8222ACF8;
} // Block from 8222AC78h-8222ACF8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8222ACF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ACF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ACF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ACF8);
		  /* 8222ACF8h */ case    0:  		/* or R30, R9, R30 */
		/* 8222ACF8h case    0:*/		cpu::op::or<0>(regs,&regs.R30,regs.R9,regs.R30);
		/* 8222ACF8h case    0:*/		return 0x8222ACFC;
	}
	return 0x8222ACFC;
} // Block from 8222ACF8h-8222ACFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222ACFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ACFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ACFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ACFC);
		  /* 8222ACFCh */ case    0:  		/* lwz R5, <#[R5 + 8]> */
		/* 8222ACFCh case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000008) );
		/* 8222ACFCh case    0:*/		return 0x8222AD00;
		  /* 8222AD00h */ case    1:  		/* b -100 */
		/* 8222AD00h case    1:*/		return 0x8222AC9C;
		/* 8222AD00h case    1:*/		return 0x8222AD04;
	}
	return 0x8222AD04;
} // Block from 8222ACFCh-8222AD04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222AD04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AD04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AD04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AD04);
		  /* 8222AD04h */ case    0:  		/* mr R4, R6 */
		/* 8222AD04h case    0:*/		regs.R4 = regs.R6;
		/* 8222AD04h case    0:*/		return 0x8222AD08;
		  /* 8222AD08h */ case    1:  		/* mr R3, R28 */
		/* 8222AD08h case    1:*/		regs.R3 = regs.R28;
		/* 8222AD08h case    1:*/		return 0x8222AD0C;
		  /* 8222AD0Ch */ case    2:  		/* bl -732428 */
		/* 8222AD0Ch case    2:*/		regs.LR = 0x8222AD10; return 0x82178000;
		/* 8222AD0Ch case    2:*/		return 0x8222AD10;
		  /* 8222AD10h */ case    3:  		/* lis R11, -28311 */
		/* 8222AD10h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 8222AD10h case    3:*/		return 0x8222AD14;
		  /* 8222AD14h */ case    4:  		/* lis R10, 0 */
		/* 8222AD14h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8222AD14h case    4:*/		return 0x8222AD18;
		  /* 8222AD18h */ case    5:  		/* lwz R8, <#[R3]> */
		/* 8222AD18h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8222AD18h case    5:*/		return 0x8222AD1C;
		  /* 8222AD1Ch */ case    6:  		/* ori R11, R11, 5192 */
		/* 8222AD1Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 8222AD1Ch case    6:*/		return 0x8222AD20;
		  /* 8222AD20h */ case    7:  		/* ori R10, R10, 36262 */
		/* 8222AD20h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 8222AD20h case    7:*/		return 0x8222AD24;
		  /* 8222AD24h */ case    8:  		/* rldicl R9, R30, 0, 32 */
		/* 8222AD24h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R30);
		/* 8222AD24h case    8:*/		return 0x8222AD28;
		  /* 8222AD28h */ case    9:  		/* rldimi R11, R10, 32, 0 */
		/* 8222AD28h case    9:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 8222AD28h case    9:*/		return 0x8222AD2C;
		  /* 8222AD2Ch */ case   10:  		/* mr R31, R3 */
		/* 8222AD2Ch case   10:*/		regs.R31 = regs.R3;
		/* 8222AD2Ch case   10:*/		return 0x8222AD30;
		  /* 8222AD30h */ case   11:  		/* srd R11, R11, R9 */
		/* 8222AD30h case   11:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8222AD30h case   11:*/		return 0x8222AD34;
		  /* 8222AD34h */ case   12:  		/* srd R11, R11, R9 */
		/* 8222AD34h case   12:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8222AD34h case   12:*/		return 0x8222AD38;
		  /* 8222AD38h */ case   13:  		/* srd R11, R11, R9 */
		/* 8222AD38h case   13:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8222AD38h case   13:*/		return 0x8222AD3C;
		  /* 8222AD3Ch */ case   14:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8222AD3Ch case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8222AD3Ch case   14:*/		return 0x8222AD40;
		  /* 8222AD40h */ case   15:  		/* li R10, 0 */
		/* 8222AD40h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222AD40h case   15:*/		return 0x8222AD44;
		  /* 8222AD44h */ case   16:  		/* rlwimi R8, R11, 25, 4, 6 */
		/* 8222AD44h case   16:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R8,regs.R11);
		/* 8222AD44h case   16:*/		return 0x8222AD48;
		  /* 8222AD48h */ case   17:  		/* li R29, 0 */
		/* 8222AD48h case   17:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8222AD48h case   17:*/		return 0x8222AD4C;
		  /* 8222AD4Ch */ case   18:  		/* li R9, 0 */
		/* 8222AD4Ch case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8222AD4Ch case   18:*/		return 0x8222AD50;
		  /* 8222AD50h */ case   19:  		/* stw R8, <#[R3]> */
		/* 8222AD50h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 8222AD50h case   19:*/		return 0x8222AD54;
		  /* 8222AD54h */ case   20:  		/* cmplwi CR6, R30, 0 */
		/* 8222AD54h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8222AD54h case   20:*/		return 0x8222AD58;
		  /* 8222AD58h */ case   21:  		/* bc 12, CR6_EQ, 80 */
		/* 8222AD58h case   21:*/		if ( regs.CR[6].eq ) { return 0x8222ADA8;  }
		/* 8222AD58h case   21:*/		return 0x8222AD5C;
		  /* 8222AD5Ch */ case   22:  		/* li R11, 0 */
		/* 8222AD5Ch case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222AD5Ch case   22:*/		return 0x8222AD60;
		  /* 8222AD60h */ case   23:  		/* li R7, 3 */
		/* 8222AD60h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8222AD60h case   23:*/		return 0x8222AD64;
		  /* 8222AD64h */ case   24:  		/* addi R8, R30, -1 */
		/* 8222AD64h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0xFFFFFFFF);
		/* 8222AD64h case   24:*/		return 0x8222AD68;
		  /* 8222AD68h */ case   25:  		/* slw R6, R7, R11 */
		/* 8222AD68h case   25:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R7,regs.R11);
		/* 8222AD68h case   25:*/		return 0x8222AD6C;
		  /* 8222AD6Ch */ case   26:  		/* andc R8, R30, R8 */
		/* 8222AD6Ch case   26:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R30,regs.R8);
		/* 8222AD6Ch case   26:*/		return 0x8222AD70;
		  /* 8222AD70h */ case   27:  		/* andc R10, R10, R6 */
		/* 8222AD70h case   27:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 8222AD70h case   27:*/		return 0x8222AD74;
		  /* 8222AD74h */ case   28:  		/* cntlzw R6, R8 */
		/* 8222AD74h case   28:*/		cpu::op::cntlzw<0>(regs,&regs.R6,regs.R8);
		/* 8222AD74h case   28:*/		return 0x8222AD78;
		  /* 8222AD78h */ case   29:  		/* subf. R30, R8, R30 */
		/* 8222AD78h case   29:*/		cpu::op::subf<1>(regs,&regs.R30,regs.R8,regs.R30);
		/* 8222AD78h case   29:*/		return 0x8222AD7C;
		  /* 8222AD7Ch */ case   30:  		/* subfic R8, R6, 31 */
		/* 8222AD7Ch case   30:*/		cpu::op::subfic<0>(regs,&regs.R8,regs.R6,0x1F);
		/* 8222AD7Ch case   30:*/		return 0x8222AD80;
		  /* 8222AD80h */ case   31:  		/* rlwinm R6, R8, 1, 0, 30 */
		/* 8222AD80h case   31:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R6,regs.R8);
		/* 8222AD80h case   31:*/		return 0x8222AD84;
		  /* 8222AD84h */ case   32:  		/* slw R8, R8, R11 */
		/* 8222AD84h case   32:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8222AD84h case   32:*/		return 0x8222AD88;
		  /* 8222AD88h */ case   33:  		/* slw R5, R7, R6 */
		/* 8222AD88h case   33:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R7,regs.R6);
		/* 8222AD88h case   33:*/		return 0x8222AD8C;
		  /* 8222AD8Ch */ case   34:  		/* slw R6, R9, R6 */
		/* 8222AD8Ch case   34:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 8222AD8Ch case   34:*/		return 0x8222AD90;
		  /* 8222AD90h */ case   35:  		/* andc R5, R29, R5 */
		/* 8222AD90h case   35:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R29,regs.R5);
		/* 8222AD90h case   35:*/		return 0x8222AD94;
		  /* 8222AD94h */ case   36:  		/* or R10, R10, R8 */
		/* 8222AD94h case   36:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8222AD94h case   36:*/		return 0x8222AD98;
		  /* 8222AD98h */ case   37:  		/* or R29, R5, R6 */
		/* 8222AD98h case   37:*/		cpu::op::or<0>(regs,&regs.R29,regs.R5,regs.R6);
		/* 8222AD98h case   37:*/		return 0x8222AD9C;
		  /* 8222AD9Ch */ case   38:  		/* addi R9, R9, 1 */
		/* 8222AD9Ch case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8222AD9Ch case   38:*/		return 0x8222ADA0;
		  /* 8222ADA0h */ case   39:  		/* addi R11, R11, 2 */
		/* 8222ADA0h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8222ADA0h case   39:*/		return 0x8222ADA4;
		  /* 8222ADA4h */ case   40:  		/* bc 4, CR0_EQ, -64 */
		/* 8222ADA4h case   40:*/		if ( !regs.CR[0].eq ) { return 0x8222AD64;  }
		/* 8222ADA4h case   40:*/		return 0x8222ADA8;
	}
	return 0x8222ADA8;
} // Block from 8222AD04h-8222ADA8h (41 instructions)

//////////////////////////////////////////////////////
// Block at 8222ADA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ADA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ADA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ADA8);
		  /* 8222ADA8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8222ADA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8222ADA8h case    0:*/		return 0x8222ADAC;
		  /* 8222ADACh */ case    1:  		/* mr R6, R31 */
		/* 8222ADACh case    1:*/		regs.R6 = regs.R31;
		/* 8222ADACh case    1:*/		return 0x8222ADB0;
		  /* 8222ADB0h */ case    2:  		/* mr R5, R26 */
		/* 8222ADB0h case    2:*/		regs.R5 = regs.R26;
		/* 8222ADB0h case    2:*/		return 0x8222ADB4;
		  /* 8222ADB4h */ case    3:  		/* rlwimi R11, R10, 5, 19, 26 */
		/* 8222ADB4h case    3:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R10);
		/* 8222ADB4h case    3:*/		return 0x8222ADB8;
		  /* 8222ADB8h */ case    4:  		/* mr R4, R27 */
		/* 8222ADB8h case    4:*/		regs.R4 = regs.R27;
		/* 8222ADB8h case    4:*/		return 0x8222ADBC;
		  /* 8222ADBCh */ case    5:  		/* stw R11, <#[R31]> */
		/* 8222ADBCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8222ADBCh case    5:*/		return 0x8222ADC0;
		  /* 8222ADC0h */ case    6:  		/* mr R3, R28 */
		/* 8222ADC0h case    6:*/		regs.R3 = regs.R28;
		/* 8222ADC0h case    6:*/		return 0x8222ADC4;
		  /* 8222ADC4h */ case    7:  		/* bl -4428 */
		/* 8222ADC4h case    7:*/		regs.LR = 0x8222ADC8; return 0x82229C78;
		/* 8222ADC4h case    7:*/		return 0x8222ADC8;
		  /* 8222ADC8h */ case    8:  		/* lwz R27, <#[R31 + 12]> */
		/* 8222ADC8h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222ADC8h case    8:*/		return 0x8222ADCC;
		  /* 8222ADCCh */ case    9:  		/* addi R30, R27, 4 */
		/* 8222ADCCh case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R27,0x4);
		/* 8222ADCCh case    9:*/		return 0x8222ADD0;
		  /* 8222ADD0h */ case   10:  		/* mr R10, R30 */
		/* 8222ADD0h case   10:*/		regs.R10 = regs.R30;
		/* 8222ADD0h case   10:*/		return 0x8222ADD4;
		  /* 8222ADD4h */ case   11:  		/* lwz R11, <#[R27 + 4]> */
		/* 8222ADD4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8222ADD4h case   11:*/		return 0x8222ADD8;
		  /* 8222ADD8h */ case   12:  		/* b 12 */
		/* 8222ADD8h case   12:*/		return 0x8222ADE4;
		/* 8222ADD8h case   12:*/		return 0x8222ADDC;
		  /* 8222ADDCh */ case   13:  		/* addi R10, R11, 8 */
		/* 8222ADDCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 8222ADDCh case   13:*/		return 0x8222ADE0;
		  /* 8222ADE0h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222ADE0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222ADE0h case   14:*/		return 0x8222ADE4;
	}
	return 0x8222ADE4;
} // Block from 8222ADA8h-8222ADE4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222ADE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222ADE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222ADE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222ADE4);
		  /* 8222ADE4h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 8222ADE4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8222ADE4h case    0:*/		return 0x8222ADE8;
		  /* 8222ADE8h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8222ADE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222ADDC;  }
		/* 8222ADE8h case    1:*/		return 0x8222ADEC;
		  /* 8222ADECh */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222ADECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222ADECh case    2:*/		return 0x8222ADF0;
		  /* 8222ADF0h */ case    3:  		/* li R6, 26 */
		/* 8222ADF0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 8222ADF0h case    3:*/		return 0x8222ADF4;
		  /* 8222ADF4h */ case    4:  		/* li R5, 20 */
		/* 8222ADF4h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 8222ADF4h case    4:*/		return 0x8222ADF8;
		  /* 8222ADF8h */ case    5:  		/* mr R4, R31 */
		/* 8222ADF8h case    5:*/		regs.R4 = regs.R31;
		/* 8222ADF8h case    5:*/		return 0x8222ADFC;
		  /* 8222ADFCh */ case    6:  		/* mr R3, R28 */
		/* 8222ADFCh case    6:*/		regs.R3 = regs.R28;
		/* 8222ADFCh case    6:*/		return 0x8222AE00;
		  /* 8222AE00h */ case    7:  		/* stw R11, <#[R10]> */
		/* 8222AE00h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8222AE00h case    7:*/		return 0x8222AE04;
		  /* 8222AE04h */ case    8:  		/* bl -811372 */
		/* 8222AE04h case    8:*/		regs.LR = 0x8222AE08; return 0x82164C98;
		/* 8222AE04h case    8:*/		return 0x8222AE08;
		  /* 8222AE08h */ case    9:  		/* mr R8, R25 */
		/* 8222AE08h case    9:*/		regs.R8 = regs.R25;
		/* 8222AE08h case    9:*/		return 0x8222AE0C;
		  /* 8222AE0Ch */ case   10:  		/* lwz R11, <#[R8]> */
		/* 8222AE0Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8222AE0Ch case   10:*/		return 0x8222AE10;
		  /* 8222AE10h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8222AE10h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222AE10h case   11:*/		return 0x8222AE14;
		  /* 8222AE14h */ case   12:  		/* bc 12, CR6_EQ, 176 */
		/* 8222AE14h case   12:*/		if ( regs.CR[6].eq ) { return 0x8222AEC4;  }
		/* 8222AE14h case   12:*/		return 0x8222AE18;
		  /* 8222AE18h */ case   13:  		/* lwz R9, <#[R11 + 16]> */
		/* 8222AE18h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8222AE18h case   13:*/		return 0x8222AE1C;
		  /* 8222AE1Ch */ case   14:  		/* cmplwi CR6, R9, 0 */
		/* 8222AE1Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8222AE1Ch case   14:*/		return 0x8222AE20;
		  /* 8222AE20h */ case   15:  		/* bc 12, CR6_EQ, 144 */
		/* 8222AE20h case   15:*/		if ( regs.CR[6].eq ) { return 0x8222AEB0;  }
		/* 8222AE20h case   15:*/		return 0x8222AE24;
		  /* 8222AE24h */ case   16:  		/* lwz R10, <#[R11]> */
		/* 8222AE24h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222AE24h case   16:*/		return 0x8222AE28;
		  /* 8222AE28h */ case   17:  		/* rlwinm. R7, R10, 0, 4, 6 */
		/* 8222AE28h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R7,regs.R10);
		/* 8222AE28h case   17:*/		return 0x8222AE2C;
		  /* 8222AE2Ch */ case   18:  		/* bc 12, CR0_EQ, 132 */
		/* 8222AE2Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x8222AEB0;  }
		/* 8222AE2Ch case   18:*/		return 0x8222AE30;
		  /* 8222AE30h */ case   19:  		/* cmplw CR6, R9, R27 */
		/* 8222AE30h case   19:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R27);
		/* 8222AE30h case   19:*/		return 0x8222AE34;
		  /* 8222AE34h */ case   20:  		/* bc 12, CR6_EQ, 124 */
		/* 8222AE34h case   20:*/		if ( regs.CR[6].eq ) { return 0x8222AEB0;  }
		/* 8222AE34h case   20:*/		return 0x8222AE38;
		  /* 8222AE38h */ case   21:  		/* rlwinm R7, R10, 22, 29, 30 */
		/* 8222AE38h case   21:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R7,regs.R10);
		/* 8222AE38h case   21:*/		return 0x8222AE3C;
		  /* 8222AE3Ch */ case   22:  		/* lwz R9, <#[R11 + 12]> */
		/* 8222AE3Ch case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222AE3Ch case   22:*/		return 0x8222AE40;
		  /* 8222AE40h */ case   23:  		/* rlwinm R6, R10, 24, 29, 30 */
		/* 8222AE40h case   23:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R6,regs.R10);
		/* 8222AE40h case   23:*/		return 0x8222AE44;
		  /* 8222AE44h */ case   24:  		/* srw R7, R29, R7 */
		/* 8222AE44h case   24:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R29,regs.R7);
		/* 8222AE44h case   24:*/		return 0x8222AE48;
		  /* 8222AE48h */ case   25:  		/* srw R6, R29, R6 */
		/* 8222AE48h case   25:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R29,regs.R6);
		/* 8222AE48h case   25:*/		return 0x8222AE4C;
		  /* 8222AE4Ch */ case   26:  		/* rlwimi R6, R7, 2, 28, 29 */
		/* 8222AE4Ch case   26:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R7);
		/* 8222AE4Ch case   26:*/		return 0x8222AE50;
		  /* 8222AE50h */ case   27:  		/* rlwinm R5, R10, 26, 29, 30 */
		/* 8222AE50h case   27:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R5,regs.R10);
		/* 8222AE50h case   27:*/		return 0x8222AE54;
		  /* 8222AE54h */ case   28:  		/* rlwinm R7, R10, 28, 29, 30 */
		/* 8222AE54h case   28:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R10);
		/* 8222AE54h case   28:*/		return 0x8222AE58;
		  /* 8222AE58h */ case   29:  		/* rlwinm R6, R6, 0, 28, 31 */
		/* 8222AE58h case   29:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R6);
		/* 8222AE58h case   29:*/		return 0x8222AE5C;
		  /* 8222AE5Ch */ case   30:  		/* srw R5, R29, R5 */
		/* 8222AE5Ch case   30:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R29,regs.R5);
		/* 8222AE5Ch case   30:*/		return 0x8222AE60;
		  /* 8222AE60h */ case   31:  		/* srw R7, R29, R7 */
		/* 8222AE60h case   31:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R29,regs.R7);
		/* 8222AE60h case   31:*/		return 0x8222AE64;
		  /* 8222AE64h */ case   32:  		/* rlwimi R5, R6, 2, 0, 29 */
		/* 8222AE64h case   32:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R5,regs.R6);
		/* 8222AE64h case   32:*/		return 0x8222AE68;
	}
	return 0x8222AE68;
} // Block from 8222ADE4h-8222AE68h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8222AE68h
// Function '?GetOrCreateInputVariable@Compiler@D3DXShader@@QAA?AVResult@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AE68);
		  /* 8222AE68h */ case    0:  		/* rlwinm R6, R10, 0, 27, 18 */
		/* 8222AE68h case    0:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R6,regs.R10);
		/* 8222AE68h case    0:*/		return 0x8222AE6C;
		  /* 8222AE6Ch */ case    1:  		/* rlwimi R7, R5, 2, 0, 29 */
		/* 8222AE6Ch case    1:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R5);
		/* 8222AE6Ch case    1:*/		return 0x8222AE70;
		  /* 8222AE70h */ case    2:  		/* addi R10, R9, 4 */
		/* 8222AE70h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 8222AE70h case    2:*/		return 0x8222AE74;
		  /* 8222AE74h */ case    3:  		/* rlwinm R7, R7, 5, 0, 26 */
		/* 8222AE74h case    3:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R7,regs.R7);
		/* 8222AE74h case    3:*/		return 0x8222AE78;
		  /* 8222AE78h */ case    4:  		/* or R7, R7, R6 */
		/* 8222AE78h case    4:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 8222AE78h case    4:*/		return 0x8222AE7C;
		  /* 8222AE7Ch */ case    5:  		/* stw R7, <#[R11]> */
		/* 8222AE7Ch case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8222AE7Ch case    5:*/		return 0x8222AE80;
		  /* 8222AE80h */ case    6:  		/* lwz R9, <#[R9 + 4]> */
		/* 8222AE80h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8222AE80h case    6:*/		return 0x8222AE84;
		  /* 8222AE84h */ case    7:  		/* b 12 */
		/* 8222AE84h case    7:*/		return 0x8222AE90;
		/* 8222AE84h case    7:*/		return 0x8222AE88;
		  /* 8222AE88h */ case    8:  		/* addi R10, R9, 8 */
		/* 8222AE88h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 8222AE88h case    8:*/		return 0x8222AE8C;
		  /* 8222AE8Ch */ case    9:  		/* lwz R9, <#[R9 + 8]> */
		/* 8222AE8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8222AE8Ch case    9:*/		return 0x8222AE90;
	}
	return 0x8222AE90;
} // Block from 8222AE68h-8222AE90h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222AE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AE90);
		  /* 8222AE90h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8222AE90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8222AE90h case    0:*/		return 0x8222AE94;
		  /* 8222AE94h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8222AE94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222AE88;  }
		/* 8222AE94h case    1:*/		return 0x8222AE98;
		  /* 8222AE98h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 8222AE98h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8222AE98h case    2:*/		return 0x8222AE9C;
		  /* 8222AE9Ch */ case    3:  		/* stw R9, <#[R10]> */
		/* 8222AE9Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222AE9Ch case    3:*/		return 0x8222AEA0;
		  /* 8222AEA0h */ case    4:  		/* lwz R10, <#[R30]> */
		/* 8222AEA0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8222AEA0h case    4:*/		return 0x8222AEA4;
		  /* 8222AEA4h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 8222AEA4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8222AEA4h case    5:*/		return 0x8222AEA8;
		  /* 8222AEA8h */ case    6:  		/* stw R11, <#[R30]> */
		/* 8222AEA8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222AEA8h case    6:*/		return 0x8222AEAC;
		  /* 8222AEACh */ case    7:  		/* stw R27, <#[R11 + 12]> */
		/* 8222AEACh case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222AEACh case    7:*/		return 0x8222AEB0;
	}
	return 0x8222AEB0;
} // Block from 8222AE90h-8222AEB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222AEB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AEB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AEB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AEB0);
		  /* 8222AEB0h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 8222AEB0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8222AEB0h case    0:*/		return 0x8222AEB4;
		  /* 8222AEB4h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8222AEB4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8222AEB4h case    1:*/		return 0x8222AEB8;
		  /* 8222AEB8h */ case    2:  		/* bc 4, CR6_EQ, -172 */
		/* 8222AEB8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8222AE0C;  }
		/* 8222AEB8h case    2:*/		return 0x8222AEBC;
		  /* 8222AEBCh */ case    3:  		/* addi R8, R11, 8 */
		/* 8222AEBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8222AEBCh case    3:*/		return 0x8222AEC0;
		  /* 8222AEC0h */ case    4:  		/* b -180 */
		/* 8222AEC0h case    4:*/		return 0x8222AE0C;
		/* 8222AEC0h case    4:*/		return 0x8222AEC4;
	}
	return 0x8222AEC4;
} // Block from 8222AEB0h-8222AEC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222AEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AEC4);
		  /* 8222AEC4h */ case    0:  		/* mr R3, R27 */
		/* 8222AEC4h case    0:*/		regs.R3 = regs.R27;
		/* 8222AEC4h case    0:*/		return 0x8222AEC8;
		  /* 8222AEC8h */ case    1:  		/* addi R1, R1, 144 */
		/* 8222AEC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8222AEC8h case    1:*/		return 0x8222AECC;
		  /* 8222AECCh */ case    2:  		/* b -1678384 */
		/* 8222AECCh case    2:*/		return 0x8209129C;
		/* 8222AECCh case    2:*/		return 0x8222AED0;
	}
	return 0x8222AED0;
} // Block from 8222AEC4h-8222AED0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222AED0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AED0);
		  /* 8222AED0h */ case    0:  		/* mfspr R12, LR */
		/* 8222AED0h case    0:*/		regs.R12 = regs.LR;
		/* 8222AED0h case    0:*/		return 0x8222AED4;
		  /* 8222AED4h */ case    1:  		/* bl -1678460 */
		/* 8222AED4h case    1:*/		regs.LR = 0x8222AED8; return 0x82091258;
		/* 8222AED4h case    1:*/		return 0x8222AED8;
		  /* 8222AED8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8222AED8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8222AED8h case    2:*/		return 0x8222AEDC;
		  /* 8222AEDCh */ case    3:  		/* mr R29, R4 */
		/* 8222AEDCh case    3:*/		regs.R29 = regs.R4;
		/* 8222AEDCh case    3:*/		return 0x8222AEE0;
		  /* 8222AEE0h */ case    4:  		/* mr R28, R5 */
		/* 8222AEE0h case    4:*/		regs.R28 = regs.R5;
		/* 8222AEE0h case    4:*/		return 0x8222AEE4;
		  /* 8222AEE4h */ case    5:  		/* mr R5, R7 */
		/* 8222AEE4h case    5:*/		regs.R5 = regs.R7;
		/* 8222AEE4h case    5:*/		return 0x8222AEE8;
		  /* 8222AEE8h */ case    6:  		/* mr R4, R6 */
		/* 8222AEE8h case    6:*/		regs.R4 = regs.R6;
		/* 8222AEE8h case    6:*/		return 0x8222AEEC;
		  /* 8222AEECh */ case    7:  		/* mr R30, R3 */
		/* 8222AEECh case    7:*/		regs.R30 = regs.R3;
		/* 8222AEECh case    7:*/		return 0x8222AEF0;
		  /* 8222AEF0h */ case    8:  		/* bl -732640 */
		/* 8222AEF0h case    8:*/		regs.LR = 0x8222AEF4; return 0x82178110;
		/* 8222AEF0h case    8:*/		return 0x8222AEF4;
		  /* 8222AEF4h */ case    9:  		/* mr R31, R3 */
		/* 8222AEF4h case    9:*/		regs.R31 = regs.R3;
		/* 8222AEF4h case    9:*/		return 0x8222AEF8;
		  /* 8222AEF8h */ case   10:  		/* mr R6, R3 */
		/* 8222AEF8h case   10:*/		regs.R6 = regs.R3;
		/* 8222AEF8h case   10:*/		return 0x8222AEFC;
		  /* 8222AEFCh */ case   11:  		/* mr R5, R28 */
		/* 8222AEFCh case   11:*/		regs.R5 = regs.R28;
		/* 8222AEFCh case   11:*/		return 0x8222AF00;
		  /* 8222AF00h */ case   12:  		/* mr R4, R29 */
		/* 8222AF00h case   12:*/		regs.R4 = regs.R29;
		/* 8222AF00h case   12:*/		return 0x8222AF04;
		  /* 8222AF04h */ case   13:  		/* mr R3, R30 */
		/* 8222AF04h case   13:*/		regs.R3 = regs.R30;
		/* 8222AF04h case   13:*/		return 0x8222AF08;
		  /* 8222AF08h */ case   14:  		/* bl -4752 */
		/* 8222AF08h case   14:*/		regs.LR = 0x8222AF0C; return 0x82229C78;
		/* 8222AF08h case   14:*/		return 0x8222AF0C;
		  /* 8222AF0Ch */ case   15:  		/* lwz R29, <#[R31 + 12]> */
		/* 8222AF0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222AF0Ch case   15:*/		return 0x8222AF10;
		  /* 8222AF10h */ case   16:  		/* addi R10, R29, 4 */
		/* 8222AF10h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x4);
		/* 8222AF10h case   16:*/		return 0x8222AF14;
		  /* 8222AF14h */ case   17:  		/* lwz R11, <#[R29 + 4]> */
		/* 8222AF14h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8222AF14h case   17:*/		return 0x8222AF18;
		  /* 8222AF18h */ case   18:  		/* b 12 */
		/* 8222AF18h case   18:*/		return 0x8222AF24;
		/* 8222AF18h case   18:*/		return 0x8222AF1C;
		  /* 8222AF1Ch */ case   19:  		/* addi R10, R11, 8 */
		/* 8222AF1Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 8222AF1Ch case   19:*/		return 0x8222AF20;
		  /* 8222AF20h */ case   20:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222AF20h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222AF20h case   20:*/		return 0x8222AF24;
	}
	return 0x8222AF24;
} // Block from 8222AED0h-8222AF24h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8222AF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AF24);
		  /* 8222AF24h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 8222AF24h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8222AF24h case    0:*/		return 0x8222AF28;
		  /* 8222AF28h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8222AF28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222AF1C;  }
		/* 8222AF28h case    1:*/		return 0x8222AF2C;
		  /* 8222AF2Ch */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222AF2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222AF2Ch case    2:*/		return 0x8222AF30;
		  /* 8222AF30h */ case    3:  		/* li R6, 26 */
		/* 8222AF30h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 8222AF30h case    3:*/		return 0x8222AF34;
		  /* 8222AF34h */ case    4:  		/* li R5, 20 */
		/* 8222AF34h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 8222AF34h case    4:*/		return 0x8222AF38;
		  /* 8222AF38h */ case    5:  		/* mr R4, R31 */
		/* 8222AF38h case    5:*/		regs.R4 = regs.R31;
		/* 8222AF38h case    5:*/		return 0x8222AF3C;
		  /* 8222AF3Ch */ case    6:  		/* mr R3, R30 */
		/* 8222AF3Ch case    6:*/		regs.R3 = regs.R30;
		/* 8222AF3Ch case    6:*/		return 0x8222AF40;
		  /* 8222AF40h */ case    7:  		/* stw R11, <#[R10]> */
		/* 8222AF40h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8222AF40h case    7:*/		return 0x8222AF44;
		  /* 8222AF44h */ case    8:  		/* bl -811692 */
		/* 8222AF44h case    8:*/		regs.LR = 0x8222AF48; return 0x82164C98;
		/* 8222AF44h case    8:*/		return 0x8222AF48;
		  /* 8222AF48h */ case    9:  		/* mr R3, R29 */
		/* 8222AF48h case    9:*/		regs.R3 = regs.R29;
		/* 8222AF48h case    9:*/		return 0x8222AF4C;
		  /* 8222AF4Ch */ case   10:  		/* addi R1, R1, 128 */
		/* 8222AF4Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8222AF4Ch case   10:*/		return 0x8222AF50;
		  /* 8222AF50h */ case   11:  		/* b -1678504 */
		/* 8222AF50h case   11:*/		return 0x820912A8;
		/* 8222AF50h case   11:*/		return 0x8222AF54;
		  /* 8222AF54h */ case   12:  		/* nop */
		/* 8222AF54h case   12:*/		cpu::op::nop();
		/* 8222AF54h case   12:*/		return 0x8222AF58;
	}
	return 0x8222AF58;
} // Block from 8222AF24h-8222AF58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222AF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AF58);
		  /* 8222AF58h */ case    0:  		/* mfspr R12, LR */
		/* 8222AF58h case    0:*/		regs.R12 = regs.LR;
		/* 8222AF58h case    0:*/		return 0x8222AF5C;
		  /* 8222AF5Ch */ case    1:  		/* bl -1678616 */
		/* 8222AF5Ch case    1:*/		regs.LR = 0x8222AF60; return 0x82091244;
		/* 8222AF5Ch case    1:*/		return 0x8222AF60;
		  /* 8222AF60h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8222AF60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8222AF60h case    2:*/		return 0x8222AF64;
		  /* 8222AF64h */ case    3:  		/* lwz R11, <#[R4 + 12]> */
		/* 8222AF64h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8222AF64h case    3:*/		return 0x8222AF68;
		  /* 8222AF68h */ case    4:  		/* mulli R10, R5, 40 */
		/* 8222AF68h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R5,0x28);
		/* 8222AF68h case    4:*/		return 0x8222AF6C;
		  /* 8222AF6Ch */ case    5:  		/* add R30, R10, R11 */
		/* 8222AF6Ch case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 8222AF6Ch case    5:*/		return 0x8222AF70;
		  /* 8222AF70h */ case    6:  		/* mr R27, R3 */
		/* 8222AF70h case    6:*/		regs.R27 = regs.R3;
		/* 8222AF70h case    6:*/		return 0x8222AF74;
		  /* 8222AF74h */ case    7:  		/* mr R31, R4 */
		/* 8222AF74h case    7:*/		regs.R31 = regs.R4;
		/* 8222AF74h case    7:*/		return 0x8222AF78;
		  /* 8222AF78h */ case    8:  		/* mr R26, R5 */
		/* 8222AF78h case    8:*/		regs.R26 = regs.R5;
		/* 8222AF78h case    8:*/		return 0x8222AF7C;
		  /* 8222AF7Ch */ case    9:  		/* mr R29, R6 */
		/* 8222AF7Ch case    9:*/		regs.R29 = regs.R6;
		/* 8222AF7Ch case    9:*/		return 0x8222AF80;
		  /* 8222AF80h */ case   10:  		/* lwz R11, <#[R30 + 24]> */
		/* 8222AF80h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8222AF80h case   10:*/		return 0x8222AF84;
		  /* 8222AF84h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8222AF84h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222AF84h case   11:*/		return 0x8222AF88;
		  /* 8222AF88h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 8222AF88h case   12:*/		if ( regs.CR[6].eq ) { return 0x8222AFB4;  }
		/* 8222AF88h case   12:*/		return 0x8222AF8C;
		  /* 8222AF8Ch */ case   13:  		/* rlwinm R10, R6, 3, 0, 28 */
		/* 8222AF8Ch case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R6);
		/* 8222AF8Ch case   13:*/		return 0x8222AF90;
		  /* 8222AF90h */ case   14:  		/* add R9, R10, R11 */
		/* 8222AF90h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8222AF90h case   14:*/		return 0x8222AF94;
		  /* 8222AF94h */ case   15:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8222AF94h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8222AF94h case   15:*/		return 0x8222AF98;
		  /* 8222AF98h */ case   16:  		/* lwz R10, <#[R9 + 4]> */
		/* 8222AF98h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8222AF98h case   16:*/		return 0x8222AF9C;
		  /* 8222AF9Ch */ case   17:  		/* stw R11, <#[R3]> */
		/* 8222AF9Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8222AF9Ch case   17:*/		return 0x8222AFA0;
		  /* 8222AFA0h */ case   18:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 8222AFA0h case   18:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 8222AFA0h case   18:*/		return 0x8222AFA4;
		  /* 8222AFA4h */ case   19:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8222AFA4h case   19:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8222AFA4h case   19:*/		return 0x8222AFA8;
		  /* 8222AFA8h */ case   20:  		/* stw R10, <#[R3 + 4]> */
		/* 8222AFA8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8222AFA8h case   20:*/		return 0x8222AFAC;
		  /* 8222AFACh */ case   21:  		/* cmpwi CR6, R11, 1 */
		/* 8222AFACh case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 8222AFACh case   21:*/		return 0x8222AFB0;
		  /* 8222AFB0h */ case   22:  		/* bc 12, CR6_EQ, 856 */
		/* 8222AFB0h case   22:*/		if ( regs.CR[6].eq ) { return 0x8222B308;  }
		/* 8222AFB0h case   22:*/		return 0x8222AFB4;
	}
	return 0x8222AFB4;
} // Block from 8222AF58h-8222AFB4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8222AFB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222AFB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222AFB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222AFB4);
		  /* 8222AFB4h */ case    0:  		/* addi R10, R1, 104 */
		/* 8222AFB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 8222AFB4h case    0:*/		return 0x8222AFB8;
		  /* 8222AFB8h */ case    1:  		/* addi R9, R1, 120 */
		/* 8222AFB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x78);
		/* 8222AFB8h case    1:*/		return 0x8222AFBC;
		  /* 8222AFBCh */ case    2:  		/* addi R8, R1, 108 */
		/* 8222AFBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x6C);
		/* 8222AFBCh case    2:*/		return 0x8222AFC0;
		  /* 8222AFC0h */ case    3:  		/* addi R7, R1, 112 */
		/* 8222AFC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 8222AFC0h case    3:*/		return 0x8222AFC4;
		  /* 8222AFC4h */ case    4:  		/* addi R6, R1, 100 */
		/* 8222AFC4h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 8222AFC4h case    4:*/		return 0x8222AFC8;
		  /* 8222AFC8h */ case    5:  		/* mr R5, R29 */
		/* 8222AFC8h case    5:*/		regs.R5 = regs.R29;
		/* 8222AFC8h case    5:*/		return 0x8222AFCC;
		  /* 8222AFCCh */ case    6:  		/* mr R4, R26 */
		/* 8222AFCCh case    6:*/		regs.R4 = regs.R26;
		/* 8222AFCCh case    6:*/		return 0x8222AFD0;
		  /* 8222AFD0h */ case    7:  		/* mr R3, R31 */
		/* 8222AFD0h case    7:*/		regs.R3 = regs.R31;
		/* 8222AFD0h case    7:*/		return 0x8222AFD4;
		  /* 8222AFD4h */ case    8:  		/* bl -40684 */
		/* 8222AFD4h case    8:*/		regs.LR = 0x8222AFD8; return 0x822210E8;
		/* 8222AFD4h case    8:*/		return 0x8222AFD8;
		  /* 8222AFD8h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8222AFD8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222AFD8h case    9:*/		return 0x8222AFDC;
		  /* 8222AFDCh */ case   10:  		/* lwz R10, <#[R30 + 24]> */
		/* 8222AFDCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8222AFDCh case   10:*/		return 0x8222AFE0;
		  /* 8222AFE0h */ case   11:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 8222AFE0h case   11:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 8222AFE0h case   11:*/		return 0x8222AFE4;
		  /* 8222AFE4h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 8222AFE4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222AFE4h case   12:*/		return 0x8222AFE8;
		  /* 8222AFE8h */ case   13:  		/* bc 4, CR6_EQ, 24 */
		/* 8222AFE8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8222B000;  }
		/* 8222AFE8h case   13:*/		return 0x8222AFEC;
		  /* 8222AFECh */ case   14:  		/* li R5, 0 */
		/* 8222AFECh case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222AFECh case   14:*/		return 0x8222AFF0;
		  /* 8222AFF0h */ case   15:  		/* rlwinm R4, R11, 3, 0, 28 */
		/* 8222AFF0h case   15:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R11);
		/* 8222AFF0h case   15:*/		return 0x8222AFF4;
		  /* 8222AFF4h */ case   16:  		/* mr R3, R31 */
		/* 8222AFF4h case   16:*/		regs.R3 = regs.R31;
		/* 8222AFF4h case   16:*/		return 0x8222AFF8;
		  /* 8222AFF8h */ case   17:  		/* bl -649680 */
		/* 8222AFF8h case   17:*/		regs.LR = 0x8222AFFC; return 0x8218C628;
		/* 8222AFF8h case   17:*/		return 0x8222AFFC;
		  /* 8222AFFCh */ case   18:  		/* stw R3, <#[R30 + 24]> */
		/* 8222AFFCh case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 8222AFFCh case   18:*/		return 0x8222B000;
	}
	return 0x8222B000;
} // Block from 8222AFB4h-8222B000h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8222B000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B000);
		  /* 8222B000h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 8222B000h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8222B000h case    0:*/		return 0x8222B004;
		  /* 8222B004h */ case    1:  		/* mr R3, R31 */
		/* 8222B004h case    1:*/		regs.R3 = regs.R31;
		/* 8222B004h case    1:*/		return 0x8222B008;
		  /* 8222B008h */ case    2:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8222B008h case    2:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8222B008h case    2:*/		return 0x8222B00C;
		  /* 8222B00Ch */ case    3:  		/* bc 4, CR0_EQ, 296 */
		/* 8222B00Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8222B134;  }
		/* 8222B00Ch case    3:*/		return 0x8222B010;
		  /* 8222B010h */ case    4:  		/* lwz R25, <#[R1 + 104]> */
		/* 8222B010h case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000068) );
		/* 8222B010h case    4:*/		return 0x8222B014;
		  /* 8222B014h */ case    5:  		/* li R5, 0 */
		/* 8222B014h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222B014h case    5:*/		return 0x8222B018;
		  /* 8222B018h */ case    6:  		/* li R4, 124 */
		/* 8222B018h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x7C);
		/* 8222B018h case    6:*/		return 0x8222B01C;
		  /* 8222B01Ch */ case    7:  		/* mr R6, R25 */
		/* 8222B01Ch case    7:*/		regs.R6 = regs.R25;
		/* 8222B01Ch case    7:*/		return 0x8222B020;
		  /* 8222B020h */ case    8:  		/* bl -814064 */
		/* 8222B020h case    8:*/		regs.LR = 0x8222B024; return 0x82164430;
		/* 8222B020h case    8:*/		return 0x8222B024;
		  /* 8222B024h */ case    9:  		/* mr R4, R3 */
		/* 8222B024h case    9:*/		regs.R4 = regs.R3;
		/* 8222B024h case    9:*/		return 0x8222B028;
		  /* 8222B028h */ case   10:  		/* mr R3, R31 */
		/* 8222B028h case   10:*/		regs.R3 = regs.R31;
		/* 8222B028h case   10:*/		return 0x8222B02C;
		  /* 8222B02Ch */ case   11:  		/* li R5, 35 */
		/* 8222B02Ch case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x23);
		/* 8222B02Ch case   11:*/		return 0x8222B030;
		  /* 8222B030h */ case   12:  		/* bl -779400 */
		/* 8222B030h case   12:*/		regs.LR = 0x8222B034; return 0x8216CBA8;
		/* 8222B030h case   12:*/		return 0x8222B034;
		  /* 8222B034h */ case   13:  		/* lwz R11, <#[R31 + 4]> */
		/* 8222B034h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8222B034h case   13:*/		return 0x8222B038;
		  /* 8222B038h */ case   14:  		/* lwz R8, <#[R30 + 28]> */
		/* 8222B038h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222B038h case   14:*/		return 0x8222B03C;
		  /* 8222B03Ch */ case   15:  		/* rlwinm R28, R29, 3, 0, 28 */
		/* 8222B03Ch case   15:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R28,regs.R29);
		/* 8222B03Ch case   15:*/		return 0x8222B040;
		  /* 8222B040h */ case   16:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8222B040h case   16:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222B040h case   16:*/		return 0x8222B044;
		  /* 8222B044h */ case   17:  		/* lwz R24, <#[R1 + 108]> */
		/* 8222B044h case   17:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x0000006C) );
		/* 8222B044h case   17:*/		return 0x8222B048;
		  /* 8222B048h */ case   18:  		/* lwz R23, <#[R1 + 100]> */
		/* 8222B048h case   18:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000064) );
		/* 8222B048h case   18:*/		return 0x8222B04C;
		  /* 8222B04Ch */ case   19:  		/* mr R4, R31 */
		/* 8222B04Ch case   19:*/		regs.R4 = regs.R31;
		/* 8222B04Ch case   19:*/		return 0x8222B050;
		  /* 8222B050h */ case   20:  		/* addic R10, R10, -1 */
		/* 8222B050h case   20:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8222B050h case   20:*/		return 0x8222B054;
		  /* 8222B054h */ case   21:  		/* lwz R9, <#[R1 + 112]> */
		/* 8222B054h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000070) );
		/* 8222B054h case   21:*/		return 0x8222B058;
		  /* 8222B058h */ case   22:  		/* mr R10, R24 */
		/* 8222B058h case   22:*/		regs.R10 = regs.R24;
		/* 8222B058h case   22:*/		return 0x8222B05C;
		  /* 8222B05Ch */ case   23:  		/* stw R25, <#[R1 + 84]> */
		/* 8222B05Ch case   23:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 8222B05Ch case   23:*/		return 0x8222B060;
		  /* 8222B060h */ case   24:  		/* lwzx R6, <#[R8 + R28]> */
		/* 8222B060h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 8222B060h case   24:*/		return 0x8222B064;
		  /* 8222B064h */ case   25:  		/* subfe R7, R7, R7 */
		/* 8222B064h case   25:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R7);
		/* 8222B064h case   25:*/		return 0x8222B068;
		  /* 8222B068h */ case   26:  		/* mr R8, R23 */
		/* 8222B068h case   26:*/		regs.R8 = regs.R23;
		/* 8222B068h case   26:*/		return 0x8222B06C;
		  /* 8222B06Ch */ case   27:  		/* rlwinm R5, R6, 14, 30, 31 */
		/* 8222B06Ch case   27:*/		cpu::op::rlwinm<0,14,30,31>(regs,&regs.R5,regs.R6);
		/* 8222B06Ch case   27:*/		return 0x8222B070;
		  /* 8222B070h */ case   28:  		/* and R6, R7, R11 */
		/* 8222B070h case   28:*/		cpu::op::and<0>(regs,&regs.R6,regs.R7,regs.R11);
		/* 8222B070h case   28:*/		return 0x8222B074;
		  /* 8222B074h */ case   29:  		/* stw R5, <#[R1 + 92]> */
		/* 8222B074h case   29:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 8222B074h case   29:*/		return 0x8222B078;
		  /* 8222B078h */ case   30:  		/* mr R7, R26 */
		/* 8222B078h case   30:*/		regs.R7 = regs.R26;
		/* 8222B078h case   30:*/		return 0x8222B07C;
		  /* 8222B07Ch */ case   31:  		/* li R5, 124 */
		/* 8222B07Ch case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x7C);
		/* 8222B07Ch case   31:*/		return 0x8222B080;
		  /* 8222B080h */ case   32:  		/* mr R29, R3 */
		/* 8222B080h case   32:*/		regs.R29 = regs.R3;
		/* 8222B080h case   32:*/		return 0x8222B084;
		  /* 8222B084h */ case   33:  		/* bl -26588 */
		/* 8222B084h case   33:*/		regs.LR = 0x8222B088; return 0x822248A8;
		/* 8222B084h case   33:*/		return 0x8222B088;
		  /* 8222B088h */ case   34:  		/* lwz R10, <#[R31 + 4]> */
		/* 8222B088h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8222B088h case   34:*/		return 0x8222B08C;
		  /* 8222B08Ch */ case   35:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 8222B08Ch case   35:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 8222B08Ch case   35:*/		return 0x8222B090;
		  /* 8222B090h */ case   36:  		/* rlwinm R8, R10, 0, 31, 31 */
		/* 8222B090h case   36:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R10);
		/* 8222B090h case   36:*/		return 0x8222B094;
		  /* 8222B094h */ case   37:  		/* addic R8, R8, -1 */
		/* 8222B094h case   37:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 8222B094h case   37:*/		return 0x8222B098;
		  /* 8222B098h */ case   38:  		/* addi R11, R11, 36 */
		/* 8222B098h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8222B098h case   38:*/		return 0x8222B09C;
		  /* 8222B09Ch */ case   39:  		/* subfe R8, R8, R8 */
		/* 8222B09Ch case   39:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 8222B09Ch case   39:*/		return 0x8222B0A0;
		  /* 8222B0A0h */ case   40:  		/* addi R7, R11, -36 */
		/* 8222B0A0h case   40:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8222B0A0h case   40:*/		return 0x8222B0A4;
		  /* 8222B0A4h */ case   41:  		/* and R10, R8, R10 */
		/* 8222B0A4h case   41:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8222B0A4h case   41:*/		return 0x8222B0A8;
		  /* 8222B0A8h */ case   42:  		/* addi R9, R11, 4 */
		/* 8222B0A8h case   42:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8222B0A8h case   42:*/		return 0x8222B0AC;
		  /* 8222B0ACh */ case   43:  		/* addi R8, R10, 16 */
		/* 8222B0ACh case   43:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x10);
		/* 8222B0ACh case   43:*/		return 0x8222B0B0;
		  /* 8222B0B0h */ case   44:  		/* addi R8, R8, -36 */
		/* 8222B0B0h case   44:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFDC);
		/* 8222B0B0h case   44:*/		return 0x8222B0B4;
		  /* 8222B0B4h */ case   45:  		/* lwz R6, <#[R10 + 16]> */
		/* 8222B0B4h case   45:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 8222B0B4h case   45:*/		return 0x8222B0B8;
		  /* 8222B0B8h */ case   46:  		/* ori R8, R8, 1 */
		/* 8222B0B8h case   46:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8222B0B8h case   46:*/		return 0x8222B0BC;
		  /* 8222B0BCh */ case   47:  		/* stw R6, <#[R11]> */
		/* 8222B0BCh case   47:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B0BCh case   47:*/		return 0x8222B0C0;
		  /* 8222B0C0h */ case   48:  		/* lwz R6, <#[R10 + 16]> */
		/* 8222B0C0h case   48:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 8222B0C0h case   48:*/		return 0x8222B0C4;
		  /* 8222B0C4h */ case   49:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8222B0C4h case   49:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8222B0C4h case   49:*/		return 0x8222B0C8;
		  /* 8222B0C8h */ case   50:  		/* stw R7, <#[R6]> */
		/* 8222B0C8h case   50:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 8222B0C8h case   50:*/		return 0x8222B0CC;
		  /* 8222B0CCh */ case   51:  		/* stw R8, <#[R11 + 4]> */
		/* 8222B0CCh case   51:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8222B0CCh case   51:*/		return 0x8222B0D0;
		  /* 8222B0D0h */ case   52:  		/* stw R9, <#[R10 + 16]> */
		/* 8222B0D0h case   52:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8222B0D0h case   52:*/		return 0x8222B0D4;
		  /* 8222B0D4h */ case   53:  		/* lwz R11, <#[R30 + 4]> */
		/* 8222B0D4h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8222B0D4h case   53:*/		return 0x8222B0D8;
		  /* 8222B0D8h */ case   54:  		/* rlwinm. R11, R11, 28, 29, 31 */
		/* 8222B0D8h case   54:*/		cpu::op::rlwinm<1,28,29,31>(regs,&regs.R11,regs.R11);
		/* 8222B0D8h case   54:*/		return 0x8222B0DC;
		  /* 8222B0DCh */ case   55:  		/* bc 4, CR0_EQ, 16 */
		/* 8222B0DCh case   55:*/		if ( !regs.CR[0].eq ) { return 0x8222B0EC;  }
		/* 8222B0DCh case   55:*/		return 0x8222B0E0;
		  /* 8222B0E0h */ case   56:  		/* lwz R11, <#[R31 + 40]> */
		/* 8222B0E0h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8222B0E0h case   56:*/		return 0x8222B0E4;
		  /* 8222B0E4h */ case   57:  		/* oris R11, R11, 2 */
		/* 8222B0E4h case   57:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8222B0E4h case   57:*/		return 0x8222B0E8;
		  /* 8222B0E8h */ case   58:  		/* b 20 */
		/* 8222B0E8h case   58:*/		return 0x8222B0FC;
		/* 8222B0E8h case   58:*/		return 0x8222B0EC;
	}
	return 0x8222B0EC;
} // Block from 8222B000h-8222B0ECh (59 instructions)

//////////////////////////////////////////////////////
// Block at 8222B0ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B0EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B0EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B0EC);
		  /* 8222B0ECh */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 8222B0ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8222B0ECh case    0:*/		return 0x8222B0F0;
		  /* 8222B0F0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8222B0F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222B100;  }
		/* 8222B0F0h case    1:*/		return 0x8222B0F4;
		  /* 8222B0F4h */ case    2:  		/* lwz R11, <#[R31 + 40]> */
		/* 8222B0F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8222B0F4h case    2:*/		return 0x8222B0F8;
		  /* 8222B0F8h */ case    3:  		/* ori R11, R11, 1 */
		/* 8222B0F8h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222B0F8h case    3:*/		return 0x8222B0FC;
	}
	return 0x8222B0FC;
} // Block from 8222B0ECh-8222B0FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B0FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B0FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B0FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B0FC);
		  /* 8222B0FCh */ case    0:  		/* stw R11, <#[R31 + 40]> */
		/* 8222B0FCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 8222B0FCh case    0:*/		return 0x8222B100;
	}
	return 0x8222B100;
} // Block from 8222B0FCh-8222B100h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B100);
		  /* 8222B100h */ case    0:  		/* mr R8, R29 */
		/* 8222B100h case    0:*/		regs.R8 = regs.R29;
		/* 8222B100h case    0:*/		return 0x8222B104;
		  /* 8222B104h */ case    1:  		/* lwz R7, <#[R1 + 120]> */
		/* 8222B104h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000078) );
		/* 8222B104h case    1:*/		return 0x8222B108;
		  /* 8222B108h */ case    2:  		/* mr R6, R24 */
		/* 8222B108h case    2:*/		regs.R6 = regs.R24;
		/* 8222B108h case    2:*/		return 0x8222B10C;
		  /* 8222B10Ch */ case    3:  		/* mr R5, R23 */
		/* 8222B10Ch case    3:*/		regs.R5 = regs.R23;
		/* 8222B10Ch case    3:*/		return 0x8222B110;
		  /* 8222B110h */ case    4:  		/* mr R4, R30 */
		/* 8222B110h case    4:*/		regs.R4 = regs.R30;
		/* 8222B110h case    4:*/		return 0x8222B114;
		  /* 8222B114h */ case    5:  		/* mr R3, R31 */
		/* 8222B114h case    5:*/		regs.R3 = regs.R31;
		/* 8222B114h case    5:*/		return 0x8222B118;
		  /* 8222B118h */ case    6:  		/* bl -40688 */
		/* 8222B118h case    6:*/		regs.LR = 0x8222B11C; return 0x82221228;
		/* 8222B118h case    6:*/		return 0x8222B11C;
		  /* 8222B11Ch */ case    7:  		/* lwz R11, <#[R30 + 24]> */
		/* 8222B11Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8222B11Ch case    7:*/		return 0x8222B120;
		  /* 8222B120h */ case    8:  		/* add R10, R28, R11 */
		/* 8222B120h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R11);
		/* 8222B120h case    8:*/		return 0x8222B124;
		  /* 8222B124h */ case    9:  		/* lwzx R11, <#[R28 + R11]> */
		/* 8222B124h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8222B124h case    9:*/		return 0x8222B128;
		  /* 8222B128h */ case   10:  		/* lwz R10, <#[R10 + 4]> */
		/* 8222B128h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8222B128h case   10:*/		return 0x8222B12C;
		  /* 8222B12Ch */ case   11:  		/* stw R11, <#[R27]> */
		/* 8222B12Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8222B12Ch case   11:*/		return 0x8222B130;
		  /* 8222B130h */ case   12:  		/* b 468 */
		/* 8222B130h case   12:*/		return 0x8222B304;
		/* 8222B130h case   12:*/		return 0x8222B134;
	}
	return 0x8222B134;
} // Block from 8222B100h-8222B134h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8222B134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B134);
		  /* 8222B134h */ case    0:  		/* lwz R11, <#[R30 + 36]> */
		/* 8222B134h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 8222B134h case    0:*/		return 0x8222B138;
		  /* 8222B138h */ case    1:  		/* lwz R11, <#[R11 + 32]> */
		/* 8222B138h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 8222B138h case    1:*/		return 0x8222B13C;
		  /* 8222B13Ch */ case    2:  		/* lwz R4, <#[R11 + 16]> */
		/* 8222B13Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 8222B13Ch case    2:*/		return 0x8222B140;
		  /* 8222B140h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 8222B140h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8222B140h case    3:*/		return 0x8222B144;
		  /* 8222B144h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 8222B144h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8222B158;  }
		/* 8222B144h case    4:*/		return 0x8222B148;
		  /* 8222B148h */ case    5:  		/* lwz R11, <#[R11 + 20]> */
		/* 8222B148h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8222B148h case    5:*/		return 0x8222B14C;
		  /* 8222B14Ch */ case    6:  		/* li R4, 3619 */
		/* 8222B14Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xE23);
		/* 8222B14Ch case    6:*/		return 0x8222B150;
		  /* 8222B150h */ case    7:  		/* lwz R5, <#[R11 + 24]> */
		/* 8222B150h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000018) );
		/* 8222B150h case    7:*/		return 0x8222B154;
		  /* 8222B154h */ case    8:  		/* bl -889580 */
		/* 8222B154h case    8:*/		regs.LR = 0x8222B158; return 0x82151E68;
		/* 8222B154h case    8:*/		return 0x8222B158;
	}
	return 0x8222B158;
} // Block from 8222B134h-8222B158h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222B158h
// Function '?GetOrCreateInputInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@IIPBDI_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B158);
		  /* 8222B158h */ case    0:  		/* li R5, 18 */
		/* 8222B158h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x12);
		/* 8222B158h case    0:*/		return 0x8222B15C;
		  /* 8222B15Ch */ case    1:  		/* bl -259404 */
		/* 8222B15Ch case    1:*/		regs.LR = 0x8222B160; return 0x821EBC10;
		/* 8222B15Ch case    1:*/		return 0x8222B160;
		  /* 8222B160h */ case    2:  		/* lwz R28, <#[R3 + 20]> */
		/* 8222B160h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000014) );
		/* 8222B160h case    2:*/		return 0x8222B164;
		  /* 8222B164h */ case    3:  		/* mr R3, R31 */
		/* 8222B164h case    3:*/		regs.R3 = regs.R31;
		/* 8222B164h case    3:*/		return 0x8222B168;
		  /* 8222B168h */ case    4:  		/* lwz R11, <#[R28 + 4]> */
		/* 8222B168h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8222B168h case    4:*/		return 0x8222B16C;
		  /* 8222B16Ch */ case    5:  		/* cmpwi CR6, R11, 3 */
		/* 8222B16Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8222B16Ch case    5:*/		return 0x8222B170;
		  /* 8222B170h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 8222B170h case    6:*/		if ( regs.CR[6].eq ) { return 0x8222B17C;  }
		/* 8222B170h case    6:*/		return 0x8222B174;
		  /* 8222B174h */ case    7:  		/* li R4, 4801 */
		/* 8222B174h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8222B174h case    7:*/		return 0x8222B178;
		  /* 8222B178h */ case    8:  		/* bl -889616 */
		/* 8222B178h case    8:*/		regs.LR = 0x8222B17C; return 0x82151E68;
		/* 8222B178h case    8:*/		return 0x8222B17C;
	}
	return 0x8222B17C;
} // Block from 8222B158h-8222B17Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222B17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B17C);
		  /* 8222B17Ch */ case    0:  		/* li R25, 0 */
		/* 8222B17Ch case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8222B17Ch case    0:*/		return 0x8222B180;
		  /* 8222B180h */ case    1:  		/* addi R8, R1, 96 */
		/* 8222B180h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8222B180h case    1:*/		return 0x8222B184;
		  /* 8222B184h */ case    2:  		/* stb R25, <#[R1 + 96]> */
		/* 8222B184h case    2:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x00000060) );
		/* 8222B184h case    2:*/		return 0x8222B188;
		  /* 8222B188h */ case    3:  		/* addi R7, R1, 120 */
		/* 8222B188h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 8222B188h case    3:*/		return 0x8222B18C;
		  /* 8222B18Ch */ case    4:  		/* addi R6, R1, 108 */
		/* 8222B18Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x6C);
		/* 8222B18Ch case    4:*/		return 0x8222B190;
		  /* 8222B190h */ case    5:  		/* li R5, 3 */
		/* 8222B190h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8222B190h case    5:*/		return 0x8222B194;
		  /* 8222B194h */ case    6:  		/* mr R4, R28 */
		/* 8222B194h case    6:*/		regs.R4 = regs.R28;
		/* 8222B194h case    6:*/		return 0x8222B198;
		  /* 8222B198h */ case    7:  		/* bl -654408 */
		/* 8222B198h case    7:*/		regs.LR = 0x8222B19C; return 0x8218B550;
		/* 8222B198h case    7:*/		return 0x8222B19C;
		  /* 8222B19Ch */ case    8:  		/* lbz R11, <#[R1 + 96]> */
		/* 8222B19Ch case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8222B19Ch case    8:*/		return 0x8222B1A0;
		  /* 8222B1A0h */ case    9:  		/* mr R3, R31 */
		/* 8222B1A0h case    9:*/		regs.R3 = regs.R31;
		/* 8222B1A0h case    9:*/		return 0x8222B1A4;
		  /* 8222B1A4h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 8222B1A4h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8222B1A4h case   10:*/		return 0x8222B1A8;
		  /* 8222B1A8h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 8222B1A8h case   11:*/		if ( regs.CR[0].eq ) { return 0x8222B1B8;  }
		/* 8222B1A8h case   11:*/		return 0x8222B1AC;
		  /* 8222B1ACh */ case   12:  		/* li R4, 4509 */
		/* 8222B1ACh case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x119D);
		/* 8222B1ACh case   12:*/		return 0x8222B1B0;
		  /* 8222B1B0h */ case   13:  		/* lwz R5, <#[R28 + 24]> */
		/* 8222B1B0h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000018) );
		/* 8222B1B0h case   13:*/		return 0x8222B1B4;
		  /* 8222B1B4h */ case   14:  		/* bl -889676 */
		/* 8222B1B4h case   14:*/		regs.LR = 0x8222B1B8; return 0x82151E68;
		/* 8222B1B4h case   14:*/		return 0x8222B1B8;
	}
	return 0x8222B1B8;
} // Block from 8222B17Ch-8222B1B8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222B1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B1B8);
		  /* 8222B1B8h */ case    0:  		/* lwz R4, <#[R31 + 564]> */
		/* 8222B1B8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 8222B1B8h case    0:*/		return 0x8222B1BC;
		  /* 8222B1BCh */ case    1:  		/* li R8, 1 */
		/* 8222B1BCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8222B1BCh case    1:*/		return 0x8222B1C0;
		  /* 8222B1C0h */ case    2:  		/* li R7, 0 */
		/* 8222B1C0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8222B1C0h case    2:*/		return 0x8222B1C4;
		  /* 8222B1C4h */ case    3:  		/* addi R5, R4, 16 */
		/* 8222B1C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x10);
		/* 8222B1C4h case    3:*/		return 0x8222B1C8;
		  /* 8222B1C8h */ case    4:  		/* li R6, 120 */
		/* 8222B1C8h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x78);
		/* 8222B1C8h case    4:*/		return 0x8222B1CC;
		  /* 8222B1CCh */ case    5:  		/* bl -26676 */
		/* 8222B1CCh case    5:*/		regs.LR = 0x8222B1D0; return 0x82224998;
		/* 8222B1CCh case    5:*/		return 0x8222B1D0;
		  /* 8222B1D0h */ case    6:  		/* mr R11, R3 */
		/* 8222B1D0h case    6:*/		regs.R11 = regs.R3;
		/* 8222B1D0h case    6:*/		return 0x8222B1D4;
		  /* 8222B1D4h */ case    7:  		/* li R28, 1 */
		/* 8222B1D4h case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8222B1D4h case    7:*/		return 0x8222B1D8;
		  /* 8222B1D8h */ case    8:  		/* mr R3, R31 */
		/* 8222B1D8h case    8:*/		regs.R3 = regs.R31;
		/* 8222B1D8h case    8:*/		return 0x8222B1DC;
		  /* 8222B1DCh */ case    9:  		/* mr R4, R11 */
		/* 8222B1DCh case    9:*/		regs.R4 = regs.R11;
		/* 8222B1DCh case    9:*/		return 0x8222B1E0;
		  /* 8222B1E0h */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 8222B1E0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8222B1E0h case   10:*/		return 0x8222B1E4;
		  /* 8222B1E4h */ case   11:  		/* rlwimi R10, R28, 1, 27, 30 */
		/* 8222B1E4h case   11:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R10,regs.R28);
		/* 8222B1E4h case   11:*/		return 0x8222B1E8;
		  /* 8222B1E8h */ case   12:  		/* stw R10, <#[R11 + 8]> */
		/* 8222B1E8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8222B1E8h case   12:*/		return 0x8222B1EC;
		  /* 8222B1ECh */ case   13:  		/* bl -733676 */
		/* 8222B1ECh case   13:*/		regs.LR = 0x8222B1F0; return 0x82178000;
		/* 8222B1ECh case   13:*/		return 0x8222B1F0;
		  /* 8222B1F0h */ case   14:  		/* addi R11, R1, 112 */
		/* 8222B1F0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8222B1F0h case   14:*/		return 0x8222B1F4;
		  /* 8222B1F4h */ case   15:  		/* lis R10, -32256 */
		/* 8222B1F4h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8222B1F4h case   15:*/		return 0x8222B1F8;
		  /* 8222B1F8h */ case   16:  		/* lwz R9, <#[R3]> */
		/* 8222B1F8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8222B1F8h case   16:*/		return 0x8222B1FC;
		  /* 8222B1FCh */ case   17:  		/* mr R24, R3 */
		/* 8222B1FCh case   17:*/		regs.R24 = regs.R3;
		/* 8222B1FCh case   17:*/		return 0x8222B200;
		  /* 8222B200h */ case   18:  		/* rlwinm R23, R29, 3, 0, 28 */
		/* 8222B200h case   18:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R23,regs.R29);
		/* 8222B200h case   18:*/		return 0x8222B204;
		  /* 8222B204h */ case   19:  		/* addi R5, R1, 128 */
		/* 8222B204h case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 8222B204h case   19:*/		return 0x8222B208;
		  /* 8222B208h */ case   20:  		/* stw R25, <#[R11]> */
		/* 8222B208h case   20:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B208h case   20:*/		return 0x8222B20C;
		  /* 8222B20Ch */ case   21:  		/* oris R11, R9, 16384 */
		/* 8222B20Ch case   21:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R9,0x4000);
		/* 8222B20Ch case   21:*/		return 0x8222B210;
		  /* 8222B210h */ case   22:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 8222B210h case   22:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 8222B210h case   22:*/		return 0x8222B214;
		  /* 8222B214h */ case   23:  		/* mr R10, R11 */
		/* 8222B214h case   23:*/		regs.R10 = regs.R11;
		/* 8222B214h case   23:*/		return 0x8222B218;
		  /* 8222B218h */ case   24:  		/* stw R11, <#[R24]> */
		/* 8222B218h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8222B218h case   24:*/		return 0x8222B21C;
		  /* 8222B21Ch */ case   25:  		/* lwz R11, <#[R1 + 120]> */
		/* 8222B21Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8222B21Ch case   25:*/		return 0x8222B220;
		  /* 8222B220h */ case   26:  		/* stfs FR0, <#[R1 + 132]> */
		/* 8222B220h case   26:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000084) );
		/* 8222B220h case   26:*/		return 0x8222B224;
		  /* 8222B224h */ case   27:  		/* rlwimi R10, R11, 17, 7, 14 */
		/* 8222B224h case   27:*/		cpu::op::rlwimi<0,17,7,14>(regs,&regs.R10,regs.R11);
		/* 8222B224h case   27:*/		return 0x8222B228;
		  /* 8222B228h */ case   28:  		/* stfs FR0, <#[R1 + 136]> */
		/* 8222B228h case   28:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 8222B228h case   28:*/		return 0x8222B22C;
		  /* 8222B22Ch */ case   29:  		/* rlwimi R10, R28, 13, 15, 18 */
		/* 8222B22Ch case   29:*/		cpu::op::rlwimi<0,13,15,18>(regs,&regs.R10,regs.R28);
		/* 8222B22Ch case   29:*/		return 0x8222B230;
		  /* 8222B230h */ case   30:  		/* lwz R6, <#[R1 + 112]> */
		/* 8222B230h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000070) );
		/* 8222B230h case   30:*/		return 0x8222B234;
		  /* 8222B234h */ case   31:  		/* stfs FR0, <#[R1 + 140]> */
		/* 8222B234h case   31:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000008C) );
		/* 8222B234h case   31:*/		return 0x8222B238;
		  /* 8222B238h */ case   32:  		/* li R4, 1 */
		/* 8222B238h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8222B238h case   32:*/		return 0x8222B23C;
		  /* 8222B23Ch */ case   33:  		/* stw R10, <#[R24]> */
		/* 8222B23Ch case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 8222B23Ch case   33:*/		return 0x8222B240;
		  /* 8222B240h */ case   34:  		/* mr R3, R31 */
		/* 8222B240h case   34:*/		regs.R3 = regs.R31;
		/* 8222B240h case   34:*/		return 0x8222B244;
		  /* 8222B244h */ case   35:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222B244h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222B244h case   35:*/		return 0x8222B248;
		  /* 8222B248h */ case   36:  		/* lwzx R11, <#[R23 + R11]> */
		/* 8222B248h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R11 + 0x00000000) );
		/* 8222B248h case   36:*/		return 0x8222B24C;
		  /* 8222B24Ch */ case   37:  		/* rlwinm R11, R11, 28, 18, 31 */
		/* 8222B24Ch case   37:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R11,regs.R11);
		/* 8222B24Ch case   37:*/		return 0x8222B250;
		  /* 8222B250h */ case   38:  		/* std R11, <#[R1 + 112]> */
		/* 8222B250h case   38:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8222B250h case   38:*/		return 0x8222B254;
		  /* 8222B254h */ case   39:  		/* lfd FR0, <#[R1 + 112]> */
		/* 8222B254h case   39:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 8222B254h case   39:*/		return 0x8222B258;
		  /* 8222B258h */ case   40:  		/* fcfid FR0, FR0 */
		/* 8222B258h case   40:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8222B258h case   40:*/		return 0x8222B25C;
		  /* 8222B25Ch */ case   41:  		/* frsp FR0, FR0 */
		/* 8222B25Ch case   41:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8222B25Ch case   41:*/		return 0x8222B260;
		  /* 8222B260h */ case   42:  		/* stfs FR0, <#[R1 + 128]> */
		/* 8222B260h case   42:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000080) );
		/* 8222B260h case   42:*/		return 0x8222B264;
		  /* 8222B264h */ case   43:  		/* bl -16940 */
		/* 8222B264h case   43:*/		regs.LR = 0x8222B268; return 0x82227038;
		/* 8222B264h case   43:*/		return 0x8222B268;
		  /* 8222B268h */ case   44:  		/* mr R4, R3 */
		/* 8222B268h case   44:*/		regs.R4 = regs.R3;
		/* 8222B268h case   44:*/		return 0x8222B26C;
		  /* 8222B26Ch */ case   45:  		/* li R5, 0 */
		/* 8222B26Ch case   45:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222B26Ch case   45:*/		return 0x8222B270;
		  /* 8222B270h */ case   46:  		/* mr R3, R31 */
		/* 8222B270h case   46:*/		regs.R3 = regs.R31;
		/* 8222B270h case   46:*/		return 0x8222B274;
		  /* 8222B274h */ case   47:  		/* bl -733540 */
		/* 8222B274h case   47:*/		regs.LR = 0x8222B278; return 0x82178110;
		/* 8222B274h case   47:*/		return 0x8222B278;
		  /* 8222B278h */ case   48:  		/* lwz R4, <#[R31 + 564]> */
		/* 8222B278h case   48:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 8222B278h case   48:*/		return 0x8222B27C;
		  /* 8222B27Ch */ case   49:  		/* mr R7, R3 */
		/* 8222B27Ch case   49:*/		regs.R7 = regs.R3;
		/* 8222B27Ch case   49:*/		return 0x8222B280;
		  /* 8222B280h */ case   50:  		/* addi R5, R4, 24 */
		/* 8222B280h case   50:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 8222B280h case   50:*/		return 0x8222B284;
		  /* 8222B284h */ case   51:  		/* mr R6, R24 */
		/* 8222B284h case   51:*/		regs.R6 = regs.R24;
		/* 8222B284h case   51:*/		return 0x8222B288;
		  /* 8222B288h */ case   52:  		/* mr R3, R31 */
		/* 8222B288h case   52:*/		regs.R3 = regs.R31;
		/* 8222B288h case   52:*/		return 0x8222B28C;
		  /* 8222B28Ch */ case   53:  		/* bl -20084 */
		/* 8222B28Ch case   53:*/		regs.LR = 0x8222B290; return 0x82226418;
		/* 8222B28Ch case   53:*/		return 0x8222B290;
		  /* 8222B290h */ case   54:  		/* mr R29, R3 */
		/* 8222B290h case   54:*/		regs.R29 = regs.R3;
		/* 8222B290h case   54:*/		return 0x8222B294;
		  /* 8222B294h */ case   55:  		/* mr R3, R31 */
		/* 8222B294h case   55:*/		regs.R3 = regs.R31;
		/* 8222B294h case   55:*/		return 0x8222B298;
		  /* 8222B298h */ case   56:  		/* lwz R11, <#[R29 + 8]> */
		/* 8222B298h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8222B298h case   56:*/		return 0x8222B29C;
		  /* 8222B29Ch */ case   57:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8222B29Ch case   57:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8222B29Ch case   57:*/		return 0x8222B2A0;
		  /* 8222B2A0h */ case   58:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8222B2A0h case   58:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8222B2A0h case   58:*/		return 0x8222B2A4;
		  /* 8222B2A4h */ case   59:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8222B2A4h case   59:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8222B2A4h case   59:*/		return 0x8222B2A8;
		  /* 8222B2A8h */ case   60:  		/* bl -814712 */
		/* 8222B2A8h case   60:*/		regs.LR = 0x8222B2AC; return 0x82164430;
		/* 8222B2A8h case   60:*/		return 0x8222B2AC;
		  /* 8222B2ACh */ case   61:  		/* addi R11, R29, -24 */
		/* 8222B2ACh case   61:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFE8);
		/* 8222B2ACh case   61:*/		return 0x8222B2B0;
		  /* 8222B2B0h */ case   62:  		/* lwz R10, <#[R1 + 100]> */
		/* 8222B2B0h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8222B2B0h case   62:*/		return 0x8222B2B4;
		  /* 8222B2B4h */ case   63:  		/* add R11, R3, R11 */
		/* 8222B2B4h case   63:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8222B2B4h case   63:*/		return 0x8222B2B8;
		  /* 8222B2B8h */ case   64:  		/* stw R29, <#[R27]> */
		/* 8222B2B8h case   64:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 8222B2B8h case   64:*/		return 0x8222B2BC;
		  /* 8222B2BCh */ case   65:  		/* lwz R9, <#[R11]> */
		/* 8222B2BCh case   65:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B2BCh case   65:*/		return 0x8222B2C0;
		  /* 8222B2C0h */ case   66:  		/* lwz R8, <#[R11 + 16]> */
		/* 8222B2C0h case   66:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8222B2C0h case   66:*/		return 0x8222B2C4;
		  /* 8222B2C4h */ case   67:  		/* rlwimi R9, R28, 0, 27, 31 */
		/* 8222B2C4h case   67:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R9,regs.R28);
		/* 8222B2C4h case   67:*/		return 0x8222B2C8;
		  /* 8222B2C8h */ case   68:  		/* lwz R7, <#[R11 + 12]> */
		/* 8222B2C8h case   68:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222B2C8h case   68:*/		return 0x8222B2CC;
		  /* 8222B2CCh */ case   69:  		/* rlwimi R8, R10, 15, 3, 16 */
		/* 8222B2CCh case   69:*/		cpu::op::rlwimi<0,15,3,16>(regs,&regs.R8,regs.R10);
		/* 8222B2CCh case   69:*/		return 0x8222B2D0;
		  /* 8222B2D0h */ case   70:  		/* lwz R10, <#[R27 + 4]> */
		/* 8222B2D0h case   70:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 8222B2D0h case   70:*/		return 0x8222B2D4;
		  /* 8222B2D4h */ case   71:  		/* stw R9, <#[R11]> */
		/* 8222B2D4h case   71:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B2D4h case   71:*/		return 0x8222B2D8;
		  /* 8222B2D8h */ case   72:  		/* oris R9, R7, 2 */
		/* 8222B2D8h case   72:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R7,0x2);
		/* 8222B2D8h case   72:*/		return 0x8222B2DC;
		  /* 8222B2DCh */ case   73:  		/* rlwimi R8, R26, 0, 17, 31 */
		/* 8222B2DCh case   73:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R8,regs.R26);
		/* 8222B2DCh case   73:*/		return 0x8222B2E0;
		  /* 8222B2E0h */ case   74:  		/* stw R9, <#[R11 + 12]> */
		/* 8222B2E0h case   74:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8222B2E0h case   74:*/		return 0x8222B2E4;
		  /* 8222B2E4h */ case   75:  		/* stw R8, <#[R11 + 16]> */
		/* 8222B2E4h case   75:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8222B2E4h case   75:*/		return 0x8222B2E8;
		  /* 8222B2E8h */ case   76:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222B2E8h case   76:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222B2E8h case   76:*/		return 0x8222B2EC;
		  /* 8222B2ECh */ case   77:  		/* lwzx R11, <#[R23 + R11]> */
		/* 8222B2ECh case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + regs.R11 + 0x00000000) );
		/* 8222B2ECh case   77:*/		return 0x8222B2F0;
		  /* 8222B2F0h */ case   78:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8222B2F0h case   78:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8222B2F0h case   78:*/		return 0x8222B2F4;
		  /* 8222B2F4h */ case   79:  		/* cntlzw R11, R11 */
		/* 8222B2F4h case   79:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8222B2F4h case   79:*/		return 0x8222B2F8;
		  /* 8222B2F8h */ case   80:  		/* subfic R11, R11, 31 */
		/* 8222B2F8h case   80:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 8222B2F8h case   80:*/		return 0x8222B2FC;
		  /* 8222B2FCh */ case   81:  		/* rlwimi R10, R11, 2, 16, 29 */
		/* 8222B2FCh case   81:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R10,regs.R11);
		/* 8222B2FCh case   81:*/		return 0x8222B300;
		  /* 8222B300h */ case   82:  		/* rlwimi R10, R28, 0, 30, 14 */
		/* 8222B300h case   82:*/		cpu::op::rlwimi<0,0,30,14>(regs,&regs.R10,regs.R28);
		/* 8222B300h case   82:*/		return 0x8222B304;
	}
	return 0x8222B304;
} // Block from 8222B1B8h-8222B304h (83 instructions)

//////////////////////////////////////////////////////
// Block at 8222B304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B304);
		  /* 8222B304h */ case    0:  		/* stw R10, <#[R27 + 4]> */
		/* 8222B304h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 8222B304h case    0:*/		return 0x8222B308;
	}
	return 0x8222B308;
} // Block from 8222B304h-8222B308h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B308);
		  /* 8222B308h */ case    0:  		/* mr R3, R27 */
		/* 8222B308h case    0:*/		regs.R3 = regs.R27;
		/* 8222B308h case    0:*/		return 0x8222B30C;
		  /* 8222B30Ch */ case    1:  		/* addi R1, R1, 224 */
		/* 8222B30Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8222B30Ch case    1:*/		return 0x8222B310;
		  /* 8222B310h */ case    2:  		/* b -1679484 */
		/* 8222B310h case    2:*/		return 0x82091294;
		/* 8222B310h case    2:*/		return 0x8222B314;
		  /* 8222B314h */ case    3:  		/* nop */
		/* 8222B314h case    3:*/		cpu::op::nop();
		/* 8222B314h case    3:*/		return 0x8222B318;
	}
	return 0x8222B318;
} // Block from 8222B308h-8222B318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B318h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B318);
		  /* 8222B318h */ case    0:  		/* mfspr R12, LR */
		/* 8222B318h case    0:*/		regs.R12 = regs.LR;
		/* 8222B318h case    0:*/		return 0x8222B31C;
		  /* 8222B31Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8222B31Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222B31Ch case    1:*/		return 0x8222B320;
		  /* 8222B320h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8222B320h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222B320h case    2:*/		return 0x8222B324;
		  /* 8222B324h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8222B324h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8222B324h case    3:*/		return 0x8222B328;
		  /* 8222B328h */ case    4:  		/* lwz R10, <#[R4 + 12]> */
		/* 8222B328h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 8222B328h case    4:*/		return 0x8222B32C;
		  /* 8222B32Ch */ case    5:  		/* mulli R9, R5, 40 */
		/* 8222B32Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R5,0x28);
		/* 8222B32Ch case    5:*/		return 0x8222B330;
		  /* 8222B330h */ case    6:  		/* lwzx R10, <#[R9 + R10]> */
		/* 8222B330h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8222B330h case    6:*/		return 0x8222B334;
		  /* 8222B334h */ case    7:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8222B334h case    7:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8222B334h case    7:*/		return 0x8222B338;
		  /* 8222B338h */ case    8:  		/* mr R31, R3 */
		/* 8222B338h case    8:*/		regs.R31 = regs.R3;
		/* 8222B338h case    8:*/		return 0x8222B33C;
		  /* 8222B33Ch */ case    9:  		/* mr R3, R4 */
		/* 8222B33Ch case    9:*/		regs.R3 = regs.R4;
		/* 8222B33Ch case    9:*/		return 0x8222B340;
		  /* 8222B340h */ case   10:  		/* mr R11, R5 */
		/* 8222B340h case   10:*/		regs.R11 = regs.R5;
		/* 8222B340h case   10:*/		return 0x8222B344;
		  /* 8222B344h */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 8222B344h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8222B344h case   11:*/		return 0x8222B348;
		  /* 8222B348h */ case   12:  		/* bc 12, CR6_EQ, 84 */
		/* 8222B348h case   12:*/		if ( regs.CR[6].eq ) { return 0x8222B39C;  }
		/* 8222B348h case   12:*/		return 0x8222B34C;
		  /* 8222B34Ch */ case   13:  		/* cmplwi CR6, R10, 2 */
		/* 8222B34Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 8222B34Ch case   13:*/		return 0x8222B350;
		  /* 8222B350h */ case   14:  		/* bc 12, CR6_EQ, 48 */
		/* 8222B350h case   14:*/		if ( regs.CR[6].eq ) { return 0x8222B380;  }
		/* 8222B350h case   14:*/		return 0x8222B354;
		  /* 8222B354h */ case   15:  		/* cmplwi CR6, R10, 3 */
		/* 8222B354h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8222B354h case   15:*/		return 0x8222B358;
		  /* 8222B358h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 8222B358h case   16:*/		if ( regs.CR[6].eq ) { return 0x8222B36C;  }
		/* 8222B358h case   16:*/		return 0x8222B35C;
		  /* 8222B35Ch */ case   17:  		/* cmplwi CR6, R10, 4 */
		/* 8222B35Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 8222B35Ch case   17:*/		return 0x8222B360;
		  /* 8222B360h */ case   18:  		/* bc 12, CR6_EQ, 32 */
		/* 8222B360h case   18:*/		if ( regs.CR[6].eq ) { return 0x8222B380;  }
		/* 8222B360h case   18:*/		return 0x8222B364;
		  /* 8222B364h */ case   19:  		/* li R4, 4800 */
		/* 8222B364h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8222B364h case   19:*/		return 0x8222B368;
		  /* 8222B368h */ case   20:  		/* bl -890112 */
		/* 8222B368h case   20:*/		regs.LR = 0x8222B36C; return 0x82151E68;
		/* 8222B368h case   20:*/		return 0x8222B36C;
	}
	return 0x8222B36C;
} // Block from 8222B318h-8222B36Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8222B36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B36C);
		  /* 8222B36Ch */ case    0:  		/* mr R4, R3 */
		/* 8222B36Ch case    0:*/		regs.R4 = regs.R3;
		/* 8222B36Ch case    0:*/		return 0x8222B370;
		  /* 8222B370h */ case    1:  		/* mr R5, R11 */
		/* 8222B370h case    1:*/		regs.R5 = regs.R11;
		/* 8222B370h case    1:*/		return 0x8222B374;
		  /* 8222B374h */ case    2:  		/* mr R3, R31 */
		/* 8222B374h case    2:*/		regs.R3 = regs.R31;
		/* 8222B374h case    2:*/		return 0x8222B378;
		  /* 8222B378h */ case    3:  		/* bl -3880 */
		/* 8222B378h case    3:*/		regs.LR = 0x8222B37C; return 0x8222A450;
		/* 8222B378h case    3:*/		return 0x8222B37C;
		  /* 8222B37Ch */ case    4:  		/* b 48 */
		/* 8222B37Ch case    4:*/		return 0x8222B3AC;
		/* 8222B37Ch case    4:*/		return 0x8222B380;
	}
	return 0x8222B380;
} // Block from 8222B36Ch-8222B380h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222B380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B380);
		  /* 8222B380h */ case    0:  		/* lwz R5, <#[R3 + 564]> */
		/* 8222B380h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000234) );
		/* 8222B380h case    0:*/		return 0x8222B384;
		  /* 8222B384h */ case    1:  		/* mr R7, R6 */
		/* 8222B384h case    1:*/		regs.R7 = regs.R6;
		/* 8222B384h case    1:*/		return 0x8222B388;
		  /* 8222B388h */ case    2:  		/* mr R4, R3 */
		/* 8222B388h case    2:*/		regs.R4 = regs.R3;
		/* 8222B388h case    2:*/		return 0x8222B38C;
		  /* 8222B38Ch */ case    3:  		/* mr R6, R11 */
		/* 8222B38Ch case    3:*/		regs.R6 = regs.R11;
		/* 8222B38Ch case    3:*/		return 0x8222B390;
		  /* 8222B390h */ case    4:  		/* mr R3, R31 */
		/* 8222B390h case    4:*/		regs.R3 = regs.R31;
		/* 8222B390h case    4:*/		return 0x8222B394;
		  /* 8222B394h */ case    5:  		/* bl -22860 */
		/* 8222B394h case    5:*/		regs.LR = 0x8222B398; return 0x82225A48;
		/* 8222B394h case    5:*/		return 0x8222B398;
		  /* 8222B398h */ case    6:  		/* b 20 */
		/* 8222B398h case    6:*/		return 0x8222B3AC;
		/* 8222B398h case    6:*/		return 0x8222B39C;
	}
	return 0x8222B39C;
} // Block from 8222B380h-8222B39Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222B39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B39C);
		  /* 8222B39Ch */ case    0:  		/* mr R4, R3 */
		/* 8222B39Ch case    0:*/		regs.R4 = regs.R3;
		/* 8222B39Ch case    0:*/		return 0x8222B3A0;
		  /* 8222B3A0h */ case    1:  		/* mr R5, R11 */
		/* 8222B3A0h case    1:*/		regs.R5 = regs.R11;
		/* 8222B3A0h case    1:*/		return 0x8222B3A4;
		  /* 8222B3A4h */ case    2:  		/* mr R3, R31 */
		/* 8222B3A4h case    2:*/		regs.R3 = regs.R31;
		/* 8222B3A4h case    2:*/		return 0x8222B3A8;
		  /* 8222B3A8h */ case    3:  		/* bl -1104 */
		/* 8222B3A8h case    3:*/		regs.LR = 0x8222B3AC; return 0x8222AF58;
		/* 8222B3A8h case    3:*/		return 0x8222B3AC;
	}
	return 0x8222B3AC;
} // Block from 8222B39Ch-8222B3ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B3AC);
		  /* 8222B3ACh */ case    0:  		/* mr R3, R31 */
		/* 8222B3ACh case    0:*/		regs.R3 = regs.R31;
		/* 8222B3ACh case    0:*/		return 0x8222B3B0;
		  /* 8222B3B0h */ case    1:  		/* addi R1, R1, 96 */
		/* 8222B3B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8222B3B0h case    1:*/		return 0x8222B3B4;
		  /* 8222B3B4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8222B3B4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8222B3B4h case    2:*/		return 0x8222B3B8;
	}
	return 0x8222B3B8;
} // Block from 8222B3ACh-8222B3B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222B3B8h
// Function '?GetOrCreateDiagnosticBaseIndexVariableInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B3B8);
		  /* 8222B3B8h */ case    0:  		/* mtspr LR, R12 */
		/* 8222B3B8h case    0:*/		regs.LR = regs.R12;
		/* 8222B3B8h case    0:*/		return 0x8222B3BC;
		  /* 8222B3BCh */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 8222B3BCh case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8222B3BCh case    1:*/		return 0x8222B3C0;
		  /* 8222B3C0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8222B3C0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8222B3C0h case    2:*/		return 0x8222B3C4;
	}
	return 0x8222B3C4;
} // Block from 8222B3B8h-8222B3C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222B3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B3C4);
		  /* 8222B3C4h */ case    0:  		/* nop */
		/* 8222B3C4h case    0:*/		cpu::op::nop();
		/* 8222B3C4h case    0:*/		return 0x8222B3C8;
	}
	return 0x8222B3C8;
} // Block from 8222B3C4h-8222B3C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B3C8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B3C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B3C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B3C8);
		  /* 8222B3C8h */ case    0:  		/* mfspr R12, LR */
		/* 8222B3C8h case    0:*/		regs.R12 = regs.LR;
		/* 8222B3C8h case    0:*/		return 0x8222B3CC;
		  /* 8222B3CCh */ case    1:  		/* bl -1679740 */
		/* 8222B3CCh case    1:*/		regs.LR = 0x8222B3D0; return 0x82091250;
		/* 8222B3CCh case    1:*/		return 0x8222B3D0;
		  /* 8222B3D0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8222B3D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8222B3D0h case    2:*/		return 0x8222B3D4;
		  /* 8222B3D4h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8222B3D4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8222B3D4h case    3:*/		return 0x8222B3D8;
		  /* 8222B3D8h */ case    4:  		/* mr R28, R3 */
		/* 8222B3D8h case    4:*/		regs.R28 = regs.R3;
		/* 8222B3D8h case    4:*/		return 0x8222B3DC;
		  /* 8222B3DCh */ case    5:  		/* mr R30, R4 */
		/* 8222B3DCh case    5:*/		regs.R30 = regs.R4;
		/* 8222B3DCh case    5:*/		return 0x8222B3E0;
		  /* 8222B3E0h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8222B3E0h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8222B3E0h case    6:*/		return 0x8222B3E4;
		  /* 8222B3E4h */ case    7:  		/* mr R27, R5 */
		/* 8222B3E4h case    7:*/		regs.R27 = regs.R5;
		/* 8222B3E4h case    7:*/		return 0x8222B3E8;
		  /* 8222B3E8h */ case    8:  		/* mr R26, R6 */
		/* 8222B3E8h case    8:*/		regs.R26 = regs.R6;
		/* 8222B3E8h case    8:*/		return 0x8222B3EC;
		  /* 8222B3ECh */ case    9:  		/* cmplwi CR6, R11, 16000 */
		/* 8222B3ECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8222B3ECh case    9:*/		return 0x8222B3F0;
		  /* 8222B3F0h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8222B3F0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8222B400;  }
		/* 8222B3F0h case   10:*/		return 0x8222B3F4;
		  /* 8222B3F4h */ case   11:  		/* lwz R11, <#[R3 + 44]> */
		/* 8222B3F4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 8222B3F4h case   11:*/		return 0x8222B3F8;
		  /* 8222B3F8h */ case   12:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 8222B3F8h case   12:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 8222B3F8h case   12:*/		return 0x8222B3FC;
		  /* 8222B3FCh */ case   13:  		/* bc 4, CR0_EQ, 584 */
		/* 8222B3FCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x8222B644;  }
		/* 8222B3FCh case   13:*/		return 0x8222B400;
	}
	return 0x8222B400;
} // Block from 8222B3C8h-8222B400h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8222B400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B400);
		  /* 8222B400h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 8222B400h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8222B400h case    0:*/		return 0x8222B404;
		  /* 8222B404h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8222B404h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8222B404h case    1:*/		return 0x8222B408;
		  /* 8222B408h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8222B408h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222B424;  }
		/* 8222B408h case    2:*/		return 0x8222B40C;
		  /* 8222B40Ch */ case    3:  		/* mr R4, R28 */
		/* 8222B40Ch case    3:*/		regs.R4 = regs.R28;
		/* 8222B40Ch case    3:*/		return 0x8222B410;
		  /* 8222B410h */ case    4:  		/* mr R3, R30 */
		/* 8222B410h case    4:*/		regs.R3 = regs.R30;
		/* 8222B410h case    4:*/		return 0x8222B414;
		  /* 8222B414h */ case    5:  		/* bl -608364 */
		/* 8222B414h case    5:*/		regs.LR = 0x8222B418; return 0x82196BA8;
		/* 8222B414h case    5:*/		return 0x8222B418;
		  /* 8222B418h */ case    6:  		/* mr R4, R30 */
		/* 8222B418h case    6:*/		regs.R4 = regs.R30;
		/* 8222B418h case    6:*/		return 0x8222B41C;
		  /* 8222B41Ch */ case    7:  		/* mr R3, R28 */
		/* 8222B41Ch case    7:*/		regs.R3 = regs.R28;
		/* 8222B41Ch case    7:*/		return 0x8222B420;
		  /* 8222B420h */ case    8:  		/* bl -31200 */
		/* 8222B420h case    8:*/		regs.LR = 0x8222B424; return 0x82223A40;
		/* 8222B420h case    8:*/		return 0x8222B424;
	}
	return 0x8222B424;
} // Block from 8222B400h-8222B424h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222B424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B424);
		  /* 8222B424h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222B424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B424h case    0:*/		return 0x8222B428;
		  /* 8222B428h */ case    1:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 8222B428h case    1:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 8222B428h case    1:*/		return 0x8222B42C;
		  /* 8222B42Ch */ case    2:  		/* bc 12, CR0_EQ, 168 */
		/* 8222B42Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8222B4D4;  }
		/* 8222B42Ch case    2:*/		return 0x8222B430;
		  /* 8222B430h */ case    3:  		/* lwz R9, <#[R30]> */
		/* 8222B430h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8222B430h case    3:*/		return 0x8222B434;
		  /* 8222B434h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 8222B434h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8222B434h case    4:*/		return 0x8222B438;
		  /* 8222B438h */ case    5:  		/* bc 12, CR6_EQ, 100 */
		/* 8222B438h case    5:*/		if ( regs.CR[6].eq ) { return 0x8222B49C;  }
		/* 8222B438h case    5:*/		return 0x8222B43C;
		  /* 8222B43Ch */ case    6:  		/* lwz R10, <#[R9]> */
		/* 8222B43Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8222B43Ch case    6:*/		return 0x8222B440;
		  /* 8222B440h */ case    7:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 8222B440h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 8222B440h case    7:*/		return 0x8222B444;
		  /* 8222B444h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 8222B444h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8222B454;  }
		/* 8222B444h case    8:*/		return 0x8222B448;
		  /* 8222B448h */ case    9:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 8222B448h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 8222B448h case    9:*/		return 0x8222B44C;
		  /* 8222B44Ch */ case   10:  		/* li R11, 1 */
		/* 8222B44Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222B44Ch case   10:*/		return 0x8222B450;
		  /* 8222B450h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8222B450h case   11:*/		if ( regs.CR[0].eq ) { return 0x8222B458;  }
		/* 8222B450h case   11:*/		return 0x8222B454;
	}
	return 0x8222B454;
} // Block from 8222B424h-8222B454h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8222B454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B454);
		  /* 8222B454h */ case    0:  		/* li R11, 0 */
		/* 8222B454h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222B454h case    0:*/		return 0x8222B458;
	}
	return 0x8222B458;
} // Block from 8222B454h-8222B458h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B458);
		  /* 8222B458h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8222B458h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8222B458h case    0:*/		return 0x8222B45C;
		  /* 8222B45Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8222B45Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8222B46C;  }
		/* 8222B45Ch case    1:*/		return 0x8222B460;
		  /* 8222B460h */ case    2:  		/* rlwinm. R11, R10, 0, 7, 18 */
		/* 8222B460h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R10);
		/* 8222B460h case    2:*/		return 0x8222B464;
		  /* 8222B464h */ case    3:  		/* li R11, 1 */
		/* 8222B464h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222B464h case    3:*/		return 0x8222B468;
		  /* 8222B468h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8222B468h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8222B470;  }
		/* 8222B468h case    4:*/		return 0x8222B46C;
	}
	return 0x8222B46C;
} // Block from 8222B458h-8222B46Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222B46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B46C);
		  /* 8222B46Ch */ case    0:  		/* li R11, 0 */
		/* 8222B46Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222B46Ch case    0:*/		return 0x8222B470;
	}
	return 0x8222B470;
} // Block from 8222B46Ch-8222B470h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B470);
		  /* 8222B470h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8222B470h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8222B470h case    0:*/		return 0x8222B474;
		  /* 8222B474h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8222B474h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8222B480;  }
		/* 8222B474h case    1:*/		return 0x8222B478;
		  /* 8222B478h */ case    2:  		/* lwz R9, <#[R9 + 4]> */
		/* 8222B478h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8222B478h case    2:*/		return 0x8222B47C;
		  /* 8222B47Ch */ case    3:  		/* b -72 */
		/* 8222B47Ch case    3:*/		return 0x8222B434;
		/* 8222B47Ch case    3:*/		return 0x8222B480;
	}
	return 0x8222B480;
} // Block from 8222B470h-8222B480h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B480);
		  /* 8222B480h */ case    0:  		/* rlwinm R11, R10, 19, 20, 31 */
		/* 8222B480h case    0:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R10);
		/* 8222B480h case    0:*/		return 0x8222B484;
		  /* 8222B484h */ case    1:  		/* lwz R3, <#[R30 + 28]> */
		/* 8222B484h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222B484h case    1:*/		return 0x8222B488;
		  /* 8222B488h */ case    2:  		/* mr R6, R28 */
		/* 8222B488h case    2:*/		regs.R6 = regs.R28;
		/* 8222B488h case    2:*/		return 0x8222B48C;
		  /* 8222B48Ch */ case    3:  		/* mr R5, R30 */
		/* 8222B48Ch case    3:*/		regs.R5 = regs.R30;
		/* 8222B48Ch case    3:*/		return 0x8222B490;
		  /* 8222B490h */ case    4:  		/* addi R4, R11, -1 */
		/* 8222B490h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 8222B490h case    4:*/		return 0x8222B494;
		  /* 8222B494h */ case    5:  		/* bl 18172 */
		/* 8222B494h case    5:*/		regs.LR = 0x8222B498; return 0x8222FB90;
		/* 8222B494h case    5:*/		return 0x8222B498;
		  /* 8222B498h */ case    6:  		/* b -104 */
		/* 8222B498h case    6:*/		return 0x8222B430;
		/* 8222B498h case    6:*/		return 0x8222B49C;
	}
	return 0x8222B49C;
} // Block from 8222B480h-8222B49Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222B49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B49C);
		  /* 8222B49Ch */ case    0:  		/* li R10, 4 */
		/* 8222B49Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8222B49Ch case    0:*/		return 0x8222B4A0;
		  /* 8222B4A0h */ case    1:  		/* lwz R11, <#[R30 + 28]> */
		/* 8222B4A0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8222B4A0h case    1:*/		return 0x8222B4A4;
		  /* 8222B4A4h */ case    2:  		/* addi R11, R11, 92 */
		/* 8222B4A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5C);
		/* 8222B4A4h case    2:*/		return 0x8222B4A8;
		  /* 8222B4A8h */ case    3:  		/* mtspr CTR, R10 */
		/* 8222B4A8h case    3:*/		regs.CTR = regs.R10;
		/* 8222B4A8h case    3:*/		return 0x8222B4AC;
		  /* 8222B4ACh */ case    4:  		/* lwz R10, <#[R11]> */
		/* 8222B4ACh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B4ACh case    4:*/		return 0x8222B4B0;
	}
	return 0x8222B4B0;
} // Block from 8222B49Ch-8222B4B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222B4B0h
// Function '?GetOrCreateIntegerConstantInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@I_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B4B0);
		  /* 8222B4B0h */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 8222B4B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 8222B4B0h case    0:*/		return 0x8222B4B4;
		  /* 8222B4B4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8222B4B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222B4C0;  }
		/* 8222B4B4h case    1:*/		return 0x8222B4B8;
		  /* 8222B4B8h */ case    2:  		/* li R10, 0 */
		/* 8222B4B8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222B4B8h case    2:*/		return 0x8222B4BC;
		  /* 8222B4BCh */ case    3:  		/* stw R10, <#[R11]> */
		/* 8222B4BCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B4BCh case    3:*/		return 0x8222B4C0;
	}
	return 0x8222B4C0;
} // Block from 8222B4B0h-8222B4C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B4C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B4C0);
		  /* 8222B4C0h */ case    0:  		/* addi R11, R11, 4 */
		/* 8222B4C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8222B4C0h case    0:*/		return 0x8222B4C4;
		  /* 8222B4C4h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 8222B4C4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8222B4AC;  }
		/* 8222B4C4h case    1:*/		return 0x8222B4C8;
		  /* 8222B4C8h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222B4C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B4C8h case    2:*/		return 0x8222B4CC;
		  /* 8222B4CCh */ case    3:  		/* rlwinm R11, R11, 0, 7, 5 */
		/* 8222B4CCh case    3:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R11);
		/* 8222B4CCh case    3:*/		return 0x8222B4D0;
		  /* 8222B4D0h */ case    4:  		/* stw R11, <#[R30 + 8]> */
		/* 8222B4D0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B4D0h case    4:*/		return 0x8222B4D4;
	}
	return 0x8222B4D4;
} // Block from 8222B4C0h-8222B4D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222B4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B4D4);
		  /* 8222B4D4h */ case    0:  		/* lwz R31, <#[R30]> */
		/* 8222B4D4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8222B4D4h case    0:*/		return 0x8222B4D8;
		  /* 8222B4D8h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8222B4D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8222B4D8h case    1:*/		return 0x8222B4DC;
		  /* 8222B4DCh */ case    2:  		/* bc 4, CR6_EQ, 100 */
		/* 8222B4DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8222B540;  }
		/* 8222B4DCh case    2:*/		return 0x8222B4E0;
		  /* 8222B4E0h */ case    3:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 8222B4E0h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 8222B4E0h case    3:*/		return 0x8222B4E4;
		  /* 8222B4E4h */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 8222B4E4h case    4:*/		if ( regs.CR[0].eq ) { return 0x8222B510;  }
		/* 8222B4E4h case    4:*/		return 0x8222B4E8;
		  /* 8222B4E8h */ case    5:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 8222B4E8h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 8222B4E8h case    5:*/		return 0x8222B4EC;
		  /* 8222B4ECh */ case    6:  		/* addi R11, R11, 36 */
		/* 8222B4ECh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8222B4ECh case    6:*/		return 0x8222B4F0;
		  /* 8222B4F0h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 8222B4F0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8222B4F0h case    7:*/		return 0x8222B4F4;
		  /* 8222B4F4h */ case    8:  		/* lwz R9, <#[R11]> */
		/* 8222B4F4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B4F4h case    8:*/		return 0x8222B4F8;
		  /* 8222B4F8h */ case    9:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8222B4F8h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8222B4F8h case    9:*/		return 0x8222B4FC;
		  /* 8222B4FCh */ case   10:  		/* stw R9, <#[R10 + 36]> */
		/* 8222B4FCh case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 8222B4FCh case   10:*/		return 0x8222B500;
		  /* 8222B500h */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 8222B500h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8222B500h case   11:*/		return 0x8222B504;
		  /* 8222B504h */ case   12:  		/* lwz R11, <#[R11]> */
		/* 8222B504h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B504h case   12:*/		return 0x8222B508;
		  /* 8222B508h */ case   13:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8222B508h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8222B508h case   13:*/		return 0x8222B50C;
		  /* 8222B50Ch */ case   14:  		/* stw R10, <#[R11]> */
		/* 8222B50Ch case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B50Ch case   14:*/		return 0x8222B510;
	}
	return 0x8222B510;
} // Block from 8222B4D4h-8222B510h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8222B510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B510);
		  /* 8222B510h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222B510h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B510h case    0:*/		return 0x8222B514;
		  /* 8222B514h */ case    1:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8222B514h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8222B514h case    1:*/		return 0x8222B518;
		  /* 8222B518h */ case    2:  		/* cmpwi CR6, R4, 112 */
		/* 8222B518h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000070);
		/* 8222B518h case    2:*/		return 0x8222B51C;
		  /* 8222B51Ch */ case    3:  		/* bc 12, CR6_LT, 220 */
		/* 8222B51Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8222B5F8;  }
		/* 8222B51Ch case    3:*/		return 0x8222B520;
	}
	return 0x8222B520;
} // Block from 8222B510h-8222B520h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B520h
// Function '?GetOrCreateIntegerConstant@Compiler@D3DXShader@@QAA?AVResult@2@I_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B520);
		  /* 8222B520h */ case    0:  		/* cmpwi CR6, R4, 113 */
		/* 8222B520h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000071);
		/* 8222B520h case    0:*/		return 0x8222B524;
		  /* 8222B524h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8222B524h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8222B530;  }
		/* 8222B524h case    1:*/		return 0x8222B528;
		  /* 8222B528h */ case    2:  		/* cmpwi CR6, R4, 125 */
		/* 8222B528h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x0000007D);
		/* 8222B528h case    2:*/		return 0x8222B52C;
		  /* 8222B52Ch */ case    3:  		/* bc 4, CR6_EQ, 204 */
		/* 8222B52Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8222B5F8;  }
		/* 8222B52Ch case    3:*/		return 0x8222B530;
	}
	return 0x8222B530;
} // Block from 8222B520h-8222B530h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B530);
		  /* 8222B530h */ case    0:  		/* li R10, 115 */
		/* 8222B530h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x73);
		/* 8222B530h case    0:*/		return 0x8222B534;
		  /* 8222B534h */ case    1:  		/* rlwimi R11, R10, 7, 18, 24 */
		/* 8222B534h case    1:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R11,regs.R10);
		/* 8222B534h case    1:*/		return 0x8222B538;
		  /* 8222B538h */ case    2:  		/* stw R11, <#[R30 + 8]> */
		/* 8222B538h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B538h case    2:*/		return 0x8222B53C;
		  /* 8222B53Ch */ case    3:  		/* b 264 */
		/* 8222B53Ch case    3:*/		return 0x8222B644;
		/* 8222B53Ch case    3:*/		return 0x8222B540;
	}
	return 0x8222B540;
} // Block from 8222B530h-8222B540h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8222B540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B540);
		  /* 8222B540h */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 8222B540h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222B540h case    0:*/		return 0x8222B544;
		  /* 8222B544h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 8222B544h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8222B544h case    1:*/		return 0x8222B548;
		  /* 8222B548h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8222B548h case    2:*/		if ( regs.CR[6].eq ) { return 0x8222B55C;  }
		/* 8222B548h case    2:*/		return 0x8222B54C;
		  /* 8222B54Ch */ case    3:  		/* mr R5, R27 */
		/* 8222B54Ch case    3:*/		regs.R5 = regs.R27;
		/* 8222B54Ch case    3:*/		return 0x8222B550;
		  /* 8222B550h */ case    4:  		/* mr R4, R29 */
		/* 8222B550h case    4:*/		regs.R4 = regs.R29;
		/* 8222B550h case    4:*/		return 0x8222B554;
		  /* 8222B554h */ case    5:  		/* mr R3, R28 */
		/* 8222B554h case    5:*/		regs.R3 = regs.R28;
		/* 8222B554h case    5:*/		return 0x8222B558;
		  /* 8222B558h */ case    6:  		/* bl -392080 */
		/* 8222B558h case    6:*/		regs.LR = 0x8222B55C; return 0x821CB9C8;
		/* 8222B558h case    6:*/		return 0x8222B55C;
	}
	return 0x8222B55C;
} // Block from 8222B540h-8222B55Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8222B55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B55C);
		  /* 8222B55Ch */ case    0:  		/* mr R5, R28 */
		/* 8222B55Ch case    0:*/		regs.R5 = regs.R28;
		/* 8222B55Ch case    0:*/		return 0x8222B560;
		  /* 8222B560h */ case    1:  		/* mr R4, R31 */
		/* 8222B560h case    1:*/		regs.R4 = regs.R31;
		/* 8222B560h case    1:*/		return 0x8222B564;
		  /* 8222B564h */ case    2:  		/* mr R3, R30 */
		/* 8222B564h case    2:*/		regs.R3 = regs.R30;
		/* 8222B564h case    2:*/		return 0x8222B568;
		  /* 8222B568h */ case    3:  		/* bl -732248 */
		/* 8222B568h case    3:*/		regs.LR = 0x8222B56C; return 0x82178910;
		/* 8222B568h case    3:*/		return 0x8222B56C;
		  /* 8222B56Ch */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 8222B56Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8222B56Ch case    4:*/		return 0x8222B570;
	}
	return 0x8222B570;
} // Block from 8222B55Ch-8222B570h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8222B570h
// Function '?GetOrCreateConstantInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@IMMMM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B570);
		  /* 8222B570h */ case    0:  		/* bc 12, CR6_EQ, -156 */
		/* 8222B570h case    0:*/		if ( regs.CR[6].eq ) { return 0x8222B4D4;  }
		/* 8222B570h case    0:*/		return 0x8222B574;
		  /* 8222B574h */ case    1:  		/* lwz R11, <#[R30 + 8]> */
		/* 8222B574h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B574h case    1:*/		return 0x8222B578;
		  /* 8222B578h */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8222B578h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8222B578h case    2:*/		return 0x8222B57C;
		  /* 8222B57Ch */ case    3:  		/* cmplwi CR6, R11, 14080 */
		/* 8222B57Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 8222B57Ch case    3:*/		return 0x8222B580;
		  /* 8222B580h */ case    4:  		/* bc 4, CR6_EQ, -172 */
		/* 8222B580h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8222B4D4;  }
		/* 8222B580h case    4:*/		return 0x8222B584;
		  /* 8222B584h */ case    5:  		/* lwz R31, <#[R29 + 4]> */
		/* 8222B584h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 8222B584h case    5:*/		return 0x8222B588;
		  /* 8222B588h */ case    6:  		/* mr R11, R31 */
		/* 8222B588h case    6:*/		regs.R11 = regs.R31;
		/* 8222B588h case    6:*/		return 0x8222B58C;
		  /* 8222B58Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8222B58Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8222B58Ch case    7:*/		return 0x8222B590;
		  /* 8222B590h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 8222B590h case    8:*/		if ( regs.CR[6].eq ) { return 0x8222B5C4;  }
		/* 8222B590h case    8:*/		return 0x8222B594;
		  /* 8222B594h */ case    9:  		/* lwz R10, <#[R11 + 16]> */
		/* 8222B594h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8222B594h case    9:*/		return 0x8222B598;
		  /* 8222B598h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8222B598h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222B598h case   10:*/		return 0x8222B59C;
		  /* 8222B59Ch */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 8222B59Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8222B5BC;  }
		/* 8222B59Ch case   11:*/		return 0x8222B5A0;
		  /* 8222B5A0h */ case   12:  		/* lwz R9, <#[R10 + 8]> */
		/* 8222B5A0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8222B5A0h case   12:*/		return 0x8222B5A4;
		  /* 8222B5A4h */ case   13:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 8222B5A4h case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 8222B5A4h case   13:*/		return 0x8222B5A8;
		  /* 8222B5A8h */ case   14:  		/* cmplwi CR6, R9, 14080 */
		/* 8222B5A8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 8222B5A8h case   14:*/		return 0x8222B5AC;
		  /* 8222B5ACh */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 8222B5ACh case   15:*/		if ( !regs.CR[6].eq ) { return 0x8222B5BC;  }
		/* 8222B5ACh case   15:*/		return 0x8222B5B0;
		  /* 8222B5B0h */ case   16:  		/* lwz R9, <#[R11]> */
		/* 8222B5B0h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B5B0h case   16:*/		return 0x8222B5B4;
		  /* 8222B5B4h */ case   17:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 8222B5B4h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 8222B5B4h case   17:*/		return 0x8222B5B8;
	}
	return 0x8222B5B8;
} // Block from 8222B570h-8222B5B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8222B5B8h
// Function '?GetOrCreateConstantInstr@Compiler@D3DXShader@@QAAPAVInstruction@2@NW4ConstantValueType@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B5B8);
		  /* 8222B5B8h */ case    0:  		/* bc 4, CR0_EQ, 16 */
		/* 8222B5B8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8222B5C8;  }
		/* 8222B5B8h case    0:*/		return 0x8222B5BC;
	}
	return 0x8222B5BC;
} // Block from 8222B5B8h-8222B5BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B5BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B5BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B5BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B5BC);
		  /* 8222B5BCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8222B5BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8222B5BCh case    0:*/		return 0x8222B5C0;
		  /* 8222B5C0h */ case    1:  		/* b -52 */
		/* 8222B5C0h case    1:*/		return 0x8222B58C;
		/* 8222B5C0h case    1:*/		return 0x8222B5C4;
	}
	return 0x8222B5C4;
} // Block from 8222B5BCh-8222B5C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222B5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B5C4);
		  /* 8222B5C4h */ case    0:  		/* li R10, 0 */
		/* 8222B5C4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8222B5C4h case    0:*/		return 0x8222B5C8;
	}
	return 0x8222B5C8;
} // Block from 8222B5C4h-8222B5C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B5C8);
		  /* 8222B5C8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8222B5C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8222B5C8h case    0:*/		return 0x8222B5CC;
		  /* 8222B5CCh */ case    1:  		/* bc 4, CR6_EQ, -248 */
		/* 8222B5CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8222B4D4;  }
		/* 8222B5CCh case    1:*/		return 0x8222B5D0;
		  /* 8222B5D0h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8222B5D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8222B5D0h case    2:*/		return 0x8222B5D4;
		  /* 8222B5D4h */ case    3:  		/* bc 12, CR6_EQ, -256 */
		/* 8222B5D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8222B4D4;  }
		/* 8222B5D4h case    3:*/		return 0x8222B5D8;
		  /* 8222B5D8h */ case    4:  		/* lwz R4, <#[R31 + 16]> */
		/* 8222B5D8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 8222B5D8h case    4:*/		return 0x8222B5DC;
		  /* 8222B5DCh */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 8222B5DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8222B5DCh case    5:*/		return 0x8222B5E0;
		  /* 8222B5E0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8222B5E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8222B5F0;  }
		/* 8222B5E0h case    6:*/		return 0x8222B5E4;
		  /* 8222B5E4h */ case    7:  		/* mr R5, R27 */
		/* 8222B5E4h case    7:*/		regs.R5 = regs.R27;
		/* 8222B5E4h case    7:*/		return 0x8222B5E8;
		  /* 8222B5E8h */ case    8:  		/* mr R3, R28 */
		/* 8222B5E8h case    8:*/		regs.R3 = regs.R28;
		/* 8222B5E8h case    8:*/		return 0x8222B5EC;
		  /* 8222B5ECh */ case    9:  		/* bl -392228 */
		/* 8222B5ECh case    9:*/		regs.LR = 0x8222B5F0; return 0x821CB9C8;
		/* 8222B5ECh case    9:*/		return 0x8222B5F0;
	}
	return 0x8222B5F0;
} // Block from 8222B5C8h-8222B5F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222B5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B5F0);
		  /* 8222B5F0h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8222B5F0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8222B5F0h case    0:*/		return 0x8222B5F4;
		  /* 8222B5F4h */ case    1:  		/* b -36 */
		/* 8222B5F4h case    1:*/		return 0x8222B5D0;
		/* 8222B5F4h case    1:*/		return 0x8222B5F8;
	}
	return 0x8222B5F8;
} // Block from 8222B5F0h-8222B5F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222B5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B5F8);
		  /* 8222B5F8h */ case    0:  		/* lwz R10, <#[R28 + 40]> */
		/* 8222B5F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000028) );
		/* 8222B5F8h case    0:*/		return 0x8222B5FC;
		  /* 8222B5FCh */ case    1:  		/* rlwinm. R10, R10, 0, 19, 19 */
		/* 8222B5FCh case    1:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8222B5FCh case    1:*/		return 0x8222B600;
		  /* 8222B600h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 8222B600h case    2:*/		if ( regs.CR[0].eq ) { return 0x8222B620;  }
		/* 8222B600h case    2:*/		return 0x8222B604;
		  /* 8222B604h */ case    3:  		/* li R10, 115 */
		/* 8222B604h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x73);
		/* 8222B604h case    3:*/		return 0x8222B608;
		  /* 8222B608h */ case    4:  		/* rlwimi R11, R10, 7, 18, 24 */
		/* 8222B608h case    4:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R11,regs.R10);
		/* 8222B608h case    4:*/		return 0x8222B60C;
		  /* 8222B60Ch */ case    5:  		/* stw R11, <#[R30 + 8]> */
		/* 8222B60Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8222B60Ch case    5:*/		return 0x8222B610;
		  /* 8222B610h */ case    6:  		/* lwz R11, <#[R28 + 540]> */
		/* 8222B610h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000021C) );
		/* 8222B610h case    6:*/		return 0x8222B614;
		  /* 8222B614h */ case    7:  		/* stw R11, <#[R30 + 32]> */
		/* 8222B614h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 8222B614h case    7:*/		return 0x8222B618;
		  /* 8222B618h */ case    8:  		/* stw R30, <#[R28 + 540]> */
		/* 8222B618h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x0000021C) );
		/* 8222B618h case    8:*/		return 0x8222B61C;
		  /* 8222B61Ch */ case    9:  		/* b 40 */
		/* 8222B61Ch case    9:*/		return 0x8222B644;
		/* 8222B61Ch case    9:*/		return 0x8222B620;
	}
	return 0x8222B620;
} // Block from 8222B5F8h-8222B620h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222B620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B620);
		  /* 8222B620h */ case    0:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8222B620h case    0:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8222B620h case    0:*/		return 0x8222B624;
		  /* 8222B624h */ case    1:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8222B624h case    1:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8222B624h case    1:*/		return 0x8222B628;
		  /* 8222B628h */ case    2:  		/* mr R3, R28 */
		/* 8222B628h case    2:*/		regs.R3 = regs.R28;
		/* 8222B628h case    2:*/		return 0x8222B62C;
		  /* 8222B62Ch */ case    3:  		/* bl -815612 */
		/* 8222B62Ch case    3:*/		regs.LR = 0x8222B630; return 0x82164430;
		/* 8222B62Ch case    3:*/		return 0x8222B630;
		  /* 8222B630h */ case    4:  		/* mr R5, R3 */
		/* 8222B630h case    4:*/		regs.R5 = regs.R3;
		/* 8222B630h case    4:*/		return 0x8222B634;
		  /* 8222B634h */ case    5:  		/* mr R4, R30 */
		/* 8222B634h case    5:*/		regs.R4 = regs.R30;
		/* 8222B634h case    5:*/		return 0x8222B638;
		  /* 8222B638h */ case    6:  		/* mr R3, R28 */
		/* 8222B638h case    6:*/		regs.R3 = regs.R28;
		/* 8222B638h case    6:*/		return 0x8222B63C;
		  /* 8222B63Ch */ case    7:  		/* li R6, 35 */
		/* 8222B63Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x23);
		/* 8222B63Ch case    7:*/		return 0x8222B640;
		  /* 8222B640h */ case    8:  		/* bl -813480 */
		/* 8222B640h case    8:*/		regs.LR = 0x8222B644; return 0x82164C98;
		/* 8222B640h case    8:*/		return 0x8222B644;
	}
	return 0x8222B644;
} // Block from 8222B620h-8222B644h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222B644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B644);
		  /* 8222B644h */ case    0:  		/* addi R1, R1, 144 */
		/* 8222B644h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8222B644h case    0:*/		return 0x8222B648;
		  /* 8222B648h */ case    1:  		/* b -1680296 */
		/* 8222B648h case    1:*/		return 0x820912A0;
		/* 8222B648h case    1:*/		return 0x8222B64C;
		  /* 8222B64Ch */ case    2:  		/* nop */
		/* 8222B64Ch case    2:*/		cpu::op::nop();
		/* 8222B64Ch case    2:*/		return 0x8222B650;
	}
	return 0x8222B650;
} // Block from 8222B644h-8222B650h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222B650h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B650);
		  /* 8222B650h */ case    0:  		/* mfspr R12, LR */
		/* 8222B650h case    0:*/		regs.R12 = regs.LR;
		/* 8222B650h case    0:*/		return 0x8222B654;
		  /* 8222B654h */ case    1:  		/* bl -1680392 */
		/* 8222B654h case    1:*/		regs.LR = 0x8222B658; return 0x8209124C;
		/* 8222B654h case    1:*/		return 0x8222B658;
		  /* 8222B658h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8222B658h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8222B658h case    2:*/		return 0x8222B65C;
		  /* 8222B65Ch */ case    3:  		/* lwz R11, <#[R3 + 40]> */
		/* 8222B65Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 8222B65Ch case    3:*/		return 0x8222B660;
		  /* 8222B660h */ case    4:  		/* mr R27, R4 */
		/* 8222B660h case    4:*/		regs.R27 = regs.R4;
		/* 8222B660h case    4:*/		return 0x8222B664;
		  /* 8222B664h */ case    5:  		/* li R5, 38 */
		/* 8222B664h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x26);
		/* 8222B664h case    5:*/		return 0x8222B668;
		  /* 8222B668h */ case    6:  		/* ori R10, R11, 4096 */
		/* 8222B668h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R11,0x1000);
		/* 8222B668h case    6:*/		return 0x8222B66C;
		  /* 8222B66Ch */ case    7:  		/* li R4, 8 */
		/* 8222B66Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8222B66Ch case    7:*/		return 0x8222B670;
		  /* 8222B670h */ case    8:  		/* stw R10, <#[R3 + 40]> */
		/* 8222B670h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000028) );
		/* 8222B670h case    8:*/		return 0x8222B674;
		  /* 8222B674h */ case    9:  		/* mr R28, R3 */
		/* 8222B674h case    9:*/		regs.R28 = regs.R3;
		/* 8222B674h case    9:*/		return 0x8222B678;
		  /* 8222B678h */ case   10:  		/* rlwinm R25, R11, 20, 31, 31 */
		/* 8222B678h case   10:*/		cpu::op::rlwinm<0,20,31,31>(regs,&regs.R25,regs.R11);
		/* 8222B678h case   10:*/		return 0x8222B67C;
		  /* 8222B67Ch */ case   11:  		/* bl -814476 */
		/* 8222B67Ch case   11:*/		regs.LR = 0x8222B680; return 0x821648F0;
		/* 8222B67Ch case   11:*/		return 0x8222B680;
		  /* 8222B680h */ case   12:  		/* addi R26, R3, 4 */
		/* 8222B680h case   12:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0x4);
		/* 8222B680h case   12:*/		return 0x8222B684;
		  /* 8222B684h */ case   13:  		/* ori R11, R3, 1 */
		/* 8222B684h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8222B684h case   13:*/		return 0x8222B688;
		  /* 8222B688h */ case   14:  		/* ori R10, R26, 1 */
		/* 8222B688h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R26,0x1);
		/* 8222B688h case   14:*/		return 0x8222B68C;
		  /* 8222B68Ch */ case   15:  		/* mr R30, R3 */
		/* 8222B68Ch case   15:*/		regs.R30 = regs.R3;
		/* 8222B68Ch case   15:*/		return 0x8222B690;
	}
	return 0x8222B690;
} // Block from 8222B650h-8222B690h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8222B690h
// Function '?InsertNewCopy@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@UInstructionPlacementPoint@12@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B690);
		  /* 8222B690h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 8222B690h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8222B690h case    0:*/		return 0x8222B694;
		  /* 8222B694h */ case    1:  		/* stw R10, <#[R3]> */
		/* 8222B694h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8222B694h case    1:*/		return 0x8222B698;
		  /* 8222B698h */ case    2:  		/* lwz R31, <#[R27]> */
		/* 8222B698h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x00000000) );
		/* 8222B698h case    2:*/		return 0x8222B69C;
		  /* 8222B69Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8222B69Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8222B69Ch case    3:*/		return 0x8222B6A0;
		  /* 8222B6A0h */ case    4:  		/* bc 12, CR6_EQ, 100 */
		/* 8222B6A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x8222B704;  }
		/* 8222B6A0h case    4:*/		return 0x8222B6A4;
		  /* 8222B6A4h */ case    5:  		/* lwz R11, <#[R26]> */
		/* 8222B6A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8222B6A4h case    5:*/		return 0x8222B6A8;
		  /* 8222B6A8h */ case    6:  		/* lwz R29, <#[R31 + 12]> */
		/* 8222B6A8h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 8222B6A8h case    6:*/		return 0x8222B6AC;
		  /* 8222B6ACh */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8222B6ACh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8222B6ACh case    7:*/		return 0x8222B6B0;
		  /* 8222B6B0h */ case    8:  		/* bc 4, CR0_EQ, 40 */
		/* 8222B6B0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8222B6D8;  }
		/* 8222B6B0h case    8:*/		return 0x8222B6B4;
		  /* 8222B6B4h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8222B6B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222B6B4h case    9:*/		return 0x8222B6B8;
		  /* 8222B6B8h */ case   10:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8222B6B8h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8222B6B8h case   10:*/		return 0x8222B6BC;
		  /* 8222B6BCh */ case   11:  		/* addic. R3, R11, -4 */
		/* 8222B6BCh case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 8222B6BCh case   11:*/		return 0x8222B6C0;
		  /* 8222B6C0h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 8222B6C0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8222B6D8;  }
		/* 8222B6C0h case   12:*/		return 0x8222B6C4;
		  /* 8222B6C4h */ case   13:  		/* lwz R11, <#[R3 + 8]> */
		/* 8222B6C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8222B6C4h case   13:*/		return 0x8222B6C8;
		  /* 8222B6C8h */ case   14:  		/* lwz R10, <#[R3 + 12]> */
		/* 8222B6C8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8222B6C8h case   14:*/		return 0x8222B6CC;
		  /* 8222B6CCh */ case   15:  		/* addi R11, R11, 1 */
		/* 8222B6CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222B6CCh case   15:*/		return 0x8222B6D0;
		  /* 8222B6D0h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 8222B6D0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8222B6D0h case   16:*/		return 0x8222B6D4;
		  /* 8222B6D4h */ case   17:  		/* bc 4, CR6_GT, 16 */
		/* 8222B6D4h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8222B6E4;  }
		/* 8222B6D4h case   17:*/		return 0x8222B6D8;
	}
	return 0x8222B6D8;
} // Block from 8222B690h-8222B6D8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8222B6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B6D8);
		  /* 8222B6D8h */ case    0:  		/* li R4, 1 */
		/* 8222B6D8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8222B6D8h case    0:*/		return 0x8222B6DC;
		  /* 8222B6DCh */ case    1:  		/* mr R3, R30 */
		/* 8222B6DCh case    1:*/		regs.R3 = regs.R30;
		/* 8222B6DCh case    1:*/		return 0x8222B6E0;
		  /* 8222B6E0h */ case    2:  		/* bl -648728 */
		/* 8222B6E0h case    2:*/		regs.LR = 0x8222B6E4; return 0x8218D0C8;
		/* 8222B6E0h case    2:*/		return 0x8222B6E4;
	}
	return 0x8222B6E4;
} // Block from 8222B6D8h-8222B6E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222B6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B6E4);
		  /* 8222B6E4h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8222B6E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8222B6E4h case    0:*/		return 0x8222B6E8;
		  /* 8222B6E8h */ case    1:  		/* addi R10, R11, 4 */
		/* 8222B6E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8222B6E8h case    1:*/		return 0x8222B6EC;
		  /* 8222B6ECh */ case    2:  		/* addi R9, R11, 1 */
		/* 8222B6ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 8222B6ECh case    2:*/		return 0x8222B6F0;
		  /* 8222B6F0h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8222B6F0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8222B6F0h case    3:*/		return 0x8222B6F4;
		  /* 8222B6F4h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 8222B6F4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8222B6F4h case    4:*/		return 0x8222B6F8;
		  /* 8222B6F8h */ case    5:  		/* stwx R29, <#[R11 + R3]> */
		/* 8222B6F8h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8222B6F8h case    5:*/		return 0x8222B6FC;
		  /* 8222B6FCh */ case    6:  		/* lwz R31, <#[R31 + 4]> */
		/* 8222B6FCh case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8222B6FCh case    6:*/		return 0x8222B700;
		  /* 8222B700h */ case    7:  		/* b -100 */
		/* 8222B700h case    7:*/		return 0x8222B69C;
		/* 8222B700h case    7:*/		return 0x8222B704;
	}
	return 0x8222B704;
} // Block from 8222B6E4h-8222B704h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222B704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B704);
		  /* 8222B704h */ case    0:  		/* lwz R29, <#[R27 + 4]> */
		/* 8222B704h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000004) );
		/* 8222B704h case    0:*/		return 0x8222B708;
		  /* 8222B708h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 8222B708h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8222B708h case    1:*/		return 0x8222B70C;
		  /* 8222B70Ch */ case    2:  		/* bc 12, CR6_EQ, 144 */
		/* 8222B70Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8222B79C;  }
		/* 8222B70Ch case    2:*/		return 0x8222B710;
		  /* 8222B710h */ case    3:  		/* lwz R31, <#[R29 + 16]> */
		/* 8222B710h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000010) );
		/* 8222B710h case    3:*/		return 0x8222B714;
		  /* 8222B714h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8222B714h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8222B714h case    4:*/		return 0x8222B718;
		  /* 8222B718h */ case    5:  		/* bc 12, CR6_EQ, 124 */
		/* 8222B718h case    5:*/		if ( regs.CR[6].eq ) { return 0x8222B794;  }
		/* 8222B718h case    5:*/		return 0x8222B71C;
		  /* 8222B71Ch */ case    6:  		/* lwz R11, <#[R29]> */
		/* 8222B71Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8222B71Ch case    6:*/		return 0x8222B720;
		  /* 8222B720h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8222B720h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8222B720h case    7:*/		return 0x8222B724;
		  /* 8222B724h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 8222B724h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8222B734;  }
		/* 8222B724h case    8:*/		return 0x8222B728;
		  /* 8222B728h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8222B728h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8222B728h case    9:*/		return 0x8222B72C;
		  /* 8222B72Ch */ case   10:  		/* li R11, 1 */
		/* 8222B72Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8222B72Ch case   10:*/		return 0x8222B730;
		  /* 8222B730h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8222B730h case   11:*/		if ( regs.CR[0].eq ) { return 0x8222B738;  }
		/* 8222B730h case   11:*/		return 0x8222B734;
	}
	return 0x8222B734;
} // Block from 8222B704h-8222B734h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8222B734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B734);
		  /* 8222B734h */ case    0:  		/* li R11, 0 */
		/* 8222B734h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8222B734h case    0:*/		return 0x8222B738;
	}
	return 0x8222B738;
} // Block from 8222B734h-8222B738h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8222B738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B738);
		  /* 8222B738h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8222B738h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8222B738h case    0:*/		return 0x8222B73C;
		  /* 8222B73Ch */ case    1:  		/* bc 12, CR0_EQ, 88 */
		/* 8222B73Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8222B794;  }
		/* 8222B73Ch case    1:*/		return 0x8222B740;
		  /* 8222B740h */ case    2:  		/* lwz R11, <#[R26]> */
		/* 8222B740h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8222B740h case    2:*/		return 0x8222B744;
		  /* 8222B744h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8222B744h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8222B744h case    3:*/		return 0x8222B748;
		  /* 8222B748h */ case    4:  		/* bc 4, CR0_EQ, 40 */
		/* 8222B748h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8222B770;  }
		/* 8222B748h case    4:*/		return 0x8222B74C;
		  /* 8222B74Ch */ case    5:  		/* lwz R11, <#[R30]> */
		/* 8222B74Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222B74Ch case    5:*/		return 0x8222B750;
		  /* 8222B750h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8222B750h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8222B750h case    6:*/		return 0x8222B754;
		  /* 8222B754h */ case    7:  		/* addic. R3, R11, -4 */
		/* 8222B754h case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 8222B754h case    7:*/		return 0x8222B758;
		  /* 8222B758h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8222B758h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222B770;  }
		/* 8222B758h case    8:*/		return 0x8222B75C;
		  /* 8222B75Ch */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 8222B75Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8222B75Ch case    9:*/		return 0x8222B760;
		  /* 8222B760h */ case   10:  		/* lwz R10, <#[R3 + 12]> */
		/* 8222B760h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8222B760h case   10:*/		return 0x8222B764;
		  /* 8222B764h */ case   11:  		/* addi R11, R11, 1 */
		/* 8222B764h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8222B764h case   11:*/		return 0x8222B768;
		  /* 8222B768h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 8222B768h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8222B768h case   12:*/		return 0x8222B76C;
		  /* 8222B76Ch */ case   13:  		/* bc 4, CR6_GT, 16 */
		/* 8222B76Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x8222B77C;  }
		/* 8222B76Ch case   13:*/		return 0x8222B770;
	}
	return 0x8222B770;
} // Block from 8222B738h-8222B770h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8222B770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B770);
		  /* 8222B770h */ case    0:  		/* li R4, 1 */
		/* 8222B770h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8222B770h case    0:*/		return 0x8222B774;
		  /* 8222B774h */ case    1:  		/* mr R3, R30 */
		/* 8222B774h case    1:*/		regs.R3 = regs.R30;
		/* 8222B774h case    1:*/		return 0x8222B778;
		  /* 8222B778h */ case    2:  		/* bl -648880 */
		/* 8222B778h case    2:*/		regs.LR = 0x8222B77C; return 0x8218D0C8;
		/* 8222B778h case    2:*/		return 0x8222B77C;
	}
	return 0x8222B77C;
} // Block from 8222B770h-8222B77Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8222B77Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B77C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B77C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B77C);
		  /* 8222B77Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8222B77Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8222B77Ch case    0:*/		return 0x8222B780;
		  /* 8222B780h */ case    1:  		/* addi R10, R11, 4 */
		/* 8222B780h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8222B780h case    1:*/		return 0x8222B784;
		  /* 8222B784h */ case    2:  		/* addi R9, R11, 1 */
		/* 8222B784h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 8222B784h case    2:*/		return 0x8222B788;
		  /* 8222B788h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8222B788h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8222B788h case    3:*/		return 0x8222B78C;
		  /* 8222B78Ch */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 8222B78Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8222B78Ch case    4:*/		return 0x8222B790;
		  /* 8222B790h */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 8222B790h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8222B790h case    5:*/		return 0x8222B794;
	}
	return 0x8222B794;
} // Block from 8222B77Ch-8222B794h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8222B794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B794);
		  /* 8222B794h */ case    0:  		/* lwz R29, <#[R29 + 8]> */
		/* 8222B794h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8222B794h case    0:*/		return 0x8222B798;
		  /* 8222B798h */ case    1:  		/* b -144 */
		/* 8222B798h case    1:*/		return 0x8222B708;
		/* 8222B798h case    1:*/		return 0x8222B79C;
	}
	return 0x8222B79C;
} // Block from 8222B794h-8222B79Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8222B79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B79C);
		  /* 8222B79Ch */ case    0:  		/* li R6, 1 */
		/* 8222B79Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8222B79Ch case    0:*/		return 0x8222B7A0;
		  /* 8222B7A0h */ case    1:  		/* li R5, 0 */
		/* 8222B7A0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8222B7A0h case    1:*/		return 0x8222B7A4;
		  /* 8222B7A4h */ case    2:  		/* mr R4, R27 */
		/* 8222B7A4h case    2:*/		regs.R4 = regs.R27;
		/* 8222B7A4h case    2:*/		return 0x8222B7A8;
		  /* 8222B7A8h */ case    3:  		/* mr R3, R28 */
		/* 8222B7A8h case    3:*/		regs.R3 = regs.R28;
		/* 8222B7A8h case    3:*/		return 0x8222B7AC;
		  /* 8222B7ACh */ case    4:  		/* bl -996 */
		/* 8222B7ACh case    4:*/		regs.LR = 0x8222B7B0; return 0x8222B3C8;
		/* 8222B7ACh case    4:*/		return 0x8222B7B0;
		  /* 8222B7B0h */ case    5:  		/* lwz R11, <#[R26]> */
		/* 8222B7B0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8222B7B0h case    5:*/		return 0x8222B7B4;
		  /* 8222B7B4h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8222B7B4h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8222B7B4h case    6:*/		return 0x8222B7B8;
		  /* 8222B7B8h */ case    7:  		/* bc 4, CR0_EQ, 148 */
		/* 8222B7B8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8222B84C;  }
		/* 8222B7B8h case    7:*/		return 0x8222B7BC;
		  /* 8222B7BCh */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 8222B7BCh case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8222B7BCh case    8:*/		return 0x8222B7C0;
		  /* 8222B7C0h */ case    9:  		/* bc 12, CR0_EQ, 140 */
		/* 8222B7C0h case    9:*/		if ( regs.CR[0].eq ) { return 0x8222B84C;  }
		/* 8222B7C0h case    9:*/		return 0x8222B7C4;
		  /* 8222B7C4h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 8222B7C4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8222B7C4h case   10:*/		return 0x8222B7C8;
		  /* 8222B7C8h */ case   11:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8222B7C8h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8222B7C8h case   11:*/		return 0x8222B7CC;
		  /* 8222B7CCh */ case   12:  		/* addi R4, R11, -4 */
		/* 8222B7CCh case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8222B7CCh case   12:*/		return 0x8222B7D0;
		  /* 8222B7D0h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 8222B7D0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8222B7D0h case   13:*/		return 0x8222B7D4;
		  /* 8222B7D4h */ case   14:  		/* addi R10, R11, 3 */
		/* 8222B7D4h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 8222B7D4h case   14:*/		return 0x8222B7D8;
		  /* 8222B7D8h */ case   15:  		/* addic. R11, R11, -1 */
		/* 8222B7D8h case   15:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8222B7D8h case   15:*/		return 0x8222B7DC;
		  /* 8222B7DCh */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8222B7DCh case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8222B7DCh case   16:*/		return 0x8222B7E0;
		  /* 8222B7E0h */ case   17:  		/* lwzx R31, <#[R10 + R4]> */
		/* 8222B7E0h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8222B7E0h case   17:*/		return 0x8222B7E4;
		  /* 8222B7E4h */ case   18:  		/* stw R11, <#[R4 + 8]> */
		/* 8222B7E4h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8222B7E4h case   18:*/		return 0x8222B7E8;
		  /* 8222B7E8h */ case   19:  		/* bc 4, CR0_EQ, 60 */
		/* 8222B7E8h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8222B824;  }
		/* 8222B7E8h case   19:*/		return 0x8222B7EC;
		  /* 8222B7ECh */ case   20:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 8222B7ECh case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 8222B7ECh case   20:*/		return 0x8222B7F0;
		  /* 8222B7F0h */ case   21:  		/* mr R3, R30 */
		/* 8222B7F0h case   21:*/		regs.R3 = regs.R30;
		/* 8222B7F0h case   21:*/		return 0x8222B7F4;
		  /* 8222B7F4h */ case   22:  		/* lwz R10, <#[R11 + 4]> */
		/* 8222B7F4h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8222B7F4h case   22:*/		return 0x8222B7F8;
		  /* 8222B7F8h */ case   23:  		/* lwz R9, <#[R11]> */
		/* 8222B7F8h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B7F8h case   23:*/		return 0x8222B7FC;
		  /* 8222B7FCh */ case   24:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8222B7FCh case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8222B7FCh case   24:*/		return 0x8222B800;
		  /* 8222B800h */ case   25:  		/* stw R9, <#[R10]> */
		/* 8222B800h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8222B800h case   25:*/		return 0x8222B804;
		  /* 8222B804h */ case   26:  		/* lwz R10, <#[R11 + 4]> */
		/* 8222B804h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8222B804h case   26:*/		return 0x8222B808;
		  /* 8222B808h */ case   27:  		/* lwz R11, <#[R11]> */
		/* 8222B808h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B808h case   27:*/		return 0x8222B80C;
		  /* 8222B80Ch */ case   28:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8222B80Ch case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8222B80Ch case   28:*/		return 0x8222B810;
		  /* 8222B810h */ case   29:  		/* stw R10, <#[R11]> */
		/* 8222B810h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8222B810h case   29:*/		return 0x8222B814;
		  /* 8222B814h */ case   30:  		/* lwz R11, <#[R4 + 12]> */
		/* 8222B814h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8222B814h case   30:*/		return 0x8222B818;
		  /* 8222B818h */ case   31:  		/* addi R11, R11, 4 */
		/* 8222B818h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8222B818h case   31:*/		return 0x8222B81C;
		  /* 8222B81Ch */ case   32:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8222B81Ch case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8222B81Ch case   32:*/		return 0x8222B820;
		  /* 8222B820h */ case   33:  		/* bl -891416 */
		/* 8222B820h case   33:*/		regs.LR = 0x8222B824; return 0x82151E08;
		/* 8222B820h case   33:*/		return 0x8222B824;
	}
	return 0x8222B824;
} // Block from 8222B79Ch-8222B824h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8222B824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B824);
		  /* 8222B824h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8222B824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8222B824h case    0:*/		return 0x8222B828;
		  /* 8222B828h */ case    1:  		/* mr R27, R31 */
		/* 8222B828h case    1:*/		regs.R27 = regs.R31;
		/* 8222B828h case    1:*/		return 0x8222B82C;
		  /* 8222B82Ch */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8222B82Ch case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8222B82Ch case    2:*/		return 0x8222B830;
		  /* 8222B830h */ case    3:  		/* cmplwi CR6, R11, 14720 */
		/* 8222B830h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003980);
		/* 8222B830h case    3:*/		return 0x8222B834;
		  /* 8222B834h */ case    4:  		/* bc 12, CR6_EQ, -132 */
		/* 8222B834h case    4:*/		if ( regs.CR[6].eq ) { return 0x8222B7B0;  }
		/* 8222B834h case    4:*/		return 0x8222B838;
		  /* 8222B838h */ case    5:  		/* mr R3, R31 */
		/* 8222B838h case    5:*/		regs.R3 = regs.R31;
		/* 8222B838h case    5:*/		return 0x8222B83C;
		  /* 8222B83Ch */ case    6:  		/* bl -814780 */
		/* 8222B83Ch case    6:*/		regs.LR = 0x8222B840; return 0x82164980;
		/* 8222B83Ch case    6:*/		return 0x8222B840;
		  /* 8222B840h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8222B840h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8222B840h case    7:*/		return 0x8222B844;
		  /* 8222B844h */ case    8:  		/* bc 12, CR0_EQ, -148 */
		/* 8222B844h case    8:*/		if ( regs.CR[0].eq ) { return 0x8222B7B0;  }
		/* 8222B844h case    8:*/		return 0x8222B848;
		  /* 8222B848h */ case    9:  		/* b -432 */
		/* 8222B848h case    9:*/		return 0x8222B698;
		/* 8222B848h case    9:*/		return 0x8222B84C;
	}
	return 0x8222B84C;
} // Block from 8222B824h-8222B84Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8222B84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B84C);
		  /* 8222B84Ch */ case    0:  		/* lwz R10, <#[R28 + 976]> */
		/* 8222B84Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x000003D0) );
		/* 8222B84Ch case    0:*/		return 0x8222B850;
		  /* 8222B850h */ case    1:  		/* mr R4, R25 */
		/* 8222B850h case    1:*/		regs.R4 = regs.R25;
		/* 8222B850h case    1:*/		return 0x8222B854;
		  /* 8222B854h */ case    2:  		/* mr R3, R28 */
		/* 8222B854h case    2:*/		regs.R3 = regs.R28;
		/* 8222B854h case    2:*/		return 0x8222B858;
		  /* 8222B858h */ case    3:  		/* addi R11, R28, 972 */
		/* 8222B858h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x3CC);
		/* 8222B858h case    3:*/		return 0x8222B85C;
		  /* 8222B85Ch */ case    4:  		/* stw R10, <#[R30]> */
		/* 8222B85Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8222B85Ch case    4:*/		return 0x8222B860;
		  /* 8222B860h */ case    5:  		/* stw R30, <#[R28 + 976]> */
		/* 8222B860h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x000003D0) );
		/* 8222B860h case    5:*/		return 0x8222B864;
		  /* 8222B864h */ case    6:  		/* bl -813940 */
		/* 8222B864h case    6:*/		regs.LR = 0x8222B868; return 0x82164CF0;
		/* 8222B864h case    6:*/		return 0x8222B868;
		  /* 8222B868h */ case    7:  		/* addi R1, R1, 144 */
		/* 8222B868h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8222B868h case    7:*/		return 0x8222B86C;
		  /* 8222B86Ch */ case    8:  		/* b -1680848 */
		/* 8222B86Ch case    8:*/		return 0x8209129C;
		/* 8222B86Ch case    8:*/		return 0x8222B870;
	}
	return 0x8222B870;
} // Block from 8222B84Ch-8222B870h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8222B870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B870);
		  /* 8222B870h */ case    0:  		/* mfspr R12, LR */
		/* 8222B870h case    0:*/		regs.R12 = regs.LR;
		/* 8222B870h case    0:*/		return 0x8222B874;
		  /* 8222B874h */ case    1:  		/* bl -1680936 */
		/* 8222B874h case    1:*/		regs.LR = 0x8222B878; return 0x8209124C;
		/* 8222B874h case    1:*/		return 0x8222B878;
		  /* 8222B878h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8222B878h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8222B878h case    2:*/		return 0x8222B87C;
		  /* 8222B87Ch */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8222B87Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8222B87Ch case    3:*/		return 0x8222B880;
		  /* 8222B880h */ case    4:  		/* mr R30, R3 */
		/* 8222B880h case    4:*/		regs.R30 = regs.R3;
		/* 8222B880h case    4:*/		return 0x8222B884;
		  /* 8222B884h */ case    5:  		/* mr R31, R4 */
		/* 8222B884h case    5:*/		regs.R31 = regs.R4;
		/* 8222B884h case    5:*/		return 0x8222B888;
		  /* 8222B888h */ case    6:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8222B888h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8222B888h case    6:*/		return 0x8222B88C;
		  /* 8222B88Ch */ case    7:  		/* cmplwi CR6, R10, 117 */
		/* 8222B88Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000075);
		/* 8222B88Ch case    7:*/		return 0x8222B890;
		  /* 8222B890h */ case    8:  		/* bc 12, CR6_EQ, 408 */
		/* 8222B890h case    8:*/		if ( regs.CR[6].eq ) { return 0x8222BA28;  }
		/* 8222B890h case    8:*/		return 0x8222B894;
		  /* 8222B894h */ case    9:  		/* rlwinm R11, R11, 14, 31, 31 */
		/* 8222B894h case    9:*/		cpu::op::rlwinm<0,14,31,31>(regs,&regs.R11,regs.R11);
		/* 8222B894h case    9:*/		return 0x8222B898;
		  /* 8222B898h */ case   10:  		/* rlwinm R9, R6, 0, 24, 31 */
		/* 8222B898h case   10:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R6);
		/* 8222B898h case   10:*/		return 0x8222B89C;
		  /* 8222B89Ch */ case   11:  		/* li R25, 0 */
		/* 8222B89Ch case   11:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8222B89Ch case   11:*/		return 0x8222B8A0;
		  /* 8222B8A0h */ case   12:  		/* cmplw CR6, R11, R9 */
		/* 8222B8A0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8222B8A0h case   12:*/		return 0x8222B8A4;
		  /* 8222B8A4h */ case   13:  		/* bc 4, CR6_EQ, 256 */
		/* 8222B8A4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8222B9A4;  }
		/* 8222B8A4h case   13:*/		return 0x8222B8A8;
		  /* 8222B8A8h */ case   14:  		/* cmpwi CR6, R10, 87 */
		/* 8222B8A8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000057);
		/* 8222B8A8h case   14:*/		return 0x8222B8AC;
		  /* 8222B8ACh */ case   15:  		/* bc 12, CR6_EQ, 128 */
		/* 8222B8ACh case   15:*/		if ( regs.CR[6].eq ) { return 0x8222B92C;  }
		/* 8222B8ACh case   15:*/		return 0x8222B8B0;
		  /* 8222B8B0h */ case   16:  		/* cmpwi CR6, R10, 90 */
		/* 8222B8B0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005A);
		/* 8222B8B0h case   16:*/		return 0x8222B8B4;
		  /* 8222B8B4h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 8222B8B4h case   17:*/		if ( regs.CR[6].eq ) { return 0x8222B8C8;  }
		/* 8222B8B4h case   17:*/		return 0x8222B8B8;
		  /* 8222B8B8h */ case   18:  		/* lis R11, -32252 */
		/* 8222B8B8h case   18:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8222B8B8h case   18:*/		return 0x8222B8BC;
		  /* 8222B8BCh */ case   19:  		/* li R4, 3500 */
		/* 8222B8BCh case   19:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 8222B8BCh case   19:*/		return 0x8222B8C0;
		  /* 8222B8C0h */ case   20:  		/* addi R5, R11, -13284 */
		/* 8222B8C0h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFCC1C);
		/* 8222B8C0h case   20:*/		return 0x8222B8C4;
		  /* 8222B8C4h */ case   21:  		/* bl -891484 */
		/* 8222B8C4h case   21:*/		regs.LR = 0x8222B8C8; return 0x82151E68;
		/* 8222B8C4h case   21:*/		return 0x8222B8C8;
	}
	return 0x8222B8C8;
} // Block from 8222B870h-8222B8C8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8222B8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B8C8);
		  /* 8222B8C8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8222B8C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8222B8C8h case    0:*/		return 0x8222B8CC;
		  /* 8222B8CCh */ case    1:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8222B8CCh case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8222B8CCh case    1:*/		return 0x8222B8D0;
		  /* 8222B8D0h */ case    2:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8222B8D0h case    2:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8222B8D0h case    2:*/		return 0x8222B8D4;
		  /* 8222B8D4h */ case    3:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8222B8D4h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8222B8D4h case    3:*/		return 0x8222B8D8;
		  /* 8222B8D8h */ case    4:  		/* bl -816296 */
		/* 8222B8D8h case    4:*/		regs.LR = 0x8222B8DC; return 0x82164430;
		/* 8222B8D8h case    4:*/		return 0x8222B8DC;
		  /* 8222B8DCh */ case    5:  		/* lwz R27, <#[R31 + 28]> */
		/* 8222B8DCh case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x0000001C) );
		/* 8222B8DCh case    5:*/		return 0x8222B8E0;
		  /* 8222B8E0h */ case    6:  		/* addi R11, R31, -16 */
		/* 8222B8E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8222B8E0h case    6:*/		return 0x8222B8E4;
		  /* 8222B8E4h */ case    7:  		/* addi R28, R27, 12 */
		/* 8222B8E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0xC);
		/* 8222B8E4h case    7:*/		return 0x8222B8E8;
	}
	return 0x8222B8E8;
} // Block from 8222B8C8h-8222B8E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8222B8E8h
// Function '?InsertNewCopy@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@UInstructionPlacementPoint@12@PAV32@W4Component@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8222B8E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8222B8E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8222B8E8);
		  /* 8222B8E8h */ case    0:  		/* lwz R29, <#[R27 + 12]> */
		/* 8222B8E8h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x0000000C) );
		/* 8222B8E8h case    0:*/		return 0x8222B8EC;
		  /* 8222B8ECh */ case    1:  		/* lwzx R26, <#[R3 + R11]> */
		/* 8222B8ECh case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 8222B8ECh case    1:*/		return 0x8222B8F0;
		  /* 8222B8F0h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 8222B8F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8222B8F0h case    2:*/		return 0x8222B8F4;
		  /* 8222B8F4h */ case    3:  		/* bc 12, CR6_EQ, 264 */
		/* 8222B8F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8222B9FC;  }
		/* 8222B8F4h case    3:*/		return 0x8222B8F8;
		  /* 8222B8F8h */ case    4:  		/* lwz R5, <#[R29]> */
		/* 8222B8F8h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x00000000) );
		/* 8222B8F8h case    4:*/		return 0x8222B8FC;
		  /* 8222B8FCh */ case    5:  		/* cmplw CR6, R5, R26 */
		/* 8222B8FCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R26);
		/* 8222B8FCh case    5:*/		return 0x8222B900;
		  /* 8222B900h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8222B900h case    6:*/		if ( regs.CR[6].eq ) { return 0x8222B914;  }
		/* 8222B900h case    6:*/		return 0x8222B904;
		  /* 8222B904h */ case    7:  		/* mr R4, R27 */
		/* 8222B904h case    7:*/		regs.R4 = regs.R27;
		/* 8222B904h case    7:*/		return 0x8222B908;
		  /* 8222B908h */ case    8:  		/* mr R3, R30 */
		/* 8222B908h case    8:*/		regs.R3 = regs.R30;
		/* 8222B908h case    8:*/		return 0x8222B90C;
		  /* 8222B90Ch */ case    9:  		/* bl -445532 */
		/* 8222B90Ch case    9:*/		regs.LR = 0x8222B910; return 0x821BECB0;
		/* 8222B90Ch case    9:*/		return 0x8222B910;
		  /* 8222B910h */ case   10:  		/* li R25, 1 */
		/* 8222B910h case   10:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8222B910h case   10:*/		return 0x8222B914;
	}
	return 0x8222B914;
} // Block from 8222B8E8h-8222B914h (11 instructions)

