#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82160A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160A74);
		  /* 82160A74h */ case    0:  		/* lwz R3, <#[R31 + 44]> */
		/* 82160A74h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82160A74h case    0:*/		return 0x82160A78;
		  /* 82160A78h */ case    1:  		/* bl -8768 */
		/* 82160A78h case    1:*/		regs.LR = 0x82160A7C; return 0x8215E838;
		/* 82160A78h case    1:*/		return 0x82160A7C;
		  /* 82160A7Ch */ case    2:  		/* mr R3, R27 */
		/* 82160A7Ch case    2:*/		regs.R3 = regs.R27;
		/* 82160A7Ch case    2:*/		return 0x82160A80;
		  /* 82160A80h */ case    3:  		/* lwz R4, <#[R31 + 44]> */
		/* 82160A80h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000002C) );
		/* 82160A80h case    3:*/		return 0x82160A84;
		  /* 82160A84h */ case    4:  		/* bl -13348 */
		/* 82160A84h case    4:*/		regs.LR = 0x82160A88; return 0x8215D660;
		/* 82160A84h case    4:*/		return 0x82160A88;
		  /* 82160A88h */ case    5:  		/* lis R11, -32252 */
		/* 82160A88h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160A88h case    5:*/		return 0x82160A8C;
		  /* 82160A8Ch */ case    6:  		/* mr R5, R28 */
		/* 82160A8Ch case    6:*/		regs.R5 = regs.R28;
		/* 82160A8Ch case    6:*/		return 0x82160A90;
		  /* 82160A90h */ case    7:  		/* addi R4, R11, -18168 */
		/* 82160A90h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFB908);
		/* 82160A90h case    7:*/		return 0x82160A94;
		  /* 82160A94h */ case    8:  		/* mr R3, R30 */
		/* 82160A94h case    8:*/		regs.R3 = regs.R30;
		/* 82160A94h case    8:*/		return 0x82160A98;
		  /* 82160A98h */ case    9:  		/* bl 772392 */
		/* 82160A98h case    9:*/		regs.LR = 0x82160A9C; return 0x8221D3C0;
		/* 82160A98h case    9:*/		return 0x82160A9C;
		  /* 82160A9Ch */ case   10:  		/* mr R6, R26 */
		/* 82160A9Ch case   10:*/		regs.R6 = regs.R26;
		/* 82160A9Ch case   10:*/		return 0x82160AA0;
		  /* 82160AA0h */ case   11:  		/* mr R5, R29 */
		/* 82160AA0h case   11:*/		regs.R5 = regs.R29;
		/* 82160AA0h case   11:*/		return 0x82160AA4;
		  /* 82160AA4h */ case   12:  		/* mr R4, R27 */
		/* 82160AA4h case   12:*/		regs.R4 = regs.R27;
		/* 82160AA4h case   12:*/		return 0x82160AA8;
		  /* 82160AA8h */ case   13:  		/* mr R3, R30 */
		/* 82160AA8h case   13:*/		regs.R3 = regs.R30;
		/* 82160AA8h case   13:*/		return 0x82160AAC;
		  /* 82160AACh */ case   14:  		/* bl 775804 */
		/* 82160AACh case   14:*/		regs.LR = 0x82160AB0; return 0x8221E128;
		/* 82160AACh case   14:*/		return 0x82160AB0;
		  /* 82160AB0h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 82160AB0h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82160AB0h case   15:*/		return 0x82160AB4;
		  /* 82160AB4h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 82160AB4h case   16:*/		if ( regs.CR[0].eq ) { return 0x82160ABC;  }
		/* 82160AB4h case   16:*/		return 0x82160AB8;
		  /* 82160AB8h */ case   17:  		/* mr R25, R3 */
		/* 82160AB8h case   17:*/		regs.R25 = regs.R3;
		/* 82160AB8h case   17:*/		return 0x82160ABC;
	}
	return 0x82160ABC;
} // Block from 82160A74h-82160ABCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 82160ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160ABC);
		  /* 82160ABCh */ case    0:  		/* mr R3, R27 */
		/* 82160ABCh case    0:*/		regs.R3 = regs.R27;
		/* 82160ABCh case    0:*/		return 0x82160AC0;
		  /* 82160AC0h */ case    1:  		/* bl -10304 */
		/* 82160AC0h case    1:*/		regs.LR = 0x82160AC4; return 0x8215E280;
		/* 82160AC0h case    1:*/		return 0x82160AC4;
		  /* 82160AC4h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82160AC4h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82160AC4h case    2:*/		return 0x82160AC8;
		  /* 82160AC8h */ case    3:  		/* bc 4, CR0_EQ, 40 */
		/* 82160AC8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82160AF0;  }
		/* 82160AC8h case    3:*/		return 0x82160ACC;
		  /* 82160ACCh */ case    4:  		/* cmpwi CR6, R25, 0 */
		/* 82160ACCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82160ACCh case    4:*/		return 0x82160AD0;
		  /* 82160AD0h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82160AD0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82160AEC;  }
		/* 82160AD0h case    5:*/		return 0x82160AD4;
		  /* 82160AD4h */ case    6:  		/* lis R11, -32252 */
		/* 82160AD4h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160AD4h case    6:*/		return 0x82160AD8;
		  /* 82160AD8h */ case    7:  		/* mr R6, R23 */
		/* 82160AD8h case    7:*/		regs.R6 = regs.R23;
		/* 82160AD8h case    7:*/		return 0x82160ADC;
		  /* 82160ADCh */ case    8:  		/* addi R5, R11, -18188 */
		/* 82160ADCh case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB8F4);
		/* 82160ADCh case    8:*/		return 0x82160AE0;
		  /* 82160AE0h */ case    9:  		/* mr R4, R24 */
		/* 82160AE0h case    9:*/		regs.R4 = regs.R24;
		/* 82160AE0h case    9:*/		return 0x82160AE4;
		  /* 82160AE4h */ case   10:  		/* li R7, 682 */
		/* 82160AE4h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x2AA);
		/* 82160AE4h case   10:*/		return 0x82160AE8;
		  /* 82160AE8h */ case   11:  		/* bl -36576 */
		/* 82160AE8h case   11:*/		regs.LR = 0x82160AEC; return 0x82157C08;
		/* 82160AE8h case   11:*/		return 0x82160AEC;
	}
	return 0x82160AEC;
} // Block from 82160ABCh-82160AECh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82160AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160AEC);
		  /* 82160AECh */ case    0:  		/* mr R3, R25 */
		/* 82160AECh case    0:*/		regs.R3 = regs.R25;
		/* 82160AECh case    0:*/		return 0x82160AF0;
	}
	return 0x82160AF0;
} // Block from 82160AECh-82160AF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160AF0);
		  /* 82160AF0h */ case    0:  		/* addi R1, R1, 160 */
		/* 82160AF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82160AF0h case    0:*/		return 0x82160AF4;
		  /* 82160AF4h */ case    1:  		/* b -850016 */
		/* 82160AF4h case    1:*/		return 0x82091294;
		/* 82160AF4h case    1:*/		return 0x82160AF8;
	}
	return 0x82160AF8;
} // Block from 82160AF0h-82160AF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82160AF8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160AF8);
		  /* 82160AF8h */ case    0:  		/* mfspr R12, LR */
		/* 82160AF8h case    0:*/		regs.R12 = regs.LR;
		/* 82160AF8h case    0:*/		return 0x82160AFC;
		  /* 82160AFCh */ case    1:  		/* bl -850116 */
		/* 82160AFCh case    1:*/		regs.LR = 0x82160B00; return 0x82091238;
		/* 82160AFCh case    1:*/		return 0x82160B00;
		  /* 82160B00h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82160B00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82160B00h case    2:*/		return 0x82160B04;
		  /* 82160B04h */ case    3:  		/* mr R28, R10 */
		/* 82160B04h case    3:*/		regs.R28 = regs.R10;
		/* 82160B04h case    3:*/		return 0x82160B08;
	}
	return 0x82160B08;
} // Block from 82160AF8h-82160B08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82160B08h
// Function '?SS_Create@XGRAPHICS@@YAPAU_SS_SHADER_STORE@1@PAXP6APAX0I@ZP6A?AW4_E_SSM_RETURNCODE@1@00@ZPAU_ORDERED_LIST_FACTORY@1@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160B08);
		  /* 82160B08h */ case    0:  		/* lis R11, -32253 */
		/* 82160B08h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82160B08h case    0:*/		return 0x82160B0C;
		  /* 82160B0Ch */ case    1:  		/* lis R10, -32252 */
		/* 82160B0Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 82160B0Ch case    1:*/		return 0x82160B10;
		  /* 82160B10h */ case    2:  		/* mr R30, R3 */
		/* 82160B10h case    2:*/		regs.R30 = regs.R3;
		/* 82160B10h case    2:*/		return 0x82160B14;
		  /* 82160B14h */ case    3:  		/* mr R29, R4 */
		/* 82160B14h case    3:*/		regs.R29 = regs.R4;
		/* 82160B14h case    3:*/		return 0x82160B18;
		  /* 82160B18h */ case    4:  		/* mr R27, R5 */
		/* 82160B18h case    4:*/		regs.R27 = regs.R5;
		/* 82160B18h case    4:*/		return 0x82160B1C;
		  /* 82160B1Ch */ case    5:  		/* mr R24, R6 */
		/* 82160B1Ch case    5:*/		regs.R24 = regs.R6;
		/* 82160B1Ch case    5:*/		return 0x82160B20;
		  /* 82160B20h */ case    6:  		/* mr R26, R7 */
		/* 82160B20h case    6:*/		regs.R26 = regs.R7;
		/* 82160B20h case    6:*/		return 0x82160B24;
		  /* 82160B24h */ case    7:  		/* mr R23, R8 */
		/* 82160B24h case    7:*/		regs.R23 = regs.R8;
		/* 82160B24h case    7:*/		return 0x82160B28;
		  /* 82160B28h */ case    8:  		/* mr R22, R9 */
		/* 82160B28h case    8:*/		regs.R22 = regs.R9;
		/* 82160B28h case    8:*/		return 0x82160B2C;
		  /* 82160B2Ch */ case    9:  		/* cmplwi CR6, R3, 0 */
		/* 82160B2Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82160B2Ch case    9:*/		return 0x82160B30;
		  /* 82160B30h */ case   10:  		/* addi R21, R11, 27460 */
		/* 82160B30h case   10:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0x6B44);
		/* 82160B30h case   10:*/		return 0x82160B34;
		  /* 82160B34h */ case   11:  		/* addi R20, R10, -18440 */
		/* 82160B34h case   11:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R10,0xFFFFB7F8);
		/* 82160B34h case   11:*/		return 0x82160B38;
		  /* 82160B38h */ case   12:  		/* bc 4, CR6_EQ, 32 */
		/* 82160B38h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82160B58;  }
		/* 82160B38h case   12:*/		return 0x82160B3C;
		  /* 82160B3Ch */ case   13:  		/* lis R11, -32252 */
		/* 82160B3Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160B3Ch case   13:*/		return 0x82160B40;
		  /* 82160B40h */ case   14:  		/* mr R6, R20 */
		/* 82160B40h case   14:*/		regs.R6 = regs.R20;
		/* 82160B40h case   14:*/		return 0x82160B44;
		  /* 82160B44h */ case   15:  		/* addi R5, R11, -18036 */
		/* 82160B44h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB98C);
		/* 82160B44h case   15:*/		return 0x82160B48;
		  /* 82160B48h */ case   16:  		/* mr R4, R21 */
		/* 82160B48h case   16:*/		regs.R4 = regs.R21;
		/* 82160B48h case   16:*/		return 0x82160B4C;
		  /* 82160B4Ch */ case   17:  		/* li R7, 139 */
		/* 82160B4Ch case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x8B);
		/* 82160B4Ch case   17:*/		return 0x82160B50;
		  /* 82160B50h */ case   18:  		/* li R3, 0 */
		/* 82160B50h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160B50h case   18:*/		return 0x82160B54;
		  /* 82160B54h */ case   19:  		/* bl -36684 */
		/* 82160B54h case   19:*/		regs.LR = 0x82160B58; return 0x82157C08;
		/* 82160B54h case   19:*/		return 0x82160B58;
	}
	return 0x82160B58;
} // Block from 82160B08h-82160B58h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82160B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160B58);
		  /* 82160B58h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82160B58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82160B58h case    0:*/		return 0x82160B5C;
		  /* 82160B5Ch */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160B5Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160B7C;  }
		/* 82160B5Ch case    1:*/		return 0x82160B60;
		  /* 82160B60h */ case    2:  		/* lis R11, -32252 */
		/* 82160B60h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160B60h case    2:*/		return 0x82160B64;
		  /* 82160B64h */ case    3:  		/* mr R6, R20 */
		/* 82160B64h case    3:*/		regs.R6 = regs.R20;
		/* 82160B64h case    3:*/		return 0x82160B68;
		  /* 82160B68h */ case    4:  		/* addi R5, R11, -21620 */
		/* 82160B68h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAB8C);
		/* 82160B68h case    4:*/		return 0x82160B6C;
		  /* 82160B6Ch */ case    5:  		/* mr R4, R21 */
		/* 82160B6Ch case    5:*/		regs.R4 = regs.R21;
		/* 82160B6Ch case    5:*/		return 0x82160B70;
		  /* 82160B70h */ case    6:  		/* li R7, 140 */
		/* 82160B70h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x8C);
		/* 82160B70h case    6:*/		return 0x82160B74;
		  /* 82160B74h */ case    7:  		/* li R3, 0 */
		/* 82160B74h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160B74h case    7:*/		return 0x82160B78;
		  /* 82160B78h */ case    8:  		/* bl -36720 */
		/* 82160B78h case    8:*/		regs.LR = 0x82160B7C; return 0x82157C08;
		/* 82160B78h case    8:*/		return 0x82160B7C;
	}
	return 0x82160B7C;
} // Block from 82160B58h-82160B7Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160B7C);
		  /* 82160B7Ch */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82160B7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82160B7Ch case    0:*/		return 0x82160B80;
		  /* 82160B80h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160B80h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160BA0;  }
		/* 82160B80h case    1:*/		return 0x82160B84;
		  /* 82160B84h */ case    2:  		/* lis R11, -32252 */
		/* 82160B84h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160B84h case    2:*/		return 0x82160B88;
		  /* 82160B88h */ case    3:  		/* mr R6, R20 */
		/* 82160B88h case    3:*/		regs.R6 = regs.R20;
		/* 82160B88h case    3:*/		return 0x82160B8C;
		  /* 82160B8Ch */ case    4:  		/* addi R5, R11, -21632 */
		/* 82160B8Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAB80);
		/* 82160B8Ch case    4:*/		return 0x82160B90;
		  /* 82160B90h */ case    5:  		/* mr R4, R21 */
		/* 82160B90h case    5:*/		regs.R4 = regs.R21;
		/* 82160B90h case    5:*/		return 0x82160B94;
		  /* 82160B94h */ case    6:  		/* li R7, 141 */
		/* 82160B94h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x8D);
		/* 82160B94h case    6:*/		return 0x82160B98;
		  /* 82160B98h */ case    7:  		/* li R3, 0 */
		/* 82160B98h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160B98h case    7:*/		return 0x82160B9C;
		  /* 82160B9Ch */ case    8:  		/* bl -36756 */
		/* 82160B9Ch case    8:*/		regs.LR = 0x82160BA0; return 0x82157C08;
		/* 82160B9Ch case    8:*/		return 0x82160BA0;
	}
	return 0x82160BA0;
} // Block from 82160B7Ch-82160BA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160BA0);
		  /* 82160BA0h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82160BA0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82160BA0h case    0:*/		return 0x82160BA4;
		  /* 82160BA4h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160BA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160BC4;  }
		/* 82160BA4h case    1:*/		return 0x82160BA8;
		  /* 82160BA8h */ case    2:  		/* lis R11, -32252 */
		/* 82160BA8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160BA8h case    2:*/		return 0x82160BAC;
		  /* 82160BACh */ case    3:  		/* mr R6, R20 */
		/* 82160BACh case    3:*/		regs.R6 = regs.R20;
		/* 82160BACh case    3:*/		return 0x82160BB0;
		  /* 82160BB0h */ case    4:  		/* addi R5, R11, -18052 */
		/* 82160BB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB97C);
		/* 82160BB0h case    4:*/		return 0x82160BB4;
		  /* 82160BB4h */ case    5:  		/* mr R4, R21 */
		/* 82160BB4h case    5:*/		regs.R4 = regs.R21;
		/* 82160BB4h case    5:*/		return 0x82160BB8;
		  /* 82160BB8h */ case    6:  		/* li R7, 142 */
		/* 82160BB8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x8E);
		/* 82160BB8h case    6:*/		return 0x82160BBC;
		  /* 82160BBCh */ case    7:  		/* li R3, 0 */
		/* 82160BBCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160BBCh case    7:*/		return 0x82160BC0;
		  /* 82160BC0h */ case    8:  		/* bl -36792 */
		/* 82160BC0h case    8:*/		regs.LR = 0x82160BC4; return 0x82157C08;
		/* 82160BC0h case    8:*/		return 0x82160BC4;
	}
	return 0x82160BC4;
} // Block from 82160BA0h-82160BC4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160BC4);
		  /* 82160BC4h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 82160BC4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82160BC4h case    0:*/		return 0x82160BC8;
		  /* 82160BC8h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160BC8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160BE8;  }
		/* 82160BC8h case    1:*/		return 0x82160BCC;
		  /* 82160BCCh */ case    2:  		/* lis R11, -32252 */
		/* 82160BCCh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160BCCh case    2:*/		return 0x82160BD0;
		  /* 82160BD0h */ case    3:  		/* mr R6, R20 */
		/* 82160BD0h case    3:*/		regs.R6 = regs.R20;
		/* 82160BD0h case    3:*/		return 0x82160BD4;
		  /* 82160BD4h */ case    4:  		/* addi R5, R11, -18788 */
		/* 82160BD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB69C);
		/* 82160BD4h case    4:*/		return 0x82160BD8;
		  /* 82160BD8h */ case    5:  		/* mr R4, R21 */
		/* 82160BD8h case    5:*/		regs.R4 = regs.R21;
		/* 82160BD8h case    5:*/		return 0x82160BDC;
		  /* 82160BDCh */ case    6:  		/* li R7, 143 */
		/* 82160BDCh case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x8F);
		/* 82160BDCh case    6:*/		return 0x82160BE0;
		  /* 82160BE0h */ case    7:  		/* li R3, 0 */
		/* 82160BE0h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160BE0h case    7:*/		return 0x82160BE4;
		  /* 82160BE4h */ case    8:  		/* bl -36828 */
		/* 82160BE4h case    8:*/		regs.LR = 0x82160BE8; return 0x82157C08;
		/* 82160BE4h case    8:*/		return 0x82160BE8;
	}
	return 0x82160BE8;
} // Block from 82160BC4h-82160BE8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160BE8);
		  /* 82160BE8h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 82160BE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82160BE8h case    0:*/		return 0x82160BEC;
		  /* 82160BECh */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160BECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160C0C;  }
		/* 82160BECh case    1:*/		return 0x82160BF0;
		  /* 82160BF0h */ case    2:  		/* lis R11, -32252 */
		/* 82160BF0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160BF0h case    2:*/		return 0x82160BF4;
		  /* 82160BF4h */ case    3:  		/* mr R6, R20 */
		/* 82160BF4h case    3:*/		regs.R6 = regs.R20;
		/* 82160BF4h case    3:*/		return 0x82160BF8;
		  /* 82160BF8h */ case    4:  		/* addi R5, R11, -18068 */
		/* 82160BF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB96C);
		/* 82160BF8h case    4:*/		return 0x82160BFC;
		  /* 82160BFCh */ case    5:  		/* mr R4, R21 */
		/* 82160BFCh case    5:*/		regs.R4 = regs.R21;
		/* 82160BFCh case    5:*/		return 0x82160C00;
		  /* 82160C00h */ case    6:  		/* li R7, 144 */
		/* 82160C00h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x90);
		/* 82160C00h case    6:*/		return 0x82160C04;
		  /* 82160C04h */ case    7:  		/* li R3, 0 */
		/* 82160C04h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160C04h case    7:*/		return 0x82160C08;
		  /* 82160C08h */ case    8:  		/* bl -36864 */
		/* 82160C08h case    8:*/		regs.LR = 0x82160C0C; return 0x82157C08;
		/* 82160C08h case    8:*/		return 0x82160C0C;
	}
	return 0x82160C0C;
} // Block from 82160BE8h-82160C0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160C0C);
		  /* 82160C0Ch */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82160C0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82160C0Ch case    0:*/		return 0x82160C10;
		  /* 82160C10h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160C10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160C30;  }
		/* 82160C10h case    1:*/		return 0x82160C14;
		  /* 82160C14h */ case    2:  		/* lis R11, -32252 */
		/* 82160C14h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160C14h case    2:*/		return 0x82160C18;
		  /* 82160C18h */ case    3:  		/* mr R6, R20 */
		/* 82160C18h case    3:*/		regs.R6 = regs.R20;
		/* 82160C18h case    3:*/		return 0x82160C1C;
		  /* 82160C1Ch */ case    4:  		/* addi R5, R11, -21104 */
		/* 82160C1Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFAD90);
		/* 82160C1Ch case    4:*/		return 0x82160C20;
		  /* 82160C20h */ case    5:  		/* mr R4, R21 */
		/* 82160C20h case    5:*/		regs.R4 = regs.R21;
		/* 82160C20h case    5:*/		return 0x82160C24;
		  /* 82160C24h */ case    6:  		/* li R7, 145 */
		/* 82160C24h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x91);
		/* 82160C24h case    6:*/		return 0x82160C28;
		  /* 82160C28h */ case    7:  		/* li R3, 0 */
		/* 82160C28h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160C28h case    7:*/		return 0x82160C2C;
		  /* 82160C2Ch */ case    8:  		/* bl -36900 */
		/* 82160C2Ch case    8:*/		regs.LR = 0x82160C30; return 0x82157C08;
		/* 82160C2Ch case    8:*/		return 0x82160C30;
	}
	return 0x82160C30;
} // Block from 82160C0Ch-82160C30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160C30);
		  /* 82160C30h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 82160C30h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82160C30h case    0:*/		return 0x82160C34;
		  /* 82160C34h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82160C34h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160C54;  }
		/* 82160C34h case    1:*/		return 0x82160C38;
		  /* 82160C38h */ case    2:  		/* lis R11, -32252 */
		/* 82160C38h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160C38h case    2:*/		return 0x82160C3C;
		  /* 82160C3Ch */ case    3:  		/* mr R6, R20 */
		/* 82160C3Ch case    3:*/		regs.R6 = regs.R20;
		/* 82160C3Ch case    3:*/		return 0x82160C40;
		  /* 82160C40h */ case    4:  		/* addi R5, R11, -18080 */
		/* 82160C40h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB960);
		/* 82160C40h case    4:*/		return 0x82160C44;
		  /* 82160C44h */ case    5:  		/* mr R4, R21 */
		/* 82160C44h case    5:*/		regs.R4 = regs.R21;
		/* 82160C44h case    5:*/		return 0x82160C48;
		  /* 82160C48h */ case    6:  		/* li R7, 146 */
		/* 82160C48h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x92);
		/* 82160C48h case    6:*/		return 0x82160C4C;
		  /* 82160C4Ch */ case    7:  		/* li R3, 0 */
		/* 82160C4Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160C4Ch case    7:*/		return 0x82160C50;
		  /* 82160C50h */ case    8:  		/* bl -36936 */
		/* 82160C50h case    8:*/		regs.LR = 0x82160C54; return 0x82157C08;
		/* 82160C50h case    8:*/		return 0x82160C54;
	}
	return 0x82160C54;
} // Block from 82160C30h-82160C54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160C54);
		  /* 82160C54h */ case    0:  		/* li R4, 1 */
		/* 82160C54h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82160C54h case    0:*/		return 0x82160C58;
		  /* 82160C58h */ case    1:  		/* mr R3, R28 */
		/* 82160C58h case    1:*/		regs.R3 = regs.R28;
		/* 82160C58h case    1:*/		return 0x82160C5C;
		  /* 82160C5Ch */ case    2:  		/* bl 693548 */
		/* 82160C5Ch case    2:*/		regs.LR = 0x82160C60; return 0x8220A188;
		/* 82160C5Ch case    2:*/		return 0x82160C60;
		  /* 82160C60h */ case    3:  		/* mr R25, R3 */
		/* 82160C60h case    3:*/		regs.R25 = regs.R3;
		/* 82160C60h case    3:*/		return 0x82160C64;
		  /* 82160C64h */ case    4:  		/* li R4, 48 */
		/* 82160C64h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 82160C64h case    4:*/		return 0x82160C68;
		  /* 82160C68h */ case    5:  		/* mtspr CTR, R29 */
		/* 82160C68h case    5:*/		regs.CTR = regs.R29;
		/* 82160C68h case    5:*/		return 0x82160C6C;
		  /* 82160C6Ch */ case    6:  		/* mr R3, R30 */
		/* 82160C6Ch case    6:*/		regs.R3 = regs.R30;
		/* 82160C6Ch case    6:*/		return 0x82160C70;
		  /* 82160C70h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82160C70h case    7:*/		if ( 1 ) { regs.LR = 0x82160C74; return (uint32)regs.CTR; }
		/* 82160C70h case    7:*/		return 0x82160C74;
		  /* 82160C74h */ case    8:  		/* or. R31, R3, R3 */
		/* 82160C74h case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82160C74h case    8:*/		return 0x82160C78;
		  /* 82160C78h */ case    9:  		/* bc 4, CR0_EQ, 40 */
		/* 82160C78h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82160CA0;  }
		/* 82160C78h case    9:*/		return 0x82160C7C;
		  /* 82160C7Ch */ case   10:  		/* lis R11, -32252 */
		/* 82160C7Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160C7Ch case   10:*/		return 0x82160C80;
		  /* 82160C80h */ case   11:  		/* mr R6, R20 */
		/* 82160C80h case   11:*/		regs.R6 = regs.R20;
		/* 82160C80h case   11:*/		return 0x82160C84;
		  /* 82160C84h */ case   12:  		/* addi R5, R11, -18460 */
		/* 82160C84h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB7E4);
		/* 82160C84h case   12:*/		return 0x82160C88;
		  /* 82160C88h */ case   13:  		/* mr R4, R21 */
		/* 82160C88h case   13:*/		regs.R4 = regs.R21;
		/* 82160C88h case   13:*/		return 0x82160C8C;
		  /* 82160C8Ch */ case   14:  		/* li R7, 156 */
		/* 82160C8Ch case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x9C);
		/* 82160C8Ch case   14:*/		return 0x82160C90;
		  /* 82160C90h */ case   15:  		/* li R3, 0 */
		/* 82160C90h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160C90h case   15:*/		return 0x82160C94;
		  /* 82160C94h */ case   16:  		/* bl -37004 */
		/* 82160C94h case   16:*/		regs.LR = 0x82160C98; return 0x82157C08;
		/* 82160C94h case   16:*/		return 0x82160C98;
		  /* 82160C98h */ case   17:  		/* li R3, 0 */
		/* 82160C98h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160C98h case   17:*/		return 0x82160C9C;
		  /* 82160C9Ch */ case   18:  		/* b 360 */
		/* 82160C9Ch case   18:*/		return 0x82160E04;
		/* 82160C9Ch case   18:*/		return 0x82160CA0;
	}
	return 0x82160CA0;
} // Block from 82160C54h-82160CA0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82160CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160CA0);
		  /* 82160CA0h */ case    0:  		/* stw R30, <#[R31]> */
		/* 82160CA0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 82160CA0h case    0:*/		return 0x82160CA4;
		  /* 82160CA4h */ case    1:  		/* mr R6, R28 */
		/* 82160CA4h case    1:*/		regs.R6 = regs.R28;
		/* 82160CA4h case    1:*/		return 0x82160CA8;
		  /* 82160CA8h */ case    2:  		/* stw R29, <#[R31 + 4]> */
		/* 82160CA8h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 82160CA8h case    2:*/		return 0x82160CAC;
		  /* 82160CACh */ case    3:  		/* mr R5, R27 */
		/* 82160CACh case    3:*/		regs.R5 = regs.R27;
		/* 82160CACh case    3:*/		return 0x82160CB0;
		  /* 82160CB0h */ case    4:  		/* stw R27, <#[R31 + 8]> */
		/* 82160CB0h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000008) );
		/* 82160CB0h case    4:*/		return 0x82160CB4;
		  /* 82160CB4h */ case    5:  		/* mr R4, R29 */
		/* 82160CB4h case    5:*/		regs.R4 = regs.R29;
		/* 82160CB4h case    5:*/		return 0x82160CB8;
	}
	return 0x82160CB8;
} // Block from 82160CA0h-82160CB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82160CB8h
// Function '?SS_StoreIL@XGRAPHICS@@YA?AW4_E_SSM_RETURNCODE@1@PAU_SS_SHADER_STORE@1@PAXIPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160CB8);
		  /* 82160CB8h */ case    0:  		/* stw R23, <#[R31 + 20]> */
		/* 82160CB8h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000014) );
		/* 82160CB8h case    0:*/		return 0x82160CBC;
		  /* 82160CBCh */ case    1:  		/* mr R3, R30 */
		/* 82160CBCh case    1:*/		regs.R3 = regs.R30;
		/* 82160CBCh case    1:*/		return 0x82160CC0;
		  /* 82160CC0h */ case    2:  		/* stw R26, <#[R31 + 16]> */
		/* 82160CC0h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000010) );
		/* 82160CC0h case    2:*/		return 0x82160CC4;
		  /* 82160CC4h */ case    3:  		/* stw R24, <#[R31 + 12]> */
		/* 82160CC4h case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 82160CC4h case    3:*/		return 0x82160CC8;
		  /* 82160CC8h */ case    4:  		/* stw R28, <#[R31 + 28]> */
		/* 82160CC8h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000001C) );
		/* 82160CC8h case    4:*/		return 0x82160CCC;
		  /* 82160CCCh */ case    5:  		/* bl -9668 */
		/* 82160CCCh case    5:*/		regs.LR = 0x82160CD0; return 0x8215E708;
		/* 82160CCCh case    5:*/		return 0x82160CD0;
		  /* 82160CD0h */ case    6:  		/* stw R3, <#[R31 + 40]> */
		/* 82160CD0h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 82160CD0h case    6:*/		return 0x82160CD4;
		  /* 82160CD4h */ case    7:  		/* mr R6, R28 */
		/* 82160CD4h case    7:*/		regs.R6 = regs.R28;
		/* 82160CD4h case    7:*/		return 0x82160CD8;
		  /* 82160CD8h */ case    8:  		/* mr R5, R27 */
		/* 82160CD8h case    8:*/		regs.R5 = regs.R27;
		/* 82160CD8h case    8:*/		return 0x82160CDC;
		  /* 82160CDCh */ case    9:  		/* mr R4, R29 */
		/* 82160CDCh case    9:*/		regs.R4 = regs.R29;
		/* 82160CDCh case    9:*/		return 0x82160CE0;
		  /* 82160CE0h */ case   10:  		/* mr R3, R30 */
		/* 82160CE0h case   10:*/		regs.R3 = regs.R30;
		/* 82160CE0h case   10:*/		return 0x82160CE4;
		  /* 82160CE4h */ case   11:  		/* bl -9692 */
		/* 82160CE4h case   11:*/		regs.LR = 0x82160CE8; return 0x8215E708;
		/* 82160CE4h case   11:*/		return 0x82160CE8;
		  /* 82160CE8h */ case   12:  		/* lwz R11, <#[R1 + 276]> */
		/* 82160CE8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000114) );
		/* 82160CE8h case   12:*/		return 0x82160CEC;
		  /* 82160CECh */ case   13:  		/* stw R3, <#[R31 + 44]> */
		/* 82160CECh case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82160CECh case   13:*/		return 0x82160CF0;
		  /* 82160CF0h */ case   14:  		/* mr R3, R30 */
		/* 82160CF0h case   14:*/		regs.R3 = regs.R30;
		/* 82160CF0h case   14:*/		return 0x82160CF4;
		  /* 82160CF4h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 82160CF4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82160CF4h case   15:*/		return 0x82160CF8;
		  /* 82160CF8h */ case   16:  		/* bc 4, CR6_EQ, 180 */
		/* 82160CF8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82160DAC;  }
		/* 82160CF8h case   16:*/		return 0x82160CFC;
		  /* 82160CFCh */ case   17:  		/* lis R11, -32234 */
		/* 82160CFCh case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8216);
		/* 82160CFCh case   17:*/		return 0x82160D00;
		  /* 82160D00h */ case   18:  		/* cmplwi CR6, R25, 0 */
		/* 82160D00h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82160D00h case   18:*/		return 0x82160D04;
		  /* 82160D04h */ case   19:  		/* addi R11, R11, 1232 */
		/* 82160D04h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4D0);
		/* 82160D04h case   19:*/		return 0x82160D08;
		  /* 82160D08h */ case   20:  		/* stw R11, <#[R31 + 36]> */
		/* 82160D08h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82160D08h case   20:*/		return 0x82160D0C;
		  /* 82160D0Ch */ case   21:  		/* bc 4, CR6_EQ, 108 */
		/* 82160D0Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x82160D78;  }
		/* 82160D0Ch case   21:*/		return 0x82160D10;
		  /* 82160D10h */ case   22:  		/* li R4, 2752 */
		/* 82160D10h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0xAC0);
		/* 82160D10h case   22:*/		return 0x82160D14;
		  /* 82160D14h */ case   23:  		/* mtspr CTR, R29 */
		/* 82160D14h case   23:*/		regs.CTR = regs.R29;
		/* 82160D14h case   23:*/		return 0x82160D18;
		  /* 82160D18h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 82160D18h case   24:*/		if ( 1 ) { regs.LR = 0x82160D1C; return (uint32)regs.CTR; }
		/* 82160D18h case   24:*/		return 0x82160D1C;
		  /* 82160D1Ch */ case   25:  		/* cmplwi CR0, R3, 0 */
		/* 82160D1Ch case   25:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82160D1Ch case   25:*/		return 0x82160D20;
		  /* 82160D20h */ case   26:  		/* bc 12, CR0_EQ, 32 */
		/* 82160D20h case   26:*/		if ( regs.CR[0].eq ) { return 0x82160D40;  }
		/* 82160D20h case   26:*/		return 0x82160D24;
		  /* 82160D24h */ case   27:  		/* mr R8, R28 */
		/* 82160D24h case   27:*/		regs.R8 = regs.R28;
		/* 82160D24h case   27:*/		return 0x82160D28;
		  /* 82160D28h */ case   28:  		/* mr R7, R26 */
		/* 82160D28h case   28:*/		regs.R7 = regs.R26;
		/* 82160D28h case   28:*/		return 0x82160D2C;
		  /* 82160D2Ch */ case   29:  		/* mr R6, R27 */
		/* 82160D2Ch case   29:*/		regs.R6 = regs.R27;
		/* 82160D2Ch case   29:*/		return 0x82160D30;
		  /* 82160D30h */ case   30:  		/* mr R5, R29 */
		/* 82160D30h case   30:*/		regs.R5 = regs.R29;
		/* 82160D30h case   30:*/		return 0x82160D34;
		  /* 82160D34h */ case   31:  		/* mr R4, R30 */
		/* 82160D34h case   31:*/		regs.R4 = regs.R30;
		/* 82160D34h case   31:*/		return 0x82160D38;
		  /* 82160D38h */ case   32:  		/* bl 771728 */
		/* 82160D38h case   32:*/		regs.LR = 0x82160D3C; return 0x8221D3C8;
		/* 82160D38h case   32:*/		return 0x82160D3C;
		  /* 82160D3Ch */ case   33:  		/* b 8 */
		/* 82160D3Ch case   33:*/		return 0x82160D44;
		/* 82160D3Ch case   33:*/		return 0x82160D40;
	}
	return 0x82160D40;
} // Block from 82160CB8h-82160D40h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82160D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160D40);
		  /* 82160D40h */ case    0:  		/* li R3, 0 */
		/* 82160D40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160D40h case    0:*/		return 0x82160D44;
	}
	return 0x82160D44;
} // Block from 82160D40h-82160D44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160D44);
		  /* 82160D44h */ case    0:  		/* stw R3, <#[R31 + 32]> */
		/* 82160D44h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 82160D44h case    0:*/		return 0x82160D48;
		  /* 82160D48h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82160D48h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82160D48h case    1:*/		return 0x82160D4C;
		  /* 82160D4Ch */ case    2:  		/* bc 4, CR6_EQ, 180 */
		/* 82160D4Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82160E00;  }
		/* 82160D4Ch case    2:*/		return 0x82160D50;
		  /* 82160D50h */ case    3:  		/* li R7, 201 */
		/* 82160D50h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0xC9);
		/* 82160D50h case    3:*/		return 0x82160D54;
		  /* 82160D54h */ case    4:  		/* lis R11, -32252 */
		/* 82160D54h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160D54h case    4:*/		return 0x82160D58;
		  /* 82160D58h */ case    5:  		/* addi R5, R11, -18112 */
		/* 82160D58h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB940);
		/* 82160D58h case    5:*/		return 0x82160D5C;
		  /* 82160D5Ch */ case    6:  		/* mr R6, R20 */
		/* 82160D5Ch case    6:*/		regs.R6 = regs.R20;
		/* 82160D5Ch case    6:*/		return 0x82160D60;
		  /* 82160D60h */ case    7:  		/* mr R4, R21 */
		/* 82160D60h case    7:*/		regs.R4 = regs.R21;
		/* 82160D60h case    7:*/		return 0x82160D64;
		  /* 82160D64h */ case    8:  		/* li R3, 0 */
		/* 82160D64h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160D64h case    8:*/		return 0x82160D68;
		  /* 82160D68h */ case    9:  		/* bl -37216 */
		/* 82160D68h case    9:*/		regs.LR = 0x82160D6C; return 0x82157C08;
		/* 82160D68h case    9:*/		return 0x82160D6C;
		  /* 82160D6Ch */ case   10:  		/* mr R3, R31 */
		/* 82160D6Ch case   10:*/		regs.R3 = regs.R31;
		/* 82160D6Ch case   10:*/		return 0x82160D70;
		  /* 82160D70h */ case   11:  		/* bl -2480 */
		/* 82160D70h case   11:*/		regs.LR = 0x82160D74; return 0x821603C0;
		/* 82160D70h case   11:*/		return 0x82160D74;
		  /* 82160D74h */ case   12:  		/* b -220 */
		/* 82160D74h case   12:*/		return 0x82160C98;
		/* 82160D74h case   12:*/		return 0x82160D78;
	}
	return 0x82160D78;
} // Block from 82160D44h-82160D78h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82160D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160D78);
		  /* 82160D78h */ case    0:  		/* mr R8, R28 */
		/* 82160D78h case    0:*/		regs.R8 = regs.R28;
		/* 82160D78h case    0:*/		return 0x82160D7C;
		  /* 82160D7Ch */ case    1:  		/* mr R7, R22 */
		/* 82160D7Ch case    1:*/		regs.R7 = regs.R22;
		/* 82160D7Ch case    1:*/		return 0x82160D80;
		  /* 82160D80h */ case    2:  		/* mr R6, R26 */
		/* 82160D80h case    2:*/		regs.R6 = regs.R26;
		/* 82160D80h case    2:*/		return 0x82160D84;
		  /* 82160D84h */ case    3:  		/* mr R5, R27 */
		/* 82160D84h case    3:*/		regs.R5 = regs.R27;
		/* 82160D84h case    3:*/		return 0x82160D88;
		  /* 82160D88h */ case    4:  		/* mr R4, R29 */
		/* 82160D88h case    4:*/		regs.R4 = regs.R29;
		/* 82160D88h case    4:*/		return 0x82160D8C;
		  /* 82160D8Ch */ case    5:  		/* bl 751580 */
		/* 82160D8Ch case    5:*/		regs.LR = 0x82160D90; return 0x82218568;
		/* 82160D8Ch case    5:*/		return 0x82160D90;
		  /* 82160D90h */ case    6:  		/* stw R3, <#[R31 + 24]> */
		/* 82160D90h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 82160D90h case    6:*/		return 0x82160D94;
		  /* 82160D94h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 82160D94h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82160D94h case    7:*/		return 0x82160D98;
		  /* 82160D98h */ case    8:  		/* bc 4, CR0_EQ, 104 */
		/* 82160D98h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82160E00;  }
		/* 82160D98h case    8:*/		return 0x82160D9C;
		  /* 82160D9Ch */ case    9:  		/* lis R11, -32252 */
		/* 82160D9Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82160D9Ch case    9:*/		return 0x82160DA0;
		  /* 82160DA0h */ case   10:  		/* li R7, 220 */
		/* 82160DA0h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0xDC);
		/* 82160DA0h case   10:*/		return 0x82160DA4;
		  /* 82160DA4h */ case   11:  		/* addi R5, R11, -18136 */
		/* 82160DA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB928);
		/* 82160DA4h case   11:*/		return 0x82160DA8;
		  /* 82160DA8h */ case   12:  		/* b -76 */
		/* 82160DA8h case   12:*/		return 0x82160D5C;
		/* 82160DA8h case   12:*/		return 0x82160DAC;
	}
	return 0x82160DAC;
} // Block from 82160D78h-82160DACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82160DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160DAC);
		  /* 82160DACh */ case    0:  		/* lis R11, -32234 */
		/* 82160DACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8216);
		/* 82160DACh case    0:*/		return 0x82160DB0;
		  /* 82160DB0h */ case    1:  		/* mtspr CTR, R29 */
		/* 82160DB0h case    1:*/		regs.CTR = regs.R29;
		/* 82160DB0h case    1:*/		return 0x82160DB4;
		  /* 82160DB4h */ case    2:  		/* li R4, 2752 */
		/* 82160DB4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xAC0);
		/* 82160DB4h case    2:*/		return 0x82160DB8;
		  /* 82160DB8h */ case    3:  		/* addi R11, R11, 2192 */
		/* 82160DB8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x890);
		/* 82160DB8h case    3:*/		return 0x82160DBC;
		  /* 82160DBCh */ case    4:  		/* stw R11, <#[R31 + 36]> */
		/* 82160DBCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82160DBCh case    4:*/		return 0x82160DC0;
		  /* 82160DC0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82160DC0h case    5:*/		if ( 1 ) { regs.LR = 0x82160DC4; return (uint32)regs.CTR; }
		/* 82160DC0h case    5:*/		return 0x82160DC4;
		  /* 82160DC4h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 82160DC4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82160DC4h case    6:*/		return 0x82160DC8;
		  /* 82160DC8h */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 82160DC8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82160DE8;  }
		/* 82160DC8h case    7:*/		return 0x82160DCC;
		  /* 82160DCCh */ case    8:  		/* mr R8, R28 */
		/* 82160DCCh case    8:*/		regs.R8 = regs.R28;
		/* 82160DCCh case    8:*/		return 0x82160DD0;
		  /* 82160DD0h */ case    9:  		/* mr R7, R26 */
		/* 82160DD0h case    9:*/		regs.R7 = regs.R26;
		/* 82160DD0h case    9:*/		return 0x82160DD4;
		  /* 82160DD4h */ case   10:  		/* mr R6, R27 */
		/* 82160DD4h case   10:*/		regs.R6 = regs.R27;
		/* 82160DD4h case   10:*/		return 0x82160DD8;
	}
	return 0x82160DD8;
} // Block from 82160DACh-82160DD8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82160DD8h
// Function '?CC_Destroy@XGRAPHICS@@YA?AW4_E_SSM_RETURNCODE@1@PAU_CC_STATE_COMPILER@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160DD8);
		  /* 82160DD8h */ case    0:  		/* mr R5, R29 */
		/* 82160DD8h case    0:*/		regs.R5 = regs.R29;
		/* 82160DD8h case    0:*/		return 0x82160DDC;
		  /* 82160DDCh */ case    1:  		/* mr R4, R30 */
		/* 82160DDCh case    1:*/		regs.R4 = regs.R30;
		/* 82160DDCh case    1:*/		return 0x82160DE0;
		  /* 82160DE0h */ case    2:  		/* bl 771560 */
		/* 82160DE0h case    2:*/		regs.LR = 0x82160DE4; return 0x8221D3C8;
		/* 82160DE0h case    2:*/		return 0x82160DE4;
		  /* 82160DE4h */ case    3:  		/* b 8 */
		/* 82160DE4h case    3:*/		return 0x82160DEC;
		/* 82160DE4h case    3:*/		return 0x82160DE8;
	}
	return 0x82160DE8;
} // Block from 82160DD8h-82160DE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82160DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160DE8);
		  /* 82160DE8h */ case    0:  		/* li R3, 0 */
		/* 82160DE8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82160DE8h case    0:*/		return 0x82160DEC;
	}
	return 0x82160DEC;
} // Block from 82160DE8h-82160DECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160DEC);
		  /* 82160DECh */ case    0:  		/* stw R3, <#[R31 + 32]> */
		/* 82160DECh case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 82160DECh case    0:*/		return 0x82160DF0;
		  /* 82160DF0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82160DF0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82160DF0h case    1:*/		return 0x82160DF4;
		  /* 82160DF4h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82160DF4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82160E00;  }
		/* 82160DF4h case    2:*/		return 0x82160DF8;
		  /* 82160DF8h */ case    3:  		/* li R7, 242 */
		/* 82160DF8h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0xF2);
		/* 82160DF8h case    3:*/		return 0x82160DFC;
		  /* 82160DFCh */ case    4:  		/* b -168 */
		/* 82160DFCh case    4:*/		return 0x82160D54;
		/* 82160DFCh case    4:*/		return 0x82160E00;
	}
	return 0x82160E00;
} // Block from 82160DECh-82160E00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82160E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160E00);
		  /* 82160E00h */ case    0:  		/* mr R3, R31 */
		/* 82160E00h case    0:*/		regs.R3 = regs.R31;
		/* 82160E00h case    0:*/		return 0x82160E04;
	}
	return 0x82160E04;
} // Block from 82160E00h-82160E04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160E04);
		  /* 82160E04h */ case    0:  		/* addi R1, R1, 192 */
		/* 82160E04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82160E04h case    0:*/		return 0x82160E08;
		  /* 82160E08h */ case    1:  		/* b -850816 */
		/* 82160E08h case    1:*/		return 0x82091288;
		/* 82160E08h case    1:*/		return 0x82160E0C;
		  /* 82160E0Ch */ case    2:  		/* nop */
		/* 82160E0Ch case    2:*/		cpu::op::nop();
		/* 82160E0Ch case    2:*/		return 0x82160E10;
	}
	return 0x82160E10;
} // Block from 82160E04h-82160E10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82160E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160E10);
		  /* 82160E10h */ case    0:  		/* mfspr R12, LR */
		/* 82160E10h case    0:*/		regs.R12 = regs.LR;
		/* 82160E10h case    0:*/		return 0x82160E14;
		  /* 82160E14h */ case    1:  		/* bl -850900 */
		/* 82160E14h case    1:*/		regs.LR = 0x82160E18; return 0x82091240;
		/* 82160E14h case    1:*/		return 0x82160E18;
		  /* 82160E18h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82160E18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82160E18h case    2:*/		return 0x82160E1C;
		  /* 82160E1Ch */ case    3:  		/* mr R11, R4 */
		/* 82160E1Ch case    3:*/		regs.R11 = regs.R4;
		/* 82160E1Ch case    3:*/		return 0x82160E20;
		  /* 82160E20h */ case    4:  		/* rlwinm R10, R4, 0, 21, 31 */
		/* 82160E20h case    4:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R4);
		/* 82160E20h case    4:*/		return 0x82160E24;
		  /* 82160E24h */ case    5:  		/* rlwimi R11, R4, 12, 21, 23 */
		/* 82160E24h case    5:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R4);
		/* 82160E24h case    5:*/		return 0x82160E28;
		  /* 82160E28h */ case    6:  		/* mr R31, R3 */
		/* 82160E28h case    6:*/		regs.R31 = regs.R3;
		/* 82160E28h case    6:*/		return 0x82160E2C;
		  /* 82160E2Ch */ case    7:  		/* rlwinm R11, R11, 24, 27, 31 */
		/* 82160E2Ch case    7:*/		cpu::op::rlwinm<0,24,27,31>(regs,&regs.R11,regs.R11);
		/* 82160E2Ch case    7:*/		return 0x82160E30;
		  /* 82160E30h */ case    8:  		/* mr R28, R4 */
		/* 82160E30h case    8:*/		regs.R28 = regs.R4;
		/* 82160E30h case    8:*/		return 0x82160E34;
		  /* 82160E34h */ case    9:  		/* mr R24, R5 */
		/* 82160E34h case    9:*/		regs.R24 = regs.R5;
		/* 82160E34h case    9:*/		return 0x82160E38;
		  /* 82160E38h */ case   10:  		/* mr R26, R6 */
		/* 82160E38h case   10:*/		regs.R26 = regs.R6;
		/* 82160E38h case   10:*/		return 0x82160E3C;
		  /* 82160E3Ch */ case   11:  		/* mr R27, R7 */
		/* 82160E3Ch case   11:*/		regs.R27 = regs.R7;
		/* 82160E3Ch case   11:*/		return 0x82160E40;
		  /* 82160E40h */ case   12:  		/* rlwinm R25, R4, 0, 12, 15 */
		/* 82160E40h case   12:*/		cpu::op::rlwinm<0,0,12,15>(regs,&regs.R25,regs.R4);
		/* 82160E40h case   12:*/		return 0x82160E44;
		  /* 82160E44h */ case   13:  		/* mr R29, R10 */
		/* 82160E44h case   13:*/		regs.R29 = regs.R10;
		/* 82160E44h case   13:*/		return 0x82160E48;
		  /* 82160E48h */ case   14:  		/* li R22, 0 */
		/* 82160E48h case   14:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82160E48h case   14:*/		return 0x82160E4C;
		  /* 82160E4Ch */ case   15:  		/* li R23, 0 */
		/* 82160E4Ch case   15:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82160E4Ch case   15:*/		return 0x82160E50;
		  /* 82160E50h */ case   16:  		/* cmpwi CR6, R11, 3 */
		/* 82160E50h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82160E50h case   16:*/		return 0x82160E54;
		  /* 82160E54h */ case   17:  		/* bc 12, CR6_EQ, 272 */
		/* 82160E54h case   17:*/		if ( regs.CR[6].eq ) { return 0x82160F64;  }
		/* 82160E54h case   17:*/		return 0x82160E58;
		  /* 82160E58h */ case   18:  		/* cmpwi CR6, R11, 4 */
		/* 82160E58h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82160E58h case   18:*/		return 0x82160E5C;
		  /* 82160E5Ch */ case   19:  		/* bc 12, CR6_EQ, 208 */
		/* 82160E5Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82160F2C;  }
		/* 82160E5Ch case   19:*/		return 0x82160E60;
		  /* 82160E60h */ case   20:  		/* cmpwi CR6, R11, 5 */
		/* 82160E60h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 82160E60h case   20:*/		return 0x82160E64;
		  /* 82160E64h */ case   21:  		/* bc 12, CR6_EQ, 180 */
		/* 82160E64h case   21:*/		if ( regs.CR[6].eq ) { return 0x82160F18;  }
		/* 82160E64h case   21:*/		return 0x82160E68;
		  /* 82160E68h */ case   22:  		/* cmpwi CR6, R11, 6 */
		/* 82160E68h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 82160E68h case   22:*/		return 0x82160E6C;
		  /* 82160E6Ch */ case   23:  		/* bc 12, CR6_EQ, 24 */
		/* 82160E6Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82160E84;  }
		/* 82160E6Ch case   23:*/		return 0x82160E70;
		  /* 82160E70h */ case   24:  		/* cmpwi CR6, R11, 19 */
		/* 82160E70h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000013);
		/* 82160E70h case   24:*/		return 0x82160E74;
		  /* 82160E74h */ case   25:  		/* li R30, 4 */
		/* 82160E74h case   25:*/		cpu::op::li<0>(regs,&regs.R30,0x4);
		/* 82160E74h case   25:*/		return 0x82160E78;
		  /* 82160E78h */ case   26:  		/* bc 4, CR6_EQ, 244 */
		/* 82160E78h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82160F6C;  }
		/* 82160E78h case   26:*/		return 0x82160E7C;
		  /* 82160E7Ch */ case   27:  		/* li R29, 32 */
		/* 82160E7Ch case   27:*/		cpu::op::li<0>(regs,&regs.R29,0x20);
		/* 82160E7Ch case   27:*/		return 0x82160E80;
		  /* 82160E80h */ case   28:  		/* b 236 */
		/* 82160E80h case   28:*/		return 0x82160F6C;
		/* 82160E80h case   28:*/		return 0x82160E84;
	}
	return 0x82160E84;
} // Block from 82160E10h-82160E84h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82160E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160E84);
		  /* 82160E84h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 82160E84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82160E84h case    0:*/		return 0x82160E88;
		  /* 82160E88h */ case    1:  		/* cmplwi CR6, R11, 768 */
		/* 82160E88h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000300);
		/* 82160E88h case    1:*/		return 0x82160E8C;
		  /* 82160E8Ch */ case    2:  		/* bc 4, CR6_LT, 28 */
		/* 82160E8Ch case    2:*/		if ( !regs.CR[6].lt ) { return 0x82160EA8;  }
		/* 82160E8Ch case    2:*/		return 0x82160E90;
		  /* 82160E90h */ case    3:  		/* lwz R11, <#[R27 + 1600]> */
		/* 82160E90h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000640) );
		/* 82160E90h case    3:*/		return 0x82160E94;
		  /* 82160E94h */ case    4:  		/* li R30, 17 */
		/* 82160E94h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x11);
		/* 82160E94h case    4:*/		return 0x82160E98;
		  /* 82160E98h */ case    5:  		/* cmplw CR6, R10, R11 */
		/* 82160E98h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82160E98h case    5:*/		return 0x82160E9C;
		  /* 82160E9Ch */ case    6:  		/* bc 4, CR6_GT, 208 */
		/* 82160E9Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x82160F6C;  }
		/* 82160E9Ch case    6:*/		return 0x82160EA0;
		  /* 82160EA0h */ case    7:  		/* stw R10, <#[R27 + 1600]> */
		/* 82160EA0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000640) );
		/* 82160EA0h case    7:*/		return 0x82160EA4;
		  /* 82160EA4h */ case    8:  		/* b 200 */
		/* 82160EA4h case    8:*/		return 0x82160F6C;
		/* 82160EA4h case    8:*/		return 0x82160EA8;
	}
	return 0x82160EA8;
} // Block from 82160E84h-82160EA8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82160EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160EA8);
		  /* 82160EA8h */ case    0:  		/* li R30, 11 */
		/* 82160EA8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xB);
		/* 82160EA8h case    0:*/		return 0x82160EAC;
		  /* 82160EACh */ case    1:  		/* li R11, 0 */
		/* 82160EACh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82160EACh case    1:*/		return 0x82160EB0;
		  /* 82160EB0h */ case    2:  		/* addi R9, R27, 1604 */
		/* 82160EB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x644);
		/* 82160EB0h case    2:*/		return 0x82160EB4;
		  /* 82160EB4h */ case    3:  		/* lwz R8, <#[R9]> */
		/* 82160EB4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82160EB4h case    3:*/		return 0x82160EB8;
		  /* 82160EB8h */ case    4:  		/* rlwinm R8, R8, 27, 21, 31 */
		/* 82160EB8h case    4:*/		cpu::op::rlwinm<0,27,21,31>(regs,&regs.R8,regs.R8);
		/* 82160EB8h case    4:*/		return 0x82160EBC;
		  /* 82160EBCh */ case    5:  		/* cmplw CR6, R8, R10 */
		/* 82160EBCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82160EBCh case    5:*/		return 0x82160EC0;
		  /* 82160EC0h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82160EC0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82160ED8;  }
		/* 82160EC0h case    6:*/		return 0x82160EC4;
		  /* 82160EC4h */ case    7:  		/* addi R11, R11, 1 */
		/* 82160EC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82160EC4h case    7:*/		return 0x82160EC8;
		  /* 82160EC8h */ case    8:  		/* addi R9, R9, 4 */
		/* 82160EC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82160EC8h case    8:*/		return 0x82160ECC;
		  /* 82160ECCh */ case    9:  		/* cmplwi CR6, R11, 64 */
		/* 82160ECCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000040);
		/* 82160ECCh case    9:*/		return 0x82160ED0;
		  /* 82160ED0h */ case   10:  		/* bc 12, CR6_LT, -28 */
		/* 82160ED0h case   10:*/		if ( regs.CR[6].lt ) { return 0x82160EB4;  }
		/* 82160ED0h case   10:*/		return 0x82160ED4;
		  /* 82160ED4h */ case   11:  		/* b 16 */
		/* 82160ED4h case   11:*/		return 0x82160EE4;
		/* 82160ED4h case   11:*/		return 0x82160ED8;
	}
	return 0x82160ED8;
} // Block from 82160EA8h-82160ED8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82160ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160ED8);
		  /* 82160ED8h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82160ED8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82160ED8h case    0:*/		return 0x82160EDC;
		  /* 82160EDCh */ case    1:  		/* add R11, R11, R27 */
		/* 82160EDCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82160EDCh case    1:*/		return 0x82160EE0;
		  /* 82160EE0h */ case    2:  		/* lbz R29, <#[R11 + 1605]> */
		/* 82160EE0h case    2:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000645) );
		/* 82160EE0h case    2:*/		return 0x82160EE4;
	}
	return 0x82160EE4;
} // Block from 82160ED8h-82160EE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82160EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160EE4);
		  /* 82160EE4h */ case    0:  		/* rlwinm R11, R28, 0, 18, 18 */
		/* 82160EE4h case    0:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R11,regs.R28);
		/* 82160EE4h case    0:*/		return 0x82160EE8;
	}
	return 0x82160EE8;
} // Block from 82160EE4h-82160EE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160EE8h
// Function '?NonRTS_CompileProgram@XGRAPHICS@@YA?AW4_E_SSM_RETURNCODE@1@PAU_CC_STATE_COMPILER@1@PAU_ABSTRACT_STATE@1@PAPAU_CP_COMPILED_PROGRAM@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160EE8);
		  /* 82160EE8h */ case    0:  		/* cmplwi CR6, R11, 8192 */
		/* 82160EE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002000);
		/* 82160EE8h case    0:*/		return 0x82160EEC;
		  /* 82160EECh */ case    1:  		/* bc 4, CR6_EQ, 128 */
		/* 82160EECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82160F6C;  }
		/* 82160EECh case    1:*/		return 0x82160EF0;
		  /* 82160EF0h */ case    2:  		/* mr R11, R24 */
		/* 82160EF0h case    2:*/		regs.R11 = regs.R24;
		/* 82160EF0h case    2:*/		return 0x82160EF4;
		  /* 82160EF4h */ case    3:  		/* lis R22, 128 */
		/* 82160EF4h case    3:*/		cpu::op::lis<0>(regs,&regs.R22,0x80);
		/* 82160EF4h case    3:*/		return 0x82160EF8;
		  /* 82160EF8h */ case    4:  		/* rlwimi R11, R24, 12, 21, 23 */
		/* 82160EF8h case    4:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R24);
		/* 82160EF8h case    4:*/		return 0x82160EFC;
		  /* 82160EFCh */ case    5:  		/* rlwinm R11, R11, 0, 19, 23 */
		/* 82160EFCh case    5:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82160EFCh case    5:*/		return 0x82160F00;
		  /* 82160F00h */ case    6:  		/* cmplwi CR6, R11, 3840 */
		/* 82160F00h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000F00);
		/* 82160F00h case    6:*/		return 0x82160F04;
		  /* 82160F04h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82160F04h case    7:*/		if ( regs.CR[6].eq ) { return 0x82160F10;  }
		/* 82160F04h case    7:*/		return 0x82160F08;
		  /* 82160F08h */ case    8:  		/* bl 1074008 */
		/* 82160F08h case    8:*/		regs.LR = 0x82160F0C; return 0x82267260;
		/* 82160F08h case    8:*/		return 0x82160F0C;
		  /* 82160F0Ch */ case    9:  		/* b 96 */
		/* 82160F0Ch case    9:*/		return 0x82160F6C;
		/* 82160F0Ch case    9:*/		return 0x82160F10;
	}
	return 0x82160F10;
} // Block from 82160EE8h-82160F10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82160F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F10);
		  /* 82160F10h */ case    0:  		/* lis R23, 1 */
		/* 82160F10h case    0:*/		cpu::op::lis<0>(regs,&regs.R23,0x1);
		/* 82160F10h case    0:*/		return 0x82160F14;
		  /* 82160F14h */ case    1:  		/* b 88 */
		/* 82160F14h case    1:*/		return 0x82160F6C;
		/* 82160F14h case    1:*/		return 0x82160F18;
	}
	return 0x82160F18;
} // Block from 82160F10h-82160F18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82160F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F18);
		  /* 82160F18h */ case    0:  		/* cntlzw R11, R10 */
		/* 82160F18h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R10);
		/* 82160F18h case    0:*/		return 0x82160F1C;
		  /* 82160F1Ch */ case    1:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82160F1Ch case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82160F1Ch case    1:*/		return 0x82160F20;
		  /* 82160F20h */ case    2:  		/* xori R11, R11, 1 */
		/* 82160F20h case    2:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82160F20h case    2:*/		return 0x82160F24;
		  /* 82160F24h */ case    3:  		/* addi R30, R11, 18 */
		/* 82160F24h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x12);
		/* 82160F24h case    3:*/		return 0x82160F28;
		  /* 82160F28h */ case    4:  		/* b 64 */
		/* 82160F28h case    4:*/		return 0x82160F68;
		/* 82160F28h case    4:*/		return 0x82160F2C;
	}
	return 0x82160F2C;
} // Block from 82160F18h-82160F2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82160F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F2C);
		  /* 82160F2Ch */ case    0:  		/* cmplwi CR6, R10, 1 */
		/* 82160F2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82160F2Ch case    0:*/		return 0x82160F30;
		  /* 82160F30h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82160F30h case    1:*/		if ( regs.CR[6].eq ) { return 0x82160F5C;  }
		/* 82160F30h case    1:*/		return 0x82160F34;
		  /* 82160F34h */ case    2:  		/* cmplwi CR6, R10, 2 */
		/* 82160F34h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 82160F34h case    2:*/		return 0x82160F38;
		  /* 82160F38h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82160F38h case    3:*/		if ( regs.CR[6].eq ) { return 0x82160F44;  }
		/* 82160F38h case    3:*/		return 0x82160F3C;
		  /* 82160F3Ch */ case    4:  		/* li R30, 14 */
		/* 82160F3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R30,0xE);
		/* 82160F3Ch case    4:*/		return 0x82160F40;
		  /* 82160F40h */ case    5:  		/* b 40 */
		/* 82160F40h case    5:*/		return 0x82160F68;
		/* 82160F40h case    5:*/		return 0x82160F44;
	}
	return 0x82160F44;
} // Block from 82160F2Ch-82160F44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82160F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F44);
		  /* 82160F44h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82160F44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82160F44h case    0:*/		return 0x82160F48;
		  /* 82160F48h */ case    1:  		/* li R30, 4 */
		/* 82160F48h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x4);
		/* 82160F48h case    1:*/		return 0x82160F4C;
		  /* 82160F4Ch */ case    2:  		/* li R29, 50 */
		/* 82160F4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x32);
		/* 82160F4Ch case    2:*/		return 0x82160F50;
		  /* 82160F50h */ case    3:  		/* ori R11, R11, 64 */
		/* 82160F50h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82160F50h case    3:*/		return 0x82160F54;
		  /* 82160F54h */ case    4:  		/* stw R11, <#[R27 + 4]> */
		/* 82160F54h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82160F54h case    4:*/		return 0x82160F58;
		  /* 82160F58h */ case    5:  		/* b 20 */
		/* 82160F58h case    5:*/		return 0x82160F6C;
		/* 82160F58h case    5:*/		return 0x82160F5C;
	}
	return 0x82160F5C;
} // Block from 82160F44h-82160F5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82160F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F5C);
		  /* 82160F5Ch */ case    0:  		/* li R30, 16 */
		/* 82160F5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x10);
		/* 82160F5Ch case    0:*/		return 0x82160F60;
		  /* 82160F60h */ case    1:  		/* b 8 */
		/* 82160F60h case    1:*/		return 0x82160F68;
		/* 82160F60h case    1:*/		return 0x82160F64;
	}
	return 0x82160F64;
} // Block from 82160F5Ch-82160F64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82160F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F64);
		  /* 82160F64h */ case    0:  		/* li R30, 3 */
		/* 82160F64h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x3);
		/* 82160F64h case    0:*/		return 0x82160F68;
	}
	return 0x82160F68;
} // Block from 82160F64h-82160F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F68);
		  /* 82160F68h */ case    0:  		/* li R29, 0 */
		/* 82160F68h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82160F68h case    0:*/		return 0x82160F6C;
	}
	return 0x82160F6C;
} // Block from 82160F68h-82160F6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82160F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F6C);
		  /* 82160F6Ch */ case    0:  		/* lis R11, 15 */
		/* 82160F6Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xF);
		/* 82160F6Ch case    0:*/		return 0x82160F70;
		  /* 82160F70h */ case    1:  		/* cmplw CR6, R25, R11 */
		/* 82160F70h case    1:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82160F70h case    1:*/		return 0x82160F74;
		  /* 82160F74h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82160F74h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82160F80;  }
		/* 82160F74h case    2:*/		return 0x82160F78;
		  /* 82160F78h */ case    3:  		/* li R9, 85 */
		/* 82160F78h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x55);
		/* 82160F78h case    3:*/		return 0x82160F7C;
		  /* 82160F7Ch */ case    4:  		/* b 56 */
		/* 82160F7Ch case    4:*/		return 0x82160FB4;
		/* 82160F7Ch case    4:*/		return 0x82160F80;
	}
	return 0x82160F80;
} // Block from 82160F6Ch-82160F80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82160F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F80);
		  /* 82160F80h */ case    0:  		/* rlwinm. R11, R25, 0, 15, 15 */
		/* 82160F80h case    0:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R11,regs.R25);
		/* 82160F80h case    0:*/		return 0x82160F84;
		  /* 82160F84h */ case    1:  		/* li R9, 0 */
		/* 82160F84h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82160F84h case    1:*/		return 0x82160F88;
		  /* 82160F88h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82160F88h case    2:*/		if ( regs.CR[0].eq ) { return 0x82160F90;  }
		/* 82160F88h case    2:*/		return 0x82160F8C;
		  /* 82160F8Ch */ case    3:  		/* li R9, 1 */
		/* 82160F8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82160F8Ch case    3:*/		return 0x82160F90;
	}
	return 0x82160F90;
} // Block from 82160F80h-82160F90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82160F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F90);
		  /* 82160F90h */ case    0:  		/* rlwinm. R11, R25, 0, 14, 14 */
		/* 82160F90h case    0:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R11,regs.R25);
		/* 82160F90h case    0:*/		return 0x82160F94;
		  /* 82160F94h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82160F94h case    1:*/		if ( regs.CR[0].eq ) { return 0x82160F9C;  }
		/* 82160F94h case    1:*/		return 0x82160F98;
		  /* 82160F98h */ case    2:  		/* ori R9, R9, 4 */
		/* 82160F98h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82160F98h case    2:*/		return 0x82160F9C;
	}
	return 0x82160F9C;
} // Block from 82160F90h-82160F9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82160F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160F9C);
		  /* 82160F9Ch */ case    0:  		/* rlwinm. R11, R25, 0, 13, 13 */
		/* 82160F9Ch case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R25);
		/* 82160F9Ch case    0:*/		return 0x82160FA0;
		  /* 82160FA0h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82160FA0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82160FA8;  }
		/* 82160FA0h case    1:*/		return 0x82160FA4;
		  /* 82160FA4h */ case    2:  		/* ori R9, R9, 16 */
		/* 82160FA4h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x10);
		/* 82160FA4h case    2:*/		return 0x82160FA8;
	}
	return 0x82160FA8;
} // Block from 82160F9Ch-82160FA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82160FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160FA8);
		  /* 82160FA8h */ case    0:  		/* rlwinm. R11, R25, 0, 12, 12 */
		/* 82160FA8h case    0:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R25);
		/* 82160FA8h case    0:*/		return 0x82160FAC;
		  /* 82160FACh */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82160FACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82160FB4;  }
		/* 82160FACh case    1:*/		return 0x82160FB0;
		  /* 82160FB0h */ case    2:  		/* ori R9, R9, 64 */
		/* 82160FB0h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x40);
		/* 82160FB0h case    2:*/		return 0x82160FB4;
	}
	return 0x82160FB4;
} // Block from 82160FA8h-82160FB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82160FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160FB4);
		  /* 82160FB4h */ case    0:  		/* rlwinm R11, R28, 0, 11, 11 */
		/* 82160FB4h case    0:*/		cpu::op::rlwinm<0,0,11,11>(regs,&regs.R11,regs.R28);
		/* 82160FB4h case    0:*/		return 0x82160FB8;
		  /* 82160FB8h */ case    1:  		/* lis R8, 16 */
		/* 82160FB8h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x10);
		/* 82160FB8h case    1:*/		return 0x82160FBC;
		  /* 82160FBCh */ case    2:  		/* li R10, 0 */
		/* 82160FBCh case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82160FBCh case    2:*/		return 0x82160FC0;
		  /* 82160FC0h */ case    3:  		/* cmplw CR6, R11, R8 */
		/* 82160FC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82160FC0h case    3:*/		return 0x82160FC4;
		  /* 82160FC4h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82160FC4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82160FCC;  }
		/* 82160FC4h case    4:*/		return 0x82160FC8;
		  /* 82160FC8h */ case    5:  		/* li R10, 256 */
		/* 82160FC8h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x100);
		/* 82160FC8h case    5:*/		return 0x82160FCC;
	}
	return 0x82160FCC;
} // Block from 82160FB4h-82160FCCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82160FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160FCC);
		  /* 82160FCCh */ case    0:  		/* cmplwi CR6, R30, 13 */
		/* 82160FCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000D);
		/* 82160FCCh case    0:*/		return 0x82160FD0;
		  /* 82160FD0h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82160FD0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82160FF4;  }
		/* 82160FD0h case    1:*/		return 0x82160FD4;
		  /* 82160FD4h */ case    2:  		/* cmplwi CR6, R30, 16 */
		/* 82160FD4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000010);
		/* 82160FD4h case    2:*/		return 0x82160FD8;
		  /* 82160FD8h */ case    3:  		/* bc 12, CR6_EQ, 128 */
		/* 82160FD8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82161058;  }
		/* 82160FD8h case    3:*/		return 0x82160FDC;
		  /* 82160FDCh */ case    4:  		/* cmplwi CR6, R30, 17 */
		/* 82160FDCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000011);
		/* 82160FDCh case    4:*/		return 0x82160FE0;
		  /* 82160FE0h */ case    5:  		/* bc 4, CR6_GT, 112 */
		/* 82160FE0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82161050;  }
		/* 82160FE0h case    5:*/		return 0x82160FE4;
		  /* 82160FE4h */ case    6:  		/* cmplwi CR6, R30, 19 */
		/* 82160FE4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000013);
		/* 82160FE4h case    6:*/		return 0x82160FE8;
		  /* 82160FE8h */ case    7:  		/* bc 4, CR6_GT, 88 */
		/* 82160FE8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82161040;  }
		/* 82160FE8h case    7:*/		return 0x82160FEC;
		  /* 82160FECh */ case    8:  		/* cmplwi CR6, R30, 50 */
		/* 82160FECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000032);
		/* 82160FECh case    8:*/		return 0x82160FF0;
		  /* 82160FF0h */ case    9:  		/* bc 4, CR6_EQ, 96 */
		/* 82160FF0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82161050;  }
		/* 82160FF0h case    9:*/		return 0x82160FF4;
	}
	return 0x82160FF4;
} // Block from 82160FCCh-82160FF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82160FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82160FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82160FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82160FF4);
		  /* 82160FF4h */ case    0:  		/* li R9, 169 */
		/* 82160FF4h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xA9);
		/* 82160FF4h case    0:*/		return 0x82160FF8;
		  /* 82160FF8h */ case    1:  		/* ori R11, R10, 169 */
		/* 82160FF8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0xA9);
		/* 82160FF8h case    1:*/		return 0x82160FFC;
		  /* 82160FFCh */ case    2:  		/* lis R8, 128 */
		/* 82160FFCh case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x80);
		/* 82160FFCh case    2:*/		return 0x82161000;
		  /* 82161000h */ case    3:  		/* cmplw CR6, R22, R8 */
		/* 82161000h case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R8);
		/* 82161000h case    3:*/		return 0x82161004;
		  /* 82161004h */ case    4:  		/* bc 4, CR6_EQ, 148 */
		/* 82161004h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82161098;  }
		/* 82161004h case    4:*/		return 0x82161008;
		  /* 82161008h */ case    5:  		/* cmplwi CR6, R9, 85 */
		/* 82161008h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000055);
		/* 82161008h case    5:*/		return 0x8216100C;
		  /* 8216100Ch */ case    6:  		/* bc 4, CR6_EQ, 92 */
		/* 8216100Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82161068;  }
		/* 8216100Ch case    6:*/		return 0x82161010;
		  /* 82161010h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82161010h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82161010h case    7:*/		return 0x82161014;
		  /* 82161014h */ case    8:  		/* bc 4, CR6_EQ, 84 */
		/* 82161014h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82161068;  }
		/* 82161014h case    8:*/		return 0x82161018;
		  /* 82161018h */ case    9:  		/* rlwinm R11, R30, 0, 26, 24 */
		/* 82161018h case    9:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R11,regs.R30);
		/* 82161018h case    9:*/		return 0x8216101C;
		  /* 8216101Ch */ case   10:  		/* rlwinm R10, R29, 0, 16, 31 */
		/* 8216101Ch case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R29);
		/* 8216101Ch case   10:*/		return 0x82161020;
		  /* 82161020h */ case   11:  		/* rlwinm R11, R11, 16, 0, 15 */
		/* 82161020h case   11:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R11);
		/* 82161020h case   11:*/		return 0x82161024;
		  /* 82161024h */ case   12:  		/* rlwinm R9, R24, 0, 21, 31 */
		/* 82161024h case   12:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R9,regs.R24);
		/* 82161024h case   12:*/		return 0x82161028;
		  /* 82161028h */ case   13:  		/* oris R11, R11, 128 */
		/* 82161028h case   13:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82161028h case   13:*/		return 0x8216102C;
		  /* 8216102Ch */ case   14:  		/* or R9, R9, R23 */
		/* 8216102Ch case   14:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R23);
		/* 8216102Ch case   14:*/		return 0x82161030;
		  /* 82161030h */ case   15:  		/* or R11, R11, R10 */
		/* 82161030h case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82161030h case   15:*/		return 0x82161034;
		  /* 82161034h */ case   16:  		/* stw R11, <#[R31]> */
		/* 82161034h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161034h case   16:*/		return 0x82161038;
		  /* 82161038h */ case   17:  		/* stwu R9, <#[R31 + 4]> */
		/* 82161038h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161038h case   17:*/		return 0x8216103C;
		  /* 8216103Ch */ case   18:  		/* b 156 */
		/* 8216103Ch case   18:*/		return 0x821610D8;
		/* 8216103Ch case   18:*/		return 0x82161040;
	}
	return 0x82161040;
} // Block from 82160FF4h-82161040h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82161040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161040);
		  /* 82161040h */ case    0:  		/* lwz R11, <#[R27 + 16]> */
		/* 82161040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82161040h case    0:*/		return 0x82161044;
		  /* 82161044h */ case    1:  		/* cmplwi CR6, R11, 768 */
		/* 82161044h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000300);
		/* 82161044h case    1:*/		return 0x82161048;
		  /* 82161048h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 82161048h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82161050;  }
		/* 82161048h case    2:*/		return 0x8216104C;
		  /* 8216104Ch */ case    3:  		/* ori R10, R10, 256 */
		/* 8216104Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x100);
		/* 8216104Ch case    3:*/		return 0x82161050;
	}
	return 0x82161050;
} // Block from 82161040h-82161050h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82161050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161050);
		  /* 82161050h */ case    0:  		/* or R11, R10, R9 */
		/* 82161050h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 82161050h case    0:*/		return 0x82161054;
		  /* 82161054h */ case    1:  		/* b -88 */
		/* 82161054h case    1:*/		return 0x82160FFC;
		/* 82161054h case    1:*/		return 0x82161058;
	}
	return 0x82161058;
} // Block from 82161050h-82161058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161058);
		  /* 82161058h */ case    0:  		/* ori R10, R10, 256 */
		/* 82161058h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x100);
		/* 82161058h case    0:*/		return 0x8216105C;
		  /* 8216105Ch */ case    1:  		/* li R9, 1 */
		/* 8216105Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8216105Ch case    1:*/		return 0x82161060;
		  /* 82161060h */ case    2:  		/* ori R11, R10, 1 */
		/* 82161060h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0x1);
		/* 82161060h case    2:*/		return 0x82161064;
		  /* 82161064h */ case    3:  		/* b -104 */
		/* 82161064h case    3:*/		return 0x82160FFC;
		/* 82161064h case    3:*/		return 0x82161068;
	}
	return 0x82161068;
} // Block from 82161058h-82161068h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82161068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161068);
		  /* 82161068h */ case    0:  		/* rlwinm R10, R30, 16, 0, 15 */
		/* 82161068h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R30);
		/* 82161068h case    0:*/		return 0x8216106C;
		  /* 8216106Ch */ case    1:  		/* rlwinm R9, R29, 0, 16, 31 */
		/* 8216106Ch case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R29);
		/* 8216106Ch case    1:*/		return 0x82161070;
		  /* 82161070h */ case    2:  		/* oris R10, R10, 192 */
		/* 82161070h case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC0);
		/* 82161070h case    2:*/		return 0x82161074;
		  /* 82161074h */ case    3:  		/* rlwinm R8, R24, 0, 21, 31 */
		/* 82161074h case    3:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R8,regs.R24);
		/* 82161074h case    3:*/		return 0x82161078;
		  /* 82161078h */ case    4:  		/* or R10, R10, R9 */
		/* 82161078h case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82161078h case    4:*/		return 0x8216107C;
		  /* 8216107Ch */ case    5:  		/* or R9, R8, R23 */
		/* 8216107Ch case    5:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R23);
		/* 8216107Ch case    5:*/		return 0x82161080;
		  /* 82161080h */ case    6:  		/* stw R10, <#[R31]> */
		/* 82161080h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82161080h case    6:*/		return 0x82161084;
		  /* 82161084h */ case    7:  		/* stwu R11, <#[R31 + 4]> */
		/* 82161084h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161084h case    7:*/		return 0x82161088;
		  /* 82161088h */ case    8:  		/* stwu R9, <#[R31 + 4]> */
		/* 82161088h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161088h case    8:*/		return 0x8216108C;
		  /* 8216108Ch */ case    9:  		/* lwz R11, <#[R26]> */
		/* 8216108Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8216108Ch case    9:*/		return 0x82161090;
		  /* 82161090h */ case   10:  		/* addi R11, R11, 3 */
		/* 82161090h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82161090h case   10:*/		return 0x82161094;
		  /* 82161094h */ case   11:  		/* b 76 */
		/* 82161094h case   11:*/		return 0x821610E0;
		/* 82161094h case   11:*/		return 0x82161098;
	}
	return 0x82161098;
} // Block from 82161068h-82161098h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82161098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161098);
		  /* 82161098h */ case    0:  		/* cmplwi CR6, R9, 85 */
		/* 82161098h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000055);
		/* 82161098h case    0:*/		return 0x8216109C;
		  /* 8216109Ch */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8216109Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821610C0;  }
		/* 8216109Ch case    1:*/		return 0x821610A0;
		  /* 821610A0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821610A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821610A0h case    2:*/		return 0x821610A4;
		  /* 821610A4h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 821610A4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821610C0;  }
		/* 821610A4h case    3:*/		return 0x821610A8;
		  /* 821610A8h */ case    4:  		/* rlwimi R29, R30, 16, 0, 15 */
		/* 821610A8h case    4:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R29,regs.R30);
		/* 821610A8h case    4:*/		return 0x821610AC;
		  /* 821610ACh */ case    5:  		/* rlwinm R11, R29, 0, 10, 8 */
		/* 821610ACh case    5:*/		cpu::op::rlwinm<0,0,10,8>(regs,&regs.R11,regs.R29);
		/* 821610ACh case    5:*/		return 0x821610B0;
		  /* 821610B0h */ case    6:  		/* stw R11, <#[R31]> */
		/* 821610B0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821610B0h case    6:*/		return 0x821610B4;
		  /* 821610B4h */ case    7:  		/* lwz R11, <#[R26]> */
		/* 821610B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821610B4h case    7:*/		return 0x821610B8;
		  /* 821610B8h */ case    8:  		/* addi R11, R11, 1 */
		/* 821610B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821610B8h case    8:*/		return 0x821610BC;
		  /* 821610BCh */ case    9:  		/* b 36 */
		/* 821610BCh case    9:*/		return 0x821610E0;
		/* 821610BCh case    9:*/		return 0x821610C0;
	}
	return 0x821610C0;
} // Block from 82161098h-821610C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821610C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821610C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821610C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821610C0);
		  /* 821610C0h */ case    0:  		/* rlwinm R10, R30, 16, 0, 15 */
		/* 821610C0h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R30);
		/* 821610C0h case    0:*/		return 0x821610C4;
		  /* 821610C4h */ case    1:  		/* rlwinm R9, R29, 0, 16, 31 */
		/* 821610C4h case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R29);
		/* 821610C4h case    1:*/		return 0x821610C8;
		  /* 821610C8h */ case    2:  		/* oris R10, R10, 64 */
		/* 821610C8h case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x40);
		/* 821610C8h case    2:*/		return 0x821610CC;
		  /* 821610CCh */ case    3:  		/* or R10, R10, R9 */
		/* 821610CCh case    3:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821610CCh case    3:*/		return 0x821610D0;
		  /* 821610D0h */ case    4:  		/* stw R10, <#[R31]> */
		/* 821610D0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821610D0h case    4:*/		return 0x821610D4;
		  /* 821610D4h */ case    5:  		/* stwu R11, <#[R31 + 4]> */
		/* 821610D4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 821610D4h case    5:*/		return 0x821610D8;
	}
	return 0x821610D8;
} // Block from 821610C0h-821610D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821610D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821610D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821610D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821610D8);
		  /* 821610D8h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 821610D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821610D8h case    0:*/		return 0x821610DC;
		  /* 821610DCh */ case    1:  		/* addi R11, R11, 2 */
		/* 821610DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821610DCh case    1:*/		return 0x821610E0;
	}
	return 0x821610E0;
} // Block from 821610D8h-821610E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821610E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821610E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821610E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821610E0);
		  /* 821610E0h */ case    0:  		/* stw R11, <#[R26]> */
		/* 821610E0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821610E0h case    0:*/		return 0x821610E4;
		  /* 821610E4h */ case    1:  		/* addi R3, R31, 4 */
		/* 821610E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 821610E4h case    1:*/		return 0x821610E8;
		  /* 821610E8h */ case    2:  		/* addi R1, R1, 176 */
		/* 821610E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821610E8h case    2:*/		return 0x821610EC;
		  /* 821610ECh */ case    3:  		/* b -851548 */
		/* 821610ECh case    3:*/		return 0x82091290;
		/* 821610ECh case    3:*/		return 0x821610F0;
	}
	return 0x821610F0;
} // Block from 821610E0h-821610F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821610F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821610F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821610F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821610F0);
		  /* 821610F0h */ case    0:  		/* mfspr R12, LR */
		/* 821610F0h case    0:*/		regs.R12 = regs.LR;
		/* 821610F0h case    0:*/		return 0x821610F4;
		  /* 821610F4h */ case    1:  		/* bl -851616 */
		/* 821610F4h case    1:*/		regs.LR = 0x821610F8; return 0x82091254;
		/* 821610F4h case    1:*/		return 0x821610F8;
		  /* 821610F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821610F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821610F8h case    2:*/		return 0x821610FC;
		  /* 821610FCh */ case    3:  		/* lwz R31, <#[R4 + 28]> */
		/* 821610FCh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x0000001C) );
		/* 821610FCh case    3:*/		return 0x82161100;
		  /* 82161100h */ case    4:  		/* mr R28, R4 */
		/* 82161100h case    4:*/		regs.R28 = regs.R4;
		/* 82161100h case    4:*/		return 0x82161104;
		  /* 82161104h */ case    5:  		/* lwz R30, <#[R4 + 24]> */
		/* 82161104h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000018) );
		/* 82161104h case    5:*/		return 0x82161108;
		  /* 82161108h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 82161108h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82161108h case    6:*/		return 0x8216110C;
		  /* 8216110Ch */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 8216110Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82161114;  }
		/* 8216110Ch case    7:*/		return 0x82161110;
		  /* 82161110h */ case    8:  		/* bl 1073488 */
		/* 82161110h case    8:*/		regs.LR = 0x82161114; return 0x82267260;
		/* 82161110h case    8:*/		return 0x82161114;
	}
	return 0x82161114;
} // Block from 821610F0h-82161114h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82161114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161114);
		  /* 82161114h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82161114h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82161114h case    0:*/		return 0x82161118;
		  /* 82161118h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82161118h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82161120;  }
		/* 82161118h case    1:*/		return 0x8216111C;
		  /* 8216111Ch */ case    2:  		/* bl 1073476 */
		/* 8216111Ch case    2:*/		regs.LR = 0x82161120; return 0x82267260;
		/* 8216111Ch case    2:*/		return 0x82161120;
	}
	return 0x82161120;
} // Block from 82161114h-82161120h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82161120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161120);
		  /* 82161120h */ case    0:  		/* li R11, 256 */
		/* 82161120h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 82161120h case    0:*/		return 0x82161124;
		  /* 82161124h */ case    1:  		/* li R27, 2 */
		/* 82161124h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82161124h case    1:*/		return 0x82161128;
		  /* 82161128h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82161128h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161128h case    2:*/		return 0x8216112C;
		  /* 8216112Ch */ case    3:  		/* li R30, 0 */
		/* 8216112Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216112Ch case    3:*/		return 0x82161130;
		  /* 82161130h */ case    4:  		/* stwu R11, <#[R31 + 4]> */
		/* 82161130h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161130h case    4:*/		return 0x82161134;
		  /* 82161134h */ case    5:  		/* lwz R11, <#[R28 + 308]> */
		/* 82161134h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000134) );
		/* 82161134h case    5:*/		return 0x82161138;
		  /* 82161138h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82161138h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82161138h case    6:*/		return 0x8216113C;
		  /* 8216113Ch */ case    7:  		/* addi R11, R31, 4 */
		/* 8216113Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 8216113Ch case    7:*/		return 0x82161140;
		  /* 82161140h */ case    8:  		/* bc 4, CR6_GT, 172 */
		/* 82161140h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821611EC;  }
		/* 82161140h case    8:*/		return 0x82161144;
		  /* 82161144h */ case    9:  		/* addi R29, R28, 50 */
		/* 82161144h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R28,0x32);
		/* 82161144h case    9:*/		return 0x82161148;
		  /* 82161148h */ case   10:  		/* addi R31, R11, -4 */
		/* 82161148h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFC);
		/* 82161148h case   10:*/		return 0x8216114C;
		  /* 8216114Ch */ case   11:  		/* lbz R11, <#[R29 + 4]> */
		/* 8216114Ch case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8216114Ch case   11:*/		return 0x82161150;
		  /* 82161150h */ case   12:  		/* cmplwi CR6, R11, 16 */
		/* 82161150h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82161150h case   12:*/		return 0x82161154;
		  /* 82161154h */ case   13:  		/* bc 12, CR6_LT, 8 */
		/* 82161154h case   13:*/		if ( regs.CR[6].lt ) { return 0x8216115C;  }
		/* 82161154h case   13:*/		return 0x82161158;
		  /* 82161158h */ case   14:  		/* bl 1073416 */
		/* 82161158h case   14:*/		regs.LR = 0x8216115C; return 0x82267260;
		/* 82161158h case   14:*/		return 0x8216115C;
	}
	return 0x8216115C;
} // Block from 82161120h-8216115Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216115Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216115C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216115C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216115C);
		  /* 8216115Ch */ case    0:  		/* rlwinm R11, R30, 16, 0, 15 */
		/* 8216115Ch case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R30);
		/* 8216115Ch case    0:*/		return 0x82161160;
		  /* 82161160h */ case    1:  		/* lis R10, 15 */
		/* 82161160h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xF);
		/* 82161160h case    1:*/		return 0x82161164;
		  /* 82161164h */ case    2:  		/* oris R11, R11, 32768 */
		/* 82161164h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82161164h case    2:*/		return 0x82161168;
		  /* 82161168h */ case    3:  		/* addi R9, R31, 4 */
		/* 82161168h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x4);
		/* 82161168h case    3:*/		return 0x8216116C;
		  /* 8216116Ch */ case    4:  		/* ori R11, R11, 26 */
		/* 8216116Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1A);
		/* 8216116Ch case    4:*/		return 0x82161170;
		  /* 82161170h */ case    5:  		/* stw R11, <#[R31 + 4]> */
		/* 82161170h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82161170h case    5:*/		return 0x82161174;
		  /* 82161174h */ case    6:  		/* lwz R11, <#[R29 + 2]> */
		/* 82161174h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000002) );
		/* 82161174h case    6:*/		return 0x82161178;
		  /* 82161178h */ case    7:  		/* rlwinm R11, R11, 12, 12, 15 */
		/* 82161178h case    7:*/		cpu::op::rlwinm<0,12,12,15>(regs,&regs.R11,regs.R11);
		/* 82161178h case    7:*/		return 0x8216117C;
		  /* 8216117Ch */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 8216117Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216117Ch case    8:*/		return 0x82161180;
		  /* 82161180h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82161180h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82161190;  }
		/* 82161180h case    9:*/		return 0x82161184;
		  /* 82161184h */ case   10:  		/* li R11, 85 */
		/* 82161184h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x55);
		/* 82161184h case   10:*/		return 0x82161188;
		  /* 82161188h */ case   11:  		/* stw R11, <#[R9 + 4]> */
		/* 82161188h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82161188h case   11:*/		return 0x8216118C;
		  /* 8216118Ch */ case   12:  		/* b 60 */
		/* 8216118Ch case   12:*/		return 0x821611C8;
		/* 8216118Ch case   12:*/		return 0x82161190;
	}
	return 0x82161190;
} // Block from 8216115Ch-82161190h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82161190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161190);
		  /* 82161190h */ case    0:  		/* rlwinm. R8, R11, 0, 15, 15 */
		/* 82161190h case    0:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R8,regs.R11);
		/* 82161190h case    0:*/		return 0x82161194;
		  /* 82161194h */ case    1:  		/* li R10, 0 */
		/* 82161194h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82161194h case    1:*/		return 0x82161198;
		  /* 82161198h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82161198h case    2:*/		if ( regs.CR[0].eq ) { return 0x821611A0;  }
		/* 82161198h case    2:*/		return 0x8216119C;
		  /* 8216119Ch */ case    3:  		/* li R10, 1 */
		/* 8216119Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216119Ch case    3:*/		return 0x821611A0;
	}
	return 0x821611A0;
} // Block from 82161190h-821611A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821611A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611A0);
		  /* 821611A0h */ case    0:  		/* rlwinm. R8, R11, 0, 14, 14 */
		/* 821611A0h case    0:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R8,regs.R11);
		/* 821611A0h case    0:*/		return 0x821611A4;
		  /* 821611A4h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821611A4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821611AC;  }
		/* 821611A4h case    1:*/		return 0x821611A8;
		  /* 821611A8h */ case    2:  		/* ori R10, R10, 4 */
		/* 821611A8h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821611A8h case    2:*/		return 0x821611AC;
	}
	return 0x821611AC;
} // Block from 821611A0h-821611ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821611ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611AC);
		  /* 821611ACh */ case    0:  		/* rlwinm. R8, R11, 0, 13, 13 */
		/* 821611ACh case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R8,regs.R11);
		/* 821611ACh case    0:*/		return 0x821611B0;
	}
	return 0x821611B0;
} // Block from 821611ACh-821611B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821611B0h
// Function '?TranslateShader@XGRAPHICS@@YA?AW4_E_SSM_RETURNCODE@1@PAU_CC_STATE_COMPILER@1@PAU_ABSTRACT_STATE@1@I_NPAPAU_CS_COMPILED_SHADER@1@PAE@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611B0);
		  /* 821611B0h */ case    0:  		/* bc 12, CR0_EQ, 8 */
		/* 821611B0h case    0:*/		if ( regs.CR[0].eq ) { return 0x821611B8;  }
		/* 821611B0h case    0:*/		return 0x821611B4;
		  /* 821611B4h */ case    1:  		/* ori R10, R10, 16 */
		/* 821611B4h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x10);
		/* 821611B4h case    1:*/		return 0x821611B8;
	}
	return 0x821611B8;
} // Block from 821611B0h-821611B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821611B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611B8);
		  /* 821611B8h */ case    0:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 821611B8h case    0:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 821611B8h case    0:*/		return 0x821611BC;
		  /* 821611BCh */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821611BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821611C4;  }
		/* 821611BCh case    1:*/		return 0x821611C0;
		  /* 821611C0h */ case    2:  		/* ori R10, R10, 64 */
		/* 821611C0h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 821611C0h case    2:*/		return 0x821611C4;
	}
	return 0x821611C4;
} // Block from 821611B8h-821611C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821611C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611C4);
		  /* 821611C4h */ case    0:  		/* stw R10, <#[R9 + 4]> */
		/* 821611C4h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 821611C4h case    0:*/		return 0x821611C8;
	}
	return 0x821611C8;
} // Block from 821611C4h-821611C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821611C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611C8);
		  /* 821611C8h */ case    0:  		/* lbzu R11, <#[R29 + 4]> */
		/* 821611C8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		regs.R29 = (uint32)(regs.R29 + 0x00000004);
		/* 821611C8h case    0:*/		return 0x821611CC;
		  /* 821611CCh */ case    1:  		/* addi R31, R9, 4 */
		/* 821611CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R9,0x4);
		/* 821611CCh case    1:*/		return 0x821611D0;
		  /* 821611D0h */ case    2:  		/* addi R30, R30, 1 */
		/* 821611D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821611D0h case    2:*/		return 0x821611D4;
		  /* 821611D4h */ case    3:  		/* oris R11, R11, 5 */
		/* 821611D4h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x5);
		/* 821611D4h case    3:*/		return 0x821611D8;
		  /* 821611D8h */ case    4:  		/* addi R27, R27, 3 */
		/* 821611D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x3);
		/* 821611D8h case    4:*/		return 0x821611DC;
		  /* 821611DCh */ case    5:  		/* stwu R11, <#[R31 + 4]> */
		/* 821611DCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 821611DCh case    5:*/		return 0x821611E0;
		  /* 821611E0h */ case    6:  		/* lwz R11, <#[R28 + 308]> */
		/* 821611E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000134) );
		/* 821611E0h case    6:*/		return 0x821611E4;
		  /* 821611E4h */ case    7:  		/* cmplw CR6, R30, R11 */
		/* 821611E4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821611E4h case    7:*/		return 0x821611E8;
		  /* 821611E8h */ case    8:  		/* bc 12, CR6_LT, -156 */
		/* 821611E8h case    8:*/		if ( regs.CR[6].lt ) { return 0x8216114C;  }
		/* 821611E8h case    8:*/		return 0x821611EC;
	}
	return 0x821611EC;
} // Block from 821611C8h-821611ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821611ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821611EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821611EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821611EC);
		  /* 821611ECh */ case    0:  		/* mr R3, R27 */
		/* 821611ECh case    0:*/		regs.R3 = regs.R27;
		/* 821611ECh case    0:*/		return 0x821611F0;
		  /* 821611F0h */ case    1:  		/* addi R1, R1, 128 */
		/* 821611F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821611F0h case    1:*/		return 0x821611F4;
		  /* 821611F4h */ case    2:  		/* b -851792 */
		/* 821611F4h case    2:*/		return 0x820912A4;
		/* 821611F4h case    2:*/		return 0x821611F8;
		  /* 821611F8h */ case    3:  		/* li R8, 0 */
		/* 821611F8h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821611F8h case    3:*/		return 0x821611FC;
		  /* 821611FCh */ case    4:  		/* li R9, 0 */
		/* 821611FCh case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821611FCh case    4:*/		return 0x82161200;
		  /* 82161200h */ case    5:  		/* li R10, 16 */
		/* 82161200h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 82161200h case    5:*/		return 0x82161204;
		  /* 82161204h */ case    6:  		/* srw R11, R3, R10 */
		/* 82161204h case    6:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R3,regs.R10);
		/* 82161204h case    6:*/		return 0x82161208;
		  /* 82161208h */ case    7:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82161208h case    7:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82161208h case    7:*/		return 0x8216120C;
		  /* 8216120Ch */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 8216120Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216120Ch case    8:*/		return 0x82161210;
		  /* 82161210h */ case    9:  		/* bc 12, CR6_LT, 44 */
		/* 82161210h case    9:*/		if ( regs.CR[6].lt ) { return 0x8216123C;  }
		/* 82161210h case    9:*/		return 0x82161214;
		  /* 82161214h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 82161214h case   10:*/		if ( regs.CR[6].eq ) { return 0x82161234;  }
		/* 82161214h case   10:*/		return 0x82161218;
		  /* 82161218h */ case   11:  		/* cmplwi CR6, R11, 3 */
		/* 82161218h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82161218h case   11:*/		return 0x8216121C;
		  /* 8216121Ch */ case   12:  		/* bc 12, CR6_LT, 16 */
		/* 8216121Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x8216122C;  }
		/* 8216121Ch case   12:*/		return 0x82161220;
		  /* 82161220h */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 82161220h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216123C;  }
		/* 82161220h case   13:*/		return 0x82161224;
		  /* 82161224h */ case   14:  		/* li R11, 3 */
		/* 82161224h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82161224h case   14:*/		return 0x82161228;
		  /* 82161228h */ case   15:  		/* b 24 */
		/* 82161228h case   15:*/		return 0x82161240;
		/* 82161228h case   15:*/		return 0x8216122C;
	}
	return 0x8216122C;
} // Block from 821611ECh-8216122Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216122Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216122C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216122C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216122C);
		  /* 8216122Ch */ case    0:  		/* li R11, 2 */
		/* 8216122Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8216122Ch case    0:*/		return 0x82161230;
		  /* 82161230h */ case    1:  		/* b 16 */
		/* 82161230h case    1:*/		return 0x82161240;
		/* 82161230h case    1:*/		return 0x82161234;
	}
	return 0x82161234;
} // Block from 8216122Ch-82161234h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161234);
		  /* 82161234h */ case    0:  		/* li R11, 1 */
		/* 82161234h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82161234h case    0:*/		return 0x82161238;
		  /* 82161238h */ case    1:  		/* b 8 */
		/* 82161238h case    1:*/		return 0x82161240;
		/* 82161238h case    1:*/		return 0x8216123C;
	}
	return 0x8216123C;
} // Block from 82161234h-8216123Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216123Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216123C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216123C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216123C);
		  /* 8216123Ch */ case    0:  		/* li R11, 0 */
		/* 8216123Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216123Ch case    0:*/		return 0x82161240;
	}
	return 0x82161240;
} // Block from 8216123Ch-82161240h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161240);
		  /* 82161240h */ case    0:  		/* slw R11, R11, R9 */
		/* 82161240h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82161240h case    0:*/		return 0x82161244;
		  /* 82161244h */ case    1:  		/* addi R10, R10, 2 */
		/* 82161244h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82161244h case    1:*/		return 0x82161248;
		  /* 82161248h */ case    2:  		/* or R8, R11, R8 */
		/* 82161248h case    2:*/		cpu::op::or<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 82161248h case    2:*/		return 0x8216124C;
		  /* 8216124Ch */ case    3:  		/* addi R9, R9, 4 */
		/* 8216124Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216124Ch case    3:*/		return 0x82161250;
		  /* 82161250h */ case    4:  		/* cmplwi CR6, R10, 24 */
		/* 82161250h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000018);
		/* 82161250h case    4:*/		return 0x82161254;
		  /* 82161254h */ case    5:  		/* bc 12, CR6_LT, -80 */
		/* 82161254h case    5:*/		if ( regs.CR[6].lt ) { return 0x82161204;  }
		/* 82161254h case    5:*/		return 0x82161258;
		  /* 82161258h */ case    6:  		/* mr R3, R8 */
		/* 82161258h case    6:*/		regs.R3 = regs.R8;
		/* 82161258h case    6:*/		return 0x8216125C;
		  /* 8216125Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 8216125Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216125Ch case    7:*/		return 0x82161260;
	}
	return 0x82161260;
} // Block from 82161240h-82161260h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82161260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161260);
		  /* 82161260h */ case    0:  		/* addi R11, R4, 401 */
		/* 82161260h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x191);
		/* 82161260h case    0:*/		return 0x82161264;
		  /* 82161264h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82161264h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82161264h case    1:*/		return 0x82161268;
		  /* 82161268h */ case    2:  		/* add R8, R11, R3 */
		/* 82161268h case    2:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R3);
		/* 82161268h case    2:*/		return 0x8216126C;
		  /* 8216126Ch */ case    3:  		/* lwzx R9, <#[R11 + R3]> */
		/* 8216126Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216126Ch case    3:*/		return 0x82161270;
		  /* 82161270h */ case    4:  		/* rlwinm. R11, R9, 4, 28, 31 */
		/* 82161270h case    4:*/		cpu::op::rlwinm<1,4,28,31>(regs,&regs.R11,regs.R9);
		/* 82161270h case    4:*/		return 0x82161274;
		  /* 82161274h */ case    5:  		/* rlwinm R10, R9, 8, 28, 31 */
		/* 82161274h case    5:*/		cpu::op::rlwinm<0,8,28,31>(regs,&regs.R10,regs.R9);
		/* 82161274h case    5:*/		return 0x82161278;
		  /* 82161278h */ case    6:  		/* rlwinm R7, R9, 15, 12, 15 */
		/* 82161278h case    6:*/		cpu::op::rlwinm<0,15,12,15>(regs,&regs.R7,regs.R9);
		/* 82161278h case    6:*/		return 0x8216127C;
		  /* 8216127Ch */ case    7:  		/* rlwinm R4, R9, 27, 21, 31 */
		/* 8216127Ch case    7:*/		cpu::op::rlwinm<0,27,21,31>(regs,&regs.R4,regs.R9);
		/* 8216127Ch case    7:*/		return 0x82161280;
		  /* 82161280h */ case    8:  		/* bc 12, CR0_EQ, 84 */
		/* 82161280h case    8:*/		if ( regs.CR[0].eq ) { return 0x821612D4;  }
		/* 82161280h case    8:*/		return 0x82161284;
		  /* 82161284h */ case    9:  		/* cmplwi CR6, R11, 4 */
		/* 82161284h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82161284h case    9:*/		return 0x82161288;
		  /* 82161288h */ case   10:  		/* bc 12, CR6_EQ, 60 */
		/* 82161288h case   10:*/		if ( regs.CR[6].eq ) { return 0x821612C4;  }
		/* 82161288h case   10:*/		return 0x8216128C;
		  /* 8216128Ch */ case   11:  		/* cmplwi CR6, R11, 5 */
		/* 8216128Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 8216128Ch case   11:*/		return 0x82161290;
		  /* 82161290h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 82161290h case   12:*/		if ( regs.CR[6].eq ) { return 0x821612BC;  }
		/* 82161290h case   12:*/		return 0x82161294;
		  /* 82161294h */ case   13:  		/* cmplwi CR6, R11, 10 */
		/* 82161294h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 82161294h case   13:*/		return 0x82161298;
		  /* 82161298h */ case   14:  		/* bc 12, CR6_EQ, 28 */
		/* 82161298h case   14:*/		if ( regs.CR[6].eq ) { return 0x821612B4;  }
		/* 82161298h case   14:*/		return 0x8216129C;
		  /* 8216129Ch */ case   15:  		/* cmplwi CR6, R11, 11 */
		/* 8216129Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 8216129Ch case   15:*/		return 0x821612A0;
		  /* 821612A0h */ case   16:  		/* bc 4, CR6_EQ, 60 */
		/* 821612A0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821612DC;  }
		/* 821612A0h case   16:*/		return 0x821612A4;
		  /* 821612A4h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 821612A4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821612A4h case   17:*/		return 0x821612A8;
	}
	return 0x821612A8;
} // Block from 82161260h-821612A8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821612A8h
// Function '?RTS_CompileProgram@XGRAPHICS@@YA?AW4_E_SSM_RETURNCODE@1@PAU_CC_STATE_COMPILER@1@PAU_ABSTRACT_STATE@1@PAPAU_CP_COMPILED_PROGRAM@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612A8);
		  /* 821612A8h */ case    0:  		/* bc 4, CR6_EQ, 52 */
		/* 821612A8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821612DC;  }
		/* 821612A8h case    0:*/		return 0x821612AC;
		  /* 821612ACh */ case    1:  		/* li R11, 4 */
		/* 821612ACh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 821612ACh case    1:*/		return 0x821612B0;
		  /* 821612B0h */ case    2:  		/* b 68 */
		/* 821612B0h case    2:*/		return 0x821612F4;
		/* 821612B0h case    2:*/		return 0x821612B4;
	}
	return 0x821612B4;
} // Block from 821612A8h-821612B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821612B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612B4);
		  /* 821612B4h */ case    0:  		/* li R11, 2 */
		/* 821612B4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 821612B4h case    0:*/		return 0x821612B8;
		  /* 821612B8h */ case    1:  		/* b 64 */
		/* 821612B8h case    1:*/		return 0x821612F8;
		/* 821612B8h case    1:*/		return 0x821612BC;
	}
	return 0x821612BC;
} // Block from 821612B4h-821612BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821612BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612BC);
		  /* 821612BCh */ case    0:  		/* li R11, 5 */
		/* 821612BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 821612BCh case    0:*/		return 0x821612C0;
		  /* 821612C0h */ case    1:  		/* b 56 */
		/* 821612C0h case    1:*/		return 0x821612F8;
		/* 821612C0h case    1:*/		return 0x821612C4;
	}
	return 0x821612C4;
} // Block from 821612BCh-821612C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821612C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612C4);
		  /* 821612C4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821612C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821612C4h case    0:*/		return 0x821612C8;
		  /* 821612C8h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 821612C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821612DC;  }
		/* 821612C8h case    1:*/		return 0x821612CC;
		  /* 821612CCh */ case    2:  		/* li R11, 1 */
		/* 821612CCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821612CCh case    2:*/		return 0x821612D0;
		  /* 821612D0h */ case    3:  		/* b 36 */
		/* 821612D0h case    3:*/		return 0x821612F4;
		/* 821612D0h case    3:*/		return 0x821612D4;
	}
	return 0x821612D4;
} // Block from 821612C4h-821612D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821612D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612D4);
		  /* 821612D4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821612D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821612D4h case    0:*/		return 0x821612D8;
		  /* 821612D8h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821612D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821612F0;  }
		/* 821612D8h case    1:*/		return 0x821612DC;
	}
	return 0x821612DC;
} // Block from 821612D4h-821612DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821612DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612DC);
		  /* 821612DCh */ case    0:  		/* addi R9, R11, 1 */
		/* 821612DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 821612DCh case    0:*/		return 0x821612E0;
		  /* 821612E0h */ case    1:  		/* li R11, 5 */
		/* 821612E0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 821612E0h case    1:*/		return 0x821612E4;
		  /* 821612E4h */ case    2:  		/* rlwinm R9, R9, 4, 0, 27 */
		/* 821612E4h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R9);
		/* 821612E4h case    2:*/		return 0x821612E8;
		  /* 821612E8h */ case    3:  		/* or R10, R9, R10 */
		/* 821612E8h case    3:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821612E8h case    3:*/		return 0x821612EC;
		  /* 821612ECh */ case    4:  		/* b 12 */
		/* 821612ECh case    4:*/		return 0x821612F8;
		/* 821612ECh case    4:*/		return 0x821612F0;
	}
	return 0x821612F0;
} // Block from 821612DCh-821612F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821612F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612F0);
		  /* 821612F0h */ case    0:  		/* li R11, 0 */
		/* 821612F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821612F0h case    0:*/		return 0x821612F4;
	}
	return 0x821612F4;
} // Block from 821612F0h-821612F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821612F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612F4);
		  /* 821612F4h */ case    0:  		/* li R10, 0 */
		/* 821612F4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821612F4h case    0:*/		return 0x821612F8;
	}
	return 0x821612F8;
} // Block from 821612F4h-821612F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821612F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821612F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821612F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821612F8);
		  /* 821612F8h */ case    0:  		/* lis R9, 15 */
		/* 821612F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xF);
		/* 821612F8h case    0:*/		return 0x821612FC;
		  /* 821612FCh */ case    1:  		/* cmplw CR6, R7, R9 */
		/* 821612FCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 821612FCh case    1:*/		return 0x82161300;
		  /* 82161300h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82161300h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216130C;  }
		/* 82161300h case    2:*/		return 0x82161304;
		  /* 82161304h */ case    3:  		/* li R9, 85 */
		/* 82161304h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x55);
		/* 82161304h case    3:*/		return 0x82161308;
		  /* 82161308h */ case    4:  		/* b 56 */
		/* 82161308h case    4:*/		return 0x82161340;
		/* 82161308h case    4:*/		return 0x8216130C;
	}
	return 0x8216130C;
} // Block from 821612F8h-8216130Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216130Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216130C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216130C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216130C);
		  /* 8216130Ch */ case    0:  		/* rlwinm. R3, R7, 0, 15, 15 */
		/* 8216130Ch case    0:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R3,regs.R7);
		/* 8216130Ch case    0:*/		return 0x82161310;
		  /* 82161310h */ case    1:  		/* li R9, 0 */
		/* 82161310h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161310h case    1:*/		return 0x82161314;
		  /* 82161314h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82161314h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216131C;  }
		/* 82161314h case    2:*/		return 0x82161318;
		  /* 82161318h */ case    3:  		/* li R9, 1 */
		/* 82161318h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82161318h case    3:*/		return 0x8216131C;
	}
	return 0x8216131C;
} // Block from 8216130Ch-8216131Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216131Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216131C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216131C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216131C);
		  /* 8216131Ch */ case    0:  		/* rlwinm. R3, R7, 0, 14, 14 */
		/* 8216131Ch case    0:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R3,regs.R7);
		/* 8216131Ch case    0:*/		return 0x82161320;
		  /* 82161320h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82161320h case    1:*/		if ( regs.CR[0].eq ) { return 0x82161328;  }
		/* 82161320h case    1:*/		return 0x82161324;
		  /* 82161324h */ case    2:  		/* ori R9, R9, 4 */
		/* 82161324h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82161324h case    2:*/		return 0x82161328;
	}
	return 0x82161328;
} // Block from 8216131Ch-82161328h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82161328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161328);
		  /* 82161328h */ case    0:  		/* rlwinm. R3, R7, 0, 13, 13 */
		/* 82161328h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R3,regs.R7);
		/* 82161328h case    0:*/		return 0x8216132C;
		  /* 8216132Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8216132Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82161334;  }
		/* 8216132Ch case    1:*/		return 0x82161330;
		  /* 82161330h */ case    2:  		/* ori R9, R9, 16 */
		/* 82161330h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x10);
		/* 82161330h case    2:*/		return 0x82161334;
	}
	return 0x82161334;
} // Block from 82161328h-82161334h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82161334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161334);
		  /* 82161334h */ case    0:  		/* rlwinm. R7, R7, 0, 12, 12 */
		/* 82161334h case    0:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R7,regs.R7);
		/* 82161334h case    0:*/		return 0x82161338;
		  /* 82161338h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82161338h case    1:*/		if ( regs.CR[0].eq ) { return 0x82161340;  }
		/* 82161338h case    1:*/		return 0x8216133C;
		  /* 8216133Ch */ case    2:  		/* ori R9, R9, 64 */
		/* 8216133Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x40);
		/* 8216133Ch case    2:*/		return 0x82161340;
	}
	return 0x82161340;
} // Block from 82161334h-82161340h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82161340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161340);
		  /* 82161340h */ case    0:  		/* rlwimi R11, R10, 5, 19, 26 */
		/* 82161340h case    0:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R10);
		/* 82161340h case    0:*/		return 0x82161344;
		  /* 82161344h */ case    1:  		/* lis R10, -32768 */
		/* 82161344h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82161344h case    1:*/		return 0x82161348;
		  /* 82161348h */ case    2:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 82161348h case    2:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82161348h case    2:*/		return 0x8216134C;
		  /* 8216134Ch */ case    3:  		/* ori R10, R10, 27 */
		/* 8216134Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1B);
		/* 8216134Ch case    3:*/		return 0x82161350;
		  /* 82161350h */ case    4:  		/* mr R7, R4 */
		/* 82161350h case    4:*/		regs.R7 = regs.R4;
		/* 82161350h case    4:*/		return 0x82161354;
		  /* 82161354h */ case    5:  		/* rlwimi R10, R11, 16, 1, 15 */
		/* 82161354h case    5:*/		cpu::op::rlwimi<0,16,1,15>(regs,&regs.R10,regs.R11);
		/* 82161354h case    5:*/		return 0x82161358;
		  /* 82161358h */ case    6:  		/* li R11, 11 */
		/* 82161358h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 82161358h case    6:*/		return 0x8216135C;
		  /* 8216135Ch */ case    7:  		/* stw R10, <#[R5]> */
		/* 8216135Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8216135Ch case    7:*/		return 0x82161360;
		  /* 82161360h */ case    8:  		/* stwu R9, <#[R5 + 4]> */
		/* 82161360h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82161360h case    8:*/		return 0x82161364;
		  /* 82161364h */ case    9:  		/* rlwimi R7, R11, 16, 0, 15 */
		/* 82161364h case    9:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R7,regs.R11);
		/* 82161364h case    9:*/		return 0x82161368;
		  /* 82161368h */ case   10:  		/* stwu R7, <#[R5 + 4]> */
		/* 82161368h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82161368h case   10:*/		return 0x8216136C;
		  /* 8216136Ch */ case   11:  		/* stb R4, <#[R8 + 1]> */
		/* 8216136Ch case   11:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R8 + 0x00000001) );
		/* 8216136Ch case   11:*/		return 0x82161370;
		  /* 82161370h */ case   12:  		/* lwz R11, <#[R6]> */
		/* 82161370h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82161370h case   12:*/		return 0x82161374;
		  /* 82161374h */ case   13:  		/* addi R11, R11, 3 */
		/* 82161374h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82161374h case   13:*/		return 0x82161378;
		  /* 82161378h */ case   14:  		/* addi R3, R5, 4 */
		/* 82161378h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R5,0x4);
		/* 82161378h case   14:*/		return 0x8216137C;
		  /* 8216137Ch */ case   15:  		/* stw R11, <#[R6]> */
		/* 8216137Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8216137Ch case   15:*/		return 0x82161380;
		  /* 82161380h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82161380h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82161380h case   16:*/		return 0x82161384;
	}
	return 0x82161384;
} // Block from 82161340h-82161384h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82161384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161384);
		  /* 82161384h */ case    0:  		/* nop */
		/* 82161384h case    0:*/		cpu::op::nop();
		/* 82161384h case    0:*/		return 0x82161388;
	}
	return 0x82161388;
} // Block from 82161384h-82161388h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161388);
		  /* 82161388h */ case    0:  		/* mfspr R12, LR */
		/* 82161388h case    0:*/		regs.R12 = regs.LR;
		/* 82161388h case    0:*/		return 0x8216138C;
		  /* 8216138Ch */ case    1:  		/* bl -852308 */
		/* 8216138Ch case    1:*/		regs.LR = 0x82161390; return 0x82091238;
		/* 8216138Ch case    1:*/		return 0x82161390;
		  /* 82161390h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82161390h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82161390h case    2:*/		return 0x82161394;
		  /* 82161394h */ case    3:  		/* mr R11, R4 */
		/* 82161394h case    3:*/		regs.R11 = regs.R4;
		/* 82161394h case    3:*/		return 0x82161398;
		  /* 82161398h */ case    4:  		/* mr R31, R3 */
		/* 82161398h case    4:*/		regs.R31 = regs.R3;
		/* 82161398h case    4:*/		return 0x8216139C;
		  /* 8216139Ch */ case    5:  		/* rlwimi R11, R4, 12, 21, 23 */
		/* 8216139Ch case    5:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R4);
		/* 8216139Ch case    5:*/		return 0x821613A0;
		  /* 821613A0h */ case    6:  		/* mr R30, R4 */
		/* 821613A0h case    6:*/		regs.R30 = regs.R4;
		/* 821613A0h case    6:*/		return 0x821613A4;
		  /* 821613A4h */ case    7:  		/* rlwinm R11, R11, 24, 27, 31 */
		/* 821613A4h case    7:*/		cpu::op::rlwinm<0,24,27,31>(regs,&regs.R11,regs.R11);
		/* 821613A4h case    7:*/		return 0x821613A8;
		  /* 821613A8h */ case    8:  		/* mr R23, R5 */
		/* 821613A8h case    8:*/		regs.R23 = regs.R5;
		/* 821613A8h case    8:*/		return 0x821613AC;
		  /* 821613ACh */ case    9:  		/* mr R29, R6 */
		/* 821613ACh case    9:*/		regs.R29 = regs.R6;
		/* 821613ACh case    9:*/		return 0x821613B0;
		  /* 821613B0h */ case   10:  		/* mr R28, R7 */
		/* 821613B0h case   10:*/		regs.R28 = regs.R7;
		/* 821613B0h case   10:*/		return 0x821613B4;
		  /* 821613B4h */ case   11:  		/* mr R21, R8 */
		/* 821613B4h case   11:*/		regs.R21 = regs.R8;
		/* 821613B4h case   11:*/		return 0x821613B8;
		  /* 821613B8h */ case   12:  		/* mr R20, R9 */
		/* 821613B8h case   12:*/		regs.R20 = regs.R9;
		/* 821613B8h case   12:*/		return 0x821613BC;
		  /* 821613BCh */ case   13:  		/* rlwinm R27, R4, 0, 21, 31 */
		/* 821613BCh case   13:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R27,regs.R4);
		/* 821613BCh case   13:*/		return 0x821613C0;
		  /* 821613C0h */ case   14:  		/* li R25, 0 */
		/* 821613C0h case   14:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821613C0h case   14:*/		return 0x821613C4;
		  /* 821613C4h */ case   15:  		/* li R22, 0 */
		/* 821613C4h case   15:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 821613C4h case   15:*/		return 0x821613C8;
		  /* 821613C8h */ case   16:  		/* li R26, 0 */
		/* 821613C8h case   16:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821613C8h case   16:*/		return 0x821613CC;
		  /* 821613CCh */ case   17:  		/* cmpwi CR6, R11, 1 */
		/* 821613CCh case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821613CCh case   17:*/		return 0x821613D0;
		  /* 821613D0h */ case   18:  		/* bc 12, CR6_EQ, 264 */
		/* 821613D0h case   18:*/		if ( regs.CR[6].eq ) { return 0x821614D8;  }
		/* 821613D0h case   18:*/		return 0x821613D4;
		  /* 821613D4h */ case   19:  		/* cmpwi CR6, R11, 2 */
		/* 821613D4h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 821613D4h case   19:*/		return 0x821613D8;
	}
	return 0x821613D8;
} // Block from 82161388h-821613D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821613D8h
// Function '?CC_CompileShader@XGRAPHICS@@YA?AW4_E_SSM_RETURNCODE@1@PAU_CC_STATE_COMPILER@1@IPAU_ABSTRACT_STATE@1@PAU_CS_COMPILED_SHADER@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821613D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821613D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821613D8);
		  /* 821613D8h */ case    0:  		/* bc 12, CR6_EQ, 92 */
		/* 821613D8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82161434;  }
		/* 821613D8h case    0:*/		return 0x821613DC;
		  /* 821613DCh */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 821613DCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821613DCh case    1:*/		return 0x821613E0;
		  /* 821613E0h */ case    2:  		/* bc 12, CR6_EQ, 76 */
		/* 821613E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216142C;  }
		/* 821613E0h case    2:*/		return 0x821613E4;
		  /* 821613E4h */ case    3:  		/* cmpwi CR6, R11, 7 */
		/* 821613E4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 821613E4h case    3:*/		return 0x821613E8;
		  /* 821613E8h */ case    4:  		/* bc 12, CR6_EQ, 60 */
		/* 821613E8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82161424;  }
		/* 821613E8h case    4:*/		return 0x821613EC;
		  /* 821613ECh */ case    5:  		/* cmpwi CR6, R11, 10 */
		/* 821613ECh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 821613ECh case    5:*/		return 0x821613F0;
		  /* 821613F0h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 821613F0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82161418;  }
		/* 821613F0h case    6:*/		return 0x821613F4;
		  /* 821613F4h */ case    7:  		/* cmpwi CR6, R11, 14 */
		/* 821613F4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821613F4h case    7:*/		return 0x821613F8;
		  /* 821613F8h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 821613F8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82161410;  }
		/* 821613F8h case    8:*/		return 0x821613FC;
		  /* 821613FCh */ case    9:  		/* cmpwi CR6, R11, 19 */
		/* 821613FCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000013);
		/* 821613FCh case    9:*/		return 0x82161400;
		  /* 82161400h */ case   10:  		/* li R24, 4 */
		/* 82161400h case   10:*/		cpu::op::li<0>(regs,&regs.R24,0x4);
		/* 82161400h case   10:*/		return 0x82161404;
		  /* 82161404h */ case   11:  		/* bc 4, CR6_EQ, 276 */
		/* 82161404h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82161518;  }
		/* 82161404h case   11:*/		return 0x82161408;
		  /* 82161408h */ case   12:  		/* li R27, 32 */
		/* 82161408h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x20);
		/* 82161408h case   12:*/		return 0x8216140C;
		  /* 8216140Ch */ case   13:  		/* b 268 */
		/* 8216140Ch case   13:*/		return 0x82161518;
		/* 8216140Ch case   13:*/		return 0x82161410;
	}
	return 0x82161410;
} // Block from 821613D8h-82161410h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82161410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161410);
		  /* 82161410h */ case    0:  		/* li R24, 0 */
		/* 82161410h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82161410h case    0:*/		return 0x82161414;
		  /* 82161414h */ case    1:  		/* b 260 */
		/* 82161414h case    1:*/		return 0x82161518;
		/* 82161414h case    1:*/		return 0x82161418;
	}
	return 0x82161418;
} // Block from 82161410h-82161418h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161418);
		  /* 82161418h */ case    0:  		/* bl 1072712 */
		/* 82161418h case    0:*/		regs.LR = 0x8216141C; return 0x82267260;
		/* 82161418h case    0:*/		return 0x8216141C;
		  /* 8216141Ch */ case    1:  		/* lwz R24, <#[R1 + 80]> */
		/* 8216141Ch case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 8216141Ch case    1:*/		return 0x82161420;
		  /* 82161420h */ case    2:  		/* b 248 */
		/* 82161420h case    2:*/		return 0x82161518;
		/* 82161420h case    2:*/		return 0x82161424;
	}
	return 0x82161424;
} // Block from 82161418h-82161424h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82161424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161424);
		  /* 82161424h */ case    0:  		/* li R24, 2 */
		/* 82161424h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x2);
		/* 82161424h case    0:*/		return 0x82161428;
		  /* 82161428h */ case    1:  		/* b 240 */
		/* 82161428h case    1:*/		return 0x82161518;
		/* 82161428h case    1:*/		return 0x8216142C;
	}
	return 0x8216142C;
} // Block from 82161424h-8216142Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216142Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216142C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216142C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216142C);
		  /* 8216142Ch */ case    0:  		/* li R24, 3 */
		/* 8216142Ch case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x3);
		/* 8216142Ch case    0:*/		return 0x82161430;
		  /* 82161430h */ case    1:  		/* b 232 */
		/* 82161430h case    1:*/		return 0x82161518;
		/* 82161430h case    1:*/		return 0x82161434;
	}
	return 0x82161434;
} // Block from 8216142Ch-82161434h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161434);
		  /* 82161434h */ case    0:  		/* rlwinm R11, R30, 0, 18, 18 */
		/* 82161434h case    0:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R11,regs.R30);
		/* 82161434h case    0:*/		return 0x82161438;
		  /* 82161438h */ case    1:  		/* li R24, 1 */
		/* 82161438h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 82161438h case    1:*/		return 0x8216143C;
		  /* 8216143Ch */ case    2:  		/* cmplwi CR6, R11, 8192 */
		/* 8216143Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002000);
		/* 8216143Ch case    2:*/		return 0x82161440;
		  /* 82161440h */ case    3:  		/* bc 4, CR6_EQ, 124 */
		/* 82161440h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821614BC;  }
		/* 82161440h case    3:*/		return 0x82161444;
		  /* 82161444h */ case    4:  		/* cmplwi CR6, R10, 512 */
		/* 82161444h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000200);
		/* 82161444h case    4:*/		return 0x82161448;
		  /* 82161448h */ case    5:  		/* lis R25, 128 */
		/* 82161448h case    5:*/		cpu::op::lis<0>(regs,&regs.R25,0x80);
		/* 82161448h case    5:*/		return 0x8216144C;
		  /* 8216144Ch */ case    6:  		/* bc 12, CR6_LT, 48 */
		/* 8216144Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x8216147C;  }
		/* 8216144Ch case    6:*/		return 0x82161450;
		  /* 82161450h */ case    7:  		/* mr R11, R23 */
		/* 82161450h case    7:*/		regs.R11 = regs.R23;
		/* 82161450h case    7:*/		return 0x82161454;
		  /* 82161454h */ case    8:  		/* rlwimi R11, R23, 12, 21, 23 */
		/* 82161454h case    8:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R23);
		/* 82161454h case    8:*/		return 0x82161458;
		  /* 82161458h */ case    9:  		/* rlwinm R11, R11, 24, 27, 31 */
		/* 82161458h case    9:*/		cpu::op::rlwinm<0,24,27,31>(regs,&regs.R11,regs.R11);
		/* 82161458h case    9:*/		return 0x8216145C;
		  /* 8216145Ch */ case   10:  		/* cmpwi CR6, R11, 3 */
		/* 8216145Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8216145Ch case   10:*/		return 0x82161460;
		  /* 82161460h */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 82161460h case   11:*/		if ( regs.CR[6].eq ) { return 0x82161484;  }
		/* 82161460h case   11:*/		return 0x82161464;
		  /* 82161464h */ case   12:  		/* cmpwi CR6, R11, 15 */
		/* 82161464h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 82161464h case   12:*/		return 0x82161468;
		  /* 82161468h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 82161468h case   13:*/		if ( regs.CR[6].eq ) { return 0x82161474;  }
		/* 82161468h case   13:*/		return 0x8216146C;
		  /* 8216146Ch */ case   14:  		/* bl 1072628 */
		/* 8216146Ch case   14:*/		regs.LR = 0x82161470; return 0x82267260;
		/* 8216146Ch case   14:*/		return 0x82161470;
		  /* 82161470h */ case   15:  		/* b 12 */
		/* 82161470h case   15:*/		return 0x8216147C;
		/* 82161470h case   15:*/		return 0x82161474;
	}
	return 0x82161474;
} // Block from 82161434h-82161474h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82161474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161474);
		  /* 82161474h */ case    0:  		/* lis R22, 1 */
		/* 82161474h case    0:*/		cpu::op::lis<0>(regs,&regs.R22,0x1);
		/* 82161474h case    0:*/		return 0x82161478;
		  /* 82161478h */ case    1:  		/* li R26, 0 */
		/* 82161478h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82161478h case    1:*/		return 0x8216147C;
	}
	return 0x8216147C;
} // Block from 82161474h-8216147Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216147Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216147C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216147C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216147C);
		  /* 8216147Ch */ case    0:  		/* addi R11, R28, -1 */
		/* 8216147Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFF);
		/* 8216147Ch case    0:*/		return 0x82161480;
		  /* 82161480h */ case    1:  		/* b 80 */
		/* 82161480h case    1:*/		return 0x821614D0;
		/* 82161480h case    1:*/		return 0x82161484;
	}
	return 0x82161484;
} // Block from 8216147Ch-82161484h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161484);
		  /* 82161484h */ case    0:  		/* rlwinm R11, R23, 16, 30, 31 */
		/* 82161484h case    0:*/		cpu::op::rlwinm<0,16,30,31>(regs,&regs.R11,regs.R23);
		/* 82161484h case    0:*/		return 0x82161488;
		  /* 82161488h */ case    1:  		/* li R22, 0 */
		/* 82161488h case    1:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82161488h case    1:*/		return 0x8216148C;
		  /* 8216148Ch */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 8216148Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216148Ch case    2:*/		return 0x82161490;
		  /* 82161490h */ case    3:  		/* bc 12, CR6_LT, -24 */
		/* 82161490h case    3:*/		if ( regs.CR[6].lt ) { return 0x82161478;  }
		/* 82161490h case    3:*/		return 0x82161494;
		  /* 82161494h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82161494h case    4:*/		if ( regs.CR[6].eq ) { return 0x821614B4;  }
		/* 82161494h case    4:*/		return 0x82161498;
		  /* 82161498h */ case    5:  		/* cmplwi CR6, R11, 3 */
		/* 82161498h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82161498h case    5:*/		return 0x8216149C;
		  /* 8216149Ch */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 8216149Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x821614AC;  }
		/* 8216149Ch case    6:*/		return 0x821614A0;
		  /* 821614A0h */ case    7:  		/* bc 4, CR6_EQ, -40 */
		/* 821614A0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82161478;  }
		/* 821614A0h case    7:*/		return 0x821614A4;
		  /* 821614A4h */ case    8:  		/* lis R26, 6 */
		/* 821614A4h case    8:*/		cpu::op::lis<0>(regs,&regs.R26,0x6);
		/* 821614A4h case    8:*/		return 0x821614A8;
		  /* 821614A8h */ case    9:  		/* b -44 */
		/* 821614A8h case    9:*/		return 0x8216147C;
		/* 821614A8h case    9:*/		return 0x821614AC;
	}
	return 0x821614AC;
} // Block from 82161484h-821614ACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821614ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821614AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821614AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821614AC);
		  /* 821614ACh */ case    0:  		/* lis R26, 4 */
		/* 821614ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R26,0x4);
		/* 821614ACh case    0:*/		return 0x821614B0;
		  /* 821614B0h */ case    1:  		/* b -52 */
		/* 821614B0h case    1:*/		return 0x8216147C;
		/* 821614B0h case    1:*/		return 0x821614B4;
	}
	return 0x821614B4;
} // Block from 821614ACh-821614B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821614B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821614B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821614B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821614B4);
		  /* 821614B4h */ case    0:  		/* lis R26, 2 */
		/* 821614B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R26,0x2);
		/* 821614B4h case    0:*/		return 0x821614B8;
		  /* 821614B8h */ case    1:  		/* b -60 */
		/* 821614B8h case    1:*/		return 0x8216147C;
		/* 821614B8h case    1:*/		return 0x821614BC;
	}
	return 0x821614BC;
} // Block from 821614B4h-821614BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821614BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821614BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821614BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821614BC);
		  /* 821614BCh */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821614BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821614BCh case    0:*/		return 0x821614C0;
		  /* 821614C0h */ case    1:  		/* li R25, 0 */
		/* 821614C0h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821614C0h case    1:*/		return 0x821614C4;
		  /* 821614C4h */ case    2:  		/* cmplw CR6, R27, R11 */
		/* 821614C4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821614C4h case    2:*/		return 0x821614C8;
		  /* 821614C8h */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 821614C8h case    3:*/		if ( regs.CR[6].lt ) { return 0x821614D0;  }
		/* 821614C8h case    3:*/		return 0x821614CC;
		  /* 821614CCh */ case    4:  		/* mr R11, R27 */
		/* 821614CCh case    4:*/		regs.R11 = regs.R27;
		/* 821614CCh case    4:*/		return 0x821614D0;
	}
	return 0x821614D0;
} // Block from 821614BCh-821614D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821614D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821614D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821614D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821614D0);
		  /* 821614D0h */ case    0:  		/* stw R11, <#[R29]> */
		/* 821614D0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821614D0h case    0:*/		return 0x821614D4;
		  /* 821614D4h */ case    1:  		/* b 68 */
		/* 821614D4h case    1:*/		return 0x82161518;
		/* 821614D4h case    1:*/		return 0x821614D8;
	}
	return 0x821614D8;
} // Block from 821614D0h-821614D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821614D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821614D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821614D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821614D8);
		  /* 821614D8h */ case    0:  		/* rlwinm R11, R30, 0, 18, 18 */
		/* 821614D8h case    0:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R11,regs.R30);
		/* 821614D8h case    0:*/		return 0x821614DC;
		  /* 821614DCh */ case    1:  		/* li R24, 5 */
		/* 821614DCh case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x5);
		/* 821614DCh case    1:*/		return 0x821614E0;
		  /* 821614E0h */ case    2:  		/* cmplwi CR6, R11, 8192 */
		/* 821614E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002000);
		/* 821614E0h case    2:*/		return 0x821614E4;
		  /* 821614E4h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 821614E4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82161518;  }
		/* 821614E4h case    3:*/		return 0x821614E8;
		  /* 821614E8h */ case    4:  		/* cmplwi CR6, R10, 768 */
		/* 821614E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000300);
		/* 821614E8h case    4:*/		return 0x821614EC;
		  /* 821614ECh */ case    5:  		/* bc 12, CR6_LT, 44 */
		/* 821614ECh case    5:*/		if ( regs.CR[6].lt ) { return 0x82161518;  }
		/* 821614ECh case    5:*/		return 0x821614F0;
		  /* 821614F0h */ case    6:  		/* mr R11, R23 */
		/* 821614F0h case    6:*/		regs.R11 = regs.R23;
		/* 821614F0h case    6:*/		return 0x821614F4;
		  /* 821614F4h */ case    7:  		/* lis R25, 128 */
		/* 821614F4h case    7:*/		cpu::op::lis<0>(regs,&regs.R25,0x80);
		/* 821614F4h case    7:*/		return 0x821614F8;
		  /* 821614F8h */ case    8:  		/* rlwimi R11, R23, 12, 21, 23 */
		/* 821614F8h case    8:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R23);
		/* 821614F8h case    8:*/		return 0x821614FC;
		  /* 821614FCh */ case    9:  		/* rlwinm R11, R11, 0, 19, 23 */
		/* 821614FCh case    9:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R11);
		/* 821614FCh case    9:*/		return 0x82161500;
		  /* 82161500h */ case   10:  		/* cmplwi CR6, R11, 3840 */
		/* 82161500h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000F00);
		/* 82161500h case   10:*/		return 0x82161504;
		  /* 82161504h */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 82161504h case   11:*/		if ( regs.CR[6].eq ) { return 0x82161510;  }
		/* 82161504h case   11:*/		return 0x82161508;
		  /* 82161508h */ case   12:  		/* bl 1072472 */
		/* 82161508h case   12:*/		regs.LR = 0x8216150C; return 0x82267260;
		/* 82161508h case   12:*/		return 0x8216150C;
		  /* 8216150Ch */ case   13:  		/* b 12 */
		/* 8216150Ch case   13:*/		return 0x82161518;
		/* 8216150Ch case   13:*/		return 0x82161510;
	}
	return 0x82161510;
} // Block from 821614D8h-82161510h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82161510h
// Function '?CC_Create@XGRAPHICS@@YAPAU_CC_STATE_COMPILER@1@PAXP6APAX0I@ZP6A?AW4_E_SSM_RETURNCODE@1@00@ZPAU_PS_PROGRAM_STORE@1@PAU_SS_SHADER_STORE@1@PAU_SR_SHADER_RECYCLER@1@PAU_TS_TEXTURE_SERVER@1@PAU_SSM_REGISTRY@1@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161510);
		  /* 82161510h */ case    0:  		/* lis R22, 1 */
		/* 82161510h case    0:*/		cpu::op::lis<0>(regs,&regs.R22,0x1);
		/* 82161510h case    0:*/		return 0x82161514;
		  /* 82161514h */ case    1:  		/* li R26, 0 */
		/* 82161514h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82161514h case    1:*/		return 0x82161518;
	}
	return 0x82161518;
} // Block from 82161510h-82161518h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161518);
		  /* 82161518h */ case    0:  		/* rlwinm R11, R30, 0, 8, 15 */
		/* 82161518h case    0:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R11,regs.R30);
		/* 82161518h case    0:*/		return 0x8216151C;
		  /* 8216151Ch */ case    1:  		/* lis R10, 228 */
		/* 8216151Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xE4);
		/* 8216151Ch case    1:*/		return 0x82161520;
		  /* 82161520h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82161520h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161520h case    2:*/		return 0x82161524;
		  /* 82161524h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82161524h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82161530;  }
		/* 82161524h case    3:*/		return 0x82161528;
		  /* 82161528h */ case    4:  		/* li R3, 12816 */
		/* 82161528h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x3210);
		/* 82161528h case    4:*/		return 0x8216152C;
		  /* 8216152Ch */ case    5:  		/* b 12 */
		/* 8216152Ch case    5:*/		return 0x82161538;
		/* 8216152Ch case    5:*/		return 0x82161530;
	}
	return 0x82161530;
} // Block from 82161518h-82161530h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82161530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161530);
		  /* 82161530h */ case    0:  		/* mr R3, R30 */
		/* 82161530h case    0:*/		regs.R3 = regs.R30;
		/* 82161530h case    0:*/		return 0x82161534;
		  /* 82161534h */ case    1:  		/* bl -828 */
		/* 82161534h case    1:*/		regs.LR = 0x82161538; return 0x821611F8;
		/* 82161534h case    1:*/		return 0x82161538;
	}
	return 0x82161538;
} // Block from 82161530h-82161538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161538);
		  /* 82161538h */ case    0:  		/* lis R10, 1792 */
		/* 82161538h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x700);
		/* 82161538h case    0:*/		return 0x8216153C;
		  /* 8216153Ch */ case    1:  		/* rlwinm R11, R30, 0, 4, 7 */
		/* 8216153Ch case    1:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R30);
		/* 8216153Ch case    1:*/		return 0x82161540;
		  /* 82161540h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82161540h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161540h case    2:*/		return 0x82161544;
		  /* 82161544h */ case    3:  		/* bc 12, CR6_GT, 136 */
		/* 82161544h case    3:*/		if ( regs.CR[6].gt ) { return 0x821615CC;  }
		/* 82161544h case    3:*/		return 0x82161548;
		  /* 82161548h */ case    4:  		/* bc 12, CR6_EQ, 124 */
		/* 82161548h case    4:*/		if ( regs.CR[6].eq ) { return 0x821615C4;  }
		/* 82161548h case    4:*/		return 0x8216154C;
		  /* 8216154Ch */ case    5:  		/* lis R10, 256 */
		/* 8216154Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x100);
		/* 8216154Ch case    5:*/		return 0x82161550;
		  /* 82161550h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82161550h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161550h case    6:*/		return 0x82161554;
		  /* 82161554h */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82161554h case    7:*/		if ( regs.CR[6].eq ) { return 0x821615BC;  }
		/* 82161554h case    7:*/		return 0x82161558;
		  /* 82161558h */ case    8:  		/* lis R10, 512 */
		/* 82161558h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 82161558h case    8:*/		return 0x8216155C;
		  /* 8216155Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8216155Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216155Ch case    9:*/		return 0x82161560;
		  /* 82161560h */ case   10:  		/* bc 12, CR6_EQ, 84 */
		/* 82161560h case   10:*/		if ( regs.CR[6].eq ) { return 0x821615B4;  }
		/* 82161560h case   10:*/		return 0x82161564;
		  /* 82161564h */ case   11:  		/* lis R10, 768 */
		/* 82161564h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x300);
		/* 82161564h case   11:*/		return 0x82161568;
		  /* 82161568h */ case   12:  		/* cmplw CR6, R11, R10 */
		/* 82161568h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161568h case   12:*/		return 0x8216156C;
		  /* 8216156Ch */ case   13:  		/* bc 12, CR6_EQ, 64 */
		/* 8216156Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821615AC;  }
		/* 8216156Ch case   13:*/		return 0x82161570;
		  /* 82161570h */ case   14:  		/* lis R10, 1024 */
		/* 82161570h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 82161570h case   14:*/		return 0x82161574;
		  /* 82161574h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 82161574h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161574h case   15:*/		return 0x82161578;
		  /* 82161578h */ case   16:  		/* bc 12, CR6_EQ, 44 */
		/* 82161578h case   16:*/		if ( regs.CR[6].eq ) { return 0x821615A4;  }
		/* 82161578h case   16:*/		return 0x8216157C;
		  /* 8216157Ch */ case   17:  		/* lis R10, 1280 */
		/* 8216157Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x500);
		/* 8216157Ch case   17:*/		return 0x82161580;
		  /* 82161580h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 82161580h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161580h case   18:*/		return 0x82161584;
		  /* 82161584h */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 82161584h case   19:*/		if ( regs.CR[6].eq ) { return 0x8216159C;  }
		/* 82161584h case   19:*/		return 0x82161588;
		  /* 82161588h */ case   20:  		/* lis R10, 1536 */
		/* 82161588h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0x600);
		/* 82161588h case   20:*/		return 0x8216158C;
		  /* 8216158Ch */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 8216158Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216158Ch case   21:*/		return 0x82161590;
		  /* 82161590h */ case   22:  		/* bc 4, CR6_EQ, 120 */
		/* 82161590h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82161608;  }
		/* 82161590h case   22:*/		return 0x82161594;
		  /* 82161594h */ case   23:  		/* lis R11, 1 */
		/* 82161594h case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82161594h case   23:*/		return 0x82161598;
		  /* 82161598h */ case   24:  		/* b 160 */
		/* 82161598h case   24:*/		return 0x82161638;
		/* 82161598h case   24:*/		return 0x8216159C;
	}
	return 0x8216159C;
} // Block from 82161538h-8216159Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216159Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216159C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216159C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216159C);
		  /* 8216159Ch */ case    0:  		/* lis R11, 8 */
		/* 8216159Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x8);
		/* 8216159Ch case    0:*/		return 0x821615A0;
		  /* 821615A0h */ case    1:  		/* b 148 */
		/* 821615A0h case    1:*/		return 0x82161634;
		/* 821615A0h case    1:*/		return 0x821615A4;
	}
	return 0x821615A4;
} // Block from 8216159Ch-821615A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821615A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821615A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821615A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821615A4);
		  /* 821615A4h */ case    0:  		/* lis R11, 8 */
		/* 821615A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x8);
		/* 821615A4h case    0:*/		return 0x821615A8;
		  /* 821615A8h */ case    1:  		/* b 144 */
		/* 821615A8h case    1:*/		return 0x82161638;
		/* 821615A8h case    1:*/		return 0x821615AC;
	}
	return 0x821615AC;
} // Block from 821615A4h-821615ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821615ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821615AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821615AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821615AC);
		  /* 821615ACh */ case    0:  		/* lis R11, 2 */
		/* 821615ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 821615ACh case    0:*/		return 0x821615B0;
		  /* 821615B0h */ case    1:  		/* b 132 */
		/* 821615B0h case    1:*/		return 0x82161634;
		/* 821615B0h case    1:*/		return 0x821615B4;
	}
	return 0x821615B4;
} // Block from 821615ACh-821615B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821615B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821615B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821615B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821615B4);
		  /* 821615B4h */ case    0:  		/* lis R11, 2 */
		/* 821615B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 821615B4h case    0:*/		return 0x821615B8;
		  /* 821615B8h */ case    1:  		/* b 128 */
		/* 821615B8h case    1:*/		return 0x82161638;
		/* 821615B8h case    1:*/		return 0x821615BC;
	}
	return 0x821615BC;
} // Block from 821615B4h-821615BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821615BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821615BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821615BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821615BC);
		  /* 821615BCh */ case    0:  		/* lis R11, 0 */
		/* 821615BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 821615BCh case    0:*/		return 0x821615C0;
		  /* 821615C0h */ case    1:  		/* b 116 */
		/* 821615C0h case    1:*/		return 0x82161634;
		/* 821615C0h case    1:*/		return 0x821615C4;
	}
	return 0x821615C4;
} // Block from 821615BCh-821615C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821615C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821615C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821615C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821615C4);
		  /* 821615C4h */ case    0:  		/* lis R11, 4 */
		/* 821615C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x4);
		/* 821615C4h case    0:*/		return 0x821615C8;
		  /* 821615C8h */ case    1:  		/* b 112 */
		/* 821615C8h case    1:*/		return 0x82161638;
		/* 821615C8h case    1:*/		return 0x821615CC;
	}
	return 0x821615CC;
} // Block from 821615C4h-821615CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821615CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821615CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821615CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821615CC);
		  /* 821615CCh */ case    0:  		/* lis R10, 2048 */
		/* 821615CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 821615CCh case    0:*/		return 0x821615D0;
		  /* 821615D0h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 821615D0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821615D0h case    1:*/		return 0x821615D4;
		  /* 821615D4h */ case    2:  		/* bc 12, CR6_EQ, 92 */
		/* 821615D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82161630;  }
		/* 821615D4h case    2:*/		return 0x821615D8;
		  /* 821615D8h */ case    3:  		/* lis R10, 2304 */
		/* 821615D8h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x900);
		/* 821615D8h case    3:*/		return 0x821615DC;
		  /* 821615DCh */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 821615DCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821615DCh case    4:*/		return 0x821615E0;
		  /* 821615E0h */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 821615E0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82161628;  }
		/* 821615E0h case    5:*/		return 0x821615E4;
		  /* 821615E4h */ case    6:  		/* lis R10, 2560 */
		/* 821615E4h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xA00);
		/* 821615E4h case    6:*/		return 0x821615E8;
		  /* 821615E8h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 821615E8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821615E8h case    7:*/		return 0x821615EC;
		  /* 821615ECh */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 821615ECh case    8:*/		if ( regs.CR[6].eq ) { return 0x82161620;  }
		/* 821615ECh case    8:*/		return 0x821615F0;
		  /* 821615F0h */ case    9:  		/* lis R10, 2816 */
		/* 821615F0h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xB00);
		/* 821615F0h case    9:*/		return 0x821615F4;
		  /* 821615F4h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 821615F4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821615F4h case   10:*/		return 0x821615F8;
		  /* 821615F8h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 821615F8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82161618;  }
		/* 821615F8h case   11:*/		return 0x821615FC;
		  /* 821615FCh */ case   12:  		/* lis R10, 3072 */
		/* 821615FCh case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xC00);
		/* 821615FCh case   12:*/		return 0x82161600;
		  /* 82161600h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 82161600h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161600h case   13:*/		return 0x82161604;
		  /* 82161604h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 82161604h case   14:*/		if ( regs.CR[6].eq ) { return 0x82161610;  }
		/* 82161604h case   14:*/		return 0x82161608;
	}
	return 0x82161608;
} // Block from 821615CCh-82161608h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82161608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161608);
		  /* 82161608h */ case    0:  		/* li R11, 0 */
		/* 82161608h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82161608h case    0:*/		return 0x8216160C;
		  /* 8216160Ch */ case    1:  		/* b 44 */
		/* 8216160Ch case    1:*/		return 0x82161638;
		/* 8216160Ch case    1:*/		return 0x82161610;
	}
	return 0x82161610;
} // Block from 82161608h-82161610h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161610);
		  /* 82161610h */ case    0:  		/* lis R11, 16 */
		/* 82161610h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x10);
		/* 82161610h case    0:*/		return 0x82161614;
		  /* 82161614h */ case    1:  		/* b 32 */
		/* 82161614h case    1:*/		return 0x82161634;
		/* 82161614h case    1:*/		return 0x82161618;
	}
	return 0x82161618;
} // Block from 82161610h-82161618h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161618);
		  /* 82161618h */ case    0:  		/* lis R11, 16 */
		/* 82161618h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x10);
		/* 82161618h case    0:*/		return 0x8216161C;
		  /* 8216161Ch */ case    1:  		/* b 28 */
		/* 8216161Ch case    1:*/		return 0x82161638;
		/* 8216161Ch case    1:*/		return 0x82161620;
	}
	return 0x82161620;
} // Block from 82161618h-82161620h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161620);
		  /* 82161620h */ case    0:  		/* lis R11, 96 */
		/* 82161620h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x60);
		/* 82161620h case    0:*/		return 0x82161624;
		  /* 82161624h */ case    1:  		/* b 20 */
		/* 82161624h case    1:*/		return 0x82161638;
		/* 82161624h case    1:*/		return 0x82161628;
	}
	return 0x82161628;
} // Block from 82161620h-82161628h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161628);
		  /* 82161628h */ case    0:  		/* lis R11, 64 */
		/* 82161628h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x40);
		/* 82161628h case    0:*/		return 0x8216162C;
		  /* 8216162Ch */ case    1:  		/* b 12 */
		/* 8216162Ch case    1:*/		return 0x82161638;
		/* 8216162Ch case    1:*/		return 0x82161630;
	}
	return 0x82161630;
} // Block from 82161628h-82161630h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161630);
		  /* 82161630h */ case    0:  		/* lis R11, 4 */
		/* 82161630h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x4);
		/* 82161630h case    0:*/		return 0x82161634;
	}
	return 0x82161634;
} // Block from 82161630h-82161634h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161634);
		  /* 82161634h */ case    0:  		/* ori R11, R11, 34952 */
		/* 82161634h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8888);
		/* 82161634h case    0:*/		return 0x82161638;
	}
	return 0x82161638;
} // Block from 82161634h-82161638h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161638);
		  /* 82161638h */ case    0:  		/* cmplwi CR6, R21, 9 */
		/* 82161638h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000009);
		/* 82161638h case    0:*/		return 0x8216163C;
		  /* 8216163Ch */ case    1:  		/* bc 12, CR6_EQ, 300 */
		/* 8216163Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82161768;  }
		/* 8216163Ch case    1:*/		return 0x82161640;
		  /* 82161640h */ case    2:  		/* cmplwi CR6, R21, 53 */
		/* 82161640h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000035);
		/* 82161640h case    2:*/		return 0x82161644;
		  /* 82161644h */ case    3:  		/* bc 12, CR6_EQ, 292 */
		/* 82161644h case    3:*/		if ( regs.CR[6].eq ) { return 0x82161768;  }
		/* 82161644h case    3:*/		return 0x82161648;
		  /* 82161648h */ case    4:  		/* cmplwi CR6, R21, 59 */
		/* 82161648h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x0000003B);
		/* 82161648h case    4:*/		return 0x8216164C;
		  /* 8216164Ch */ case    5:  		/* bc 4, CR6_GT, 52 */
		/* 8216164Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82161680;  }
		/* 8216164Ch case    5:*/		return 0x82161650;
		  /* 82161650h */ case    6:  		/* cmplwi CR6, R21, 61 */
		/* 82161650h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x0000003D);
		/* 82161650h case    6:*/		return 0x82161654;
		  /* 82161654h */ case    7:  		/* bc 4, CR6_GT, 40 */
		/* 82161654h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8216167C;  }
		/* 82161654h case    7:*/		return 0x82161658;
		  /* 82161658h */ case    8:  		/* cmplwi CR6, R21, 62 */
		/* 82161658h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x0000003E);
		/* 82161658h case    8:*/		return 0x8216165C;
		  /* 8216165Ch */ case    9:  		/* bc 12, CR6_EQ, 268 */
		/* 8216165Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82161768;  }
		/* 8216165Ch case    9:*/		return 0x82161660;
		  /* 82161660h */ case   10:  		/* cmplwi CR6, R21, 78 */
		/* 82161660h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x0000004E);
		/* 82161660h case   10:*/		return 0x82161664;
		  /* 82161664h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 82161664h case   11:*/		if ( regs.CR[6].eq ) { return 0x82161674;  }
		/* 82161664h case   11:*/		return 0x82161668;
		  /* 82161668h */ case   12:  		/* cmplwi CR6, R21, 85 */
		/* 82161668h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000055);
		/* 82161668h case   12:*/		return 0x8216166C;
		  /* 8216166Ch */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 8216166Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8216167C;  }
		/* 8216166Ch case   13:*/		return 0x82161670;
		  /* 82161670h */ case   14:  		/* b 16 */
		/* 82161670h case   14:*/		return 0x82161680;
		/* 82161670h case   14:*/		return 0x82161674;
	}
	return 0x82161674;
} // Block from 82161638h-82161674h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82161674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161674);
		  /* 82161674h */ case    0:  		/* rlwinm. R10, R20, 0, 24, 31 */
		/* 82161674h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R20);
		/* 82161674h case    0:*/		return 0x82161678;
		  /* 82161678h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 82161678h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82161680;  }
		/* 82161678h case    1:*/		return 0x8216167C;
	}
	return 0x8216167C;
} // Block from 82161674h-8216167Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216167Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216167C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216167C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216167C);
		  /* 8216167Ch */ case    0:  		/* oris R11, R11, 16 */
		/* 8216167Ch case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8216167Ch case    0:*/		return 0x82161680;
	}
	return 0x82161680;
} // Block from 8216167Ch-82161680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161680);
		  /* 82161680h */ case    0:  		/* lis R10, 128 */
		/* 82161680h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x80);
		/* 82161680h case    0:*/		return 0x82161684;
		  /* 82161684h */ case    1:  		/* cmplw CR6, R25, R10 */
		/* 82161684h case    1:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 82161684h case    1:*/		return 0x82161688;
		  /* 82161688h */ case    2:  		/* bc 4, CR6_EQ, 136 */
		/* 82161688h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82161710;  }
		/* 82161688h case    2:*/		return 0x8216168C;
		  /* 8216168Ch */ case    3:  		/* cmplwi CR6, R3, 12816 */
		/* 8216168Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00003210);
		/* 8216168Ch case    3:*/		return 0x82161690;
		  /* 82161690h */ case    4:  		/* bc 4, CR6_EQ, 68 */
		/* 82161690h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821616D4;  }
		/* 82161690h case    4:*/		return 0x82161694;
		  /* 82161694h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82161694h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82161694h case    5:*/		return 0x82161698;
		  /* 82161698h */ case    6:  		/* bc 4, CR6_EQ, 60 */
		/* 82161698h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821616D4;  }
		/* 82161698h case    6:*/		return 0x8216169C;
		  /* 8216169Ch */ case    7:  		/* rlwinm R10, R24, 0, 26, 24 */
		/* 8216169Ch case    7:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R10,regs.R24);
		/* 8216169Ch case    7:*/		return 0x821616A0;
		  /* 821616A0h */ case    8:  		/* lwz R11, <#[R1 + 276]> */
		/* 821616A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000114) );
		/* 821616A0h case    8:*/		return 0x821616A4;
		  /* 821616A4h */ case    9:  		/* rlwinm R9, R23, 0, 21, 31 */
		/* 821616A4h case    9:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R9,regs.R23);
		/* 821616A4h case    9:*/		return 0x821616A8;
		  /* 821616A8h */ case   10:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 821616A8h case   10:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 821616A8h case   10:*/		return 0x821616AC;
		  /* 821616ACh */ case   11:  		/* rlwinm R8, R27, 0, 16, 31 */
		/* 821616ACh case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R27);
		/* 821616ACh case   11:*/		return 0x821616B0;
		  /* 821616B0h */ case   12:  		/* oris R10, R10, 128 */
		/* 821616B0h case   12:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x80);
		/* 821616B0h case   12:*/		return 0x821616B4;
		  /* 821616B4h */ case   13:  		/* or R9, R9, R26 */
		/* 821616B4h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R26);
		/* 821616B4h case   13:*/		return 0x821616B8;
		  /* 821616B8h */ case   14:  		/* or R10, R10, R8 */
		/* 821616B8h case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821616B8h case   14:*/		return 0x821616BC;
		  /* 821616BCh */ case   15:  		/* or R9, R9, R22 */
		/* 821616BCh case   15:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R22);
		/* 821616BCh case   15:*/		return 0x821616C0;
		  /* 821616C0h */ case   16:  		/* stw R10, <#[R31]> */
		/* 821616C0h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821616C0h case   16:*/		return 0x821616C4;
		  /* 821616C4h */ case   17:  		/* stwu R9, <#[R31 + 4]> */
		/* 821616C4h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 821616C4h case   17:*/		return 0x821616C8;
		  /* 821616C8h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 821616C8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821616C8h case   18:*/		return 0x821616CC;
		  /* 821616CCh */ case   19:  		/* addi R10, R10, 2 */
		/* 821616CCh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821616CCh case   19:*/		return 0x821616D0;
		  /* 821616D0h */ case   20:  		/* b 172 */
		/* 821616D0h case   20:*/		return 0x8216177C;
		/* 821616D0h case   20:*/		return 0x821616D4;
	}
	return 0x821616D4;
} // Block from 82161680h-821616D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821616D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821616D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821616D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821616D4);
		  /* 821616D4h */ case    0:  		/* rlwinm R9, R24, 16, 0, 15 */
		/* 821616D4h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R9,regs.R24);
		/* 821616D4h case    0:*/		return 0x821616D8;
		  /* 821616D8h */ case    1:  		/* lwz R10, <#[R1 + 276]> */
		/* 821616D8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000114) );
		/* 821616D8h case    1:*/		return 0x821616DC;
		  /* 821616DCh */ case    2:  		/* rlwinm R8, R27, 0, 16, 31 */
		/* 821616DCh case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R27);
		/* 821616DCh case    2:*/		return 0x821616E0;
		  /* 821616E0h */ case    3:  		/* oris R9, R9, 192 */
		/* 821616E0h case    3:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0xC0);
		/* 821616E0h case    3:*/		return 0x821616E4;
		  /* 821616E4h */ case    4:  		/* or R11, R11, R3 */
		/* 821616E4h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 821616E4h case    4:*/		return 0x821616E8;
		  /* 821616E8h */ case    5:  		/* or R9, R9, R8 */
		/* 821616E8h case    5:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821616E8h case    5:*/		return 0x821616EC;
		  /* 821616ECh */ case    6:  		/* rlwinm R8, R23, 0, 21, 31 */
		/* 821616ECh case    6:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R8,regs.R23);
		/* 821616ECh case    6:*/		return 0x821616F0;
		  /* 821616F0h */ case    7:  		/* stw R9, <#[R31]> */
		/* 821616F0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821616F0h case    7:*/		return 0x821616F4;
		  /* 821616F4h */ case    8:  		/* stwu R11, <#[R31 + 4]> */
		/* 821616F4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 821616F4h case    8:*/		return 0x821616F8;
		  /* 821616F8h */ case    9:  		/* or R11, R8, R26 */
		/* 821616F8h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R26);
		/* 821616F8h case    9:*/		return 0x821616FC;
		  /* 821616FCh */ case   10:  		/* or R11, R11, R22 */
		/* 821616FCh case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R22);
		/* 821616FCh case   10:*/		return 0x82161700;
		  /* 82161700h */ case   11:  		/* stwu R11, <#[R31 + 4]> */
		/* 82161700h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161700h case   11:*/		return 0x82161704;
		  /* 82161704h */ case   12:  		/* lwz R11, <#[R10]> */
		/* 82161704h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82161704h case   12:*/		return 0x82161708;
		  /* 82161708h */ case   13:  		/* addi R11, R11, 3 */
		/* 82161708h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82161708h case   13:*/		return 0x8216170C;
		  /* 8216170Ch */ case   14:  		/* b 84 */
		/* 8216170Ch case   14:*/		return 0x82161760;
		/* 8216170Ch case   14:*/		return 0x82161710;
	}
	return 0x82161710;
} // Block from 821616D4h-82161710h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82161710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161710);
		  /* 82161710h */ case    0:  		/* cmplwi CR6, R3, 12816 */
		/* 82161710h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00003210);
		/* 82161710h case    0:*/		return 0x82161714;
		  /* 82161714h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82161714h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82161734;  }
		/* 82161714h case    1:*/		return 0x82161718;
		  /* 82161718h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82161718h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82161718h case    2:*/		return 0x8216171C;
		  /* 8216171Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8216171Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82161734;  }
		/* 8216171Ch case    3:*/		return 0x82161720;
		  /* 82161720h */ case    4:  		/* rlwimi R27, R24, 16, 0, 15 */
		/* 82161720h case    4:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R27,regs.R24);
		/* 82161720h case    4:*/		return 0x82161724;
		  /* 82161724h */ case    5:  		/* or R10, R27, R25 */
		/* 82161724h case    5:*/		cpu::op::or<0>(regs,&regs.R10,regs.R27,regs.R25);
		/* 82161724h case    5:*/		return 0x82161728;
		  /* 82161728h */ case    6:  		/* rlwinm R10, R10, 0, 10, 8 */
		/* 82161728h case    6:*/		cpu::op::rlwinm<0,0,10,8>(regs,&regs.R10,regs.R10);
		/* 82161728h case    6:*/		return 0x8216172C;
		  /* 8216172Ch */ case    7:  		/* stw R10, <#[R31]> */
		/* 8216172Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8216172Ch case    7:*/		return 0x82161730;
		  /* 82161730h */ case    8:  		/* b 64 */
		/* 82161730h case    8:*/		return 0x82161770;
		/* 82161730h case    8:*/		return 0x82161734;
	}
	return 0x82161734;
} // Block from 82161710h-82161734h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82161734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161734);
		  /* 82161734h */ case    0:  		/* rlwinm R9, R24, 16, 0, 15 */
		/* 82161734h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R9,regs.R24);
		/* 82161734h case    0:*/		return 0x82161738;
		  /* 82161738h */ case    1:  		/* lwz R10, <#[R1 + 276]> */
		/* 82161738h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000114) );
		/* 82161738h case    1:*/		return 0x8216173C;
		  /* 8216173Ch */ case    2:  		/* rlwinm R8, R27, 0, 16, 31 */
		/* 8216173Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R27);
		/* 8216173Ch case    2:*/		return 0x82161740;
		  /* 82161740h */ case    3:  		/* oris R9, R9, 64 */
		/* 82161740h case    3:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x40);
		/* 82161740h case    3:*/		return 0x82161744;
		  /* 82161744h */ case    4:  		/* or R11, R11, R3 */
		/* 82161744h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82161744h case    4:*/		return 0x82161748;
		  /* 82161748h */ case    5:  		/* or R9, R9, R8 */
		/* 82161748h case    5:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82161748h case    5:*/		return 0x8216174C;
		  /* 8216174Ch */ case    6:  		/* or R9, R9, R25 */
		/* 8216174Ch case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R25);
		/* 8216174Ch case    6:*/		return 0x82161750;
		  /* 82161750h */ case    7:  		/* stw R9, <#[R31]> */
		/* 82161750h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82161750h case    7:*/		return 0x82161754;
		  /* 82161754h */ case    8:  		/* stwu R11, <#[R31 + 4]> */
		/* 82161754h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161754h case    8:*/		return 0x82161758;
		  /* 82161758h */ case    9:  		/* lwz R11, <#[R10]> */
		/* 82161758h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82161758h case    9:*/		return 0x8216175C;
		  /* 8216175Ch */ case   10:  		/* addi R11, R11, 2 */
		/* 8216175Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8216175Ch case   10:*/		return 0x82161760;
	}
	return 0x82161760;
} // Block from 82161734h-82161760h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82161760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161760);
		  /* 82161760h */ case    0:  		/* stw R11, <#[R10]> */
		/* 82161760h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82161760h case    0:*/		return 0x82161764;
		  /* 82161764h */ case    1:  		/* b 28 */
		/* 82161764h case    1:*/		return 0x82161780;
		/* 82161764h case    1:*/		return 0x82161768;
	}
	return 0x82161768;
} // Block from 82161760h-82161768h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161768);
		  /* 82161768h */ case    0:  		/* rlwimi R27, R24, 16, 0, 15 */
		/* 82161768h case    0:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R27,regs.R24);
		/* 82161768h case    0:*/		return 0x8216176C;
		  /* 8216176Ch */ case    1:  		/* stw R27, <#[R31]> */
		/* 8216176Ch case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 8216176Ch case    1:*/		return 0x82161770;
	}
	return 0x82161770;
} // Block from 82161768h-82161770h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161770);
		  /* 82161770h */ case    0:  		/* lwz R11, <#[R1 + 276]> */
		/* 82161770h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000114) );
		/* 82161770h case    0:*/		return 0x82161774;
		  /* 82161774h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 82161774h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82161774h case    1:*/		return 0x82161778;
		  /* 82161778h */ case    2:  		/* addi R10, R10, 1 */
		/* 82161778h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82161778h case    2:*/		return 0x8216177C;
	}
	return 0x8216177C;
} // Block from 82161770h-8216177Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216177Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216177C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216177C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216177C);
		  /* 8216177Ch */ case    0:  		/* stw R10, <#[R11]> */
		/* 8216177Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216177Ch case    0:*/		return 0x82161780;
	}
	return 0x82161780;
} // Block from 8216177Ch-82161780h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161780);
		  /* 82161780h */ case    0:  		/* addi R3, R31, 4 */
		/* 82161780h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161780h case    0:*/		return 0x82161784;
		  /* 82161784h */ case    1:  		/* addi R1, R1, 192 */
		/* 82161784h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82161784h case    1:*/		return 0x82161788;
		  /* 82161788h */ case    2:  		/* b -853248 */
		/* 82161788h case    2:*/		return 0x82091288;
		/* 82161788h case    2:*/		return 0x8216178C;
		  /* 8216178Ch */ case    3:  		/* nop */
		/* 8216178Ch case    3:*/		cpu::op::nop();
		/* 8216178Ch case    3:*/		return 0x82161790;
	}
	return 0x82161790;
} // Block from 82161780h-82161790h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82161790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161790);
		  /* 82161790h */ case    0:  		/* mfspr R12, LR */
		/* 82161790h case    0:*/		regs.R12 = regs.LR;
		/* 82161790h case    0:*/		return 0x82161794;
		  /* 82161794h */ case    1:  		/* bl -853304 */
		/* 82161794h case    1:*/		regs.LR = 0x82161798; return 0x8209125C;
		/* 82161794h case    1:*/		return 0x82161798;
		  /* 82161798h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82161798h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82161798h case    2:*/		return 0x8216179C;
		  /* 8216179Ch */ case    3:  		/* li R11, 12 */
		/* 8216179Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 8216179Ch case    3:*/		return 0x821617A0;
		  /* 821617A0h */ case    4:  		/* li R10, 1 */
		/* 821617A0h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821617A0h case    4:*/		return 0x821617A4;
		  /* 821617A4h */ case    5:  		/* stw R11, <#[R3]> */
		/* 821617A4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821617A4h case    5:*/		return 0x821617A8;
		  /* 821617A8h */ case    6:  		/* mr R31, R6 */
		/* 821617A8h case    6:*/		regs.R31 = regs.R6;
		/* 821617A8h case    6:*/		return 0x821617AC;
		  /* 821617ACh */ case    7:  		/* stw R10, <#[R1 + 80]> */
		/* 821617ACh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821617ACh case    7:*/		return 0x821617B0;
		  /* 821617B0h */ case    8:  		/* mr R30, R7 */
		/* 821617B0h case    8:*/		regs.R30 = regs.R7;
		/* 821617B0h case    8:*/		return 0x821617B4;
		  /* 821617B4h */ case    9:  		/* mr R7, R9 */
		/* 821617B4h case    9:*/		regs.R7 = regs.R9;
		/* 821617B4h case    9:*/		return 0x821617B8;
		  /* 821617B8h */ case   10:  		/* addi R6, R1, 80 */
		/* 821617B8h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 821617B8h case   10:*/		return 0x821617BC;
		  /* 821617BCh */ case   11:  		/* addi R3, R3, 4 */
		/* 821617BCh case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821617BCh case   11:*/		return 0x821617C0;
		  /* 821617C0h */ case   12:  		/* mr R29, R8 */
		/* 821617C0h case   12:*/		regs.R29 = regs.R8;
		/* 821617C0h case   12:*/		return 0x821617C4;
		  /* 821617C4h */ case   13:  		/* bl -2484 */
		/* 821617C4h case   13:*/		regs.LR = 0x821617C8; return 0x82160E10;
		/* 821617C4h case   13:*/		return 0x821617C8;
		  /* 821617C8h */ case   14:  		/* lis R10, 3328 */
		/* 821617C8h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0xD00);
		/* 821617C8h case   14:*/		return 0x821617CC;
		  /* 821617CCh */ case   15:  		/* rlwinm R11, R31, 0, 4, 7 */
		/* 821617CCh case   15:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R31);
		/* 821617CCh case   15:*/		return 0x821617D0;
		  /* 821617D0h */ case   16:  		/* lis R5, 228 */
		/* 821617D0h case   16:*/		cpu::op::lis<0>(regs,&regs.R5,0xE4);
		/* 821617D0h case   16:*/		return 0x821617D4;
		  /* 821617D4h */ case   17:  		/* subf R11, R11, R10 */
		/* 821617D4h case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821617D4h case   17:*/		return 0x821617D8;
		  /* 821617D8h */ case   18:  		/* lis R10, 1 */
		/* 821617D8h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 821617D8h case   18:*/		return 0x821617DC;
		  /* 821617DCh */ case   19:  		/* addic R11, R11, -1 */
		/* 821617DCh case   19:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821617DCh case   19:*/		return 0x821617E0;
		  /* 821617E0h */ case   20:  		/* rlwinm R9, R31, 0, 8, 15 */
		/* 821617E0h case   20:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R9,regs.R31);
		/* 821617E0h case   20:*/		return 0x821617E4;
		  /* 821617E4h */ case   21:  		/* subfe R11, R11, R11 */
		/* 821617E4h case   21:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821617E4h case   21:*/		return 0x821617E8;
		  /* 821617E8h */ case   22:  		/* mr R7, R3 */
		/* 821617E8h case   22:*/		regs.R7 = regs.R3;
		/* 821617E8h case   22:*/		return 0x821617EC;
		  /* 821617ECh */ case   23:  		/* and R6, R11, R10 */
		/* 821617ECh case   23:*/		cpu::op::and<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 821617ECh case   23:*/		return 0x821617F0;
		  /* 821617F0h */ case   24:  		/* lis R11, 68 */
		/* 821617F0h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0x44);
		/* 821617F0h case   24:*/		return 0x821617F4;
		  /* 821617F4h */ case   25:  		/* cmplw CR6, R9, R5 */
		/* 821617F4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 821617F4h case   25:*/		return 0x821617F8;
		  /* 821617F8h */ case   26:  		/* ori R11, R11, 32 */
		/* 821617F8h case   26:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821617F8h case   26:*/		return 0x821617FC;
		  /* 821617FCh */ case   27:  		/* stw R11, <#[R3]> */
		/* 821617FCh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821617FCh case   27:*/		return 0x82161800;
		  /* 82161800h */ case   28:  		/* bc 4, CR6_EQ, 16 */
		/* 82161800h case   28:*/		if ( !regs.CR[6].eq ) { return 0x82161810;  }
		/* 82161800h case   28:*/		return 0x82161804;
		  /* 82161804h */ case   29:  		/* ori R9, R6, 12816 */
		/* 82161804h case   29:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R6,0x3210);
		/* 82161804h case   29:*/		return 0x82161808;
		  /* 82161808h */ case   30:  		/* stwu R9, <#[R7 + 4]> */
		/* 82161808h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82161808h case   30:*/		return 0x8216180C;
		  /* 8216180Ch */ case   31:  		/* b 20 */
		/* 8216180Ch case   31:*/		return 0x82161820;
		/* 8216180Ch case   31:*/		return 0x82161810;
	}
	return 0x82161810;
} // Block from 82161790h-82161810h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82161810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161810);
		  /* 82161810h */ case    0:  		/* mr R3, R31 */
		/* 82161810h case    0:*/		regs.R3 = regs.R31;
		/* 82161810h case    0:*/		return 0x82161814;
		  /* 82161814h */ case    1:  		/* bl -1564 */
		/* 82161814h case    1:*/		regs.LR = 0x82161818; return 0x821611F8;
		/* 82161814h case    1:*/		return 0x82161818;
		  /* 82161818h */ case    2:  		/* or R11, R3, R6 */
		/* 82161818h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R3,regs.R6);
		/* 82161818h case    2:*/		return 0x8216181C;
		  /* 8216181Ch */ case    3:  		/* stwu R11, <#[R7 + 4]> */
		/* 8216181Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8216181Ch case    3:*/		return 0x82161820;
	}
	return 0x82161820;
} // Block from 82161810h-82161820h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82161820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161820);
		  /* 82161820h */ case    0:  		/* lwz R10, <#[R1 + 80]> */
		/* 82161820h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82161820h case    0:*/		return 0x82161824;
		  /* 82161824h */ case    1:  		/* addi R7, R7, 4 */
		/* 82161824h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82161824h case    1:*/		return 0x82161828;
	}
	return 0x82161828;
} // Block from 82161820h-82161828h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161828h
// Function '?r400VSConvertDst@XGRAPHICS@@YAPAKPAKKK0PAU_R400VSFUNC@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161828);
		  /* 82161828h */ case    0:  		/* cmplw CR6, R30, R5 */
		/* 82161828h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R5);
		/* 82161828h case    0:*/		return 0x8216182C;
		  /* 8216182Ch */ case    1:  		/* addi R6, R10, 2 */
		/* 8216182Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x2);
		/* 8216182Ch case    1:*/		return 0x82161830;
		  /* 82161830h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 82161830h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82161848;  }
		/* 82161830h case    2:*/		return 0x82161834;
		  /* 82161834h */ case    3:  		/* lis R10, 4 */
		/* 82161834h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x4);
		/* 82161834h case    3:*/		return 0x82161838;
		  /* 82161838h */ case    4:  		/* addi R11, R6, 1 */
		/* 82161838h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x1);
		/* 82161838h case    4:*/		return 0x8216183C;
		  /* 8216183Ch */ case    5:  		/* ori R10, R10, 33 */
		/* 8216183Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x21);
		/* 8216183Ch case    5:*/		return 0x82161840;
		  /* 82161840h */ case    6:  		/* stw R10, <#[R7]> */
		/* 82161840h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82161840h case    6:*/		return 0x82161844;
		  /* 82161844h */ case    7:  		/* b 32 */
		/* 82161844h case    7:*/		return 0x82161864;
		/* 82161844h case    7:*/		return 0x82161848;
	}
	return 0x82161848;
} // Block from 82161828h-82161848h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82161848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161848);
		  /* 82161848h */ case    0:  		/* lis R11, 68 */
		/* 82161848h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x44);
		/* 82161848h case    0:*/		return 0x8216184C;
		  /* 8216184Ch */ case    1:  		/* mr R3, R30 */
		/* 8216184Ch case    1:*/		regs.R3 = regs.R30;
		/* 8216184Ch case    1:*/		return 0x82161850;
		  /* 82161850h */ case    2:  		/* ori R11, R11, 33 */
		/* 82161850h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x21);
		/* 82161850h case    2:*/		return 0x82161854;
		  /* 82161854h */ case    3:  		/* stw R11, <#[R7]> */
		/* 82161854h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82161854h case    3:*/		return 0x82161858;
		  /* 82161858h */ case    4:  		/* bl -1632 */
		/* 82161858h case    4:*/		regs.LR = 0x8216185C; return 0x821611F8;
		/* 82161858h case    4:*/		return 0x8216185C;
		  /* 8216185Ch */ case    5:  		/* stwu R3, <#[R7 + 4]> */
		/* 8216185Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8216185Ch case    5:*/		return 0x82161860;
		  /* 82161860h */ case    6:  		/* addi R11, R6, 2 */
		/* 82161860h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x2);
		/* 82161860h case    6:*/		return 0x82161864;
	}
	return 0x82161864;
} // Block from 82161848h-82161864h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82161864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161864);
		  /* 82161864h */ case    0:  		/* lwz R10, <#[R29]> */
		/* 82161864h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82161864h case    0:*/		return 0x82161868;
		  /* 82161868h */ case    1:  		/* addi R3, R7, 4 */
		/* 82161868h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R7,0x4);
		/* 82161868h case    1:*/		return 0x8216186C;
		  /* 8216186Ch */ case    2:  		/* add R11, R10, R11 */
		/* 8216186Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216186Ch case    2:*/		return 0x82161870;
		  /* 82161870h */ case    3:  		/* stw R11, <#[R29]> */
		/* 82161870h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161870h case    3:*/		return 0x82161874;
		  /* 82161874h */ case    4:  		/* addi R1, R1, 128 */
		/* 82161874h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82161874h case    4:*/		return 0x82161878;
		  /* 82161878h */ case    5:  		/* b -853452 */
		/* 82161878h case    5:*/		return 0x820912AC;
		/* 82161878h case    5:*/		return 0x8216187C;
		  /* 8216187Ch */ case    6:  		/* nop */
		/* 8216187Ch case    6:*/		cpu::op::nop();
		/* 8216187Ch case    6:*/		return 0x82161880;
	}
	return 0x82161880;
} // Block from 82161864h-82161880h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82161880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161880);
		  /* 82161880h */ case    0:  		/* mfspr R12, LR */
		/* 82161880h case    0:*/		regs.R12 = regs.LR;
		/* 82161880h case    0:*/		return 0x82161884;
		  /* 82161884h */ case    1:  		/* bl -853576 */
		/* 82161884h case    1:*/		regs.LR = 0x82161888; return 0x8209123C;
		/* 82161884h case    1:*/		return 0x82161888;
		  /* 82161888h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 82161888h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82161888h case    2:*/		return 0x8216188C;
		  /* 8216188Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8216188Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8216188Ch case    3:*/		return 0x82161890;
		  /* 82161890h */ case    4:  		/* mr R28, R3 */
		/* 82161890h case    4:*/		regs.R28 = regs.R3;
		/* 82161890h case    4:*/		return 0x82161894;
		  /* 82161894h */ case    5:  		/* lwz R26, <#[R3 + 16]> */
		/* 82161894h case    5:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000010) );
		/* 82161894h case    5:*/		return 0x82161898;
		  /* 82161898h */ case    6:  		/* mr R27, R4 */
		/* 82161898h case    6:*/		regs.R27 = regs.R4;
		/* 82161898h case    6:*/		return 0x8216189C;
		  /* 8216189Ch */ case    7:  		/* mr R31, R5 */
		/* 8216189Ch case    7:*/		regs.R31 = regs.R5;
		/* 8216189Ch case    7:*/		return 0x821618A0;
		  /* 821618A0h */ case    8:  		/* mr R29, R6 */
		/* 821618A0h case    8:*/		regs.R29 = regs.R6;
		/* 821618A0h case    8:*/		return 0x821618A4;
		  /* 821618A4h */ case    9:  		/* mr R21, R7 */
		/* 821618A4h case    9:*/		regs.R21 = regs.R7;
		/* 821618A4h case    9:*/		return 0x821618A8;
		  /* 821618A8h */ case   10:  		/* mr R22, R8 */
		/* 821618A8h case   10:*/		regs.R22 = regs.R8;
		/* 821618A8h case   10:*/		return 0x821618AC;
		  /* 821618ACh */ case   11:  		/* mr R24, R9 */
		/* 821618ACh case   11:*/		regs.R24 = regs.R9;
		/* 821618ACh case   11:*/		return 0x821618B0;
		  /* 821618B0h */ case   12:  		/* mr R23, R10 */
		/* 821618B0h case   12:*/		regs.R23 = regs.R10;
		/* 821618B0h case   12:*/		return 0x821618B4;
		  /* 821618B4h */ case   13:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 821618B4h case   13:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 821618B4h case   13:*/		return 0x821618B8;
		  /* 821618B8h */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 821618B8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821618C0;  }
		/* 821618B8h case   14:*/		return 0x821618BC;
		  /* 821618BCh */ case   15:  		/* bl 1071524 */
		/* 821618BCh case   15:*/		regs.LR = 0x821618C0; return 0x82267260;
		/* 821618BCh case   15:*/		return 0x821618C0;
	}
	return 0x821618C0;
} // Block from 82161880h-821618C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821618C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821618C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821618C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821618C0);
		  /* 821618C0h */ case    0:  		/* lwz R11, <#[R28 + 1580]> */
		/* 821618C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000062C) );
		/* 821618C0h case    0:*/		return 0x821618C4;
		  /* 821618C4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821618C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821618C4h case    1:*/		return 0x821618C8;
		  /* 821618C8h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 821618C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821618D0;  }
		/* 821618C8h case    2:*/		return 0x821618CC;
		  /* 821618CCh */ case    3:  		/* bl 1071508 */
		/* 821618CCh case    3:*/		regs.LR = 0x821618D0; return 0x82267260;
		/* 821618CCh case    3:*/		return 0x821618D0;
	}
	return 0x821618D0;
} // Block from 821618C0h-821618D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821618D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821618D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821618D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821618D0);
		  /* 821618D0h */ case    0:  		/* rlwinm R10, R27, 0, 16, 31 */
		/* 821618D0h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R27);
		/* 821618D0h case    0:*/		return 0x821618D4;
		  /* 821618D4h */ case    1:  		/* lwz R30, <#[R28 + 1580]> */
		/* 821618D4h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x0000062C) );
		/* 821618D4h case    1:*/		return 0x821618D8;
		  /* 821618D8h */ case    2:  		/* li R25, 0 */
		/* 821618D8h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821618D8h case    2:*/		return 0x821618DC;
		  /* 821618DCh */ case    3:  		/* cmplwi CR6, R10, 96 */
		/* 821618DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 821618DCh case    3:*/		return 0x821618E0;
		  /* 821618E0h */ case    4:  		/* mr R11, R25 */
		/* 821618E0h case    4:*/		regs.R11 = regs.R25;
		/* 821618E0h case    4:*/		return 0x821618E4;
		  /* 821618E4h */ case    5:  		/* bc 12, CR6_GT, 2296 */
		/* 821618E4h case    5:*/		if ( regs.CR[6].gt ) { return 0x821621DC;  }
		/* 821618E4h case    5:*/		return 0x821618E8;
		  /* 821618E8h */ case    6:  		/* bc 12, CR6_EQ, 2164 */
		/* 821618E8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216215C;  }
		/* 821618E8h case    6:*/		return 0x821618EC;
		  /* 821618ECh */ case    7:  		/* addi R10, R10, -25 */
		/* 821618ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFE7);
		/* 821618ECh case    7:*/		return 0x821618F0;
		  /* 821618F0h */ case    8:  		/* cmplwi CR6, R10, 20 */
		/* 821618F0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000014);
		/* 821618F0h case    8:*/		return 0x821618F4;
		  /* 821618F4h */ case    9:  		/* bc 12, CR6_GT, 2280 */
		/* 821618F4h case    9:*/		if ( regs.CR[6].gt ) { return 0x821621DC;  }
		/* 821618F4h case    9:*/		return 0x821618F8;
		  /* 821618F8h */ case   10:  		/* lis R12, -32252 */
		/* 821618F8h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 821618F8h case   10:*/		return 0x821618FC;
		  /* 821618FCh */ case   11:  		/* rlwinm R0, R10, 1, 0, 30 */
		/* 821618FCh case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R10);
		/* 821618FCh case   11:*/		return 0x82161900;
		  /* 82161900h */ case   12:  		/* addi R12, R12, -18016 */
		/* 82161900h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFB9A0);
		/* 82161900h case   12:*/		return 0x82161904;
		  /* 82161904h */ case   13:  		/* lhzx R0, <#[R12 + R0]> */
		/* 82161904h case   13:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 82161904h case   13:*/		return 0x82161908;
		  /* 82161908h */ case   14:  		/* lis R12, -32234 */
		/* 82161908h case   14:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8216);
		/* 82161908h case   14:*/		return 0x8216190C;
		  /* 8216190Ch */ case   15:  		/* addi R12, R12, 6432 */
		/* 8216190Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x1920);
		/* 8216190Ch case   15:*/		return 0x82161910;
		  /* 82161910h */ case   16:  		/* ori R0, R0, 0 */
		/* 82161910h case   16:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82161910h case   16:*/		return 0x82161914;
		  /* 82161914h */ case   17:  		/* add R12, R12, R0 */
		/* 82161914h case   17:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82161914h case   17:*/		return 0x82161918;
		  /* 82161918h */ case   18:  		/* mtspr CTR, R12 */
		/* 82161918h case   18:*/		regs.CTR = regs.R12;
		/* 82161918h case   18:*/		return 0x8216191C;
		  /* 8216191Ch */ case   19:  		/* bcctr 20, CR0_LT */
		/* 8216191Ch case   19:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8216191Ch case   19:*/		return 0x82161920;
		  /* 82161920h */ case   20:  		/* lwz R11, <#[R29]> */
		/* 82161920h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161920h case   20:*/		return 0x82161924;
		  /* 82161924h */ case   21:  		/* li R27, 2 */
		/* 82161924h case   21:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82161924h case   21:*/		return 0x82161928;
		  /* 82161928h */ case   22:  		/* mr R10, R11 */
		/* 82161928h case   22:*/		regs.R10 = regs.R11;
		/* 82161928h case   22:*/		return 0x8216192C;
		  /* 8216192Ch */ case   23:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 8216192Ch case   23:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 8216192Ch case   23:*/		return 0x82161930;
		  /* 82161930h */ case   24:  		/* rlwinm R10, R10, 24, 27, 31 */
		/* 82161930h case   24:*/		cpu::op::rlwinm<0,24,27,31>(regs,&regs.R10,regs.R10);
		/* 82161930h case   24:*/		return 0x82161934;
		  /* 82161934h */ case   25:  		/* cmplwi CR6, R10, 19 */
		/* 82161934h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000013);
		/* 82161934h case   25:*/		return 0x82161938;
		  /* 82161938h */ case   26:  		/* bc 4, CR6_EQ, 172 */
		/* 82161938h case   26:*/		if ( !regs.CR[6].eq ) { return 0x821619E4;  }
		/* 82161938h case   26:*/		return 0x8216193C;
		  /* 8216193Ch */ case   27:  		/* rlwinm R11, R11, 0, 4, 7 */
		/* 8216193Ch case   27:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R11);
		/* 8216193Ch case   27:*/		return 0x82161940;
		  /* 82161940h */ case   28:  		/* lis R10, 3328 */
		/* 82161940h case   28:*/		cpu::op::lis<0>(regs,&regs.R10,0xD00);
		/* 82161940h case   28:*/		return 0x82161944;
		  /* 82161944h */ case   29:  		/* addi R3, R31, 4 */
		/* 82161944h case   29:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161944h case   29:*/		return 0x82161948;
		  /* 82161948h */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 82161948h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161948h case   30:*/		return 0x8216194C;
		  /* 8216194Ch */ case   31:  		/* bc 4, CR6_EQ, 16 */
		/* 8216194Ch case   31:*/		if ( !regs.CR[6].eq ) { return 0x8216195C;  }
		/* 8216194Ch case   31:*/		return 0x82161950;
		  /* 82161950h */ case   32:  		/* lis R11, 1 */
		/* 82161950h case   32:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82161950h case   32:*/		return 0x82161954;
		  /* 82161954h */ case   33:  		/* ori R11, R11, 52 */
		/* 82161954h case   33:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82161954h case   33:*/		return 0x82161958;
		  /* 82161958h */ case   34:  		/* b 8 */
		/* 82161958h case   34:*/		return 0x82161960;
		/* 82161958h case   34:*/		return 0x8216195C;
	}
	return 0x8216195C;
} // Block from 821618D0h-8216195Ch (35 instructions)

//////////////////////////////////////////////////////
// Block at 8216195Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216195C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216195C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216195C);
		  /* 8216195Ch */ case    0:  		/* li R11, 52 */
		/* 8216195Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x34);
		/* 8216195Ch case    0:*/		return 0x82161960;
	}
	return 0x82161960;
} // Block from 8216195Ch-82161960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161960);
		  /* 82161960h */ case    0:  		/* stw R11, <#[R31]> */
		/* 82161960h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161960h case    0:*/		return 0x82161964;
		  /* 82161964h */ case    1:  		/* addi R8, R1, 96 */
		/* 82161964h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82161964h case    1:*/		return 0x82161968;
		  /* 82161968h */ case    2:  		/* lwz R4, <#[R29]> */
		/* 82161968h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000000) );
		/* 82161968h case    2:*/		return 0x8216196C;
		  /* 8216196Ch */ case    3:  		/* li R11, 1 */
		/* 8216196Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216196Ch case    3:*/		return 0x82161970;
		  /* 82161970h */ case    4:  		/* stw R8, <#[R1 + 84]> */
		/* 82161970h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82161970h case    4:*/		return 0x82161974;
		  /* 82161974h */ case    5:  		/* mr R10, R26 */
		/* 82161974h case    5:*/		regs.R10 = regs.R26;
		/* 82161974h case    5:*/		return 0x82161978;
		  /* 82161978h */ case    6:  		/* li R9, 0 */
		/* 82161978h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161978h case    6:*/		return 0x8216197C;
		  /* 8216197Ch */ case    7:  		/* stw R11, <#[R1 + 96]> */
		/* 8216197Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8216197Ch case    7:*/		return 0x82161980;
		  /* 82161980h */ case    8:  		/* li R8, 52 */
		/* 82161980h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x34);
		/* 82161980h case    8:*/		return 0x82161984;
		  /* 82161984h */ case    9:  		/* li R7, 0 */
		/* 82161984h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161984h case    9:*/		return 0x82161988;
		  /* 82161988h */ case   10:  		/* li R6, 0 */
		/* 82161988h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161988h case   10:*/		return 0x8216198C;
		  /* 8216198Ch */ case   11:  		/* li R5, 0 */
		/* 8216198Ch case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216198Ch case   11:*/		return 0x82161990;
		  /* 82161990h */ case   12:  		/* bl -1544 */
		/* 82161990h case   12:*/		regs.LR = 0x82161994; return 0x82161388;
		/* 82161990h case   12:*/		return 0x82161994;
		  /* 82161994h */ case   13:  		/* lis R11, 68 */
		/* 82161994h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0x44);
		/* 82161994h case   13:*/		return 0x82161998;
		  /* 82161998h */ case   14:  		/* lwz R10, <#[R1 + 96]> */
		/* 82161998h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82161998h case   14:*/		return 0x8216199C;
		  /* 8216199Ch */ case   15:  		/* li R9, 17476 */
		/* 8216199Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x4444);
		/* 8216199Ch case   15:*/		return 0x821619A0;
		  /* 821619A0h */ case   16:  		/* ori R8, R11, 32 */
		/* 821619A0h case   16:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0x20);
		/* 821619A0h case   16:*/		return 0x821619A4;
		  /* 821619A4h */ case   17:  		/* stw R8, <#[R3]> */
		/* 821619A4h case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 821619A4h case   17:*/		return 0x821619A8;
		  /* 821619A8h */ case   18:  		/* stwu R9, <#[R3 + 4]> */
		/* 821619A8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 821619A8h case   18:*/		return 0x821619AC;
		  /* 821619ACh */ case   19:  		/* addi R11, R10, 2 */
		/* 821619ACh case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x2);
		/* 821619ACh case   19:*/		return 0x821619B0;
		  /* 821619B0h */ case   20:  		/* lwz R10, <#[R30]> */
		/* 821619B0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821619B0h case   20:*/		return 0x821619B4;
		  /* 821619B4h */ case   21:  		/* addi R10, R10, 1 */
		/* 821619B4h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821619B4h case   21:*/		return 0x821619B8;
		  /* 821619B8h */ case   22:  		/* rlwinm R9, R10, 3, 0, 28 */
		/* 821619B8h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R10);
		/* 821619B8h case   22:*/		return 0x821619BC;
		  /* 821619BCh */ case   23:  		/* stw R10, <#[R30]> */
		/* 821619BCh case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821619BCh case   23:*/		return 0x821619C0;
		  /* 821619C0h */ case   24:  		/* addi R31, R3, 4 */
		/* 821619C0h case   24:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 821619C0h case   24:*/		return 0x821619C4;
		  /* 821619C4h */ case   25:  		/* add R10, R9, R30 */
		/* 821619C4h case   25:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R30);
		/* 821619C4h case   25:*/		return 0x821619C8;
		  /* 821619C8h */ case   26:  		/* stw R25, <#[R10 + 4]> */
		/* 821619C8h case   26:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R10 + 0x00000004) );
		/* 821619C8h case   26:*/		return 0x821619CC;
		  /* 821619CCh */ case   27:  		/* lwz R9, <#[R29]> */
		/* 821619CCh case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 821619CCh case   27:*/		return 0x821619D0;
		  /* 821619D0h */ case   28:  		/* lwz R10, <#[R30]> */
		/* 821619D0h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821619D0h case   28:*/		return 0x821619D4;
		  /* 821619D4h */ case   29:  		/* addi R10, R10, 1 */
		/* 821619D4h case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821619D4h case   29:*/		return 0x821619D8;
		  /* 821619D8h */ case   30:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 821619D8h case   30:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 821619D8h case   30:*/		return 0x821619DC;
		  /* 821619DCh */ case   31:  		/* stwx R9, <#[R10 + R30]> */
		/* 821619DCh case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 821619DCh case   31:*/		return 0x821619E0;
		  /* 821619E0h */ case   32:  		/* b 328 */
		/* 821619E0h case   32:*/		return 0x82161B28;
		/* 821619E0h case   32:*/		return 0x821619E4;
	}
	return 0x821619E4;
} // Block from 82161960h-821619E4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821619E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821619E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821619E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821619E4);
		  /* 821619E4h */ case    0:  		/* cmplwi CR6, R10, 14 */
		/* 821619E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000E);
		/* 821619E4h case    0:*/		return 0x821619E8;
		  /* 821619E8h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 821619E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821619F0;  }
		/* 821619E8h case    1:*/		return 0x821619EC;
		  /* 821619ECh */ case    2:  		/* bl 1071220 */
		/* 821619ECh case    2:*/		regs.LR = 0x821619F0; return 0x82267260;
		/* 821619ECh case    2:*/		return 0x821619F0;
	}
	return 0x821619F0;
} // Block from 821619E4h-821619F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821619F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821619F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821619F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821619F0);
		  /* 821619F0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821619F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821619F0h case    0:*/		return 0x821619F4;
		  /* 821619F4h */ case    1:  		/* lis R10, 228 */
		/* 821619F4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xE4);
		/* 821619F4h case    1:*/		return 0x821619F8;
		  /* 821619F8h */ case    2:  		/* rlwinm R11, R11, 0, 8, 15 */
		/* 821619F8h case    2:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R11,regs.R11);
		/* 821619F8h case    2:*/		return 0x821619FC;
		  /* 821619FCh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 821619FCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821619FCh case    3:*/		return 0x82161A00;
		  /* 82161A00h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 82161A00h case    4:*/		if ( regs.CR[6].eq ) { return 0x82161A08;  }
		/* 82161A00h case    4:*/		return 0x82161A04;
		  /* 82161A04h */ case    5:  		/* bl 1071196 */
		/* 82161A04h case    5:*/		regs.LR = 0x82161A08; return 0x82267260;
		/* 82161A04h case    5:*/		return 0x82161A08;
	}
	return 0x82161A08;
} // Block from 821619F0h-82161A08h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82161A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161A08);
		  /* 82161A08h */ case    0:  		/* li R11, 53 */
		/* 82161A08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x35);
		/* 82161A08h case    0:*/		return 0x82161A0C;
		  /* 82161A0Ch */ case    1:  		/* addi R7, R1, 96 */
		/* 82161A0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82161A0Ch case    1:*/		return 0x82161A10;
		  /* 82161A10h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82161A10h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161A10h case    2:*/		return 0x82161A14;
		  /* 82161A14h */ case    3:  		/* li R11, 1 */
		/* 82161A14h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82161A14h case    3:*/		return 0x82161A18;
		  /* 82161A18h */ case    4:  		/* lwz R4, <#[R29]> */
		/* 82161A18h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000000) );
		/* 82161A18h case    4:*/		return 0x82161A1C;
		  /* 82161A1Ch */ case    5:  		/* mr R10, R26 */
		/* 82161A1Ch case    5:*/		regs.R10 = regs.R26;
		/* 82161A1Ch case    5:*/		return 0x82161A20;
		  /* 82161A20h */ case    6:  		/* stw R7, <#[R1 + 84]> */
		/* 82161A20h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 82161A20h case    6:*/		return 0x82161A24;
		  /* 82161A24h */ case    7:  		/* li R9, 0 */
		/* 82161A24h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161A24h case    7:*/		return 0x82161A28;
		  /* 82161A28h */ case    8:  		/* li R8, 53 */
		/* 82161A28h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x35);
		/* 82161A28h case    8:*/		return 0x82161A2C;
		  /* 82161A2Ch */ case    9:  		/* stw R11, <#[R1 + 96]> */
		/* 82161A2Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82161A2Ch case    9:*/		return 0x82161A30;
		  /* 82161A30h */ case   10:  		/* li R7, 0 */
		/* 82161A30h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161A30h case   10:*/		return 0x82161A34;
		  /* 82161A34h */ case   11:  		/* li R6, 0 */
		/* 82161A34h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161A34h case   11:*/		return 0x82161A38;
		  /* 82161A38h */ case   12:  		/* li R5, 0 */
		/* 82161A38h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82161A38h case   12:*/		return 0x82161A3C;
		  /* 82161A3Ch */ case   13:  		/* addi R3, R31, 4 */
		/* 82161A3Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161A3Ch case   13:*/		return 0x82161A40;
		  /* 82161A40h */ case   14:  		/* bl -1720 */
		/* 82161A40h case   14:*/		regs.LR = 0x82161A44; return 0x82161388;
		/* 82161A40h case   14:*/		return 0x82161A44;
		  /* 82161A44h */ case   15:  		/* lwz R11, <#[R30]> */
		/* 82161A44h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82161A44h case   15:*/		return 0x82161A48;
		  /* 82161A48h */ case   16:  		/* lis R9, 3328 */
		/* 82161A48h case   16:*/		cpu::op::lis<0>(regs,&regs.R9,0xD00);
		/* 82161A48h case   16:*/		return 0x82161A4C;
		  /* 82161A4Ch */ case   17:  		/* addi R11, R11, 1 */
		/* 82161A4Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82161A4Ch case   17:*/		return 0x82161A50;
		  /* 82161A50h */ case   18:  		/* mr R31, R3 */
		/* 82161A50h case   18:*/		regs.R31 = regs.R3;
		/* 82161A50h case   18:*/		return 0x82161A54;
		  /* 82161A54h */ case   19:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 82161A54h case   19:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 82161A54h case   19:*/		return 0x82161A58;
		  /* 82161A58h */ case   20:  		/* stw R11, <#[R30]> */
		/* 82161A58h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82161A58h case   20:*/		return 0x82161A5C;
		  /* 82161A5Ch */ case   21:  		/* add R11, R10, R30 */
		/* 82161A5Ch case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R30);
		/* 82161A5Ch case   21:*/		return 0x82161A60;
		  /* 82161A60h */ case   22:  		/* stw R25, <#[R11 + 4]> */
		/* 82161A60h case   22:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000004) );
		/* 82161A60h case   22:*/		return 0x82161A64;
		  /* 82161A64h */ case   23:  		/* lwz R10, <#[R29]> */
		/* 82161A64h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82161A64h case   23:*/		return 0x82161A68;
		  /* 82161A68h */ case   24:  		/* lwz R11, <#[R30]> */
		/* 82161A68h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82161A68h case   24:*/		return 0x82161A6C;
		  /* 82161A6Ch */ case   25:  		/* addi R11, R11, 1 */
		/* 82161A6Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82161A6Ch case   25:*/		return 0x82161A70;
		  /* 82161A70h */ case   26:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82161A70h case   26:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82161A70h case   26:*/		return 0x82161A74;
		  /* 82161A74h */ case   27:  		/* stwx R10, <#[R11 + R30]> */
		/* 82161A74h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82161A74h case   27:*/		return 0x82161A78;
		  /* 82161A78h */ case   28:  		/* lwz R11, <#[R29]> */
		/* 82161A78h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161A78h case   28:*/		return 0x82161A7C;
		  /* 82161A7Ch */ case   29:  		/* rlwinm R11, R11, 0, 4, 7 */
		/* 82161A7Ch case   29:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R11);
		/* 82161A7Ch case   29:*/		return 0x82161A80;
		  /* 82161A80h */ case   30:  		/* cmplw CR6, R11, R9 */
		/* 82161A80h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82161A80h case   30:*/		return 0x82161A84;
		  /* 82161A84h */ case   31:  		/* bc 4, CR6_EQ, 160 */
		/* 82161A84h case   31:*/		if ( !regs.CR[6].eq ) { return 0x82161B24;  }
		/* 82161A84h case   31:*/		return 0x82161A88;
		  /* 82161A88h */ case   32:  		/* lwz R11, <#[R30]> */
		/* 82161A88h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82161A88h case   32:*/		return 0x82161A8C;
		  /* 82161A8Ch */ case   33:  		/* li R9, 1 */
		/* 82161A8Ch case   33:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82161A8Ch case   33:*/		return 0x82161A90;
		  /* 82161A90h */ case   34:  		/* lwz R7, <#[R1 + 96]> */
		/* 82161A90h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 82161A90h case   34:*/		return 0x82161A94;
		  /* 82161A94h */ case   35:  		/* li R8, 39 */
		/* 82161A94h case   35:*/		cpu::op::li<0>(regs,&regs.R8,0x27);
		/* 82161A94h case   35:*/		return 0x82161A98;
		  /* 82161A98h */ case   36:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 82161A98h case   36:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 82161A98h case   36:*/		return 0x82161A9C;
		  /* 82161A9Ch */ case   37:  		/* addi R11, R7, 1 */
		/* 82161A9Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0x1);
		/* 82161A9Ch case   37:*/		return 0x82161AA0;
		  /* 82161AA0h */ case   38:  		/* add R10, R10, R30 */
		/* 82161AA0h case   38:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82161AA0h case   38:*/		return 0x82161AA4;
		  /* 82161AA4h */ case   39:  		/* stw R9, <#[R10 + 4]> */
		/* 82161AA4h case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82161AA4h case   39:*/		return 0x82161AA8;
		  /* 82161AA8h */ case   40:  		/* stw R8, <#[R3]> */
		/* 82161AA8h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 82161AA8h case   40:*/		return 0x82161AAC;
		  /* 82161AACh */ case   41:  		/* addi R31, R31, 4 */
		/* 82161AACh case   41:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82161AACh case   41:*/		return 0x82161AB0;
		  /* 82161AB0h */ case   42:  		/* b 120 */
		/* 82161AB0h case   42:*/		return 0x82161B28;
		/* 82161AB0h case   42:*/		return 0x82161AB4;
		  /* 82161AB4h */ case   43:  		/* lwz R11, <#[R30]> */
		/* 82161AB4h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82161AB4h case   43:*/		return 0x82161AB8;
		  /* 82161AB8h */ case   44:  		/* li R27, 1 */
		/* 82161AB8h case   44:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82161AB8h case   44:*/		return 0x82161ABC;
		  /* 82161ABCh */ case   45:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82161ABCh case   45:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82161ABCh case   45:*/		return 0x82161AC0;
		  /* 82161AC0h */ case   46:  		/* add R11, R11, R30 */
		/* 82161AC0h case   46:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82161AC0h case   46:*/		return 0x82161AC4;
		  /* 82161AC4h */ case   47:  		/* lwz R11, <#[R11 + 4]> */
		/* 82161AC4h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82161AC4h case   47:*/		return 0x82161AC8;
		  /* 82161AC8h */ case   48:  		/* cmpwi CR6, R11, 0 */
		/* 82161AC8h case   48:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82161AC8h case   48:*/		return 0x82161ACC;
		  /* 82161ACCh */ case   49:  		/* bc 12, CR6_EQ, 124 */
		/* 82161ACCh case   49:*/		if ( regs.CR[6].eq ) { return 0x82161B48;  }
		/* 82161ACCh case   49:*/		return 0x82161AD0;
		  /* 82161AD0h */ case   50:  		/* li R11, 41 */
		/* 82161AD0h case   50:*/		cpu::op::li<0>(regs,&regs.R11,0x29);
		/* 82161AD0h case   50:*/		return 0x82161AD4;
		  /* 82161AD4h */ case   51:  		/* li R10, 53 */
		/* 82161AD4h case   51:*/		cpu::op::li<0>(regs,&regs.R10,0x35);
		/* 82161AD4h case   51:*/		return 0x82161AD8;
		  /* 82161AD8h */ case   52:  		/* stw R11, <#[R31]> */
		/* 82161AD8h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161AD8h case   52:*/		return 0x82161ADC;
		  /* 82161ADCh */ case   53:  		/* li R9, 2 */
		/* 82161ADCh case   53:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82161ADCh case   53:*/		return 0x82161AE0;
		  /* 82161AE0h */ case   54:  		/* stwu R10, <#[R31 + 4]> */
		/* 82161AE0h case   54:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161AE0h case   54:*/		return 0x82161AE4;
		  /* 82161AE4h */ case   55:  		/* addi R8, R1, 96 */
		/* 82161AE4h case   55:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82161AE4h case   55:*/		return 0x82161AE8;
		  /* 82161AE8h */ case   56:  		/* stw R9, <#[R1 + 96]> */
		/* 82161AE8h case   56:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82161AE8h case   56:*/		return 0x82161AEC;
		  /* 82161AECh */ case   57:  		/* mr R10, R26 */
		/* 82161AECh case   57:*/		regs.R10 = regs.R26;
		/* 82161AECh case   57:*/		return 0x82161AF0;
		  /* 82161AF0h */ case   58:  		/* stw R8, <#[R1 + 84]> */
		/* 82161AF0h case   58:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82161AF0h case   58:*/		return 0x82161AF4;
		  /* 82161AF4h */ case   59:  		/* li R9, 0 */
		/* 82161AF4h case   59:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161AF4h case   59:*/		return 0x82161AF8;
		  /* 82161AF8h */ case   60:  		/* li R8, 53 */
		/* 82161AF8h case   60:*/		cpu::op::li<0>(regs,&regs.R8,0x35);
		/* 82161AF8h case   60:*/		return 0x82161AFC;
		  /* 82161AFCh */ case   61:  		/* li R7, 0 */
		/* 82161AFCh case   61:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161AFCh case   61:*/		return 0x82161B00;
		  /* 82161B00h */ case   62:  		/* li R6, 0 */
		/* 82161B00h case   62:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161B00h case   62:*/		return 0x82161B04;
		  /* 82161B04h */ case   63:  		/* li R5, 0 */
		/* 82161B04h case   63:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82161B04h case   63:*/		return 0x82161B08;
	}
	return 0x82161B08;
} // Block from 82161A08h-82161B08h (64 instructions)

//////////////////////////////////////////////////////
// Block at 82161B08h
// Function '?r400VSGenDclv@XGRAPHICS@@YAKPAU_ATID3DCTX@@PAU_R400VSFUNC@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161B08);
		  /* 82161B08h */ case    0:  		/* addi R3, R31, 4 */
		/* 82161B08h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161B08h case    0:*/		return 0x82161B0C;
		  /* 82161B0Ch */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82161B0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82161B0Ch case    1:*/		return 0x82161B10;
		  /* 82161B10h */ case    2:  		/* addi R11, R11, 1 */
		/* 82161B10h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82161B10h case    2:*/		return 0x82161B14;
		  /* 82161B14h */ case    3:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82161B14h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82161B14h case    3:*/		return 0x82161B18;
		  /* 82161B18h */ case    4:  		/* lwzx R4, <#[R11 + R30]> */
		/* 82161B18h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82161B18h case    4:*/		return 0x82161B1C;
		  /* 82161B1Ch */ case    5:  		/* bl -1940 */
		/* 82161B1Ch case    5:*/		regs.LR = 0x82161B20; return 0x82161388;
		/* 82161B1Ch case    5:*/		return 0x82161B20;
		  /* 82161B20h */ case    6:  		/* mr R31, R3 */
		/* 82161B20h case    6:*/		regs.R31 = regs.R3;
		/* 82161B20h case    6:*/		return 0x82161B24;
	}
	return 0x82161B24;
} // Block from 82161B08h-82161B24h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82161B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161B24);
		  /* 82161B24h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82161B24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82161B24h case    0:*/		return 0x82161B28;
	}
	return 0x82161B28;
} // Block from 82161B24h-82161B28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161B28);
		  /* 82161B28h */ case    0:  		/* addi R10, R27, -1 */
		/* 82161B28h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFF);
		/* 82161B28h case    0:*/		return 0x82161B2C;
		  /* 82161B2Ch */ case    1:  		/* mr R3, R31 */
		/* 82161B2Ch case    1:*/		regs.R3 = regs.R31;
		/* 82161B2Ch case    1:*/		return 0x82161B30;
		  /* 82161B30h */ case    2:  		/* stw R10, <#[R21]> */
		/* 82161B30h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 82161B30h case    2:*/		return 0x82161B34;
		  /* 82161B34h */ case    3:  		/* lwz R10, <#[R22]> */
		/* 82161B34h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000000) );
		/* 82161B34h case    3:*/		return 0x82161B38;
		  /* 82161B38h */ case    4:  		/* add R11, R10, R11 */
		/* 82161B38h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82161B38h case    4:*/		return 0x82161B3C;
		  /* 82161B3Ch */ case    5:  		/* stw R11, <#[R22]> */
		/* 82161B3Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82161B3Ch case    5:*/		return 0x82161B40;
		  /* 82161B40h */ case    6:  		/* addi R1, R1, 224 */
		/* 82161B40h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82161B40h case    6:*/		return 0x82161B44;
		  /* 82161B44h */ case    7:  		/* b -854200 */
		/* 82161B44h case    7:*/		return 0x8209128C;
		/* 82161B44h case    7:*/		return 0x82161B48;
	}
	return 0x82161B48;
} // Block from 82161B28h-82161B48h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82161B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161B48);
		  /* 82161B48h */ case    0:  		/* li R10, 39 */
		/* 82161B48h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x27);
		/* 82161B48h case    0:*/		return 0x82161B4C;
		  /* 82161B4Ch */ case    1:  		/* li R11, 1 */
		/* 82161B4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82161B4Ch case    1:*/		return 0x82161B50;
		  /* 82161B50h */ case    2:  		/* stw R10, <#[R31]> */
		/* 82161B50h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82161B50h case    2:*/		return 0x82161B54;
		  /* 82161B54h */ case    3:  		/* b -168 */
		/* 82161B54h case    3:*/		return 0x82161AAC;
		/* 82161B54h case    3:*/		return 0x82161B58;
		  /* 82161B58h */ case    4:  		/* li R11, 41 */
		/* 82161B58h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x29);
		/* 82161B58h case    4:*/		return 0x82161B5C;
		  /* 82161B5Ch */ case    5:  		/* li R27, 1 */
		/* 82161B5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82161B5Ch case    5:*/		return 0x82161B60;
		  /* 82161B60h */ case    6:  		/* stw R11, <#[R31]> */
		/* 82161B60h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161B60h case    6:*/		return 0x82161B64;
		  /* 82161B64h */ case    7:  		/* addi R31, R31, 4 */
		/* 82161B64h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82161B64h case    7:*/		return 0x82161B68;
		  /* 82161B68h */ case    8:  		/* lwz R10, <#[R30]> */
		/* 82161B68h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82161B68h case    8:*/		return 0x82161B6C;
		  /* 82161B6Ch */ case    9:  		/* li R11, 1 */
		/* 82161B6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82161B6Ch case    9:*/		return 0x82161B70;
		  /* 82161B70h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82161B70h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82161B70h case   10:*/		return 0x82161B74;
		  /* 82161B74h */ case   11:  		/* bc 12, CR6_EQ, -76 */
		/* 82161B74h case   11:*/		if ( regs.CR[6].eq ) { return 0x82161B28;  }
		/* 82161B74h case   11:*/		return 0x82161B78;
		  /* 82161B78h */ case   12:  		/* addi R10, R10, -1 */
		/* 82161B78h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82161B78h case   12:*/		return 0x82161B7C;
		  /* 82161B7Ch */ case   13:  		/* stw R10, <#[R30]> */
		/* 82161B7Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82161B7Ch case   13:*/		return 0x82161B80;
		  /* 82161B80h */ case   14:  		/* b -88 */
		/* 82161B80h case   14:*/		return 0x82161B28;
		/* 82161B80h case   14:*/		return 0x82161B84;
		  /* 82161B84h */ case   15:  		/* lwz R11, <#[R29]> */
		/* 82161B84h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161B84h case   15:*/		return 0x82161B88;
		  /* 82161B88h */ case   16:  		/* li R27, 3 */
		/* 82161B88h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 82161B88h case   16:*/		return 0x82161B8C;
		  /* 82161B8Ch */ case   17:  		/* mr R10, R11 */
		/* 82161B8Ch case   17:*/		regs.R10 = regs.R11;
		/* 82161B8Ch case   17:*/		return 0x82161B90;
		  /* 82161B90h */ case   18:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161B90h case   18:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161B90h case   18:*/		return 0x82161B94;
		  /* 82161B94h */ case   19:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161B94h case   19:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161B94h case   19:*/		return 0x82161B98;
		  /* 82161B98h */ case   20:  		/* cmplwi CR6, R11, 3840 */
		/* 82161B98h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000F00);
		/* 82161B98h case   20:*/		return 0x82161B9C;
		  /* 82161B9Ch */ case   21:  		/* bc 12, CR6_EQ, 8 */
		/* 82161B9Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82161BA4;  }
		/* 82161B9Ch case   21:*/		return 0x82161BA0;
		  /* 82161BA0h */ case   22:  		/* bl 1070784 */
		/* 82161BA0h case   22:*/		regs.LR = 0x82161BA4; return 0x82267260;
		/* 82161BA0h case   22:*/		return 0x82161BA4;
	}
	return 0x82161BA4;
} // Block from 82161B48h-82161BA4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82161BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161BA4);
		  /* 82161BA4h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 82161BA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161BA4h case    0:*/		return 0x82161BA8;
		  /* 82161BA8h */ case    1:  		/* rlwinm. R11, R11, 0, 21, 31 */
		/* 82161BA8h case    1:*/		cpu::op::rlwinm<1,0,21,31>(regs,&regs.R11,regs.R11);
		/* 82161BA8h case    1:*/		return 0x82161BAC;
		  /* 82161BACh */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82161BACh case    2:*/		if ( regs.CR[0].eq ) { return 0x82161BB4;  }
		/* 82161BACh case    2:*/		return 0x82161BB0;
		  /* 82161BB0h */ case    3:  		/* bl 1070768 */
		/* 82161BB0h case    3:*/		regs.LR = 0x82161BB4; return 0x82267260;
		/* 82161BB0h case    3:*/		return 0x82161BB4;
	}
	return 0x82161BB4;
} // Block from 82161BA4h-82161BB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82161BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161BB4);
		  /* 82161BB4h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82161BB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82161BB4h case    0:*/		return 0x82161BB8;
		  /* 82161BB8h */ case    1:  		/* mr R10, R11 */
		/* 82161BB8h case    1:*/		regs.R10 = regs.R11;
		/* 82161BB8h case    1:*/		return 0x82161BBC;
		  /* 82161BBCh */ case    2:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161BBCh case    2:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161BBCh case    2:*/		return 0x82161BC0;
		  /* 82161BC0h */ case    3:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161BC0h case    3:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161BC0h case    3:*/		return 0x82161BC4;
		  /* 82161BC4h */ case    4:  		/* cmplwi CR6, R11, 1792 */
		/* 82161BC4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000700);
		/* 82161BC4h case    4:*/		return 0x82161BC8;
		  /* 82161BC8h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82161BC8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82161BD0;  }
		/* 82161BC8h case    5:*/		return 0x82161BCC;
		  /* 82161BCCh */ case    6:  		/* bl 1070740 */
		/* 82161BCCh case    6:*/		regs.LR = 0x82161BD0; return 0x82267260;
		/* 82161BCCh case    6:*/		return 0x82161BD0;
	}
	return 0x82161BD0;
} // Block from 82161BB4h-82161BD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82161BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161BD0);
		  /* 82161BD0h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82161BD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82161BD0h case    0:*/		return 0x82161BD4;
		  /* 82161BD4h */ case    1:  		/* rlwinm R11, R11, 0, 21, 31 */
		/* 82161BD4h case    1:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R11);
		/* 82161BD4h case    1:*/		return 0x82161BD8;
		  /* 82161BD8h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 82161BD8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82161BD8h case    2:*/		return 0x82161BDC;
		  /* 82161BDCh */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 82161BDCh case    3:*/		if ( regs.CR[6].lt ) { return 0x82161BE4;  }
		/* 82161BDCh case    3:*/		return 0x82161BE0;
		  /* 82161BE0h */ case    4:  		/* bl 1070720 */
		/* 82161BE0h case    4:*/		regs.LR = 0x82161BE4; return 0x82267260;
		/* 82161BE0h case    4:*/		return 0x82161BE4;
	}
	return 0x82161BE4;
} // Block from 82161BD0h-82161BE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82161BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161BE4);
		  /* 82161BE4h */ case    0:  		/* li R11, 62 */
		/* 82161BE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3E);
		/* 82161BE4h case    0:*/		return 0x82161BE8;
		  /* 82161BE8h */ case    1:  		/* addi R9, R1, 96 */
		/* 82161BE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 82161BE8h case    1:*/		return 0x82161BEC;
		  /* 82161BECh */ case    2:  		/* stw R11, <#[R31]> */
		/* 82161BECh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161BECh case    2:*/		return 0x82161BF0;
		  /* 82161BF0h */ case    3:  		/* li R11, 1 */
		/* 82161BF0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82161BF0h case    3:*/		return 0x82161BF4;
		  /* 82161BF4h */ case    4:  		/* lwz R4, <#[R29 + 4]> */
		/* 82161BF4h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 82161BF4h case    4:*/		return 0x82161BF8;
		  /* 82161BF8h */ case    5:  		/* mr R10, R26 */
		/* 82161BF8h case    5:*/		regs.R10 = regs.R26;
		/* 82161BF8h case    5:*/		return 0x82161BFC;
		  /* 82161BFCh */ case    6:  		/* stw R9, <#[R1 + 84]> */
		/* 82161BFCh case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82161BFCh case    6:*/		return 0x82161C00;
		  /* 82161C00h */ case    7:  		/* li R9, 0 */
		/* 82161C00h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161C00h case    7:*/		return 0x82161C04;
		  /* 82161C04h */ case    8:  		/* stw R11, <#[R1 + 96]> */
		/* 82161C04h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82161C04h case    8:*/		return 0x82161C08;
		  /* 82161C08h */ case    9:  		/* li R8, 62 */
		/* 82161C08h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x3E);
		/* 82161C08h case    9:*/		return 0x82161C0C;
		  /* 82161C0Ch */ case   10:  		/* li R7, 0 */
		/* 82161C0Ch case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161C0Ch case   10:*/		return 0x82161C10;
	}
	return 0x82161C10;
} // Block from 82161BE4h-82161C10h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82161C10h
// Function '?r400VSConvertDxSwizzle2ILSwizzle@XGRAPHICS@@YAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161C10);
		  /* 82161C10h */ case    0:  		/* li R6, 0 */
		/* 82161C10h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161C10h case    0:*/		return 0x82161C14;
		  /* 82161C14h */ case    1:  		/* li R5, 0 */
		/* 82161C14h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82161C14h case    1:*/		return 0x82161C18;
		  /* 82161C18h */ case    2:  		/* addi R3, R31, 4 */
		/* 82161C18h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161C18h case    2:*/		return 0x82161C1C;
		  /* 82161C1Ch */ case    3:  		/* bl -2196 */
		/* 82161C1Ch case    3:*/		regs.LR = 0x82161C20; return 0x82161388;
		/* 82161C1Ch case    3:*/		return 0x82161C20;
		  /* 82161C20h */ case    4:  		/* b -256 */
		/* 82161C20h case    4:*/		return 0x82161B20;
		/* 82161C20h case    4:*/		return 0x82161C24;
		  /* 82161C24h */ case    5:  		/* lwz R11, <#[R29]> */
		/* 82161C24h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161C24h case    5:*/		return 0x82161C28;
		  /* 82161C28h */ case    6:  		/* li R27, 2 */
		/* 82161C28h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82161C28h case    6:*/		return 0x82161C2C;
		  /* 82161C2Ch */ case    7:  		/* mr R10, R11 */
		/* 82161C2Ch case    7:*/		regs.R10 = regs.R11;
		/* 82161C2Ch case    7:*/		return 0x82161C30;
		  /* 82161C30h */ case    8:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161C30h case    8:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161C30h case    8:*/		return 0x82161C34;
		  /* 82161C34h */ case    9:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161C34h case    9:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161C34h case    9:*/		return 0x82161C38;
		  /* 82161C38h */ case   10:  		/* cmplwi CR6, R11, 4608 */
		/* 82161C38h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001200);
		/* 82161C38h case   10:*/		return 0x82161C3C;
		  /* 82161C3Ch */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 82161C3Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82161C44;  }
		/* 82161C3Ch case   11:*/		return 0x82161C40;
		  /* 82161C40h */ case   12:  		/* bl 1070624 */
		/* 82161C40h case   12:*/		regs.LR = 0x82161C44; return 0x82267260;
		/* 82161C40h case   12:*/		return 0x82161C44;
	}
	return 0x82161C44;
} // Block from 82161C10h-82161C44h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82161C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161C44);
		  /* 82161C44h */ case    0:  		/* li R10, 50 */
		/* 82161C44h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x32);
		/* 82161C44h case    0:*/		return 0x82161C48;
		  /* 82161C48h */ case    1:  		/* stw R10, <#[R31]> */
		/* 82161C48h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82161C48h case    1:*/		return 0x82161C4C;
		  /* 82161C4Ch */ case    2:  		/* li R11, 2 */
		/* 82161C4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82161C4Ch case    2:*/		return 0x82161C50;
		  /* 82161C50h */ case    3:  		/* lwz R10, <#[R29]> */
		/* 82161C50h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82161C50h case    3:*/		return 0x82161C54;
		  /* 82161C54h */ case    4:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 82161C54h case    4:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 82161C54h case    4:*/		return 0x82161C58;
		  /* 82161C58h */ case    5:  		/* stwu R10, <#[R31 + 4]> */
		/* 82161C58h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 82161C58h case    5:*/		return 0x82161C5C;
		  /* 82161C5Ch */ case    6:  		/* b -432 */
		/* 82161C5Ch case    6:*/		return 0x82161AAC;
		/* 82161C5Ch case    6:*/		return 0x82161C60;
		  /* 82161C60h */ case    7:  		/* lwz R11, <#[R29]> */
		/* 82161C60h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161C60h case    7:*/		return 0x82161C64;
		  /* 82161C64h */ case    8:  		/* li R27, 2 */
		/* 82161C64h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82161C64h case    8:*/		return 0x82161C68;
		  /* 82161C68h */ case    9:  		/* mr R10, R11 */
		/* 82161C68h case    9:*/		regs.R10 = regs.R11;
		/* 82161C68h case    9:*/		return 0x82161C6C;
		  /* 82161C6Ch */ case   10:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161C6Ch case   10:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161C6Ch case   10:*/		return 0x82161C70;
		  /* 82161C70h */ case   11:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161C70h case   11:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161C70h case   11:*/		return 0x82161C74;
		  /* 82161C74h */ case   12:  		/* cmplwi CR6, R11, 4608 */
		/* 82161C74h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001200);
		/* 82161C74h case   12:*/		return 0x82161C78;
	}
	return 0x82161C78;
} // Block from 82161C44h-82161C78h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82161C78h
// Function '?r400VSConvertDclOutput@XGRAPHICS@@YAPAKPAU_R400VSFUNC@1@KPAK1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161C78);
		  /* 82161C78h */ case    0:  		/* bc 12, CR6_EQ, 8 */
		/* 82161C78h case    0:*/		if ( regs.CR[6].eq ) { return 0x82161C80;  }
		/* 82161C78h case    0:*/		return 0x82161C7C;
		  /* 82161C7Ch */ case    1:  		/* bl 1070564 */
		/* 82161C7Ch case    1:*/		regs.LR = 0x82161C80; return 0x82267260;
		/* 82161C7Ch case    1:*/		return 0x82161C80;
	}
	return 0x82161C80;
} // Block from 82161C78h-82161C80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161C80);
		  /* 82161C80h */ case    0:  		/* li R10, 8 */
		/* 82161C80h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 82161C80h case    0:*/		return 0x82161C84;
		  /* 82161C84h */ case    1:  		/* b -60 */
		/* 82161C84h case    1:*/		return 0x82161C48;
		/* 82161C84h case    1:*/		return 0x82161C88;
		  /* 82161C88h */ case    2:  		/* lwz R11, <#[R28 + 4]> */
		/* 82161C88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82161C88h case    2:*/		return 0x82161C8C;
		  /* 82161C8Ch */ case    3:  		/* li R27, 1 */
		/* 82161C8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82161C8Ch case    3:*/		return 0x82161C90;
		  /* 82161C90h */ case    4:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82161C90h case    4:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82161C90h case    4:*/		return 0x82161C94;
		  /* 82161C94h */ case    5:  		/* bc 4, CR0_EQ, 28 */
		/* 82161C94h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82161CB0;  }
		/* 82161C94h case    5:*/		return 0x82161C98;
		  /* 82161C98h */ case    6:  		/* li R11, 43 */
		/* 82161C98h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x2B);
		/* 82161C98h case    6:*/		return 0x82161C9C;
		  /* 82161C9Ch */ case    7:  		/* stw R11, <#[R31]> */
		/* 82161C9Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161C9Ch case    7:*/		return 0x82161CA0;
		  /* 82161CA0h */ case    8:  		/* lwz R11, <#[R28 + 4]> */
		/* 82161CA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82161CA0h case    8:*/		return 0x82161CA4;
		  /* 82161CA4h */ case    9:  		/* ori R11, R11, 32 */
		/* 82161CA4h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82161CA4h case    9:*/		return 0x82161CA8;
		  /* 82161CA8h */ case   10:  		/* stw R11, <#[R28 + 4]> */
		/* 82161CA8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82161CA8h case   10:*/		return 0x82161CAC;
		  /* 82161CACh */ case   11:  		/* b 12 */
		/* 82161CACh case   11:*/		return 0x82161CB8;
		/* 82161CACh case   11:*/		return 0x82161CB0;
	}
	return 0x82161CB0;
} // Block from 82161C80h-82161CB0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82161CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161CB0);
		  /* 82161CB0h */ case    0:  		/* li R11, 83 */
		/* 82161CB0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x53);
		/* 82161CB0h case    0:*/		return 0x82161CB4;
		  /* 82161CB4h */ case    1:  		/* stw R11, <#[R31]> */
		/* 82161CB4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161CB4h case    1:*/		return 0x82161CB8;
	}
	return 0x82161CB8;
} // Block from 82161CB0h-82161CB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161CB8);
		  /* 82161CB8h */ case    0:  		/* addi R31, R31, 4 */
		/* 82161CB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82161CB8h case    0:*/		return 0x82161CBC;
		  /* 82161CBCh */ case    1:  		/* li R11, 1 */
		/* 82161CBCh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82161CBCh case    1:*/		return 0x82161CC0;
		  /* 82161CC0h */ case    2:  		/* b -408 */
		/* 82161CC0h case    2:*/		return 0x82161B28;
		/* 82161CC0h case    2:*/		return 0x82161CC4;
		  /* 82161CC4h */ case    3:  		/* li R11, 42 */
		/* 82161CC4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x2A);
		/* 82161CC4h case    3:*/		return 0x82161CC8;
		  /* 82161CC8h */ case    4:  		/* li R27, 1 */
		/* 82161CC8h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82161CC8h case    4:*/		return 0x82161CCC;
		  /* 82161CCCh */ case    5:  		/* b -24 */
		/* 82161CCCh case    5:*/		return 0x82161CB4;
		/* 82161CCCh case    5:*/		return 0x82161CD0;
		  /* 82161CD0h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82161CD0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161CD0h case    6:*/		return 0x82161CD4;
		  /* 82161CD4h */ case    7:  		/* li R27, 2 */
		/* 82161CD4h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82161CD4h case    7:*/		return 0x82161CD8;
		  /* 82161CD8h */ case    8:  		/* mr R10, R11 */
		/* 82161CD8h case    8:*/		regs.R10 = regs.R11;
		/* 82161CD8h case    8:*/		return 0x82161CDC;
		  /* 82161CDCh */ case    9:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161CDCh case    9:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161CDCh case    9:*/		return 0x82161CE0;
		  /* 82161CE0h */ case   10:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161CE0h case   10:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161CE0h case   10:*/		return 0x82161CE4;
		  /* 82161CE4h */ case   11:  		/* cmplwi CR6, R11, 1792 */
		/* 82161CE4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000700);
		/* 82161CE4h case   11:*/		return 0x82161CE8;
		  /* 82161CE8h */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 82161CE8h case   12:*/		if ( regs.CR[6].eq ) { return 0x82161CF0;  }
		/* 82161CE8h case   12:*/		return 0x82161CEC;
		  /* 82161CECh */ case   13:  		/* bl 1070452 */
		/* 82161CECh case   13:*/		regs.LR = 0x82161CF0; return 0x82267260;
		/* 82161CECh case   13:*/		return 0x82161CF0;
	}
	return 0x82161CF0;
} // Block from 82161CB8h-82161CF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82161CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161CF0);
		  /* 82161CF0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 82161CF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161CF0h case    0:*/		return 0x82161CF4;
		  /* 82161CF4h */ case    1:  		/* rlwinm R11, R11, 0, 21, 31 */
		/* 82161CF4h case    1:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R11);
		/* 82161CF4h case    1:*/		return 0x82161CF8;
		  /* 82161CF8h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 82161CF8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82161CF8h case    2:*/		return 0x82161CFC;
		  /* 82161CFCh */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 82161CFCh case    3:*/		if ( regs.CR[6].lt ) { return 0x82161D04;  }
		/* 82161CFCh case    3:*/		return 0x82161D00;
		  /* 82161D00h */ case    4:  		/* bl 1070432 */
		/* 82161D00h case    4:*/		regs.LR = 0x82161D04; return 0x82267260;
		/* 82161D00h case    4:*/		return 0x82161D04;
	}
	return 0x82161D04;
} // Block from 82161CF0h-82161D04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82161D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161D04);
		  /* 82161D04h */ case    0:  		/* li R11, 62 */
		/* 82161D04h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3E);
		/* 82161D04h case    0:*/		return 0x82161D08;
		  /* 82161D08h */ case    1:  		/* addi R10, R1, 96 */
		/* 82161D08h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82161D08h case    1:*/		return 0x82161D0C;
		  /* 82161D0Ch */ case    2:  		/* li R9, 1 */
		/* 82161D0Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82161D0Ch case    2:*/		return 0x82161D10;
		  /* 82161D10h */ case    3:  		/* stw R11, <#[R31]> */
		/* 82161D10h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161D10h case    3:*/		return 0x82161D14;
		  /* 82161D14h */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82161D14h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82161D14h case    4:*/		return 0x82161D18;
		  /* 82161D18h */ case    5:  		/* mr R10, R26 */
		/* 82161D18h case    5:*/		regs.R10 = regs.R26;
		/* 82161D18h case    5:*/		return 0x82161D1C;
		  /* 82161D1Ch */ case    6:  		/* stw R9, <#[R1 + 96]> */
		/* 82161D1Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82161D1Ch case    6:*/		return 0x82161D20;
		  /* 82161D20h */ case    7:  		/* li R9, 0 */
		/* 82161D20h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161D20h case    7:*/		return 0x82161D24;
		  /* 82161D24h */ case    8:  		/* li R8, 62 */
		/* 82161D24h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x3E);
		/* 82161D24h case    8:*/		return 0x82161D28;
		  /* 82161D28h */ case    9:  		/* li R7, 0 */
		/* 82161D28h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161D28h case    9:*/		return 0x82161D2C;
		  /* 82161D2Ch */ case   10:  		/* li R6, 0 */
		/* 82161D2Ch case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161D2Ch case   10:*/		return 0x82161D30;
		  /* 82161D30h */ case   11:  		/* li R5, 0 */
		/* 82161D30h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82161D30h case   11:*/		return 0x82161D34;
		  /* 82161D34h */ case   12:  		/* addi R3, R31, 4 */
		/* 82161D34h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161D34h case   12:*/		return 0x82161D38;
		  /* 82161D38h */ case   13:  		/* lwz R4, <#[R29]> */
		/* 82161D38h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000000) );
		/* 82161D38h case   13:*/		return 0x82161D3C;
		  /* 82161D3Ch */ case   14:  		/* bl -2484 */
		/* 82161D3Ch case   14:*/		regs.LR = 0x82161D40; return 0x82161388;
		/* 82161D3Ch case   14:*/		return 0x82161D40;
		  /* 82161D40h */ case   15:  		/* b -544 */
		/* 82161D40h case   15:*/		return 0x82161B20;
		/* 82161D40h case   15:*/		return 0x82161D44;
		  /* 82161D44h */ case   16:  		/* lwz R11, <#[R29 + 4]> */
		/* 82161D44h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82161D44h case   16:*/		return 0x82161D48;
		  /* 82161D48h */ case   17:  		/* li R27, 3 */
		/* 82161D48h case   17:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 82161D48h case   17:*/		return 0x82161D4C;
		  /* 82161D4Ch */ case   18:  		/* mr R10, R11 */
		/* 82161D4Ch case   18:*/		regs.R10 = regs.R11;
		/* 82161D4Ch case   18:*/		return 0x82161D50;
		  /* 82161D50h */ case   19:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161D50h case   19:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161D50h case   19:*/		return 0x82161D54;
		  /* 82161D54h */ case   20:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161D54h case   20:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161D54h case   20:*/		return 0x82161D58;
		  /* 82161D58h */ case   21:  		/* cmplwi CR6, R11, 4864 */
		/* 82161D58h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001300);
		/* 82161D58h case   21:*/		return 0x82161D5C;
		  /* 82161D5Ch */ case   22:  		/* lwz R11, <#[R29]> */
		/* 82161D5Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161D5Ch case   22:*/		return 0x82161D60;
		  /* 82161D60h */ case   23:  		/* mr R10, R11 */
		/* 82161D60h case   23:*/		regs.R10 = regs.R11;
		/* 82161D60h case   23:*/		return 0x82161D64;
		  /* 82161D64h */ case   24:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161D64h case   24:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161D64h case   24:*/		return 0x82161D68;
		  /* 82161D68h */ case   25:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161D68h case   25:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161D68h case   25:*/		return 0x82161D6C;
		  /* 82161D6Ch */ case   26:  		/* bc 4, CR6_EQ, 136 */
		/* 82161D6Ch case   26:*/		if ( !regs.CR[6].eq ) { return 0x82161DF4;  }
		/* 82161D6Ch case   26:*/		return 0x82161D70;
		  /* 82161D70h */ case   27:  		/* cmplwi CR6, R11, 4608 */
		/* 82161D70h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001200);
		/* 82161D70h case   27:*/		return 0x82161D74;
		  /* 82161D74h */ case   28:  		/* bc 12, CR6_EQ, 8 */
		/* 82161D74h case   28:*/		if ( regs.CR[6].eq ) { return 0x82161D7C;  }
		/* 82161D74h case   28:*/		return 0x82161D78;
		  /* 82161D78h */ case   29:  		/* bl 1070312 */
		/* 82161D78h case   29:*/		regs.LR = 0x82161D7C; return 0x82267260;
		/* 82161D78h case   29:*/		return 0x82161D7C;
	}
	return 0x82161D7C;
} // Block from 82161D04h-82161D7Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 82161D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161D7C);
		  /* 82161D7Ch */ case    0:  		/* li R11, 52 */
		/* 82161D7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x34);
		/* 82161D7Ch case    0:*/		return 0x82161D80;
		  /* 82161D80h */ case    1:  		/* addi R10, R1, 96 */
		/* 82161D80h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82161D80h case    1:*/		return 0x82161D84;
		  /* 82161D84h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82161D84h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161D84h case    2:*/		return 0x82161D88;
		  /* 82161D88h */ case    3:  		/* li R9, 1 */
		/* 82161D88h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82161D88h case    3:*/		return 0x82161D8C;
		  /* 82161D8Ch */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82161D8Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82161D8Ch case    4:*/		return 0x82161D90;
		  /* 82161D90h */ case    5:  		/* mr R10, R26 */
		/* 82161D90h case    5:*/		regs.R10 = regs.R26;
		/* 82161D90h case    5:*/		return 0x82161D94;
		  /* 82161D94h */ case    6:  		/* stw R9, <#[R1 + 96]> */
		/* 82161D94h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82161D94h case    6:*/		return 0x82161D98;
		  /* 82161D98h */ case    7:  		/* li R9, 0 */
		/* 82161D98h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161D98h case    7:*/		return 0x82161D9C;
		  /* 82161D9Ch */ case    8:  		/* li R8, 52 */
		/* 82161D9Ch case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x34);
		/* 82161D9Ch case    8:*/		return 0x82161DA0;
	}
	return 0x82161DA0;
} // Block from 82161D7Ch-82161DA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82161DA0h
// Function '?r400VSConvertSrc@XGRAPHICS@@YAPAKPAKKK0KKEK0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161DA0);
		  /* 82161DA0h */ case    0:  		/* li R7, 0 */
		/* 82161DA0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161DA0h case    0:*/		return 0x82161DA4;
		  /* 82161DA4h */ case    1:  		/* li R6, 0 */
		/* 82161DA4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161DA4h case    1:*/		return 0x82161DA8;
		  /* 82161DA8h */ case    2:  		/* li R5, 0 */
		/* 82161DA8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82161DA8h case    2:*/		return 0x82161DAC;
		  /* 82161DACh */ case    3:  		/* addi R3, R31, 4 */
		/* 82161DACh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161DACh case    3:*/		return 0x82161DB0;
		  /* 82161DB0h */ case    4:  		/* lwz R4, <#[R29 + 4]> */
		/* 82161DB0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 82161DB0h case    4:*/		return 0x82161DB4;
		  /* 82161DB4h */ case    5:  		/* bl -2604 */
		/* 82161DB4h case    5:*/		regs.LR = 0x82161DB8; return 0x82161388;
		/* 82161DB4h case    5:*/		return 0x82161DB8;
		  /* 82161DB8h */ case    6:  		/* lis R11, 68 */
		/* 82161DB8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0x44);
		/* 82161DB8h case    6:*/		return 0x82161DBC;
		  /* 82161DBCh */ case    7:  		/* lwz R10, <#[R1 + 96]> */
		/* 82161DBCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82161DBCh case    7:*/		return 0x82161DC0;
		  /* 82161DC0h */ case    8:  		/* li R9, 17476 */
		/* 82161DC0h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x4444);
		/* 82161DC0h case    8:*/		return 0x82161DC4;
		  /* 82161DC4h */ case    9:  		/* ori R11, R11, 32 */
		/* 82161DC4h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82161DC4h case    9:*/		return 0x82161DC8;
		  /* 82161DC8h */ case   10:  		/* li R8, 8 */
		/* 82161DC8h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 82161DC8h case   10:*/		return 0x82161DCC;
		  /* 82161DCCh */ case   11:  		/* stw R11, <#[R3]> */
		/* 82161DCCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82161DCCh case   11:*/		return 0x82161DD0;
		  /* 82161DD0h */ case   12:  		/* addi R11, R10, 5 */
		/* 82161DD0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x5);
		/* 82161DD0h case   12:*/		return 0x82161DD4;
		  /* 82161DD4h */ case   13:  		/* stwu R9, <#[R3 + 4]> */
		/* 82161DD4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161DD4h case   13:*/		return 0x82161DD8;
		  /* 82161DD8h */ case   14:  		/* li R7, 41 */
		/* 82161DD8h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x29);
		/* 82161DD8h case   14:*/		return 0x82161DDC;
		  /* 82161DDCh */ case   15:  		/* stwu R8, <#[R3 + 4]> */
		/* 82161DDCh case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161DDCh case   15:*/		return 0x82161DE0;
		  /* 82161DE0h */ case   16:  		/* lwz R10, <#[R29]> */
		/* 82161DE0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82161DE0h case   16:*/		return 0x82161DE4;
		  /* 82161DE4h */ case   17:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 82161DE4h case   17:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 82161DE4h case   17:*/		return 0x82161DE8;
		  /* 82161DE8h */ case   18:  		/* stwu R10, <#[R3 + 4]> */
		/* 82161DE8h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161DE8h case   18:*/		return 0x82161DEC;
		  /* 82161DECh */ case   19:  		/* stwu R7, <#[R3 + 4]> */
		/* 82161DECh case   19:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161DECh case   19:*/		return 0x82161DF0;
		  /* 82161DF0h */ case   20:  		/* b 996 */
		/* 82161DF0h case   20:*/		return 0x821621D4;
		/* 82161DF0h case   20:*/		return 0x82161DF4;
	}
	return 0x82161DF4;
} // Block from 82161DA0h-82161DF4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82161DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161DF4);
		  /* 82161DF4h */ case    0:  		/* cmplwi CR6, R11, 4608 */
		/* 82161DF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001200);
		/* 82161DF4h case    0:*/		return 0x82161DF8;
		  /* 82161DF8h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82161DF8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82161E00;  }
		/* 82161DF8h case    1:*/		return 0x82161DFC;
		  /* 82161DFCh */ case    2:  		/* bl 1070180 */
		/* 82161DFCh case    2:*/		regs.LR = 0x82161E00; return 0x82267260;
		/* 82161DFCh case    2:*/		return 0x82161E00;
	}
	return 0x82161E00;
} // Block from 82161DF4h-82161E00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82161E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161E00);
		  /* 82161E00h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82161E00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82161E00h case    0:*/		return 0x82161E04;
		  /* 82161E04h */ case    1:  		/* mr R10, R11 */
		/* 82161E04h case    1:*/		regs.R10 = regs.R11;
		/* 82161E04h case    1:*/		return 0x82161E08;
		  /* 82161E08h */ case    2:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82161E08h case    2:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82161E08h case    2:*/		return 0x82161E0C;
		  /* 82161E0Ch */ case    3:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82161E0Ch case    3:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82161E0Ch case    3:*/		return 0x82161E10;
		  /* 82161E10h */ case    4:  		/* cmplwi CR6, R11, 3584 */
		/* 82161E10h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000E00);
		/* 82161E10h case    4:*/		return 0x82161E14;
		  /* 82161E14h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82161E14h case    5:*/		if ( regs.CR[6].eq ) { return 0x82161E1C;  }
		/* 82161E14h case    5:*/		return 0x82161E18;
		  /* 82161E18h */ case    6:  		/* bl 1070152 */
		/* 82161E18h case    6:*/		regs.LR = 0x82161E1C; return 0x82267260;
		/* 82161E18h case    6:*/		return 0x82161E1C;
	}
	return 0x82161E1C;
} // Block from 82161E00h-82161E1Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82161E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161E1C);
		  /* 82161E1Ch */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82161E1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82161E1Ch case    0:*/		return 0x82161E20;
		  /* 82161E20h */ case    1:  		/* rlwinm R11, R11, 0, 21, 31 */
		/* 82161E20h case    1:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R11,regs.R11);
		/* 82161E20h case    1:*/		return 0x82161E24;
		  /* 82161E24h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 82161E24h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82161E24h case    2:*/		return 0x82161E28;
		  /* 82161E28h */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 82161E28h case    3:*/		if ( regs.CR[6].lt ) { return 0x82161E30;  }
		/* 82161E28h case    3:*/		return 0x82161E2C;
		  /* 82161E2Ch */ case    4:  		/* bl 1070132 */
		/* 82161E2Ch case    4:*/		regs.LR = 0x82161E30; return 0x82267260;
		/* 82161E2Ch case    4:*/		return 0x82161E30;
	}
	return 0x82161E30;
} // Block from 82161E1Ch-82161E30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82161E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161E30);
		  /* 82161E30h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82161E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82161E30h case    0:*/		return 0x82161E34;
		  /* 82161E34h */ case    1:  		/* li R9, 1 */
		/* 82161E34h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82161E34h case    1:*/		return 0x82161E38;
		  /* 82161E38h */ case    2:  		/* lis R10, 3328 */
		/* 82161E38h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xD00);
		/* 82161E38h case    2:*/		return 0x82161E3C;
		  /* 82161E3Ch */ case    3:  		/* rlwinm R11, R11, 0, 4, 7 */
		/* 82161E3Ch case    3:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R11);
		/* 82161E3Ch case    3:*/		return 0x82161E40;
		  /* 82161E40h */ case    4:  		/* stw R9, <#[R1 + 96]> */
		/* 82161E40h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82161E40h case    4:*/		return 0x82161E44;
		  /* 82161E44h */ case    5:  		/* li R7, 0 */
		/* 82161E44h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82161E44h case    5:*/		return 0x82161E48;
		  /* 82161E48h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82161E48h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82161E48h case    6:*/		return 0x82161E4C;
		  /* 82161E4Ch */ case    7:  		/* li R6, 0 */
		/* 82161E4Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82161E4Ch case    7:*/		return 0x82161E50;
		  /* 82161E50h */ case    8:  		/* li R5, 0 */
		/* 82161E50h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82161E50h case    8:*/		return 0x82161E54;
		  /* 82161E54h */ case    9:  		/* addi R3, R31, 4 */
		/* 82161E54h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161E54h case    9:*/		return 0x82161E58;
		  /* 82161E58h */ case   10:  		/* li R9, 0 */
		/* 82161E58h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161E58h case   10:*/		return 0x82161E5C;
		  /* 82161E5Ch */ case   11:  		/* bc 4, CR6_EQ, 84 */
		/* 82161E5Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82161EB0;  }
		/* 82161E5Ch case   11:*/		return 0x82161E60;
		  /* 82161E60h */ case   12:  		/* li R11, 53 */
		/* 82161E60h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x35);
		/* 82161E60h case   12:*/		return 0x82161E64;
		  /* 82161E64h */ case   13:  		/* addi R10, R1, 96 */
		/* 82161E64h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82161E64h case   13:*/		return 0x82161E68;
		  /* 82161E68h */ case   14:  		/* stw R11, <#[R31]> */
		/* 82161E68h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161E68h case   14:*/		return 0x82161E6C;
		  /* 82161E6Ch */ case   15:  		/* li R8, 53 */
		/* 82161E6Ch case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x35);
		/* 82161E6Ch case   15:*/		return 0x82161E70;
		  /* 82161E70h */ case   16:  		/* stw R10, <#[R1 + 84]> */
		/* 82161E70h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82161E70h case   16:*/		return 0x82161E74;
		  /* 82161E74h */ case   17:  		/* mr R10, R26 */
		/* 82161E74h case   17:*/		regs.R10 = regs.R26;
		/* 82161E74h case   17:*/		return 0x82161E78;
		  /* 82161E78h */ case   18:  		/* lwz R4, <#[R29 + 4]> */
		/* 82161E78h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 82161E78h case   18:*/		return 0x82161E7C;
		  /* 82161E7Ch */ case   19:  		/* bl -2804 */
		/* 82161E7Ch case   19:*/		regs.LR = 0x82161E80; return 0x82161388;
		/* 82161E7Ch case   19:*/		return 0x82161E80;
		  /* 82161E80h */ case   20:  		/* li R11, 39 */
		/* 82161E80h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x27);
		/* 82161E80h case   20:*/		return 0x82161E84;
		  /* 82161E84h */ case   21:  		/* lwz R10, <#[R1 + 96]> */
		/* 82161E84h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82161E84h case   21:*/		return 0x82161E88;
		  /* 82161E88h */ case   22:  		/* li R9, 8 */
		/* 82161E88h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82161E88h case   22:*/		return 0x82161E8C;
		  /* 82161E8Ch */ case   23:  		/* stw R11, <#[R3]> */
		/* 82161E8Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82161E8Ch case   23:*/		return 0x82161E90;
		  /* 82161E90h */ case   24:  		/* addi R11, R10, 4 */
		/* 82161E90h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 82161E90h case   24:*/		return 0x82161E94;
		  /* 82161E94h */ case   25:  		/* stwu R9, <#[R3 + 4]> */
		/* 82161E94h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161E94h case   25:*/		return 0x82161E98;
		  /* 82161E98h */ case   26:  		/* li R8, 41 */
		/* 82161E98h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x29);
		/* 82161E98h case   26:*/		return 0x82161E9C;
		  /* 82161E9Ch */ case   27:  		/* lwz R10, <#[R29]> */
		/* 82161E9Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82161E9Ch case   27:*/		return 0x82161EA0;
		  /* 82161EA0h */ case   28:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 82161EA0h case   28:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 82161EA0h case   28:*/		return 0x82161EA4;
		  /* 82161EA4h */ case   29:  		/* stwu R10, <#[R3 + 4]> */
		/* 82161EA4h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161EA4h case   29:*/		return 0x82161EA8;
		  /* 82161EA8h */ case   30:  		/* stwu R8, <#[R3 + 4]> */
		/* 82161EA8h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82161EA8h case   30:*/		return 0x82161EAC;
		  /* 82161EACh */ case   31:  		/* b 808 */
		/* 82161EACh case   31:*/		return 0x821621D4;
		/* 82161EACh case   31:*/		return 0x82161EB0;
	}
	return 0x82161EB0;
} // Block from 82161E30h-82161EB0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82161EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161EB0);
		  /* 82161EB0h */ case    0:  		/* li R11, 9 */
		/* 82161EB0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 82161EB0h case    0:*/		return 0x82161EB4;
		  /* 82161EB4h */ case    1:  		/* mr R10, R26 */
		/* 82161EB4h case    1:*/		regs.R10 = regs.R26;
		/* 82161EB4h case    1:*/		return 0x82161EB8;
		  /* 82161EB8h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82161EB8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161EB8h case    2:*/		return 0x82161EBC;
		  /* 82161EBCh */ case    3:  		/* addi R11, R1, 96 */
		/* 82161EBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82161EBCh case    3:*/		return 0x82161EC0;
		  /* 82161EC0h */ case    4:  		/* li R8, 9 */
		/* 82161EC0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x9);
		/* 82161EC0h case    4:*/		return 0x82161EC4;
		  /* 82161EC4h */ case    5:  		/* stw R11, <#[R1 + 84]> */
		/* 82161EC4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82161EC4h case    5:*/		return 0x82161EC8;
		  /* 82161EC8h */ case    6:  		/* lwz R4, <#[R29 + 4]> */
		/* 82161EC8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 82161EC8h case    6:*/		return 0x82161ECC;
		  /* 82161ECCh */ case    7:  		/* bl -2884 */
		/* 82161ECCh case    7:*/		regs.LR = 0x82161ED0; return 0x82161388;
		/* 82161ECCh case    7:*/		return 0x82161ED0;
		  /* 82161ED0h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 82161ED0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82161ED0h case    8:*/		return 0x82161ED4;
		  /* 82161ED4h */ case    9:  		/* lwz R10, <#[R1 + 96]> */
		/* 82161ED4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82161ED4h case    9:*/		return 0x82161ED8;
		  /* 82161ED8h */ case   10:  		/* addi R31, R3, 4 */
		/* 82161ED8h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 82161ED8h case   10:*/		return 0x82161EDC;
		  /* 82161EDCh */ case   11:  		/* rlwinm R9, R11, 0, 21, 31 */
		/* 82161EDCh case   11:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R9,regs.R11);
		/* 82161EDCh case   11:*/		return 0x82161EE0;
		  /* 82161EE0h */ case   12:  		/* addi R11, R10, 1 */
		/* 82161EE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 82161EE0h case   12:*/		return 0x82161EE4;
		  /* 82161EE4h */ case   13:  		/* stw R9, <#[R3]> */
		/* 82161EE4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82161EE4h case   13:*/		return 0x82161EE8;
		  /* 82161EE8h */ case   14:  		/* b -960 */
		/* 82161EE8h case   14:*/		return 0x82161B28;
		/* 82161EE8h case   14:*/		return 0x82161EEC;
		  /* 82161EECh */ case   15:  		/* li R11, 6 */
		/* 82161EECh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 82161EECh case   15:*/		return 0x82161EF0;
		  /* 82161EF0h */ case   16:  		/* b -552 */
		/* 82161EF0h case   16:*/		return 0x82161CC8;
		/* 82161EF0h case   16:*/		return 0x82161EF4;
		  /* 82161EF4h */ case   17:  		/* rlwinm R11, R27, 16, 29, 31 */
		/* 82161EF4h case   17:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R11,regs.R27);
		/* 82161EF4h case   17:*/		return 0x82161EF8;
		  /* 82161EF8h */ case   18:  		/* li R27, 3 */
		/* 82161EF8h case   18:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 82161EF8h case   18:*/		return 0x82161EFC;
		  /* 82161EFCh */ case   19:  		/* cmplwi CR6, R11, 1 */
		/* 82161EFCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82161EFCh case   19:*/		return 0x82161F00;
		  /* 82161F00h */ case   20:  		/* bc 12, CR6_EQ, 80 */
		/* 82161F00h case   20:*/		if ( regs.CR[6].eq ) { return 0x82161F50;  }
		/* 82161F00h case   20:*/		return 0x82161F04;
		  /* 82161F04h */ case   21:  		/* cmplwi CR6, R11, 3 */
		/* 82161F04h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82161F04h case   21:*/		return 0x82161F08;
		  /* 82161F08h */ case   22:  		/* bc 12, CR6_EQ, 64 */
		/* 82161F08h case   22:*/		if ( regs.CR[6].eq ) { return 0x82161F48;  }
		/* 82161F08h case   22:*/		return 0x82161F0C;
		  /* 82161F0Ch */ case   23:  		/* cmplwi CR6, R11, 4 */
		/* 82161F0Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82161F0Ch case   23:*/		return 0x82161F10;
		  /* 82161F10h */ case   24:  		/* bc 12, CR6_EQ, 48 */
		/* 82161F10h case   24:*/		if ( regs.CR[6].eq ) { return 0x82161F40;  }
		/* 82161F10h case   24:*/		return 0x82161F14;
		  /* 82161F14h */ case   25:  		/* cmplwi CR6, R11, 5 */
		/* 82161F14h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82161F14h case   25:*/		return 0x82161F18;
		  /* 82161F18h */ case   26:  		/* addi R3, R31, 4 */
		/* 82161F18h case   26:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161F18h case   26:*/		return 0x82161F1C;
		  /* 82161F1Ch */ case   27:  		/* bc 12, CR6_EQ, 28 */
		/* 82161F1Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x82161F38;  }
		/* 82161F1Ch case   27:*/		return 0x82161F20;
		  /* 82161F20h */ case   28:  		/* cmplwi CR6, R11, 6 */
		/* 82161F20h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 82161F20h case   28:*/		return 0x82161F24;
		  /* 82161F24h */ case   29:  		/* bc 12, CR6_EQ, 12 */
		/* 82161F24h case   29:*/		if ( regs.CR[6].eq ) { return 0x82161F30;  }
		/* 82161F24h case   29:*/		return 0x82161F28;
		  /* 82161F28h */ case   30:  		/* lis R11, 1 */
		/* 82161F28h case   30:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82161F28h case   30:*/		return 0x82161F2C;
		  /* 82161F2Ch */ case   31:  		/* b 44 */
		/* 82161F2Ch case   31:*/		return 0x82161F58;
		/* 82161F2Ch case   31:*/		return 0x82161F30;
	}
	return 0x82161F30;
} // Block from 82161EB0h-82161F30h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82161F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F30);
		  /* 82161F30h */ case    0:  		/* lis R11, 4 */
		/* 82161F30h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x4);
		/* 82161F30h case    0:*/		return 0x82161F34;
		  /* 82161F34h */ case    1:  		/* b 36 */
		/* 82161F34h case    1:*/		return 0x82161F58;
		/* 82161F34h case    1:*/		return 0x82161F38;
	}
	return 0x82161F38;
} // Block from 82161F30h-82161F38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F38);
		  /* 82161F38h */ case    0:  		/* li R11, 52 */
		/* 82161F38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x34);
		/* 82161F38h case    0:*/		return 0x82161F3C;
		  /* 82161F3Ch */ case    1:  		/* b 32 */
		/* 82161F3Ch case    1:*/		return 0x82161F5C;
		/* 82161F3Ch case    1:*/		return 0x82161F40;
	}
	return 0x82161F40;
} // Block from 82161F38h-82161F40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F40);
		  /* 82161F40h */ case    0:  		/* lis R11, 5 */
		/* 82161F40h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5);
		/* 82161F40h case    0:*/		return 0x82161F44;
		  /* 82161F44h */ case    1:  		/* b 16 */
		/* 82161F44h case    1:*/		return 0x82161F54;
		/* 82161F44h case    1:*/		return 0x82161F48;
	}
	return 0x82161F48;
} // Block from 82161F40h-82161F48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F48);
		  /* 82161F48h */ case    0:  		/* lis R11, 2 */
		/* 82161F48h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 82161F48h case    0:*/		return 0x82161F4C;
		  /* 82161F4Ch */ case    1:  		/* b 8 */
		/* 82161F4Ch case    1:*/		return 0x82161F54;
		/* 82161F4Ch case    1:*/		return 0x82161F50;
	}
	return 0x82161F50;
} // Block from 82161F48h-82161F50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F50);
		  /* 82161F50h */ case    0:  		/* lis R11, 3 */
		/* 82161F50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x3);
		/* 82161F50h case    0:*/		return 0x82161F54;
	}
	return 0x82161F54;
} // Block from 82161F50h-82161F54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F54);
		  /* 82161F54h */ case    0:  		/* addi R3, R31, 4 */
		/* 82161F54h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82161F54h case    0:*/		return 0x82161F58;
	}
	return 0x82161F58;
} // Block from 82161F54h-82161F58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F58);
		  /* 82161F58h */ case    0:  		/* ori R11, R11, 52 */
		/* 82161F58h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82161F58h case    0:*/		return 0x82161F5C;
	}
	return 0x82161F5C;
} // Block from 82161F58h-82161F5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82161F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161F5C);
		  /* 82161F5Ch */ case    0:  		/* li R9, 2 */
		/* 82161F5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82161F5Ch case    0:*/		return 0x82161F60;
		  /* 82161F60h */ case    1:  		/* stw R11, <#[R31]> */
		/* 82161F60h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82161F60h case    1:*/		return 0x82161F64;
		  /* 82161F64h */ case    2:  		/* li R10, 1 */
		/* 82161F64h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82161F64h case    2:*/		return 0x82161F68;
		  /* 82161F68h */ case    3:  		/* mr R11, R25 */
		/* 82161F68h case    3:*/		regs.R11 = regs.R25;
		/* 82161F68h case    3:*/		return 0x82161F6C;
		  /* 82161F6Ch */ case    4:  		/* stw R10, <#[R1 + 96]> */
		/* 82161F6Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82161F6Ch case    4:*/		return 0x82161F70;
		  /* 82161F70h */ case    5:  		/* addi R10, R29, -4 */
		/* 82161F70h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFFC);
		/* 82161F70h case    5:*/		return 0x82161F74;
		  /* 82161F74h */ case    6:  		/* mtspr CTR, R9 */
		/* 82161F74h case    6:*/		regs.CTR = regs.R9;
		/* 82161F74h case    6:*/		return 0x82161F78;
		  /* 82161F78h */ case    7:  		/* lwz R8, <#[R10 + 4]> */
		/* 82161F78h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82161F78h case    7:*/		return 0x82161F7C;
		  /* 82161F7Ch */ case    8:  		/* addi R9, R1, 112 */
		/* 82161F7Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 82161F7Ch case    8:*/		return 0x82161F80;
		  /* 82161F80h */ case    9:  		/* addi R10, R10, 4 */
		/* 82161F80h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82161F80h case    9:*/		return 0x82161F84;
		  /* 82161F84h */ case   10:  		/* cmplwi CR6, R26, 512 */
		/* 82161F84h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000200);
		/* 82161F84h case   10:*/		return 0x82161F88;
		  /* 82161F88h */ case   11:  		/* stwx R8, <#[R11 + R9]> */
		/* 82161F88h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82161F88h case   11:*/		return 0x82161F8C;
		  /* 82161F8Ch */ case   12:  		/* bc 12, CR6_LT, 56 */
		/* 82161F8Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x82161FC4;  }
		/* 82161F8Ch case   12:*/		return 0x82161F90;
		  /* 82161F90h */ case   13:  		/* rlwinm R9, R8, 0, 0, 31 */
		/* 82161F90h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R8);
		/* 82161F90h case   13:*/		return 0x82161F94;
		  /* 82161F94h */ case   14:  		/* rlwinm R8, R9, 0, 18, 18 */
		/* 82161F94h case   14:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R8,regs.R9);
		/* 82161F94h case   14:*/		return 0x82161F98;
		  /* 82161F98h */ case   15:  		/* cmplwi CR6, R8, 8192 */
		/* 82161F98h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00002000);
		/* 82161F98h case   15:*/		return 0x82161F9C;
		  /* 82161F9Ch */ case   16:  		/* bc 4, CR6_EQ, 40 */
		/* 82161F9Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x82161FC4;  }
		/* 82161F9Ch case   16:*/		return 0x82161FA0;
		  /* 82161FA0h */ case   17:  		/* rlwimi R9, R9, 12, 21, 23 */
		/* 82161FA0h case   17:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R9,regs.R9);
		/* 82161FA0h case   17:*/		return 0x82161FA4;
		  /* 82161FA4h */ case   18:  		/* rlwinm R9, R9, 0, 19, 23 */
		/* 82161FA4h case   18:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R9,regs.R9);
		/* 82161FA4h case   18:*/		return 0x82161FA8;
		  /* 82161FA8h */ case   19:  		/* cmplwi CR6, R9, 512 */
		/* 82161FA8h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000200);
		/* 82161FA8h case   19:*/		return 0x82161FAC;
		  /* 82161FACh */ case   20:  		/* bc 4, CR6_EQ, 24 */
		/* 82161FACh case   20:*/		if ( !regs.CR[6].eq ) { return 0x82161FC4;  }
		/* 82161FACh case   20:*/		return 0x82161FB0;
		  /* 82161FB0h */ case   21:  		/* lwzu R9, <#[R10 + 4]> */
		/* 82161FB0h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82161FB0h case   21:*/		return 0x82161FB4;
		  /* 82161FB4h */ case   22:  		/* addi R8, R1, 104 */
		/* 82161FB4h case   22:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x68);
		/* 82161FB4h case   22:*/		return 0x82161FB8;
		  /* 82161FB8h */ case   23:  		/* addi R27, R27, 1 */
		/* 82161FB8h case   23:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82161FB8h case   23:*/		return 0x82161FBC;
		  /* 82161FBCh */ case   24:  		/* stwx R9, <#[R11 + R8]> */
		/* 82161FBCh case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82161FBCh case   24:*/		return 0x82161FC0;
		  /* 82161FC0h */ case   25:  		/* b 12 */
		/* 82161FC0h case   25:*/		return 0x82161FCC;
		/* 82161FC0h case   25:*/		return 0x82161FC4;
	}
	return 0x82161FC4;
} // Block from 82161F5Ch-82161FC4h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82161FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161FC4);
		  /* 82161FC4h */ case    0:  		/* addi R9, R1, 104 */
		/* 82161FC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x68);
		/* 82161FC4h case    0:*/		return 0x82161FC8;
		  /* 82161FC8h */ case    1:  		/* stwx R25, <#[R11 + R9]> */
		/* 82161FC8h case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82161FC8h case    1:*/		return 0x82161FCC;
	}
	return 0x82161FCC;
} // Block from 82161FC4h-82161FCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82161FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82161FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82161FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82161FCC);
		  /* 82161FCCh */ case    0:  		/* addi R11, R11, 4 */
		/* 82161FCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82161FCCh case    0:*/		return 0x82161FD0;
		  /* 82161FD0h */ case    1:  		/* bc 16, CR0_LT, -88 */
		/* 82161FD0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82161F78;  }
		/* 82161FD0h case    1:*/		return 0x82161FD4;
		  /* 82161FD4h */ case    2:  		/* addi R11, R1, 96 */
		/* 82161FD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82161FD4h case    2:*/		return 0x82161FD8;
		  /* 82161FD8h */ case    3:  		/* lwz R5, <#[R1 + 104]> */
		/* 82161FD8h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 82161FD8h case    3:*/		return 0x82161FDC;
		  /* 82161FDCh */ case    4:  		/* mr R10, R26 */
		/* 82161FDCh case    4:*/		regs.R10 = regs.R26;
		/* 82161FDCh case    4:*/		return 0x82161FE0;
		  /* 82161FE0h */ case    5:  		/* lwz R4, <#[R1 + 112]> */
		/* 82161FE0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000070) );
		/* 82161FE0h case    5:*/		return 0x82161FE4;
		  /* 82161FE4h */ case    6:  		/* stw R11, <#[R1 + 84]> */
		/* 82161FE4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82161FE4h case    6:*/		return 0x82161FE8;
		  /* 82161FE8h */ case    7:  		/* li R9, 0 */
		/* 82161FE8h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82161FE8h case    7:*/		return 0x82161FEC;
		  /* 82161FECh */ case    8:  		/* li R8, 52 */
		/* 82161FECh case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x34);
		/* 82161FECh case    8:*/		return 0x82161FF0;
		  /* 82161FF0h */ case    9:  		/* mr R7, R23 */
		/* 82161FF0h case    9:*/		regs.R7 = regs.R23;
		/* 82161FF0h case    9:*/		return 0x82161FF4;
		  /* 82161FF4h */ case   10:  		/* mr R6, R24 */
		/* 82161FF4h case   10:*/		regs.R6 = regs.R24;
		/* 82161FF4h case   10:*/		return 0x82161FF8;
		  /* 82161FF8h */ case   11:  		/* bl -3184 */
		/* 82161FF8h case   11:*/		regs.LR = 0x82161FFC; return 0x82161388;
		/* 82161FF8h case   11:*/		return 0x82161FFC;
		  /* 82161FFCh */ case   12:  		/* addi R11, R1, 96 */
		/* 82161FFCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82161FFCh case   12:*/		return 0x82162000;
		  /* 82162000h */ case   13:  		/* mr R10, R26 */
		/* 82162000h case   13:*/		regs.R10 = regs.R26;
		/* 82162000h case   13:*/		return 0x82162004;
		  /* 82162004h */ case   14:  		/* lwz R5, <#[R1 + 108]> */
		/* 82162004h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000006C) );
		/* 82162004h case   14:*/		return 0x82162008;
		  /* 82162008h */ case   15:  		/* li R9, 0 */
		/* 82162008h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82162008h case   15:*/		return 0x8216200C;
		  /* 8216200Ch */ case   16:  		/* lwz R4, <#[R1 + 116]> */
		/* 8216200Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000074) );
		/* 8216200Ch case   16:*/		return 0x82162010;
		  /* 82162010h */ case   17:  		/* li R8, 52 */
		/* 82162010h case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x34);
		/* 82162010h case   17:*/		return 0x82162014;
		  /* 82162014h */ case   18:  		/* stw R11, <#[R1 + 84]> */
		/* 82162014h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82162014h case   18:*/		return 0x82162018;
		  /* 82162018h */ case   19:  		/* mr R7, R23 */
		/* 82162018h case   19:*/		regs.R7 = regs.R23;
		/* 82162018h case   19:*/		return 0x8216201C;
		  /* 8216201Ch */ case   20:  		/* mr R6, R24 */
		/* 8216201Ch case   20:*/		regs.R6 = regs.R24;
		/* 8216201Ch case   20:*/		return 0x82162020;
		  /* 82162020h */ case   21:  		/* bl -3224 */
		/* 82162020h case   21:*/		regs.LR = 0x82162024; return 0x82161388;
		/* 82162020h case   21:*/		return 0x82162024;
		  /* 82162024h */ case   22:  		/* b -1284 */
		/* 82162024h case   22:*/		return 0x82161B20;
		/* 82162024h case   22:*/		return 0x82162028;
		  /* 82162028h */ case   23:  		/* rlwinm R11, R27, 16, 29, 31 */
		/* 82162028h case   23:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R11,regs.R27);
		/* 82162028h case   23:*/		return 0x8216202C;
		  /* 8216202Ch */ case   24:  		/* li R27, 3 */
		/* 8216202Ch case   24:*/		cpu::op::li<0>(regs,&regs.R27,0x3);
		/* 8216202Ch case   24:*/		return 0x82162030;
		  /* 82162030h */ case   25:  		/* cmplwi CR6, R11, 1 */
		/* 82162030h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82162030h case   25:*/		return 0x82162034;
		  /* 82162034h */ case   26:  		/* bc 12, CR6_EQ, 80 */
		/* 82162034h case   26:*/		if ( regs.CR[6].eq ) { return 0x82162084;  }
		/* 82162034h case   26:*/		return 0x82162038;
		  /* 82162038h */ case   27:  		/* cmplwi CR6, R11, 3 */
		/* 82162038h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82162038h case   27:*/		return 0x8216203C;
		  /* 8216203Ch */ case   28:  		/* bc 12, CR6_EQ, 64 */
		/* 8216203Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x8216207C;  }
		/* 8216203Ch case   28:*/		return 0x82162040;
		  /* 82162040h */ case   29:  		/* cmplwi CR6, R11, 4 */
		/* 82162040h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82162040h case   29:*/		return 0x82162044;
		  /* 82162044h */ case   30:  		/* bc 12, CR6_EQ, 48 */
		/* 82162044h case   30:*/		if ( regs.CR[6].eq ) { return 0x82162074;  }
		/* 82162044h case   30:*/		return 0x82162048;
		  /* 82162048h */ case   31:  		/* cmplwi CR6, R11, 5 */
		/* 82162048h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82162048h case   31:*/		return 0x8216204C;
		  /* 8216204Ch */ case   32:  		/* addi R3, R31, 4 */
		/* 8216204Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 8216204Ch case   32:*/		return 0x82162050;
		  /* 82162050h */ case   33:  		/* bc 12, CR6_EQ, 28 */
		/* 82162050h case   33:*/		if ( regs.CR[6].eq ) { return 0x8216206C;  }
		/* 82162050h case   33:*/		return 0x82162054;
		  /* 82162054h */ case   34:  		/* cmplwi CR6, R11, 6 */
		/* 82162054h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 82162054h case   34:*/		return 0x82162058;
		  /* 82162058h */ case   35:  		/* bc 12, CR6_EQ, 12 */
		/* 82162058h case   35:*/		if ( regs.CR[6].eq ) { return 0x82162064;  }
		/* 82162058h case   35:*/		return 0x8216205C;
		  /* 8216205Ch */ case   36:  		/* lis R11, 1 */
		/* 8216205Ch case   36:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 8216205Ch case   36:*/		return 0x82162060;
		  /* 82162060h */ case   37:  		/* b 44 */
		/* 82162060h case   37:*/		return 0x8216208C;
		/* 82162060h case   37:*/		return 0x82162064;
	}
	return 0x82162064;
} // Block from 82161FCCh-82162064h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82162064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162064);
		  /* 82162064h */ case    0:  		/* lis R11, 4 */
		/* 82162064h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x4);
		/* 82162064h case    0:*/		return 0x82162068;
		  /* 82162068h */ case    1:  		/* b 36 */
		/* 82162068h case    1:*/		return 0x8216208C;
		/* 82162068h case    1:*/		return 0x8216206C;
	}
	return 0x8216206C;
} // Block from 82162064h-8216206Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216206Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216206C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216206C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216206C);
		  /* 8216206Ch */ case    0:  		/* li R11, 7 */
		/* 8216206Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 8216206Ch case    0:*/		return 0x82162070;
		  /* 82162070h */ case    1:  		/* b 32 */
		/* 82162070h case    1:*/		return 0x82162090;
		/* 82162070h case    1:*/		return 0x82162074;
	}
	return 0x82162074;
} // Block from 8216206Ch-82162074h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162074);
		  /* 82162074h */ case    0:  		/* lis R11, 5 */
		/* 82162074h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5);
		/* 82162074h case    0:*/		return 0x82162078;
		  /* 82162078h */ case    1:  		/* b 16 */
		/* 82162078h case    1:*/		return 0x82162088;
		/* 82162078h case    1:*/		return 0x8216207C;
	}
	return 0x8216207C;
} // Block from 82162074h-8216207Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216207Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216207C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216207C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216207C);
		  /* 8216207Ch */ case    0:  		/* lis R11, 2 */
		/* 8216207Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 8216207Ch case    0:*/		return 0x82162080;
		  /* 82162080h */ case    1:  		/* b 8 */
		/* 82162080h case    1:*/		return 0x82162088;
		/* 82162080h case    1:*/		return 0x82162084;
	}
	return 0x82162084;
} // Block from 8216207Ch-82162084h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162084);
		  /* 82162084h */ case    0:  		/* lis R11, 3 */
		/* 82162084h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x3);
		/* 82162084h case    0:*/		return 0x82162088;
	}
	return 0x82162088;
} // Block from 82162084h-82162088h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162088);
		  /* 82162088h */ case    0:  		/* addi R3, R31, 4 */
		/* 82162088h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82162088h case    0:*/		return 0x8216208C;
	}
	return 0x8216208C;
} // Block from 82162088h-8216208Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216208Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216208C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216208C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216208C);
		  /* 8216208Ch */ case    0:  		/* ori R11, R11, 7 */
		/* 8216208Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x7);
		/* 8216208Ch case    0:*/		return 0x82162090;
	}
	return 0x82162090;
} // Block from 8216208Ch-82162090h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162090);
		  /* 82162090h */ case    0:  		/* li R9, 2 */
		/* 82162090h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82162090h case    0:*/		return 0x82162094;
		  /* 82162094h */ case    1:  		/* stw R11, <#[R31]> */
		/* 82162094h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82162094h case    1:*/		return 0x82162098;
		  /* 82162098h */ case    2:  		/* li R10, 1 */
		/* 82162098h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82162098h case    2:*/		return 0x8216209C;
		  /* 8216209Ch */ case    3:  		/* mr R11, R25 */
		/* 8216209Ch case    3:*/		regs.R11 = regs.R25;
		/* 8216209Ch case    3:*/		return 0x821620A0;
		  /* 821620A0h */ case    4:  		/* stw R10, <#[R1 + 96]> */
		/* 821620A0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 821620A0h case    4:*/		return 0x821620A4;
		  /* 821620A4h */ case    5:  		/* addi R10, R29, -4 */
		/* 821620A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFFC);
		/* 821620A4h case    5:*/		return 0x821620A8;
		  /* 821620A8h */ case    6:  		/* mtspr CTR, R9 */
		/* 821620A8h case    6:*/		regs.CTR = regs.R9;
		/* 821620A8h case    6:*/		return 0x821620AC;
		  /* 821620ACh */ case    7:  		/* lwz R8, <#[R10 + 4]> */
		/* 821620ACh case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821620ACh case    7:*/		return 0x821620B0;
		  /* 821620B0h */ case    8:  		/* addi R9, R1, 112 */
		/* 821620B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 821620B0h case    8:*/		return 0x821620B4;
		  /* 821620B4h */ case    9:  		/* addi R10, R10, 4 */
		/* 821620B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821620B4h case    9:*/		return 0x821620B8;
		  /* 821620B8h */ case   10:  		/* cmplwi CR6, R26, 512 */
		/* 821620B8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000200);
		/* 821620B8h case   10:*/		return 0x821620BC;
		  /* 821620BCh */ case   11:  		/* stwx R8, <#[R11 + R9]> */
		/* 821620BCh case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821620BCh case   11:*/		return 0x821620C0;
		  /* 821620C0h */ case   12:  		/* bc 12, CR6_LT, 56 */
		/* 821620C0h case   12:*/		if ( regs.CR[6].lt ) { return 0x821620F8;  }
		/* 821620C0h case   12:*/		return 0x821620C4;
		  /* 821620C4h */ case   13:  		/* rlwinm R9, R8, 0, 0, 31 */
		/* 821620C4h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R8);
		/* 821620C4h case   13:*/		return 0x821620C8;
		  /* 821620C8h */ case   14:  		/* rlwinm R8, R9, 0, 18, 18 */
		/* 821620C8h case   14:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R8,regs.R9);
		/* 821620C8h case   14:*/		return 0x821620CC;
		  /* 821620CCh */ case   15:  		/* cmplwi CR6, R8, 8192 */
		/* 821620CCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00002000);
		/* 821620CCh case   15:*/		return 0x821620D0;
		  /* 821620D0h */ case   16:  		/* bc 4, CR6_EQ, 40 */
		/* 821620D0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821620F8;  }
		/* 821620D0h case   16:*/		return 0x821620D4;
		  /* 821620D4h */ case   17:  		/* rlwimi R9, R9, 12, 21, 23 */
		/* 821620D4h case   17:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R9,regs.R9);
		/* 821620D4h case   17:*/		return 0x821620D8;
		  /* 821620D8h */ case   18:  		/* rlwinm R9, R9, 0, 19, 23 */
		/* 821620D8h case   18:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R9,regs.R9);
		/* 821620D8h case   18:*/		return 0x821620DC;
		  /* 821620DCh */ case   19:  		/* cmplwi CR6, R9, 512 */
		/* 821620DCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000200);
		/* 821620DCh case   19:*/		return 0x821620E0;
		  /* 821620E0h */ case   20:  		/* bc 4, CR6_EQ, 24 */
		/* 821620E0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x821620F8;  }
		/* 821620E0h case   20:*/		return 0x821620E4;
		  /* 821620E4h */ case   21:  		/* lwzu R9, <#[R10 + 4]> */
		/* 821620E4h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 821620E4h case   21:*/		return 0x821620E8;
		  /* 821620E8h */ case   22:  		/* addi R8, R1, 104 */
		/* 821620E8h case   22:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x68);
		/* 821620E8h case   22:*/		return 0x821620EC;
		  /* 821620ECh */ case   23:  		/* addi R27, R27, 1 */
		/* 821620ECh case   23:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821620ECh case   23:*/		return 0x821620F0;
		  /* 821620F0h */ case   24:  		/* stwx R9, <#[R11 + R8]> */
		/* 821620F0h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821620F0h case   24:*/		return 0x821620F4;
		  /* 821620F4h */ case   25:  		/* b 12 */
		/* 821620F4h case   25:*/		return 0x82162100;
		/* 821620F4h case   25:*/		return 0x821620F8;
	}
	return 0x821620F8;
} // Block from 82162090h-821620F8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821620F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821620F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821620F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821620F8);
		  /* 821620F8h */ case    0:  		/* addi R9, R1, 104 */
		/* 821620F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x68);
		/* 821620F8h case    0:*/		return 0x821620FC;
		  /* 821620FCh */ case    1:  		/* stwx R25, <#[R11 + R9]> */
		/* 821620FCh case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821620FCh case    1:*/		return 0x82162100;
	}
	return 0x82162100;
} // Block from 821620F8h-82162100h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162100);
		  /* 82162100h */ case    0:  		/* addi R11, R11, 4 */
		/* 82162100h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82162100h case    0:*/		return 0x82162104;
		  /* 82162104h */ case    1:  		/* bc 16, CR0_LT, -88 */
		/* 82162104h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821620AC;  }
		/* 82162104h case    1:*/		return 0x82162108;
		  /* 82162108h */ case    2:  		/* addi R11, R1, 96 */
		/* 82162108h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82162108h case    2:*/		return 0x8216210C;
		  /* 8216210Ch */ case    3:  		/* lwz R5, <#[R1 + 104]> */
		/* 8216210Ch case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 8216210Ch case    3:*/		return 0x82162110;
		  /* 82162110h */ case    4:  		/* mr R10, R26 */
		/* 82162110h case    4:*/		regs.R10 = regs.R26;
		/* 82162110h case    4:*/		return 0x82162114;
		  /* 82162114h */ case    5:  		/* lwz R4, <#[R1 + 112]> */
		/* 82162114h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000070) );
		/* 82162114h case    5:*/		return 0x82162118;
		  /* 82162118h */ case    6:  		/* li R9, 0 */
		/* 82162118h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82162118h case    6:*/		return 0x8216211C;
		  /* 8216211Ch */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 8216211Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8216211Ch case    7:*/		return 0x82162120;
		  /* 82162120h */ case    8:  		/* li R8, 7 */
		/* 82162120h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x7);
		/* 82162120h case    8:*/		return 0x82162124;
		  /* 82162124h */ case    9:  		/* mr R7, R23 */
		/* 82162124h case    9:*/		regs.R7 = regs.R23;
		/* 82162124h case    9:*/		return 0x82162128;
		  /* 82162128h */ case   10:  		/* mr R6, R24 */
		/* 82162128h case   10:*/		regs.R6 = regs.R24;
		/* 82162128h case   10:*/		return 0x8216212C;
		  /* 8216212Ch */ case   11:  		/* bl -3492 */
		/* 8216212Ch case   11:*/		regs.LR = 0x82162130; return 0x82161388;
		/* 8216212Ch case   11:*/		return 0x82162130;
		  /* 82162130h */ case   12:  		/* addi R11, R1, 96 */
		/* 82162130h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82162130h case   12:*/		return 0x82162134;
		  /* 82162134h */ case   13:  		/* mr R10, R26 */
		/* 82162134h case   13:*/		regs.R10 = regs.R26;
		/* 82162134h case   13:*/		return 0x82162138;
		  /* 82162138h */ case   14:  		/* lwz R5, <#[R1 + 108]> */
		/* 82162138h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000006C) );
		/* 82162138h case   14:*/		return 0x8216213C;
		  /* 8216213Ch */ case   15:  		/* li R9, 0 */
		/* 8216213Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8216213Ch case   15:*/		return 0x82162140;
		  /* 82162140h */ case   16:  		/* lwz R4, <#[R1 + 116]> */
		/* 82162140h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000074) );
		/* 82162140h case   16:*/		return 0x82162144;
		  /* 82162144h */ case   17:  		/* li R8, 7 */
		/* 82162144h case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x7);
		/* 82162144h case   17:*/		return 0x82162148;
		  /* 82162148h */ case   18:  		/* stw R11, <#[R1 + 84]> */
		/* 82162148h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82162148h case   18:*/		return 0x8216214C;
		  /* 8216214Ch */ case   19:  		/* mr R7, R23 */
		/* 8216214Ch case   19:*/		regs.R7 = regs.R23;
		/* 8216214Ch case   19:*/		return 0x82162150;
		  /* 82162150h */ case   20:  		/* mr R6, R24 */
		/* 82162150h case   20:*/		regs.R6 = regs.R24;
		/* 82162150h case   20:*/		return 0x82162154;
		  /* 82162154h */ case   21:  		/* bl -3532 */
		/* 82162154h case   21:*/		regs.LR = 0x82162158; return 0x82161388;
		/* 82162154h case   21:*/		return 0x82162158;
		  /* 82162158h */ case   22:  		/* b -1592 */
		/* 82162158h case   22:*/		return 0x82161B20;
		/* 82162158h case   22:*/		return 0x8216215C;
	}
	return 0x8216215C;
} // Block from 82162100h-8216215Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8216215Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216215C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216215C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216215C);
		  /* 8216215Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8216215Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216215Ch case    0:*/		return 0x82162160;
		  /* 82162160h */ case    1:  		/* li R27, 2 */
		/* 82162160h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82162160h case    1:*/		return 0x82162164;
		  /* 82162164h */ case    2:  		/* mr R10, R11 */
		/* 82162164h case    2:*/		regs.R10 = regs.R11;
		/* 82162164h case    2:*/		return 0x82162168;
		  /* 82162168h */ case    3:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82162168h case    3:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82162168h case    3:*/		return 0x8216216C;
		  /* 8216216Ch */ case    4:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 8216216Ch case    4:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 8216216Ch case    4:*/		return 0x82162170;
		  /* 82162170h */ case    5:  		/* cmplwi CR6, R11, 4864 */
		/* 82162170h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001300);
		/* 82162170h case    5:*/		return 0x82162174;
		  /* 82162174h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 82162174h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216217C;  }
		/* 82162174h case    6:*/		return 0x82162178;
		  /* 82162178h */ case    7:  		/* bl 1069288 */
		/* 82162178h case    7:*/		regs.LR = 0x8216217C; return 0x82267260;
		/* 82162178h case    7:*/		return 0x8216217C;
	}
	return 0x8216217C;
} // Block from 8216215Ch-8216217Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216217Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216217C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216217C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216217C);
		  /* 8216217Ch */ case    0:  		/* li R11, 7 */
		/* 8216217Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 8216217Ch case    0:*/		return 0x82162180;
		  /* 82162180h */ case    1:  		/* addi R10, R1, 96 */
		/* 82162180h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82162180h case    1:*/		return 0x82162184;
		  /* 82162184h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82162184h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82162184h case    2:*/		return 0x82162188;
		  /* 82162188h */ case    3:  		/* li R9, 1 */
		/* 82162188h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82162188h case    3:*/		return 0x8216218C;
		  /* 8216218Ch */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 8216218Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8216218Ch case    4:*/		return 0x82162190;
		  /* 82162190h */ case    5:  		/* mr R10, R26 */
		/* 82162190h case    5:*/		regs.R10 = regs.R26;
		/* 82162190h case    5:*/		return 0x82162194;
		  /* 82162194h */ case    6:  		/* stw R9, <#[R1 + 96]> */
		/* 82162194h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82162194h case    6:*/		return 0x82162198;
		  /* 82162198h */ case    7:  		/* li R9, 0 */
		/* 82162198h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82162198h case    7:*/		return 0x8216219C;
		  /* 8216219Ch */ case    8:  		/* li R8, 7 */
		/* 8216219Ch case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x7);
		/* 8216219Ch case    8:*/		return 0x821621A0;
		  /* 821621A0h */ case    9:  		/* li R7, 0 */
		/* 821621A0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821621A0h case    9:*/		return 0x821621A4;
		  /* 821621A4h */ case   10:  		/* li R6, 0 */
		/* 821621A4h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821621A4h case   10:*/		return 0x821621A8;
	}
	return 0x821621A8;
} // Block from 8216217Ch-821621A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821621A8h
// Function '?r400VSSetupPredicatedInst@XGRAPHICS@@YAPAKPAKKKKK0PAU_R400VSFUNC@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821621A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821621A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821621A8);
		  /* 821621A8h */ case    0:  		/* li R5, 0 */
		/* 821621A8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821621A8h case    0:*/		return 0x821621AC;
		  /* 821621ACh */ case    1:  		/* addi R3, R31, 4 */
		/* 821621ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 821621ACh case    1:*/		return 0x821621B0;
		  /* 821621B0h */ case    2:  		/* lwz R4, <#[R29]> */
		/* 821621B0h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000000) );
		/* 821621B0h case    2:*/		return 0x821621B4;
		  /* 821621B4h */ case    3:  		/* bl -3628 */
		/* 821621B4h case    3:*/		regs.LR = 0x821621B8; return 0x82161388;
		/* 821621B4h case    3:*/		return 0x821621B8;
		  /* 821621B8h */ case    4:  		/* lis R11, 68 */
		/* 821621B8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x44);
		/* 821621B8h case    4:*/		return 0x821621BC;
		  /* 821621BCh */ case    5:  		/* lwz R10, <#[R1 + 96]> */
		/* 821621BCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 821621BCh case    5:*/		return 0x821621C0;
		  /* 821621C0h */ case    6:  		/* li R9, 17476 */
		/* 821621C0h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x4444);
		/* 821621C0h case    6:*/		return 0x821621C4;
		  /* 821621C4h */ case    7:  		/* ori R8, R11, 32 */
		/* 821621C4h case    7:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0x20);
		/* 821621C4h case    7:*/		return 0x821621C8;
		  /* 821621C8h */ case    8:  		/* addi R11, R10, 2 */
		/* 821621C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x2);
		/* 821621C8h case    8:*/		return 0x821621CC;
		  /* 821621CCh */ case    9:  		/* stw R8, <#[R3]> */
		/* 821621CCh case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 821621CCh case    9:*/		return 0x821621D0;
		  /* 821621D0h */ case   10:  		/* stwu R9, <#[R3 + 4]> */
		/* 821621D0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 821621D0h case   10:*/		return 0x821621D4;
	}
	return 0x821621D4;
} // Block from 821621A8h-821621D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821621D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821621D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821621D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821621D4);
		  /* 821621D4h */ case    0:  		/* addi R31, R3, 4 */
		/* 821621D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 821621D4h case    0:*/		return 0x821621D8;
		  /* 821621D8h */ case    1:  		/* b -1712 */
		/* 821621D8h case    1:*/		return 0x82161B28;
		/* 821621D8h case    1:*/		return 0x821621DC;
	}
	return 0x821621DC;
} // Block from 821621D4h-821621DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821621DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821621DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821621DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821621DC);
		  /* 821621DCh */ case    0:  		/* li R27, 1 */
		/* 821621DCh case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821621DCh case    0:*/		return 0x821621E0;
		  /* 821621E0h */ case    1:  		/* b -1720 */
		/* 821621E0h case    1:*/		return 0x82161B28;
		/* 821621E0h case    1:*/		return 0x821621E4;
		  /* 821621E4h */ case    2:  		/* nop */
		/* 821621E4h case    2:*/		cpu::op::nop();
		/* 821621E4h case    2:*/		return 0x821621E8;
	}
	return 0x821621E8;
} // Block from 821621DCh-821621E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821621E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821621E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821621E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821621E8);
		  /* 821621E8h */ case    0:  		/* mfspr R12, LR */
		/* 821621E8h case    0:*/		regs.R12 = regs.LR;
		/* 821621E8h case    0:*/		return 0x821621EC;
		  /* 821621ECh */ case    1:  		/* bl -856008 */
		/* 821621ECh case    1:*/		regs.LR = 0x821621F0; return 0x82091224;
		/* 821621ECh case    1:*/		return 0x821621F0;
		  /* 821621F0h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 821621F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 821621F0h case    2:*/		return 0x821621F4;
		  /* 821621F4h */ case    3:  		/* lwz R30, <#[R6]> */
		/* 821621F4h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R6 + 0x00000000) );
		/* 821621F4h case    3:*/		return 0x821621F8;
		  /* 821621F8h */ case    4:  		/* mr R19, R10 */
		/* 821621F8h case    4:*/		regs.R19 = regs.R10;
		/* 821621F8h case    4:*/		return 0x821621FC;
		  /* 821621FCh */ case    5:  		/* li R21, 0 */
		/* 821621FCh case    5:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821621FCh case    5:*/		return 0x82162200;
		  /* 82162200h */ case    6:  		/* lwz R24, <#[R3 + 16]> */
		/* 82162200h case    6:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R3 + 0x00000010) );
		/* 82162200h case    6:*/		return 0x82162204;
		  /* 82162204h */ case    7:  		/* rlwinm R10, R30, 0, 18, 18 */
		/* 82162204h case    7:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R10,regs.R30);
		/* 82162204h case    7:*/		return 0x82162208;
		  /* 82162208h */ case    8:  		/* mr R15, R7 */
		/* 82162208h case    8:*/		regs.R15 = regs.R7;
		/* 82162208h case    8:*/		return 0x8216220C;
		  /* 8216220Ch */ case    9:  		/* mr R27, R3 */
		/* 8216220Ch case    9:*/		regs.R27 = regs.R3;
		/* 8216220Ch case    9:*/		return 0x82162210;
		  /* 82162210h */ case   10:  		/* mr R29, R4 */
		/* 82162210h case   10:*/		regs.R29 = regs.R4;
		/* 82162210h case   10:*/		return 0x82162214;
		  /* 82162214h */ case   11:  		/* mr R31, R5 */
		/* 82162214h case   11:*/		regs.R31 = regs.R5;
		/* 82162214h case   11:*/		return 0x82162218;
		  /* 82162218h */ case   12:  		/* mr R16, R8 */
		/* 82162218h case   12:*/		regs.R16 = regs.R8;
		/* 82162218h case   12:*/		return 0x8216221C;
		  /* 8216221Ch */ case   13:  		/* mr R20, R9 */
		/* 8216221Ch case   13:*/		regs.R20 = regs.R9;
		/* 8216221Ch case   13:*/		return 0x82162220;
		  /* 82162220h */ case   14:  		/* addi R11, R6, 4 */
		/* 82162220h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x4);
		/* 82162220h case   14:*/		return 0x82162224;
		  /* 82162224h */ case   15:  		/* mr R7, R21 */
		/* 82162224h case   15:*/		regs.R7 = regs.R21;
		/* 82162224h case   15:*/		return 0x82162228;
		  /* 82162228h */ case   16:  		/* mr R28, R21 */
		/* 82162228h case   16:*/		regs.R28 = regs.R21;
		/* 82162228h case   16:*/		return 0x8216222C;
		  /* 8216222Ch */ case   17:  		/* mr R18, R30 */
		/* 8216222Ch case   17:*/		regs.R18 = regs.R30;
		/* 8216222Ch case   17:*/		return 0x82162230;
		  /* 82162230h */ case   18:  		/* cmplwi CR6, R10, 8192 */
		/* 82162230h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002000);
		/* 82162230h case   18:*/		return 0x82162234;
		  /* 82162234h */ case   19:  		/* bc 4, CR6_EQ, 24 */
		/* 82162234h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8216224C;  }
		/* 82162234h case   19:*/		return 0x82162238;
		  /* 82162238h */ case   20:  		/* cmplwi CR6, R24, 768 */
		/* 82162238h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000300);
		/* 82162238h case   20:*/		return 0x8216223C;
		  /* 8216223Ch */ case   21:  		/* bc 12, CR6_LT, 16 */
		/* 8216223Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x8216224C;  }
		/* 8216223Ch case   21:*/		return 0x82162240;
		  /* 82162240h */ case   22:  		/* lwz R23, <#[R11]> */
		/* 82162240h case   22:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82162240h case   22:*/		return 0x82162244;
		  /* 82162244h */ case   23:  		/* addi R11, R11, 4 */
		/* 82162244h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82162244h case   23:*/		return 0x82162248;
		  /* 82162248h */ case   24:  		/* b 8 */
		/* 82162248h case   24:*/		return 0x82162250;
		/* 82162248h case   24:*/		return 0x8216224C;
	}
	return 0x8216224C;
} // Block from 821621E8h-8216224Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216224Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216224C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216224C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216224C);
		  /* 8216224Ch */ case    0:  		/* mr R23, R21 */
		/* 8216224Ch case    0:*/		regs.R23 = regs.R21;
		/* 8216224Ch case    0:*/		return 0x82162250;
	}
	return 0x82162250;
} // Block from 8216224Ch-82162250h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162250);
		  /* 82162250h */ case    0:  		/* lwz R25, <#[R1 + 372]> */
		/* 82162250h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000174) );
		/* 82162250h case    0:*/		return 0x82162254;
		  /* 82162254h */ case    1:  		/* mr R17, R21 */
		/* 82162254h case    1:*/		regs.R17 = regs.R21;
		/* 82162254h case    1:*/		return 0x82162258;
		  /* 82162258h */ case    2:  		/* cmpwi CR6, R25, 0 */
		/* 82162258h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82162258h case    2:*/		return 0x8216225C;
		  /* 8216225Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8216225Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82162274;  }
		/* 8216225Ch case    3:*/		return 0x82162260;
		  /* 82162260h */ case    4:  		/* li R10, 33 */
		/* 82162260h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x21);
		/* 82162260h case    4:*/		return 0x82162264;
		  /* 82162264h */ case    5:  		/* lwz R17, <#[R11]> */
		/* 82162264h case    5:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R11 + 0x00000000) );
		/* 82162264h case    5:*/		return 0x82162268;
		  /* 82162268h */ case    6:  		/* addi R11, R11, 4 */
		/* 82162268h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82162268h case    6:*/		return 0x8216226C;
		  /* 8216226Ch */ case    7:  		/* rlwimi R30, R10, 0, 19, 31 */
		/* 8216226Ch case    7:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R30,regs.R10);
		/* 8216226Ch case    7:*/		return 0x82162270;
		  /* 82162270h */ case    8:  		/* rlwimi R30, R10, 0, 1, 3 */
		/* 82162270h case    8:*/		cpu::op::rlwimi<0,0,1,3>(regs,&regs.R30,regs.R10);
		/* 82162270h case    8:*/		return 0x82162274;
	}
	return 0x82162274;
} // Block from 82162250h-82162274h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82162274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162274);
		  /* 82162274h */ case    0:  		/* li R26, 3 */
		/* 82162274h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x3);
		/* 82162274h case    0:*/		return 0x82162278;
		  /* 82162278h */ case    1:  		/* mr R10, R21 */
		/* 82162278h case    1:*/		regs.R10 = regs.R21;
		/* 82162278h case    1:*/		return 0x8216227C;
		  /* 8216227Ch */ case    2:  		/* mr R9, R26 */
		/* 8216227Ch case    2:*/		regs.R9 = regs.R26;
		/* 8216227Ch case    2:*/		return 0x82162280;
		  /* 82162280h */ case    3:  		/* addi R11, R11, -4 */
		/* 82162280h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82162280h case    3:*/		return 0x82162284;
		  /* 82162284h */ case    4:  		/* mtspr CTR, R26 */
		/* 82162284h case    4:*/		regs.CTR = regs.R26;
		/* 82162284h case    4:*/		return 0x82162288;
		  /* 82162288h */ case    5:  		/* lwz R8, <#[R11 + 4]> */
		/* 82162288h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82162288h case    5:*/		return 0x8216228C;
		  /* 8216228Ch */ case    6:  		/* rlwinm. R9, R8, 0, 0, 0 */
		/* 8216228Ch case    6:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R8);
		/* 8216228Ch case    6:*/		return 0x82162290;
		  /* 82162290h */ case    7:  		/* addi R9, R1, 104 */
		/* 82162290h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x68);
		/* 82162290h case    7:*/		return 0x82162294;
		  /* 82162294h */ case    8:  		/* bc 12, CR0_EQ, 80 */
		/* 82162294h case    8:*/		if ( regs.CR[0].eq ) { return 0x821622E4;  }
		/* 82162294h case    8:*/		return 0x82162298;
	}
	return 0x82162298;
} // Block from 82162274h-82162298h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82162298h
// Function '?r400VSConvertFlowCntl@XGRAPHICS@@YAPAKPAU_R400VSFUNC@1@KPAK1111K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162298);
		  /* 82162298h */ case    0:  		/* addi R11, R11, 4 */
		/* 82162298h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82162298h case    0:*/		return 0x8216229C;
		  /* 8216229Ch */ case    1:  		/* stwx R8, <#[R10 + R9]> */
		/* 8216229Ch case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8216229Ch case    1:*/		return 0x821622A0;
		  /* 821622A0h */ case    2:  		/* cmplwi CR6, R24, 512 */
		/* 821622A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000200);
		/* 821622A0h case    2:*/		return 0x821622A4;
		  /* 821622A4h */ case    3:  		/* bc 12, CR6_LT, 56 */
		/* 821622A4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821622DC;  }
		/* 821622A4h case    3:*/		return 0x821622A8;
		  /* 821622A8h */ case    4:  		/* rlwinm R9, R8, 0, 0, 31 */
		/* 821622A8h case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R8);
		/* 821622A8h case    4:*/		return 0x821622AC;
		  /* 821622ACh */ case    5:  		/* rlwinm R8, R9, 0, 18, 18 */
		/* 821622ACh case    5:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R8,regs.R9);
		/* 821622ACh case    5:*/		return 0x821622B0;
		  /* 821622B0h */ case    6:  		/* cmplwi CR6, R8, 8192 */
		/* 821622B0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00002000);
		/* 821622B0h case    6:*/		return 0x821622B4;
		  /* 821622B4h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 821622B4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821622DC;  }
		/* 821622B4h case    7:*/		return 0x821622B8;
		  /* 821622B8h */ case    8:  		/* rlwimi R9, R9, 12, 21, 23 */
		/* 821622B8h case    8:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R9,regs.R9);
		/* 821622B8h case    8:*/		return 0x821622BC;
		  /* 821622BCh */ case    9:  		/* rlwinm R9, R9, 0, 19, 23 */
		/* 821622BCh case    9:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R9,regs.R9);
		/* 821622BCh case    9:*/		return 0x821622C0;
		  /* 821622C0h */ case   10:  		/* cmplwi CR6, R9, 512 */
		/* 821622C0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000200);
		/* 821622C0h case   10:*/		return 0x821622C4;
		  /* 821622C4h */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 821622C4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821622DC;  }
		/* 821622C4h case   11:*/		return 0x821622C8;
		  /* 821622C8h */ case   12:  		/* lwzu R9, <#[R11 + 4]> */
		/* 821622C8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 821622C8h case   12:*/		return 0x821622CC;
		  /* 821622CCh */ case   13:  		/* addi R8, R1, 120 */
		/* 821622CCh case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x78);
		/* 821622CCh case   13:*/		return 0x821622D0;
		  /* 821622D0h */ case   14:  		/* addi R28, R28, 1 */
		/* 821622D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821622D0h case   14:*/		return 0x821622D4;
		  /* 821622D4h */ case   15:  		/* stwx R9, <#[R10 + R8]> */
		/* 821622D4h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 821622D4h case   15:*/		return 0x821622D8;
		  /* 821622D8h */ case   16:  		/* b 24 */
		/* 821622D8h case   16:*/		return 0x821622F0;
		/* 821622D8h case   16:*/		return 0x821622DC;
	}
	return 0x821622DC;
} // Block from 82162298h-821622DCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 821622DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821622DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821622DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821622DC);
		  /* 821622DCh */ case    0:  		/* addi R9, R1, 120 */
		/* 821622DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x78);
		/* 821622DCh case    0:*/		return 0x821622E0;
		  /* 821622E0h */ case    1:  		/* b 12 */
		/* 821622E0h case    1:*/		return 0x821622EC;
		/* 821622E0h case    1:*/		return 0x821622E4;
	}
	return 0x821622E4;
} // Block from 821622DCh-821622E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821622E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821622E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821622E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821622E4);
		  /* 821622E4h */ case    0:  		/* addi R8, R1, 120 */
		/* 821622E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x78);
		/* 821622E4h case    0:*/		return 0x821622E8;
		  /* 821622E8h */ case    1:  		/* stwx R21, <#[R10 + R8]> */
		/* 821622E8h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 821622E8h case    1:*/		return 0x821622EC;
	}
	return 0x821622EC;
} // Block from 821622E4h-821622ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821622ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821622EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821622EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821622EC);
		  /* 821622ECh */ case    0:  		/* stwx R21, <#[R10 + R9]> */
		/* 821622ECh case    0:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821622ECh case    0:*/		return 0x821622F0;
	}
	return 0x821622F0;
} // Block from 821622ECh-821622F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821622F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821622F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821622F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821622F0);
		  /* 821622F0h */ case    0:  		/* addi R10, R10, 4 */
		/* 821622F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821622F0h case    0:*/		return 0x821622F4;
		  /* 821622F4h */ case    1:  		/* bc 16, CR0_LT, -108 */
		/* 821622F4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82162288;  }
		/* 821622F4h case    1:*/		return 0x821622F8;
		  /* 821622F8h */ case    2:  		/* rlwinm R11, R29, 0, 16, 31 */
		/* 821622F8h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R29);
		/* 821622F8h case    2:*/		return 0x821622FC;
		  /* 821622FCh */ case    3:  		/* cmplwi CR6, R11, 34 */
		/* 821622FCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000022);
		/* 821622FCh case    3:*/		return 0x82162300;
		  /* 82162300h */ case    4:  		/* bc 12, CR6_EQ, 296 */
		/* 82162300h case    4:*/		if ( regs.CR[6].eq ) { return 0x82162428;  }
		/* 82162300h case    4:*/		return 0x82162304;
		  /* 82162304h */ case    5:  		/* cmplwi CR6, R11, 37 */
		/* 82162304h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000025);
		/* 82162304h case    5:*/		return 0x82162308;
		  /* 82162308h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82162308h case    6:*/		if ( regs.CR[6].eq ) { return 0x82162314;  }
		/* 82162308h case    6:*/		return 0x8216230C;
		  /* 8216230Ch */ case    7:  		/* mr R22, R21 */
		/* 8216230Ch case    7:*/		regs.R22 = regs.R21;
		/* 8216230Ch case    7:*/		return 0x82162310;
		  /* 82162310h */ case    8:  		/* b 464 */
		/* 82162310h case    8:*/		return 0x821624E0;
		/* 82162310h case    8:*/		return 0x82162314;
	}
	return 0x82162314;
} // Block from 821622F0h-82162314h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82162314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162314);
		  /* 82162314h */ case    0:  		/* mr R11, R18 */
		/* 82162314h case    0:*/		regs.R11 = regs.R18;
		/* 82162314h case    0:*/		return 0x82162318;
		  /* 82162318h */ case    1:  		/* rlwimi R11, R18, 12, 21, 23 */
		/* 82162318h case    1:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R18);
		/* 82162318h case    1:*/		return 0x8216231C;
		  /* 8216231Ch */ case    2:  		/* rlwinm. R11, R11, 0, 19, 23 */
		/* 8216231Ch case    2:*/		cpu::op::rlwinm<1,0,19,23>(regs,&regs.R11,regs.R11);
		/* 8216231Ch case    2:*/		return 0x82162320;
		  /* 82162320h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82162320h case    3:*/		if ( regs.CR[0].eq ) { return 0x82162328;  }
		/* 82162320h case    3:*/		return 0x82162324;
		  /* 82162324h */ case    4:  		/* bl 1068860 */
		/* 82162324h case    4:*/		regs.LR = 0x82162328; return 0x82267260;
		/* 82162324h case    4:*/		return 0x82162328;
	}
	return 0x82162328;
} // Block from 82162314h-82162328h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82162328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162328);
		  /* 82162328h */ case    0:  		/* cmplwi CR6, R24, 768 */
		/* 82162328h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000300);
		/* 82162328h case    0:*/		return 0x8216232C;
		  /* 8216232Ch */ case    1:  		/* bc 4, CR6_LT, 60 */
		/* 8216232Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82162368;  }
		/* 8216232Ch case    1:*/		return 0x82162330;
		  /* 82162330h */ case    2:  		/* lwz R11, <#[R1 + 108]> */
		/* 82162330h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82162330h case    2:*/		return 0x82162334;
		  /* 82162334h */ case    3:  		/* rlwimi R11, R11, 12, 21, 23 */
		/* 82162334h case    3:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R11);
		/* 82162334h case    3:*/		return 0x82162338;
		  /* 82162338h */ case    4:  		/* rlwinm R11, R11, 0, 19, 23 */
		/* 82162338h case    4:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82162338h case    4:*/		return 0x8216233C;
		  /* 8216233Ch */ case    5:  		/* cmplwi CR6, R11, 512 */
		/* 8216233Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000200);
		/* 8216233Ch case    5:*/		return 0x82162340;
		  /* 82162340h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 82162340h case    6:*/		if ( regs.CR[6].eq ) { return 0x82162348;  }
		/* 82162340h case    6:*/		return 0x82162344;
		  /* 82162344h */ case    7:  		/* bl 1068828 */
		/* 82162344h case    7:*/		regs.LR = 0x82162348; return 0x82267260;
		/* 82162344h case    7:*/		return 0x82162348;
	}
	return 0x82162348;
} // Block from 82162328h-82162348h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82162348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162348);
		  /* 82162348h */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 82162348h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82162348h case    0:*/		return 0x8216234C;
		  /* 8216234Ch */ case    1:  		/* rlwimi R11, R11, 12, 21, 23 */
		/* 8216234Ch case    1:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R11);
		/* 8216234Ch case    1:*/		return 0x82162350;
		  /* 82162350h */ case    2:  		/* rlwinm R11, R11, 0, 19, 23 */
		/* 82162350h case    2:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82162350h case    2:*/		return 0x82162354;
		  /* 82162354h */ case    3:  		/* cmplwi CR6, R11, 512 */
		/* 82162354h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000200);
		/* 82162354h case    3:*/		return 0x82162358;
		  /* 82162358h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 82162358h case    4:*/		if ( regs.CR[6].eq ) { return 0x82162360;  }
		/* 82162358h case    4:*/		return 0x8216235C;
		  /* 8216235Ch */ case    5:  		/* bl 1068804 */
		/* 8216235Ch case    5:*/		regs.LR = 0x82162360; return 0x82267260;
		/* 8216235Ch case    5:*/		return 0x82162360;
	}
	return 0x82162360;
} // Block from 82162348h-82162360h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82162360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162360);
		  /* 82162360h */ case    0:  		/* addi R22, R28, 4 */
		/* 82162360h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R28,0x4);
		/* 82162360h case    0:*/		return 0x82162364;
		  /* 82162364h */ case    1:  		/* b 28 */
		/* 82162364h case    1:*/		return 0x82162380;
		/* 82162364h case    1:*/		return 0x82162368;
	}
	return 0x82162368;
} // Block from 82162360h-82162368h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162368);
		  /* 82162368h */ case    0:  		/* rlwinm R11, R29, 0, 4, 7 */
		/* 82162368h case    0:*/		cpu::op::rlwinm<0,0,4,7>(regs,&regs.R11,regs.R29);
		/* 82162368h case    0:*/		return 0x8216236C;
		  /* 8216236Ch */ case    1:  		/* lis R10, 512 */
		/* 8216236Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 8216236Ch case    1:*/		return 0x82162370;
		  /* 82162370h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82162370h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82162370h case    2:*/		return 0x82162374;
		  /* 82162374h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 82162374h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216237C;  }
		/* 82162374h case    3:*/		return 0x82162378;
		  /* 82162378h */ case    4:  		/* bl 1068776 */
		/* 82162378h case    4:*/		regs.LR = 0x8216237C; return 0x82267260;
		/* 82162378h case    4:*/		return 0x8216237C;
	}
	return 0x8216237C;
} // Block from 82162368h-8216237Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216237Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216237C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216237C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216237C);
		  /* 8216237Ch */ case    0:  		/* addi R22, R28, 2 */
		/* 8216237Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R28,0x2);
		/* 8216237Ch case    0:*/		return 0x82162380;
	}
	return 0x82162380;
} // Block from 8216237Ch-82162380h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162380);
		  /* 82162380h */ case    0:  		/* li R11, 89 */
		/* 82162380h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x59);
		/* 82162380h case    0:*/		return 0x82162384;
		  /* 82162384h */ case    1:  		/* rlwimi R30, R26, 16, 12, 15 */
		/* 82162384h case    1:*/		cpu::op::rlwimi<0,16,12,15>(regs,&regs.R30,regs.R26);
		/* 82162384h case    1:*/		return 0x82162388;
		  /* 82162388h */ case    2:  		/* li R10, 1 */
		/* 82162388h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82162388h case    2:*/		return 0x8216238C;
		  /* 8216238Ch */ case    3:  		/* stw R11, <#[R31]> */
		/* 8216238Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216238Ch case    3:*/		return 0x82162390;
		  /* 82162390h */ case    4:  		/* addi R3, R31, 4 */
		/* 82162390h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82162390h case    4:*/		return 0x82162394;
		  /* 82162394h */ case    5:  		/* mr R4, R30 */
		/* 82162394h case    5:*/		regs.R4 = regs.R30;
		/* 82162394h case    5:*/		return 0x82162398;
		  /* 82162398h */ case    6:  		/* stw R10, <#[R1 + 96]> */
		/* 82162398h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82162398h case    6:*/		return 0x8216239C;
		  /* 8216239Ch */ case    7:  		/* cmpwi CR6, R25, 0 */
		/* 8216239Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8216239Ch case    7:*/		return 0x821623A0;
		  /* 821623A0h */ case    8:  		/* mr R7, R27 */
		/* 821623A0h case    8:*/		regs.R7 = regs.R27;
		/* 821623A0h case    8:*/		return 0x821623A4;
		  /* 821623A4h */ case    9:  		/* addi R6, R1, 96 */
		/* 821623A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 821623A4h case    9:*/		return 0x821623A8;
		  /* 821623A8h */ case   10:  		/* li R5, 0 */
		/* 821623A8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821623A8h case   10:*/		return 0x821623AC;
		  /* 821623ACh */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 821623ACh case   11:*/		if ( !regs.CR[6].eq ) { return 0x821623B4;  }
		/* 821623ACh case   11:*/		return 0x821623B0;
		  /* 821623B0h */ case   12:  		/* mr R5, R23 */
		/* 821623B0h case   12:*/		regs.R5 = regs.R23;
		/* 821623B0h case   12:*/		return 0x821623B4;
	}
	return 0x821623B4;
} // Block from 82162380h-821623B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821623B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821623B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821623B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821623B4);
		  /* 821623B4h */ case    0:  		/* bl -5540 */
		/* 821623B4h case    0:*/		regs.LR = 0x821623B8; return 0x82160E10;
		/* 821623B4h case    0:*/		return 0x821623B8;
		  /* 821623B8h */ case    1:  		/* addi R11, R1, 96 */
		/* 821623B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821623B8h case    1:*/		return 0x821623BC;
		  /* 821623BCh */ case    2:  		/* mr R10, R24 */
		/* 821623BCh case    2:*/		regs.R10 = regs.R24;
		/* 821623BCh case    2:*/		return 0x821623C0;
		  /* 821623C0h */ case    3:  		/* lwz R5, <#[R1 + 120]> */
		/* 821623C0h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000078) );
		/* 821623C0h case    3:*/		return 0x821623C4;
		  /* 821623C4h */ case    4:  		/* li R9, 0 */
		/* 821623C4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821623C4h case    4:*/		return 0x821623C8;
		  /* 821623C8h */ case    5:  		/* lwz R4, <#[R1 + 104]> */
		/* 821623C8h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 821623C8h case    5:*/		return 0x821623CC;
		  /* 821623CCh */ case    6:  		/* li R8, 89 */
		/* 821623CCh case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x59);
		/* 821623CCh case    6:*/		return 0x821623D0;
		  /* 821623D0h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 821623D0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821623D0h case    7:*/		return 0x821623D4;
		  /* 821623D4h */ case    8:  		/* mr R7, R19 */
		/* 821623D4h case    8:*/		regs.R7 = regs.R19;
		/* 821623D4h case    8:*/		return 0x821623D8;
		  /* 821623D8h */ case    9:  		/* mr R6, R20 */
		/* 821623D8h case    9:*/		regs.R6 = regs.R20;
		/* 821623D8h case    9:*/		return 0x821623DC;
		  /* 821623DCh */ case   10:  		/* bl -4180 */
		/* 821623DCh case   10:*/		regs.LR = 0x821623E0; return 0x82161388;
		/* 821623DCh case   10:*/		return 0x821623E0;
		  /* 821623E0h */ case   11:  		/* mr R31, R3 */
		/* 821623E0h case   11:*/		regs.R31 = regs.R3;
		/* 821623E0h case   11:*/		return 0x821623E4;
		  /* 821623E4h */ case   12:  		/* cmpwi CR6, R25, 0 */
		/* 821623E4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 821623E4h case   12:*/		return 0x821623E8;
		  /* 821623E8h */ case   13:  		/* bc 12, CR6_EQ, 244 */
		/* 821623E8h case   13:*/		if ( regs.CR[6].eq ) { return 0x821624DC;  }
		/* 821623E8h case   13:*/		return 0x821623EC;
		  /* 821623ECh */ case   14:  		/* mr R4, R18 */
		/* 821623ECh case   14:*/		regs.R4 = regs.R18;
		/* 821623ECh case   14:*/		return 0x821623F0;
		  /* 821623F0h */ case   15:  		/* rlwimi R4, R26, 16, 12, 15 */
		/* 821623F0h case   15:*/		cpu::op::rlwimi<0,16,12,15>(regs,&regs.R4,regs.R26);
		/* 821623F0h case   15:*/		return 0x821623F4;
		  /* 821623F4h */ case   16:  		/* stw R21, <#[R1 + 100]> */
		/* 821623F4h case   16:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 821623F4h case   16:*/		return 0x821623F8;
		  /* 821623F8h */ case   17:  		/* mr R5, R23 */
		/* 821623F8h case   17:*/		regs.R5 = regs.R23;
		/* 821623F8h case   17:*/		return 0x821623FC;
		  /* 821623FCh */ case   18:  		/* mr R6, R17 */
		/* 821623FCh case   18:*/		regs.R6 = regs.R17;
		/* 821623FCh case   18:*/		return 0x82162400;
		  /* 82162400h */ case   19:  		/* lis R7, 228 */
		/* 82162400h case   19:*/		cpu::op::lis<0>(regs,&regs.R7,0xE4);
		/* 82162400h case   19:*/		return 0x82162404;
		  /* 82162404h */ case   20:  		/* addi R8, R1, 100 */
		/* 82162404h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x64);
		/* 82162404h case   20:*/		return 0x82162408;
		  /* 82162408h */ case   21:  		/* mr R9, R27 */
		/* 82162408h case   21:*/		regs.R9 = regs.R27;
		/* 82162408h case   21:*/		return 0x8216240C;
		  /* 8216240Ch */ case   22:  		/* mr R3, R31 */
		/* 8216240Ch case   22:*/		regs.R3 = regs.R31;
		/* 8216240Ch case   22:*/		return 0x82162410;
		  /* 82162410h */ case   23:  		/* bl -3200 */
		/* 82162410h case   23:*/		regs.LR = 0x82162414; return 0x82161790;
		/* 82162410h case   23:*/		return 0x82162414;
		  /* 82162414h */ case   24:  		/* lwz R11, <#[R1 + 100]> */
		/* 82162414h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82162414h case   24:*/		return 0x82162418;
		  /* 82162418h */ case   25:  		/* lwz R10, <#[R1 + 96]> */
		/* 82162418h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82162418h case   25:*/		return 0x8216241C;
		  /* 8216241Ch */ case   26:  		/* mr R31, R3 */
		/* 8216241Ch case   26:*/		regs.R31 = regs.R3;
		/* 8216241Ch case   26:*/		return 0x82162420;
		  /* 82162420h */ case   27:  		/* add R7, R10, R11 */
		/* 82162420h case   27:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 82162420h case   27:*/		return 0x82162424;
		  /* 82162424h */ case   28:  		/* b 188 */
		/* 82162424h case   28:*/		return 0x821624E0;
		/* 82162424h case   28:*/		return 0x82162428;
	}
	return 0x82162428;
} // Block from 821623B4h-82162428h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82162428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162428);
		  /* 82162428h */ case    0:  		/* lwz R29, <#[R1 + 108]> */
		/* 82162428h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000006C) );
		/* 82162428h case    0:*/		return 0x8216242C;
		  /* 8216242Ch */ case    1:  		/* addi R22, R28, 4 */
		/* 8216242Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R28,0x4);
		/* 8216242Ch case    1:*/		return 0x82162430;
		  /* 82162430h */ case    2:  		/* mr R11, R29 */
		/* 82162430h case    2:*/		regs.R11 = regs.R29;
		/* 82162430h case    2:*/		return 0x82162434;
		  /* 82162434h */ case    3:  		/* rlwimi R11, R29, 12, 21, 23 */
		/* 82162434h case    3:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R29);
		/* 82162434h case    3:*/		return 0x82162438;
		  /* 82162438h */ case    4:  		/* rlwinm. R11, R11, 0, 19, 23 */
		/* 82162438h case    4:*/		cpu::op::rlwinm<1,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82162438h case    4:*/		return 0x8216243C;
		  /* 8216243Ch */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 8216243Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82162444;  }
		/* 8216243Ch case    5:*/		return 0x82162440;
		  /* 82162440h */ case    6:  		/* bl 1068576 */
		/* 82162440h case    6:*/		regs.LR = 0x82162444; return 0x82267260;
		/* 82162440h case    6:*/		return 0x82162444;
	}
	return 0x82162444;
} // Block from 82162428h-82162444h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82162444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162444);
		  /* 82162444h */ case    0:  		/* lwz R28, <#[R1 + 112]> */
		/* 82162444h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000070) );
		/* 82162444h case    0:*/		return 0x82162448;
		  /* 82162448h */ case    1:  		/* mr R11, R28 */
		/* 82162448h case    1:*/		regs.R11 = regs.R28;
		/* 82162448h case    1:*/		return 0x8216244C;
		  /* 8216244Ch */ case    2:  		/* rlwimi R11, R28, 12, 21, 23 */
		/* 8216244Ch case    2:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R28);
		/* 8216244Ch case    2:*/		return 0x82162450;
		  /* 82162450h */ case    3:  		/* rlwinm. R11, R11, 0, 19, 23 */
		/* 82162450h case    3:*/		cpu::op::rlwinm<1,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82162450h case    3:*/		return 0x82162454;
		  /* 82162454h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82162454h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216245C;  }
		/* 82162454h case    4:*/		return 0x82162458;
		  /* 82162458h */ case    5:  		/* bl 1068552 */
		/* 82162458h case    5:*/		regs.LR = 0x8216245C; return 0x82267260;
		/* 82162458h case    5:*/		return 0x8216245C;
	}
	return 0x8216245C;
} // Block from 82162444h-8216245Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216245Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216245C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216245C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216245C);
		  /* 8216245Ch */ case    0:  		/* xor R11, R28, R29 */
		/* 8216245Ch case    0:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R28,regs.R29);
		/* 8216245Ch case    0:*/		return 0x82162460;
		  /* 82162460h */ case    1:  		/* rlwinm. R11, R11, 0, 21, 31 */
		/* 82162460h case    1:*/		cpu::op::rlwinm<1,0,21,31>(regs,&regs.R11,regs.R11);
		/* 82162460h case    1:*/		return 0x82162464;
		  /* 82162464h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82162464h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216246C;  }
		/* 82162464h case    2:*/		return 0x82162468;
		  /* 82162468h */ case    3:  		/* bl 1068536 */
		/* 82162468h case    3:*/		regs.LR = 0x8216246C; return 0x82267260;
		/* 82162468h case    3:*/		return 0x8216246C;
	}
	return 0x8216246C;
} // Block from 8216245Ch-8216246Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216246Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216246C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216246C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216246C);
		  /* 8216246Ch */ case    0:  		/* li R11, 87 */
		/* 8216246Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x57);
		/* 8216246Ch case    0:*/		return 0x82162470;
		  /* 82162470h */ case    1:  		/* li R10, 1 */
		/* 82162470h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82162470h case    1:*/		return 0x82162474;
		  /* 82162474h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82162474h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82162474h case    2:*/		return 0x82162478;
		  /* 82162478h */ case    3:  		/* addi R3, R31, 4 */
		/* 82162478h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82162478h case    3:*/		return 0x8216247C;
		  /* 8216247Ch */ case    4:  		/* stw R10, <#[R1 + 96]> */
		/* 8216247Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8216247Ch case    4:*/		return 0x82162480;
		  /* 82162480h */ case    5:  		/* cmpwi CR6, R25, 0 */
		/* 82162480h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82162480h case    5:*/		return 0x82162484;
		  /* 82162484h */ case    6:  		/* mr R7, R27 */
		/* 82162484h case    6:*/		regs.R7 = regs.R27;
		/* 82162484h case    6:*/		return 0x82162488;
		  /* 82162488h */ case    7:  		/* addi R6, R1, 96 */
		/* 82162488h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 82162488h case    7:*/		return 0x8216248C;
		  /* 8216248Ch */ case    8:  		/* mr R4, R30 */
		/* 8216248Ch case    8:*/		regs.R4 = regs.R30;
		/* 8216248Ch case    8:*/		return 0x82162490;
		  /* 82162490h */ case    9:  		/* li R5, 0 */
		/* 82162490h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82162490h case    9:*/		return 0x82162494;
		  /* 82162494h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 82162494h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8216249C;  }
		/* 82162494h case   10:*/		return 0x82162498;
		  /* 82162498h */ case   11:  		/* mr R5, R23 */
		/* 82162498h case   11:*/		regs.R5 = regs.R23;
		/* 82162498h case   11:*/		return 0x8216249C;
	}
	return 0x8216249C;
} // Block from 8216246Ch-8216249Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216249Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216249C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216249C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216249C);
		  /* 8216249Ch */ case    0:  		/* bl -5772 */
		/* 8216249Ch case    0:*/		regs.LR = 0x821624A0; return 0x82160E10;
		/* 8216249Ch case    0:*/		return 0x821624A0;
		  /* 821624A0h */ case    1:  		/* addi R11, R1, 96 */
		/* 821624A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821624A0h case    1:*/		return 0x821624A4;
		  /* 821624A4h */ case    2:  		/* mr R10, R24 */
		/* 821624A4h case    2:*/		regs.R10 = regs.R24;
		/* 821624A4h case    2:*/		return 0x821624A8;
		  /* 821624A8h */ case    3:  		/* lwz R5, <#[R1 + 120]> */
		/* 821624A8h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000078) );
		/* 821624A8h case    3:*/		return 0x821624AC;
		  /* 821624ACh */ case    4:  		/* li R9, 0 */
		/* 821624ACh case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821624ACh case    4:*/		return 0x821624B0;
		  /* 821624B0h */ case    5:  		/* lwz R4, <#[R1 + 104]> */
		/* 821624B0h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 821624B0h case    5:*/		return 0x821624B4;
		  /* 821624B4h */ case    6:  		/* li R8, 87 */
		/* 821624B4h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x57);
		/* 821624B4h case    6:*/		return 0x821624B8;
		  /* 821624B8h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 821624B8h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821624B8h case    7:*/		return 0x821624BC;
		  /* 821624BCh */ case    8:  		/* mr R7, R19 */
		/* 821624BCh case    8:*/		regs.R7 = regs.R19;
		/* 821624BCh case    8:*/		return 0x821624C0;
		  /* 821624C0h */ case    9:  		/* mr R6, R20 */
		/* 821624C0h case    9:*/		regs.R6 = regs.R20;
		/* 821624C0h case    9:*/		return 0x821624C4;
		  /* 821624C4h */ case   10:  		/* bl -4412 */
		/* 821624C4h case   10:*/		regs.LR = 0x821624C8; return 0x82161388;
		/* 821624C4h case   10:*/		return 0x821624C8;
		  /* 821624C8h */ case   11:  		/* mr R31, R3 */
		/* 821624C8h case   11:*/		regs.R31 = regs.R3;
		/* 821624C8h case   11:*/		return 0x821624CC;
		  /* 821624CCh */ case   12:  		/* cmpwi CR6, R25, 0 */
		/* 821624CCh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 821624CCh case   12:*/		return 0x821624D0;
		  /* 821624D0h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 821624D0h case   13:*/		if ( regs.CR[6].eq ) { return 0x821624DC;  }
		/* 821624D0h case   13:*/		return 0x821624D4;
		  /* 821624D4h */ case   14:  		/* mr R4, R18 */
		/* 821624D4h case   14:*/		regs.R4 = regs.R18;
		/* 821624D4h case   14:*/		return 0x821624D8;
		  /* 821624D8h */ case   15:  		/* b -228 */
		/* 821624D8h case   15:*/		return 0x821623F4;
		/* 821624D8h case   15:*/		return 0x821624DC;
	}
	return 0x821624DC;
} // Block from 8216249Ch-821624DCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821624DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821624DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821624DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821624DC);
		  /* 821624DCh */ case    0:  		/* lwz R7, <#[R1 + 96]> */
		/* 821624DCh case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 821624DCh case    0:*/		return 0x821624E0;
	}
	return 0x821624E0;
} // Block from 821624DCh-821624E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821624E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821624E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821624E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821624E0);
		  /* 821624E0h */ case    0:  		/* stw R22, <#[R15]> */
		/* 821624E0h case    0:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R15 + 0x00000000) );
		/* 821624E0h case    0:*/		return 0x821624E4;
		  /* 821624E4h */ case    1:  		/* mr R3, R31 */
		/* 821624E4h case    1:*/		regs.R3 = regs.R31;
		/* 821624E4h case    1:*/		return 0x821624E8;
		  /* 821624E8h */ case    2:  		/* lwz R11, <#[R16]> */
		/* 821624E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821624E8h case    2:*/		return 0x821624EC;
		  /* 821624ECh */ case    3:  		/* add R11, R11, R7 */
		/* 821624ECh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821624ECh case    3:*/		return 0x821624F0;
		  /* 821624F0h */ case    4:  		/* stw R11, <#[R16]> */
		/* 821624F0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821624F0h case    4:*/		return 0x821624F4;
		  /* 821624F4h */ case    5:  		/* addi R1, R1, 288 */
		/* 821624F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 821624F4h case    5:*/		return 0x821624F8;
		  /* 821624F8h */ case    6:  		/* b -856708 */
		/* 821624F8h case    6:*/		return 0x82091274;
		/* 821624F8h case    6:*/		return 0x821624FC;
		  /* 821624FCh */ case    7:  		/* nop */
		/* 821624FCh case    7:*/		cpu::op::nop();
		/* 821624FCh case    7:*/		return 0x82162500;
	}
	return 0x82162500;
} // Block from 821624E0h-82162500h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82162500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162500);
		  /* 82162500h */ case    0:  		/* mfspr R12, LR */
		/* 82162500h case    0:*/		regs.R12 = regs.LR;
		/* 82162500h case    0:*/		return 0x82162504;
		  /* 82162504h */ case    1:  		/* bl -856804 */
		/* 82162504h case    1:*/		regs.LR = 0x82162508; return 0x82091220;
		/* 82162504h case    1:*/		return 0x82162508;
		  /* 82162508h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 82162508h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 82162508h case    2:*/		return 0x8216250C;
		  /* 8216250Ch */ case    3:  		/* lwz R24, <#[R3 + 16]> */
		/* 8216250Ch case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R3 + 0x00000010) );
		/* 8216250Ch case    3:*/		return 0x82162510;
		  /* 82162510h */ case    4:  		/* mr R25, R3 */
		/* 82162510h case    4:*/		regs.R25 = regs.R3;
		/* 82162510h case    4:*/		return 0x82162514;
		  /* 82162514h */ case    5:  		/* mr R23, R4 */
		/* 82162514h case    5:*/		regs.R23 = regs.R4;
		/* 82162514h case    5:*/		return 0x82162518;
		  /* 82162518h */ case    6:  		/* stw R6, <#[R1 + 316]> */
		/* 82162518h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000013C) );
		/* 82162518h case    6:*/		return 0x8216251C;
		  /* 8216251Ch */ case    7:  		/* mr R31, R5 */
		/* 8216251Ch case    7:*/		regs.R31 = regs.R5;
		/* 8216251Ch case    7:*/		return 0x82162520;
		  /* 82162520h */ case    8:  		/* mr R14, R7 */
		/* 82162520h case    8:*/		regs.R14 = regs.R7;
		/* 82162520h case    8:*/		return 0x82162524;
		  /* 82162524h */ case    9:  		/* mr R21, R8 */
		/* 82162524h case    9:*/		regs.R21 = regs.R8;
		/* 82162524h case    9:*/		return 0x82162528;
		  /* 82162528h */ case   10:  		/* mr R20, R9 */
		/* 82162528h case   10:*/		regs.R20 = regs.R9;
		/* 82162528h case   10:*/		return 0x8216252C;
		  /* 8216252Ch */ case   11:  		/* mr R22, R10 */
		/* 8216252Ch case   11:*/		regs.R22 = regs.R10;
		/* 8216252Ch case   11:*/		return 0x82162530;
		  /* 82162530h */ case   12:  		/* cmplwi CR6, R24, 768 */
		/* 82162530h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000300);
		/* 82162530h case   12:*/		return 0x82162534;
		  /* 82162534h */ case   13:  		/* bc 4, CR6_LT, 8 */
		/* 82162534h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8216253C;  }
		/* 82162534h case   13:*/		return 0x82162538;
		  /* 82162538h */ case   14:  		/* bl 1068328 */
		/* 82162538h case   14:*/		regs.LR = 0x8216253C; return 0x82267260;
		/* 82162538h case   14:*/		return 0x8216253C;
	}
	return 0x8216253C;
} // Block from 82162500h-8216253Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216253Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216253C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216253C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216253C);
		  /* 8216253Ch */ case    0:  		/* lwz R28, <#[R31]> */
		/* 8216253Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 8216253Ch case    0:*/		return 0x82162540;
		  /* 82162540h */ case    1:  		/* li R19, 0 */
		/* 82162540h case    1:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82162540h case    1:*/		return 0x82162544;
		  /* 82162544h */ case    2:  		/* addi R30, R31, 4 */
		/* 82162544h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 82162544h case    2:*/		return 0x82162548;
		  /* 82162548h */ case    3:  		/* mr R11, R28 */
		/* 82162548h case    3:*/		regs.R11 = regs.R28;
		/* 82162548h case    3:*/		return 0x8216254C;
		  /* 8216254Ch */ case    4:  		/* mr R27, R19 */
		/* 8216254Ch case    4:*/		regs.R27 = regs.R19;
		/* 8216254Ch case    4:*/		return 0x82162550;
		  /* 82162550h */ case    5:  		/* rlwimi R11, R28, 12, 21, 23 */
		/* 82162550h case    5:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R28);
		/* 82162550h case    5:*/		return 0x82162554;
		  /* 82162554h */ case    6:  		/* mr R15, R28 */
		/* 82162554h case    6:*/		regs.R15 = regs.R28;
		/* 82162554h case    6:*/		return 0x82162558;
		  /* 82162558h */ case    7:  		/* rlwinm. R11, R11, 0, 19, 23 */
		/* 82162558h case    7:*/		cpu::op::rlwinm<1,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82162558h case    7:*/		return 0x8216255C;
		  /* 8216255Ch */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8216255Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82162564;  }
		/* 8216255Ch case    8:*/		return 0x82162560;
		  /* 82162560h */ case    9:  		/* bl 1068288 */
		/* 82162560h case    9:*/		regs.LR = 0x82162564; return 0x82267260;
		/* 82162560h case    9:*/		return 0x82162564;
	}
	return 0x82162564;
} // Block from 8216253Ch-82162564h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82162564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162564);
		  /* 82162564h */ case    0:  		/* rlwinm. R11, R28, 0, 18, 18 */
		/* 82162564h case    0:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R28);
		/* 82162564h case    0:*/		return 0x82162568;
		  /* 82162568h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82162568h case    1:*/		if ( regs.CR[0].eq ) { return 0x82162570;  }
		/* 82162568h case    1:*/		return 0x8216256C;
		  /* 8216256Ch */ case    2:  		/* bl 1068276 */
		/* 8216256Ch case    2:*/		regs.LR = 0x82162570; return 0x82267260;
		/* 8216256Ch case    2:*/		return 0x82162570;
	}
	return 0x82162570;
} // Block from 82162564h-82162570h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82162570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162570);
		  /* 82162570h */ case    0:  		/* mr R18, R19 */
		/* 82162570h case    0:*/		regs.R18 = regs.R19;
		/* 82162570h case    0:*/		return 0x82162574;
		  /* 82162574h */ case    1:  		/* li R16, 33 */
		/* 82162574h case    1:*/		cpu::op::li<0>(regs,&regs.R16,0x21);
		/* 82162574h case    1:*/		return 0x82162578;
		  /* 82162578h */ case    2:  		/* cmpwi CR6, R22, 0 */
		/* 82162578h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82162578h case    2:*/		return 0x8216257C;
		  /* 8216257Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8216257Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82162594;  }
		/* 8216257Ch case    3:*/		return 0x82162580;
		  /* 82162580h */ case    4:  		/* mr R11, R16 */
		/* 82162580h case    4:*/		regs.R11 = regs.R16;
		/* 82162580h case    4:*/		return 0x82162584;
		  /* 82162584h */ case    5:  		/* lwz R18, <#[R30]> */
		/* 82162584h case    5:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R30 + 0x00000000) );
		/* 82162584h case    5:*/		return 0x82162588;
		  /* 82162588h */ case    6:  		/* addi R30, R30, 4 */
		/* 82162588h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82162588h case    6:*/		return 0x8216258C;
		  /* 8216258Ch */ case    7:  		/* rlwimi R28, R11, 0, 19, 31 */
		/* 8216258Ch case    7:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R28,regs.R11);
		/* 8216258Ch case    7:*/		return 0x82162590;
		  /* 82162590h */ case    8:  		/* rlwimi R28, R16, 0, 1, 3 */
		/* 82162590h case    8:*/		cpu::op::rlwimi<0,0,1,3>(regs,&regs.R28,regs.R16);
		/* 82162590h case    8:*/		return 0x82162594;
	}
	return 0x82162594;
} // Block from 82162570h-82162594h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82162594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162594);
		  /* 82162594h */ case    0:  		/* mr R29, R19 */
		/* 82162594h case    0:*/		regs.R29 = regs.R19;
		/* 82162594h case    0:*/		return 0x82162598;
		  /* 82162598h */ case    1:  		/* mr R31, R19 */
		/* 82162598h case    1:*/		regs.R31 = regs.R19;
		/* 82162598h case    1:*/		return 0x8216259C;
		  /* 8216259Ch */ case    2:  		/* addi R30, R30, -4 */
		/* 8216259Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFC);
		/* 8216259Ch case    2:*/		return 0x821625A0;
		  /* 821625A0h */ case    3:  		/* lwz R10, <#[R30 + 4]> */
		/* 821625A0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 821625A0h case    3:*/		return 0x821625A4;
		  /* 821625A4h */ case    4:  		/* rlwinm. R11, R10, 0, 0, 0 */
		/* 821625A4h case    4:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R10);
		/* 821625A4h case    4:*/		return 0x821625A8;
		  /* 821625A8h */ case    5:  		/* addi R11, R1, 112 */
		/* 821625A8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 821625A8h case    5:*/		return 0x821625AC;
		  /* 821625ACh */ case    6:  		/* bc 12, CR0_EQ, 92 */
		/* 821625ACh case    6:*/		if ( regs.CR[0].eq ) { return 0x82162608;  }
		/* 821625ACh case    6:*/		return 0x821625B0;
		  /* 821625B0h */ case    7:  		/* stwx R10, <#[R31 + R11]> */
		/* 821625B0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821625B0h case    7:*/		return 0x821625B4;
		  /* 821625B4h */ case    8:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 821625B4h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 821625B4h case    8:*/		return 0x821625B8;
		  /* 821625B8h */ case    9:  		/* addi R30, R30, 4 */
		/* 821625B8h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821625B8h case    9:*/		return 0x821625BC;
		  /* 821625BCh */ case   10:  		/* rlwinm R10, R11, 0, 18, 18 */
		/* 821625BCh case   10:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R10,regs.R11);
		/* 821625BCh case   10:*/		return 0x821625C0;
		  /* 821625C0h */ case   11:  		/* cmplwi CR6, R10, 8192 */
		/* 821625C0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002000);
		/* 821625C0h case   11:*/		return 0x821625C4;
		  /* 821625C4h */ case   12:  		/* bc 4, CR6_EQ, 60 */
		/* 821625C4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82162600;  }
		/* 821625C4h case   12:*/		return 0x821625C8;
		  /* 821625C8h */ case   13:  		/* rlwimi R11, R11, 12, 21, 23 */
		/* 821625C8h case   13:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R11);
		/* 821625C8h case   13:*/		return 0x821625CC;
		  /* 821625CCh */ case   14:  		/* rlwinm R11, R11, 24, 27, 31 */
		/* 821625CCh case   14:*/		cpu::op::rlwinm<0,24,27,31>(regs,&regs.R11,regs.R11);
		/* 821625CCh case   14:*/		return 0x821625D0;
		  /* 821625D0h */ case   15:  		/* cmplwi CR6, R11, 2 */
		/* 821625D0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821625D0h case   15:*/		return 0x821625D4;
		  /* 821625D4h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 821625D4h case   16:*/		if ( regs.CR[6].eq ) { return 0x821625E0;  }
		/* 821625D4h case   16:*/		return 0x821625D8;
		  /* 821625D8h */ case   17:  		/* cmplwi CR6, R11, 1 */
		/* 821625D8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821625D8h case   17:*/		return 0x821625DC;
		  /* 821625DCh */ case   18:  		/* bc 4, CR6_EQ, 36 */
		/* 821625DCh case   18:*/		if ( !regs.CR[6].eq ) { return 0x82162600;  }
		/* 821625DCh case   18:*/		return 0x821625E0;
	}
	return 0x821625E0;
} // Block from 82162594h-821625E0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821625E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821625E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821625E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821625E0);
		  /* 821625E0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 821625E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821625E0h case    0:*/		return 0x821625E4;
		  /* 821625E4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 821625E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821625EC;  }
		/* 821625E4h case    1:*/		return 0x821625E8;
		  /* 821625E8h */ case    2:  		/* bl 1068152 */
		/* 821625E8h case    2:*/		regs.LR = 0x821625EC; return 0x82267260;
		/* 821625E8h case    2:*/		return 0x821625EC;
	}
	return 0x821625EC;
} // Block from 821625E0h-821625ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821625ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821625EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821625EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821625EC);
		  /* 821625ECh */ case    0:  		/* lwzu R11, <#[R30 + 4]> */
		/* 821625ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 821625ECh case    0:*/		return 0x821625F0;
		  /* 821625F0h */ case    1:  		/* addi R10, R1, 104 */
		/* 821625F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 821625F0h case    1:*/		return 0x821625F4;
		  /* 821625F4h */ case    2:  		/* addi R27, R27, 1 */
		/* 821625F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821625F4h case    2:*/		return 0x821625F8;
		  /* 821625F8h */ case    3:  		/* stwx R11, <#[R31 + R10]> */
		/* 821625F8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 821625F8h case    3:*/		return 0x821625FC;
		  /* 821625FCh */ case    4:  		/* b 24 */
		/* 821625FCh case    4:*/		return 0x82162614;
		/* 821625FCh case    4:*/		return 0x82162600;
	}
	return 0x82162600;
} // Block from 821625ECh-82162600h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82162600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162600);
		  /* 82162600h */ case    0:  		/* addi R11, R1, 104 */
		/* 82162600h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x68);
		/* 82162600h case    0:*/		return 0x82162604;
		  /* 82162604h */ case    1:  		/* b 12 */
		/* 82162604h case    1:*/		return 0x82162610;
		/* 82162604h case    1:*/		return 0x82162608;
	}
	return 0x82162608;
} // Block from 82162600h-82162608h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162608);
		  /* 82162608h */ case    0:  		/* addi R10, R1, 104 */
		/* 82162608h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 82162608h case    0:*/		return 0x8216260C;
		  /* 8216260Ch */ case    1:  		/* stwx R19, <#[R31 + R10]> */
		/* 8216260Ch case    1:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8216260Ch case    1:*/		return 0x82162610;
	}
	return 0x82162610;
} // Block from 82162608h-82162610h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162610);
		  /* 82162610h */ case    0:  		/* stwx R19, <#[R31 + R11]> */
		/* 82162610h case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82162610h case    0:*/		return 0x82162614;
	}
	return 0x82162614;
} // Block from 82162610h-82162614h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162614);
		  /* 82162614h */ case    0:  		/* addi R31, R31, 4 */
		/* 82162614h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82162614h case    0:*/		return 0x82162618;
		  /* 82162618h */ case    1:  		/* addi R29, R29, 1 */
		/* 82162618h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82162618h case    1:*/		return 0x8216261C;
		  /* 8216261Ch */ case    2:  		/* cmplwi CR6, R31, 8 */
		/* 8216261Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000008);
		/* 8216261Ch case    2:*/		return 0x82162620;
		  /* 82162620h */ case    3:  		/* bc 12, CR6_LT, -128 */
		/* 82162620h case    3:*/		if ( regs.CR[6].lt ) { return 0x821625A0;  }
		/* 82162620h case    3:*/		return 0x82162624;
		  /* 82162624h */ case    4:  		/* lwz R31, <#[R1 + 116]> */
		/* 82162624h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000074) );
		/* 82162624h case    4:*/		return 0x82162628;
		  /* 82162628h */ case    5:  		/* addi R17, R27, 3 */
		/* 82162628h case    5:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R27,0x3);
		/* 82162628h case    5:*/		return 0x8216262C;
		  /* 8216262Ch */ case    6:  		/* mr R11, R31 */
		/* 8216262Ch case    6:*/		regs.R11 = regs.R31;
		/* 8216262Ch case    6:*/		return 0x82162630;
		  /* 82162630h */ case    7:  		/* rlwimi R11, R31, 12, 21, 23 */
		/* 82162630h case    7:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R11,regs.R31);
		/* 82162630h case    7:*/		return 0x82162634;
		  /* 82162634h */ case    8:  		/* rlwinm R11, R11, 0, 19, 23 */
		/* 82162634h case    8:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R11);
		/* 82162634h case    8:*/		return 0x82162638;
		  /* 82162638h */ case    9:  		/* cmplwi CR6, R11, 2560 */
		/* 82162638h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000A00);
		/* 82162638h case    9:*/		return 0x8216263C;
		  /* 8216263Ch */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 8216263Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82162644;  }
		/* 8216263Ch case   10:*/		return 0x82162640;
		  /* 82162640h */ case   11:  		/* bl 1068064 */
		/* 82162640h case   11:*/		regs.LR = 0x82162644; return 0x82267260;
		/* 82162640h case   11:*/		return 0x82162644;
	}
	return 0x82162644;
} // Block from 82162614h-82162644h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82162644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162644);
		  /* 82162644h */ case    0:  		/* lis R11, 2560 */
		/* 82162644h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xA00);
		/* 82162644h case    0:*/		return 0x82162648;
		  /* 82162648h */ case    1:  		/* addi R10, R31, 16 */
		/* 82162648h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x10);
		/* 82162648h case    1:*/		return 0x8216264C;
		  /* 8216264Ch */ case    2:  		/* ori R11, R11, 94 */
		/* 8216264Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x5E);
		/* 8216264Ch case    2:*/		return 0x82162650;
		  /* 82162650h */ case    3:  		/* lis R26, 228 */
		/* 82162650h case    3:*/		cpu::op::lis<0>(regs,&regs.R26,0xE4);
		/* 82162650h case    3:*/		return 0x82162654;
		  /* 82162654h */ case    4:  		/* li R27, 1 */
		/* 82162654h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82162654h case    4:*/		return 0x82162658;
		  /* 82162658h */ case    5:  		/* rlwinm R29, R31, 0, 8, 15 */
		/* 82162658h case    5:*/		cpu::op::rlwinm<0,0,8,15>(regs,&regs.R29,regs.R31);
		/* 82162658h case    5:*/		return 0x8216265C;
		  /* 8216265Ch */ case    6:  		/* rlwimi R11, R10, 16, 8, 15 */
		/* 8216265Ch case    6:*/		cpu::op::rlwimi<0,16,8,15>(regs,&regs.R11,regs.R10);
		/* 8216265Ch case    6:*/		return 0x82162660;
		  /* 82162660h */ case    7:  		/* stw R27, <#[R1 + 96]> */
		/* 82162660h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 82162660h case    7:*/		return 0x82162664;
		  /* 82162664h */ case    8:  		/* addi R3, R23, 4 */
		/* 82162664h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R23,0x4);
		/* 82162664h case    8:*/		return 0x82162668;
		  /* 82162668h */ case    9:  		/* stw R11, <#[R23]> */
		/* 82162668h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82162668h case    9:*/		return 0x8216266C;
		  /* 8216266Ch */ case   10:  		/* cmplw CR6, R29, R26 */
		/* 8216266Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R26);
		/* 8216266Ch case   10:*/		return 0x82162670;
		  /* 82162670h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 82162670h case   11:*/		if ( regs.CR[6].eq ) { return 0x82162688;  }
		/* 82162670h case   11:*/		return 0x82162674;
		  /* 82162674h */ case   12:  		/* oris R28, R28, 15 */
		/* 82162674h case   12:*/		cpu::op::oris<0>(regs,&regs.R28,regs.R28,0xF);
		/* 82162674h case   12:*/		return 0x82162678;
		  /* 82162678h */ case   13:  		/* cmpwi CR6, R22, 0 */
		/* 82162678h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82162678h case   13:*/		return 0x8216267C;
		  /* 8216267Ch */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 8216267Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x82162688;  }
		/* 8216267Ch case   14:*/		return 0x82162680;
		  /* 82162680h */ case   15:  		/* rlwimi R28, R16, 0, 19, 31 */
		/* 82162680h case   15:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R28,regs.R16);
		/* 82162680h case   15:*/		return 0x82162684;
		  /* 82162684h */ case   16:  		/* rlwimi R28, R16, 0, 1, 3 */
		/* 82162684h case   16:*/		cpu::op::rlwimi<0,0,1,3>(regs,&regs.R28,regs.R16);
		/* 82162684h case   16:*/		return 0x82162688;
	}
	return 0x82162688;
} // Block from 82162644h-82162688h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82162688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162688);
		  /* 82162688h */ case    0:  		/* mr R7, R25 */
		/* 82162688h case    0:*/		regs.R7 = regs.R25;
		/* 82162688h case    0:*/		return 0x8216268C;
		  /* 8216268Ch */ case    1:  		/* addi R6, R1, 96 */
		/* 8216268Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 8216268Ch case    1:*/		return 0x82162690;
		  /* 82162690h */ case    2:  		/* li R5, 0 */
		/* 82162690h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82162690h case    2:*/		return 0x82162694;
		  /* 82162694h */ case    3:  		/* mr R4, R28 */
		/* 82162694h case    3:*/		regs.R4 = regs.R28;
		/* 82162694h case    3:*/		return 0x82162698;
		  /* 82162698h */ case    4:  		/* bl -6280 */
		/* 82162698h case    4:*/		regs.LR = 0x8216269C; return 0x82160E10;
		/* 82162698h case    4:*/		return 0x8216269C;
		  /* 8216269Ch */ case    5:  		/* lwz R31, <#[R1 + 104]> */
		/* 8216269Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000068) );
		/* 8216269Ch case    5:*/		return 0x821626A0;
		  /* 821626A0h */ case    6:  		/* lwz R30, <#[R1 + 112]> */
		/* 821626A0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000070) );
		/* 821626A0h case    6:*/		return 0x821626A4;
		  /* 821626A4h */ case    7:  		/* addi R11, R1, 96 */
		/* 821626A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821626A4h case    7:*/		return 0x821626A8;
		  /* 821626A8h */ case    8:  		/* mr R10, R24 */
		/* 821626A8h case    8:*/		regs.R10 = regs.R24;
		/* 821626A8h case    8:*/		return 0x821626AC;
		  /* 821626ACh */ case    9:  		/* li R9, 0 */
		/* 821626ACh case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821626ACh case    9:*/		return 0x821626B0;
		  /* 821626B0h */ case   10:  		/* stw R11, <#[R1 + 84]> */
		/* 821626B0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821626B0h case   10:*/		return 0x821626B4;
		  /* 821626B4h */ case   11:  		/* li R8, 94 */
		/* 821626B4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x5E);
		/* 821626B4h case   11:*/		return 0x821626B8;
		  /* 821626B8h */ case   12:  		/* mr R7, R20 */
		/* 821626B8h case   12:*/		regs.R7 = regs.R20;
		/* 821626B8h case   12:*/		return 0x821626BC;
		  /* 821626BCh */ case   13:  		/* mr R6, R21 */
		/* 821626BCh case   13:*/		regs.R6 = regs.R21;
		/* 821626BCh case   13:*/		return 0x821626C0;
		  /* 821626C0h */ case   14:  		/* mr R5, R31 */
		/* 821626C0h case   14:*/		regs.R5 = regs.R31;
		/* 821626C0h case   14:*/		return 0x821626C4;
		  /* 821626C4h */ case   15:  		/* mr R4, R30 */
		/* 821626C4h case   15:*/		regs.R4 = regs.R30;
		/* 821626C4h case   15:*/		return 0x821626C8;
		  /* 821626C8h */ case   16:  		/* bl -4928 */
		/* 821626C8h case   16:*/		regs.LR = 0x821626CC; return 0x82161388;
		/* 821626C8h case   16:*/		return 0x821626CC;
		  /* 821626CCh */ case   17:  		/* addi R11, R1, 96 */
		/* 821626CCh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821626CCh case   17:*/		return 0x821626D0;
		  /* 821626D0h */ case   18:  		/* mr R10, R24 */
		/* 821626D0h case   18:*/		regs.R10 = regs.R24;
		/* 821626D0h case   18:*/		return 0x821626D4;
		  /* 821626D4h */ case   19:  		/* li R9, 0 */
		/* 821626D4h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821626D4h case   19:*/		return 0x821626D8;
		  /* 821626D8h */ case   20:  		/* stw R11, <#[R1 + 84]> */
		/* 821626D8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821626D8h case   20:*/		return 0x821626DC;
		  /* 821626DCh */ case   21:  		/* li R8, 94 */
		/* 821626DCh case   21:*/		cpu::op::li<0>(regs,&regs.R8,0x5E);
		/* 821626DCh case   21:*/		return 0x821626E0;
		  /* 821626E0h */ case   22:  		/* mr R7, R20 */
		/* 821626E0h case   22:*/		regs.R7 = regs.R20;
		/* 821626E0h case   22:*/		return 0x821626E4;
		  /* 821626E4h */ case   23:  		/* mr R6, R21 */
		/* 821626E4h case   23:*/		regs.R6 = regs.R21;
		/* 821626E4h case   23:*/		return 0x821626E8;
		  /* 821626E8h */ case   24:  		/* mr R5, R31 */
		/* 821626E8h case   24:*/		regs.R5 = regs.R31;
		/* 821626E8h case   24:*/		return 0x821626EC;
		  /* 821626ECh */ case   25:  		/* mr R4, R30 */
		/* 821626ECh case   25:*/		regs.R4 = regs.R30;
		/* 821626ECh case   25:*/		return 0x821626F0;
		  /* 821626F0h */ case   26:  		/* bl -4968 */
		/* 821626F0h case   26:*/		regs.LR = 0x821626F4; return 0x82161388;
		/* 821626F0h case   26:*/		return 0x821626F4;
		  /* 821626F4h */ case   27:  		/* cmpwi CR6, R22, 0 */
		/* 821626F4h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 821626F4h case   27:*/		return 0x821626F8;
		  /* 821626F8h */ case   28:  		/* bc 12, CR6_EQ, 52 */
		/* 821626F8h case   28:*/		if ( regs.CR[6].eq ) { return 0x8216272C;  }
		/* 821626F8h case   28:*/		return 0x821626FC;
		  /* 821626FCh */ case   29:  		/* stw R19, <#[R1 + 104]> */
		/* 821626FCh case   29:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000068) );
		/* 821626FCh case   29:*/		return 0x82162700;
		  /* 82162700h */ case   30:  		/* mr R9, R25 */
		/* 82162700h case   30:*/		regs.R9 = regs.R25;
		/* 82162700h case   30:*/		return 0x82162704;
		  /* 82162704h */ case   31:  		/* addi R8, R1, 104 */
		/* 82162704h case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x68);
		/* 82162704h case   31:*/		return 0x82162708;
		  /* 82162708h */ case   32:  		/* mr R7, R29 */
		/* 82162708h case   32:*/		regs.R7 = regs.R29;
		/* 82162708h case   32:*/		return 0x8216270C;
		  /* 8216270Ch */ case   33:  		/* mr R6, R18 */
		/* 8216270Ch case   33:*/		regs.R6 = regs.R18;
		/* 8216270Ch case   33:*/		return 0x82162710;
		  /* 82162710h */ case   34:  		/* li R5, 0 */
		/* 82162710h case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82162710h case   34:*/		return 0x82162714;
		  /* 82162714h */ case   35:  		/* mr R4, R15 */
		/* 82162714h case   35:*/		regs.R4 = regs.R15;
		/* 82162714h case   35:*/		return 0x82162718;
		  /* 82162718h */ case   36:  		/* bl -3976 */
		/* 82162718h case   36:*/		regs.LR = 0x8216271C; return 0x82161790;
		/* 82162718h case   36:*/		return 0x8216271C;
		  /* 8216271Ch */ case   37:  		/* lwz R11, <#[R1 + 104]> */
		/* 8216271Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8216271Ch case   37:*/		return 0x82162720;
		  /* 82162720h */ case   38:  		/* lwz R10, <#[R1 + 96]> */
		/* 82162720h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82162720h case   38:*/		return 0x82162724;
		  /* 82162724h */ case   39:  		/* add R11, R10, R11 */
		/* 82162724h case   39:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82162724h case   39:*/		return 0x82162728;
		  /* 82162728h */ case   40:  		/* b 96 */
		/* 82162728h case   40:*/		return 0x82162788;
		/* 82162728h case   40:*/		return 0x8216272C;
	}
	return 0x8216272C;
} // Block from 82162688h-8216272Ch (41 instructions)

//////////////////////////////////////////////////////
// Block at 8216272Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216272C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216272C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216272C);
		  /* 8216272Ch */ case    0:  		/* cmplw CR6, R29, R26 */
		/* 8216272Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R26);
		/* 8216272Ch case    0:*/		return 0x82162730;
		  /* 82162730h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 82162730h case    1:*/		if ( regs.CR[6].eq ) { return 0x82162784;  }
		/* 82162730h case    1:*/		return 0x82162734;
		  /* 82162734h */ case    2:  		/* li R11, 71 */
		/* 82162734h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x47);
		/* 82162734h case    2:*/		return 0x82162738;
		  /* 82162738h */ case    3:  		/* stw R27, <#[R1 + 104]> */
		/* 82162738h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 82162738h case    3:*/		return 0x8216273C;
		  /* 8216273Ch */ case    4:  		/* mr R7, R25 */
		/* 8216273Ch case    4:*/		regs.R7 = regs.R25;
		/* 8216273Ch case    4:*/		return 0x82162740;
		  /* 82162740h */ case    5:  		/* stw R11, <#[R3]> */
		/* 82162740h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82162740h case    5:*/		return 0x82162744;
		  /* 82162744h */ case    6:  		/* addi R6, R1, 104 */
		/* 82162744h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 82162744h case    6:*/		return 0x82162748;
		  /* 82162748h */ case    7:  		/* li R5, 0 */
		/* 82162748h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82162748h case    7:*/		return 0x8216274C;
		  /* 8216274Ch */ case    8:  		/* mr R4, R15 */
		/* 8216274Ch case    8:*/		regs.R4 = regs.R15;
		/* 8216274Ch case    8:*/		return 0x82162750;
		  /* 82162750h */ case    9:  		/* addi R3, R3, 4 */
		/* 82162750h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82162750h case    9:*/		return 0x82162754;
		  /* 82162754h */ case   10:  		/* bl -6468 */
		/* 82162754h case   10:*/		regs.LR = 0x82162758; return 0x82160E10;
		/* 82162754h case   10:*/		return 0x82162758;
		  /* 82162758h */ case   11:  		/* mr R7, R3 */
		/* 82162758h case   11:*/		regs.R7 = regs.R3;
		/* 82162758h case   11:*/		return 0x8216275C;
		  /* 8216275Ch */ case   12:  		/* lis R11, 68 */
		/* 8216275Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0x44);
		/* 8216275Ch case   12:*/		return 0x82162760;
		  /* 82162760h */ case   13:  		/* mr R3, R29 */
		/* 82162760h case   13:*/		regs.R3 = regs.R29;
		/* 82162760h case   13:*/		return 0x82162764;
		  /* 82162764h */ case   14:  		/* ori R11, R11, 33 */
		/* 82162764h case   14:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x21);
		/* 82162764h case   14:*/		return 0x82162768;
		  /* 82162768h */ case   15:  		/* stw R11, <#[R7]> */
		/* 82162768h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82162768h case   15:*/		return 0x8216276C;
		  /* 8216276Ch */ case   16:  		/* bl -5492 */
		/* 8216276Ch case   16:*/		regs.LR = 0x82162770; return 0x821611F8;
		/* 8216276Ch case   16:*/		return 0x82162770;
		  /* 82162770h */ case   17:  		/* lwz R11, <#[R1 + 104]> */
		/* 82162770h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82162770h case   17:*/		return 0x82162774;
		  /* 82162774h */ case   18:  		/* stwu R3, <#[R7 + 4]> */
		/* 82162774h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82162774h case   18:*/		return 0x82162778;
		  /* 82162778h */ case   19:  		/* addi R11, R11, 2 */
		/* 82162778h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82162778h case   19:*/		return 0x8216277C;
		  /* 8216277Ch */ case   20:  		/* addi R3, R7, 4 */
		/* 8216277Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R7,0x4);
		/* 8216277Ch case   20:*/		return 0x82162780;
		  /* 82162780h */ case   21:  		/* b -96 */
		/* 82162780h case   21:*/		return 0x82162720;
		/* 82162780h case   21:*/		return 0x82162784;
	}
	return 0x82162784;
} // Block from 8216272Ch-82162784h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82162784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162784);
		  /* 82162784h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82162784h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82162784h case    0:*/		return 0x82162788;
	}
	return 0x82162788;
} // Block from 82162784h-82162788h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162788);
		  /* 82162788h */ case    0:  		/* lwz R10, <#[R1 + 316]> */
		/* 82162788h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000013C) );
		/* 82162788h case    0:*/		return 0x8216278C;
		  /* 8216278Ch */ case    1:  		/* stw R17, <#[R10]> */
		/* 8216278Ch case    1:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R10 + 0x00000000) );
		/* 8216278Ch case    1:*/		return 0x82162790;
		  /* 82162790h */ case    2:  		/* lwz R10, <#[R14]> */
		/* 82162790h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 82162790h case    2:*/		return 0x82162794;
		  /* 82162794h */ case    3:  		/* add R11, R10, R11 */
		/* 82162794h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82162794h case    3:*/		return 0x82162798;
		  /* 82162798h */ case    4:  		/* stw R11, <#[R14]> */
		/* 82162798h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82162798h case    4:*/		return 0x8216279C;
		  /* 8216279Ch */ case    5:  		/* addi R1, R1, 272 */
		/* 8216279Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8216279Ch case    5:*/		return 0x821627A0;
		  /* 821627A0h */ case    6:  		/* b -857392 */
		/* 821627A0h case    6:*/		return 0x82091270;
		/* 821627A0h case    6:*/		return 0x821627A4;
		  /* 821627A4h */ case    7:  		/* nop */
		/* 821627A4h case    7:*/		cpu::op::nop();
		/* 821627A4h case    7:*/		return 0x821627A8;
	}
	return 0x821627A8;
} // Block from 82162788h-821627A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821627A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821627A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821627A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821627A8);
		  /* 821627A8h */ case    0:  		/* mfspr R12, LR */
		/* 821627A8h case    0:*/		regs.R12 = regs.LR;
		/* 821627A8h case    0:*/		return 0x821627AC;
		  /* 821627ACh */ case    1:  		/* bl -857484 */
		/* 821627ACh case    1:*/		regs.LR = 0x821627B0; return 0x82091220;
		/* 821627ACh case    1:*/		return 0x821627B0;
		  /* 821627B0h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 821627B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 821627B0h case    2:*/		return 0x821627B4;
		  /* 821627B4h */ case    3:  		/* li R19, 0 */
		/* 821627B4h case    3:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 821627B4h case    3:*/		return 0x821627B8;
		  /* 821627B8h */ case    4:  		/* lwz R17, <#[R7 + 16]> */
		/* 821627B8h case    4:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R7 + 0x00000010) );
		/* 821627B8h case    4:*/		return 0x821627BC;
		  /* 821627BCh */ case    5:  		/* mr R15, R10 */
		/* 821627BCh case    5:*/		regs.R15 = regs.R10;
		/* 821627BCh case    5:*/		return 0x821627C0;
		  /* 821627C0h */ case    6:  		/* lwz R10, <#[R7 + 28]> */
		/* 821627C0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000001C) );
		/* 821627C0h case    6:*/		return 0x821627C4;
		  /* 821627C4h */ case    7:  		/* stw R19, <#[R7 + 1600]> */
		/* 821627C4h case    7:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R7 + 0x00000640) );
		/* 821627C4h case    7:*/		return 0x821627C8;
		  /* 821627C8h */ case    8:  		/* mr R14, R4 */
		/* 821627C8h case    8:*/		regs.R14 = regs.R4;
		/* 821627C8h case    8:*/		return 0x821627CC;
		  /* 821627CCh */ case    9:  		/* lwz R11, <#[R8]> */
		/* 821627CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821627CCh case    9:*/		return 0x821627D0;
		  /* 821627D0h */ case   10:  		/* mr R20, R6 */
		/* 821627D0h case   10:*/		regs.R20 = regs.R6;
		/* 821627D0h case   10:*/		return 0x821627D4;
		  /* 821627D4h */ case   11:  		/* stw R5, <#[R1 + 308]> */
		/* 821627D4h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000134) );
		/* 821627D4h case   11:*/		return 0x821627D8;
		  /* 821627D8h */ case   12:  		/* mr R23, R7 */
		/* 821627D8h case   12:*/		regs.R23 = regs.R7;
		/* 821627D8h case   12:*/		return 0x821627DC;
		  /* 821627DCh */ case   13:  		/* mr R16, R8 */
		/* 821627DCh case   13:*/		regs.R16 = regs.R8;
		/* 821627DCh case   13:*/		return 0x821627E0;
		  /* 821627E0h */ case   14:  		/* stw R9, <#[R1 + 340]> */
		/* 821627E0h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000154) );
		/* 821627E0h case   14:*/		return 0x821627E4;
		  /* 821627E4h */ case   15:  		/* mr R27, R9 */
		/* 821627E4h case   15:*/		regs.R27 = regs.R9;
		/* 821627E4h case   15:*/		return 0x821627E8;
		  /* 821627E8h */ case   16:  		/* stw R19, <#[R1 + 96]> */
		/* 821627E8h case   16:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000060) );
		/* 821627E8h case   16:*/		return 0x821627EC;
		  /* 821627ECh */ case   17:  		/* addi R28, R4, 4 */
		/* 821627ECh case   17:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R4,0x4);
		/* 821627ECh case   17:*/		return 0x821627F0;
		  /* 821627F0h */ case   18:  		/* stw R19, <#[R1 + 100]> */
		/* 821627F0h case   18:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000064) );
		/* 821627F0h case   18:*/		return 0x821627F4;
		  /* 821627F4h */ case   19:  		/* mr R29, R19 */
		/* 821627F4h case   19:*/		regs.R29 = regs.R19;
		/* 821627F4h case   19:*/		return 0x821627F8;
		  /* 821627F8h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 821627F8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821627F8h case   20:*/		return 0x821627FC;
		  /* 821627FCh */ case   21:  		/* bc 4, CR6_EQ, 36 */
		/* 821627FCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x82162820;  }
		/* 821627FCh case   21:*/		return 0x82162800;
		  /* 82162800h */ case   22:  		/* li R9, 256 */
		/* 82162800h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x100);
		/* 82162800h case   22:*/		return 0x82162804;
		  /* 82162804h */ case   23:  		/* addi R11, R10, 4 */
		/* 82162804h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 82162804h case   23:*/		return 0x82162808;
		  /* 82162808h */ case   24:  		/* li R29, 2 */
		/* 82162808h case   24:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 82162808h case   24:*/		return 0x8216280C;
		  /* 8216280Ch */ case   25:  		/* stw R9, <#[R10]> */
		/* 8216280Ch case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216280Ch case   25:*/		return 0x82162810;
		  /* 82162810h */ case   26:  		/* stw R9, <#[R10 + 4]> */
		/* 82162810h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82162810h case   26:*/		return 0x82162814;
		  /* 82162814h */ case   27:  		/* addi R24, R11, 4 */
		/* 82162814h case   27:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x4);
		/* 82162814h case   27:*/		return 0x82162818;
		  /* 82162818h */ case   28:  		/* stw R29, <#[R1 + 96]> */
		/* 82162818h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82162818h case   28:*/		return 0x8216281C;
		  /* 8216281Ch */ case   29:  		/* b 12 */
		/* 8216281Ch case   29:*/		return 0x82162828;
		/* 8216281Ch case   29:*/		return 0x82162820;
	}
	return 0x82162820;
} // Block from 821627A8h-82162820h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82162820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162820);
		  /* 82162820h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82162820h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82162820h case    0:*/		return 0x82162824;
		  /* 82162824h */ case    1:  		/* add R24, R11, R10 */
		/* 82162824h case    1:*/		cpu::op::add<0>(regs,&regs.R24,regs.R11,regs.R10);
		/* 82162824h case    1:*/		return 0x82162828;
	}
	return 0x82162828;
} // Block from 82162820h-82162828h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162828);
		  /* 82162828h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 82162828h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 82162828h case    0:*/		return 0x8216282C;
		  /* 8216282Ch */ case    1:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 8216282Ch case    1:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 8216282Ch case    1:*/		return 0x82162830;
		  /* 82162830h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 82162830h case    2:*/		if ( regs.CR[0].eq ) { return 0x82162844;  }
		/* 82162830h case    2:*/		return 0x82162834;
		  /* 82162834h */ case    3:  		/* lwz R11, <#[R23 + 1580]> */
		/* 82162834h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000062C) );
		/* 82162834h case    3:*/		return 0x82162838;
		  /* 82162838h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82162838h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82162838h case    4:*/		return 0x8216283C;
		  /* 8216283Ch */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 8216283Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82162844;  }
		/* 8216283Ch case    5:*/		return 0x82162840;
		  /* 82162840h */ case    6:  		/* stw R19, <#[R11]> */
		/* 82162840h case    6:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 82162840h case    6:*/		return 0x82162844;
	}
	return 0x82162844;
} // Block from 82162828h-82162844h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82162844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162844);
		  /* 82162844h */ case    0:  		/* cmplwi CR6, R17, 768 */
		/* 82162844h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000300);
		/* 82162844h case    0:*/		return 0x82162848;
		  /* 82162848h */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 82162848h case    1:*/		if ( regs.CR[6].lt ) { return 0x82162864;  }
		/* 82162848h case    1:*/		return 0x8216284C;
		  /* 8216284Ch */ case    2:  		/* li R5, 256 */
		/* 8216284Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x100);
		/* 8216284Ch case    2:*/		return 0x82162850;
		  /* 82162850h */ case    3:  		/* li R4, 0 */
		/* 82162850h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82162850h case    3:*/		return 0x82162854;
		  /* 82162854h */ case    4:  		/* addi R3, R23, 1604 */
		/* 82162854h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R23,0x644);
		/* 82162854h case    4:*/		return 0x82162858;
		  /* 82162858h */ case    5:  		/* mr R18, R19 */
		/* 82162858h case    5:*/		regs.R18 = regs.R19;
		/* 82162858h case    5:*/		return 0x8216285C;
		  /* 8216285Ch */ case    6:  		/* bl -857372 */
		/* 8216285Ch case    6:*/		regs.LR = 0x82162860; return 0x82091340;
		/* 8216285Ch case    6:*/		return 0x82162860;
		  /* 82162860h */ case    7:  		/* b 8 */
		/* 82162860h case    7:*/		return 0x82162868;
		/* 82162860h case    7:*/		return 0x82162864;
	}
	return 0x82162864;
} // Block from 82162844h-82162864h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82162864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162864);
		  /* 82162864h */ case    0:  		/* lwz R18, <#[R1 + 104]> */
		/* 82162864h case    0:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 82162864h case    0:*/		return 0x82162868;
	}
	return 0x82162868;
} // Block from 82162864h-82162868h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162868);
		  /* 82162868h */ case    0:  		/* lwz R4, <#[R28]> */
		/* 82162868h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 82162868h case    0:*/		return 0x8216286C;
		  /* 8216286Ch */ case    1:  		/* cmplwi CR6, R4, 65535 */
		/* 8216286Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000FFFF);
		/* 8216286Ch case    1:*/		return 0x82162870;
		  /* 82162870h */ case    2:  		/* bc 12, CR6_EQ, 1436 */
		/* 82162870h case    2:*/		if ( regs.CR[6].eq ) { return 0x82162E0C;  }
		/* 82162870h case    2:*/		return 0x82162874;
		  /* 82162874h */ case    3:  		/* addi R11, R18, 400 */
		/* 82162874h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R18,0x190);
		/* 82162874h case    3:*/		return 0x82162878;
		  /* 82162878h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82162878h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82162878h case    4:*/		return 0x8216287C;
		  /* 8216287Ch */ case    5:  		/* add R21, R11, R23 */
		/* 8216287Ch case    5:*/		cpu::op::add<0>(regs,&regs.R21,regs.R11,regs.R23);
		/* 8216287Ch case    5:*/		return 0x82162880;
		  /* 82162880h */ case    6:  		/* lwz R11, <#[R16]> */
		/* 82162880h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82162880h case    6:*/		return 0x82162884;
		  /* 82162884h */ case    7:  		/* add R11, R11, R29 */
		/* 82162884h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82162884h case    7:*/		return 0x82162888;
		  /* 82162888h */ case    8:  		/* cmplw CR6, R11, R15 */
		/* 82162888h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 82162888h case    8:*/		return 0x8216288C;
		  /* 8216288Ch */ case    9:  		/* bc 4, CR6_LT, 1600 */
		/* 8216288Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82162ECC;  }
		/* 8216288Ch case    9:*/		return 0x82162890;
		  /* 82162890h */ case   10:  		/* rlwinm R11, R4, 0, 16, 31 */
		/* 82162890h case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R4);
		/* 82162890h case   10:*/		return 0x82162894;
		  /* 82162894h */ case   11:  		/* addi R28, R28, 4 */
		/* 82162894h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82162894h case   11:*/		return 0x82162898;
		  /* 82162898h */ case   12:  		/* rlwinm R22, R4, 0, 3, 3 */
		/* 82162898h case   12:*/		cpu::op::rlwinm<0,0,3,3>(regs,&regs.R22,regs.R4);
		/* 82162898h case   12:*/		return 0x8216289C;
		  /* 8216289Ch */ case   13:  		/* cmplwi CR6, R11, 65534 */
		/* 8216289Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000FFFE);
		/* 8216289Ch case   13:*/		return 0x821628A0;
		  /* 821628A0h */ case   14:  		/* bc 12, CR6_GT, 1372 */
		/* 821628A0h case   14:*/		if ( regs.CR[6].gt ) { return 0x82162DFC;  }
		/* 821628A0h case   14:*/		return 0x821628A4;
		  /* 821628A4h */ case   15:  		/* bc 12, CR6_EQ, 1128 */
		/* 821628A4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82162D0C;  }
		/* 821628A4h case   15:*/		return 0x821628A8;
		  /* 821628A8h */ case   16:  		/* cmplwi CR6, R11, 96 */
		/* 821628A8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 821628A8h case   16:*/		return 0x821628AC;
		  /* 821628ACh */ case   17:  		/* bc 12, CR6_GT, 1360 */
		/* 821628ACh case   17:*/		if ( regs.CR[6].gt ) { return 0x82162DFC;  }
		/* 821628ACh case   17:*/		return 0x821628B0;
		  /* 821628B0h */ case   18:  		/* lis R12, -32252 */
		/* 821628B0h case   18:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 821628B0h case   18:*/		return 0x821628B4;
		  /* 821628B4h */ case   19:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 821628B4h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 821628B4h case   19:*/		return 0x821628B8;
		  /* 821628B8h */ case   20:  		/* addi R12, R12, -17968 */
		/* 821628B8h case   20:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFB9D0);
		/* 821628B8h case   20:*/		return 0x821628BC;
		  /* 821628BCh */ case   21:  		/* lhzx R0, <#[R12 + R0]> */
		/* 821628BCh case   21:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 821628BCh case   21:*/		return 0x821628C0;
		  /* 821628C0h */ case   22:  		/* lis R12, -32234 */
		/* 821628C0h case   22:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8216);
		/* 821628C0h case   22:*/		return 0x821628C4;
		  /* 821628C4h */ case   23:  		/* addi R12, R12, 10456 */
		/* 821628C4h case   23:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x28D8);
		/* 821628C4h case   23:*/		return 0x821628C8;
		  /* 821628C8h */ case   24:  		/* ori R0, R0, 0 */
		/* 821628C8h case   24:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 821628C8h case   24:*/		return 0x821628CC;
		  /* 821628CCh */ case   25:  		/* add R12, R12, R0 */
		/* 821628CCh case   25:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 821628CCh case   25:*/		return 0x821628D0;
		  /* 821628D0h */ case   26:  		/* mtspr CTR, R12 */
		/* 821628D0h case   26:*/		regs.CTR = regs.R12;
		/* 821628D0h case   26:*/		return 0x821628D4;
		  /* 821628D4h */ case   27:  		/* bcctr 20, CR0_LT */
		/* 821628D4h case   27:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 821628D4h case   27:*/		return 0x821628D8;
		  /* 821628D8h */ case   28:  		/* lwz R11, <#[R28]> */
		/* 821628D8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821628D8h case   28:*/		return 0x821628DC;
		  /* 821628DCh */ case   29:  		/* li R30, 1 */
		/* 821628DCh case   29:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821628DCh case   29:*/		return 0x821628E0;
		  /* 821628E0h */ case   30:  		/* mr R10, R11 */
		/* 821628E0h case   30:*/		regs.R10 = regs.R11;
		/* 821628E0h case   30:*/		return 0x821628E4;
		  /* 821628E4h */ case   31:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 821628E4h case   31:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 821628E4h case   31:*/		return 0x821628E8;
		  /* 821628E8h */ case   32:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 821628E8h case   32:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 821628E8h case   32:*/		return 0x821628EC;
		  /* 821628ECh */ case   33:  		/* addi R11, R11, -768 */
		/* 821628ECh case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFD00);
		/* 821628ECh case   33:*/		return 0x821628F0;
		  /* 821628F0h */ case   34:  		/* cntlzw R11, R11 */
		/* 821628F0h case   34:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821628F0h case   34:*/		return 0x821628F4;
		  /* 821628F4h */ case   35:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 821628F4h case   35:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821628F4h case   35:*/		return 0x821628F8;
		  /* 821628F8h */ case   36:  		/* addi R31, R11, 71 */
		/* 821628F8h case   36:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x47);
		/* 821628F8h case   36:*/		return 0x821628FC;
		  /* 821628FCh */ case   37:  		/* stw R31, <#[R24]> */
		/* 821628FCh case   37:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R24 + 0x00000000) );
		/* 821628FCh case   37:*/		return 0x82162900;
		  /* 82162900h */ case   38:  		/* addi R11, R29, 1 */
		/* 82162900h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x1);
		/* 82162900h case   38:*/		return 0x82162904;
		  /* 82162904h */ case   39:  		/* lwz R27, <#[R28]> */
		/* 82162904h case   39:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R28 + 0x00000000) );
		/* 82162904h case   39:*/		return 0x82162908;
		  /* 82162908h */ case   40:  		/* rlwinm R10, R27, 0, 18, 18 */
		/* 82162908h case   40:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R10,regs.R27);
		/* 82162908h case   40:*/		return 0x8216290C;
		  /* 8216290Ch */ case   41:  		/* addi R3, R24, 4 */
		/* 8216290Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R24,0x4);
		/* 8216290Ch case   41:*/		return 0x82162910;
		  /* 82162910h */ case   42:  		/* stw R11, <#[R1 + 96]> */
		/* 82162910h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82162910h case   42:*/		return 0x82162914;
		  /* 82162914h */ case   43:  		/* addi R28, R28, 4 */
		/* 82162914h case   43:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82162914h case   43:*/		return 0x82162918;
		  /* 82162918h */ case   44:  		/* cmplwi CR6, R10, 8192 */
		/* 82162918h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002000);
		/* 82162918h case   44:*/		return 0x8216291C;
		  /* 8216291Ch */ case   45:  		/* bc 4, CR6_EQ, 1016 */
		/* 8216291Ch case   45:*/		if ( !regs.CR[6].eq ) { return 0x82162D14;  }
		/* 8216291Ch case   45:*/		return 0x82162920;
		  /* 82162920h */ case   46:  		/* cmplwi CR6, R17, 768 */
		/* 82162920h case   46:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000300);
		/* 82162920h case   46:*/		return 0x82162924;
		  /* 82162924h */ case   47:  		/* bc 12, CR6_LT, 1008 */
		/* 82162924h case   47:*/		if ( regs.CR[6].lt ) { return 0x82162D14;  }
		/* 82162924h case   47:*/		return 0x82162928;
		  /* 82162928h */ case   48:  		/* lwz R25, <#[R28]> */
		/* 82162928h case   48:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R28 + 0x00000000) );
		/* 82162928h case   48:*/		return 0x8216292C;
		  /* 8216292Ch */ case   49:  		/* addi R28, R28, 4 */
		/* 8216292Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8216292Ch case   49:*/		return 0x82162930;
		  /* 82162930h */ case   50:  		/* b 1000 */
		/* 82162930h case   50:*/		return 0x82162D18;
		/* 82162930h case   50:*/		return 0x82162934;
		  /* 82162934h */ case   51:  		/* li R30, 2 */
		/* 82162934h case   51:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162934h case   51:*/		return 0x82162938;
		  /* 82162938h */ case   52:  		/* li R31, 3 */
		/* 82162938h case   52:*/		cpu::op::li<0>(regs,&regs.R31,0x3);
		/* 82162938h case   52:*/		return 0x8216293C;
		  /* 8216293Ch */ case   53:  		/* b -64 */
		/* 8216293Ch case   53:*/		return 0x821628FC;
		/* 8216293Ch case   53:*/		return 0x82162940;
		  /* 82162940h */ case   54:  		/* li R30, 2 */
		/* 82162940h case   54:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162940h case   54:*/		return 0x82162944;
		  /* 82162944h */ case   55:  		/* li R31, 91 */
		/* 82162944h case   55:*/		cpu::op::li<0>(regs,&regs.R31,0x5B);
		/* 82162944h case   55:*/		return 0x82162948;
		  /* 82162948h */ case   56:  		/* b -76 */
		/* 82162948h case   56:*/		return 0x821628FC;
		/* 82162948h case   56:*/		return 0x8216294C;
		  /* 8216294Ch */ case   57:  		/* li R30, 3 */
		/* 8216294Ch case   57:*/		cpu::op::li<0>(regs,&regs.R30,0x3);
		/* 8216294Ch case   57:*/		return 0x82162950;
		  /* 82162950h */ case   58:  		/* li R31, 64 */
		/* 82162950h case   58:*/		cpu::op::li<0>(regs,&regs.R31,0x40);
		/* 82162950h case   58:*/		return 0x82162954;
		  /* 82162954h */ case   59:  		/* b -88 */
		/* 82162954h case   59:*/		return 0x821628FC;
		/* 82162954h case   59:*/		return 0x82162958;
		  /* 82162958h */ case   60:  		/* li R30, 2 */
		/* 82162958h case   60:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162958h case   60:*/		return 0x8216295C;
		  /* 8216295Ch */ case   61:  		/* li R31, 73 */
		/* 8216295Ch case   61:*/		cpu::op::li<0>(regs,&regs.R31,0x49);
		/* 8216295Ch case   61:*/		return 0x82162960;
		  /* 82162960h */ case   62:  		/* b -100 */
		/* 82162960h case   62:*/		return 0x821628FC;
		/* 82162960h case   62:*/		return 0x82162964;
		  /* 82162964h */ case   63:  		/* li R30, 1 */
		/* 82162964h case   63:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162964h case   63:*/		return 0x82162968;
		  /* 82162968h */ case   64:  		/* li R31, 81 */
		/* 82162968h case   64:*/		cpu::op::li<0>(regs,&regs.R31,0x51);
		/* 82162968h case   64:*/		return 0x8216296C;
		  /* 8216296Ch */ case   65:  		/* b -112 */
		/* 8216296Ch case   65:*/		return 0x821628FC;
		/* 8216296Ch case   65:*/		return 0x82162970;
		  /* 82162970h */ case   66:  		/* li R30, 1 */
		/* 82162970h case   66:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162970h case   66:*/		return 0x82162974;
		  /* 82162974h */ case   67:  		/* li R31, 85 */
		/* 82162974h case   67:*/		cpu::op::li<0>(regs,&regs.R31,0x55);
		/* 82162974h case   67:*/		return 0x82162978;
		  /* 82162978h */ case   68:  		/* b -124 */
		/* 82162978h case   68:*/		return 0x821628FC;
		/* 82162978h case   68:*/		return 0x8216297C;
		  /* 8216297Ch */ case   69:  		/* li R30, 2 */
		/* 8216297Ch case   69:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 8216297Ch case   69:*/		return 0x82162980;
		  /* 82162980h */ case   70:  		/* li R31, 34 */
		/* 82162980h case   70:*/		cpu::op::li<0>(regs,&regs.R31,0x22);
		/* 82162980h case   70:*/		return 0x82162984;
		  /* 82162984h */ case   71:  		/* b -136 */
		/* 82162984h case   71:*/		return 0x821628FC;
		/* 82162984h case   71:*/		return 0x82162988;
		  /* 82162988h */ case   72:  		/* li R30, 2 */
		/* 82162988h case   72:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162988h case   72:*/		return 0x8216298C;
		  /* 8216298Ch */ case   73:  		/* li R31, 35 */
		/* 8216298Ch case   73:*/		cpu::op::li<0>(regs,&regs.R31,0x23);
		/* 8216298Ch case   73:*/		return 0x82162990;
		  /* 82162990h */ case   74:  		/* b -148 */
		/* 82162990h case   74:*/		return 0x821628FC;
		/* 82162990h case   74:*/		return 0x82162994;
		  /* 82162994h */ case   75:  		/* li R30, 2 */
		/* 82162994h case   75:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162994h case   75:*/		return 0x82162998;
		  /* 82162998h */ case   76:  		/* li R31, 68 */
		/* 82162998h case   76:*/		cpu::op::li<0>(regs,&regs.R31,0x44);
		/* 82162998h case   76:*/		return 0x8216299C;
		  /* 8216299Ch */ case   77:  		/* b -160 */
		/* 8216299Ch case   77:*/		return 0x821628FC;
		/* 8216299Ch case   77:*/		return 0x821629A0;
		  /* 821629A0h */ case   78:  		/* li R30, 2 */
		/* 821629A0h case   78:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 821629A0h case   78:*/		return 0x821629A4;
		  /* 821629A4h */ case   79:  		/* li R31, 65 */
		/* 821629A4h case   79:*/		cpu::op::li<0>(regs,&regs.R31,0x41);
		/* 821629A4h case   79:*/		return 0x821629A8;
		  /* 821629A8h */ case   80:  		/* b -172 */
		/* 821629A8h case   80:*/		return 0x821628FC;
		/* 821629A8h case   80:*/		return 0x821629AC;
		  /* 821629ACh */ case   81:  		/* lis R31, 5 */
		/* 821629ACh case   81:*/		cpu::op::lis<0>(regs,&regs.R31,0x5);
		/* 821629ACh case   81:*/		return 0x821629B0;
		  /* 821629B0h */ case   82:  		/* li R30, 2 */
		/* 821629B0h case   82:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 821629B0h case   82:*/		return 0x821629B4;
		  /* 821629B4h */ case   83:  		/* ori R31, R31, 86 */
		/* 821629B4h case   83:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x56);
		/* 821629B4h case   83:*/		return 0x821629B8;
		  /* 821629B8h */ case   84:  		/* b -188 */
		/* 821629B8h case   84:*/		return 0x821628FC;
		/* 821629B8h case   84:*/		return 0x821629BC;
		  /* 821629BCh */ case   85:  		/* lis R31, 2 */
		/* 821629BCh case   85:*/		cpu::op::lis<0>(regs,&regs.R31,0x2);
		/* 821629BCh case   85:*/		return 0x821629C0;
		  /* 821629C0h */ case   86:  		/* b -16 */
		/* 821629C0h case   86:*/		return 0x821629B0;
		/* 821629C0h case   86:*/		return 0x821629C4;
		  /* 821629C4h */ case   87:  		/* li R30, 1 */
		/* 821629C4h case   87:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821629C4h case   87:*/		return 0x821629C8;
		  /* 821629C8h */ case   88:  		/* li R31, 57 */
		/* 821629C8h case   88:*/		cpu::op::li<0>(regs,&regs.R31,0x39);
		/* 821629C8h case   88:*/		return 0x821629CC;
		  /* 821629CCh */ case   89:  		/* b -208 */
		/* 821629CCh case   89:*/		return 0x821628FC;
		/* 821629CCh case   89:*/		return 0x821629D0;
		  /* 821629D0h */ case   90:  		/* li R30, 2 */
		/* 821629D0h case   90:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 821629D0h case   90:*/		return 0x821629D4;
		  /* 821629D4h */ case   91:  		/* li R31, 36 */
		/* 821629D4h case   91:*/		cpu::op::li<0>(regs,&regs.R31,0x24);
		/* 821629D4h case   91:*/		return 0x821629D8;
		  /* 821629D8h */ case   92:  		/* b -220 */
		/* 821629D8h case   92:*/		return 0x821628FC;
		/* 821629D8h case   92:*/		return 0x821629DC;
		  /* 821629DCh */ case   93:  		/* li R30, 1 */
		/* 821629DCh case   93:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821629DCh case   93:*/		return 0x821629E0;
		  /* 821629E0h */ case   94:  		/* li R31, 46 */
		/* 821629E0h case   94:*/		cpu::op::li<0>(regs,&regs.R31,0x2E);
		/* 821629E0h case   94:*/		return 0x821629E4;
		  /* 821629E4h */ case   95:  		/* b -232 */
		/* 821629E4h case   95:*/		return 0x821628FC;
		/* 821629E4h case   95:*/		return 0x821629E8;
		  /* 821629E8h */ case   96:  		/* li R30, 1 */
		/* 821629E8h case   96:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821629E8h case   96:*/		return 0x821629EC;
		  /* 821629ECh */ case   97:  		/* li R31, 61 */
		/* 821629ECh case   97:*/		cpu::op::li<0>(regs,&regs.R31,0x3D);
		/* 821629ECh case   97:*/		return 0x821629F0;
		  /* 821629F0h */ case   98:  		/* b -244 */
		/* 821629F0h case   98:*/		return 0x821628FC;
		/* 821629F0h case   98:*/		return 0x821629F4;
		  /* 821629F4h */ case   99:  		/* li R30, 1 */
		/* 821629F4h case   99:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821629F4h case   99:*/		return 0x821629F8;
		  /* 821629F8h */ case  100:  		/* li R31, 45 */
		/* 821629F8h case  100:*/		cpu::op::li<0>(regs,&regs.R31,0x2D);
		/* 821629F8h case  100:*/		return 0x821629FC;
		  /* 821629FCh */ case  101:  		/* b -256 */
		/* 821629FCh case  101:*/		return 0x821628FC;
		/* 821629FCh case  101:*/		return 0x82162A00;
		  /* 82162A00h */ case  102:  		/* li R30, 1 */
		/* 82162A00h case  102:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162A00h case  102:*/		return 0x82162A04;
		  /* 82162A04h */ case  103:  		/* li R31, 49 */
		/* 82162A04h case  103:*/		cpu::op::li<0>(regs,&regs.R31,0x31);
		/* 82162A04h case  103:*/		return 0x82162A08;
		  /* 82162A08h */ case  104:  		/* b -268 */
		/* 82162A08h case  104:*/		return 0x821628FC;
		/* 82162A08h case  104:*/		return 0x82162A0C;
		  /* 82162A0Ch */ case  105:  		/* li R30, 1 */
		/* 82162A0Ch case  105:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162A0Ch case  105:*/		return 0x82162A10;
		  /* 82162A10h */ case  106:  		/* li R31, 60 */
		/* 82162A10h case  106:*/		cpu::op::li<0>(regs,&regs.R31,0x3C);
		/* 82162A10h case  106:*/		return 0x82162A14;
		  /* 82162A14h */ case  107:  		/* b -280 */
		/* 82162A14h case  107:*/		return 0x821628FC;
		/* 82162A14h case  107:*/		return 0x82162A18;
		  /* 82162A18h */ case  108:  		/* li R30, 2 */
		/* 82162A18h case  108:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162A18h case  108:*/		return 0x82162A1C;
		  /* 82162A1Ch */ case  109:  		/* li R31, 69 */
		/* 82162A1Ch case  109:*/		cpu::op::li<0>(regs,&regs.R31,0x45);
		/* 82162A1Ch case  109:*/		return 0x82162A20;
		  /* 82162A20h */ case  110:  		/* b -292 */
		/* 82162A20h case  110:*/		return 0x821628FC;
		/* 82162A20h case  110:*/		return 0x82162A24;
		  /* 82162A24h */ case  111:  		/* lis R31, 1 */
		/* 82162A24h case  111:*/		cpu::op::lis<0>(regs,&regs.R31,0x1);
		/* 82162A24h case  111:*/		return 0x82162A28;
		  /* 82162A28h */ case  112:  		/* li R30, 2 */
		/* 82162A28h case  112:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162A28h case  112:*/		return 0x82162A2C;
		  /* 82162A2Ch */ case  113:  		/* ori R31, R31, 69 */
		/* 82162A2Ch case  113:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x45);
		/* 82162A2Ch case  113:*/		return 0x82162A30;
		  /* 82162A30h */ case  114:  		/* b -308 */
		/* 82162A30h case  114:*/		return 0x821628FC;
		/* 82162A30h case  114:*/		return 0x82162A34;
		  /* 82162A34h */ case  115:  		/* lis R31, 2 */
		/* 82162A34h case  115:*/		cpu::op::lis<0>(regs,&regs.R31,0x2);
		/* 82162A34h case  115:*/		return 0x82162A38;
		  /* 82162A38h */ case  116:  		/* b -16 */
		/* 82162A38h case  116:*/		return 0x82162A28;
		/* 82162A38h case  116:*/		return 0x82162A3C;
		  /* 82162A3Ch */ case  117:  		/* lis R31, 3 */
		/* 82162A3Ch case  117:*/		cpu::op::lis<0>(regs,&regs.R31,0x3);
		/* 82162A3Ch case  117:*/		return 0x82162A40;
		  /* 82162A40h */ case  118:  		/* b -24 */
		/* 82162A40h case  118:*/		return 0x82162A28;
		/* 82162A40h case  118:*/		return 0x82162A44;
		  /* 82162A44h */ case  119:  		/* lis R31, 4 */
		/* 82162A44h case  119:*/		cpu::op::lis<0>(regs,&regs.R31,0x4);
		/* 82162A44h case  119:*/		return 0x82162A48;
		  /* 82162A48h */ case  120:  		/* b -32 */
		/* 82162A48h case  120:*/		return 0x82162A28;
		/* 82162A48h case  120:*/		return 0x82162A4C;
		  /* 82162A4Ch */ case  121:  		/* lis R31, 1 */
		/* 82162A4Ch case  121:*/		cpu::op::lis<0>(regs,&regs.R31,0x1);
		/* 82162A4Ch case  121:*/		return 0x82162A50;
		  /* 82162A50h */ case  122:  		/* li R30, 1 */
		/* 82162A50h case  122:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162A50h case  122:*/		return 0x82162A54;
		  /* 82162A54h */ case  123:  		/* ori R31, R31, 72 */
		/* 82162A54h case  123:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x48);
		/* 82162A54h case  123:*/		return 0x82162A58;
		  /* 82162A58h */ case  124:  		/* b -348 */
		/* 82162A58h case  124:*/		return 0x821628FC;
		/* 82162A58h case  124:*/		return 0x82162A5C;
		  /* 82162A5Ch */ case  125:  		/* rlwinm R11, R4, 16, 29, 31 */
		/* 82162A5Ch case  125:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R11,regs.R4);
		/* 82162A5Ch case  125:*/		return 0x82162A60;
		  /* 82162A60h */ case  126:  		/* li R30, 2 */
		/* 82162A60h case  126:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162A60h case  126:*/		return 0x82162A64;
		  /* 82162A64h */ case  127:  		/* cmplwi CR6, R11, 1 */
		/* 82162A64h case  127:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82162A64h case  127:*/		return 0x82162A68;
		  /* 82162A68h */ case  128:  		/* bc 12, CR6_EQ, 76 */
		/* 82162A68h case  128:*/		if ( regs.CR[6].eq ) { return 0x82162AB4;  }
		/* 82162A68h case  128:*/		return 0x82162A6C;
		  /* 82162A6Ch */ case  129:  		/* cmplwi CR6, R11, 3 */
		/* 82162A6Ch case  129:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82162A6Ch case  129:*/		return 0x82162A70;
		  /* 82162A70h */ case  130:  		/* bc 12, CR6_EQ, 60 */
		/* 82162A70h case  130:*/		if ( regs.CR[6].eq ) { return 0x82162AAC;  }
		/* 82162A70h case  130:*/		return 0x82162A74;
		  /* 82162A74h */ case  131:  		/* cmplwi CR6, R11, 4 */
		/* 82162A74h case  131:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82162A74h case  131:*/		return 0x82162A78;
		  /* 82162A78h */ case  132:  		/* bc 12, CR6_EQ, 44 */
		/* 82162A78h case  132:*/		if ( regs.CR[6].eq ) { return 0x82162AA4;  }
		/* 82162A78h case  132:*/		return 0x82162A7C;
		  /* 82162A7Ch */ case  133:  		/* cmplwi CR6, R11, 5 */
		/* 82162A7Ch case  133:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82162A7Ch case  133:*/		return 0x82162A80;
		  /* 82162A80h */ case  134:  		/* bc 12, CR6_EQ, 28 */
		/* 82162A80h case  134:*/		if ( regs.CR[6].eq ) { return 0x82162A9C;  }
		/* 82162A80h case  134:*/		return 0x82162A84;
		  /* 82162A84h */ case  135:  		/* cmplwi CR6, R11, 6 */
		/* 82162A84h case  135:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 82162A84h case  135:*/		return 0x82162A88;
		  /* 82162A88h */ case  136:  		/* bc 12, CR6_EQ, 12 */
		/* 82162A88h case  136:*/		if ( regs.CR[6].eq ) { return 0x82162A94;  }
		/* 82162A88h case  136:*/		return 0x82162A8C;
		  /* 82162A8Ch */ case  137:  		/* lis R31, 1 */
		/* 82162A8Ch case  137:*/		cpu::op::lis<0>(regs,&regs.R31,0x1);
		/* 82162A8Ch case  137:*/		return 0x82162A90;
		  /* 82162A90h */ case  138:  		/* b 40 */
		/* 82162A90h case  138:*/		return 0x82162AB8;
		/* 82162A90h case  138:*/		return 0x82162A94;
	}
	return 0x82162A94;
} // Block from 82162868h-82162A94h (139 instructions)

//////////////////////////////////////////////////////
// Block at 82162A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162A94);
		  /* 82162A94h */ case    0:  		/* lis R31, 4 */
		/* 82162A94h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x4);
		/* 82162A94h case    0:*/		return 0x82162A98;
		  /* 82162A98h */ case    1:  		/* b 32 */
		/* 82162A98h case    1:*/		return 0x82162AB8;
		/* 82162A98h case    1:*/		return 0x82162A9C;
	}
	return 0x82162A9C;
} // Block from 82162A94h-82162A9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162A9C);
		  /* 82162A9Ch */ case    0:  		/* li R31, 86 */
		/* 82162A9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x56);
		/* 82162A9Ch case    0:*/		return 0x82162AA0;
		  /* 82162AA0h */ case    1:  		/* b 28 */
		/* 82162AA0h case    1:*/		return 0x82162ABC;
		/* 82162AA0h case    1:*/		return 0x82162AA4;
	}
	return 0x82162AA4;
} // Block from 82162A9Ch-82162AA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162AA4);
		  /* 82162AA4h */ case    0:  		/* lis R31, 5 */
		/* 82162AA4h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x5);
		/* 82162AA4h case    0:*/		return 0x82162AA8;
		  /* 82162AA8h */ case    1:  		/* b 16 */
		/* 82162AA8h case    1:*/		return 0x82162AB8;
		/* 82162AA8h case    1:*/		return 0x82162AAC;
	}
	return 0x82162AAC;
} // Block from 82162AA4h-82162AACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162AAC);
		  /* 82162AACh */ case    0:  		/* lis R31, 2 */
		/* 82162AACh case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x2);
		/* 82162AACh case    0:*/		return 0x82162AB0;
		  /* 82162AB0h */ case    1:  		/* b 8 */
		/* 82162AB0h case    1:*/		return 0x82162AB8;
		/* 82162AB0h case    1:*/		return 0x82162AB4;
	}
	return 0x82162AB4;
} // Block from 82162AACh-82162AB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162AB4);
		  /* 82162AB4h */ case    0:  		/* lis R31, 3 */
		/* 82162AB4h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x3);
		/* 82162AB4h case    0:*/		return 0x82162AB8;
	}
	return 0x82162AB8;
} // Block from 82162AB4h-82162AB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162AB8);
		  /* 82162AB8h */ case    0:  		/* ori R31, R31, 86 */
		/* 82162AB8h case    0:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x56);
		/* 82162AB8h case    0:*/		return 0x82162ABC;
	}
	return 0x82162ABC;
} // Block from 82162AB8h-82162ABCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162ABC);
		  /* 82162ABCh */ case    0:  		/* mr R22, R19 */
		/* 82162ABCh case    0:*/		regs.R22 = regs.R19;
		/* 82162ABCh case    0:*/		return 0x82162AC0;
		  /* 82162AC0h */ case    1:  		/* b -452 */
		/* 82162AC0h case    1:*/		return 0x821628FC;
		/* 82162AC0h case    1:*/		return 0x82162AC4;
		  /* 82162AC4h */ case    2:  		/* mr R10, R22 */
		/* 82162AC4h case    2:*/		regs.R10 = regs.R22;
		/* 82162AC4h case    2:*/		return 0x82162AC8;
		  /* 82162AC8h */ case    3:  		/* stw R19, <#[R1 + 104]> */
		/* 82162AC8h case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000068) );
		/* 82162AC8h case    3:*/		return 0x82162ACC;
		  /* 82162ACCh */ case    4:  		/* mr R9, R20 */
		/* 82162ACCh case    4:*/		regs.R9 = regs.R20;
		/* 82162ACCh case    4:*/		return 0x82162AD0;
		  /* 82162AD0h */ case    5:  		/* addi R8, R1, 100 */
		/* 82162AD0h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x64);
		/* 82162AD0h case    5:*/		return 0x82162AD4;
		  /* 82162AD4h */ case    6:  		/* addi R7, R1, 96 */
		/* 82162AD4h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82162AD4h case    6:*/		return 0x82162AD8;
		  /* 82162AD8h */ case    7:  		/* addi R6, R1, 104 */
		/* 82162AD8h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 82162AD8h case    7:*/		return 0x82162ADC;
		  /* 82162ADCh */ case    8:  		/* mr R5, R28 */
		/* 82162ADCh case    8:*/		regs.R5 = regs.R28;
		/* 82162ADCh case    8:*/		return 0x82162AE0;
		  /* 82162AE0h */ case    9:  		/* mr R4, R24 */
		/* 82162AE0h case    9:*/		regs.R4 = regs.R24;
		/* 82162AE0h case    9:*/		return 0x82162AE4;
		  /* 82162AE4h */ case   10:  		/* mr R3, R23 */
		/* 82162AE4h case   10:*/		regs.R3 = regs.R23;
		/* 82162AE4h case   10:*/		return 0x82162AE8;
		  /* 82162AE8h */ case   11:  		/* bl -1512 */
		/* 82162AE8h case   11:*/		regs.LR = 0x82162AEC; return 0x82162500;
		/* 82162AE8h case   11:*/		return 0x82162AEC;
		  /* 82162AECh */ case   12:  		/* lwz R11, <#[R1 + 104]> */
		/* 82162AECh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82162AECh case   12:*/		return 0x82162AF0;
		  /* 82162AF0h */ case   13:  		/* mr R24, R3 */
		/* 82162AF0h case   13:*/		regs.R24 = regs.R3;
		/* 82162AF0h case   13:*/		return 0x82162AF4;
		  /* 82162AF4h */ case   14:  		/* lwz R29, <#[R1 + 96]> */
		/* 82162AF4h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82162AF4h case   14:*/		return 0x82162AF8;
		  /* 82162AF8h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82162AF8h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82162AF8h case   15:*/		return 0x82162AFC;
		  /* 82162AFCh */ case   16:  		/* add R28, R11, R28 */
		/* 82162AFCh case   16:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 82162AFCh case   16:*/		return 0x82162B00;
		  /* 82162B00h */ case   17:  		/* b 764 */
		/* 82162B00h case   17:*/		return 0x82162DFC;
		/* 82162B00h case   17:*/		return 0x82162B04;
		  /* 82162B04h */ case   18:  		/* lwz R11, <#[R28 + 4]> */
		/* 82162B04h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82162B04h case   18:*/		return 0x82162B08;
		  /* 82162B08h */ case   19:  		/* mr R10, R11 */
		/* 82162B08h case   19:*/		regs.R10 = regs.R11;
		/* 82162B08h case   19:*/		return 0x82162B0C;
		  /* 82162B0Ch */ case   20:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82162B0Ch case   20:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82162B0Ch case   20:*/		return 0x82162B10;
		  /* 82162B10h */ case   21:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82162B10h case   21:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82162B10h case   21:*/		return 0x82162B14;
		  /* 82162B14h */ case   22:  		/* cmplwi CR6, R11, 256 */
		/* 82162B14h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 82162B14h case   22:*/		return 0x82162B18;
		  /* 82162B18h */ case   23:  		/* bc 12, CR6_EQ, 340 */
		/* 82162B18h case   23:*/		if ( regs.CR[6].eq ) { return 0x82162C6C;  }
		/* 82162B18h case   23:*/		return 0x82162B1C;
		  /* 82162B1Ch */ case   24:  		/* lwz R11, <#[R28 + 4]> */
		/* 82162B1Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82162B1Ch case   24:*/		return 0x82162B20;
		  /* 82162B20h */ case   25:  		/* mr R10, R11 */
		/* 82162B20h case   25:*/		regs.R10 = regs.R11;
		/* 82162B20h case   25:*/		return 0x82162B24;
		  /* 82162B24h */ case   26:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82162B24h case   26:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82162B24h case   26:*/		return 0x82162B28;
		  /* 82162B28h */ case   27:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82162B28h case   27:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82162B28h case   27:*/		return 0x82162B2C;
		  /* 82162B2Ch */ case   28:  		/* cmplwi CR6, R11, 1536 */
		/* 82162B2Ch case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000600);
		/* 82162B2Ch case   28:*/		return 0x82162B30;
		  /* 82162B30h */ case   29:  		/* bc 4, CR6_EQ, 156 */
		/* 82162B30h case   29:*/		if ( !regs.CR[6].eq ) { return 0x82162BCC;  }
		/* 82162B30h case   29:*/		return 0x82162B34;
		  /* 82162B34h */ case   30:  		/* cmplwi CR6, R17, 768 */
		/* 82162B34h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000300);
		/* 82162B34h case   30:*/		return 0x82162B38;
		  /* 82162B38h */ case   31:  		/* bc 4, CR6_LT, 8 */
		/* 82162B38h case   31:*/		if ( !regs.CR[6].lt ) { return 0x82162B40;  }
		/* 82162B38h case   31:*/		return 0x82162B3C;
		  /* 82162B3Ch */ case   32:  		/* bl 1066788 */
		/* 82162B3Ch case   32:*/		regs.LR = 0x82162B40; return 0x82267260;
		/* 82162B3Ch case   32:*/		return 0x82162B40;
	}
	return 0x82162B40;
} // Block from 82162ABCh-82162B40h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82162B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162B40);
		  /* 82162B40h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82162B40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82162B40h case    0:*/		return 0x82162B44;
		  /* 82162B44h */ case    1:  		/* mr R10, R11 */
		/* 82162B44h case    1:*/		regs.R10 = regs.R11;
		/* 82162B44h case    1:*/		return 0x82162B48;
		  /* 82162B48h */ case    2:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82162B48h case    2:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82162B48h case    2:*/		return 0x82162B4C;
		  /* 82162B4Ch */ case    3:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82162B4Ch case    3:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82162B4Ch case    3:*/		return 0x82162B50;
		  /* 82162B50h */ case    4:  		/* cmplwi CR6, R11, 1536 */
		/* 82162B50h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000600);
		/* 82162B50h case    4:*/		return 0x82162B54;
		  /* 82162B54h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82162B54h case    5:*/		if ( regs.CR[6].eq ) { return 0x82162B5C;  }
		/* 82162B54h case    5:*/		return 0x82162B58;
		  /* 82162B58h */ case    6:  		/* bl 1066760 */
		/* 82162B58h case    6:*/		regs.LR = 0x82162B5C; return 0x82267260;
		/* 82162B58h case    6:*/		return 0x82162B5C;
	}
	return 0x82162B5C;
} // Block from 82162B40h-82162B5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82162B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162B5C);
		  /* 82162B5Ch */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 82162B5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82162B5Ch case    0:*/		return 0x82162B60;
		  /* 82162B60h */ case    1:  		/* addi R6, R1, 96 */
		/* 82162B60h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 82162B60h case    1:*/		return 0x82162B64;
		  /* 82162B64h */ case    2:  		/* mr R5, R24 */
		/* 82162B64h case    2:*/		regs.R5 = regs.R24;
		/* 82162B64h case    2:*/		return 0x82162B68;
		  /* 82162B68h */ case    3:  		/* ori R11, R11, 1 */
		/* 82162B68h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82162B68h case    3:*/		return 0x82162B6C;
		  /* 82162B6Ch */ case    4:  		/* mr R4, R18 */
		/* 82162B6Ch case    4:*/		regs.R4 = regs.R18;
		/* 82162B6Ch case    4:*/		return 0x82162B70;
		  /* 82162B70h */ case    5:  		/* mr R10, R11 */
		/* 82162B70h case    5:*/		regs.R10 = regs.R11;
		/* 82162B70h case    5:*/		return 0x82162B74;
		  /* 82162B74h */ case    6:  		/* stw R11, <#[R21 + 4]> */
		/* 82162B74h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82162B74h case    6:*/		return 0x82162B78;
		  /* 82162B78h */ case    7:  		/* lwz R11, <#[R28]> */
		/* 82162B78h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82162B78h case    7:*/		return 0x82162B7C;
		  /* 82162B7Ch */ case    8:  		/* mr R3, R23 */
		/* 82162B7Ch case    8:*/		regs.R3 = regs.R23;
		/* 82162B7Ch case    8:*/		return 0x82162B80;
		  /* 82162B80h */ case    9:  		/* rlwimi R10, R11, 28, 0, 3 */
		/* 82162B80h case    9:*/		cpu::op::rlwimi<0,28,0,3>(regs,&regs.R10,regs.R11);
		/* 82162B80h case    9:*/		return 0x82162B84;
		  /* 82162B84h */ case   10:  		/* mr R11, R10 */
		/* 82162B84h case   10:*/		regs.R11 = regs.R10;
		/* 82162B84h case   10:*/		return 0x82162B88;
		  /* 82162B88h */ case   11:  		/* stw R10, <#[R21 + 4]> */
		/* 82162B88h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R21 + 0x00000004) );
		/* 82162B88h case   11:*/		return 0x82162B8C;
		  /* 82162B8Ch */ case   12:  		/* lwz R10, <#[R28]> */
		/* 82162B8Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 82162B8Ch case   12:*/		return 0x82162B90;
		  /* 82162B90h */ case   13:  		/* rlwimi R11, R10, 8, 4, 7 */
		/* 82162B90h case   13:*/		cpu::op::rlwimi<0,8,4,7>(regs,&regs.R11,regs.R10);
		/* 82162B90h case   13:*/		return 0x82162B94;
		  /* 82162B94h */ case   14:  		/* mr R10, R11 */
		/* 82162B94h case   14:*/		regs.R10 = regs.R11;
		/* 82162B94h case   14:*/		return 0x82162B98;
		  /* 82162B98h */ case   15:  		/* stw R11, <#[R21 + 4]> */
		/* 82162B98h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82162B98h case   15:*/		return 0x82162B9C;
		  /* 82162B9Ch */ case   16:  		/* lwz R11, <#[R28 + 4]> */
		/* 82162B9Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82162B9Ch case   16:*/		return 0x82162BA0;
		  /* 82162BA0h */ case   17:  		/* rlwimi R10, R11, 5, 16, 26 */
		/* 82162BA0h case   17:*/		cpu::op::rlwimi<0,5,16,26>(regs,&regs.R10,regs.R11);
		/* 82162BA0h case   17:*/		return 0x82162BA4;
		  /* 82162BA4h */ case   18:  		/* mr R11, R10 */
		/* 82162BA4h case   18:*/		regs.R11 = regs.R10;
		/* 82162BA4h case   18:*/		return 0x82162BA8;
		  /* 82162BA8h */ case   19:  		/* stw R10, <#[R21 + 4]> */
		/* 82162BA8h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R21 + 0x00000004) );
		/* 82162BA8h case   19:*/		return 0x82162BAC;
		  /* 82162BACh */ case   20:  		/* lwz R10, <#[R28 + 4]> */
		/* 82162BACh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 82162BACh case   20:*/		return 0x82162BB0;
		  /* 82162BB0h */ case   21:  		/* rlwimi R11, R10, 17, 27, 30 */
		/* 82162BB0h case   21:*/		cpu::op::rlwimi<0,17,27,30>(regs,&regs.R11,regs.R10);
		/* 82162BB0h case   21:*/		return 0x82162BB4;
		  /* 82162BB4h */ case   22:  		/* stwu R11, <#[R21 + 4]> */
		/* 82162BB4h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000004) );
		regs.R21 = (uint32)(regs.R21 + 0x00000004);
		/* 82162BB4h case   22:*/		return 0x82162BB8;
		  /* 82162BB8h */ case   23:  		/* bl -6488 */
		/* 82162BB8h case   23:*/		regs.LR = 0x82162BBC; return 0x82161260;
		/* 82162BB8h case   23:*/		return 0x82162BBC;
		  /* 82162BBCh */ case   24:  		/* lwz R29, <#[R1 + 96]> */
		/* 82162BBCh case   24:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82162BBCh case   24:*/		return 0x82162BC0;
		  /* 82162BC0h */ case   25:  		/* mr R24, R3 */
		/* 82162BC0h case   25:*/		regs.R24 = regs.R3;
		/* 82162BC0h case   25:*/		return 0x82162BC4;
		  /* 82162BC4h */ case   26:  		/* addi R18, R18, 1 */
		/* 82162BC4h case   26:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 82162BC4h case   26:*/		return 0x82162BC8;
		  /* 82162BC8h */ case   27:  		/* b 164 */
		/* 82162BC8h case   27:*/		return 0x82162C6C;
		/* 82162BC8h case   27:*/		return 0x82162BCC;
	}
	return 0x82162BCC;
} // Block from 82162B5Ch-82162BCCh (28 instructions)

//////////////////////////////////////////////////////
// Block at 82162BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162BCC);
		  /* 82162BCCh */ case    0:  		/* cmplwi CR6, R17, 768 */
		/* 82162BCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000300);
		/* 82162BCCh case    0:*/		return 0x82162BD0;
		  /* 82162BD0h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 82162BD0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82162BD8;  }
		/* 82162BD0h case    1:*/		return 0x82162BD4;
		  /* 82162BD4h */ case    2:  		/* bl 1066636 */
		/* 82162BD4h case    2:*/		regs.LR = 0x82162BD8; return 0x82267260;
		/* 82162BD4h case    2:*/		return 0x82162BD8;
	}
	return 0x82162BD8;
} // Block from 82162BCCh-82162BD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82162BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162BD8);
		  /* 82162BD8h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82162BD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82162BD8h case    0:*/		return 0x82162BDC;
		  /* 82162BDCh */ case    1:  		/* mr R10, R11 */
		/* 82162BDCh case    1:*/		regs.R10 = regs.R11;
		/* 82162BDCh case    1:*/		return 0x82162BE0;
		  /* 82162BE0h */ case    2:  		/* rlwimi R10, R11, 12, 21, 23 */
		/* 82162BE0h case    2:*/		cpu::op::rlwimi<0,12,21,23>(regs,&regs.R10,regs.R11);
		/* 82162BE0h case    2:*/		return 0x82162BE4;
		  /* 82162BE4h */ case    3:  		/* rlwinm R11, R10, 0, 19, 23 */
		/* 82162BE4h case    3:*/		cpu::op::rlwinm<0,0,19,23>(regs,&regs.R11,regs.R10);
		/* 82162BE4h case    3:*/		return 0x82162BE8;
		  /* 82162BE8h */ case    4:  		/* cmplwi CR6, R11, 2560 */
		/* 82162BE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000A00);
		/* 82162BE8h case    4:*/		return 0x82162BEC;
		  /* 82162BECh */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82162BECh case    5:*/		if ( regs.CR[6].eq ) { return 0x82162BF4;  }
		/* 82162BECh case    5:*/		return 0x82162BF0;
		  /* 82162BF0h */ case    6:  		/* bl 1066608 */
		/* 82162BF0h case    6:*/		regs.LR = 0x82162BF4; return 0x82267260;
		/* 82162BF0h case    6:*/		return 0x82162BF4;
	}
	return 0x82162BF4;
} // Block from 82162BD8h-82162BF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82162BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162BF4);
		  /* 82162BF4h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82162BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82162BF4h case    0:*/		return 0x82162BF8;
		  /* 82162BF8h */ case    1:  		/* lis R10, 4096 */
		/* 82162BF8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 82162BF8h case    1:*/		return 0x82162BFC;
		  /* 82162BFCh */ case    2:  		/* rlwinm R11, R11, 0, 1, 4 */
		/* 82162BFCh case    2:*/		cpu::op::rlwinm<0,0,1,4>(regs,&regs.R11,regs.R11);
		/* 82162BFCh case    2:*/		return 0x82162C00;
	}
	return 0x82162C00;
} // Block from 82162BF4h-82162C00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82162C00h
// Function '?r400VSConvertMacro@XGRAPHICS@@YAPAKPAU_R400VSFUNC@1@KPAK1111KH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162C00);
		  /* 82162C00h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82162C00h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82162C00h case    0:*/		return 0x82162C04;
		  /* 82162C04h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 82162C04h case    1:*/		if ( regs.CR[6].eq ) { return 0x82162C38;  }
		/* 82162C04h case    1:*/		return 0x82162C08;
		  /* 82162C08h */ case    2:  		/* lis R10, 6144 */
		/* 82162C08h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x1800);
		/* 82162C08h case    2:*/		return 0x82162C0C;
		  /* 82162C0Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82162C0Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82162C0Ch case    3:*/		return 0x82162C10;
		  /* 82162C10h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82162C10h case    4:*/		if ( regs.CR[6].eq ) { return 0x82162C30;  }
		/* 82162C10h case    4:*/		return 0x82162C14;
		  /* 82162C14h */ case    5:  		/* lis R10, 8192 */
		/* 82162C14h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x2000);
		/* 82162C14h case    5:*/		return 0x82162C18;
		  /* 82162C18h */ case    6:  		/* li R9, 3 */
		/* 82162C18h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 82162C18h case    6:*/		return 0x82162C1C;
		  /* 82162C1Ch */ case    7:  		/* subf R11, R11, R10 */
		/* 82162C1Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82162C1Ch case    7:*/		return 0x82162C20;
		  /* 82162C20h */ case    8:  		/* addic R11, R11, -1 */
		/* 82162C20h case    8:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82162C20h case    8:*/		return 0x82162C24;
		  /* 82162C24h */ case    9:  		/* subfe R11, R11, R11 */
		/* 82162C24h case    9:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82162C24h case    9:*/		return 0x82162C28;
		  /* 82162C28h */ case   10:  		/* and R11, R11, R9 */
		/* 82162C28h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82162C28h case   10:*/		return 0x82162C2C;
		  /* 82162C2Ch */ case   11:  		/* b 16 */
		/* 82162C2Ch case   11:*/		return 0x82162C3C;
		/* 82162C2Ch case   11:*/		return 0x82162C30;
	}
	return 0x82162C30;
} // Block from 82162C00h-82162C30h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82162C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162C30);
		  /* 82162C30h */ case    0:  		/* li R11, 4 */
		/* 82162C30h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82162C30h case    0:*/		return 0x82162C34;
		  /* 82162C34h */ case    1:  		/* b 8 */
		/* 82162C34h case    1:*/		return 0x82162C3C;
		/* 82162C34h case    1:*/		return 0x82162C38;
	}
	return 0x82162C38;
} // Block from 82162C30h-82162C38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162C38);
		  /* 82162C38h */ case    0:  		/* li R11, 2 */
		/* 82162C38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82162C38h case    0:*/		return 0x82162C3C;
	}
	return 0x82162C3C;
} // Block from 82162C38h-82162C3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162C3C);
		  /* 82162C3Ch */ case    0:  		/* lwz R10, <#[R28 + 4]> */
		/* 82162C3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 82162C3Ch case    0:*/		return 0x82162C40;
		  /* 82162C40h */ case    1:  		/* rlwinm R9, R11, 24, 5, 7 */
		/* 82162C40h case    1:*/		cpu::op::rlwinm<0,24,5,7>(regs,&regs.R9,regs.R11);
		/* 82162C40h case    1:*/		return 0x82162C44;
		  /* 82162C44h */ case    2:  		/* addi R11, R24, 4 */
		/* 82162C44h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x4);
		/* 82162C44h case    2:*/		return 0x82162C48;
		  /* 82162C48h */ case    3:  		/* addi R10, R10, 16 */
		/* 82162C48h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x10);
		/* 82162C48h case    3:*/		return 0x82162C4C;
		  /* 82162C4Ch */ case    4:  		/* addi R29, R29, 1 */
		/* 82162C4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82162C4Ch case    4:*/		return 0x82162C50;
		  /* 82162C50h */ case    5:  		/* rlwinm R10, R10, 16, 8, 15 */
		/* 82162C50h case    5:*/		cpu::op::rlwinm<0,16,8,15>(regs,&regs.R10,regs.R10);
		/* 82162C50h case    5:*/		return 0x82162C54;
		  /* 82162C54h */ case    6:  		/* stw R29, <#[R1 + 96]> */
		/* 82162C54h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82162C54h case    6:*/		return 0x82162C58;
		  /* 82162C58h */ case    7:  		/* or R10, R10, R9 */
		/* 82162C58h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82162C58h case    7:*/		return 0x82162C5C;
		  /* 82162C5Ch */ case    8:  		/* oris R10, R10, 2048 */
		/* 82162C5Ch case    8:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 82162C5Ch case    8:*/		return 0x82162C60;
		  /* 82162C60h */ case    9:  		/* ori R10, R10, 25 */
		/* 82162C60h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x19);
		/* 82162C60h case    9:*/		return 0x82162C64;
		  /* 82162C64h */ case   10:  		/* stw R10, <#[R24]> */
		/* 82162C64h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 82162C64h case   10:*/		return 0x82162C68;
		  /* 82162C68h */ case   11:  		/* mr R24, R11 */
		/* 82162C68h case   11:*/		regs.R24 = regs.R11;
		/* 82162C68h case   11:*/		return 0x82162C6C;
	}
	return 0x82162C6C;
} // Block from 82162C3Ch-82162C6Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82162C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162C6C);
		  /* 82162C6Ch */ case    0:  		/* addi R28, R28, 8 */
		/* 82162C6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82162C6Ch case    0:*/		return 0x82162C70;
		  /* 82162C70h */ case    1:  		/* b 396 */
		/* 82162C70h case    1:*/		return 0x82162DFC;
		/* 82162C70h case    1:*/		return 0x82162C74;
		  /* 82162C74h */ case    2:  		/* addi R28, R28, 20 */
		/* 82162C74h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x14);
		/* 82162C74h case    2:*/		return 0x82162C78;
		  /* 82162C78h */ case    3:  		/* b 388 */
		/* 82162C78h case    3:*/		return 0x82162DFC;
		/* 82162C78h case    3:*/		return 0x82162C7C;
		  /* 82162C7Ch */ case    4:  		/* mr R10, R20 */
		/* 82162C7Ch case    4:*/		regs.R10 = regs.R20;
		/* 82162C7Ch case    4:*/		return 0x82162C80;
		  /* 82162C80h */ case    5:  		/* stw R19, <#[R1 + 104]> */
		/* 82162C80h case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000068) );
		/* 82162C80h case    5:*/		return 0x82162C84;
		  /* 82162C84h */ case    6:  		/* addi R9, R1, 100 */
		/* 82162C84h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 82162C84h case    6:*/		return 0x82162C88;
		  /* 82162C88h */ case    7:  		/* addi R8, R1, 96 */
		/* 82162C88h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82162C88h case    7:*/		return 0x82162C8C;
		  /* 82162C8Ch */ case    8:  		/* addi R7, R1, 104 */
		/* 82162C8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x68);
		/* 82162C8Ch case    8:*/		return 0x82162C90;
		  /* 82162C90h */ case    9:  		/* mr R6, R28 */
		/* 82162C90h case    9:*/		regs.R6 = regs.R28;
		/* 82162C90h case    9:*/		return 0x82162C94;
		  /* 82162C94h */ case   10:  		/* mr R5, R24 */
		/* 82162C94h case   10:*/		regs.R5 = regs.R24;
		/* 82162C94h case   10:*/		return 0x82162C98;
		  /* 82162C98h */ case   11:  		/* mr R3, R23 */
		/* 82162C98h case   11:*/		regs.R3 = regs.R23;
		/* 82162C98h case   11:*/		return 0x82162C9C;
		  /* 82162C9Ch */ case   12:  		/* bl -5148 */
		/* 82162C9Ch case   12:*/		regs.LR = 0x82162CA0; return 0x82161880;
		/* 82162C9Ch case   12:*/		return 0x82162CA0;
		  /* 82162CA0h */ case   13:  		/* b -436 */
		/* 82162CA0h case   13:*/		return 0x82162AEC;
		/* 82162CA0h case   13:*/		return 0x82162CA4;
		  /* 82162CA4h */ case   14:  		/* li R30, 3 */
		/* 82162CA4h case   14:*/		cpu::op::li<0>(regs,&regs.R30,0x3);
		/* 82162CA4h case   14:*/		return 0x82162CA8;
		  /* 82162CA8h */ case   15:  		/* li R31, 63 */
		/* 82162CA8h case   15:*/		cpu::op::li<0>(regs,&regs.R31,0x3F);
		/* 82162CA8h case   15:*/		return 0x82162CAC;
		  /* 82162CACh */ case   16:  		/* b -944 */
		/* 82162CACh case   16:*/		return 0x821628FC;
		/* 82162CACh case   16:*/		return 0x82162CB0;
		  /* 82162CB0h */ case   17:  		/* li R30, 2 */
		/* 82162CB0h case   17:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162CB0h case   17:*/		return 0x82162CB4;
		  /* 82162CB4h */ case   18:  		/* li R31, 78 */
		/* 82162CB4h case   18:*/		cpu::op::li<0>(regs,&regs.R31,0x4E);
		/* 82162CB4h case   18:*/		return 0x82162CB8;
		  /* 82162CB8h */ case   19:  		/* b -956 */
		/* 82162CB8h case   19:*/		return 0x821628FC;
		/* 82162CB8h case   19:*/		return 0x82162CBC;
		  /* 82162CBCh */ case   20:  		/* li R30, 2 */
		/* 82162CBCh case   20:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 82162CBCh case   20:*/		return 0x82162CC0;
		  /* 82162CC0h */ case   21:  		/* li R31, 19 */
		/* 82162CC0h case   21:*/		cpu::op::li<0>(regs,&regs.R31,0x13);
		/* 82162CC0h case   21:*/		return 0x82162CC4;
		  /* 82162CC4h */ case   22:  		/* b -968 */
		/* 82162CC4h case   22:*/		return 0x821628FC;
		/* 82162CC4h case   22:*/		return 0x82162CC8;
		  /* 82162CC8h */ case   23:  		/* mr R10, R20 */
		/* 82162CC8h case   23:*/		regs.R10 = regs.R20;
		/* 82162CC8h case   23:*/		return 0x82162CCC;
		  /* 82162CCCh */ case   24:  		/* stw R22, <#[R1 + 84]> */
		/* 82162CCCh case   24:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 82162CCCh case   24:*/		return 0x82162CD0;
		  /* 82162CD0h */ case   25:  		/* addi R9, R1, 100 */
		/* 82162CD0h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 82162CD0h case   25:*/		return 0x82162CD4;
		  /* 82162CD4h */ case   26:  		/* stw R19, <#[R1 + 104]> */
		/* 82162CD4h case   26:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000068) );
		/* 82162CD4h case   26:*/		return 0x82162CD8;
		  /* 82162CD8h */ case   27:  		/* addi R8, R1, 96 */
		/* 82162CD8h case   27:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82162CD8h case   27:*/		return 0x82162CDC;
		  /* 82162CDCh */ case   28:  		/* addi R7, R1, 104 */
		/* 82162CDCh case   28:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x68);
		/* 82162CDCh case   28:*/		return 0x82162CE0;
		  /* 82162CE0h */ case   29:  		/* mr R6, R28 */
		/* 82162CE0h case   29:*/		regs.R6 = regs.R28;
		/* 82162CE0h case   29:*/		return 0x82162CE4;
		  /* 82162CE4h */ case   30:  		/* mr R5, R24 */
		/* 82162CE4h case   30:*/		regs.R5 = regs.R24;
		/* 82162CE4h case   30:*/		return 0x82162CE8;
		  /* 82162CE8h */ case   31:  		/* mr R3, R23 */
		/* 82162CE8h case   31:*/		regs.R3 = regs.R23;
		/* 82162CE8h case   31:*/		return 0x82162CEC;
		  /* 82162CECh */ case   32:  		/* bl -2820 */
		/* 82162CECh case   32:*/		regs.LR = 0x82162CF0; return 0x821621E8;
		/* 82162CECh case   32:*/		return 0x82162CF0;
		  /* 82162CF0h */ case   33:  		/* b -516 */
		/* 82162CF0h case   33:*/		return 0x82162AEC;
		/* 82162CF0h case   33:*/		return 0x82162CF4;
		  /* 82162CF4h */ case   34:  		/* li R30, 1 */
		/* 82162CF4h case   34:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162CF4h case   34:*/		return 0x82162CF8;
		  /* 82162CF8h */ case   35:  		/* li R31, 1 */
		/* 82162CF8h case   35:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 82162CF8h case   35:*/		return 0x82162CFC;
		  /* 82162CFCh */ case   36:  		/* b -1024 */
		/* 82162CFCh case   36:*/		return 0x821628FC;
		/* 82162CFCh case   36:*/		return 0x82162D00;
		  /* 82162D00h */ case   37:  		/* li R30, 1 */
		/* 82162D00h case   37:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82162D00h case   37:*/		return 0x82162D04;
		  /* 82162D04h */ case   38:  		/* li R31, 76 */
		/* 82162D04h case   38:*/		cpu::op::li<0>(regs,&regs.R31,0x4C);
		/* 82162D04h case   38:*/		return 0x82162D08;
		  /* 82162D08h */ case   39:  		/* b -1036 */
		/* 82162D08h case   39:*/		return 0x821628FC;
		/* 82162D08h case   39:*/		return 0x82162D0C;
	}
	return 0x82162D0C;
} // Block from 82162C6Ch-82162D0Ch (40 instructions)

//////////////////////////////////////////////////////
// Block at 82162D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D0C);
		  /* 82162D0Ch */ case    0:  		/* rlwinm R11, R4, 18, 15, 29 */
		/* 82162D0Ch case    0:*/		cpu::op::rlwinm<0,18,15,29>(regs,&regs.R11,regs.R4);
		/* 82162D0Ch case    0:*/		return 0x82162D10;
		  /* 82162D10h */ case    1:  		/* b -532 */
		/* 82162D10h case    1:*/		return 0x82162AFC;
		/* 82162D10h case    1:*/		return 0x82162D14;
	}
	return 0x82162D14;
} // Block from 82162D0Ch-82162D14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D14);
		  /* 82162D14h */ case    0:  		/* mr R25, R19 */
		/* 82162D14h case    0:*/		regs.R25 = regs.R19;
		/* 82162D14h case    0:*/		return 0x82162D18;
	}
	return 0x82162D18;
} // Block from 82162D14h-82162D18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D18);
		  /* 82162D18h */ case    0:  		/* mr R26, R19 */
		/* 82162D18h case    0:*/		regs.R26 = regs.R19;
		/* 82162D18h case    0:*/		return 0x82162D1C;
		  /* 82162D1Ch */ case    1:  		/* cmpwi CR6, R22, 0 */
		/* 82162D1Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82162D1Ch case    1:*/		return 0x82162D20;
		  /* 82162D20h */ case    2:  		/* mr R4, R27 */
		/* 82162D20h case    2:*/		regs.R4 = regs.R27;
		/* 82162D20h case    2:*/		return 0x82162D24;
		  /* 82162D24h */ case    3:  		/* mr R7, R23 */
		/* 82162D24h case    3:*/		regs.R7 = regs.R23;
		/* 82162D24h case    3:*/		return 0x82162D28;
		  /* 82162D28h */ case    4:  		/* addi R6, R1, 96 */
		/* 82162D28h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 82162D28h case    4:*/		return 0x82162D2C;
		  /* 82162D2Ch */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82162D2Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82162D4C;  }
		/* 82162D2Ch case    5:*/		return 0x82162D30;
		  /* 82162D30h */ case    6:  		/* li R11, 33 */
		/* 82162D30h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x21);
		/* 82162D30h case    6:*/		return 0x82162D34;
		  /* 82162D34h */ case    7:  		/* lwz R26, <#[R28]> */
		/* 82162D34h case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R28 + 0x00000000) );
		/* 82162D34h case    7:*/		return 0x82162D38;
		  /* 82162D38h */ case    8:  		/* li R5, 0 */
		/* 82162D38h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82162D38h case    8:*/		return 0x82162D3C;
		  /* 82162D3Ch */ case    9:  		/* rlwimi R4, R11, 0, 19, 31 */
		/* 82162D3Ch case    9:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R4,regs.R11);
		/* 82162D3Ch case    9:*/		return 0x82162D40;
		  /* 82162D40h */ case   10:  		/* addi R28, R28, 4 */
		/* 82162D40h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82162D40h case   10:*/		return 0x82162D44;
		  /* 82162D44h */ case   11:  		/* rlwimi R4, R11, 0, 1, 3 */
		/* 82162D44h case   11:*/		cpu::op::rlwimi<0,0,1,3>(regs,&regs.R4,regs.R11);
		/* 82162D44h case   11:*/		return 0x82162D48;
		  /* 82162D48h */ case   12:  		/* b 8 */
		/* 82162D48h case   12:*/		return 0x82162D50;
		/* 82162D48h case   12:*/		return 0x82162D4C;
	}
	return 0x82162D4C;
} // Block from 82162D18h-82162D4Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82162D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D4C);
		  /* 82162D4Ch */ case    0:  		/* mr R5, R25 */
		/* 82162D4Ch case    0:*/		regs.R5 = regs.R25;
		/* 82162D4Ch case    0:*/		return 0x82162D50;
	}
	return 0x82162D50;
} // Block from 82162D4Ch-82162D50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D50);
		  /* 82162D50h */ case    0:  		/* bl -8000 */
		/* 82162D50h case    0:*/		regs.LR = 0x82162D54; return 0x82160E10;
		/* 82162D50h case    0:*/		return 0x82162D54;
		  /* 82162D54h */ case    1:  		/* mr R24, R3 */
		/* 82162D54h case    1:*/		regs.R24 = regs.R3;
		/* 82162D54h case    1:*/		return 0x82162D58;
		  /* 82162D58h */ case    2:  		/* mr R29, R19 */
		/* 82162D58h case    2:*/		regs.R29 = regs.R19;
		/* 82162D58h case    2:*/		return 0x82162D5C;
		  /* 82162D5Ch */ case    3:  		/* cmplw CR6, R29, R30 */
		/* 82162D5Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 82162D5Ch case    3:*/		return 0x82162D60;
		  /* 82162D60h */ case    4:  		/* bc 4, CR6_LT, 100 */
		/* 82162D60h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82162DC4;  }
		/* 82162D60h case    4:*/		return 0x82162D64;
		  /* 82162D64h */ case    5:  		/* lwz R4, <#[R28]> */
		/* 82162D64h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 82162D64h case    5:*/		return 0x82162D68;
		  /* 82162D68h */ case    6:  		/* addi R28, R28, 4 */
		/* 82162D68h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82162D68h case    6:*/		return 0x82162D6C;
		  /* 82162D6Ch */ case    7:  		/* rlwinm R11, R4, 0, 18, 18 */
		/* 82162D6Ch case    7:*/		cpu::op::rlwinm<0,0,18,18>(regs,&regs.R11,regs.R4);
		/* 82162D6Ch case    7:*/		return 0x82162D70;
		  /* 82162D70h */ case    8:  		/* cmplwi CR6, R11, 8192 */
		/* 82162D70h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002000);
		/* 82162D70h case    8:*/		return 0x82162D74;
		  /* 82162D74h */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 82162D74h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82162D8C;  }
		/* 82162D74h case    9:*/		return 0x82162D78;
		  /* 82162D78h */ case   10:  		/* cmplwi CR6, R17, 512 */
		/* 82162D78h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000200);
		/* 82162D78h case   10:*/		return 0x82162D7C;
		  /* 82162D7Ch */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 82162D7Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x82162D8C;  }
		/* 82162D7Ch case   11:*/		return 0x82162D80;
		  /* 82162D80h */ case   12:  		/* lwz R5, <#[R28]> */
		/* 82162D80h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000000) );
		/* 82162D80h case   12:*/		return 0x82162D84;
		  /* 82162D84h */ case   13:  		/* addi R28, R28, 4 */
		/* 82162D84h case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82162D84h case   13:*/		return 0x82162D88;
		  /* 82162D88h */ case   14:  		/* b 8 */
		/* 82162D88h case   14:*/		return 0x82162D90;
		/* 82162D88h case   14:*/		return 0x82162D8C;
	}
	return 0x82162D8C;
} // Block from 82162D50h-82162D8Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82162D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D8C);
		  /* 82162D8Ch */ case    0:  		/* mr R5, R19 */
		/* 82162D8Ch case    0:*/		regs.R5 = regs.R19;
		/* 82162D8Ch case    0:*/		return 0x82162D90;
	}
	return 0x82162D90;
} // Block from 82162D8Ch-82162D90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162D90);
		  /* 82162D90h */ case    0:  		/* addi R11, R1, 96 */
		/* 82162D90h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82162D90h case    0:*/		return 0x82162D94;
		  /* 82162D94h */ case    1:  		/* mr R10, R17 */
		/* 82162D94h case    1:*/		regs.R10 = regs.R17;
		/* 82162D94h case    1:*/		return 0x82162D98;
		  /* 82162D98h */ case    2:  		/* rlwinm R9, R29, 0, 24, 31 */
		/* 82162D98h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R29);
		/* 82162D98h case    2:*/		return 0x82162D9C;
		  /* 82162D9Ch */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 82162D9Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82162D9Ch case    3:*/		return 0x82162DA0;
		  /* 82162DA0h */ case    4:  		/* mr R8, R31 */
		/* 82162DA0h case    4:*/		regs.R8 = regs.R31;
		/* 82162DA0h case    4:*/		return 0x82162DA4;
		  /* 82162DA4h */ case    5:  		/* mr R7, R20 */
		/* 82162DA4h case    5:*/		regs.R7 = regs.R20;
		/* 82162DA4h case    5:*/		return 0x82162DA8;
		  /* 82162DA8h */ case    6:  		/* addi R6, R1, 100 */
		/* 82162DA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 82162DA8h case    6:*/		return 0x82162DAC;
		  /* 82162DACh */ case    7:  		/* mr R3, R24 */
		/* 82162DACh case    7:*/		regs.R3 = regs.R24;
		/* 82162DACh case    7:*/		return 0x82162DB0;
		  /* 82162DB0h */ case    8:  		/* bl -6696 */
		/* 82162DB0h case    8:*/		regs.LR = 0x82162DB4; return 0x82161388;
		/* 82162DB0h case    8:*/		return 0x82162DB4;
		  /* 82162DB4h */ case    9:  		/* addi R29, R29, 1 */
		/* 82162DB4h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82162DB4h case    9:*/		return 0x82162DB8;
		  /* 82162DB8h */ case   10:  		/* mr R24, R3 */
		/* 82162DB8h case   10:*/		regs.R24 = regs.R3;
		/* 82162DB8h case   10:*/		return 0x82162DBC;
		  /* 82162DBCh */ case   11:  		/* cmplwi CR6, R29, 3 */
		/* 82162DBCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000003);
		/* 82162DBCh case   11:*/		return 0x82162DC0;
		  /* 82162DC0h */ case   12:  		/* bc 12, CR6_LT, -100 */
		/* 82162DC0h case   12:*/		if ( regs.CR[6].lt ) { return 0x82162D5C;  }
		/* 82162DC0h case   12:*/		return 0x82162DC4;
	}
	return 0x82162DC4;
} // Block from 82162D90h-82162DC4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82162DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162DC4);
		  /* 82162DC4h */ case    0:  		/* cmpwi CR6, R22, 0 */
		/* 82162DC4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82162DC4h case    0:*/		return 0x82162DC8;
		  /* 82162DC8h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 82162DC8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82162DF8;  }
		/* 82162DC8h case    1:*/		return 0x82162DCC;
		  /* 82162DCCh */ case    2:  		/* mr R9, R23 */
		/* 82162DCCh case    2:*/		regs.R9 = regs.R23;
		/* 82162DCCh case    2:*/		return 0x82162DD0;
		  /* 82162DD0h */ case    3:  		/* addi R8, R1, 96 */
		/* 82162DD0h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82162DD0h case    3:*/		return 0x82162DD4;
		  /* 82162DD4h */ case    4:  		/* lis R7, 228 */
		/* 82162DD4h case    4:*/		cpu::op::lis<0>(regs,&regs.R7,0xE4);
		/* 82162DD4h case    4:*/		return 0x82162DD8;
		  /* 82162DD8h */ case    5:  		/* mr R6, R26 */
		/* 82162DD8h case    5:*/		regs.R6 = regs.R26;
		/* 82162DD8h case    5:*/		return 0x82162DDC;
		  /* 82162DDCh */ case    6:  		/* mr R5, R25 */
		/* 82162DDCh case    6:*/		regs.R5 = regs.R25;
		/* 82162DDCh case    6:*/		return 0x82162DE0;
		  /* 82162DE0h */ case    7:  		/* mr R4, R27 */
		/* 82162DE0h case    7:*/		regs.R4 = regs.R27;
		/* 82162DE0h case    7:*/		return 0x82162DE4;
		  /* 82162DE4h */ case    8:  		/* mr R3, R24 */
		/* 82162DE4h case    8:*/		regs.R3 = regs.R24;
		/* 82162DE4h case    8:*/		return 0x82162DE8;
		  /* 82162DE8h */ case    9:  		/* bl -5720 */
		/* 82162DE8h case    9:*/		regs.LR = 0x82162DEC; return 0x82161790;
		/* 82162DE8h case    9:*/		return 0x82162DEC;
		  /* 82162DECh */ case   10:  		/* lwz R29, <#[R1 + 96]> */
		/* 82162DECh case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82162DECh case   10:*/		return 0x82162DF0;
		  /* 82162DF0h */ case   11:  		/* mr R24, R3 */
		/* 82162DF0h case   11:*/		regs.R24 = regs.R3;
		/* 82162DF0h case   11:*/		return 0x82162DF4;
		  /* 82162DF4h */ case   12:  		/* b 8 */
		/* 82162DF4h case   12:*/		return 0x82162DFC;
		/* 82162DF4h case   12:*/		return 0x82162DF8;
	}
	return 0x82162DF8;
} // Block from 82162DC4h-82162DF8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82162DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162DF8);
		  /* 82162DF8h */ case    0:  		/* lwz R29, <#[R1 + 96]> */
		/* 82162DF8h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82162DF8h case    0:*/		return 0x82162DFC;
	}
	return 0x82162DFC;
} // Block from 82162DF8h-82162DFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162DFC);
		  /* 82162DFCh */ case    0:  		/* lwz R4, <#[R28]> */
		/* 82162DFCh case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 82162DFCh case    0:*/		return 0x82162E00;
		  /* 82162E00h */ case    1:  		/* cmplwi CR6, R4, 65535 */
		/* 82162E00h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000FFFF);
		/* 82162E00h case    1:*/		return 0x82162E04;
		  /* 82162E04h */ case    2:  		/* bc 4, CR6_EQ, -1412 */
		/* 82162E04h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82162880;  }
		/* 82162E04h case    2:*/		return 0x82162E08;
		  /* 82162E08h */ case    3:  		/* lwz R27, <#[R1 + 340]> */
		/* 82162E08h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000154) );
		/* 82162E08h case    3:*/		return 0x82162E0C;
	}
	return 0x82162E0C;
} // Block from 82162DFCh-82162E0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82162E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162E0C);
		  /* 82162E0Ch */ case    0:  		/* lwz R11, <#[R16]> */
		/* 82162E0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82162E0Ch case    0:*/		return 0x82162E10;
		  /* 82162E10h */ case    1:  		/* add R11, R11, R29 */
		/* 82162E10h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82162E10h case    1:*/		return 0x82162E14;
		  /* 82162E14h */ case    2:  		/* cmplw CR6, R11, R15 */
		/* 82162E14h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 82162E14h case    2:*/		return 0x82162E18;
		  /* 82162E18h */ case    3:  		/* bc 4, CR6_LT, 180 */
		/* 82162E18h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82162ECC;  }
		/* 82162E18h case    3:*/		return 0x82162E1C;
		  /* 82162E1Ch */ case    4:  		/* cmplwi CR6, R17, 768 */
		/* 82162E1Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000300);
		/* 82162E1Ch case    4:*/		return 0x82162E20;
		  /* 82162E20h */ case    5:  		/* bc 4, CR6_LT, 84 */
		/* 82162E20h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82162E74;  }
		/* 82162E20h case    5:*/		return 0x82162E24;
		  /* 82162E24h */ case    6:  		/* lwz R9, <#[R23 + 4]> */
		/* 82162E24h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000004) );
		/* 82162E24h case    6:*/		return 0x82162E28;
		  /* 82162E28h */ case    7:  		/* mr R11, R24 */
		/* 82162E28h case    7:*/		regs.R11 = regs.R24;
		/* 82162E28h case    7:*/		return 0x82162E2C;
		  /* 82162E2Ch */ case    8:  		/* mr R10, R19 */
		/* 82162E2Ch case    8:*/		regs.R10 = regs.R19;
		/* 82162E2Ch case    8:*/		return 0x82162E30;
		  /* 82162E30h */ case    9:  		/* rlwinm. R9, R9, 0, 25, 25 */
		/* 82162E30h case    9:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R9,regs.R9);
		/* 82162E30h case    9:*/		return 0x82162E34;
		  /* 82162E34h */ case   10:  		/* bc 12, CR0_EQ, 56 */
		/* 82162E34h case   10:*/		if ( regs.CR[0].eq ) { return 0x82162E6C;  }
		/* 82162E34h case   10:*/		return 0x82162E38;
		  /* 82162E38h */ case   11:  		/* addi R10, R24, 4 */
		/* 82162E38h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0x4);
		/* 82162E38h case   11:*/		return 0x82162E3C;
		  /* 82162E3Ch */ case   12:  		/* li R9, 71 */
		/* 82162E3Ch case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x47);
		/* 82162E3Ch case   12:*/		return 0x82162E40;
		  /* 82162E40h */ case   13:  		/* addi R11, R10, 4 */
		/* 82162E40h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 82162E40h case   13:*/		return 0x82162E44;
		  /* 82162E44h */ case   14:  		/* stw R9, <#[R24]> */
		/* 82162E44h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R24 + 0x00000000) );
		/* 82162E44h case   14:*/		return 0x82162E48;
		  /* 82162E48h */ case   15:  		/* lis R10, 4 */
		/* 82162E48h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x4);
		/* 82162E48h case   15:*/		return 0x82162E4C;
		  /* 82162E4Ch */ case   16:  		/* lis R9, 77 */
		/* 82162E4Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R9,0x4D);
		/* 82162E4Ch case   16:*/		return 0x82162E50;
		  /* 82162E50h */ case   17:  		/* li R8, 1 */
		/* 82162E50h case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82162E50h case   17:*/		return 0x82162E54;
		  /* 82162E54h */ case   18:  		/* ori R7, R10, 50 */
		/* 82162E54h case   18:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x32);
		/* 82162E54h case   18:*/		return 0x82162E58;
		  /* 82162E58h */ case   19:  		/* stw R9, <#[R24 + 4]> */
		/* 82162E58h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R24 + 0x00000004) );
		/* 82162E58h case   19:*/		return 0x82162E5C;
		  /* 82162E5Ch */ case   20:  		/* stw R8, <#[R11]> */
		/* 82162E5Ch case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82162E5Ch case   20:*/		return 0x82162E60;
		  /* 82162E60h */ case   21:  		/* li R10, 4 */
		/* 82162E60h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82162E60h case   21:*/		return 0x82162E64;
		  /* 82162E64h */ case   22:  		/* stwu R7, <#[R11 + 4]> */
		/* 82162E64h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82162E64h case   22:*/		return 0x82162E68;
		  /* 82162E68h */ case   23:  		/* addi R11, R11, 4 */
		/* 82162E68h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82162E68h case   23:*/		return 0x82162E6C;
	}
	return 0x82162E6C;
} // Block from 82162E0Ch-82162E6Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 82162E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162E6C);
		  /* 82162E6Ch */ case    0:  		/* add R29, R10, R29 */
		/* 82162E6Ch case    0:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R29);
		/* 82162E6Ch case    0:*/		return 0x82162E70;
		  /* 82162E70h */ case    1:  		/* mr R24, R11 */
		/* 82162E70h case    1:*/		regs.R24 = regs.R11;
		/* 82162E70h case    1:*/		return 0x82162E74;
	}
	return 0x82162E74;
} // Block from 82162E6Ch-82162E74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162E74);
		  /* 82162E74h */ case    0:  		/* li R11, 40 */
		/* 82162E74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x28);
		/* 82162E74h case    0:*/		return 0x82162E78;
		  /* 82162E78h */ case    1:  		/* addic. R31, R29, 1 */
		/* 82162E78h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R29,0x1);
		/* 82162E78h case    1:*/		return 0x82162E7C;
		  /* 82162E7Ch */ case    2:  		/* addi R30, R28, 4 */
		/* 82162E7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R28,0x4);
		/* 82162E7Ch case    2:*/		return 0x82162E80;
		  /* 82162E80h */ case    3:  		/* stw R11, <#[R24]> */
		/* 82162E80h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82162E80h case    3:*/		return 0x82162E84;
		  /* 82162E84h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82162E84h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82162E8C;  }
		/* 82162E84h case    4:*/		return 0x82162E88;
		  /* 82162E88h */ case    5:  		/* bl 1065944 */
		/* 82162E88h case    5:*/		regs.LR = 0x82162E8C; return 0x82267260;
		/* 82162E88h case    5:*/		return 0x82162E8C;
	}
	return 0x82162E8C;
} // Block from 82162E74h-82162E8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82162E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162E8C);
		  /* 82162E8Ch */ case    0:  		/* lwz R11, <#[R1 + 308]> */
		/* 82162E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000134) );
		/* 82162E8Ch case    0:*/		return 0x82162E90;
		  /* 82162E90h */ case    1:  		/* subf R10, R14, R30 */
		/* 82162E90h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R14,regs.R30);
		/* 82162E90h case    1:*/		return 0x82162E94;
		  /* 82162E94h */ case    2:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 82162E94h case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 82162E94h case    2:*/		return 0x82162E98;
		  /* 82162E98h */ case    3:  		/* srawi R10, R10, 2 */
		/* 82162E98h case    3:*/		cpu::op::srawi<0,2>(regs,&regs.R10,regs.R10);
		/* 82162E98h case    3:*/		return 0x82162E9C;
		  /* 82162E9Ch */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 82162E9Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82162E9Ch case    4:*/		return 0x82162EA0;
		  /* 82162EA0h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82162EA0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82162EA8;  }
		/* 82162EA0h case    5:*/		return 0x82162EA4;
		  /* 82162EA4h */ case    6:  		/* bl 1065916 */
		/* 82162EA4h case    6:*/		regs.LR = 0x82162EA8; return 0x82267260;
		/* 82162EA4h case    6:*/		return 0x82162EA8;
	}
	return 0x82162EA8;
} // Block from 82162E8Ch-82162EA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82162EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162EA8);
		  /* 82162EA8h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 82162EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82162EA8h case    0:*/		return 0x82162EAC;
		  /* 82162EACh */ case    1:  		/* li R3, 0 */
		/* 82162EACh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82162EACh case    1:*/		return 0x82162EB0;
		  /* 82162EB0h */ case    2:  		/* lwz R10, <#[R1 + 100]> */
		/* 82162EB0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 82162EB0h case    2:*/		return 0x82162EB4;
		  /* 82162EB4h */ case    3:  		/* add R11, R11, R31 */
		/* 82162EB4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82162EB4h case    3:*/		return 0x82162EB8;
		  /* 82162EB8h */ case    4:  		/* addi R10, R10, 1 */
		/* 82162EB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82162EB8h case    4:*/		return 0x82162EBC;
		  /* 82162EBCh */ case    5:  		/* stw R11, <#[R16]> */
		/* 82162EBCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82162EBCh case    5:*/		return 0x82162EC0;
		  /* 82162EC0h */ case    6:  		/* stw R10, <#[R27]> */
		/* 82162EC0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82162EC0h case    6:*/		return 0x82162EC4;
		  /* 82162EC4h */ case    7:  		/* addi R1, R1, 272 */
		/* 82162EC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82162EC4h case    7:*/		return 0x82162EC8;
		  /* 82162EC8h */ case    8:  		/* b -859224 */
		/* 82162EC8h case    8:*/		return 0x82091270;
		/* 82162EC8h case    8:*/		return 0x82162ECC;
	}
	return 0x82162ECC;
} // Block from 82162EA8h-82162ECCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82162ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162ECC);
		  /* 82162ECCh */ case    0:  		/* lis R3, -30602 */
		/* 82162ECCh case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 82162ECCh case    0:*/		return 0x82162ED0;
		  /* 82162ED0h */ case    1:  		/* ori R3, R3, 2921 */
		/* 82162ED0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB69);
		/* 82162ED0h case    1:*/		return 0x82162ED4;
		  /* 82162ED4h */ case    2:  		/* b -16 */
		/* 82162ED4h case    2:*/		return 0x82162EC4;
		/* 82162ED4h case    2:*/		return 0x82162ED8;
	}
	return 0x82162ED8;
} // Block from 82162ECCh-82162ED8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82162ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162ED8);
		  /* 82162ED8h */ case    0:  		/* mfspr R12, LR */
		/* 82162ED8h case    0:*/		regs.R12 = regs.LR;
		/* 82162ED8h case    0:*/		return 0x82162EDC;
		  /* 82162EDCh */ case    1:  		/* bl -859284 */
		/* 82162EDCh case    1:*/		regs.LR = 0x82162EE0; return 0x82091248;
		/* 82162EDCh case    1:*/		return 0x82162EE0;
		  /* 82162EE0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82162EE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82162EE0h case    2:*/		return 0x82162EE4;
		  /* 82162EE4h */ case    3:  		/* mr R25, R4 */
		/* 82162EE4h case    3:*/		regs.R25 = regs.R4;
		/* 82162EE4h case    3:*/		return 0x82162EE8;
		  /* 82162EE8h */ case    4:  		/* mr R27, R5 */
		/* 82162EE8h case    4:*/		regs.R27 = regs.R5;
		/* 82162EE8h case    4:*/		return 0x82162EEC;
		  /* 82162EECh */ case    5:  		/* li R5, 1140 */
		/* 82162EECh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x474);
		/* 82162EECh case    5:*/		return 0x82162EF0;
		  /* 82162EF0h */ case    6:  		/* li R4, 0 */
		/* 82162EF0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82162EF0h case    6:*/		return 0x82162EF4;
		  /* 82162EF4h */ case    7:  		/* mr R31, R3 */
		/* 82162EF4h case    7:*/		regs.R31 = regs.R3;
		/* 82162EF4h case    7:*/		return 0x82162EF8;
		  /* 82162EF8h */ case    8:  		/* mr R26, R6 */
		/* 82162EF8h case    8:*/		regs.R26 = regs.R6;
		/* 82162EF8h case    8:*/		return 0x82162EFC;
		  /* 82162EFCh */ case    9:  		/* mr R29, R7 */
		/* 82162EFCh case    9:*/		regs.R29 = regs.R7;
		/* 82162EFCh case    9:*/		return 0x82162F00;
		  /* 82162F00h */ case   10:  		/* mr R28, R8 */
		/* 82162F00h case   10:*/		regs.R28 = regs.R8;
		/* 82162F00h case   10:*/		return 0x82162F04;
		  /* 82162F04h */ case   11:  		/* mr R30, R9 */
		/* 82162F04h case   11:*/		regs.R30 = regs.R9;
		/* 82162F04h case   11:*/		return 0x82162F08;
		  /* 82162F08h */ case   12:  		/* mr R24, R10 */
		/* 82162F08h case   12:*/		regs.R24 = regs.R10;
		/* 82162F08h case   12:*/		return 0x82162F0C;
		  /* 82162F0Ch */ case   13:  		/* bl -859084 */
		/* 82162F0Ch case   13:*/		regs.LR = 0x82162F10; return 0x82091340;
		/* 82162F0Ch case   13:*/		return 0x82162F10;
		  /* 82162F10h */ case   14:  		/* lwz R4, <#[R1 + 244]> */
		/* 82162F10h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000F4) );
		/* 82162F10h case   14:*/		return 0x82162F14;
		  /* 82162F14h */ case   15:  		/* stw R25, <#[R31 + 1052]> */
		/* 82162F14h case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000041C) );
		/* 82162F14h case   15:*/		return 0x82162F18;
	}
	return 0x82162F18;
} // Block from 82162ED8h-82162F18h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82162F18h
// Function '?r400VSConvertVtxTexture@XGRAPHICS@@YAPAKPAU_R400VSFUNC@1@KPAK1111KH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162F18);
		  /* 82162F18h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82162F18h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82162F18h case    0:*/		return 0x82162F1C;
		  /* 82162F1Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82162F1Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82162F34;  }
		/* 82162F1Ch case    1:*/		return 0x82162F20;
		  /* 82162F20h */ case    2:  		/* li R11, 1 */
		/* 82162F20h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82162F20h case    2:*/		return 0x82162F24;
		  /* 82162F24h */ case    3:  		/* addi R3, R31, 176 */
		/* 82162F24h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xB0);
		/* 82162F24h case    3:*/		return 0x82162F28;
		  /* 82162F28h */ case    4:  		/* stw R11, <#[R31 + 980]> */
		/* 82162F28h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000003D4) );
		/* 82162F28h case    4:*/		return 0x82162F2C;
		  /* 82162F2Ch */ case    5:  		/* li R5, 768 */
		/* 82162F2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x300);
		/* 82162F2Ch case    5:*/		return 0x82162F30;
		  /* 82162F30h */ case    6:  		/* bl -857472 */
		/* 82162F30h case    6:*/		regs.LR = 0x82162F34; return 0x820919B0;
		/* 82162F30h case    6:*/		return 0x82162F34;
	}
	return 0x82162F34;
} // Block from 82162F18h-82162F34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82162F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162F34);
		  /* 82162F34h */ case    0:  		/* stw R27, <#[R31]> */
		/* 82162F34h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 82162F34h case    0:*/		return 0x82162F38;
		  /* 82162F38h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82162F38h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82162F38h case    1:*/		return 0x82162F3C;
		  /* 82162F3Ch */ case    2:  		/* stw R26, <#[R31 + 4]> */
		/* 82162F3Ch case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000004) );
		/* 82162F3Ch case    2:*/		return 0x82162F40;
		  /* 82162F40h */ case    3:  		/* stw R29, <#[R31 + 8]> */
		/* 82162F40h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 82162F40h case    3:*/		return 0x82162F44;
		  /* 82162F44h */ case    4:  		/* stw R28, <#[R31 + 12]> */
		/* 82162F44h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 82162F44h case    4:*/		return 0x82162F48;
		  /* 82162F48h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82162F48h case    5:*/		if ( regs.CR[6].eq ) { return 0x82162F6C;  }
		/* 82162F48h case    5:*/		return 0x82162F4C;
		  /* 82162F4Ch */ case    6:  		/* li R5, 32 */
		/* 82162F4Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 82162F4Ch case    6:*/		return 0x82162F50;
		  /* 82162F50h */ case    7:  		/* li R4, 255 */
		/* 82162F50h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82162F50h case    7:*/		return 0x82162F54;
		  /* 82162F54h */ case    8:  		/* addi R3, R31, 944 */
		/* 82162F54h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x3B0);
		/* 82162F54h case    8:*/		return 0x82162F58;
		  /* 82162F58h */ case    9:  		/* bl -859160 */
		/* 82162F58h case    9:*/		regs.LR = 0x82162F5C; return 0x82091340;
		/* 82162F58h case    9:*/		return 0x82162F5C;
		  /* 82162F5Ch */ case   10:  		/* addi R3, R31, 16 */
		/* 82162F5Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 82162F5Ch case   10:*/		return 0x82162F60;
		  /* 82162F60h */ case   11:  		/* li R5, 32 */
		/* 82162F60h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 82162F60h case   11:*/		return 0x82162F64;
		  /* 82162F64h */ case   12:  		/* mr R4, R30 */
		/* 82162F64h case   12:*/		regs.R4 = regs.R30;
		/* 82162F64h case   12:*/		return 0x82162F68;
		  /* 82162F68h */ case   13:  		/* bl -857528 */
		/* 82162F68h case   13:*/		regs.LR = 0x82162F6C; return 0x820919B0;
		/* 82162F68h case   13:*/		return 0x82162F6C;
	}
	return 0x82162F6C;
} // Block from 82162F34h-82162F6Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82162F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162F6C);
		  /* 82162F6Ch */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82162F6Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82162F6Ch case    0:*/		return 0x82162F70;
		  /* 82162F70h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82162F70h case    1:*/		if ( regs.CR[6].eq ) { return 0x82162F8C;  }
		/* 82162F70h case    1:*/		return 0x82162F74;
		  /* 82162F74h */ case    2:  		/* li R11, -1 */
		/* 82162F74h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82162F74h case    2:*/		return 0x82162F78;
		  /* 82162F78h */ case    3:  		/* addi R3, R31, 48 */
		/* 82162F78h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x30);
		/* 82162F78h case    3:*/		return 0x82162F7C;
		  /* 82162F7Ch */ case    4:  		/* stw R11, <#[R31 + 976]> */
		/* 82162F7Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000003D0) );
		/* 82162F7Ch case    4:*/		return 0x82162F80;
		  /* 82162F80h */ case    5:  		/* li R5, 128 */
		/* 82162F80h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 82162F80h case    5:*/		return 0x82162F84;
		  /* 82162F84h */ case    6:  		/* mr R4, R24 */
		/* 82162F84h case    6:*/		regs.R4 = regs.R24;
		/* 82162F84h case    6:*/		return 0x82162F88;
		  /* 82162F88h */ case    7:  		/* bl -857560 */
		/* 82162F88h case    7:*/		regs.LR = 0x82162F8C; return 0x820919B0;
		/* 82162F88h case    7:*/		return 0x82162F8C;
	}
	return 0x82162F8C;
} // Block from 82162F6Ch-82162F8Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82162F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162F8C);
		  /* 82162F8Ch */ case    0:  		/* lwz R11, <#[R1 + 252]> */
		/* 82162F8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000FC) );
		/* 82162F8Ch case    0:*/		return 0x82162F90;
		  /* 82162F90h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 82162F90h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82162F90h case    1:*/		return 0x82162F94;
		  /* 82162F94h */ case    2:  		/* lwz R10, <#[R1 + 260]> */
		/* 82162F94h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 82162F94h case    2:*/		return 0x82162F98;
		  /* 82162F98h */ case    3:  		/* stw R11, <#[R31 + 1020]> */
		/* 82162F98h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000003FC) );
		/* 82162F98h case    3:*/		return 0x82162F9C;
		  /* 82162F9Ch */ case    4:  		/* stw R10, <#[R31 + 1024]> */
		/* 82162F9Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000400) );
		/* 82162F9Ch case    4:*/		return 0x82162FA0;
		  /* 82162FA0h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 82162FA0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82162FCC;  }
		/* 82162FA0h case    5:*/		return 0x82162FA4;
		  /* 82162FA4h */ case    6:  		/* rlwinm. R11, R27, 0, 15, 15 */
		/* 82162FA4h case    6:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R11,regs.R27);
		/* 82162FA4h case    6:*/		return 0x82162FA8;
		  /* 82162FA8h */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 82162FA8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82162FC4;  }
		/* 82162FA8h case    7:*/		return 0x82162FAC;
		  /* 82162FACh */ case    8:  		/* rlwinm R11, R26, 0, 13, 13 */
		/* 82162FACh case    8:*/		cpu::op::rlwinm<0,0,13,13>(regs,&regs.R11,regs.R26);
		/* 82162FACh case    8:*/		return 0x82162FB0;
		  /* 82162FB0h */ case    9:  		/* cntlzw R11, R11 */
		/* 82162FB0h case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82162FB0h case    9:*/		return 0x82162FB4;
		  /* 82162FB4h */ case   10:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82162FB4h case   10:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82162FB4h case   10:*/		return 0x82162FB8;
		  /* 82162FB8h */ case   11:  		/* xori R11, R11, 1 */
		/* 82162FB8h case   11:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82162FB8h case   11:*/		return 0x82162FBC;
		  /* 82162FBCh */ case   12:  		/* addi R11, R11, 1 */
		/* 82162FBCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82162FBCh case   12:*/		return 0x82162FC0;
		  /* 82162FC0h */ case   13:  		/* b 16 */
		/* 82162FC0h case   13:*/		return 0x82162FD0;
		/* 82162FC0h case   13:*/		return 0x82162FC4;
	}
	return 0x82162FC4;
} // Block from 82162F8Ch-82162FC4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82162FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162FC4);
		  /* 82162FC4h */ case    0:  		/* li R11, 0 */
		/* 82162FC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82162FC4h case    0:*/		return 0x82162FC8;
		  /* 82162FC8h */ case    1:  		/* b 8 */
		/* 82162FC8h case    1:*/		return 0x82162FD0;
		/* 82162FC8h case    1:*/		return 0x82162FCC;
	}
	return 0x82162FCC;
} // Block from 82162FC4h-82162FCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82162FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162FCC);
		  /* 82162FCCh */ case    0:  		/* rlwinm R11, R27, 15, 31, 31 */
		/* 82162FCCh case    0:*/		cpu::op::rlwinm<0,15,31,31>(regs,&regs.R11,regs.R27);
		/* 82162FCCh case    0:*/		return 0x82162FD0;
	}
	return 0x82162FD0;
} // Block from 82162FCCh-82162FD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82162FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162FD0);
		  /* 82162FD0h */ case    0:  		/* stw R11, <#[R31 + 1096]> */
		/* 82162FD0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000448) );
		/* 82162FD0h case    0:*/		return 0x82162FD4;
		  /* 82162FD4h */ case    1:  		/* mr R3, R31 */
		/* 82162FD4h case    1:*/		regs.R3 = regs.R31;
		/* 82162FD4h case    1:*/		return 0x82162FD8;
		  /* 82162FD8h */ case    2:  		/* addi R1, R1, 160 */
		/* 82162FD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82162FD8h case    2:*/		return 0x82162FDC;
		  /* 82162FDCh */ case    3:  		/* b -859460 */
		/* 82162FDCh case    3:*/		return 0x82091298;
		/* 82162FDCh case    3:*/		return 0x82162FE0;
	}
	return 0x82162FE0;
} // Block from 82162FD0h-82162FE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82162FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82162FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82162FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82162FE0);
		  /* 82162FE0h */ case    0:  		/* mfspr R12, LR */
		/* 82162FE0h case    0:*/		regs.R12 = regs.LR;
		/* 82162FE0h case    0:*/		return 0x82162FE4;
		  /* 82162FE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82162FE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82162FE4h case    1:*/		return 0x82162FE8;
		  /* 82162FE8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82162FE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82162FE8h case    2:*/		return 0x82162FEC;
		  /* 82162FECh */ case    3:  		/* lwz R10, <#[R3 + 1092]> */
		/* 82162FECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000444) );
		/* 82162FECh case    3:*/		return 0x82162FF0;
		  /* 82162FF0h */ case    4:  		/* mr R11, R4 */
		/* 82162FF0h case    4:*/		regs.R11 = regs.R4;
		/* 82162FF0h case    4:*/		return 0x82162FF4;
		  /* 82162FF4h */ case    5:  		/* cmpwi CR6, R10, 0 */
		/* 82162FF4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82162FF4h case    5:*/		return 0x82162FF8;
		  /* 82162FF8h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82162FF8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82163010;  }
		/* 82162FF8h case    6:*/		return 0x82162FFC;
		  /* 82162FFCh */ case    7:  		/* li R5, 84 */
		/* 82162FFCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x54);
		/* 82162FFCh case    7:*/		return 0x82163000;
		  /* 82163000h */ case    8:  		/* li R4, -1 */
		/* 82163000h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82163000h case    8:*/		return 0x82163004;
		  /* 82163004h */ case    9:  		/* mr R3, R11 */
		/* 82163004h case    9:*/		regs.R3 = regs.R11;
		/* 82163004h case    9:*/		return 0x82163008;
		  /* 82163008h */ case   10:  		/* bl -859336 */
		/* 82163008h case   10:*/		regs.LR = 0x8216300C; return 0x82091340;
		/* 82163008h case   10:*/		return 0x8216300C;
		  /* 8216300Ch */ case   11:  		/* b 1352 */
		/* 8216300Ch case   11:*/		return 0x82163554;
		/* 8216300Ch case   11:*/		return 0x82163010;
	}
	return 0x82163010;
} // Block from 82162FE0h-82163010h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82163010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163010);
		  /* 82163010h */ case    0:  		/* lwz R10, <#[R3 + 1084]> */
		/* 82163010h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000043C) );
		/* 82163010h case    0:*/		return 0x82163014;
		  /* 82163014h */ case    1:  		/* lis R9, -32252 */
		/* 82163014h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 82163014h case    1:*/		return 0x82163018;
		  /* 82163018h */ case    2:  		/* lis R8, -32256 */
		/* 82163018h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82163018h case    2:*/		return 0x8216301C;
		  /* 8216301Ch */ case    3:  		/* lis R7, -32256 */
		/* 8216301Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 8216301Ch case    3:*/		return 0x82163020;
		  /* 82163020h */ case    4:  		/* std R10, <#[R1 + 80]> */
		/* 82163020h case    4:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82163020h case    4:*/		return 0x82163024;
		  /* 82163024h */ case    5:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82163024h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82163024h case    5:*/		return 0x82163028;
		  /* 82163028h */ case    6:  		/* fcfid FR13, FR0 */
		/* 82163028h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR0);
		/* 82163028h case    6:*/		return 0x8216302C;
		  /* 8216302Ch */ case    7:  		/* lis R10, -32256 */
		/* 8216302Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8216302Ch case    7:*/		return 0x82163030;
		  /* 82163030h */ case    8:  		/* frsp FR11, FR13 */
		/* 82163030h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR13);
		/* 82163030h case    8:*/		return 0x82163034;
		  /* 82163034h */ case    9:  		/* lfs FR0, <#[R9 - 17772]> */
		/* 82163034h case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0xFFFFBA94) );
		/* 82163034h case    9:*/		return 0x82163038;
		  /* 82163038h */ case   10:  		/* lfs FR12, <#[R10 + 8464]> */
		/* 82163038h case   10:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00002110) );
		/* 82163038h case   10:*/		return 0x8216303C;
		  /* 8216303Ch */ case   11:  		/* lfs FR13, <#[R8 + 2988]> */
		/* 8216303Ch case   11:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R8 + 0x00000BAC) );
		/* 8216303Ch case   11:*/		return 0x82163040;
		  /* 82163040h */ case   12:  		/* lfs FR5, <#[R7 + 1820]> */
		/* 82163040h case   12:*/		cpu::mem::load32f( regs, &regs.FR5, (uint32)(regs.R7 + 0x0000071C) );
		/* 82163040h case   12:*/		return 0x82163044;
		  /* 82163044h */ case   13:  		/* fmuls FR11, FR11, FR0 */
		/* 82163044h case   13:*/		cpu::op::fmuls<0>(regs,&regs.FR11,regs.FR11,regs.FR0);
		/* 82163044h case   13:*/		return 0x82163048;
		  /* 82163048h */ case   14:  		/* stfs FR11, <#[R11]> */
		/* 82163048h case   14:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R11 + 0x00000000) );
		/* 82163048h case   14:*/		return 0x8216304C;
		  /* 8216304Ch */ case   15:  		/* lwz R10, <#[R3 + 1080]> */
		/* 8216304Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000438) );
		/* 8216304Ch case   15:*/		return 0x82163050;
		  /* 82163050h */ case   16:  		/* std R10, <#[R1 + 80]> */
		/* 82163050h case   16:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82163050h case   16:*/		return 0x82163054;
		  /* 82163054h */ case   17:  		/* lfd FR11, <#[R1 + 80]> */
		/* 82163054h case   17:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000050) );
		/* 82163054h case   17:*/		return 0x82163058;
		  /* 82163058h */ case   18:  		/* fcfid FR11, FR11 */
		/* 82163058h case   18:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 82163058h case   18:*/		return 0x8216305C;
		  /* 8216305Ch */ case   19:  		/* frsp FR11, FR11 */
		/* 8216305Ch case   19:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 8216305Ch case   19:*/		return 0x82163060;
		  /* 82163060h */ case   20:  		/* fmuls FR0, FR11, FR0 */
		/* 82163060h case   20:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR11,regs.FR0);
		/* 82163060h case   20:*/		return 0x82163064;
		  /* 82163064h */ case   21:  		/* stfs FR0, <#[R11 + 4]> */
		/* 82163064h case   21:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000004) );
		/* 82163064h case   21:*/		return 0x82163068;
		  /* 82163068h */ case   22:  		/* lwz R10, <#[R3 + 1088]> */
		/* 82163068h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000440) );
		/* 82163068h case   22:*/		return 0x8216306C;
		  /* 8216306Ch */ case   23:  		/* std R10, <#[R1 + 80]> */
		/* 8216306Ch case   23:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8216306Ch case   23:*/		return 0x82163070;
		  /* 82163070h */ case   24:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82163070h case   24:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82163070h case   24:*/		return 0x82163074;
		  /* 82163074h */ case   25:  		/* fcfid FR0, FR0 */
		/* 82163074h case   25:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82163074h case   25:*/		return 0x82163078;
		  /* 82163078h */ case   26:  		/* frsp FR0, FR0 */
		/* 82163078h case   26:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82163078h case   26:*/		return 0x8216307C;
		  /* 8216307Ch */ case   27:  		/* fmuls FR0, FR0, FR13 */
		/* 8216307Ch case   27:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 8216307Ch case   27:*/		return 0x82163080;
		  /* 82163080h */ case   28:  		/* stfs FR0, <#[R11 + 28]> */
		/* 82163080h case   28:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000001C) );
		/* 82163080h case   28:*/		return 0x82163084;
		  /* 82163084h */ case   29:  		/* lwz R10, <#[R3 + 1060]> */
		/* 82163084h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000424) );
		/* 82163084h case   29:*/		return 0x82163088;
		  /* 82163088h */ case   30:  		/* std R10, <#[R1 + 80]> */
		/* 82163088h case   30:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82163088h case   30:*/		return 0x8216308C;
		  /* 8216308Ch */ case   31:  		/* lfd FR0, <#[R1 + 80]> */
		/* 8216308Ch case   31:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8216308Ch case   31:*/		return 0x82163090;
		  /* 82163090h */ case   32:  		/* lwz R10, <#[R3 + 1068]> */
		/* 82163090h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000042C) );
		/* 82163090h case   32:*/		return 0x82163094;
		  /* 82163094h */ case   33:  		/* std R10, <#[R1 + 80]> */
		/* 82163094h case   33:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82163094h case   33:*/		return 0x82163098;
		  /* 82163098h */ case   34:  		/* fcfid FR0, FR0 */
		/* 82163098h case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82163098h case   34:*/		return 0x8216309C;
		  /* 8216309Ch */ case   35:  		/* lfd FR13, <#[R1 + 80]> */
		/* 8216309Ch case   35:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 8216309Ch case   35:*/		return 0x821630A0;
		  /* 821630A0h */ case   36:  		/* frsp FR0, FR0 */
		/* 821630A0h case   36:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 821630A0h case   36:*/		return 0x821630A4;
		  /* 821630A4h */ case   37:  		/* fcfid FR13, FR13 */
		/* 821630A4h case   37:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821630A4h case   37:*/		return 0x821630A8;
		  /* 821630A8h */ case   38:  		/* fmuls FR0, FR0, FR5 */
		/* 821630A8h case   38:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR5);
		/* 821630A8h case   38:*/		return 0x821630AC;
		  /* 821630ACh */ case   39:  		/* frsp FR13, FR13 */
		/* 821630ACh case   39:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821630ACh case   39:*/		return 0x821630B0;
		  /* 821630B0h */ case   40:  		/* fmuls FR13, FR13, FR12 */
		/* 821630B0h case   40:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 821630B0h case   40:*/		return 0x821630B4;
		  /* 821630B4h */ case   41:  		/* fcmpu CR6, FR0, FR13 */
		/* 821630B4h case   41:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 821630B4h case   41:*/		return 0x821630B8;
		  /* 821630B8h */ case   42:  		/* bc 12, CR6_GT, 8 */
		/* 821630B8h case   42:*/		if ( regs.CR[6].gt ) { return 0x821630C0;  }
		/* 821630B8h case   42:*/		return 0x821630BC;
		  /* 821630BCh */ case   43:  		/* fmr FR0, FR13 */
		/* 821630BCh case   43:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 821630BCh case   43:*/		return 0x821630C0;
	}
	return 0x821630C0;
} // Block from 82163010h-821630C0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 821630C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821630C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821630C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821630C0);
		  /* 821630C0h */ case    0:  		/* stfs FR0, <#[R11 + 20]> */
		/* 821630C0h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000014) );
		/* 821630C0h case    0:*/		return 0x821630C4;
		  /* 821630C4h */ case    1:  		/* lwz R10, <#[R3 + 1064]> */
		/* 821630C4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000428) );
		/* 821630C4h case    1:*/		return 0x821630C8;
		  /* 821630C8h */ case    2:  		/* std R10, <#[R1 + 80]> */
		/* 821630C8h case    2:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821630C8h case    2:*/		return 0x821630CC;
		  /* 821630CCh */ case    3:  		/* lwz R9, <#[R3 + 1056]> */
		/* 821630CCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000420) );
		/* 821630CCh case    3:*/		return 0x821630D0;
		  /* 821630D0h */ case    4:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821630D0h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821630D0h case    4:*/		return 0x821630D4;
		  /* 821630D4h */ case    5:  		/* std R9, <#[R1 + 80]> */
		/* 821630D4h case    5:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821630D4h case    5:*/		return 0x821630D8;
		  /* 821630D8h */ case    6:  		/* fcfid FR13, FR13 */
		/* 821630D8h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821630D8h case    6:*/		return 0x821630DC;
		  /* 821630DCh */ case    7:  		/* lfd FR11, <#[R1 + 80]> */
		/* 821630DCh case    7:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000050) );
		/* 821630DCh case    7:*/		return 0x821630E0;
		  /* 821630E0h */ case    8:  		/* frsp FR13, FR13 */
		/* 821630E0h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821630E0h case    8:*/		return 0x821630E4;
		  /* 821630E4h */ case    9:  		/* fcfid FR11, FR11 */
		/* 821630E4h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 821630E4h case    9:*/		return 0x821630E8;
		  /* 821630E8h */ case   10:  		/* mr R10, R9 */
		/* 821630E8h case   10:*/		regs.R10 = regs.R9;
		/* 821630E8h case   10:*/		return 0x821630EC;
		  /* 821630ECh */ case   11:  		/* fmuls FR12, FR13, FR12 */
		/* 821630ECh case   11:*/		cpu::op::fmuls<0>(regs,&regs.FR12,regs.FR13,regs.FR12);
		/* 821630ECh case   11:*/		return 0x821630F0;
		  /* 821630F0h */ case   12:  		/* frsp FR11, FR11 */
		/* 821630F0h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 821630F0h case   12:*/		return 0x821630F4;
		  /* 821630F4h */ case   13:  		/* fmuls FR11, FR11, FR5 */
		/* 821630F4h case   13:*/		cpu::op::fmuls<0>(regs,&regs.FR11,regs.FR11,regs.FR5);
		/* 821630F4h case   13:*/		return 0x821630F8;
		  /* 821630F8h */ case   14:  		/* fcmpu CR6, FR11, FR12 */
		/* 821630F8h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR12);
		/* 821630F8h case   14:*/		return 0x821630FC;
		  /* 821630FCh */ case   15:  		/* bc 4, CR6_GT, 8 */
		/* 821630FCh case   15:*/		if ( !regs.CR[6].gt ) { return 0x82163104;  }
		/* 821630FCh case   15:*/		return 0x82163100;
		  /* 82163100h */ case   16:  		/* fmr FR12, FR11 */
		/* 82163100h case   16:*/		cpu::op::fmr<0>(regs,&regs.FR12,regs.FR11);
		/* 82163100h case   16:*/		return 0x82163104;
	}
	return 0x82163104;
} // Block from 821630C0h-82163104h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82163104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163104);
		  /* 82163104h */ case    0:  		/* stfs FR12, <#[R11 + 24]> */
		/* 82163104h case    0:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R11 + 0x00000018) );
		/* 82163104h case    0:*/		return 0x82163108;
		  /* 82163108h */ case    1:  		/* lwz R10, <#[R3 + 1076]> */
		/* 82163108h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000434) );
		/* 82163108h case    1:*/		return 0x8216310C;
		  /* 8216310Ch */ case    2:  		/* std R10, <#[R1 + 80]> */
		/* 8216310Ch case    2:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8216310Ch case    2:*/		return 0x82163110;
		  /* 82163110h */ case    3:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82163110h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82163110h case    3:*/		return 0x82163114;
		  /* 82163114h */ case    4:  		/* fcfid FR13, FR13 */
		/* 82163114h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82163114h case    4:*/		return 0x82163118;
		  /* 82163118h */ case    5:  		/* lis R10, -32256 */
		/* 82163118h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82163118h case    5:*/		return 0x8216311C;
		  /* 8216311Ch */ case    6:  		/* frsp FR13, FR13 */
		/* 8216311Ch case    6:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8216311Ch case    6:*/		return 0x82163120;
		  /* 82163120h */ case    7:  		/* lfs FR9, <#[R10 + 2980]> */
		/* 82163120h case    7:*/		cpu::mem::load32f( regs, &regs.FR9, (uint32)(regs.R10 + 0x00000BA4) );
		/* 82163120h case    7:*/		return 0x82163124;
		  /* 82163124h */ case    8:  		/* fmuls FR13, FR13, FR9 */
		/* 82163124h case    8:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR13,regs.FR9);
		/* 82163124h case    8:*/		return 0x82163128;
		  /* 82163128h */ case    9:  		/* stfs FR13, <#[R11 + 12]> */
		/* 82163128h case    9:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x0000000C) );
		/* 82163128h case    9:*/		return 0x8216312C;
		  /* 8216312Ch */ case   10:  		/* lwz R10, <#[R3 + 1072]> */
		/* 8216312Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000430) );
		/* 8216312Ch case   10:*/		return 0x82163130;
		  /* 82163130h */ case   11:  		/* std R10, <#[R1 + 80]> */
		/* 82163130h case   11:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82163130h case   11:*/		return 0x82163134;
		  /* 82163134h */ case   12:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82163134h case   12:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82163134h case   12:*/		return 0x82163138;
		  /* 82163138h */ case   13:  		/* fcfid FR13, FR13 */
		/* 82163138h case   13:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82163138h case   13:*/		return 0x8216313C;
		  /* 8216313Ch */ case   14:  		/* frsp FR13, FR13 */
		/* 8216313Ch case   14:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8216313Ch case   14:*/		return 0x82163140;
		  /* 82163140h */ case   15:  		/* fmuls FR13, FR13, FR9 */
		/* 82163140h case   15:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR13,regs.FR9);
		/* 82163140h case   15:*/		return 0x82163144;
		  /* 82163144h */ case   16:  		/* stfs FR13, <#[R11 + 16]> */
		/* 82163144h case   16:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x00000010) );
		/* 82163144h case   16:*/		return 0x82163148;
		  /* 82163148h */ case   17:  		/* lwz R10, <#[R3 + 1052]> */
		/* 82163148h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000041C) );
		/* 82163148h case   17:*/		return 0x8216314C;
		  /* 8216314Ch */ case   18:  		/* cmpwi CR6, R10, 0 */
		/* 8216314Ch case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8216314Ch case   18:*/		return 0x82163150;
		  /* 82163150h */ case   19:  		/* bc 12, CR6_EQ, 16 */
		/* 82163150h case   19:*/		if ( regs.CR[6].eq ) { return 0x82163160;  }
		/* 82163150h case   19:*/		return 0x82163154;
		  /* 82163154h */ case   20:  		/* lis R10, -32256 */
		/* 82163154h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82163154h case   20:*/		return 0x82163158;
		  /* 82163158h */ case   21:  		/* lfs FR10, <#[R10 + 1816]> */
		/* 82163158h case   21:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R10 + 0x00000718) );
		/* 82163158h case   21:*/		return 0x8216315C;
		  /* 8216315Ch */ case   22:  		/* b 116 */
		/* 8216315Ch case   22:*/		return 0x821631D0;
		/* 8216315Ch case   22:*/		return 0x82163160;
	}
	return 0x82163160;
} // Block from 82163104h-82163160h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82163160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163160);
		  /* 82163160h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 82163160h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82163160h case    0:*/		return 0x82163164;
		  /* 82163164h */ case    1:  		/* lwz R9, <#[R3 + 4]> */
		/* 82163164h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 82163164h case    1:*/		return 0x82163168;
		  /* 82163168h */ case    2:  		/* rlwinm R10, R10, 12, 28, 31 */
		/* 82163168h case    2:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R10,regs.R10);
		/* 82163168h case    2:*/		return 0x8216316C;
		  /* 8216316Ch */ case    3:  		/* rlwinm R9, R9, 0, 28, 29 */
		/* 8216316Ch case    3:*/		cpu::op::rlwinm<0,0,28,29>(regs,&regs.R9,regs.R9);
		/* 8216316Ch case    3:*/		return 0x82163170;
		  /* 82163170h */ case    4:  		/* addi R10, R10, 1 */
		/* 82163170h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82163170h case    4:*/		return 0x82163174;
		  /* 82163174h */ case    5:  		/* cmplwi CR6, R9, 8 */
		/* 82163174h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000008);
		/* 82163174h case    5:*/		return 0x82163178;
		  /* 82163178h */ case    6:  		/* rldicl R10, R10, 0, 32 */
		/* 82163178h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82163178h case    6:*/		return 0x8216317C;
		  /* 8216317Ch */ case    7:  		/* std R10, <#[R1 + 80]> */
		/* 8216317Ch case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8216317Ch case    7:*/		return 0x82163180;
		  /* 82163180h */ case    8:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82163180h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82163180h case    8:*/		return 0x82163184;
		  /* 82163184h */ case    9:  		/* fcfid FR13, FR13 */
		/* 82163184h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82163184h case    9:*/		return 0x82163188;
		  /* 82163188h */ case   10:  		/* frsp FR10, FR13 */
		/* 82163188h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR13);
		/* 82163188h case   10:*/		return 0x8216318C;
		  /* 8216318Ch */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 8216318Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821631AC;  }
		/* 8216318Ch case   11:*/		return 0x82163190;
		  /* 82163190h */ case   12:  		/* lis R10, -32256 */
		/* 82163190h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82163190h case   12:*/		return 0x82163194;
		  /* 82163194h */ case   13:  		/* lfs FR8, <#[R10 + 8444]> */
		/* 82163194h case   13:*/		cpu::mem::load32f( regs, &regs.FR8, (uint32)(regs.R10 + 0x000020FC) );
		/* 82163194h case   13:*/		return 0x82163198;
		  /* 82163198h */ case   14:  		/* fcmpu CR6, FR10, FR8 */
		/* 82163198h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR8);
		/* 82163198h case   14:*/		return 0x8216319C;
		  /* 8216319Ch */ case   15:  		/* bc 12, CR6_GT, 32 */
		/* 8216319Ch case   15:*/		if ( regs.CR[6].gt ) { return 0x821631BC;  }
		/* 8216319Ch case   15:*/		return 0x821631A0;
		  /* 821631A0h */ case   16:  		/* lis R10, -32256 */
		/* 821631A0h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821631A0h case   16:*/		return 0x821631A4;
		  /* 821631A4h */ case   17:  		/* lfs FR10, <#[R10 + 8432]> */
		/* 821631A4h case   17:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R10 + 0x000020F0) );
		/* 821631A4h case   17:*/		return 0x821631A8;
		  /* 821631A8h */ case   18:  		/* b 40 */
		/* 821631A8h case   18:*/		return 0x821631D0;
		/* 821631A8h case   18:*/		return 0x821631AC;
	}
	return 0x821631AC;
} // Block from 82163160h-821631ACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821631ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631AC);
		  /* 821631ACh */ case    0:  		/* lis R10, -32256 */
		/* 821631ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821631ACh case    0:*/		return 0x821631B0;
		  /* 821631B0h */ case    1:  		/* lfs FR8, <#[R10 + 2752]> */
		/* 821631B0h case    1:*/		cpu::mem::load32f( regs, &regs.FR8, (uint32)(regs.R10 + 0x00000AC0) );
		/* 821631B0h case    1:*/		return 0x821631B4;
		  /* 821631B4h */ case    2:  		/* fcmpu CR6, FR10, FR8 */
		/* 821631B4h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR8);
		/* 821631B4h case    2:*/		return 0x821631B8;
		  /* 821631B8h */ case    3:  		/* bc 4, CR6_GT, 16 */
		/* 821631B8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821631C8;  }
		/* 821631B8h case    3:*/		return 0x821631BC;
	}
	return 0x821631BC;
} // Block from 821631ACh-821631BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821631BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631BC);
		  /* 821631BCh */ case    0:  		/* fmuls FR13, FR10, FR9 */
		/* 821631BCh case    0:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR10,regs.FR9);
		/* 821631BCh case    0:*/		return 0x821631C0;
	}
	return 0x821631C0;
} // Block from 821631BCh-821631C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821631C0h
// Function '?r400VSConvertShader@XGRAPHICS@@YAJPAU_ATID3DCTX@@PAKKKPAU_R400VSFUNC@1@11K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631C0);
		  /* 821631C0h */ case    0:  		/* stfs FR13, <#[R11 + 8]> */
		/* 821631C0h case    0:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x00000008) );
		/* 821631C0h case    0:*/		return 0x821631C4;
		  /* 821631C4h */ case    1:  		/* b 16 */
		/* 821631C4h case    1:*/		return 0x821631D4;
		/* 821631C4h case    1:*/		return 0x821631C8;
	}
	return 0x821631C8;
} // Block from 821631C0h-821631C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821631C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631C8);
		  /* 821631C8h */ case    0:  		/* lis R10, -32256 */
		/* 821631C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821631C8h case    0:*/		return 0x821631CC;
		  /* 821631CCh */ case    1:  		/* lfs FR10, <#[R10 + 2660]> */
		/* 821631CCh case    1:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R10 + 0x00000A64) );
		/* 821631CCh case    1:*/		return 0x821631D0;
	}
	return 0x821631D0;
} // Block from 821631C8h-821631D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821631D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631D0);
		  /* 821631D0h */ case    0:  		/* stfs FR10, <#[R11 + 8]> */
		/* 821631D0h case    0:*/		cpu::mem::store32f( regs, regs.FR10, (uint32)(regs.R11 + 0x00000008) );
		/* 821631D0h case    0:*/		return 0x821631D4;
	}
	return 0x821631D4;
} // Block from 821631D0h-821631D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821631D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631D4);
		  /* 821631D4h */ case    0:  		/* lfs FR8, <#[R11 + 12]> */
		/* 821631D4h case    0:*/		cpu::mem::load32f( regs, &regs.FR8, (uint32)(regs.R11 + 0x0000000C) );
		/* 821631D4h case    0:*/		return 0x821631D8;
		  /* 821631D8h */ case    1:  		/* lfs FR7, <#[R11 + 8]> */
		/* 821631D8h case    1:*/		cpu::mem::load32f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000008) );
		/* 821631D8h case    1:*/		return 0x821631DC;
		  /* 821631DCh */ case    2:  		/* fcmpu CR6, FR8, FR7 */
		/* 821631DCh case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 821631DCh case    2:*/		return 0x821631E0;
		  /* 821631E0h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 821631E0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821631EC;  }
		/* 821631E0h case    3:*/		return 0x821631E4;
		  /* 821631E4h */ case    4:  		/* fmr FR10, FR8 */
		/* 821631E4h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 821631E4h case    4:*/		return 0x821631E8;
		  /* 821631E8h */ case    5:  		/* b 8 */
		/* 821631E8h case    5:*/		return 0x821631F0;
		/* 821631E8h case    5:*/		return 0x821631EC;
	}
	return 0x821631EC;
} // Block from 821631D4h-821631ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821631ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631EC);
		  /* 821631ECh */ case    0:  		/* fmr FR10, FR7 */
		/* 821631ECh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 821631ECh case    0:*/		return 0x821631F0;
	}
	return 0x821631F0;
} // Block from 821631ECh-821631F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821631F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821631F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821631F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821631F0);
		  /* 821631F0h */ case    0:  		/* fcmpu CR6, FR0, FR10 */
		/* 821631F0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR10);
		/* 821631F0h case    0:*/		return 0x821631F4;
		  /* 821631F4h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821631F4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163200;  }
		/* 821631F4h case    1:*/		return 0x821631F8;
		  /* 821631F8h */ case    2:  		/* fmr FR10, FR0 */
		/* 821631F8h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR0);
		/* 821631F8h case    2:*/		return 0x821631FC;
		  /* 821631FCh */ case    3:  		/* b 24 */
		/* 821631FCh case    3:*/		return 0x82163214;
		/* 821631FCh case    3:*/		return 0x82163200;
	}
	return 0x82163200;
} // Block from 821631F0h-82163200h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163200);
		  /* 82163200h */ case    0:  		/* fcmpu CR6, FR8, FR7 */
		/* 82163200h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 82163200h case    0:*/		return 0x82163204;
		  /* 82163204h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163204h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163210;  }
		/* 82163204h case    1:*/		return 0x82163208;
		  /* 82163208h */ case    2:  		/* fmr FR10, FR8 */
		/* 82163208h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 82163208h case    2:*/		return 0x8216320C;
		  /* 8216320Ch */ case    3:  		/* b 8 */
		/* 8216320Ch case    3:*/		return 0x82163214;
		/* 8216320Ch case    3:*/		return 0x82163210;
	}
	return 0x82163210;
} // Block from 82163200h-82163210h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163210);
		  /* 82163210h */ case    0:  		/* fmr FR10, FR7 */
		/* 82163210h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 82163210h case    0:*/		return 0x82163214;
	}
	return 0x82163214;
} // Block from 82163210h-82163214h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163214);
		  /* 82163214h */ case    0:  		/* lfs FR6, <#[R11 + 28]> */
		/* 82163214h case    0:*/		cpu::mem::load32f( regs, &regs.FR6, (uint32)(regs.R11 + 0x0000001C) );
		/* 82163214h case    0:*/		return 0x82163218;
		  /* 82163218h */ case    1:  		/* fcmpu CR6, FR6, FR10 */
		/* 82163218h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR6,regs.FR10);
		/* 82163218h case    1:*/		return 0x8216321C;
		  /* 8216321Ch */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 8216321Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x82163228;  }
		/* 8216321Ch case    2:*/		return 0x82163220;
		  /* 82163220h */ case    3:  		/* fmr FR10, FR6 */
		/* 82163220h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR6);
		/* 82163220h case    3:*/		return 0x82163224;
		  /* 82163224h */ case    4:  		/* b 60 */
		/* 82163224h case    4:*/		return 0x82163260;
		/* 82163224h case    4:*/		return 0x82163228;
	}
	return 0x82163228;
} // Block from 82163214h-82163228h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163228);
		  /* 82163228h */ case    0:  		/* fcmpu CR6, FR8, FR7 */
		/* 82163228h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 82163228h case    0:*/		return 0x8216322C;
		  /* 8216322Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8216322Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163238;  }
		/* 8216322Ch case    1:*/		return 0x82163230;
		  /* 82163230h */ case    2:  		/* fmr FR10, FR8 */
		/* 82163230h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 82163230h case    2:*/		return 0x82163234;
		  /* 82163234h */ case    3:  		/* b 8 */
		/* 82163234h case    3:*/		return 0x8216323C;
		/* 82163234h case    3:*/		return 0x82163238;
	}
	return 0x82163238;
} // Block from 82163228h-82163238h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163238);
		  /* 82163238h */ case    0:  		/* fmr FR10, FR7 */
		/* 82163238h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 82163238h case    0:*/		return 0x8216323C;
	}
	return 0x8216323C;
} // Block from 82163238h-8216323Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216323Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216323C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216323C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216323C);
		  /* 8216323Ch */ case    0:  		/* fcmpu CR6, FR0, FR10 */
		/* 8216323Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR10);
		/* 8216323Ch case    0:*/		return 0x82163240;
		  /* 82163240h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163240h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216324C;  }
		/* 82163240h case    1:*/		return 0x82163244;
		  /* 82163244h */ case    2:  		/* fmr FR10, FR0 */
		/* 82163244h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR0);
		/* 82163244h case    2:*/		return 0x82163248;
		  /* 82163248h */ case    3:  		/* b 24 */
		/* 82163248h case    3:*/		return 0x82163260;
		/* 82163248h case    3:*/		return 0x8216324C;
	}
	return 0x8216324C;
} // Block from 8216323Ch-8216324Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216324Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216324C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216324C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216324C);
		  /* 8216324Ch */ case    0:  		/* fcmpu CR6, FR8, FR7 */
		/* 8216324Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 8216324Ch case    0:*/		return 0x82163250;
		  /* 82163250h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163250h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216325C;  }
		/* 82163250h case    1:*/		return 0x82163254;
		  /* 82163254h */ case    2:  		/* fmr FR10, FR8 */
		/* 82163254h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 82163254h case    2:*/		return 0x82163258;
		  /* 82163258h */ case    3:  		/* b 8 */
		/* 82163258h case    3:*/		return 0x82163260;
		/* 82163258h case    3:*/		return 0x8216325C;
	}
	return 0x8216325C;
} // Block from 8216324Ch-8216325Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216325Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216325C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216325C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216325C);
		  /* 8216325Ch */ case    0:  		/* fmr FR10, FR7 */
		/* 8216325Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 8216325Ch case    0:*/		return 0x82163260;
	}
	return 0x82163260;
} // Block from 8216325Ch-82163260h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163260);
		  /* 82163260h */ case    0:  		/* lfs FR9, <#[R11]> */
		/* 82163260h case    0:*/		cpu::mem::load32f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000000) );
		/* 82163260h case    0:*/		return 0x82163264;
		  /* 82163264h */ case    1:  		/* fcmpu CR6, FR9, FR10 */
		/* 82163264h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR9,regs.FR10);
		/* 82163264h case    1:*/		return 0x82163268;
		  /* 82163268h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 82163268h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82163274;  }
		/* 82163268h case    2:*/		return 0x8216326C;
		  /* 8216326Ch */ case    3:  		/* fmr FR0, FR9 */
		/* 8216326Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR9);
		/* 8216326Ch case    3:*/		return 0x82163270;
		  /* 82163270h */ case    4:  		/* b 124 */
		/* 82163270h case    4:*/		return 0x821632EC;
		/* 82163270h case    4:*/		return 0x82163274;
	}
	return 0x82163274;
} // Block from 82163260h-82163274h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163274);
		  /* 82163274h */ case    0:  		/* fcmpu CR6, FR8, FR7 */
		/* 82163274h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 82163274h case    0:*/		return 0x82163278;
		  /* 82163278h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163278h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163284;  }
		/* 82163278h case    1:*/		return 0x8216327C;
		  /* 8216327Ch */ case    2:  		/* fmr FR10, FR8 */
		/* 8216327Ch case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 8216327Ch case    2:*/		return 0x82163280;
		  /* 82163280h */ case    3:  		/* b 8 */
		/* 82163280h case    3:*/		return 0x82163288;
		/* 82163280h case    3:*/		return 0x82163284;
	}
	return 0x82163284;
} // Block from 82163274h-82163284h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163284);
		  /* 82163284h */ case    0:  		/* fmr FR10, FR7 */
		/* 82163284h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 82163284h case    0:*/		return 0x82163288;
	}
	return 0x82163288;
} // Block from 82163284h-82163288h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163288);
		  /* 82163288h */ case    0:  		/* fcmpu CR6, FR0, FR10 */
		/* 82163288h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR10);
		/* 82163288h case    0:*/		return 0x8216328C;
		  /* 8216328Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8216328Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163298;  }
		/* 8216328Ch case    1:*/		return 0x82163290;
		  /* 82163290h */ case    2:  		/* fmr FR10, FR0 */
		/* 82163290h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR0);
		/* 82163290h case    2:*/		return 0x82163294;
		  /* 82163294h */ case    3:  		/* b 24 */
		/* 82163294h case    3:*/		return 0x821632AC;
		/* 82163294h case    3:*/		return 0x82163298;
	}
	return 0x82163298;
} // Block from 82163288h-82163298h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163298);
		  /* 82163298h */ case    0:  		/* fcmpu CR6, FR8, FR7 */
		/* 82163298h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 82163298h case    0:*/		return 0x8216329C;
		  /* 8216329Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8216329Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x821632A8;  }
		/* 8216329Ch case    1:*/		return 0x821632A0;
		  /* 821632A0h */ case    2:  		/* fmr FR10, FR8 */
		/* 821632A0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 821632A0h case    2:*/		return 0x821632A4;
		  /* 821632A4h */ case    3:  		/* b 8 */
		/* 821632A4h case    3:*/		return 0x821632AC;
		/* 821632A4h case    3:*/		return 0x821632A8;
	}
	return 0x821632A8;
} // Block from 82163298h-821632A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821632A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632A8);
		  /* 821632A8h */ case    0:  		/* fmr FR10, FR7 */
		/* 821632A8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 821632A8h case    0:*/		return 0x821632AC;
	}
	return 0x821632AC;
} // Block from 821632A8h-821632ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821632ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632AC);
		  /* 821632ACh */ case    0:  		/* fcmpu CR6, FR6, FR10 */
		/* 821632ACh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR6,regs.FR10);
		/* 821632ACh case    0:*/		return 0x821632B0;
		  /* 821632B0h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821632B0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821632BC;  }
		/* 821632B0h case    1:*/		return 0x821632B4;
		  /* 821632B4h */ case    2:  		/* fmr FR0, FR6 */
		/* 821632B4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR6);
		/* 821632B4h case    2:*/		return 0x821632B8;
		  /* 821632B8h */ case    3:  		/* b 52 */
		/* 821632B8h case    3:*/		return 0x821632EC;
		/* 821632B8h case    3:*/		return 0x821632BC;
	}
	return 0x821632BC;
} // Block from 821632ACh-821632BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821632BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632BC);
		  /* 821632BCh */ case    0:  		/* fcmpu CR6, FR8, FR7 */
		/* 821632BCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 821632BCh case    0:*/		return 0x821632C0;
		  /* 821632C0h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821632C0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821632CC;  }
		/* 821632C0h case    1:*/		return 0x821632C4;
		  /* 821632C4h */ case    2:  		/* fmr FR10, FR8 */
		/* 821632C4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR8);
		/* 821632C4h case    2:*/		return 0x821632C8;
		  /* 821632C8h */ case    3:  		/* b 8 */
		/* 821632C8h case    3:*/		return 0x821632D0;
		/* 821632C8h case    3:*/		return 0x821632CC;
	}
	return 0x821632CC;
} // Block from 821632BCh-821632CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821632CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632CC);
		  /* 821632CCh */ case    0:  		/* fmr FR10, FR7 */
		/* 821632CCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR10,regs.FR7);
		/* 821632CCh case    0:*/		return 0x821632D0;
	}
	return 0x821632D0;
} // Block from 821632CCh-821632D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821632D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632D0);
		  /* 821632D0h */ case    0:  		/* fcmpu CR6, FR0, FR10 */
		/* 821632D0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR10);
		/* 821632D0h case    0:*/		return 0x821632D4;
		  /* 821632D4h */ case    1:  		/* bc 12, CR6_GT, 24 */
		/* 821632D4h case    1:*/		if ( regs.CR[6].gt ) { return 0x821632EC;  }
		/* 821632D4h case    1:*/		return 0x821632D8;
		  /* 821632D8h */ case    2:  		/* fcmpu CR6, FR8, FR7 */
		/* 821632D8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR8,regs.FR7);
		/* 821632D8h case    2:*/		return 0x821632DC;
		  /* 821632DCh */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 821632DCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x821632E8;  }
		/* 821632DCh case    3:*/		return 0x821632E0;
		  /* 821632E0h */ case    4:  		/* fmr FR0, FR8 */
		/* 821632E0h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR8);
		/* 821632E0h case    4:*/		return 0x821632E4;
		  /* 821632E4h */ case    5:  		/* b 8 */
		/* 821632E4h case    5:*/		return 0x821632EC;
		/* 821632E4h case    5:*/		return 0x821632E8;
	}
	return 0x821632E8;
} // Block from 821632D0h-821632E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821632E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632E8);
		  /* 821632E8h */ case    0:  		/* fmr FR0, FR7 */
		/* 821632E8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 821632E8h case    0:*/		return 0x821632EC;
	}
	return 0x821632EC;
} // Block from 821632E8h-821632ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821632ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821632EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821632EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821632EC);
		  /* 821632ECh */ case    0:  		/* lfs FR10, <#[R11 + 16]> */
		/* 821632ECh case    0:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000010) );
		/* 821632ECh case    0:*/		return 0x821632F0;
		  /* 821632F0h */ case    1:  		/* stfs FR0, <#[R11 + 32]> */
		/* 821632F0h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 821632F0h case    1:*/		return 0x821632F4;
		  /* 821632F4h */ case    2:  		/* fcmpu CR6, FR10, FR7 */
		/* 821632F4h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 821632F4h case    2:*/		return 0x821632F8;
		  /* 821632F8h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 821632F8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82163304;  }
		/* 821632F8h case    3:*/		return 0x821632FC;
		  /* 821632FCh */ case    4:  		/* fmr FR0, FR10 */
		/* 821632FCh case    4:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 821632FCh case    4:*/		return 0x82163300;
		  /* 82163300h */ case    5:  		/* b 8 */
		/* 82163300h case    5:*/		return 0x82163308;
		/* 82163300h case    5:*/		return 0x82163304;
	}
	return 0x82163304;
} // Block from 821632ECh-82163304h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82163304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163304);
		  /* 82163304h */ case    0:  		/* fmr FR0, FR7 */
		/* 82163304h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 82163304h case    0:*/		return 0x82163308;
	}
	return 0x82163308;
} // Block from 82163304h-82163308h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163308);
		  /* 82163308h */ case    0:  		/* fcmpu CR6, FR12, FR0 */
		/* 82163308h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82163308h case    0:*/		return 0x8216330C;
		  /* 8216330Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8216330Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163318;  }
		/* 8216330Ch case    1:*/		return 0x82163310;
		  /* 82163310h */ case    2:  		/* fmr FR0, FR12 */
		/* 82163310h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR12);
		/* 82163310h case    2:*/		return 0x82163314;
		  /* 82163314h */ case    3:  		/* b 24 */
		/* 82163314h case    3:*/		return 0x8216332C;
		/* 82163314h case    3:*/		return 0x82163318;
	}
	return 0x82163318;
} // Block from 82163308h-82163318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163318);
		  /* 82163318h */ case    0:  		/* fcmpu CR6, FR10, FR7 */
		/* 82163318h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 82163318h case    0:*/		return 0x8216331C;
		  /* 8216331Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8216331Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163328;  }
		/* 8216331Ch case    1:*/		return 0x82163320;
		  /* 82163320h */ case    2:  		/* fmr FR0, FR10 */
		/* 82163320h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 82163320h case    2:*/		return 0x82163324;
		  /* 82163324h */ case    3:  		/* b 8 */
		/* 82163324h case    3:*/		return 0x8216332C;
		/* 82163324h case    3:*/		return 0x82163328;
	}
	return 0x82163328;
} // Block from 82163318h-82163328h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163328);
		  /* 82163328h */ case    0:  		/* fmr FR0, FR7 */
		/* 82163328h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 82163328h case    0:*/		return 0x8216332C;
	}
	return 0x8216332C;
} // Block from 82163328h-8216332Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216332Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216332C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216332C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216332C);
		  /* 8216332Ch */ case    0:  		/* fcmpu CR6, FR6, FR0 */
		/* 8216332Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR6,regs.FR0);
		/* 8216332Ch case    0:*/		return 0x82163330;
		  /* 82163330h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163330h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216333C;  }
		/* 82163330h case    1:*/		return 0x82163334;
		  /* 82163334h */ case    2:  		/* fmr FR13, FR6 */
		/* 82163334h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR6);
		/* 82163334h case    2:*/		return 0x82163338;
		  /* 82163338h */ case    3:  		/* b 60 */
		/* 82163338h case    3:*/		return 0x82163374;
		/* 82163338h case    3:*/		return 0x8216333C;
	}
	return 0x8216333C;
} // Block from 8216332Ch-8216333Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216333Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216333C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216333C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216333C);
		  /* 8216333Ch */ case    0:  		/* fcmpu CR6, FR10, FR7 */
		/* 8216333Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 8216333Ch case    0:*/		return 0x82163340;
		  /* 82163340h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163340h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216334C;  }
		/* 82163340h case    1:*/		return 0x82163344;
		  /* 82163344h */ case    2:  		/* fmr FR0, FR10 */
		/* 82163344h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 82163344h case    2:*/		return 0x82163348;
		  /* 82163348h */ case    3:  		/* b 8 */
		/* 82163348h case    3:*/		return 0x82163350;
		/* 82163348h case    3:*/		return 0x8216334C;
	}
	return 0x8216334C;
} // Block from 8216333Ch-8216334Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216334Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216334C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216334C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216334C);
		  /* 8216334Ch */ case    0:  		/* fmr FR0, FR7 */
		/* 8216334Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 8216334Ch case    0:*/		return 0x82163350;
	}
	return 0x82163350;
} // Block from 8216334Ch-82163350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163350);
		  /* 82163350h */ case    0:  		/* fcmpu CR6, FR12, FR0 */
		/* 82163350h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82163350h case    0:*/		return 0x82163354;
		  /* 82163354h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163354h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163360;  }
		/* 82163354h case    1:*/		return 0x82163358;
		  /* 82163358h */ case    2:  		/* fmr FR13, FR12 */
		/* 82163358h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR12);
		/* 82163358h case    2:*/		return 0x8216335C;
		  /* 8216335Ch */ case    3:  		/* b 24 */
		/* 8216335Ch case    3:*/		return 0x82163374;
		/* 8216335Ch case    3:*/		return 0x82163360;
	}
	return 0x82163360;
} // Block from 82163350h-82163360h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163360);
		  /* 82163360h */ case    0:  		/* fcmpu CR6, FR10, FR7 */
		/* 82163360h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 82163360h case    0:*/		return 0x82163364;
		  /* 82163364h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163364h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82163370;  }
		/* 82163364h case    1:*/		return 0x82163368;
		  /* 82163368h */ case    2:  		/* fmr FR13, FR10 */
		/* 82163368h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR10);
		/* 82163368h case    2:*/		return 0x8216336C;
		  /* 8216336Ch */ case    3:  		/* b 8 */
		/* 8216336Ch case    3:*/		return 0x82163374;
		/* 8216336Ch case    3:*/		return 0x82163370;
	}
	return 0x82163370;
} // Block from 82163360h-82163370h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163370);
		  /* 82163370h */ case    0:  		/* fmr FR13, FR7 */
		/* 82163370h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR13,regs.FR7);
		/* 82163370h case    0:*/		return 0x82163374;
	}
	return 0x82163374;
} // Block from 82163370h-82163374h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163374);
		  /* 82163374h */ case    0:  		/* lfs FR0, <#[R11 + 4]> */
		/* 82163374h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000004) );
		/* 82163374h case    0:*/		return 0x82163378;
		  /* 82163378h */ case    1:  		/* fcmpu CR6, FR0, FR13 */
		/* 82163378h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82163378h case    1:*/		return 0x8216337C;
		  /* 8216337Ch */ case    2:  		/* bc 12, CR6_GT, 132 */
		/* 8216337Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x82163400;  }
		/* 8216337Ch case    2:*/		return 0x82163380;
		  /* 82163380h */ case    3:  		/* fcmpu CR6, FR10, FR7 */
		/* 82163380h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 82163380h case    3:*/		return 0x82163384;
		  /* 82163384h */ case    4:  		/* bc 4, CR6_GT, 12 */
		/* 82163384h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82163390;  }
		/* 82163384h case    4:*/		return 0x82163388;
		  /* 82163388h */ case    5:  		/* fmr FR0, FR10 */
		/* 82163388h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 82163388h case    5:*/		return 0x8216338C;
		  /* 8216338Ch */ case    6:  		/* b 8 */
		/* 8216338Ch case    6:*/		return 0x82163394;
		/* 8216338Ch case    6:*/		return 0x82163390;
	}
	return 0x82163390;
} // Block from 82163374h-82163390h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82163390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163390);
		  /* 82163390h */ case    0:  		/* fmr FR0, FR7 */
		/* 82163390h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 82163390h case    0:*/		return 0x82163394;
	}
	return 0x82163394;
} // Block from 82163390h-82163394h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163394);
		  /* 82163394h */ case    0:  		/* fcmpu CR6, FR12, FR0 */
		/* 82163394h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82163394h case    0:*/		return 0x82163398;
		  /* 82163398h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82163398h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821633A4;  }
		/* 82163398h case    1:*/		return 0x8216339C;
		  /* 8216339Ch */ case    2:  		/* fmr FR0, FR12 */
		/* 8216339Ch case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR12);
		/* 8216339Ch case    2:*/		return 0x821633A0;
		  /* 821633A0h */ case    3:  		/* b 24 */
		/* 821633A0h case    3:*/		return 0x821633B8;
		/* 821633A0h case    3:*/		return 0x821633A4;
	}
	return 0x821633A4;
} // Block from 82163394h-821633A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821633A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633A4);
		  /* 821633A4h */ case    0:  		/* fcmpu CR6, FR10, FR7 */
		/* 821633A4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 821633A4h case    0:*/		return 0x821633A8;
		  /* 821633A8h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821633A8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821633B4;  }
		/* 821633A8h case    1:*/		return 0x821633AC;
		  /* 821633ACh */ case    2:  		/* fmr FR0, FR10 */
		/* 821633ACh case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 821633ACh case    2:*/		return 0x821633B0;
		  /* 821633B0h */ case    3:  		/* b 8 */
		/* 821633B0h case    3:*/		return 0x821633B8;
		/* 821633B0h case    3:*/		return 0x821633B4;
	}
	return 0x821633B4;
} // Block from 821633A4h-821633B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821633B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633B4);
		  /* 821633B4h */ case    0:  		/* fmr FR0, FR7 */
		/* 821633B4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 821633B4h case    0:*/		return 0x821633B8;
	}
	return 0x821633B8;
} // Block from 821633B4h-821633B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821633B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633B8);
		  /* 821633B8h */ case    0:  		/* fcmpu CR6, FR6, FR0 */
		/* 821633B8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR6,regs.FR0);
		/* 821633B8h case    0:*/		return 0x821633BC;
		  /* 821633BCh */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821633BCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x821633C8;  }
		/* 821633BCh case    1:*/		return 0x821633C0;
		  /* 821633C0h */ case    2:  		/* fmr FR0, FR6 */
		/* 821633C0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR6);
		/* 821633C0h case    2:*/		return 0x821633C4;
		  /* 821633C4h */ case    3:  		/* b 60 */
		/* 821633C4h case    3:*/		return 0x82163400;
		/* 821633C4h case    3:*/		return 0x821633C8;
	}
	return 0x821633C8;
} // Block from 821633B8h-821633C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821633C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633C8);
		  /* 821633C8h */ case    0:  		/* fcmpu CR6, FR10, FR7 */
		/* 821633C8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 821633C8h case    0:*/		return 0x821633CC;
		  /* 821633CCh */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821633CCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x821633D8;  }
		/* 821633CCh case    1:*/		return 0x821633D0;
		  /* 821633D0h */ case    2:  		/* fmr FR0, FR10 */
		/* 821633D0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 821633D0h case    2:*/		return 0x821633D4;
		  /* 821633D4h */ case    3:  		/* b 8 */
		/* 821633D4h case    3:*/		return 0x821633DC;
		/* 821633D4h case    3:*/		return 0x821633D8;
	}
	return 0x821633D8;
} // Block from 821633C8h-821633D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821633D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633D8);
		  /* 821633D8h */ case    0:  		/* fmr FR0, FR7 */
		/* 821633D8h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 821633D8h case    0:*/		return 0x821633DC;
	}
	return 0x821633DC;
} // Block from 821633D8h-821633DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821633DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633DC);
		  /* 821633DCh */ case    0:  		/* fcmpu CR6, FR12, FR0 */
		/* 821633DCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 821633DCh case    0:*/		return 0x821633E0;
		  /* 821633E0h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821633E0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821633EC;  }
		/* 821633E0h case    1:*/		return 0x821633E4;
		  /* 821633E4h */ case    2:  		/* fmr FR0, FR12 */
		/* 821633E4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR12);
		/* 821633E4h case    2:*/		return 0x821633E8;
		  /* 821633E8h */ case    3:  		/* b 24 */
		/* 821633E8h case    3:*/		return 0x82163400;
		/* 821633E8h case    3:*/		return 0x821633EC;
	}
	return 0x821633EC;
} // Block from 821633DCh-821633ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821633ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633EC);
		  /* 821633ECh */ case    0:  		/* fcmpu CR6, FR10, FR7 */
		/* 821633ECh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR10,regs.FR7);
		/* 821633ECh case    0:*/		return 0x821633F0;
		  /* 821633F0h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821633F0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821633FC;  }
		/* 821633F0h case    1:*/		return 0x821633F4;
		  /* 821633F4h */ case    2:  		/* fmr FR0, FR10 */
		/* 821633F4h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR10);
		/* 821633F4h case    2:*/		return 0x821633F8;
		  /* 821633F8h */ case    3:  		/* b 8 */
		/* 821633F8h case    3:*/		return 0x82163400;
		/* 821633F8h case    3:*/		return 0x821633FC;
	}
	return 0x821633FC;
} // Block from 821633ECh-821633FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821633FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821633FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821633FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821633FC);
		  /* 821633FCh */ case    0:  		/* fmr FR0, FR7 */
		/* 821633FCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR7);
		/* 821633FCh case    0:*/		return 0x82163400;
	}
	return 0x82163400;
} // Block from 821633FCh-82163400h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163400);
		  /* 82163400h */ case    0:  		/* addi R9, R11, 84 */
		/* 82163400h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x54);
		/* 82163400h case    0:*/		return 0x82163404;
		  /* 82163404h */ case    1:  		/* stfs FR0, <#[R11 + 36]> */
		/* 82163404h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000024) );
		/* 82163404h case    1:*/		return 0x82163408;
		  /* 82163408h */ case    2:  		/* mr R10, R11 */
		/* 82163408h case    2:*/		regs.R10 = regs.R11;
		/* 82163408h case    2:*/		return 0x8216340C;
		  /* 8216340Ch */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 8216340Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8216340Ch case    3:*/		return 0x82163410;
		  /* 82163410h */ case    4:  		/* bc 4, CR6_LT, 36 */
		/* 82163410h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82163434;  }
		/* 82163410h case    4:*/		return 0x82163414;
		  /* 82163414h */ case    5:  		/* lis R8, -32256 */
		/* 82163414h case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82163414h case    5:*/		return 0x82163418;
		  /* 82163418h */ case    6:  		/* lfs FR0, <#[R8 + 8460]> */
		/* 82163418h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R8 + 0x0000210C) );
		/* 82163418h case    6:*/		return 0x8216341C;
		  /* 8216341Ch */ case    7:  		/* lfs FR13, <#[R10]> */
		/* 8216341Ch case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000000) );
		/* 8216341Ch case    7:*/		return 0x82163420;
		  /* 82163420h */ case    8:  		/* fmuls FR13, FR13, FR0 */
		/* 82163420h case    8:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 82163420h case    8:*/		return 0x82163424;
		  /* 82163424h */ case    9:  		/* stfs FR13, <#[R10]> */
		/* 82163424h case    9:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R10 + 0x00000000) );
		/* 82163424h case    9:*/		return 0x82163428;
		  /* 82163428h */ case   10:  		/* addi R10, R10, 4 */
		/* 82163428h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82163428h case   10:*/		return 0x8216342C;
		  /* 8216342Ch */ case   11:  		/* cmplw CR6, R10, R9 */
		/* 8216342Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8216342Ch case   11:*/		return 0x82163430;
		  /* 82163430h */ case   12:  		/* bc 12, CR6_LT, -20 */
		/* 82163430h case   12:*/		if ( regs.CR[6].lt ) { return 0x8216341C;  }
		/* 82163430h case   12:*/		return 0x82163434;
	}
	return 0x82163434;
} // Block from 82163400h-82163434h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82163434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163434);
		  /* 82163434h */ case    0:  		/* lwz R10, <#[R3 + 1036]> */
		/* 82163434h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000040C) );
		/* 82163434h case    0:*/		return 0x82163438;
		  /* 82163438h */ case    1:  		/* stw R10, <#[R11 + 48]> */
		/* 82163438h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82163438h case    1:*/		return 0x8216343C;
		  /* 8216343Ch */ case    2:  		/* lwz R10, <#[R3 + 1028]> */
		/* 8216343Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000404) );
		/* 8216343Ch case    2:*/		return 0x82163440;
		  /* 82163440h */ case    3:  		/* stw R10, <#[R11 + 40]> */
		/* 82163440h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 82163440h case    3:*/		return 0x82163444;
		  /* 82163444h */ case    4:  		/* lwz R10, <#[R3 + 1032]> */
		/* 82163444h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000408) );
		/* 82163444h case    4:*/		return 0x82163448;
		  /* 82163448h */ case    5:  		/* stw R10, <#[R11 + 44]> */
		/* 82163448h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 82163448h case    5:*/		return 0x8216344C;
		  /* 8216344Ch */ case    6:  		/* lwz R10, <#[R3 + 1040]> */
		/* 8216344Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000410) );
		/* 8216344Ch case    6:*/		return 0x82163450;
		  /* 82163450h */ case    7:  		/* stw R10, <#[R11 + 52]> */
		/* 82163450h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 82163450h case    7:*/		return 0x82163454;
		  /* 82163454h */ case    8:  		/* lwz R10, <#[R3 + 1044]> */
		/* 82163454h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000414) );
		/* 82163454h case    8:*/		return 0x82163458;
		  /* 82163458h */ case    9:  		/* stw R10, <#[R11 + 56]> */
		/* 82163458h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 82163458h case    9:*/		return 0x8216345C;
		  /* 8216345Ch */ case   10:  		/* lwz R10, <#[R3 + 1048]> */
		/* 8216345Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000418) );
		/* 8216345Ch case   10:*/		return 0x82163460;
		  /* 82163460h */ case   11:  		/* stw R10, <#[R11 + 60]> */
		/* 82163460h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 82163460h case   11:*/		return 0x82163464;
		  /* 82163464h */ case   12:  		/* lwz R10, <#[R3 + 1052]> */
		/* 82163464h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000041C) );
		/* 82163464h case   12:*/		return 0x82163468;
		  /* 82163468h */ case   13:  		/* cmpwi CR6, R10, 0 */
		/* 82163468h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82163468h case   13:*/		return 0x8216346C;
		  /* 8216346Ch */ case   14:  		/* lwz R10, <#[R3]> */
		/* 8216346Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8216346Ch case   14:*/		return 0x82163470;
		  /* 82163470h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82163470h case   15:*/		if ( regs.CR[6].eq ) { return 0x8216347C;  }
		/* 82163470h case   15:*/		return 0x82163474;
		  /* 82163474h */ case   16:  		/* rlwinm R10, R10, 0, 26, 31 */
		/* 82163474h case   16:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R10);
		/* 82163474h case   16:*/		return 0x82163478;
		  /* 82163478h */ case   17:  		/* b 8 */
		/* 82163478h case   17:*/		return 0x82163480;
		/* 82163478h case   17:*/		return 0x8216347C;
	}
	return 0x8216347C;
} // Block from 82163434h-8216347Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8216347Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216347C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216347C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216347C);
		  /* 8216347Ch */ case    0:  		/* rlwinm R10, R10, 24, 26, 31 */
		/* 8216347Ch case    0:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R10,regs.R10);
		/* 8216347Ch case    0:*/		return 0x82163480;
	}
	return 0x82163480;
} // Block from 8216347Ch-82163480h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163480);
		  /* 82163480h */ case    0:  		/* stw R10, <#[R11 + 64]> */
		/* 82163480h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 82163480h case    0:*/		return 0x82163484;
		  /* 82163484h */ case    1:  		/* lwz R10, <#[R3 + 1112]> */
		/* 82163484h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000458) );
		/* 82163484h case    1:*/		return 0x82163488;
		  /* 82163488h */ case    2:  		/* lwz R9, <#[R3 + 1108]> */
		/* 82163488h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000454) );
		/* 82163488h case    2:*/		return 0x8216348C;
		  /* 8216348Ch */ case    3:  		/* std R10, <#[R1 + 88]> */
		/* 8216348Ch case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8216348Ch case    3:*/		return 0x82163490;
		  /* 82163490h */ case    4:  		/* std R9, <#[R1 + 80]> */
		/* 82163490h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82163490h case    4:*/		return 0x82163494;
		  /* 82163494h */ case    5:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82163494h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82163494h case    5:*/		return 0x82163498;
		  /* 82163498h */ case    6:  		/* fcfid FR0, FR0 */
		/* 82163498h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82163498h case    6:*/		return 0x8216349C;
		  /* 8216349Ch */ case    7:  		/* lfd FR13, <#[R1 + 88]> */
		/* 8216349Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 8216349Ch case    7:*/		return 0x821634A0;
		  /* 821634A0h */ case    8:  		/* frsp FR0, FR0 */
		/* 821634A0h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 821634A0h case    8:*/		return 0x821634A4;
		  /* 821634A4h */ case    9:  		/* fcfid FR13, FR13 */
		/* 821634A4h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821634A4h case    9:*/		return 0x821634A8;
		  /* 821634A8h */ case   10:  		/* frsp FR13, FR13 */
		/* 821634A8h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821634A8h case   10:*/		return 0x821634AC;
		  /* 821634ACh */ case   11:  		/* fadds FR0, FR13, FR0 */
		/* 821634ACh case   11:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 821634ACh case   11:*/		return 0x821634B0;
		  /* 821634B0h */ case   12:  		/* fmuls FR0, FR0, FR5 */
		/* 821634B0h case   12:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR5);
		/* 821634B0h case   12:*/		return 0x821634B4;
		  /* 821634B4h */ case   13:  		/* stfs FR0, <#[R11 + 72]> */
		/* 821634B4h case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000048) );
		/* 821634B4h case   13:*/		return 0x821634B8;
		  /* 821634B8h */ case   14:  		/* lwz R10, <#[R3 + 1132]> */
		/* 821634B8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000046C) );
		/* 821634B8h case   14:*/		return 0x821634BC;
		  /* 821634BCh */ case   15:  		/* std R10, <#[R1 + 80]> */
		/* 821634BCh case   15:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821634BCh case   15:*/		return 0x821634C0;
		  /* 821634C0h */ case   16:  		/* lwz R9, <#[R3 + 1136]> */
		/* 821634C0h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000470) );
		/* 821634C0h case   16:*/		return 0x821634C4;
		  /* 821634C4h */ case   17:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821634C4h case   17:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821634C4h case   17:*/		return 0x821634C8;
		  /* 821634C8h */ case   18:  		/* std R9, <#[R1 + 88]> */
		/* 821634C8h case   18:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 821634C8h case   18:*/		return 0x821634CC;
		  /* 821634CCh */ case   19:  		/* fcfid FR13, FR13 */
		/* 821634CCh case   19:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821634CCh case   19:*/		return 0x821634D0;
		  /* 821634D0h */ case   20:  		/* lfd FR0, <#[R1 + 88]> */
		/* 821634D0h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 821634D0h case   20:*/		return 0x821634D4;
		  /* 821634D4h */ case   21:  		/* frsp FR13, FR13 */
		/* 821634D4h case   21:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821634D4h case   21:*/		return 0x821634D8;
		  /* 821634D8h */ case   22:  		/* fcfid FR0, FR0 */
		/* 821634D8h case   22:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 821634D8h case   22:*/		return 0x821634DC;
		  /* 821634DCh */ case   23:  		/* frsp FR0, FR0 */
		/* 821634DCh case   23:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 821634DCh case   23:*/		return 0x821634E0;
		  /* 821634E0h */ case   24:  		/* fadds FR0, FR0, FR13 */
		/* 821634E0h case   24:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 821634E0h case   24:*/		return 0x821634E4;
		  /* 821634E4h */ case   25:  		/* fmuls FR0, FR0, FR5 */
		/* 821634E4h case   25:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR5);
		/* 821634E4h case   25:*/		return 0x821634E8;
		  /* 821634E8h */ case   26:  		/* stfs FR0, <#[R11 + 80]> */
		/* 821634E8h case   26:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000050) );
		/* 821634E8h case   26:*/		return 0x821634EC;
		  /* 821634ECh */ case   27:  		/* lwz R9, <#[R3 + 1104]> */
		/* 821634ECh case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000450) );
		/* 821634ECh case   27:*/		return 0x821634F0;
		  /* 821634F0h */ case   28:  		/* lwz R10, <#[R3 + 1100]> */
		/* 821634F0h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000044C) );
		/* 821634F0h case   28:*/		return 0x821634F4;
		  /* 821634F4h */ case   29:  		/* std R10, <#[R1 + 80]> */
		/* 821634F4h case   29:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821634F4h case   29:*/		return 0x821634F8;
		  /* 821634F8h */ case   30:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821634F8h case   30:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821634F8h case   30:*/		return 0x821634FC;
		  /* 821634FCh */ case   31:  		/* std R9, <#[R1 + 88]> */
		/* 821634FCh case   31:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 821634FCh case   31:*/		return 0x82163500;
		  /* 82163500h */ case   32:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82163500h case   32:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82163500h case   32:*/		return 0x82163504;
		  /* 82163504h */ case   33:  		/* fcfid FR0, FR0 */
		/* 82163504h case   33:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82163504h case   33:*/		return 0x82163508;
		  /* 82163508h */ case   34:  		/* fcfid FR13, FR13 */
		/* 82163508h case   34:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82163508h case   34:*/		return 0x8216350C;
		  /* 8216350Ch */ case   35:  		/* frsp FR0, FR0 */
		/* 8216350Ch case   35:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8216350Ch case   35:*/		return 0x82163510;
		  /* 82163510h */ case   36:  		/* frsp FR13, FR13 */
		/* 82163510h case   36:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82163510h case   36:*/		return 0x82163514;
		  /* 82163514h */ case   37:  		/* fadds FR0, FR0, FR13 */
		/* 82163514h case   37:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82163514h case   37:*/		return 0x82163518;
		  /* 82163518h */ case   38:  		/* fmuls FR0, FR0, FR5 */
		/* 82163518h case   38:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR5);
		/* 82163518h case   38:*/		return 0x8216351C;
		  /* 8216351Ch */ case   39:  		/* stfs FR0, <#[R11 + 68]> */
		/* 8216351Ch case   39:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000044) );
		/* 8216351Ch case   39:*/		return 0x82163520;
		  /* 82163520h */ case   40:  		/* lwz R10, <#[R3 + 1128]> */
		/* 82163520h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000468) );
		/* 82163520h case   40:*/		return 0x82163524;
		  /* 82163524h */ case   41:  		/* std R10, <#[R1 + 88]> */
		/* 82163524h case   41:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82163524h case   41:*/		return 0x82163528;
		  /* 82163528h */ case   42:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82163528h case   42:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82163528h case   42:*/		return 0x8216352C;
		  /* 8216352Ch */ case   43:  		/* lwz R10, <#[R3 + 1124]> */
		/* 8216352Ch case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000464) );
		/* 8216352Ch case   43:*/		return 0x82163530;
		  /* 82163530h */ case   44:  		/* std R10, <#[R1 + 88]> */
		/* 82163530h case   44:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82163530h case   44:*/		return 0x82163534;
		  /* 82163534h */ case   45:  		/* fcfid FR0, FR0 */
		/* 82163534h case   45:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82163534h case   45:*/		return 0x82163538;
		  /* 82163538h */ case   46:  		/* lfd FR13, <#[R1 + 88]> */
		/* 82163538h case   46:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82163538h case   46:*/		return 0x8216353C;
		  /* 8216353Ch */ case   47:  		/* frsp FR0, FR0 */
		/* 8216353Ch case   47:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8216353Ch case   47:*/		return 0x82163540;
		  /* 82163540h */ case   48:  		/* fcfid FR13, FR13 */
		/* 82163540h case   48:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82163540h case   48:*/		return 0x82163544;
		  /* 82163544h */ case   49:  		/* frsp FR13, FR13 */
		/* 82163544h case   49:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82163544h case   49:*/		return 0x82163548;
		  /* 82163548h */ case   50:  		/* fadds FR0, FR0, FR13 */
		/* 82163548h case   50:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82163548h case   50:*/		return 0x8216354C;
		  /* 8216354Ch */ case   51:  		/* fmuls FR0, FR0, FR5 */
		/* 8216354Ch case   51:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR5);
		/* 8216354Ch case   51:*/		return 0x82163550;
		  /* 82163550h */ case   52:  		/* stfs FR0, <#[R11 + 76]> */
		/* 82163550h case   52:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000004C) );
		/* 82163550h case   52:*/		return 0x82163554;
	}
	return 0x82163554;
} // Block from 82163480h-82163554h (53 instructions)

//////////////////////////////////////////////////////
// Block at 82163554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163554);
		  /* 82163554h */ case    0:  		/* addi R1, R1, 112 */
		/* 82163554h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82163554h case    0:*/		return 0x82163558;
		  /* 82163558h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82163558h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82163558h case    1:*/		return 0x8216355C;
		  /* 8216355Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8216355Ch case    2:*/		regs.LR = regs.R12;
		/* 8216355Ch case    2:*/		return 0x82163560;
		  /* 82163560h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82163560h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82163560h case    3:*/		return 0x82163564;
	}
	return 0x82163564;
} // Block from 82163554h-82163564h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163564);
		  /* 82163564h */ case    0:  		/* nop */
		/* 82163564h case    0:*/		cpu::op::nop();
		/* 82163564h case    0:*/		return 0x82163568;
		  /* 82163568h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 82163568h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82163568h case    1:*/		return 0x8216356C;
		  /* 8216356Ch */ case    2:  		/* bc 4, CR6_EQ, 176 */
		/* 8216356Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216361C;  }
		/* 8216356Ch case    2:*/		return 0x82163570;
		  /* 82163570h */ case    3:  		/* cmplwi CR6, R5, 1 */
		/* 82163570h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 82163570h case    3:*/		return 0x82163574;
		  /* 82163574h */ case    4:  		/* bc 12, CR6_LT, 84 */
		/* 82163574h case    4:*/		if ( regs.CR[6].lt ) { return 0x821635C8;  }
		/* 82163574h case    4:*/		return 0x82163578;
		  /* 82163578h */ case    5:  		/* bc 12, CR6_EQ, 164 */
		/* 82163578h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216361C;  }
		/* 82163578h case    5:*/		return 0x8216357C;
		  /* 8216357Ch */ case    6:  		/* cmplwi CR6, R5, 3 */
		/* 8216357Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000003);
		/* 8216357Ch case    6:*/		return 0x82163580;
		  /* 82163580h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 82163580h case    7:*/		if ( regs.CR[6].lt ) { return 0x82163590;  }
		/* 82163580h case    7:*/		return 0x82163584;
		  /* 82163584h */ case    8:  		/* lis R3, -32768 */
		/* 82163584h case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82163584h case    8:*/		return 0x82163588;
		  /* 82163588h */ case    9:  		/* ori R3, R3, 16389 */
		/* 82163588h case    9:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82163588h case    9:*/		return 0x8216358C;
		  /* 8216358Ch */ case   10:  		/* bclr 20, CR0_LT */
		/* 8216358Ch case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216358Ch case   10:*/		return 0x82163590;
	}
	return 0x82163590;
} // Block from 82163564h-82163590h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82163590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163590);
		  /* 82163590h */ case    0:  		/* addi R10, R6, 12 */
		/* 82163590h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xC);
		/* 82163590h case    0:*/		return 0x82163594;
		  /* 82163594h */ case    1:  		/* lwz R9, <#[R7]> */
		/* 82163594h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 82163594h case    1:*/		return 0x82163598;
		  /* 82163598h */ case    2:  		/* rlwinm R11, R6, 27, 5, 31 */
		/* 82163598h case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R6);
		/* 82163598h case    2:*/		return 0x8216359C;
		  /* 8216359Ch */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216359Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216359Ch case    3:*/		return 0x821635A0;
		  /* 821635A0h */ case    4:  		/* addi R11, R11, 244 */
		/* 821635A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xF4);
		/* 821635A0h case    4:*/		return 0x821635A4;
		  /* 821635A4h */ case    5:  		/* rlwinm R8, R6, 0, 27, 31 */
		/* 821635A4h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R6);
		/* 821635A4h case    5:*/		return 0x821635A8;
		  /* 821635A8h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821635A8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821635A8h case    6:*/		return 0x821635AC;
		  /* 821635ACh */ case    7:  		/* li R7, 1 */
		/* 821635ACh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821635ACh case    7:*/		return 0x821635B0;
		  /* 821635B0h */ case    8:  		/* stwx R9, <#[R10 + R3]> */
		/* 821635B0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 821635B0h case    8:*/		return 0x821635B4;
		  /* 821635B4h */ case    9:  		/* slw R10, R7, R8 */
		/* 821635B4h case    9:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R7,regs.R8);
		/* 821635B4h case    9:*/		return 0x821635B8;
		  /* 821635B8h */ case   10:  		/* lwzx R9, <#[R11 + R3]> */
		/* 821635B8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821635B8h case   10:*/		return 0x821635BC;
		  /* 821635BCh */ case   11:  		/* or R10, R10, R9 */
		/* 821635BCh case   11:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821635BCh case   11:*/		return 0x821635C0;
		  /* 821635C0h */ case   12:  		/* stwx R10, <#[R11 + R3]> */
		/* 821635C0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821635C0h case   12:*/		return 0x821635C4;
		  /* 821635C4h */ case   13:  		/* b 88 */
		/* 821635C4h case   13:*/		return 0x8216361C;
		/* 821635C4h case   13:*/		return 0x821635C8;
	}
	return 0x821635C8;
} // Block from 82163590h-821635C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821635C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821635C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821635C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821635C8);
		  /* 821635C8h */ case    0:  		/* rlwinm R10, R6, 27, 5, 31 */
		/* 821635C8h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R6);
		/* 821635C8h case    0:*/		return 0x821635CC;
		  /* 821635CCh */ case    1:  		/* rlwinm R9, R6, 0, 27, 31 */
		/* 821635CCh case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R6);
		/* 821635CCh case    1:*/		return 0x821635D0;
		  /* 821635D0h */ case    2:  		/* addi R11, R10, 4 */
		/* 821635D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 821635D0h case    2:*/		return 0x821635D4;
		  /* 821635D4h */ case    3:  		/* li R8, 1 */
		/* 821635D4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821635D4h case    3:*/		return 0x821635D8;
		  /* 821635D8h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821635D8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821635D8h case    4:*/		return 0x821635DC;
		  /* 821635DCh */ case    5:  		/* slw R8, R8, R9 */
		/* 821635DCh case    5:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 821635DCh case    5:*/		return 0x821635E0;
		  /* 821635E0h */ case    6:  		/* lwzx R6, <#[R11 + R3]> */
		/* 821635E0h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821635E0h case    6:*/		return 0x821635E4;
		  /* 821635E4h */ case    7:  		/* addi R10, R10, 236 */
		/* 821635E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xEC);
		/* 821635E4h case    7:*/		return 0x821635E8;
		  /* 821635E8h */ case    8:  		/* andc R6, R6, R8 */
		/* 821635E8h case    8:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R6,regs.R8);
		/* 821635E8h case    8:*/		return 0x821635EC;
		  /* 821635ECh */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821635ECh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821635ECh case    9:*/		return 0x821635F0;
		  /* 821635F0h */ case   10:  		/* stwx R6, <#[R11 + R3]> */
		/* 821635F0h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821635F0h case   10:*/		return 0x821635F4;
		  /* 821635F4h */ case   11:  		/* rlwinm R6, R6, 0, 0, 31 */
		/* 821635F4h case   11:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R6);
		/* 821635F4h case   11:*/		return 0x821635F8;
		  /* 821635F8h */ case   12:  		/* lwz R7, <#[R7]> */
		/* 821635F8h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 821635F8h case   12:*/		return 0x821635FC;
		  /* 821635FCh */ case   13:  		/* addic R5, R7, -1 */
		/* 821635FCh case   13:*/		cpu::op::addic<0>(regs,&regs.R5,regs.R7,0xFFFFFFFF);
		/* 821635FCh case   13:*/		return 0x82163600;
		  /* 82163600h */ case   14:  		/* subfe R7, R5, R7 */
		/* 82163600h case   14:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 82163600h case   14:*/		return 0x82163604;
		  /* 82163604h */ case   15:  		/* slw R9, R7, R9 */
		/* 82163604h case   15:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82163604h case   15:*/		return 0x82163608;
		  /* 82163608h */ case   16:  		/* or R9, R9, R6 */
		/* 82163608h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82163608h case   16:*/		return 0x8216360C;
		  /* 8216360Ch */ case   17:  		/* stwx R9, <#[R11 + R3]> */
		/* 8216360Ch case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216360Ch case   17:*/		return 0x82163610;
		  /* 82163610h */ case   18:  		/* lwzx R11, <#[R10 + R3]> */
		/* 82163610h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82163610h case   18:*/		return 0x82163614;
		  /* 82163614h */ case   19:  		/* or R11, R11, R8 */
		/* 82163614h case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82163614h case   19:*/		return 0x82163618;
		  /* 82163618h */ case   20:  		/* stwx R11, <#[R10 + R3]> */
		/* 82163618h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82163618h case   20:*/		return 0x8216361C;
	}
	return 0x8216361C;
} // Block from 821635C8h-8216361Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216361Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216361C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216361C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216361C);
		  /* 8216361Ch */ case    0:  		/* li R3, 0 */
		/* 8216361Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216361Ch case    0:*/		return 0x82163620;
		  /* 82163620h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82163620h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82163620h case    1:*/		return 0x82163624;
	}
	return 0x82163624;
} // Block from 8216361Ch-82163624h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163624);
		  /* 82163624h */ case    0:  		/* nop */
		/* 82163624h case    0:*/		cpu::op::nop();
		/* 82163624h case    0:*/		return 0x82163628;
		  /* 82163628h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 82163628h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82163628h case    1:*/		return 0x8216362C;
		  /* 8216362Ch */ case    2:  		/* bc 12, CR6_EQ, 224 */
		/* 8216362Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8216370C;  }
		/* 8216362Ch case    2:*/		return 0x82163630;
		  /* 82163630h */ case    3:  		/* cmplwi CR6, R6, 1 */
		/* 82163630h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82163630h case    3:*/		return 0x82163634;
		  /* 82163634h */ case    4:  		/* bc 12, CR6_LT, 112 */
		/* 82163634h case    4:*/		if ( regs.CR[6].lt ) { return 0x821636A4;  }
		/* 82163634h case    4:*/		return 0x82163638;
		  /* 82163638h */ case    5:  		/* bc 4, CR6_EQ, 212 */
		/* 82163638h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216370C;  }
		/* 82163638h case    5:*/		return 0x8216363C;
		  /* 8216363Ch */ case    6:  		/* addi R11, R7, 12 */
		/* 8216363Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0xC);
		/* 8216363Ch case    6:*/		return 0x82163640;
		  /* 82163640h */ case    7:  		/* lwz R9, <#[R8]> */
		/* 82163640h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82163640h case    7:*/		return 0x82163644;
		  /* 82163644h */ case    8:  		/* rlwinm R10, R7, 27, 5, 31 */
		/* 82163644h case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R7);
		/* 82163644h case    8:*/		return 0x82163648;
		  /* 82163648h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82163648h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82163648h case    9:*/		return 0x8216364C;
		  /* 8216364Ch */ case   10:  		/* addi R6, R10, 244 */
		/* 8216364Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xF4);
		/* 8216364Ch case   10:*/		return 0x82163650;
		  /* 82163650h */ case   11:  		/* add R11, R11, R3 */
		/* 82163650h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82163650h case   11:*/		return 0x82163654;
		  /* 82163654h */ case   12:  		/* addi R5, R10, 254 */
		/* 82163654h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFE);
		/* 82163654h case   12:*/		return 0x82163658;
		  /* 82163658h */ case   13:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 82163658h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 82163658h case   13:*/		return 0x8216365C;
		  /* 8216365Ch */ case   14:  		/* li R6, 1 */
		/* 8216365Ch case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216365Ch case   14:*/		return 0x82163660;
		  /* 82163660h */ case   15:  		/* rlwinm R7, R7, 0, 27, 31 */
		/* 82163660h case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R7);
		/* 82163660h case   15:*/		return 0x82163664;
		  /* 82163664h */ case   16:  		/* stb R9, <#[R11]> */
		/* 82163664h case   16:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82163664h case   16:*/		return 0x82163668;
		  /* 82163668h */ case   17:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 82163668h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 82163668h case   17:*/		return 0x8216366C;
		  /* 8216366Ch */ case   18:  		/* slw R7, R6, R7 */
		/* 8216366Ch case   18:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R6,regs.R7);
		/* 8216366Ch case   18:*/		return 0x82163670;
		  /* 82163670h */ case   19:  		/* lwz R6, <#[R8 + 4]> */
		/* 82163670h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000004) );
		/* 82163670h case   19:*/		return 0x82163674;
		  /* 82163674h */ case   20:  		/* stb R6, <#[R11 + 1]> */
		/* 82163674h case   20:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00000001) );
		/* 82163674h case   20:*/		return 0x82163678;
		  /* 82163678h */ case   21:  		/* lwz R6, <#[R8 + 8]> */
		/* 82163678h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000008) );
		/* 82163678h case   21:*/		return 0x8216367C;
		  /* 8216367Ch */ case   22:  		/* stb R6, <#[R11 + 2]> */
		/* 8216367Ch case   22:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00000002) );
		/* 8216367Ch case   22:*/		return 0x82163680;
		  /* 82163680h */ case   23:  		/* lwz R8, <#[R8 + 12]> */
		/* 82163680h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 82163680h case   23:*/		return 0x82163684;
		  /* 82163684h */ case   24:  		/* stb R8, <#[R11 + 3]> */
		/* 82163684h case   24:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R11 + 0x00000003) );
		/* 82163684h case   24:*/		return 0x82163688;
		  /* 82163688h */ case   25:  		/* lwzx R11, <#[R10 + R3]> */
		/* 82163688h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82163688h case   25:*/		return 0x8216368C;
		  /* 8216368Ch */ case   26:  		/* or R11, R11, R7 */
		/* 8216368Ch case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8216368Ch case   26:*/		return 0x82163690;
		  /* 82163690h */ case   27:  		/* stwx R11, <#[R10 + R3]> */
		/* 82163690h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82163690h case   27:*/		return 0x82163694;
		  /* 82163694h */ case   28:  		/* lwzx R11, <#[R9 + R3]> */
		/* 82163694h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82163694h case   28:*/		return 0x82163698;
		  /* 82163698h */ case   29:  		/* or R11, R11, R7 */
		/* 82163698h case   29:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82163698h case   29:*/		return 0x8216369C;
		  /* 8216369Ch */ case   30:  		/* stwx R11, <#[R9 + R3]> */
		/* 8216369Ch case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8216369Ch case   30:*/		return 0x821636A0;
		  /* 821636A0h */ case   31:  		/* b 108 */
		/* 821636A0h case   31:*/		return 0x8216370C;
		/* 821636A0h case   31:*/		return 0x821636A4;
	}
	return 0x821636A4;
} // Block from 82163624h-821636A4h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821636A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821636A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821636A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821636A4);
		  /* 821636A4h */ case    0:  		/* rlwinm R10, R7, 27, 5, 31 */
		/* 821636A4h case    0:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R7);
		/* 821636A4h case    0:*/		return 0x821636A8;
		  /* 821636A8h */ case    1:  		/* rlwinm R7, R7, 0, 27, 31 */
		/* 821636A8h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R7);
		/* 821636A8h case    1:*/		return 0x821636AC;
		  /* 821636ACh */ case    2:  		/* addi R11, R10, 4 */
		/* 821636ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 821636ACh case    2:*/		return 0x821636B0;
		  /* 821636B0h */ case    3:  		/* li R9, 1 */
		/* 821636B0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821636B0h case    3:*/		return 0x821636B4;
		  /* 821636B4h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821636B4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821636B4h case    4:*/		return 0x821636B8;
		  /* 821636B8h */ case    5:  		/* slw R6, R9, R7 */
		/* 821636B8h case    5:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R9,regs.R7);
		/* 821636B8h case    5:*/		return 0x821636BC;
		  /* 821636BCh */ case    6:  		/* lwzx R9, <#[R11 + R3]> */
		/* 821636BCh case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821636BCh case    6:*/		return 0x821636C0;
		  /* 821636C0h */ case    7:  		/* addi R5, R10, 236 */
		/* 821636C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xEC);
		/* 821636C0h case    7:*/		return 0x821636C4;
		  /* 821636C4h */ case    8:  		/* addi R10, R10, 246 */
		/* 821636C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xF6);
		/* 821636C4h case    8:*/		return 0x821636C8;
		  /* 821636C8h */ case    9:  		/* andc R4, R9, R6 */
		/* 821636C8h case    9:*/		cpu::op::andc<0>(regs,&regs.R4,regs.R9,regs.R6);
		/* 821636C8h case    9:*/		return 0x821636CC;
		  /* 821636CCh */ case   10:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 821636CCh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 821636CCh case   10:*/		return 0x821636D0;
		  /* 821636D0h */ case   11:  		/* stwx R4, <#[R11 + R3]> */
		/* 821636D0h case   11:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821636D0h case   11:*/		return 0x821636D4;
		  /* 821636D4h */ case   12:  		/* rlwinm R5, R4, 0, 0, 31 */
		/* 821636D4h case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R5,regs.R4);
		/* 821636D4h case   12:*/		return 0x821636D8;
		  /* 821636D8h */ case   13:  		/* lwz R8, <#[R8]> */
		/* 821636D8h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 821636D8h case   13:*/		return 0x821636DC;
		  /* 821636DCh */ case   14:  		/* addic R4, R8, -1 */
		/* 821636DCh case   14:*/		cpu::op::addic<0>(regs,&regs.R4,regs.R8,0xFFFFFFFF);
		/* 821636DCh case   14:*/		return 0x821636E0;
		  /* 821636E0h */ case   15:  		/* subfe R8, R4, R8 */
		/* 821636E0h case   15:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R4,regs.R8);
		/* 821636E0h case   15:*/		return 0x821636E4;
		  /* 821636E4h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821636E4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821636E4h case   16:*/		return 0x821636E8;
		  /* 821636E8h */ case   17:  		/* slw R8, R8, R7 */
		/* 821636E8h case   17:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821636E8h case   17:*/		return 0x821636EC;
		  /* 821636ECh */ case   18:  		/* or R8, R8, R5 */
		/* 821636ECh case   18:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 821636ECh case   18:*/		return 0x821636F0;
		  /* 821636F0h */ case   19:  		/* stwx R8, <#[R11 + R3]> */
		/* 821636F0h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821636F0h case   19:*/		return 0x821636F4;
		  /* 821636F4h */ case   20:  		/* lwzx R11, <#[R9 + R3]> */
		/* 821636F4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 821636F4h case   20:*/		return 0x821636F8;
		  /* 821636F8h */ case   21:  		/* or R11, R6, R11 */
		/* 821636F8h case   21:*/		cpu::op::or<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 821636F8h case   21:*/		return 0x821636FC;
		  /* 821636FCh */ case   22:  		/* stwx R11, <#[R9 + R3]> */
		/* 821636FCh case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 821636FCh case   22:*/		return 0x82163700;
		  /* 82163700h */ case   23:  		/* lwzx R11, <#[R10 + R3]> */
		/* 82163700h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82163700h case   23:*/		return 0x82163704;
		  /* 82163704h */ case   24:  		/* or R11, R6, R11 */
		/* 82163704h case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82163704h case   24:*/		return 0x82163708;
		  /* 82163708h */ case   25:  		/* stwx R11, <#[R10 + R3]> */
		/* 82163708h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82163708h case   25:*/		return 0x8216370C;
	}
	return 0x8216370C;
} // Block from 821636A4h-8216370Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216370Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216370C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216370C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216370C);
		  /* 8216370Ch */ case    0:  		/* li R3, 0 */
		/* 8216370Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216370Ch case    0:*/		return 0x82163710;
		  /* 82163710h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82163710h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82163710h case    1:*/		return 0x82163714;
	}
	return 0x82163714;
} // Block from 8216370Ch-82163714h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163714);
		  /* 82163714h */ case    0:  		/* nop */
		/* 82163714h case    0:*/		cpu::op::nop();
		/* 82163714h case    0:*/		return 0x82163718;
	}
	return 0x82163718;
} // Block from 82163714h-82163718h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163718);
		  /* 82163718h */ case    0:  		/* mfspr R12, LR */
		/* 82163718h case    0:*/		regs.R12 = regs.LR;
		/* 82163718h case    0:*/		return 0x8216371C;
		  /* 8216371Ch */ case    1:  		/* bl -861376 */
		/* 8216371Ch case    1:*/		regs.LR = 0x82163720; return 0x8209125C;
		/* 8216371Ch case    1:*/		return 0x82163720;
		  /* 82163720h */ case    2:  		/* rlwinm. R11, R3, 0, 30, 30 */
		/* 82163720h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R3);
		/* 82163720h case    2:*/		return 0x82163724;
		  /* 82163724h */ case    3:  		/* bc 12, CR0_EQ, 1044 */
		/* 82163724h case    3:*/		if ( regs.CR[0].eq ) { return 0x82163B38;  }
		/* 82163724h case    3:*/		return 0x82163728;
		  /* 82163728h */ case    4:  		/* lwz R11, <#[R5]> */
		/* 82163728h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82163728h case    4:*/		return 0x8216372C;
		  /* 8216372Ch */ case    5:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8216372Ch case    5:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8216372Ch case    5:*/		return 0x82163730;
		  /* 82163730h */ case    6:  		/* bc 4, CR0_EQ, 556 */
		/* 82163730h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216395C;  }
		/* 82163730h case    6:*/		return 0x82163734;
		  /* 82163734h */ case    7:  		/* rlwinm. R11, R3, 0, 27, 27 */
		/* 82163734h case    7:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R3);
		/* 82163734h case    7:*/		return 0x82163738;
		  /* 82163738h */ case    8:  		/* bc 4, CR0_EQ, 176 */
		/* 82163738h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821637E8;  }
		/* 82163738h case    8:*/		return 0x8216373C;
		  /* 8216373Ch */ case    9:  		/* li R11, 2 */
		/* 8216373Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8216373Ch case    9:*/		return 0x82163740;
		  /* 82163740h */ case   10:  		/* rlwinm. R10, R3, 0, 24, 24 */
		/* 82163740h case   10:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R3);
		/* 82163740h case   10:*/		return 0x82163744;
		  /* 82163744h */ case   11:  		/* stw R11, <#[R6 + 1096]> */
		/* 82163744h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000448) );
		/* 82163744h case   11:*/		return 0x82163748;
		  /* 82163748h */ case   12:  		/* bc 4, CR0_EQ, 72 */
		/* 82163748h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82163790;  }
		/* 82163748h case   12:*/		return 0x8216374C;
		  /* 8216374Ch */ case   13:  		/* lwz R11, <#[R6 + 1076]> */
		/* 8216374Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000434) );
		/* 8216374Ch case   13:*/		return 0x82163750;
		  /* 82163750h */ case   14:  		/* lwz R10, <#[R6 + 1100]> */
		/* 82163750h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000044C) );
		/* 82163750h case   14:*/		return 0x82163754;
		  /* 82163754h */ case   15:  		/* lwz R9, <#[R6 + 1108]> */
		/* 82163754h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000454) );
		/* 82163754h case   15:*/		return 0x82163758;
		  /* 82163758h */ case   16:  		/* addi R8, R11, 1 */
		/* 82163758h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 82163758h case   16:*/		return 0x8216375C;
		  /* 8216375Ch */ case   17:  		/* lwz R7, <#[R6 + 1116]> */
		/* 8216375Ch case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x0000045C) );
		/* 8216375Ch case   17:*/		return 0x82163760;
		  /* 82163760h */ case   18:  		/* addi R10, R10, 1 */
		/* 82163760h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82163760h case   18:*/		return 0x82163764;
		  /* 82163764h */ case   19:  		/* addi R11, R9, 1 */
		/* 82163764h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x1);
		/* 82163764h case   19:*/		return 0x82163768;
		  /* 82163768h */ case   20:  		/* stw R8, <#[R6 + 1076]> */
		/* 82163768h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000434) );
		/* 82163768h case   20:*/		return 0x8216376C;
		  /* 8216376Ch */ case   21:  		/* cmpwi CR6, R7, 0 */
		/* 8216376Ch case   21:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8216376Ch case   21:*/		return 0x82163770;
		  /* 82163770h */ case   22:  		/* stw R10, <#[R6 + 1100]> */
		/* 82163770h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x0000044C) );
		/* 82163770h case   22:*/		return 0x82163774;
		  /* 82163774h */ case   23:  		/* stw R11, <#[R6 + 1108]> */
		/* 82163774h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 82163774h case   23:*/		return 0x82163778;
		  /* 82163778h */ case   24:  		/* bc 12, CR6_EQ, 24 */
		/* 82163778h case   24:*/		if ( regs.CR[6].eq ) { return 0x82163790;  }
		/* 82163778h case   24:*/		return 0x8216377C;
		  /* 8216377Ch */ case   25:  		/* lwz R10, <#[R6 + 1120]> */
		/* 8216377Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000460) );
		/* 8216377Ch case   25:*/		return 0x82163780;
		  /* 82163780h */ case   26:  		/* cmpwi CR6, R10, 0 */
		/* 82163780h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82163780h case   26:*/		return 0x82163784;
		  /* 82163784h */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 82163784h case   27:*/		if ( regs.CR[6].eq ) { return 0x82163790;  }
		/* 82163784h case   27:*/		return 0x82163788;
		  /* 82163788h */ case   28:  		/* addi R11, R11, 1 */
		/* 82163788h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163788h case   28:*/		return 0x8216378C;
		  /* 8216378Ch */ case   29:  		/* stw R11, <#[R6 + 1108]> */
		/* 8216378Ch case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 8216378Ch case   29:*/		return 0x82163790;
	}
	return 0x82163790;
} // Block from 82163718h-82163790h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82163790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163790);
		  /* 82163790h */ case    0:  		/* lwz R11, <#[R6 + 1072]> */
		/* 82163790h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000430) );
		/* 82163790h case    0:*/		return 0x82163794;
		  /* 82163794h */ case    1:  		/* lwz R10, <#[R6 + 1104]> */
		/* 82163794h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000450) );
		/* 82163794h case    1:*/		return 0x82163798;
		  /* 82163798h */ case    2:  		/* lwz R9, <#[R6 + 1112]> */
		/* 82163798h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000458) );
		/* 82163798h case    2:*/		return 0x8216379C;
		  /* 8216379Ch */ case    3:  		/* addi R8, R11, 1 */
		/* 8216379Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 8216379Ch case    3:*/		return 0x821637A0;
		  /* 821637A0h */ case    4:  		/* lwz R7, <#[R6 + 1116]> */
		/* 821637A0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x0000045C) );
		/* 821637A0h case    4:*/		return 0x821637A4;
		  /* 821637A4h */ case    5:  		/* addi R10, R10, 1 */
		/* 821637A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821637A4h case    5:*/		return 0x821637A8;
		  /* 821637A8h */ case    6:  		/* addi R11, R9, 1 */
		/* 821637A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x1);
		/* 821637A8h case    6:*/		return 0x821637AC;
		  /* 821637ACh */ case    7:  		/* stw R8, <#[R6 + 1072]> */
		/* 821637ACh case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000430) );
		/* 821637ACh case    7:*/		return 0x821637B0;
		  /* 821637B0h */ case    8:  		/* stw R10, <#[R6 + 1104]> */
		/* 821637B0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000450) );
		/* 821637B0h case    8:*/		return 0x821637B4;
		  /* 821637B4h */ case    9:  		/* cmpwi CR6, R7, 0 */
		/* 821637B4h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 821637B4h case    9:*/		return 0x821637B8;
		  /* 821637B8h */ case   10:  		/* stw R11, <#[R6 + 1112]> */
		/* 821637B8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000458) );
		/* 821637B8h case   10:*/		return 0x821637BC;
		  /* 821637BCh */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 821637BCh case   11:*/		if ( regs.CR[6].eq ) { return 0x821637D4;  }
		/* 821637BCh case   11:*/		return 0x821637C0;
		  /* 821637C0h */ case   12:  		/* lwz R10, <#[R6 + 1120]> */
		/* 821637C0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000460) );
		/* 821637C0h case   12:*/		return 0x821637C4;
		  /* 821637C4h */ case   13:  		/* cmpwi CR6, R10, 0 */
		/* 821637C4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821637C4h case   13:*/		return 0x821637C8;
		  /* 821637C8h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 821637C8h case   14:*/		if ( regs.CR[6].eq ) { return 0x821637D4;  }
		/* 821637C8h case   14:*/		return 0x821637CC;
		  /* 821637CCh */ case   15:  		/* addi R11, R11, 1 */
		/* 821637CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821637CCh case   15:*/		return 0x821637D0;
		  /* 821637D0h */ case   16:  		/* stw R11, <#[R6 + 1112]> */
		/* 821637D0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000458) );
		/* 821637D0h case   16:*/		return 0x821637D4;
	}
	return 0x821637D4;
} // Block from 82163790h-821637D4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821637D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821637D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821637D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821637D4);
		  /* 821637D4h */ case    0:  		/* li R11, 0 */
		/* 821637D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821637D4h case    0:*/		return 0x821637D8;
		  /* 821637D8h */ case    1:  		/* li R10, 1 */
		/* 821637D8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821637D8h case    1:*/		return 0x821637DC;
		  /* 821637DCh */ case    2:  		/* stw R11, <#[R6 + 1120]> */
		/* 821637DCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000460) );
		/* 821637DCh case    2:*/		return 0x821637E0;
		  /* 821637E0h */ case    3:  		/* stw R10, <#[R6 + 1116]> */
		/* 821637E0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x0000045C) );
		/* 821637E0h case    3:*/		return 0x821637E4;
		  /* 821637E4h */ case    4:  		/* b 1216 */
		/* 821637E4h case    4:*/		return 0x82163CA4;
		/* 821637E4h case    4:*/		return 0x821637E8;
	}
	return 0x821637E8;
} // Block from 821637D4h-821637E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821637E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821637E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821637E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821637E8);
		  /* 821637E8h */ case    0:  		/* li R31, 0 */
		/* 821637E8h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821637E8h case    0:*/		return 0x821637EC;
		  /* 821637ECh */ case    1:  		/* li R29, 1 */
		/* 821637ECh case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821637ECh case    1:*/		return 0x821637F0;
		  /* 821637F0h */ case    2:  		/* rlwinm. R30, R3, 0, 24, 24 */
		/* 821637F0h case    2:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R30,regs.R3);
		/* 821637F0h case    2:*/		return 0x821637F4;
		  /* 821637F4h */ case    3:  		/* stw R31, <#[R6 + 1120]> */
		/* 821637F4h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000460) );
		/* 821637F4h case    3:*/		return 0x821637F8;
		  /* 821637F8h */ case    4:  		/* stw R29, <#[R6 + 1096]> */
		/* 821637F8h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000448) );
		/* 821637F8h case    4:*/		return 0x821637FC;
		  /* 821637FCh */ case    5:  		/* bc 4, CR0_EQ, 28 */
		/* 821637FCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x82163818;  }
		/* 821637FCh case    5:*/		return 0x82163800;
		  /* 82163800h */ case    6:  		/* lwz R11, <#[R6 + 1124]> */
		/* 82163800h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000464) );
		/* 82163800h case    6:*/		return 0x82163804;
		  /* 82163804h */ case    7:  		/* addi R10, R11, 1 */
		/* 82163804h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 82163804h case    7:*/		return 0x82163808;
		  /* 82163808h */ case    8:  		/* lwz R11, <#[R6 + 1132]> */
		/* 82163808h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000046C) );
		/* 82163808h case    8:*/		return 0x8216380C;
		  /* 8216380Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 8216380Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216380Ch case    9:*/		return 0x82163810;
		  /* 82163810h */ case   10:  		/* stw R10, <#[R6 + 1124]> */
		/* 82163810h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000464) );
		/* 82163810h case   10:*/		return 0x82163814;
		  /* 82163814h */ case   11:  		/* stw R11, <#[R6 + 1132]> */
		/* 82163814h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x0000046C) );
		/* 82163814h case   11:*/		return 0x82163818;
	}
	return 0x82163818;
} // Block from 821637E8h-82163818h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82163818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163818);
		  /* 82163818h */ case    0:  		/* lwz R11, <#[R6 + 1128]> */
		/* 82163818h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000468) );
		/* 82163818h case    0:*/		return 0x8216381C;
		  /* 8216381Ch */ case    1:  		/* addi R10, R11, 1 */
		/* 8216381Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 8216381Ch case    1:*/		return 0x82163820;
		  /* 82163820h */ case    2:  		/* lwz R11, <#[R6 + 1136]> */
		/* 82163820h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000470) );
		/* 82163820h case    2:*/		return 0x82163824;
		  /* 82163824h */ case    3:  		/* addi R11, R11, 1 */
		/* 82163824h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163824h case    3:*/		return 0x82163828;
		  /* 82163828h */ case    4:  		/* stw R10, <#[R6 + 1128]> */
		/* 82163828h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000468) );
		/* 82163828h case    4:*/		return 0x8216382C;
		  /* 8216382Ch */ case    5:  		/* stw R11, <#[R6 + 1136]> */
		/* 8216382Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000470) );
		/* 8216382Ch case    5:*/		return 0x82163830;
		  /* 82163830h */ case    6:  		/* lwz R10, <#[R5 + 4]> */
		/* 82163830h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 82163830h case    6:*/		return 0x82163834;
		  /* 82163834h */ case    7:  		/* rlwinm. R11, R10, 0, 10, 15 */
		/* 82163834h case    7:*/		cpu::op::rlwinm<1,0,10,15>(regs,&regs.R11,regs.R10);
		/* 82163834h case    7:*/		return 0x82163838;
		  /* 82163838h */ case    8:  		/* bc 4, CR0_EQ, 176 */
		/* 82163838h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821638E8;  }
		/* 82163838h case    8:*/		return 0x8216383C;
		  /* 8216383Ch */ case    9:  		/* lwz R11, <#[R6 + 1020]> */
		/* 8216383Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x000003FC) );
		/* 8216383Ch case    9:*/		return 0x82163840;
		  /* 82163840h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82163840h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82163840h case   10:*/		return 0x82163844;
		  /* 82163844h */ case   11:  		/* bc 12, CR6_EQ, 164 */
		/* 82163844h case   11:*/		if ( regs.CR[6].eq ) { return 0x821638E8;  }
		/* 82163844h case   11:*/		return 0x82163848;
		  /* 82163848h */ case   12:  		/* lwz R8, <#[R6 + 1024]> */
		/* 82163848h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000400) );
		/* 82163848h case   12:*/		return 0x8216384C;
		  /* 8216384Ch */ case   13:  		/* mr R5, R31 */
		/* 8216384Ch case   13:*/		regs.R5 = regs.R31;
		/* 8216384Ch case   13:*/		return 0x82163850;
		  /* 82163850h */ case   14:  		/* mr R7, R31 */
		/* 82163850h case   14:*/		regs.R7 = regs.R31;
		/* 82163850h case   14:*/		return 0x82163854;
		  /* 82163854h */ case   15:  		/* mr R3, R31 */
		/* 82163854h case   15:*/		regs.R3 = regs.R31;
		/* 82163854h case   15:*/		return 0x82163858;
		  /* 82163858h */ case   16:  		/* mr R9, R31 */
		/* 82163858h case   16:*/		regs.R9 = regs.R31;
		/* 82163858h case   16:*/		return 0x8216385C;
		  /* 8216385Ch */ case   17:  		/* stw R29, <#[R6 + 1048]> */
		/* 8216385Ch case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000418) );
		/* 8216385Ch case   17:*/		return 0x82163860;
		  /* 82163860h */ case   18:  		/* lwzx R11, <#[R9 + R8]> */
		/* 82163860h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82163860h case   18:*/		return 0x82163864;
		  /* 82163864h */ case   19:  		/* rlwinm R10, R11, 12, 30, 31 */
		/* 82163864h case   19:*/		cpu::op::rlwinm<0,12,30,31>(regs,&regs.R10,regs.R11);
		/* 82163864h case   19:*/		return 0x82163868;
		  /* 82163868h */ case   20:  		/* cmplwi CR6, R10, 1 */
		/* 82163868h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82163868h case   20:*/		return 0x8216386C;
		  /* 8216386Ch */ case   21:  		/* bc 4, CR6_EQ, 12 */
		/* 8216386Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x82163878;  }
		/* 8216386Ch case   21:*/		return 0x82163870;
		  /* 82163870h */ case   22:  		/* mr R5, R29 */
		/* 82163870h case   22:*/		regs.R5 = regs.R29;
		/* 82163870h case   22:*/		return 0x82163874;
		  /* 82163874h */ case   23:  		/* mr R7, R31 */
		/* 82163874h case   23:*/		regs.R7 = regs.R31;
		/* 82163874h case   23:*/		return 0x82163878;
	}
	return 0x82163878;
} // Block from 82163818h-82163878h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82163878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163878);
		  /* 82163878h */ case    0:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82163878h case    0:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82163878h case    0:*/		return 0x8216387C;
		  /* 8216387Ch */ case    1:  		/* cmplw CR6, R11, R4 */
		/* 8216387Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8216387Ch case    1:*/		return 0x82163880;
		  /* 82163880h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 82163880h case    2:*/		if ( regs.CR[6].eq ) { return 0x821638B4;  }
		/* 82163880h case    2:*/		return 0x82163884;
		  /* 82163884h */ case    3:  		/* addi R7, R7, 1 */
		/* 82163884h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82163884h case    3:*/		return 0x82163888;
		  /* 82163888h */ case    4:  		/* cmplwi CR6, R10, 2 */
		/* 82163888h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 82163888h case    4:*/		return 0x8216388C;
		  /* 8216388Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8216388Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82163898;  }
		/* 8216388Ch case    5:*/		return 0x82163890;
		  /* 82163890h */ case    6:  		/* cmplwi CR6, R10, 3 */
		/* 82163890h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 82163890h case    6:*/		return 0x82163894;
		  /* 82163894h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82163894h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8216389C;  }
		/* 82163894h case    7:*/		return 0x82163898;
	}
	return 0x82163898;
} // Block from 82163878h-82163898h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82163898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163898);
		  /* 82163898h */ case    0:  		/* mr R5, R31 */
		/* 82163898h case    0:*/		regs.R5 = regs.R31;
		/* 82163898h case    0:*/		return 0x8216389C;
	}
	return 0x8216389C;
} // Block from 82163898h-8216389Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216389Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216389C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216389C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216389C);
		  /* 8216389Ch */ case    0:  		/* lwz R11, <#[R6 + 1020]> */
		/* 8216389Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x000003FC) );
		/* 8216389Ch case    0:*/		return 0x821638A0;
		  /* 821638A0h */ case    1:  		/* addi R3, R3, 1 */
		/* 821638A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821638A0h case    1:*/		return 0x821638A4;
		  /* 821638A4h */ case    2:  		/* addi R9, R9, 4 */
		/* 821638A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821638A4h case    2:*/		return 0x821638A8;
		  /* 821638A8h */ case    3:  		/* cmplw CR6, R3, R11 */
		/* 821638A8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 821638A8h case    3:*/		return 0x821638AC;
		  /* 821638ACh */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 821638ACh case    4:*/		if ( regs.CR[6].lt ) { return 0x8216385C;  }
		/* 821638ACh case    4:*/		return 0x821638B0;
		  /* 821638B0h */ case    5:  		/* b 1012 */
		/* 821638B0h case    5:*/		return 0x82163CA4;
		/* 821638B0h case    5:*/		return 0x821638B4;
	}
	return 0x821638B4;
} // Block from 8216389Ch-821638B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821638B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821638B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821638B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821638B4);
		  /* 821638B4h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 821638B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 821638B4h case    0:*/		return 0x821638B8;
		  /* 821638B8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 821638B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821638C4;  }
		/* 821638B8h case    1:*/		return 0x821638BC;
		  /* 821638BCh */ case    2:  		/* rlwinm. R11, R7, 0, 30, 31 */
		/* 821638BCh case    2:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R7);
		/* 821638BCh case    2:*/		return 0x821638C0;
		  /* 821638C0h */ case    3:  		/* bc 4, CR0_EQ, 996 */
		/* 821638C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82163CA4;  }
		/* 821638C0h case    3:*/		return 0x821638C4;
	}
	return 0x821638C4;
} // Block from 821638B4h-821638C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821638C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821638C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821638C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821638C4);
		  /* 821638C4h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821638C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821638C4h case    0:*/		return 0x821638C8;
		  /* 821638C8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 821638C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821638D8;  }
		/* 821638C8h case    1:*/		return 0x821638CC;
		  /* 821638CCh */ case    2:  		/* lwz R11, <#[R6 + 1060]> */
		/* 821638CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000424) );
		/* 821638CCh case    2:*/		return 0x821638D0;
		  /* 821638D0h */ case    3:  		/* addi R11, R11, 1 */
		/* 821638D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821638D0h case    3:*/		return 0x821638D4;
		  /* 821638D4h */ case    4:  		/* stw R11, <#[R6 + 1060]> */
		/* 821638D4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000424) );
		/* 821638D4h case    4:*/		return 0x821638D8;
	}
	return 0x821638D8;
} // Block from 821638C4h-821638D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821638D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821638D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821638D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821638D8);
		  /* 821638D8h */ case    0:  		/* lwz R11, <#[R6 + 1056]> */
		/* 821638D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000420) );
		/* 821638D8h case    0:*/		return 0x821638DC;
		  /* 821638DCh */ case    1:  		/* addi R11, R11, 1 */
		/* 821638DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821638DCh case    1:*/		return 0x821638E0;
		  /* 821638E0h */ case    2:  		/* stw R11, <#[R6 + 1056]> */
		/* 821638E0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000420) );
		/* 821638E0h case    2:*/		return 0x821638E4;
		  /* 821638E4h */ case    3:  		/* b 960 */
		/* 821638E4h case    3:*/		return 0x82163CA4;
		/* 821638E4h case    3:*/		return 0x821638E8;
	}
	return 0x821638E8;
} // Block from 821638D8h-821638E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821638E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821638E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821638E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821638E8);
		  /* 821638E8h */ case    0:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 821638E8h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 821638E8h case    0:*/		return 0x821638EC;
		  /* 821638ECh */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 821638ECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82163910;  }
		/* 821638ECh case    1:*/		return 0x821638F0;
	}
	return 0x821638F0;
} // Block from 821638E8h-821638F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821638F0h
// Function '??0CShaderCost@XGRAPHICS@@QAA@HTGPU_PROGRAMCONTROL@@TGPU_CONTEXTMISC@@PBKK22PBTGPUFETCH_CONSTANT@@KPBT_UCODE_VSINPUTDECLARATION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821638F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821638F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821638F0);
		  /* 821638F0h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821638F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821638F0h case    0:*/		return 0x821638F4;
		  /* 821638F4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 821638F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82163904;  }
		/* 821638F4h case    1:*/		return 0x821638F8;
		  /* 821638F8h */ case    2:  		/* lwz R11, <#[R6 + 1060]> */
		/* 821638F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000424) );
		/* 821638F8h case    2:*/		return 0x821638FC;
		  /* 821638FCh */ case    3:  		/* addi R11, R11, 1 */
		/* 821638FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821638FCh case    3:*/		return 0x82163900;
		  /* 82163900h */ case    4:  		/* stw R11, <#[R6 + 1060]> */
		/* 82163900h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000424) );
		/* 82163900h case    4:*/		return 0x82163904;
	}
	return 0x82163904;
} // Block from 821638F0h-82163904h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163904);
		  /* 82163904h */ case    0:  		/* lwz R11, <#[R6 + 1056]> */
		/* 82163904h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000420) );
		/* 82163904h case    0:*/		return 0x82163908;
		  /* 82163908h */ case    1:  		/* addi R11, R11, 1 */
		/* 82163908h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163908h case    1:*/		return 0x8216390C;
		  /* 8216390Ch */ case    2:  		/* stw R11, <#[R6 + 1056]> */
		/* 8216390Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000420) );
		/* 8216390Ch case    2:*/		return 0x82163910;
	}
	return 0x82163910;
} // Block from 82163904h-82163910h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82163910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163910);
		  /* 82163910h */ case    0:  		/* lis R11, -32256 */
		/* 82163910h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82163910h case    0:*/		return 0x82163914;
		  /* 82163914h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82163914h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82163914h case    1:*/		return 0x82163918;
		  /* 82163918h */ case    2:  		/* addi R11, R11, 4488 */
		/* 82163918h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1188);
		/* 82163918h case    2:*/		return 0x8216391C;
		  /* 8216391Ch */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 8216391Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216393C;  }
		/* 8216391Ch case    3:*/		return 0x82163920;
		  /* 82163920h */ case    4:  		/* lhz R10, <#[R5 + 4]> */
		/* 82163920h case    4:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 82163920h case    4:*/		return 0x82163924;
		  /* 82163924h */ case    5:  		/* lwz R9, <#[R6 + 1068]> */
		/* 82163924h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000042C) );
		/* 82163924h case    5:*/		return 0x82163928;
		  /* 82163928h */ case    6:  		/* rlwinm R10, R10, 0, 26, 31 */
		/* 82163928h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R10);
		/* 82163928h case    6:*/		return 0x8216392C;
		  /* 8216392Ch */ case    7:  		/* lbzx R10, <#[R10 + R11]> */
		/* 8216392Ch case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8216392Ch case    7:*/		return 0x82163930;
		  /* 82163930h */ case    8:  		/* rlwinm R10, R10, 29, 3, 31 */
		/* 82163930h case    8:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R10,regs.R10);
		/* 82163930h case    8:*/		return 0x82163934;
		  /* 82163934h */ case    9:  		/* add R10, R10, R9 */
		/* 82163934h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82163934h case    9:*/		return 0x82163938;
		  /* 82163938h */ case   10:  		/* stw R10, <#[R6 + 1068]> */
		/* 82163938h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x0000042C) );
		/* 82163938h case   10:*/		return 0x8216393C;
	}
	return 0x8216393C;
} // Block from 82163910h-8216393Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216393Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216393C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216393C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216393C);
		  /* 8216393Ch */ case    0:  		/* lhz R9, <#[R5 + 4]> */
		/* 8216393Ch case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 8216393Ch case    0:*/		return 0x82163940;
		  /* 82163940h */ case    1:  		/* lwz R10, <#[R6 + 1064]> */
		/* 82163940h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000428) );
		/* 82163940h case    1:*/		return 0x82163944;
		  /* 82163944h */ case    2:  		/* rlwinm R9, R9, 0, 26, 31 */
		/* 82163944h case    2:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R9,regs.R9);
		/* 82163944h case    2:*/		return 0x82163948;
		  /* 82163948h */ case    3:  		/* lbzx R11, <#[R9 + R11]> */
		/* 82163948h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82163948h case    3:*/		return 0x8216394C;
		  /* 8216394Ch */ case    4:  		/* rlwinm R11, R11, 29, 3, 31 */
		/* 8216394Ch case    4:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R11,regs.R11);
		/* 8216394Ch case    4:*/		return 0x82163950;
		  /* 82163950h */ case    5:  		/* add R11, R11, R10 */
		/* 82163950h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82163950h case    5:*/		return 0x82163954;
		  /* 82163954h */ case    6:  		/* stw R11, <#[R6 + 1064]> */
		/* 82163954h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000428) );
		/* 82163954h case    6:*/		return 0x82163958;
		  /* 82163958h */ case    7:  		/* b 844 */
		/* 82163958h case    7:*/		return 0x82163CA4;
		/* 82163958h case    7:*/		return 0x8216395C;
	}
	return 0x8216395C;
} // Block from 8216393Ch-8216395Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216395Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216395C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216395C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216395C);
		  /* 8216395Ch */ case    0:  		/* li R11, 2 */
		/* 8216395Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8216395Ch case    0:*/		return 0x82163960;
		  /* 82163960h */ case    1:  		/* rlwinm. R3, R3, 0, 24, 24 */
		/* 82163960h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R3,regs.R3);
		/* 82163960h case    1:*/		return 0x82163964;
		  /* 82163964h */ case    2:  		/* stw R11, <#[R6 + 1096]> */
		/* 82163964h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000448) );
		/* 82163964h case    2:*/		return 0x82163968;
		  /* 82163968h */ case    3:  		/* bc 4, CR0_EQ, 60 */
		/* 82163968h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821639A4;  }
		/* 82163968h case    3:*/		return 0x8216396C;
		  /* 8216396Ch */ case    4:  		/* lwz R10, <#[R6 + 1100]> */
		/* 8216396Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000044C) );
		/* 8216396Ch case    4:*/		return 0x82163970;
		  /* 82163970h */ case    5:  		/* lwz R11, <#[R6 + 1108]> */
		/* 82163970h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 82163970h case    5:*/		return 0x82163974;
		  /* 82163974h */ case    6:  		/* lwz R9, <#[R6 + 1116]> */
		/* 82163974h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000045C) );
		/* 82163974h case    6:*/		return 0x82163978;
		  /* 82163978h */ case    7:  		/* addi R10, R10, 1 */
		/* 82163978h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82163978h case    7:*/		return 0x8216397C;
		  /* 8216397Ch */ case    8:  		/* addi R11, R11, 1 */
		/* 8216397Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216397Ch case    8:*/		return 0x82163980;
		  /* 82163980h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 82163980h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82163980h case    9:*/		return 0x82163984;
		  /* 82163984h */ case   10:  		/* stw R10, <#[R6 + 1100]> */
		/* 82163984h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x0000044C) );
		/* 82163984h case   10:*/		return 0x82163988;
		  /* 82163988h */ case   11:  		/* stw R11, <#[R6 + 1108]> */
		/* 82163988h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 82163988h case   11:*/		return 0x8216398C;
		  /* 8216398Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 8216398Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x821639A4;  }
		/* 8216398Ch case   12:*/		return 0x82163990;
		  /* 82163990h */ case   13:  		/* lwz R10, <#[R6 + 1120]> */
		/* 82163990h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000460) );
		/* 82163990h case   13:*/		return 0x82163994;
		  /* 82163994h */ case   14:  		/* cmpwi CR6, R10, 0 */
		/* 82163994h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82163994h case   14:*/		return 0x82163998;
		  /* 82163998h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82163998h case   15:*/		if ( regs.CR[6].eq ) { return 0x821639A4;  }
		/* 82163998h case   15:*/		return 0x8216399C;
		  /* 8216399Ch */ case   16:  		/* addi R11, R11, 1 */
		/* 8216399Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216399Ch case   16:*/		return 0x821639A0;
		  /* 821639A0h */ case   17:  		/* stw R11, <#[R6 + 1108]> */
		/* 821639A0h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 821639A0h case   17:*/		return 0x821639A4;
	}
	return 0x821639A4;
} // Block from 8216395Ch-821639A4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821639A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821639A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821639A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821639A4);
		  /* 821639A4h */ case    0:  		/* lwz R10, <#[R6 + 1104]> */
		/* 821639A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000450) );
		/* 821639A4h case    0:*/		return 0x821639A8;
		  /* 821639A8h */ case    1:  		/* lwz R11, <#[R6 + 1112]> */
		/* 821639A8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000458) );
		/* 821639A8h case    1:*/		return 0x821639AC;
		  /* 821639ACh */ case    2:  		/* lwz R9, <#[R6 + 1116]> */
		/* 821639ACh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000045C) );
		/* 821639ACh case    2:*/		return 0x821639B0;
		  /* 821639B0h */ case    3:  		/* addi R10, R10, 1 */
		/* 821639B0h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821639B0h case    3:*/		return 0x821639B4;
		  /* 821639B4h */ case    4:  		/* addi R11, R11, 1 */
		/* 821639B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821639B4h case    4:*/		return 0x821639B8;
		  /* 821639B8h */ case    5:  		/* stw R10, <#[R6 + 1104]> */
		/* 821639B8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000450) );
		/* 821639B8h case    5:*/		return 0x821639BC;
		  /* 821639BCh */ case    6:  		/* cmpwi CR6, R9, 0 */
		/* 821639BCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 821639BCh case    6:*/		return 0x821639C0;
		  /* 821639C0h */ case    7:  		/* stw R11, <#[R6 + 1112]> */
		/* 821639C0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000458) );
		/* 821639C0h case    7:*/		return 0x821639C4;
		  /* 821639C4h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 821639C4h case    8:*/		if ( regs.CR[6].eq ) { return 0x821639E0;  }
		/* 821639C4h case    8:*/		return 0x821639C8;
		  /* 821639C8h */ case    9:  		/* lwz R11, <#[R6 + 1120]> */
		/* 821639C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000460) );
		/* 821639C8h case    9:*/		return 0x821639CC;
		  /* 821639CCh */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 821639CCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821639CCh case   10:*/		return 0x821639D0;
		  /* 821639D0h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 821639D0h case   11:*/		if ( regs.CR[6].eq ) { return 0x821639E0;  }
		/* 821639D0h case   11:*/		return 0x821639D4;
		  /* 821639D4h */ case   12:  		/* lwz R11, <#[R6 + 1108]> */
		/* 821639D4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 821639D4h case   12:*/		return 0x821639D8;
		  /* 821639D8h */ case   13:  		/* addi R11, R11, 1 */
		/* 821639D8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821639D8h case   13:*/		return 0x821639DC;
		  /* 821639DCh */ case   14:  		/* stw R11, <#[R6 + 1108]> */
		/* 821639DCh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000454) );
		/* 821639DCh case   14:*/		return 0x821639E0;
	}
	return 0x821639E0;
} // Block from 821639A4h-821639E0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821639E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821639E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821639E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821639E0);
		  /* 821639E0h */ case    0:  		/* li R11, 0 */
		/* 821639E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821639E0h case    0:*/		return 0x821639E4;
		  /* 821639E4h */ case    1:  		/* lwz R10, <#[R6 + 980]> */
		/* 821639E4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x000003D4) );
		/* 821639E4h case    1:*/		return 0x821639E8;
		  /* 821639E8h */ case    2:  		/* li R29, 1 */
		/* 821639E8h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821639E8h case    2:*/		return 0x821639EC;
		  /* 821639ECh */ case    3:  		/* stw R11, <#[R6 + 1120]> */
		/* 821639ECh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000460) );
		/* 821639ECh case    3:*/		return 0x821639F0;
		  /* 821639F0h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 821639F0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821639F0h case    4:*/		return 0x821639F4;
		  /* 821639F4h */ case    5:  		/* stw R29, <#[R6 + 1116]> */
		/* 821639F4h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x0000045C) );
		/* 821639F4h case    5:*/		return 0x821639F8;
	}
	return 0x821639F8;
} // Block from 821639E0h-821639F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821639F8h
// Function '?Get@CShaderCost@XGRAPHICS@@QAAXPAU_XGIDEALSHADERCOST@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821639F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821639F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821639F8);
		  /* 821639F8h */ case    0:  		/* mr R9, R29 */
		/* 821639F8h case    0:*/		regs.R9 = regs.R29;
		/* 821639F8h case    0:*/		return 0x821639FC;
		  /* 821639FCh */ case    1:  		/* lwz R11, <#[R5]> */
		/* 821639FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821639FCh case    1:*/		return 0x82163A00;
		  /* 82163A00h */ case    2:  		/* rlwinm R11, R11, 12, 27, 31 */
		/* 82163A00h case    2:*/		cpu::op::rlwinm<0,12,27,31>(regs,&regs.R11,regs.R11);
		/* 82163A00h case    2:*/		return 0x82163A04;
		  /* 82163A04h */ case    3:  		/* mulli R11, R11, 24 */
		/* 82163A04h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82163A04h case    3:*/		return 0x82163A08;
		  /* 82163A08h */ case    4:  		/* add R7, R11, R6 */
		/* 82163A08h case    4:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R6);
		/* 82163A08h case    4:*/		return 0x82163A0C;
		  /* 82163A0Ch */ case    5:  		/* lwz R11, <#[R7 + 180]> */
		/* 82163A0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x000000B4) );
		/* 82163A0Ch case    5:*/		return 0x82163A10;
		  /* 82163A10h */ case    6:  		/* rlwinm R4, R11, 0, 26, 31 */
		/* 82163A10h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R4,regs.R11);
		/* 82163A10h case    6:*/		return 0x82163A14;
		  /* 82163A14h */ case    7:  		/* bc 12, CR6_EQ, 252 */
		/* 82163A14h case    7:*/		if ( regs.CR[6].eq ) { return 0x82163B10;  }
		/* 82163A14h case    7:*/		return 0x82163A18;
		  /* 82163A18h */ case    8:  		/* cmplwi CR6, R4, 63 */
		/* 82163A18h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000003F);
		/* 82163A18h case    8:*/		return 0x82163A1C;
		  /* 82163A1Ch */ case    9:  		/* bc 12, CR6_GT, 72 */
		/* 82163A1Ch case    9:*/		if ( regs.CR[6].gt ) { return 0x82163A64;  }
		/* 82163A1Ch case    9:*/		return 0x82163A20;
		  /* 82163A20h */ case   10:  		/* lis R12, -32252 */
		/* 82163A20h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82163A20h case   10:*/		return 0x82163A24;
		  /* 82163A24h */ case   11:  		/* addi R12, R12, -17768 */
		/* 82163A24h case   11:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBA98);
		/* 82163A24h case   11:*/		return 0x82163A28;
		  /* 82163A28h */ case   12:  		/* lbzx R0, <#[R12 + R4]> */
		/* 82163A28h case   12:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R4 + 0x00000000) );
		/* 82163A28h case   12:*/		return 0x82163A2C;
		  /* 82163A2Ch */ case   13:  		/* lis R12, -32234 */
		/* 82163A2Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8216);
		/* 82163A2Ch case   13:*/		return 0x82163A30;
		  /* 82163A30h */ case   14:  		/* ori R0, R0, 0 */
		/* 82163A30h case   14:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82163A30h case   14:*/		return 0x82163A34;
		  /* 82163A34h */ case   15:  		/* addi R12, R12, 14920 */
		/* 82163A34h case   15:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x3A48);
		/* 82163A34h case   15:*/		return 0x82163A38;
		  /* 82163A38h */ case   16:  		/* ori R0, R0, 0 */
		/* 82163A38h case   16:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82163A38h case   16:*/		return 0x82163A3C;
		  /* 82163A3Ch */ case   17:  		/* add R12, R12, R0 */
		/* 82163A3Ch case   17:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82163A3Ch case   17:*/		return 0x82163A40;
		  /* 82163A40h */ case   18:  		/* mtspr CTR, R12 */
		/* 82163A40h case   18:*/		regs.CTR = regs.R12;
		/* 82163A40h case   18:*/		return 0x82163A44;
		  /* 82163A44h */ case   19:  		/* bcctr 20, CR0_LT */
		/* 82163A44h case   19:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82163A44h case   19:*/		return 0x82163A48;
		  /* 82163A48h */ case   20:  		/* mr R9, R29 */
		/* 82163A48h case   20:*/		regs.R9 = regs.R29;
		/* 82163A48h case   20:*/		return 0x82163A4C;
		  /* 82163A4Ch */ case   21:  		/* b 24 */
		/* 82163A4Ch case   21:*/		return 0x82163A64;
		/* 82163A4Ch case   21:*/		return 0x82163A50;
		  /* 82163A50h */ case   22:  		/* li R9, 2 */
		/* 82163A50h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82163A50h case   22:*/		return 0x82163A54;
		  /* 82163A54h */ case   23:  		/* b 16 */
		/* 82163A54h case   23:*/		return 0x82163A64;
		/* 82163A54h case   23:*/		return 0x82163A58;
		  /* 82163A58h */ case   24:  		/* li R9, 3 */
		/* 82163A58h case   24:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 82163A58h case   24:*/		return 0x82163A5C;
		  /* 82163A5Ch */ case   25:  		/* b 8 */
		/* 82163A5Ch case   25:*/		return 0x82163A64;
		/* 82163A5Ch case   25:*/		return 0x82163A60;
		  /* 82163A60h */ case   26:  		/* li R9, 4 */
		/* 82163A60h case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82163A60h case   26:*/		return 0x82163A64;
	}
	return 0x82163A64;
} // Block from 821639F8h-82163A64h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82163A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163A64);
		  /* 82163A64h */ case    0:  		/* lwz R8, <#[R5 + 4]> */
		/* 82163A64h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000004) );
		/* 82163A64h case    0:*/		return 0x82163A68;
		  /* 82163A68h */ case    1:  		/* rlwinm R10, R8, 18, 30, 31 */
		/* 82163A68h case    1:*/		cpu::op::rlwinm<0,18,30,31>(regs,&regs.R10,regs.R8);
		/* 82163A68h case    1:*/		return 0x82163A6C;
		  /* 82163A6Ch */ case    2:  		/* cmplwi CR6, R10, 3 */
		/* 82163A6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 82163A6Ch case    2:*/		return 0x82163A70;
		  /* 82163A70h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82163A70h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82163A7C;  }
		/* 82163A70h case    3:*/		return 0x82163A74;
		  /* 82163A74h */ case    4:  		/* lwz R11, <#[R7 + 188]> */
		/* 82163A74h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x000000BC) );
		/* 82163A74h case    4:*/		return 0x82163A78;
		  /* 82163A78h */ case    5:  		/* rlwinm R10, R11, 11, 30, 31 */
		/* 82163A78h case    5:*/		cpu::op::rlwinm<0,11,30,31>(regs,&regs.R10,regs.R11);
		/* 82163A78h case    5:*/		return 0x82163A7C;
	}
	return 0x82163A7C;
} // Block from 82163A64h-82163A7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82163A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163A7C);
		  /* 82163A7Ch */ case    0:  		/* rlwinm R11, R8, 20, 30, 31 */
		/* 82163A7Ch case    0:*/		cpu::op::rlwinm<0,20,30,31>(regs,&regs.R11,regs.R8);
		/* 82163A7Ch case    0:*/		return 0x82163A80;
		  /* 82163A80h */ case    1:  		/* cmplwi CR6, R11, 3 */
		/* 82163A80h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82163A80h case    1:*/		return 0x82163A84;
		  /* 82163A84h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82163A84h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82163A90;  }
		/* 82163A84h case    2:*/		return 0x82163A88;
		  /* 82163A88h */ case    3:  		/* lwz R11, <#[R7 + 188]> */
		/* 82163A88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x000000BC) );
		/* 82163A88h case    3:*/		return 0x82163A8C;
		  /* 82163A8Ch */ case    4:  		/* rlwinm R11, R11, 11, 30, 31 */
		/* 82163A8Ch case    4:*/		cpu::op::rlwinm<0,11,30,31>(regs,&regs.R11,regs.R11);
		/* 82163A8Ch case    4:*/		return 0x82163A90;
	}
	return 0x82163A90;
} // Block from 82163A7Ch-82163A90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163A90);
		  /* 82163A90h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82163A90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82163A90h case    0:*/		return 0x82163A94;
		  /* 82163A94h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82163A94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82163AAC;  }
		/* 82163A94h case    1:*/		return 0x82163A98;
		  /* 82163A98h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82163A98h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82163A98h case    2:*/		return 0x82163A9C;
		  /* 82163A9Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82163A9Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82163AAC;  }
		/* 82163A9Ch case    3:*/		return 0x82163AA0;
		  /* 82163AA0h */ case    4:  		/* cmplwi CR6, R4, 38 */
		/* 82163AA0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000026);
		/* 82163AA0h case    4:*/		return 0x82163AA4;
		  /* 82163AA4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 82163AA4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82163AAC;  }
		/* 82163AA4h case    5:*/		return 0x82163AA8;
		  /* 82163AA8h */ case    6:  		/* li R9, 2 */
		/* 82163AA8h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 82163AA8h case    6:*/		return 0x82163AAC;
	}
	return 0x82163AAC;
} // Block from 82163A90h-82163AACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82163AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163AAC);
		  /* 82163AACh */ case    0:  		/* rlwinm R11, R8, 14, 29, 31 */
		/* 82163AACh case    0:*/		cpu::op::rlwinm<0,14,29,31>(regs,&regs.R11,regs.R8);
		/* 82163AACh case    0:*/		return 0x82163AB0;
		  /* 82163AB0h */ case    1:  		/* cmplwi CR6, R11, 7 */
		/* 82163AB0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82163AB0h case    1:*/		return 0x82163AB4;
		  /* 82163AB4h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82163AB4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82163AC0;  }
		/* 82163AB4h case    2:*/		return 0x82163AB8;
		  /* 82163AB8h */ case    3:  		/* lwz R11, <#[R7 + 188]> */
		/* 82163AB8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x000000BC) );
		/* 82163AB8h case    3:*/		return 0x82163ABC;
		  /* 82163ABCh */ case    4:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82163ABCh case    4:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82163ABCh case    4:*/		return 0x82163AC0;
	}
	return 0x82163AC0;
} // Block from 82163AACh-82163AC0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163AC0);
		  /* 82163AC0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82163AC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82163AC0h case    0:*/		return 0x82163AC4;
		  /* 82163AC4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82163AC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82163AD8;  }
		/* 82163AC4h case    1:*/		return 0x82163AC8;
		  /* 82163AC8h */ case    2:  		/* addi R11, R11, -1 */
		/* 82163AC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82163AC8h case    2:*/		return 0x82163ACC;
		  /* 82163ACCh */ case    3:  		/* slw R11, R29, R11 */
		/* 82163ACCh case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82163ACCh case    3:*/		return 0x82163AD0;
		  /* 82163AD0h */ case    4:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 82163AD0h case    4:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 82163AD0h case    4:*/		return 0x82163AD4;
		  /* 82163AD4h */ case    5:  		/* mullw R9, R11, R9 */
		/* 82163AD4h case    5:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82163AD4h case    5:*/		return 0x82163AD8;
	}
	return 0x82163AD8;
} // Block from 82163AC0h-82163AD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82163AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163AD8);
		  /* 82163AD8h */ case    0:  		/* rlwinm R11, R8, 16, 30, 31 */
		/* 82163AD8h case    0:*/		cpu::op::rlwinm<0,16,30,31>(regs,&regs.R11,regs.R8);
		/* 82163AD8h case    0:*/		return 0x82163ADC;
		  /* 82163ADCh */ case    1:  		/* cmplwi CR6, R11, 3 */
		/* 82163ADCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82163ADCh case    1:*/		return 0x82163AE0;
		  /* 82163AE0h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82163AE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82163AEC;  }
		/* 82163AE0h case    2:*/		return 0x82163AE4;
		  /* 82163AE4h */ case    3:  		/* lwz R11, <#[R7 + 188]> */
		/* 82163AE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x000000BC) );
		/* 82163AE4h case    3:*/		return 0x82163AE8;
		  /* 82163AE8h */ case    4:  		/* rlwinm R11, R11, 9, 30, 31 */
		/* 82163AE8h case    4:*/		cpu::op::rlwinm<0,9,30,31>(regs,&regs.R11,regs.R11);
		/* 82163AE8h case    4:*/		return 0x82163AEC;
	}
	return 0x82163AEC;
} // Block from 82163AD8h-82163AECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163AEC);
		  /* 82163AECh */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 82163AECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82163AECh case    0:*/		return 0x82163AF0;
		  /* 82163AF0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82163AF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82163B14;  }
		/* 82163AF0h case    1:*/		return 0x82163AF4;
		  /* 82163AF4h */ case    2:  		/* lwz R11, <#[R7 + 192]> */
		/* 82163AF4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x000000C0) );
		/* 82163AF4h case    2:*/		return 0x82163AF8;
		  /* 82163AF8h */ case    3:  		/* rlwinm R10, R11, 28, 4, 31 */
		/* 82163AF8h case    3:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R11);
		/* 82163AF8h case    3:*/		return 0x82163AFC;
		  /* 82163AFCh */ case    4:  		/* xor R11, R10, R11 */
		/* 82163AFCh case    4:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82163AFCh case    4:*/		return 0x82163B00;
		  /* 82163B00h */ case    5:  		/* rlwinm. R11, R11, 0, 26, 29 */
		/* 82163B00h case    5:*/		cpu::op::rlwinm<1,0,26,29>(regs,&regs.R11,regs.R11);
		/* 82163B00h case    5:*/		return 0x82163B04;
		  /* 82163B04h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82163B04h case    6:*/		if ( regs.CR[0].eq ) { return 0x82163B14;  }
		/* 82163B04h case    6:*/		return 0x82163B08;
		  /* 82163B08h */ case    7:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 82163B08h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 82163B08h case    7:*/		return 0x82163B0C;
		  /* 82163B0Ch */ case    8:  		/* b 8 */
		/* 82163B0Ch case    8:*/		return 0x82163B14;
		/* 82163B0Ch case    8:*/		return 0x82163B10;
	}
	return 0x82163B10;
} // Block from 82163AECh-82163B10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82163B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B10);
		  /* 82163B10h */ case    0:  		/* stw R29, <#[R6 + 1044]> */
		/* 82163B10h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000414) );
		/* 82163B10h case    0:*/		return 0x82163B14;
	}
	return 0x82163B14;
} // Block from 82163B10h-82163B14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B14);
		  /* 82163B14h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 82163B14h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82163B14h case    0:*/		return 0x82163B18;
		  /* 82163B18h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82163B18h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82163B28;  }
		/* 82163B18h case    1:*/		return 0x82163B1C;
		  /* 82163B1Ch */ case    2:  		/* lwz R11, <#[R6 + 1076]> */
		/* 82163B1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000434) );
		/* 82163B1Ch case    2:*/		return 0x82163B20;
		  /* 82163B20h */ case    3:  		/* add R11, R9, R11 */
		/* 82163B20h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82163B20h case    3:*/		return 0x82163B24;
		  /* 82163B24h */ case    4:  		/* stw R11, <#[R6 + 1076]> */
		/* 82163B24h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000434) );
		/* 82163B24h case    4:*/		return 0x82163B28;
	}
	return 0x82163B28;
} // Block from 82163B14h-82163B28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B28);
		  /* 82163B28h */ case    0:  		/* lwz R11, <#[R6 + 1072]> */
		/* 82163B28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000430) );
		/* 82163B28h case    0:*/		return 0x82163B2C;
		  /* 82163B2Ch */ case    1:  		/* add R11, R9, R11 */
		/* 82163B2Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82163B2Ch case    1:*/		return 0x82163B30;
		  /* 82163B30h */ case    2:  		/* stw R11, <#[R6 + 1072]> */
		/* 82163B30h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000430) );
		/* 82163B30h case    2:*/		return 0x82163B34;
		  /* 82163B34h */ case    3:  		/* b 368 */
		/* 82163B34h case    3:*/		return 0x82163CA4;
		/* 82163B34h case    3:*/		return 0x82163B38;
	}
	return 0x82163B38;
} // Block from 82163B28h-82163B38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B38);
		  /* 82163B38h */ case    0:  		/* rlwinm. R11, R3, 0, 29, 29 */
		/* 82163B38h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R3);
		/* 82163B38h case    0:*/		return 0x82163B3C;
		  /* 82163B3Ch */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82163B3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82163B70;  }
		/* 82163B3Ch case    1:*/		return 0x82163B40;
		  /* 82163B40h */ case    2:  		/* li R31, 0 */
		/* 82163B40h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82163B40h case    2:*/		return 0x82163B44;
		  /* 82163B44h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 24 */
		/* 82163B44h case    3:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R3);
		/* 82163B44h case    3:*/		return 0x82163B48;
		  /* 82163B48h */ case    4:  		/* stw R31, <#[R6 + 1120]> */
		/* 82163B48h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000460) );
		/* 82163B48h case    4:*/		return 0x82163B4C;
		  /* 82163B4Ch */ case    5:  		/* stw R31, <#[R6 + 1096]> */
		/* 82163B4Ch case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000448) );
		/* 82163B4Ch case    5:*/		return 0x82163B50;
		  /* 82163B50h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 82163B50h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82163B60;  }
		/* 82163B50h case    6:*/		return 0x82163B54;
		  /* 82163B54h */ case    7:  		/* lwz R11, <#[R6 + 1084]> */
		/* 82163B54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000043C) );
		/* 82163B54h case    7:*/		return 0x82163B58;
		  /* 82163B58h */ case    8:  		/* addi R11, R11, 1 */
		/* 82163B58h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163B58h case    8:*/		return 0x82163B5C;
		  /* 82163B5Ch */ case    9:  		/* stw R11, <#[R6 + 1084]> */
		/* 82163B5Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x0000043C) );
		/* 82163B5Ch case    9:*/		return 0x82163B60;
	}
	return 0x82163B60;
} // Block from 82163B38h-82163B60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82163B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B60);
		  /* 82163B60h */ case    0:  		/* lwz R11, <#[R6 + 1080]> */
		/* 82163B60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000438) );
		/* 82163B60h case    0:*/		return 0x82163B64;
		  /* 82163B64h */ case    1:  		/* addi R11, R11, 1 */
		/* 82163B64h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163B64h case    1:*/		return 0x82163B68;
		  /* 82163B68h */ case    2:  		/* stw R11, <#[R6 + 1080]> */
		/* 82163B68h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000438) );
		/* 82163B68h case    2:*/		return 0x82163B6C;
		  /* 82163B6Ch */ case    3:  		/* b 312 */
		/* 82163B6Ch case    3:*/		return 0x82163CA4;
		/* 82163B6Ch case    3:*/		return 0x82163B70;
	}
	return 0x82163B70;
} // Block from 82163B60h-82163B70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B70);
		  /* 82163B70h */ case    0:  		/* rlwinm. R11, R3, 0, 31, 31 */
		/* 82163B70h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R3);
		/* 82163B70h case    0:*/		return 0x82163B74;
		  /* 82163B74h */ case    1:  		/* bc 12, CR0_EQ, 304 */
		/* 82163B74h case    1:*/		if ( regs.CR[0].eq ) { return 0x82163CA4;  }
		/* 82163B74h case    1:*/		return 0x82163B78;
		  /* 82163B78h */ case    2:  		/* lwz R11, <#[R5 + 4]> */
		/* 82163B78h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82163B78h case    2:*/		return 0x82163B7C;
		  /* 82163B7Ch */ case    3:  		/* rlwinm R11, R11, 0, 16, 19 */
		/* 82163B7Ch case    3:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R11,regs.R11);
		/* 82163B7Ch case    3:*/		return 0x82163B80;
		  /* 82163B80h */ case    4:  		/* cmplwi CR6, R11, 49152 */
		/* 82163B80h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000C000);
		/* 82163B80h case    4:*/		return 0x82163B84;
		  /* 82163B84h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82163B84h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82163B90;  }
		/* 82163B84h case    5:*/		return 0x82163B88;
		  /* 82163B88h */ case    6:  		/* li R11, 0 */
		/* 82163B88h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82163B88h case    6:*/		return 0x82163B8C;
		  /* 82163B8Ch */ case    7:  		/* stw R11, <#[R6 + 1096]> */
		/* 82163B8Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000448) );
		/* 82163B8Ch case    7:*/		return 0x82163B90;
	}
	return 0x82163B90;
} // Block from 82163B70h-82163B90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82163B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163B90);
		  /* 82163B90h */ case    0:  		/* lwz R11, <#[R6 + 1096]> */
		/* 82163B90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000448) );
		/* 82163B90h case    0:*/		return 0x82163B94;
		  /* 82163B94h */ case    1:  		/* li R29, 1 */
		/* 82163B94h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82163B94h case    1:*/		return 0x82163B98;
		  /* 82163B98h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82163B98h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82163B98h case    2:*/		return 0x82163B9C;
		  /* 82163B9Ch */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 82163B9Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82163BBC;  }
		/* 82163B9Ch case    3:*/		return 0x82163BA0;
		  /* 82163BA0h */ case    4:  		/* lwz R10, <#[R6 + 1132]> */
		/* 82163BA0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000046C) );
		/* 82163BA0h case    4:*/		return 0x82163BA4;
		  /* 82163BA4h */ case    5:  		/* lwz R11, <#[R6 + 1136]> */
		/* 82163BA4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000470) );
		/* 82163BA4h case    5:*/		return 0x82163BA8;
		  /* 82163BA8h */ case    6:  		/* addi R10, R10, 1 */
		/* 82163BA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82163BA8h case    6:*/		return 0x82163BAC;
		  /* 82163BACh */ case    7:  		/* addi R11, R11, 1 */
		/* 82163BACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163BACh case    7:*/		return 0x82163BB0;
		  /* 82163BB0h */ case    8:  		/* stw R10, <#[R6 + 1132]> */
		/* 82163BB0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x0000046C) );
		/* 82163BB0h case    8:*/		return 0x82163BB4;
		  /* 82163BB4h */ case    9:  		/* stw R11, <#[R6 + 1136]> */
		/* 82163BB4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000470) );
		/* 82163BB4h case    9:*/		return 0x82163BB8;
		  /* 82163BB8h */ case   10:  		/* b 16 */
		/* 82163BB8h case   10:*/		return 0x82163BC8;
		/* 82163BB8h case   10:*/		return 0x82163BBC;
	}
	return 0x82163BBC;
} // Block from 82163B90h-82163BBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82163BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163BBC);
		  /* 82163BBCh */ case    0:  		/* cmplwi CR6, R11, 2 */
		/* 82163BBCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82163BBCh case    0:*/		return 0x82163BC0;
		  /* 82163BC0h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82163BC0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82163BC8;  }
		/* 82163BC0h case    1:*/		return 0x82163BC4;
		  /* 82163BC4h */ case    2:  		/* stw R29, <#[R6 + 1120]> */
		/* 82163BC4h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000460) );
		/* 82163BC4h case    2:*/		return 0x82163BC8;
	}
	return 0x82163BC8;
} // Block from 82163BBCh-82163BC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82163BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163BC8);
		  /* 82163BC8h */ case    0:  		/* lwz R11, <#[R5 + 4]> */
		/* 82163BC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82163BC8h case    0:*/		return 0x82163BCC;
		  /* 82163BCCh */ case    1:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82163BCCh case    1:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82163BCCh case    1:*/		return 0x82163BD0;
		  /* 82163BD0h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 82163BD0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82163BD0h case    2:*/		return 0x82163BD4;
		  /* 82163BD4h */ case    3:  		/* bc 12, CR6_EQ, 240 */
		/* 82163BD4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82163CC4;  }
		/* 82163BD4h case    3:*/		return 0x82163BD8;
		  /* 82163BD8h */ case    4:  		/* cmplwi CR6, R11, 4 */
		/* 82163BD8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82163BD8h case    4:*/		return 0x82163BDC;
		  /* 82163BDCh */ case    5:  		/* bc 12, CR6_EQ, 232 */
		/* 82163BDCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82163CC4;  }
		/* 82163BDCh case    5:*/		return 0x82163BE0;
		  /* 82163BE0h */ case    6:  		/* cmplwi CR6, R11, 9 */
		/* 82163BE0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000009);
		/* 82163BE0h case    6:*/		return 0x82163BE4;
		  /* 82163BE4h */ case    7:  		/* bc 12, CR6_EQ, 240 */
		/* 82163BE4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82163CD4;  }
		/* 82163BE4h case    7:*/		return 0x82163BE8;
		  /* 82163BE8h */ case    8:  		/* cmplwi CR6, R11, 11 */
		/* 82163BE8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 82163BE8h case    8:*/		return 0x82163BEC;
		  /* 82163BECh */ case    9:  		/* bc 12, CR6_EQ, 216 */
		/* 82163BECh case    9:*/		if ( regs.CR[6].eq ) { return 0x82163CC4;  }
		/* 82163BECh case    9:*/		return 0x82163BF0;
		  /* 82163BF0h */ case   10:  		/* cmplwi CR6, R11, 13 */
		/* 82163BF0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 82163BF0h case   10:*/		return 0x82163BF4;
		  /* 82163BF4h */ case   11:  		/* bc 12, CR6_EQ, 208 */
		/* 82163BF4h case   11:*/		if ( regs.CR[6].eq ) { return 0x82163CC4;  }
		/* 82163BF4h case   11:*/		return 0x82163BF8;
		  /* 82163BF8h */ case   12:  		/* cmplwi CR6, R11, 14 */
		/* 82163BF8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000E);
		/* 82163BF8h case   12:*/		return 0x82163BFC;
		  /* 82163BFCh */ case   13:  		/* bc 12, CR6_EQ, 200 */
		/* 82163BFCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82163CC4;  }
		/* 82163BFCh case   13:*/		return 0x82163C00;
		  /* 82163C00h */ case   14:  		/* cmplwi CR6, R11, 7 */
		/* 82163C00h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82163C00h case   14:*/		return 0x82163C04;
		  /* 82163C04h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82163C04h case   15:*/		if ( regs.CR[6].eq ) { return 0x82163C10;  }
		/* 82163C04h case   15:*/		return 0x82163C08;
		  /* 82163C08h */ case   16:  		/* cmplwi CR6, R11, 8 */
		/* 82163C08h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 82163C08h case   16:*/		return 0x82163C0C;
		  /* 82163C0Ch */ case   17:  		/* bc 4, CR6_EQ, 60 */
		/* 82163C0Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x82163C48;  }
		/* 82163C0Ch case   17:*/		return 0x82163C10;
	}
	return 0x82163C10;
} // Block from 82163BC8h-82163C10h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82163C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163C10);
		  /* 82163C10h */ case    0:  		/* lhz R11, <#[R5]> */
		/* 82163C10h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82163C10h case    0:*/		return 0x82163C14;
		  /* 82163C14h */ case    1:  		/* lwz R10, <#[R6 + 976]> */
		/* 82163C14h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x000003D0) );
		/* 82163C14h case    1:*/		return 0x82163C18;
		  /* 82163C18h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82163C18h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82163C18h case    2:*/		return 0x82163C1C;
		  /* 82163C1Ch */ case    3:  		/* slw R11, R29, R11 */
		/* 82163C1Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82163C1Ch case    3:*/		return 0x82163C20;
		  /* 82163C20h */ case    4:  		/* and. R11, R11, R10 */
		/* 82163C20h case    4:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82163C20h case    4:*/		return 0x82163C24;
		  /* 82163C24h */ case    5:  		/* bc 4, CR0_EQ, 8 */
		/* 82163C24h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82163C2C;  }
		/* 82163C24h case    5:*/		return 0x82163C28;
		  /* 82163C28h */ case    6:  		/* stw R29, <#[R6 + 1028]> */
		/* 82163C28h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000404) );
		/* 82163C28h case    6:*/		return 0x82163C2C;
	}
	return 0x82163C2C;
} // Block from 82163C10h-82163C2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82163C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163C2C);
		  /* 82163C2Ch */ case    0:  		/* lhz R11, <#[R5]> */
		/* 82163C2Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82163C2Ch case    0:*/		return 0x82163C30;
		  /* 82163C30h */ case    1:  		/* lwz R10, <#[R6 + 1016]> */
		/* 82163C30h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x000003F8) );
		/* 82163C30h case    1:*/		return 0x82163C34;
		  /* 82163C34h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82163C34h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82163C34h case    2:*/		return 0x82163C38;
		  /* 82163C38h */ case    3:  		/* slw R11, R29, R11 */
		/* 82163C38h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82163C38h case    3:*/		return 0x82163C3C;
		  /* 82163C3Ch */ case    4:  		/* and. R11, R11, R10 */
		/* 82163C3Ch case    4:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82163C3Ch case    4:*/		return 0x82163C40;
		  /* 82163C40h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82163C40h case    5:*/		if ( regs.CR[0].eq ) { return 0x82163C48;  }
		/* 82163C40h case    5:*/		return 0x82163C44;
		  /* 82163C44h */ case    6:  		/* stw R29, <#[R6 + 1032]> */
		/* 82163C44h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000408) );
		/* 82163C44h case    6:*/		return 0x82163C48;
	}
	return 0x82163C48;
} // Block from 82163C2Ch-82163C48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82163C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163C48);
		  /* 82163C48h */ case    0:  		/* lwz R11, <#[R6 + 1088]> */
		/* 82163C48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000440) );
		/* 82163C48h case    0:*/		return 0x82163C4C;
		  /* 82163C4Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 82163C4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163C4Ch case    1:*/		return 0x82163C50;
		  /* 82163C50h */ case    2:  		/* stw R11, <#[R6 + 1088]> */
		/* 82163C50h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000440) );
		/* 82163C50h case    2:*/		return 0x82163C54;
		  /* 82163C54h */ case    3:  		/* lwz R11, <#[R5 + 4]> */
		/* 82163C54h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82163C54h case    3:*/		return 0x82163C58;
		  /* 82163C58h */ case    4:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82163C58h case    4:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82163C58h case    4:*/		return 0x82163C5C;
		  /* 82163C5Ch */ case    5:  		/* cmplwi CR6, R11, 9 */
		/* 82163C5Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000009);
		/* 82163C5Ch case    5:*/		return 0x82163C60;
		  /* 82163C60h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82163C60h case    6:*/		if ( regs.CR[6].eq ) { return 0x82163C6C;  }
		/* 82163C60h case    6:*/		return 0x82163C64;
		  /* 82163C64h */ case    7:  		/* cmplwi CR6, R11, 11 */
		/* 82163C64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 82163C64h case    7:*/		return 0x82163C68;
		  /* 82163C68h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 82163C68h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82163C84;  }
		/* 82163C68h case    8:*/		return 0x82163C6C;
	}
	return 0x82163C6C;
} // Block from 82163C48h-82163C6Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82163C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163C6C);
		  /* 82163C6Ch */ case    0:  		/* lwz R11, <#[R5]> */
		/* 82163C6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82163C6Ch case    0:*/		return 0x82163C70;
		  /* 82163C70h */ case    1:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 82163C70h case    1:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 82163C70h case    1:*/		return 0x82163C74;
		  /* 82163C74h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 82163C74h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82163C84;  }
		/* 82163C74h case    2:*/		return 0x82163C78;
		  /* 82163C78h */ case    3:  		/* rlwinm. R11, R11, 0, 17, 17 */
		/* 82163C78h case    3:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R11,regs.R11);
		/* 82163C78h case    3:*/		return 0x82163C7C;
		  /* 82163C7Ch */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82163C7Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82163C84;  }
		/* 82163C7Ch case    4:*/		return 0x82163C80;
		  /* 82163C80h */ case    5:  		/* stw R29, <#[R6 + 1036]> */
		/* 82163C80h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x0000040C) );
		/* 82163C80h case    5:*/		return 0x82163C84;
	}
	return 0x82163C84;
} // Block from 82163C6Ch-82163C84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82163C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163C84);
		  /* 82163C84h */ case    0:  		/* lwz R11, <#[R5 + 4]> */
		/* 82163C84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82163C84h case    0:*/		return 0x82163C88;
		  /* 82163C88h */ case    1:  		/* rlwinm R11, R11, 0, 16, 19 */
		/* 82163C88h case    1:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R11,regs.R11);
		/* 82163C88h case    1:*/		return 0x82163C8C;
		  /* 82163C8Ch */ case    2:  		/* cmplwi CR6, R11, 32768 */
		/* 82163C8Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 82163C8Ch case    2:*/		return 0x82163C90;
		  /* 82163C90h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 82163C90h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82163CA4;  }
		/* 82163C90h case    3:*/		return 0x82163C94;
		  /* 82163C94h */ case    4:  		/* lwz R11, <#[R5]> */
		/* 82163C94h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82163C94h case    4:*/		return 0x82163C98;
		  /* 82163C98h */ case    5:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 82163C98h case    5:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 82163C98h case    5:*/		return 0x82163C9C;
		  /* 82163C9Ch */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 82163C9Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82163CA4;  }
		/* 82163C9Ch case    6:*/		return 0x82163CA0;
		  /* 82163CA0h */ case    7:  		/* stw R29, <#[R6 + 1040]> */
		/* 82163CA0h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000410) );
		/* 82163CA0h case    7:*/		return 0x82163CA4;
	}
	return 0x82163CA4;
} // Block from 82163C84h-82163CA4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82163CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163CA4);
		  /* 82163CA4h */ case    0:  		/* lis R11, 1 */
		/* 82163CA4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82163CA4h case    0:*/		return 0x82163CA8;
		  /* 82163CA8h */ case    1:  		/* lwz R10, <#[R6 + 1088]> */
		/* 82163CA8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000440) );
		/* 82163CA8h case    1:*/		return 0x82163CAC;
		  /* 82163CACh */ case    2:  		/* li R9, -1000 */
		/* 82163CACh case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFC18);
		/* 82163CACh case    2:*/		return 0x82163CB0;
		  /* 82163CB0h */ case    3:  		/* ori R11, R11, 34464 */
		/* 82163CB0h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x86A0);
		/* 82163CB0h case    3:*/		return 0x82163CB4;
		  /* 82163CB4h */ case    4:  		/* subfc R11, R10, R11 */
		/* 82163CB4h case    4:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82163CB4h case    4:*/		return 0x82163CB8;
		  /* 82163CB8h */ case    5:  		/* subfe R11, R11, R11 */
		/* 82163CB8h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82163CB8h case    5:*/		return 0x82163CBC;
		  /* 82163CBCh */ case    6:  		/* and R3, R11, R9 */
		/* 82163CBCh case    6:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 82163CBCh case    6:*/		return 0x82163CC0;
		  /* 82163CC0h */ case    7:  		/* b -862740 */
		/* 82163CC0h case    7:*/		return 0x820912AC;
		/* 82163CC0h case    7:*/		return 0x82163CC4;
	}
	return 0x82163CC4;
} // Block from 82163CA4h-82163CC4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82163CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163CC4);
		  /* 82163CC4h */ case    0:  		/* cmplwi CR6, R11, 9 */
		/* 82163CC4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000009);
		/* 82163CC4h case    0:*/		return 0x82163CC8;
		  /* 82163CC8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82163CC8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82163CD4;  }
		/* 82163CC8h case    1:*/		return 0x82163CCC;
		  /* 82163CCCh */ case    2:  		/* cmplwi CR6, R11, 11 */
		/* 82163CCCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 82163CCCh case    2:*/		return 0x82163CD0;
		  /* 82163CD0h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82163CD0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82163CE8;  }
		/* 82163CD0h case    3:*/		return 0x82163CD4;
	}
	return 0x82163CD4;
} // Block from 82163CC4h-82163CD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163CD4);
		  /* 82163CD4h */ case    0:  		/* lwz R11, <#[R5]> */
		/* 82163CD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82163CD4h case    0:*/		return 0x82163CD8;
		  /* 82163CD8h */ case    1:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 82163CD8h case    1:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 82163CD8h case    1:*/		return 0x82163CDC;
		  /* 82163CDCh */ case    2:  		/* bc 4, CR0_EQ, -148 */
		/* 82163CDCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82163C48;  }
		/* 82163CDCh case    2:*/		return 0x82163CE0;
		  /* 82163CE0h */ case    3:  		/* rlwinm. R11, R11, 0, 17, 17 */
		/* 82163CE0h case    3:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R11,regs.R11);
		/* 82163CE0h case    3:*/		return 0x82163CE4;
		  /* 82163CE4h */ case    4:  		/* bc 4, CR0_EQ, -156 */
		/* 82163CE4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82163C48;  }
		/* 82163CE4h case    4:*/		return 0x82163CE8;
	}
	return 0x82163CE8;
} // Block from 82163CD4h-82163CE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82163CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163CE8);
		  /* 82163CE8h */ case    0:  		/* lwz R10, <#[R5 + 4]> */
		/* 82163CE8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 82163CE8h case    0:*/		return 0x82163CEC;
		  /* 82163CECh */ case    1:  		/* rlwinm R11, R10, 25, 29, 31 */
		/* 82163CECh case    1:*/		cpu::op::rlwinm<0,25,29,31>(regs,&regs.R11,regs.R10);
		/* 82163CECh case    1:*/		return 0x82163CF0;
		  /* 82163CF0h */ case    2:  		/* rlwinm R10, R10, 30, 27, 31 */
		/* 82163CF0h case    2:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R10,regs.R10);
		/* 82163CF0h case    2:*/		return 0x82163CF4;
		  /* 82163CF4h */ case    3:  		/* addi R11, R11, 236 */
		/* 82163CF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xEC);
		/* 82163CF4h case    3:*/		return 0x82163CF8;
		  /* 82163CF8h */ case    4:  		/* slw R10, R29, R10 */
		/* 82163CF8h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 82163CF8h case    4:*/		return 0x82163CFC;
		  /* 82163CFCh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82163CFCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82163CFCh case    5:*/		return 0x82163D00;
		  /* 82163D00h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82163D00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82163D00h case    6:*/		return 0x82163D04;
		  /* 82163D04h */ case    7:  		/* and. R11, R10, R11 */
		/* 82163D04h case    7:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82163D04h case    7:*/		return 0x82163D08;
		  /* 82163D08h */ case    8:  		/* bc 4, CR0_EQ, 8 */
		/* 82163D08h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82163D10;  }
		/* 82163D08h case    8:*/		return 0x82163D0C;
		  /* 82163D0Ch */ case    9:  		/* stw R29, <#[R6 + 1028]> */
		/* 82163D0Ch case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000404) );
		/* 82163D0Ch case    9:*/		return 0x82163D10;
	}
	return 0x82163D10;
} // Block from 82163CE8h-82163D10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82163D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163D10);
		  /* 82163D10h */ case    0:  		/* lwz R10, <#[R5 + 4]> */
		/* 82163D10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 82163D10h case    0:*/		return 0x82163D14;
		  /* 82163D14h */ case    1:  		/* rlwinm R11, R10, 25, 29, 31 */
		/* 82163D14h case    1:*/		cpu::op::rlwinm<0,25,29,31>(regs,&regs.R11,regs.R10);
		/* 82163D14h case    1:*/		return 0x82163D18;
		  /* 82163D18h */ case    2:  		/* rlwinm R10, R10, 30, 27, 31 */
		/* 82163D18h case    2:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R10,regs.R10);
		/* 82163D18h case    2:*/		return 0x82163D1C;
		  /* 82163D1Ch */ case    3:  		/* addi R11, R11, 246 */
		/* 82163D1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xF6);
		/* 82163D1Ch case    3:*/		return 0x82163D20;
		  /* 82163D20h */ case    4:  		/* slw R10, R29, R10 */
		/* 82163D20h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 82163D20h case    4:*/		return 0x82163D24;
		  /* 82163D24h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82163D24h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82163D24h case    5:*/		return 0x82163D28;
		  /* 82163D28h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82163D28h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82163D28h case    6:*/		return 0x82163D2C;
		  /* 82163D2Ch */ case    7:  		/* and. R11, R10, R11 */
		/* 82163D2Ch case    7:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82163D2Ch case    7:*/		return 0x82163D30;
		  /* 82163D30h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82163D30h case    8:*/		if ( regs.CR[0].eq ) { return 0x82163D38;  }
		/* 82163D30h case    8:*/		return 0x82163D34;
		  /* 82163D34h */ case    9:  		/* stw R29, <#[R6 + 1032]> */
		/* 82163D34h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000408) );
		/* 82163D34h case    9:*/		return 0x82163D38;
	}
	return 0x82163D38;
} // Block from 82163D10h-82163D38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82163D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163D38);
		  /* 82163D38h */ case    0:  		/* lwz R11, <#[R6 + 1088]> */
		/* 82163D38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000440) );
		/* 82163D38h case    0:*/		return 0x82163D3C;
		  /* 82163D3Ch */ case    1:  		/* addi R11, R11, 2 */
		/* 82163D3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82163D3Ch case    1:*/		return 0x82163D40;
		  /* 82163D40h */ case    2:  		/* b -240 */
		/* 82163D40h case    2:*/		return 0x82163C50;
		/* 82163D40h case    2:*/		return 0x82163D44;
		  /* 82163D44h */ case    3:  		/* nop */
		/* 82163D44h case    3:*/		cpu::op::nop();
		/* 82163D44h case    3:*/		return 0x82163D48;
	}
	return 0x82163D48;
} // Block from 82163D38h-82163D48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163D48);
		  /* 82163D48h */ case    0:  		/* mfspr R12, LR */
		/* 82163D48h case    0:*/		regs.R12 = regs.LR;
		/* 82163D48h case    0:*/		return 0x82163D4C;
		  /* 82163D4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82163D4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82163D4Ch case    1:*/		return 0x82163D50;
		  /* 82163D50h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82163D50h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82163D50h case    2:*/		return 0x82163D54;
		  /* 82163D54h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82163D54h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82163D54h case    3:*/		return 0x82163D58;
		  /* 82163D58h */ case    4:  		/* mr R31, R3 */
		/* 82163D58h case    4:*/		regs.R31 = regs.R3;
		/* 82163D58h case    4:*/		return 0x82163D5C;
		  /* 82163D5Ch */ case    5:  		/* lwz R4, <#[R3 + 12]> */
		/* 82163D5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x0000000C) );
		/* 82163D5Ch case    5:*/		return 0x82163D60;
		  /* 82163D60h */ case    6:  		/* lis R11, -32234 */
		/* 82163D60h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8216);
		/* 82163D60h case    6:*/		return 0x82163D64;
		  /* 82163D64h */ case    7:  		/* lwz R3, <#[R3 + 8]> */
		/* 82163D64h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 82163D64h case    7:*/		return 0x82163D68;
		  /* 82163D68h */ case    8:  		/* li R9, 15 */
		/* 82163D68h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 82163D68h case    8:*/		return 0x82163D6C;
		  /* 82163D6Ch */ case    9:  		/* stw R31, <#[R1 + 84]> */
		/* 82163D6Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 82163D6Ch case    9:*/		return 0x82163D70;
		  /* 82163D70h */ case   10:  		/* addi R10, R11, 14104 */
		/* 82163D70h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3718);
		/* 82163D70h case   10:*/		return 0x82163D74;
		  /* 82163D74h */ case   11:  		/* addi R8, R31, 48 */
		/* 82163D74h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x30);
		/* 82163D74h case   11:*/		return 0x82163D78;
		  /* 82163D78h */ case   12:  		/* addi R7, R31, 16 */
		/* 82163D78h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x10);
		/* 82163D78h case   12:*/		return 0x82163D7C;
		  /* 82163D7Ch */ case   13:  		/* li R6, 0 */
		/* 82163D7Ch case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82163D7Ch case   13:*/		return 0x82163D80;
		  /* 82163D80h */ case   14:  		/* li R5, 0 */
		/* 82163D80h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82163D80h case   14:*/		return 0x82163D84;
		  /* 82163D84h */ case   15:  		/* bl -1030412 */
		/* 82163D84h case   15:*/		regs.LR = 0x82163D88; return 0x82068478;
		/* 82163D84h case   15:*/		return 0x82163D88;
		  /* 82163D88h */ case   16:  		/* li R11, -1000 */
		/* 82163D88h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFC18);
		/* 82163D88h case   16:*/		return 0x82163D8C;
		  /* 82163D8Ch */ case   17:  		/* subf R11, R3, R11 */
		/* 82163D8Ch case   17:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82163D8Ch case   17:*/		return 0x82163D90;
		  /* 82163D90h */ case   18:  		/* cntlzw R11, R11 */
		/* 82163D90h case   18:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82163D90h case   18:*/		return 0x82163D94;
		  /* 82163D94h */ case   19:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82163D94h case   19:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82163D94h case   19:*/		return 0x82163D98;
		  /* 82163D98h */ case   20:  		/* stw R11, <#[R31 + 1092]> */
		/* 82163D98h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000444) );
		/* 82163D98h case   20:*/		return 0x82163D9C;
		  /* 82163D9Ch */ case   21:  		/* addi R1, R1, 112 */
		/* 82163D9Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82163D9Ch case   21:*/		return 0x82163DA0;
		  /* 82163DA0h */ case   22:  		/* lwz R12, <#[R1 - 8]> */
		/* 82163DA0h case   22:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82163DA0h case   22:*/		return 0x82163DA4;
		  /* 82163DA4h */ case   23:  		/* mtspr LR, R12 */
		/* 82163DA4h case   23:*/		regs.LR = regs.R12;
		/* 82163DA4h case   23:*/		return 0x82163DA8;
		  /* 82163DA8h */ case   24:  		/* ld R31, <#[R1 - 16]> */
		/* 82163DA8h case   24:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82163DA8h case   24:*/		return 0x82163DAC;
		  /* 82163DACh */ case   25:  		/* bclr 20, CR0_LT */
		/* 82163DACh case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82163DACh case   25:*/		return 0x82163DB0;
	}
	return 0x82163DB0;
} // Block from 82163D48h-82163DB0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82163DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163DB0);
		  /* 82163DB0h */ case    0:  		/* mfspr R12, LR */
		/* 82163DB0h case    0:*/		regs.R12 = regs.LR;
		/* 82163DB0h case    0:*/		return 0x82163DB4;
		  /* 82163DB4h */ case    1:  		/* bl -863124 */
		/* 82163DB4h case    1:*/		regs.LR = 0x82163DB8; return 0x82091220;
		/* 82163DB4h case    1:*/		return 0x82163DB8;
		  /* 82163DB8h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 82163DB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 82163DB8h case    2:*/		return 0x82163DBC;
		  /* 82163DBCh */ case    3:  		/* mr R16, R4 */
		/* 82163DBCh case    3:*/		regs.R16 = regs.R4;
		/* 82163DBCh case    3:*/		return 0x82163DC0;
		  /* 82163DC0h */ case    4:  		/* stw R5, <#[R1 + 308]> */
		/* 82163DC0h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000134) );
		/* 82163DC0h case    4:*/		return 0x82163DC4;
		  /* 82163DC4h */ case    5:  		/* addi R4, R1, 96 */
		/* 82163DC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82163DC4h case    5:*/		return 0x82163DC8;
		  /* 82163DC8h */ case    6:  		/* mr R28, R5 */
		/* 82163DC8h case    6:*/		regs.R28 = regs.R5;
		/* 82163DC8h case    6:*/		return 0x82163DCC;
		  /* 82163DCCh */ case    7:  		/* mr R15, R6 */
		/* 82163DCCh case    7:*/		regs.R15 = regs.R6;
		/* 82163DCCh case    7:*/		return 0x82163DD0;
		  /* 82163DD0h */ case    8:  		/* bl -1028216 */
		/* 82163DD0h case    8:*/		regs.LR = 0x82163DD4; return 0x82068D58;
		/* 82163DD0h case    8:*/		return 0x82163DD4;
		  /* 82163DD4h */ case    9:  		/* lwz R11, <#[R1 + 96]> */
		/* 82163DD4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82163DD4h case    9:*/		return 0x82163DD8;
		  /* 82163DD8h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82163DD8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82163DD8h case   10:*/		return 0x82163DDC;
		  /* 82163DDCh */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82163DDCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82163DFC;  }
		/* 82163DDCh case   11:*/		return 0x82163DE0;
		  /* 82163DE0h */ case   12:  		/* lwz R10, <#[R11 + 16]> */
		/* 82163DE0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82163DE0h case   12:*/		return 0x82163DE4;
		  /* 82163DE4h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 82163DE4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82163DE4h case   13:*/		return 0x82163DE8;
		  /* 82163DE8h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82163DE8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82163DFC;  }
		/* 82163DE8h case   14:*/		return 0x82163DEC;
		  /* 82163DECh */ case   15:  		/* add. R10, R10, R11 */
		/* 82163DECh case   15:*/		cpu::op::add<1>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82163DECh case   15:*/		return 0x82163DF0;
		  /* 82163DF0h */ case   16:  		/* bc 12, CR0_EQ, 12 */
		/* 82163DF0h case   16:*/		if ( regs.CR[0].eq ) { return 0x82163DFC;  }
		/* 82163DF0h case   16:*/		return 0x82163DF4;
		  /* 82163DF4h */ case   17:  		/* addic. R22, R10, 4 */
		/* 82163DF4h case   17:*/		cpu::op::addic<1>(regs,&regs.R22,regs.R10,0x4);
		/* 82163DF4h case   17:*/		return 0x82163DF8;
		  /* 82163DF8h */ case   18:  		/* bc 4, CR0_EQ, 12 */
		/* 82163DF8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x82163E04;  }
		/* 82163DF8h case   18:*/		return 0x82163DFC;
	}
	return 0x82163DFC;
} // Block from 82163DB0h-82163DFCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82163DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163DFC);
		  /* 82163DFCh */ case    0:  		/* li R3, 1 */
		/* 82163DFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82163DFCh case    0:*/		return 0x82163E00;
		  /* 82163E00h */ case    1:  		/* b 368 */
		/* 82163E00h case    1:*/		return 0x82163F70;
		/* 82163E00h case    1:*/		return 0x82163E04;
	}
	return 0x82163E04;
} // Block from 82163DFCh-82163E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163E04);
		  /* 82163E04h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82163E04h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82163E04h case    0:*/		return 0x82163E08;
		  /* 82163E08h */ case    1:  		/* li R21, 0 */
		/* 82163E08h case    1:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82163E08h case    1:*/		return 0x82163E0C;
		  /* 82163E0Ch */ case    2:  		/* lwz R11, <#[R22 + 16]> */
		/* 82163E0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000010) );
		/* 82163E0Ch case    2:*/		return 0x82163E10;
		  /* 82163E10h */ case    3:  		/* lwz R18, <#[R22 + 12]> */
		/* 82163E10h case    3:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R22 + 0x0000000C) );
		/* 82163E10h case    3:*/		return 0x82163E14;
		  /* 82163E14h */ case    4:  		/* mr R17, R21 */
		/* 82163E14h case    4:*/		regs.R17 = regs.R21;
		/* 82163E14h case    4:*/		return 0x82163E18;
		  /* 82163E18h */ case    5:  		/* rlwinm R19, R10, 0, 31, 31 */
		/* 82163E18h case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R19,regs.R10);
		/* 82163E18h case    5:*/		return 0x82163E1C;
		  /* 82163E1Ch */ case    6:  		/* add R30, R11, R22 */
		/* 82163E1Ch case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R22);
		/* 82163E1Ch case    6:*/		return 0x82163E20;
		  /* 82163E20h */ case    7:  		/* cmplwi CR6, R18, 0 */
		/* 82163E20h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82163E20h case    7:*/		return 0x82163E24;
		  /* 82163E24h */ case    8:  		/* bc 12, CR6_EQ, 328 */
		/* 82163E24h case    8:*/		if ( regs.CR[6].eq ) { return 0x82163F6C;  }
		/* 82163E24h case    8:*/		return 0x82163E28;
		  /* 82163E28h */ case    9:  		/* rlwinm R14, R28, 0, 31, 31 */
		/* 82163E28h case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R14,regs.R28);
		/* 82163E28h case    9:*/		return 0x82163E2C;
		  /* 82163E2Ch */ case   10:  		/* lwz R10, <#[R30]> */
		/* 82163E2Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82163E2Ch case   10:*/		return 0x82163E30;
		  /* 82163E30h */ case   11:  		/* cmpwi CR6, R19, 0 */
		/* 82163E30h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 82163E30h case   11:*/		return 0x82163E34;
		  /* 82163E34h */ case   12:  		/* lhz R29, <#[R30 + 4]> */
		/* 82163E34h case   12:*/		cpu::mem::load16z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000004) );
		/* 82163E34h case   12:*/		return 0x82163E38;
		  /* 82163E38h */ case   13:  		/* lhz R9, <#[R30 + 6]> */
		/* 82163E38h case   13:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000006) );
		/* 82163E38h case   13:*/		return 0x82163E3C;
		  /* 82163E3Ch */ case   14:  		/* add R20, R10, R22 */
		/* 82163E3Ch case   14:*/		cpu::op::add<0>(regs,&regs.R20,regs.R10,regs.R22);
		/* 82163E3Ch case   14:*/		return 0x82163E40;
		  /* 82163E40h */ case   15:  		/* lhz R11, <#[R30 + 8]> */
		/* 82163E40h case   15:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82163E40h case   15:*/		return 0x82163E44;
		  /* 82163E44h */ case   16:  		/* bc 4, CR6_EQ, 44 */
		/* 82163E44h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82163E70;  }
		/* 82163E44h case   16:*/		return 0x82163E48;
		  /* 82163E48h */ case   17:  		/* rlwinm. R10, R28, 0, 27, 27 */
		/* 82163E48h case   17:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R28);
		/* 82163E48h case   17:*/		return 0x82163E4C;
		  /* 82163E4Ch */ case   18:  		/* bc 12, CR0_EQ, 36 */
		/* 82163E4Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x82163E70;  }
		/* 82163E4Ch case   18:*/		return 0x82163E50;
		  /* 82163E50h */ case   19:  		/* cmpwi CR6, R29, 0 */
		/* 82163E50h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82163E50h case   19:*/		return 0x82163E54;
		  /* 82163E54h */ case   20:  		/* bc 4, CR6_EQ, 12 */
		/* 82163E54h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82163E60;  }
		/* 82163E54h case   20:*/		return 0x82163E58;
		  /* 82163E58h */ case   21:  		/* rlwinm R10, R9, 0, 16, 31 */
		/* 82163E58h case   21:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R9);
		/* 82163E58h case   21:*/		return 0x82163E5C;
		  /* 82163E5Ch */ case   22:  		/* xori R9, R10, 128 */
		/* 82163E5Ch case   22:*/		cpu::op::xori<0>(regs,&regs.R9,regs.R10,0x80);
		/* 82163E5Ch case   22:*/		return 0x82163E60;
	}
	return 0x82163E60;
} // Block from 82163E04h-82163E60h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82163E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163E60);
		  /* 82163E60h */ case    0:  		/* cmpwi CR6, R29, 1 */
		/* 82163E60h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000001);
		/* 82163E60h case    0:*/		return 0x82163E64;
		  /* 82163E64h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82163E64h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82163E70;  }
		/* 82163E64h case    1:*/		return 0x82163E68;
		  /* 82163E68h */ case    2:  		/* rlwinm R10, R9, 0, 16, 31 */
		/* 82163E68h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R9);
		/* 82163E68h case    2:*/		return 0x82163E6C;
		  /* 82163E6Ch */ case    3:  		/* xori R9, R10, 16 */
		/* 82163E6Ch case    3:*/		cpu::op::xori<0>(regs,&regs.R9,regs.R10,0x10);
		/* 82163E6Ch case    3:*/		return 0x82163E70;
	}
	return 0x82163E70;
} // Block from 82163E60h-82163E70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163E70);
		  /* 82163E70h */ case    0:  		/* cmplwi CR6, R14, 1 */
		/* 82163E70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000001);
		/* 82163E70h case    0:*/		return 0x82163E74;
		  /* 82163E74h */ case    1:  		/* bc 12, CR6_LT, 192 */
		/* 82163E74h case    1:*/		if ( regs.CR[6].lt ) { return 0x82163F34;  }
		/* 82163E74h case    1:*/		return 0x82163E78;
		  /* 82163E78h */ case    2:  		/* bc 4, CR6_EQ, 228 */
		/* 82163E78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82163F5C;  }
		/* 82163E78h case    2:*/		return 0x82163E7C;
		  /* 82163E7Ch */ case    3:  		/* subfic R10, R29, 0 */
		/* 82163E7Ch case    3:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R29,0x0);
		/* 82163E7Ch case    3:*/		return 0x82163E80;
		  /* 82163E80h */ case    4:  		/* lwz R24, <#[R30 + 16]> */
		/* 82163E80h case    4:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R30 + 0x00000010) );
		/* 82163E80h case    4:*/		return 0x82163E84;
		  /* 82163E84h */ case    5:  		/* rlwinm. R25, R11, 0, 16, 31 */
		/* 82163E84h case    5:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R25,regs.R11);
		/* 82163E84h case    5:*/		return 0x82163E88;
		  /* 82163E88h */ case    6:  		/* stw R21, <#[R1 + 80]> */
		/* 82163E88h case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 82163E88h case    6:*/		return 0x82163E8C;
		  /* 82163E8Ch */ case    7:  		/* subfe R11, R10, R10 */
		/* 82163E8Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R10);
		/* 82163E8Ch case    7:*/		return 0x82163E90;
		  /* 82163E90h */ case    8:  		/* stw R21, <#[R1 + 84]> */
		/* 82163E90h case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 82163E90h case    8:*/		return 0x82163E94;
		  /* 82163E94h */ case    9:  		/* stw R21, <#[R1 + 88]> */
		/* 82163E94h case    9:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000058) );
		/* 82163E94h case    9:*/		return 0x82163E98;
		  /* 82163E98h */ case   10:  		/* mr R31, R21 */
		/* 82163E98h case   10:*/		regs.R31 = regs.R21;
		/* 82163E98h case   10:*/		return 0x82163E9C;
		  /* 82163E9Ch */ case   11:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82163E9Ch case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82163E9Ch case   11:*/		return 0x82163EA0;
		  /* 82163EA0h */ case   12:  		/* stw R21, <#[R1 + 92]> */
		/* 82163EA0h case   12:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 82163EA0h case   12:*/		return 0x82163EA4;
		  /* 82163EA4h */ case   13:  		/* addi R27, R11, 1 */
		/* 82163EA4h case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x1);
		/* 82163EA4h case   13:*/		return 0x82163EA8;
		  /* 82163EA8h */ case   14:  		/* bc 12, CR0_EQ, 180 */
		/* 82163EA8h case   14:*/		if ( regs.CR[0].eq ) { return 0x82163F5C;  }
		/* 82163EA8h case   14:*/		return 0x82163EAC;
		  /* 82163EACh */ case   15:  		/* add R23, R24, R22 */
		/* 82163EACh case   15:*/		cpu::op::add<0>(regs,&regs.R23,regs.R24,regs.R22);
		/* 82163EACh case   15:*/		return 0x82163EB0;
		  /* 82163EB0h */ case   16:  		/* rlwinm R26, R9, 0, 16, 31 */
		/* 82163EB0h case   16:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R26,regs.R9);
		/* 82163EB0h case   16:*/		return 0x82163EB4;
		  /* 82163EB4h */ case   17:  		/* mr R28, R21 */
		/* 82163EB4h case   17:*/		regs.R28 = regs.R21;
		/* 82163EB4h case   17:*/		return 0x82163EB8;
		  /* 82163EB8h */ case   18:  		/* cmplwi CR6, R24, 0 */
		/* 82163EB8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82163EB8h case   18:*/		return 0x82163EBC;
		  /* 82163EBCh */ case   19:  		/* bc 12, CR6_EQ, 56 */
		/* 82163EBCh case   19:*/		if ( regs.CR[6].eq ) { return 0x82163EF4;  }
		/* 82163EBCh case   19:*/		return 0x82163EC0;
		  /* 82163EC0h */ case   20:  		/* mr R11, R21 */
		/* 82163EC0h case   20:*/		regs.R11 = regs.R21;
		/* 82163EC0h case   20:*/		return 0x82163EC4;
		  /* 82163EC4h */ case   21:  		/* cmpwi CR6, R27, 0 */
		/* 82163EC4h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82163EC4h case   21:*/		return 0x82163EC8;
		  /* 82163EC8h */ case   22:  		/* bc 4, CR6_GT, 36 */
		/* 82163EC8h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82163EEC;  }
		/* 82163EC8h case   22:*/		return 0x82163ECC;
		  /* 82163ECCh */ case   23:  		/* addi R10, R1, 76 */
		/* 82163ECCh case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x4C);
		/* 82163ECCh case   23:*/		return 0x82163ED0;
		  /* 82163ED0h */ case   24:  		/* mtspr CTR, R27 */
		/* 82163ED0h case   24:*/		regs.CTR = regs.R27;
		/* 82163ED0h case   24:*/		return 0x82163ED4;
		  /* 82163ED4h */ case   25:  		/* add R9, R28, R11 */
		/* 82163ED4h case   25:*/		cpu::op::add<0>(regs,&regs.R9,regs.R28,regs.R11);
		/* 82163ED4h case   25:*/		return 0x82163ED8;
		  /* 82163ED8h */ case   26:  		/* addi R11, R11, 1 */
		/* 82163ED8h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82163ED8h case   26:*/		return 0x82163EDC;
		  /* 82163EDCh */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82163EDCh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82163EDCh case   27:*/		return 0x82163EE0;
		  /* 82163EE0h */ case   28:  		/* lwzx R9, <#[R9 + R23]> */
		/* 82163EE0h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R23 + 0x00000000) );
		/* 82163EE0h case   28:*/		return 0x82163EE4;
		  /* 82163EE4h */ case   29:  		/* stwu R9, <#[R10 + 4]> */
		/* 82163EE4h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82163EE4h case   29:*/		return 0x82163EE8;
		  /* 82163EE8h */ case   30:  		/* bc 16, CR0_LT, -20 */
		/* 82163EE8h case   30:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82163ED4;  }
		/* 82163EE8h case   30:*/		return 0x82163EEC;
	}
	return 0x82163EEC;
} // Block from 82163E70h-82163EECh (31 instructions)

//////////////////////////////////////////////////////
// Block at 82163EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163EEC);
		  /* 82163EECh */ case    0:  		/* addi R8, R1, 80 */
		/* 82163EECh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82163EECh case    0:*/		return 0x82163EF0;
		  /* 82163EF0h */ case    1:  		/* b 8 */
		/* 82163EF0h case    1:*/		return 0x82163EF8;
		/* 82163EF0h case    1:*/		return 0x82163EF4;
	}
	return 0x82163EF4;
} // Block from 82163EECh-82163EF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163EF4);
		  /* 82163EF4h */ case    0:  		/* mr R8, R21 */
		/* 82163EF4h case    0:*/		regs.R8 = regs.R21;
		/* 82163EF4h case    0:*/		return 0x82163EF8;
	}
	return 0x82163EF8;
} // Block from 82163EF4h-82163EF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163EF8);
		  /* 82163EF8h */ case    0:  		/* mr R7, R26 */
		/* 82163EF8h case    0:*/		regs.R7 = regs.R26;
		/* 82163EF8h case    0:*/		return 0x82163EFC;
		  /* 82163EFCh */ case    1:  		/* mtspr CTR, R15 */
		/* 82163EFCh case    1:*/		regs.CTR = regs.R15;
		/* 82163EFCh case    1:*/		return 0x82163F00;
		  /* 82163F00h */ case    2:  		/* mr R6, R29 */
		/* 82163F00h case    2:*/		regs.R6 = regs.R29;
		/* 82163F00h case    2:*/		return 0x82163F04;
		  /* 82163F04h */ case    3:  		/* mr R5, R31 */
		/* 82163F04h case    3:*/		regs.R5 = regs.R31;
		/* 82163F04h case    3:*/		return 0x82163F08;
		  /* 82163F08h */ case    4:  		/* mr R4, R20 */
		/* 82163F08h case    4:*/		regs.R4 = regs.R20;
		/* 82163F08h case    4:*/		return 0x82163F0C;
		  /* 82163F0Ch */ case    5:  		/* mr R3, R16 */
		/* 82163F0Ch case    5:*/		regs.R3 = regs.R16;
		/* 82163F0Ch case    5:*/		return 0x82163F10;
		  /* 82163F10h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82163F10h case    6:*/		if ( 1 ) { regs.LR = 0x82163F14; return (uint32)regs.CTR; }
		/* 82163F10h case    6:*/		return 0x82163F14;
		  /* 82163F14h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82163F14h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82163F14h case    7:*/		return 0x82163F18;
		  /* 82163F18h */ case    8:  		/* bc 12, CR0_LT, 88 */
		/* 82163F18h case    8:*/		if ( regs.CR[0].lt ) { return 0x82163F70;  }
		/* 82163F18h case    8:*/		return 0x82163F1C;
		  /* 82163F1Ch */ case    9:  		/* addi R31, R31, 1 */
		/* 82163F1Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82163F1Ch case    9:*/		return 0x82163F20;
		  /* 82163F20h */ case   10:  		/* add R28, R28, R27 */
		/* 82163F20h case   10:*/		cpu::op::add<0>(regs,&regs.R28,regs.R28,regs.R27);
		/* 82163F20h case   10:*/		return 0x82163F24;
		  /* 82163F24h */ case   11:  		/* cmplw CR6, R31, R25 */
		/* 82163F24h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 82163F24h case   11:*/		return 0x82163F28;
		  /* 82163F28h */ case   12:  		/* bc 12, CR6_LT, -112 */
		/* 82163F28h case   12:*/		if ( regs.CR[6].lt ) { return 0x82163EB8;  }
		/* 82163F28h case   12:*/		return 0x82163F2C;
		  /* 82163F2Ch */ case   13:  		/* lwz R28, <#[R1 + 308]> */
		/* 82163F2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000134) );
		/* 82163F2Ch case   13:*/		return 0x82163F30;
		  /* 82163F30h */ case   14:  		/* b 44 */
		/* 82163F30h case   14:*/		return 0x82163F5C;
		/* 82163F30h case   14:*/		return 0x82163F34;
	}
	return 0x82163F34;
} // Block from 82163EF8h-82163F34h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82163F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163F34);
		  /* 82163F34h */ case    0:  		/* li R8, 0 */
		/* 82163F34h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82163F34h case    0:*/		return 0x82163F38;
		  /* 82163F38h */ case    1:  		/* mtspr CTR, R15 */
		/* 82163F38h case    1:*/		regs.CTR = regs.R15;
		/* 82163F38h case    1:*/		return 0x82163F3C;
		  /* 82163F3Ch */ case    2:  		/* rlwinm R7, R9, 0, 16, 31 */
		/* 82163F3Ch case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R9);
		/* 82163F3Ch case    2:*/		return 0x82163F40;
		  /* 82163F40h */ case    3:  		/* mr R6, R29 */
		/* 82163F40h case    3:*/		regs.R6 = regs.R29;
		/* 82163F40h case    3:*/		return 0x82163F44;
		  /* 82163F44h */ case    4:  		/* rlwinm R5, R11, 0, 16, 31 */
		/* 82163F44h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R5,regs.R11);
		/* 82163F44h case    4:*/		return 0x82163F48;
		  /* 82163F48h */ case    5:  		/* mr R4, R20 */
		/* 82163F48h case    5:*/		regs.R4 = regs.R20;
		/* 82163F48h case    5:*/		return 0x82163F4C;
		  /* 82163F4Ch */ case    6:  		/* mr R3, R16 */
		/* 82163F4Ch case    6:*/		regs.R3 = regs.R16;
		/* 82163F4Ch case    6:*/		return 0x82163F50;
		  /* 82163F50h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82163F50h case    7:*/		if ( 1 ) { regs.LR = 0x82163F54; return (uint32)regs.CTR; }
		/* 82163F50h case    7:*/		return 0x82163F54;
		  /* 82163F54h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82163F54h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82163F54h case    8:*/		return 0x82163F58;
		  /* 82163F58h */ case    9:  		/* bc 12, CR0_LT, 24 */
		/* 82163F58h case    9:*/		if ( regs.CR[0].lt ) { return 0x82163F70;  }
		/* 82163F58h case    9:*/		return 0x82163F5C;
	}
	return 0x82163F5C;
} // Block from 82163F34h-82163F5Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82163F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163F5C);
		  /* 82163F5Ch */ case    0:  		/* addi R17, R17, 1 */
		/* 82163F5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 82163F5Ch case    0:*/		return 0x82163F60;
		  /* 82163F60h */ case    1:  		/* addi R30, R30, 20 */
		/* 82163F60h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x14);
		/* 82163F60h case    1:*/		return 0x82163F64;
		  /* 82163F64h */ case    2:  		/* cmplw CR6, R17, R18 */
		/* 82163F64h case    2:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R18);
		/* 82163F64h case    2:*/		return 0x82163F68;
		  /* 82163F68h */ case    3:  		/* bc 12, CR6_LT, -316 */
		/* 82163F68h case    3:*/		if ( regs.CR[6].lt ) { return 0x82163E2C;  }
		/* 82163F68h case    3:*/		return 0x82163F6C;
	}
	return 0x82163F6C;
} // Block from 82163F5Ch-82163F6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82163F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163F6C);
		  /* 82163F6Ch */ case    0:  		/* li R3, 0 */
		/* 82163F6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82163F6Ch case    0:*/		return 0x82163F70;
	}
	return 0x82163F70;
} // Block from 82163F6Ch-82163F70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82163F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163F70);
		  /* 82163F70h */ case    0:  		/* addi R1, R1, 272 */
		/* 82163F70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82163F70h case    0:*/		return 0x82163F74;
		  /* 82163F74h */ case    1:  		/* b -863492 */
		/* 82163F74h case    1:*/		return 0x82091270;
		/* 82163F74h case    1:*/		return 0x82163F78;
	}
	return 0x82163F78;
} // Block from 82163F70h-82163F78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163F78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163F78);
		  /* 82163F78h */ case    0:  		/* mfspr R12, LR */
		/* 82163F78h case    0:*/		regs.R12 = regs.LR;
		/* 82163F78h case    0:*/		return 0x82163F7C;
		  /* 82163F7Ch */ case    1:  		/* bl -863528 */
		/* 82163F7Ch case    1:*/		regs.LR = 0x82163F80; return 0x82091254;
		/* 82163F7Ch case    1:*/		return 0x82163F80;
	}
	return 0x82163F80;
} // Block from 82163F78h-82163F80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163F80h
// Function '?EnumerateLiteralsShaderCostCallback@XGRAPHICS@@YAJPAXKKKPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163F80);
		  /* 82163F80h */ case    0:  		/* stwu R1, <#[R1 - 1328]> */
		/* 82163F80h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFAD0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFAD0);
		/* 82163F80h case    0:*/		return 0x82163F84;
		  /* 82163F84h */ case    1:  		/* mr R30, R4 */
		/* 82163F84h case    1:*/		regs.R30 = regs.R4;
		/* 82163F84h case    1:*/		return 0x82163F88;
		  /* 82163F88h */ case    2:  		/* addi R4, R1, 112 */
		/* 82163F88h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 82163F88h case    2:*/		return 0x82163F8C;
		  /* 82163F8Ch */ case    3:  		/* mr R31, R3 */
		/* 82163F8Ch case    3:*/		regs.R31 = regs.R3;
		/* 82163F8Ch case    3:*/		return 0x82163F90;
		  /* 82163F90h */ case    4:  		/* mr R27, R5 */
		/* 82163F90h case    4:*/		regs.R27 = regs.R5;
		/* 82163F90h case    4:*/		return 0x82163F94;
		  /* 82163F94h */ case    5:  		/* bl -1028668 */
		/* 82163F94h case    5:*/		regs.LR = 0x82163F98; return 0x82068D58;
		/* 82163F94h case    5:*/		return 0x82163F98;
		  /* 82163F98h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 82163F98h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82163F98h case    6:*/		return 0x82163F9C;
		  /* 82163F9Ch */ case    7:  		/* li R28, 0 */
		/* 82163F9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82163F9Ch case    7:*/		return 0x82163FA0;
		  /* 82163FA0h */ case    8:  		/* li R29, 0 */
		/* 82163FA0h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82163FA0h case    8:*/		return 0x82163FA4;
		  /* 82163FA4h */ case    9:  		/* rlwinm. R4, R11, 0, 31, 31 */
		/* 82163FA4h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R4,regs.R11);
		/* 82163FA4h case    9:*/		return 0x82163FA8;
		  /* 82163FA8h */ case   10:  		/* addi R11, R30, 3 */
		/* 82163FA8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x3);
		/* 82163FA8h case   10:*/		return 0x82163FAC;
		  /* 82163FACh */ case   11:  		/* li R3, 0 */
		/* 82163FACh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82163FACh case   11:*/		return 0x82163FB0;
		  /* 82163FB0h */ case   12:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82163FB0h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82163FB0h case   12:*/		return 0x82163FB4;
		  /* 82163FB4h */ case   13:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82163FB4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82163FB4h case   13:*/		return 0x82163FB8;
		  /* 82163FB8h */ case   14:  		/* bc 12, CR0_EQ, 32 */
		/* 82163FB8h case   14:*/		if ( regs.CR[0].eq ) { return 0x82163FD8;  }
		/* 82163FB8h case   14:*/		return 0x82163FBC;
		  /* 82163FBCh */ case   15:  		/* add R11, R11, R31 */
		/* 82163FBCh case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82163FBCh case   15:*/		return 0x82163FC0;
		  /* 82163FC0h */ case   16:  		/* lwz R10, <#[R11 + 24]> */
		/* 82163FC0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82163FC0h case   16:*/		return 0x82163FC4;
		  /* 82163FC4h */ case   17:  		/* lwz R29, <#[R11 + 28]> */
		/* 82163FC4h case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x0000001C) );
		/* 82163FC4h case   17:*/		return 0x82163FC8;
		  /* 82163FC8h */ case   18:  		/* addi R10, R10, 9 */
		/* 82163FC8h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x9);
		/* 82163FC8h case   18:*/		return 0x82163FCC;
		  /* 82163FCCh */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82163FCCh case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82163FCCh case   19:*/		return 0x82163FD0;
		  /* 82163FD0h */ case   20:  		/* add R28, R10, R11 */
		/* 82163FD0h case   20:*/		cpu::op::add<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 82163FD0h case   20:*/		return 0x82163FD4;
		  /* 82163FD4h */ case   21:  		/* b 12 */
		/* 82163FD4h case   21:*/		return 0x82163FE0;
		/* 82163FD4h case   21:*/		return 0x82163FD8;
	}
	return 0x82163FD8;
} // Block from 82163F80h-82163FD8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82163FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163FD8);
		  /* 82163FD8h */ case    0:  		/* add R3, R11, R31 */
		/* 82163FD8h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R31);
		/* 82163FD8h case    0:*/		return 0x82163FDC;
		  /* 82163FDCh */ case    1:  		/* mr R11, R3 */
		/* 82163FDCh case    1:*/		regs.R11 = regs.R3;
		/* 82163FDCh case    1:*/		return 0x82163FE0;
	}
	return 0x82163FE0;
} // Block from 82163FD8h-82163FE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82163FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82163FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82163FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82163FE0);
		  /* 82163FE0h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82163FE0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82163FE0h case    0:*/		return 0x82163FE4;
		  /* 82163FE4h */ case    1:  		/* cmpwi CR6, R4, 0 */
		/* 82163FE4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82163FE4h case    1:*/		return 0x82163FE8;
		  /* 82163FE8h */ case    2:  		/* lwz R9, <#[R1 + 120]> */
		/* 82163FE8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000078) );
		/* 82163FE8h case    2:*/		return 0x82163FEC;
		  /* 82163FECh */ case    3:  		/* lwz R8, <#[R11 + 4]> */
		/* 82163FECh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82163FECh case    3:*/		return 0x82163FF0;
		  /* 82163FF0h */ case    4:  		/* lwz R5, <#[R11 + 8]> */
		/* 82163FF0h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 82163FF0h case    4:*/		return 0x82163FF4;
		  /* 82163FF4h */ case    5:  		/* add R7, R10, R9 */
		/* 82163FF4h case    5:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R9);
		/* 82163FF4h case    5:*/		return 0x82163FF8;
		  /* 82163FF8h */ case    6:  		/* lwz R6, <#[R11 + 12]> */
		/* 82163FF8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 82163FF8h case    6:*/		return 0x82163FFC;
		  /* 82163FFCh */ case    7:  		/* bc 4, CR6_EQ, 68 */
		/* 82163FFCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82164040;  }
		/* 82163FFCh case    7:*/		return 0x82164000;
		  /* 82164000h */ case    8:  		/* lwz R11, <#[R11 + 20]> */
		/* 82164000h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82164000h case    8:*/		return 0x82164004;
		  /* 82164004h */ case    9:  		/* rlwinm R9, R5, 12, 28, 31 */
		/* 82164004h case    9:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R9,regs.R5);
		/* 82164004h case    9:*/		return 0x82164008;
		  /* 82164008h */ case   10:  		/* addi R3, R3, 32 */
		/* 82164008h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 82164008h case   10:*/		return 0x8216400C;
		  /* 8216400Ch */ case   11:  		/* rlwinm. R11, R11, 27, 27, 31 */
		/* 8216400Ch case   11:*/		cpu::op::rlwinm<1,27,27,31>(regs,&regs.R11,regs.R11);
		/* 8216400Ch case   11:*/		return 0x82164010;
		  /* 82164010h */ case   12:  		/* li R10, 0 */
		/* 82164010h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82164010h case   12:*/		return 0x82164014;
		  /* 82164014h */ case   13:  		/* bc 12, CR0_EQ, 40 */
		/* 82164014h case   13:*/		if ( regs.CR[0].eq ) { return 0x8216403C;  }
		/* 82164014h case   13:*/		return 0x82164018;
		  /* 82164018h */ case   14:  		/* lwz R30, <#[R3]> */
		/* 82164018h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82164018h case   14:*/		return 0x8216401C;
		  /* 8216401Ch */ case   15:  		/* rlwinm R30, R30, 24, 28, 31 */
		/* 8216401Ch case   15:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R30,regs.R30);
		/* 8216401Ch case   15:*/		return 0x82164020;
		  /* 82164020h */ case   16:  		/* cmplw CR6, R9, R30 */
		/* 82164020h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 82164020h case   16:*/		return 0x82164024;
		  /* 82164024h */ case   17:  		/* bc 12, CR6_GT, 8 */
		/* 82164024h case   17:*/		if ( regs.CR[6].gt ) { return 0x8216402C;  }
		/* 82164024h case   17:*/		return 0x82164028;
		  /* 82164028h */ case   18:  		/* mr R9, R30 */
		/* 82164028h case   18:*/		regs.R9 = regs.R30;
		/* 82164028h case   18:*/		return 0x8216402C;
	}
	return 0x8216402C;
} // Block from 82163FE0h-8216402Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216402Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216402C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216402C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216402C);
		  /* 8216402Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8216402Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216402Ch case    0:*/		return 0x82164030;
		  /* 82164030h */ case    1:  		/* addi R3, R3, 4 */
		/* 82164030h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82164030h case    1:*/		return 0x82164034;
		  /* 82164034h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82164034h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82164034h case    2:*/		return 0x82164038;
		  /* 82164038h */ case    3:  		/* bc 12, CR6_LT, -32 */
		/* 82164038h case    3:*/		if ( regs.CR[6].lt ) { return 0x82164018;  }
		/* 82164038h case    3:*/		return 0x8216403C;
	}
	return 0x8216403C;
} // Block from 8216402Ch-8216403Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216403Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216403C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216403C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216403C);
		  /* 8216403Ch */ case    0:  		/* rlwimi R5, R9, 20, 8, 11 */
		/* 8216403Ch case    0:*/		cpu::op::rlwimi<0,20,8,11>(regs,&regs.R5,regs.R9);
		/* 8216403Ch case    0:*/		return 0x82164040;
	}
	return 0x82164040;
} // Block from 8216403Ch-82164040h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164040h
// Function '?EnumerateConstantTableShaderCostCallback@XGRAPHICS@@YAJPAXPBDKW4_D3DXREGISTER_SET@@KPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164040);
		  /* 82164040h */ case    0:  		/* li R11, 0 */
		/* 82164040h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164040h case    0:*/		return 0x82164044;
		  /* 82164044h */ case    1:  		/* stw R28, <#[R1 + 100]> */
		/* 82164044h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000064) );
		/* 82164044h case    1:*/		return 0x82164048;
		  /* 82164048h */ case    2:  		/* li R10, 0 */
		/* 82164048h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82164048h case    2:*/		return 0x8216404C;
		  /* 8216404Ch */ case    3:  		/* stw R29, <#[R1 + 92]> */
		/* 8216404Ch case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8216404Ch case    3:*/		return 0x82164050;
		  /* 82164050h */ case    4:  		/* li R9, 0 */
		/* 82164050h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82164050h case    4:*/		return 0x82164054;
		  /* 82164054h */ case    5:  		/* stw R11, <#[R1 + 84]> */
		/* 82164054h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82164054h case    5:*/		return 0x82164058;
		  /* 82164058h */ case    6:  		/* addi R3, R1, 128 */
		/* 82164058h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82164058h case    6:*/		return 0x8216405C;
		  /* 8216405Ch */ case    7:  		/* bl -4484 */
		/* 8216405Ch case    7:*/		regs.LR = 0x82164060; return 0x82162ED8;
		/* 8216405Ch case    7:*/		return 0x82164060;
		  /* 82164060h */ case    8:  		/* lis R11, -32234 */
		/* 82164060h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8216);
		/* 82164060h case    8:*/		return 0x82164064;
		  /* 82164064h */ case    9:  		/* addi R4, R1, 128 */
		/* 82164064h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 82164064h case    9:*/		return 0x82164068;
		  /* 82164068h */ case   10:  		/* addi R5, R11, 13672 */
		/* 82164068h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3568);
		/* 82164068h case   10:*/		return 0x8216406C;
		  /* 8216406Ch */ case   11:  		/* mr R3, R31 */
		/* 8216406Ch case   11:*/		regs.R3 = regs.R31;
		/* 8216406Ch case   11:*/		return 0x82164070;
		  /* 82164070h */ case   12:  		/* bl -1022584 */
		/* 82164070h case   12:*/		regs.LR = 0x82164074; return 0x8206A5F8;
		/* 82164070h case   12:*/		return 0x82164074;
		  /* 82164074h */ case   13:  		/* lis R11, -32234 */
		/* 82164074h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8216);
		/* 82164074h case   13:*/		return 0x82164078;
		  /* 82164078h */ case   14:  		/* li R5, 17 */
		/* 82164078h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x11);
		/* 82164078h case   14:*/		return 0x8216407C;
		  /* 8216407Ch */ case   15:  		/* addi R6, R11, 13864 */
		/* 8216407Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x3628);
		/* 8216407Ch case   15:*/		return 0x82164080;
		  /* 82164080h */ case   16:  		/* addi R4, R1, 128 */
		/* 82164080h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 82164080h case   16:*/		return 0x82164084;
		  /* 82164084h */ case   17:  		/* mr R3, R31 */
		/* 82164084h case   17:*/		regs.R3 = regs.R31;
		/* 82164084h case   17:*/		return 0x82164088;
		  /* 82164088h */ case   18:  		/* bl -728 */
		/* 82164088h case   18:*/		regs.LR = 0x8216408C; return 0x82163DB0;
		/* 82164088h case   18:*/		return 0x8216408C;
		  /* 8216408Ch */ case   19:  		/* addi R3, R1, 128 */
		/* 8216408Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8216408Ch case   19:*/		return 0x82164090;
		  /* 82164090h */ case   20:  		/* bl -840 */
		/* 82164090h case   20:*/		regs.LR = 0x82164094; return 0x82163D48;
		/* 82164090h case   20:*/		return 0x82164094;
		  /* 82164094h */ case   21:  		/* mr R4, R27 */
		/* 82164094h case   21:*/		regs.R4 = regs.R27;
		/* 82164094h case   21:*/		return 0x82164098;
		  /* 82164098h */ case   22:  		/* addi R3, R1, 128 */
		/* 82164098h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82164098h case   22:*/		return 0x8216409C;
		  /* 8216409Ch */ case   23:  		/* bl -4284 */
		/* 8216409Ch case   23:*/		regs.LR = 0x821640A0; return 0x82162FE0;
		/* 8216409Ch case   23:*/		return 0x821640A0;
		  /* 821640A0h */ case   24:  		/* li R3, 0 */
		/* 821640A0h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821640A0h case   24:*/		return 0x821640A4;
		  /* 821640A4h */ case   25:  		/* addi R1, R1, 1328 */
		/* 821640A4h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x530);
		/* 821640A4h case   25:*/		return 0x821640A8;
		  /* 821640A8h */ case   26:  		/* b -863748 */
		/* 821640A8h case   26:*/		return 0x820912A4;
		/* 821640A8h case   26:*/		return 0x821640AC;
		  /* 821640ACh */ case   27:  		/* nop */
		/* 821640ACh case   27:*/		cpu::op::nop();
		/* 821640ACh case   27:*/		return 0x821640B0;
		  /* 821640B0h */ case   28:  		/* lwz R11, <#[R3 + 8]> */
		/* 821640B0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821640B0h case   28:*/		return 0x821640B4;
		  /* 821640B4h */ case   29:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 821640B4h case   29:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 821640B4h case   29:*/		return 0x821640B8;
		  /* 821640B8h */ case   30:  		/* bc 4, CR0_EQ, 12 */
		/* 821640B8h case   30:*/		if ( !regs.CR[0].eq ) { return 0x821640C4;  }
		/* 821640B8h case   30:*/		return 0x821640BC;
		  /* 821640BCh */ case   31:  		/* li R3, 0 */
		/* 821640BCh case   31:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821640BCh case   31:*/		return 0x821640C0;
		  /* 821640C0h */ case   32:  		/* bclr 20, CR0_LT */
		/* 821640C0h case   32:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821640C0h case   32:*/		return 0x821640C4;
	}
	return 0x821640C4;
} // Block from 82164040h-821640C4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821640C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821640C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821640C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821640C4);
		  /* 821640C4h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821640C4h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821640C4h case    0:*/		return 0x821640C8;
		  /* 821640C8h */ case    1:  		/* cmplwi CR6, R11, 21 */
		/* 821640C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 821640C8h case    1:*/		return 0x821640CC;
		  /* 821640CCh */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 821640CCh case    2:*/		if ( regs.CR[6].lt ) { return 0x821640D8;  }
		/* 821640CCh case    2:*/		return 0x821640D0;
		  /* 821640D0h */ case    3:  		/* cmplwi CR6, R11, 24 */
		/* 821640D0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 821640D0h case    3:*/		return 0x821640D4;
		  /* 821640D4h */ case    4:  		/* bc 4, CR6_GT, 20 */
		/* 821640D4h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821640E8;  }
		/* 821640D4h case    4:*/		return 0x821640D8;
	}
	return 0x821640D8;
} // Block from 821640C4h-821640D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821640D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821640D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821640D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821640D8);
		  /* 821640D8h */ case    0:  		/* cmplwi CR6, R11, 59 */
		/* 821640D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003B);
		/* 821640D8h case    0:*/		return 0x821640DC;
		  /* 821640DCh */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 821640DCh case    1:*/		if ( regs.CR[6].lt ) { return 0x821640F0;  }
		/* 821640DCh case    1:*/		return 0x821640E0;
		  /* 821640E0h */ case    2:  		/* cmplwi CR6, R11, 66 */
		/* 821640E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000042);
		/* 821640E0h case    2:*/		return 0x821640E4;
		  /* 821640E4h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 821640E4h case    3:*/		if ( regs.CR[6].gt ) { return 0x821640F0;  }
		/* 821640E4h case    3:*/		return 0x821640E8;
	}
	return 0x821640E8;
} // Block from 821640D8h-821640E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821640E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821640E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821640E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821640E8);
		  /* 821640E8h */ case    0:  		/* li R11, 1 */
		/* 821640E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821640E8h case    0:*/		return 0x821640EC;
		  /* 821640ECh */ case    1:  		/* b 8 */
		/* 821640ECh case    1:*/		return 0x821640F4;
		/* 821640ECh case    1:*/		return 0x821640F0;
	}
	return 0x821640F0;
} // Block from 821640E8h-821640F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821640F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821640F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821640F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821640F0);
		  /* 821640F0h */ case    0:  		/* li R11, 0 */
		/* 821640F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821640F0h case    0:*/		return 0x821640F4;
	}
	return 0x821640F4;
} // Block from 821640F0h-821640F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821640F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821640F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821640F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821640F4);
		  /* 821640F4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821640F4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821640F4h case    0:*/		return 0x821640F8;
		  /* 821640F8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821640F8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821640F8h case    1:*/		return 0x821640FC;
	}
	return 0x821640FC;
} // Block from 821640F4h-821640FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821640FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821640FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821640FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821640FC);
		  /* 821640FCh */ case    0:  		/* nop */
		/* 821640FCh case    0:*/		cpu::op::nop();
		/* 821640FCh case    0:*/		return 0x82164100;
		  /* 82164100h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164100h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164100h case    1:*/		return 0x82164104;
		  /* 82164104h */ case    2:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 82164104h case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 82164104h case    2:*/		return 0x82164108;
		  /* 82164108h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82164108h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82164114;  }
		/* 82164108h case    3:*/		return 0x8216410C;
		  /* 8216410Ch */ case    4:  		/* li R3, 0 */
		/* 8216410Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216410Ch case    4:*/		return 0x82164110;
		  /* 82164110h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82164110h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164110h case    5:*/		return 0x82164114;
	}
	return 0x82164114;
} // Block from 821640FCh-82164114h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164114);
		  /* 82164114h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82164114h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82164114h case    0:*/		return 0x82164118;
		  /* 82164118h */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 82164118h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 82164118h case    1:*/		return 0x8216411C;
		  /* 8216411Ch */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8216411Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82164134;  }
		/* 8216411Ch case    2:*/		return 0x82164120;
		  /* 82164120h */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 82164120h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82164120h case    3:*/		return 0x82164124;
		  /* 82164124h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82164124h case    4:*/		if ( regs.CR[6].eq ) { return 0x82164134;  }
		/* 82164124h case    4:*/		return 0x82164128;
		  /* 82164128h */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 82164128h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 82164128h case    5:*/		return 0x8216412C;
		  /* 8216412Ch */ case    6:  		/* li R11, 0 */
		/* 8216412Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216412Ch case    6:*/		return 0x82164130;
	}
	return 0x82164130;
} // Block from 82164114h-82164130h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82164130h
// Function '?ShaderCostCallback@XGRAPHICS@@YAJKKPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164130);
		  /* 82164130h */ case    0:  		/* bc 4, CR6_EQ, 8 */
		/* 82164130h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82164138;  }
		/* 82164130h case    0:*/		return 0x82164134;
	}
	return 0x82164134;
} // Block from 82164130h-82164134h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164134);
		  /* 82164134h */ case    0:  		/* li R11, 1 */
		/* 82164134h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164134h case    0:*/		return 0x82164138;
	}
	return 0x82164138;
} // Block from 82164134h-82164138h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164138);
		  /* 82164138h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82164138h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82164138h case    0:*/		return 0x8216413C;
		  /* 8216413Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216413Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216413Ch case    1:*/		return 0x82164140;
	}
	return 0x82164140;
} // Block from 82164138h-82164140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164140);
		  /* 82164140h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164140h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164140h case    0:*/		return 0x82164144;
		  /* 82164144h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82164144h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82164144h case    1:*/		return 0x82164148;
		  /* 82164148h */ case    2:  		/* cmplwi CR6, R11, 21 */
		/* 82164148h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 82164148h case    2:*/		return 0x8216414C;
		  /* 8216414Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8216414Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8216415C;  }
		/* 8216414Ch case    3:*/		return 0x82164150;
		  /* 82164150h */ case    4:  		/* cmplwi CR6, R11, 24 */
		/* 82164150h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 82164150h case    4:*/		return 0x82164154;
		  /* 82164154h */ case    5:  		/* li R10, 1 */
		/* 82164154h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82164154h case    5:*/		return 0x82164158;
		  /* 82164158h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82164158h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82164160;  }
		/* 82164158h case    6:*/		return 0x8216415C;
	}
	return 0x8216415C;
} // Block from 82164140h-8216415Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216415Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216415C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216415C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216415C);
		  /* 8216415Ch */ case    0:  		/* li R10, 0 */
		/* 8216415Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216415Ch case    0:*/		return 0x82164160;
	}
	return 0x82164160;
} // Block from 8216415Ch-82164160h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164160);
		  /* 82164160h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82164160h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82164160h case    0:*/		return 0x82164164;
		  /* 82164164h */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 82164164h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216418C;  }
		/* 82164164h case    1:*/		return 0x82164168;
		  /* 82164168h */ case    2:  		/* cmplwi CR6, R11, 63 */
		/* 82164168h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003F);
		/* 82164168h case    2:*/		return 0x8216416C;
		  /* 8216416Ch */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 8216416Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82164178;  }
		/* 8216416Ch case    3:*/		return 0x82164170;
		  /* 82164170h */ case    4:  		/* cmplwi CR6, R11, 66 */
		/* 82164170h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000042);
		/* 82164170h case    4:*/		return 0x82164174;
		  /* 82164174h */ case    5:  		/* bc 4, CR6_GT, 24 */
		/* 82164174h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8216418C;  }
		/* 82164174h case    5:*/		return 0x82164178;
	}
	return 0x82164178;
} // Block from 82164160h-82164178h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164178);
		  /* 82164178h */ case    0:  		/* cmplwi CR6, R11, 109 */
		/* 82164178h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006D);
		/* 82164178h case    0:*/		return 0x8216417C;
		  /* 8216417Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8216417Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8216418C;  }
		/* 8216417Ch case    1:*/		return 0x82164180;
		  /* 82164180h */ case    2:  		/* cmplwi CR6, R11, 108 */
		/* 82164180h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006C);
		/* 82164180h case    2:*/		return 0x82164184;
		  /* 82164184h */ case    3:  		/* li R11, 0 */
		/* 82164184h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164184h case    3:*/		return 0x82164188;
		  /* 82164188h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82164188h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82164190;  }
		/* 82164188h case    4:*/		return 0x8216418C;
	}
	return 0x8216418C;
} // Block from 82164178h-8216418Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216418Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216418C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216418C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216418C);
		  /* 8216418Ch */ case    0:  		/* li R11, 1 */
		/* 8216418Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216418Ch case    0:*/		return 0x82164190;
	}
	return 0x82164190;
} // Block from 8216418Ch-82164190h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164190);
		  /* 82164190h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82164190h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82164190h case    0:*/		return 0x82164194;
		  /* 82164194h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164194h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164194h case    1:*/		return 0x82164198;
	}
	return 0x82164198;
} // Block from 82164190h-82164198h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164198);
		  /* 82164198h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164198h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164198h case    0:*/		return 0x8216419C;
		  /* 8216419Ch */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8216419Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8216419Ch case    1:*/		return 0x821641A0;
		  /* 821641A0h */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 821641A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821641A0h case    2:*/		return 0x821641A4;
		  /* 821641A4h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821641A4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821641B4;  }
		/* 821641A4h case    3:*/		return 0x821641A8;
		  /* 821641A8h */ case    4:  		/* cmplwi CR6, R10, 82 */
		/* 821641A8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 821641A8h case    4:*/		return 0x821641AC;
		  /* 821641ACh */ case    5:  		/* li R11, 1 */
		/* 821641ACh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821641ACh case    5:*/		return 0x821641B0;
		  /* 821641B0h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821641B0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821641B8;  }
		/* 821641B0h case    6:*/		return 0x821641B4;
	}
	return 0x821641B4;
} // Block from 82164198h-821641B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821641B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641B4);
		  /* 821641B4h */ case    0:  		/* li R11, 0 */
		/* 821641B4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821641B4h case    0:*/		return 0x821641B8;
	}
	return 0x821641B8;
} // Block from 821641B4h-821641B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821641B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641B8);
		  /* 821641B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821641B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821641B8h case    0:*/		return 0x821641BC;
		  /* 821641BCh */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 821641BCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821641EC;  }
		/* 821641BCh case    1:*/		return 0x821641C0;
		  /* 821641C0h */ case    2:  		/* cmplwi CR6, R10, 96 */
		/* 821641C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 821641C0h case    2:*/		return 0x821641C4;
		  /* 821641C4h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821641C4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821641D4;  }
		/* 821641C4h case    3:*/		return 0x821641C8;
		  /* 821641C8h */ case    4:  		/* cmplwi CR6, R10, 102 */
		/* 821641C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 821641C8h case    4:*/		return 0x821641CC;
		  /* 821641CCh */ case    5:  		/* li R11, 1 */
		/* 821641CCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821641CCh case    5:*/		return 0x821641D0;
		  /* 821641D0h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821641D0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821641D8;  }
		/* 821641D0h case    6:*/		return 0x821641D4;
	}
	return 0x821641D4;
} // Block from 821641B8h-821641D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821641D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641D4);
		  /* 821641D4h */ case    0:  		/* li R11, 0 */
		/* 821641D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821641D4h case    0:*/		return 0x821641D8;
	}
	return 0x821641D8;
} // Block from 821641D4h-821641D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821641D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641D8);
		  /* 821641D8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821641D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821641D8h case    0:*/		return 0x821641DC;
		  /* 821641DCh */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 821641DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821641EC;  }
		/* 821641DCh case    1:*/		return 0x821641E0;
		  /* 821641E0h */ case    2:  		/* cmplwi CR6, R10, 126 */
		/* 821641E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007E);
		/* 821641E0h case    2:*/		return 0x821641E4;
		  /* 821641E4h */ case    3:  		/* li R11, 0 */
		/* 821641E4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821641E4h case    3:*/		return 0x821641E8;
		  /* 821641E8h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 821641E8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821641F0;  }
		/* 821641E8h case    4:*/		return 0x821641EC;
	}
	return 0x821641EC;
} // Block from 821641D8h-821641ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821641ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641EC);
		  /* 821641ECh */ case    0:  		/* li R11, 1 */
		/* 821641ECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821641ECh case    0:*/		return 0x821641F0;
	}
	return 0x821641F0;
} // Block from 821641ECh-821641F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821641F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641F0);
		  /* 821641F0h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821641F0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821641F0h case    0:*/		return 0x821641F4;
		  /* 821641F4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821641F4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821641F4h case    1:*/		return 0x821641F8;
	}
	return 0x821641F8;
} // Block from 821641F0h-821641F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821641F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821641F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821641F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821641F8);
		  /* 821641F8h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821641F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821641F8h case    0:*/		return 0x821641FC;
		  /* 821641FCh */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821641FCh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821641FCh case    1:*/		return 0x82164200;
		  /* 82164200h */ case    2:  		/* cmplwi CR6, R11, 86 */
		/* 82164200h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 82164200h case    2:*/		return 0x82164204;
		  /* 82164204h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 82164204h case    3:*/		if ( regs.CR[6].eq ) { return 0x82164234;  }
		/* 82164204h case    3:*/		return 0x82164208;
		  /* 82164208h */ case    4:  		/* cmplwi CR6, R11, 87 */
		/* 82164208h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 82164208h case    4:*/		return 0x8216420C;
		  /* 8216420Ch */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 8216420Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82164234;  }
		/* 8216420Ch case    5:*/		return 0x82164210;
		  /* 82164210h */ case    6:  		/* cmplwi CR6, R11, 89 */
		/* 82164210h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 82164210h case    6:*/		return 0x82164214;
		  /* 82164214h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 82164214h case    7:*/		if ( regs.CR[6].eq ) { return 0x82164234;  }
		/* 82164214h case    7:*/		return 0x82164218;
		  /* 82164218h */ case    8:  		/* cmplwi CR6, R11, 90 */
		/* 82164218h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 82164218h case    8:*/		return 0x8216421C;
		  /* 8216421Ch */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 8216421Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82164234;  }
		/* 8216421Ch case    9:*/		return 0x82164220;
		  /* 82164220h */ case   10:  		/* cmplwi CR6, R11, 84 */
		/* 82164220h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 82164220h case   10:*/		return 0x82164224;
		  /* 82164224h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 82164224h case   11:*/		if ( regs.CR[6].eq ) { return 0x82164234;  }
		/* 82164224h case   11:*/		return 0x82164228;
		  /* 82164228h */ case   12:  		/* cmplwi CR6, R11, 85 */
		/* 82164228h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000055);
		/* 82164228h case   12:*/		return 0x8216422C;
		  /* 8216422Ch */ case   13:  		/* li R11, 0 */
		/* 8216422Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216422Ch case   13:*/		return 0x82164230;
		  /* 82164230h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 82164230h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82164238;  }
		/* 82164230h case   14:*/		return 0x82164234;
	}
	return 0x82164234;
} // Block from 821641F8h-82164234h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82164234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164234);
		  /* 82164234h */ case    0:  		/* li R11, 1 */
		/* 82164234h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164234h case    0:*/		return 0x82164238;
	}
	return 0x82164238;
} // Block from 82164234h-82164238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164238);
		  /* 82164238h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82164238h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82164238h case    0:*/		return 0x8216423C;
		  /* 8216423Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216423Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216423Ch case    1:*/		return 0x82164240;
	}
	return 0x82164240;
} // Block from 82164238h-82164240h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164240);
		  /* 82164240h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 82164240h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82164240h case    0:*/		return 0x82164244;
		  /* 82164244h */ case    1:  		/* li R3, 0 */
		/* 82164244h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82164244h case    1:*/		return 0x82164248;
		  /* 82164248h */ case    2:  		/* li R11, 0 */
		/* 82164248h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164248h case    2:*/		return 0x8216424C;
		  /* 8216424Ch */ case    3:  		/* rlwinm. R8, R9, 7, 29, 31 */
		/* 8216424Ch case    3:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R9);
		/* 8216424Ch case    3:*/		return 0x82164250;
		  /* 82164250h */ case    4:  		/* bclr 12, CR0_EQ */
		/* 82164250h case    4:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82164250h case    4:*/		return 0x82164254;
	}
	return 0x82164254;
} // Block from 82164240h-82164254h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82164254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164254);
		  /* 82164254h */ case    0:  		/* li R10, 0 */
		/* 82164254h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82164254h case    0:*/		return 0x82164258;
		  /* 82164258h */ case    1:  		/* rlwinm R7, R9, 27, 24, 31 */
		/* 82164258h case    1:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R9);
		/* 82164258h case    1:*/		return 0x8216425C;
		  /* 8216425Ch */ case    2:  		/* li R6, 1 */
		/* 8216425Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216425Ch case    2:*/		return 0x82164260;
		  /* 82164260h */ case    3:  		/* srw R7, R7, R10 */
		/* 82164260h case    3:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82164260h case    3:*/		return 0x82164264;
		  /* 82164264h */ case    4:  		/* rlwinm R7, R7, 0, 30, 31 */
		/* 82164264h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R7);
		/* 82164264h case    4:*/		return 0x82164268;
		  /* 82164268h */ case    5:  		/* addi R11, R11, 1 */
		/* 82164268h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82164268h case    5:*/		return 0x8216426C;
		  /* 8216426Ch */ case    6:  		/* slw R7, R6, R7 */
		/* 8216426Ch case    6:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R6,regs.R7);
		/* 8216426Ch case    6:*/		return 0x82164270;
		  /* 82164270h */ case    7:  		/* or R3, R7, R3 */
		/* 82164270h case    7:*/		cpu::op::or<0>(regs,&regs.R3,regs.R7,regs.R3);
		/* 82164270h case    7:*/		return 0x82164274;
		  /* 82164274h */ case    8:  		/* addi R10, R10, 2 */
		/* 82164274h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82164274h case    8:*/		return 0x82164278;
		  /* 82164278h */ case    9:  		/* cmplw CR6, R11, R8 */
		/* 82164278h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82164278h case    9:*/		return 0x8216427C;
		  /* 8216427Ch */ case   10:  		/* bc 12, CR6_LT, -36 */
		/* 8216427Ch case   10:*/		if ( regs.CR[6].lt ) { return 0x82164258;  }
		/* 8216427Ch case   10:*/		return 0x82164280;
		  /* 82164280h */ case   11:  		/* bclr 20, CR0_LT */
		/* 82164280h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164280h case   11:*/		return 0x82164284;
	}
	return 0x82164284;
} // Block from 82164254h-82164284h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82164284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164284);
		  /* 82164284h */ case    0:  		/* nop */
		/* 82164284h case    0:*/		cpu::op::nop();
		/* 82164284h case    0:*/		return 0x82164288;
		  /* 82164288h */ case    1:  		/* lwz R11, <#[R3 + 12]> */
		/* 82164288h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82164288h case    1:*/		return 0x8216428C;
		  /* 8216428Ch */ case    2:  		/* lwz R10, <#[R4 + 12]> */
		/* 8216428Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 8216428Ch case    2:*/		return 0x82164290;
		  /* 82164290h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82164290h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82164290h case    3:*/		return 0x82164294;
		  /* 82164294h */ case    4:  		/* bc 12, CR6_EQ, 80 */
		/* 82164294h case    4:*/		if ( regs.CR[6].eq ) { return 0x821642E4;  }
		/* 82164294h case    4:*/		return 0x82164298;
		  /* 82164298h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 82164298h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82164298h case    5:*/		return 0x8216429C;
		  /* 8216429Ch */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216429Ch case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216429Ch case    6:*/		return 0x821642A0;
		  /* 821642A0h */ case    7:  		/* cmplwi CR6, R11, 15360 */
		/* 821642A0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 821642A0h case    7:*/		return 0x821642A4;
		  /* 821642A4h */ case    8:  		/* bc 4, CR6_EQ, 156 */
		/* 821642A4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82164340;  }
		/* 821642A4h case    8:*/		return 0x821642A8;
		  /* 821642A8h */ case    9:  		/* lwz R11, <#[R10 + 8]> */
		/* 821642A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821642A8h case    9:*/		return 0x821642AC;
		  /* 821642ACh */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821642ACh case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821642ACh case   10:*/		return 0x821642B0;
		  /* 821642B0h */ case   11:  		/* cmplwi CR6, R11, 15360 */
		/* 821642B0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 821642B0h case   11:*/		return 0x821642B4;
		  /* 821642B4h */ case   12:  		/* bc 4, CR6_EQ, 140 */
		/* 821642B4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82164340;  }
		/* 821642B4h case   12:*/		return 0x821642B8;
		  /* 821642B8h */ case   13:  		/* lwz R11, <#[R4]> */
		/* 821642B8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821642B8h case   13:*/		return 0x821642BC;
		  /* 821642BCh */ case   14:  		/* lwz R10, <#[R3]> */
		/* 821642BCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821642BCh case   14:*/		return 0x821642C0;
		  /* 821642C0h */ case   15:  		/* rlwinm R8, R11, 2, 31, 31 */
		/* 821642C0h case   15:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R8,regs.R11);
		/* 821642C0h case   15:*/		return 0x821642C4;
		  /* 821642C4h */ case   16:  		/* rlwinm R9, R10, 2, 31, 31 */
		/* 821642C4h case   16:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R9,regs.R10);
		/* 821642C4h case   16:*/		return 0x821642C8;
		  /* 821642C8h */ case   17:  		/* cmplw CR6, R9, R8 */
		/* 821642C8h case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821642C8h case   17:*/		return 0x821642CC;
		  /* 821642CCh */ case   18:  		/* bc 4, CR6_EQ, 116 */
		/* 821642CCh case   18:*/		if ( !regs.CR[6].eq ) { return 0x82164340;  }
		/* 821642CCh case   18:*/		return 0x821642D0;
		  /* 821642D0h */ case   19:  		/* cmplwi CR6, R9, 0 */
		/* 821642D0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821642D0h case   19:*/		return 0x821642D4;
		  /* 821642D4h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 821642D4h case   20:*/		if ( regs.CR[6].eq ) { return 0x821642E4;  }
		/* 821642D4h case   20:*/		return 0x821642D8;
		  /* 821642D8h */ case   21:  		/* xor R11, R10, R11 */
		/* 821642D8h case   21:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821642D8h case   21:*/		return 0x821642DC;
		  /* 821642DCh */ case   22:  		/* rlwinm. R11, R11, 0, 7, 18 */
		/* 821642DCh case   22:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R11);
		/* 821642DCh case   22:*/		return 0x821642E0;
		  /* 821642E0h */ case   23:  		/* bc 4, CR0_EQ, 96 */
		/* 821642E0h case   23:*/		if ( !regs.CR[0].eq ) { return 0x82164340;  }
		/* 821642E0h case   23:*/		return 0x821642E4;
	}
	return 0x821642E4;
} // Block from 82164284h-821642E4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821642E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821642E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821642E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821642E4);
		  /* 821642E4h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 821642E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821642E4h case    0:*/		return 0x821642E8;
		  /* 821642E8h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 821642E8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821642E8h case    1:*/		return 0x821642EC;
		  /* 821642ECh */ case    2:  		/* xor R9, R10, R11 */
		/* 821642ECh case    2:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 821642ECh case    2:*/		return 0x821642F0;
		  /* 821642F0h */ case    3:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 821642F0h case    3:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821642F0h case    3:*/		return 0x821642F4;
		  /* 821642F4h */ case    4:  		/* bc 4, CR0_EQ, 76 */
		/* 821642F4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82164340;  }
		/* 821642F4h case    4:*/		return 0x821642F8;
		  /* 821642F8h */ case    5:  		/* rlwinm R9, R11, 7, 29, 31 */
		/* 821642F8h case    5:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R11);
		/* 821642F8h case    5:*/		return 0x821642FC;
		  /* 821642FCh */ case    6:  		/* rlwinm R8, R10, 7, 29, 31 */
		/* 821642FCh case    6:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R10);
		/* 821642FCh case    6:*/		return 0x82164300;
		  /* 82164300h */ case    7:  		/* cmplw CR6, R8, R9 */
		/* 82164300h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82164300h case    7:*/		return 0x82164304;
		  /* 82164304h */ case    8:  		/* bc 4, CR6_EQ, 60 */
		/* 82164304h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82164340;  }
		/* 82164304h case    8:*/		return 0x82164308;
		  /* 82164308h */ case    9:  		/* li R7, 1 */
		/* 82164308h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82164308h case    9:*/		return 0x8216430C;
		  /* 8216430Ch */ case   10:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8216430Ch case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8216430Ch case   10:*/		return 0x82164310;
		  /* 82164310h */ case   11:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 82164310h case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 82164310h case   11:*/		return 0x82164314;
		  /* 82164314h */ case   12:  		/* slw R8, R7, R8 */
		/* 82164314h case   12:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 82164314h case   12:*/		return 0x82164318;
		  /* 82164318h */ case   13:  		/* slw R9, R7, R9 */
		/* 82164318h case   13:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82164318h case   13:*/		return 0x8216431C;
		  /* 8216431Ch */ case   14:  		/* rlwinm R11, R11, 27, 5, 31 */
		/* 8216431Ch case   14:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R11);
		/* 8216431Ch case   14:*/		return 0x82164320;
		  /* 82164320h */ case   15:  		/* addi R8, R8, -1 */
		/* 82164320h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82164320h case   15:*/		return 0x82164324;
		  /* 82164324h */ case   16:  		/* rlwinm R10, R10, 27, 5, 31 */
		/* 82164324h case   16:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R10);
		/* 82164324h case   16:*/		return 0x82164328;
		  /* 82164328h */ case   17:  		/* addi R9, R9, -1 */
		/* 82164328h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82164328h case   17:*/		return 0x8216432C;
		  /* 8216432Ch */ case   18:  		/* and R10, R8, R10 */
		/* 8216432Ch case   18:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8216432Ch case   18:*/		return 0x82164330;
		  /* 82164330h */ case   19:  		/* and R11, R9, R11 */
		/* 82164330h case   19:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82164330h case   19:*/		return 0x82164334;
		  /* 82164334h */ case   20:  		/* xor R11, R10, R11 */
		/* 82164334h case   20:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82164334h case   20:*/		return 0x82164338;
		  /* 82164338h */ case   21:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82164338h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82164338h case   21:*/		return 0x8216433C;
		  /* 8216433Ch */ case   22:  		/* bc 12, CR0_EQ, 8 */
		/* 8216433Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x82164344;  }
		/* 8216433Ch case   22:*/		return 0x82164340;
	}
	return 0x82164340;
} // Block from 821642E4h-82164340h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82164340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164340);
		  /* 82164340h */ case    0:  		/* li R7, 0 */
		/* 82164340h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82164340h case    0:*/		return 0x82164344;
	}
	return 0x82164344;
} // Block from 82164340h-82164344h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164344);
		  /* 82164344h */ case    0:  		/* rlwinm R3, R7, 0, 24, 31 */
		/* 82164344h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R7);
		/* 82164344h case    0:*/		return 0x82164348;
		  /* 82164348h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164348h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164348h case    1:*/		return 0x8216434C;
	}
	return 0x8216434C;
} // Block from 82164344h-8216434Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216434Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216434C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216434C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216434C);
		  /* 8216434Ch */ case    0:  		/* nop */
		/* 8216434Ch case    0:*/		cpu::op::nop();
		/* 8216434Ch case    0:*/		return 0x82164350;
		  /* 82164350h */ case    1:  		/* lwz R11, <#[R3 + 112]> */
		/* 82164350h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 82164350h case    1:*/		return 0x82164354;
		  /* 82164354h */ case    2:  		/* lwz R10, <#[R11 + 48]> */
		/* 82164354h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82164354h case    2:*/		return 0x82164358;
		  /* 82164358h */ case    3:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82164358h case    3:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82164358h case    3:*/		return 0x8216435C;
		  /* 8216435Ch */ case    4:  		/* bc 12, CR0_EQ, 48 */
		/* 8216435Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8216438C;  }
		/* 8216435Ch case    4:*/		return 0x82164360;
		  /* 82164360h */ case    5:  		/* b 16 */
		/* 82164360h case    5:*/		return 0x82164370;
		/* 82164360h case    5:*/		return 0x82164364;
		  /* 82164364h */ case    6:  		/* lwz R10, <#[R11 + 48]> */
		/* 82164364h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82164364h case    6:*/		return 0x82164368;
		  /* 82164368h */ case    7:  		/* rlwinm. R10, R10, 0, 9, 9 */
		/* 82164368h case    7:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R10,regs.R10);
		/* 82164368h case    7:*/		return 0x8216436C;
		  /* 8216436Ch */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8216436Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8216437C;  }
		/* 8216436Ch case    8:*/		return 0x82164370;
	}
	return 0x82164370;
} // Block from 8216434Ch-82164370h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82164370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164370);
		  /* 82164370h */ case    0:  		/* lwz R11, <#[R11 + 80]> */
		/* 82164370h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82164370h case    0:*/		return 0x82164374;
		  /* 82164374h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82164374h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164374h case    1:*/		return 0x82164378;
		  /* 82164378h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82164378h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82164364;  }
		/* 82164378h case    2:*/		return 0x8216437C;
	}
	return 0x8216437C;
} // Block from 82164370h-8216437Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216437Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216437C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216437C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216437C);
		  /* 8216437Ch */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216437Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216437Ch case    0:*/		return 0x82164380;
		  /* 82164380h */ case    1:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82164380h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82164380h case    1:*/		return 0x82164384;
		  /* 82164384h */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 82164384h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82164370;  }
		/* 82164384h case    2:*/		return 0x82164388;
		  /* 82164388h */ case    3:  		/* stw R11, <#[R3 + 112]> */
		/* 82164388h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 82164388h case    3:*/		return 0x8216438C;
	}
	return 0x8216438C;
} // Block from 8216437Ch-8216438Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216438Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216438C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216438C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216438C);
		  /* 8216438Ch */ case    0:  		/* lwz R3, <#[R3 + 112]> */
		/* 8216438Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000070) );
		/* 8216438Ch case    0:*/		return 0x82164390;
		  /* 82164390h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164390h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164390h case    1:*/		return 0x82164394;
	}
	return 0x82164394;
} // Block from 8216438Ch-82164394h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164394);
		  /* 82164394h */ case    0:  		/* nop */
		/* 82164394h case    0:*/		cpu::op::nop();
		/* 82164394h case    0:*/		return 0x82164398;
		  /* 82164398h */ case    1:  		/* lwz R11, <#[R3 + 804]> */
		/* 82164398h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000324) );
		/* 82164398h case    1:*/		return 0x8216439C;
		  /* 8216439Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8216439Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216439Ch case    2:*/		return 0x821643A0;
		  /* 821643A0h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821643A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821643AC;  }
		/* 821643A0h case    3:*/		return 0x821643A4;
		  /* 821643A4h */ case    4:  		/* lwz R3, <#[R3 + 800]> */
		/* 821643A4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000320) );
		/* 821643A4h case    4:*/		return 0x821643A8;
		  /* 821643A8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821643A8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821643A8h case    5:*/		return 0x821643AC;
	}
	return 0x821643AC;
} // Block from 82164394h-821643ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821643ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821643AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821643AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821643AC);
		  /* 821643ACh */ case    0:  		/* lwz R11, <#[R3 + 40]> */
		/* 821643ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 821643ACh case    0:*/		return 0x821643B0;
		  /* 821643B0h */ case    1:  		/* rlwinm. R11, R11, 0, 15, 15 */
		/* 821643B0h case    1:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R11,regs.R11);
		/* 821643B0h case    1:*/		return 0x821643B4;
		  /* 821643B4h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821643B4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821643C0;  }
		/* 821643B4h case    2:*/		return 0x821643B8;
		  /* 821643B8h */ case    3:  		/* li R3, 0 */
		/* 821643B8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821643B8h case    3:*/		return 0x821643BC;
		  /* 821643BCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 821643BCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821643BCh case    4:*/		return 0x821643C0;
	}
	return 0x821643C0;
} // Block from 821643ACh-821643C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821643C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821643C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821643C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821643C0);
		  /* 821643C0h */ case    0:  		/* lwz R11, <#[R3 + 48]> */
		/* 821643C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 821643C0h case    0:*/		return 0x821643C4;
		  /* 821643C4h */ case    1:  		/* lis R10, -1 */
		/* 821643C4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 821643C4h case    1:*/		return 0x821643C8;
		  /* 821643C8h */ case    2:  		/* li R9, 16 */
		/* 821643C8h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 821643C8h case    2:*/		return 0x821643CC;
		  /* 821643CCh */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821643CCh case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821643CCh case    3:*/		return 0x821643D0;
		  /* 821643D0h */ case    4:  		/* subf R11, R10, R11 */
		/* 821643D0h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821643D0h case    4:*/		return 0x821643D4;
		  /* 821643D4h */ case    5:  		/* subfic R11, R11, 0 */
		/* 821643D4h case    5:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 821643D4h case    5:*/		return 0x821643D8;
		  /* 821643D8h */ case    6:  		/* subfe R11, R11, R11 */
		/* 821643D8h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821643D8h case    6:*/		return 0x821643DC;
		  /* 821643DCh */ case    7:  		/* and R3, R11, R9 */
		/* 821643DCh case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 821643DCh case    7:*/		return 0x821643E0;
		  /* 821643E0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 821643E0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821643E0h case    8:*/		return 0x821643E4;
	}
	return 0x821643E4;
} // Block from 821643C0h-821643E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821643E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821643E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821643E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821643E4);
		  /* 821643E4h */ case    0:  		/* nop */
		/* 821643E4h case    0:*/		cpu::op::nop();
		/* 821643E4h case    0:*/		return 0x821643E8;
		  /* 821643E8h */ case    1:  		/* lwz R11, <#[R3 + 56]> */
		/* 821643E8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 821643E8h case    1:*/		return 0x821643EC;
		  /* 821643ECh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821643ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821643ECh case    2:*/		return 0x821643F0;
		  /* 821643F0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821643F0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82164400;  }
		/* 821643F0h case    3:*/		return 0x821643F4;
		  /* 821643F4h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 821643F4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821643F4h case    4:*/		return 0x821643F8;
		  /* 821643F8h */ case    5:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 821643F8h case    5:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 821643F8h case    5:*/		return 0x821643FC;
		  /* 821643FCh */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 821643FCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216441C;  }
		/* 821643FCh case    6:*/		return 0x82164400;
	}
	return 0x82164400;
} // Block from 821643E4h-82164400h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82164400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164400);
		  /* 82164400h */ case    0:  		/* rlwinm. R10, R4, 0, 24, 31 */
		/* 82164400h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R4);
		/* 82164400h case    0:*/		return 0x82164404;
		  /* 82164404h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 82164404h case    1:*/		if ( regs.CR[0].eq ) { return 0x82164424;  }
		/* 82164404h case    1:*/		return 0x82164408;
		  /* 82164408h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82164408h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164408h case    2:*/		return 0x8216440C;
		  /* 8216440Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8216440Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8216441C;  }
		/* 8216440Ch case    3:*/		return 0x82164410;
		  /* 82164410h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 82164410h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82164410h case    4:*/		return 0x82164414;
		  /* 82164414h */ case    5:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 82164414h case    5:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82164414h case    5:*/		return 0x82164418;
		  /* 82164418h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82164418h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82164424;  }
		/* 82164418h case    6:*/		return 0x8216441C;
	}
	return 0x8216441C;
} // Block from 82164400h-8216441Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216441Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216441C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216441C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216441C);
		  /* 8216441Ch */ case    0:  		/* li R11, 1 */
		/* 8216441Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216441Ch case    0:*/		return 0x82164420;
		  /* 82164420h */ case    1:  		/* b 8 */
		/* 82164420h case    1:*/		return 0x82164428;
		/* 82164420h case    1:*/		return 0x82164424;
	}
	return 0x82164424;
} // Block from 8216441Ch-82164424h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164424);
		  /* 82164424h */ case    0:  		/* li R11, 0 */
		/* 82164424h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164424h case    0:*/		return 0x82164428;
	}
	return 0x82164428;
} // Block from 82164424h-82164428h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164428);
		  /* 82164428h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82164428h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82164428h case    0:*/		return 0x8216442C;
		  /* 8216442Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216442Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216442Ch case    1:*/		return 0x82164430;
	}
	return 0x82164430;
} // Block from 82164428h-82164430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164430);
		  /* 82164430h */ case    0:  		/* addi R10, R5, 11 */
		/* 82164430h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xB);
		/* 82164430h case    0:*/		return 0x82164434;
		  /* 82164434h */ case    1:  		/* addi R11, R4, -84 */
		/* 82164434h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFAC);
		/* 82164434h case    1:*/		return 0x82164438;
		  /* 82164438h */ case    2:  		/* rlwinm R3, R10, 2, 0, 29 */
		/* 82164438h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R10);
		/* 82164438h case    2:*/		return 0x8216443C;
		  /* 8216443Ch */ case    3:  		/* cmplwi CR6, R11, 41 */
		/* 8216443Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000029);
		/* 8216443Ch case    3:*/		return 0x82164440;
		  /* 82164440h */ case    4:  		/* bclr 12, CR6_GT */
		/* 82164440h case    4:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82164440h case    4:*/		return 0x82164444;
	}
	return 0x82164444;
} // Block from 82164430h-82164444h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82164444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164444);
		  /* 82164444h */ case    0:  		/* lis R12, -32252 */
		/* 82164444h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82164444h case    0:*/		return 0x82164448;
		  /* 82164448h */ case    1:  		/* addi R12, R12, -17704 */
		/* 82164448h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBAD8);
		/* 82164448h case    1:*/		return 0x8216444C;
		  /* 8216444Ch */ case    2:  		/* lbzx R0, <#[R12 + R11]> */
		/* 8216444Ch case    2:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 8216444Ch case    2:*/		return 0x82164450;
		  /* 82164450h */ case    3:  		/* lis R12, -32234 */
		/* 82164450h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8216);
		/* 82164450h case    3:*/		return 0x82164454;
		  /* 82164454h */ case    4:  		/* ori R0, R0, 0 */
		/* 82164454h case    4:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82164454h case    4:*/		return 0x82164458;
		  /* 82164458h */ case    5:  		/* addi R12, R12, 17516 */
		/* 82164458h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x446C);
		/* 82164458h case    5:*/		return 0x8216445C;
		  /* 8216445Ch */ case    6:  		/* ori R0, R0, 0 */
		/* 8216445Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8216445Ch case    6:*/		return 0x82164460;
		  /* 82164460h */ case    7:  		/* add R12, R12, R0 */
		/* 82164460h case    7:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82164460h case    7:*/		return 0x82164464;
		  /* 82164464h */ case    8:  		/* mtspr CTR, R12 */
		/* 82164464h case    8:*/		regs.CTR = regs.R12;
		/* 82164464h case    8:*/		return 0x82164468;
		  /* 82164468h */ case    9:  		/* bcctr 20, CR0_LT */
		/* 82164468h case    9:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82164468h case    9:*/		return 0x8216446C;
		  /* 8216446Ch */ case   10:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 8216446Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 8216446Ch case   10:*/		return 0x82164470;
		  /* 82164470h */ case   11:  		/* add R3, R11, R3 */
		/* 82164470h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 82164470h case   11:*/		return 0x82164474;
		  /* 82164474h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82164474h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164474h case   12:*/		return 0x82164478;
	}
	return 0x82164478;
} // Block from 82164444h-82164478h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82164478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164478);
		  /* 82164478h */ case    0:  		/* addi R3, R3, 12 */
		/* 82164478h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xC);
		/* 82164478h case    0:*/		return 0x8216447C;
		  /* 8216447Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216447Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216447Ch case    1:*/		return 0x82164480;
	}
	return 0x82164480;
} // Block from 82164478h-82164480h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164480);
		  /* 82164480h */ case    0:  		/* addi R3, R3, 8 */
		/* 82164480h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x8);
		/* 82164480h case    0:*/		return 0x82164484;
		  /* 82164484h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164484h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164484h case    1:*/		return 0x82164488;
	}
	return 0x82164488;
} // Block from 82164480h-82164488h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164488);
		  /* 82164488h */ case    0:  		/* addi R3, R3, 20 */
		/* 82164488h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x14);
		/* 82164488h case    0:*/		return 0x8216448C;
		  /* 8216448Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216448Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216448Ch case    1:*/		return 0x82164490;
	}
	return 0x82164490;
} // Block from 82164488h-82164490h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164490);
		  /* 82164490h */ case    0:  		/* addi R3, R3, 24 */
		/* 82164490h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x18);
		/* 82164490h case    0:*/		return 0x82164494;
		  /* 82164494h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164494h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164494h case    1:*/		return 0x82164498;
	}
	return 0x82164498;
} // Block from 82164490h-82164498h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164498);
		  /* 82164498h */ case    0:  		/* addi R3, R3, 16 */
		/* 82164498h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x10);
		/* 82164498h case    0:*/		return 0x8216449C;
		  /* 8216449Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216449Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216449Ch case    1:*/		return 0x821644A0;
	}
	return 0x821644A0;
} // Block from 82164498h-821644A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821644A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821644A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821644A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821644A0);
		  /* 821644A0h */ case    0:  		/* addi R3, R3, 32 */
		/* 821644A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x20);
		/* 821644A0h case    0:*/		return 0x821644A4;
		  /* 821644A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821644A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821644A4h case    1:*/		return 0x821644A8;
	}
	return 0x821644A8;
} // Block from 821644A0h-821644A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821644A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821644A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821644A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821644A8);
		  /* 821644A8h */ case    0:  		/* addi R3, R3, 4 */
		/* 821644A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821644A8h case    0:*/		return 0x821644AC;
		  /* 821644ACh */ case    1:  		/* bclr 20, CR0_LT */
		/* 821644ACh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821644ACh case    1:*/		return 0x821644B0;
	}
	return 0x821644B0;
} // Block from 821644A8h-821644B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821644B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821644B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821644B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821644B0);
		  /* 821644B0h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 821644B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821644B0h case    0:*/		return 0x821644B4;
		  /* 821644B4h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 821644B4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821644B4h case    1:*/		return 0x821644B8;
		  /* 821644B8h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 821644B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821644B8h case    2:*/		return 0x821644BC;
		  /* 821644BCh */ case    3:  		/* lwz R10, <#[R10 + 12]> */
		/* 821644BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 821644BCh case    3:*/		return 0x821644C0;
		  /* 821644C0h */ case    4:  		/* lwz R11, <#[R11 + 20]> */
		/* 821644C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821644C0h case    4:*/		return 0x821644C4;
		  /* 821644C4h */ case    5:  		/* lwz R9, <#[R10 + 20]> */
		/* 821644C4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 821644C4h case    5:*/		return 0x821644C8;
		  /* 821644C8h */ case    6:  		/* lwz R10, <#[R11 + 24]> */
		/* 821644C8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 821644C8h case    6:*/		return 0x821644CC;
		  /* 821644CCh */ case    7:  		/* lwz R11, <#[R9 + 24]> */
		/* 821644CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 821644CCh case    7:*/		return 0x821644D0;
		  /* 821644D0h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 821644D0h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821644D0h case    8:*/		return 0x821644D4;
		  /* 821644D4h */ case    9:  		/* lbz R8, <#[R10]> */
		/* 821644D4h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821644D4h case    9:*/		return 0x821644D8;
		  /* 821644D8h */ case   10:  		/* cmpwi CR0, R9, 0 */
		/* 821644D8h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 821644D8h case   10:*/		return 0x821644DC;
		  /* 821644DCh */ case   11:  		/* subf R3, R8, R9 */
		/* 821644DCh case   11:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R8,regs.R9);
		/* 821644DCh case   11:*/		return 0x821644E0;
		  /* 821644E0h */ case   12:  		/* bclr 12, CR0_EQ */
		/* 821644E0h case   12:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821644E0h case   12:*/		return 0x821644E4;
	}
	return 0x821644E4;
} // Block from 821644B0h-821644E4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821644E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821644E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821644E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821644E4);
		  /* 821644E4h */ case    0:  		/* addi R11, R11, 1 */
		/* 821644E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821644E4h case    0:*/		return 0x821644E8;
		  /* 821644E8h */ case    1:  		/* addi R10, R10, 1 */
		/* 821644E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821644E8h case    1:*/		return 0x821644EC;
		  /* 821644ECh */ case    2:  		/* cmpwi CR6, R3, 0 */
		/* 821644ECh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 821644ECh case    2:*/		return 0x821644F0;
		  /* 821644F0h */ case    3:  		/* bc 12, CR6_EQ, -32 */
		/* 821644F0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821644D0;  }
		/* 821644F0h case    3:*/		return 0x821644F4;
		  /* 821644F4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821644F4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821644F4h case    4:*/		return 0x821644F8;
	}
	return 0x821644F8;
} // Block from 821644E4h-821644F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821644F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821644F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821644F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821644F8);
		  /* 821644F8h */ case    0:  		/* mfspr R12, LR */
		/* 821644F8h case    0:*/		regs.R12 = regs.LR;
		/* 821644F8h case    0:*/		return 0x821644FC;
		  /* 821644FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821644FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821644FCh case    1:*/		return 0x82164500;
		  /* 82164500h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82164500h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82164500h case    2:*/		return 0x82164504;
		  /* 82164504h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82164504h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164504h case    3:*/		return 0x82164508;
		  /* 82164508h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82164508h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82164508h case    4:*/		return 0x8216450C;
		  /* 8216450Ch */ case    5:  		/* mr R31, R5 */
		/* 8216450Ch case    5:*/		regs.R31 = regs.R5;
		/* 8216450Ch case    5:*/		return 0x82164510;
		  /* 82164510h */ case    6:  		/* mr R30, R6 */
		/* 82164510h case    6:*/		regs.R30 = regs.R6;
		/* 82164510h case    6:*/		return 0x82164514;
		  /* 82164514h */ case    7:  		/* bl 1005548 */
		/* 82164514h case    7:*/		regs.LR = 0x82164518; return 0x82259D00;
		/* 82164514h case    7:*/		return 0x82164518;
		  /* 82164518h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 82164518h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82164518h case    8:*/		return 0x8216451C;
		  /* 8216451Ch */ case    9:  		/* bc 12, CR0_EQ, 40 */
		/* 8216451Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82164544;  }
		/* 8216451Ch case    9:*/		return 0x82164520;
		  /* 82164520h */ case   10:  		/* bl -737560 */
		/* 82164520h case   10:*/		regs.LR = 0x82164524; return 0x820B0408;
		/* 82164520h case   10:*/		return 0x82164524;
		  /* 82164524h */ case   11:  		/* or. R11, R3, R3 */
		/* 82164524h case   11:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 82164524h case   11:*/		return 0x82164528;
		  /* 82164528h */ case   12:  		/* bc 12, CR0_EQ, 28 */
		/* 82164528h case   12:*/		if ( regs.CR[0].eq ) { return 0x82164544;  }
		/* 82164528h case   12:*/		return 0x8216452C;
		  /* 8216452Ch */ case   13:  		/* lwz R10, <#[R11 + 16]> */
		/* 8216452Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8216452Ch case   13:*/		return 0x82164530;
		  /* 82164530h */ case   14:  		/* li R3, 1 */
		/* 82164530h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82164530h case   14:*/		return 0x82164534;
		  /* 82164534h */ case   15:  		/* stw R10, <#[R31]> */
		/* 82164534h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82164534h case   15:*/		return 0x82164538;
		  /* 82164538h */ case   16:  		/* lwz R11, <#[R11 + 24]> */
		/* 82164538h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82164538h case   16:*/		return 0x8216453C;
		  /* 8216453Ch */ case   17:  		/* stw R11, <#[R30]> */
		/* 8216453Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216453Ch case   17:*/		return 0x82164540;
		  /* 82164540h */ case   18:  		/* b 8 */
		/* 82164540h case   18:*/		return 0x82164548;
		/* 82164540h case   18:*/		return 0x82164544;
	}
	return 0x82164544;
} // Block from 821644F8h-82164544h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82164544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164544);
		  /* 82164544h */ case    0:  		/* li R3, 0 */
		/* 82164544h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82164544h case    0:*/		return 0x82164548;
	}
	return 0x82164548;
} // Block from 82164544h-82164548h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164548);
		  /* 82164548h */ case    0:  		/* addi R1, R1, 112 */
		/* 82164548h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82164548h case    0:*/		return 0x8216454C;
		  /* 8216454Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216454Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216454Ch case    1:*/		return 0x82164550;
		  /* 82164550h */ case    2:  		/* mtspr LR, R12 */
		/* 82164550h case    2:*/		regs.LR = regs.R12;
		/* 82164550h case    2:*/		return 0x82164554;
		  /* 82164554h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82164554h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82164554h case    3:*/		return 0x82164558;
		  /* 82164558h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82164558h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164558h case    4:*/		return 0x8216455C;
		  /* 8216455Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216455Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216455Ch case    5:*/		return 0x82164560;
	}
	return 0x82164560;
} // Block from 82164548h-82164560h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164560);
		  /* 82164560h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82164560h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82164560h case    0:*/		return 0x82164564;
		  /* 82164564h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 82164564h case    1:*/		if ( regs.CR[6].eq ) { return 0x821645A0;  }
		/* 82164564h case    1:*/		return 0x82164568;
		  /* 82164568h */ case    2:  		/* lwz R11, <#[R3 + 744]> */
		/* 82164568h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002E8) );
		/* 82164568h case    2:*/		return 0x8216456C;
		  /* 8216456Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8216456Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216456Ch case    3:*/		return 0x82164570;
		  /* 82164570h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 82164570h case    4:*/		if ( regs.CR[6].eq ) { return 0x821645A0;  }
		/* 82164570h case    4:*/		return 0x82164574;
		  /* 82164574h */ case    5:  		/* lwz R11, <#[R3 + 756]> */
		/* 82164574h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002F4) );
		/* 82164574h case    5:*/		return 0x82164578;
		  /* 82164578h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82164578h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164578h case    6:*/		return 0x8216457C;
		  /* 8216457Ch */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 8216457Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82164598;  }
		/* 8216457Ch case    7:*/		return 0x82164580;
		  /* 82164580h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82164580h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82164580h case    8:*/		return 0x82164584;
		  /* 82164584h */ case    9:  		/* cmplw CR6, R4, R10 */
		/* 82164584h case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82164584h case    9:*/		return 0x82164588;
		  /* 82164588h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82164588h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82164598;  }
		/* 82164588h case   10:*/		return 0x8216458C;
		  /* 8216458Ch */ case   11:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 8216458Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 8216458Ch case   11:*/		return 0x82164590;
		  /* 82164590h */ case   12:  		/* lwzx R3, <#[R10 + R11]> */
		/* 82164590h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82164590h case   12:*/		return 0x82164594;
		  /* 82164594h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82164594h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164594h case   13:*/		return 0x82164598;
	}
	return 0x82164598;
} // Block from 82164560h-82164598h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82164598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164598);
		  /* 82164598h */ case    0:  		/* li R4, 4800 */
		/* 82164598h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82164598h case    0:*/		return 0x8216459C;
		  /* 8216459Ch */ case    1:  		/* b -75572 */
		/* 8216459Ch case    1:*/		return 0x82151E68;
		/* 8216459Ch case    1:*/		return 0x821645A0;
	}
	return 0x821645A0;
} // Block from 82164598h-821645A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821645A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821645A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821645A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821645A0);
		  /* 821645A0h */ case    0:  		/* li R3, -1 */
		/* 821645A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 821645A0h case    0:*/		return 0x821645A4;
		  /* 821645A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821645A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821645A4h case    1:*/		return 0x821645A8;
	}
	return 0x821645A8;
} // Block from 821645A0h-821645A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821645A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821645A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821645A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821645A8);
		  /* 821645A8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821645A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821645A8h case    0:*/		return 0x821645AC;
		  /* 821645ACh */ case    1:  		/* rlwinm R10, R11, 0, 29, 31 */
		/* 821645ACh case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R11);
		/* 821645ACh case    1:*/		return 0x821645B0;
		  /* 821645B0h */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 821645B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821645B0h case    2:*/		return 0x821645B4;
		  /* 821645B4h */ case    3:  		/* bc 4, CR6_EQ, 44 */
		/* 821645B4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821645E0;  }
		/* 821645B4h case    3:*/		return 0x821645B8;
		  /* 821645B8h */ case    4:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 821645B8h case    4:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 821645B8h case    4:*/		return 0x821645BC;
		  /* 821645BCh */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 821645BCh case    5:*/		if ( regs.CR[0].eq ) { return 0x821645E0;  }
		/* 821645BCh case    5:*/		return 0x821645C0;
		  /* 821645C0h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 821645C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821645C0h case    6:*/		return 0x821645C4;
		  /* 821645C4h */ case    7:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821645C4h case    7:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821645C4h case    7:*/		return 0x821645C8;
		  /* 821645C8h */ case    8:  		/* cmplwi CR6, R11, 96 */
		/* 821645C8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 821645C8h case    8:*/		return 0x821645CC;
		  /* 821645CCh */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821645CCh case    9:*/		if ( regs.CR[6].eq ) { return 0x821645E0;  }
		/* 821645CCh case    9:*/		return 0x821645D0;
		  /* 821645D0h */ case   10:  		/* lwz R11, <#[R3 + 12]> */
		/* 821645D0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821645D0h case   10:*/		return 0x821645D4;
		  /* 821645D4h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821645D4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821645D4h case   11:*/		return 0x821645D8;
		  /* 821645D8h */ case   12:  		/* li R11, 1 */
		/* 821645D8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821645D8h case   12:*/		return 0x821645DC;
		  /* 821645DCh */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 821645DCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x821645E4;  }
		/* 821645DCh case   13:*/		return 0x821645E0;
	}
	return 0x821645E0;
} // Block from 821645A8h-821645E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821645E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821645E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821645E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821645E0);
		  /* 821645E0h */ case    0:  		/* li R11, 0 */
		/* 821645E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821645E0h case    0:*/		return 0x821645E4;
	}
	return 0x821645E4;
} // Block from 821645E0h-821645E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821645E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821645E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821645E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821645E4);
		  /* 821645E4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821645E4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821645E4h case    0:*/		return 0x821645E8;
		  /* 821645E8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821645E8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821645E8h case    1:*/		return 0x821645EC;
	}
	return 0x821645EC;
} // Block from 821645E4h-821645ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821645ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821645EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821645EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821645EC);
		  /* 821645ECh */ case    0:  		/* nop */
		/* 821645ECh case    0:*/		cpu::op::nop();
		/* 821645ECh case    0:*/		return 0x821645F0;
	}
	return 0x821645F0;
} // Block from 821645ECh-821645F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821645F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821645F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821645F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821645F0);
		  /* 821645F0h */ case    0:  		/* mfspr R12, LR */
		/* 821645F0h case    0:*/		regs.R12 = regs.LR;
		/* 821645F0h case    0:*/		return 0x821645F4;
		  /* 821645F4h */ case    1:  		/* bl -865176 */
		/* 821645F4h case    1:*/		regs.LR = 0x821645F8; return 0x8209125C;
		/* 821645F4h case    1:*/		return 0x821645F8;
		  /* 821645F8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821645F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821645F8h case    2:*/		return 0x821645FC;
		  /* 821645FCh */ case    3:  		/* mr R31, R3 */
		/* 821645FCh case    3:*/		regs.R31 = regs.R3;
		/* 821645FCh case    3:*/		return 0x82164600;
		  /* 82164600h */ case    4:  		/* mr R29, R4 */
		/* 82164600h case    4:*/		regs.R29 = regs.R4;
		/* 82164600h case    4:*/		return 0x82164604;
		  /* 82164604h */ case    5:  		/* addi R11, R4, 4 */
		/* 82164604h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x4);
		/* 82164604h case    5:*/		return 0x82164608;
		  /* 82164608h */ case    6:  		/* b 32 */
		/* 82164608h case    6:*/		return 0x82164628;
		/* 82164608h case    6:*/		return 0x8216460C;
		  /* 8216460Ch */ case    7:  		/* rlwinm R10, R11, 30, 2, 31 */
		/* 8216460Ch case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R11);
		/* 8216460Ch case    7:*/		return 0x82164610;
		  /* 82164610h */ case    8:  		/* addi R10, R10, -1 */
		/* 82164610h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82164610h case    8:*/		return 0x82164614;
		  /* 82164614h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82164614h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82164614h case    9:*/		return 0x82164618;
		  /* 82164618h */ case   10:  		/* lwzx R30, <#[R10 + R31]> */
		/* 82164618h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82164618h case   10:*/		return 0x8216461C;
		  /* 8216461Ch */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 8216461Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8216461Ch case   11:*/		return 0x82164620;
		  /* 82164620h */ case   12:  		/* bc 4, CR6_EQ, 140 */
		/* 82164620h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821646AC;  }
		/* 82164620h case   12:*/		return 0x82164624;
		  /* 82164624h */ case   13:  		/* addi R11, R11, 4 */
		/* 82164624h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82164624h case   13:*/		return 0x82164628;
	}
	return 0x82164628;
} // Block from 821645F0h-82164628h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82164628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164628);
		  /* 82164628h */ case    0:  		/* cmplwi CR6, R11, 132 */
		/* 82164628h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000084);
		/* 82164628h case    0:*/		return 0x8216462C;
		  /* 8216462Ch */ case    1:  		/* bc 4, CR6_GT, -32 */
		/* 8216462Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x8216460C;  }
		/* 8216462Ch case    1:*/		return 0x82164630;
		  /* 82164630h */ case    2:  		/* lwz R11, <#[R31 + 144]> */
		/* 82164630h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 82164630h case    2:*/		return 0x82164634;
		  /* 82164634h */ case    3:  		/* lwz R10, <#[R31 + 140]> */
		/* 82164634h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000008C) );
		/* 82164634h case    3:*/		return 0x82164638;
		  /* 82164638h */ case    4:  		/* subf R10, R11, R10 */
		/* 82164638h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82164638h case    4:*/		return 0x8216463C;
		  /* 8216463Ch */ case    5:  		/* addic. R10, R10, 4096 */
		/* 8216463Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0x1000);
		/* 8216463Ch case    5:*/		return 0x82164640;
		  /* 82164640h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82164640h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216465C;  }
		/* 82164640h case    6:*/		return 0x82164644;
		  /* 82164644h */ case    7:  		/* rlwinm R10, R10, 30, 2, 31 */
		/* 82164644h case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R10);
		/* 82164644h case    7:*/		return 0x82164648;
		  /* 82164648h */ case    8:  		/* addi R10, R10, -1 */
		/* 82164648h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82164648h case    8:*/		return 0x8216464C;
		  /* 8216464Ch */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216464Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216464Ch case    9:*/		return 0x82164650;
		  /* 82164650h */ case   10:  		/* lwzx R9, <#[R10 + R31]> */
		/* 82164650h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82164650h case   10:*/		return 0x82164654;
		  /* 82164654h */ case   11:  		/* stw R9, <#[R11]> */
		/* 82164654h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82164654h case   11:*/		return 0x82164658;
		  /* 82164658h */ case   12:  		/* stwx R11, <#[R10 + R31]> */
		/* 82164658h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82164658h case   12:*/		return 0x8216465C;
	}
	return 0x8216465C;
} // Block from 82164628h-8216465Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216465Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216465C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216465C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216465C);
		  /* 8216465Ch */ case    0:  		/* lwz R11, <#[R31 + 140]> */
		/* 8216465Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 8216465Ch case    0:*/		return 0x82164660;
		  /* 82164660h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82164660h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82164660h case    1:*/		return 0x82164664;
		  /* 82164664h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82164664h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164664h case    2:*/		return 0x82164668;
		  /* 82164668h */ case    3:  		/* stw R11, <#[R31 + 140]> */
		/* 82164668h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 82164668h case    3:*/		return 0x8216466C;
		  /* 8216466Ch */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 8216466Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82164694;  }
		/* 8216466Ch case    4:*/		return 0x82164670;
		  /* 82164670h */ case    5:  		/* mr R3, R31 */
		/* 82164670h case    5:*/		regs.R3 = regs.R31;
		/* 82164670h case    5:*/		return 0x82164674;
		  /* 82164674h */ case    6:  		/* bl -75212 */
		/* 82164674h case    6:*/		regs.LR = 0x82164678; return 0x821520A8;
		/* 82164674h case    6:*/		return 0x82164678;
		  /* 82164678h */ case    7:  		/* lwz R11, <#[R31 + 136]> */
		/* 82164678h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82164678h case    7:*/		return 0x8216467C;
		  /* 8216467Ch */ case    8:  		/* stw R3, <#[R31 + 140]> */
		/* 8216467Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000008C) );
		/* 8216467Ch case    8:*/		return 0x82164680;
		  /* 82164680h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82164680h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164680h case    9:*/		return 0x82164684;
		  /* 82164684h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 82164684h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216468C;  }
		/* 82164684h case   10:*/		return 0x82164688;
		  /* 82164688h */ case   11:  		/* stw R3, <#[R11 + 4]> */
		/* 82164688h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 82164688h case   11:*/		return 0x8216468C;
	}
	return 0x8216468C;
} // Block from 8216465Ch-8216468Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216468Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216468C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216468C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216468C);
		  /* 8216468Ch */ case    0:  		/* lwz R11, <#[R31 + 140]> */
		/* 8216468Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 8216468Ch case    0:*/		return 0x82164690;
		  /* 82164690h */ case    1:  		/* stw R11, <#[R31 + 136]> */
		/* 82164690h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 82164690h case    1:*/		return 0x82164694;
	}
	return 0x82164694;
} // Block from 8216468Ch-82164694h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164694);
		  /* 82164694h */ case    0:  		/* lwz R11, <#[R31 + 140]> */
		/* 82164694h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 82164694h case    0:*/		return 0x82164698;
		  /* 82164698h */ case    1:  		/* addi R3, R11, 8 */
		/* 82164698h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x8);
		/* 82164698h case    1:*/		return 0x8216469C;
		  /* 8216469Ch */ case    2:  		/* add R11, R3, R29 */
		/* 8216469Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R29);
		/* 8216469Ch case    2:*/		return 0x821646A0;
		  /* 821646A0h */ case    3:  		/* stw R11, <#[R31 + 144]> */
		/* 821646A0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 821646A0h case    3:*/		return 0x821646A4;
		  /* 821646A4h */ case    4:  		/* addi R1, R1, 112 */
		/* 821646A4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821646A4h case    4:*/		return 0x821646A8;
		  /* 821646A8h */ case    5:  		/* b -865276 */
		/* 821646A8h case    5:*/		return 0x820912AC;
		/* 821646A8h case    5:*/		return 0x821646AC;
	}
	return 0x821646AC;
} // Block from 82164694h-821646ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821646ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821646AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821646AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821646AC);
		  /* 821646ACh */ case    0:  		/* lwz R9, <#[R30]> */
		/* 821646ACh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 821646ACh case    0:*/		return 0x821646B0;
		  /* 821646B0h */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 821646B0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 821646B0h case    1:*/		return 0x821646B4;
		  /* 821646B4h */ case    2:  		/* stwx R9, <#[R10 + R31]> */
		/* 821646B4h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821646B4h case    2:*/		return 0x821646B8;
		  /* 821646B8h */ case    3:  		/* bc 4, CR6_GT, 36 */
		/* 821646B8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821646DC;  }
		/* 821646B8h case    3:*/		return 0x821646BC;
		  /* 821646BCh */ case    4:  		/* subf R11, R29, R11 */
		/* 821646BCh case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 821646BCh case    4:*/		return 0x821646C0;
		  /* 821646C0h */ case    5:  		/* add R10, R30, R29 */
		/* 821646C0h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R30,regs.R29);
		/* 821646C0h case    5:*/		return 0x821646C4;
		  /* 821646C4h */ case    6:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 821646C4h case    6:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 821646C4h case    6:*/		return 0x821646C8;
		  /* 821646C8h */ case    7:  		/* addi R11, R11, -1 */
		/* 821646C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821646C8h case    7:*/		return 0x821646CC;
		  /* 821646CCh */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821646CCh case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821646CCh case    8:*/		return 0x821646D0;
		  /* 821646D0h */ case    9:  		/* lwzx R9, <#[R11 + R31]> */
		/* 821646D0h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821646D0h case    9:*/		return 0x821646D4;
		  /* 821646D4h */ case   10:  		/* stwx R9, <#[R30 + R29]> */
		/* 821646D4h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 821646D4h case   10:*/		return 0x821646D8;
		  /* 821646D8h */ case   11:  		/* stwx R10, <#[R11 + R31]> */
		/* 821646D8h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821646D8h case   11:*/		return 0x821646DC;
	}
	return 0x821646DC;
} // Block from 821646ACh-821646DCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821646DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821646DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821646DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821646DC);
		  /* 821646DCh */ case    0:  		/* mr R5, R29 */
		/* 821646DCh case    0:*/		regs.R5 = regs.R29;
		/* 821646DCh case    0:*/		return 0x821646E0;
		  /* 821646E0h */ case    1:  		/* li R4, 0 */
		/* 821646E0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821646E0h case    1:*/		return 0x821646E4;
		  /* 821646E4h */ case    2:  		/* mr R3, R30 */
		/* 821646E4h case    2:*/		regs.R3 = regs.R30;
		/* 821646E4h case    2:*/		return 0x821646E8;
		  /* 821646E8h */ case    3:  		/* bl -865192 */
		/* 821646E8h case    3:*/		regs.LR = 0x821646EC; return 0x82091340;
		/* 821646E8h case    3:*/		return 0x821646EC;
		  /* 821646ECh */ case    4:  		/* mr R3, R30 */
		/* 821646ECh case    4:*/		regs.R3 = regs.R30;
		/* 821646ECh case    4:*/		return 0x821646F0;
		  /* 821646F0h */ case    5:  		/* b -76 */
		/* 821646F0h case    5:*/		return 0x821646A4;
		/* 821646F0h case    5:*/		return 0x821646F4;
		  /* 821646F4h */ case    6:  		/* nop */
		/* 821646F4h case    6:*/		cpu::op::nop();
		/* 821646F4h case    6:*/		return 0x821646F8;
	}
	return 0x821646F8;
} // Block from 821646DCh-821646F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821646F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821646F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821646F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821646F8);
		  /* 821646F8h */ case    0:  		/* mfspr R12, LR */
		/* 821646F8h case    0:*/		regs.R12 = regs.LR;
		/* 821646F8h case    0:*/		return 0x821646FC;
		  /* 821646FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821646FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821646FCh case    1:*/		return 0x82164700;
		  /* 82164700h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82164700h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164700h case    2:*/		return 0x82164704;
		  /* 82164704h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82164704h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82164704h case    3:*/		return 0x82164708;
		  /* 82164708h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164708h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164708h case    4:*/		return 0x8216470C;
		  /* 8216470Ch */ case    5:  		/* mr R31, R3 */
		/* 8216470Ch case    5:*/		regs.R31 = regs.R3;
		/* 8216470Ch case    5:*/		return 0x82164710;
		  /* 82164710h */ case    6:  		/* mr R3, R4 */
		/* 82164710h case    6:*/		regs.R3 = regs.R4;
		/* 82164710h case    6:*/		return 0x82164714;
		  /* 82164714h */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82164714h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82164714h case    7:*/		return 0x82164718;
		  /* 82164718h */ case    8:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82164718h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82164718h case    8:*/		return 0x8216471C;
		  /* 8216471Ch */ case    9:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8216471Ch case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8216471Ch case    9:*/		return 0x82164720;
		  /* 82164720h */ case   10:  		/* bl -752 */
		/* 82164720h case   10:*/		regs.LR = 0x82164724; return 0x82164430;
		/* 82164720h case   10:*/		return 0x82164724;
		  /* 82164724h */ case   11:  		/* addi R11, R31, -20 */
		/* 82164724h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFEC);
		/* 82164724h case   11:*/		return 0x82164728;
		  /* 82164728h */ case   12:  		/* add R3, R3, R11 */
		/* 82164728h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 82164728h case   12:*/		return 0x8216472C;
		  /* 8216472Ch */ case   13:  		/* addi R1, R1, 96 */
		/* 8216472Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216472Ch case   13:*/		return 0x82164730;
		  /* 82164730h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 82164730h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164730h case   14:*/		return 0x82164734;
		  /* 82164734h */ case   15:  		/* mtspr LR, R12 */
		/* 82164734h case   15:*/		regs.LR = regs.R12;
		/* 82164734h case   15:*/		return 0x82164738;
		  /* 82164738h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 82164738h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164738h case   16:*/		return 0x8216473C;
		  /* 8216473Ch */ case   17:  		/* bclr 20, CR0_LT */
		/* 8216473Ch case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216473Ch case   17:*/		return 0x82164740;
	}
	return 0x82164740;
} // Block from 821646F8h-82164740h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82164740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164740);
		  /* 82164740h */ case    0:  		/* mfspr R12, LR */
		/* 82164740h case    0:*/		regs.R12 = regs.LR;
		/* 82164740h case    0:*/		return 0x82164744;
		  /* 82164744h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82164744h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164744h case    1:*/		return 0x82164748;
		  /* 82164748h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82164748h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164748h case    2:*/		return 0x8216474C;
		  /* 8216474Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216474Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216474Ch case    3:*/		return 0x82164750;
		  /* 82164750h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164750h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164750h case    4:*/		return 0x82164754;
		  /* 82164754h */ case    5:  		/* mr R31, R3 */
		/* 82164754h case    5:*/		regs.R31 = regs.R3;
		/* 82164754h case    5:*/		return 0x82164758;
		  /* 82164758h */ case    6:  		/* mr R3, R4 */
		/* 82164758h case    6:*/		regs.R3 = regs.R4;
		/* 82164758h case    6:*/		return 0x8216475C;
		  /* 8216475Ch */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8216475Ch case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8216475Ch case    7:*/		return 0x82164760;
	}
	return 0x82164760;
} // Block from 82164740h-82164760h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82164760h
// Function '?Calculate@CShaderCost@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164760);
		  /* 82164760h */ case    0:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82164760h case    0:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82164760h case    0:*/		return 0x82164764;
		  /* 82164764h */ case    1:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82164764h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82164764h case    1:*/		return 0x82164768;
		  /* 82164768h */ case    2:  		/* bl -824 */
		/* 82164768h case    2:*/		regs.LR = 0x8216476C; return 0x82164430;
		/* 82164768h case    2:*/		return 0x8216476C;
		  /* 8216476Ch */ case    3:  		/* addi R11, R31, -16 */
		/* 8216476Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216476Ch case    3:*/		return 0x82164770;
		  /* 82164770h */ case    4:  		/* add R3, R3, R11 */
		/* 82164770h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 82164770h case    4:*/		return 0x82164774;
		  /* 82164774h */ case    5:  		/* addi R1, R1, 96 */
		/* 82164774h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82164774h case    5:*/		return 0x82164778;
		  /* 82164778h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82164778h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164778h case    6:*/		return 0x8216477C;
		  /* 8216477Ch */ case    7:  		/* mtspr LR, R12 */
		/* 8216477Ch case    7:*/		regs.LR = regs.R12;
		/* 8216477Ch case    7:*/		return 0x82164780;
		  /* 82164780h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 82164780h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164780h case    8:*/		return 0x82164784;
		  /* 82164784h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82164784h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164784h case    9:*/		return 0x82164788;
	}
	return 0x82164788;
} // Block from 82164760h-82164788h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82164788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164788);
		  /* 82164788h */ case    0:  		/* mfspr R12, LR */
		/* 82164788h case    0:*/		regs.R12 = regs.LR;
		/* 82164788h case    0:*/		return 0x8216478C;
		  /* 8216478Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216478Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216478Ch case    1:*/		return 0x82164790;
		  /* 82164790h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82164790h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164790h case    2:*/		return 0x82164794;
		  /* 82164794h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82164794h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82164794h case    3:*/		return 0x82164798;
		  /* 82164798h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164798h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164798h case    4:*/		return 0x8216479C;
		  /* 8216479Ch */ case    5:  		/* mr R31, R3 */
		/* 8216479Ch case    5:*/		regs.R31 = regs.R3;
		/* 8216479Ch case    5:*/		return 0x821647A0;
		  /* 821647A0h */ case    6:  		/* mr R3, R4 */
		/* 821647A0h case    6:*/		regs.R3 = regs.R4;
		/* 821647A0h case    6:*/		return 0x821647A4;
		  /* 821647A4h */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821647A4h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821647A4h case    7:*/		return 0x821647A8;
		  /* 821647A8h */ case    8:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821647A8h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821647A8h case    8:*/		return 0x821647AC;
		  /* 821647ACh */ case    9:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821647ACh case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821647ACh case    9:*/		return 0x821647B0;
		  /* 821647B0h */ case   10:  		/* bl -896 */
		/* 821647B0h case   10:*/		regs.LR = 0x821647B4; return 0x82164430;
		/* 821647B0h case   10:*/		return 0x821647B4;
		  /* 821647B4h */ case   11:  		/* addi R11, R31, -16 */
		/* 821647B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821647B4h case   11:*/		return 0x821647B8;
		  /* 821647B8h */ case   12:  		/* add R11, R3, R11 */
		/* 821647B8h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821647B8h case   12:*/		return 0x821647BC;
		  /* 821647BCh */ case   13:  		/* li R3, 7 */
		/* 821647BCh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x7);
		/* 821647BCh case   13:*/		return 0x821647C0;
		  /* 821647C0h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 821647C0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821647C0h case   14:*/		return 0x821647C4;
		  /* 821647C4h */ case   15:  		/* rlwinm. R10, R11, 0, 30, 31 */
		/* 821647C4h case   15:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R11);
		/* 821647C4h case   15:*/		return 0x821647C8;
	}
	return 0x821647C8;
} // Block from 82164788h-821647C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821647C8h
// Function '?EnumerateConstantTableDefaults@XGRAPHICS@@YAJPBXPAXKP6AJ1PBDKW4_D3DXREGISTER_SET@@K0@Z@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821647C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821647C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821647C8);
		  /* 821647C8h */ case    0:  		/* bc 4, CR0_EQ, 8 */
		/* 821647C8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x821647D0;  }
		/* 821647C8h case    0:*/		return 0x821647CC;
		  /* 821647CCh */ case    1:  		/* rlwinm R3, R11, 30, 28, 31 */
		/* 821647CCh case    1:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R3,regs.R11);
		/* 821647CCh case    1:*/		return 0x821647D0;
	}
	return 0x821647D0;
} // Block from 821647C8h-821647D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821647D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821647D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821647D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821647D0);
		  /* 821647D0h */ case    0:  		/* addi R1, R1, 96 */
		/* 821647D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821647D0h case    0:*/		return 0x821647D4;
		  /* 821647D4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821647D4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821647D4h case    1:*/		return 0x821647D8;
		  /* 821647D8h */ case    2:  		/* mtspr LR, R12 */
		/* 821647D8h case    2:*/		regs.LR = regs.R12;
		/* 821647D8h case    2:*/		return 0x821647DC;
		  /* 821647DCh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821647DCh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821647DCh case    3:*/		return 0x821647E0;
		  /* 821647E0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821647E0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821647E0h case    4:*/		return 0x821647E4;
	}
	return 0x821647E4;
} // Block from 821647D0h-821647E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821647E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821647E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821647E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821647E4);
		  /* 821647E4h */ case    0:  		/* nop */
		/* 821647E4h case    0:*/		cpu::op::nop();
		/* 821647E4h case    0:*/		return 0x821647E8;
	}
	return 0x821647E8;
} // Block from 821647E4h-821647E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821647E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821647E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821647E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821647E8);
		  /* 821647E8h */ case    0:  		/* mfspr R12, LR */
		/* 821647E8h case    0:*/		regs.R12 = regs.LR;
		/* 821647E8h case    0:*/		return 0x821647EC;
		  /* 821647ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821647ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821647ECh case    1:*/		return 0x821647F0;
		  /* 821647F0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821647F0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821647F0h case    2:*/		return 0x821647F4;
		  /* 821647F4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821647F4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821647F4h case    3:*/		return 0x821647F8;
		  /* 821647F8h */ case    4:  		/* mr R31, R3 */
		/* 821647F8h case    4:*/		regs.R31 = regs.R3;
		/* 821647F8h case    4:*/		return 0x821647FC;
		  /* 821647FCh */ case    5:  		/* mr R3, R4 */
		/* 821647FCh case    5:*/		regs.R3 = regs.R4;
		/* 821647FCh case    5:*/		return 0x82164800;
		  /* 82164800h */ case    6:  		/* li R6, 0 */
		/* 82164800h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82164800h case    6:*/		return 0x82164804;
		  /* 82164804h */ case    7:  		/* li R5, 0 */
		/* 82164804h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82164804h case    7:*/		return 0x82164808;
		  /* 82164808h */ case    8:  		/* li R4, 84 */
		/* 82164808h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x54);
		/* 82164808h case    8:*/		return 0x8216480C;
		  /* 8216480Ch */ case    9:  		/* bl -988 */
		/* 8216480Ch case    9:*/		regs.LR = 0x82164810; return 0x82164430;
		/* 8216480Ch case    9:*/		return 0x82164810;
		  /* 82164810h */ case   10:  		/* addi R11, R31, -32 */
		/* 82164810h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFE0);
		/* 82164810h case   10:*/		return 0x82164814;
		  /* 82164814h */ case   11:  		/* add R3, R3, R11 */
		/* 82164814h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 82164814h case   11:*/		return 0x82164818;
		  /* 82164818h */ case   12:  		/* addi R1, R1, 96 */
		/* 82164818h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82164818h case   12:*/		return 0x8216481C;
		  /* 8216481Ch */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216481Ch case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216481Ch case   13:*/		return 0x82164820;
		  /* 82164820h */ case   14:  		/* mtspr LR, R12 */
		/* 82164820h case   14:*/		regs.LR = regs.R12;
		/* 82164820h case   14:*/		return 0x82164824;
		  /* 82164824h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82164824h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164824h case   15:*/		return 0x82164828;
		  /* 82164828h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82164828h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164828h case   16:*/		return 0x8216482C;
	}
	return 0x8216482C;
} // Block from 821647E8h-8216482Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216482Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216482C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216482C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216482C);
		  /* 8216482Ch */ case    0:  		/* nop */
		/* 8216482Ch case    0:*/		cpu::op::nop();
		/* 8216482Ch case    0:*/		return 0x82164830;
		  /* 82164830h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82164830h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82164830h case    1:*/		return 0x82164834;
		  /* 82164834h */ case    2:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82164834h case    2:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82164834h case    2:*/		return 0x82164838;
		  /* 82164838h */ case    3:  		/* bc 12, CR0_EQ, 64 */
		/* 82164838h case    3:*/		if ( regs.CR[0].eq ) { return 0x82164878;  }
		/* 82164838h case    3:*/		return 0x8216483C;
		  /* 8216483Ch */ case    4:  		/* lwz R10, <#[R3 + 12]> */
		/* 8216483Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8216483Ch case    4:*/		return 0x82164840;
		  /* 82164840h */ case    5:  		/* lwz R11, <#[R10 + 8]> */
		/* 82164840h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82164840h case    5:*/		return 0x82164844;
		  /* 82164844h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82164844h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82164844h case    6:*/		return 0x82164848;
		  /* 82164848h */ case    7:  		/* cmplwi CR6, R11, 125 */
		/* 82164848h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82164848h case    7:*/		return 0x8216484C;
		  /* 8216484Ch */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8216484Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8216485C;  }
		/* 8216484Ch case    8:*/		return 0x82164850;
		  /* 82164850h */ case    9:  		/* cmplwi CR6, R11, 124 */
		/* 82164850h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82164850h case    9:*/		return 0x82164854;
		  /* 82164854h */ case   10:  		/* li R11, 0 */
		/* 82164854h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164854h case   10:*/		return 0x82164858;
		  /* 82164858h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 82164858h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82164860;  }
		/* 82164858h case   11:*/		return 0x8216485C;
	}
	return 0x8216485C;
} // Block from 8216482Ch-8216485Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216485Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216485C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216485C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216485C);
		  /* 8216485Ch */ case    0:  		/* li R11, 1 */
		/* 8216485Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216485Ch case    0:*/		return 0x82164860;
	}
	return 0x82164860;
} // Block from 8216485Ch-82164860h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164860);
		  /* 82164860h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82164860h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82164860h case    0:*/		return 0x82164864;
		  /* 82164864h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 82164864h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82164878;  }
		/* 82164864h case    1:*/		return 0x82164868;
		  /* 82164868h */ case    2:  		/* lwz R11, <#[R10 + 8]> */
		/* 82164868h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82164868h case    2:*/		return 0x8216486C;
		  /* 8216486Ch */ case    3:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8216486Ch case    3:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8216486Ch case    3:*/		return 0x82164870;
		  /* 82164870h */ case    4:  		/* li R11, 1 */
		/* 82164870h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164870h case    4:*/		return 0x82164874;
		  /* 82164874h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82164874h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216487C;  }
		/* 82164874h case    5:*/		return 0x82164878;
	}
	return 0x82164878;
} // Block from 82164860h-82164878h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164878);
		  /* 82164878h */ case    0:  		/* li R11, 0 */
		/* 82164878h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164878h case    0:*/		return 0x8216487C;
	}
	return 0x8216487C;
} // Block from 82164878h-8216487Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216487Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216487C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216487C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216487C);
		  /* 8216487Ch */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8216487Ch case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8216487Ch case    0:*/		return 0x82164880;
		  /* 82164880h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164880h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164880h case    1:*/		return 0x82164884;
	}
	return 0x82164884;
} // Block from 8216487Ch-82164884h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164884);
		  /* 82164884h */ case    0:  		/* nop */
		/* 82164884h case    0:*/		cpu::op::nop();
		/* 82164884h case    0:*/		return 0x82164888;
		  /* 82164888h */ case    1:  		/* lwz R9, <#[R4 + 140]> */
		/* 82164888h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000008C) );
		/* 82164888h case    1:*/		return 0x8216488C;
		  /* 8216488Ch */ case    2:  		/* mr R10, R4 */
		/* 8216488Ch case    2:*/		regs.R10 = regs.R4;
		/* 8216488Ch case    2:*/		return 0x82164890;
		  /* 82164890h */ case    3:  		/* lwz R11, <#[R4 + 144]> */
		/* 82164890h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000090) );
		/* 82164890h case    3:*/		return 0x82164894;
		  /* 82164894h */ case    4:  		/* subf R9, R11, R9 */
		/* 82164894h case    4:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82164894h case    4:*/		return 0x82164898;
		  /* 82164898h */ case    5:  		/* addi R9, R9, 4096 */
		/* 82164898h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 82164898h case    5:*/		return 0x8216489C;
		  /* 8216489Ch */ case    6:  		/* cmplwi CR6, R9, 16 */
		/* 8216489Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000010);
		/* 8216489Ch case    6:*/		return 0x821648A0;
		  /* 821648A0h */ case    7:  		/* bc 12, CR6_LT, 20 */
		/* 821648A0h case    7:*/		if ( regs.CR[6].lt ) { return 0x821648B4;  }
		/* 821648A0h case    7:*/		return 0x821648A4;
		  /* 821648A4h */ case    8:  		/* addi R9, R11, 16 */
		/* 821648A4h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 821648A4h case    8:*/		return 0x821648A8;
		  /* 821648A8h */ case    9:  		/* mr R3, R11 */
		/* 821648A8h case    9:*/		regs.R3 = regs.R11;
		/* 821648A8h case    9:*/		return 0x821648AC;
		  /* 821648ACh */ case   10:  		/* stw R9, <#[R4 + 144]> */
		/* 821648ACh case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000090) );
		/* 821648ACh case   10:*/		return 0x821648B0;
		  /* 821648B0h */ case   11:  		/* bclr 20, CR0_LT */
		/* 821648B0h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821648B0h case   11:*/		return 0x821648B4;
	}
	return 0x821648B4;
} // Block from 82164884h-821648B4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821648B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821648B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821648B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821648B4);
		  /* 821648B4h */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 821648B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 821648B4h case    0:*/		return 0x821648B8;
		  /* 821648B8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821648B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821648B8h case    1:*/		return 0x821648BC;
		  /* 821648BCh */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 821648BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821648E4;  }
		/* 821648BCh case    2:*/		return 0x821648C0;
		  /* 821648C0h */ case    3:  		/* lwz R8, <#[R11]> */
		/* 821648C0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821648C0h case    3:*/		return 0x821648C4;
		  /* 821648C4h */ case    4:  		/* li R9, 0 */
		/* 821648C4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821648C4h case    4:*/		return 0x821648C8;
		  /* 821648C8h */ case    5:  		/* mr R3, R11 */
		/* 821648C8h case    5:*/		regs.R3 = regs.R11;
		/* 821648C8h case    5:*/		return 0x821648CC;
		  /* 821648CCh */ case    6:  		/* stw R8, <#[R10 + 12]> */
		/* 821648CCh case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 821648CCh case    6:*/		return 0x821648D0;
		  /* 821648D0h */ case    7:  		/* stw R9, <#[R11]> */
		/* 821648D0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821648D0h case    7:*/		return 0x821648D4;
		  /* 821648D4h */ case    8:  		/* stw R9, <#[R11 + 4]> */
		/* 821648D4h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821648D4h case    8:*/		return 0x821648D8;
		  /* 821648D8h */ case    9:  		/* stw R9, <#[R11 + 8]> */
		/* 821648D8h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821648D8h case    9:*/		return 0x821648DC;
		  /* 821648DCh */ case   10:  		/* stw R9, <#[R11 + 12]> */
		/* 821648DCh case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821648DCh case   10:*/		return 0x821648E0;
		  /* 821648E0h */ case   11:  		/* bclr 20, CR0_LT */
		/* 821648E0h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821648E0h case   11:*/		return 0x821648E4;
	}
	return 0x821648E4;
} // Block from 821648B4h-821648E4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821648E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821648E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821648E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821648E4);
		  /* 821648E4h */ case    0:  		/* li R4, 16 */
		/* 821648E4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 821648E4h case    0:*/		return 0x821648E8;
		  /* 821648E8h */ case    1:  		/* mr R3, R10 */
		/* 821648E8h case    1:*/		regs.R3 = regs.R10;
		/* 821648E8h case    1:*/		return 0x821648EC;
		  /* 821648ECh */ case    2:  		/* b -764 */
		/* 821648ECh case    2:*/		return 0x821645F0;
		/* 821648ECh case    2:*/		return 0x821648F0;
	}
	return 0x821648F0;
} // Block from 821648E4h-821648F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821648F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821648F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821648F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821648F0);
		  /* 821648F0h */ case    0:  		/* mfspr R12, LR */
		/* 821648F0h case    0:*/		regs.R12 = regs.LR;
		/* 821648F0h case    0:*/		return 0x821648F4;
		  /* 821648F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821648F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821648F4h case    1:*/		return 0x821648F8;
		  /* 821648F8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821648F8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821648F8h case    2:*/		return 0x821648FC;
		  /* 821648FCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821648FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821648FCh case    3:*/		return 0x82164900;
		  /* 82164900h */ case    4:  		/* lwz R9, <#[R3 + 1112]> */
		/* 82164900h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000458) );
		/* 82164900h case    4:*/		return 0x82164904;
		  /* 82164904h */ case    5:  		/* addi R11, R3, 972 */
		/* 82164904h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3CC);
		/* 82164904h case    5:*/		return 0x82164908;
		  /* 82164908h */ case    6:  		/* lwz R10, <#[R3 + 1116]> */
		/* 82164908h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000045C) );
		/* 82164908h case    6:*/		return 0x8216490C;
		  /* 8216490Ch */ case    7:  		/* subf R9, R10, R9 */
		/* 8216490Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8216490Ch case    7:*/		return 0x82164910;
		  /* 82164910h */ case    8:  		/* addi R9, R9, 4096 */
		/* 82164910h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 82164910h case    8:*/		return 0x82164914;
		  /* 82164914h */ case    9:  		/* cmplw CR6, R9, R4 */
		/* 82164914h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82164914h case    9:*/		return 0x82164918;
		  /* 82164918h */ case   10:  		/* bc 12, CR6_LT, 20 */
		/* 82164918h case   10:*/		if ( regs.CR[6].lt ) { return 0x8216492C;  }
		/* 82164918h case   10:*/		return 0x8216491C;
		  /* 8216491Ch */ case   11:  		/* add R9, R10, R4 */
		/* 8216491Ch case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 8216491Ch case   11:*/		return 0x82164920;
		  /* 82164920h */ case   12:  		/* mr R3, R10 */
		/* 82164920h case   12:*/		regs.R3 = regs.R10;
		/* 82164920h case   12:*/		return 0x82164924;
		  /* 82164924h */ case   13:  		/* stw R9, <#[R11 + 144]> */
		/* 82164924h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 82164924h case   13:*/		return 0x82164928;
		  /* 82164928h */ case   14:  		/* b 68 */
		/* 82164928h case   14:*/		return 0x8216496C;
		/* 82164928h case   14:*/		return 0x8216492C;
	}
	return 0x8216492C;
} // Block from 821648F0h-8216492Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216492Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216492C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216492C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216492C);
		  /* 8216492Ch */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 8216492Ch case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 8216492Ch case    0:*/		return 0x82164930;
		  /* 82164930h */ case    1:  		/* addi R10, R10, -1 */
		/* 82164930h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82164930h case    1:*/		return 0x82164934;
		  /* 82164934h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82164934h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82164934h case    2:*/		return 0x82164938;
		  /* 82164938h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82164938h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82164938h case    3:*/		return 0x8216493C;
		  /* 8216493Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216493Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216493Ch case    4:*/		return 0x82164940;
		  /* 82164940h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82164940h case    5:*/		if ( regs.CR[6].eq ) { return 0x82164964;  }
		/* 82164940h case    5:*/		return 0x82164944;
		  /* 82164944h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82164944h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82164944h case    6:*/		return 0x82164948;
		  /* 82164948h */ case    7:  		/* mr R5, R4 */
		/* 82164948h case    7:*/		regs.R5 = regs.R4;
		/* 82164948h case    7:*/		return 0x8216494C;
		  /* 8216494Ch */ case    8:  		/* li R4, 0 */
		/* 8216494Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216494Ch case    8:*/		return 0x82164950;
		  /* 82164950h */ case    9:  		/* mr R3, R31 */
		/* 82164950h case    9:*/		regs.R3 = regs.R31;
		/* 82164950h case    9:*/		return 0x82164954;
		  /* 82164954h */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 82164954h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82164954h case   10:*/		return 0x82164958;
		  /* 82164958h */ case   11:  		/* bl -865816 */
		/* 82164958h case   11:*/		regs.LR = 0x8216495C; return 0x82091340;
		/* 82164958h case   11:*/		return 0x8216495C;
		  /* 8216495Ch */ case   12:  		/* mr R3, R31 */
		/* 8216495Ch case   12:*/		regs.R3 = regs.R31;
		/* 8216495Ch case   12:*/		return 0x82164960;
		  /* 82164960h */ case   13:  		/* b 12 */
		/* 82164960h case   13:*/		return 0x8216496C;
		/* 82164960h case   13:*/		return 0x82164964;
	}
	return 0x82164964;
} // Block from 8216492Ch-82164964h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82164964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164964);
		  /* 82164964h */ case    0:  		/* mr R3, R11 */
		/* 82164964h case    0:*/		regs.R3 = regs.R11;
		/* 82164964h case    0:*/		return 0x82164968;
		  /* 82164968h */ case    1:  		/* bl -888 */
		/* 82164968h case    1:*/		regs.LR = 0x8216496C; return 0x821645F0;
		/* 82164968h case    1:*/		return 0x8216496C;
	}
	return 0x8216496C;
} // Block from 82164964h-8216496Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216496Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216496C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216496C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216496C);
		  /* 8216496Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8216496Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216496Ch case    0:*/		return 0x82164970;
		  /* 82164970h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82164970h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164970h case    1:*/		return 0x82164974;
		  /* 82164974h */ case    2:  		/* mtspr LR, R12 */
		/* 82164974h case    2:*/		regs.LR = regs.R12;
		/* 82164974h case    2:*/		return 0x82164978;
		  /* 82164978h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82164978h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164978h case    3:*/		return 0x8216497C;
		  /* 8216497Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216497Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216497Ch case    4:*/		return 0x82164980;
	}
	return 0x82164980;
} // Block from 8216496Ch-82164980h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82164980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164980);
		  /* 82164980h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 82164980h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82164980h case    0:*/		return 0x82164984;
		  /* 82164984h */ case    1:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 82164984h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 82164984h case    1:*/		return 0x82164988;
		  /* 82164988h */ case    2:  		/* cmplwi CR6, R11, 83 */
		/* 82164988h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 82164988h case    2:*/		return 0x8216498C;
		  /* 8216498Ch */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8216498Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8216499C;  }
		/* 8216498Ch case    3:*/		return 0x82164990;
	}
	return 0x82164990;
} // Block from 82164980h-82164990h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82164990h
// Function 'XGEstimateIdealShaderCost'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164990);
		  /* 82164990h */ case    0:  		/* cmplwi CR6, R11, 95 */
		/* 82164990h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 82164990h case    0:*/		return 0x82164994;
		  /* 82164994h */ case    1:  		/* li R11, 1 */
		/* 82164994h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164994h case    1:*/		return 0x82164998;
		  /* 82164998h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 82164998h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821649A0;  }
		/* 82164998h case    2:*/		return 0x8216499C;
	}
	return 0x8216499C;
} // Block from 82164990h-8216499Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216499Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216499C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216499C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216499C);
		  /* 8216499Ch */ case    0:  		/* li R11, 0 */
		/* 8216499Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216499Ch case    0:*/		return 0x821649A0;
	}
	return 0x821649A0;
} // Block from 8216499Ch-821649A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821649A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821649A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821649A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821649A0);
		  /* 821649A0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821649A0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821649A0h case    0:*/		return 0x821649A4;
		  /* 821649A4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821649A4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821649B0;  }
		/* 821649A4h case    1:*/		return 0x821649A8;
		  /* 821649A8h */ case    2:  		/* li R3, 0 */
		/* 821649A8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821649A8h case    2:*/		return 0x821649AC;
		  /* 821649ACh */ case    3:  		/* bclr 20, CR0_LT */
		/* 821649ACh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821649ACh case    3:*/		return 0x821649B0;
	}
	return 0x821649B0;
} // Block from 821649A0h-821649B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821649B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821649B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821649B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821649B0);
		  /* 821649B0h */ case    0:  		/* rlwinm. R11, R10, 0, 6, 6 */
		/* 821649B0h case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R10);
		/* 821649B0h case    0:*/		return 0x821649B4;
		  /* 821649B4h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 821649B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821649D0;  }
		/* 821649B4h case    1:*/		return 0x821649B8;
		  /* 821649B8h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 821649B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821649B8h case    2:*/		return 0x821649BC;
		  /* 821649BCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821649BCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821649BCh case    3:*/		return 0x821649C0;
		  /* 821649C0h */ case    4:  		/* bc 4, CR6_EQ, -24 */
		/* 821649C0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821649A8;  }
		/* 821649C0h case    4:*/		return 0x821649C4;
		  /* 821649C4h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 821649C4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821649C4h case    5:*/		return 0x821649C8;
		  /* 821649C8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821649C8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821649C8h case    6:*/		return 0x821649CC;
		  /* 821649CCh */ case    7:  		/* bc 4, CR6_EQ, -36 */
		/* 821649CCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x821649A8;  }
		/* 821649CCh case    7:*/		return 0x821649D0;
	}
	return 0x821649D0;
} // Block from 821649B0h-821649D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821649D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821649D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821649D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821649D0);
		  /* 821649D0h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 821649D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821649D0h case    0:*/		return 0x821649D4;
		  /* 821649D4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821649D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821649D4h case    1:*/		return 0x821649D8;
		  /* 821649D8h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 821649D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821649EC;  }
		/* 821649D8h case    2:*/		return 0x821649DC;
		  /* 821649DCh */ case    3:  		/* li R3, 1 */
		/* 821649DCh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821649DCh case    3:*/		return 0x821649E0;
		  /* 821649E0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821649E0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821649E0h case    4:*/		return 0x821649E4;
	}
	return 0x821649E4;
} // Block from 821649D0h-821649E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821649E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821649E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821649E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821649E4);
		  /* 821649E4h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821649E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821649E4h case    0:*/		return 0x821649E8;
		  /* 821649E8h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 821649E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82164A24;  }
		/* 821649E8h case    1:*/		return 0x821649EC;
	}
	return 0x821649EC;
} // Block from 821649E4h-821649ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821649ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821649EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821649EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821649EC);
		  /* 821649ECh */ case    0:  		/* lwz R10, <#[R11 + 16]> */
		/* 821649ECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821649ECh case    0:*/		return 0x821649F0;
		  /* 821649F0h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821649F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821649F0h case    1:*/		return 0x821649F4;
		  /* 821649F4h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 821649F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82164A1C;  }
		/* 821649F4h case    2:*/		return 0x821649F8;
		  /* 821649F8h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 821649F8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821649F8h case    3:*/		return 0x821649FC;
		  /* 821649FCh */ case    4:  		/* rlwinm. R9, R10, 0, 1, 1 */
		/* 821649FCh case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R10);
		/* 821649FCh case    4:*/		return 0x82164A00;
		  /* 82164A00h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82164A00h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82164A10;  }
		/* 82164A00h case    5:*/		return 0x82164A04;
		  /* 82164A04h */ case    6:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82164A04h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82164A04h case    6:*/		return 0x82164A08;
		  /* 82164A08h */ case    7:  		/* li R10, 1 */
		/* 82164A08h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82164A08h case    7:*/		return 0x82164A0C;
		  /* 82164A0Ch */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82164A0Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82164A14;  }
		/* 82164A0Ch case    8:*/		return 0x82164A10;
	}
	return 0x82164A10;
} // Block from 821649ECh-82164A10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82164A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A10);
		  /* 82164A10h */ case    0:  		/* li R10, 0 */
		/* 82164A10h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82164A10h case    0:*/		return 0x82164A14;
	}
	return 0x82164A14;
} // Block from 82164A10h-82164A14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A14);
		  /* 82164A14h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82164A14h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82164A14h case    0:*/		return 0x82164A18;
		  /* 82164A18h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82164A18h case    1:*/		if ( regs.CR[0].eq ) { return 0x82164A24;  }
		/* 82164A18h case    1:*/		return 0x82164A1C;
	}
	return 0x82164A1C;
} // Block from 82164A14h-82164A1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A1C);
		  /* 82164A1Ch */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82164A1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82164A1Ch case    0:*/		return 0x82164A20;
		  /* 82164A20h */ case    1:  		/* b -60 */
		/* 82164A20h case    1:*/		return 0x821649E4;
		/* 82164A20h case    1:*/		return 0x82164A24;
	}
	return 0x82164A24;
} // Block from 82164A1Ch-82164A24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A24);
		  /* 82164A24h */ case    0:  		/* cntlzw R11, R11 */
		/* 82164A24h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82164A24h case    0:*/		return 0x82164A28;
		  /* 82164A28h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82164A28h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82164A28h case    1:*/		return 0x82164A2C;
		  /* 82164A2Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 82164A2Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164A2Ch case    2:*/		return 0x82164A30;
	}
	return 0x82164A30;
} // Block from 82164A24h-82164A30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82164A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A30);
		  /* 82164A30h */ case    0:  		/* mfspr R12, LR */
		/* 82164A30h case    0:*/		regs.R12 = regs.LR;
		/* 82164A30h case    0:*/		return 0x82164A34;
		  /* 82164A34h */ case    1:  		/* bl -866276 */
		/* 82164A34h case    1:*/		regs.LR = 0x82164A38; return 0x82091250;
		/* 82164A34h case    1:*/		return 0x82164A38;
		  /* 82164A38h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82164A38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82164A38h case    2:*/		return 0x82164A3C;
		  /* 82164A3Ch */ case    3:  		/* mr R31, R4 */
		/* 82164A3Ch case    3:*/		regs.R31 = regs.R4;
		/* 82164A3Ch case    3:*/		return 0x82164A40;
		  /* 82164A40h */ case    4:  		/* mr R27, R5 */
		/* 82164A40h case    4:*/		regs.R27 = regs.R5;
		/* 82164A40h case    4:*/		return 0x82164A44;
		  /* 82164A44h */ case    5:  		/* mr R26, R6 */
		/* 82164A44h case    5:*/		regs.R26 = regs.R6;
		/* 82164A44h case    5:*/		return 0x82164A48;
		  /* 82164A48h */ case    6:  		/* li R29, 0 */
		/* 82164A48h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82164A48h case    6:*/		return 0x82164A4C;
		  /* 82164A4Ch */ case    7:  		/* li R28, 0 */
		/* 82164A4Ch case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82164A4Ch case    7:*/		return 0x82164A50;
		  /* 82164A50h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 82164A50h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82164A50h case    8:*/		return 0x82164A54;
		  /* 82164A54h */ case    9:  		/* bc 12, CR6_EQ, 112 */
		/* 82164A54h case    9:*/		if ( regs.CR[6].eq ) { return 0x82164AC4;  }
		/* 82164A54h case    9:*/		return 0x82164A58;
		  /* 82164A58h */ case   10:  		/* lwz R11, <#[R4 + 8]> */
		/* 82164A58h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82164A58h case   10:*/		return 0x82164A5C;
		  /* 82164A5Ch */ case   11:  		/* rlwinm R30, R11, 25, 25, 31 */
		/* 82164A5Ch case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R30,regs.R11);
		/* 82164A5Ch case   11:*/		return 0x82164A60;
		  /* 82164A60h */ case   12:  		/* cmplwi CR6, R30, 96 */
		/* 82164A60h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000060);
		/* 82164A60h case   12:*/		return 0x82164A64;
		  /* 82164A64h */ case   13:  		/* bc 12, CR6_LT, 16 */
		/* 82164A64h case   13:*/		if ( regs.CR[6].lt ) { return 0x82164A74;  }
		/* 82164A64h case   13:*/		return 0x82164A68;
		  /* 82164A68h */ case   14:  		/* cmplwi CR6, R30, 102 */
		/* 82164A68h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000066);
		/* 82164A68h case   14:*/		return 0x82164A6C;
		  /* 82164A6Ch */ case   15:  		/* li R11, 1 */
		/* 82164A6Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164A6Ch case   15:*/		return 0x82164A70;
		  /* 82164A70h */ case   16:  		/* bc 4, CR6_GT, 8 */
		/* 82164A70h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82164A78;  }
		/* 82164A70h case   16:*/		return 0x82164A74;
	}
	return 0x82164A74;
} // Block from 82164A30h-82164A74h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82164A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A74);
		  /* 82164A74h */ case    0:  		/* li R11, 0 */
		/* 82164A74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164A74h case    0:*/		return 0x82164A78;
	}
	return 0x82164A78;
} // Block from 82164A74h-82164A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164A78);
		  /* 82164A78h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82164A78h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82164A78h case    0:*/		return 0x82164A7C;
		  /* 82164A7Ch */ case    1:  		/* bc 12, CR0_EQ, 72 */
		/* 82164A7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82164AC4;  }
		/* 82164A7Ch case    1:*/		return 0x82164A80;
		  /* 82164A80h */ case    2:  		/* li R29, 1 */
		/* 82164A80h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82164A80h case    2:*/		return 0x82164A84;
		  /* 82164A84h */ case    3:  		/* cmplwi CR6, R30, 96 */
		/* 82164A84h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000060);
		/* 82164A84h case    3:*/		return 0x82164A88;
		  /* 82164A88h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 82164A88h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82164AB0;  }
		/* 82164A88h case    4:*/		return 0x82164A8C;
		  /* 82164A8Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 82164A8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82164A8Ch case    5:*/		return 0x82164A90;
		  /* 82164A90h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82164A90h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82164A90h case    6:*/		return 0x82164A94;
		  /* 82164A94h */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82164A94h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82164A94h case    7:*/		return 0x82164A98;
		  /* 82164A98h */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82164A98h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82164A98h case    8:*/		return 0x82164A9C;
		  /* 82164A9Ch */ case    9:  		/* bl -1644 */
		/* 82164A9Ch case    9:*/		regs.LR = 0x82164AA0; return 0x82164430;
		/* 82164A9Ch case    9:*/		return 0x82164AA0;
		  /* 82164AA0h */ case   10:  		/* addi R11, R31, -8 */
		/* 82164AA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF8);
		/* 82164AA0h case   10:*/		return 0x82164AA4;
		  /* 82164AA4h */ case   11:  		/* lhzx R11, <#[R3 + R11]> */
		/* 82164AA4h case   11:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82164AA4h case   11:*/		return 0x82164AA8;
		  /* 82164AA8h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82164AA8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82164AA8h case   12:*/		return 0x82164AAC;
		  /* 82164AACh */ case   13:  		/* bc 4, CR0_EQ, 20 */
		/* 82164AACh case   13:*/		if ( !regs.CR[0].eq ) { return 0x82164AC0;  }
		/* 82164AACh case   13:*/		return 0x82164AB0;
	}
	return 0x82164AB0;
} // Block from 82164A78h-82164AB0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82164AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164AB0);
		  /* 82164AB0h */ case    0:  		/* cmplwi CR6, R30, 97 */
		/* 82164AB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000061);
		/* 82164AB0h case    0:*/		return 0x82164AB4;
		  /* 82164AB4h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82164AB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82164AC0;  }
		/* 82164AB4h case    1:*/		return 0x82164AB8;
		  /* 82164AB8h */ case    2:  		/* cmplwi CR6, R30, 99 */
		/* 82164AB8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000063);
		/* 82164AB8h case    2:*/		return 0x82164ABC;
		  /* 82164ABCh */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 82164ABCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82164AC4;  }
		/* 82164ABCh case    3:*/		return 0x82164AC0;
	}
	return 0x82164AC0;
} // Block from 82164AB0h-82164AC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82164AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164AC0);
		  /* 82164AC0h */ case    0:  		/* li R28, 1 */
		/* 82164AC0h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82164AC0h case    0:*/		return 0x82164AC4;
	}
	return 0x82164AC4;
} // Block from 82164AC0h-82164AC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164AC4);
		  /* 82164AC4h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 82164AC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82164AC4h case    0:*/		return 0x82164AC8;
	}
	return 0x82164AC8;
} // Block from 82164AC4h-82164AC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164AC8h
// Function '?SetsPredicate@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164AC8);
		  /* 82164AC8h */ case    0:  		/* rlwinm R10, R29, 0, 24, 31 */
		/* 82164AC8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R29);
		/* 82164AC8h case    0:*/		return 0x82164ACC;
		  /* 82164ACCh */ case    1:  		/* rlwinm R9, R28, 0, 24, 31 */
		/* 82164ACCh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R28);
		/* 82164ACCh case    1:*/		return 0x82164AD0;
		  /* 82164AD0h */ case    2:  		/* rlwimi R11, R10, 16, 15, 15 */
		/* 82164AD0h case    2:*/		cpu::op::rlwimi<0,16,15,15>(regs,&regs.R11,regs.R10);
		/* 82164AD0h case    2:*/		return 0x82164AD4;
		  /* 82164AD4h */ case    3:  		/* stw R11, <#[R27]> */
		/* 82164AD4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82164AD4h case    3:*/		return 0x82164AD8;
		  /* 82164AD8h */ case    4:  		/* lwz R11, <#[R26]> */
		/* 82164AD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82164AD8h case    4:*/		return 0x82164ADC;
		  /* 82164ADCh */ case    5:  		/* rlwimi R11, R9, 18, 13, 13 */
		/* 82164ADCh case    5:*/		cpu::op::rlwimi<0,18,13,13>(regs,&regs.R11,regs.R9);
		/* 82164ADCh case    5:*/		return 0x82164AE0;
		  /* 82164AE0h */ case    6:  		/* stw R11, <#[R26]> */
		/* 82164AE0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82164AE0h case    6:*/		return 0x82164AE4;
		  /* 82164AE4h */ case    7:  		/* addi R1, R1, 144 */
		/* 82164AE4h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82164AE4h case    7:*/		return 0x82164AE8;
		  /* 82164AE8h */ case    8:  		/* b -866376 */
		/* 82164AE8h case    8:*/		return 0x820912A0;
		/* 82164AE8h case    8:*/		return 0x82164AEC;
		  /* 82164AECh */ case    9:  		/* nop */
		/* 82164AECh case    9:*/		cpu::op::nop();
		/* 82164AECh case    9:*/		return 0x82164AF0;
	}
	return 0x82164AF0;
} // Block from 82164AC8h-82164AF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82164AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164AF0);
		  /* 82164AF0h */ case    0:  		/* mfspr R12, LR */
		/* 82164AF0h case    0:*/		regs.R12 = regs.LR;
		/* 82164AF0h case    0:*/		return 0x82164AF4;
		  /* 82164AF4h */ case    1:  		/* bl -866464 */
		/* 82164AF4h case    1:*/		regs.LR = 0x82164AF8; return 0x82091254;
		/* 82164AF4h case    1:*/		return 0x82164AF8;
		  /* 82164AF8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82164AF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82164AF8h case    2:*/		return 0x82164AFC;
		  /* 82164AFCh */ case    3:  		/* mr R31, R3 */
		/* 82164AFCh case    3:*/		regs.R31 = regs.R3;
		/* 82164AFCh case    3:*/		return 0x82164B00;
		  /* 82164B00h */ case    4:  		/* mr R30, R4 */
		/* 82164B00h case    4:*/		regs.R30 = regs.R4;
		/* 82164B00h case    4:*/		return 0x82164B04;
		  /* 82164B04h */ case    5:  		/* mr R27, R5 */
		/* 82164B04h case    5:*/		regs.R27 = regs.R5;
		/* 82164B04h case    5:*/		return 0x82164B08;
		  /* 82164B08h */ case    6:  		/* mr R28, R7 */
		/* 82164B08h case    6:*/		regs.R28 = regs.R7;
		/* 82164B08h case    6:*/		return 0x82164B0C;
		  /* 82164B0Ch */ case    7:  		/* li R29, 1 */
		/* 82164B0Ch case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82164B0Ch case    7:*/		return 0x82164B10;
		  /* 82164B10h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 82164B10h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82164B10h case    8:*/		return 0x82164B14;
		  /* 82164B14h */ case    9:  		/* bc 4, CR6_EQ, 52 */
		/* 82164B14h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82164B48;  }
		/* 82164B14h case    9:*/		return 0x82164B18;
	}
	return 0x82164B18;
} // Block from 82164AF0h-82164B18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82164B18h
// Function '?SetsAddress@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164B18);
		  /* 82164B18h */ case    0:  		/* addi R4, R4, -1 */
		/* 82164B18h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82164B18h case    0:*/		return 0x82164B1C;
		  /* 82164B1Ch */ case    1:  		/* lwz R3, <#[R3 + 768]> */
		/* 82164B1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000300) );
		/* 82164B1Ch case    1:*/		return 0x82164B20;
		  /* 82164B20h */ case    2:  		/* bl -1026176 */
		/* 82164B20h case    2:*/		regs.LR = 0x82164B24; return 0x8206A2A0;
		/* 82164B20h case    2:*/		return 0x82164B24;
		  /* 82164B24h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82164B24h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82164B24h case    3:*/		return 0x82164B28;
		  /* 82164B28h */ case    4:  		/* rlwinm R10, R11, 0, 16, 19 */
		/* 82164B28h case    4:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R10,regs.R11);
		/* 82164B28h case    4:*/		return 0x82164B2C;
		  /* 82164B2Ch */ case    5:  		/* cmplwi CR6, R10, 20480 */
		/* 82164B2Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00005000);
		/* 82164B2Ch case    5:*/		return 0x82164B30;
		  /* 82164B30h */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 82164B30h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82164B44;  }
		/* 82164B30h case    6:*/		return 0x82164B34;
		  /* 82164B34h */ case    7:  		/* rlwinm R11, R11, 22, 31, 31 */
		/* 82164B34h case    7:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R11,regs.R11);
		/* 82164B34h case    7:*/		return 0x82164B38;
		  /* 82164B38h */ case    8:  		/* rlwinm R10, R28, 0, 24, 31 */
		/* 82164B38h case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R28);
		/* 82164B38h case    8:*/		return 0x82164B3C;
		  /* 82164B3Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 82164B3Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82164B3Ch case    9:*/		return 0x82164B40;
		  /* 82164B40h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 82164B40h case   10:*/		if ( regs.CR[6].eq ) { return 0x82164B48;  }
		/* 82164B40h case   10:*/		return 0x82164B44;
	}
	return 0x82164B44;
} // Block from 82164B18h-82164B44h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82164B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164B44);
		  /* 82164B44h */ case    0:  		/* li R27, 1 */
		/* 82164B44h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82164B44h case    0:*/		return 0x82164B48;
	}
	return 0x82164B48;
} // Block from 82164B44h-82164B48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164B48);
		  /* 82164B48h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82164B48h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82164B48h case    0:*/		return 0x82164B4C;
		  /* 82164B4Ch */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 82164B4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82164B70;  }
		/* 82164B4Ch case    1:*/		return 0x82164B50;
		  /* 82164B50h */ case    2:  		/* mr R4, R30 */
		/* 82164B50h case    2:*/		regs.R4 = regs.R30;
		/* 82164B50h case    2:*/		return 0x82164B54;
		  /* 82164B54h */ case    3:  		/* lwz R3, <#[R31 + 768]> */
		/* 82164B54h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000300) );
		/* 82164B54h case    3:*/		return 0x82164B58;
	}
	return 0x82164B58;
} // Block from 82164B48h-82164B58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82164B58h
// Function '?IsPredicateStackOp@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164B58);
		  /* 82164B58h */ case    0:  		/* bl -1026232 */
		/* 82164B58h case    0:*/		regs.LR = 0x82164B5C; return 0x8206A2A0;
		/* 82164B58h case    0:*/		return 0x82164B5C;
		  /* 82164B5Ch */ case    1:  		/* lhz R11, <#[R3]> */
		/* 82164B5Ch case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82164B5Ch case    1:*/		return 0x82164B60;
		  /* 82164B60h */ case    2:  		/* andi. R11, R11, 2730 */
		/* 82164B60h case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xAAA);
		/* 82164B60h case    2:*/		return 0x82164B64;
		  /* 82164B64h */ case    3:  		/* addic R11, R11, -1 */
		/* 82164B64h case    3:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82164B64h case    3:*/		return 0x82164B68;
		  /* 82164B68h */ case    4:  		/* subfe R11, R11, R11 */
		/* 82164B68h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82164B68h case    4:*/		return 0x82164B6C;
		  /* 82164B6Ch */ case    5:  		/* and R29, R11, R29 */
		/* 82164B6Ch case    5:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 82164B6Ch case    5:*/		return 0x82164B70;
	}
	return 0x82164B70;
} // Block from 82164B58h-82164B70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164B70);
		  /* 82164B70h */ case    0:  		/* mr R3, R29 */
		/* 82164B70h case    0:*/		regs.R3 = regs.R29;
		/* 82164B70h case    0:*/		return 0x82164B74;
		  /* 82164B74h */ case    1:  		/* addi R1, R1, 128 */
		/* 82164B74h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82164B74h case    1:*/		return 0x82164B78;
		  /* 82164B78h */ case    2:  		/* b -866516 */
		/* 82164B78h case    2:*/		return 0x820912A4;
		/* 82164B78h case    2:*/		return 0x82164B7C;
		  /* 82164B7Ch */ case    3:  		/* nop */
		/* 82164B7Ch case    3:*/		cpu::op::nop();
		/* 82164B7Ch case    3:*/		return 0x82164B80;
	}
	return 0x82164B80;
} // Block from 82164B70h-82164B80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82164B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164B80);
		  /* 82164B80h */ case    0:  		/* mfspr R12, LR */
		/* 82164B80h case    0:*/		regs.R12 = regs.LR;
		/* 82164B80h case    0:*/		return 0x82164B84;
		  /* 82164B84h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82164B84h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164B84h case    1:*/		return 0x82164B88;
		  /* 82164B88h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82164B88h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164B88h case    2:*/		return 0x82164B8C;
		  /* 82164B8Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82164B8Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82164B8Ch case    3:*/		return 0x82164B90;
		  /* 82164B90h */ case    4:  		/* lwz R3, <#[R3 + 768]> */
		/* 82164B90h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000300) );
		/* 82164B90h case    4:*/		return 0x82164B94;
		  /* 82164B94h */ case    5:  		/* mr R31, R5 */
		/* 82164B94h case    5:*/		regs.R31 = regs.R5;
		/* 82164B94h case    5:*/		return 0x82164B98;
		  /* 82164B98h */ case    6:  		/* bl -1026296 */
		/* 82164B98h case    6:*/		regs.LR = 0x82164B9C; return 0x8206A2A0;
		/* 82164B98h case    6:*/		return 0x82164B9C;
		  /* 82164B9Ch */ case    7:  		/* lis R12, -1 */
		/* 82164B9Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFFF);
		/* 82164B9Ch case    7:*/		return 0x82164BA0;
		  /* 82164BA0h */ case    8:  		/* lwz R10, <#[R3 + 4]> */
		/* 82164BA0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82164BA0h case    8:*/		return 0x82164BA4;
		  /* 82164BA4h */ case    9:  		/* li R11, 20480 */
		/* 82164BA4h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x5000);
		/* 82164BA4h case    9:*/		return 0x82164BA8;
		  /* 82164BA8h */ case   10:  		/* ori R12, R12, 23551 */
		/* 82164BA8h case   10:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x5BFF);
		/* 82164BA8h case   10:*/		return 0x82164BAC;
		  /* 82164BACh */ case   11:  		/* rlwimi R11, R31, 10, 21, 21 */
		/* 82164BACh case   11:*/		cpu::op::rlwimi<0,10,21,21>(regs,&regs.R11,regs.R31);
		/* 82164BACh case   11:*/		return 0x82164BB0;
	}
	return 0x82164BB0;
} // Block from 82164B80h-82164BB0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82164BB0h
// Function '?ShouldBeEncodedInExecBlock@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164BB0);
		  /* 82164BB0h */ case    0:  		/* and R10, R10, R12 */
		/* 82164BB0h case    0:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82164BB0h case    0:*/		return 0x82164BB4;
		  /* 82164BB4h */ case    1:  		/* or R11, R11, R10 */
		/* 82164BB4h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82164BB4h case    1:*/		return 0x82164BB8;
		  /* 82164BB8h */ case    2:  		/* stw R11, <#[R3 + 4]> */
		/* 82164BB8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82164BB8h case    2:*/		return 0x82164BBC;
		  /* 82164BBCh */ case    3:  		/* addi R1, R1, 96 */
		/* 82164BBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82164BBCh case    3:*/		return 0x82164BC0;
		  /* 82164BC0h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82164BC0h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164BC0h case    4:*/		return 0x82164BC4;
		  /* 82164BC4h */ case    5:  		/* mtspr LR, R12 */
		/* 82164BC4h case    5:*/		regs.LR = regs.R12;
		/* 82164BC4h case    5:*/		return 0x82164BC8;
		  /* 82164BC8h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82164BC8h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164BC8h case    6:*/		return 0x82164BCC;
		  /* 82164BCCh */ case    7:  		/* bclr 20, CR0_LT */
		/* 82164BCCh case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164BCCh case    7:*/		return 0x82164BD0;
	}
	return 0x82164BD0;
} // Block from 82164BB0h-82164BD0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82164BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164BD0);
		  /* 82164BD0h */ case    0:  		/* mfspr R12, LR */
		/* 82164BD0h case    0:*/		regs.R12 = regs.LR;
		/* 82164BD0h case    0:*/		return 0x82164BD4;
		  /* 82164BD4h */ case    1:  		/* bl -866688 */
		/* 82164BD4h case    1:*/		regs.LR = 0x82164BD8; return 0x82091254;
		/* 82164BD4h case    1:*/		return 0x82164BD8;
		  /* 82164BD8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82164BD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82164BD8h case    2:*/		return 0x82164BDC;
		  /* 82164BDCh */ case    3:  		/* mr R27, R3 */
		/* 82164BDCh case    3:*/		regs.R27 = regs.R3;
		/* 82164BDCh case    3:*/		return 0x82164BE0;
		  /* 82164BE0h */ case    4:  		/* lwz R3, <#[R3 + 768]> */
		/* 82164BE0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000300) );
		/* 82164BE0h case    4:*/		return 0x82164BE4;
		  /* 82164BE4h */ case    5:  		/* mr R30, R4 */
		/* 82164BE4h case    5:*/		regs.R30 = regs.R4;
		/* 82164BE4h case    5:*/		return 0x82164BE8;
		  /* 82164BE8h */ case    6:  		/* mr R29, R5 */
		/* 82164BE8h case    6:*/		regs.R29 = regs.R5;
		/* 82164BE8h case    6:*/		return 0x82164BEC;
		  /* 82164BECh */ case    7:  		/* bl -1026380 */
		/* 82164BECh case    7:*/		regs.LR = 0x82164BF0; return 0x8206A2A0;
		/* 82164BECh case    7:*/		return 0x82164BF0;
		  /* 82164BF0h */ case    8:  		/* addi R31, R30, 1 */
		/* 82164BF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0x1);
		/* 82164BF0h case    8:*/		return 0x82164BF4;
		  /* 82164BF4h */ case    9:  		/* mr R28, R3 */
		/* 82164BF4h case    9:*/		regs.R28 = regs.R3;
		/* 82164BF4h case    9:*/		return 0x82164BF8;
		  /* 82164BF8h */ case   10:  		/* cmplw CR6, R31, R29 */
		/* 82164BF8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82164BF8h case   10:*/		return 0x82164BFC;
		  /* 82164BFCh */ case   11:  		/* bc 12, CR6_GT, 144 */
		/* 82164BFCh case   11:*/		if ( regs.CR[6].gt ) { return 0x82164C8C;  }
		/* 82164BFCh case   11:*/		return 0x82164C00;
		  /* 82164C00h */ case   12:  		/* mr R4, R31 */
		/* 82164C00h case   12:*/		regs.R4 = regs.R31;
		/* 82164C00h case   12:*/		return 0x82164C04;
		  /* 82164C04h */ case   13:  		/* lwz R3, <#[R27 + 768]> */
		/* 82164C04h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000300) );
		/* 82164C04h case   13:*/		return 0x82164C08;
		  /* 82164C08h */ case   14:  		/* bl -1026408 */
		/* 82164C08h case   14:*/		regs.LR = 0x82164C0C; return 0x8206A2A0;
		/* 82164C08h case   14:*/		return 0x82164C0C;
		  /* 82164C0Ch */ case   15:  		/* lwz R11, <#[R28 + 4]> */
		/* 82164C0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82164C0Ch case   15:*/		return 0x82164C10;
	}
	return 0x82164C10;
} // Block from 82164BD0h-82164C10h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82164C10h
// Function '?HasControlTransferInfo@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164C10);
		  /* 82164C10h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 82164C10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82164C10h case    0:*/		return 0x82164C14;
		  /* 82164C14h */ case    1:  		/* rlwinm R9, R11, 20, 28, 31 */
		/* 82164C14h case    1:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R9,regs.R11);
		/* 82164C14h case    1:*/		return 0x82164C18;
		  /* 82164C18h */ case    2:  		/* rlwinm R11, R10, 20, 28, 31 */
		/* 82164C18h case    2:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R10);
		/* 82164C18h case    2:*/		return 0x82164C1C;
		  /* 82164C1Ch */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 82164C1Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82164C1Ch case    3:*/		return 0x82164C20;
		  /* 82164C20h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82164C20h case    4:*/		if ( regs.CR[6].eq ) { return 0x82164C34;  }
		/* 82164C20h case    4:*/		return 0x82164C24;
		  /* 82164C24h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 82164C24h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82164C24h case    5:*/		return 0x82164C28;
		  /* 82164C28h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82164C28h case    6:*/		if ( regs.CR[6].eq ) { return 0x82164C40;  }
		/* 82164C28h case    6:*/		return 0x82164C2C;
		  /* 82164C2Ch */ case    7:  		/* cmplwi CR6, R11, 5 */
		/* 82164C2Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82164C2Ch case    7:*/		return 0x82164C30;
		  /* 82164C30h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82164C30h case    8:*/		if ( regs.CR[6].eq ) { return 0x82164C40;  }
		/* 82164C30h case    8:*/		return 0x82164C34;
	}
	return 0x82164C34;
} // Block from 82164C10h-82164C34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82164C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164C34);
		  /* 82164C34h */ case    0:  		/* addi R31, R31, 1 */
		/* 82164C34h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82164C34h case    0:*/		return 0x82164C38;
		  /* 82164C38h */ case    1:  		/* cmplw CR6, R31, R29 */
		/* 82164C38h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82164C38h case    1:*/		return 0x82164C3C;
		  /* 82164C3Ch */ case    2:  		/* bc 4, CR6_GT, -60 */
		/* 82164C3Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x82164C00;  }
		/* 82164C3Ch case    2:*/		return 0x82164C40;
	}
	return 0x82164C40;
} // Block from 82164C34h-82164C40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82164C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164C40);
		  /* 82164C40h */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 82164C40h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82164C40h case    0:*/		return 0x82164C44;
		  /* 82164C44h */ case    1:  		/* bc 12, CR6_GT, 72 */
		/* 82164C44h case    1:*/		if ( regs.CR[6].gt ) { return 0x82164C8C;  }
		/* 82164C44h case    1:*/		return 0x82164C48;
		  /* 82164C48h */ case    2:  		/* mr R31, R30 */
		/* 82164C48h case    2:*/		regs.R31 = regs.R30;
		/* 82164C48h case    2:*/		return 0x82164C4C;
		  /* 82164C4Ch */ case    3:  		/* cmplw CR6, R30, R29 */
		/* 82164C4Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 82164C4Ch case    3:*/		return 0x82164C50;
		  /* 82164C50h */ case    4:  		/* bc 12, CR6_GT, 60 */
		/* 82164C50h case    4:*/		if ( regs.CR[6].gt ) { return 0x82164C8C;  }
		/* 82164C50h case    4:*/		return 0x82164C54;
		  /* 82164C54h */ case    5:  		/* mr R4, R31 */
		/* 82164C54h case    5:*/		regs.R4 = regs.R31;
		/* 82164C54h case    5:*/		return 0x82164C58;
	}
	return 0x82164C58;
} // Block from 82164C40h-82164C58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164C58h
// Function '?GetWriteMaskRequired@Dependency@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164C58);
		  /* 82164C58h */ case    0:  		/* lwz R3, <#[R27 + 768]> */
		/* 82164C58h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000300) );
		/* 82164C58h case    0:*/		return 0x82164C5C;
		  /* 82164C5Ch */ case    1:  		/* bl -1026492 */
		/* 82164C5Ch case    1:*/		regs.LR = 0x82164C60; return 0x8206A2A0;
		/* 82164C5Ch case    1:*/		return 0x82164C60;
		  /* 82164C60h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 82164C60h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82164C60h case    2:*/		return 0x82164C64;
		  /* 82164C64h */ case    3:  		/* rlwinm R10, R11, 0, 16, 19 */
		/* 82164C64h case    3:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R10,regs.R11);
		/* 82164C64h case    3:*/		return 0x82164C68;
		  /* 82164C68h */ case    4:  		/* cmplwi CR6, R10, 20480 */
		/* 82164C68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00005000);
		/* 82164C68h case    4:*/		return 0x82164C6C;
		  /* 82164C6Ch */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 82164C6Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82164C80;  }
		/* 82164C6Ch case    5:*/		return 0x82164C70;
		  /* 82164C70h */ case    6:  		/* li R10, 1 */
		/* 82164C70h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82164C70h case    6:*/		return 0x82164C74;
		  /* 82164C74h */ case    7:  		/* rlwimi R11, R10, 12, 21, 21 */
		/* 82164C74h case    7:*/		cpu::op::rlwimi<0,12,21,21>(regs,&regs.R11,regs.R10);
		/* 82164C74h case    7:*/		return 0x82164C78;
		  /* 82164C78h */ case    8:  		/* rlwimi R11, R10, 12, 16, 19 */
		/* 82164C78h case    8:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R10);
		/* 82164C78h case    8:*/		return 0x82164C7C;
		  /* 82164C7Ch */ case    9:  		/* stw R11, <#[R3 + 4]> */
		/* 82164C7Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82164C7Ch case    9:*/		return 0x82164C80;
	}
	return 0x82164C80;
} // Block from 82164C58h-82164C80h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82164C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164C80);
		  /* 82164C80h */ case    0:  		/* addi R31, R31, 1 */
		/* 82164C80h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82164C80h case    0:*/		return 0x82164C84;
		  /* 82164C84h */ case    1:  		/* cmplw CR6, R31, R29 */
		/* 82164C84h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82164C84h case    1:*/		return 0x82164C88;
		  /* 82164C88h */ case    2:  		/* bc 4, CR6_GT, -52 */
		/* 82164C88h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82164C54;  }
		/* 82164C88h case    2:*/		return 0x82164C8C;
	}
	return 0x82164C8C;
} // Block from 82164C80h-82164C8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82164C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164C8C);
		  /* 82164C8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82164C8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82164C8Ch case    0:*/		return 0x82164C90;
		  /* 82164C90h */ case    1:  		/* b -866796 */
		/* 82164C90h case    1:*/		return 0x820912A4;
		/* 82164C90h case    1:*/		return 0x82164C94;
		  /* 82164C94h */ case    2:  		/* nop */
		/* 82164C94h case    2:*/		cpu::op::nop();
		/* 82164C94h case    2:*/		return 0x82164C98;
		  /* 82164C98h */ case    3:  		/* addi R10, R3, 812 */
		/* 82164C98h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x32C);
		/* 82164C98h case    3:*/		return 0x82164C9C;
		  /* 82164C9Ch */ case    4:  		/* cmplwi CR6, R5, 132 */
		/* 82164C9Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000084);
		/* 82164C9Ch case    4:*/		return 0x82164CA0;
	}
	return 0x82164CA0;
} // Block from 82164C8Ch-82164CA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82164CA0h
// Function '?IsEquivalentVectorDependency@Dependency@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164CA0);
		  /* 82164CA0h */ case    0:  		/* bc 4, CR6_GT, 52 */
		/* 82164CA0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82164CD4;  }
		/* 82164CA0h case    0:*/		return 0x82164CA4;
		  /* 82164CA4h */ case    1:  		/* addi R3, R4, -12 */
		/* 82164CA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R4,0xFFFFFFF4);
		/* 82164CA4h case    1:*/		return 0x82164CA8;
		  /* 82164CA8h */ case    2:  		/* lis R4, 24973 */
		/* 82164CA8h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x618D);
		/* 82164CA8h case    2:*/		return 0x82164CAC;
		  /* 82164CACh */ case    3:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 82164CACh case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 82164CACh case    3:*/		return 0x82164CB0;
		  /* 82164CB0h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 82164CB0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82164CB0h case    4:*/		return 0x82164CB4;
		  /* 82164CB4h */ case    5:  		/* lwz R9, <#[R11]> */
		/* 82164CB4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82164CB4h case    5:*/		return 0x82164CB8;
		  /* 82164CB8h */ case    6:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82164CB8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82164CB8h case    6:*/		return 0x82164CBC;
		  /* 82164CBCh */ case    7:  		/* stw R9, <#[R10]> */
		/* 82164CBCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82164CBCh case    7:*/		return 0x82164CC0;
		  /* 82164CC0h */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 82164CC0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82164CC0h case    8:*/		return 0x82164CC4;
		  /* 82164CC4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82164CC4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82164CC4h case    9:*/		return 0x82164CC8;
		  /* 82164CC8h */ case   10:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82164CC8h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82164CC8h case   10:*/		return 0x82164CCC;
		  /* 82164CCCh */ case   11:  		/* stw R10, <#[R11]> */
		/* 82164CCCh case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82164CCCh case   11:*/		return 0x82164CD0;
		  /* 82164CD0h */ case   12:  		/* b -903576 */
		/* 82164CD0h case   12:*/		return 0x82088338;
		/* 82164CD0h case   12:*/		return 0x82164CD4;
	}
	return 0x82164CD4;
} // Block from 82164CA0h-82164CD4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82164CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164CD4);
		  /* 82164CD4h */ case    0:  		/* rlwinm R11, R5, 30, 2, 31 */
		/* 82164CD4h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R5);
		/* 82164CD4h case    0:*/		return 0x82164CD8;
		  /* 82164CD8h */ case    1:  		/* addi R11, R11, -1 */
		/* 82164CD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82164CD8h case    1:*/		return 0x82164CDC;
		  /* 82164CDCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82164CDCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82164CDCh case    2:*/		return 0x82164CE0;
		  /* 82164CE0h */ case    3:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82164CE0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82164CE0h case    3:*/		return 0x82164CE4;
		  /* 82164CE4h */ case    4:  		/* stw R9, <#[R4]> */
		/* 82164CE4h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 82164CE4h case    4:*/		return 0x82164CE8;
		  /* 82164CE8h */ case    5:  		/* stwx R4, <#[R11 + R10]> */
		/* 82164CE8h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82164CE8h case    5:*/		return 0x82164CEC;
		  /* 82164CECh */ case    6:  		/* bclr 20, CR0_LT */
		/* 82164CECh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164CECh case    6:*/		return 0x82164CF0;
	}
	return 0x82164CF0;
} // Block from 82164CD4h-82164CF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82164CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164CF0);
		  /* 82164CF0h */ case    0:  		/* mfspr R12, LR */
		/* 82164CF0h case    0:*/		regs.R12 = regs.LR;
		/* 82164CF0h case    0:*/		return 0x82164CF4;
		  /* 82164CF4h */ case    1:  		/* bl -866968 */
		/* 82164CF4h case    1:*/		regs.LR = 0x82164CF8; return 0x8209125C;
		/* 82164CF4h case    1:*/		return 0x82164CF8;
		  /* 82164CF8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82164CF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82164CF8h case    2:*/		return 0x82164CFC;
		  /* 82164CFCh */ case    3:  		/* mr R30, R3 */
		/* 82164CFCh case    3:*/		regs.R30 = regs.R3;
		/* 82164CFCh case    3:*/		return 0x82164D00;
		  /* 82164D00h */ case    4:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82164D00h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82164D00h case    4:*/		return 0x82164D04;
		  /* 82164D04h */ case    5:  		/* bc 4, CR0_EQ, 96 */
		/* 82164D04h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82164D64;  }
		/* 82164D04h case    5:*/		return 0x82164D08;
		  /* 82164D08h */ case    6:  		/* lwz R11, <#[R3 + 40]> */
		/* 82164D08h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82164D08h case    6:*/		return 0x82164D0C;
		  /* 82164D0Ch */ case    7:  		/* lwz R31, <#[R3 + 540]> */
		/* 82164D0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000021C) );
		/* 82164D0Ch case    7:*/		return 0x82164D10;
		  /* 82164D10h */ case    8:  		/* addi R11, R11, -4096 */
		/* 82164D10h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFF000);
		/* 82164D10h case    8:*/		return 0x82164D14;
		  /* 82164D14h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 82164D14h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82164D14h case    9:*/		return 0x82164D18;
		  /* 82164D18h */ case   10:  		/* stw R11, <#[R3 + 40]> */
		/* 82164D18h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82164D18h case   10:*/		return 0x82164D1C;
		  /* 82164D1Ch */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 82164D1Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82164D5C;  }
		/* 82164D1Ch case   11:*/		return 0x82164D20;
		  /* 82164D20h */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 82164D20h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82164D20h case   12:*/		return 0x82164D24;
		  /* 82164D24h */ case   13:  		/* mr R3, R30 */
		/* 82164D24h case   13:*/		regs.R3 = regs.R30;
		/* 82164D24h case   13:*/		return 0x82164D28;
		  /* 82164D28h */ case   14:  		/* lwz R29, <#[R31 + 32]> */
		/* 82164D28h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000020) );
		/* 82164D28h case   14:*/		return 0x82164D2C;
		  /* 82164D2Ch */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82164D2Ch case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82164D2Ch case   15:*/		return 0x82164D30;
		  /* 82164D30h */ case   16:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82164D30h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82164D30h case   16:*/		return 0x82164D34;
		  /* 82164D34h */ case   17:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82164D34h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82164D34h case   17:*/		return 0x82164D38;
		  /* 82164D38h */ case   18:  		/* bl -2312 */
		/* 82164D38h case   18:*/		regs.LR = 0x82164D3C; return 0x82164430;
		/* 82164D38h case   18:*/		return 0x82164D3C;
		  /* 82164D3Ch */ case   19:  		/* mr R5, R3 */
		/* 82164D3Ch case   19:*/		regs.R5 = regs.R3;
		/* 82164D3Ch case   19:*/		return 0x82164D40;
		  /* 82164D40h */ case   20:  		/* mr R4, R31 */
		/* 82164D40h case   20:*/		regs.R4 = regs.R31;
		/* 82164D40h case   20:*/		return 0x82164D44;
		  /* 82164D44h */ case   21:  		/* mr R3, R30 */
		/* 82164D44h case   21:*/		regs.R3 = regs.R30;
		/* 82164D44h case   21:*/		return 0x82164D48;
		  /* 82164D48h */ case   22:  		/* li R6, 0 */
		/* 82164D48h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82164D48h case   22:*/		return 0x82164D4C;
		  /* 82164D4Ch */ case   23:  		/* bl -180 */
		/* 82164D4Ch case   23:*/		regs.LR = 0x82164D50; return 0x82164C98;
		/* 82164D4Ch case   23:*/		return 0x82164D50;
		  /* 82164D50h */ case   24:  		/* mr R31, R29 */
		/* 82164D50h case   24:*/		regs.R31 = regs.R29;
		/* 82164D50h case   24:*/		return 0x82164D54;
		  /* 82164D54h */ case   25:  		/* cmplwi CR6, R29, 0 */
		/* 82164D54h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82164D54h case   25:*/		return 0x82164D58;
		  /* 82164D58h */ case   26:  		/* bc 4, CR6_EQ, -56 */
		/* 82164D58h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82164D20;  }
		/* 82164D58h case   26:*/		return 0x82164D5C;
	}
	return 0x82164D5C;
} // Block from 82164CF0h-82164D5Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82164D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164D5C);
		  /* 82164D5Ch */ case    0:  		/* li R11, 0 */
		/* 82164D5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164D5Ch case    0:*/		return 0x82164D60;
		  /* 82164D60h */ case    1:  		/* stw R11, <#[R30 + 540]> */
		/* 82164D60h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000021C) );
		/* 82164D60h case    1:*/		return 0x82164D64;
	}
	return 0x82164D64;
} // Block from 82164D5Ch-82164D64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164D64);
		  /* 82164D64h */ case    0:  		/* addi R1, R1, 112 */
		/* 82164D64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82164D64h case    0:*/		return 0x82164D68;
	}
	return 0x82164D68;
} // Block from 82164D64h-82164D68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164D68h
// Function '?GetPredicateRegisterControllingBlock@Block@D3DXShader@@QAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164D68);
		  /* 82164D68h */ case    0:  		/* b -867004 */
		/* 82164D68h case    0:*/		return 0x820912AC;
		/* 82164D68h case    0:*/		return 0x82164D6C;
		  /* 82164D6Ch */ case    1:  		/* nop */
		/* 82164D6Ch case    1:*/		cpu::op::nop();
		/* 82164D6Ch case    1:*/		return 0x82164D70;
		  /* 82164D70h */ case    2:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 82164D70h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 82164D70h case    2:*/		return 0x82164D74;
		  /* 82164D74h */ case    3:  		/* mr R11, R3 */
		/* 82164D74h case    3:*/		regs.R11 = regs.R3;
		/* 82164D74h case    3:*/		return 0x82164D78;
		  /* 82164D78h */ case    4:  		/* lwz R3, <#[R10 + 40]> */
		/* 82164D78h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000028) );
		/* 82164D78h case    4:*/		return 0x82164D7C;
		  /* 82164D7Ch */ case    5:  		/* rlwinm. R10, R3, 0, 31, 31 */
		/* 82164D7Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R3);
		/* 82164D7Ch case    5:*/		return 0x82164D80;
		  /* 82164D80h */ case    6:  		/* bc 4, CR0_EQ, 148 */
		/* 82164D80h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82164E14;  }
		/* 82164D80h case    6:*/		return 0x82164D84;
		  /* 82164D84h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 82164D84h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82164D84h case    7:*/		return 0x82164D88;
		  /* 82164D88h */ case    8:  		/* bc 12, CR6_EQ, 140 */
		/* 82164D88h case    8:*/		if ( regs.CR[6].eq ) { return 0x82164E14;  }
		/* 82164D88h case    8:*/		return 0x82164D8C;
		  /* 82164D8Ch */ case    9:  		/* lbz R10, <#[R11 + 16]> */
		/* 82164D8Ch case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82164D8Ch case    9:*/		return 0x82164D90;
		  /* 82164D90h */ case   10:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82164D90h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82164D90h case   10:*/		return 0x82164D94;
		  /* 82164D94h */ case   11:  		/* bc 12, CR0_EQ, 128 */
		/* 82164D94h case   11:*/		if ( regs.CR[0].eq ) { return 0x82164E14;  }
		/* 82164D94h case   11:*/		return 0x82164D98;
		  /* 82164D98h */ case   12:  		/* lwz R10, <#[R11 + 20]> */
		/* 82164D98h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82164D98h case   12:*/		return 0x82164D9C;
		  /* 82164D9Ch */ case   13:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82164D9Ch case   13:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82164D9Ch case   13:*/		return 0x82164DA0;
		  /* 82164DA0h */ case   14:  		/* cmplwi CR6, R10, 8191 */
		/* 82164DA0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00001FFF);
		/* 82164DA0h case   14:*/		return 0x82164DA4;
		  /* 82164DA4h */ case   15:  		/* bc 12, CR6_EQ, 112 */
		/* 82164DA4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82164E14;  }
		/* 82164DA4h case   15:*/		return 0x82164DA8;
		  /* 82164DA8h */ case   16:  		/* lwz R11, <#[R11 + 8]> */
		/* 82164DA8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82164DA8h case   16:*/		return 0x82164DAC;
		  /* 82164DACh */ case   17:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82164DACh case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82164DACh case   17:*/		return 0x82164DB0;
	}
	return 0x82164DB0;
} // Block from 82164D68h-82164DB0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82164DB0h
// Function '?GetSamplerRegisterBase@Compiler@D3DXShader@@QAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164DB0);
		  /* 82164DB0h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 82164DB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82164DB0h case    0:*/		return 0x82164DB4;
		  /* 82164DB4h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82164DB4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82164DC4;  }
		/* 82164DB4h case    1:*/		return 0x82164DB8;
		  /* 82164DB8h */ case    2:  		/* cmplwi CR6, R11, 31 */
		/* 82164DB8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001F);
		/* 82164DB8h case    2:*/		return 0x82164DBC;
		  /* 82164DBCh */ case    3:  		/* li R11, 1 */
		/* 82164DBCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164DBCh case    3:*/		return 0x82164DC0;
		  /* 82164DC0h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82164DC0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82164DC8;  }
		/* 82164DC0h case    4:*/		return 0x82164DC4;
	}
	return 0x82164DC4;
} // Block from 82164DB0h-82164DC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82164DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164DC4);
		  /* 82164DC4h */ case    0:  		/* li R11, 0 */
		/* 82164DC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164DC4h case    0:*/		return 0x82164DC8;
	}
	return 0x82164DC8;
} // Block from 82164DC4h-82164DC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164DC8);
		  /* 82164DC8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82164DC8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82164DC8h case    0:*/		return 0x82164DCC;
		  /* 82164DCCh */ case    1:  		/* bc 12, CR0_EQ, 72 */
		/* 82164DCCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82164E14;  }
		/* 82164DCCh case    1:*/		return 0x82164DD0;
		  /* 82164DD0h */ case    2:  		/* lbz R11, <#[R3 + 16]> */
		/* 82164DD0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82164DD0h case    2:*/		return 0x82164DD4;
		  /* 82164DD4h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82164DD4h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82164DD4h case    3:*/		return 0x82164DD8;
		  /* 82164DD8h */ case    4:  		/* bc 12, CR0_EQ, 60 */
		/* 82164DD8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82164E14;  }
		/* 82164DD8h case    4:*/		return 0x82164DDC;
		  /* 82164DDCh */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 82164DDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82164DDCh case    5:*/		return 0x82164DE0;
		  /* 82164DE0h */ case    6:  		/* rlwinm R11, R11, 0, 19, 31 */
		/* 82164DE0h case    6:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R11,regs.R11);
		/* 82164DE0h case    6:*/		return 0x82164DE4;
		  /* 82164DE4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82164DE4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82164DE4h case    7:*/		return 0x82164DE8;
		  /* 82164DE8h */ case    8:  		/* bc 4, CR6_EQ, 44 */
		/* 82164DE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82164E14;  }
		/* 82164DE8h case    8:*/		return 0x82164DEC;
		  /* 82164DECh */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 82164DECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82164DECh case    9:*/		return 0x82164DF0;
		  /* 82164DF0h */ case   10:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82164DF0h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82164DF0h case   10:*/		return 0x82164DF4;
		  /* 82164DF4h */ case   11:  		/* cmplwi CR6, R11, 32 */
		/* 82164DF4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 82164DF4h case   11:*/		return 0x82164DF8;
		  /* 82164DF8h */ case   12:  		/* bc 12, CR6_LT, 16 */
		/* 82164DF8h case   12:*/		if ( regs.CR[6].lt ) { return 0x82164E08;  }
		/* 82164DF8h case   12:*/		return 0x82164DFC;
		  /* 82164DFCh */ case   13:  		/* cmplwi CR6, R11, 82 */
		/* 82164DFCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 82164DFCh case   13:*/		return 0x82164E00;
	}
	return 0x82164E00;
} // Block from 82164DC8h-82164E00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82164E00h
// Function '?NeedDebugPrintExports@Compiler@D3DXShader@@QAA_N_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E00);
		  /* 82164E00h */ case    0:  		/* li R11, 1 */
		/* 82164E00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82164E00h case    0:*/		return 0x82164E04;
		  /* 82164E04h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82164E04h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82164E0C;  }
		/* 82164E04h case    1:*/		return 0x82164E08;
	}
	return 0x82164E08;
} // Block from 82164E00h-82164E08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E08);
		  /* 82164E08h */ case    0:  		/* li R11, 0 */
		/* 82164E08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82164E08h case    0:*/		return 0x82164E0C;
	}
	return 0x82164E0C;
} // Block from 82164E08h-82164E0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E0C);
		  /* 82164E0Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82164E0Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82164E0Ch case    0:*/		return 0x82164E10;
		  /* 82164E10h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 82164E10h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82164E10h case    1:*/		return 0x82164E14;
	}
	return 0x82164E14;
} // Block from 82164E0Ch-82164E14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E14);
		  /* 82164E14h */ case    0:  		/* li R3, 0 */
		/* 82164E14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82164E14h case    0:*/		return 0x82164E18;
		  /* 82164E18h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82164E18h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164E18h case    1:*/		return 0x82164E1C;
	}
	return 0x82164E1C;
} // Block from 82164E14h-82164E1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E1C);
		  /* 82164E1Ch */ case    0:  		/* nop */
		/* 82164E1Ch case    0:*/		cpu::op::nop();
		/* 82164E1Ch case    0:*/		return 0x82164E20;
		  /* 82164E20h */ case    1:  		/* lwz R11, <#[R3 + 28]> */
		/* 82164E20h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 82164E20h case    1:*/		return 0x82164E24;
		  /* 82164E24h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82164E24h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82164E24h case    2:*/		return 0x82164E28;
		  /* 82164E28h */ case    3:  		/* bc 4, CR0_EQ, 48 */
		/* 82164E28h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82164E58;  }
		/* 82164E28h case    3:*/		return 0x82164E2C;
		  /* 82164E2Ch */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82164E2Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82164E2Ch case    4:*/		return 0x82164E30;
		  /* 82164E30h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 82164E30h case    5:*/		if ( regs.CR[0].eq ) { return 0x82164E58;  }
		/* 82164E30h case    5:*/		return 0x82164E34;
		  /* 82164E34h */ case    6:  		/* lwz R10, <#[R11 + 8]> */
		/* 82164E34h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82164E34h case    6:*/		return 0x82164E38;
		  /* 82164E38h */ case    7:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82164E38h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82164E38h case    7:*/		return 0x82164E3C;
		  /* 82164E3Ch */ case    8:  		/* cmplwi CR6, R10, 16128 */
		/* 82164E3Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003F00);
		/* 82164E3Ch case    8:*/		return 0x82164E40;
		  /* 82164E40h */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 82164E40h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82164E58;  }
		/* 82164E40h case    9:*/		return 0x82164E44;
		  /* 82164E44h */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 82164E44h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82164E44h case   10:*/		return 0x82164E48;
	}
	return 0x82164E48;
} // Block from 82164E1Ch-82164E48h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82164E48h
// Function '?ComputeAllocSize@Instruction@D3DXShader@@SAKPAVCompiler@2@W4Opcode@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E48);
		  /* 82164E48h */ case    0:  		/* rlwinm. R10, R11, 16, 31, 31 */
		/* 82164E48h case    0:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R10,regs.R11);
		/* 82164E48h case    0:*/		return 0x82164E4C;
		  /* 82164E4Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82164E4Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82164E58;  }
		/* 82164E4Ch case    1:*/		return 0x82164E50;
		  /* 82164E50h */ case    2:  		/* rlwinm R3, R11, 0, 20, 31 */
		/* 82164E50h case    2:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R3,regs.R11);
		/* 82164E50h case    2:*/		return 0x82164E54;
		  /* 82164E54h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82164E54h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164E54h case    3:*/		return 0x82164E58;
	}
	return 0x82164E58;
} // Block from 82164E48h-82164E58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82164E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E58);
		  /* 82164E58h */ case    0:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 82164E58h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 82164E58h case    0:*/		return 0x82164E5C;
		  /* 82164E5Ch */ case    1:  		/* li R4, 4800 */
		/* 82164E5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82164E5Ch case    1:*/		return 0x82164E60;
		  /* 82164E60h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82164E60h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82164E60h case    2:*/		return 0x82164E64;
		  /* 82164E64h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82164E64h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82164E64h case    3:*/		return 0x82164E68;
		  /* 82164E68h */ case    4:  		/* b -77824 */
		/* 82164E68h case    4:*/		return 0x82151E68;
		/* 82164E68h case    4:*/		return 0x82164E6C;
		  /* 82164E6Ch */ case    5:  		/* nop */
		/* 82164E6Ch case    5:*/		cpu::op::nop();
		/* 82164E6Ch case    5:*/		return 0x82164E70;
	}
	return 0x82164E70;
} // Block from 82164E58h-82164E70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164E70);
		  /* 82164E70h */ case    0:  		/* mfspr R12, LR */
		/* 82164E70h case    0:*/		regs.R12 = regs.LR;
		/* 82164E70h case    0:*/		return 0x82164E74;
		  /* 82164E74h */ case    1:  		/* bl -867356 */
		/* 82164E74h case    1:*/		regs.LR = 0x82164E78; return 0x82091258;
		/* 82164E74h case    1:*/		return 0x82164E78;
		  /* 82164E78h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82164E78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82164E78h case    2:*/		return 0x82164E7C;
		  /* 82164E7Ch */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 82164E7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82164E7Ch case    3:*/		return 0x82164E80;
		  /* 82164E80h */ case    4:  		/* li R28, 0 */
		/* 82164E80h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82164E80h case    4:*/		return 0x82164E84;
		  /* 82164E84h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82164E84h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82164E84h case    5:*/		return 0x82164E88;
		  /* 82164E88h */ case    6:  		/* bc 4, CR0_EQ, 120 */
		/* 82164E88h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82164F00;  }
		/* 82164E88h case    6:*/		return 0x82164E8C;
		  /* 82164E8Ch */ case    7:  		/* mr R29, R11 */
		/* 82164E8Ch case    7:*/		regs.R29 = regs.R11;
		/* 82164E8Ch case    7:*/		return 0x82164E90;
		  /* 82164E90h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82164E90h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82164E90h case    8:*/		return 0x82164E94;
		  /* 82164E94h */ case    9:  		/* bc 12, CR0_EQ, 108 */
		/* 82164E94h case    9:*/		if ( regs.CR[0].eq ) { return 0x82164F00;  }
		/* 82164E94h case    9:*/		return 0x82164E98;
		  /* 82164E98h */ case   10:  		/* lwz R30, <#[R29 + 4]> */
		/* 82164E98h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000004) );
		/* 82164E98h case   10:*/		return 0x82164E9C;
		  /* 82164E9Ch */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 82164E9Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82164E9Ch case   11:*/		return 0x82164EA0;
		  /* 82164EA0h */ case   12:  		/* bc 12, CR6_EQ, 68 */
		/* 82164EA0h case   12:*/		if ( regs.CR[6].eq ) { return 0x82164EE4;  }
		/* 82164EA0h case   12:*/		return 0x82164EA4;
		  /* 82164EA4h */ case   13:  		/* lwz R11, <#[R30 + 16]> */
		/* 82164EA4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82164EA4h case   13:*/		return 0x82164EA8;
		  /* 82164EA8h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82164EA8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164EA8h case   14:*/		return 0x82164EAC;
		  /* 82164EACh */ case   15:  		/* bc 12, CR6_EQ, 48 */
		/* 82164EACh case   15:*/		if ( regs.CR[6].eq ) { return 0x82164EDC;  }
		/* 82164EACh case   15:*/		return 0x82164EB0;
		  /* 82164EB0h */ case   16:  		/* lwz R31, <#[R30]> */
		/* 82164EB0h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82164EB0h case   16:*/		return 0x82164EB4;
		  /* 82164EB4h */ case   17:  		/* rlwinm. R11, R31, 0, 4, 6 */
		/* 82164EB4h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R31);
		/* 82164EB4h case   17:*/		return 0x82164EB8;
		  /* 82164EB8h */ case   18:  		/* bc 12, CR0_EQ, 36 */
		/* 82164EB8h case   18:*/		if ( regs.CR[0].eq ) { return 0x82164EDC;  }
		/* 82164EB8h case   18:*/		return 0x82164EBC;
		  /* 82164EBCh */ case   19:  		/* mr R3, R30 */
		/* 82164EBCh case   19:*/		regs.R3 = regs.R30;
		/* 82164EBCh case   19:*/		return 0x82164EC0;
		  /* 82164EC0h */ case   20:  		/* bl -1680 */
		/* 82164EC0h case   20:*/		regs.LR = 0x82164EC4; return 0x82164830;
		/* 82164EC0h case   20:*/		return 0x82164EC4;
		  /* 82164EC4h */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82164EC4h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82164EC4h case   21:*/		return 0x82164EC8;
	}
	return 0x82164EC8;
} // Block from 82164E70h-82164EC8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82164EC8h
// Function '?CompareGlobalVarNames@D3DXShader@@YAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164EC8);
		  /* 82164EC8h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 82164EC8h case    0:*/		if ( regs.CR[0].eq ) { return 0x82164EDC;  }
		/* 82164EC8h case    0:*/		return 0x82164ECC;
		  /* 82164ECCh */ case    1:  		/* rlwinm R11, R31, 15, 24, 31 */
		/* 82164ECCh case    1:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R11,regs.R31);
		/* 82164ECCh case    1:*/		return 0x82164ED0;
		  /* 82164ED0h */ case    2:  		/* cmplw CR6, R11, R28 */
		/* 82164ED0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82164ED0h case    2:*/		return 0x82164ED4;
		  /* 82164ED4h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 82164ED4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82164EDC;  }
		/* 82164ED4h case    3:*/		return 0x82164ED8;
		  /* 82164ED8h */ case    4:  		/* mr R28, R11 */
		/* 82164ED8h case    4:*/		regs.R28 = regs.R11;
		/* 82164ED8h case    4:*/		return 0x82164EDC;
	}
	return 0x82164EDC;
} // Block from 82164EC8h-82164EDCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82164EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164EDC);
		  /* 82164EDCh */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82164EDCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82164EDCh case    0:*/		return 0x82164EE0;
		  /* 82164EE0h */ case    1:  		/* b -68 */
		/* 82164EE0h case    1:*/		return 0x82164E9C;
		/* 82164EE0h case    1:*/		return 0x82164EE4;
	}
	return 0x82164EE4;
} // Block from 82164EDCh-82164EE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82164EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164EE4);
		  /* 82164EE4h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82164EE4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82164EE4h case    0:*/		return 0x82164EE8;
		  /* 82164EE8h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82164EE8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82164EE8h case    1:*/		return 0x82164EEC;
		  /* 82164EECh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82164EECh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82164EECh case    2:*/		return 0x82164EF0;
		  /* 82164EF0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82164EF0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82164F00;  }
		/* 82164EF0h case    3:*/		return 0x82164EF4;
		  /* 82164EF4h */ case    4:  		/* mr R29, R11 */
		/* 82164EF4h case    4:*/		regs.R29 = regs.R11;
		/* 82164EF4h case    4:*/		return 0x82164EF8;
		  /* 82164EF8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82164EF8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82164EF8h case    5:*/		return 0x82164EFC;
		  /* 82164EFCh */ case    6:  		/* bc 4, CR6_EQ, -100 */
		/* 82164EFCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x82164E98;  }
		/* 82164EFCh case    6:*/		return 0x82164F00;
	}
	return 0x82164F00;
} // Block from 82164EE4h-82164F00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82164F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164F00);
		  /* 82164F00h */ case    0:  		/* mr R3, R28 */
		/* 82164F00h case    0:*/		regs.R3 = regs.R28;
		/* 82164F00h case    0:*/		return 0x82164F04;
		  /* 82164F04h */ case    1:  		/* addi R1, R1, 128 */
		/* 82164F04h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82164F04h case    1:*/		return 0x82164F08;
		  /* 82164F08h */ case    2:  		/* b -867424 */
		/* 82164F08h case    2:*/		return 0x820912A8;
		/* 82164F08h case    2:*/		return 0x82164F0C;
		  /* 82164F0Ch */ case    3:  		/* nop */
		/* 82164F0Ch case    3:*/		cpu::op::nop();
		/* 82164F0Ch case    3:*/		return 0x82164F10;
	}
	return 0x82164F10;
} // Block from 82164F00h-82164F10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82164F10h
// Function '?FindSourceLineForContext@Compiler@D3DXShader@@AAA_NKPAPBDPAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164F10);
		  /* 82164F10h */ case    0:  		/* mfspr R12, LR */
		/* 82164F10h case    0:*/		regs.R12 = regs.LR;
		/* 82164F10h case    0:*/		return 0x82164F14;
		  /* 82164F14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82164F14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164F14h case    1:*/		return 0x82164F18;
		  /* 82164F18h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82164F18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82164F18h case    2:*/		return 0x82164F1C;
		  /* 82164F1Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82164F1Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164F1Ch case    3:*/		return 0x82164F20;
		  /* 82164F20h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82164F20h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82164F20h case    4:*/		return 0x82164F24;
		  /* 82164F24h */ case    5:  		/* addi R30, R4, 12 */
		/* 82164F24h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0xC);
		/* 82164F24h case    5:*/		return 0x82164F28;
		  /* 82164F28h */ case    6:  		/* mr R31, R3 */
		/* 82164F28h case    6:*/		regs.R31 = regs.R3;
		/* 82164F28h case    6:*/		return 0x82164F2C;
		  /* 82164F2Ch */ case    7:  		/* lis R4, 24973 */
		/* 82164F2Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x618D);
		/* 82164F2Ch case    7:*/		return 0x82164F30;
		  /* 82164F30h */ case    8:  		/* mr R3, R30 */
		/* 82164F30h case    8:*/		regs.R3 = regs.R30;
		/* 82164F30h case    8:*/		return 0x82164F34;
		  /* 82164F34h */ case    9:  		/* bl -904500 */
		/* 82164F34h case    9:*/		regs.LR = 0x82164F38; return 0x82088200;
		/* 82164F34h case    9:*/		return 0x82164F38;
		  /* 82164F38h */ case   10:  		/* stw R30, <#[R3 + 8]> */
		/* 82164F38h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 82164F38h case   10:*/		return 0x82164F3C;
		  /* 82164F3Ch */ case   11:  		/* lwz R8, <#[R31 + 152]> */
		/* 82164F3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000098) );
		/* 82164F3Ch case   11:*/		return 0x82164F40;
		  /* 82164F40h */ case   12:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 82164F40h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 82164F40h case   12:*/		return 0x82164F44;
		  /* 82164F44h */ case   13:  		/* stw R8, <#[R11]> */
		/* 82164F44h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82164F44h case   13:*/		return 0x82164F48;
		  /* 82164F48h */ case   14:  		/* addi R10, R31, 152 */
		/* 82164F48h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x98);
		/* 82164F48h case   14:*/		return 0x82164F4C;
		  /* 82164F4Ch */ case   15:  		/* lwz R8, <#[R31 + 152]> */
		/* 82164F4Ch case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000098) );
		/* 82164F4Ch case   15:*/		return 0x82164F50;
		  /* 82164F50h */ case   16:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 82164F50h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 82164F50h case   16:*/		return 0x82164F54;
		  /* 82164F54h */ case   17:  		/* ori R9, R10, 1 */
		/* 82164F54h case   17:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R10,0x1);
		/* 82164F54h case   17:*/		return 0x82164F58;
		  /* 82164F58h */ case   18:  		/* stw R11, <#[R8]> */
		/* 82164F58h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82164F58h case   18:*/		return 0x82164F5C;
		  /* 82164F5Ch */ case   19:  		/* addi R10, R11, 4 */
		/* 82164F5Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82164F5Ch case   19:*/		return 0x82164F60;
		  /* 82164F60h */ case   20:  		/* stw R9, <#[R11 + 4]> */
		/* 82164F60h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82164F60h case   20:*/		return 0x82164F64;
		  /* 82164F64h */ case   21:  		/* addi R3, R3, 12 */
		/* 82164F64h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xC);
		/* 82164F64h case   21:*/		return 0x82164F68;
		  /* 82164F68h */ case   22:  		/* stw R10, <#[R31 + 152]> */
		/* 82164F68h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000098) );
		/* 82164F68h case   22:*/		return 0x82164F6C;
		  /* 82164F6Ch */ case   23:  		/* addi R1, R1, 112 */
		/* 82164F6Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82164F6Ch case   23:*/		return 0x82164F70;
		  /* 82164F70h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 82164F70h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164F70h case   24:*/		return 0x82164F74;
		  /* 82164F74h */ case   25:  		/* mtspr LR, R12 */
		/* 82164F74h case   25:*/		regs.LR = regs.R12;
		/* 82164F74h case   25:*/		return 0x82164F78;
	}
	return 0x82164F78;
} // Block from 82164F10h-82164F78h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82164F78h
// Function '?GetLexicalScopeID@Compiler@D3DXShader@@AAAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164F78);
		  /* 82164F78h */ case    0:  		/* ld R30, <#[R1 - 24]> */
		/* 82164F78h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82164F78h case    0:*/		return 0x82164F7C;
		  /* 82164F7Ch */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 82164F7Ch case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164F7Ch case    1:*/		return 0x82164F80;
		  /* 82164F80h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82164F80h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82164F80h case    2:*/		return 0x82164F84;
	}
	return 0x82164F84;
} // Block from 82164F78h-82164F84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82164F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164F84);
		  /* 82164F84h */ case    0:  		/* nop */
		/* 82164F84h case    0:*/		cpu::op::nop();
		/* 82164F84h case    0:*/		return 0x82164F88;
	}
	return 0x82164F88;
} // Block from 82164F84h-82164F88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82164F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164F88);
		  /* 82164F88h */ case    0:  		/* mfspr R12, LR */
		/* 82164F88h case    0:*/		regs.R12 = regs.LR;
		/* 82164F88h case    0:*/		return 0x82164F8C;
		  /* 82164F8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82164F8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82164F8Ch case    1:*/		return 0x82164F90;
		  /* 82164F90h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82164F90h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82164F90h case    2:*/		return 0x82164F94;
		  /* 82164F94h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82164F94h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82164F94h case    3:*/		return 0x82164F98;
		  /* 82164F98h */ case    4:  		/* rlwinm R11, R3, 0, 0, 19 */
		/* 82164F98h case    4:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R3);
		/* 82164F98h case    4:*/		return 0x82164F9C;
		  /* 82164F9Ch */ case    5:  		/* cmplwi CR6, R4, 132 */
		/* 82164F9Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 82164F9Ch case    5:*/		return 0x82164FA0;
		  /* 82164FA0h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 82164FA0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82164FA0h case    6:*/		return 0x82164FA4;
		  /* 82164FA4h */ case    7:  		/* bc 4, CR6_GT, 16 */
		/* 82164FA4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82164FB4;  }
		/* 82164FA4h case    7:*/		return 0x82164FA8;
		  /* 82164FA8h */ case    8:  		/* mr R3, R11 */
		/* 82164FA8h case    8:*/		regs.R3 = regs.R11;
		/* 82164FA8h case    8:*/		return 0x82164FAC;
		  /* 82164FACh */ case    9:  		/* bl -156 */
		/* 82164FACh case    9:*/		regs.LR = 0x82164FB0; return 0x82164F10;
		/* 82164FACh case    9:*/		return 0x82164FB0;
		  /* 82164FB0h */ case   10:  		/* b 112 */
		/* 82164FB0h case   10:*/		return 0x82165020;
		/* 82164FB0h case   10:*/		return 0x82164FB4;
	}
	return 0x82164FB4;
} // Block from 82164F88h-82164FB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82164FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164FB4);
		  /* 82164FB4h */ case    0:  		/* lwz R9, <#[R11 + 140]> */
		/* 82164FB4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000008C) );
		/* 82164FB4h case    0:*/		return 0x82164FB8;
		  /* 82164FB8h */ case    1:  		/* lwz R10, <#[R11 + 144]> */
		/* 82164FB8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000090) );
		/* 82164FB8h case    1:*/		return 0x82164FBC;
		  /* 82164FBCh */ case    2:  		/* subf R9, R10, R9 */
		/* 82164FBCh case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82164FBCh case    2:*/		return 0x82164FC0;
	}
	return 0x82164FC0;
} // Block from 82164FB4h-82164FC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82164FC0h
// Function '?ShouldEmitVariableDeclaration@D3DXShader@@YA_NPAUVariable@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164FC0);
		  /* 82164FC0h */ case    0:  		/* addi R9, R9, 4096 */
		/* 82164FC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 82164FC0h case    0:*/		return 0x82164FC4;
		  /* 82164FC4h */ case    1:  		/* cmplw CR6, R9, R4 */
		/* 82164FC4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82164FC4h case    1:*/		return 0x82164FC8;
		  /* 82164FC8h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 82164FC8h case    2:*/		if ( regs.CR[6].lt ) { return 0x82164FD8;  }
		/* 82164FC8h case    2:*/		return 0x82164FCC;
		  /* 82164FCCh */ case    3:  		/* add R9, R10, R4 */
		/* 82164FCCh case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 82164FCCh case    3:*/		return 0x82164FD0;
		  /* 82164FD0h */ case    4:  		/* stw R9, <#[R11 + 144]> */
		/* 82164FD0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 82164FD0h case    4:*/		return 0x82164FD4;
		  /* 82164FD4h */ case    5:  		/* b 72 */
		/* 82164FD4h case    5:*/		return 0x8216501C;
		/* 82164FD4h case    5:*/		return 0x82164FD8;
	}
	return 0x82164FD8;
} // Block from 82164FC0h-82164FD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82164FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82164FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82164FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82164FD8);
		  /* 82164FD8h */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 82164FD8h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 82164FD8h case    0:*/		return 0x82164FDC;
		  /* 82164FDCh */ case    1:  		/* addi R10, R10, -1 */
		/* 82164FDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82164FDCh case    1:*/		return 0x82164FE0;
		  /* 82164FE0h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82164FE0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82164FE0h case    2:*/		return 0x82164FE4;
		  /* 82164FE4h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82164FE4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82164FE4h case    3:*/		return 0x82164FE8;
		  /* 82164FE8h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82164FE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82164FE8h case    4:*/		return 0x82164FEC;
		  /* 82164FECh */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82164FECh case    5:*/		if ( regs.CR[6].eq ) { return 0x82165010;  }
		/* 82164FECh case    5:*/		return 0x82164FF0;
		  /* 82164FF0h */ case    6:  		/* lwz R9, <#[R31]> */
		/* 82164FF0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82164FF0h case    6:*/		return 0x82164FF4;
		  /* 82164FF4h */ case    7:  		/* mr R5, R4 */
		/* 82164FF4h case    7:*/		regs.R5 = regs.R4;
		/* 82164FF4h case    7:*/		return 0x82164FF8;
		  /* 82164FF8h */ case    8:  		/* li R4, 0 */
		/* 82164FF8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82164FF8h case    8:*/		return 0x82164FFC;
		  /* 82164FFCh */ case    9:  		/* mr R3, R31 */
		/* 82164FFCh case    9:*/		regs.R3 = regs.R31;
		/* 82164FFCh case    9:*/		return 0x82165000;
		  /* 82165000h */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 82165000h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82165000h case   10:*/		return 0x82165004;
		  /* 82165004h */ case   11:  		/* bl -867524 */
		/* 82165004h case   11:*/		regs.LR = 0x82165008; return 0x82091340;
		/* 82165004h case   11:*/		return 0x82165008;
	}
	return 0x82165008;
} // Block from 82164FD8h-82165008h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82165008h
// Function '?SlowAlloc@CompilerHeap@D3DXShader@@AAAPAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165008);
		  /* 82165008h */ case    0:  		/* mr R10, R31 */
		/* 82165008h case    0:*/		regs.R10 = regs.R31;
		/* 82165008h case    0:*/		return 0x8216500C;
		  /* 8216500Ch */ case    1:  		/* b 16 */
		/* 8216500Ch case    1:*/		return 0x8216501C;
		/* 8216500Ch case    1:*/		return 0x82165010;
	}
	return 0x82165010;
} // Block from 82165008h-82165010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165010);
		  /* 82165010h */ case    0:  		/* mr R3, R11 */
		/* 82165010h case    0:*/		regs.R3 = regs.R11;
		/* 82165010h case    0:*/		return 0x82165014;
		  /* 82165014h */ case    1:  		/* bl -2596 */
		/* 82165014h case    1:*/		regs.LR = 0x82165018; return 0x821645F0;
		/* 82165014h case    1:*/		return 0x82165018;
		  /* 82165018h */ case    2:  		/* mr R10, R3 */
		/* 82165018h case    2:*/		regs.R10 = regs.R3;
		/* 82165018h case    2:*/		return 0x8216501C;
	}
	return 0x8216501C;
} // Block from 82165010h-8216501Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216501Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216501C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216501C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216501C);
		  /* 8216501Ch */ case    0:  		/* mr R3, R10 */
		/* 8216501Ch case    0:*/		regs.R3 = regs.R10;
		/* 8216501Ch case    0:*/		return 0x82165020;
	}
	return 0x82165020;
} // Block from 8216501Ch-82165020h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165020);
		  /* 82165020h */ case    0:  		/* addi R1, R1, 96 */
		/* 82165020h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82165020h case    0:*/		return 0x82165024;
		  /* 82165024h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82165024h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82165024h case    1:*/		return 0x82165028;
		  /* 82165028h */ case    2:  		/* mtspr LR, R12 */
		/* 82165028h case    2:*/		regs.LR = regs.R12;
		/* 82165028h case    2:*/		return 0x8216502C;
		  /* 8216502Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8216502Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216502Ch case    3:*/		return 0x82165030;
		  /* 82165030h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82165030h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82165030h case    4:*/		return 0x82165034;
	}
	return 0x82165034;
} // Block from 82165020h-82165034h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82165034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165034);
		  /* 82165034h */ case    0:  		/* nop */
		/* 82165034h case    0:*/		cpu::op::nop();
		/* 82165034h case    0:*/		return 0x82165038;
	}
	return 0x82165038;
} // Block from 82165034h-82165038h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165038);
		  /* 82165038h */ case    0:  		/* mfspr R12, LR */
		/* 82165038h case    0:*/		regs.R12 = regs.LR;
		/* 82165038h case    0:*/		return 0x8216503C;
		  /* 8216503Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216503Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216503Ch case    1:*/		return 0x82165040;
		  /* 82165040h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82165040h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82165040h case    2:*/		return 0x82165044;
		  /* 82165044h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82165044h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82165044h case    3:*/		return 0x82165048;
		  /* 82165048h */ case    4:  		/* addi R11, R3, 972 */
		/* 82165048h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3CC);
		/* 82165048h case    4:*/		return 0x8216504C;
		  /* 8216504Ch */ case    5:  		/* cmplwi CR6, R4, 132 */
		/* 8216504Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 8216504Ch case    5:*/		return 0x82165050;
		  /* 82165050h */ case    6:  		/* bc 4, CR6_GT, 16 */
		/* 82165050h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82165060;  }
		/* 82165050h case    6:*/		return 0x82165054;
		  /* 82165054h */ case    7:  		/* mr R3, R11 */
		/* 82165054h case    7:*/		regs.R3 = regs.R11;
		/* 82165054h case    7:*/		return 0x82165058;
		  /* 82165058h */ case    8:  		/* bl -328 */
		/* 82165058h case    8:*/		regs.LR = 0x8216505C; return 0x82164F10;
		/* 82165058h case    8:*/		return 0x8216505C;
		  /* 8216505Ch */ case    9:  		/* b 112 */
		/* 8216505Ch case    9:*/		return 0x821650CC;
		/* 8216505Ch case    9:*/		return 0x82165060;
	}
	return 0x82165060;
} // Block from 82165038h-82165060h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82165060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165060);
		  /* 82165060h */ case    0:  		/* lwz R9, <#[R11 + 140]> */
		/* 82165060h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000008C) );
		/* 82165060h case    0:*/		return 0x82165064;
		  /* 82165064h */ case    1:  		/* lwz R10, <#[R11 + 144]> */
		/* 82165064h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000090) );
		/* 82165064h case    1:*/		return 0x82165068;
		  /* 82165068h */ case    2:  		/* subf R9, R10, R9 */
		/* 82165068h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82165068h case    2:*/		return 0x8216506C;
		  /* 8216506Ch */ case    3:  		/* addi R9, R9, 4096 */
		/* 8216506Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 8216506Ch case    3:*/		return 0x82165070;
		  /* 82165070h */ case    4:  		/* cmplw CR6, R9, R4 */
		/* 82165070h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82165070h case    4:*/		return 0x82165074;
		  /* 82165074h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 82165074h case    5:*/		if ( regs.CR[6].lt ) { return 0x82165084;  }
		/* 82165074h case    5:*/		return 0x82165078;
		  /* 82165078h */ case    6:  		/* add R9, R10, R4 */
		/* 82165078h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 82165078h case    6:*/		return 0x8216507C;
		  /* 8216507Ch */ case    7:  		/* stw R9, <#[R11 + 144]> */
		/* 8216507Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 8216507Ch case    7:*/		return 0x82165080;
		  /* 82165080h */ case    8:  		/* b 72 */
		/* 82165080h case    8:*/		return 0x821650C8;
		/* 82165080h case    8:*/		return 0x82165084;
	}
	return 0x82165084;
} // Block from 82165060h-82165084h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82165084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165084);
		  /* 82165084h */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 82165084h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 82165084h case    0:*/		return 0x82165088;
		  /* 82165088h */ case    1:  		/* addi R10, R10, -1 */
		/* 82165088h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82165088h case    1:*/		return 0x8216508C;
		  /* 8216508Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216508Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216508Ch case    2:*/		return 0x82165090;
		  /* 82165090h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82165090h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82165090h case    3:*/		return 0x82165094;
		  /* 82165094h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82165094h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82165094h case    4:*/		return 0x82165098;
		  /* 82165098h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82165098h case    5:*/		if ( regs.CR[6].eq ) { return 0x821650BC;  }
		/* 82165098h case    5:*/		return 0x8216509C;
		  /* 8216509Ch */ case    6:  		/* lwz R9, <#[R31]> */
		/* 8216509Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216509Ch case    6:*/		return 0x821650A0;
		  /* 821650A0h */ case    7:  		/* mr R5, R4 */
		/* 821650A0h case    7:*/		regs.R5 = regs.R4;
		/* 821650A0h case    7:*/		return 0x821650A4;
		  /* 821650A4h */ case    8:  		/* li R4, 0 */
		/* 821650A4h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821650A4h case    8:*/		return 0x821650A8;
		  /* 821650A8h */ case    9:  		/* mr R3, R31 */
		/* 821650A8h case    9:*/		regs.R3 = regs.R31;
		/* 821650A8h case    9:*/		return 0x821650AC;
		  /* 821650ACh */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 821650ACh case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821650ACh case   10:*/		return 0x821650B0;
		  /* 821650B0h */ case   11:  		/* bl -867696 */
		/* 821650B0h case   11:*/		regs.LR = 0x821650B4; return 0x82091340;
		/* 821650B0h case   11:*/		return 0x821650B4;
		  /* 821650B4h */ case   12:  		/* mr R10, R31 */
		/* 821650B4h case   12:*/		regs.R10 = regs.R31;
		/* 821650B4h case   12:*/		return 0x821650B8;
		  /* 821650B8h */ case   13:  		/* b 16 */
		/* 821650B8h case   13:*/		return 0x821650C8;
		/* 821650B8h case   13:*/		return 0x821650BC;
	}
	return 0x821650BC;
} // Block from 82165084h-821650BCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821650BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821650BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821650BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821650BC);
		  /* 821650BCh */ case    0:  		/* mr R3, R11 */
		/* 821650BCh case    0:*/		regs.R3 = regs.R11;
		/* 821650BCh case    0:*/		return 0x821650C0;
		  /* 821650C0h */ case    1:  		/* bl -2768 */
		/* 821650C0h case    1:*/		regs.LR = 0x821650C4; return 0x821645F0;
		/* 821650C0h case    1:*/		return 0x821650C4;
		  /* 821650C4h */ case    2:  		/* mr R10, R3 */
		/* 821650C4h case    2:*/		regs.R10 = regs.R3;
		/* 821650C4h case    2:*/		return 0x821650C8;
	}
	return 0x821650C8;
} // Block from 821650BCh-821650C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821650C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821650C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821650C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821650C8);
		  /* 821650C8h */ case    0:  		/* mr R3, R10 */
		/* 821650C8h case    0:*/		regs.R3 = regs.R10;
		/* 821650C8h case    0:*/		return 0x821650CC;
	}
	return 0x821650CC;
} // Block from 821650C8h-821650CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821650CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821650CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821650CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821650CC);
		  /* 821650CCh */ case    0:  		/* addi R1, R1, 96 */
		/* 821650CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821650CCh case    0:*/		return 0x821650D0;
		  /* 821650D0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821650D0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821650D0h case    1:*/		return 0x821650D4;
		  /* 821650D4h */ case    2:  		/* mtspr LR, R12 */
		/* 821650D4h case    2:*/		regs.LR = regs.R12;
		/* 821650D4h case    2:*/		return 0x821650D8;
		  /* 821650D8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821650D8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821650D8h case    3:*/		return 0x821650DC;
		  /* 821650DCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 821650DCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821650DCh case    4:*/		return 0x821650E0;
	}
	return 0x821650E0;
} // Block from 821650CCh-821650E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821650E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821650E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821650E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821650E0);
		  /* 821650E0h */ case    0:  		/* mfspr R12, LR */
		/* 821650E0h case    0:*/		regs.R12 = regs.LR;
		/* 821650E0h case    0:*/		return 0x821650E4;
		  /* 821650E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821650E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821650E4h case    1:*/		return 0x821650E8;
		  /* 821650E8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821650E8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821650E8h case    2:*/		return 0x821650EC;
		  /* 821650ECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821650ECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821650ECh case    3:*/		return 0x821650F0;
		  /* 821650F0h */ case    4:  		/* addi R10, R4, 3 */
		/* 821650F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x3);
		/* 821650F0h case    4:*/		return 0x821650F4;
		  /* 821650F4h */ case    5:  		/* addi R11, R3, 972 */
		/* 821650F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3CC);
		/* 821650F4h case    5:*/		return 0x821650F8;
		  /* 821650F8h */ case    6:  		/* rlwinm R4, R10, 0, 0, 29 */
		/* 821650F8h case    6:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R10);
		/* 821650F8h case    6:*/		return 0x821650FC;
		  /* 821650FCh */ case    7:  		/* cmplwi CR6, R4, 132 */
		/* 821650FCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 821650FCh case    7:*/		return 0x82165100;
		  /* 82165100h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 82165100h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82165110;  }
		/* 82165100h case    8:*/		return 0x82165104;
		  /* 82165104h */ case    9:  		/* mr R3, R11 */
		/* 82165104h case    9:*/		regs.R3 = regs.R11;
		/* 82165104h case    9:*/		return 0x82165108;
		  /* 82165108h */ case   10:  		/* bl -504 */
		/* 82165108h case   10:*/		regs.LR = 0x8216510C; return 0x82164F10;
		/* 82165108h case   10:*/		return 0x8216510C;
		  /* 8216510Ch */ case   11:  		/* b 112 */
		/* 8216510Ch case   11:*/		return 0x8216517C;
		/* 8216510Ch case   11:*/		return 0x82165110;
	}
	return 0x82165110;
} // Block from 821650E0h-82165110h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82165110h
// Function '?GetVFETCHInfo@Instruction@D3DXShader@@QAAPAUInstruction_VFETCH@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165110);
		  /* 82165110h */ case    0:  		/* lwz R9, <#[R11 + 140]> */
		/* 82165110h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000008C) );
		/* 82165110h case    0:*/		return 0x82165114;
		  /* 82165114h */ case    1:  		/* lwz R10, <#[R11 + 144]> */
		/* 82165114h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000090) );
		/* 82165114h case    1:*/		return 0x82165118;
		  /* 82165118h */ case    2:  		/* subf R9, R10, R9 */
		/* 82165118h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82165118h case    2:*/		return 0x8216511C;
		  /* 8216511Ch */ case    3:  		/* addi R9, R9, 4096 */
		/* 8216511Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 8216511Ch case    3:*/		return 0x82165120;
		  /* 82165120h */ case    4:  		/* cmplw CR6, R9, R4 */
		/* 82165120h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82165120h case    4:*/		return 0x82165124;
		  /* 82165124h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 82165124h case    5:*/		if ( regs.CR[6].lt ) { return 0x82165134;  }
		/* 82165124h case    5:*/		return 0x82165128;
		  /* 82165128h */ case    6:  		/* add R9, R10, R4 */
		/* 82165128h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 82165128h case    6:*/		return 0x8216512C;
		  /* 8216512Ch */ case    7:  		/* stw R9, <#[R11 + 144]> */
		/* 8216512Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 8216512Ch case    7:*/		return 0x82165130;
		  /* 82165130h */ case    8:  		/* b 72 */
		/* 82165130h case    8:*/		return 0x82165178;
		/* 82165130h case    8:*/		return 0x82165134;
	}
	return 0x82165134;
} // Block from 82165110h-82165134h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82165134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165134);
		  /* 82165134h */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 82165134h case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 82165134h case    0:*/		return 0x82165138;
		  /* 82165138h */ case    1:  		/* addi R10, R10, -1 */
		/* 82165138h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82165138h case    1:*/		return 0x8216513C;
		  /* 8216513Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216513Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216513Ch case    2:*/		return 0x82165140;
		  /* 82165140h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82165140h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82165140h case    3:*/		return 0x82165144;
		  /* 82165144h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82165144h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82165144h case    4:*/		return 0x82165148;
		  /* 82165148h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82165148h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216516C;  }
		/* 82165148h case    5:*/		return 0x8216514C;
		  /* 8216514Ch */ case    6:  		/* lwz R9, <#[R31]> */
		/* 8216514Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216514Ch case    6:*/		return 0x82165150;
		  /* 82165150h */ case    7:  		/* mr R5, R4 */
		/* 82165150h case    7:*/		regs.R5 = regs.R4;
		/* 82165150h case    7:*/		return 0x82165154;
		  /* 82165154h */ case    8:  		/* li R4, 0 */
		/* 82165154h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82165154h case    8:*/		return 0x82165158;
	}
	return 0x82165158;
} // Block from 82165134h-82165158h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82165158h
// Function '?GetControlTransferInfo@Instruction@D3DXShader@@QAAPAUInstruction_ControlTransfer@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165158);
		  /* 82165158h */ case    0:  		/* mr R3, R31 */
		/* 82165158h case    0:*/		regs.R3 = regs.R31;
		/* 82165158h case    0:*/		return 0x8216515C;
		  /* 8216515Ch */ case    1:  		/* stwx R9, <#[R10 + R11]> */
		/* 8216515Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8216515Ch case    1:*/		return 0x82165160;
		  /* 82165160h */ case    2:  		/* bl -867872 */
		/* 82165160h case    2:*/		regs.LR = 0x82165164; return 0x82091340;
		/* 82165160h case    2:*/		return 0x82165164;
		  /* 82165164h */ case    3:  		/* mr R10, R31 */
		/* 82165164h case    3:*/		regs.R10 = regs.R31;
		/* 82165164h case    3:*/		return 0x82165168;
		  /* 82165168h */ case    4:  		/* b 16 */
		/* 82165168h case    4:*/		return 0x82165178;
		/* 82165168h case    4:*/		return 0x8216516C;
	}
	return 0x8216516C;
} // Block from 82165158h-8216516Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216516Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216516C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216516C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216516C);
		  /* 8216516Ch */ case    0:  		/* mr R3, R11 */
		/* 8216516Ch case    0:*/		regs.R3 = regs.R11;
		/* 8216516Ch case    0:*/		return 0x82165170;
		  /* 82165170h */ case    1:  		/* bl -2944 */
		/* 82165170h case    1:*/		regs.LR = 0x82165174; return 0x821645F0;
		/* 82165170h case    1:*/		return 0x82165174;
		  /* 82165174h */ case    2:  		/* mr R10, R3 */
		/* 82165174h case    2:*/		regs.R10 = regs.R3;
		/* 82165174h case    2:*/		return 0x82165178;
	}
	return 0x82165178;
} // Block from 8216516Ch-82165178h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165178);
		  /* 82165178h */ case    0:  		/* mr R3, R10 */
		/* 82165178h case    0:*/		regs.R3 = regs.R10;
		/* 82165178h case    0:*/		return 0x8216517C;
	}
	return 0x8216517C;
} // Block from 82165178h-8216517Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216517Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216517C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216517C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216517C);
		  /* 8216517Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8216517Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216517Ch case    0:*/		return 0x82165180;
		  /* 82165180h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82165180h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82165180h case    1:*/		return 0x82165184;
		  /* 82165184h */ case    2:  		/* mtspr LR, R12 */
		/* 82165184h case    2:*/		regs.LR = regs.R12;
		/* 82165184h case    2:*/		return 0x82165188;
		  /* 82165188h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82165188h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82165188h case    3:*/		return 0x8216518C;
		  /* 8216518Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 8216518Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216518Ch case    4:*/		return 0x82165190;
	}
	return 0x82165190;
} // Block from 8216517Ch-82165190h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82165190h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165190);
		  /* 82165190h */ case    0:  		/* mfspr R12, LR */
		/* 82165190h case    0:*/		regs.R12 = regs.LR;
		/* 82165190h case    0:*/		return 0x82165194;
		  /* 82165194h */ case    1:  		/* bl -868192 */
		/* 82165194h case    1:*/		regs.LR = 0x82165198; return 0x82091234;
		/* 82165194h case    1:*/		return 0x82165198;
		  /* 82165198h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82165198h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82165198h case    2:*/		return 0x8216519C;
		  /* 8216519Ch */ case    3:  		/* lwz R10, <#[R3 + 44]> */
		/* 8216519Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000002C) );
		/* 8216519Ch case    3:*/		return 0x821651A0;
	}
	return 0x821651A0;
} // Block from 82165190h-821651A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821651A0h
// Function '?GetControlFlowPreference@Instruction@D3DXShader@@QAA?AW4ControlFlowPreference@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821651A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821651A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821651A0);
		  /* 821651A0h */ case    0:  		/* mr R23, R3 */
		/* 821651A0h case    0:*/		regs.R23 = regs.R3;
		/* 821651A0h case    0:*/		return 0x821651A4;
		  /* 821651A4h */ case    1:  		/* li R21, 0 */
		/* 821651A4h case    1:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821651A4h case    1:*/		return 0x821651A8;
		  /* 821651A8h */ case    2:  		/* li R20, 1 */
		/* 821651A8h case    2:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 821651A8h case    2:*/		return 0x821651AC;
		  /* 821651ACh */ case    3:  		/* rlwinm. R11, R10, 0, 8, 8 */
		/* 821651ACh case    3:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R10);
		/* 821651ACh case    3:*/		return 0x821651B0;
		  /* 821651B0h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 821651B0h case    4:*/		if ( regs.CR[0].eq ) { return 0x821651D0;  }
		/* 821651B0h case    4:*/		return 0x821651B4;
		  /* 821651B4h */ case    5:  		/* lwz R11, <#[R3 + 56]> */
		/* 821651B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 821651B4h case    5:*/		return 0x821651B8;
		  /* 821651B8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821651B8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821651B8h case    6:*/		return 0x821651BC;
		  /* 821651BCh */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821651BCh case    7:*/		if ( regs.CR[6].eq ) { return 0x821651D0;  }
		/* 821651BCh case    7:*/		return 0x821651C0;
		  /* 821651C0h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 821651C0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821651C0h case    8:*/		return 0x821651C4;
		  /* 821651C4h */ case    9:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 821651C4h case    9:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 821651C4h case    9:*/		return 0x821651C8;
		  /* 821651C8h */ case   10:  		/* mr R11, R20 */
		/* 821651C8h case   10:*/		regs.R11 = regs.R20;
		/* 821651C8h case   10:*/		return 0x821651CC;
		  /* 821651CCh */ case   11:  		/* bc 4, CR0_EQ, 8 */
		/* 821651CCh case   11:*/		if ( !regs.CR[0].eq ) { return 0x821651D4;  }
		/* 821651CCh case   11:*/		return 0x821651D0;
	}
	return 0x821651D0;
} // Block from 821651A0h-821651D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821651D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821651D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821651D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821651D0);
		  /* 821651D0h */ case    0:  		/* mr R11, R21 */
		/* 821651D0h case    0:*/		regs.R11 = regs.R21;
		/* 821651D0h case    0:*/		return 0x821651D4;
	}
	return 0x821651D4;
} // Block from 821651D0h-821651D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821651D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821651D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821651D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821651D4);
		  /* 821651D4h */ case    0:  		/* rlwinm. R9, R10, 0, 7, 7 */
		/* 821651D4h case    0:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R9,regs.R10);
		/* 821651D4h case    0:*/		return 0x821651D8;
		  /* 821651D8h */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 821651D8h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 821651D8h case    1:*/		return 0x821651DC;
		  /* 821651DCh */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 821651DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8216520C;  }
		/* 821651DCh case    2:*/		return 0x821651E0;
		  /* 821651E0h */ case    3:  		/* lwz R11, <#[R23 + 56]> */
		/* 821651E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000038) );
		/* 821651E0h case    3:*/		return 0x821651E4;
		  /* 821651E4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821651E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821651E4h case    4:*/		return 0x821651E8;
		  /* 821651E8h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 821651E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821651FC;  }
		/* 821651E8h case    5:*/		return 0x821651EC;
		  /* 821651ECh */ case    6:  		/* lwz R11, <#[R11]> */
		/* 821651ECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821651ECh case    6:*/		return 0x821651F0;
		  /* 821651F0h */ case    7:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 821651F0h case    7:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 821651F0h case    7:*/		return 0x821651F4;
		  /* 821651F4h */ case    8:  		/* mr R11, R20 */
		/* 821651F4h case    8:*/		regs.R11 = regs.R20;
		/* 821651F4h case    8:*/		return 0x821651F8;
		  /* 821651F8h */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 821651F8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82165200;  }
		/* 821651F8h case    9:*/		return 0x821651FC;
	}
	return 0x821651FC;
} // Block from 821651D4h-821651FCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821651FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821651FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821651FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821651FC);
		  /* 821651FCh */ case    0:  		/* mr R11, R21 */
		/* 821651FCh case    0:*/		regs.R11 = regs.R21;
		/* 821651FCh case    0:*/		return 0x82165200;
	}
	return 0x82165200;
} // Block from 821651FCh-82165200h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165200h
// Function '?GetLoopStartInfo@Instruction@D3DXShader@@QAAPAUInstruction_LoopStart@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165200);
		  /* 82165200h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165200h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165200h case    0:*/		return 0x82165204;
		  /* 82165204h */ case    1:  		/* mr R11, R20 */
		/* 82165204h case    1:*/		regs.R11 = regs.R20;
		/* 82165204h case    1:*/		return 0x82165208;
		  /* 82165208h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82165208h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82165210;  }
		/* 82165208h case    2:*/		return 0x8216520C;
	}
	return 0x8216520C;
} // Block from 82165200h-8216520Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216520Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216520C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216520C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216520C);
		  /* 8216520Ch */ case    0:  		/* mr R11, R21 */
		/* 8216520Ch case    0:*/		regs.R11 = regs.R21;
		/* 8216520Ch case    0:*/		return 0x82165210;
	}
	return 0x82165210;
} // Block from 8216520Ch-82165210h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165210);
		  /* 82165210h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82165210h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82165210h case    0:*/		return 0x82165214;
		  /* 82165214h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82165214h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82165224;  }
		/* 82165214h case    1:*/		return 0x82165218;
		  /* 82165218h */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165218h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165218h case    2:*/		return 0x8216521C;
		  /* 8216521Ch */ case    3:  		/* mr R11, R21 */
		/* 8216521Ch case    3:*/		regs.R11 = regs.R21;
		/* 8216521Ch case    3:*/		return 0x82165220;
		  /* 82165220h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82165220h case    4:*/		if ( regs.CR[0].eq ) { return 0x82165228;  }
		/* 82165220h case    4:*/		return 0x82165224;
	}
	return 0x82165224;
} // Block from 82165210h-82165224h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82165224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165224);
		  /* 82165224h */ case    0:  		/* mr R11, R20 */
		/* 82165224h case    0:*/		regs.R11 = regs.R20;
		/* 82165224h case    0:*/		return 0x82165228;
	}
	return 0x82165228;
} // Block from 82165224h-82165228h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165228);
		  /* 82165228h */ case    0:  		/* rlwinm R19, R11, 0, 24, 31 */
		/* 82165228h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R19,regs.R11);
		/* 82165228h case    0:*/		return 0x8216522C;
		  /* 8216522Ch */ case    1:  		/* lwz R11, <#[R23 + 4]> */
		/* 8216522Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8216522Ch case    1:*/		return 0x82165230;
		  /* 82165230h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82165230h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82165230h case    2:*/		return 0x82165234;
		  /* 82165234h */ case    3:  		/* addic R10, R10, -1 */
		/* 82165234h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82165234h case    3:*/		return 0x82165238;
		  /* 82165238h */ case    4:  		/* subfe R10, R10, R10 */
		/* 82165238h case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82165238h case    4:*/		return 0x8216523C;
		  /* 8216523Ch */ case    5:  		/* and R22, R10, R11 */
		/* 8216523Ch case    5:*/		cpu::op::and<0>(regs,&regs.R22,regs.R10,regs.R11);
		/* 8216523Ch case    5:*/		return 0x82165240;
		  /* 82165240h */ case    6:  		/* cmplwi CR6, R22, 0 */
		/* 82165240h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82165240h case    6:*/		return 0x82165244;
		  /* 82165244h */ case    7:  		/* bc 12, CR6_EQ, 1568 */
		/* 82165244h case    7:*/		if ( regs.CR[6].eq ) { return 0x82165864;  }
		/* 82165244h case    7:*/		return 0x82165248;
	}
	return 0x82165248;
} // Block from 82165228h-82165248h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82165248h
// Function '?IsTempRegisterDependency@Dependency@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165248);
		  /* 82165248h */ case    0:  		/* lwz R11, <#[R22 + 28]> */
		/* 82165248h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000001C) );
		/* 82165248h case    0:*/		return 0x8216524C;
		  /* 8216524Ch */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216524Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216524Ch case    1:*/		return 0x82165250;
		  /* 82165250h */ case    2:  		/* bc 4, CR0_EQ, 1432 */
		/* 82165250h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821657E8;  }
		/* 82165250h case    2:*/		return 0x82165254;
		  /* 82165254h */ case    3:  		/* mr R24, R11 */
		/* 82165254h case    3:*/		regs.R24 = regs.R11;
		/* 82165254h case    3:*/		return 0x82165258;
		  /* 82165258h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82165258h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82165258h case    4:*/		return 0x8216525C;
		  /* 8216525Ch */ case    5:  		/* bc 12, CR0_EQ, 1420 */
		/* 8216525Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x821657E8;  }
		/* 8216525Ch case    5:*/		return 0x82165260;
		  /* 82165260h */ case    6:  		/* lwz R30, <#[R24 + 8]> */
		/* 82165260h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0x00000008) );
		/* 82165260h case    6:*/		return 0x82165264;
		  /* 82165264h */ case    7:  		/* rlwinm R31, R30, 25, 25, 31 */
		/* 82165264h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R31,regs.R30);
		/* 82165264h case    7:*/		return 0x82165268;
		  /* 82165268h */ case    8:  		/* cmplwi CR6, R31, 117 */
		/* 82165268h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000075);
		/* 82165268h case    8:*/		return 0x8216526C;
		  /* 8216526Ch */ case    9:  		/* bc 4, CR6_EQ, 60 */
		/* 8216526Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821652A8;  }
		/* 8216526Ch case    9:*/		return 0x82165270;
		  /* 82165270h */ case   10:  		/* li R6, 0 */
		/* 82165270h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82165270h case   10:*/		return 0x82165274;
		  /* 82165274h */ case   11:  		/* li R5, 0 */
		/* 82165274h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82165274h case   11:*/		return 0x82165278;
		  /* 82165278h */ case   12:  		/* li R4, 117 */
		/* 82165278h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 82165278h case   12:*/		return 0x8216527C;
		  /* 8216527Ch */ case   13:  		/* mr R3, R23 */
		/* 8216527Ch case   13:*/		regs.R3 = regs.R23;
		/* 8216527Ch case   13:*/		return 0x82165280;
		  /* 82165280h */ case   14:  		/* bl -3664 */
		/* 82165280h case   14:*/		regs.LR = 0x82165284; return 0x82164430;
		/* 82165280h case   14:*/		return 0x82165284;
		  /* 82165284h */ case   15:  		/* addi R11, R24, -16 */
		/* 82165284h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFF0);
		/* 82165284h case   15:*/		return 0x82165288;
		  /* 82165288h */ case   16:  		/* add R11, R3, R11 */
		/* 82165288h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82165288h case   16:*/		return 0x8216528C;
		  /* 8216528Ch */ case   17:  		/* lwz R10, <#[R11]> */
		/* 8216528Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216528Ch case   17:*/		return 0x82165290;
		  /* 82165290h */ case   18:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82165290h case   18:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82165290h case   18:*/		return 0x82165294;
		  /* 82165294h */ case   19:  		/* cmplwi CR6, R10, 7 */
		/* 82165294h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 82165294h case   19:*/		return 0x82165298;
		  /* 82165298h */ case   20:  		/* bc 4, CR6_EQ, 16 */
		/* 82165298h case   20:*/		if ( !regs.CR[6].eq ) { return 0x821652A8;  }
		/* 82165298h case   20:*/		return 0x8216529C;
		  /* 8216529Ch */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216529Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216529Ch case   21:*/		return 0x821652A0;
	}
	return 0x821652A0;
} // Block from 82165248h-821652A0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821652A0h
// Function '??2CCompilerHeapCommentBlock@D3DXShader@@SAPAXIPAVCompilerHeap@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821652A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821652A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821652A0);
		  /* 821652A0h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 821652A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821652A0h case    0:*/		return 0x821652A4;
		  /* 821652A4h */ case    1:  		/* bc 12, CR6_EQ, 1360 */
		/* 821652A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821657F4;  }
		/* 821652A4h case    1:*/		return 0x821652A8;
	}
	return 0x821652A8;
} // Block from 821652A0h-821652A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821652A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821652A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821652A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821652A8);
		  /* 821652A8h */ case    0:  		/* rlwinm. R11, R19, 0, 24, 31 */
		/* 821652A8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R19);
		/* 821652A8h case    0:*/		return 0x821652AC;
		  /* 821652ACh */ case    1:  		/* bc 12, CR0_EQ, 200 */
		/* 821652ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82165374;  }
		/* 821652ACh case    1:*/		return 0x821652B0;
		  /* 821652B0h */ case    2:  		/* rlwinm. R11, R30, 27, 31, 31 */
		/* 821652B0h case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R30);
		/* 821652B0h case    2:*/		return 0x821652B4;
		  /* 821652B4h */ case    3:  		/* bc 12, CR0_EQ, 192 */
		/* 821652B4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82165374;  }
		/* 821652B4h case    3:*/		return 0x821652B8;
		  /* 821652B8h */ case    4:  		/* lwz R11, <#[R24]> */
		/* 821652B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821652B8h case    4:*/		return 0x821652BC;
		  /* 821652BCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821652BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821652BCh case    5:*/		return 0x821652C0;
		  /* 821652C0h */ case    6:  		/* bc 12, CR6_EQ, 1292 */
		/* 821652C0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821657CC;  }
		/* 821652C0h case    6:*/		return 0x821652C4;
		  /* 821652C4h */ case    7:  		/* lwz R28, <#[R11 + 12]> */
		/* 821652C4h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000000C) );
		/* 821652C4h case    7:*/		return 0x821652C8;
		  /* 821652C8h */ case    8:  		/* lwz R10, <#[R28 + 8]> */
		/* 821652C8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821652C8h case    8:*/		return 0x821652CC;
		  /* 821652CCh */ case    9:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821652CCh case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821652CCh case    9:*/		return 0x821652D0;
		  /* 821652D0h */ case   10:  		/* cmplwi CR6, R10, 12032 */
		/* 821652D0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002F00);
		/* 821652D0h case   10:*/		return 0x821652D4;
		  /* 821652D4h */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 821652D4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821652E0;  }
		/* 821652D4h case   11:*/		return 0x821652D8;
		  /* 821652D8h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 821652D8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821652D8h case   12:*/		return 0x821652DC;
		  /* 821652DCh */ case   13:  		/* b -32 */
		/* 821652DCh case   13:*/		return 0x821652BC;
		/* 821652DCh case   13:*/		return 0x821652E0;
	}
	return 0x821652E0;
} // Block from 821652A8h-821652E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821652E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821652E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821652E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821652E0);
		  /* 821652E0h */ case    0:  		/* li R6, 0 */
		/* 821652E0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821652E0h case    0:*/		return 0x821652E4;
		  /* 821652E4h */ case    1:  		/* li R5, 0 */
		/* 821652E4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821652E4h case    1:*/		return 0x821652E8;
		  /* 821652E8h */ case    2:  		/* li R4, 94 */
		/* 821652E8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x5E);
		/* 821652E8h case    2:*/		return 0x821652EC;
		  /* 821652ECh */ case    3:  		/* mr R3, R23 */
		/* 821652ECh case    3:*/		regs.R3 = regs.R23;
		/* 821652ECh case    3:*/		return 0x821652F0;
		  /* 821652F0h */ case    4:  		/* bl -3776 */
		/* 821652F0h case    4:*/		regs.LR = 0x821652F4; return 0x82164430;
		/* 821652F0h case    4:*/		return 0x821652F4;
		  /* 821652F4h */ case    5:  		/* addi R11, R28, -12 */
		/* 821652F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFF4);
		/* 821652F4h case    5:*/		return 0x821652F8;
		  /* 821652F8h */ case    6:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821652F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821652F8h case    6:*/		return 0x821652FC;
		  /* 821652FCh */ case    7:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 821652FCh case    7:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 821652FCh case    7:*/		return 0x82165300;
		  /* 82165300h */ case    8:  		/* bc 4, CR0_EQ, 1228 */
		/* 82165300h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821657CC;  }
		/* 82165300h case    8:*/		return 0x82165304;
		  /* 82165304h */ case    9:  		/* addi R29, R24, 4 */
		/* 82165304h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R24,0x4);
		/* 82165304h case    9:*/		return 0x82165308;
	}
	return 0x82165308;
} // Block from 821652E0h-82165308h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82165308h
// Function '?AllocSmallPhaseMem@Compiler@D3DXShader@@QAAPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165308);
		  /* 82165308h */ case    0:  		/* lwz R31, <#[R29]> */
		/* 82165308h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 82165308h case    0:*/		return 0x8216530C;
		  /* 8216530Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8216530Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216530Ch case    1:*/		return 0x82165310;
		  /* 82165310h */ case    2:  		/* bc 12, CR6_EQ, 1276 */
		/* 82165310h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216580C;  }
		/* 82165310h case    2:*/		return 0x82165314;
		  /* 82165314h */ case    3:  		/* lwz R30, <#[R31 + 16]> */
		/* 82165314h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 82165314h case    3:*/		return 0x82165318;
		  /* 82165318h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82165318h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82165318h case    4:*/		return 0x8216531C;
		  /* 8216531Ch */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 8216531Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82165360;  }
		/* 8216531Ch case    5:*/		return 0x82165320;
		  /* 82165320h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 82165320h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82165320h case    6:*/		return 0x82165324;
		  /* 82165324h */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82165324h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82165324h case    7:*/		return 0x82165328;
		  /* 82165328h */ case    8:  		/* bc 12, CR0_EQ, 56 */
		/* 82165328h case    8:*/		if ( regs.CR[0].eq ) { return 0x82165360;  }
		/* 82165328h case    8:*/		return 0x8216532C;
		  /* 8216532Ch */ case    9:  		/* mr R5, R23 */
		/* 8216532Ch case    9:*/		regs.R5 = regs.R23;
		/* 8216532Ch case    9:*/		return 0x82165330;
		  /* 82165330h */ case   10:  		/* mr R4, R31 */
		/* 82165330h case   10:*/		regs.R4 = regs.R31;
		/* 82165330h case   10:*/		return 0x82165334;
		  /* 82165334h */ case   11:  		/* mr R3, R30 */
		/* 82165334h case   11:*/		regs.R3 = regs.R30;
		/* 82165334h case   11:*/		return 0x82165338;
		  /* 82165338h */ case   12:  		/* bl 79320 */
		/* 82165338h case   12:*/		regs.LR = 0x8216533C; return 0x82178910;
		/* 82165338h case   12:*/		return 0x8216533C;
		  /* 8216533Ch */ case   13:  		/* mr R3, R30 */
		/* 8216533Ch case   13:*/		regs.R3 = regs.R30;
		/* 8216533Ch case   13:*/		return 0x82165340;
		  /* 82165340h */ case   14:  		/* bl -2496 */
		/* 82165340h case   14:*/		regs.LR = 0x82165344; return 0x82164980;
		/* 82165340h case   14:*/		return 0x82165344;
		  /* 82165344h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82165344h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82165344h case   15:*/		return 0x82165348;
		  /* 82165348h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 82165348h case   16:*/		if ( regs.CR[0].eq ) { return 0x82165360;  }
		/* 82165348h case   16:*/		return 0x8216534C;
		  /* 8216534Ch */ case   17:  		/* li R6, 1 */
		/* 8216534Ch case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8216534Ch case   17:*/		return 0x82165350;
		  /* 82165350h */ case   18:  		/* li R5, 0 */
		/* 82165350h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82165350h case   18:*/		return 0x82165354;
		  /* 82165354h */ case   19:  		/* mr R4, R30 */
		/* 82165354h case   19:*/		regs.R4 = regs.R30;
		/* 82165354h case   19:*/		return 0x82165358;
		  /* 82165358h */ case   20:  		/* mr R3, R23 */
		/* 82165358h case   20:*/		regs.R3 = regs.R23;
		/* 82165358h case   20:*/		return 0x8216535C;
		  /* 8216535Ch */ case   21:  		/* bl 811116 */
		/* 8216535Ch case   21:*/		regs.LR = 0x82165360; return 0x8222B3C8;
		/* 8216535Ch case   21:*/		return 0x82165360;
	}
	return 0x82165360;
} // Block from 82165308h-82165360h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82165360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165360);
		  /* 82165360h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 82165360h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82165360h case    0:*/		return 0x82165364;
		  /* 82165364h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82165364h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82165364h case    1:*/		return 0x82165368;
		  /* 82165368h */ case    2:  		/* bc 4, CR6_EQ, -96 */
		/* 82165368h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82165308;  }
		/* 82165368h case    2:*/		return 0x8216536C;
		  /* 8216536Ch */ case    3:  		/* addi R29, R31, 8 */
		/* 8216536Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 8216536Ch case    3:*/		return 0x82165370;
		  /* 82165370h */ case    4:  		/* b -104 */
		/* 82165370h case    4:*/		return 0x82165308;
		/* 82165370h case    4:*/		return 0x82165374;
	}
	return 0x82165374;
} // Block from 82165360h-82165374h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82165374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165374);
		  /* 82165374h */ case    0:  		/* mr R3, R24 */
		/* 82165374h case    0:*/		regs.R3 = regs.R24;
		/* 82165374h case    0:*/		return 0x82165378;
		  /* 82165378h */ case    1:  		/* bl -2552 */
		/* 82165378h case    1:*/		regs.LR = 0x8216537C; return 0x82164980;
		/* 82165378h case    1:*/		return 0x8216537C;
		  /* 8216537Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216537Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216537Ch case    2:*/		return 0x82165380;
		  /* 82165380h */ case    3:  		/* bc 4, CR0_EQ, 1148 */
		/* 82165380h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821657FC;  }
		/* 82165380h case    3:*/		return 0x82165384;
		  /* 82165384h */ case    4:  		/* cmplwi CR6, R31, 104 */
		/* 82165384h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000068);
		/* 82165384h case    4:*/		return 0x82165388;
		  /* 82165388h */ case    5:  		/* bc 4, CR6_EQ, 1092 */
		/* 82165388h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821657CC;  }
		/* 82165388h case    5:*/		return 0x8216538C;
		  /* 8216538Ch */ case    6:  		/* lwz R11, <#[R24 + 4]> */
		/* 8216538Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8216538Ch case    6:*/		return 0x82165390;
		  /* 82165390h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 82165390h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82165390h case    7:*/		return 0x82165394;
		  /* 82165394h */ case    8:  		/* bc 12, CR6_EQ, 1120 */
		/* 82165394h case    8:*/		if ( regs.CR[6].eq ) { return 0x821657F4;  }
		/* 82165394h case    8:*/		return 0x82165398;
	}
	return 0x82165398;
} // Block from 82165374h-82165398h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82165398h
// Function '?IsUselessInstruction@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165398);
		  /* 82165398h */ case    0:  		/* mr R6, R21 */
		/* 82165398h case    0:*/		regs.R6 = regs.R21;
		/* 82165398h case    0:*/		return 0x8216539C;
		  /* 8216539Ch */ case    1:  		/* mr R5, R11 */
		/* 8216539Ch case    1:*/		regs.R5 = regs.R11;
		/* 8216539Ch case    1:*/		return 0x821653A0;
		  /* 821653A0h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 821653A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821653A0h case    2:*/		return 0x821653A4;
		  /* 821653A4h */ case    3:  		/* bc 12, CR6_EQ, 96 */
		/* 821653A4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82165404;  }
		/* 821653A4h case    3:*/		return 0x821653A8;
		  /* 821653A8h */ case    4:  		/* lwz R11, <#[R5 + 16]> */
		/* 821653A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 821653A8h case    4:*/		return 0x821653AC;
		  /* 821653ACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821653ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821653ACh case    5:*/		return 0x821653B0;
		  /* 821653B0h */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 821653B0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821653FC;  }
		/* 821653B0h case    6:*/		return 0x821653B4;
		  /* 821653B4h */ case    7:  		/* lwz R7, <#[R5]> */
		/* 821653B4h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000000) );
		/* 821653B4h case    7:*/		return 0x821653B8;
		  /* 821653B8h */ case    8:  		/* rlwinm. R8, R7, 7, 29, 31 */
		/* 821653B8h case    8:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R7);
		/* 821653B8h case    8:*/		return 0x821653BC;
		  /* 821653BCh */ case    9:  		/* bc 12, CR0_EQ, 64 */
		/* 821653BCh case    9:*/		if ( regs.CR[0].eq ) { return 0x821653FC;  }
		/* 821653BCh case    9:*/		return 0x821653C0;
		  /* 821653C0h */ case   10:  		/* mr R9, R21 */
		/* 821653C0h case   10:*/		regs.R9 = regs.R21;
		/* 821653C0h case   10:*/		return 0x821653C4;
		  /* 821653C4h */ case   11:  		/* mr R11, R21 */
		/* 821653C4h case   11:*/		regs.R11 = regs.R21;
		/* 821653C4h case   11:*/		return 0x821653C8;
		  /* 821653C8h */ case   12:  		/* cmplwi CR6, R8, 0 */
		/* 821653C8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821653C8h case   12:*/		return 0x821653CC;
		  /* 821653CCh */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 821653CCh case   13:*/		if ( regs.CR[6].eq ) { return 0x821653F8;  }
		/* 821653CCh case   13:*/		return 0x821653D0;
		  /* 821653D0h */ case   14:  		/* mr R10, R21 */
		/* 821653D0h case   14:*/		regs.R10 = regs.R21;
		/* 821653D0h case   14:*/		return 0x821653D4;
		  /* 821653D4h */ case   15:  		/* rlwinm R4, R7, 27, 24, 31 */
		/* 821653D4h case   15:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R4,regs.R7);
		/* 821653D4h case   15:*/		return 0x821653D8;
		  /* 821653D8h */ case   16:  		/* addi R11, R11, 1 */
		/* 821653D8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821653D8h case   16:*/		return 0x821653DC;
		  /* 821653DCh */ case   17:  		/* srw R4, R4, R10 */
		/* 821653DCh case   17:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R4,regs.R10);
		/* 821653DCh case   17:*/		return 0x821653E0;
		  /* 821653E0h */ case   18:  		/* rlwinm R4, R4, 0, 30, 31 */
		/* 821653E0h case   18:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R4);
		/* 821653E0h case   18:*/		return 0x821653E4;
		  /* 821653E4h */ case   19:  		/* addi R10, R10, 2 */
		/* 821653E4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821653E4h case   19:*/		return 0x821653E8;
		  /* 821653E8h */ case   20:  		/* slw R4, R20, R4 */
		/* 821653E8h case   20:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R20,regs.R4);
		/* 821653E8h case   20:*/		return 0x821653EC;
		  /* 821653ECh */ case   21:  		/* or R9, R4, R9 */
		/* 821653ECh case   21:*/		cpu::op::or<0>(regs,&regs.R9,regs.R4,regs.R9);
		/* 821653ECh case   21:*/		return 0x821653F0;
		  /* 821653F0h */ case   22:  		/* cmplw CR6, R11, R8 */
		/* 821653F0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821653F0h case   22:*/		return 0x821653F4;
		  /* 821653F4h */ case   23:  		/* bc 12, CR6_LT, -32 */
		/* 821653F4h case   23:*/		if ( regs.CR[6].lt ) { return 0x821653D4;  }
		/* 821653F4h case   23:*/		return 0x821653F8;
	}
	return 0x821653F8;
} // Block from 82165398h-821653F8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821653F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821653F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821653F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821653F8);
		  /* 821653F8h */ case    0:  		/* or R6, R9, R6 */
		/* 821653F8h case    0:*/		cpu::op::or<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 821653F8h case    0:*/		return 0x821653FC;
	}
	return 0x821653FC;
} // Block from 821653F8h-821653FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821653FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821653FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821653FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821653FC);
		  /* 821653FCh */ case    0:  		/* lwz R5, <#[R5 + 8]> */
		/* 821653FCh case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000008) );
		/* 821653FCh case    0:*/		return 0x82165400;
		  /* 82165400h */ case    1:  		/* b -96 */
		/* 82165400h case    1:*/		return 0x821653A0;
		/* 82165400h case    1:*/		return 0x82165404;
	}
	return 0x82165404;
} // Block from 821653FCh-82165404h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165404);
		  /* 82165404h */ case    0:  		/* rlwinm R10, R30, 31, 28, 31 */
		/* 82165404h case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R10,regs.R30);
		/* 82165404h case    0:*/		return 0x82165408;
		  /* 82165408h */ case    1:  		/* lwz R11, <#[R24 + 44]> */
		/* 82165408h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000002C) );
		/* 82165408h case    1:*/		return 0x8216540C;
		  /* 8216540Ch */ case    2:  		/* cmplw CR6, R6, R10 */
		/* 8216540Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 8216540Ch case    2:*/		return 0x82165410;
		  /* 82165410h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82165410h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82165428;  }
		/* 82165410h case    3:*/		return 0x82165414;
		  /* 82165414h */ case    4:  		/* lwz R10, <#[R11]> */
		/* 82165414h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82165414h case    4:*/		return 0x82165418;
		  /* 82165418h */ case    5:  		/* rlwinm R10, R10, 21, 11, 31 */
		/* 82165418h case    5:*/		cpu::op::rlwinm<0,21,11,31>(regs,&regs.R10,regs.R10);
		/* 82165418h case    5:*/		return 0x8216541C;
		  /* 8216541Ch */ case    6:  		/* xor R10, R10, R30 */
		/* 8216541Ch case    6:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 8216541Ch case    6:*/		return 0x82165420;
		  /* 82165420h */ case    7:  		/* rlwinm. R10, R10, 0, 15, 17 */
		/* 82165420h case    7:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R10,regs.R10);
		/* 82165420h case    7:*/		return 0x82165424;
		  /* 82165424h */ case    8:  		/* bc 12, CR0_EQ, 936 */
		/* 82165424h case    8:*/		if ( regs.CR[0].eq ) { return 0x821657CC;  }
		/* 82165424h case    8:*/		return 0x82165428;
	}
	return 0x82165428;
} // Block from 82165404h-82165428h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82165428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165428);
		  /* 82165428h */ case    0:  		/* lwz R26, <#[R11 + 12]> */
		/* 82165428h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 82165428h case    0:*/		return 0x8216542C;
		  /* 8216542Ch */ case    1:  		/* mr R29, R24 */
		/* 8216542Ch case    1:*/		regs.R29 = regs.R24;
		/* 8216542Ch case    1:*/		return 0x82165430;
		  /* 82165430h */ case    2:  		/* mr R25, R6 */
		/* 82165430h case    2:*/		regs.R25 = regs.R6;
		/* 82165430h case    2:*/		return 0x82165434;
		  /* 82165434h */ case    3:  		/* b 212 */
		/* 82165434h case    3:*/		return 0x82165508;
		/* 82165434h case    3:*/		return 0x82165438;
		  /* 82165438h */ case    4:  		/* lwz R28, <#[R26 + 44]> */
		/* 82165438h case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R26 + 0x0000002C) );
		/* 82165438h case    4:*/		return 0x8216543C;
		  /* 8216543Ch */ case    5:  		/* lwz R4, <#[R26 + 48]> */
		/* 8216543Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000030) );
		/* 8216543Ch case    5:*/		return 0x82165440;
		  /* 82165440h */ case    6:  		/* mr R3, R28 */
		/* 82165440h case    6:*/		regs.R3 = regs.R28;
		/* 82165440h case    6:*/		return 0x82165444;
		  /* 82165444h */ case    7:  		/* bl -4540 */
		/* 82165444h case    7:*/		regs.LR = 0x82165448; return 0x82164288;
		/* 82165444h case    7:*/		return 0x82165448;
	}
	return 0x82165448;
} // Block from 82165428h-82165448h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82165448h
// Function '?SetSQRegistersForFirstInstr@Compiler@D3DXShader@@AAAXPAVInstruction@2@PATGPU_PROGRAMCONTROL@@PATGPU_CONTEXTMISC@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165448);
		  /* 82165448h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82165448h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82165448h case    0:*/		return 0x8216544C;
		  /* 8216544Ch */ case    1:  		/* bc 12, CR0_EQ, 204 */
		/* 8216544Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82165518;  }
		/* 8216544Ch case    1:*/		return 0x82165450;
		  /* 82165450h */ case    2:  		/* lwz R10, <#[R26 + 4]> */
		/* 82165450h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 82165450h case    2:*/		return 0x82165454;
		  /* 82165454h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82165454h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82165454h case    3:*/		return 0x82165458;
		  /* 82165458h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82165458h case    4:*/		if ( regs.CR[6].eq ) { return 0x82165480;  }
		/* 82165458h case    4:*/		return 0x8216545C;
		  /* 8216545Ch */ case    5:  		/* lwz R11, <#[R10 + 16]> */
		/* 8216545Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8216545Ch case    5:*/		return 0x82165460;
		  /* 82165460h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82165460h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165460h case    6:*/		return 0x82165464;
		  /* 82165464h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82165464h case    7:*/		if ( regs.CR[6].eq ) { return 0x82165470;  }
		/* 82165464h case    7:*/		return 0x82165468;
		  /* 82165468h */ case    8:  		/* cmplw CR6, R11, R29 */
		/* 82165468h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82165468h case    8:*/		return 0x8216546C;
		  /* 8216546Ch */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 8216546Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82165478;  }
		/* 8216546Ch case    9:*/		return 0x82165470;
	}
	return 0x82165470;
} // Block from 82165448h-82165470h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82165470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165470);
		  /* 82165470h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82165470h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82165470h case    0:*/		return 0x82165474;
		  /* 82165474h */ case    1:  		/* b -32 */
		/* 82165474h case    1:*/		return 0x82165454;
		/* 82165474h case    1:*/		return 0x82165478;
	}
	return 0x82165478;
} // Block from 82165470h-82165478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165478);
		  /* 82165478h */ case    0:  		/* mr R11, R20 */
		/* 82165478h case    0:*/		regs.R11 = regs.R20;
		/* 82165478h case    0:*/		return 0x8216547C;
		  /* 8216547Ch */ case    1:  		/* b 8 */
		/* 8216547Ch case    1:*/		return 0x82165484;
		/* 8216547Ch case    1:*/		return 0x82165480;
	}
	return 0x82165480;
} // Block from 82165478h-82165480h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165480);
		  /* 82165480h */ case    0:  		/* mr R11, R21 */
		/* 82165480h case    0:*/		regs.R11 = regs.R21;
		/* 82165480h case    0:*/		return 0x82165484;
	}
	return 0x82165484;
} // Block from 82165480h-82165484h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165484);
		  /* 82165484h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165484h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165484h case    0:*/		return 0x82165488;
		  /* 82165488h */ case    1:  		/* bc 4, CR0_EQ, 144 */
		/* 82165488h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82165518;  }
		/* 82165488h case    1:*/		return 0x8216548C;
		  /* 8216548Ch */ case    2:  		/* lwz R8, <#[R28]> */
		/* 8216548Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000000) );
		/* 8216548Ch case    2:*/		return 0x82165490;
		  /* 82165490h */ case    3:  		/* mr R7, R21 */
		/* 82165490h case    3:*/		regs.R7 = regs.R21;
		/* 82165490h case    3:*/		return 0x82165494;
		  /* 82165494h */ case    4:  		/* mr R10, R21 */
		/* 82165494h case    4:*/		regs.R10 = regs.R21;
		/* 82165494h case    4:*/		return 0x82165498;
		  /* 82165498h */ case    5:  		/* rlwinm R5, R8, 7, 29, 31 */
		/* 82165498h case    5:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R8);
		/* 82165498h case    5:*/		return 0x8216549C;
		  /* 8216549Ch */ case    6:  		/* rlwinm R11, R30, 31, 28, 31 */
		/* 8216549Ch case    6:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R30);
		/* 8216549Ch case    6:*/		return 0x821654A0;
		  /* 821654A0h */ case    7:  		/* mr R9, R21 */
		/* 821654A0h case    7:*/		regs.R9 = regs.R21;
		/* 821654A0h case    7:*/		return 0x821654A4;
		  /* 821654A4h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 821654A4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821654A4h case    8:*/		return 0x821654A8;
		  /* 821654A8h */ case    9:  		/* bc 12, CR6_EQ, 84 */
		/* 821654A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821654FC;  }
		/* 821654A8h case    9:*/		return 0x821654AC;
		  /* 821654ACh */ case   10:  		/* addi R6, R11, -1 */
		/* 821654ACh case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 821654ACh case   10:*/		return 0x821654B0;
		  /* 821654B0h */ case   11:  		/* andc R6, R11, R6 */
		/* 821654B0h case   11:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 821654B0h case   11:*/		return 0x821654B4;
		  /* 821654B4h */ case   12:  		/* cntlzw R6, R6 */
		/* 821654B4h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R6,regs.R6);
		/* 821654B4h case   12:*/		return 0x821654B8;
		  /* 821654B8h */ case   13:  		/* subfic R6, R6, 31 */
		/* 821654B8h case   13:*/		cpu::op::subfic<0>(regs,&regs.R6,regs.R6,0x1F);
		/* 821654B8h case   13:*/		return 0x821654BC;
		  /* 821654BCh */ case   14:  		/* slw R6, R20, R6 */
		/* 821654BCh case   14:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R20,regs.R6);
		/* 821654BCh case   14:*/		return 0x821654C0;
		  /* 821654C0h */ case   15:  		/* and. R6, R6, R25 */
		/* 821654C0h case   15:*/		cpu::op::and<1>(regs,&regs.R6,regs.R6,regs.R25);
		/* 821654C0h case   15:*/		return 0x821654C4;
		  /* 821654C4h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 821654C4h case   16:*/		if ( regs.CR[0].eq ) { return 0x821654DC;  }
		/* 821654C4h case   16:*/		return 0x821654C8;
		  /* 821654C8h */ case   17:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 821654C8h case   17:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 821654C8h case   17:*/		return 0x821654CC;
		  /* 821654CCh */ case   18:  		/* srw R6, R6, R9 */
		/* 821654CCh case   18:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 821654CCh case   18:*/		return 0x821654D0;
		  /* 821654D0h */ case   19:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 821654D0h case   19:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 821654D0h case   19:*/		return 0x821654D4;
		  /* 821654D4h */ case   20:  		/* slw R6, R20, R6 */
		/* 821654D4h case   20:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R20,regs.R6);
		/* 821654D4h case   20:*/		return 0x821654D8;
		  /* 821654D8h */ case   21:  		/* or R10, R6, R10 */
		/* 821654D8h case   21:*/		cpu::op::or<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 821654D8h case   21:*/		return 0x821654DC;
	}
	return 0x821654DC;
} // Block from 82165484h-821654DCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 821654DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821654DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821654DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821654DC);
		  /* 821654DCh */ case    0:  		/* addi R7, R7, 1 */
		/* 821654DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821654DCh case    0:*/		return 0x821654E0;
		  /* 821654E0h */ case    1:  		/* addi R9, R9, 2 */
		/* 821654E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 821654E0h case    1:*/		return 0x821654E4;
		  /* 821654E4h */ case    2:  		/* cmplw CR6, R7, R5 */
		/* 821654E4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 821654E4h case    2:*/		return 0x821654E8;
		  /* 821654E8h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 821654E8h case    3:*/		if ( !regs.CR[6].lt ) { return 0x821654FC;  }
		/* 821654E8h case    3:*/		return 0x821654EC;
		  /* 821654ECh */ case    4:  		/* addi R6, R11, -1 */
		/* 821654ECh case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 821654ECh case    4:*/		return 0x821654F0;
		  /* 821654F0h */ case    5:  		/* andc R6, R11, R6 */
		/* 821654F0h case    5:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 821654F0h case    5:*/		return 0x821654F4;
		  /* 821654F4h */ case    6:  		/* subf R11, R6, R11 */
		/* 821654F4h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 821654F4h case    6:*/		return 0x821654F8;
		  /* 821654F8h */ case    7:  		/* b -84 */
		/* 821654F8h case    7:*/		return 0x821654A4;
		/* 821654F8h case    7:*/		return 0x821654FC;
	}
	return 0x821654FC;
} // Block from 821654DCh-821654FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821654FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821654FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821654FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821654FC);
		  /* 821654FCh */ case    0:  		/* mr R29, R26 */
		/* 821654FCh case    0:*/		regs.R29 = regs.R26;
		/* 821654FCh case    0:*/		return 0x82165500;
		  /* 82165500h */ case    1:  		/* lwz R26, <#[R28 + 12]> */
		/* 82165500h case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R28 + 0x0000000C) );
		/* 82165500h case    1:*/		return 0x82165504;
		  /* 82165504h */ case    2:  		/* mr R25, R10 */
		/* 82165504h case    2:*/		regs.R25 = regs.R10;
		/* 82165504h case    2:*/		return 0x82165508;
	}
	return 0x82165508;
} // Block from 821654FCh-82165508h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165508h
// Function '?CanPredicateExecBlock@Compiler@D3DXShader@@AAA_NK_NPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165508);
		  /* 82165508h */ case    0:  		/* lwz R30, <#[R26 + 8]> */
		/* 82165508h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000008) );
		/* 82165508h case    0:*/		return 0x8216550C;
		  /* 8216550Ch */ case    1:  		/* rlwinm R31, R30, 25, 25, 31 */
		/* 8216550Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R31,regs.R30);
		/* 8216550Ch case    1:*/		return 0x82165510;
		  /* 82165510h */ case    2:  		/* cmplwi CR6, R31, 3 */
		/* 82165510h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000003);
		/* 82165510h case    2:*/		return 0x82165514;
		  /* 82165514h */ case    3:  		/* bc 12, CR6_EQ, -220 */
		/* 82165514h case    3:*/		if ( regs.CR[6].eq ) { return 0x82165438;  }
		/* 82165514h case    3:*/		return 0x82165518;
	}
	return 0x82165518;
} // Block from 82165508h-82165518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82165518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165518);
		  /* 82165518h */ case    0:  		/* cmplwi CR6, R31, 110 */
		/* 82165518h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x0000006E);
		/* 82165518h case    0:*/		return 0x8216551C;
		  /* 8216551Ch */ case    1:  		/* bc 4, CR6_EQ, 688 */
		/* 8216551Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821657CC;  }
		/* 8216551Ch case    1:*/		return 0x82165520;
		  /* 82165520h */ case    2:  		/* lwz R10, <#[R26 + 4]> */
		/* 82165520h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 82165520h case    2:*/		return 0x82165524;
		  /* 82165524h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82165524h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82165524h case    3:*/		return 0x82165528;
		  /* 82165528h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82165528h case    4:*/		if ( regs.CR[6].eq ) { return 0x82165550;  }
		/* 82165528h case    4:*/		return 0x8216552C;
		  /* 8216552Ch */ case    5:  		/* lwz R11, <#[R10 + 16]> */
		/* 8216552Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8216552Ch case    5:*/		return 0x82165530;
		  /* 82165530h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82165530h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165530h case    6:*/		return 0x82165534;
		  /* 82165534h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82165534h case    7:*/		if ( regs.CR[6].eq ) { return 0x82165540;  }
		/* 82165534h case    7:*/		return 0x82165538;
		  /* 82165538h */ case    8:  		/* cmplw CR6, R11, R29 */
		/* 82165538h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82165538h case    8:*/		return 0x8216553C;
		  /* 8216553Ch */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 8216553Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82165548;  }
		/* 8216553Ch case    9:*/		return 0x82165540;
	}
	return 0x82165540;
} // Block from 82165518h-82165540h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82165540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165540);
		  /* 82165540h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82165540h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82165540h case    0:*/		return 0x82165544;
		  /* 82165544h */ case    1:  		/* b -32 */
		/* 82165544h case    1:*/		return 0x82165524;
		/* 82165544h case    1:*/		return 0x82165548;
	}
	return 0x82165548;
} // Block from 82165540h-82165548h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165548);
		  /* 82165548h */ case    0:  		/* mr R11, R20 */
		/* 82165548h case    0:*/		regs.R11 = regs.R20;
		/* 82165548h case    0:*/		return 0x8216554C;
		  /* 8216554Ch */ case    1:  		/* b 8 */
		/* 8216554Ch case    1:*/		return 0x82165554;
		/* 8216554Ch case    1:*/		return 0x82165550;
	}
	return 0x82165550;
} // Block from 82165548h-82165550h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165550);
		  /* 82165550h */ case    0:  		/* mr R11, R21 */
		/* 82165550h case    0:*/		regs.R11 = regs.R21;
		/* 82165550h case    0:*/		return 0x82165554;
	}
	return 0x82165554;
} // Block from 82165550h-82165554h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165554);
		  /* 82165554h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165554h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165554h case    0:*/		return 0x82165558;
		  /* 82165558h */ case    1:  		/* bc 4, CR0_EQ, 628 */
		/* 82165558h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821657CC;  }
		/* 82165558h case    1:*/		return 0x8216555C;
		  /* 8216555Ch */ case    2:  		/* rlwinm R11, R30, 31, 28, 31 */
		/* 8216555Ch case    2:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R30);
		/* 8216555Ch case    2:*/		return 0x82165560;
		  /* 82165560h */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 82165560h case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82165560h case    3:*/		return 0x82165564;
		  /* 82165564h */ case    4:  		/* bc 12, CR6_EQ, 616 */
		/* 82165564h case    4:*/		if ( regs.CR[6].eq ) { return 0x821657CC;  }
		/* 82165564h case    4:*/		return 0x82165568;
		  /* 82165568h */ case    5:  		/* addi R11, R1, 80 */
		/* 82165568h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82165568h case    5:*/		return 0x8216556C;
		  /* 8216556Ch */ case    6:  		/* mr R27, R21 */
		/* 8216556Ch case    6:*/		regs.R27 = regs.R21;
		/* 8216556Ch case    6:*/		return 0x82165570;
		  /* 82165570h */ case    7:  		/* addi R29, R1, 80 */
		/* 82165570h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0x50);
		/* 82165570h case    7:*/		return 0x82165574;
		  /* 82165574h */ case    8:  		/* addi R28, R26, 44 */
		/* 82165574h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R26,0x2C);
		/* 82165574h case    8:*/		return 0x82165578;
		  /* 82165578h */ case    9:  		/* std R21, <#[R11]> */
		/* 82165578h case    9:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R11 + 0x00000000) );
		/* 82165578h case    9:*/		return 0x8216557C;
		  /* 8216557Ch */ case   10:  		/* std R21, <#[R11 + 8]> */
		/* 8216557Ch case   10:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R11 + 0x00000008) );
		/* 8216557Ch case   10:*/		return 0x82165580;
		  /* 82165580h */ case   11:  		/* lwz R11, <#[R26 + 8]> */
		/* 82165580h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82165580h case   11:*/		return 0x82165584;
		  /* 82165584h */ case   12:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82165584h case   12:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82165584h case   12:*/		return 0x82165588;
		  /* 82165588h */ case   13:  		/* cmplw CR6, R27, R11 */
		/* 82165588h case   13:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82165588h case   13:*/		return 0x8216558C;
		  /* 8216558Ch */ case   14:  		/* bc 4, CR6_LT, 248 */
		/* 8216558Ch case   14:*/		if ( !regs.CR[6].lt ) { return 0x82165684;  }
		/* 8216558Ch case   14:*/		return 0x82165590;
		  /* 82165590h */ case   15:  		/* lwz R31, <#[R28]> */
		/* 82165590h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 82165590h case   15:*/		return 0x82165594;
		  /* 82165594h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 82165594h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82165594h case   16:*/		return 0x82165598;
	}
	return 0x82165598;
} // Block from 82165554h-82165598h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82165598h
// Function '?PredicateExecBlock@Compiler@D3DXShader@@AAAXK_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165598);
		  /* 82165598h */ case    0:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 82165598h case    0:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 82165598h case    0:*/		return 0x8216559C;
		  /* 8216559Ch */ case    1:  		/* slw R30, R20, R11 */
		/* 8216559Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R30,regs.R20,regs.R11);
		/* 8216559Ch case    1:*/		return 0x821655A0;
		  /* 821655A0h */ case    2:  		/* and. R11, R30, R25 */
		/* 821655A0h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R30,regs.R25);
		/* 821655A0h case    2:*/		return 0x821655A4;
		  /* 821655A4h */ case    3:  		/* bc 4, CR0_EQ, 208 */
		/* 821655A4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82165674;  }
		/* 821655A4h case    3:*/		return 0x821655A8;
		  /* 821655A8h */ case    4:  		/* lwz R9, <#[R31 + 12]> */
		/* 821655A8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 821655A8h case    4:*/		return 0x821655AC;
		  /* 821655ACh */ case    5:  		/* lwz R11, <#[R9 + 8]> */
		/* 821655ACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821655ACh case    5:*/		return 0x821655B0;
		  /* 821655B0h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821655B0h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821655B0h case    6:*/		return 0x821655B4;
		  /* 821655B4h */ case    7:  		/* cmplwi CR6, R11, 15360 */
		/* 821655B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 821655B4h case    7:*/		return 0x821655B8;
		  /* 821655B8h */ case    8:  		/* bc 12, CR6_EQ, 188 */
		/* 821655B8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82165674;  }
		/* 821655B8h case    8:*/		return 0x821655BC;
		  /* 821655BCh */ case    9:  		/* lwz R10, <#[R9 + 4]> */
		/* 821655BCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 821655BCh case    9:*/		return 0x821655C0;
		  /* 821655C0h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 821655C0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821655C0h case   10:*/		return 0x821655C4;
		  /* 821655C4h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 821655C4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821655EC;  }
		/* 821655C4h case   11:*/		return 0x821655C8;
		  /* 821655C8h */ case   12:  		/* lwz R11, <#[R10 + 16]> */
		/* 821655C8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821655C8h case   12:*/		return 0x821655CC;
		  /* 821655CCh */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821655CCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821655CCh case   13:*/		return 0x821655D0;
		  /* 821655D0h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 821655D0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821655DC;  }
		/* 821655D0h case   14:*/		return 0x821655D4;
		  /* 821655D4h */ case   15:  		/* cmplw CR6, R11, R26 */
		/* 821655D4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821655D4h case   15:*/		return 0x821655D8;
		  /* 821655D8h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 821655D8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821655E4;  }
		/* 821655D8h case   16:*/		return 0x821655DC;
	}
	return 0x821655DC;
} // Block from 82165598h-821655DCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 821655DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821655DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821655DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821655DC);
		  /* 821655DCh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821655DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821655DCh case    0:*/		return 0x821655E0;
		  /* 821655E0h */ case    1:  		/* b -32 */
		/* 821655E0h case    1:*/		return 0x821655C0;
		/* 821655E0h case    1:*/		return 0x821655E4;
	}
	return 0x821655E4;
} // Block from 821655DCh-821655E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821655E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821655E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821655E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821655E4);
		  /* 821655E4h */ case    0:  		/* mr R11, R20 */
		/* 821655E4h case    0:*/		regs.R11 = regs.R20;
		/* 821655E4h case    0:*/		return 0x821655E8;
	}
	return 0x821655E8;
} // Block from 821655E4h-821655E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821655E8h
// Function '?EnsureExecBlocksHaveSamePredicateState@Compiler@D3DXShader@@AAAXKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821655E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821655E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821655E8);
		  /* 821655E8h */ case    0:  		/* b 8 */
		/* 821655E8h case    0:*/		return 0x821655F0;
		/* 821655E8h case    0:*/		return 0x821655EC;
	}
	return 0x821655EC;
} // Block from 821655E8h-821655ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821655ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821655EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821655EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821655EC);
		  /* 821655ECh */ case    0:  		/* mr R11, R21 */
		/* 821655ECh case    0:*/		regs.R11 = regs.R21;
		/* 821655ECh case    0:*/		return 0x821655F0;
	}
	return 0x821655F0;
} // Block from 821655ECh-821655F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821655F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821655F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821655F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821655F0);
		  /* 821655F0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821655F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821655F0h case    0:*/		return 0x821655F4;
		  /* 821655F4h */ case    1:  		/* bc 4, CR0_EQ, 128 */
		/* 821655F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82165674;  }
		/* 821655F4h case    1:*/		return 0x821655F8;
		  /* 821655F8h */ case    2:  		/* li R8, 1 */
		/* 821655F8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821655F8h case    2:*/		return 0x821655FC;
		  /* 821655FCh */ case    3:  		/* stw R9, <#[R29]> */
		/* 821655FCh case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 821655FCh case    3:*/		return 0x82165600;
		  /* 82165600h */ case    4:  		/* li R7, 0 */
		/* 82165600h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82165600h case    4:*/		return 0x82165604;
		  /* 82165604h */ case    5:  		/* li R6, 120 */
		/* 82165604h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x78);
		/* 82165604h case    5:*/		return 0x82165608;
		  /* 82165608h */ case    6:  		/* addi R5, R22, 16 */
		/* 82165608h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R22,0x10);
		/* 82165608h case    6:*/		return 0x8216560C;
		  /* 8216560Ch */ case    7:  		/* mr R4, R22 */
		/* 8216560Ch case    7:*/		regs.R4 = regs.R22;
		/* 8216560Ch case    7:*/		return 0x82165610;
		  /* 82165610h */ case    8:  		/* mr R3, R23 */
		/* 82165610h case    8:*/		regs.R3 = regs.R23;
		/* 82165610h case    8:*/		return 0x82165614;
		  /* 82165614h */ case    9:  		/* bl 783236 */
		/* 82165614h case    9:*/		regs.LR = 0x82165618; return 0x82224998;
		/* 82165614h case    9:*/		return 0x82165618;
		  /* 82165618h */ case   10:  		/* lwz R10, <#[R3 + 8]> */
		/* 82165618h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82165618h case   10:*/		return 0x8216561C;
		  /* 8216561Ch */ case   11:  		/* lis R11, 256 */
		/* 8216561Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0x100);
		/* 8216561Ch case   11:*/		return 0x82165620;
		  /* 82165620h */ case   12:  		/* rlwinm R10, R10, 0, 31, 26 */
		/* 82165620h case   12:*/		cpu::op::rlwinm<0,0,31,26>(regs,&regs.R10,regs.R10);
		/* 82165620h case   12:*/		return 0x82165624;
		  /* 82165624h */ case   13:  		/* rlwimi R11, R30, 1, 27, 30 */
		/* 82165624h case   13:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R11,regs.R30);
		/* 82165624h case   13:*/		return 0x82165628;
		  /* 82165628h */ case   14:  		/* or R11, R11, R10 */
		/* 82165628h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82165628h case   14:*/		return 0x8216562C;
		  /* 8216562Ch */ case   15:  		/* stw R11, <#[R3 + 8]> */
		/* 8216562Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8216562Ch case   15:*/		return 0x82165630;
		  /* 82165630h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 82165630h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82165630h case   16:*/		return 0x82165634;
		  /* 82165634h */ case   17:  		/* addi R11, R11, 4 */
		/* 82165634h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82165634h case   17:*/		return 0x82165638;
		  /* 82165638h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 82165638h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82165638h case   18:*/		return 0x8216563C;
		  /* 8216563Ch */ case   19:  		/* b 12 */
		/* 8216563Ch case   19:*/		return 0x82165648;
		/* 8216563Ch case   19:*/		return 0x82165640;
		  /* 82165640h */ case   20:  		/* addi R11, R10, 8 */
		/* 82165640h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82165640h case   20:*/		return 0x82165644;
		  /* 82165644h */ case   21:  		/* lwz R10, <#[R10 + 8]> */
		/* 82165644h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82165644h case   21:*/		return 0x82165648;
	}
	return 0x82165648;
} // Block from 821655F0h-82165648h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82165648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165648);
		  /* 82165648h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 82165648h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82165648h case    0:*/		return 0x8216564C;
		  /* 8216564Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8216564Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82165640;  }
		/* 8216564Ch case    1:*/		return 0x82165650;
		  /* 82165650h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82165650h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82165650h case    2:*/		return 0x82165654;
		  /* 82165654h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82165654h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82165654h case    3:*/		return 0x82165658;
		  /* 82165658h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 82165658h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82165658h case    4:*/		return 0x8216565C;
		  /* 8216565Ch */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 8216565Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8216565Ch case    5:*/		return 0x82165660;
		  /* 82165660h */ case    6:  		/* stw R31, <#[R3 + 4]> */
		/* 82165660h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 82165660h case    6:*/		return 0x82165664;
		  /* 82165664h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82165664h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82165664h case    7:*/		return 0x82165668;
		  /* 82165668h */ case    8:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82165668h case    8:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82165668h case    8:*/		return 0x8216566C;
		  /* 8216566Ch */ case    9:  		/* stw R3, <#[R31 + 12]> */
		/* 8216566Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8216566Ch case    9:*/		return 0x82165670;
		  /* 82165670h */ case   10:  		/* stw R11, <#[R31]> */
		/* 82165670h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82165670h case   10:*/		return 0x82165674;
	}
	return 0x82165674;
} // Block from 82165648h-82165674h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82165674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165674);
		  /* 82165674h */ case    0:  		/* addi R27, R27, 1 */
		/* 82165674h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82165674h case    0:*/		return 0x82165678;
		  /* 82165678h */ case    1:  		/* addi R28, R28, 4 */
		/* 82165678h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82165678h case    1:*/		return 0x8216567C;
		  /* 8216567Ch */ case    2:  		/* addi R29, R29, 4 */
		/* 8216567Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8216567Ch case    2:*/		return 0x82165680;
		  /* 82165680h */ case    3:  		/* b -256 */
		/* 82165680h case    3:*/		return 0x82165580;
		/* 82165680h case    3:*/		return 0x82165684;
	}
	return 0x82165684;
} // Block from 82165674h-82165684h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82165684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165684);
		  /* 82165684h */ case    0:  		/* lwz R11, <#[R23 + 40]> */
		/* 82165684h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000028) );
		/* 82165684h case    0:*/		return 0x82165688;
		  /* 82165688h */ case    1:  		/* mr R27, R21 */
		/* 82165688h case    1:*/		regs.R27 = regs.R21;
		/* 82165688h case    1:*/		return 0x8216568C;
		  /* 8216568Ch */ case    2:  		/* addi R30, R1, 80 */
		/* 8216568Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x50);
		/* 8216568Ch case    2:*/		return 0x82165690;
		  /* 82165690h */ case    3:  		/* ori R10, R11, 4096 */
		/* 82165690h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R11,0x1000);
		/* 82165690h case    3:*/		return 0x82165694;
		  /* 82165694h */ case    4:  		/* rlwinm R28, R11, 20, 31, 31 */
		/* 82165694h case    4:*/		cpu::op::rlwinm<0,20,31,31>(regs,&regs.R28,regs.R11);
		/* 82165694h case    4:*/		return 0x82165698;
		  /* 82165698h */ case    5:  		/* stw R10, <#[R23 + 40]> */
		/* 82165698h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0x00000028) );
		/* 82165698h case    5:*/		return 0x8216569C;
		  /* 8216569Ch */ case    6:  		/* li R29, 4 */
		/* 8216569Ch case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 8216569Ch case    6:*/		return 0x821656A0;
		  /* 821656A0h */ case    7:  		/* lwz R31, <#[R30]> */
		/* 821656A0h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 821656A0h case    7:*/		return 0x821656A4;
		  /* 821656A4h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 821656A4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821656A4h case    8:*/		return 0x821656A8;
		  /* 821656A8h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 821656A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821656DC;  }
		/* 821656A8h case    9:*/		return 0x821656AC;
		  /* 821656ACh */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 821656ACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821656ACh case   10:*/		return 0x821656B0;
	}
	return 0x821656B0;
} // Block from 82165684h-821656B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821656B0h
// Function '?FreeFunctionMem@Compiler@D3DXShader@@QAAXPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821656B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821656B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821656B0);
		  /* 821656B0h */ case    0:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821656B0h case    0:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821656B0h case    0:*/		return 0x821656B4;
		  /* 821656B4h */ case    1:  		/* cmplwi CR6, R11, 14720 */
		/* 821656B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003980);
		/* 821656B4h case    1:*/		return 0x821656B8;
		  /* 821656B8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 821656B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821656DC;  }
		/* 821656B8h case    2:*/		return 0x821656BC;
		  /* 821656BCh */ case    3:  		/* mr R3, R31 */
		/* 821656BCh case    3:*/		regs.R3 = regs.R31;
		/* 821656BCh case    3:*/		return 0x821656C0;
		  /* 821656C0h */ case    4:  		/* bl -3392 */
		/* 821656C0h case    4:*/		regs.LR = 0x821656C4; return 0x82164980;
		/* 821656C0h case    4:*/		return 0x821656C4;
		  /* 821656C4h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821656C4h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821656C4h case    5:*/		return 0x821656C8;
		  /* 821656C8h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 821656C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x821656DC;  }
		/* 821656C8h case    6:*/		return 0x821656CC;
		  /* 821656CCh */ case    7:  		/* mr R4, R31 */
		/* 821656CCh case    7:*/		regs.R4 = regs.R31;
		/* 821656CCh case    7:*/		return 0x821656D0;
		  /* 821656D0h */ case    8:  		/* mr R3, R23 */
		/* 821656D0h case    8:*/		regs.R3 = regs.R23;
		/* 821656D0h case    8:*/		return 0x821656D4;
		  /* 821656D4h */ case    9:  		/* bl 810876 */
		/* 821656D4h case    9:*/		regs.LR = 0x821656D8; return 0x8222B650;
		/* 821656D4h case    9:*/		return 0x821656D8;
		  /* 821656D8h */ case   10:  		/* mr R27, R20 */
		/* 821656D8h case   10:*/		regs.R27 = regs.R20;
		/* 821656D8h case   10:*/		return 0x821656DC;
	}
	return 0x821656DC;
} // Block from 821656B0h-821656DCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821656DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821656DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821656DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821656DC);
		  /* 821656DCh */ case    0:  		/* addic. R29, R29, -1 */
		/* 821656DCh case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 821656DCh case    0:*/		return 0x821656E0;
		  /* 821656E0h */ case    1:  		/* addi R30, R30, 4 */
		/* 821656E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821656E0h case    1:*/		return 0x821656E4;
		  /* 821656E4h */ case    2:  		/* bc 4, CR0_EQ, -68 */
		/* 821656E4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821656A0;  }
		/* 821656E4h case    2:*/		return 0x821656E8;
		  /* 821656E8h */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 821656E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821656E8h case    3:*/		return 0x821656EC;
		  /* 821656ECh */ case    4:  		/* mr R4, R28 */
		/* 821656ECh case    4:*/		regs.R4 = regs.R28;
		/* 821656ECh case    4:*/		return 0x821656F0;
		  /* 821656F0h */ case    5:  		/* mr R3, R23 */
		/* 821656F0h case    5:*/		regs.R3 = regs.R23;
		/* 821656F0h case    5:*/		return 0x821656F4;
		  /* 821656F4h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821656F4h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821656F4h case    6:*/		return 0x821656F8;
		  /* 821656F8h */ case    7:  		/* addi R11, R11, -14720 */
		/* 821656F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC680);
		/* 821656F8h case    7:*/		return 0x821656FC;
		  /* 821656FCh */ case    8:  		/* subfic R11, R11, 0 */
		/* 821656FCh case    8:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 821656FCh case    8:*/		return 0x82165700;
		  /* 82165700h */ case    9:  		/* subfe R11, R11, R11 */
		/* 82165700h case    9:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82165700h case    9:*/		return 0x82165704;
		  /* 82165704h */ case   10:  		/* and R31, R11, R26 */
		/* 82165704h case   10:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R26);
		/* 82165704h case   10:*/		return 0x82165708;
	}
	return 0x82165708;
} // Block from 821656DCh-82165708h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82165708h
// Function '?FreeDeadCode@Compiler@D3DXShader@@QAAX_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165708);
		  /* 82165708h */ case    0:  		/* bl -2584 */
		/* 82165708h case    0:*/		regs.LR = 0x8216570C; return 0x82164CF0;
		/* 82165708h case    0:*/		return 0x8216570C;
		  /* 8216570Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8216570Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216570Ch case    1:*/		return 0x82165710;
		  /* 82165710h */ case    2:  		/* bc 12, CR6_EQ, 180 */
		/* 82165710h case    2:*/		if ( regs.CR[6].eq ) { return 0x821657C4;  }
		/* 82165710h case    2:*/		return 0x82165714;
		  /* 82165714h */ case    3:  		/* addi R5, R31, 44 */
		/* 82165714h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x2C);
		/* 82165714h case    3:*/		return 0x82165718;
		  /* 82165718h */ case    4:  		/* mr R4, R21 */
		/* 82165718h case    4:*/		regs.R4 = regs.R21;
		/* 82165718h case    4:*/		return 0x8216571C;
		  /* 8216571Ch */ case    5:  		/* mr R8, R5 */
		/* 8216571Ch case    5:*/		regs.R8 = regs.R5;
		/* 8216571Ch case    5:*/		return 0x82165720;
		  /* 82165720h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82165720h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82165720h case    6:*/		return 0x82165724;
		  /* 82165724h */ case    7:  		/* rlwinm R3, R11, 13, 29, 31 */
		/* 82165724h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R3,regs.R11);
		/* 82165724h case    7:*/		return 0x82165728;
		  /* 82165728h */ case    8:  		/* cmplw CR6, R4, R3 */
		/* 82165728h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 82165728h case    8:*/		return 0x8216572C;
		  /* 8216572Ch */ case    9:  		/* bc 4, CR6_LT, 152 */
		/* 8216572Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x821657C4;  }
		/* 8216572Ch case    9:*/		return 0x82165730;
		  /* 82165730h */ case   10:  		/* lwz R6, <#[R8]> */
		/* 82165730h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 82165730h case   10:*/		return 0x82165734;
		  /* 82165734h */ case   11:  		/* mr R11, R21 */
		/* 82165734h case   11:*/		regs.R11 = regs.R21;
		/* 82165734h case   11:*/		return 0x82165738;
		  /* 82165738h */ case   12:  		/* mr R7, R21 */
		/* 82165738h case   12:*/		regs.R7 = regs.R21;
		/* 82165738h case   12:*/		return 0x8216573C;
		  /* 8216573Ch */ case   13:  		/* mr R10, R5 */
		/* 8216573Ch case   13:*/		regs.R10 = regs.R5;
		/* 8216573Ch case   13:*/		return 0x82165740;
		  /* 82165740h */ case   14:  		/* cmplw CR6, R7, R3 */
		/* 82165740h case   14:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 82165740h case   14:*/		return 0x82165744;
		  /* 82165744h */ case   15:  		/* bc 4, CR6_LT, 52 */
		/* 82165744h case   15:*/		if ( !regs.CR[6].lt ) { return 0x82165778;  }
		/* 82165744h case   15:*/		return 0x82165748;
		  /* 82165748h */ case   16:  		/* lwz R9, <#[R10]> */
		/* 82165748h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82165748h case   16:*/		return 0x8216574C;
		  /* 8216574Ch */ case   17:  		/* lwz R30, <#[R6 + 12]> */
		/* 8216574Ch case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R6 + 0x0000000C) );
		/* 8216574Ch case   17:*/		return 0x82165750;
		  /* 82165750h */ case   18:  		/* lwz R29, <#[R9 + 12]> */
		/* 82165750h case   18:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x0000000C) );
		/* 82165750h case   18:*/		return 0x82165754;
		  /* 82165754h */ case   19:  		/* cmpw CR6, R29, R30 */
		/* 82165754h case   19:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R30);
		/* 82165754h case   19:*/		return 0x82165758;
		  /* 82165758h */ case   20:  		/* bc 4, CR6_EQ, 20 */
		/* 82165758h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8216576C;  }
		/* 82165758h case   20:*/		return 0x8216575C;
		  /* 8216575Ch */ case   21:  		/* lwz R9, <#[R9]> */
		/* 8216575Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8216575Ch case   21:*/		return 0x82165760;
		  /* 82165760h */ case   22:  		/* rlwinm R9, R9, 27, 30, 31 */
		/* 82165760h case   22:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R9,regs.R9);
		/* 82165760h case   22:*/		return 0x82165764;
		  /* 82165764h */ case   23:  		/* slw R9, R20, R9 */
		/* 82165764h case   23:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R20,regs.R9);
		/* 82165764h case   23:*/		return 0x82165768;
		  /* 82165768h */ case   24:  		/* or R11, R9, R11 */
		/* 82165768h case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82165768h case   24:*/		return 0x8216576C;
	}
	return 0x8216576C;
} // Block from 82165708h-8216576Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216576Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216576C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216576C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216576C);
		  /* 8216576Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 8216576Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8216576Ch case    0:*/		return 0x82165770;
		  /* 82165770h */ case    1:  		/* addi R10, R10, 4 */
		/* 82165770h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82165770h case    1:*/		return 0x82165774;
		  /* 82165774h */ case    2:  		/* b -52 */
		/* 82165774h case    2:*/		return 0x82165740;
		/* 82165774h case    2:*/		return 0x82165778;
	}
	return 0x82165778;
} // Block from 8216576Ch-82165778h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165778);
		  /* 82165778h */ case    0:  		/* lis R10, -28311 */
		/* 82165778h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 82165778h case    0:*/		return 0x8216577C;
		  /* 8216577Ch */ case    1:  		/* lwz R9, <#[R6 + 12]> */
		/* 8216577Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000000C) );
		/* 8216577Ch case    1:*/		return 0x82165780;
		  /* 82165780h */ case    2:  		/* lis R7, 0 */
		/* 82165780h case    2:*/		cpu::op::lis<0>(regs,&regs.R7,0x0);
		/* 82165780h case    2:*/		return 0x82165784;
		  /* 82165784h */ case    3:  		/* ori R10, R10, 5192 */
		/* 82165784h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82165784h case    3:*/		return 0x82165788;
	}
	return 0x82165788;
} // Block from 82165778h-82165788h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82165788h
// Function '?GetCoissuedScalarInstruction@Instruction@D3DXShader@@QAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165788);
		  /* 82165788h */ case    0:  		/* ori R7, R7, 36262 */
		/* 82165788h case    0:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x8DA6);
		/* 82165788h case    0:*/		return 0x8216578C;
		  /* 8216578Ch */ case    1:  		/* rldicl R6, R11, 0, 32 */
		/* 8216578Ch case    1:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R6,regs.R11);
		/* 8216578Ch case    1:*/		return 0x82165790;
		  /* 82165790h */ case    2:  		/* rldimi R10, R7, 32, 0 */
		/* 82165790h case    2:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R7);
		/* 82165790h case    2:*/		return 0x82165794;
		  /* 82165794h */ case    3:  		/* lwz R7, <#[R9 + 8]> */
		/* 82165794h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 82165794h case    3:*/		return 0x82165798;
		  /* 82165798h */ case    4:  		/* addi R4, R4, 1 */
		/* 82165798h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82165798h case    4:*/		return 0x8216579C;
		  /* 8216579Ch */ case    5:  		/* srd R10, R10, R6 */
		/* 8216579Ch case    5:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 8216579Ch case    5:*/		return 0x821657A0;
		  /* 821657A0h */ case    6:  		/* srd R10, R10, R6 */
		/* 821657A0h case    6:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 821657A0h case    6:*/		return 0x821657A4;
		  /* 821657A4h */ case    7:  		/* srd R10, R10, R6 */
		/* 821657A4h case    7:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 821657A4h case    7:*/		return 0x821657A8;
		  /* 821657A8h */ case    8:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 821657A8h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 821657A8h case    8:*/		return 0x821657AC;
		  /* 821657ACh */ case    9:  		/* addi R8, R8, 4 */
		/* 821657ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821657ACh case    9:*/		return 0x821657B0;
		  /* 821657B0h */ case   10:  		/* rlwimi R11, R10, 13, 16, 18 */
		/* 821657B0h case   10:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R11,regs.R10);
		/* 821657B0h case   10:*/		return 0x821657B4;
		  /* 821657B4h */ case   11:  		/* rlwimi R7, R11, 1, 27, 30 */
		/* 821657B4h case   11:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R7,regs.R11);
		/* 821657B4h case   11:*/		return 0x821657B8;
		  /* 821657B8h */ case   12:  		/* rlwimi R7, R11, 1, 15, 17 */
		/* 821657B8h case   12:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R7,regs.R11);
		/* 821657B8h case   12:*/		return 0x821657BC;
		  /* 821657BCh */ case   13:  		/* stw R7, <#[R9 + 8]> */
		/* 821657BCh case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 821657BCh case   13:*/		return 0x821657C0;
		  /* 821657C0h */ case   14:  		/* b -160 */
		/* 821657C0h case   14:*/		return 0x82165720;
		/* 821657C0h case   14:*/		return 0x821657C4;
	}
	return 0x821657C4;
} // Block from 82165788h-821657C4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821657C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821657C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821657C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821657C4);
		  /* 821657C4h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 821657C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 821657C4h case    0:*/		return 0x821657C8;
		  /* 821657C8h */ case    1:  		/* bc 4, CR0_EQ, -1436 */
		/* 821657C8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216522C;  }
		/* 821657C8h case    1:*/		return 0x821657CC;
	}
	return 0x821657CC;
} // Block from 821657C4h-821657CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821657CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821657CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821657CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821657CC);
		  /* 821657CCh */ case    0:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 821657CCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 821657CCh case    0:*/		return 0x821657D0;
		  /* 821657D0h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821657D0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821657D0h case    1:*/		return 0x821657D4;
		  /* 821657D4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821657D4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821657D4h case    2:*/		return 0x821657D8;
		  /* 821657D8h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821657D8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821657E8;  }
		/* 821657D8h case    3:*/		return 0x821657DC;
		  /* 821657DCh */ case    4:  		/* mr R24, R11 */
		/* 821657DCh case    4:*/		regs.R24 = regs.R11;
		/* 821657DCh case    4:*/		return 0x821657E0;
		  /* 821657E0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821657E0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821657E0h case    5:*/		return 0x821657E4;
		  /* 821657E4h */ case    6:  		/* bc 4, CR6_EQ, -1412 */
		/* 821657E4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82165260;  }
		/* 821657E4h case    6:*/		return 0x821657E8;
	}
	return 0x821657E8;
} // Block from 821657CCh-821657E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821657E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821657E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821657E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821657E8);
		  /* 821657E8h */ case    0:  		/* rlwinm R11, R22, 0, 0, 30 */
		/* 821657E8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R22);
		/* 821657E8h case    0:*/		return 0x821657EC;
		  /* 821657ECh */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821657ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821657ECh case    1:*/		return 0x821657F0;
		  /* 821657F0h */ case    2:  		/* b -1472 */
		/* 821657F0h case    2:*/		return 0x82165230;
		/* 821657F0h case    2:*/		return 0x821657F4;
	}
	return 0x821657F4;
} // Block from 821657E8h-821657F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821657F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821657F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821657F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821657F4);
		  /* 821657F4h */ case    0:  		/* rlwinm R11, R30, 0, 7, 5 */
		/* 821657F4h case    0:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R30);
		/* 821657F4h case    0:*/		return 0x821657F8;
		  /* 821657F8h */ case    1:  		/* stw R11, <#[R24 + 8]> */
		/* 821657F8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821657F8h case    1:*/		return 0x821657FC;
	}
	return 0x821657FC;
} // Block from 821657F4h-821657FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821657FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821657FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821657FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821657FC);
		  /* 821657FCh */ case    0:  		/* mr R4, R24 */
		/* 821657FCh case    0:*/		regs.R4 = regs.R24;
		/* 821657FCh case    0:*/		return 0x82165800;
		  /* 82165800h */ case    1:  		/* mr R3, R23 */
		/* 82165800h case    1:*/		regs.R3 = regs.R23;
		/* 82165800h case    1:*/		return 0x82165804;
		  /* 82165804h */ case    2:  		/* bl 810572 */
		/* 82165804h case    2:*/		regs.LR = 0x82165808; return 0x8222B650;
		/* 82165804h case    2:*/		return 0x82165808;
		  /* 82165808h */ case    3:  		/* b -1500 */
		/* 82165808h case    3:*/		return 0x8216522C;
		/* 82165808h case    3:*/		return 0x8216580C;
	}
	return 0x8216580C;
} // Block from 821657FCh-8216580Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216580Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216580C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216580C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216580C);
		  /* 8216580Ch */ case    0:  		/* mr R4, R24 */
		/* 8216580Ch case    0:*/		regs.R4 = regs.R24;
		/* 8216580Ch case    0:*/		return 0x82165810;
		  /* 82165810h */ case    1:  		/* mr R3, R23 */
		/* 82165810h case    1:*/		regs.R3 = regs.R23;
		/* 82165810h case    1:*/		return 0x82165814;
		  /* 82165814h */ case    2:  		/* bl 810556 */
		/* 82165814h case    2:*/		regs.LR = 0x82165818; return 0x8222B650;
		/* 82165814h case    2:*/		return 0x82165818;
		  /* 82165818h */ case    3:  		/* lwz R10, <#[R28 + 4]> */
		/* 82165818h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 82165818h case    3:*/		return 0x8216581C;
		  /* 8216581Ch */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8216581Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216581Ch case    4:*/		return 0x82165820;
		  /* 82165820h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 82165820h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216585C;  }
		/* 82165820h case    5:*/		return 0x82165824;
		  /* 82165824h */ case    6:  		/* lwz R11, <#[R10 + 16]> */
		/* 82165824h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82165824h case    6:*/		return 0x82165828;
		  /* 82165828h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82165828h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165828h case    7:*/		return 0x8216582C;
		  /* 8216582Ch */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 8216582Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82165854;  }
		/* 8216582Ch case    8:*/		return 0x82165830;
		  /* 82165830h */ case    9:  		/* lwz R11, <#[R10]> */
		/* 82165830h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82165830h case    9:*/		return 0x82165834;
		  /* 82165834h */ case   10:  		/* rlwinm. R9, R11, 0, 1, 1 */
		/* 82165834h case   10:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R11);
		/* 82165834h case   10:*/		return 0x82165838;
	}
	return 0x82165838;
} // Block from 8216580Ch-82165838h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82165838h
// Function '?GetAddress@Block@D3DXShader@@QAAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165838);
		  /* 82165838h */ case    0:  		/* bc 4, CR0_EQ, 16 */
		/* 82165838h case    0:*/		if ( !regs.CR[0].eq ) { return 0x82165848;  }
		/* 82165838h case    0:*/		return 0x8216583C;
		  /* 8216583Ch */ case    1:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8216583Ch case    1:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8216583Ch case    1:*/		return 0x82165840;
		  /* 82165840h */ case    2:  		/* mr R11, R21 */
		/* 82165840h case    2:*/		regs.R11 = regs.R21;
		/* 82165840h case    2:*/		return 0x82165844;
		  /* 82165844h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82165844h case    3:*/		if ( regs.CR[0].eq ) { return 0x8216584C;  }
		/* 82165844h case    3:*/		return 0x82165848;
	}
	return 0x82165848;
} // Block from 82165838h-82165848h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82165848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165848);
		  /* 82165848h */ case    0:  		/* mr R11, R20 */
		/* 82165848h case    0:*/		regs.R11 = regs.R20;
		/* 82165848h case    0:*/		return 0x8216584C;
	}
	return 0x8216584C;
} // Block from 82165848h-8216584Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216584Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216584C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216584C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216584C);
		  /* 8216584Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216584Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216584Ch case    0:*/		return 0x82165850;
		  /* 82165850h */ case    1:  		/* bc 4, CR0_EQ, -1572 */
		/* 82165850h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216522C;  }
		/* 82165850h case    1:*/		return 0x82165854;
	}
	return 0x82165854;
} // Block from 8216584Ch-82165854h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165854);
		  /* 82165854h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82165854h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82165854h case    0:*/		return 0x82165858;
		  /* 82165858h */ case    1:  		/* b -60 */
		/* 82165858h case    1:*/		return 0x8216581C;
		/* 82165858h case    1:*/		return 0x8216585C;
	}
	return 0x8216585C;
} // Block from 82165854h-8216585Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216585Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216585C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216585C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216585C);
		  /* 8216585Ch */ case    0:  		/* mr R4, R28 */
		/* 8216585Ch case    0:*/		regs.R4 = regs.R28;
		/* 8216585Ch case    0:*/		return 0x82165860;
		  /* 82165860h */ case    1:  		/* b -96 */
		/* 82165860h case    1:*/		return 0x82165800;
		/* 82165860h case    1:*/		return 0x82165864;
	}
	return 0x82165864;
} // Block from 8216585Ch-82165864h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165864);
		  /* 82165864h */ case    0:  		/* addi R1, R1, 208 */
		/* 82165864h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82165864h case    0:*/		return 0x82165868;
		  /* 82165868h */ case    1:  		/* b -869860 */
		/* 82165868h case    1:*/		return 0x82091284;
		/* 82165868h case    1:*/		return 0x8216586C;
		  /* 8216586Ch */ case    2:  		/* nop */
		/* 8216586Ch case    2:*/		cpu::op::nop();
		/* 8216586Ch case    2:*/		return 0x82165870;
	}
	return 0x82165870;
} // Block from 82165864h-82165870h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165870);
		  /* 82165870h */ case    0:  		/* mfspr R12, LR */
		/* 82165870h case    0:*/		regs.R12 = regs.LR;
		/* 82165870h case    0:*/		return 0x82165874;
		  /* 82165874h */ case    1:  		/* bl -869916 */
		/* 82165874h case    1:*/		regs.LR = 0x82165878; return 0x82091258;
		/* 82165874h case    1:*/		return 0x82165878;
		  /* 82165878h */ case    2:  		/* stwu R1, <#[R1 - 368]> */
		/* 82165878h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 82165878h case    2:*/		return 0x8216587C;
		  /* 8216587Ch */ case    3:  		/* lis R11, -32252 */
		/* 8216587Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8216587Ch case    3:*/		return 0x82165880;
		  /* 82165880h */ case    4:  		/* mr R29, R3 */
		/* 82165880h case    4:*/		regs.R29 = regs.R3;
		/* 82165880h case    4:*/		return 0x82165884;
		  /* 82165884h */ case    5:  		/* mr R28, R4 */
		/* 82165884h case    5:*/		regs.R28 = regs.R4;
		/* 82165884h case    5:*/		return 0x82165888;
	}
	return 0x82165888;
} // Block from 82165870h-82165888h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82165888h
// Function '?FindMaxReg@Compiler@D3DXShader@@AAAIPAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165888);
		  /* 82165888h */ case    0:  		/* addi R3, R1, 160 */
		/* 82165888h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 82165888h case    0:*/		return 0x8216588C;
		  /* 8216588Ch */ case    1:  		/* addi R4, R11, -17576 */
		/* 8216588Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBB58);
		/* 8216588Ch case    1:*/		return 0x82165890;
		  /* 82165890h */ case    2:  		/* li R5, 157 */
		/* 82165890h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x9D);
		/* 82165890h case    2:*/		return 0x82165894;
		  /* 82165894h */ case    3:  		/* bl -868068 */
		/* 82165894h case    3:*/		regs.LR = 0x82165898; return 0x820919B0;
		/* 82165894h case    3:*/		return 0x82165898;
		  /* 82165898h */ case    4:  		/* lis R11, -32252 */
		/* 82165898h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82165898h case    4:*/		return 0x8216589C;
		  /* 8216589Ch */ case    5:  		/* addi R3, R1, 112 */
		/* 8216589Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8216589Ch case    5:*/		return 0x821658A0;
		  /* 821658A0h */ case    6:  		/* addi R4, R11, -17620 */
		/* 821658A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBB2C);
		/* 821658A0h case    6:*/		return 0x821658A4;
		  /* 821658A4h */ case    7:  		/* li R5, 38 */
		/* 821658A4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x26);
		/* 821658A4h case    7:*/		return 0x821658A8;
		  /* 821658A8h */ case    8:  		/* bl -868088 */
		/* 821658A8h case    8:*/		regs.LR = 0x821658AC; return 0x820919B0;
		/* 821658A8h case    8:*/		return 0x821658AC;
		  /* 821658ACh */ case    9:  		/* li R5, 156 */
		/* 821658ACh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x9C);
		/* 821658ACh case    9:*/		return 0x821658B0;
		  /* 821658B0h */ case   10:  		/* addi R4, R1, 160 */
		/* 821658B0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 821658B0h case   10:*/		return 0x821658B4;
		  /* 821658B4h */ case   11:  		/* mr R3, R28 */
		/* 821658B4h case   11:*/		regs.R3 = regs.R28;
		/* 821658B4h case   11:*/		return 0x821658B8;
		  /* 821658B8h */ case   12:  		/* bl -865608 */
		/* 821658B8h case   12:*/		regs.LR = 0x821658BC; return 0x82092370;
		/* 821658B8h case   12:*/		return 0x821658BC;
		  /* 821658BCh */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 821658BCh case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821658BCh case   13:*/		return 0x821658C0;
		  /* 821658C0h */ case   14:  		/* bc 12, CR0_EQ, 28 */
		/* 821658C0h case   14:*/		if ( regs.CR[0].eq ) { return 0x821658DC;  }
		/* 821658C0h case   14:*/		return 0x821658C4;
		  /* 821658C4h */ case   15:  		/* li R5, 37 */
		/* 821658C4h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x25);
		/* 821658C4h case   15:*/		return 0x821658C8;
		  /* 821658C8h */ case   16:  		/* addi R4, R1, 112 */
		/* 821658C8h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 821658C8h case   16:*/		return 0x821658CC;
		  /* 821658CCh */ case   17:  		/* mr R3, R28 */
		/* 821658CCh case   17:*/		regs.R3 = regs.R28;
		/* 821658CCh case   17:*/		return 0x821658D0;
		  /* 821658D0h */ case   18:  		/* bl -865632 */
		/* 821658D0h case   18:*/		regs.LR = 0x821658D4; return 0x82092370;
		/* 821658D0h case   18:*/		return 0x821658D4;
		  /* 821658D4h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 821658D4h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821658D4h case   19:*/		return 0x821658D8;
		  /* 821658D8h */ case   20:  		/* bc 4, CR0_EQ, 204 */
		/* 821658D8h case   20:*/		if ( !regs.CR[0].eq ) { return 0x821659A4;  }
		/* 821658D8h case   20:*/		return 0x821658DC;
	}
	return 0x821658DC;
} // Block from 82165888h-821658DCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821658DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821658DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821658DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821658DC);
		  /* 821658DCh */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 821658DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821658DCh case    0:*/		return 0x821658E0;
		  /* 821658E0h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821658E0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821658E0h case    1:*/		return 0x821658E4;
		  /* 821658E4h */ case    2:  		/* bc 4, CR0_EQ, 192 */
		/* 821658E4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821659A4;  }
		/* 821658E4h case    2:*/		return 0x821658E8;
		  /* 821658E8h */ case    3:  		/* mr R30, R11 */
		/* 821658E8h case    3:*/		regs.R30 = regs.R11;
		/* 821658E8h case    3:*/		return 0x821658EC;
		  /* 821658ECh */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 821658ECh case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821658ECh case    4:*/		return 0x821658F0;
		  /* 821658F0h */ case    5:  		/* bc 12, CR0_EQ, 180 */
		/* 821658F0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821659A4;  }
		/* 821658F0h case    5:*/		return 0x821658F4;
		  /* 821658F4h */ case    6:  		/* lwz R11, <#[R30 + 28]> */
		/* 821658F4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821658F4h case    6:*/		return 0x821658F8;
		  /* 821658F8h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821658F8h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821658F8h case    7:*/		return 0x821658FC;
		  /* 821658FCh */ case    8:  		/* bc 4, CR0_EQ, 140 */
		/* 821658FCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x82165988;  }
		/* 821658FCh case    8:*/		return 0x82165900;
		  /* 82165900h */ case    9:  		/* lwz R11, <#[R30 + 24]> */
		/* 82165900h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82165900h case    9:*/		return 0x82165904;
		  /* 82165904h */ case   10:  		/* b 120 */
		/* 82165904h case   10:*/		return 0x8216597C;
		/* 82165904h case   10:*/		return 0x82165908;
		  /* 82165908h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 82165908h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82165908h case   11:*/		return 0x8216590C;
		  /* 8216590Ch */ case   12:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216590Ch case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216590Ch case   12:*/		return 0x82165910;
		  /* 82165910h */ case   13:  		/* cmplwi CR6, R11, 86 */
		/* 82165910h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 82165910h case   13:*/		return 0x82165914;
		  /* 82165914h */ case   14:  		/* bc 12, CR6_EQ, 48 */
		/* 82165914h case   14:*/		if ( regs.CR[6].eq ) { return 0x82165944;  }
		/* 82165914h case   14:*/		return 0x82165918;
		  /* 82165918h */ case   15:  		/* cmplwi CR6, R11, 87 */
		/* 82165918h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 82165918h case   15:*/		return 0x8216591C;
		  /* 8216591Ch */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 8216591Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x82165944;  }
		/* 8216591Ch case   16:*/		return 0x82165920;
		  /* 82165920h */ case   17:  		/* cmplwi CR6, R11, 89 */
		/* 82165920h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 82165920h case   17:*/		return 0x82165924;
		  /* 82165924h */ case   18:  		/* bc 12, CR6_EQ, 32 */
		/* 82165924h case   18:*/		if ( regs.CR[6].eq ) { return 0x82165944;  }
		/* 82165924h case   18:*/		return 0x82165928;
	}
	return 0x82165928;
} // Block from 821658DCh-82165928h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82165928h
// Function '?GetNext@?$ArrayListEnumerator@VResult@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAPAVResult@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165928);
		  /* 82165928h */ case    0:  		/* cmplwi CR6, R11, 90 */
		/* 82165928h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 82165928h case    0:*/		return 0x8216592C;
		  /* 8216592Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8216592Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82165944;  }
		/* 8216592Ch case    1:*/		return 0x82165930;
		  /* 82165930h */ case    2:  		/* cmplwi CR6, R11, 84 */
		/* 82165930h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 82165930h case    2:*/		return 0x82165934;
		  /* 82165934h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82165934h case    3:*/		if ( regs.CR[6].eq ) { return 0x82165944;  }
		/* 82165934h case    3:*/		return 0x82165938;
		  /* 82165938h */ case    4:  		/* cmplwi CR6, R11, 85 */
		/* 82165938h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000055);
		/* 82165938h case    4:*/		return 0x8216593C;
		  /* 8216593Ch */ case    5:  		/* li R11, 0 */
		/* 8216593Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216593Ch case    5:*/		return 0x82165940;
		  /* 82165940h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82165940h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82165948;  }
		/* 82165940h case    6:*/		return 0x82165944;
	}
	return 0x82165944;
} // Block from 82165928h-82165944h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82165944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165944);
		  /* 82165944h */ case    0:  		/* li R11, 1 */
		/* 82165944h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82165944h case    0:*/		return 0x82165948;
	}
	return 0x82165948;
} // Block from 82165944h-82165948h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165948);
		  /* 82165948h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165948h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165948h case    0:*/		return 0x8216594C;
		  /* 8216594Ch */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8216594Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8216596C;  }
		/* 8216594Ch case    1:*/		return 0x82165950;
		  /* 82165950h */ case    2:  		/* mr R4, R29 */
		/* 82165950h case    2:*/		regs.R4 = regs.R29;
		/* 82165950h case    2:*/		return 0x82165954;
		  /* 82165954h */ case    3:  		/* mr R3, R31 */
		/* 82165954h case    3:*/		regs.R3 = regs.R31;
		/* 82165954h case    3:*/		return 0x82165958;
		  /* 82165958h */ case    4:  		/* bl -4560 */
		/* 82165958h case    4:*/		regs.LR = 0x8216595C; return 0x82164788;
		/* 82165958h case    4:*/		return 0x8216595C;
		  /* 8216595Ch */ case    5:  		/* cmpwi CR6, R3, 8 */
		/* 8216595Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 8216595Ch case    5:*/		return 0x82165960;
		  /* 82165960h */ case    6:  		/* bc 12, CR6_EQ, 124 */
		/* 82165960h case    6:*/		if ( regs.CR[6].eq ) { return 0x821659DC;  }
		/* 82165960h case    6:*/		return 0x82165964;
		  /* 82165964h */ case    7:  		/* cmpwi CR6, R3, 9 */
		/* 82165964h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000009);
		/* 82165964h case    7:*/		return 0x82165968;
		  /* 82165968h */ case    8:  		/* bc 12, CR6_EQ, 116 */
		/* 82165968h case    8:*/		if ( regs.CR[6].eq ) { return 0x821659DC;  }
		/* 82165968h case    8:*/		return 0x8216596C;
	}
	return 0x8216596C;
} // Block from 82165948h-8216596Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216596Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216596C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216596C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216596C);
		  /* 8216596Ch */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216596Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216596Ch case    0:*/		return 0x82165970;
		  /* 82165970h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 82165970h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82165970h case    1:*/		return 0x82165974;
		  /* 82165974h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82165974h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82165974h case    2:*/		return 0x82165978;
		  /* 82165978h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82165978h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82165988;  }
		/* 82165978h case    3:*/		return 0x8216597C;
	}
	return 0x8216597C;
} // Block from 8216596Ch-8216597Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216597Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216597C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216597C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216597C);
		  /* 8216597Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216597Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216597Ch case    0:*/		return 0x82165980;
	}
	return 0x82165980;
} // Block from 8216597Ch-82165980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165980h
// Function '?GetHeapMemory@CompilerHeap@D3DXShader@@AAAPAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165980);
		  /* 82165980h */ case    0:  		/* addic. R31, R11, -40 */
		/* 82165980h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82165980h case    0:*/		return 0x82165984;
		  /* 82165984h */ case    1:  		/* bc 4, CR0_EQ, -124 */
		/* 82165984h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82165908;  }
		/* 82165984h case    1:*/		return 0x82165988;
	}
	return 0x82165988;
} // Block from 82165980h-82165988h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165988);
		  /* 82165988h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82165988h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82165988h case    0:*/		return 0x8216598C;
		  /* 8216598Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216598Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216598Ch case    1:*/		return 0x82165990;
		  /* 82165990h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82165990h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82165990h case    2:*/		return 0x82165994;
		  /* 82165994h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82165994h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821659A4;  }
		/* 82165994h case    3:*/		return 0x82165998;
		  /* 82165998h */ case    4:  		/* mr R30, R11 */
		/* 82165998h case    4:*/		regs.R30 = regs.R11;
		/* 82165998h case    4:*/		return 0x8216599C;
		  /* 8216599Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216599Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216599Ch case    5:*/		return 0x821659A0;
		  /* 821659A0h */ case    6:  		/* bc 4, CR6_EQ, -172 */
		/* 821659A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821658F4;  }
		/* 821659A0h case    6:*/		return 0x821659A4;
	}
	return 0x821659A4;
} // Block from 82165988h-821659A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821659A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821659A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821659A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821659A4);
		  /* 821659A4h */ case    0:  		/* lis R11, -32252 */
		/* 821659A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821659A4h case    0:*/		return 0x821659A8;
		  /* 821659A8h */ case    1:  		/* addi R3, R1, 80 */
		/* 821659A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821659A8h case    1:*/		return 0x821659AC;
		  /* 821659ACh */ case    2:  		/* addi R4, R11, -17640 */
		/* 821659ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBB18);
		/* 821659ACh case    2:*/		return 0x821659B0;
		  /* 821659B0h */ case    3:  		/* li R5, 20 */
		/* 821659B0h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 821659B0h case    3:*/		return 0x821659B4;
		  /* 821659B4h */ case    4:  		/* bl -868356 */
		/* 821659B4h case    4:*/		regs.LR = 0x821659B8; return 0x820919B0;
		/* 821659B4h case    4:*/		return 0x821659B8;
		  /* 821659B8h */ case    5:  		/* li R5, 19 */
		/* 821659B8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x13);
		/* 821659B8h case    5:*/		return 0x821659BC;
		  /* 821659BCh */ case    6:  		/* addi R4, R1, 80 */
		/* 821659BCh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821659BCh case    6:*/		return 0x821659C0;
		  /* 821659C0h */ case    7:  		/* mr R3, R28 */
		/* 821659C0h case    7:*/		regs.R3 = regs.R28;
		/* 821659C0h case    7:*/		return 0x821659C4;
		  /* 821659C4h */ case    8:  		/* bl -865876 */
		/* 821659C4h case    8:*/		regs.LR = 0x821659C8; return 0x82092370;
		/* 821659C4h case    8:*/		return 0x821659C8;
		  /* 821659C8h */ case    9:  		/* addi R11, R3, 0 */
		/* 821659C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x0);
		/* 821659C8h case    9:*/		return 0x821659CC;
		  /* 821659CCh */ case   10:  		/* cntlzw R11, R11 */
		/* 821659CCh case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821659CCh case   10:*/		return 0x821659D0;
		  /* 821659D0h */ case   11:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821659D0h case   11:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821659D0h case   11:*/		return 0x821659D4;
		  /* 821659D4h */ case   12:  		/* addi R1, R1, 368 */
		/* 821659D4h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 821659D4h case   12:*/		return 0x821659D8;
		  /* 821659D8h */ case   13:  		/* b -870192 */
		/* 821659D8h case   13:*/		return 0x820912A8;
		/* 821659D8h case   13:*/		return 0x821659DC;
	}
	return 0x821659DC;
} // Block from 821659A4h-821659DCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821659DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821659DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821659DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821659DC);
		  /* 821659DCh */ case    0:  		/* li R3, 1 */
		/* 821659DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821659DCh case    0:*/		return 0x821659E0;
		  /* 821659E0h */ case    1:  		/* b -12 */
		/* 821659E0h case    1:*/		return 0x821659D4;
		/* 821659E0h case    1:*/		return 0x821659E4;
		  /* 821659E4h */ case    2:  		/* nop */
		/* 821659E4h case    2:*/		cpu::op::nop();
		/* 821659E4h case    2:*/		return 0x821659E8;
	}
	return 0x821659E8;
} // Block from 821659DCh-821659E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821659E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821659E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821659E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821659E8);
		  /* 821659E8h */ case    0:  		/* mfspr R12, LR */
		/* 821659E8h case    0:*/		regs.R12 = regs.LR;
		/* 821659E8h case    0:*/		return 0x821659EC;
		  /* 821659ECh */ case    1:  		/* bl -870300 */
		/* 821659ECh case    1:*/		regs.LR = 0x821659F0; return 0x82091250;
		/* 821659ECh case    1:*/		return 0x821659F0;
		  /* 821659F0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821659F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821659F0h case    2:*/		return 0x821659F4;
		  /* 821659F4h */ case    3:  		/* mr R30, R3 */
		/* 821659F4h case    3:*/		regs.R30 = regs.R3;
		/* 821659F4h case    3:*/		return 0x821659F8;
	}
	return 0x821659F8;
} // Block from 821659E8h-821659F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821659F8h
// Function '?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821659F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821659F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821659F8);
		  /* 821659F8h */ case    0:  		/* mr R27, R4 */
		/* 821659F8h case    0:*/		regs.R27 = regs.R4;
		/* 821659F8h case    0:*/		return 0x821659FC;
		  /* 821659FCh */ case    1:  		/* mr R26, R5 */
		/* 821659FCh case    1:*/		regs.R26 = regs.R5;
		/* 821659FCh case    1:*/		return 0x82165A00;
		  /* 82165A00h */ case    2:  		/* mr R28, R6 */
		/* 82165A00h case    2:*/		regs.R28 = regs.R6;
		/* 82165A00h case    2:*/		return 0x82165A04;
		  /* 82165A04h */ case    3:  		/* mr R31, R7 */
		/* 82165A04h case    3:*/		regs.R31 = regs.R7;
		/* 82165A04h case    3:*/		return 0x82165A08;
		  /* 82165A08h */ case    4:  		/* cmplwi CR6, R6, 0 */
		/* 82165A08h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82165A08h case    4:*/		return 0x82165A0C;
		  /* 82165A0Ch */ case    5:  		/* bc 12, CR6_EQ, 208 */
		/* 82165A0Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82165ADC;  }
		/* 82165A0Ch case    5:*/		return 0x82165A10;
		  /* 82165A10h */ case    6:  		/* li R5, 1 */
		/* 82165A10h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82165A10h case    6:*/		return 0x82165A14;
		  /* 82165A14h */ case    7:  		/* mr R4, R7 */
		/* 82165A14h case    7:*/		regs.R4 = regs.R7;
		/* 82165A14h case    7:*/		return 0x82165A18;
		  /* 82165A18h */ case    8:  		/* bl 1000168 */
		/* 82165A18h case    8:*/		regs.LR = 0x82165A1C; return 0x82259D00;
		/* 82165A18h case    8:*/		return 0x82165A1C;
		  /* 82165A1Ch */ case    9:  		/* or. R4, R3, R3 */
		/* 82165A1Ch case    9:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 82165A1Ch case    9:*/		return 0x82165A20;
		  /* 82165A20h */ case   10:  		/* bc 12, CR0_EQ, 188 */
		/* 82165A20h case   10:*/		if ( regs.CR[0].eq ) { return 0x82165ADC;  }
		/* 82165A20h case   10:*/		return 0x82165A24;
		  /* 82165A24h */ case   11:  		/* addi R6, R1, 80 */
		/* 82165A24h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82165A24h case   11:*/		return 0x82165A28;
		  /* 82165A28h */ case   12:  		/* addi R5, R1, 84 */
		/* 82165A28h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82165A28h case   12:*/		return 0x82165A2C;
		  /* 82165A2Ch */ case   13:  		/* mr R3, R30 */
		/* 82165A2Ch case   13:*/		regs.R3 = regs.R30;
		/* 82165A2Ch case   13:*/		return 0x82165A30;
		  /* 82165A30h */ case   14:  		/* bl -5432 */
		/* 82165A30h case   14:*/		regs.LR = 0x82165A34; return 0x821644F8;
		/* 82165A30h case   14:*/		return 0x82165A34;
		  /* 82165A34h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82165A34h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82165A34h case   15:*/		return 0x82165A38;
		  /* 82165A38h */ case   16:  		/* bc 12, CR0_EQ, 164 */
		/* 82165A38h case   16:*/		if ( regs.CR[0].eq ) { return 0x82165ADC;  }
		/* 82165A38h case   16:*/		return 0x82165A3C;
		  /* 82165A3Ch */ case   17:  		/* lwz R11, <#[R31 + 28]> */
		/* 82165A3Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82165A3Ch case   17:*/		return 0x82165A40;
		  /* 82165A40h */ case   18:  		/* lwz R11, <#[R11 + 76]> */
		/* 82165A40h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82165A40h case   18:*/		return 0x82165A44;
		  /* 82165A44h */ case   19:  		/* rlwinm. R4, R11, 0, 13, 31 */
		/* 82165A44h case   19:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R4,regs.R11);
		/* 82165A44h case   19:*/		return 0x82165A48;
		  /* 82165A48h */ case   20:  		/* bc 4, CR0_EQ, 12 */
		/* 82165A48h case   20:*/		if ( !regs.CR[0].eq ) { return 0x82165A54;  }
		/* 82165A48h case   20:*/		return 0x82165A4C;
		  /* 82165A4Ch */ case   21:  		/* li R29, -1 */
		/* 82165A4Ch case   21:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 82165A4Ch case   21:*/		return 0x82165A50;
		  /* 82165A50h */ case   22:  		/* b 16 */
		/* 82165A50h case   22:*/		return 0x82165A60;
		/* 82165A50h case   22:*/		return 0x82165A54;
	}
	return 0x82165A54;
} // Block from 821659F8h-82165A54h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82165A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165A54);
		  /* 82165A54h */ case    0:  		/* mr R3, R30 */
		/* 82165A54h case    0:*/		regs.R3 = regs.R30;
		/* 82165A54h case    0:*/		return 0x82165A58;
		  /* 82165A58h */ case    1:  		/* bl -5368 */
		/* 82165A58h case    1:*/		regs.LR = 0x82165A5C; return 0x82164560;
		/* 82165A58h case    1:*/		return 0x82165A5C;
		  /* 82165A5Ch */ case    2:  		/* mr R29, R3 */
		/* 82165A5Ch case    2:*/		regs.R29 = regs.R3;
		/* 82165A5Ch case    2:*/		return 0x82165A60;
	}
	return 0x82165A60;
} // Block from 82165A54h-82165A60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165A60);
		  /* 82165A60h */ case    0:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 82165A60h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 82165A60h case    0:*/		return 0x82165A64;
		  /* 82165A64h */ case    1:  		/* li R11, 0 */
		/* 82165A64h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82165A64h case    1:*/		return 0x82165A68;
		  /* 82165A68h */ case    2:  		/* lwz R10, <#[R10 + 36]> */
		/* 82165A68h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000024) );
		/* 82165A68h case    2:*/		return 0x82165A6C;
		  /* 82165A6Ch */ case    3:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82165A6Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82165A6Ch case    3:*/		return 0x82165A70;
		  /* 82165A70h */ case    4:  		/* bc 4, CR0_EQ, 76 */
		/* 82165A70h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82165ABC;  }
		/* 82165A70h case    4:*/		return 0x82165A74;
		  /* 82165A74h */ case    5:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 82165A74h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 82165A74h case    5:*/		return 0x82165A78;
		  /* 82165A78h */ case    6:  		/* addic. R31, R10, -40 */
		/* 82165A78h case    6:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R10,0xFFFFFFD8);
		/* 82165A78h case    6:*/		return 0x82165A7C;
		  /* 82165A7Ch */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 82165A7Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82165ABC;  }
		/* 82165A7Ch case    7:*/		return 0x82165A80;
		  /* 82165A80h */ case    8:  		/* lwz R10, <#[R31 + 8]> */
		/* 82165A80h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82165A80h case    8:*/		return 0x82165A84;
		  /* 82165A84h */ case    9:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82165A84h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82165A84h case    9:*/		return 0x82165A88;
		  /* 82165A88h */ case   10:  		/* cmplwi CR6, R10, 14976 */
		/* 82165A88h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003A80);
		/* 82165A88h case   10:*/		return 0x82165A8C;
		  /* 82165A8Ch */ case   11:  		/* bc 4, CR6_EQ, 48 */
		/* 82165A8Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82165ABC;  }
		/* 82165A8Ch case   11:*/		return 0x82165A90;
		  /* 82165A90h */ case   12:  		/* li R6, 0 */
		/* 82165A90h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82165A90h case   12:*/		return 0x82165A94;
		  /* 82165A94h */ case   13:  		/* li R5, 0 */
		/* 82165A94h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82165A94h case   13:*/		return 0x82165A98;
		  /* 82165A98h */ case   14:  		/* li R4, 117 */
		/* 82165A98h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 82165A98h case   14:*/		return 0x82165A9C;
		  /* 82165A9Ch */ case   15:  		/* mr R3, R30 */
		/* 82165A9Ch case   15:*/		regs.R3 = regs.R30;
		/* 82165A9Ch case   15:*/		return 0x82165AA0;
		  /* 82165AA0h */ case   16:  		/* bl -5744 */
		/* 82165AA0h case   16:*/		regs.LR = 0x82165AA4; return 0x82164430;
		/* 82165AA0h case   16:*/		return 0x82165AA4;
		  /* 82165AA4h */ case   17:  		/* addi R11, R31, -16 */
		/* 82165AA4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 82165AA4h case   17:*/		return 0x82165AA8;
	}
	return 0x82165AA8;
} // Block from 82165A60h-82165AA8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82165AA8h
// Function '?AllocPhaseMem@Compiler@D3DXShader@@QAAPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165AA8);
		  /* 82165AA8h */ case    0:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82165AA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82165AA8h case    0:*/		return 0x82165AAC;
		  /* 82165AACh */ case    1:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82165AACh case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82165AACh case    1:*/		return 0x82165AB0;
		  /* 82165AB0h */ case    2:  		/* addi R11, R11, -3 */
		/* 82165AB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 82165AB0h case    2:*/		return 0x82165AB4;
		  /* 82165AB4h */ case    3:  		/* cntlzw R11, R11 */
		/* 82165AB4h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82165AB4h case    3:*/		return 0x82165AB8;
		  /* 82165AB8h */ case    4:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82165AB8h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82165AB8h case    4:*/		return 0x82165ABC;
	}
	return 0x82165ABC;
} // Block from 82165AA8h-82165ABCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82165ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165ABC);
		  /* 82165ABCh */ case    0:  		/* rlwinm R9, R11, 0, 24, 31 */
		/* 82165ABCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R11);
		/* 82165ABCh case    0:*/		return 0x82165AC0;
		  /* 82165AC0h */ case    1:  		/* lwz R7, <#[R1 + 80]> */
		/* 82165AC0h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 82165AC0h case    1:*/		return 0x82165AC4;
		  /* 82165AC4h */ case    2:  		/* mr R8, R29 */
		/* 82165AC4h case    2:*/		regs.R8 = regs.R29;
		/* 82165AC4h case    2:*/		return 0x82165AC8;
		  /* 82165AC8h */ case    3:  		/* lwz R6, <#[R1 + 84]> */
		/* 82165AC8h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82165AC8h case    3:*/		return 0x82165ACC;
		  /* 82165ACCh */ case    4:  		/* mr R5, R26 */
		/* 82165ACCh case    4:*/		regs.R5 = regs.R26;
		/* 82165ACCh case    4:*/		return 0x82165AD0;
		  /* 82165AD0h */ case    5:  		/* mr R4, R27 */
		/* 82165AD0h case    5:*/		regs.R4 = regs.R27;
		/* 82165AD0h case    5:*/		return 0x82165AD4;
		  /* 82165AD4h */ case    6:  		/* mr R3, R28 */
		/* 82165AD4h case    6:*/		regs.R3 = regs.R28;
		/* 82165AD4h case    6:*/		return 0x82165AD8;
		  /* 82165AD8h */ case    7:  		/* bl -106368 */
		/* 82165AD8h case    7:*/		regs.LR = 0x82165ADC; return 0x8214BB58;
		/* 82165AD8h case    7:*/		return 0x82165ADC;
	}
	return 0x82165ADC;
} // Block from 82165ABCh-82165ADCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82165ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165ADC);
		  /* 82165ADCh */ case    0:  		/* addi R1, R1, 144 */
		/* 82165ADCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82165ADCh case    0:*/		return 0x82165AE0;
		  /* 82165AE0h */ case    1:  		/* b -870464 */
		/* 82165AE0h case    1:*/		return 0x820912A0;
		/* 82165AE0h case    1:*/		return 0x82165AE4;
		  /* 82165AE4h */ case    2:  		/* nop */
		/* 82165AE4h case    2:*/		cpu::op::nop();
		/* 82165AE4h case    2:*/		return 0x82165AE8;
	}
	return 0x82165AE8;
} // Block from 82165ADCh-82165AE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165AE8);
		  /* 82165AE8h */ case    0:  		/* mfspr R12, LR */
		/* 82165AE8h case    0:*/		regs.R12 = regs.LR;
		/* 82165AE8h case    0:*/		return 0x82165AEC;
		  /* 82165AECh */ case    1:  		/* bl -870556 */
		/* 82165AECh case    1:*/		regs.LR = 0x82165AF0; return 0x82091250;
		/* 82165AECh case    1:*/		return 0x82165AF0;
		  /* 82165AF0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82165AF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82165AF0h case    2:*/		return 0x82165AF4;
		  /* 82165AF4h */ case    3:  		/* lwz R11, <#[R7]> */
		/* 82165AF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82165AF4h case    3:*/		return 0x82165AF8;
		  /* 82165AF8h */ case    4:  		/* mr R30, R3 */
		/* 82165AF8h case    4:*/		regs.R30 = regs.R3;
		/* 82165AF8h case    4:*/		return 0x82165AFC;
		  /* 82165AFCh */ case    5:  		/* mr R26, R4 */
		/* 82165AFCh case    5:*/		regs.R26 = regs.R4;
		/* 82165AFCh case    5:*/		return 0x82165B00;
		  /* 82165B00h */ case    6:  		/* mr R29, R5 */
		/* 82165B00h case    6:*/		regs.R29 = regs.R5;
		/* 82165B00h case    6:*/		return 0x82165B04;
		  /* 82165B04h */ case    7:  		/* mr R27, R7 */
		/* 82165B04h case    7:*/		regs.R27 = regs.R7;
		/* 82165B04h case    7:*/		return 0x82165B08;
		  /* 82165B08h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 82165B08h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82165B08h case    8:*/		return 0x82165B0C;
		  /* 82165B0Ch */ case    9:  		/* bc 4, CR6_LT, 172 */
		/* 82165B0Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82165BB8;  }
		/* 82165B0Ch case    9:*/		return 0x82165B10;
		  /* 82165B10h */ case   10:  		/* lwz R11, <#[R5 + 8]> */
		/* 82165B10h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 82165B10h case   10:*/		return 0x82165B14;
		  /* 82165B14h */ case   11:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82165B14h case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82165B14h case   11:*/		return 0x82165B18;
		  /* 82165B18h */ case   12:  		/* cmplwi CR6, R11, 123 */
		/* 82165B18h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007B);
		/* 82165B18h case   12:*/		return 0x82165B1C;
		  /* 82165B1Ch */ case   13:  		/* bc 12, CR6_EQ, 60 */
		/* 82165B1Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82165B58;  }
		/* 82165B1Ch case   13:*/		return 0x82165B20;
		  /* 82165B20h */ case   14:  		/* cmplwi CR6, R11, 117 */
		/* 82165B20h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 82165B20h case   14:*/		return 0x82165B24;
		  /* 82165B24h */ case   15:  		/* bc 4, CR6_EQ, 40 */
		/* 82165B24h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82165B4C;  }
		/* 82165B24h case   15:*/		return 0x82165B28;
		  /* 82165B28h */ case   16:  		/* li R6, 0 */
		/* 82165B28h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82165B28h case   16:*/		return 0x82165B2C;
		  /* 82165B2Ch */ case   17:  		/* li R5, 0 */
		/* 82165B2Ch case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82165B2Ch case   17:*/		return 0x82165B30;
		  /* 82165B30h */ case   18:  		/* li R4, 117 */
		/* 82165B30h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 82165B30h case   18:*/		return 0x82165B34;
		  /* 82165B34h */ case   19:  		/* bl -5892 */
		/* 82165B34h case   19:*/		regs.LR = 0x82165B38; return 0x82164430;
		/* 82165B34h case   19:*/		return 0x82165B38;
		  /* 82165B38h */ case   20:  		/* addi R11, R29, -16 */
		/* 82165B38h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFF0);
		/* 82165B38h case   20:*/		return 0x82165B3C;
		  /* 82165B3Ch */ case   21:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82165B3Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82165B3Ch case   21:*/		return 0x82165B40;
		  /* 82165B40h */ case   22:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82165B40h case   22:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82165B40h case   22:*/		return 0x82165B44;
		  /* 82165B44h */ case   23:  		/* cmplwi CR6, R11, 7 */
		/* 82165B44h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82165B44h case   23:*/		return 0x82165B48;
		  /* 82165B48h */ case   24:  		/* bc 12, CR6_EQ, 16 */
		/* 82165B48h case   24:*/		if ( regs.CR[6].eq ) { return 0x82165B58;  }
		/* 82165B48h case   24:*/		return 0x82165B4C;
	}
	return 0x82165B4C;
} // Block from 82165AE8h-82165B4Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 82165B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165B4C);
		  /* 82165B4Ch */ case    0:  		/* li R4, 4800 */
		/* 82165B4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82165B4Ch case    0:*/		return 0x82165B50;
	}
	return 0x82165B50;
} // Block from 82165B4Ch-82165B50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165B50h
// Function '?AllocAlignedPhaseMem@Compiler@D3DXShader@@QAAPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165B50);
		  /* 82165B50h */ case    0:  		/* mr R3, R30 */
		/* 82165B50h case    0:*/		regs.R3 = regs.R30;
		/* 82165B50h case    0:*/		return 0x82165B54;
		  /* 82165B54h */ case    1:  		/* bl -81132 */
		/* 82165B54h case    1:*/		regs.LR = 0x82165B58; return 0x82151E68;
		/* 82165B54h case    1:*/		return 0x82165B58;
	}
	return 0x82165B58;
} // Block from 82165B50h-82165B58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165B58);
		  /* 82165B58h */ case    0:  		/* addi R10, R1, 80 */
		/* 82165B58h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82165B58h case    0:*/		return 0x82165B5C;
		  /* 82165B5Ch */ case    1:  		/* lwz R3, <#[R30 + 768]> */
		/* 82165B5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000300) );
		/* 82165B5Ch case    1:*/		return 0x82165B60;
		  /* 82165B60h */ case    2:  		/* li R11, 0 */
		/* 82165B60h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82165B60h case    2:*/		return 0x82165B64;
		  /* 82165B64h */ case    3:  		/* li R28, 1 */
		/* 82165B64h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82165B64h case    3:*/		return 0x82165B68;
		  /* 82165B68h */ case    4:  		/* addi R4, R1, 80 */
		/* 82165B68h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82165B68h case    4:*/		return 0x82165B6C;
		  /* 82165B6Ch */ case    5:  		/* std R11, <#[R10]> */
		/* 82165B6Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82165B6Ch case    5:*/		return 0x82165B70;
		  /* 82165B70h */ case    6:  		/* stw R11, <#[R10 + 8]> */
		/* 82165B70h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82165B70h case    6:*/		return 0x82165B74;
		  /* 82165B74h */ case    7:  		/* lwz R11, <#[R1 + 88]> */
		/* 82165B74h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82165B74h case    7:*/		return 0x82165B78;
		  /* 82165B78h */ case    8:  		/* lwz R10, <#[R1 + 80]> */
		/* 82165B78h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82165B78h case    8:*/		return 0x82165B7C;
		  /* 82165B7Ch */ case    9:  		/* rlwinm R10, R10, 0, 6, 31 */
		/* 82165B7Ch case    9:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R10,regs.R10);
		/* 82165B7Ch case    9:*/		return 0x82165B80;
		  /* 82165B80h */ case   10:  		/* rlwimi R11, R28, 25, 3, 7 */
		/* 82165B80h case   10:*/		cpu::op::rlwimi<0,25,3,7>(regs,&regs.R11,regs.R28);
		/* 82165B80h case   10:*/		return 0x82165B84;
		  /* 82165B84h */ case   11:  		/* oris R10, R10, 51200 */
		/* 82165B84h case   11:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC800);
		/* 82165B84h case   11:*/		return 0x82165B88;
		  /* 82165B88h */ case   12:  		/* stw R11, <#[R1 + 88]> */
		/* 82165B88h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82165B88h case   12:*/		return 0x82165B8C;
		  /* 82165B8Ch */ case   13:  		/* stw R10, <#[R1 + 80]> */
		/* 82165B8Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82165B8Ch case   13:*/		return 0x82165B90;
		  /* 82165B90h */ case   14:  		/* bl -1015600 */
		/* 82165B90h case   14:*/		regs.LR = 0x82165B94; return 0x8206DC60;
		/* 82165B90h case   14:*/		return 0x82165B94;
		  /* 82165B94h */ case   15:  		/* mr R31, R3 */
		/* 82165B94h case   15:*/		regs.R31 = regs.R3;
		/* 82165B94h case   15:*/		return 0x82165B98;
		  /* 82165B98h */ case   16:  		/* mr R5, R3 */
		/* 82165B98h case   16:*/		regs.R5 = regs.R3;
		/* 82165B98h case   16:*/		return 0x82165B9C;
		  /* 82165B9Ch */ case   17:  		/* mr R7, R29 */
		/* 82165B9Ch case   17:*/		regs.R7 = regs.R29;
		/* 82165B9Ch case   17:*/		return 0x82165BA0;
		  /* 82165BA0h */ case   18:  		/* mr R6, R26 */
		/* 82165BA0h case   18:*/		regs.R6 = regs.R26;
		/* 82165BA0h case   18:*/		return 0x82165BA4;
		  /* 82165BA4h */ case   19:  		/* li R4, 1 */
		/* 82165BA4h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82165BA4h case   19:*/		return 0x82165BA8;
		  /* 82165BA8h */ case   20:  		/* mr R3, R30 */
		/* 82165BA8h case   20:*/		regs.R3 = regs.R30;
		/* 82165BA8h case   20:*/		return 0x82165BAC;
		  /* 82165BACh */ case   21:  		/* bl -452 */
		/* 82165BACh case   21:*/		regs.LR = 0x82165BB0; return 0x821659E8;
		/* 82165BACh case   21:*/		return 0x82165BB0;
		  /* 82165BB0h */ case   22:  		/* mr R6, R31 */
		/* 82165BB0h case   22:*/		regs.R6 = regs.R31;
		/* 82165BB0h case   22:*/		return 0x82165BB4;
		  /* 82165BB4h */ case   23:  		/* stw R28, <#[R27]> */
		/* 82165BB4h case   23:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R27 + 0x00000000) );
		/* 82165BB4h case   23:*/		return 0x82165BB8;
	}
	return 0x82165BB8;
} // Block from 82165B58h-82165BB8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82165BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165BB8);
		  /* 82165BB8h */ case    0:  		/* mr R3, R6 */
		/* 82165BB8h case    0:*/		regs.R3 = regs.R6;
		/* 82165BB8h case    0:*/		return 0x82165BBC;
		  /* 82165BBCh */ case    1:  		/* addi R1, R1, 160 */
		/* 82165BBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82165BBCh case    1:*/		return 0x82165BC0;
		  /* 82165BC0h */ case    2:  		/* b -870688 */
		/* 82165BC0h case    2:*/		return 0x820912A0;
		/* 82165BC0h case    2:*/		return 0x82165BC4;
		  /* 82165BC4h */ case    3:  		/* nop */
		/* 82165BC4h case    3:*/		cpu::op::nop();
		/* 82165BC4h case    3:*/		return 0x82165BC8;
	}
	return 0x82165BC8;
} // Block from 82165BB8h-82165BC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82165BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165BC8);
		  /* 82165BC8h */ case    0:  		/* mfspr R12, LR */
		/* 82165BC8h case    0:*/		regs.R12 = regs.LR;
		/* 82165BC8h case    0:*/		return 0x82165BCC;
		  /* 82165BCCh */ case    1:  		/* bl -870784 */
		/* 82165BCCh case    1:*/		regs.LR = 0x82165BD0; return 0x8209124C;
		/* 82165BCCh case    1:*/		return 0x82165BD0;
		  /* 82165BD0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82165BD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82165BD0h case    2:*/		return 0x82165BD4;
		  /* 82165BD4h */ case    3:  		/* add R10, R4, R5 */
		/* 82165BD4h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R4,regs.R5);
		/* 82165BD4h case    3:*/		return 0x82165BD8;
		  /* 82165BD8h */ case    4:  		/* li R25, 0 */
		/* 82165BD8h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82165BD8h case    4:*/		return 0x82165BDC;
		  /* 82165BDCh */ case    5:  		/* mr R31, R3 */
		/* 82165BDCh case    5:*/		regs.R31 = regs.R3;
		/* 82165BDCh case    5:*/		return 0x82165BE0;
		  /* 82165BE0h */ case    6:  		/* mr R26, R4 */
		/* 82165BE0h case    6:*/		regs.R26 = regs.R4;
		/* 82165BE0h case    6:*/		return 0x82165BE4;
		  /* 82165BE4h */ case    7:  		/* mr R11, R4 */
		/* 82165BE4h case    7:*/		regs.R11 = regs.R4;
		/* 82165BE4h case    7:*/		return 0x82165BE8;
		  /* 82165BE8h */ case    8:  		/* mr R29, R25 */
		/* 82165BE8h case    8:*/		regs.R29 = regs.R25;
		/* 82165BE8h case    8:*/		return 0x82165BEC;
		  /* 82165BECh */ case    9:  		/* cmplw CR6, R4, R10 */
		/* 82165BECh case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82165BECh case    9:*/		return 0x82165BF0;
		  /* 82165BF0h */ case   10:  		/* bc 4, CR6_LT, 32 */
		/* 82165BF0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82165C10;  }
		/* 82165BF0h case   10:*/		return 0x82165BF4;
		  /* 82165BF4h */ case   11:  		/* lbz R9, <#[R11]> */
		/* 82165BF4h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82165BF4h case   11:*/		return 0x82165BF8;
		  /* 82165BF8h */ case   12:  		/* cmplwi CR0, R9, 0 */
		/* 82165BF8h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82165BF8h case   12:*/		return 0x82165BFC;
		  /* 82165BFCh */ case   13:  		/* bc 12, CR0_EQ, 20 */
		/* 82165BFCh case   13:*/		if ( regs.CR[0].eq ) { return 0x82165C10;  }
		/* 82165BFCh case   13:*/		return 0x82165C00;
	}
	return 0x82165C00;
} // Block from 82165BC8h-82165C00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82165C00h
// Function '?RemoveDeadIsolatedCode@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165C00);
		  /* 82165C00h */ case    0:  		/* addi R11, R11, 1 */
		/* 82165C00h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82165C00h case    0:*/		return 0x82165C04;
		  /* 82165C04h */ case    1:  		/* addi R29, R29, 1 */
		/* 82165C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82165C04h case    1:*/		return 0x82165C08;
		  /* 82165C08h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82165C08h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82165C08h case    2:*/		return 0x82165C0C;
		  /* 82165C0Ch */ case    3:  		/* bc 12, CR6_LT, -24 */
		/* 82165C0Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82165BF4;  }
		/* 82165C0Ch case    3:*/		return 0x82165C10;
	}
	return 0x82165C10;
} // Block from 82165C00h-82165C10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82165C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165C10);
		  /* 82165C10h */ case    0:  		/* lwz R10, <#[R31 + 784]> */
		/* 82165C10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000310) );
		/* 82165C10h case    0:*/		return 0x82165C14;
		  /* 82165C14h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82165C14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82165C14h case    1:*/		return 0x82165C18;
		  /* 82165C18h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 82165C18h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82165C68;  }
		/* 82165C18h case    2:*/		return 0x82165C1C;
		  /* 82165C1Ch */ case    3:  		/* lis R4, 9345 */
		/* 82165C1Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82165C1Ch case    3:*/		return 0x82165C20;
		  /* 82165C20h */ case    4:  		/* addi R3, R29, 1 */
		/* 82165C20h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x1);
		/* 82165C20h case    4:*/		return 0x82165C24;
		  /* 82165C24h */ case    5:  		/* bl -907812 */
		/* 82165C24h case    5:*/		regs.LR = 0x82165C28; return 0x82088200;
		/* 82165C24h case    5:*/		return 0x82165C28;
		  /* 82165C28h */ case    6:  		/* stw R3, <#[R31 + 784]> */
		/* 82165C28h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000310) );
		/* 82165C28h case    6:*/		return 0x82165C2C;
		  /* 82165C2Ch */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 82165C2Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82165C2Ch case    7:*/		return 0x82165C30;
		  /* 82165C30h */ case    8:  		/* bc 4, CR0_EQ, 28 */
		/* 82165C30h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82165C4C;  }
		/* 82165C30h case    8:*/		return 0x82165C34;
		  /* 82165C34h */ case    9:  		/* lwz R11, <#[R31 + 776]> */
		/* 82165C34h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000308) );
		/* 82165C34h case    9:*/		return 0x82165C38;
		  /* 82165C38h */ case   10:  		/* lis R3, -32761 */
		/* 82165C38h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82165C38h case   10:*/		return 0x82165C3C;
		  /* 82165C3Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 82165C3Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82165C3Ch case   11:*/		return 0x82165C40;
		  /* 82165C40h */ case   12:  		/* ori R3, R3, 14 */
		/* 82165C40h case   12:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82165C40h case   12:*/		return 0x82165C44;
		  /* 82165C44h */ case   13:  		/* stw R11, <#[R31 + 776]> */
		/* 82165C44h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000308) );
		/* 82165C44h case   13:*/		return 0x82165C48;
		  /* 82165C48h */ case   14:  		/* b 332 */
		/* 82165C48h case   14:*/		return 0x82165D94;
		/* 82165C48h case   14:*/		return 0x82165C4C;
	}
	return 0x82165C4C;
} // Block from 82165C10h-82165C4Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82165C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165C4C);
		  /* 82165C4Ch */ case    0:  		/* mr R5, R29 */
		/* 82165C4Ch case    0:*/		regs.R5 = regs.R29;
		/* 82165C4Ch case    0:*/		return 0x82165C50;
		  /* 82165C50h */ case    1:  		/* mr R4, R26 */
		/* 82165C50h case    1:*/		regs.R4 = regs.R26;
		/* 82165C50h case    1:*/		return 0x82165C54;
		  /* 82165C54h */ case    2:  		/* bl -869028 */
		/* 82165C54h case    2:*/		regs.LR = 0x82165C58; return 0x820919B0;
		/* 82165C54h case    2:*/		return 0x82165C58;
		  /* 82165C58h */ case    3:  		/* lwz R11, <#[R31 + 784]> */
		/* 82165C58h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000310) );
		/* 82165C58h case    3:*/		return 0x82165C5C;
		  /* 82165C5Ch */ case    4:  		/* mr R28, R29 */
		/* 82165C5Ch case    4:*/		regs.R28 = regs.R29;
		/* 82165C5Ch case    4:*/		return 0x82165C60;
		  /* 82165C60h */ case    5:  		/* stbx R25, <#[R11 + R29]> */
		/* 82165C60h case    5:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82165C60h case    5:*/		return 0x82165C64;
		  /* 82165C64h */ case    6:  		/* b 112 */
		/* 82165C64h case    6:*/		return 0x82165CD4;
		/* 82165C64h case    6:*/		return 0x82165C68;
	}
	return 0x82165C68;
} // Block from 82165C4Ch-82165C68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82165C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165C68);
		  /* 82165C68h */ case    0:  		/* mr R11, R10 */
		/* 82165C68h case    0:*/		regs.R11 = regs.R10;
		/* 82165C68h case    0:*/		return 0x82165C6C;
		  /* 82165C6Ch */ case    1:  		/* lbz R9, <#[R11]> */
		/* 82165C6Ch case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82165C6Ch case    1:*/		return 0x82165C70;
		  /* 82165C70h */ case    2:  		/* addi R11, R11, 1 */
		/* 82165C70h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82165C70h case    2:*/		return 0x82165C74;
		  /* 82165C74h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 82165C74h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82165C74h case    3:*/		return 0x82165C78;
		  /* 82165C78h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82165C78h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82165C6C;  }
		/* 82165C78h case    4:*/		return 0x82165C7C;
		  /* 82165C7Ch */ case    5:  		/* subf R11, R10, R11 */
		/* 82165C7Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82165C7Ch case    5:*/		return 0x82165C80;
		  /* 82165C80h */ case    6:  		/* lis R4, 9345 */
		/* 82165C80h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82165C80h case    6:*/		return 0x82165C84;
		  /* 82165C84h */ case    7:  		/* addi R11, R11, -1 */
		/* 82165C84h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82165C84h case    7:*/		return 0x82165C88;
		  /* 82165C88h */ case    8:  		/* rlwinm R27, R11, 0, 0, 31 */
		/* 82165C88h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R27,regs.R11);
		/* 82165C88h case    8:*/		return 0x82165C8C;
		  /* 82165C8Ch */ case    9:  		/* add R28, R27, R29 */
		/* 82165C8Ch case    9:*/		cpu::op::add<0>(regs,&regs.R28,regs.R27,regs.R29);
		/* 82165C8Ch case    9:*/		return 0x82165C90;
		  /* 82165C90h */ case   10:  		/* addi R3, R28, 1 */
		/* 82165C90h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R28,0x1);
		/* 82165C90h case   10:*/		return 0x82165C94;
		  /* 82165C94h */ case   11:  		/* bl -907924 */
		/* 82165C94h case   11:*/		regs.LR = 0x82165C98; return 0x82088200;
		/* 82165C94h case   11:*/		return 0x82165C98;
		  /* 82165C98h */ case   12:  		/* or. R30, R3, R3 */
		/* 82165C98h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82165C98h case   12:*/		return 0x82165C9C;
		  /* 82165C9Ch */ case   13:  		/* bc 12, CR0_EQ, -104 */
		/* 82165C9Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82165C34;  }
		/* 82165C9Ch case   13:*/		return 0x82165CA0;
		  /* 82165CA0h */ case   14:  		/* mr R5, R27 */
		/* 82165CA0h case   14:*/		regs.R5 = regs.R27;
		/* 82165CA0h case   14:*/		return 0x82165CA4;
		  /* 82165CA4h */ case   15:  		/* lwz R4, <#[R31 + 784]> */
		/* 82165CA4h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000310) );
		/* 82165CA4h case   15:*/		return 0x82165CA8;
		  /* 82165CA8h */ case   16:  		/* mr R3, R30 */
		/* 82165CA8h case   16:*/		regs.R3 = regs.R30;
		/* 82165CA8h case   16:*/		return 0x82165CAC;
		  /* 82165CACh */ case   17:  		/* bl -869116 */
		/* 82165CACh case   17:*/		regs.LR = 0x82165CB0; return 0x820919B0;
		/* 82165CACh case   17:*/		return 0x82165CB0;
		  /* 82165CB0h */ case   18:  		/* mr R5, R29 */
		/* 82165CB0h case   18:*/		regs.R5 = regs.R29;
		/* 82165CB0h case   18:*/		return 0x82165CB4;
		  /* 82165CB4h */ case   19:  		/* mr R4, R26 */
		/* 82165CB4h case   19:*/		regs.R4 = regs.R26;
		/* 82165CB4h case   19:*/		return 0x82165CB8;
		  /* 82165CB8h */ case   20:  		/* add R3, R30, R27 */
		/* 82165CB8h case   20:*/		cpu::op::add<0>(regs,&regs.R3,regs.R30,regs.R27);
		/* 82165CB8h case   20:*/		return 0x82165CBC;
		  /* 82165CBCh */ case   21:  		/* bl -869132 */
		/* 82165CBCh case   21:*/		regs.LR = 0x82165CC0; return 0x820919B0;
		/* 82165CBCh case   21:*/		return 0x82165CC0;
		  /* 82165CC0h */ case   22:  		/* stbx R25, <#[R30 + R28]> */
		/* 82165CC0h case   22:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R30 + regs.R28 + 0x00000000) );
		/* 82165CC0h case   22:*/		return 0x82165CC4;
		  /* 82165CC4h */ case   23:  		/* lis R4, 9345 */
		/* 82165CC4h case   23:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82165CC4h case   23:*/		return 0x82165CC8;
		  /* 82165CC8h */ case   24:  		/* lwz R3, <#[R31 + 784]> */
		/* 82165CC8h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000310) );
		/* 82165CC8h case   24:*/		return 0x82165CCC;
		  /* 82165CCCh */ case   25:  		/* bl -907668 */
		/* 82165CCCh case   25:*/		regs.LR = 0x82165CD0; return 0x82088338;
		/* 82165CCCh case   25:*/		return 0x82165CD0;
		  /* 82165CD0h */ case   26:  		/* stw R30, <#[R31 + 784]> */
		/* 82165CD0h case   26:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000310) );
		/* 82165CD0h case   26:*/		return 0x82165CD4;
	}
	return 0x82165CD4;
} // Block from 82165C68h-82165CD4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82165CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165CD4);
		  /* 82165CD4h */ case    0:  		/* lis R11, -32256 */
		/* 82165CD4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82165CD4h case    0:*/		return 0x82165CD8;
		  /* 82165CD8h */ case    1:  		/* addi R26, R11, 17784 */
		/* 82165CD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x4578);
		/* 82165CD8h case    1:*/		return 0x82165CDC;
		  /* 82165CDCh */ case    2:  		/* li R4, 10 */
		/* 82165CDCh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 82165CDCh case    2:*/		return 0x82165CE0;
		  /* 82165CE0h */ case    3:  		/* lwz R3, <#[R31 + 784]> */
		/* 82165CE0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000310) );
		/* 82165CE0h case    3:*/		return 0x82165CE4;
		  /* 82165CE4h */ case    4:  		/* bl 1057180 */
		/* 82165CE4h case    4:*/		regs.LR = 0x82165CE8; return 0x82267E80;
		/* 82165CE4h case    4:*/		return 0x82165CE8;
		  /* 82165CE8h */ case    5:  		/* or. R29, R3, R3 */
		/* 82165CE8h case    5:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82165CE8h case    5:*/		return 0x82165CEC;
		  /* 82165CECh */ case    6:  		/* bc 12, CR0_EQ, 164 */
		/* 82165CECh case    6:*/		if ( regs.CR[0].eq ) { return 0x82165D90;  }
		/* 82165CECh case    6:*/		return 0x82165CF0;
		  /* 82165CF0h */ case    7:  		/* lwz R11, <#[R31 + 784]> */
		/* 82165CF0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000310) );
		/* 82165CF0h case    7:*/		return 0x82165CF4;
		  /* 82165CF4h */ case    8:  		/* mr R30, R25 */
		/* 82165CF4h case    8:*/		regs.R30 = regs.R25;
		/* 82165CF4h case    8:*/		return 0x82165CF8;
		  /* 82165CF8h */ case    9:  		/* subf R11, R29, R11 */
		/* 82165CF8h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82165CF8h case    9:*/		return 0x82165CFC;
		  /* 82165CFCh */ case   10:  		/* add R10, R11, R28 */
		/* 82165CFCh case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R28);
		/* 82165CFCh case   10:*/		return 0x82165D00;
		  /* 82165D00h */ case   11:  		/* lwz R11, <#[R31 + 776]> */
		/* 82165D00h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000308) );
		/* 82165D00h case   11:*/		return 0x82165D04;
		  /* 82165D04h */ case   12:  		/* addi R11, R11, 1 */
		/* 82165D04h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82165D04h case   12:*/		return 0x82165D08;
		  /* 82165D08h */ case   13:  		/* addic. R28, R10, -1 */
		/* 82165D08h case   13:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R10,0xFFFFFFFF);
		/* 82165D08h case   13:*/		return 0x82165D0C;
		  /* 82165D0Ch */ case   14:  		/* stw R11, <#[R31 + 776]> */
		/* 82165D0Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000308) );
		/* 82165D0Ch case   14:*/		return 0x82165D10;
		  /* 82165D10h */ case   15:  		/* bc 12, CR0_EQ, 44 */
		/* 82165D10h case   15:*/		if ( regs.CR[0].eq ) { return 0x82165D3C;  }
		/* 82165D10h case   15:*/		return 0x82165D14;
		  /* 82165D14h */ case   16:  		/* addi R27, R28, 1 */
		/* 82165D14h case   16:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R28,0x1);
		/* 82165D14h case   16:*/		return 0x82165D18;
		  /* 82165D18h */ case   17:  		/* lis R4, 9345 */
		/* 82165D18h case   17:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82165D18h case   17:*/		return 0x82165D1C;
		  /* 82165D1Ch */ case   18:  		/* mr R3, R27 */
		/* 82165D1Ch case   18:*/		regs.R3 = regs.R27;
		/* 82165D1Ch case   18:*/		return 0x82165D20;
		  /* 82165D20h */ case   19:  		/* bl -908064 */
		/* 82165D20h case   19:*/		regs.LR = 0x82165D24; return 0x82088200;
		/* 82165D20h case   19:*/		return 0x82165D24;
		  /* 82165D24h */ case   20:  		/* or. R30, R3, R3 */
		/* 82165D24h case   20:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82165D24h case   20:*/		return 0x82165D28;
		  /* 82165D28h */ case   21:  		/* bc 12, CR0_EQ, 116 */
		/* 82165D28h case   21:*/		if ( regs.CR[0].eq ) { return 0x82165D9C;  }
		/* 82165D28h case   21:*/		return 0x82165D2C;
		  /* 82165D2Ch */ case   22:  		/* mr R5, R27 */
		/* 82165D2Ch case   22:*/		regs.R5 = regs.R27;
		/* 82165D2Ch case   22:*/		return 0x82165D30;
		  /* 82165D30h */ case   23:  		/* addi R4, R29, 1 */
		/* 82165D30h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x1);
		/* 82165D30h case   23:*/		return 0x82165D34;
		  /* 82165D34h */ case   24:  		/* mr R3, R30 */
		/* 82165D34h case   24:*/		regs.R3 = regs.R30;
		/* 82165D34h case   24:*/		return 0x82165D38;
		  /* 82165D38h */ case   25:  		/* bl -869256 */
		/* 82165D38h case   25:*/		regs.LR = 0x82165D3C; return 0x820919B0;
		/* 82165D38h case   25:*/		return 0x82165D3C;
	}
	return 0x82165D3C;
} // Block from 82165CD4h-82165D3Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 82165D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165D3C);
		  /* 82165D3Ch */ case    0:  		/* lwz R27, <#[R31 + 784]> */
		/* 82165D3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000310) );
		/* 82165D3Ch case    0:*/		return 0x82165D40;
		  /* 82165D40h */ case    1:  		/* mr R3, R31 */
		/* 82165D40h case    1:*/		regs.R3 = regs.R31;
		/* 82165D40h case    1:*/		return 0x82165D44;
		  /* 82165D44h */ case    2:  		/* stb R25, <#[R29]> */
		/* 82165D44h case    2:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R29 + 0x00000000) );
		/* 82165D44h case    2:*/		return 0x82165D48;
		  /* 82165D48h */ case    3:  		/* stw R30, <#[R31 + 784]> */
		/* 82165D48h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000310) );
		/* 82165D48h case    3:*/		return 0x82165D4C;
		  /* 82165D4Ch */ case    4:  		/* mr R4, R27 */
		/* 82165D4Ch case    4:*/		regs.R4 = regs.R27;
		/* 82165D4Ch case    4:*/		return 0x82165D50;
		  /* 82165D50h */ case    5:  		/* bl -1248 */
		/* 82165D50h case    5:*/		regs.LR = 0x82165D54; return 0x82165870;
		/* 82165D50h case    5:*/		return 0x82165D54;
		  /* 82165D54h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82165D54h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82165D54h case    6:*/		return 0x82165D58;
		  /* 82165D58h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 82165D58h case    7:*/		if ( regs.CR[0].eq ) { return 0x82165D6C;  }
		/* 82165D58h case    7:*/		return 0x82165D5C;
		  /* 82165D5Ch */ case    8:  		/* lwz R11, <#[R31 + 780]> */
		/* 82165D5Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000030C) );
		/* 82165D5Ch case    8:*/		return 0x82165D60;
		  /* 82165D60h */ case    9:  		/* addi R11, R11, 1 */
		/* 82165D60h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82165D60h case    9:*/		return 0x82165D64;
		  /* 82165D64h */ case   10:  		/* stw R11, <#[R31 + 780]> */
		/* 82165D64h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000030C) );
		/* 82165D64h case   10:*/		return 0x82165D68;
		  /* 82165D68h */ case   11:  		/* b 16 */
		/* 82165D68h case   11:*/		return 0x82165D78;
		/* 82165D68h case   11:*/		return 0x82165D6C;
	}
	return 0x82165D6C;
} // Block from 82165D3Ch-82165D6Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82165D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165D6C);
		  /* 82165D6Ch */ case    0:  		/* mr R3, R26 */
		/* 82165D6Ch case    0:*/		regs.R3 = regs.R26;
		/* 82165D6Ch case    0:*/		return 0x82165D70;
		  /* 82165D70h */ case    1:  		/* mr R4, R27 */
		/* 82165D70h case    1:*/		regs.R4 = regs.R27;
		/* 82165D70h case    1:*/		return 0x82165D74;
		  /* 82165D74h */ case    2:  		/* bl -831516 */
		/* 82165D74h case    2:*/		regs.LR = 0x82165D78; return 0x8209AD58;
		/* 82165D74h case    2:*/		return 0x82165D78;
	}
	return 0x82165D78;
} // Block from 82165D6Ch-82165D78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165D78);
		  /* 82165D78h */ case    0:  		/* lis R4, 9345 */
		/* 82165D78h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82165D78h case    0:*/		return 0x82165D7C;
		  /* 82165D7Ch */ case    1:  		/* mr R3, R27 */
		/* 82165D7Ch case    1:*/		regs.R3 = regs.R27;
		/* 82165D7Ch case    1:*/		return 0x82165D80;
		  /* 82165D80h */ case    2:  		/* bl -907848 */
		/* 82165D80h case    2:*/		regs.LR = 0x82165D84; return 0x82088338;
		/* 82165D80h case    2:*/		return 0x82165D84;
		  /* 82165D84h */ case    3:  		/* lwz R11, <#[R31 + 784]> */
		/* 82165D84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000310) );
		/* 82165D84h case    3:*/		return 0x82165D88;
		  /* 82165D88h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82165D88h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165D88h case    4:*/		return 0x82165D8C;
		  /* 82165D8Ch */ case    5:  		/* bc 4, CR6_EQ, -176 */
		/* 82165D8Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82165CDC;  }
		/* 82165D8Ch case    5:*/		return 0x82165D90;
	}
	return 0x82165D90;
} // Block from 82165D78h-82165D90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82165D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165D90);
		  /* 82165D90h */ case    0:  		/* li R3, 0 */
		/* 82165D90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82165D90h case    0:*/		return 0x82165D94;
	}
	return 0x82165D94;
} // Block from 82165D90h-82165D94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165D94);
		  /* 82165D94h */ case    0:  		/* addi R1, R1, 144 */
		/* 82165D94h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82165D94h case    0:*/		return 0x82165D98;
		  /* 82165D98h */ case    1:  		/* b -871164 */
		/* 82165D98h case    1:*/		return 0x8209129C;
		/* 82165D98h case    1:*/		return 0x82165D9C;
	}
	return 0x82165D9C;
} // Block from 82165D94h-82165D9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82165D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165D9C);
		  /* 82165D9Ch */ case    0:  		/* lis R3, -32761 */
		/* 82165D9Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82165D9Ch case    0:*/		return 0x82165DA0;
		  /* 82165DA0h */ case    1:  		/* ori R3, R3, 14 */
		/* 82165DA0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82165DA0h case    1:*/		return 0x82165DA4;
		  /* 82165DA4h */ case    2:  		/* b -16 */
		/* 82165DA4h case    2:*/		return 0x82165D94;
		/* 82165DA4h case    2:*/		return 0x82165DA8;
		  /* 82165DA8h */ case    3:  		/* b -480 */
		/* 82165DA8h case    3:*/		return 0x82165BC8;
		/* 82165DA8h case    3:*/		return 0x82165DAC;
		  /* 82165DACh */ case    4:  		/* nop */
		/* 82165DACh case    4:*/		cpu::op::nop();
		/* 82165DACh case    4:*/		return 0x82165DB0;
	}
	return 0x82165DB0;
} // Block from 82165D9Ch-82165DB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82165DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165DB0);
		  /* 82165DB0h */ case    0:  		/* mfspr R12, LR */
		/* 82165DB0h case    0:*/		regs.R12 = regs.LR;
		/* 82165DB0h case    0:*/		return 0x82165DB4;
		  /* 82165DB4h */ case    1:  		/* bl -871260 */
		/* 82165DB4h case    1:*/		regs.LR = 0x82165DB8; return 0x82091258;
		/* 82165DB4h case    1:*/		return 0x82165DB8;
		  /* 82165DB8h */ case    2:  		/* stfd FR31, <#[R1 - 48]> */
		/* 82165DB8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82165DB8h case    2:*/		return 0x82165DBC;
		  /* 82165DBCh */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 82165DBCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82165DBCh case    3:*/		return 0x82165DC0;
		  /* 82165DC0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 82165DC0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82165DC0h case    4:*/		return 0x82165DC4;
		  /* 82165DC4h */ case    5:  		/* mr R29, R3 */
		/* 82165DC4h case    5:*/		regs.R29 = regs.R3;
		/* 82165DC4h case    5:*/		return 0x82165DC8;
		  /* 82165DC8h */ case    6:  		/* fmr FR31, FR1 */
		/* 82165DC8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82165DC8h case    6:*/		return 0x82165DCC;
		  /* 82165DCCh */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82165DCCh case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82165DCCh case    7:*/		return 0x82165DD0;
		  /* 82165DD0h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 82165DD0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82165DDC;  }
		/* 82165DD0h case    8:*/		return 0x82165DD4;
		  /* 82165DD4h */ case    9:  		/* li R3, 0 */
		/* 82165DD4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82165DD4h case    9:*/		return 0x82165DD8;
		  /* 82165DD8h */ case   10:  		/* b 188 */
		/* 82165DD8h case   10:*/		return 0x82165E94;
		/* 82165DD8h case   10:*/		return 0x82165DDC;
	}
	return 0x82165DDC;
} // Block from 82165DB0h-82165DDCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82165DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165DDC);
		  /* 82165DDCh */ case    0:  		/* addi R5, R1, 80 */
		/* 82165DDCh case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82165DDCh case    0:*/		return 0x82165DE0;
		  /* 82165DE0h */ case    1:  		/* lwz R3, <#[R29 + 12]> */
		/* 82165DE0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000000C) );
		/* 82165DE0h case    1:*/		return 0x82165DE4;
		  /* 82165DE4h */ case    2:  		/* addi R4, R1, 96 */
		/* 82165DE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82165DE4h case    2:*/		return 0x82165DE8;
		  /* 82165DE8h */ case    3:  		/* bl 792152 */
		/* 82165DE8h case    3:*/		regs.LR = 0x82165DEC; return 0x82227440;
		/* 82165DE8h case    3:*/		return 0x82165DEC;
		  /* 82165DECh */ case    4:  		/* lwz R11, <#[R29]> */
		/* 82165DECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82165DECh case    4:*/		return 0x82165DF0;
		  /* 82165DF0h */ case    5:  		/* mr R28, R3 */
		/* 82165DF0h case    5:*/		regs.R28 = regs.R3;
		/* 82165DF0h case    5:*/		return 0x82165DF4;
		  /* 82165DF4h */ case    6:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 82165DF4h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82165DF4h case    6:*/		return 0x82165DF8;
		  /* 82165DF8h */ case    7:  		/* li R30, 0 */
		/* 82165DF8h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82165DF8h case    7:*/		return 0x82165DFC;
		  /* 82165DFCh */ case    8:  		/* bc 12, CR0_EQ, 148 */
		/* 82165DFCh case    8:*/		if ( regs.CR[0].eq ) { return 0x82165E90;  }
		/* 82165DFCh case    8:*/		return 0x82165E00;
		  /* 82165E00h */ case    9:  		/* li R31, 0 */
		/* 82165E00h case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82165E00h case    9:*/		return 0x82165E04;
		  /* 82165E04h */ case   10:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 82165E04h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 82165E04h case   10:*/		return 0x82165E08;
		  /* 82165E08h */ case   11:  		/* li R9, 1 */
		/* 82165E08h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82165E08h case   11:*/		return 0x82165E0C;
		  /* 82165E0Ch */ case   12:  		/* srw R10, R10, R31 */
		/* 82165E0Ch case   12:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82165E0Ch case   12:*/		return 0x82165E10;
		  /* 82165E10h */ case   13:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82165E10h case   13:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82165E10h case   13:*/		return 0x82165E14;
		  /* 82165E14h */ case   14:  		/* slw R9, R9, R10 */
		/* 82165E14h case   14:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82165E14h case   14:*/		return 0x82165E18;
		  /* 82165E18h */ case   15:  		/* and. R9, R9, R28 */
		/* 82165E18h case   15:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R28);
		/* 82165E18h case   15:*/		return 0x82165E1C;
		  /* 82165E1Ch */ case   16:  		/* bc 12, CR0_EQ, -72 */
		/* 82165E1Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x82165DD4;  }
		/* 82165E1Ch case   16:*/		return 0x82165E20;
		  /* 82165E20h */ case   17:  		/* rlwinm R9, R10, 1, 0, 30 */
		/* 82165E20h case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R10);
		/* 82165E20h case   17:*/		return 0x82165E24;
		  /* 82165E24h */ case   18:  		/* rlwinm R8, R10, 30, 3, 29 */
		/* 82165E24h case   18:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R8,regs.R10);
		/* 82165E24h case   18:*/		return 0x82165E28;
		  /* 82165E28h */ case   19:  		/* addi R9, R9, 1 */
		/* 82165E28h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82165E28h case   19:*/		return 0x82165E2C;
		  /* 82165E2Ch */ case   20:  		/* li R7, 2 */
		/* 82165E2Ch case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82165E2Ch case   20:*/		return 0x82165E30;
		  /* 82165E30h */ case   21:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82165E30h case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82165E30h case   21:*/		return 0x82165E34;
		  /* 82165E34h */ case   22:  		/* addi R6, R1, 80 */
		/* 82165E34h case   22:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82165E34h case   22:*/		return 0x82165E38;
		  /* 82165E38h */ case   23:  		/* slw R9, R7, R9 */
		/* 82165E38h case   23:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82165E38h case   23:*/		return 0x82165E3C;
		  /* 82165E3Ch */ case   24:  		/* lwzx R8, <#[R8 + R6]> */
		/* 82165E3Ch case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82165E3Ch case   24:*/		return 0x82165E40;
		  /* 82165E40h */ case   25:  		/* addi R9, R9, -1 */
		/* 82165E40h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82165E40h case   25:*/		return 0x82165E44;
		  /* 82165E44h */ case   26:  		/* rlwinm R7, R10, 1, 27, 30 */
		/* 82165E44h case   26:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R7,regs.R10);
		/* 82165E44h case   26:*/		return 0x82165E48;
		  /* 82165E48h */ case   27:  		/* li R6, -1 */
		/* 82165E48h case   27:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 82165E48h case   27:*/		return 0x82165E4C;
		  /* 82165E4Ch */ case   28:  		/* and R9, R9, R8 */
		/* 82165E4Ch case   28:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82165E4Ch case   28:*/		return 0x82165E50;
		  /* 82165E50h */ case   29:  		/* slw R8, R6, R7 */
		/* 82165E50h case   29:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R6,regs.R7);
		/* 82165E50h case   29:*/		return 0x82165E54;
		  /* 82165E54h */ case   30:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82165E54h case   30:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82165E54h case   30:*/		return 0x82165E58;
		  /* 82165E58h */ case   31:  		/* addi R6, R1, 96 */
		/* 82165E58h case   31:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 82165E58h case   31:*/		return 0x82165E5C;
		  /* 82165E5Ch */ case   32:  		/* and R9, R9, R8 */
		/* 82165E5Ch case   32:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82165E5Ch case   32:*/		return 0x82165E60;
		  /* 82165E60h */ case   33:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 82165E60h case   33:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 82165E60h case   33:*/		return 0x82165E64;
		  /* 82165E64h */ case   34:  		/* srw R4, R9, R7 */
		/* 82165E64h case   34:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R9,regs.R7);
		/* 82165E64h case   34:*/		return 0x82165E68;
		  /* 82165E68h */ case   35:  		/* lfdx FR1, <#[R10 + R6]> */
		/* 82165E68h case   35:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82165E68h case   35:*/		return 0x82165E6C;
		  /* 82165E6Ch */ case   36:  		/* bl 767500 */
		/* 82165E6Ch case   36:*/		regs.LR = 0x82165E70; return 0x82221478;
		/* 82165E6Ch case   36:*/		return 0x82165E70;
		  /* 82165E70h */ case   37:  		/* fcmpu CR6, FR1, FR31 */
		/* 82165E70h case   37:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82165E70h case   37:*/		return 0x82165E74;
		  /* 82165E74h */ case   38:  		/* bc 4, CR6_EQ, -160 */
		/* 82165E74h case   38:*/		if ( !regs.CR[6].eq ) { return 0x82165DD4;  }
		/* 82165E74h case   38:*/		return 0x82165E78;
		  /* 82165E78h */ case   39:  		/* lwz R11, <#[R29]> */
		/* 82165E78h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82165E78h case   39:*/		return 0x82165E7C;
		  /* 82165E7Ch */ case   40:  		/* addi R30, R30, 1 */
		/* 82165E7Ch case   40:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82165E7Ch case   40:*/		return 0x82165E80;
		  /* 82165E80h */ case   41:  		/* addi R31, R31, 2 */
		/* 82165E80h case   41:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 82165E80h case   41:*/		return 0x82165E84;
		  /* 82165E84h */ case   42:  		/* rlwinm R10, R11, 7, 29, 31 */
		/* 82165E84h case   42:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R11);
		/* 82165E84h case   42:*/		return 0x82165E88;
		  /* 82165E88h */ case   43:  		/* cmplw CR6, R30, R10 */
		/* 82165E88h case   43:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 82165E88h case   43:*/		return 0x82165E8C;
		  /* 82165E8Ch */ case   44:  		/* bc 12, CR6_LT, -136 */
		/* 82165E8Ch case   44:*/		if ( regs.CR[6].lt ) { return 0x82165E04;  }
		/* 82165E8Ch case   44:*/		return 0x82165E90;
	}
	return 0x82165E90;
} // Block from 82165DDCh-82165E90h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82165E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165E90);
		  /* 82165E90h */ case    0:  		/* li R3, 1 */
		/* 82165E90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82165E90h case    0:*/		return 0x82165E94;
	}
	return 0x82165E94;
} // Block from 82165E90h-82165E94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165E94);
		  /* 82165E94h */ case    0:  		/* addi R1, R1, 176 */
		/* 82165E94h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82165E94h case    0:*/		return 0x82165E98;
		  /* 82165E98h */ case    1:  		/* lfd FR31, <#[R1 - 48]> */
		/* 82165E98h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82165E98h case    1:*/		return 0x82165E9C;
		  /* 82165E9Ch */ case    2:  		/* b -871412 */
		/* 82165E9Ch case    2:*/		return 0x820912A8;
		/* 82165E9Ch case    2:*/		return 0x82165EA0;
	}
	return 0x82165EA0;
} // Block from 82165E94h-82165EA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82165EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165EA0);
		  /* 82165EA0h */ case    0:  		/* mfspr R12, LR */
		/* 82165EA0h case    0:*/		regs.R12 = regs.LR;
		/* 82165EA0h case    0:*/		return 0x82165EA4;
		  /* 82165EA4h */ case    1:  		/* bl -871504 */
		/* 82165EA4h case    1:*/		regs.LR = 0x82165EA8; return 0x82091254;
		/* 82165EA4h case    1:*/		return 0x82165EA8;
		  /* 82165EA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82165EA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82165EA8h case    2:*/		return 0x82165EAC;
		  /* 82165EACh */ case    3:  		/* mr R31, R4 */
		/* 82165EACh case    3:*/		regs.R31 = regs.R4;
		/* 82165EACh case    3:*/		return 0x82165EB0;
		  /* 82165EB0h */ case    4:  		/* li R5, 6 */
		/* 82165EB0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82165EB0h case    4:*/		return 0x82165EB4;
		  /* 82165EB4h */ case    5:  		/* li R4, 8 */
		/* 82165EB4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82165EB4h case    5:*/		return 0x82165EB8;
		  /* 82165EB8h */ case    6:  		/* mr R27, R3 */
		/* 82165EB8h case    6:*/		regs.R27 = regs.R3;
		/* 82165EB8h case    6:*/		return 0x82165EBC;
		  /* 82165EBCh */ case    7:  		/* bl -5580 */
		/* 82165EBCh case    7:*/		regs.LR = 0x82165EC0; return 0x821648F0;
		/* 82165EBCh case    7:*/		return 0x82165EC0;
		  /* 82165EC0h */ case    8:  		/* addi R28, R3, 4 */
		/* 82165EC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R3,0x4);
		/* 82165EC0h case    8:*/		return 0x82165EC4;
		  /* 82165EC4h */ case    9:  		/* ori R11, R3, 1 */
		/* 82165EC4h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82165EC4h case    9:*/		return 0x82165EC8;
		  /* 82165EC8h */ case   10:  		/* ori R10, R28, 1 */
		/* 82165EC8h case   10:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R28,0x1);
		/* 82165EC8h case   10:*/		return 0x82165ECC;
		  /* 82165ECCh */ case   11:  		/* mr R29, R3 */
		/* 82165ECCh case   11:*/		regs.R29 = regs.R3;
		/* 82165ECCh case   11:*/		return 0x82165ED0;
		  /* 82165ED0h */ case   12:  		/* stw R11, <#[R3 + 4]> */
		/* 82165ED0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82165ED0h case   12:*/		return 0x82165ED4;
		  /* 82165ED4h */ case   13:  		/* stw R10, <#[R3]> */
		/* 82165ED4h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82165ED4h case   13:*/		return 0x82165ED8;
		  /* 82165ED8h */ case   14:  		/* lwz R11, <#[R31 + 28]> */
		/* 82165ED8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82165ED8h case   14:*/		return 0x82165EDC;
		  /* 82165EDCh */ case   15:  		/* mr R9, R31 */
		/* 82165EDCh case   15:*/		regs.R9 = regs.R31;
		/* 82165EDCh case   15:*/		return 0x82165EE0;
		  /* 82165EE0h */ case   16:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 82165EE0h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 82165EE0h case   16:*/		return 0x82165EE4;
		  /* 82165EE4h */ case   17:  		/* bc 4, CR0_EQ, 116 */
		/* 82165EE4h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82165F58;  }
		/* 82165EE4h case   17:*/		return 0x82165EE8;
		  /* 82165EE8h */ case   18:  		/* mr R3, R11 */
		/* 82165EE8h case   18:*/		regs.R3 = regs.R11;
		/* 82165EE8h case   18:*/		return 0x82165EEC;
		  /* 82165EECh */ case   19:  		/* cmplwi CR0, R11, 0 */
		/* 82165EECh case   19:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82165EECh case   19:*/		return 0x82165EF0;
		  /* 82165EF0h */ case   20:  		/* bc 12, CR0_EQ, 104 */
		/* 82165EF0h case   20:*/		if ( regs.CR[0].eq ) { return 0x82165F58;  }
		/* 82165EF0h case   20:*/		return 0x82165EF4;
		  /* 82165EF4h */ case   21:  		/* lwz R11, <#[R3 + 8]> */
		/* 82165EF4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82165EF4h case   21:*/		return 0x82165EF8;
		  /* 82165EF8h */ case   22:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82165EF8h case   22:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82165EF8h case   22:*/		return 0x82165EFC;
		  /* 82165EFCh */ case   23:  		/* cmplwi CR6, R10, 1 */
		/* 82165EFCh case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82165EFCh case   23:*/		return 0x82165F00;
		  /* 82165F00h */ case   24:  		/* bc 12, CR6_LT, 16 */
		/* 82165F00h case   24:*/		if ( regs.CR[6].lt ) { return 0x82165F10;  }
		/* 82165F00h case   24:*/		return 0x82165F04;
		  /* 82165F04h */ case   25:  		/* cmplwi CR6, R10, 82 */
		/* 82165F04h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 82165F04h case   25:*/		return 0x82165F08;
		  /* 82165F08h */ case   26:  		/* li R11, 1 */
		/* 82165F08h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82165F08h case   26:*/		return 0x82165F0C;
		  /* 82165F0Ch */ case   27:  		/* bc 4, CR6_GT, 8 */
		/* 82165F0Ch case   27:*/		if ( !regs.CR[6].gt ) { return 0x82165F14;  }
		/* 82165F0Ch case   27:*/		return 0x82165F10;
	}
	return 0x82165F10;
} // Block from 82165EA0h-82165F10h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82165F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F10);
		  /* 82165F10h */ case    0:  		/* li R11, 0 */
		/* 82165F10h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82165F10h case    0:*/		return 0x82165F14;
	}
	return 0x82165F14;
} // Block from 82165F10h-82165F14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F14);
		  /* 82165F14h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165F14h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165F14h case    0:*/		return 0x82165F18;
		  /* 82165F18h */ case    1:  		/* bc 4, CR0_EQ, 500 */
		/* 82165F18h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216610C;  }
		/* 82165F18h case    1:*/		return 0x82165F1C;
		  /* 82165F1Ch */ case    2:  		/* cmplwi CR6, R10, 96 */
		/* 82165F1Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 82165F1Ch case    2:*/		return 0x82165F20;
		  /* 82165F20h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82165F20h case    3:*/		if ( regs.CR[6].lt ) { return 0x82165F30;  }
		/* 82165F20h case    3:*/		return 0x82165F24;
		  /* 82165F24h */ case    4:  		/* cmplwi CR6, R10, 102 */
		/* 82165F24h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 82165F24h case    4:*/		return 0x82165F28;
		  /* 82165F28h */ case    5:  		/* li R11, 1 */
		/* 82165F28h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82165F28h case    5:*/		return 0x82165F2C;
		  /* 82165F2Ch */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82165F2Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x82165F34;  }
		/* 82165F2Ch case    6:*/		return 0x82165F30;
	}
	return 0x82165F30;
} // Block from 82165F14h-82165F30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82165F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F30);
		  /* 82165F30h */ case    0:  		/* li R11, 0 */
		/* 82165F30h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82165F30h case    0:*/		return 0x82165F34;
	}
	return 0x82165F34;
} // Block from 82165F30h-82165F34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F34);
		  /* 82165F34h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165F34h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165F34h case    0:*/		return 0x82165F38;
		  /* 82165F38h */ case    1:  		/* bc 4, CR0_EQ, 468 */
		/* 82165F38h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216610C;  }
		/* 82165F38h case    1:*/		return 0x82165F3C;
		  /* 82165F3Ch */ case    2:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 82165F3Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 82165F3Ch case    2:*/		return 0x82165F40;
		  /* 82165F40h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 82165F40h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82165F40h case    3:*/		return 0x82165F44;
		  /* 82165F44h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82165F44h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82165F44h case    4:*/		return 0x82165F48;
		  /* 82165F48h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82165F48h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82165F58;  }
		/* 82165F48h case    5:*/		return 0x82165F4C;
		  /* 82165F4Ch */ case    6:  		/* mr R3, R11 */
		/* 82165F4Ch case    6:*/		regs.R3 = regs.R11;
		/* 82165F4Ch case    6:*/		return 0x82165F50;
		  /* 82165F50h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82165F50h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165F50h case    7:*/		return 0x82165F54;
		  /* 82165F54h */ case    8:  		/* bc 4, CR6_EQ, -96 */
		/* 82165F54h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82165EF4;  }
		/* 82165F54h case    8:*/		return 0x82165F58;
	}
	return 0x82165F58;
} // Block from 82165F34h-82165F58h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82165F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F58);
		  /* 82165F58h */ case    0:  		/* lwz R30, <#[R9 + 12]> */
		/* 82165F58h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x0000000C) );
		/* 82165F58h case    0:*/		return 0x82165F5C;
		  /* 82165F5Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82165F5Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82165F5Ch case    1:*/		return 0x82165F60;
		  /* 82165F60h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82165F60h case    2:*/		if ( regs.CR[6].eq ) { return 0x82165F74;  }
		/* 82165F60h case    2:*/		return 0x82165F64;
		  /* 82165F64h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 82165F64h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82165F64h case    3:*/		return 0x82165F68;
		  /* 82165F68h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82165F68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165F68h case    4:*/		return 0x82165F6C;
		  /* 82165F6Ch */ case    5:  		/* li R11, 1 */
		/* 82165F6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82165F6Ch case    5:*/		return 0x82165F70;
		  /* 82165F70h */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 82165F70h case    6:*/		if ( regs.CR[6].eq ) { return 0x82165F78;  }
		/* 82165F70h case    6:*/		return 0x82165F74;
	}
	return 0x82165F74;
} // Block from 82165F58h-82165F74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82165F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F74);
		  /* 82165F74h */ case    0:  		/* li R11, 0 */
		/* 82165F74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82165F74h case    0:*/		return 0x82165F78;
	}
	return 0x82165F78;
} // Block from 82165F74h-82165F78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F78);
		  /* 82165F78h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165F78h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165F78h case    0:*/		return 0x82165F7C;
		  /* 82165F7Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82165F7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82165F90;  }
		/* 82165F7Ch case    1:*/		return 0x82165F80;
		  /* 82165F80h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 82165F80h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82165F80h case    2:*/		return 0x82165F84;
		  /* 82165F84h */ case    3:  		/* bc 12, CR6_EQ, 268 */
		/* 82165F84h case    3:*/		if ( regs.CR[6].eq ) { return 0x82166090;  }
		/* 82165F84h case    3:*/		return 0x82165F88;
		  /* 82165F88h */ case    4:  		/* lwz R31, <#[R30]> */
		/* 82165F88h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82165F88h case    4:*/		return 0x82165F8C;
		  /* 82165F8Ch */ case    5:  		/* b 252 */
		/* 82165F8Ch case    5:*/		return 0x82166088;
		/* 82165F8Ch case    5:*/		return 0x82165F90;
	}
	return 0x82165F90;
} // Block from 82165F78h-82165F90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82165F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165F90);
		  /* 82165F90h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 82165F90h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82165F90h case    0:*/		return 0x82165F94;
		  /* 82165F94h */ case    1:  		/* bc 4, CR6_EQ, 224 */
		/* 82165F94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82166074;  }
		/* 82165F94h case    1:*/		return 0x82165F98;
		  /* 82165F98h */ case    2:  		/* lwz R11, <#[R9 + 24]> */
		/* 82165F98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 82165F98h case    2:*/		return 0x82165F9C;
		  /* 82165F9Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82165F9Ch case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82165F9Ch case    3:*/		return 0x82165FA0;
		  /* 82165FA0h */ case    4:  		/* addic. R31, R11, -40 */
		/* 82165FA0h case    4:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 82165FA0h case    4:*/		return 0x82165FA4;
		  /* 82165FA4h */ case    5:  		/* bc 12, CR0_EQ, 208 */
		/* 82165FA4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82166074;  }
		/* 82165FA4h case    5:*/		return 0x82165FA8;
		  /* 82165FA8h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82165FA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82165FA8h case    6:*/		return 0x82165FAC;
		  /* 82165FACh */ case    7:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82165FACh case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82165FACh case    7:*/		return 0x82165FB0;
		  /* 82165FB0h */ case    8:  		/* cmplwi CR6, R10, 86 */
		/* 82165FB0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000056);
		/* 82165FB0h case    8:*/		return 0x82165FB4;
		  /* 82165FB4h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 82165FB4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82165FC4;  }
		/* 82165FB4h case    9:*/		return 0x82165FB8;
		  /* 82165FB8h */ case   10:  		/* cmplwi CR6, R10, 87 */
		/* 82165FB8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000057);
		/* 82165FB8h case   10:*/		return 0x82165FBC;
		  /* 82165FBCh */ case   11:  		/* li R11, 0 */
		/* 82165FBCh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82165FBCh case   11:*/		return 0x82165FC0;
		  /* 82165FC0h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 82165FC0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82165FC8;  }
		/* 82165FC0h case   12:*/		return 0x82165FC4;
	}
	return 0x82165FC4;
} // Block from 82165F90h-82165FC4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82165FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165FC4);
		  /* 82165FC4h */ case    0:  		/* li R11, 1 */
		/* 82165FC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82165FC4h case    0:*/		return 0x82165FC8;
	}
	return 0x82165FC8;
} // Block from 82165FC4h-82165FC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82165FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82165FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82165FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82165FC8);
		  /* 82165FC8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82165FC8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82165FC8h case    0:*/		return 0x82165FCC;
		  /* 82165FCCh */ case    1:  		/* bc 12, CR0_EQ, 168 */
		/* 82165FCCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82166074;  }
		/* 82165FCCh case    1:*/		return 0x82165FD0;
		  /* 82165FD0h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82165FD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82165FD0h case    2:*/		return 0x82165FD4;
		  /* 82165FD4h */ case    3:  		/* mr R3, R27 */
		/* 82165FD4h case    3:*/		regs.R3 = regs.R27;
		/* 82165FD4h case    3:*/		return 0x82165FD8;
		  /* 82165FD8h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82165FD8h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82165FD8h case    4:*/		return 0x82165FDC;
		  /* 82165FDCh */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82165FDCh case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82165FDCh case    5:*/		return 0x82165FE0;
		  /* 82165FE0h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82165FE0h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82165FE0h case    6:*/		return 0x82165FE4;
		  /* 82165FE4h */ case    7:  		/* bl -7092 */
		/* 82165FE4h case    7:*/		regs.LR = 0x82165FE8; return 0x82164430;
		/* 82165FE4h case    7:*/		return 0x82165FE8;
		  /* 82165FE8h */ case    8:  		/* addi R10, R31, -16 */
		/* 82165FE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF0);
		/* 82165FE8h case    8:*/		return 0x82165FEC;
		  /* 82165FECh */ case    9:  		/* mr R11, R30 */
		/* 82165FECh case    9:*/		regs.R11 = regs.R30;
		/* 82165FECh case    9:*/		return 0x82165FF0;
		  /* 82165FF0h */ case   10:  		/* lwzx R10, <#[R3 + R10]> */
		/* 82165FF0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 82165FF0h case   10:*/		return 0x82165FF4;
		  /* 82165FF4h */ case   11:  		/* rlwinm R10, R10, 0, 0, 29 */
		/* 82165FF4h case   11:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R10);
		/* 82165FF4h case   11:*/		return 0x82165FF8;
		  /* 82165FF8h */ case   12:  		/* lwz R31, <#[R10 + 28]> */
		/* 82165FF8h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000001C) );
		/* 82165FF8h case   12:*/		return 0x82165FFC;
		  /* 82165FFCh */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82165FFCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82165FFCh case   13:*/		return 0x82166000;
		  /* 82166000h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 82166000h case   14:*/		if ( regs.CR[6].eq ) { return 0x82166018;  }
		/* 82166000h case   14:*/		return 0x82166004;
		  /* 82166004h */ case   15:  		/* lwz R30, <#[R11]> */
		/* 82166004h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82166004h case   15:*/		return 0x82166008;
		  /* 82166008h */ case   16:  		/* cmplw CR6, R30, R31 */
		/* 82166008h case   16:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 82166008h case   16:*/		return 0x8216600C;
		  /* 8216600Ch */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 8216600Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216601C;  }
		/* 8216600Ch case   17:*/		return 0x82166010;
		  /* 82166010h */ case   18:  		/* lwz R11, <#[R11 + 8]> */
		/* 82166010h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82166010h case   18:*/		return 0x82166014;
		  /* 82166014h */ case   19:  		/* b -24 */
		/* 82166014h case   19:*/		return 0x82165FFC;
		/* 82166014h case   19:*/		return 0x82166018;
	}
	return 0x82166018;
} // Block from 82165FC8h-82166018h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82166018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166018);
		  /* 82166018h */ case    0:  		/* li R30, 0 */
		/* 82166018h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82166018h case    0:*/		return 0x8216601C;
	}
	return 0x8216601C;
} // Block from 82166018h-8216601Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216601Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216601C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216601C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216601C);
		  /* 8216601Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8216601Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8216601Ch case    0:*/		return 0x82166020;
		  /* 82166020h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82166020h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82166020h case    1:*/		return 0x82166024;
		  /* 82166024h */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 82166024h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216604C;  }
		/* 82166024h case    2:*/		return 0x82166028;
		  /* 82166028h */ case    3:  		/* lwz R11, <#[R29]> */
		/* 82166028h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82166028h case    3:*/		return 0x8216602C;
		  /* 8216602Ch */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216602Ch case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216602Ch case    4:*/		return 0x82166030;
		  /* 82166030h */ case    5:  		/* addic. R3, R11, -4 */
		/* 82166030h case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 82166030h case    5:*/		return 0x82166034;
		  /* 82166034h */ case    6:  		/* bc 12, CR0_EQ, 24 */
		/* 82166034h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216604C;  }
		/* 82166034h case    6:*/		return 0x82166038;
		  /* 82166038h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 82166038h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82166038h case    7:*/		return 0x8216603C;
		  /* 8216603Ch */ case    8:  		/* lwz R10, <#[R3 + 12]> */
		/* 8216603Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8216603Ch case    8:*/		return 0x82166040;
		  /* 82166040h */ case    9:  		/* addi R11, R11, 1 */
		/* 82166040h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82166040h case    9:*/		return 0x82166044;
		  /* 82166044h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 82166044h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82166044h case   10:*/		return 0x82166048;
		  /* 82166048h */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 82166048h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82166058;  }
		/* 82166048h case   11:*/		return 0x8216604C;
	}
	return 0x8216604C;
} // Block from 8216601Ch-8216604Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216604Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216604C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216604C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216604C);
		  /* 8216604Ch */ case    0:  		/* li R4, 1 */
		/* 8216604Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216604Ch case    0:*/		return 0x82166050;
		  /* 82166050h */ case    1:  		/* mr R3, R29 */
		/* 82166050h case    1:*/		regs.R3 = regs.R29;
		/* 82166050h case    1:*/		return 0x82166054;
		  /* 82166054h */ case    2:  		/* bl 159860 */
		/* 82166054h case    2:*/		regs.LR = 0x82166058; return 0x8218D0C8;
		/* 82166054h case    2:*/		return 0x82166058;
	}
	return 0x82166058;
} // Block from 8216604Ch-82166058h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166058);
		  /* 82166058h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82166058h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82166058h case    0:*/		return 0x8216605C;
		  /* 8216605Ch */ case    1:  		/* addi R10, R11, 4 */
		/* 8216605Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8216605Ch case    1:*/		return 0x82166060;
		  /* 82166060h */ case    2:  		/* addi R9, R11, 1 */
		/* 82166060h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82166060h case    2:*/		return 0x82166064;
		  /* 82166064h */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82166064h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82166064h case    3:*/		return 0x82166068;
		  /* 82166068h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 82166068h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82166068h case    4:*/		return 0x8216606C;
		  /* 8216606Ch */ case    5:  		/* stwx R30, <#[R11 + R3]> */
		/* 8216606Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216606Ch case    5:*/		return 0x82166070;
		  /* 82166070h */ case    6:  		/* b 24 */
		/* 82166070h case    6:*/		return 0x82166088;
		/* 82166070h case    6:*/		return 0x82166074;
	}
	return 0x82166074;
} // Block from 82166058h-82166074h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82166074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166074);
		  /* 82166074h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 82166074h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 82166074h case    0:*/		return 0x82166078;
		  /* 82166078h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82166078h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82166078h case    1:*/		return 0x8216607C;
		  /* 8216607Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216607Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216607Ch case    2:*/		return 0x82166080;
		  /* 82166080h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82166080h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82166090;  }
		/* 82166080h case    3:*/		return 0x82166084;
		  /* 82166084h */ case    4:  		/* mr R31, R11 */
		/* 82166084h case    4:*/		regs.R31 = regs.R11;
		/* 82166084h case    4:*/		return 0x82166088;
	}
	return 0x82166088;
} // Block from 82166074h-82166088h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82166088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166088);
		  /* 82166088h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82166088h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82166088h case    0:*/		return 0x8216608C;
		  /* 8216608Ch */ case    1:  		/* bc 4, CR6_EQ, -436 */
		/* 8216608Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82165ED8;  }
		/* 8216608Ch case    1:*/		return 0x82166090;
	}
	return 0x82166090;
} // Block from 82166088h-82166090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166090);
		  /* 82166090h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 82166090h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82166090h case    0:*/		return 0x82166094;
		  /* 82166094h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82166094h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166094h case    1:*/		return 0x82166098;
		  /* 82166098h */ case    2:  		/* bc 4, CR0_EQ, 112 */
		/* 82166098h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82166108;  }
		/* 82166098h case    2:*/		return 0x8216609C;
		  /* 8216609Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8216609Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216609Ch case    3:*/		return 0x821660A0;
		  /* 821660A0h */ case    4:  		/* bc 12, CR0_EQ, 104 */
		/* 821660A0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82166108;  }
		/* 821660A0h case    4:*/		return 0x821660A4;
		  /* 821660A4h */ case    5:  		/* lwz R11, <#[R29]> */
		/* 821660A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821660A4h case    5:*/		return 0x821660A8;
		  /* 821660A8h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821660A8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821660A8h case    6:*/		return 0x821660AC;
		  /* 821660ACh */ case    7:  		/* addi R4, R11, -4 */
		/* 821660ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821660ACh case    7:*/		return 0x821660B0;
		  /* 821660B0h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 821660B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821660B0h case    8:*/		return 0x821660B4;
		  /* 821660B4h */ case    9:  		/* addi R10, R11, 3 */
		/* 821660B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 821660B4h case    9:*/		return 0x821660B8;
		  /* 821660B8h */ case   10:  		/* addic. R11, R11, -1 */
		/* 821660B8h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821660B8h case   10:*/		return 0x821660BC;
		  /* 821660BCh */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821660BCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821660BCh case   11:*/		return 0x821660C0;
		  /* 821660C0h */ case   12:  		/* lwzx R31, <#[R10 + R4]> */
		/* 821660C0h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821660C0h case   12:*/		return 0x821660C4;
		  /* 821660C4h */ case   13:  		/* stw R11, <#[R4 + 8]> */
		/* 821660C4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821660C4h case   13:*/		return 0x821660C8;
		  /* 821660C8h */ case   14:  		/* bc 4, CR0_EQ, -496 */
		/* 821660C8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82165ED8;  }
		/* 821660C8h case   14:*/		return 0x821660CC;
		  /* 821660CCh */ case   15:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821660CCh case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821660CCh case   15:*/		return 0x821660D0;
		  /* 821660D0h */ case   16:  		/* mr R3, R29 */
		/* 821660D0h case   16:*/		regs.R3 = regs.R29;
		/* 821660D0h case   16:*/		return 0x821660D4;
		  /* 821660D4h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 821660D4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821660D4h case   17:*/		return 0x821660D8;
		  /* 821660D8h */ case   18:  		/* lwz R9, <#[R11]> */
		/* 821660D8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821660D8h case   18:*/		return 0x821660DC;
		  /* 821660DCh */ case   19:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821660DCh case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821660DCh case   19:*/		return 0x821660E0;
		  /* 821660E0h */ case   20:  		/* stw R9, <#[R10]> */
		/* 821660E0h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821660E0h case   20:*/		return 0x821660E4;
		  /* 821660E4h */ case   21:  		/* lwz R10, <#[R11 + 4]> */
		/* 821660E4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821660E4h case   21:*/		return 0x821660E8;
		  /* 821660E8h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 821660E8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821660E8h case   22:*/		return 0x821660EC;
		  /* 821660ECh */ case   23:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821660ECh case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821660ECh case   23:*/		return 0x821660F0;
		  /* 821660F0h */ case   24:  		/* stw R10, <#[R11]> */
		/* 821660F0h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821660F0h case   24:*/		return 0x821660F4;
		  /* 821660F4h */ case   25:  		/* lwz R11, <#[R4 + 12]> */
		/* 821660F4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821660F4h case   25:*/		return 0x821660F8;
		  /* 821660F8h */ case   26:  		/* addi R11, R11, 4 */
		/* 821660F8h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821660F8h case   26:*/		return 0x821660FC;
		  /* 821660FCh */ case   27:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821660FCh case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821660FCh case   27:*/		return 0x82166100;
		  /* 82166100h */ case   28:  		/* bl -82680 */
		/* 82166100h case   28:*/		regs.LR = 0x82166104; return 0x82151E08;
		/* 82166100h case   28:*/		return 0x82166104;
		  /* 82166104h */ case   29:  		/* b -556 */
		/* 82166104h case   29:*/		return 0x82165ED8;
		/* 82166104h case   29:*/		return 0x82166108;
	}
	return 0x82166108;
} // Block from 82166090h-82166108h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82166108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166108);
		  /* 82166108h */ case    0:  		/* li R3, 0 */
		/* 82166108h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82166108h case    0:*/		return 0x8216610C;
	}
	return 0x8216610C;
} // Block from 82166108h-8216610Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216610Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216610C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216610C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216610C);
		  /* 8216610Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8216610Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216610Ch case    0:*/		return 0x82166110;
		  /* 82166110h */ case    1:  		/* b -872044 */
		/* 82166110h case    1:*/		return 0x820912A4;
		/* 82166110h case    1:*/		return 0x82166114;
		  /* 82166114h */ case    2:  		/* nop */
		/* 82166114h case    2:*/		cpu::op::nop();
		/* 82166114h case    2:*/		return 0x82166118;
	}
	return 0x82166118;
} // Block from 8216610Ch-82166118h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166118);
		  /* 82166118h */ case    0:  		/* mfspr R12, LR */
		/* 82166118h case    0:*/		regs.R12 = regs.LR;
		/* 82166118h case    0:*/		return 0x8216611C;
		  /* 8216611Ch */ case    1:  		/* bl -872188 */
		/* 8216611Ch case    1:*/		regs.LR = 0x82166120; return 0x82091220;
		/* 8216611Ch case    1:*/		return 0x82166120;
		  /* 82166120h */ case    2:  		/* stwu R1, <#[R1 - 448]> */
		/* 82166120h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE40);
		/* 82166120h case    2:*/		return 0x82166124;
		  /* 82166124h */ case    3:  		/* lwz R11, <#[R3 + 44]> */
		/* 82166124h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 82166124h case    3:*/		return 0x82166128;
		  /* 82166128h */ case    4:  		/* mr R15, R3 */
		/* 82166128h case    4:*/		regs.R15 = regs.R3;
		/* 82166128h case    4:*/		return 0x8216612C;
		  /* 8216612Ch */ case    5:  		/* mr R25, R4 */
		/* 8216612Ch case    5:*/		regs.R25 = regs.R4;
		/* 8216612Ch case    5:*/		return 0x82166130;
		  /* 82166130h */ case    6:  		/* stw R4, <#[R1 + 476]> */
		/* 82166130h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000001DC) );
		/* 82166130h case    6:*/		return 0x82166134;
		  /* 82166134h */ case    7:  		/* mr R30, R5 */
		/* 82166134h case    7:*/		regs.R30 = regs.R5;
		/* 82166134h case    7:*/		return 0x82166138;
		  /* 82166138h */ case    8:  		/* stw R6, <#[R1 + 492]> */
		/* 82166138h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001EC) );
		/* 82166138h case    8:*/		return 0x8216613C;
		  /* 8216613Ch */ case    9:  		/* mr R14, R6 */
		/* 8216613Ch case    9:*/		regs.R14 = regs.R6;
		/* 8216613Ch case    9:*/		return 0x82166140;
		  /* 82166140h */ case   10:  		/* li R23, 0 */
		/* 82166140h case   10:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82166140h case   10:*/		return 0x82166144;
		  /* 82166144h */ case   11:  		/* li R22, 1 */
		/* 82166144h case   11:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82166144h case   11:*/		return 0x82166148;
		  /* 82166148h */ case   12:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 82166148h case   12:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 82166148h case   12:*/		return 0x8216614C;
		  /* 8216614Ch */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 8216614Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8216615C;  }
		/* 8216614Ch case   13:*/		return 0x82166150;
		  /* 82166150h */ case   14:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82166150h case   14:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82166150h case   14:*/		return 0x82166154;
		  /* 82166154h */ case   15:  		/* mr R11, R22 */
		/* 82166154h case   15:*/		regs.R11 = regs.R22;
		/* 82166154h case   15:*/		return 0x82166158;
		  /* 82166158h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 82166158h case   16:*/		if ( regs.CR[0].eq ) { return 0x82166160;  }
		/* 82166158h case   16:*/		return 0x8216615C;
	}
	return 0x8216615C;
} // Block from 82166118h-8216615Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8216615Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216615C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216615C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216615C);
		  /* 8216615Ch */ case    0:  		/* mr R11, R23 */
		/* 8216615Ch case    0:*/		regs.R11 = regs.R23;
		/* 8216615Ch case    0:*/		return 0x82166160;
	}
	return 0x82166160;
} // Block from 8216615Ch-82166160h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166160);
		  /* 82166160h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82166160h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82166160h case    0:*/		return 0x82166164;
		  /* 82166164h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 82166164h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166194;  }
		/* 82166164h case    1:*/		return 0x82166168;
		  /* 82166168h */ case    2:  		/* li R4, 192 */
		/* 82166168h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xC0);
		/* 82166168h case    2:*/		return 0x8216616C;
		  /* 8216616Ch */ case    3:  		/* cmpwi CR6, R30, 0 */
		/* 8216616Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8216616Ch case    3:*/		return 0x82166170;
		  /* 82166170h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 82166170h case    4:*/		if ( regs.CR[6].eq ) { return 0x82166178;  }
		/* 82166170h case    4:*/		return 0x82166174;
		  /* 82166174h */ case    5:  		/* li R4, 193 */
		/* 82166174h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xC1);
		/* 82166174h case    5:*/		return 0x82166178;
	}
	return 0x82166178;
} // Block from 82166160h-82166178h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82166178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166178);
		  /* 82166178h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166178h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166178h case    0:*/		return 0x8216617C;
		  /* 8216617Ch */ case    1:  		/* bl -1040956 */
		/* 8216617Ch case    1:*/		regs.LR = 0x82166180; return 0x82067F40;
		/* 8216617Ch case    1:*/		return 0x82166180;
		  /* 82166180h */ case    2:  		/* lwz R3, <#[R14 + 16]> */
		/* 82166180h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R14 + 0x00000010) );
		/* 82166180h case    2:*/		return 0x82166184;
		  /* 82166184h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 82166184h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82166184h case    3:*/		return 0x82166188;
		  /* 82166188h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82166188h case    4:*/		if ( regs.CR[6].eq ) { return 0x82166194;  }
		/* 82166188h case    4:*/		return 0x8216618C;
		  /* 8216618Ch */ case    5:  		/* mr R4, R30 */
		/* 8216618Ch case    5:*/		regs.R4 = regs.R30;
		/* 8216618Ch case    5:*/		return 0x82166190;
		  /* 82166190h */ case    6:  		/* bl -130040 */
		/* 82166190h case    6:*/		regs.LR = 0x82166194; return 0x82146598;
		/* 82166190h case    6:*/		return 0x82166194;
	}
	return 0x82166194;
} // Block from 82166178h-82166194h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82166194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166194);
		  /* 82166194h */ case    0:  		/* lwz R11, <#[R15 + 4]> */
		/* 82166194h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 82166194h case    0:*/		return 0x82166198;
		  /* 82166198h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82166198h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166198h case    1:*/		return 0x8216619C;
		  /* 8216619Ch */ case    2:  		/* addic R10, R10, -1 */
		/* 8216619Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216619Ch case    2:*/		return 0x821661A0;
		  /* 821661A0h */ case    3:  		/* subfe R10, R10, R10 */
		/* 821661A0h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821661A0h case    3:*/		return 0x821661A4;
		  /* 821661A4h */ case    4:  		/* and R11, R10, R11 */
		/* 821661A4h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821661A4h case    4:*/		return 0x821661A8;
		  /* 821661A8h */ case    5:  		/* lwz R11, <#[R11 + 20]> */
		/* 821661A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821661A8h case    5:*/		return 0x821661AC;
		  /* 821661ACh */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821661ACh case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821661ACh case    6:*/		return 0x821661B0;
		  /* 821661B0h */ case    7:  		/* bc 4, CR0_EQ, 188 */
		/* 821661B0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216626C;  }
		/* 821661B0h case    7:*/		return 0x821661B4;
		  /* 821661B4h */ case    8:  		/* mr R31, R11 */
		/* 821661B4h case    8:*/		regs.R31 = regs.R11;
		/* 821661B4h case    8:*/		return 0x821661B8;
		  /* 821661B8h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 821661B8h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821661B8h case    9:*/		return 0x821661BC;
		  /* 821661BCh */ case   10:  		/* bc 12, CR0_EQ, 176 */
		/* 821661BCh case   10:*/		if ( regs.CR[0].eq ) { return 0x8216626C;  }
		/* 821661BCh case   10:*/		return 0x821661C0;
		  /* 821661C0h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 821661C0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821661C0h case   11:*/		return 0x821661C4;
		  /* 821661C4h */ case   12:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821661C4h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821661C4h case   12:*/		return 0x821661C8;
		  /* 821661C8h */ case   13:  		/* cmplwi CR6, R10, 16000 */
		/* 821661C8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E80);
		/* 821661C8h case   13:*/		return 0x821661CC;
		  /* 821661CCh */ case   14:  		/* bc 4, CR6_EQ, 132 */
		/* 821661CCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x82166250;  }
		/* 821661CCh case   14:*/		return 0x821661D0;
		  /* 821661D0h */ case   15:  		/* lwz R7, <#[R31 + 4]> */
		/* 821661D0h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 821661D0h case   15:*/		return 0x821661D4;
		  /* 821661D4h */ case   16:  		/* cmplwi CR6, R7, 0 */
		/* 821661D4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821661D4h case   16:*/		return 0x821661D8;
		  /* 821661D8h */ case   17:  		/* bc 12, CR6_EQ, 120 */
		/* 821661D8h case   17:*/		if ( regs.CR[6].eq ) { return 0x82166250;  }
		/* 821661D8h case   17:*/		return 0x821661DC;
		  /* 821661DCh */ case   18:  		/* rlwinm. R10, R11, 18, 29, 31 */
		/* 821661DCh case   18:*/		cpu::op::rlwinm<1,18,29,31>(regs,&regs.R10,regs.R11);
		/* 821661DCh case   18:*/		return 0x821661E0;
		  /* 821661E0h */ case   19:  		/* mr R11, R23 */
		/* 821661E0h case   19:*/		regs.R11 = regs.R23;
		/* 821661E0h case   19:*/		return 0x821661E4;
		  /* 821661E4h */ case   20:  		/* bc 12, CR0_EQ, 44 */
		/* 821661E4h case   20:*/		if ( regs.CR[0].eq ) { return 0x82166210;  }
		/* 821661E4h case   20:*/		return 0x821661E8;
		  /* 821661E8h */ case   21:  		/* addi R11, R1, 272 */
		/* 821661E8h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x110);
		/* 821661E8h case   21:*/		return 0x821661EC;
		  /* 821661ECh */ case   22:  		/* mtspr CTR, R10 */
		/* 821661ECh case   22:*/		regs.CTR = regs.R10;
		/* 821661ECh case   22:*/		return 0x821661F0;
		  /* 821661F0h */ case   23:  		/* addi R9, R31, 40 */
		/* 821661F0h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x28);
		/* 821661F0h case   23:*/		return 0x821661F4;
		  /* 821661F4h */ case   24:  		/* addi R8, R11, -4 */
		/* 821661F4h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFC);
		/* 821661F4h case   24:*/		return 0x821661F8;
		  /* 821661F8h */ case   25:  		/* mr R11, R10 */
		/* 821661F8h case   25:*/		regs.R11 = regs.R10;
		/* 821661F8h case   25:*/		return 0x821661FC;
		  /* 821661FCh */ case   26:  		/* lfsu FR0, <#[R9 + 4]> */
		/* 821661FCh case   26:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 821661FCh case   26:*/		return 0x82166200;
		  /* 82166200h */ case   27:  		/* stfsu FR0, <#[R8 + 4]> */
		/* 82166200h case   27:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 82166200h case   27:*/		return 0x82166204;
		  /* 82166204h */ case   28:  		/* bc 16, CR0_LT, -8 */
		/* 82166204h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821661FC;  }
		/* 82166204h case   28:*/		return 0x82166208;
		  /* 82166208h */ case   29:  		/* cmplwi CR6, R10, 4 */
		/* 82166208h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 82166208h case   29:*/		return 0x8216620C;
		  /* 8216620Ch */ case   30:  		/* bc 4, CR6_LT, 48 */
		/* 8216620Ch case   30:*/		if ( !regs.CR[6].lt ) { return 0x8216623C;  }
		/* 8216620Ch case   30:*/		return 0x82166210;
	}
	return 0x82166210;
} // Block from 82166194h-82166210h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82166210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166210);
		  /* 82166210h */ case    0:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82166210h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82166210h case    0:*/		return 0x82166214;
		  /* 82166214h */ case    1:  		/* addi R10, R1, 272 */
		/* 82166214h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x110);
		/* 82166214h case    1:*/		return 0x82166218;
		  /* 82166218h */ case    2:  		/* subfic R11, R11, 4 */
		/* 82166218h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82166218h case    2:*/		return 0x8216621C;
		  /* 8216621Ch */ case    3:  		/* add R10, R9, R10 */
		/* 8216621Ch case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216621Ch case    3:*/		return 0x82166220;
		  /* 82166220h */ case    4:  		/* mr R9, R23 */
		/* 82166220h case    4:*/		regs.R9 = regs.R23;
		/* 82166220h case    4:*/		return 0x82166224;
		  /* 82166224h */ case    5:  		/* addi R10, R10, -4 */
		/* 82166224h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 82166224h case    5:*/		return 0x82166228;
		  /* 82166228h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82166228h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166228h case    6:*/		return 0x8216622C;
		  /* 8216622Ch */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8216622Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8216623C;  }
		/* 8216622Ch case    7:*/		return 0x82166230;
		  /* 82166230h */ case    8:  		/* mtspr CTR, R11 */
		/* 82166230h case    8:*/		regs.CTR = regs.R11;
		/* 82166230h case    8:*/		return 0x82166234;
		  /* 82166234h */ case    9:  		/* stwu R9, <#[R10 + 4]> */
		/* 82166234h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82166234h case    9:*/		return 0x82166238;
		  /* 82166238h */ case   10:  		/* bc 16, CR0_LT, -4 */
		/* 82166238h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82166234;  }
		/* 82166238h case   10:*/		return 0x8216623C;
	}
	return 0x8216623C;
} // Block from 82166210h-8216623Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216623Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216623C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216623C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216623C);
		  /* 8216623Ch */ case    0:  		/* lwz R11, <#[R7]> */
		/* 8216623Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8216623Ch case    0:*/		return 0x82166240;
		  /* 82166240h */ case    1:  		/* addi R5, R1, 272 */
		/* 82166240h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x110);
		/* 82166240h case    1:*/		return 0x82166244;
		  /* 82166244h */ case    2:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166244h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166244h case    2:*/		return 0x82166248;
		  /* 82166248h */ case    3:  		/* rlwinm R4, R11, 15, 24, 31 */
		/* 82166248h case    3:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R4,regs.R11);
		/* 82166248h case    3:*/		return 0x8216624C;
		  /* 8216624Ch */ case    4:  		/* bl -1032204 */
		/* 8216624Ch case    4:*/		regs.LR = 0x82166250; return 0x8206A240;
		/* 8216624Ch case    4:*/		return 0x82166250;
	}
	return 0x82166250;
} // Block from 8216623Ch-82166250h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82166250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166250);
		  /* 82166250h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82166250h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82166250h case    0:*/		return 0x82166254;
		  /* 82166254h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82166254h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82166254h case    1:*/		return 0x82166258;
		  /* 82166258h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82166258h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166258h case    2:*/		return 0x8216625C;
		  /* 8216625Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216625Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216626C;  }
		/* 8216625Ch case    3:*/		return 0x82166260;
		  /* 82166260h */ case    4:  		/* mr R31, R11 */
		/* 82166260h case    4:*/		regs.R31 = regs.R11;
		/* 82166260h case    4:*/		return 0x82166264;
		  /* 82166264h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82166264h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166264h case    5:*/		return 0x82166268;
		  /* 82166268h */ case    6:  		/* bc 4, CR6_EQ, -168 */
		/* 82166268h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821661C0;  }
		/* 82166268h case    6:*/		return 0x8216626C;
	}
	return 0x8216626C;
} // Block from 82166250h-8216626Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216626Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216626C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216626C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216626C);
		  /* 8216626Ch */ case    0:  		/* lwz R11, <#[R15 + 48]> */
		/* 8216626Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 8216626Ch case    0:*/		return 0x82166270;
		  /* 82166270h */ case    1:  		/* lis R17, -1 */
		/* 82166270h case    1:*/		cpu::op::lis<0>(regs,&regs.R17,0xFFFFFFFF);
		/* 82166270h case    1:*/		return 0x82166274;
		  /* 82166274h */ case    2:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82166274h case    2:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82166274h case    2:*/		return 0x82166278;
		  /* 82166278h */ case    3:  		/* cmplw CR6, R11, R17 */
		/* 82166278h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 82166278h case    3:*/		return 0x8216627C;
		  /* 8216627Ch */ case    4:  		/* bc 12, CR6_EQ, 96 */
		/* 8216627Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821662DC;  }
		/* 8216627Ch case    4:*/		return 0x82166280;
		  /* 82166280h */ case    5:  		/* cmpwi CR6, R30, 0 */
		/* 82166280h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82166280h case    5:*/		return 0x82166284;
		  /* 82166284h */ case    6:  		/* bc 4, CR6_EQ, 88 */
		/* 82166284h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821662DC;  }
		/* 82166284h case    6:*/		return 0x82166288;
		  /* 82166288h */ case    7:  		/* lwz R11, <#[R15 + 336]> */
		/* 82166288h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000150) );
		/* 82166288h case    7:*/		return 0x8216628C;
		  /* 8216628Ch */ case    8:  		/* mr R30, R23 */
		/* 8216628Ch case    8:*/		regs.R30 = regs.R23;
		/* 8216628Ch case    8:*/		return 0x82166290;
		  /* 82166290h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82166290h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166290h case    9:*/		return 0x82166294;
		  /* 82166294h */ case   10:  		/* bc 4, CR6_GT, 72 */
		/* 82166294h case   10:*/		if ( !regs.CR[6].gt ) { return 0x821662DC;  }
		/* 82166294h case   10:*/		return 0x82166298;
		  /* 82166298h */ case   11:  		/* addi R31, R15, 124 */
		/* 82166298h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R15,0x7C);
		/* 82166298h case   11:*/		return 0x8216629C;
		  /* 8216629Ch */ case   12:  		/* lwz R11, <#[R31 + 4]> */
		/* 8216629Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8216629Ch case   12:*/		return 0x821662A0;
		  /* 821662A0h */ case   13:  		/* rlwinm R4, R11, 28, 4, 31 */
		/* 821662A0h case   13:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R4,regs.R11);
		/* 821662A0h case   13:*/		return 0x821662A4;
		  /* 821662A4h */ case   14:  		/* cmplwi CR6, R4, 15 */
		/* 821662A4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000F);
		/* 821662A4h case   14:*/		return 0x821662A8;
		  /* 821662A8h */ case   15:  		/* bc 12, CR6_GT, 32 */
		/* 821662A8h case   15:*/		if ( regs.CR[6].gt ) { return 0x821662C8;  }
		/* 821662A8h case   15:*/		return 0x821662AC;
		  /* 821662ACh */ case   16:  		/* lwz R10, <#[R31]> */
		/* 821662ACh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821662ACh case   16:*/		return 0x821662B0;
		  /* 821662B0h */ case   17:  		/* rlwinm R5, R11, 0, 28, 31 */
		/* 821662B0h case   17:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R5,regs.R11);
		/* 821662B0h case   17:*/		return 0x821662B4;
		  /* 821662B4h */ case   18:  		/* lwz R3, <#[R15 + 768]> */
		/* 821662B4h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821662B4h case   18:*/		return 0x821662B8;
		  /* 821662B8h */ case   19:  		/* rlwinm R11, R10, 27, 28, 31 */
		/* 821662B8h case   19:*/		cpu::op::rlwinm<0,27,28,31>(regs,&regs.R11,regs.R10);
		/* 821662B8h case   19:*/		return 0x821662BC;
		  /* 821662BCh */ case   20:  		/* rlwinm R10, R10, 4, 24, 27 */
		/* 821662BCh case   20:*/		cpu::op::rlwinm<0,4,24,27>(regs,&regs.R10,regs.R10);
		/* 821662BCh case   20:*/		return 0x821662C0;
		  /* 821662C0h */ case   21:  		/* or R6, R11, R10 */
		/* 821662C0h case   21:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 821662C0h case   21:*/		return 0x821662C4;
		  /* 821662C4h */ case   22:  		/* bl -1019244 */
		/* 821662C4h case   22:*/		regs.LR = 0x821662C8; return 0x8206D558;
		/* 821662C4h case   22:*/		return 0x821662C8;
	}
	return 0x821662C8;
} // Block from 8216626Ch-821662C8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821662C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821662C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821662C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821662C8);
		  /* 821662C8h */ case    0:  		/* lwz R11, <#[R15 + 336]> */
		/* 821662C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000150) );
		/* 821662C8h case    0:*/		return 0x821662CC;
		  /* 821662CCh */ case    1:  		/* addi R30, R30, 1 */
		/* 821662CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821662CCh case    1:*/		return 0x821662D0;
		  /* 821662D0h */ case    2:  		/* addi R31, R31, 12 */
		/* 821662D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xC);
		/* 821662D0h case    2:*/		return 0x821662D4;
		  /* 821662D4h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 821662D4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821662D4h case    3:*/		return 0x821662D8;
		  /* 821662D8h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 821662D8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8216629C;  }
		/* 821662D8h case    4:*/		return 0x821662DC;
	}
	return 0x821662DC;
} // Block from 821662C8h-821662DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821662DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821662DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821662DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821662DC);
		  /* 821662DCh */ case    0:  		/* lwz R11, <#[R15 + 536]> */
		/* 821662DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000218) );
		/* 821662DCh case    0:*/		return 0x821662E0;
	}
	return 0x821662E0;
} // Block from 821662DCh-821662E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821662E0h
// Function '?ShouldIgnoreValidatorError@Compiler@D3DXShader@@AAA_NPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821662E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821662E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821662E0);
		  /* 821662E0h */ case    0:  		/* mr R28, R23 */
		/* 821662E0h case    0:*/		regs.R28 = regs.R23;
		/* 821662E0h case    0:*/		return 0x821662E4;
		  /* 821662E4h */ case    1:  		/* mr R27, R23 */
		/* 821662E4h case    1:*/		regs.R27 = regs.R23;
		/* 821662E4h case    1:*/		return 0x821662E8;
		  /* 821662E8h */ case    2:  		/* mr R29, R23 */
		/* 821662E8h case    2:*/		regs.R29 = regs.R23;
		/* 821662E8h case    2:*/		return 0x821662EC;
		  /* 821662ECh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821662ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821662ECh case    3:*/		return 0x821662F0;
		  /* 821662F0h */ case    4:  		/* bc 4, CR6_GT, 296 */
		/* 821662F0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82166418;  }
		/* 821662F0h case    4:*/		return 0x821662F4;
		  /* 821662F4h */ case    5:  		/* addi R30, R15, 348 */
		/* 821662F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R15,0x15C);
		/* 821662F4h case    5:*/		return 0x821662F8;
		  /* 821662F8h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 821662F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821662F8h case    6:*/		return 0x821662FC;
		  /* 821662FCh */ case    7:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 821662FCh case    7:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 821662FCh case    7:*/		return 0x82166300;
		  /* 82166300h */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 82166300h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216632C;  }
		/* 82166300h case    8:*/		return 0x82166304;
		  /* 82166304h */ case    9:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 82166304h case    9:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82166304h case    9:*/		return 0x82166308;
		  /* 82166308h */ case   10:  		/* bc 12, CR0_EQ, 252 */
		/* 82166308h case   10:*/		if ( regs.CR[0].eq ) { return 0x82166404;  }
		/* 82166308h case   10:*/		return 0x8216630C;
		  /* 8216630Ch */ case   11:  		/* cmplwi CR6, R11, 18 */
		/* 8216630Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 8216630Ch case   11:*/		return 0x82166310;
		  /* 82166310h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 82166310h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216631C;  }
		/* 82166310h case   12:*/		return 0x82166314;
		  /* 82166314h */ case   13:  		/* li R27, 2 */
		/* 82166314h case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x2);
		/* 82166314h case   13:*/		return 0x82166318;
		  /* 82166318h */ case   14:  		/* b 236 */
		/* 82166318h case   14:*/		return 0x82166404;
		/* 82166318h case   14:*/		return 0x8216631C;
	}
	return 0x8216631C;
} // Block from 821662E0h-8216631Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216631Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216631C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216631C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216631C);
		  /* 8216631Ch */ case    0:  		/* cmplwi CR6, R27, 1 */
		/* 8216631Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 8216631Ch case    0:*/		return 0x82166320;
		  /* 82166320h */ case    1:  		/* bc 4, CR6_LT, 228 */
		/* 82166320h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82166404;  }
		/* 82166320h case    1:*/		return 0x82166324;
		  /* 82166324h */ case    2:  		/* mr R27, R22 */
		/* 82166324h case    2:*/		regs.R27 = regs.R22;
		/* 82166324h case    2:*/		return 0x82166328;
		  /* 82166328h */ case    3:  		/* b 220 */
		/* 82166328h case    3:*/		return 0x82166404;
		/* 82166328h case    3:*/		return 0x8216632C;
	}
	return 0x8216632C;
} // Block from 8216631Ch-8216632Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216632Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216632C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216632C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216632C);
		  /* 8216632Ch */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 8216632Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8216632Ch case    0:*/		return 0x82166330;
		  /* 82166330h */ case    1:  		/* lwz R9, <#[R11 + 8]> */
		/* 82166330h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82166330h case    1:*/		return 0x82166334;
		  /* 82166334h */ case    2:  		/* rlwinm R10, R9, 0, 18, 24 */
		/* 82166334h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R9);
		/* 82166334h case    2:*/		return 0x82166338;
		  /* 82166338h */ case    3:  		/* cmplwi CR6, R10, 14720 */
		/* 82166338h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003980);
		/* 82166338h case    3:*/		return 0x8216633C;
		  /* 8216633Ch */ case    4:  		/* bc 12, CR6_EQ, 200 */
		/* 8216633Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82166404;  }
		/* 8216633Ch case    4:*/		return 0x82166340;
		  /* 82166340h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82166340h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82166340h case    5:*/		return 0x82166344;
		  /* 82166344h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82166344h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166344h case    6:*/		return 0x82166348;
		  /* 82166348h */ case    7:  		/* bc 12, CR6_EQ, 188 */
		/* 82166348h case    7:*/		if ( regs.CR[6].eq ) { return 0x82166404;  }
		/* 82166348h case    7:*/		return 0x8216634C;
		  /* 8216634Ch */ case    8:  		/* lwz R10, <#[R11 + 16]> */
		/* 8216634Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8216634Ch case    8:*/		return 0x82166350;
		  /* 82166350h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 82166350h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82166350h case    9:*/		return 0x82166354;
		  /* 82166354h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 82166354h case   10:*/		if ( regs.CR[6].eq ) { return 0x82166364;  }
		/* 82166354h case   10:*/		return 0x82166358;
		  /* 82166358h */ case   11:  		/* lwz R10, <#[R11]> */
		/* 82166358h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82166358h case   11:*/		return 0x8216635C;
		  /* 8216635Ch */ case   12:  		/* rlwinm. R8, R10, 0, 4, 6 */
		/* 8216635Ch case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R10);
		/* 8216635Ch case   12:*/		return 0x82166360;
		  /* 82166360h */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 82166360h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8216636C;  }
		/* 82166360h case   13:*/		return 0x82166364;
	}
	return 0x82166364;
} // Block from 8216632Ch-82166364h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82166364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166364);
		  /* 82166364h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82166364h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82166364h case    0:*/		return 0x82166368;
		  /* 82166368h */ case    1:  		/* b -36 */
		/* 82166368h case    1:*/		return 0x82166344;
		/* 82166368h case    1:*/		return 0x8216636C;
	}
	return 0x8216636C;
} // Block from 82166364h-8216636Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216636Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216636C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216636C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216636C);
		  /* 8216636Ch */ case    0:  		/* lwz R11, <#[R15 + 48]> */
		/* 8216636Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 8216636Ch case    0:*/		return 0x82166370;
		  /* 82166370h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82166370h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82166370h case    1:*/		return 0x82166374;
		  /* 82166374h */ case    2:  		/* cmplw CR6, R11, R17 */
		/* 82166374h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 82166374h case    2:*/		return 0x82166378;
		  /* 82166378h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 82166378h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82166378h case    3:*/		return 0x8216637C;
		  /* 8216637Ch */ case    4:  		/* bc 4, CR6_EQ, 64 */
		/* 8216637Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x821663BC;  }
		/* 8216637Ch case    4:*/		return 0x82166380;
		  /* 82166380h */ case    5:  		/* rlwinm R31, R10, 15, 24, 31 */
		/* 82166380h case    5:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R31,regs.R10);
		/* 82166380h case    5:*/		return 0x82166384;
		  /* 82166384h */ case    6:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166384h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166384h case    6:*/		return 0x82166388;
		  /* 82166388h */ case    7:  		/* mr R10, R11 */
		/* 82166388h case    7:*/		regs.R10 = regs.R11;
		/* 82166388h case    7:*/		return 0x8216638C;
		  /* 8216638Ch */ case    8:  		/* rlwinm R5, R9, 31, 28, 31 */
		/* 8216638Ch case    8:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R5,regs.R9);
		/* 8216638Ch case    8:*/		return 0x82166390;
		  /* 82166390h */ case    9:  		/* rlwimi R10, R11, 31, 17, 18 */
		/* 82166390h case    9:*/		cpu::op::rlwimi<0,31,17,18>(regs,&regs.R10,regs.R11);
		/* 82166390h case    9:*/		return 0x82166394;
		  /* 82166394h */ case   10:  		/* rlwinm R9, R11, 4, 24, 27 */
		/* 82166394h case   10:*/		cpu::op::rlwinm<0,4,24,27>(regs,&regs.R9,regs.R11);
		/* 82166394h case   10:*/		return 0x82166398;
		  /* 82166398h */ case   11:  		/* rlwinm R11, R10, 27, 22, 31 */
		/* 82166398h case   11:*/		cpu::op::rlwinm<0,27,22,31>(regs,&regs.R11,regs.R10);
		/* 82166398h case   11:*/		return 0x8216639C;
		  /* 8216639Ch */ case   12:  		/* mr R4, R31 */
		/* 8216639Ch case   12:*/		regs.R4 = regs.R31;
		/* 8216639Ch case   12:*/		return 0x821663A0;
		  /* 821663A0h */ case   13:  		/* rlwinm R11, R11, 0, 28, 23 */
		/* 821663A0h case   13:*/		cpu::op::rlwinm<0,0,28,23>(regs,&regs.R11,regs.R11);
		/* 821663A0h case   13:*/		return 0x821663A4;
		  /* 821663A4h */ case   14:  		/* or R6, R11, R9 */
		/* 821663A4h case   14:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R9);
		/* 821663A4h case   14:*/		return 0x821663A8;
		  /* 821663A8h */ case   15:  		/* bl -1019472 */
		/* 821663A8h case   15:*/		regs.LR = 0x821663AC; return 0x8206D558;
		/* 821663A8h case   15:*/		return 0x821663AC;
		  /* 821663ACh */ case   16:  		/* cmplw CR6, R31, R28 */
		/* 821663ACh case   16:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 821663ACh case   16:*/		return 0x821663B0;
		  /* 821663B0h */ case   17:  		/* bc 4, CR6_GT, 84 */
		/* 821663B0h case   17:*/		if ( !regs.CR[6].gt ) { return 0x82166404;  }
		/* 821663B0h case   17:*/		return 0x821663B4;
		  /* 821663B4h */ case   18:  		/* mr R28, R31 */
		/* 821663B4h case   18:*/		regs.R28 = regs.R31;
		/* 821663B4h case   18:*/		return 0x821663B8;
		  /* 821663B8h */ case   19:  		/* b 76 */
		/* 821663B8h case   19:*/		return 0x82166404;
		/* 821663B8h case   19:*/		return 0x821663BC;
	}
	return 0x821663BC;
} // Block from 8216636Ch-821663BCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821663BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821663BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821663BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821663BC);
		  /* 821663BCh */ case    0:  		/* mr R9, R11 */
		/* 821663BCh case    0:*/		regs.R9 = regs.R11;
		/* 821663BCh case    0:*/		return 0x821663C0;
		  /* 821663C0h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821663C0h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821663C0h case    1:*/		return 0x821663C4;
		  /* 821663C4h */ case    2:  		/* rlwimi R9, R10, 28, 11, 18 */
		/* 821663C4h case    2:*/		cpu::op::rlwimi<0,28,11,18>(regs,&regs.R9,regs.R10);
		/* 821663C4h case    2:*/		return 0x821663C8;
		  /* 821663C8h */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 821663C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 821663C8h case    3:*/		return 0x821663CC;
		  /* 821663CCh */ case    4:  		/* rlwinm R10, R9, 23, 20, 31 */
		/* 821663CCh case    4:*/		cpu::op::rlwinm<0,23,20,31>(regs,&regs.R10,regs.R9);
		/* 821663CCh case    4:*/		return 0x821663D0;
		  /* 821663D0h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 821663D0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821663D8;  }
		/* 821663D0h case    5:*/		return 0x821663D4;
		  /* 821663D4h */ case    6:  		/* li R11, 9 */
		/* 821663D4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 821663D4h case    6:*/		return 0x821663D8;
	}
	return 0x821663D8;
} // Block from 821663BCh-821663D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821663D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821663D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821663D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821663D8);
		  /* 821663D8h */ case    0:  		/* lwz R9, <#[R30]> */
		/* 821663D8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 821663D8h case    0:*/		return 0x821663DC;
		  /* 821663DCh */ case    1:  		/* rlwinm R5, R10, 0, 28, 31 */
		/* 821663DCh case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R5,regs.R10);
		/* 821663DCh case    1:*/		return 0x821663E0;
		  /* 821663E0h */ case    2:  		/* rlwinm R4, R10, 28, 4, 31 */
		/* 821663E0h case    2:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R4,regs.R10);
		/* 821663E0h case    2:*/		return 0x821663E4;
		  /* 821663E4h */ case    3:  		/* lwz R3, <#[R15 + 768]> */
		/* 821663E4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821663E4h case    3:*/		return 0x821663E8;
		  /* 821663E8h */ case    4:  		/* mr R8, R9 */
		/* 821663E8h case    4:*/		regs.R8 = regs.R9;
		/* 821663E8h case    4:*/		return 0x821663EC;
		  /* 821663ECh */ case    5:  		/* rlwinm R11, R11, 4, 24, 27 */
		/* 821663ECh case    5:*/		cpu::op::rlwinm<0,4,24,27>(regs,&regs.R11,regs.R11);
		/* 821663ECh case    5:*/		return 0x821663F0;
		  /* 821663F0h */ case    6:  		/* rlwimi R8, R9, 31, 17, 18 */
		/* 821663F0h case    6:*/		cpu::op::rlwimi<0,31,17,18>(regs,&regs.R8,regs.R9);
		/* 821663F0h case    6:*/		return 0x821663F4;
		  /* 821663F4h */ case    7:  		/* rlwinm R10, R8, 27, 22, 31 */
		/* 821663F4h case    7:*/		cpu::op::rlwinm<0,27,22,31>(regs,&regs.R10,regs.R8);
		/* 821663F4h case    7:*/		return 0x821663F8;
		  /* 821663F8h */ case    8:  		/* rlwinm R10, R10, 0, 28, 23 */
		/* 821663F8h case    8:*/		cpu::op::rlwinm<0,0,28,23>(regs,&regs.R10,regs.R10);
		/* 821663F8h case    8:*/		return 0x821663FC;
		  /* 821663FCh */ case    9:  		/* or R6, R10, R11 */
		/* 821663FCh case    9:*/		cpu::op::or<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 821663FCh case    9:*/		return 0x82166400;
		  /* 82166400h */ case   10:  		/* bl -1019536 */
		/* 82166400h case   10:*/		regs.LR = 0x82166404; return 0x8206D570;
		/* 82166400h case   10:*/		return 0x82166404;
	}
	return 0x82166404;
} // Block from 821663D8h-82166404h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82166404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166404);
		  /* 82166404h */ case    0:  		/* lwz R11, <#[R15 + 536]> */
		/* 82166404h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000218) );
		/* 82166404h case    0:*/		return 0x82166408;
		  /* 82166408h */ case    1:  		/* addi R29, R29, 1 */
		/* 82166408h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82166408h case    1:*/		return 0x8216640C;
		  /* 8216640Ch */ case    2:  		/* addi R30, R30, 12 */
		/* 8216640Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xC);
		/* 8216640Ch case    2:*/		return 0x82166410;
		  /* 82166410h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82166410h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82166410h case    3:*/		return 0x82166414;
		  /* 82166414h */ case    4:  		/* bc 12, CR6_LT, -284 */
		/* 82166414h case    4:*/		if ( regs.CR[6].lt ) { return 0x821662F8;  }
		/* 82166414h case    4:*/		return 0x82166418;
	}
	return 0x82166418;
} // Block from 82166404h-82166418h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82166418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166418);
		  /* 82166418h */ case    0:  		/* lwz R11, <#[R15 + 48]> */
		/* 82166418h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 82166418h case    0:*/		return 0x8216641C;
		  /* 8216641Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 8216641Ch case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 8216641Ch case    1:*/		return 0x82166420;
		  /* 82166420h */ case    2:  		/* cmplw CR6, R11, R17 */
		/* 82166420h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 82166420h case    2:*/		return 0x82166424;
		  /* 82166424h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82166424h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216644C;  }
		/* 82166424h case    3:*/		return 0x82166428;
		  /* 82166428h */ case    4:  		/* li R5, 0 */
		/* 82166428h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82166428h case    4:*/		return 0x8216642C;
		  /* 8216642Ch */ case    5:  		/* mr R4, R25 */
		/* 8216642Ch case    5:*/		regs.R4 = regs.R25;
		/* 8216642Ch case    5:*/		return 0x82166430;
		  /* 82166430h */ case    6:  		/* mr R3, R15 */
		/* 82166430h case    6:*/		regs.R3 = regs.R15;
		/* 82166430h case    6:*/		return 0x82166434;
		  /* 82166434h */ case    7:  		/* bl -1428 */
		/* 82166434h case    7:*/		regs.LR = 0x82166438; return 0x82165EA0;
		/* 82166434h case    7:*/		return 0x82166438;
		  /* 82166438h */ case    8:  		/* mr R4, R3 */
		/* 82166438h case    8:*/		regs.R4 = regs.R3;
		/* 82166438h case    8:*/		return 0x8216643C;
		  /* 8216643Ch */ case    9:  		/* mr R3, R15 */
		/* 8216643Ch case    9:*/		regs.R3 = regs.R15;
		/* 8216643Ch case    9:*/		return 0x82166440;
		  /* 82166440h */ case   10:  		/* lwz R6, <#[R14 + 4]> */
		/* 82166440h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R14 + 0x00000004) );
		/* 82166440h case   10:*/		return 0x82166444;
		  /* 82166444h */ case   11:  		/* lwz R5, <#[R14]> */
		/* 82166444h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R14 + 0x00000000) );
		/* 82166444h case   11:*/		return 0x82166448;
		  /* 82166448h */ case   12:  		/* bl -6680 */
		/* 82166448h case   12:*/		regs.LR = 0x8216644C; return 0x82164A30;
		/* 82166448h case   12:*/		return 0x8216644C;
	}
	return 0x8216644C;
} // Block from 82166418h-8216644Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216644Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216644C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216644C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216644C);
		  /* 8216644Ch */ case    0:  		/* lwz R11, <#[R15 + 4]> */
		/* 8216644Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 8216644Ch case    0:*/		return 0x82166450;
		  /* 82166450h */ case    1:  		/* mr R3, R15 */
		/* 82166450h case    1:*/		regs.R3 = regs.R15;
		/* 82166450h case    1:*/		return 0x82166454;
		  /* 82166454h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82166454h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166454h case    2:*/		return 0x82166458;
	}
	return 0x82166458;
} // Block from 8216644Ch-82166458h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166458h
// Function '?AddPDBInfo@Compiler@D3DXShader@@AAAXHKPAUXShaderPDBBuilder@@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166458);
		  /* 82166458h */ case    0:  		/* addic R10, R10, -1 */
		/* 82166458h case    0:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82166458h case    0:*/		return 0x8216645C;
		  /* 8216645Ch */ case    1:  		/* subfe R10, R10, R10 */
		/* 8216645Ch case    1:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216645Ch case    1:*/		return 0x82166460;
		  /* 82166460h */ case    2:  		/* and R11, R10, R11 */
		/* 82166460h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82166460h case    2:*/		return 0x82166464;
		  /* 82166464h */ case    3:  		/* addi R4, R11, 16 */
		/* 82166464h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 82166464h case    3:*/		return 0x82166468;
		  /* 82166468h */ case    4:  		/* bl -5624 */
		/* 82166468h case    4:*/		regs.LR = 0x8216646C; return 0x82164E70;
		/* 82166468h case    4:*/		return 0x8216646C;
		  /* 8216646Ch */ case    5:  		/* mr R30, R3 */
		/* 8216646Ch case    5:*/		regs.R30 = regs.R3;
		/* 8216646Ch case    5:*/		return 0x82166470;
		  /* 82166470h */ case    6:  		/* mr R31, R25 */
		/* 82166470h case    6:*/		regs.R31 = regs.R25;
		/* 82166470h case    6:*/		return 0x82166474;
		  /* 82166474h */ case    7:  		/* cmplwi CR6, R25, 0 */
		/* 82166474h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82166474h case    7:*/		return 0x82166478;
		  /* 82166478h */ case    8:  		/* bc 12, CR6_EQ, 72 */
		/* 82166478h case    8:*/		if ( regs.CR[6].eq ) { return 0x821664C0;  }
		/* 82166478h case    8:*/		return 0x8216647C;
		  /* 8216647Ch */ case    9:  		/* cmplw CR6, R31, R25 */
		/* 8216647Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 8216647Ch case    9:*/		return 0x82166480;
		  /* 82166480h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 82166480h case   10:*/		if ( regs.CR[6].eq ) { return 0x82166490;  }
		/* 82166480h case   10:*/		return 0x82166484;
		  /* 82166484h */ case   11:  		/* lwz R11, <#[R31 + 76]> */
		/* 82166484h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 82166484h case   11:*/		return 0x82166488;
		  /* 82166488h */ case   12:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 82166488h case   12:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 82166488h case   12:*/		return 0x8216648C;
		  /* 8216648Ch */ case   13:  		/* bc 4, CR0_EQ, 52 */
		/* 8216648Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x821664C0;  }
		/* 8216648Ch case   13:*/		return 0x82166490;
	}
	return 0x82166490;
} // Block from 82166458h-82166490h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82166490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166490);
		  /* 82166490h */ case    0:  		/* addi R4, R31, 24 */
		/* 82166490h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x18);
		/* 82166490h case    0:*/		return 0x82166494;
		  /* 82166494h */ case    1:  		/* mr R3, R15 */
		/* 82166494h case    1:*/		regs.R3 = regs.R15;
		/* 82166494h case    1:*/		return 0x82166498;
		  /* 82166498h */ case    2:  		/* bl -5672 */
		/* 82166498h case    2:*/		regs.LR = 0x8216649C; return 0x82164E70;
		/* 82166498h case    2:*/		return 0x8216649C;
		  /* 8216649Ch */ case    3:  		/* cmplw CR6, R3, R30 */
		/* 8216649Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8216649Ch case    3:*/		return 0x821664A0;
		  /* 821664A0h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 821664A0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821664A8;  }
		/* 821664A0h case    4:*/		return 0x821664A4;
		  /* 821664A4h */ case    5:  		/* mr R30, R3 */
		/* 821664A4h case    5:*/		regs.R30 = regs.R3;
		/* 821664A4h case    5:*/		return 0x821664A8;
	}
	return 0x821664A8;
} // Block from 82166490h-821664A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821664A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821664A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821664A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821664A8);
		  /* 821664A8h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821664A8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821664A8h case    0:*/		return 0x821664AC;
		  /* 821664ACh */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 821664ACh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 821664ACh case    1:*/		return 0x821664B0;
		  /* 821664B0h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821664B0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821664B0h case    2:*/		return 0x821664B4;
		  /* 821664B4h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821664B4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821664C0;  }
		/* 821664B4h case    3:*/		return 0x821664B8;
		  /* 821664B8h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821664B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821664B8h case    4:*/		return 0x821664BC;
		  /* 821664BCh */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 821664BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8216647C;  }
		/* 821664BCh case    5:*/		return 0x821664C0;
	}
	return 0x821664C0;
} // Block from 821664A8h-821664C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821664C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821664C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821664C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821664C0);
		  /* 821664C0h */ case    0:  		/* lwz R11, <#[R15 + 48]> */
		/* 821664C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 821664C0h case    0:*/		return 0x821664C4;
		  /* 821664C4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821664C4h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821664C4h case    1:*/		return 0x821664C8;
		  /* 821664C8h */ case    2:  		/* cmplw CR6, R11, R17 */
		/* 821664C8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 821664C8h case    2:*/		return 0x821664CC;
		  /* 821664CCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 821664CCh case    3:*/		if ( regs.CR[6].eq ) { return 0x821664E4;  }
		/* 821664CCh case    3:*/		return 0x821664D0;
		  /* 821664D0h */ case    4:  		/* lwz R11, <#[R14]> */
		/* 821664D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 821664D0h case    4:*/		return 0x821664D4;
		  /* 821664D4h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 821664D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821664D4h case    5:*/		return 0x821664D8;
		  /* 821664D8h */ case    6:  		/* rlwimi R10, R30, 0, 26, 31 */
		/* 821664D8h case    6:*/		cpu::op::rlwimi<0,0,26,31>(regs,&regs.R10,regs.R30);
		/* 821664D8h case    6:*/		return 0x821664DC;
		  /* 821664DCh */ case    7:  		/* stw R10, <#[R11]> */
		/* 821664DCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821664DCh case    7:*/		return 0x821664E0;
		  /* 821664E0h */ case    8:  		/* b 36 */
		/* 821664E0h case    8:*/		return 0x82166504;
		/* 821664E0h case    8:*/		return 0x821664E4;
	}
	return 0x821664E4;
} // Block from 821664C0h-821664E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821664E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821664E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821664E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821664E4);
		  /* 821664E4h */ case    0:  		/* add R11, R27, R28 */
		/* 821664E4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R27,regs.R28);
		/* 821664E4h case    0:*/		return 0x821664E8;
		  /* 821664E8h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 821664E8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821664E8h case    1:*/		return 0x821664EC;
		  /* 821664ECh */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 821664ECh case    2:*/		if ( !regs.CR[6].gt ) { return 0x821664F4;  }
		/* 821664ECh case    2:*/		return 0x821664F0;
		  /* 821664F0h */ case    3:  		/* mr R11, R30 */
		/* 821664F0h case    3:*/		regs.R11 = regs.R30;
		/* 821664F0h case    3:*/		return 0x821664F4;
	}
	return 0x821664F4;
} // Block from 821664E4h-821664F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821664F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821664F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821664F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821664F4);
		  /* 821664F4h */ case    0:  		/* lwz R10, <#[R14]> */
		/* 821664F4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 821664F4h case    0:*/		return 0x821664F8;
		  /* 821664F8h */ case    1:  		/* lwz R9, <#[R10]> */
		/* 821664F8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821664F8h case    1:*/		return 0x821664FC;
		  /* 821664FCh */ case    2:  		/* rlwimi R9, R11, 8, 18, 23 */
		/* 821664FCh case    2:*/		cpu::op::rlwimi<0,8,18,23>(regs,&regs.R9,regs.R11);
		/* 821664FCh case    2:*/		return 0x82166500;
		  /* 82166500h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82166500h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82166500h case    3:*/		return 0x82166504;
	}
	return 0x82166504;
} // Block from 821664F4h-82166504h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82166504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166504);
		  /* 82166504h */ case    0:  		/* lwz R11, <#[R14 + 4]> */
		/* 82166504h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 82166504h case    0:*/		return 0x82166508;
		  /* 82166508h */ case    1:  		/* lwz R10, <#[R14]> */
		/* 82166508h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 82166508h case    1:*/		return 0x8216650C;
		  /* 8216650Ch */ case    2:  		/* lwz R3, <#[R15 + 768]> */
		/* 8216650Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 8216650Ch case    2:*/		return 0x82166510;
		  /* 82166510h */ case    3:  		/* lwz R5, <#[R11]> */
		/* 82166510h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 82166510h case    3:*/		return 0x82166514;
		  /* 82166514h */ case    4:  		/* lwz R4, <#[R10]> */
		/* 82166514h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 82166514h case    4:*/		return 0x82166518;
		  /* 82166518h */ case    5:  		/* bl -1041848 */
		/* 82166518h case    5:*/		regs.LR = 0x8216651C; return 0x82067F60;
		/* 82166518h case    5:*/		return 0x8216651C;
		  /* 8216651Ch */ case    6:  		/* li R19, -1 */
		/* 8216651Ch case    6:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 8216651Ch case    6:*/		return 0x82166520;
		  /* 82166520h */ case    7:  		/* mr R20, R23 */
		/* 82166520h case    7:*/		regs.R20 = regs.R23;
		/* 82166520h case    7:*/		return 0x82166524;
		  /* 82166524h */ case    8:  		/* mr R27, R22 */
		/* 82166524h case    8:*/		regs.R27 = regs.R22;
		/* 82166524h case    8:*/		return 0x82166528;
		  /* 82166528h */ case    9:  		/* mr R24, R23 */
		/* 82166528h case    9:*/		regs.R24 = regs.R23;
		/* 82166528h case    9:*/		return 0x8216652C;
		  /* 8216652Ch */ case   10:  		/* mr R26, R25 */
		/* 8216652Ch case   10:*/		regs.R26 = regs.R25;
		/* 8216652Ch case   10:*/		return 0x82166530;
		  /* 82166530h */ case   11:  		/* cmplwi CR6, R25, 0 */
		/* 82166530h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82166530h case   11:*/		return 0x82166534;
		  /* 82166534h */ case   12:  		/* lwz R18, <#[R14 + 8]> */
		/* 82166534h case   12:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R14 + 0x00000008) );
		/* 82166534h case   12:*/		return 0x82166538;
		  /* 82166538h */ case   13:  		/* lwz R21, <#[R14 + 12]> */
		/* 82166538h case   13:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R14 + 0x0000000C) );
		/* 82166538h case   13:*/		return 0x8216653C;
		  /* 8216653Ch */ case   14:  		/* lwz R16, <#[R14 + 16]> */
		/* 8216653Ch case   14:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R14 + 0x00000010) );
		/* 8216653Ch case   14:*/		return 0x82166540;
		  /* 82166540h */ case   15:  		/* stw R18, <#[R1 + 104]> */
		/* 82166540h case   15:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 82166540h case   15:*/		return 0x82166544;
		  /* 82166544h */ case   16:  		/* stw R21, <#[R1 + 100]> */
		/* 82166544h case   16:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 82166544h case   16:*/		return 0x82166548;
		  /* 82166548h */ case   17:  		/* stw R16, <#[R1 + 108]> */
		/* 82166548h case   17:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R1 + 0x0000006C) );
		/* 82166548h case   17:*/		return 0x8216654C;
		  /* 8216654Ch */ case   18:  		/* bc 12, CR6_EQ, 3160 */
		/* 8216654Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x821671A4;  }
		/* 8216654Ch case   18:*/		return 0x82166550;
		  /* 82166550h */ case   19:  		/* cmplw CR6, R26, R25 */
		/* 82166550h case   19:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 82166550h case   19:*/		return 0x82166554;
		  /* 82166554h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 82166554h case   20:*/		if ( regs.CR[6].eq ) { return 0x82166564;  }
		/* 82166554h case   20:*/		return 0x82166558;
	}
	return 0x82166558;
} // Block from 82166504h-82166558h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82166558h
// Function '?ResolveDebugInfoAddress@Compiler@D3DXShader@@AAAKPAUXShaderPDBBuilder@@PAVInstruction@2@KPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166558);
		  /* 82166558h */ case    0:  		/* lwz R11, <#[R26 + 76]> */
		/* 82166558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 82166558h case    0:*/		return 0x8216655C;
		  /* 8216655Ch */ case    1:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 8216655Ch case    1:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 8216655Ch case    1:*/		return 0x82166560;
		  /* 82166560h */ case    2:  		/* bc 4, CR0_EQ, 3140 */
		/* 82166560h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821671A4;  }
		/* 82166560h case    2:*/		return 0x82166564;
	}
	return 0x82166564;
} // Block from 82166558h-82166564h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166564);
		  /* 82166564h */ case    0:  		/* lwz R31, <#[R26 + 20]> */
		/* 82166564h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000014) );
		/* 82166564h case    0:*/		return 0x82166568;
		  /* 82166568h */ case    1:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82166568h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82166568h case    1:*/		return 0x8216656C;
		  /* 8216656Ch */ case    2:  		/* bc 4, CR0_EQ, 80 */
		/* 8216656Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x821665BC;  }
		/* 8216656Ch case    2:*/		return 0x82166570;
		  /* 82166570h */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 82166570h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 82166570h case    3:*/		return 0x82166574;
		  /* 82166574h */ case    4:  		/* bc 12, CR0_EQ, 72 */
		/* 82166574h case    4:*/		if ( regs.CR[0].eq ) { return 0x821665BC;  }
		/* 82166574h case    4:*/		return 0x82166578;
		  /* 82166578h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 82166578h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82166578h case    5:*/		return 0x8216657C;
		  /* 8216657Ch */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216657Ch case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216657Ch case    6:*/		return 0x82166580;
		  /* 82166580h */ case    7:  		/* cmplwi CR6, R11, 14848 */
		/* 82166580h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A00);
		/* 82166580h case    7:*/		return 0x82166584;
		  /* 82166584h */ case    8:  		/* bc 4, CR6_EQ, 32 */
		/* 82166584h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821665A4;  }
		/* 82166584h case    8:*/		return 0x82166588;
		  /* 82166588h */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 82166588h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82166588h case    9:*/		return 0x8216658C;
		  /* 8216658Ch */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 8216658Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216658Ch case   10:*/		return 0x82166590;
		  /* 82166590h */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 82166590h case   11:*/		if ( regs.CR[6].eq ) { return 0x821665A4;  }
		/* 82166590h case   11:*/		return 0x82166594;
		  /* 82166594h */ case   12:  		/* lwz R11, <#[R31 + 28]> */
		/* 82166594h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82166594h case   12:*/		return 0x82166598;
		  /* 82166598h */ case   13:  		/* lwz R11, <#[R11 + 68]> */
		/* 82166598h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 82166598h case   13:*/		return 0x8216659C;
		  /* 8216659Ch */ case   14:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 8216659Ch case   14:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 8216659Ch case   14:*/		return 0x821665A0;
		  /* 821665A0h */ case   15:  		/* bc 12, CR0_EQ, 3104 */
		/* 821665A0h case   15:*/		if ( regs.CR[0].eq ) { return 0x821671C0;  }
		/* 821665A0h case   15:*/		return 0x821665A4;
	}
	return 0x821665A4;
} // Block from 82166564h-821665A4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821665A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821665A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821665A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821665A4);
		  /* 821665A4h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821665A4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821665A4h case    0:*/		return 0x821665A8;
		  /* 821665A8h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 821665A8h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 821665A8h case    1:*/		return 0x821665AC;
		  /* 821665ACh */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821665ACh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821665ACh case    2:*/		return 0x821665B0;
		  /* 821665B0h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821665B0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821665BC;  }
		/* 821665B0h case    3:*/		return 0x821665B4;
		  /* 821665B4h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821665B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821665B4h case    4:*/		return 0x821665B8;
		  /* 821665B8h */ case    5:  		/* bc 4, CR6_EQ, -64 */
		/* 821665B8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82166578;  }
		/* 821665B8h case    5:*/		return 0x821665BC;
	}
	return 0x821665BC;
} // Block from 821665A4h-821665BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821665BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821665BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821665BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821665BC);
		  /* 821665BCh */ case    0:  		/* lwz R31, <#[R26 + 28]> */
		/* 821665BCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x0000001C) );
		/* 821665BCh case    0:*/		return 0x821665C0;
		  /* 821665C0h */ case    1:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821665C0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821665C0h case    1:*/		return 0x821665C4;
		  /* 821665C4h */ case    2:  		/* bc 4, CR0_EQ, 3012 */
		/* 821665C4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82167188;  }
		/* 821665C4h case    2:*/		return 0x821665C8;
		  /* 821665C8h */ case    3:  		/* cmplwi CR0, R31, 0 */
		/* 821665C8h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821665C8h case    3:*/		return 0x821665CC;
		  /* 821665CCh */ case    4:  		/* bc 12, CR0_EQ, 3004 */
		/* 821665CCh case    4:*/		if ( regs.CR[0].eq ) { return 0x82167188;  }
		/* 821665CCh case    4:*/		return 0x821665D0;
		  /* 821665D0h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 821665D0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821665D0h case    5:*/		return 0x821665D4;
		  /* 821665D4h */ case    6:  		/* li R9, -1 */
		/* 821665D4h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 821665D4h case    6:*/		return 0x821665D8;
		  /* 821665D8h */ case    7:  		/* mr R30, R19 */
		/* 821665D8h case    7:*/		regs.R30 = regs.R19;
		/* 821665D8h case    7:*/		return 0x821665DC;
		  /* 821665DCh */ case    8:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821665DCh case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821665DCh case    8:*/		return 0x821665E0;
		  /* 821665E0h */ case    9:  		/* stw R9, <#[R1 + 96]> */
		/* 821665E0h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 821665E0h case    9:*/		return 0x821665E4;
		  /* 821665E4h */ case   10:  		/* mr R25, R31 */
		/* 821665E4h case   10:*/		regs.R25 = regs.R31;
		/* 821665E4h case   10:*/		return 0x821665E8;
		  /* 821665E8h */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 821665E8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821665E8h case   11:*/		return 0x821665EC;
		  /* 821665ECh */ case   12:  		/* bc 12, CR6_LT, 16 */
		/* 821665ECh case   12:*/		if ( regs.CR[6].lt ) { return 0x821665FC;  }
		/* 821665ECh case   12:*/		return 0x821665F0;
		  /* 821665F0h */ case   13:  		/* cmplwi CR6, R10, 82 */
		/* 821665F0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000052);
		/* 821665F0h case   13:*/		return 0x821665F4;
		  /* 821665F4h */ case   14:  		/* mr R9, R22 */
		/* 821665F4h case   14:*/		regs.R9 = regs.R22;
		/* 821665F4h case   14:*/		return 0x821665F8;
		  /* 821665F8h */ case   15:  		/* bc 4, CR6_GT, 8 */
		/* 821665F8h case   15:*/		if ( !regs.CR[6].gt ) { return 0x82166600;  }
		/* 821665F8h case   15:*/		return 0x821665FC;
	}
	return 0x821665FC;
} // Block from 821665BCh-821665FCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821665FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821665FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821665FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821665FC);
		  /* 821665FCh */ case    0:  		/* mr R9, R23 */
		/* 821665FCh case    0:*/		regs.R9 = regs.R23;
		/* 821665FCh case    0:*/		return 0x82166600;
	}
	return 0x82166600;
} // Block from 821665FCh-82166600h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166600);
		  /* 82166600h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82166600h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82166600h case    0:*/		return 0x82166604;
		  /* 82166604h */ case    1:  		/* bc 12, CR0_EQ, 888 */
		/* 82166604h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216697C;  }
		/* 82166604h case    1:*/		return 0x82166608;
		  /* 82166608h */ case    2:  		/* lwz R11, <#[R26 + 76]> */
		/* 82166608h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 82166608h case    2:*/		return 0x8216660C;
		  /* 8216660Ch */ case    3:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8216660Ch case    3:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8216660Ch case    3:*/		return 0x82166610;
		  /* 82166610h */ case    4:  		/* bc 12, CR0_EQ, 104 */
		/* 82166610h case    4:*/		if ( regs.CR[0].eq ) { return 0x82166678;  }
		/* 82166610h case    4:*/		return 0x82166614;
		  /* 82166614h */ case    5:  		/* mr R3, R31 */
		/* 82166614h case    5:*/		regs.R3 = regs.R31;
		/* 82166614h case    5:*/		return 0x82166618;
		  /* 82166618h */ case    6:  		/* bl -9432 */
		/* 82166618h case    6:*/		regs.LR = 0x8216661C; return 0x82164140;
		/* 82166618h case    6:*/		return 0x8216661C;
		  /* 8216661Ch */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216661Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216661Ch case    7:*/		return 0x82166620;
		  /* 82166620h */ case    8:  		/* bc 12, CR0_EQ, 88 */
		/* 82166620h case    8:*/		if ( regs.CR[0].eq ) { return 0x82166678;  }
		/* 82166620h case    8:*/		return 0x82166624;
		  /* 82166624h */ case    9:  		/* lwz R11, <#[R26 + 112]> */
		/* 82166624h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 82166624h case    9:*/		return 0x82166628;
		  /* 82166628h */ case   10:  		/* lwz R10, <#[R11 + 48]> */
		/* 82166628h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82166628h case   10:*/		return 0x8216662C;
		  /* 8216662Ch */ case   11:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 8216662Ch case   11:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 8216662Ch case   11:*/		return 0x82166630;
		  /* 82166630h */ case   12:  		/* bc 12, CR0_EQ, 48 */
		/* 82166630h case   12:*/		if ( regs.CR[0].eq ) { return 0x82166660;  }
		/* 82166630h case   12:*/		return 0x82166634;
		  /* 82166634h */ case   13:  		/* b 16 */
		/* 82166634h case   13:*/		return 0x82166644;
		/* 82166634h case   13:*/		return 0x82166638;
	}
	return 0x82166638;
} // Block from 82166600h-82166638h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82166638h
// Function '?ValidatorOutputCallbackWorker@Compiler@D3DXShader@@AAAJPBDK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166638);
		  /* 82166638h */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 82166638h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82166638h case    0:*/		return 0x8216663C;
		  /* 8216663Ch */ case    1:  		/* rlwinm. R10, R10, 0, 9, 9 */
		/* 8216663Ch case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R10,regs.R10);
		/* 8216663Ch case    1:*/		return 0x82166640;
		  /* 82166640h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82166640h case    2:*/		if ( regs.CR[0].eq ) { return 0x82166650;  }
		/* 82166640h case    2:*/		return 0x82166644;
	}
	return 0x82166644;
} // Block from 82166638h-82166644h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166644);
		  /* 82166644h */ case    0:  		/* lwz R11, <#[R11 + 80]> */
		/* 82166644h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82166644h case    0:*/		return 0x82166648;
		  /* 82166648h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82166648h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166648h case    1:*/		return 0x8216664C;
		  /* 8216664Ch */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 8216664Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82166638;  }
		/* 8216664Ch case    2:*/		return 0x82166650;
	}
	return 0x82166650;
} // Block from 82166644h-82166650h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166650);
		  /* 82166650h */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 82166650h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82166650h case    0:*/		return 0x82166654;
		  /* 82166654h */ case    1:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82166654h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82166654h case    1:*/		return 0x82166658;
		  /* 82166658h */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 82166658h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82166644;  }
		/* 82166658h case    2:*/		return 0x8216665C;
		  /* 8216665Ch */ case    3:  		/* stw R11, <#[R26 + 112]> */
		/* 8216665Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 8216665Ch case    3:*/		return 0x82166660;
	}
	return 0x82166660;
} // Block from 82166650h-82166660h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82166660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166660);
		  /* 82166660h */ case    0:  		/* lwz R11, <#[R26 + 112]> */
		/* 82166660h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 82166660h case    0:*/		return 0x82166664;
		  /* 82166664h */ case    1:  		/* lwz R11, <#[R11 + 76]> */
		/* 82166664h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82166664h case    1:*/		return 0x82166668;
		  /* 82166668h */ case    2:  		/* rlwinm. R11, R11, 0, 5, 5 */
		/* 82166668h case    2:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R11);
		/* 82166668h case    2:*/		return 0x8216666C;
		  /* 8216666Ch */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8216666Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82166678;  }
		/* 8216666Ch case    3:*/		return 0x82166670;
		  /* 82166670h */ case    4:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166670h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166670h case    4:*/		return 0x82166674;
		  /* 82166674h */ case    5:  		/* bl -1017972 */
		/* 82166674h case    5:*/		regs.LR = 0x82166678; return 0x8206DE00;
		/* 82166674h case    5:*/		return 0x82166678;
	}
	return 0x82166678;
} // Block from 82166660h-82166678h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82166678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166678);
		  /* 82166678h */ case    0:  		/* addi R11, R1, 200 */
		/* 82166678h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC8);
		/* 82166678h case    0:*/		return 0x8216667C;
		  /* 8216667Ch */ case    1:  		/* li R5, 0 */
		/* 8216667Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216667Ch case    1:*/		return 0x82166680;
		  /* 82166680h */ case    2:  		/* addi R4, R1, 200 */
		/* 82166680h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC8);
		/* 82166680h case    2:*/		return 0x82166684;
		  /* 82166684h */ case    3:  		/* mr R3, R31 */
		/* 82166684h case    3:*/		regs.R3 = regs.R31;
		/* 82166684h case    3:*/		return 0x82166688;
		  /* 82166688h */ case    4:  		/* std R23, <#[R11]> */
		/* 82166688h case    4:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166688h case    4:*/		return 0x8216668C;
		  /* 8216668Ch */ case    5:  		/* stw R23, <#[R11 + 8]> */
		/* 8216668Ch case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 8216668Ch case    5:*/		return 0x82166690;
		  /* 82166690h */ case    6:  		/* bl 797800 */
		/* 82166690h case    6:*/		regs.LR = 0x82166694; return 0x822292F8;
		/* 82166690h case    6:*/		return 0x82166694;
		  /* 82166694h */ case    7:  		/* mr R3, R31 */
		/* 82166694h case    7:*/		regs.R3 = regs.R31;
		/* 82166694h case    7:*/		return 0x82166698;
		  /* 82166698h */ case    8:  		/* bl -6440 */
		/* 82166698h case    8:*/		regs.LR = 0x8216669C; return 0x82164D70;
		/* 82166698h case    8:*/		return 0x8216669C;
		  /* 8216669Ch */ case    9:  		/* or. R28, R3, R3 */
		/* 8216669Ch case    9:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 8216669Ch case    9:*/		return 0x821666A0;
		  /* 821666A0h */ case   10:  		/* bc 12, CR0_EQ, 24 */
		/* 821666A0h case   10:*/		if ( regs.CR[0].eq ) { return 0x821666B8;  }
		/* 821666A0h case   10:*/		return 0x821666A4;
		  /* 821666A4h */ case   11:  		/* li R5, 1 */
		/* 821666A4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821666A4h case   11:*/		return 0x821666A8;
		  /* 821666A8h */ case   12:  		/* addi R4, R1, 200 */
		/* 821666A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC8);
		/* 821666A8h case   12:*/		return 0x821666AC;
		  /* 821666ACh */ case   13:  		/* mr R3, R28 */
		/* 821666ACh case   13:*/		regs.R3 = regs.R28;
		/* 821666ACh case   13:*/		return 0x821666B0;
		  /* 821666B0h */ case   14:  		/* bl 797768 */
		/* 821666B0h case   14:*/		regs.LR = 0x821666B4; return 0x822292F8;
		/* 821666B0h case   14:*/		return 0x821666B4;
		  /* 821666B4h */ case   15:  		/* mr R25, R28 */
		/* 821666B4h case   15:*/		regs.R25 = regs.R28;
		/* 821666B4h case   15:*/		return 0x821666B8;
	}
	return 0x821666B8;
} // Block from 82166678h-821666B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821666B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821666B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821666B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821666B8);
		  /* 821666B8h */ case    0:  		/* lwz R11, <#[R1 + 204]> */
		/* 821666B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000CC) );
		/* 821666B8h case    0:*/		return 0x821666BC;
		  /* 821666BCh */ case    1:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 821666BCh case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 821666BCh case    1:*/		return 0x821666C0;
		  /* 821666C0h */ case    2:  		/* bc 12, CR0_EQ, 384 */
		/* 821666C0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82166840;  }
		/* 821666C0h case    2:*/		return 0x821666C4;
		  /* 821666C4h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 821666C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821666C4h case    3:*/		return 0x821666C8;
		  /* 821666C8h */ case    4:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 821666C8h case    4:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 821666C8h case    4:*/		return 0x821666CC;
		  /* 821666CCh */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 821666CCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x821666D8;  }
		/* 821666CCh case    5:*/		return 0x821666D0;
		  /* 821666D0h */ case    6:  		/* mr R11, R23 */
		/* 821666D0h case    6:*/		regs.R11 = regs.R23;
		/* 821666D0h case    6:*/		return 0x821666D4;
		  /* 821666D4h */ case    7:  		/* b 44 */
		/* 821666D4h case    7:*/		return 0x82166700;
		/* 821666D4h case    7:*/		return 0x821666D8;
	}
	return 0x821666D8;
} // Block from 821666B8h-821666D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821666D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821666D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821666D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821666D8);
		  /* 821666D8h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821666D8h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821666D8h case    0:*/		return 0x821666DC;
		  /* 821666DCh */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 821666DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 821666DCh case    1:*/		return 0x821666E0;
		  /* 821666E0h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821666E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821666F8;  }
		/* 821666E0h case    2:*/		return 0x821666E4;
		  /* 821666E4h */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 821666E4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 821666E4h case    3:*/		return 0x821666E8;
		  /* 821666E8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 821666E8h case    4:*/		if ( regs.CR[6].eq ) { return 0x821666F8;  }
		/* 821666E8h case    4:*/		return 0x821666EC;
		  /* 821666ECh */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 821666ECh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 821666ECh case    5:*/		return 0x821666F0;
		  /* 821666F0h */ case    6:  		/* mr R11, R23 */
		/* 821666F0h case    6:*/		regs.R11 = regs.R23;
		/* 821666F0h case    6:*/		return 0x821666F4;
		  /* 821666F4h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 821666F4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821666FC;  }
		/* 821666F4h case    7:*/		return 0x821666F8;
	}
	return 0x821666F8;
} // Block from 821666D8h-821666F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821666F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821666F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821666F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821666F8);
		  /* 821666F8h */ case    0:  		/* mr R11, R22 */
		/* 821666F8h case    0:*/		regs.R11 = regs.R22;
		/* 821666F8h case    0:*/		return 0x821666FC;
	}
	return 0x821666FC;
} // Block from 821666F8h-821666FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821666FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821666FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821666FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821666FC);
		  /* 821666FCh */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821666FCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821666FCh case    0:*/		return 0x82166700;
	}
	return 0x82166700;
} // Block from 821666FCh-82166700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166700);
		  /* 82166700h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82166700h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82166700h case    0:*/		return 0x82166704;
		  /* 82166704h */ case    1:  		/* bc 4, CR0_EQ, 80 */
		/* 82166704h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82166754;  }
		/* 82166704h case    1:*/		return 0x82166708;
		  /* 82166708h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 82166708h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82166708h case    2:*/		return 0x8216670C;
		  /* 8216670Ch */ case    3:  		/* bc 12, CR6_EQ, 308 */
		/* 8216670Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82166840;  }
		/* 8216670Ch case    3:*/		return 0x82166710;
		  /* 82166710h */ case    4:  		/* lwz R11, <#[R25 + 8]> */
		/* 82166710h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82166710h case    4:*/		return 0x82166714;
		  /* 82166714h */ case    5:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 82166714h case    5:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 82166714h case    5:*/		return 0x82166718;
		  /* 82166718h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 82166718h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82166724;  }
		/* 82166718h case    6:*/		return 0x8216671C;
		  /* 8216671Ch */ case    7:  		/* mr R11, R23 */
		/* 8216671Ch case    7:*/		regs.R11 = regs.R23;
		/* 8216671Ch case    7:*/		return 0x82166720;
		  /* 82166720h */ case    8:  		/* b 44 */
		/* 82166720h case    8:*/		return 0x8216674C;
		/* 82166720h case    8:*/		return 0x82166724;
	}
	return 0x82166724;
} // Block from 82166700h-82166724h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82166724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166724);
		  /* 82166724h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82166724h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82166724h case    0:*/		return 0x82166728;
		  /* 82166728h */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 82166728h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 82166728h case    1:*/		return 0x8216672C;
		  /* 8216672Ch */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 8216672Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82166744;  }
		/* 8216672Ch case    2:*/		return 0x82166730;
		  /* 82166730h */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 82166730h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82166730h case    3:*/		return 0x82166734;
		  /* 82166734h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82166734h case    4:*/		if ( regs.CR[6].eq ) { return 0x82166744;  }
		/* 82166734h case    4:*/		return 0x82166738;
		  /* 82166738h */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 82166738h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 82166738h case    5:*/		return 0x8216673C;
		  /* 8216673Ch */ case    6:  		/* mr R11, R23 */
		/* 8216673Ch case    6:*/		regs.R11 = regs.R23;
		/* 8216673Ch case    6:*/		return 0x82166740;
		  /* 82166740h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82166740h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82166748;  }
		/* 82166740h case    7:*/		return 0x82166744;
	}
	return 0x82166744;
} // Block from 82166724h-82166744h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82166744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166744);
		  /* 82166744h */ case    0:  		/* mr R11, R22 */
		/* 82166744h case    0:*/		regs.R11 = regs.R22;
		/* 82166744h case    0:*/		return 0x82166748;
	}
	return 0x82166748;
} // Block from 82166744h-82166748h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166748);
		  /* 82166748h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82166748h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82166748h case    0:*/		return 0x8216674C;
	}
	return 0x8216674C;
} // Block from 82166748h-8216674Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216674Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216674C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216674C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216674C);
		  /* 8216674Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216674Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216674Ch case    0:*/		return 0x82166750;
		  /* 82166750h */ case    1:  		/* bc 12, CR0_EQ, 240 */
		/* 82166750h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166840;  }
		/* 82166750h case    1:*/		return 0x82166754;
	}
	return 0x82166754;
} // Block from 8216674Ch-82166754h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166754);
		  /* 82166754h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166754h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166754h case    0:*/		return 0x82166758;
		  /* 82166758h */ case    1:  		/* bl -1033424 */
		/* 82166758h case    1:*/		regs.LR = 0x8216675C; return 0x8206A288;
		/* 82166758h case    1:*/		return 0x8216675C;
		  /* 8216675Ch */ case    2:  		/* mr R29, R3 */
		/* 8216675Ch case    2:*/		regs.R29 = regs.R3;
		/* 8216675Ch case    2:*/		return 0x82166760;
		  /* 82166760h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82166760h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82166760h case    3:*/		return 0x82166764;
		  /* 82166764h */ case    4:  		/* bc 12, CR6_EQ, 144 */
		/* 82166764h case    4:*/		if ( regs.CR[6].eq ) { return 0x821667F4;  }
		/* 82166764h case    4:*/		return 0x82166768;
		  /* 82166768h */ case    5:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82166768h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82166768h case    5:*/		return 0x8216676C;
		  /* 8216676Ch */ case    6:  		/* bc 4, CR0_EQ, 136 */
		/* 8216676Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821667F4;  }
		/* 8216676Ch case    6:*/		return 0x82166770;
		  /* 82166770h */ case    7:  		/* mr R4, R3 */
		/* 82166770h case    7:*/		regs.R4 = regs.R3;
		/* 82166770h case    7:*/		return 0x82166774;
		  /* 82166774h */ case    8:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166774h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166774h case    8:*/		return 0x82166778;
		  /* 82166778h */ case    9:  		/* bl -1033432 */
		/* 82166778h case    9:*/		regs.LR = 0x8216677C; return 0x8206A2A0;
		/* 82166778h case    9:*/		return 0x8216677C;
		  /* 8216677Ch */ case   10:  		/* lwz R11, <#[R3 + 4]> */
		/* 8216677Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8216677Ch case   10:*/		return 0x82166780;
		  /* 82166780h */ case   11:  		/* mr R30, R3 */
		/* 82166780h case   11:*/		regs.R30 = regs.R3;
		/* 82166780h case   11:*/		return 0x82166784;
		  /* 82166784h */ case   12:  		/* rlwinm R11, R11, 0, 16, 19 */
		/* 82166784h case   12:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R11,regs.R11);
		/* 82166784h case   12:*/		return 0x82166788;
		  /* 82166788h */ case   13:  		/* cmplwi CR6, R11, 4096 */
		/* 82166788h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 82166788h case   13:*/		return 0x8216678C;
		  /* 8216678Ch */ case   14:  		/* bc 4, CR6_EQ, 92 */
		/* 8216678Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x821667E8;  }
		/* 8216678Ch case   14:*/		return 0x82166790;
		  /* 82166790h */ case   15:  		/* lwz R10, <#[R3]> */
		/* 82166790h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82166790h case   15:*/		return 0x82166794;
		  /* 82166794h */ case   16:  		/* rlwinm R11, R10, 20, 29, 31 */
		/* 82166794h case   16:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R11,regs.R10);
		/* 82166794h case   16:*/		return 0x82166798;
		  /* 82166798h */ case   17:  		/* cmplwi CR6, R11, 6 */
		/* 82166798h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 82166798h case   17:*/		return 0x8216679C;
		  /* 8216679Ch */ case   18:  		/* bc 12, CR6_EQ, 76 */
		/* 8216679Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x821667E8;  }
		/* 8216679Ch case   18:*/		return 0x821667A0;
		  /* 821667A0h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 821667A0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821667A0h case   19:*/		return 0x821667A4;
		  /* 821667A4h */ case   20:  		/* bc 12, CR6_EQ, 68 */
		/* 821667A4h case   20:*/		if ( regs.CR[6].eq ) { return 0x821667E8;  }
		/* 821667A4h case   20:*/		return 0x821667A8;
		  /* 821667A8h */ case   21:  		/* rlwinm R10, R10, 0, 20, 31 */
		/* 821667A8h case   21:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R10);
		/* 821667A8h case   21:*/		return 0x821667AC;
		  /* 821667ACh */ case   22:  		/* lwz R3, <#[R15 + 768]> */
		/* 821667ACh case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821667ACh case   22:*/		return 0x821667B0;
		  /* 821667B0h */ case   23:  		/* addi R5, R1, 180 */
		/* 821667B0h case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xB4);
		/* 821667B0h case   23:*/		return 0x821667B4;
		  /* 821667B4h */ case   24:  		/* add R11, R10, R11 */
		/* 821667B4h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821667B4h case   24:*/		return 0x821667B8;
		  /* 821667B8h */ case   25:  		/* addi R4, R11, -1 */
		/* 821667B8h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 821667B8h case   25:*/		return 0x821667BC;
		  /* 821667BCh */ case   26:  		/* bl -1033452 */
		/* 821667BCh case   26:*/		regs.LR = 0x821667C0; return 0x8206A2D0;
		/* 821667BCh case   26:*/		return 0x821667C0;
		  /* 821667C0h */ case   27:  		/* lwz R11, <#[R1 + 180]> */
		/* 821667C0h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B4) );
		/* 821667C0h case   27:*/		return 0x821667C4;
		  /* 821667C4h */ case   28:  		/* cmpwi CR6, R11, 0 */
		/* 821667C4h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821667C4h case   28:*/		return 0x821667C8;
		  /* 821667C8h */ case   29:  		/* bc 12, CR6_EQ, 36 */
		/* 821667C8h case   29:*/		if ( regs.CR[6].eq ) { return 0x821667EC;  }
		/* 821667C8h case   29:*/		return 0x821667CC;
		  /* 821667CCh */ case   30:  		/* lwz R11, <#[R30]> */
		/* 821667CCh case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821667CCh case   30:*/		return 0x821667D0;
		  /* 821667D0h */ case   31:  		/* rlwinm R11, R11, 0, 17, 19 */
		/* 821667D0h case   31:*/		cpu::op::rlwinm<0,0,17,19>(regs,&regs.R11,regs.R11);
		/* 821667D0h case   31:*/		return 0x821667D4;
		  /* 821667D4h */ case   32:  		/* cmplwi CR6, R11, 20480 */
		/* 821667D4h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00005000);
		/* 821667D4h case   32:*/		return 0x821667D8;
		  /* 821667D8h */ case   33:  		/* bc 4, CR6_EQ, 28 */
		/* 821667D8h case   33:*/		if ( !regs.CR[6].eq ) { return 0x821667F4;  }
		/* 821667D8h case   33:*/		return 0x821667DC;
		  /* 821667DCh */ case   34:  		/* lwz R3, <#[R15 + 768]> */
		/* 821667DCh case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821667DCh case   34:*/		return 0x821667E0;
		  /* 821667E0h */ case   35:  		/* bl -1018336 */
		/* 821667E0h case   35:*/		regs.LR = 0x821667E4; return 0x8206DE00;
		/* 821667E0h case   35:*/		return 0x821667E4;
		  /* 821667E4h */ case   36:  		/* b 16 */
		/* 821667E4h case   36:*/		return 0x821667F4;
		/* 821667E4h case   36:*/		return 0x821667E8;
	}
	return 0x821667E8;
} // Block from 82166754h-821667E8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821667E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821667E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821667E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821667E8);
		  /* 821667E8h */ case    0:  		/* mr R29, R19 */
		/* 821667E8h case    0:*/		regs.R29 = regs.R19;
		/* 821667E8h case    0:*/		return 0x821667EC;
	}
	return 0x821667EC;
} // Block from 821667E8h-821667ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821667ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821667EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821667EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821667EC);
		  /* 821667ECh */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 821667ECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 821667ECh case    0:*/		return 0x821667F0;
		  /* 821667F0h */ case    1:  		/* bc 4, CR6_EQ, 80 */
		/* 821667F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82166840;  }
		/* 821667F0h case    1:*/		return 0x821667F4;
	}
	return 0x821667F4;
} // Block from 821667ECh-821667F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821667F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821667F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821667F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821667F4);
		  /* 821667F4h */ case    0:  		/* addi R11, R1, 168 */
		/* 821667F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA8);
		/* 821667F4h case    0:*/		return 0x821667F8;
		  /* 821667F8h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 821667F8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821667F8h case    1:*/		return 0x821667FC;
		  /* 821667FCh */ case    2:  		/* addi R4, R1, 168 */
		/* 821667FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA8);
		/* 821667FCh case    2:*/		return 0x82166800;
		  /* 82166800h */ case    3:  		/* std R23, <#[R11]> */
		/* 82166800h case    3:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166800h case    3:*/		return 0x82166804;
		  /* 82166804h */ case    4:  		/* stw R23, <#[R11 + 8]> */
		/* 82166804h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 82166804h case    4:*/		return 0x82166808;
		  /* 82166808h */ case    5:  		/* lwz R11, <#[R1 + 176]> */
		/* 82166808h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82166808h case    5:*/		return 0x8216680C;
		  /* 8216680Ch */ case    6:  		/* lwz R10, <#[R1 + 168]> */
		/* 8216680Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A8) );
		/* 8216680Ch case    6:*/		return 0x82166810;
		  /* 82166810h */ case    7:  		/* rlwinm R10, R10, 0, 6, 31 */
		/* 82166810h case    7:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R10,regs.R10);
		/* 82166810h case    7:*/		return 0x82166814;
		  /* 82166814h */ case    8:  		/* rlwimi R11, R22, 25, 3, 7 */
		/* 82166814h case    8:*/		cpu::op::rlwimi<0,25,3,7>(regs,&regs.R11,regs.R22);
		/* 82166814h case    8:*/		return 0x82166818;
	}
	return 0x82166818;
} // Block from 821667F4h-82166818h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82166818h
// Function '?ValidatorOutputCallback@Compiler@D3DXShader@@CAJPAXPBDK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166818);
		  /* 82166818h */ case    0:  		/* oris R10, R10, 51200 */
		/* 82166818h case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC800);
		/* 82166818h case    0:*/		return 0x8216681C;
		  /* 8216681Ch */ case    1:  		/* stw R11, <#[R1 + 176]> */
		/* 8216681Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 8216681Ch case    1:*/		return 0x82166820;
	}
	return 0x82166820;
} // Block from 82166818h-82166820h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166820h
// Function '?IsConstant@Dependency@D3DXShader@@QAA_NN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166820);
		  /* 82166820h */ case    0:  		/* stw R10, <#[R1 + 168]> */
		/* 82166820h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000A8) );
		/* 82166820h case    0:*/		return 0x82166824;
		  /* 82166824h */ case    1:  		/* bl -1018820 */
		/* 82166824h case    1:*/		regs.LR = 0x82166828; return 0x8206DC60;
		/* 82166824h case    1:*/		return 0x82166828;
		  /* 82166828h */ case    2:  		/* mr R5, R3 */
		/* 82166828h case    2:*/		regs.R5 = regs.R3;
		/* 82166828h case    2:*/		return 0x8216682C;
		  /* 8216682Ch */ case    3:  		/* mr R7, R31 */
		/* 8216682Ch case    3:*/		regs.R7 = regs.R31;
		/* 8216682Ch case    3:*/		return 0x82166830;
		  /* 82166830h */ case    4:  		/* mr R6, R16 */
		/* 82166830h case    4:*/		regs.R6 = regs.R16;
		/* 82166830h case    4:*/		return 0x82166834;
		  /* 82166834h */ case    5:  		/* li R4, 1 */
		/* 82166834h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82166834h case    5:*/		return 0x82166838;
		  /* 82166838h */ case    6:  		/* mr R3, R15 */
		/* 82166838h case    6:*/		regs.R3 = regs.R15;
		/* 82166838h case    6:*/		return 0x8216683C;
		  /* 8216683Ch */ case    7:  		/* bl -3668 */
		/* 8216683Ch case    7:*/		regs.LR = 0x82166840; return 0x821659E8;
		/* 8216683Ch case    7:*/		return 0x82166840;
	}
	return 0x82166840;
} // Block from 82166820h-82166840h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82166840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166840);
		  /* 82166840h */ case    0:  		/* addi R4, R1, 200 */
		/* 82166840h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC8);
		/* 82166840h case    0:*/		return 0x82166844;
		  /* 82166844h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166844h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166844h case    1:*/		return 0x82166848;
		  /* 82166848h */ case    2:  		/* bl -1018856 */
		/* 82166848h case    2:*/		regs.LR = 0x8216684C; return 0x8206DC60;
		/* 82166848h case    2:*/		return 0x8216684C;
		  /* 8216684Ch */ case    3:  		/* mr R30, R3 */
		/* 8216684Ch case    3:*/		regs.R30 = regs.R3;
		/* 8216684Ch case    3:*/		return 0x82166850;
		  /* 82166850h */ case    4:  		/* mr R5, R3 */
		/* 82166850h case    4:*/		regs.R5 = regs.R3;
		/* 82166850h case    4:*/		return 0x82166854;
		  /* 82166854h */ case    5:  		/* mr R7, R31 */
		/* 82166854h case    5:*/		regs.R7 = regs.R31;
		/* 82166854h case    5:*/		return 0x82166858;
		  /* 82166858h */ case    6:  		/* mr R6, R16 */
		/* 82166858h case    6:*/		regs.R6 = regs.R16;
		/* 82166858h case    6:*/		return 0x8216685C;
		  /* 8216685Ch */ case    7:  		/* li R4, 1 */
		/* 8216685Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8216685Ch case    7:*/		return 0x82166860;
		  /* 82166860h */ case    8:  		/* mr R3, R15 */
		/* 82166860h case    8:*/		regs.R3 = regs.R15;
		/* 82166860h case    8:*/		return 0x82166864;
		  /* 82166864h */ case    9:  		/* bl -3708 */
		/* 82166864h case    9:*/		regs.LR = 0x82166868; return 0x821659E8;
		/* 82166864h case    9:*/		return 0x82166868;
		  /* 82166868h */ case   10:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166868h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166868h case   10:*/		return 0x8216686C;
		  /* 8216686Ch */ case   11:  		/* stw R22, <#[R1 + 96]> */
		/* 8216686Ch case   11:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 8216686Ch case   11:*/		return 0x82166870;
		  /* 82166870h */ case   12:  		/* bl -1033608 */
		/* 82166870h case   12:*/		regs.LR = 0x82166874; return 0x8206A2E8;
		/* 82166870h case   12:*/		return 0x82166874;
		  /* 82166874h */ case   13:  		/* lwz R11, <#[R31 + 16]> */
		/* 82166874h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82166874h case   13:*/		return 0x82166878;
		  /* 82166878h */ case   14:  		/* addi R29, R3, -1 */
		/* 82166878h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0xFFFFFFFF);
		/* 82166878h case   14:*/		return 0x8216687C;
		  /* 8216687Ch */ case   15:  		/* rlwinm R11, R11, 0, 8, 6 */
		/* 8216687Ch case   15:*/		cpu::op::rlwinm<0,0,8,6>(regs,&regs.R11,regs.R11);
		/* 8216687Ch case   15:*/		return 0x82166880;
		  /* 82166880h */ case   16:  		/* stw R11, <#[R31 + 16]> */
		/* 82166880h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82166880h case   16:*/		return 0x82166884;
		  /* 82166884h */ case   17:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166884h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166884h case   17:*/		return 0x82166888;
		  /* 82166888h */ case   18:  		/* bl -1033728 */
		/* 82166888h case   18:*/		regs.LR = 0x8216688C; return 0x8206A288;
		/* 82166888h case   18:*/		return 0x8216688C;
		  /* 8216688Ch */ case   19:  		/* lwz R11, <#[R31 + 20]> */
		/* 8216688Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8216688Ch case   19:*/		return 0x82166890;
		  /* 82166890h */ case   20:  		/* rlwinm R9, R11, 0, 0, 16 */
		/* 82166890h case   20:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R9,regs.R11);
		/* 82166890h case   20:*/		return 0x82166894;
		  /* 82166894h */ case   21:  		/* rlwinm R10, R3, 0, 20, 31 */
		/* 82166894h case   21:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R3);
		/* 82166894h case   21:*/		return 0x82166898;
		  /* 82166898h */ case   22:  		/* rlwinm R11, R29, 12, 17, 19 */
		/* 82166898h case   22:*/		cpu::op::rlwinm<0,12,17,19>(regs,&regs.R11,regs.R29);
		/* 82166898h case   22:*/		return 0x8216689C;
		  /* 8216689Ch */ case   23:  		/* or R10, R10, R9 */
		/* 8216689Ch case   23:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216689Ch case   23:*/		return 0x821668A0;
		  /* 821668A0h */ case   24:  		/* cmplwi CR6, R28, 0 */
		/* 821668A0h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821668A0h case   24:*/		return 0x821668A4;
		  /* 821668A4h */ case   25:  		/* or R10, R10, R11 */
		/* 821668A4h case   25:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821668A4h case   25:*/		return 0x821668A8;
		  /* 821668A8h */ case   26:  		/* rlwinm R10, R10, 0, 17, 15 */
		/* 821668A8h case   26:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R10,regs.R10);
		/* 821668A8h case   26:*/		return 0x821668AC;
		  /* 821668ACh */ case   27:  		/* stw R10, <#[R31 + 20]> */
		/* 821668ACh case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821668ACh case   27:*/		return 0x821668B0;
		  /* 821668B0h */ case   28:  		/* bc 12, CR6_EQ, 56 */
		/* 821668B0h case   28:*/		if ( regs.CR[6].eq ) { return 0x821668E8;  }
		/* 821668B0h case   28:*/		return 0x821668B4;
		  /* 821668B4h */ case   29:  		/* ori R10, R10, 32768 */
		/* 821668B4h case   29:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 821668B4h case   29:*/		return 0x821668B8;
		  /* 821668B8h */ case   30:  		/* stw R10, <#[R31 + 20]> */
		/* 821668B8h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821668B8h case   30:*/		return 0x821668BC;
		  /* 821668BCh */ case   31:  		/* lwz R10, <#[R28 + 20]> */
		/* 821668BCh case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000014) );
		/* 821668BCh case   31:*/		return 0x821668C0;
		  /* 821668C0h */ case   32:  		/* lwz R9, <#[R28 + 16]> */
		/* 821668C0h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000010) );
		/* 821668C0h case   32:*/		return 0x821668C4;
		  /* 821668C4h */ case   33:  		/* rlwinm R9, R9, 0, 8, 6 */
		/* 821668C4h case   33:*/		cpu::op::rlwinm<0,0,8,6>(regs,&regs.R9,regs.R9);
		/* 821668C4h case   33:*/		return 0x821668C8;
		  /* 821668C8h */ case   34:  		/* stw R9, <#[R28 + 16]> */
		/* 821668C8h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000010) );
		/* 821668C8h case   34:*/		return 0x821668CC;
		  /* 821668CCh */ case   35:  		/* rlwinm R10, R10, 0, 0, 16 */
		/* 821668CCh case   35:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R10,regs.R10);
		/* 821668CCh case   35:*/		return 0x821668D0;
		  /* 821668D0h */ case   36:  		/* lwz R9, <#[R31 + 20]> */
		/* 821668D0h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 821668D0h case   36:*/		return 0x821668D4;
		  /* 821668D4h */ case   37:  		/* rlwinm R9, R9, 0, 20, 31 */
		/* 821668D4h case   37:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R9);
		/* 821668D4h case   37:*/		return 0x821668D8;
		  /* 821668D8h */ case   38:  		/* or R10, R9, R10 */
		/* 821668D8h case   38:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821668D8h case   38:*/		return 0x821668DC;
		  /* 821668DCh */ case   39:  		/* or R11, R10, R11 */
		/* 821668DCh case   39:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821668DCh case   39:*/		return 0x821668E0;
		  /* 821668E0h */ case   40:  		/* rlwinm R11, R11, 0, 17, 15 */
		/* 821668E0h case   40:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R11,regs.R11);
		/* 821668E0h case   40:*/		return 0x821668E4;
		  /* 821668E4h */ case   41:  		/* stw R11, <#[R28 + 20]> */
		/* 821668E4h case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000014) );
		/* 821668E4h case   41:*/		return 0x821668E8;
	}
	return 0x821668E8;
} // Block from 82166840h-821668E8h (42 instructions)

//////////////////////////////////////////////////////
// Block at 821668E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821668E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821668E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821668E8);
		  /* 821668E8h */ case    0:  		/* lwz R11, <#[R26 + 76]> */
		/* 821668E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000004C) );
		/* 821668E8h case    0:*/		return 0x821668EC;
		  /* 821668ECh */ case    1:  		/* mr R27, R23 */
		/* 821668ECh case    1:*/		regs.R27 = regs.R23;
		/* 821668ECh case    1:*/		return 0x821668F0;
		  /* 821668F0h */ case    2:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 821668F0h case    2:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 821668F0h case    2:*/		return 0x821668F4;
		  /* 821668F4h */ case    3:  		/* bc 12, CR0_EQ, 1892 */
		/* 821668F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82167058;  }
		/* 821668F4h case    3:*/		return 0x821668F8;
		  /* 821668F8h */ case    4:  		/* mr R3, R31 */
		/* 821668F8h case    4:*/		regs.R3 = regs.R31;
		/* 821668F8h case    4:*/		return 0x821668FC;
		  /* 821668FCh */ case    5:  		/* bl -10172 */
		/* 821668FCh case    5:*/		regs.LR = 0x82166900; return 0x82164140;
		/* 821668FCh case    5:*/		return 0x82166900;
		  /* 82166900h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82166900h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82166900h case    6:*/		return 0x82166904;
		  /* 82166904h */ case    7:  		/* bc 12, CR0_EQ, 1876 */
		/* 82166904h case    7:*/		if ( regs.CR[0].eq ) { return 0x82167058;  }
		/* 82166904h case    7:*/		return 0x82166908;
		  /* 82166908h */ case    8:  		/* lwz R11, <#[R26 + 112]> */
		/* 82166908h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 82166908h case    8:*/		return 0x8216690C;
		  /* 8216690Ch */ case    9:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216690Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216690Ch case    9:*/		return 0x82166910;
	}
	return 0x82166910;
} // Block from 821668E8h-82166910h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82166910h
// Function '?GuessFirstALUOrFetchInstruction@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166910);
		  /* 82166910h */ case    0:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82166910h case    0:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82166910h case    0:*/		return 0x82166914;
		  /* 82166914h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 82166914h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166944;  }
		/* 82166914h case    1:*/		return 0x82166918;
		  /* 82166918h */ case    2:  		/* b 16 */
		/* 82166918h case    2:*/		return 0x82166928;
		/* 82166918h case    2:*/		return 0x8216691C;
		  /* 8216691Ch */ case    3:  		/* lwz R10, <#[R11 + 48]> */
		/* 8216691Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8216691Ch case    3:*/		return 0x82166920;
		  /* 82166920h */ case    4:  		/* rlwinm. R10, R10, 0, 9, 9 */
		/* 82166920h case    4:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R10,regs.R10);
		/* 82166920h case    4:*/		return 0x82166924;
		  /* 82166924h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82166924h case    5:*/		if ( regs.CR[0].eq ) { return 0x82166934;  }
		/* 82166924h case    5:*/		return 0x82166928;
	}
	return 0x82166928;
} // Block from 82166910h-82166928h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82166928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166928);
		  /* 82166928h */ case    0:  		/* lwz R11, <#[R11 + 80]> */
		/* 82166928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82166928h case    0:*/		return 0x8216692C;
		  /* 8216692Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8216692Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216692Ch case    1:*/		return 0x82166930;
		  /* 82166930h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82166930h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8216691C;  }
		/* 82166930h case    2:*/		return 0x82166934;
	}
	return 0x82166934;
} // Block from 82166928h-82166934h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166934);
		  /* 82166934h */ case    0:  		/* lwz R10, <#[R11 + 48]> */
		/* 82166934h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82166934h case    0:*/		return 0x82166938;
		  /* 82166938h */ case    1:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82166938h case    1:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82166938h case    1:*/		return 0x8216693C;
		  /* 8216693Ch */ case    2:  		/* bc 4, CR0_EQ, -20 */
		/* 8216693Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82166928;  }
		/* 8216693Ch case    2:*/		return 0x82166940;
		  /* 82166940h */ case    3:  		/* stw R11, <#[R26 + 112]> */
		/* 82166940h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 82166940h case    3:*/		return 0x82166944;
	}
	return 0x82166944;
} // Block from 82166934h-82166944h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82166944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166944);
		  /* 82166944h */ case    0:  		/* lwz R11, <#[R26 + 112]> */
		/* 82166944h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000070) );
		/* 82166944h case    0:*/		return 0x82166948;
		  /* 82166948h */ case    1:  		/* lwz R11, <#[R11 + 76]> */
		/* 82166948h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 82166948h case    1:*/		return 0x8216694C;
		  /* 8216694Ch */ case    2:  		/* rlwinm. R11, R11, 0, 5, 5 */
		/* 8216694Ch case    2:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R11);
		/* 8216694Ch case    2:*/		return 0x82166950;
		  /* 82166950h */ case    3:  		/* bc 12, CR0_EQ, 1800 */
		/* 82166950h case    3:*/		if ( regs.CR[0].eq ) { return 0x82167058;  }
		/* 82166950h case    3:*/		return 0x82166954;
		  /* 82166954h */ case    4:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 82166954h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 82166954h case    4:*/		return 0x82166958;
		  /* 82166958h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82166958h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82166958h case    5:*/		return 0x8216695C;
		  /* 8216695Ch */ case    6:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8216695Ch case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216695Ch case    6:*/		return 0x82166960;
		  /* 82166960h */ case    7:  		/* addic R10, R10, -1 */
		/* 82166960h case    7:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82166960h case    7:*/		return 0x82166964;
		  /* 82166964h */ case    8:  		/* subfe R10, R10, R10 */
		/* 82166964h case    8:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82166964h case    8:*/		return 0x82166968;
		  /* 82166968h */ case    9:  		/* and R11, R10, R11 */
		/* 82166968h case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82166968h case    9:*/		return 0x8216696C;
		  /* 8216696Ch */ case   10:  		/* lwz R11, <#[R11 + 76]> */
		/* 8216696Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8216696Ch case   10:*/		return 0x82166970;
		  /* 82166970h */ case   11:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82166970h case   11:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82166970h case   11:*/		return 0x82166974;
		  /* 82166974h */ case   12:  		/* bc 12, CR0_EQ, 1764 */
		/* 82166974h case   12:*/		if ( regs.CR[0].eq ) { return 0x82167058;  }
		/* 82166974h case   12:*/		return 0x82166978;
		  /* 82166978h */ case   13:  		/* b 1712 */
		/* 82166978h case   13:*/		return 0x82167028;
		/* 82166978h case   13:*/		return 0x8216697C;
	}
	return 0x8216697C;
} // Block from 82166944h-8216697Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216697Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216697C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216697C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216697C);
		  /* 8216697Ch */ case    0:  		/* cmplwi CR6, R10, 83 */
		/* 8216697Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 8216697Ch case    0:*/		return 0x82166980;
		  /* 82166980h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82166980h case    1:*/		if ( regs.CR[6].lt ) { return 0x82166990;  }
		/* 82166980h case    1:*/		return 0x82166984;
		  /* 82166984h */ case    2:  		/* cmplwi CR6, R10, 95 */
		/* 82166984h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005F);
		/* 82166984h case    2:*/		return 0x82166988;
		  /* 82166988h */ case    3:  		/* mr R9, R22 */
		/* 82166988h case    3:*/		regs.R9 = regs.R22;
		/* 82166988h case    3:*/		return 0x8216698C;
		  /* 8216698Ch */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 8216698Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82166994;  }
		/* 8216698Ch case    4:*/		return 0x82166990;
	}
	return 0x82166990;
} // Block from 8216697Ch-82166990h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82166990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166990);
		  /* 82166990h */ case    0:  		/* mr R9, R23 */
		/* 82166990h case    0:*/		regs.R9 = regs.R23;
		/* 82166990h case    0:*/		return 0x82166994;
	}
	return 0x82166994;
} // Block from 82166990h-82166994h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166994);
		  /* 82166994h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82166994h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82166994h case    0:*/		return 0x82166998;
		  /* 82166998h */ case    1:  		/* bc 12, CR0_EQ, 604 */
		/* 82166998h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166BF4;  }
		/* 82166998h case    1:*/		return 0x8216699C;
		  /* 8216699Ch */ case    2:  		/* cmplwi CR6, R10, 83 */
		/* 8216699Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 8216699Ch case    2:*/		return 0x821669A0;
		  /* 821669A0h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 821669A0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821669AC;  }
		/* 821669A0h case    3:*/		return 0x821669A4;
		  /* 821669A4h */ case    4:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 821669A4h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 821669A4h case    4:*/		return 0x821669A8;
		  /* 821669A8h */ case    5:  		/* bc 12, CR0_EQ, 1988 */
		/* 821669A8h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216716C;  }
		/* 821669A8h case    5:*/		return 0x821669AC;
	}
	return 0x821669AC;
} // Block from 82166994h-821669ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821669ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821669AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821669AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821669AC);
		  /* 821669ACh */ case    0:  		/* cmplwi CR6, R10, 84 */
		/* 821669ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000054);
		/* 821669ACh case    0:*/		return 0x821669B0;
		  /* 821669B0h */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 821669B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82166A08;  }
		/* 821669B0h case    1:*/		return 0x821669B4;
		  /* 821669B4h */ case    2:  		/* li R6, 0 */
		/* 821669B4h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821669B4h case    2:*/		return 0x821669B8;
		  /* 821669B8h */ case    3:  		/* li R5, 0 */
		/* 821669B8h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821669B8h case    3:*/		return 0x821669BC;
		  /* 821669BCh */ case    4:  		/* li R4, 84 */
		/* 821669BCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x54);
		/* 821669BCh case    4:*/		return 0x821669C0;
		  /* 821669C0h */ case    5:  		/* mr R3, R15 */
		/* 821669C0h case    5:*/		regs.R3 = regs.R15;
		/* 821669C0h case    5:*/		return 0x821669C4;
		  /* 821669C4h */ case    6:  		/* bl -9620 */
		/* 821669C4h case    6:*/		regs.LR = 0x821669C8; return 0x82164430;
		/* 821669C4h case    6:*/		return 0x821669C8;
		  /* 821669C8h */ case    7:  		/* addi R11, R31, -32 */
		/* 821669C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFE0);
		/* 821669C8h case    7:*/		return 0x821669CC;
		  /* 821669CCh */ case    8:  		/* add R11, R3, R11 */
		/* 821669CCh case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821669CCh case    8:*/		return 0x821669D0;
		  /* 821669D0h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 821669D0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821669D0h case    9:*/		return 0x821669D4;
		  /* 821669D4h */ case   10:  		/* cmpwi CR6, R10, 0 */
		/* 821669D4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821669D4h case   10:*/		return 0x821669D8;
		  /* 821669D8h */ case   11:  		/* bc 12, CR6_EQ, 48 */
		/* 821669D8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82166A08;  }
		/* 821669D8h case   11:*/		return 0x821669DC;
		  /* 821669DCh */ case   12:  		/* stw R10, <#[R1 + 240]> */
		/* 821669DCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000F0) );
		/* 821669DCh case   12:*/		return 0x821669E0;
		  /* 821669E0h */ case   13:  		/* addi R5, R1, 240 */
		/* 821669E0h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xF0);
		/* 821669E0h case   13:*/		return 0x821669E4;
		  /* 821669E4h */ case   14:  		/* lwz R10, <#[R11 + 4]> */
		/* 821669E4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821669E4h case   14:*/		return 0x821669E8;
		  /* 821669E8h */ case   15:  		/* stw R10, <#[R1 + 244]> */
		/* 821669E8h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000F4) );
		/* 821669E8h case   15:*/		return 0x821669EC;
		  /* 821669ECh */ case   16:  		/* lwz R10, <#[R11 + 8]> */
		/* 821669ECh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821669ECh case   16:*/		return 0x821669F0;
		  /* 821669F0h */ case   17:  		/* stw R10, <#[R1 + 248]> */
		/* 821669F0h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000F8) );
		/* 821669F0h case   17:*/		return 0x821669F4;
		  /* 821669F4h */ case   18:  		/* stw R23, <#[R1 + 252]> */
		/* 821669F4h case   18:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x000000FC) );
		/* 821669F4h case   18:*/		return 0x821669F8;
		  /* 821669F8h */ case   19:  		/* lwz R3, <#[R15 + 768]> */
		/* 821669F8h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821669F8h case   19:*/		return 0x821669FC;
		  /* 821669FCh */ case   20:  		/* lwz R11, <#[R11 + 12]> */
		/* 821669FCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821669FCh case   20:*/		return 0x82166A00;
		  /* 82166A00h */ case   21:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 82166A00h case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 82166A00h case   21:*/		return 0x82166A04;
		  /* 82166A04h */ case   22:  		/* bl -1027484 */
		/* 82166A04h case   22:*/		regs.LR = 0x82166A08; return 0x8206BC68;
		/* 82166A04h case   22:*/		return 0x82166A08;
	}
	return 0x82166A08;
} // Block from 821669ACh-82166A08h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82166A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166A08);
		  /* 82166A08h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82166A08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82166A08h case    0:*/		return 0x82166A0C;
		  /* 82166A0Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82166A0Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82166A0Ch case    1:*/		return 0x82166A10;
		  /* 82166A10h */ case    2:  		/* cmplwi CR6, R11, 10624 */
		/* 82166A10h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002980);
		/* 82166A10h case    2:*/		return 0x82166A14;
		  /* 82166A14h */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 82166A14h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82166A54;  }
		/* 82166A14h case    3:*/		return 0x82166A18;
		  /* 82166A18h */ case    4:  		/* lwz R11, <#[R15 + 48]> */
		/* 82166A18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 82166A18h case    4:*/		return 0x82166A1C;
		  /* 82166A1Ch */ case    5:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166A1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166A1Ch case    5:*/		return 0x82166A20;
		  /* 82166A20h */ case    6:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82166A20h case    6:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82166A20h case    6:*/		return 0x82166A24;
		  /* 82166A24h */ case    7:  		/* cmplw CR6, R11, R17 */
		/* 82166A24h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 82166A24h case    7:*/		return 0x82166A28;
		  /* 82166A28h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82166A28h case    8:*/		if ( regs.CR[6].eq ) { return 0x82166A48;  }
		/* 82166A28h case    8:*/		return 0x82166A2C;
		  /* 82166A2Ch */ case    9:  		/* addi R11, R1, 160 */
		/* 82166A2Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 82166A2Ch case    9:*/		return 0x82166A30;
		  /* 82166A30h */ case   10:  		/* addi R4, R1, 160 */
		/* 82166A30h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 82166A30h case   10:*/		return 0x82166A34;
		  /* 82166A34h */ case   11:  		/* std R23, <#[R11]> */
		/* 82166A34h case   11:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166A34h case   11:*/		return 0x82166A38;
		  /* 82166A38h */ case   12:  		/* lwz R11, <#[R1 + 164]> */
		/* 82166A38h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A4) );
		/* 82166A38h case   12:*/		return 0x82166A3C;
		  /* 82166A3Ch */ case   13:  		/* rlwimi R11, R22, 13, 16, 19 */
		/* 82166A3Ch case   13:*/		cpu::op::rlwimi<0,13,16,19>(regs,&regs.R11,regs.R22);
		/* 82166A3Ch case   13:*/		return 0x82166A40;
		  /* 82166A40h */ case   14:  		/* stw R11, <#[R1 + 164]> */
		/* 82166A40h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000A4) );
		/* 82166A40h case   14:*/		return 0x82166A44;
		  /* 82166A44h */ case   15:  		/* b 104 */
		/* 82166A44h case   15:*/		return 0x82166AAC;
		/* 82166A44h case   15:*/		return 0x82166A48;
	}
	return 0x82166A48;
} // Block from 82166A08h-82166A48h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82166A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166A48);
		  /* 82166A48h */ case    0:  		/* bl -1018952 */
		/* 82166A48h case    0:*/		regs.LR = 0x82166A4C; return 0x8206DE00;
		/* 82166A48h case    0:*/		return 0x82166A4C;
		  /* 82166A4Ch */ case    1:  		/* mr R30, R3 */
		/* 82166A4Ch case    1:*/		regs.R30 = regs.R3;
		/* 82166A4Ch case    1:*/		return 0x82166A50;
		  /* 82166A50h */ case    2:  		/* b 124 */
		/* 82166A50h case    2:*/		return 0x82166ACC;
		/* 82166A50h case    2:*/		return 0x82166A54;
	}
	return 0x82166A54;
} // Block from 82166A48h-82166A54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82166A54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166A54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166A54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166A54);
		  /* 82166A54h */ case    0:  		/* addi R11, R1, 216 */
		/* 82166A54h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD8);
		/* 82166A54h case    0:*/		return 0x82166A58;
		  /* 82166A58h */ case    1:  		/* mr R5, R15 */
		/* 82166A58h case    1:*/		regs.R5 = regs.R15;
		/* 82166A58h case    1:*/		return 0x82166A5C;
		  /* 82166A5Ch */ case    2:  		/* addi R4, R1, 216 */
		/* 82166A5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xD8);
		/* 82166A5Ch case    2:*/		return 0x82166A60;
		  /* 82166A60h */ case    3:  		/* mr R3, R31 */
		/* 82166A60h case    3:*/		regs.R3 = regs.R31;
		/* 82166A60h case    3:*/		return 0x82166A64;
		  /* 82166A64h */ case    4:  		/* std R23, <#[R11]> */
		/* 82166A64h case    4:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166A64h case    4:*/		return 0x82166A68;
		  /* 82166A68h */ case    5:  		/* bl 776808 */
		/* 82166A68h case    5:*/		regs.LR = 0x82166A6C; return 0x822244D0;
		/* 82166A68h case    5:*/		return 0x82166A6C;
		  /* 82166A6Ch */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82166A6Ch case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82166A6Ch case    6:*/		return 0x82166A70;
		  /* 82166A70h */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 82166A70h case    7:*/		if ( regs.CR[0].eq ) { return 0x82166AA4;  }
		/* 82166A70h case    7:*/		return 0x82166A74;
		  /* 82166A74h */ case    8:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166A74h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166A74h case    8:*/		return 0x82166A78;
		  /* 82166A78h */ case    9:  		/* bl -1019000 */
		/* 82166A78h case    9:*/		regs.LR = 0x82166A7C; return 0x8206DE00;
		/* 82166A78h case    9:*/		return 0x82166A7C;
		  /* 82166A7Ch */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 82166A7Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82166A7Ch case   10:*/		return 0x82166A80;
		  /* 82166A80h */ case   11:  		/* mr R30, R3 */
		/* 82166A80h case   11:*/		regs.R30 = regs.R3;
		/* 82166A80h case   11:*/		return 0x82166A84;
		  /* 82166A84h */ case   12:  		/* mr R3, R15 */
		/* 82166A84h case   12:*/		regs.R3 = regs.R15;
		/* 82166A84h case   12:*/		return 0x82166A88;
		  /* 82166A88h */ case   13:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82166A88h case   13:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82166A88h case   13:*/		return 0x82166A8C;
		  /* 82166A8Ch */ case   14:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82166A8Ch case   14:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82166A8Ch case   14:*/		return 0x82166A90;
		  /* 82166A90h */ case   15:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82166A90h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82166A90h case   15:*/		return 0x82166A94;
		  /* 82166A94h */ case   16:  		/* bl -9828 */
		/* 82166A94h case   16:*/		regs.LR = 0x82166A98; return 0x82164430;
		/* 82166A94h case   16:*/		return 0x82166A98;
		  /* 82166A98h */ case   17:  		/* addi R11, R31, -12 */
		/* 82166A98h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF4);
		/* 82166A98h case   17:*/		return 0x82166A9C;
		  /* 82166A9Ch */ case   18:  		/* mr R20, R22 */
		/* 82166A9Ch case   18:*/		regs.R20 = regs.R22;
		/* 82166A9Ch case   18:*/		return 0x82166AA0;
		  /* 82166AA0h */ case   19:  		/* stwx R30, <#[R3 + R11]> */
		/* 82166AA0h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82166AA0h case   19:*/		return 0x82166AA4;
	}
	return 0x82166AA4;
} // Block from 82166A54h-82166AA4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82166AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166AA4);
		  /* 82166AA4h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166AA4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166AA4h case    0:*/		return 0x82166AA8;
		  /* 82166AA8h */ case    1:  		/* addi R4, R1, 216 */
		/* 82166AA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xD8);
		/* 82166AA8h case    1:*/		return 0x82166AAC;
	}
	return 0x82166AAC;
} // Block from 82166AA4h-82166AACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166AAC);
		  /* 82166AACh */ case    0:  		/* bl -1019076 */
		/* 82166AACh case    0:*/		regs.LR = 0x82166AB0; return 0x8206DDE8;
		/* 82166AACh case    0:*/		return 0x82166AB0;
		  /* 82166AB0h */ case    1:  		/* mr R30, R3 */
		/* 82166AB0h case    1:*/		regs.R30 = regs.R3;
		/* 82166AB0h case    1:*/		return 0x82166AB4;
		  /* 82166AB4h */ case    2:  		/* mr R5, R3 */
		/* 82166AB4h case    2:*/		regs.R5 = regs.R3;
		/* 82166AB4h case    2:*/		return 0x82166AB8;
		  /* 82166AB8h */ case    3:  		/* mr R7, R31 */
		/* 82166AB8h case    3:*/		regs.R7 = regs.R31;
		/* 82166AB8h case    3:*/		return 0x82166ABC;
		  /* 82166ABCh */ case    4:  		/* mr R6, R16 */
		/* 82166ABCh case    4:*/		regs.R6 = regs.R16;
		/* 82166ABCh case    4:*/		return 0x82166AC0;
		  /* 82166AC0h */ case    5:  		/* li R4, 0 */
		/* 82166AC0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82166AC0h case    5:*/		return 0x82166AC4;
		  /* 82166AC4h */ case    6:  		/* mr R3, R15 */
		/* 82166AC4h case    6:*/		regs.R3 = regs.R15;
		/* 82166AC4h case    6:*/		return 0x82166AC8;
		  /* 82166AC8h */ case    7:  		/* bl -4320 */
		/* 82166AC8h case    7:*/		regs.LR = 0x82166ACC; return 0x821659E8;
		/* 82166AC8h case    7:*/		return 0x82166ACC;
	}
	return 0x82166ACC;
} // Block from 82166AACh-82166ACCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82166ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166ACC);
		  /* 82166ACCh */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82166ACCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82166ACCh case    0:*/		return 0x82166AD0;
		  /* 82166AD0h */ case    1:  		/* rlwinm R10, R30, 0, 20, 31 */
		/* 82166AD0h case    1:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R30);
		/* 82166AD0h case    1:*/		return 0x82166AD4;
		  /* 82166AD4h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 82166AD4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82166AD4h case    2:*/		return 0x82166AD8;
		  /* 82166AD8h */ case    3:  		/* mr R27, R22 */
		/* 82166AD8h case    3:*/		regs.R27 = regs.R22;
		/* 82166AD8h case    3:*/		return 0x82166ADC;
		  /* 82166ADCh */ case    4:  		/* rlwinm R11, R11, 0, 8, 6 */
		/* 82166ADCh case    4:*/		cpu::op::rlwinm<0,0,8,6>(regs,&regs.R11,regs.R11);
		/* 82166ADCh case    4:*/		return 0x82166AE0;
		  /* 82166AE0h */ case    5:  		/* stw R23, <#[R1 + 96]> */
		/* 82166AE0h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000060) );
		/* 82166AE0h case    5:*/		return 0x82166AE4;
		  /* 82166AE4h */ case    6:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82166AE4h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82166AE4h case    6:*/		return 0x82166AE8;
		  /* 82166AE8h */ case    7:  		/* sth R10, <#[R31 + 22]> */
		/* 82166AE8h case    7:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000016) );
		/* 82166AE8h case    7:*/		return 0x82166AEC;
		  /* 82166AECh */ case    8:  		/* stw R11, <#[R31 + 16]> */
		/* 82166AECh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82166AECh case    8:*/		return 0x82166AF0;
		  /* 82166AF0h */ case    9:  		/* cmplwi CR6, R9, 10624 */
		/* 82166AF0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00002980);
		/* 82166AF0h case    9:*/		return 0x82166AF4;
		  /* 82166AF4h */ case   10:  		/* bc 4, CR6_EQ, 1380 */
		/* 82166AF4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82167058;  }
		/* 82166AF4h case   10:*/		return 0x82166AF8;
		  /* 82166AF8h */ case   11:  		/* lwz R11, <#[R15 + 48]> */
		/* 82166AF8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 82166AF8h case   11:*/		return 0x82166AFC;
		  /* 82166AFCh */ case   12:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82166AFCh case   12:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82166AFCh case   12:*/		return 0x82166B00;
		  /* 82166B00h */ case   13:  		/* cmplw CR6, R11, R17 */
		/* 82166B00h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 82166B00h case   13:*/		return 0x82166B04;
		  /* 82166B04h */ case   14:  		/* bc 4, CR6_EQ, 1364 */
		/* 82166B04h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82167058;  }
		/* 82166B04h case   14:*/		return 0x82166B08;
		  /* 82166B08h */ case   15:  		/* lbz R11, <#[R26 + 48]> */
		/* 82166B08h case   15:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 82166B08h case   15:*/		return 0x82166B0C;
		  /* 82166B0Ch */ case   16:  		/* mr R9, R22 */
		/* 82166B0Ch case   16:*/		regs.R9 = regs.R22;
		/* 82166B0Ch case   16:*/		return 0x82166B10;
		  /* 82166B10h */ case   17:  		/* mr R10, R26 */
		/* 82166B10h case   17:*/		regs.R10 = regs.R26;
		/* 82166B10h case   17:*/		return 0x82166B14;
		  /* 82166B14h */ case   18:  		/* b 108 */
		/* 82166B14h case   18:*/		return 0x82166B80;
		/* 82166B14h case   18:*/		return 0x82166B18;
		  /* 82166B18h */ case   19:  		/* lwz R11, <#[R10 + 28]> */
		/* 82166B18h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 82166B18h case   19:*/		return 0x82166B1C;
		  /* 82166B1Ch */ case   20:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 82166B1Ch case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 82166B1Ch case   20:*/		return 0x82166B20;
		  /* 82166B20h */ case   21:  		/* bc 4, CR0_EQ, 1796 */
		/* 82166B20h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82167224;  }
		/* 82166B20h case   21:*/		return 0x82166B24;
		  /* 82166B24h */ case   22:  		/* cmplwi CR0, R11, 0 */
		/* 82166B24h case   22:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82166B24h case   22:*/		return 0x82166B28;
		  /* 82166B28h */ case   23:  		/* bc 12, CR0_EQ, 1788 */
		/* 82166B28h case   23:*/		if ( regs.CR[0].eq ) { return 0x82167224;  }
		/* 82166B28h case   23:*/		return 0x82166B2C;
		  /* 82166B2Ch */ case   24:  		/* lwz R8, <#[R11 + 8]> */
		/* 82166B2Ch case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82166B2Ch case   24:*/		return 0x82166B30;
		  /* 82166B30h */ case   25:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 82166B30h case   25:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 82166B30h case   25:*/		return 0x82166B34;
		  /* 82166B34h */ case   26:  		/* cmplwi CR6, R8, 16128 */
		/* 82166B34h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003F00);
		/* 82166B34h case   26:*/		return 0x82166B38;
		  /* 82166B38h */ case   27:  		/* bc 4, CR6_EQ, 1772 */
		/* 82166B38h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82167224;  }
		/* 82166B38h case   27:*/		return 0x82166B3C;
		  /* 82166B3Ch */ case   28:  		/* lwz R11, <#[R11 + 20]> */
		/* 82166B3Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82166B3Ch case   28:*/		return 0x82166B40;
		  /* 82166B40h */ case   29:  		/* rlwinm R8, R11, 0, 20, 31 */
		/* 82166B40h case   29:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R8,regs.R11);
		/* 82166B40h case   29:*/		return 0x82166B44;
		  /* 82166B44h */ case   30:  		/* cmplw CR6, R8, R30 */
		/* 82166B44h case   30:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R30);
		/* 82166B44h case   30:*/		return 0x82166B48;
		  /* 82166B48h */ case   31:  		/* bc 12, CR6_LT, 68 */
		/* 82166B48h case   31:*/		if ( regs.CR[6].lt ) { return 0x82166B8C;  }
		/* 82166B48h case   31:*/		return 0x82166B4C;
		  /* 82166B4Ch */ case   32:  		/* rlwinm. R11, R11, 16, 31, 31 */
		/* 82166B4Ch case   32:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R11,regs.R11);
		/* 82166B4Ch case   32:*/		return 0x82166B50;
		  /* 82166B50h */ case   33:  		/* bc 4, CR0_EQ, 64 */
		/* 82166B50h case   33:*/		if ( !regs.CR[0].eq ) { return 0x82166B90;  }
		/* 82166B50h case   33:*/		return 0x82166B54;
		  /* 82166B54h */ case   34:  		/* lwz R11, <#[R10 + 76]> */
		/* 82166B54h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000004C) );
		/* 82166B54h case   34:*/		return 0x82166B58;
		  /* 82166B58h */ case   35:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 82166B58h case   35:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 82166B58h case   35:*/		return 0x82166B5C;
		  /* 82166B5Ch */ case   36:  		/* bc 4, CR0_EQ, 52 */
		/* 82166B5Ch case   36:*/		if ( !regs.CR[0].eq ) { return 0x82166B90;  }
		/* 82166B5Ch case   36:*/		return 0x82166B60;
		  /* 82166B60h */ case   37:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 82166B60h case   37:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 82166B60h case   37:*/		return 0x82166B64;
		  /* 82166B64h */ case   38:  		/* lwz R11, <#[R11]> */
		/* 82166B64h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82166B64h case   38:*/		return 0x82166B68;
		  /* 82166B68h */ case   39:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82166B68h case   39:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166B68h case   39:*/		return 0x82166B6C;
		  /* 82166B6Ch */ case   40:  		/* bc 4, CR0_EQ, 36 */
		/* 82166B6Ch case   40:*/		if ( !regs.CR[0].eq ) { return 0x82166B90;  }
		/* 82166B6Ch case   40:*/		return 0x82166B70;
		  /* 82166B70h */ case   41:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82166B70h case   41:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82166B70h case   41:*/		return 0x82166B74;
		  /* 82166B74h */ case   42:  		/* addic. R10, R11, -4 */
		/* 82166B74h case   42:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R11,0xFFFFFFFC);
		/* 82166B74h case   42:*/		return 0x82166B78;
		  /* 82166B78h */ case   43:  		/* bc 12, CR0_EQ, 24 */
		/* 82166B78h case   43:*/		if ( regs.CR[0].eq ) { return 0x82166B90;  }
		/* 82166B78h case   43:*/		return 0x82166B7C;
		  /* 82166B7Ch */ case   44:  		/* lbz R11, <#[R10 + 48]> */
		/* 82166B7Ch case   44:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 82166B7Ch case   44:*/		return 0x82166B80;
	}
	return 0x82166B80;
} // Block from 82166ACCh-82166B80h (45 instructions)

//////////////////////////////////////////////////////
// Block at 82166B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166B80);
		  /* 82166B80h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82166B80h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82166B80h case    0:*/		return 0x82166B84;
		  /* 82166B84h */ case    1:  		/* bc 12, CR0_EQ, -108 */
		/* 82166B84h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166B18;  }
		/* 82166B84h case    1:*/		return 0x82166B88;
	}
	return 0x82166B88;
} // Block from 82166B80h-82166B88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166B88h
// Function '?EmitShader@Compiler@D3DXShader@@AAAPAVBlock@2@PAV32@HPAUEmitState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166B88);
		  /* 82166B88h */ case    0:  		/* b 8 */
		/* 82166B88h case    0:*/		return 0x82166B90;
		/* 82166B88h case    0:*/		return 0x82166B8C;
	}
	return 0x82166B8C;
} // Block from 82166B88h-82166B8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166B8C);
		  /* 82166B8Ch */ case    0:  		/* mr R9, R23 */
		/* 82166B8Ch case    0:*/		regs.R9 = regs.R23;
		/* 82166B8Ch case    0:*/		return 0x82166B90;
	}
	return 0x82166B90;
} // Block from 82166B8Ch-82166B90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166B90);
		  /* 82166B90h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 82166B90h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 82166B90h case    0:*/		return 0x82166B94;
		  /* 82166B94h */ case    1:  		/* bc 12, CR0_EQ, 1220 */
		/* 82166B94h case    1:*/		if ( regs.CR[0].eq ) { return 0x82167058;  }
		/* 82166B94h case    1:*/		return 0x82166B98;
		  /* 82166B98h */ case    2:  		/* addi R11, R1, 184 */
		/* 82166B98h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xB8);
		/* 82166B98h case    2:*/		return 0x82166B9C;
		  /* 82166B9Ch */ case    3:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166B9Ch case    3:*/		return 0x82166BA0;
		  /* 82166BA0h */ case    4:  		/* addi R4, R1, 184 */
		/* 82166BA0h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xB8);
		/* 82166BA0h case    4:*/		return 0x82166BA4;
		  /* 82166BA4h */ case    5:  		/* std R23, <#[R11]> */
		/* 82166BA4h case    5:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166BA4h case    5:*/		return 0x82166BA8;
		  /* 82166BA8h */ case    6:  		/* stw R23, <#[R11 + 8]> */
		/* 82166BA8h case    6:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 82166BA8h case    6:*/		return 0x82166BAC;
		  /* 82166BACh */ case    7:  		/* lwz R11, <#[R1 + 192]> */
		/* 82166BACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 82166BACh case    7:*/		return 0x82166BB0;
		  /* 82166BB0h */ case    8:  		/* rlwimi R11, R22, 25, 3, 7 */
		/* 82166BB0h case    8:*/		cpu::op::rlwimi<0,25,3,7>(regs,&regs.R11,regs.R22);
		/* 82166BB0h case    8:*/		return 0x82166BB4;
		  /* 82166BB4h */ case    9:  		/* lwz R10, <#[R1 + 184]> */
		/* 82166BB4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 82166BB4h case    9:*/		return 0x82166BB8;
		  /* 82166BB8h */ case   10:  		/* stw R11, <#[R1 + 192]> */
		/* 82166BB8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 82166BB8h case   10:*/		return 0x82166BBC;
		  /* 82166BBCh */ case   11:  		/* rlwinm R10, R10, 0, 6, 31 */
		/* 82166BBCh case   11:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R10,regs.R10);
		/* 82166BBCh case   11:*/		return 0x82166BC0;
		  /* 82166BC0h */ case   12:  		/* oris R10, R10, 51200 */
		/* 82166BC0h case   12:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC800);
		/* 82166BC0h case   12:*/		return 0x82166BC4;
		  /* 82166BC4h */ case   13:  		/* stw R10, <#[R1 + 184]> */
		/* 82166BC4h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000B8) );
		/* 82166BC4h case   13:*/		return 0x82166BC8;
		  /* 82166BC8h */ case   14:  		/* bl -1019752 */
		/* 82166BC8h case   14:*/		regs.LR = 0x82166BCC; return 0x8206DC60;
		/* 82166BC8h case   14:*/		return 0x82166BCC;
		  /* 82166BCCh */ case   15:  		/* mr R30, R3 */
		/* 82166BCCh case   15:*/		regs.R30 = regs.R3;
		/* 82166BCCh case   15:*/		return 0x82166BD0;
		  /* 82166BD0h */ case   16:  		/* mr R5, R3 */
		/* 82166BD0h case   16:*/		regs.R5 = regs.R3;
		/* 82166BD0h case   16:*/		return 0x82166BD4;
		  /* 82166BD4h */ case   17:  		/* mr R7, R31 */
		/* 82166BD4h case   17:*/		regs.R7 = regs.R31;
		/* 82166BD4h case   17:*/		return 0x82166BD8;
		  /* 82166BD8h */ case   18:  		/* mr R6, R16 */
		/* 82166BD8h case   18:*/		regs.R6 = regs.R16;
		/* 82166BD8h case   18:*/		return 0x82166BDC;
		  /* 82166BDCh */ case   19:  		/* li R4, 1 */
		/* 82166BDCh case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82166BDCh case   19:*/		return 0x82166BE0;
		  /* 82166BE0h */ case   20:  		/* mr R3, R15 */
		/* 82166BE0h case   20:*/		regs.R3 = regs.R15;
		/* 82166BE0h case   20:*/		return 0x82166BE4;
		  /* 82166BE4h */ case   21:  		/* bl -4604 */
		/* 82166BE4h case   21:*/		regs.LR = 0x82166BE8; return 0x821659E8;
		/* 82166BE4h case   21:*/		return 0x82166BE8;
		  /* 82166BE8h */ case   22:  		/* stw R22, <#[R1 + 96]> */
		/* 82166BE8h case   22:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 82166BE8h case   22:*/		return 0x82166BEC;
		  /* 82166BECh */ case   23:  		/* mr R27, R23 */
		/* 82166BECh case   23:*/		regs.R27 = regs.R23;
		/* 82166BECh case   23:*/		return 0x82166BF0;
		  /* 82166BF0h */ case   24:  		/* b 1128 */
		/* 82166BF0h case   24:*/		return 0x82167058;
		/* 82166BF0h case   24:*/		return 0x82166BF4;
	}
	return 0x82166BF4;
} // Block from 82166B90h-82166BF4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82166BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166BF4);
		  /* 82166BF4h */ case    0:  		/* cmplwi CR6, R10, 96 */
		/* 82166BF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 82166BF4h case    0:*/		return 0x82166BF8;
		  /* 82166BF8h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82166BF8h case    1:*/		if ( regs.CR[6].lt ) { return 0x82166C08;  }
		/* 82166BF8h case    1:*/		return 0x82166BFC;
		  /* 82166BFCh */ case    2:  		/* cmplwi CR6, R10, 102 */
		/* 82166BFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 82166BFCh case    2:*/		return 0x82166C00;
		  /* 82166C00h */ case    3:  		/* mr R9, R22 */
		/* 82166C00h case    3:*/		regs.R9 = regs.R22;
		/* 82166C00h case    3:*/		return 0x82166C04;
		  /* 82166C04h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82166C04h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82166C0C;  }
		/* 82166C04h case    4:*/		return 0x82166C08;
	}
	return 0x82166C08;
} // Block from 82166BF4h-82166C08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82166C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166C08);
		  /* 82166C08h */ case    0:  		/* mr R9, R23 */
		/* 82166C08h case    0:*/		regs.R9 = regs.R23;
		/* 82166C08h case    0:*/		return 0x82166C0C;
	}
	return 0x82166C0C;
} // Block from 82166C08h-82166C0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166C0C);
		  /* 82166C0Ch */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82166C0Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82166C0Ch case    0:*/		return 0x82166C10;
		  /* 82166C10h */ case    1:  		/* bc 12, CR0_EQ, 516 */
		/* 82166C10h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166E14;  }
		/* 82166C10h case    1:*/		return 0x82166C14;
		  /* 82166C14h */ case    2:  		/* cmplwi CR6, R10, 96 */
		/* 82166C14h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 82166C14h case    2:*/		return 0x82166C18;
		  /* 82166C18h */ case    3:  		/* mr R5, R15 */
		/* 82166C18h case    3:*/		regs.R5 = regs.R15;
		/* 82166C18h case    3:*/		return 0x82166C1C;
		  /* 82166C1Ch */ case    4:  		/* mr R3, R31 */
		/* 82166C1Ch case    4:*/		regs.R3 = regs.R31;
		/* 82166C1Ch case    4:*/		return 0x82166C20;
		  /* 82166C20h */ case    5:  		/* bc 4, CR6_EQ, 368 */
		/* 82166C20h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82166D90;  }
		/* 82166C20h case    5:*/		return 0x82166C24;
		  /* 82166C24h */ case    6:  		/* addi R11, R1, 224 */
		/* 82166C24h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xE0);
		/* 82166C24h case    6:*/		return 0x82166C28;
		  /* 82166C28h */ case    7:  		/* addi R4, R1, 224 */
		/* 82166C28h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xE0);
		/* 82166C28h case    7:*/		return 0x82166C2C;
		  /* 82166C2Ch */ case    8:  		/* std R23, <#[R11]> */
		/* 82166C2Ch case    8:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166C2Ch case    8:*/		return 0x82166C30;
		  /* 82166C30h */ case    9:  		/* stw R23, <#[R11 + 8]> */
		/* 82166C30h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 82166C30h case    9:*/		return 0x82166C34;
		  /* 82166C34h */ case   10:  		/* bl 770372 */
		/* 82166C34h case   10:*/		regs.LR = 0x82166C38; return 0x82222D78;
		/* 82166C34h case   10:*/		return 0x82166C38;
		  /* 82166C38h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 82166C38h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82166C38h case   11:*/		return 0x82166C3C;
		  /* 82166C3Ch */ case   12:  		/* mr R3, R15 */
		/* 82166C3Ch case   12:*/		regs.R3 = regs.R15;
		/* 82166C3Ch case   12:*/		return 0x82166C40;
		  /* 82166C40h */ case   13:  		/* rlwinm R29, R11, 13, 29, 31 */
		/* 82166C40h case   13:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R29,regs.R11);
		/* 82166C40h case   13:*/		return 0x82166C44;
		  /* 82166C44h */ case   14:  		/* rlwinm R30, R11, 25, 25, 31 */
		/* 82166C44h case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R30,regs.R11);
		/* 82166C44h case   14:*/		return 0x82166C48;
		  /* 82166C48h */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82166C48h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82166C48h case   15:*/		return 0x82166C4C;
		  /* 82166C4Ch */ case   16:  		/* mr R5, R29 */
		/* 82166C4Ch case   16:*/		regs.R5 = regs.R29;
		/* 82166C4Ch case   16:*/		return 0x82166C50;
		  /* 82166C50h */ case   17:  		/* mr R4, R30 */
		/* 82166C50h case   17:*/		regs.R4 = regs.R30;
		/* 82166C50h case   17:*/		return 0x82166C54;
		  /* 82166C54h */ case   18:  		/* bl -10276 */
		/* 82166C54h case   18:*/		regs.LR = 0x82166C58; return 0x82164430;
		/* 82166C54h case   18:*/		return 0x82166C58;
		  /* 82166C58h */ case   19:  		/* addi R11, R31, -20 */
		/* 82166C58h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFEC);
		/* 82166C58h case   19:*/		return 0x82166C5C;
		  /* 82166C5Ch */ case   20:  		/* add R28, R3, R11 */
		/* 82166C5Ch case   20:*/		cpu::op::add<0>(regs,&regs.R28,regs.R3,regs.R11);
		/* 82166C5Ch case   20:*/		return 0x82166C60;
		  /* 82166C60h */ case   21:  		/* lbz R11, <#[R28 + 15]> */
		/* 82166C60h case   21:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000F) );
		/* 82166C60h case   21:*/		return 0x82166C64;
		  /* 82166C64h */ case   22:  		/* cmplwi CR6, R11, 255 */
		/* 82166C64h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 82166C64h case   22:*/		return 0x82166C68;
		  /* 82166C68h */ case   23:  		/* bc 12, CR6_EQ, 32 */
		/* 82166C68h case   23:*/		if ( regs.CR[6].eq ) { return 0x82166C88;  }
		/* 82166C68h case   23:*/		return 0x82166C6C;
		  /* 82166C6Ch */ case   24:  		/* lwz R11, <#[R28 + 12]> */
		/* 82166C6Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 82166C6Ch case   24:*/		return 0x82166C70;
		  /* 82166C70h */ case   25:  		/* addi R4, R1, 224 */
		/* 82166C70h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xE0);
		/* 82166C70h case   25:*/		return 0x82166C74;
		  /* 82166C74h */ case   26:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166C74h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166C74h case   26:*/		return 0x82166C78;
		  /* 82166C78h */ case   27:  		/* rlwinm R6, R11, 16, 31, 31 */
		/* 82166C78h case   27:*/		cpu::op::rlwinm<0,16,31,31>(regs,&regs.R6,regs.R11);
		/* 82166C78h case   27:*/		return 0x82166C7C;
		  /* 82166C7Ch */ case   28:  		/* rlwinm R5, R11, 0, 24, 31 */
		/* 82166C7Ch case   28:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R5,regs.R11);
		/* 82166C7Ch case   28:*/		return 0x82166C80;
		  /* 82166C80h */ case   29:  		/* bl -1019960 */
		/* 82166C80h case   29:*/		regs.LR = 0x82166C84; return 0x8206DC48;
		/* 82166C80h case   29:*/		return 0x82166C84;
		  /* 82166C84h */ case   30:  		/* b 300 */
		/* 82166C84h case   30:*/		return 0x82166DB0;
		/* 82166C84h case   30:*/		return 0x82166C88;
	}
	return 0x82166C88;
} // Block from 82166C0Ch-82166C88h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82166C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166C88);
		  /* 82166C88h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82166C88h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82166C88h case    0:*/		return 0x82166C8C;
		  /* 82166C8Ch */ case    1:  		/* bc 4, CR0_EQ, 236 */
		/* 82166C8Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82166D78;  }
		/* 82166C8Ch case    1:*/		return 0x82166C90;
		  /* 82166C90h */ case    2:  		/* cmplwi CR6, R30, 96 */
		/* 82166C90h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000060);
		/* 82166C90h case    2:*/		return 0x82166C94;
		  /* 82166C94h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82166C94h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82166CA4;  }
		/* 82166C94h case    3:*/		return 0x82166C98;
		  /* 82166C98h */ case    4:  		/* cmplwi CR6, R29, 1 */
		/* 82166C98h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 82166C98h case    4:*/		return 0x82166C9C;
		  /* 82166C9Ch */ case    5:  		/* mr R11, R22 */
		/* 82166C9Ch case    5:*/		regs.R11 = regs.R22;
		/* 82166C9Ch case    5:*/		return 0x82166CA0;
		  /* 82166CA0h */ case    6:  		/* bc 12, CR6_GT, 8 */
		/* 82166CA0h case    6:*/		if ( regs.CR[6].gt ) { return 0x82166CA8;  }
		/* 82166CA0h case    6:*/		return 0x82166CA4;
	}
	return 0x82166CA4;
} // Block from 82166C88h-82166CA4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82166CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166CA4);
		  /* 82166CA4h */ case    0:  		/* mr R11, R23 */
		/* 82166CA4h case    0:*/		regs.R11 = regs.R23;
		/* 82166CA4h case    0:*/		return 0x82166CA8;
	}
	return 0x82166CA8;
} // Block from 82166CA4h-82166CA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166CA8);
		  /* 82166CA8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82166CA8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82166CA8h case    0:*/		return 0x82166CAC;
		  /* 82166CACh */ case    1:  		/* bc 12, CR0_EQ, 204 */
		/* 82166CACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82166D78;  }
		/* 82166CACh case    1:*/		return 0x82166CB0;
		  /* 82166CB0h */ case    2:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166CB0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166CB0h case    2:*/		return 0x82166CB4;
		  /* 82166CB4h */ case    3:  		/* bl -1034796 */
		/* 82166CB4h case    3:*/		regs.LR = 0x82166CB8; return 0x8206A288;
		/* 82166CB4h case    3:*/		return 0x82166CB8;
		  /* 82166CB8h */ case    4:  		/* mr R29, R3 */
		/* 82166CB8h case    4:*/		regs.R29 = regs.R3;
		/* 82166CB8h case    4:*/		return 0x82166CBC;
		  /* 82166CBCh */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 82166CBCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82166CBCh case    5:*/		return 0x82166CC0;
		  /* 82166CC0h */ case    6:  		/* bc 12, CR6_EQ, 176 */
		/* 82166CC0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82166D70;  }
		/* 82166CC0h case    6:*/		return 0x82166CC4;
		  /* 82166CC4h */ case    7:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82166CC4h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82166CC4h case    7:*/		return 0x82166CC8;
		  /* 82166CC8h */ case    8:  		/* mr R30, R22 */
		/* 82166CC8h case    8:*/		regs.R30 = regs.R22;
		/* 82166CC8h case    8:*/		return 0x82166CCC;
		  /* 82166CCCh */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 82166CCCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82166CCCh case    9:*/		return 0x82166CD0;
		  /* 82166CD0h */ case   10:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82166CD0h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166CD0h case   10:*/		return 0x82166CD4;
		  /* 82166CD4h */ case   11:  		/* bc 4, CR0_EQ, 96 */
		/* 82166CD4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82166D34;  }
		/* 82166CD4h case   11:*/		return 0x82166CD8;
		  /* 82166CD8h */ case   12:  		/* mr R10, R11 */
		/* 82166CD8h case   12:*/		regs.R10 = regs.R11;
		/* 82166CD8h case   12:*/		return 0x82166CDC;
		  /* 82166CDCh */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82166CDCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166CDCh case   13:*/		return 0x82166CE0;
		  /* 82166CE0h */ case   14:  		/* bc 12, CR6_EQ, 84 */
		/* 82166CE0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82166D34;  }
		/* 82166CE0h case   14:*/		return 0x82166CE4;
		  /* 82166CE4h */ case   15:  		/* lwz R11, <#[R10 + 8]> */
		/* 82166CE4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82166CE4h case   15:*/		return 0x82166CE8;
		  /* 82166CE8h */ case   16:  		/* rlwinm R9, R11, 0, 18, 24 */
		/* 82166CE8h case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R11);
		/* 82166CE8h case   16:*/		return 0x82166CEC;
		  /* 82166CECh */ case   17:  		/* cmplwi CR6, R9, 12288 */
		/* 82166CECh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003000);
		/* 82166CECh case   17:*/		return 0x82166CF0;
		  /* 82166CF0h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 82166CF0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82166D00;  }
		/* 82166CF0h case   18:*/		return 0x82166CF4;
		  /* 82166CF4h */ case   19:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 82166CF4h case   19:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 82166CF4h case   19:*/		return 0x82166CF8;
		  /* 82166CF8h */ case   20:  		/* mr R11, R22 */
		/* 82166CF8h case   20:*/		regs.R11 = regs.R22;
		/* 82166CF8h case   20:*/		return 0x82166CFC;
		  /* 82166CFCh */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 82166CFCh case   21:*/		if ( regs.CR[0].eq ) { return 0x82166D04;  }
		/* 82166CFCh case   21:*/		return 0x82166D00;
	}
	return 0x82166D00;
} // Block from 82166CA8h-82166D00h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82166D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D00);
		  /* 82166D00h */ case    0:  		/* mr R11, R23 */
		/* 82166D00h case    0:*/		regs.R11 = regs.R23;
		/* 82166D00h case    0:*/		return 0x82166D04;
	}
	return 0x82166D04;
} // Block from 82166D00h-82166D04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D04);
		  /* 82166D04h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82166D04h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82166D04h case    0:*/		return 0x82166D08;
		  /* 82166D08h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 82166D08h case    1:*/		if ( regs.CR[0].eq ) { return 0x82166D2C;  }
		/* 82166D08h case    1:*/		return 0x82166D0C;
		  /* 82166D0Ch */ case    2:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 82166D0Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 82166D0Ch case    2:*/		return 0x82166D10;
		  /* 82166D10h */ case    3:  		/* addi R30, R30, 1 */
		/* 82166D10h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82166D10h case    3:*/		return 0x82166D14;
		  /* 82166D14h */ case    4:  		/* lwz R11, <#[R11 + 40]> */
		/* 82166D14h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82166D14h case    4:*/		return 0x82166D18;
		  /* 82166D18h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82166D18h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82166D18h case    5:*/		return 0x82166D1C;
		  /* 82166D1Ch */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 82166D1Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x82166D2C;  }
		/* 82166D1Ch case    6:*/		return 0x82166D20;
		  /* 82166D20h */ case    7:  		/* mr R10, R11 */
		/* 82166D20h case    7:*/		regs.R10 = regs.R11;
		/* 82166D20h case    7:*/		return 0x82166D24;
		  /* 82166D24h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82166D24h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82166D24h case    8:*/		return 0x82166D28;
		  /* 82166D28h */ case    9:  		/* bc 4, CR6_EQ, -68 */
		/* 82166D28h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82166CE4;  }
		/* 82166D28h case    9:*/		return 0x82166D2C;
	}
	return 0x82166D2C;
} // Block from 82166D04h-82166D2Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82166D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D2C);
		  /* 82166D2Ch */ case    0:  		/* cmplwi CR6, R30, 6 */
		/* 82166D2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000006);
		/* 82166D2Ch case    0:*/		return 0x82166D30;
		  /* 82166D30h */ case    1:  		/* bc 12, CR6_GT, 1280 */
		/* 82166D30h case    1:*/		if ( regs.CR[6].gt ) { return 0x82167230;  }
		/* 82166D30h case    1:*/		return 0x82166D34;
	}
	return 0x82166D34;
} // Block from 82166D2Ch-82166D34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D34);
		  /* 82166D34h */ case    0:  		/* mr R4, R29 */
		/* 82166D34h case    0:*/		regs.R4 = regs.R29;
		/* 82166D34h case    0:*/		return 0x82166D38;
		  /* 82166D38h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166D38h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166D38h case    1:*/		return 0x82166D3C;
		  /* 82166D3Ch */ case    2:  		/* bl -1034908 */
		/* 82166D3Ch case    2:*/		regs.LR = 0x82166D40; return 0x8206A2A0;
		/* 82166D3Ch case    2:*/		return 0x82166D40;
		  /* 82166D40h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82166D40h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82166D40h case    3:*/		return 0x82166D44;
		  /* 82166D44h */ case    4:  		/* rlwinm R11, R11, 0, 16, 19 */
		/* 82166D44h case    4:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R11,regs.R11);
		/* 82166D44h case    4:*/		return 0x82166D48;
		  /* 82166D48h */ case    5:  		/* cmplwi CR6, R11, 4096 */
		/* 82166D48h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 82166D48h case    5:*/		return 0x82166D4C;
		  /* 82166D4Ch */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 82166D4Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82166D64;  }
		/* 82166D4Ch case    6:*/		return 0x82166D50;
		  /* 82166D50h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 82166D50h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82166D50h case    7:*/		return 0x82166D54;
		  /* 82166D54h */ case    8:  		/* rlwinm R11, R11, 20, 29, 31 */
		/* 82166D54h case    8:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R11,regs.R11);
		/* 82166D54h case    8:*/		return 0x82166D58;
		  /* 82166D58h */ case    9:  		/* subfic R11, R11, 6 */
		/* 82166D58h case    9:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x6);
		/* 82166D58h case    9:*/		return 0x82166D5C;
		  /* 82166D5Ch */ case   10:  		/* cmplw CR6, R30, R11 */
		/* 82166D5Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82166D5Ch case   10:*/		return 0x82166D60;
		  /* 82166D60h */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 82166D60h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82166D68;  }
		/* 82166D60h case   11:*/		return 0x82166D64;
	}
	return 0x82166D64;
} // Block from 82166D34h-82166D64h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82166D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D64);
		  /* 82166D64h */ case    0:  		/* mr R29, R19 */
		/* 82166D64h case    0:*/		regs.R29 = regs.R19;
		/* 82166D64h case    0:*/		return 0x82166D68;
	}
	return 0x82166D68;
} // Block from 82166D64h-82166D68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82166D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D68);
		  /* 82166D68h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 82166D68h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82166D68h case    0:*/		return 0x82166D6C;
		  /* 82166D6Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82166D6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82166D78;  }
		/* 82166D6Ch case    1:*/		return 0x82166D70;
	}
	return 0x82166D70;
} // Block from 82166D68h-82166D70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D70);
		  /* 82166D70h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166D70h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166D70h case    0:*/		return 0x82166D74;
		  /* 82166D74h */ case    1:  		/* bl -1028236 */
		/* 82166D74h case    1:*/		regs.LR = 0x82166D78; return 0x8206BCE8;
		/* 82166D74h case    1:*/		return 0x82166D78;
	}
	return 0x82166D78;
} // Block from 82166D70h-82166D78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82166D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D78);
		  /* 82166D78h */ case    0:  		/* lhz R11, <#[R28 + 12]> */
		/* 82166D78h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 82166D78h case    0:*/		return 0x82166D7C;
		  /* 82166D7Ch */ case    1:  		/* addi R4, R1, 224 */
		/* 82166D7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xE0);
		/* 82166D7Ch case    1:*/		return 0x82166D80;
		  /* 82166D80h */ case    2:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166D80h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166D80h case    2:*/		return 0x82166D84;
		  /* 82166D84h */ case    3:  		/* rlwinm R5, R11, 0, 31, 31 */
		/* 82166D84h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R5,regs.R11);
		/* 82166D84h case    3:*/		return 0x82166D88;
		  /* 82166D88h */ case    4:  		/* bl -1020248 */
		/* 82166D88h case    4:*/		regs.LR = 0x82166D8C; return 0x8206DC30;
		/* 82166D88h case    4:*/		return 0x82166D8C;
		  /* 82166D8Ch */ case    5:  		/* b 36 */
		/* 82166D8Ch case    5:*/		return 0x82166DB0;
		/* 82166D8Ch case    5:*/		return 0x82166D90;
	}
	return 0x82166D90;
} // Block from 82166D78h-82166D90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82166D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166D90);
		  /* 82166D90h */ case    0:  		/* addi R11, R1, 256 */
		/* 82166D90h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x100);
		/* 82166D90h case    0:*/		return 0x82166D94;
		  /* 82166D94h */ case    1:  		/* addi R4, R1, 256 */
		/* 82166D94h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x100);
		/* 82166D94h case    1:*/		return 0x82166D98;
		  /* 82166D98h */ case    2:  		/* std R23, <#[R11]> */
		/* 82166D98h case    2:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R11 + 0x00000000) );
		/* 82166D98h case    2:*/		return 0x82166D9C;
		  /* 82166D9Ch */ case    3:  		/* stw R23, <#[R11 + 8]> */
		/* 82166D9Ch case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000008) );
		/* 82166D9Ch case    3:*/		return 0x82166DA0;
		  /* 82166DA0h */ case    4:  		/* bl 770824 */
		/* 82166DA0h case    4:*/		regs.LR = 0x82166DA4; return 0x822230A8;
		/* 82166DA0h case    4:*/		return 0x82166DA4;
		  /* 82166DA4h */ case    5:  		/* addi R4, R1, 256 */
		/* 82166DA4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x100);
		/* 82166DA4h case    5:*/		return 0x82166DA8;
		  /* 82166DA8h */ case    6:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166DA8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166DA8h case    6:*/		return 0x82166DAC;
		  /* 82166DACh */ case    7:  		/* bl -1020308 */
		/* 82166DACh case    7:*/		regs.LR = 0x82166DB0; return 0x8206DC18;
		/* 82166DACh case    7:*/		return 0x82166DB0;
	}
	return 0x82166DB0;
} // Block from 82166D90h-82166DB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82166DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166DB0);
		  /* 82166DB0h */ case    0:  		/* mr R30, R3 */
		/* 82166DB0h case    0:*/		regs.R30 = regs.R3;
		/* 82166DB0h case    0:*/		return 0x82166DB4;
		  /* 82166DB4h */ case    1:  		/* mr R5, R3 */
		/* 82166DB4h case    1:*/		regs.R5 = regs.R3;
		/* 82166DB4h case    1:*/		return 0x82166DB8;
		  /* 82166DB8h */ case    2:  		/* mr R7, R31 */
		/* 82166DB8h case    2:*/		regs.R7 = regs.R31;
		/* 82166DB8h case    2:*/		return 0x82166DBC;
		  /* 82166DBCh */ case    3:  		/* mr R6, R16 */
		/* 82166DBCh case    3:*/		regs.R6 = regs.R16;
		/* 82166DBCh case    3:*/		return 0x82166DC0;
		  /* 82166DC0h */ case    4:  		/* li R4, 1 */
		/* 82166DC0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82166DC0h case    4:*/		return 0x82166DC4;
		  /* 82166DC4h */ case    5:  		/* mr R3, R15 */
		/* 82166DC4h case    5:*/		regs.R3 = regs.R15;
		/* 82166DC4h case    5:*/		return 0x82166DC8;
		  /* 82166DC8h */ case    6:  		/* bl -5088 */
		/* 82166DC8h case    6:*/		regs.LR = 0x82166DCC; return 0x821659E8;
		/* 82166DC8h case    6:*/		return 0x82166DCC;
		  /* 82166DCCh */ case    7:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166DCCh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166DCCh case    7:*/		return 0x82166DD0;
		  /* 82166DD0h */ case    8:  		/* stw R22, <#[R1 + 96]> */
		/* 82166DD0h case    8:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 82166DD0h case    8:*/		return 0x82166DD4;
		  /* 82166DD4h */ case    9:  		/* mr R27, R23 */
		/* 82166DD4h case    9:*/		regs.R27 = regs.R23;
		/* 82166DD4h case    9:*/		return 0x82166DD8;
		  /* 82166DD8h */ case   10:  		/* bl -1034992 */
		/* 82166DD8h case   10:*/		regs.LR = 0x82166DDC; return 0x8206A2E8;
		/* 82166DD8h case   10:*/		return 0x82166DDC;
		  /* 82166DDCh */ case   11:  		/* lwz R11, <#[R31 + 16]> */
		/* 82166DDCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82166DDCh case   11:*/		return 0x82166DE0;
		  /* 82166DE0h */ case   12:  		/* addi R29, R3, -1 */
		/* 82166DE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0xFFFFFFFF);
		/* 82166DE0h case   12:*/		return 0x82166DE4;
		  /* 82166DE4h */ case   13:  		/* rlwinm R11, R11, 0, 8, 6 */
		/* 82166DE4h case   13:*/		cpu::op::rlwinm<0,0,8,6>(regs,&regs.R11,regs.R11);
		/* 82166DE4h case   13:*/		return 0x82166DE8;
		  /* 82166DE8h */ case   14:  		/* stw R11, <#[R31 + 16]> */
		/* 82166DE8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82166DE8h case   14:*/		return 0x82166DEC;
		  /* 82166DECh */ case   15:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166DECh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166DECh case   15:*/		return 0x82166DF0;
		  /* 82166DF0h */ case   16:  		/* bl -1035112 */
		/* 82166DF0h case   16:*/		regs.LR = 0x82166DF4; return 0x8206A288;
		/* 82166DF0h case   16:*/		return 0x82166DF4;
		  /* 82166DF4h */ case   17:  		/* lwz R11, <#[R31 + 20]> */
		/* 82166DF4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166DF4h case   17:*/		return 0x82166DF8;
		  /* 82166DF8h */ case   18:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82166DF8h case   18:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82166DF8h case   18:*/		return 0x82166DFC;
		  /* 82166DFCh */ case   19:  		/* rlwinm R10, R29, 12, 17, 19 */
		/* 82166DFCh case   19:*/		cpu::op::rlwinm<0,12,17,19>(regs,&regs.R10,regs.R29);
		/* 82166DFCh case   19:*/		return 0x82166E00;
		  /* 82166E00h */ case   20:  		/* rlwinm R9, R3, 0, 20, 31 */
		/* 82166E00h case   20:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R3);
		/* 82166E00h case   20:*/		return 0x82166E04;
		  /* 82166E04h */ case   21:  		/* or R11, R10, R11 */
		/* 82166E04h case   21:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82166E04h case   21:*/		return 0x82166E08;
		  /* 82166E08h */ case   22:  		/* or R11, R11, R9 */
		/* 82166E08h case   22:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82166E08h case   22:*/		return 0x82166E0C;
		  /* 82166E0Ch */ case   23:  		/* stw R11, <#[R31 + 20]> */
		/* 82166E0Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166E0Ch case   23:*/		return 0x82166E10;
		  /* 82166E10h */ case   24:  		/* b 584 */
		/* 82166E10h case   24:*/		return 0x82167058;
		/* 82166E10h case   24:*/		return 0x82166E14;
	}
	return 0x82166E14;
} // Block from 82166DB0h-82166E14h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82166E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166E14);
		  /* 82166E14h */ case    0:  		/* cmplwi CR6, R10, 126 */
		/* 82166E14h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007E);
		/* 82166E14h case    0:*/		return 0x82166E18;
		  /* 82166E18h */ case    1:  		/* bc 4, CR6_EQ, 176 */
		/* 82166E18h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82166EC8;  }
		/* 82166E18h case    1:*/		return 0x82166E1C;
		  /* 82166E1Ch */ case    2:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82166E1Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82166E1Ch case    2:*/		return 0x82166E20;
		  /* 82166E20h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82166E20h case    3:*/		if ( regs.CR[0].eq ) { return 0x82166E30;  }
		/* 82166E20h case    3:*/		return 0x82166E24;
		  /* 82166E24h */ case    4:  		/* lwz R11, <#[R31 + 20]> */
		/* 82166E24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166E24h case    4:*/		return 0x82166E28;
		  /* 82166E28h */ case    5:  		/* oris R11, R11, 1 */
		/* 82166E28h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82166E28h case    5:*/		return 0x82166E2C;
		  /* 82166E2Ch */ case    6:  		/* stw R11, <#[R31 + 20]> */
		/* 82166E2Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166E2Ch case    6:*/		return 0x82166E30;
	}
	return 0x82166E30;
} // Block from 82166E14h-82166E30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82166E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166E30);
		  /* 82166E30h */ case    0:  		/* lhz R11, <#[R31 + 20]> */
		/* 82166E30h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166E30h case    0:*/		return 0x82166E34;
		  /* 82166E34h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166E34h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166E34h case    1:*/		return 0x82166E38;
		  /* 82166E38h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82166E38h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82166E38h case    2:*/		return 0x82166E3C;
		  /* 82166E3Ch */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 82166E3Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82166E5C;  }
		/* 82166E3Ch case    3:*/		return 0x82166E40;
		  /* 82166E40h */ case    4:  		/* bl -1019968 */
		/* 82166E40h case    4:*/		regs.LR = 0x82166E44; return 0x8206DE00;
		/* 82166E40h case    4:*/		return 0x82166E44;
		  /* 82166E44h */ case    5:  		/* lwz R11, <#[R31 + 20]> */
		/* 82166E44h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166E44h case    5:*/		return 0x82166E48;
		  /* 82166E48h */ case    6:  		/* rlwinm R10, R3, 0, 20, 31 */
		/* 82166E48h case    6:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R3);
		/* 82166E48h case    6:*/		return 0x82166E4C;
		  /* 82166E4Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 16 */
		/* 82166E4Ch case    7:*/		cpu::op::rlwinm<0,0,0,16>(regs,&regs.R11,regs.R11);
		/* 82166E4Ch case    7:*/		return 0x82166E50;
		  /* 82166E50h */ case    8:  		/* mr R27, R22 */
		/* 82166E50h case    8:*/		regs.R27 = regs.R22;
		/* 82166E50h case    8:*/		return 0x82166E54;
		  /* 82166E54h */ case    9:  		/* or R11, R11, R10 */
		/* 82166E54h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82166E54h case    9:*/		return 0x82166E58;
		  /* 82166E58h */ case   10:  		/* b -76 */
		/* 82166E58h case   10:*/		return 0x82166E0C;
		/* 82166E58h case   10:*/		return 0x82166E5C;
	}
	return 0x82166E5C;
} // Block from 82166E30h-82166E5Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82166E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166E5C);
		  /* 82166E5Ch */ case    0:  		/* mr R28, R23 */
		/* 82166E5Ch case    0:*/		regs.R28 = regs.R23;
		/* 82166E5Ch case    0:*/		return 0x82166E60;
		  /* 82166E60h */ case    1:  		/* bl -1035224 */
		/* 82166E60h case    1:*/		regs.LR = 0x82166E64; return 0x8206A288;
		/* 82166E60h case    1:*/		return 0x82166E64;
		  /* 82166E64h */ case    2:  		/* mr R29, R3 */
		/* 82166E64h case    2:*/		regs.R29 = regs.R3;
		/* 82166E64h case    2:*/		return 0x82166E68;
		  /* 82166E68h */ case    3:  		/* cmpwi CR6, R3, -1 */
		/* 82166E68h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82166E68h case    3:*/		return 0x82166E6C;
		  /* 82166E6Ch */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 82166E6Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82166EB4;  }
		/* 82166E6Ch case    4:*/		return 0x82166E70;
		  /* 82166E70h */ case    5:  		/* mr R4, R3 */
		/* 82166E70h case    5:*/		regs.R4 = regs.R3;
		/* 82166E70h case    5:*/		return 0x82166E74;
		  /* 82166E74h */ case    6:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166E74h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166E74h case    6:*/		return 0x82166E78;
		  /* 82166E78h */ case    7:  		/* bl -1035224 */
		/* 82166E78h case    7:*/		regs.LR = 0x82166E7C; return 0x8206A2A0;
		/* 82166E78h case    7:*/		return 0x82166E7C;
		  /* 82166E7Ch */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 82166E7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82166E7Ch case    8:*/		return 0x82166E80;
		  /* 82166E80h */ case    9:  		/* rlwinm R11, R11, 0, 16, 19 */
		/* 82166E80h case    9:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R11,regs.R11);
		/* 82166E80h case    9:*/		return 0x82166E84;
		  /* 82166E84h */ case   10:  		/* cmplwi CR6, R11, 4096 */
		/* 82166E84h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 82166E84h case   10:*/		return 0x82166E88;
		  /* 82166E88h */ case   11:  		/* bc 4, CR6_EQ, 44 */
		/* 82166E88h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82166EB4;  }
		/* 82166E88h case   11:*/		return 0x82166E8C;
		  /* 82166E8Ch */ case   12:  		/* lwz R11, <#[R3]> */
		/* 82166E8Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82166E8Ch case   12:*/		return 0x82166E90;
		  /* 82166E90h */ case   13:  		/* rlwinm R28, R11, 20, 29, 31 */
		/* 82166E90h case   13:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R28,regs.R11);
		/* 82166E90h case   13:*/		return 0x82166E94;
		  /* 82166E94h */ case   14:  		/* cmplwi CR6, R28, 6 */
		/* 82166E94h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000006);
		/* 82166E94h case   14:*/		return 0x82166E98;
		  /* 82166E98h */ case   15:  		/* bc 4, CR6_EQ, 28 */
		/* 82166E98h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82166EB4;  }
		/* 82166E98h case   15:*/		return 0x82166E9C;
		  /* 82166E9Ch */ case   16:  		/* lwz R11, <#[R31 + 20]> */
		/* 82166E9Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166E9Ch case   16:*/		return 0x82166EA0;
		  /* 82166EA0h */ case   17:  		/* addi R29, R29, 1 */
		/* 82166EA0h case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82166EA0h case   17:*/		return 0x82166EA4;
		  /* 82166EA4h */ case   18:  		/* mr R28, R23 */
		/* 82166EA4h case   18:*/		regs.R28 = regs.R23;
		/* 82166EA4h case   18:*/		return 0x82166EA8;
		  /* 82166EA8h */ case   19:  		/* oris R11, R11, 1 */
		/* 82166EA8h case   19:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82166EA8h case   19:*/		return 0x82166EAC;
		  /* 82166EACh */ case   20:  		/* mr R27, R22 */
		/* 82166EACh case   20:*/		regs.R27 = regs.R22;
		/* 82166EACh case   20:*/		return 0x82166EB0;
		  /* 82166EB0h */ case   21:  		/* stw R11, <#[R31 + 20]> */
		/* 82166EB0h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166EB0h case   21:*/		return 0x82166EB4;
	}
	return 0x82166EB4;
} // Block from 82166E5Ch-82166EB4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82166EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166EB4);
		  /* 82166EB4h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82166EB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82166EB4h case    0:*/		return 0x82166EB8;
		  /* 82166EB8h */ case    1:  		/* rlwimi R29, R28, 12, 17, 19 */
		/* 82166EB8h case    1:*/		cpu::op::rlwimi<0,12,17,19>(regs,&regs.R29,regs.R28);
		/* 82166EB8h case    1:*/		return 0x82166EBC;
		  /* 82166EBCh */ case    2:  		/* rlwimi R29, R11, 0, 0, 16 */
		/* 82166EBCh case    2:*/		cpu::op::rlwimi<0,0,0,16>(regs,&regs.R29,regs.R11);
		/* 82166EBCh case    2:*/		return 0x82166EC0;
		  /* 82166EC0h */ case    3:  		/* stw R29, <#[R31 + 20]> */
		/* 82166EC0h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000014) );
		/* 82166EC0h case    3:*/		return 0x82166EC4;
		  /* 82166EC4h */ case    4:  		/* b 404 */
		/* 82166EC4h case    4:*/		return 0x82167058;
		/* 82166EC4h case    4:*/		return 0x82166EC8;
	}
	return 0x82166EC8;
} // Block from 82166EB4h-82166EC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82166EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166EC8);
		  /* 82166EC8h */ case    0:  		/* cmplwi CR6, R10, 106 */
		/* 82166EC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006A);
		/* 82166EC8h case    0:*/		return 0x82166ECC;
		  /* 82166ECCh */ case    1:  		/* bc 4, CR6_EQ, 364 */
		/* 82166ECCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82167038;  }
		/* 82166ECCh case    1:*/		return 0x82166ED0;
		  /* 82166ED0h */ case    2:  		/* lwz R10, <#[R31 + 4]> */
		/* 82166ED0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82166ED0h case    2:*/		return 0x82166ED4;
		  /* 82166ED4h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82166ED4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82166ED4h case    3:*/		return 0x82166ED8;
		  /* 82166ED8h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82166ED8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82166EF0;  }
		/* 82166ED8h case    4:*/		return 0x82166EDC;
		  /* 82166EDCh */ case    5:  		/* lwz R9, <#[R10]> */
		/* 82166EDCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82166EDCh case    5:*/		return 0x82166EE0;
		  /* 82166EE0h */ case    6:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82166EE0h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82166EE0h case    6:*/		return 0x82166EE4;
		  /* 82166EE4h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 82166EE4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82166EF0;  }
		/* 82166EE4h case    7:*/		return 0x82166EE8;
		  /* 82166EE8h */ case    8:  		/* lwz R10, <#[R10 + 8]> */
		/* 82166EE8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82166EE8h case    8:*/		return 0x82166EEC;
		  /* 82166EECh */ case    9:  		/* b -24 */
		/* 82166EECh case    9:*/		return 0x82166ED4;
		/* 82166EECh case    9:*/		return 0x82166EF0;
	}
	return 0x82166EF0;
} // Block from 82166EC8h-82166EF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82166EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82166EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82166EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82166EF0);
		  /* 82166EF0h */ case    0:  		/* addi R9, R1, 128 */
		/* 82166EF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 82166EF0h case    0:*/		return 0x82166EF4;
		  /* 82166EF4h */ case    1:  		/* lwz R10, <#[R10]> */
		/* 82166EF4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82166EF4h case    1:*/		return 0x82166EF8;
		  /* 82166EF8h */ case    2:  		/* addi R4, R1, 128 */
		/* 82166EF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 82166EF8h case    2:*/		return 0x82166EFC;
		  /* 82166EFCh */ case    3:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166EFCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166EFCh case    3:*/		return 0x82166F00;
		  /* 82166F00h */ case    4:  		/* rlwimi R11, R10, 20, 19, 26 */
		/* 82166F00h case    4:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R11,regs.R10);
		/* 82166F00h case    4:*/		return 0x82166F04;
		  /* 82166F04h */ case    5:  		/* rlwinm R30, R11, 31, 20, 31 */
		/* 82166F04h case    5:*/		cpu::op::rlwinm<0,31,20,31>(regs,&regs.R30,regs.R11);
		/* 82166F04h case    5:*/		return 0x82166F08;
		  /* 82166F08h */ case    6:  		/* std R23, <#[R9]> */
		/* 82166F08h case    6:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R9 + 0x00000000) );
		/* 82166F08h case    6:*/		return 0x82166F0C;
		  /* 82166F0Ch */ case    7:  		/* stw R23, <#[R9 + 8]> */
		/* 82166F0Ch case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R9 + 0x00000008) );
		/* 82166F0Ch case    7:*/		return 0x82166F10;
		  /* 82166F10h */ case    8:  		/* rlwinm R10, R30, 28, 4, 31 */
		/* 82166F10h case    8:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R30);
		/* 82166F10h case    8:*/		return 0x82166F14;
		  /* 82166F14h */ case    9:  		/* rlwinm R29, R30, 12, 16, 19 */
		/* 82166F14h case    9:*/		cpu::op::rlwinm<0,12,16,19>(regs,&regs.R29,regs.R30);
		/* 82166F14h case    9:*/		return 0x82166F18;
		  /* 82166F18h */ case   10:  		/* rlwinm R11, R30, 28, 26, 31 */
		/* 82166F18h case   10:*/		cpu::op::rlwinm<0,28,26,31>(regs,&regs.R11,regs.R30);
		/* 82166F18h case   10:*/		return 0x82166F1C;
		  /* 82166F1Ch */ case   11:  		/* or R11, R11, R29 */
		/* 82166F1Ch case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82166F1Ch case   11:*/		return 0x82166F20;
		  /* 82166F20h */ case   12:  		/* rlwinm R11, R11, 8, 0, 23 */
		/* 82166F20h case   12:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R11,regs.R11);
		/* 82166F20h case   12:*/		return 0x82166F24;
		  /* 82166F24h */ case   13:  		/* lwz R8, <#[R1 + 136]> */
		/* 82166F24h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000088) );
		/* 82166F24h case   13:*/		return 0x82166F28;
		  /* 82166F28h */ case   14:  		/* lwz R10, <#[R1 + 132]> */
		/* 82166F28h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 82166F28h case   14:*/		return 0x82166F2C;
		  /* 82166F2Ch */ case   15:  		/* lwz R9, <#[R1 + 128]> */
		/* 82166F2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000080) );
		/* 82166F2Ch case   15:*/		return 0x82166F30;
		  /* 82166F30h */ case   16:  		/* rlwinm R9, R9, 0, 6, 31 */
		/* 82166F30h case   16:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R9,regs.R9);
		/* 82166F30h case   16:*/		return 0x82166F34;
		  /* 82166F34h */ case   17:  		/* oris R9, R9, 8192 */
		/* 82166F34h case   17:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x2000);
		/* 82166F34h case   17:*/		return 0x82166F38;
		  /* 82166F38h */ case   18:  		/* rlwimi R8, R22, 25, 3, 7 */
		/* 82166F38h case   18:*/		cpu::op::rlwimi<0,25,3,7>(regs,&regs.R8,regs.R22);
		/* 82166F38h case   18:*/		return 0x82166F3C;
		  /* 82166F3Ch */ case   19:  		/* rlwinm R9, R9, 0, 24, 17 */
		/* 82166F3Ch case   19:*/		cpu::op::rlwinm<0,0,24,17>(regs,&regs.R9,regs.R9);
		/* 82166F3Ch case   19:*/		return 0x82166F40;
		  /* 82166F40h */ case   20:  		/* oris R8, R8, 8192 */
		/* 82166F40h case   20:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x2000);
		/* 82166F40h case   20:*/		return 0x82166F44;
		  /* 82166F44h */ case   21:  		/* rlwinm R9, R9, 0, 12, 7 */
		/* 82166F44h case   21:*/		cpu::op::rlwinm<0,0,12,7>(regs,&regs.R9,regs.R9);
		/* 82166F44h case   21:*/		return 0x82166F48;
		  /* 82166F48h */ case   22:  		/* rlwinm R8, R8, 0, 0, 24 */
		/* 82166F48h case   22:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R8,regs.R8);
		/* 82166F48h case   22:*/		return 0x82166F4C;
		  /* 82166F4Ch */ case   23:  		/* or R11, R11, R9 */
		/* 82166F4Ch case   23:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82166F4Ch case   23:*/		return 0x82166F50;
		  /* 82166F50h */ case   24:  		/* oris R10, R10, 256 */
		/* 82166F50h case   24:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 82166F50h case   24:*/		return 0x82166F54;
		  /* 82166F54h */ case   25:  		/* ori R9, R8, 128 */
		/* 82166F54h case   25:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R8,0x80);
		/* 82166F54h case   25:*/		return 0x82166F58;
		  /* 82166F58h */ case   26:  		/* stw R11, <#[R1 + 128]> */
		/* 82166F58h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 82166F58h case   26:*/		return 0x82166F5C;
		  /* 82166F5Ch */ case   27:  		/* stw R10, <#[R1 + 132]> */
		/* 82166F5Ch case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 82166F5Ch case   27:*/		return 0x82166F60;
		  /* 82166F60h */ case   28:  		/* stw R9, <#[R1 + 136]> */
		/* 82166F60h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000088) );
		/* 82166F60h case   28:*/		return 0x82166F64;
		  /* 82166F64h */ case   29:  		/* bl -1020676 */
		/* 82166F64h case   29:*/		regs.LR = 0x82166F68; return 0x8206DC60;
		/* 82166F64h case   29:*/		return 0x82166F68;
		  /* 82166F68h */ case   30:  		/* mr R5, R3 */
		/* 82166F68h case   30:*/		regs.R5 = regs.R3;
		/* 82166F68h case   30:*/		return 0x82166F6C;
		  /* 82166F6Ch */ case   31:  		/* mr R7, R31 */
		/* 82166F6Ch case   31:*/		regs.R7 = regs.R31;
		/* 82166F6Ch case   31:*/		return 0x82166F70;
		  /* 82166F70h */ case   32:  		/* mr R6, R16 */
		/* 82166F70h case   32:*/		regs.R6 = regs.R16;
		/* 82166F70h case   32:*/		return 0x82166F74;
		  /* 82166F74h */ case   33:  		/* li R4, 1 */
		/* 82166F74h case   33:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82166F74h case   33:*/		return 0x82166F78;
		  /* 82166F78h */ case   34:  		/* mr R3, R15 */
		/* 82166F78h case   34:*/		regs.R3 = regs.R15;
		/* 82166F78h case   34:*/		return 0x82166F7C;
		  /* 82166F7Ch */ case   35:  		/* bl -5524 */
		/* 82166F7Ch case   35:*/		regs.LR = 0x82166F80; return 0x821659E8;
		/* 82166F7Ch case   35:*/		return 0x82166F80;
		  /* 82166F80h */ case   36:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166F80h case   36:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166F80h case   36:*/		return 0x82166F84;
		  /* 82166F84h */ case   37:  		/* bl -1020292 */
		/* 82166F84h case   37:*/		regs.LR = 0x82166F88; return 0x8206DE00;
		/* 82166F84h case   37:*/		return 0x82166F88;
		  /* 82166F88h */ case   38:  		/* mr R28, R3 */
		/* 82166F88h case   38:*/		regs.R28 = regs.R3;
		/* 82166F88h case   38:*/		return 0x82166F8C;
		  /* 82166F8Ch */ case   39:  		/* li R5, 25 */
		/* 82166F8Ch case   39:*/		cpu::op::li<0>(regs,&regs.R5,0x19);
		/* 82166F8Ch case   39:*/		return 0x82166F90;
		  /* 82166F90h */ case   40:  		/* li R4, 12 */
		/* 82166F90h case   40:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 82166F90h case   40:*/		return 0x82166F94;
		  /* 82166F94h */ case   41:  		/* mr R3, R15 */
		/* 82166F94h case   41:*/		regs.R3 = regs.R15;
		/* 82166F94h case   41:*/		return 0x82166F98;
		  /* 82166F98h */ case   42:  		/* bl -9896 */
		/* 82166F98h case   42:*/		regs.LR = 0x82166F9C; return 0x821648F0;
		/* 82166F98h case   42:*/		return 0x82166F9C;
		  /* 82166F9Ch */ case   43:  		/* addi R10, R1, 144 */
		/* 82166F9Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82166F9Ch case   43:*/		return 0x82166FA0;
		  /* 82166FA0h */ case   44:  		/* stw R24, <#[R3 + 8]> */
		/* 82166FA0h case   44:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000008) );
		/* 82166FA0h case   44:*/		return 0x82166FA4;
		  /* 82166FA4h */ case   45:  		/* mr R11, R3 */
		/* 82166FA4h case   45:*/		regs.R11 = regs.R3;
		/* 82166FA4h case   45:*/		return 0x82166FA8;
		  /* 82166FA8h */ case   46:  		/* stw R28, <#[R3]> */
		/* 82166FA8h case   46:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82166FA8h case   46:*/		return 0x82166FAC;
		  /* 82166FACh */ case   47:  		/* mr R24, R3 */
		/* 82166FACh case   47:*/		regs.R24 = regs.R3;
		/* 82166FACh case   47:*/		return 0x82166FB0;
		  /* 82166FB0h */ case   48:  		/* stw R31, <#[R3 + 4]> */
		/* 82166FB0h case   48:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 82166FB0h case   48:*/		return 0x82166FB4;
		  /* 82166FB4h */ case   49:  		/* rlwinm R9, R30, 28, 26, 31 */
		/* 82166FB4h case   49:*/		cpu::op::rlwinm<0,28,26,31>(regs,&regs.R9,regs.R30);
		/* 82166FB4h case   49:*/		return 0x82166FB8;
		  /* 82166FB8h */ case   50:  		/* lwz R3, <#[R15 + 768]> */
		/* 82166FB8h case   50:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82166FB8h case   50:*/		return 0x82166FBC;
		  /* 82166FBCh */ case   51:  		/* addi R4, R1, 144 */
		/* 82166FBCh case   51:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 82166FBCh case   51:*/		return 0x82166FC0;
		  /* 82166FC0h */ case   52:  		/* std R23, <#[R10]> */
		/* 82166FC0h case   52:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R10 + 0x00000000) );
		/* 82166FC0h case   52:*/		return 0x82166FC4;
		  /* 82166FC4h */ case   53:  		/* stw R23, <#[R10 + 8]> */
		/* 82166FC4h case   53:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R10 + 0x00000008) );
		/* 82166FC4h case   53:*/		return 0x82166FC8;
		  /* 82166FC8h */ case   54:  		/* or R9, R9, R29 */
		/* 82166FC8h case   54:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R29);
		/* 82166FC8h case   54:*/		return 0x82166FCC;
		  /* 82166FCCh */ case   55:  		/* rlwinm R9, R9, 8, 0, 23 */
		/* 82166FCCh case   55:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R9,regs.R9);
		/* 82166FCCh case   55:*/		return 0x82166FD0;
		  /* 82166FD0h */ case   56:  		/* lwz R11, <#[R1 + 152]> */
		/* 82166FD0h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 82166FD0h case   56:*/		return 0x82166FD4;
		  /* 82166FD4h */ case   57:  		/* lwz R10, <#[R1 + 144]> */
		/* 82166FD4h case   57:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82166FD4h case   57:*/		return 0x82166FD8;
		  /* 82166FD8h */ case   58:  		/* rlwinm R10, R10, 0, 6, 31 */
		/* 82166FD8h case   58:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R10,regs.R10);
		/* 82166FD8h case   58:*/		return 0x82166FDC;
		  /* 82166FDCh */ case   59:  		/* rlwimi R11, R22, 25, 3, 7 */
		/* 82166FDCh case   59:*/		cpu::op::rlwimi<0,25,3,7>(regs,&regs.R11,regs.R22);
		/* 82166FDCh case   59:*/		return 0x82166FE0;
		  /* 82166FE0h */ case   60:  		/* oris R10, R10, 9216 */
		/* 82166FE0h case   60:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x2400);
		/* 82166FE0h case   60:*/		return 0x82166FE4;
		  /* 82166FE4h */ case   61:  		/* rlwinm R11, R11, 0, 0, 24 */
		/* 82166FE4h case   61:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R11,regs.R11);
		/* 82166FE4h case   61:*/		return 0x82166FE8;
		  /* 82166FE8h */ case   62:  		/* rlwinm R10, R10, 0, 24, 17 */
		/* 82166FE8h case   62:*/		cpu::op::rlwinm<0,0,24,17>(regs,&regs.R10,regs.R10);
		/* 82166FE8h case   62:*/		return 0x82166FEC;
		  /* 82166FECh */ case   63:  		/* oris R11, R11, 8192 */
		/* 82166FECh case   63:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82166FECh case   63:*/		return 0x82166FF0;
		  /* 82166FF0h */ case   64:  		/* rlwinm R10, R10, 0, 12, 7 */
		/* 82166FF0h case   64:*/		cpu::op::rlwinm<0,0,12,7>(regs,&regs.R10,regs.R10);
		/* 82166FF0h case   64:*/		return 0x82166FF4;
		  /* 82166FF4h */ case   65:  		/* ori R11, R11, 128 */
		/* 82166FF4h case   65:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82166FF4h case   65:*/		return 0x82166FF8;
		  /* 82166FF8h */ case   66:  		/* or R10, R9, R10 */
		/* 82166FF8h case   66:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82166FF8h case   66:*/		return 0x82166FFC;
		  /* 82166FFCh */ case   67:  		/* stw R11, <#[R1 + 152]> */
		/* 82166FFCh case   67:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 82166FFCh case   67:*/		return 0x82167000;
		  /* 82167000h */ case   68:  		/* stw R10, <#[R1 + 144]> */
		/* 82167000h case   68:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82167000h case   68:*/		return 0x82167004;
		  /* 82167004h */ case   69:  		/* bl -1020836 */
		/* 82167004h case   69:*/		regs.LR = 0x82167008; return 0x8206DC60;
		/* 82167004h case   69:*/		return 0x82167008;
		  /* 82167008h */ case   70:  		/* mr R30, R3 */
		/* 82167008h case   70:*/		regs.R30 = regs.R3;
		/* 82167008h case   70:*/		return 0x8216700C;
		  /* 8216700Ch */ case   71:  		/* mr R5, R3 */
		/* 8216700Ch case   71:*/		regs.R5 = regs.R3;
		/* 8216700Ch case   71:*/		return 0x82167010;
		  /* 82167010h */ case   72:  		/* mr R7, R31 */
		/* 82167010h case   72:*/		regs.R7 = regs.R31;
		/* 82167010h case   72:*/		return 0x82167014;
		  /* 82167014h */ case   73:  		/* mr R6, R16 */
		/* 82167014h case   73:*/		regs.R6 = regs.R16;
		/* 82167014h case   73:*/		return 0x82167018;
		  /* 82167018h */ case   74:  		/* li R4, 1 */
		/* 82167018h case   74:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82167018h case   74:*/		return 0x8216701C;
		  /* 8216701Ch */ case   75:  		/* mr R3, R15 */
		/* 8216701Ch case   75:*/		regs.R3 = regs.R15;
		/* 8216701Ch case   75:*/		return 0x82167020;
		  /* 82167020h */ case   76:  		/* bl -5688 */
		/* 82167020h case   76:*/		regs.LR = 0x82167024; return 0x821659E8;
		/* 82167020h case   76:*/		return 0x82167024;
		  /* 82167024h */ case   77:  		/* stw R22, <#[R1 + 96]> */
		/* 82167024h case   77:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000060) );
		/* 82167024h case   77:*/		return 0x82167028;
	}
	return 0x82167028;
} // Block from 82166EF0h-82167028h (78 instructions)

//////////////////////////////////////////////////////
// Block at 82167028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167028);
		  /* 82167028h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167028h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167028h case    0:*/		return 0x8216702C;
		  /* 8216702Ch */ case    1:  		/* bl -1020460 */
		/* 8216702Ch case    1:*/		regs.LR = 0x82167030; return 0x8206DE00;
		/* 8216702Ch case    1:*/		return 0x82167030;
		  /* 82167030h */ case    2:  		/* mr R27, R22 */
		/* 82167030h case    2:*/		regs.R27 = regs.R22;
		/* 82167030h case    2:*/		return 0x82167034;
		  /* 82167034h */ case    3:  		/* b 36 */
		/* 82167034h case    3:*/		return 0x82167058;
		/* 82167034h case    3:*/		return 0x82167038;
	}
	return 0x82167038;
} // Block from 82167028h-82167038h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82167038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167038);
		  /* 82167038h */ case    0:  		/* cmplwi CR6, R10, 1 */
		/* 82167038h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82167038h case    0:*/		return 0x8216703C;
		  /* 8216703Ch */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 8216703Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8216704C;  }
		/* 8216703Ch case    1:*/		return 0x82167040;
		  /* 82167040h */ case    2:  		/* cmplwi CR6, R10, 102 */
		/* 82167040h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 82167040h case    2:*/		return 0x82167044;
		  /* 82167044h */ case    3:  		/* mr R11, R22 */
		/* 82167044h case    3:*/		regs.R11 = regs.R22;
		/* 82167044h case    3:*/		return 0x82167048;
		  /* 82167048h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82167048h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82167050;  }
		/* 82167048h case    4:*/		return 0x8216704C;
	}
	return 0x8216704C;
} // Block from 82167038h-8216704Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216704Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216704C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216704C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216704C);
		  /* 8216704Ch */ case    0:  		/* mr R11, R23 */
		/* 8216704Ch case    0:*/		regs.R11 = regs.R23;
		/* 8216704Ch case    0:*/		return 0x82167050;
	}
	return 0x82167050;
} // Block from 8216704Ch-82167050h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167050);
		  /* 82167050h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167050h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167050h case    0:*/		return 0x82167054;
		  /* 82167054h */ case    1:  		/* bc 4, CR0_EQ, 488 */
		/* 82167054h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216723C;  }
		/* 82167054h case    1:*/		return 0x82167058;
	}
	return 0x82167058;
} // Block from 82167050h-82167058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167058);
		  /* 82167058h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 82167058h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82167058h case    0:*/		return 0x8216705C;
		  /* 8216705Ch */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 8216705Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821670E0;  }
		/* 8216705Ch case    1:*/		return 0x82167060;
		  /* 82167060h */ case    2:  		/* lwz R11, <#[R18]> */
		/* 82167060h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 82167060h case    2:*/		return 0x82167064;
		  /* 82167064h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82167064h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82167064h case    3:*/		return 0x82167068;
		  /* 82167068h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82167068h case    4:*/		if ( regs.CR[6].eq ) { return 0x82167074;  }
		/* 82167068h case    4:*/		return 0x8216706C;
		  /* 8216706Ch */ case    5:  		/* cmplw CR6, R25, R11 */
		/* 8216706Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8216706Ch case    5:*/		return 0x82167070;
		  /* 82167070h */ case    6:  		/* bc 4, CR6_EQ, 112 */
		/* 82167070h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821670E0;  }
		/* 82167070h case    6:*/		return 0x82167074;
	}
	return 0x82167074;
} // Block from 82167058h-82167074h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82167074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167074);
		  /* 82167074h */ case    0:  		/* addi R7, R1, 96 */
		/* 82167074h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82167074h case    0:*/		return 0x82167078;
		  /* 82167078h */ case    1:  		/* mr R6, R30 */
		/* 82167078h case    1:*/		regs.R6 = regs.R30;
		/* 82167078h case    1:*/		return 0x8216707C;
		  /* 8216707Ch */ case    2:  		/* mr R5, R31 */
		/* 8216707Ch case    2:*/		regs.R5 = regs.R31;
		/* 8216707Ch case    2:*/		return 0x82167080;
		  /* 82167080h */ case    3:  		/* mr R4, R16 */
		/* 82167080h case    3:*/		regs.R4 = regs.R16;
		/* 82167080h case    3:*/		return 0x82167084;
		  /* 82167084h */ case    4:  		/* mr R3, R15 */
		/* 82167084h case    4:*/		regs.R3 = regs.R15;
		/* 82167084h case    4:*/		return 0x82167088;
		  /* 82167088h */ case    5:  		/* bl -5536 */
		/* 82167088h case    5:*/		regs.LR = 0x8216708C; return 0x82165AE8;
		/* 82167088h case    5:*/		return 0x8216708C;
		  /* 8216708Ch */ case    6:  		/* lwz R11, <#[R18]> */
		/* 8216708Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000000) );
		/* 8216708Ch case    6:*/		return 0x82167090;
		  /* 82167090h */ case    7:  		/* mr R30, R3 */
		/* 82167090h case    7:*/		regs.R30 = regs.R3;
		/* 82167090h case    7:*/		return 0x82167094;
		  /* 82167094h */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 82167094h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82167094h case    8:*/		return 0x82167098;
		  /* 82167098h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 82167098h case    9:*/		if ( regs.CR[6].eq ) { return 0x821670A4;  }
		/* 82167098h case    9:*/		return 0x8216709C;
		  /* 8216709Ch */ case   10:  		/* cmplw CR6, R25, R11 */
		/* 8216709Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 8216709Ch case   10:*/		return 0x821670A0;
		  /* 821670A0h */ case   11:  		/* bc 4, CR6_EQ, -64 */
		/* 821670A0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82167060;  }
		/* 821670A0h case   11:*/		return 0x821670A4;
	}
	return 0x821670A4;
} // Block from 82167074h-821670A4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821670A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821670A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821670A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821670A4);
		  /* 821670A4h */ case    0:  		/* lwz R11, <#[R18 + 4]> */
		/* 821670A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 821670A4h case    0:*/		return 0x821670A8;
		  /* 821670A8h */ case    1:  		/* lwz R10, <#[R1 + 96]> */
		/* 821670A8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 821670A8h case    1:*/		return 0x821670AC;
		  /* 821670ACh */ case    2:  		/* stw R30, <#[R18]> */
		/* 821670ACh case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R18 + 0x00000000) );
		/* 821670ACh case    2:*/		return 0x821670B0;
		  /* 821670B0h */ case    3:  		/* rlwimi R11, R10, 31, 0, 0 */
		/* 821670B0h case    3:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R11,regs.R10);
		/* 821670B0h case    3:*/		return 0x821670B4;
		  /* 821670B4h */ case    4:  		/* stw R11, <#[R18 + 4]> */
		/* 821670B4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 821670B4h case    4:*/		return 0x821670B8;
		  /* 821670B8h */ case    5:  		/* addi R18, R18, 12 */
		/* 821670B8h case    5:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0xC);
		/* 821670B8h case    5:*/		return 0x821670BC;
		  /* 821670BCh */ case    6:  		/* stw R18, <#[R1 + 104]> */
		/* 821670BCh case    6:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 821670BCh case    6:*/		return 0x821670C0;
		  /* 821670C0h */ case    7:  		/* lwz R11, <#[R15 + 740]> */
		/* 821670C0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002E4) );
		/* 821670C0h case    7:*/		return 0x821670C4;
		  /* 821670C4h */ case    8:  		/* mulli R10, R11, 12 */
		/* 821670C4h case    8:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0xC);
		/* 821670C4h case    8:*/		return 0x821670C8;
		  /* 821670C8h */ case    9:  		/* lwz R11, <#[R15 + 736]> */
		/* 821670C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002E0) );
		/* 821670C8h case    9:*/		return 0x821670CC;
		  /* 821670CCh */ case   10:  		/* add R11, R10, R11 */
		/* 821670CCh case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821670CCh case   10:*/		return 0x821670D0;
		  /* 821670D0h */ case   11:  		/* cmplw CR6, R18, R11 */
		/* 821670D0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 821670D0h case   11:*/		return 0x821670D4;
		  /* 821670D4h */ case   12:  		/* bc 12, CR6_LT, -116 */
		/* 821670D4h case   12:*/		if ( regs.CR[6].lt ) { return 0x82167060;  }
		/* 821670D4h case   12:*/		return 0x821670D8;
		  /* 821670D8h */ case   13:  		/* mr R18, R23 */
		/* 821670D8h case   13:*/		regs.R18 = regs.R23;
		/* 821670D8h case   13:*/		return 0x821670DC;
		  /* 821670DCh */ case   14:  		/* stw R23, <#[R1 + 104]> */
		/* 821670DCh case   14:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000068) );
		/* 821670DCh case   14:*/		return 0x821670E0;
	}
	return 0x821670E0;
} // Block from 821670A4h-821670E0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821670E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821670E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821670E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821670E0);
		  /* 821670E0h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 821670E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 821670E0h case    0:*/		return 0x821670E4;
		  /* 821670E4h */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 821670E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82167168;  }
		/* 821670E4h case    1:*/		return 0x821670E8;
		  /* 821670E8h */ case    2:  		/* lwz R11, <#[R21]> */
		/* 821670E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 821670E8h case    2:*/		return 0x821670EC;
		  /* 821670ECh */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 821670ECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821670ECh case    3:*/		return 0x821670F0;
		  /* 821670F0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 821670F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x821670FC;  }
		/* 821670F0h case    4:*/		return 0x821670F4;
		  /* 821670F4h */ case    5:  		/* cmplw CR6, R25, R11 */
		/* 821670F4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 821670F4h case    5:*/		return 0x821670F8;
		  /* 821670F8h */ case    6:  		/* bc 4, CR6_EQ, 112 */
		/* 821670F8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82167168;  }
		/* 821670F8h case    6:*/		return 0x821670FC;
	}
	return 0x821670FC;
} // Block from 821670E0h-821670FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821670FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821670FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821670FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821670FC);
		  /* 821670FCh */ case    0:  		/* addi R7, R1, 96 */
		/* 821670FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 821670FCh case    0:*/		return 0x82167100;
		  /* 82167100h */ case    1:  		/* mr R6, R30 */
		/* 82167100h case    1:*/		regs.R6 = regs.R30;
		/* 82167100h case    1:*/		return 0x82167104;
		  /* 82167104h */ case    2:  		/* mr R5, R31 */
		/* 82167104h case    2:*/		regs.R5 = regs.R31;
		/* 82167104h case    2:*/		return 0x82167108;
		  /* 82167108h */ case    3:  		/* mr R4, R16 */
		/* 82167108h case    3:*/		regs.R4 = regs.R16;
		/* 82167108h case    3:*/		return 0x8216710C;
		  /* 8216710Ch */ case    4:  		/* mr R3, R15 */
		/* 8216710Ch case    4:*/		regs.R3 = regs.R15;
		/* 8216710Ch case    4:*/		return 0x82167110;
		  /* 82167110h */ case    5:  		/* bl -5672 */
		/* 82167110h case    5:*/		regs.LR = 0x82167114; return 0x82165AE8;
		/* 82167110h case    5:*/		return 0x82167114;
		  /* 82167114h */ case    6:  		/* lwz R11, <#[R21]> */
		/* 82167114h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82167114h case    6:*/		return 0x82167118;
		  /* 82167118h */ case    7:  		/* mr R30, R3 */
		/* 82167118h case    7:*/		regs.R30 = regs.R3;
		/* 82167118h case    7:*/		return 0x8216711C;
		  /* 8216711Ch */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 8216711Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8216711Ch case    8:*/		return 0x82167120;
		  /* 82167120h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 82167120h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216712C;  }
		/* 82167120h case    9:*/		return 0x82167124;
		  /* 82167124h */ case   10:  		/* cmplw CR6, R25, R11 */
		/* 82167124h case   10:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82167124h case   10:*/		return 0x82167128;
		  /* 82167128h */ case   11:  		/* bc 4, CR6_EQ, -64 */
		/* 82167128h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821670E8;  }
		/* 82167128h case   11:*/		return 0x8216712C;
	}
	return 0x8216712C;
} // Block from 821670FCh-8216712Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216712Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216712C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216712C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216712C);
		  /* 8216712Ch */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 8216712Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8216712Ch case    0:*/		return 0x82167130;
		  /* 82167130h */ case    1:  		/* lwz R10, <#[R1 + 96]> */
		/* 82167130h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82167130h case    1:*/		return 0x82167134;
		  /* 82167134h */ case    2:  		/* stw R30, <#[R21]> */
		/* 82167134h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R21 + 0x00000000) );
		/* 82167134h case    2:*/		return 0x82167138;
		  /* 82167138h */ case    3:  		/* rlwimi R11, R10, 1, 30, 30 */
		/* 82167138h case    3:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R11,regs.R10);
		/* 82167138h case    3:*/		return 0x8216713C;
		  /* 8216713Ch */ case    4:  		/* stw R11, <#[R21 + 4]> */
		/* 8216713Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8216713Ch case    4:*/		return 0x82167140;
		  /* 82167140h */ case    5:  		/* addi R21, R21, 12 */
		/* 82167140h case    5:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0xC);
		/* 82167140h case    5:*/		return 0x82167144;
		  /* 82167144h */ case    6:  		/* stw R21, <#[R1 + 100]> */
		/* 82167144h case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 82167144h case    6:*/		return 0x82167148;
		  /* 82167148h */ case    7:  		/* lwz R10, <#[R15 + 764]> */
		/* 82167148h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x000002FC) );
		/* 82167148h case    7:*/		return 0x8216714C;
		  /* 8216714Ch */ case    8:  		/* mulli R10, R10, 12 */
		/* 8216714Ch case    8:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8216714Ch case    8:*/		return 0x82167150;
		  /* 82167150h */ case    9:  		/* lwz R11, <#[R15 + 760]> */
		/* 82167150h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002F8) );
		/* 82167150h case    9:*/		return 0x82167154;
		  /* 82167154h */ case   10:  		/* add R11, R10, R11 */
		/* 82167154h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82167154h case   10:*/		return 0x82167158;
		  /* 82167158h */ case   11:  		/* cmplw CR6, R21, R11 */
		/* 82167158h case   11:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 82167158h case   11:*/		return 0x8216715C;
		  /* 8216715Ch */ case   12:  		/* bc 12, CR6_LT, -116 */
		/* 8216715Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x821670E8;  }
		/* 8216715Ch case   12:*/		return 0x82167160;
		  /* 82167160h */ case   13:  		/* mr R21, R23 */
		/* 82167160h case   13:*/		regs.R21 = regs.R23;
		/* 82167160h case   13:*/		return 0x82167164;
		  /* 82167164h */ case   14:  		/* stw R23, <#[R1 + 100]> */
		/* 82167164h case   14:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000064) );
		/* 82167164h case   14:*/		return 0x82167168;
	}
	return 0x82167168;
} // Block from 8216712Ch-82167168h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82167168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167168);
		  /* 82167168h */ case    0:  		/* mr R31, R25 */
		/* 82167168h case    0:*/		regs.R31 = regs.R25;
		/* 82167168h case    0:*/		return 0x8216716C;
	}
	return 0x8216716C;
} // Block from 82167168h-8216716Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216716Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216716C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216716C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216716C);
		  /* 8216716Ch */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8216716Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8216716Ch case    0:*/		return 0x82167170;
		  /* 82167170h */ case    1:  		/* lwz R31, <#[R11 + 40]> */
		/* 82167170h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 82167170h case    1:*/		return 0x82167174;
		  /* 82167174h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82167174h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82167174h case    2:*/		return 0x82167178;
		  /* 82167178h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 82167178h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82167184;  }
		/* 82167178h case    3:*/		return 0x8216717C;
		  /* 8216717Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216717Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216717Ch case    4:*/		return 0x82167180;
		  /* 82167180h */ case    5:  		/* bc 4, CR6_EQ, -2992 */
		/* 82167180h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821665D0;  }
		/* 82167180h case    5:*/		return 0x82167184;
	}
	return 0x82167184;
} // Block from 8216716Ch-82167184h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82167184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167184);
		  /* 82167184h */ case    0:  		/* lwz R25, <#[R1 + 476]> */
		/* 82167184h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000001DC) );
		/* 82167184h case    0:*/		return 0x82167188;
	}
	return 0x82167188;
} // Block from 82167184h-82167188h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167188);
		  /* 82167188h */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 82167188h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 82167188h case    0:*/		return 0x8216718C;
		  /* 8216718Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216718Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216718Ch case    1:*/		return 0x82167190;
		  /* 82167190h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167190h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167190h case    2:*/		return 0x82167194;
		  /* 82167194h */ case    3:  		/* bc 4, CR0_EQ, 36 */
		/* 82167194h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821671B8;  }
		/* 82167194h case    3:*/		return 0x82167198;
		  /* 82167198h */ case    4:  		/* mr R26, R11 */
		/* 82167198h case    4:*/		regs.R26 = regs.R11;
		/* 82167198h case    4:*/		return 0x8216719C;
		  /* 8216719Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216719Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216719Ch case    5:*/		return 0x821671A0;
		  /* 821671A0h */ case    6:  		/* bc 4, CR6_EQ, -3152 */
		/* 821671A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82166550;  }
		/* 821671A0h case    6:*/		return 0x821671A4;
	}
	return 0x821671A4;
} // Block from 82167188h-821671A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821671A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821671A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821671A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821671A4);
		  /* 821671A4h */ case    0:  		/* mr R29, R23 */
		/* 821671A4h case    0:*/		regs.R29 = regs.R23;
		/* 821671A4h case    0:*/		return 0x821671A8;
		  /* 821671A8h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 821671A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821671A8h case    1:*/		return 0x821671AC;
		  /* 821671ACh */ case    2:  		/* bc 12, CR6_EQ, 164 */
		/* 821671ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x82167250;  }
		/* 821671ACh case    2:*/		return 0x821671B0;
		  /* 821671B0h */ case    3:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821671B0h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821671B0h case    3:*/		return 0x821671B4;
		  /* 821671B4h */ case    4:  		/* b 308 */
		/* 821671B4h case    4:*/		return 0x821672E8;
		/* 821671B4h case    4:*/		return 0x821671B8;
	}
	return 0x821671B8;
} // Block from 821671A4h-821671B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821671B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821671B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821671B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821671B8);
		  /* 821671B8h */ case    0:  		/* mr R26, R23 */
		/* 821671B8h case    0:*/		regs.R26 = regs.R23;
		/* 821671B8h case    0:*/		return 0x821671BC;
		  /* 821671BCh */ case    1:  		/* b -24 */
		/* 821671BCh case    1:*/		return 0x821671A4;
		/* 821671BCh case    1:*/		return 0x821671C0;
	}
	return 0x821671C0;
} // Block from 821671B8h-821671C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821671C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821671C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821671C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821671C0);
		  /* 821671C0h */ case    0:  		/* li R6, 1 */
		/* 821671C0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821671C0h case    0:*/		return 0x821671C4;
		  /* 821671C4h */ case    1:  		/* li R5, 0 */
		/* 821671C4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821671C4h case    1:*/		return 0x821671C8;
		  /* 821671C8h */ case    2:  		/* li R4, 116 */
		/* 821671C8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x74);
		/* 821671C8h case    2:*/		return 0x821671CC;
		  /* 821671CCh */ case    3:  		/* mr R3, R15 */
		/* 821671CCh case    3:*/		regs.R3 = regs.R15;
		/* 821671CCh case    3:*/		return 0x821671D0;
		  /* 821671D0h */ case    4:  		/* bl -11680 */
		/* 821671D0h case    4:*/		regs.LR = 0x821671D4; return 0x82164430;
		/* 821671D0h case    4:*/		return 0x821671D4;
		  /* 821671D4h */ case    5:  		/* addi R10, R31, -4 */
		/* 821671D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFC);
		/* 821671D4h case    5:*/		return 0x821671D8;
		  /* 821671D8h */ case    6:  		/* lwz R11, <#[R15 + 12]> */
		/* 821671D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000000C) );
		/* 821671D8h case    6:*/		return 0x821671DC;
		  /* 821671DCh */ case    7:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821671DCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821671DCh case    7:*/		return 0x821671E0;
		  /* 821671E0h */ case    8:  		/* mr R3, R15 */
		/* 821671E0h case    8:*/		regs.R3 = regs.R15;
		/* 821671E0h case    8:*/		return 0x821671E4;
		  /* 821671E4h */ case    9:  		/* rlwinm R4, R10, 0, 17, 31 */
		/* 821671E4h case    9:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R4,regs.R10);
		/* 821671E4h case    9:*/		return 0x821671E8;
		  /* 821671E8h */ case   10:  		/* mulli R10, R4, 40 */
		/* 821671E8h case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R4,0x28);
		/* 821671E8h case   10:*/		return 0x821671EC;
		  /* 821671ECh */ case   11:  		/* add R11, R10, R11 */
		/* 821671ECh case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821671ECh case   11:*/		return 0x821671F0;
		  /* 821671F0h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 821671F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821671F0h case   12:*/		return 0x821671F4;
		  /* 821671F4h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 4 */
		/* 821671F4h case   13:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R11);
		/* 821671F4h case   13:*/		return 0x821671F8;
		  /* 821671F8h */ case   14:  		/* bc 12, CR0_EQ, 24 */
		/* 821671F8h case   14:*/		if ( regs.CR[0].eq ) { return 0x82167210;  }
		/* 821671F8h case   14:*/		return 0x821671FC;
		  /* 821671FCh */ case   15:  		/* bl 546884 */
		/* 821671FCh case   15:*/		regs.LR = 0x82167200; return 0x821ECA40;
		/* 821671FCh case   15:*/		return 0x82167200;
		  /* 82167200h */ case   16:  		/* mr R5, R3 */
		/* 82167200h case   16:*/		regs.R5 = regs.R3;
		/* 82167200h case   16:*/		return 0x82167204;
		  /* 82167204h */ case   17:  		/* li R4, 3507 */
		/* 82167204h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0xDB3);
		/* 82167204h case   17:*/		return 0x82167208;
		  /* 82167208h */ case   18:  		/* mr R3, R15 */
		/* 82167208h case   18:*/		regs.R3 = regs.R15;
		/* 82167208h case   18:*/		return 0x8216720C;
		  /* 8216720Ch */ case   19:  		/* bl -86948 */
		/* 8216720Ch case   19:*/		regs.LR = 0x82167210; return 0x82151E68;
		/* 8216720Ch case   19:*/		return 0x82167210;
	}
	return 0x82167210;
} // Block from 821671C0h-82167210h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82167210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167210);
		  /* 82167210h */ case    0:  		/* bl 546864 */
		/* 82167210h case    0:*/		regs.LR = 0x82167214; return 0x821ECA40;
		/* 82167210h case    0:*/		return 0x82167214;
		  /* 82167214h */ case    1:  		/* mr R5, R3 */
		/* 82167214h case    1:*/		regs.R5 = regs.R3;
		/* 82167214h case    1:*/		return 0x82167218;
		  /* 82167218h */ case    2:  		/* li R4, 3527 */
		/* 82167218h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xDC7);
		/* 82167218h case    2:*/		return 0x8216721C;
		  /* 8216721Ch */ case    3:  		/* mr R3, R15 */
		/* 8216721Ch case    3:*/		regs.R3 = regs.R15;
		/* 8216721Ch case    3:*/		return 0x82167220;
		  /* 82167220h */ case    4:  		/* bl -86968 */
		/* 82167220h case    4:*/		regs.LR = 0x82167224; return 0x82151E68;
		/* 82167220h case    4:*/		return 0x82167224;
	}
	return 0x82167224;
} // Block from 82167210h-82167224h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167224);
		  /* 82167224h */ case    0:  		/* li R4, 4800 */
		/* 82167224h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167224h case    0:*/		return 0x82167228;
		  /* 82167228h */ case    1:  		/* mr R3, R15 */
		/* 82167228h case    1:*/		regs.R3 = regs.R15;
		/* 82167228h case    1:*/		return 0x8216722C;
		  /* 8216722Ch */ case    2:  		/* bl -86980 */
		/* 8216722Ch case    2:*/		regs.LR = 0x82167230; return 0x82151E68;
		/* 8216722Ch case    2:*/		return 0x82167230;
	}
	return 0x82167230;
} // Block from 82167224h-82167230h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82167230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167230);
		  /* 82167230h */ case    0:  		/* li R4, 4800 */
		/* 82167230h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167230h case    0:*/		return 0x82167234;
		  /* 82167234h */ case    1:  		/* mr R3, R15 */
		/* 82167234h case    1:*/		regs.R3 = regs.R15;
		/* 82167234h case    1:*/		return 0x82167238;
		  /* 82167238h */ case    2:  		/* bl -86992 */
		/* 82167238h case    2:*/		regs.LR = 0x8216723C; return 0x82151E68;
		/* 82167238h case    2:*/		return 0x8216723C;
	}
	return 0x8216723C;
} // Block from 82167230h-8216723Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216723Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216723C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216723C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216723C);
		  /* 8216723Ch */ case    0:  		/* lis R11, -32252 */
		/* 8216723Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8216723Ch case    0:*/		return 0x82167240;
		  /* 82167240h */ case    1:  		/* li R4, 3500 */
		/* 82167240h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 82167240h case    1:*/		return 0x82167244;
		  /* 82167244h */ case    2:  		/* addi R5, R11, -17416 */
		/* 82167244h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBBF8);
		/* 82167244h case    2:*/		return 0x82167248;
		  /* 82167248h */ case    3:  		/* mr R3, R15 */
		/* 82167248h case    3:*/		regs.R3 = regs.R15;
		/* 82167248h case    3:*/		return 0x8216724C;
		  /* 8216724Ch */ case    4:  		/* bl -87012 */
		/* 8216724Ch case    4:*/		regs.LR = 0x82167250; return 0x82151E68;
		/* 8216724Ch case    4:*/		return 0x82167250;
	}
	return 0x82167250;
} // Block from 8216723Ch-82167250h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167250);
		  /* 82167250h */ case    0:  		/* lwz R11, <#[R15 + 4]> */
		/* 82167250h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 82167250h case    0:*/		return 0x82167254;
		  /* 82167254h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82167254h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82167254h case    1:*/		return 0x82167258;
		  /* 82167258h */ case    2:  		/* bc 4, CR0_EQ, 156 */
		/* 82167258h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821672F4;  }
		/* 82167258h case    2:*/		return 0x8216725C;
		  /* 8216725Ch */ case    3:  		/* lwz R11, <#[R15]> */
		/* 8216725Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8216725Ch case    3:*/		return 0x82167260;
		  /* 82167260h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82167260h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82167260h case    4:*/		return 0x82167264;
		  /* 82167264h */ case    5:  		/* addi R11, R11, -4 */
		/* 82167264h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82167264h case    5:*/		return 0x82167268;
		  /* 82167268h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82167268h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82167268h case    6:*/		return 0x8216726C;
		  /* 8216726Ch */ case    7:  		/* mr R30, R11 */
		/* 8216726Ch case    7:*/		regs.R30 = regs.R11;
		/* 8216726Ch case    7:*/		return 0x82167270;
		  /* 82167270h */ case    8:  		/* bc 12, CR0_EQ, 172 */
		/* 82167270h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216731C;  }
		/* 82167270h case    8:*/		return 0x82167274;
		  /* 82167274h */ case    9:  		/* lwz R11, <#[R11 + 28]> */
		/* 82167274h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82167274h case    9:*/		return 0x82167278;
		  /* 82167278h */ case   10:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82167278h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82167278h case   10:*/		return 0x8216727C;
		  /* 8216727Ch */ case   11:  		/* bc 4, CR0_EQ, 96 */
		/* 8216727Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x821672DC;  }
		/* 8216727Ch case   11:*/		return 0x82167280;
		  /* 82167280h */ case   12:  		/* lwz R11, <#[R30 + 24]> */
		/* 82167280h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82167280h case   12:*/		return 0x82167284;
		  /* 82167284h */ case   13:  		/* b 76 */
		/* 82167284h case   13:*/		return 0x821672D0;
		/* 82167284h case   13:*/		return 0x82167288;
		  /* 82167288h */ case   14:  		/* mr R3, R31 */
		/* 82167288h case   14:*/		regs.R3 = regs.R31;
		/* 82167288h case   14:*/		return 0x8216728C;
		  /* 8216728Ch */ case   15:  		/* bl -12532 */
		/* 8216728Ch case   15:*/		regs.LR = 0x82167290; return 0x82164198;
		/* 8216728Ch case   15:*/		return 0x82167290;
		  /* 82167290h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167290h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167290h case   16:*/		return 0x82167294;
		  /* 82167294h */ case   17:  		/* bc 12, CR0_EQ, 44 */
		/* 82167294h case   17:*/		if ( regs.CR[0].eq ) { return 0x821672C0;  }
		/* 82167294h case   17:*/		return 0x82167298;
		  /* 82167298h */ case   18:  		/* lwz R11, <#[R31 + 8]> */
		/* 82167298h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82167298h case   18:*/		return 0x8216729C;
		  /* 8216729Ch */ case   19:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216729Ch case   19:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216729Ch case   19:*/		return 0x821672A0;
		  /* 821672A0h */ case   20:  		/* cmplwi CR6, R11, 1 */
		/* 821672A0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821672A0h case   20:*/		return 0x821672A4;
		  /* 821672A4h */ case   21:  		/* bc 12, CR6_LT, 16 */
		/* 821672A4h case   21:*/		if ( regs.CR[6].lt ) { return 0x821672B4;  }
		/* 821672A4h case   21:*/		return 0x821672A8;
		  /* 821672A8h */ case   22:  		/* cmplwi CR6, R11, 102 */
		/* 821672A8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821672A8h case   22:*/		return 0x821672AC;
		  /* 821672ACh */ case   23:  		/* mr R11, R22 */
		/* 821672ACh case   23:*/		regs.R11 = regs.R22;
		/* 821672ACh case   23:*/		return 0x821672B0;
		  /* 821672B0h */ case   24:  		/* bc 4, CR6_GT, 8 */
		/* 821672B0h case   24:*/		if ( !regs.CR[6].gt ) { return 0x821672B8;  }
		/* 821672B0h case   24:*/		return 0x821672B4;
	}
	return 0x821672B4;
} // Block from 82167250h-821672B4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821672B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672B4);
		  /* 821672B4h */ case    0:  		/* mr R11, R23 */
		/* 821672B4h case    0:*/		regs.R11 = regs.R23;
		/* 821672B4h case    0:*/		return 0x821672B8;
	}
	return 0x821672B8;
} // Block from 821672B4h-821672B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821672B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672B8);
		  /* 821672B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821672B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821672B8h case    0:*/		return 0x821672BC;
		  /* 821672BCh */ case    1:  		/* bc 4, CR0_EQ, 64 */
		/* 821672BCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821672FC;  }
		/* 821672BCh case    1:*/		return 0x821672C0;
	}
	return 0x821672C0;
} // Block from 821672B8h-821672C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821672C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672C0);
		  /* 821672C0h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821672C0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821672C0h case    0:*/		return 0x821672C4;
		  /* 821672C4h */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 821672C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821672C4h case    1:*/		return 0x821672C8;
		  /* 821672C8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821672C8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821672C8h case    2:*/		return 0x821672CC;
		  /* 821672CCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821672CCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821672DC;  }
		/* 821672CCh case    3:*/		return 0x821672D0;
	}
	return 0x821672D0;
} // Block from 821672C0h-821672D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821672D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672D0);
		  /* 821672D0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821672D0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821672D0h case    0:*/		return 0x821672D4;
		  /* 821672D4h */ case    1:  		/* addic. R31, R11, -40 */
		/* 821672D4h case    1:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821672D4h case    1:*/		return 0x821672D8;
		  /* 821672D8h */ case    2:  		/* bc 4, CR0_EQ, -80 */
		/* 821672D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82167288;  }
		/* 821672D8h case    2:*/		return 0x821672DC;
	}
	return 0x821672DC;
} // Block from 821672D0h-821672DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821672DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672DC);
		  /* 821672DCh */ case    0:  		/* cmplw CR6, R30, R25 */
		/* 821672DCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R25);
		/* 821672DCh case    0:*/		return 0x821672E0;
		  /* 821672E0h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821672E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821672F4;  }
		/* 821672E0h case    1:*/		return 0x821672E4;
		  /* 821672E4h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821672E4h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821672E4h case    2:*/		return 0x821672E8;
	}
	return 0x821672E8;
} // Block from 821672DCh-821672E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821672E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672E8);
		  /* 821672E8h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821672E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821672E8h case    0:*/		return 0x821672EC;
		  /* 821672ECh */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821672ECh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821672ECh case    1:*/		return 0x821672F0;
		  /* 821672F0h */ case    2:  		/* bc 12, CR0_EQ, -144 */
		/* 821672F0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82167260;  }
		/* 821672F0h case    2:*/		return 0x821672F4;
	}
	return 0x821672F4;
} // Block from 821672E8h-821672F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821672F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672F4);
		  /* 821672F4h */ case    0:  		/* mr R11, R23 */
		/* 821672F4h case    0:*/		regs.R11 = regs.R23;
		/* 821672F4h case    0:*/		return 0x821672F8;
		  /* 821672F8h */ case    1:  		/* b -144 */
		/* 821672F8h case    1:*/		return 0x82167268;
		/* 821672F8h case    1:*/		return 0x821672FC;
	}
	return 0x821672FC;
} // Block from 821672F4h-821672FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821672FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821672FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821672FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821672FC);
		  /* 821672FCh */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 821672FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821672FCh case    0:*/		return 0x82167300;
		  /* 82167300h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167300h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167300h case    1:*/		return 0x82167304;
		  /* 82167304h */ case    2:  		/* rlwinm R4, R11, 0, 20, 31 */
		/* 82167304h case    2:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R4,regs.R11);
		/* 82167304h case    2:*/		return 0x82167308;
		  /* 82167308h */ case    3:  		/* bl -1036392 */
		/* 82167308h case    3:*/		regs.LR = 0x8216730C; return 0x8206A2A0;
		/* 82167308h case    3:*/		return 0x8216730C;
		  /* 8216730Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8216730Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216730Ch case    4:*/		return 0x82167310;
		  /* 82167310h */ case    5:  		/* rlwinm R10, R11, 20, 29, 31 */
		/* 82167310h case    5:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R10,regs.R11);
		/* 82167310h case    5:*/		return 0x82167314;
		  /* 82167314h */ case    6:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82167314h case    6:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82167314h case    6:*/		return 0x82167318;
		  /* 82167318h */ case    7:  		/* add R29, R10, R11 */
		/* 82167318h case    7:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 82167318h case    7:*/		return 0x8216731C;
	}
	return 0x8216731C;
} // Block from 821672FCh-8216731Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216731Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216731C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216731C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216731C);
		  /* 8216731Ch */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 8216731Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 8216731Ch case    0:*/		return 0x82167320;
		  /* 82167320h */ case    1:  		/* bl -1021216 */
		/* 82167320h case    1:*/		regs.LR = 0x82167324; return 0x8206DE00;
		/* 82167320h case    1:*/		return 0x82167324;
		  /* 82167324h */ case    2:  		/* lwz R6, <#[R15 + 808]> */
		/* 82167324h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R15 + 0x00000328) );
		/* 82167324h case    2:*/		return 0x82167328;
		  /* 82167328h */ case    3:  		/* addi R11, R3, 1 */
		/* 82167328h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82167328h case    3:*/		return 0x8216732C;
		  /* 8216732Ch */ case    4:  		/* cmplwi CR6, R6, 0 */
		/* 8216732Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8216732Ch case    4:*/		return 0x82167330;
		  /* 82167330h */ case    5:  		/* rlwinm R10, R11, 31, 1, 31 */
		/* 82167330h case    5:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R11);
		/* 82167330h case    5:*/		return 0x82167334;
		  /* 82167334h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82167334h case    6:*/		if ( regs.CR[6].eq ) { return 0x82167340;  }
		/* 82167334h case    6:*/		return 0x82167338;
		  /* 82167338h */ case    7:  		/* mr R11, R6 */
		/* 82167338h case    7:*/		regs.R11 = regs.R6;
		/* 82167338h case    7:*/		return 0x8216733C;
		  /* 8216733Ch */ case    8:  		/* b 28 */
		/* 8216733Ch case    8:*/		return 0x82167358;
		/* 8216733Ch case    8:*/		return 0x82167340;
	}
	return 0x82167340;
} // Block from 8216731Ch-82167340h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82167340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167340);
		  /* 82167340h */ case    0:  		/* lwz R11, <#[R15 + 48]> */
		/* 82167340h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000030) );
		/* 82167340h case    0:*/		return 0x82167344;
		  /* 82167344h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82167344h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82167344h case    1:*/		return 0x82167348;
		  /* 82167348h */ case    2:  		/* subf R11, R17, R11 */
		/* 82167348h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R17,regs.R11);
		/* 82167348h case    2:*/		return 0x8216734C;
		  /* 8216734Ch */ case    3:  		/* cntlzw R11, R11 */
		/* 8216734Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8216734Ch case    3:*/		return 0x82167350;
		  /* 82167350h */ case    4:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82167350h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82167350h case    4:*/		return 0x82167354;
		  /* 82167354h */ case    5:  		/* addi R11, R11, 2046 */
		/* 82167354h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7FE);
		/* 82167354h case    5:*/		return 0x82167358;
	}
	return 0x82167358;
} // Block from 82167340h-82167358h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82167358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167358);
		  /* 82167358h */ case    0:  		/* add R5, R10, R29 */
		/* 82167358h case    0:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R29);
		/* 82167358h case    0:*/		return 0x8216735C;
		  /* 8216735Ch */ case    1:  		/* cmplw CR6, R5, R11 */
		/* 8216735Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 8216735Ch case    1:*/		return 0x82167360;
		  /* 82167360h */ case    2:  		/* bc 4, CR6_GT, 32 */
		/* 82167360h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82167380;  }
		/* 82167360h case    2:*/		return 0x82167364;
		  /* 82167364h */ case    3:  		/* cmplwi CR6, R6, 0 */
		/* 82167364h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82167364h case    3:*/		return 0x82167368;
		  /* 82167368h */ case    4:  		/* mr R3, R15 */
		/* 82167368h case    4:*/		regs.R3 = regs.R15;
		/* 82167368h case    4:*/		return 0x8216736C;
		  /* 8216736Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8216736Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82167378;  }
		/* 8216736Ch case    5:*/		return 0x82167370;
		  /* 82167370h */ case    6:  		/* li R4, 3617 */
		/* 82167370h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xE21);
		/* 82167370h case    6:*/		return 0x82167374;
		  /* 82167374h */ case    7:  		/* bl -87308 */
		/* 82167374h case    7:*/		regs.LR = 0x82167378; return 0x82151E68;
		/* 82167374h case    7:*/		return 0x82167378;
	}
	return 0x82167378;
} // Block from 82167358h-82167378h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82167378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167378);
		  /* 82167378h */ case    0:  		/* li R4, 3641 */
		/* 82167378h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE39);
		/* 82167378h case    0:*/		return 0x8216737C;
		  /* 8216737Ch */ case    1:  		/* bl -87316 */
		/* 8216737Ch case    1:*/		regs.LR = 0x82167380; return 0x82151E68;
		/* 8216737Ch case    1:*/		return 0x82167380;
	}
	return 0x82167380;
} // Block from 82167378h-82167380h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167380);
		  /* 82167380h */ case    0:  		/* mr R31, R24 */
		/* 82167380h case    0:*/		regs.R31 = regs.R24;
		/* 82167380h case    0:*/		return 0x82167384;
		  /* 82167384h */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 82167384h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82167384h case    1:*/		return 0x82167388;
		  /* 82167388h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 82167388h case    2:*/		if ( regs.CR[6].eq ) { return 0x821673C8;  }
		/* 82167388h case    2:*/		return 0x8216738C;
		  /* 8216738Ch */ case    3:  		/* lwz R4, <#[R31]> */
		/* 8216738Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8216738Ch case    3:*/		return 0x82167390;
		  /* 82167390h */ case    4:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167390h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167390h case    4:*/		return 0x82167394;
		  /* 82167394h */ case    5:  		/* bl -1036532 */
		/* 82167394h case    5:*/		regs.LR = 0x82167398; return 0x8206A2A0;
		/* 82167394h case    5:*/		return 0x82167398;
		  /* 82167398h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 82167398h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82167398h case    6:*/		return 0x8216739C;
		  /* 8216739Ch */ case    7:  		/* rlwinm R11, R11, 0, 18, 15 */
		/* 8216739Ch case    7:*/		cpu::op::rlwinm<0,0,18,15>(regs,&regs.R11,regs.R11);
		/* 8216739Ch case    7:*/		return 0x821673A0;
		  /* 821673A0h */ case    8:  		/* ori R11, R11, 13312 */
		/* 821673A0h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3400);
		/* 821673A0h case    8:*/		return 0x821673A4;
		  /* 821673A4h */ case    9:  		/* stw R11, <#[R3 + 4]> */
		/* 821673A4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821673A4h case    9:*/		return 0x821673A8;
		  /* 821673A8h */ case   10:  		/* lwz R10, <#[R31 + 4]> */
		/* 821673A8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821673A8h case   10:*/		return 0x821673AC;
		  /* 821673ACh */ case   11:  		/* lwz R10, <#[R10 + 44]> */
		/* 821673ACh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000002C) );
		/* 821673ACh case   11:*/		return 0x821673B0;
		  /* 821673B0h */ case   12:  		/* lwz R10, <#[R10]> */
		/* 821673B0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821673B0h case   12:*/		return 0x821673B4;
		  /* 821673B4h */ case   13:  		/* rlwimi R11, R10, 17, 22, 29 */
		/* 821673B4h case   13:*/		cpu::op::rlwimi<0,17,22,29>(regs,&regs.R11,regs.R10);
		/* 821673B4h case   13:*/		return 0x821673B8;
		  /* 821673B8h */ case   14:  		/* stw R11, <#[R3 + 4]> */
		/* 821673B8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821673B8h case   14:*/		return 0x821673BC;
		  /* 821673BCh */ case   15:  		/* lwz R31, <#[R31 + 8]> */
		/* 821673BCh case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 821673BCh case   15:*/		return 0x821673C0;
		  /* 821673C0h */ case   16:  		/* cmplwi CR6, R31, 0 */
		/* 821673C0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821673C0h case   16:*/		return 0x821673C4;
		  /* 821673C4h */ case   17:  		/* bc 4, CR6_EQ, -56 */
		/* 821673C4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8216738C;  }
		/* 821673C4h case   17:*/		return 0x821673C8;
	}
	return 0x821673C8;
} // Block from 82167380h-821673C8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821673C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821673C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821673C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821673C8);
		  /* 821673C8h */ case    0:  		/* rlwinm. R11, R20, 0, 24, 31 */
		/* 821673C8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R20);
		/* 821673C8h case    0:*/		return 0x821673CC;
		  /* 821673CCh */ case    1:  		/* bc 12, CR0_EQ, 260 */
		/* 821673CCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821674D0;  }
		/* 821673CCh case    1:*/		return 0x821673D0;
		  /* 821673D0h */ case    2:  		/* mr R30, R25 */
		/* 821673D0h case    2:*/		regs.R30 = regs.R25;
		/* 821673D0h case    2:*/		return 0x821673D4;
		  /* 821673D4h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 821673D4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821673D4h case    3:*/		return 0x821673D8;
		  /* 821673D8h */ case    4:  		/* bc 12, CR6_EQ, 248 */
		/* 821673D8h case    4:*/		if ( regs.CR[6].eq ) { return 0x821674D0;  }
		/* 821673D8h case    4:*/		return 0x821673DC;
		  /* 821673DCh */ case    5:  		/* cmplw CR6, R30, R25 */
		/* 821673DCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R25);
		/* 821673DCh case    5:*/		return 0x821673E0;
		  /* 821673E0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821673E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821673F0;  }
		/* 821673E0h case    6:*/		return 0x821673E4;
		  /* 821673E4h */ case    7:  		/* lwz R11, <#[R30 + 76]> */
		/* 821673E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 821673E4h case    7:*/		return 0x821673E8;
		  /* 821673E8h */ case    8:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 821673E8h case    8:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 821673E8h case    8:*/		return 0x821673EC;
		  /* 821673ECh */ case    9:  		/* bc 4, CR0_EQ, 228 */
		/* 821673ECh case    9:*/		if ( !regs.CR[0].eq ) { return 0x821674D0;  }
		/* 821673ECh case    9:*/		return 0x821673F0;
	}
	return 0x821673F0;
} // Block from 821673C8h-821673F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821673F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821673F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821673F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821673F0);
		  /* 821673F0h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 821673F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821673F0h case    0:*/		return 0x821673F4;
		  /* 821673F4h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821673F4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821673F4h case    1:*/		return 0x821673F8;
		  /* 821673F8h */ case    2:  		/* bc 4, CR0_EQ, 188 */
		/* 821673F8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821674B4;  }
		/* 821673F8h case    2:*/		return 0x821673FC;
		  /* 821673FCh */ case    3:  		/* mr R31, R11 */
		/* 821673FCh case    3:*/		regs.R31 = regs.R11;
		/* 821673FCh case    3:*/		return 0x82167400;
		  /* 82167400h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 82167400h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82167400h case    4:*/		return 0x82167404;
		  /* 82167404h */ case    5:  		/* bc 12, CR0_EQ, 176 */
		/* 82167404h case    5:*/		if ( regs.CR[0].eq ) { return 0x821674B4;  }
		/* 82167404h case    5:*/		return 0x82167408;
		  /* 82167408h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82167408h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82167408h case    6:*/		return 0x8216740C;
		  /* 8216740Ch */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8216740Ch case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8216740Ch case    7:*/		return 0x82167410;
		  /* 82167410h */ case    8:  		/* cmplwi CR6, R11, 86 */
		/* 82167410h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 82167410h case    8:*/		return 0x82167414;
		  /* 82167414h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 82167414h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216743C;  }
		/* 82167414h case    9:*/		return 0x82167418;
		  /* 82167418h */ case   10:  		/* cmplwi CR6, R11, 87 */
		/* 82167418h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 82167418h case   10:*/		return 0x8216741C;
		  /* 8216741Ch */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 8216741Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8216743C;  }
		/* 8216741Ch case   11:*/		return 0x82167420;
		  /* 82167420h */ case   12:  		/* cmplwi CR6, R11, 89 */
		/* 82167420h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000059);
		/* 82167420h case   12:*/		return 0x82167424;
		  /* 82167424h */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 82167424h case   13:*/		if ( regs.CR[6].eq ) { return 0x8216743C;  }
		/* 82167424h case   13:*/		return 0x82167428;
		  /* 82167428h */ case   14:  		/* cmplwi CR6, R11, 90 */
		/* 82167428h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 82167428h case   14:*/		return 0x8216742C;
		  /* 8216742Ch */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 8216742Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8216743C;  }
		/* 8216742Ch case   15:*/		return 0x82167430;
		  /* 82167430h */ case   16:  		/* cmplwi CR6, R11, 84 */
		/* 82167430h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000054);
		/* 82167430h case   16:*/		return 0x82167434;
		  /* 82167434h */ case   17:  		/* mr R11, R23 */
		/* 82167434h case   17:*/		regs.R11 = regs.R23;
		/* 82167434h case   17:*/		return 0x82167438;
		  /* 82167438h */ case   18:  		/* bc 4, CR6_EQ, 8 */
		/* 82167438h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82167440;  }
		/* 82167438h case   18:*/		return 0x8216743C;
	}
	return 0x8216743C;
} // Block from 821673F0h-8216743Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216743Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216743C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216743C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216743C);
		  /* 8216743Ch */ case    0:  		/* mr R11, R22 */
		/* 8216743Ch case    0:*/		regs.R11 = regs.R22;
		/* 8216743Ch case    0:*/		return 0x82167440;
	}
	return 0x82167440;
} // Block from 8216743Ch-82167440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167440);
		  /* 82167440h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167440h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167440h case    0:*/		return 0x82167444;
		  /* 82167444h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 82167444h case    1:*/		if ( regs.CR[0].eq ) { return 0x82167498;  }
		/* 82167444h case    1:*/		return 0x82167448;
		  /* 82167448h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82167448h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82167448h case    2:*/		return 0x8216744C;
		  /* 8216744Ch */ case    3:  		/* mr R3, R15 */
		/* 8216744Ch case    3:*/		regs.R3 = regs.R15;
		/* 8216744Ch case    3:*/		return 0x82167450;
		  /* 82167450h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 82167450h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 82167450h case    4:*/		return 0x82167454;
		  /* 82167454h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 82167454h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 82167454h case    5:*/		return 0x82167458;
		  /* 82167458h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 82167458h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 82167458h case    6:*/		return 0x8216745C;
		  /* 8216745Ch */ case    7:  		/* bl -12332 */
		/* 8216745Ch case    7:*/		regs.LR = 0x82167460; return 0x82164430;
		/* 8216745Ch case    7:*/		return 0x82167460;
		  /* 82167460h */ case    8:  		/* addi R11, R31, -16 */
		/* 82167460h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 82167460h case    8:*/		return 0x82167464;
		  /* 82167464h */ case    9:  		/* lwz R10, <#[R15 + 768]> */
		/* 82167464h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000300) );
		/* 82167464h case    9:*/		return 0x82167468;
		  /* 82167468h */ case   10:  		/* add R29, R3, R11 */
		/* 82167468h case   10:*/		cpu::op::add<0>(regs,&regs.R29,regs.R3,regs.R11);
		/* 82167468h case   10:*/		return 0x8216746C;
		  /* 8216746Ch */ case   11:  		/* mr R3, R10 */
		/* 8216746Ch case   11:*/		regs.R3 = regs.R10;
		/* 8216746Ch case   11:*/		return 0x82167470;
		  /* 82167470h */ case   12:  		/* lwz R4, <#[R29 + 4]> */
		/* 82167470h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000004) );
		/* 82167470h case   12:*/		return 0x82167474;
		  /* 82167474h */ case   13:  		/* bl -1036756 */
		/* 82167474h case   13:*/		regs.LR = 0x82167478; return 0x8206A2A0;
		/* 82167474h case   13:*/		return 0x82167478;
		  /* 82167478h */ case   14:  		/* lwz R11, <#[R29]> */
		/* 82167478h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82167478h case   14:*/		return 0x8216747C;
		  /* 8216747Ch */ case   15:  		/* lwz R10, <#[R3]> */
		/* 8216747Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8216747Ch case   15:*/		return 0x82167480;
		  /* 82167480h */ case   16:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 82167480h case   16:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 82167480h case   16:*/		return 0x82167484;
		  /* 82167484h */ case   17:  		/* rlwinm R10, R10, 0, 0, 18 */
		/* 82167484h case   17:*/		cpu::op::rlwinm<0,0,0,18>(regs,&regs.R10,regs.R10);
		/* 82167484h case   17:*/		return 0x82167488;
		  /* 82167488h */ case   18:  		/* lwz R11, <#[R11 + 20]> */
		/* 82167488h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82167488h case   18:*/		return 0x8216748C;
		  /* 8216748Ch */ case   19:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 8216748Ch case   19:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8216748Ch case   19:*/		return 0x82167490;
		  /* 82167490h */ case   20:  		/* or R11, R11, R10 */
		/* 82167490h case   20:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82167490h case   20:*/		return 0x82167494;
		  /* 82167494h */ case   21:  		/* stw R11, <#[R3]> */
		/* 82167494h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82167494h case   21:*/		return 0x82167498;
	}
	return 0x82167498;
} // Block from 82167440h-82167498h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82167498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167498);
		  /* 82167498h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82167498h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82167498h case    0:*/		return 0x8216749C;
		  /* 8216749Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216749Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216749Ch case    1:*/		return 0x821674A0;
		  /* 821674A0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821674A0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821674A0h case    2:*/		return 0x821674A4;
		  /* 821674A4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821674A4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821674B4;  }
		/* 821674A4h case    3:*/		return 0x821674A8;
		  /* 821674A8h */ case    4:  		/* mr R31, R11 */
		/* 821674A8h case    4:*/		regs.R31 = regs.R11;
		/* 821674A8h case    4:*/		return 0x821674AC;
		  /* 821674ACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821674ACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821674ACh case    5:*/		return 0x821674B0;
		  /* 821674B0h */ case    6:  		/* bc 4, CR6_EQ, -168 */
		/* 821674B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82167408;  }
		/* 821674B0h case    6:*/		return 0x821674B4;
	}
	return 0x821674B4;
} // Block from 82167498h-821674B4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821674B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821674B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821674B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821674B4);
		  /* 821674B4h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821674B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821674B4h case    0:*/		return 0x821674B8;
		  /* 821674B8h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821674B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821674B8h case    1:*/		return 0x821674BC;
		  /* 821674BCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821674BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821674BCh case    2:*/		return 0x821674C0;
		  /* 821674C0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821674C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821674D0;  }
		/* 821674C0h case    3:*/		return 0x821674C4;
		  /* 821674C4h */ case    4:  		/* mr R30, R11 */
		/* 821674C4h case    4:*/		regs.R30 = regs.R11;
		/* 821674C4h case    4:*/		return 0x821674C8;
		  /* 821674C8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821674C8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821674C8h case    5:*/		return 0x821674CC;
		  /* 821674CCh */ case    6:  		/* bc 4, CR6_EQ, -240 */
		/* 821674CCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821673DC;  }
		/* 821674CCh case    6:*/		return 0x821674D0;
	}
	return 0x821674D0;
} // Block from 821674B4h-821674D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821674D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821674D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821674D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821674D0);
		  /* 821674D0h */ case    0:  		/* mr R17, R25 */
		/* 821674D0h case    0:*/		regs.R17 = regs.R25;
		/* 821674D0h case    0:*/		return 0x821674D4;
		  /* 821674D4h */ case    1:  		/* stw R25, <#[R1 + 96]> */
		/* 821674D4h case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000060) );
		/* 821674D4h case    1:*/		return 0x821674D8;
		  /* 821674D8h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 821674D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821674D8h case    2:*/		return 0x821674DC;
		  /* 821674DCh */ case    3:  		/* bc 12, CR6_EQ, 2484 */
		/* 821674DCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82167E90;  }
		/* 821674DCh case    3:*/		return 0x821674E0;
		  /* 821674E0h */ case    4:  		/* li R14, 3 */
		/* 821674E0h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x3);
		/* 821674E0h case    4:*/		return 0x821674E4;
		  /* 821674E4h */ case    5:  		/* lwz R11, <#[R1 + 476]> */
		/* 821674E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000001DC) );
		/* 821674E4h case    5:*/		return 0x821674E8;
		  /* 821674E8h */ case    6:  		/* cmplw CR6, R17, R11 */
		/* 821674E8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R11);
		/* 821674E8h case    6:*/		return 0x821674EC;
		  /* 821674ECh */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821674ECh case    7:*/		if ( regs.CR[6].eq ) { return 0x821674FC;  }
		/* 821674ECh case    7:*/		return 0x821674F0;
		  /* 821674F0h */ case    8:  		/* lwz R11, <#[R17 + 76]> */
		/* 821674F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 821674F0h case    8:*/		return 0x821674F4;
		  /* 821674F4h */ case    9:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 821674F4h case    9:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 821674F4h case    9:*/		return 0x821674F8;
		  /* 821674F8h */ case   10:  		/* bc 4, CR0_EQ, 2448 */
		/* 821674F8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82167E88;  }
		/* 821674F8h case   10:*/		return 0x821674FC;
	}
	return 0x821674FC;
} // Block from 821674D0h-821674FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821674FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821674FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821674FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821674FC);
		  /* 821674FCh */ case    0:  		/* lwz R11, <#[R17 + 28]> */
		/* 821674FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000001C) );
		/* 821674FCh case    0:*/		return 0x82167500;
		  /* 82167500h */ case    1:  		/* addi R29, R17, 24 */
		/* 82167500h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R17,0x18);
		/* 82167500h case    1:*/		return 0x82167504;
		  /* 82167504h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82167504h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82167504h case    2:*/		return 0x82167508;
		  /* 82167508h */ case    3:  		/* bc 4, CR0_EQ, 180 */
		/* 82167508h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821675BC;  }
		/* 82167508h case    3:*/		return 0x8216750C;
		  /* 8216750Ch */ case    4:  		/* lwz R11, <#[R29]> */
		/* 8216750Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216750Ch case    4:*/		return 0x82167510;
		  /* 82167510h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82167510h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82167510h case    5:*/		return 0x82167514;
		  /* 82167514h */ case    6:  		/* addic. R11, R11, -40 */
		/* 82167514h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 82167514h case    6:*/		return 0x82167518;
		  /* 82167518h */ case    7:  		/* bc 12, CR0_EQ, 164 */
		/* 82167518h case    7:*/		if ( regs.CR[0].eq ) { return 0x821675BC;  }
		/* 82167518h case    7:*/		return 0x8216751C;
		  /* 8216751Ch */ case    8:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216751Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216751Ch case    8:*/		return 0x82167520;
		  /* 82167520h */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82167520h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82167520h case    9:*/		return 0x82167524;
		  /* 82167524h */ case   10:  		/* cmplwi CR6, R11, 10624 */
		/* 82167524h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002980);
		/* 82167524h case   10:*/		return 0x82167528;
		  /* 82167528h */ case   11:  		/* bc 4, CR6_EQ, 148 */
		/* 82167528h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821675BC;  }
		/* 82167528h case   11:*/		return 0x8216752C;
		  /* 8216752Ch */ case   12:  		/* rlwinm R11, R17, 0, 0, 30 */
		/* 8216752Ch case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R17);
		/* 8216752Ch case   12:*/		return 0x82167530;
		  /* 82167530h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 82167530h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82167530h case   13:*/		return 0x82167534;
		  /* 82167534h */ case   14:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167534h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167534h case   14:*/		return 0x82167538;
		  /* 82167538h */ case   15:  		/* bc 4, CR0_EQ, 48 */
		/* 82167538h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82167568;  }
		/* 82167538h case   15:*/		return 0x8216753C;
		  /* 8216753Ch */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8216753Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216753Ch case   16:*/		return 0x82167540;
		  /* 82167540h */ case   17:  		/* bc 12, CR6_EQ, 40 */
		/* 82167540h case   17:*/		if ( regs.CR[6].eq ) { return 0x82167568;  }
		/* 82167540h case   17:*/		return 0x82167544;
		  /* 82167544h */ case   18:  		/* lwz R10, <#[R11 + 76]> */
		/* 82167544h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 82167544h case   18:*/		return 0x82167548;
		  /* 82167548h */ case   19:  		/* rlwinm R10, R10, 0, 10, 10 */
		/* 82167548h case   19:*/		cpu::op::rlwinm<0,0,10,10>(regs,&regs.R10,regs.R10);
		/* 82167548h case   19:*/		return 0x8216754C;
		  /* 8216754Ch */ case   20:  		/* addic R10, R10, -1 */
		/* 8216754Ch case   20:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216754Ch case   20:*/		return 0x82167550;
		  /* 82167550h */ case   21:  		/* subfe R10, R10, R10 */
		/* 82167550h case   21:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82167550h case   21:*/		return 0x82167554;
		  /* 82167554h */ case   22:  		/* and R3, R10, R11 */
		/* 82167554h case   22:*/		cpu::op::and<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82167554h case   22:*/		return 0x82167558;
		  /* 82167558h */ case   23:  		/* cmplwi CR6, R3, 0 */
		/* 82167558h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82167558h case   23:*/		return 0x8216755C;
		  /* 8216755Ch */ case   24:  		/* bc 12, CR6_EQ, 12 */
		/* 8216755Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x82167568;  }
		/* 8216755Ch case   24:*/		return 0x82167560;
		  /* 82167560h */ case   25:  		/* bl -10048 */
		/* 82167560h case   25:*/		regs.LR = 0x82167564; return 0x82164E20;
		/* 82167560h case   25:*/		return 0x82167564;
		  /* 82167564h */ case   26:  		/* b 12 */
		/* 82167564h case   26:*/		return 0x82167570;
		/* 82167564h case   26:*/		return 0x82167568;
	}
	return 0x82167568;
} // Block from 821674FCh-82167568h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82167568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167568);
		  /* 82167568h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167568h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167568h case    0:*/		return 0x8216756C;
		  /* 8216756Ch */ case    1:  		/* bl -1021804 */
		/* 8216756Ch case    1:*/		regs.LR = 0x82167570; return 0x8206DE00;
		/* 8216756Ch case    1:*/		return 0x82167570;
	}
	return 0x82167570;
} // Block from 82167568h-82167570h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167570);
		  /* 82167570h */ case    0:  		/* addi R4, R3, -1 */
		/* 82167570h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0xFFFFFFFF);
		/* 82167570h case    0:*/		return 0x82167574;
		  /* 82167574h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167574h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167574h case    1:*/		return 0x82167578;
		  /* 82167578h */ case    2:  		/* bl -1037016 */
		/* 82167578h case    2:*/		regs.LR = 0x8216757C; return 0x8206A2A0;
		/* 82167578h case    2:*/		return 0x8216757C;
		  /* 8216757Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8216757Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8216757Ch case    3:*/		return 0x82167580;
		  /* 82167580h */ case    4:  		/* rlwinm R10, R11, 20, 28, 31 */
		/* 82167580h case    4:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R11);
		/* 82167580h case    4:*/		return 0x82167584;
		  /* 82167584h */ case    5:  		/* cmplwi CR6, R10, 2 */
		/* 82167584h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 82167584h case    5:*/		return 0x82167588;
		  /* 82167588h */ case    6:  		/* bc 12, CR6_EQ, 52 */
		/* 82167588h case    6:*/		if ( regs.CR[6].eq ) { return 0x821675BC;  }
		/* 82167588h case    6:*/		return 0x8216758C;
		  /* 8216758Ch */ case    7:  		/* cmplwi CR6, R10, 5 */
		/* 8216758Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 8216758Ch case    7:*/		return 0x82167590;
		  /* 82167590h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 82167590h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821675A4;  }
		/* 82167590h case    8:*/		return 0x82167594;
		  /* 82167594h */ case    9:  		/* mr R10, R22 */
		/* 82167594h case    9:*/		regs.R10 = regs.R22;
		/* 82167594h case    9:*/		return 0x82167598;
		  /* 82167598h */ case   10:  		/* rlwimi R11, R10, 12, 21, 21 */
		/* 82167598h case   10:*/		cpu::op::rlwimi<0,12,21,21>(regs,&regs.R11,regs.R10);
		/* 82167598h case   10:*/		return 0x8216759C;
		  /* 8216759Ch */ case   11:  		/* rlwimi R11, R22, 12, 16, 19 */
		/* 8216759Ch case   11:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R22);
		/* 8216759Ch case   11:*/		return 0x821675A0;
		  /* 821675A0h */ case   12:  		/* stw R11, <#[R3 + 4]> */
		/* 821675A0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821675A0h case   12:*/		return 0x821675A4;
	}
	return 0x821675A4;
} // Block from 82167570h-821675A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821675A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821675A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821675A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821675A4);
		  /* 821675A4h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 821675A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821675A4h case    0:*/		return 0x821675A8;
		  /* 821675A8h */ case    1:  		/* rlwinm R10, R11, 0, 16, 19 */
		/* 821675A8h case    1:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R10,regs.R11);
		/* 821675A8h case    1:*/		return 0x821675AC;
		  /* 821675ACh */ case    2:  		/* cmplwi CR6, R10, 4096 */
		/* 821675ACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00001000);
		/* 821675ACh case    2:*/		return 0x821675B0;
		  /* 821675B0h */ case    3:  		/* bc 4, CR6_EQ, 2312 */
		/* 821675B0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82167EB8;  }
		/* 821675B0h case    3:*/		return 0x821675B4;
		  /* 821675B4h */ case    4:  		/* rlwimi R11, R22, 13, 16, 19 */
		/* 821675B4h case    4:*/		cpu::op::rlwimi<0,13,16,19>(regs,&regs.R11,regs.R22);
		/* 821675B4h case    4:*/		return 0x821675B8;
		  /* 821675B8h */ case    5:  		/* stw R11, <#[R3 + 4]> */
		/* 821675B8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821675B8h case    5:*/		return 0x821675BC;
	}
	return 0x821675BC;
} // Block from 821675A4h-821675BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821675BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821675BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821675BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821675BC);
		  /* 821675BCh */ case    0:  		/* lwz R11, <#[R17 + 48]> */
		/* 821675BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000030) );
		/* 821675BCh case    0:*/		return 0x821675C0;
		  /* 821675C0h */ case    1:  		/* rlwinm. R10, R11, 0, 7, 7 */
		/* 821675C0h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R10,regs.R11);
		/* 821675C0h case    1:*/		return 0x821675C4;
		  /* 821675C4h */ case    2:  		/* bc 12, CR0_EQ, 412 */
		/* 821675C4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82167760;  }
		/* 821675C4h case    2:*/		return 0x821675C8;
		  /* 821675C8h */ case    3:  		/* mr R3, R17 */
		/* 821675C8h case    3:*/		regs.R3 = regs.R17;
		/* 821675C8h case    3:*/		return 0x821675CC;
		  /* 821675CCh */ case    4:  		/* bl -10156 */
		/* 821675CCh case    4:*/		regs.LR = 0x821675D0; return 0x82164E20;
		/* 821675CCh case    4:*/		return 0x821675D0;
		  /* 821675D0h */ case    5:  		/* rlwinm R11, R17, 0, 0, 30 */
		/* 821675D0h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R17);
		/* 821675D0h case    5:*/		return 0x821675D4;
		  /* 821675D4h */ case    6:  		/* mr R29, R3 */
		/* 821675D4h case    6:*/		regs.R29 = regs.R3;
		/* 821675D4h case    6:*/		return 0x821675D8;
		  /* 821675D8h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 821675D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821675D8h case    7:*/		return 0x821675DC;
		  /* 821675DCh */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821675DCh case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821675DCh case    8:*/		return 0x821675E0;
		  /* 821675E0h */ case    9:  		/* bc 12, CR0_EQ, 92 */
		/* 821675E0h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216763C;  }
		/* 821675E0h case    9:*/		return 0x821675E4;
		  /* 821675E4h */ case   10:  		/* mr R31, R23 */
		/* 821675E4h case   10:*/		regs.R31 = regs.R23;
		/* 821675E4h case   10:*/		return 0x821675E8;
		  /* 821675E8h */ case   11:  		/* lwz R3, <#[R15 + 768]> */
		/* 821675E8h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821675E8h case   11:*/		return 0x821675EC;
		  /* 821675ECh */ case   12:  		/* bl -1021932 */
		/* 821675ECh case   12:*/		regs.LR = 0x821675F0; return 0x8206DE00;
		/* 821675ECh case   12:*/		return 0x821675F0;
		  /* 821675F0h */ case   13:  		/* mr R30, R3 */
		/* 821675F0h case   13:*/		regs.R30 = regs.R3;
		/* 821675F0h case   13:*/		return 0x821675F4;
		  /* 821675F4h */ case   14:  		/* b 308 */
		/* 821675F4h case   14:*/		return 0x82167728;
		/* 821675F4h case   14:*/		return 0x821675F8;
		  /* 821675F8h */ case   15:  		/* lwz R11, <#[R31 + 28]> */
		/* 821675F8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821675F8h case   15:*/		return 0x821675FC;
		  /* 821675FCh */ case   16:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821675FCh case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821675FCh case   16:*/		return 0x82167600;
		  /* 82167600h */ case   17:  		/* bc 4, CR0_EQ, 2244 */
		/* 82167600h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82167EC4;  }
		/* 82167600h case   17:*/		return 0x82167604;
		  /* 82167604h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 82167604h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82167604h case   18:*/		return 0x82167608;
		  /* 82167608h */ case   19:  		/* bc 12, CR0_EQ, 2236 */
		/* 82167608h case   19:*/		if ( regs.CR[0].eq ) { return 0x82167EC4;  }
		/* 82167608h case   19:*/		return 0x8216760C;
		  /* 8216760Ch */ case   20:  		/* lwz R10, <#[R11 + 8]> */
		/* 8216760Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8216760Ch case   20:*/		return 0x82167610;
		  /* 82167610h */ case   21:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82167610h case   21:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82167610h case   21:*/		return 0x82167614;
		  /* 82167614h */ case   22:  		/* cmplwi CR6, R10, 16128 */
		/* 82167614h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003F00);
		/* 82167614h case   22:*/		return 0x82167618;
		  /* 82167618h */ case   23:  		/* bc 4, CR6_EQ, 2220 */
		/* 82167618h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82167EC4;  }
		/* 82167618h case   23:*/		return 0x8216761C;
		  /* 8216761Ch */ case   24:  		/* lhz R11, <#[R11 + 20]> */
		/* 8216761Ch case   24:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8216761Ch case   24:*/		return 0x82167620;
		  /* 82167620h */ case   25:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82167620h case   25:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82167620h case   25:*/		return 0x82167624;
		  /* 82167624h */ case   26:  		/* bc 4, CR0_EQ, 44 */
		/* 82167624h case   26:*/		if ( !regs.CR[0].eq ) { return 0x82167650;  }
		/* 82167624h case   26:*/		return 0x82167628;
		  /* 82167628h */ case   27:  		/* lwz R11, <#[R31 + 76]> */
		/* 82167628h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 82167628h case   27:*/		return 0x8216762C;
		  /* 8216762Ch */ case   28:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 8216762Ch case   28:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 8216762Ch case   28:*/		return 0x82167630;
		  /* 82167630h */ case   29:  		/* bc 4, CR0_EQ, 28 */
		/* 82167630h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8216764C;  }
		/* 82167630h case   29:*/		return 0x82167634;
		  /* 82167634h */ case   30:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82167634h case   30:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82167634h case   30:*/		return 0x82167638;
		  /* 82167638h */ case   31:  		/* b -96 */
		/* 82167638h case   31:*/		return 0x821675D8;
		/* 82167638h case   31:*/		return 0x8216763C;
	}
	return 0x8216763C;
} // Block from 821675BCh-8216763Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 8216763Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216763C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216763C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216763C);
		  /* 8216763Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8216763Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216763Ch case    0:*/		return 0x82167640;
		  /* 82167640h */ case    1:  		/* mr R31, R11 */
		/* 82167640h case    1:*/		regs.R31 = regs.R11;
		/* 82167640h case    1:*/		return 0x82167644;
		  /* 82167644h */ case    2:  		/* bc 4, CR6_EQ, -76 */
		/* 82167644h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821675F8;  }
		/* 82167644h case    2:*/		return 0x82167648;
		  /* 82167648h */ case    3:  		/* b -96 */
		/* 82167648h case    3:*/		return 0x821675E8;
		/* 82167648h case    3:*/		return 0x8216764C;
	}
	return 0x8216764C;
} // Block from 8216763Ch-8216764Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216764Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216764C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216764C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216764C);
		  /* 8216764Ch */ case    0:  		/* mr R31, R23 */
		/* 8216764Ch case    0:*/		regs.R31 = regs.R23;
		/* 8216764Ch case    0:*/		return 0x82167650;
	}
	return 0x82167650;
} // Block from 8216764Ch-82167650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167650);
		  /* 82167650h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82167650h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82167650h case    0:*/		return 0x82167654;
		  /* 82167654h */ case    1:  		/* bc 12, CR6_EQ, -108 */
		/* 82167654h case    1:*/		if ( regs.CR[6].eq ) { return 0x821675E8;  }
		/* 82167654h case    1:*/		return 0x82167658;
		  /* 82167658h */ case    2:  		/* mr R3, R31 */
		/* 82167658h case    2:*/		regs.R3 = regs.R31;
		/* 82167658h case    2:*/		return 0x8216765C;
		  /* 8216765Ch */ case    3:  		/* bl -10300 */
		/* 8216765Ch case    3:*/		regs.LR = 0x82167660; return 0x82164E20;
		/* 8216765Ch case    3:*/		return 0x82167660;
		  /* 82167660h */ case    4:  		/* b -112 */
		/* 82167660h case    4:*/		return 0x821675F0;
		/* 82167660h case    4:*/		return 0x82167664;
		  /* 82167664h */ case    5:  		/* mr R4, R29 */
		/* 82167664h case    5:*/		regs.R4 = regs.R29;
		/* 82167664h case    5:*/		return 0x82167668;
		  /* 82167668h */ case    6:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167668h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167668h case    6:*/		return 0x8216766C;
		  /* 8216766Ch */ case    7:  		/* bl -1037260 */
		/* 8216766Ch case    7:*/		regs.LR = 0x82167670; return 0x8206A2A0;
		/* 8216766Ch case    7:*/		return 0x82167670;
		  /* 82167670h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 82167670h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82167670h case    8:*/		return 0x82167674;
		  /* 82167674h */ case    9:  		/* rlwinm R10, R11, 20, 28, 31 */
		/* 82167674h case    9:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R11);
		/* 82167674h case    9:*/		return 0x82167678;
		  /* 82167678h */ case   10:  		/* cmplwi CR6, R10, 1 */
		/* 82167678h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82167678h case   10:*/		return 0x8216767C;
		  /* 8216767Ch */ case   11:  		/* bc 4, CR6_EQ, 72 */
		/* 8216767Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821676C4;  }
		/* 8216767Ch case   11:*/		return 0x82167680;
		  /* 82167680h */ case   12:  		/* lbz R10, <#[R17 + 76]> */
		/* 82167680h case   12:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R17 + 0x0000004C) );
		/* 82167680h case   12:*/		return 0x82167684;
		  /* 82167684h */ case   13:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82167684h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82167684h case   13:*/		return 0x82167688;
		  /* 82167688h */ case   14:  		/* bc 12, CR0_EQ, 48 */
		/* 82167688h case   14:*/		if ( regs.CR[0].eq ) { return 0x821676B8;  }
		/* 82167688h case   14:*/		return 0x8216768C;
		  /* 8216768Ch */ case   15:  		/* rlwimi R11, R14, 12, 16, 19 */
		/* 8216768Ch case   15:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R14);
		/* 8216768Ch case   15:*/		return 0x82167690;
		  /* 82167690h */ case   16:  		/* stw R11, <#[R3 + 4]> */
		/* 82167690h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82167690h case   16:*/		return 0x82167694;
		  /* 82167694h */ case   17:  		/* lwz R10, <#[R17 + 76]> */
		/* 82167694h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x0000004C) );
		/* 82167694h case   17:*/		return 0x82167698;
		  /* 82167698h */ case   18:  		/* rlwinm R10, R10, 7, 25, 31 */
		/* 82167698h case   18:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R10,regs.R10);
		/* 82167698h case   18:*/		return 0x8216769C;
		  /* 8216769Ch */ case   19:  		/* rlwimi R11, R10, 10, 21, 21 */
		/* 8216769Ch case   19:*/		cpu::op::rlwimi<0,10,21,21>(regs,&regs.R11,regs.R10);
		/* 8216769Ch case   19:*/		return 0x821676A0;
		  /* 821676A0h */ case   20:  		/* stw R11, <#[R3 + 4]> */
		/* 821676A0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821676A0h case   20:*/		return 0x821676A4;
		  /* 821676A4h */ case   21:  		/* lwz R10, <#[R17 + 72]> */
		/* 821676A4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000048) );
		/* 821676A4h case   21:*/		return 0x821676A8;
		  /* 821676A8h */ case   22:  		/* lwz R10, <#[R10]> */
		/* 821676A8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821676A8h case   22:*/		return 0x821676AC;
		  /* 821676ACh */ case   23:  		/* rlwimi R11, R10, 17, 22, 29 */
		/* 821676ACh case   23:*/		cpu::op::rlwimi<0,17,22,29>(regs,&regs.R11,regs.R10);
		/* 821676ACh case   23:*/		return 0x821676B0;
		  /* 821676B0h */ case   24:  		/* stw R11, <#[R3 + 4]> */
		/* 821676B0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821676B0h case   24:*/		return 0x821676B4;
		  /* 821676B4h */ case   25:  		/* b 112 */
		/* 821676B4h case   25:*/		return 0x82167724;
		/* 821676B4h case   25:*/		return 0x821676B8;
	}
	return 0x821676B8;
} // Block from 82167650h-821676B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821676B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821676B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821676B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821676B8);
		  /* 821676B8h */ case    0:  		/* li R10, 5 */
		/* 821676B8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 821676B8h case    0:*/		return 0x821676BC;
		  /* 821676BCh */ case    1:  		/* rlwimi R11, R10, 12, 16, 19 */
		/* 821676BCh case    1:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R10);
		/* 821676BCh case    1:*/		return 0x821676C0;
		  /* 821676C0h */ case    2:  		/* b 76 */
		/* 821676C0h case    2:*/		return 0x8216770C;
		/* 821676C0h case    2:*/		return 0x821676C4;
	}
	return 0x821676C4;
} // Block from 821676B8h-821676C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821676C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821676C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821676C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821676C4);
		  /* 821676C4h */ case    0:  		/* cmplwi CR6, R10, 2 */
		/* 821676C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 821676C4h case    0:*/		return 0x821676C8;
		  /* 821676C8h */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 821676C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82167724;  }
		/* 821676C8h case    1:*/		return 0x821676CC;
		  /* 821676CCh */ case    2:  		/* lbz R11, <#[R17 + 76]> */
		/* 821676CCh case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 821676CCh case    2:*/		return 0x821676D0;
		  /* 821676D0h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821676D0h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821676D0h case    3:*/		return 0x821676D4;
		  /* 821676D4h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 821676D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821676D4h case    4:*/		return 0x821676D8;
		  /* 821676D8h */ case    5:  		/* bc 12, CR0_EQ, 48 */
		/* 821676D8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82167708;  }
		/* 821676D8h case    5:*/		return 0x821676DC;
		  /* 821676DCh */ case    6:  		/* rlwimi R11, R22, 14, 16, 19 */
		/* 821676DCh case    6:*/		cpu::op::rlwimi<0,14,16,19>(regs,&regs.R11,regs.R22);
		/* 821676DCh case    6:*/		return 0x821676E0;
		  /* 821676E0h */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 821676E0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821676E0h case    7:*/		return 0x821676E4;
		  /* 821676E4h */ case    8:  		/* lwz R11, <#[R17 + 76]> */
		/* 821676E4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 821676E4h case    8:*/		return 0x821676E8;
		  /* 821676E8h */ case    9:  		/* lwz R10, <#[R3 + 4]> */
		/* 821676E8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821676E8h case    9:*/		return 0x821676EC;
		  /* 821676ECh */ case   10:  		/* rlwinm R11, R11, 7, 25, 31 */
		/* 821676ECh case   10:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R11,regs.R11);
		/* 821676ECh case   10:*/		return 0x821676F0;
		  /* 821676F0h */ case   11:  		/* rlwimi R10, R11, 10, 21, 21 */
		/* 821676F0h case   11:*/		cpu::op::rlwimi<0,10,21,21>(regs,&regs.R10,regs.R11);
		/* 821676F0h case   11:*/		return 0x821676F4;
		  /* 821676F4h */ case   12:  		/* stw R10, <#[R3 + 4]> */
		/* 821676F4h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821676F4h case   12:*/		return 0x821676F8;
		  /* 821676F8h */ case   13:  		/* lwz R11, <#[R17 + 72]> */
		/* 821676F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000048) );
		/* 821676F8h case   13:*/		return 0x821676FC;
		  /* 821676FCh */ case   14:  		/* lwz R11, <#[R11]> */
		/* 821676FCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821676FCh case   14:*/		return 0x82167700;
		  /* 82167700h */ case   15:  		/* rlwimi R10, R11, 17, 22, 29 */
		/* 82167700h case   15:*/		cpu::op::rlwimi<0,17,22,29>(regs,&regs.R10,regs.R11);
		/* 82167700h case   15:*/		return 0x82167704;
		  /* 82167704h */ case   16:  		/* b 28 */
		/* 82167704h case   16:*/		return 0x82167720;
		/* 82167704h case   16:*/		return 0x82167708;
	}
	return 0x82167708;
} // Block from 821676C4h-82167708h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82167708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167708);
		  /* 82167708h */ case    0:  		/* rlwimi R11, R14, 13, 16, 19 */
		/* 82167708h case    0:*/		cpu::op::rlwimi<0,13,16,19>(regs,&regs.R11,regs.R14);
		/* 82167708h case    0:*/		return 0x8216770C;
	}
	return 0x8216770C;
} // Block from 82167708h-8216770Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216770Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216770C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216770C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216770C);
		  /* 8216770Ch */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 8216770Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8216770Ch case    0:*/		return 0x82167710;
		  /* 82167710h */ case    1:  		/* lwz R11, <#[R17 + 76]> */
		/* 82167710h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 82167710h case    1:*/		return 0x82167714;
		  /* 82167714h */ case    2:  		/* rlwinm R11, R11, 9, 24, 31 */
		/* 82167714h case    2:*/		cpu::op::rlwinm<0,9,24,31>(regs,&regs.R11,regs.R11);
		/* 82167714h case    2:*/		return 0x82167718;
		  /* 82167718h */ case    3:  		/* lwz R10, <#[R3 + 4]> */
		/* 82167718h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82167718h case    3:*/		return 0x8216771C;
		  /* 8216771Ch */ case    4:  		/* rlwimi R10, R11, 10, 21, 21 */
		/* 8216771Ch case    4:*/		cpu::op::rlwimi<0,10,21,21>(regs,&regs.R10,regs.R11);
		/* 8216771Ch case    4:*/		return 0x82167720;
	}
	return 0x82167720;
} // Block from 8216770Ch-82167720h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167720);
		  /* 82167720h */ case    0:  		/* stw R10, <#[R3 + 4]> */
		/* 82167720h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82167720h case    0:*/		return 0x82167724;
	}
	return 0x82167724;
} // Block from 82167720h-82167724h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167724);
		  /* 82167724h */ case    0:  		/* addi R29, R29, 1 */
		/* 82167724h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82167724h case    0:*/		return 0x82167728;
	}
	return 0x82167728;
} // Block from 82167724h-82167728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167728);
		  /* 82167728h */ case    0:  		/* cmplw CR6, R29, R30 */
		/* 82167728h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 82167728h case    0:*/		return 0x8216772C;
		  /* 8216772Ch */ case    1:  		/* bc 12, CR6_LT, -200 */
		/* 8216772Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82167664;  }
		/* 8216772Ch case    1:*/		return 0x82167730;
		  /* 82167730h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82167730h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82167730h case    2:*/		return 0x82167734;
		  /* 82167734h */ case    3:  		/* bc 12, CR6_EQ, 1876 */
		/* 82167734h case    3:*/		if ( regs.CR[6].eq ) { return 0x82167E88;  }
		/* 82167734h case    3:*/		return 0x82167738;
		  /* 82167738h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82167738h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82167738h case    4:*/		return 0x8216773C;
		  /* 8216773Ch */ case    5:  		/* lwz R11, <#[R11]> */
		/* 8216773Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216773Ch case    5:*/		return 0x82167740;
		  /* 82167740h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167740h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167740h case    6:*/		return 0x82167744;
		  /* 82167744h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82167744h case    7:*/		if ( regs.CR[0].eq ) { return 0x82167750;  }
		/* 82167744h case    7:*/		return 0x82167748;
		  /* 82167748h */ case    8:  		/* stw R23, <#[R1 + 96]> */
		/* 82167748h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000060) );
		/* 82167748h case    8:*/		return 0x8216774C;
		  /* 8216774Ch */ case    9:  		/* b 1792 */
		/* 8216774Ch case    9:*/		return 0x82167E4C;
		/* 8216774Ch case    9:*/		return 0x82167750;
	}
	return 0x82167750;
} // Block from 82167728h-82167750h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82167750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167750);
		  /* 82167750h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82167750h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82167750h case    0:*/		return 0x82167754;
		  /* 82167754h */ case    1:  		/* addi R11, R11, -4 */
		/* 82167754h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82167754h case    1:*/		return 0x82167758;
		  /* 82167758h */ case    2:  		/* stw R11, <#[R1 + 96]> */
		/* 82167758h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82167758h case    2:*/		return 0x8216775C;
		  /* 8216775Ch */ case    3:  		/* b 1776 */
		/* 8216775Ch case    3:*/		return 0x82167E4C;
		/* 8216775Ch case    3:*/		return 0x82167760;
	}
	return 0x82167760;
} // Block from 82167750h-82167760h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82167760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167760);
		  /* 82167760h */ case    0:  		/* lbz R10, <#[R17 + 76]> */
		/* 82167760h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R17 + 0x0000004C) );
		/* 82167760h case    0:*/		return 0x82167764;
		  /* 82167764h */ case    1:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82167764h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82167764h case    1:*/		return 0x82167768;
		  /* 82167768h */ case    2:  		/* bc 4, CR0_EQ, 1764 */
		/* 82167768h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82167E4C;  }
		/* 82167768h case    2:*/		return 0x8216776C;
		  /* 8216776Ch */ case    3:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 8216776Ch case    3:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 8216776Ch case    3:*/		return 0x82167770;
		  /* 82167770h */ case    4:  		/* bc 4, CR0_EQ, 1756 */
		/* 82167770h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82167E4C;  }
		/* 82167770h case    4:*/		return 0x82167774;
		  /* 82167774h */ case    5:  		/* rlwinm R11, R17, 0, 0, 30 */
		/* 82167774h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R17);
		/* 82167774h case    5:*/		return 0x82167778;
		  /* 82167778h */ case    6:  		/* lwz R30, <#[R11 + 4]> */
		/* 82167778h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82167778h case    6:*/		return 0x8216777C;
		  /* 8216777Ch */ case    7:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8216777Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8216777Ch case    7:*/		return 0x82167780;
		  /* 82167780h */ case    8:  		/* bc 4, CR0_EQ, 164 */
		/* 82167780h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82167824;  }
		/* 82167780h case    8:*/		return 0x82167784;
		  /* 82167784h */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 82167784h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82167784h case    9:*/		return 0x82167788;
		  /* 82167788h */ case   10:  		/* bc 12, CR6_EQ, 156 */
		/* 82167788h case   10:*/		if ( regs.CR[6].eq ) { return 0x82167824;  }
		/* 82167788h case   10:*/		return 0x8216778C;
		  /* 8216778Ch */ case   11:  		/* lwz R11, <#[R30 + 76]> */
		/* 8216778Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 8216778Ch case   11:*/		return 0x82167790;
		  /* 82167790h */ case   12:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 82167790h case   12:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 82167790h case   12:*/		return 0x82167794;
		  /* 82167794h */ case   13:  		/* bc 4, CR0_EQ, 144 */
		/* 82167794h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82167824;  }
		/* 82167794h case   13:*/		return 0x82167798;
		  /* 82167798h */ case   14:  		/* lwz R11, <#[R30 + 28]> */
		/* 82167798h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82167798h case   14:*/		return 0x8216779C;
		  /* 8216779Ch */ case   15:  		/* addi R31, R30, 24 */
		/* 8216779Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0x18);
		/* 8216779Ch case   15:*/		return 0x821677A0;
		  /* 821677A0h */ case   16:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821677A0h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821677A0h case   16:*/		return 0x821677A4;
		  /* 821677A4h */ case   17:  		/* bc 4, CR0_EQ, 1864 */
		/* 821677A4h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82167EEC;  }
		/* 821677A4h case   17:*/		return 0x821677A8;
		  /* 821677A8h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 821677A8h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821677A8h case   18:*/		return 0x821677AC;
		  /* 821677ACh */ case   19:  		/* bc 12, CR0_EQ, 1856 */
		/* 821677ACh case   19:*/		if ( regs.CR[0].eq ) { return 0x82167EEC;  }
		/* 821677ACh case   19:*/		return 0x821677B0;
		  /* 821677B0h */ case   20:  		/* lwz R10, <#[R11 + 8]> */
		/* 821677B0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821677B0h case   20:*/		return 0x821677B4;
		  /* 821677B4h */ case   21:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821677B4h case   21:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821677B4h case   21:*/		return 0x821677B8;
		  /* 821677B8h */ case   22:  		/* cmplwi CR6, R10, 16128 */
		/* 821677B8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003F00);
		/* 821677B8h case   22:*/		return 0x821677BC;
		  /* 821677BCh */ case   23:  		/* bc 4, CR6_EQ, 1840 */
		/* 821677BCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x82167EEC;  }
		/* 821677BCh case   23:*/		return 0x821677C0;
		  /* 821677C0h */ case   24:  		/* lwz R11, <#[R11 + 20]> */
		/* 821677C0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821677C0h case   24:*/		return 0x821677C4;
		  /* 821677C4h */ case   25:  		/* rlwinm R16, R11, 0, 20, 31 */
		/* 821677C4h case   25:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R16,regs.R11);
		/* 821677C4h case   25:*/		return 0x821677C8;
		  /* 821677C8h */ case   26:  		/* cmpwi CR6, R16, -1 */
		/* 821677C8h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R16,0xFFFFFFFF);
		/* 821677C8h case   26:*/		return 0x821677CC;
		  /* 821677CCh */ case   27:  		/* bc 12, CR6_EQ, 1664 */
		/* 821677CCh case   27:*/		if ( regs.CR[6].eq ) { return 0x82167E4C;  }
		/* 821677CCh case   27:*/		return 0x821677D0;
		  /* 821677D0h */ case   28:  		/* lwz R3, <#[R15 + 768]> */
		/* 821677D0h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821677D0h case   28:*/		return 0x821677D4;
		  /* 821677D4h */ case   29:  		/* bl -1022420 */
		/* 821677D4h case   29:*/		regs.LR = 0x821677D8; return 0x8206DE00;
		/* 821677D4h case   29:*/		return 0x821677D8;
		  /* 821677D8h */ case   30:  		/* cmplw CR6, R16, R3 */
		/* 821677D8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R3);
		/* 821677D8h case   30:*/		return 0x821677DC;
		  /* 821677DCh */ case   31:  		/* bc 4, CR6_LT, 84 */
		/* 821677DCh case   31:*/		if ( !regs.CR[6].lt ) { return 0x82167830;  }
		/* 821677DCh case   31:*/		return 0x821677E0;
		  /* 821677E0h */ case   32:  		/* lwz R11, <#[R31 + 4]> */
		/* 821677E0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821677E0h case   32:*/		return 0x821677E4;
		  /* 821677E4h */ case   33:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821677E4h case   33:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821677E4h case   33:*/		return 0x821677E8;
		  /* 821677E8h */ case   34:  		/* bc 4, CR0_EQ, 1776 */
		/* 821677E8h case   34:*/		if ( !regs.CR[0].eq ) { return 0x82167ED8;  }
		/* 821677E8h case   34:*/		return 0x821677EC;
		  /* 821677ECh */ case   35:  		/* cmplwi CR0, R11, 0 */
		/* 821677ECh case   35:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821677ECh case   35:*/		return 0x821677F0;
		  /* 821677F0h */ case   36:  		/* bc 12, CR0_EQ, 1768 */
		/* 821677F0h case   36:*/		if ( regs.CR[0].eq ) { return 0x82167ED8;  }
		/* 821677F0h case   36:*/		return 0x821677F4;
		  /* 821677F4h */ case   37:  		/* lwz R10, <#[R11 + 8]> */
		/* 821677F4h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821677F4h case   37:*/		return 0x821677F8;
		  /* 821677F8h */ case   38:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821677F8h case   38:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821677F8h case   38:*/		return 0x821677FC;
		  /* 821677FCh */ case   39:  		/* cmplwi CR6, R10, 16128 */
		/* 821677FCh case   39:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003F00);
		/* 821677FCh case   39:*/		return 0x82167800;
		  /* 82167800h */ case   40:  		/* bc 4, CR6_EQ, 1752 */
		/* 82167800h case   40:*/		if ( !regs.CR[6].eq ) { return 0x82167ED8;  }
		/* 82167800h case   40:*/		return 0x82167804;
		  /* 82167804h */ case   41:  		/* lhz R11, <#[R11 + 20]> */
		/* 82167804h case   41:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82167804h case   41:*/		return 0x82167808;
		  /* 82167808h */ case   42:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82167808h case   42:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82167808h case   42:*/		return 0x8216780C;
		  /* 8216780Ch */ case   43:  		/* bc 4, CR0_EQ, 36 */
		/* 8216780Ch case   43:*/		if ( !regs.CR[0].eq ) { return 0x82167830;  }
		/* 8216780Ch case   43:*/		return 0x82167810;
		  /* 82167810h */ case   44:  		/* lwz R11, <#[R30 + 48]> */
		/* 82167810h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 82167810h case   44:*/		return 0x82167814;
		  /* 82167814h */ case   45:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 82167814h case   45:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 82167814h case   45:*/		return 0x82167818;
		  /* 82167818h */ case   46:  		/* bc 4, CR0_EQ, 24 */
		/* 82167818h case   46:*/		if ( !regs.CR[0].eq ) { return 0x82167830;  }
		/* 82167818h case   46:*/		return 0x8216781C;
		  /* 8216781Ch */ case   47:  		/* addi R16, R16, 1 */
		/* 8216781Ch case   47:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 8216781Ch case   47:*/		return 0x82167820;
		  /* 82167820h */ case   48:  		/* b 16 */
		/* 82167820h case   48:*/		return 0x82167830;
		/* 82167820h case   48:*/		return 0x82167824;
	}
	return 0x82167824;
} // Block from 82167760h-82167824h (49 instructions)

//////////////////////////////////////////////////////
// Block at 82167824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167824);
		  /* 82167824h */ case    0:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167824h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167824h case    0:*/		return 0x82167828;
		  /* 82167828h */ case    1:  		/* bl -1022504 */
		/* 82167828h case    1:*/		regs.LR = 0x8216782C; return 0x8206DE00;
		/* 82167828h case    1:*/		return 0x8216782C;
		  /* 8216782Ch */ case    2:  		/* mr R16, R3 */
		/* 8216782Ch case    2:*/		regs.R16 = regs.R3;
		/* 8216782Ch case    2:*/		return 0x82167830;
	}
	return 0x82167830;
} // Block from 82167824h-82167830h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82167830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167830);
		  /* 82167830h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82167830h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82167830h case    0:*/		return 0x82167834;
		  /* 82167834h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167834h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167834h case    1:*/		return 0x82167838;
		  /* 82167838h */ case    2:  		/* bc 4, CR0_EQ, 1756 */
		/* 82167838h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82167F14;  }
		/* 82167838h case    2:*/		return 0x8216783C;
		  /* 8216783Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8216783Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216783Ch case    3:*/		return 0x82167840;
		  /* 82167840h */ case    4:  		/* bc 12, CR0_EQ, 1748 */
		/* 82167840h case    4:*/		if ( regs.CR[0].eq ) { return 0x82167F14;  }
		/* 82167840h case    4:*/		return 0x82167844;
		  /* 82167844h */ case    5:  		/* lwz R10, <#[R11 + 8]> */
		/* 82167844h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82167844h case    5:*/		return 0x82167848;
		  /* 82167848h */ case    6:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 82167848h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 82167848h case    6:*/		return 0x8216784C;
		  /* 8216784Ch */ case    7:  		/* cmplwi CR6, R10, 16128 */
		/* 8216784Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003F00);
		/* 8216784Ch case    7:*/		return 0x82167850;
		  /* 82167850h */ case    8:  		/* bc 4, CR6_EQ, 1732 */
		/* 82167850h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82167F14;  }
		/* 82167850h case    8:*/		return 0x82167854;
		  /* 82167854h */ case    9:  		/* lhz R11, <#[R11 + 20]> */
		/* 82167854h case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82167854h case    9:*/		return 0x82167858;
		  /* 82167858h */ case   10:  		/* mr R27, R19 */
		/* 82167858h case   10:*/		regs.R27 = regs.R19;
		/* 82167858h case   10:*/		return 0x8216785C;
		  /* 8216785Ch */ case   11:  		/* mr R26, R23 */
		/* 8216785Ch case   11:*/		regs.R26 = regs.R23;
		/* 8216785Ch case   11:*/		return 0x82167860;
		  /* 82167860h */ case   12:  		/* rlwinm R28, R11, 0, 31, 31 */
		/* 82167860h case   12:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R28,regs.R11);
		/* 82167860h case   12:*/		return 0x82167864;
		  /* 82167864h */ case   13:  		/* mr R22, R23 */
		/* 82167864h case   13:*/		regs.R22 = regs.R23;
		/* 82167864h case   13:*/		return 0x82167868;
		  /* 82167868h */ case   14:  		/* mr R29, R28 */
		/* 82167868h case   14:*/		regs.R29 = regs.R28;
		/* 82167868h case   14:*/		return 0x8216786C;
		  /* 8216786Ch */ case   15:  		/* mr R25, R28 */
		/* 8216786Ch case   15:*/		regs.R25 = regs.R28;
		/* 8216786Ch case   15:*/		return 0x82167870;
		  /* 82167870h */ case   16:  		/* mr R18, R23 */
		/* 82167870h case   16:*/		regs.R18 = regs.R23;
		/* 82167870h case   16:*/		return 0x82167874;
		  /* 82167874h */ case   17:  		/* mr R30, R23 */
		/* 82167874h case   17:*/		regs.R30 = regs.R23;
		/* 82167874h case   17:*/		return 0x82167878;
		  /* 82167878h */ case   18:  		/* mr R21, R23 */
		/* 82167878h case   18:*/		regs.R21 = regs.R23;
		/* 82167878h case   18:*/		return 0x8216787C;
		  /* 8216787Ch */ case   19:  		/* lwz R11, <#[R17 + 28]> */
		/* 8216787Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000001C) );
		/* 8216787Ch case   19:*/		return 0x82167880;
		  /* 82167880h */ case   20:  		/* addi R20, R17, 24 */
		/* 82167880h case   20:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R17,0x18);
		/* 82167880h case   20:*/		return 0x82167884;
		  /* 82167884h */ case   21:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167884h case   21:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167884h case   21:*/		return 0x82167888;
		  /* 82167888h */ case   22:  		/* bc 4, CR0_EQ, 1212 */
		/* 82167888h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82167D44;  }
		/* 82167888h case   22:*/		return 0x8216788C;
		  /* 8216788Ch */ case   23:  		/* mr R24, R11 */
		/* 8216788Ch case   23:*/		regs.R24 = regs.R11;
		/* 8216788Ch case   23:*/		return 0x82167890;
		  /* 82167890h */ case   24:  		/* cmplwi CR0, R11, 0 */
		/* 82167890h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82167890h case   24:*/		return 0x82167894;
		  /* 82167894h */ case   25:  		/* bc 12, CR0_EQ, 1200 */
		/* 82167894h case   25:*/		if ( regs.CR[0].eq ) { return 0x82167D44;  }
		/* 82167894h case   25:*/		return 0x82167898;
		  /* 82167898h */ case   26:  		/* lwz R11, <#[R24 + 8]> */
		/* 82167898h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82167898h case   26:*/		return 0x8216789C;
		  /* 8216789Ch */ case   27:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8216789Ch case   27:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8216789Ch case   27:*/		return 0x821678A0;
		  /* 821678A0h */ case   28:  		/* cmplwi CR6, R10, 1 */
		/* 821678A0h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821678A0h case   28:*/		return 0x821678A4;
		  /* 821678A4h */ case   29:  		/* bc 12, CR6_LT, 16 */
		/* 821678A4h case   29:*/		if ( regs.CR[6].lt ) { return 0x821678B4;  }
		/* 821678A4h case   29:*/		return 0x821678A8;
		  /* 821678A8h */ case   30:  		/* cmplwi CR6, R10, 102 */
		/* 821678A8h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 821678A8h case   30:*/		return 0x821678AC;
		  /* 821678ACh */ case   31:  		/* li R11, 1 */
		/* 821678ACh case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821678ACh case   31:*/		return 0x821678B0;
		  /* 821678B0h */ case   32:  		/* bc 4, CR6_GT, 8 */
		/* 821678B0h case   32:*/		if ( !regs.CR[6].gt ) { return 0x821678B8;  }
		/* 821678B0h case   32:*/		return 0x821678B4;
	}
	return 0x821678B4;
} // Block from 82167830h-821678B4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821678B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821678B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821678B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821678B4);
		  /* 821678B4h */ case    0:  		/* li R11, 0 */
		/* 821678B4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821678B4h case    0:*/		return 0x821678B8;
	}
	return 0x821678B8;
} // Block from 821678B4h-821678B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821678B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821678B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821678B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821678B8);
		  /* 821678B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821678B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821678B8h case    0:*/		return 0x821678BC;
		  /* 821678BCh */ case    1:  		/* bc 12, CR0_EQ, 1132 */
		/* 821678BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82167D28;  }
		/* 821678BCh case    1:*/		return 0x821678C0;
		  /* 821678C0h */ case    2:  		/* cmplwi CR6, R10, 83 */
		/* 821678C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 821678C0h case    2:*/		return 0x821678C4;
		  /* 821678C4h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821678C4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821678D4;  }
		/* 821678C4h case    3:*/		return 0x821678C8;
		  /* 821678C8h */ case    4:  		/* cmplwi CR6, R10, 95 */
		/* 821678C8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005F);
		/* 821678C8h case    4:*/		return 0x821678CC;
		  /* 821678CCh */ case    5:  		/* li R11, 1 */
		/* 821678CCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821678CCh case    5:*/		return 0x821678D0;
		  /* 821678D0h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821678D0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821678D8;  }
		/* 821678D0h case    6:*/		return 0x821678D4;
	}
	return 0x821678D4;
} // Block from 821678B8h-821678D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821678D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821678D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821678D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821678D4);
		  /* 821678D4h */ case    0:  		/* li R11, 0 */
		/* 821678D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821678D4h case    0:*/		return 0x821678D8;
	}
	return 0x821678D8;
} // Block from 821678D4h-821678D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821678D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821678D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821678D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821678D8);
		  /* 821678D8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821678D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821678D8h case    0:*/		return 0x821678DC;
		  /* 821678DCh */ case    1:  		/* bc 4, CR0_EQ, 904 */
		/* 821678DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82167C64;  }
		/* 821678DCh case    1:*/		return 0x821678E0;
		  /* 821678E0h */ case    2:  		/* lwz R11, <#[R24 + 20]> */
		/* 821678E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 821678E0h case    2:*/		return 0x821678E4;
		  /* 821678E4h */ case    3:  		/* rlwinm R10, R11, 0, 17, 19 */
		/* 821678E4h case    3:*/		cpu::op::rlwinm<0,0,17,19>(regs,&regs.R10,regs.R11);
		/* 821678E4h case    3:*/		return 0x821678E8;
		  /* 821678E8h */ case    4:  		/* cmplwi CR6, R10, 28672 */
		/* 821678E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007000);
		/* 821678E8h case    4:*/		return 0x821678EC;
		  /* 821678ECh */ case    5:  		/* bc 12, CR6_EQ, 1228 */
		/* 821678ECh case    5:*/		if ( regs.CR[6].eq ) { return 0x82167DB8;  }
		/* 821678ECh case    5:*/		return 0x821678F0;
		  /* 821678F0h */ case    6:  		/* cmpwi CR6, R27, -1 */
		/* 821678F0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0xFFFFFFFF);
		/* 821678F0h case    6:*/		return 0x821678F4;
		  /* 821678F4h */ case    7:  		/* bc 12, CR6_EQ, 524 */
		/* 821678F4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82167B00;  }
		/* 821678F4h case    7:*/		return 0x821678F8;
		  /* 821678F8h */ case    8:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 821678F8h case    8:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 821678F8h case    8:*/		return 0x821678FC;
		  /* 821678FCh */ case    9:  		/* cmplw CR6, R27, R11 */
		/* 821678FCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821678FCh case    9:*/		return 0x82167900;
		  /* 82167900h */ case   10:  		/* bc 12, CR6_EQ, 512 */
		/* 82167900h case   10:*/		if ( regs.CR[6].eq ) { return 0x82167B00;  }
		/* 82167900h case   10:*/		return 0x82167904;
		  /* 82167904h */ case   11:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82167904h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82167904h case   11:*/		return 0x82167908;
		  /* 82167908h */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 82167908h case   12:*/		if ( regs.CR[0].eq ) { return 0x82167928;  }
		/* 82167908h case   12:*/		return 0x8216790C;
		  /* 8216790Ch */ case   13:  		/* mr R7, R23 */
		/* 8216790Ch case   13:*/		regs.R7 = regs.R23;
		/* 8216790Ch case   13:*/		return 0x82167910;
		  /* 82167910h */ case   14:  		/* mr R6, R30 */
		/* 82167910h case   14:*/		regs.R6 = regs.R30;
		/* 82167910h case   14:*/		return 0x82167914;
		  /* 82167914h */ case   15:  		/* mr R5, R22 */
		/* 82167914h case   15:*/		regs.R5 = regs.R22;
		/* 82167914h case   15:*/		return 0x82167918;
		  /* 82167918h */ case   16:  		/* mr R4, R27 */
		/* 82167918h case   16:*/		regs.R4 = regs.R27;
		/* 82167918h case   16:*/		return 0x8216791C;
		  /* 8216791Ch */ case   17:  		/* mr R3, R15 */
		/* 8216791Ch case   17:*/		regs.R3 = regs.R15;
		/* 8216791Ch case   17:*/		return 0x82167920;
		  /* 82167920h */ case   18:  		/* bl -11824 */
		/* 82167920h case   18:*/		regs.LR = 0x82167924; return 0x82164AF0;
		/* 82167920h case   18:*/		return 0x82167924;
		  /* 82167924h */ case   19:  		/* mr R28, R3 */
		/* 82167924h case   19:*/		regs.R28 = regs.R3;
		/* 82167924h case   19:*/		return 0x82167928;
	}
	return 0x82167928;
} // Block from 821678D8h-82167928h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82167928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167928);
		  /* 82167928h */ case    0:  		/* rlwinm. R31, R28, 0, 24, 31 */
		/* 82167928h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R31,regs.R28);
		/* 82167928h case    0:*/		return 0x8216792C;
		  /* 8216792Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8216792Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82167940;  }
		/* 8216792Ch case    1:*/		return 0x82167930;
		  /* 82167930h */ case    2:  		/* mr R5, R23 */
		/* 82167930h case    2:*/		regs.R5 = regs.R23;
		/* 82167930h case    2:*/		return 0x82167934;
		  /* 82167934h */ case    3:  		/* mr R4, R27 */
		/* 82167934h case    3:*/		regs.R4 = regs.R27;
		/* 82167934h case    3:*/		return 0x82167938;
		  /* 82167938h */ case    4:  		/* mr R3, R15 */
		/* 82167938h case    4:*/		regs.R3 = regs.R15;
		/* 82167938h case    4:*/		return 0x8216793C;
		  /* 8216793Ch */ case    5:  		/* bl -11708 */
		/* 8216793Ch case    5:*/		regs.LR = 0x82167940; return 0x82164B80;
		/* 8216793Ch case    5:*/		return 0x82167940;
	}
	return 0x82167940;
} // Block from 82167928h-82167940h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82167940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167940);
		  /* 82167940h */ case    0:  		/* mr R4, R27 */
		/* 82167940h case    0:*/		regs.R4 = regs.R27;
		/* 82167940h case    0:*/		return 0x82167944;
		  /* 82167944h */ case    1:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167944h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167944h case    1:*/		return 0x82167948;
		  /* 82167948h */ case    2:  		/* bl -1037992 */
		/* 82167948h case    2:*/		regs.LR = 0x8216794C; return 0x8206A2A0;
		/* 82167948h case    2:*/		return 0x8216794C;
		  /* 8216794Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8216794Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216794Ch case    3:*/		return 0x82167950;
		  /* 82167950h */ case    4:  		/* li R12, -683 */
		/* 82167950h case    4:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFD55);
		/* 82167950h case    4:*/		return 0x82167954;
		  /* 82167954h */ case    5:  		/* rlwinm R10, R11, 16, 21, 31 */
		/* 82167954h case    5:*/		cpu::op::rlwinm<0,16,21,31>(regs,&regs.R10,regs.R11);
		/* 82167954h case    5:*/		return 0x82167958;
		  /* 82167958h */ case    6:  		/* rlwinm R9, R11, 16, 20, 30 */
		/* 82167958h case    6:*/		cpu::op::rlwinm<0,16,20,30>(regs,&regs.R9,regs.R11);
		/* 82167958h case    6:*/		return 0x8216795C;
		  /* 8216795Ch */ case    7:  		/* and R10, R10, R12 */
		/* 8216795Ch case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 8216795Ch case    7:*/		return 0x82167960;
		  /* 82167960h */ case    8:  		/* li R12, -1365 */
		/* 82167960h case    8:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFAAB);
		/* 82167960h case    8:*/		return 0x82167964;
		  /* 82167964h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 82167964h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82167964h case    9:*/		return 0x82167968;
		  /* 82167968h */ case   10:  		/* and R9, R9, R12 */
		/* 82167968h case   10:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R12);
		/* 82167968h case   10:*/		return 0x8216796C;
		  /* 8216796Ch */ case   11:  		/* bc 4, CR6_EQ, 132 */
		/* 8216796Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821679F0;  }
		/* 8216796Ch case   11:*/		return 0x82167970;
		  /* 82167970h */ case   12:  		/* rlwinm. R8, R25, 0, 24, 31 */
		/* 82167970h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R25);
		/* 82167970h case   12:*/		return 0x82167974;
		  /* 82167974h */ case   13:  		/* bc 12, CR0_EQ, 52 */
		/* 82167974h case   13:*/		if ( regs.CR[0].eq ) { return 0x821679A8;  }
		/* 82167974h case   13:*/		return 0x82167978;
		  /* 82167978h */ case   14:  		/* cmplwi CR6, R9, 0 */
		/* 82167978h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82167978h case   14:*/		return 0x8216797C;
		  /* 8216797Ch */ case   15:  		/* bc 4, CR6_EQ, 40 */
		/* 8216797Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x821679A4;  }
		/* 8216797Ch case   15:*/		return 0x82167980;
		  /* 82167980h */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 82167980h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82167980h case   16:*/		return 0x82167984;
		  /* 82167984h */ case   17:  		/* bc 12, CR6_EQ, 36 */
		/* 82167984h case   17:*/		if ( regs.CR[6].eq ) { return 0x821679A8;  }
		/* 82167984h case   17:*/		return 0x82167988;
		  /* 82167988h */ case   18:  		/* rlwinm R11, R11, 20, 29, 31 */
		/* 82167988h case   18:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R11,regs.R11);
		/* 82167988h case   18:*/		return 0x8216798C;
		  /* 8216798Ch */ case   19:  		/* li R8, 1365 */
		/* 8216798Ch case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x555);
		/* 8216798Ch case   19:*/		return 0x82167990;
		  /* 82167990h */ case   20:  		/* subfic R11, R11, 6 */
		/* 82167990h case   20:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x6);
		/* 82167990h case   20:*/		return 0x82167994;
		  /* 82167994h */ case   21:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82167994h case   21:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82167994h case   21:*/		return 0x82167998;
		  /* 82167998h */ case   22:  		/* srw R11, R8, R11 */
		/* 82167998h case   22:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82167998h case   22:*/		return 0x8216799C;
		  /* 8216799Ch */ case   23:  		/* cmplw CR6, R10, R11 */
		/* 8216799Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216799Ch case   23:*/		return 0x821679A0;
		  /* 821679A0h */ case   24:  		/* bc 12, CR6_EQ, 8 */
		/* 821679A0h case   24:*/		if ( regs.CR[6].eq ) { return 0x821679A8;  }
		/* 821679A0h case   24:*/		return 0x821679A4;
	}
	return 0x821679A4;
} // Block from 82167940h-821679A4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821679A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821679A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821679A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821679A4);
		  /* 821679A4h */ case    0:  		/* li R29, 1 */
		/* 821679A4h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821679A4h case    0:*/		return 0x821679A8;
	}
	return 0x821679A8;
} // Block from 821679A4h-821679A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821679A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821679A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821679A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821679A8);
		  /* 821679A8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821679A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821679A8h case    0:*/		return 0x821679AC;
		  /* 821679ACh */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 821679ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821679F0;  }
		/* 821679ACh case    1:*/		return 0x821679B0;
		  /* 821679B0h */ case    2:  		/* rlwinm. R11, R22, 0, 24, 31 */
		/* 821679B0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R22);
		/* 821679B0h case    2:*/		return 0x821679B4;
		  /* 821679B4h */ case    3:  		/* bc 4, CR0_EQ, 60 */
		/* 821679B4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821679F0;  }
		/* 821679B4h case    3:*/		return 0x821679B8;
		  /* 821679B8h */ case    4:  		/* mr R11, R10 */
		/* 821679B8h case    4:*/		regs.R11 = regs.R10;
		/* 821679B8h case    4:*/		return 0x821679BC;
		  /* 821679BCh */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 821679BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821679BCh case    5:*/		return 0x821679C0;
		  /* 821679C0h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 821679C0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821679E4;  }
		/* 821679C0h case    6:*/		return 0x821679C4;
		  /* 821679C4h */ case    7:  		/* cntlzw R11, R9 */
		/* 821679C4h case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R9);
		/* 821679C4h case    7:*/		return 0x821679C8;
		  /* 821679C8h */ case    8:  		/* li R9, 1 */
		/* 821679C8h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821679C8h case    8:*/		return 0x821679CC;
		  /* 821679CCh */ case    9:  		/* addi R11, R11, 1 */
		/* 821679CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821679CCh case    9:*/		return 0x821679D0;
		  /* 821679D0h */ case   10:  		/* subfic R11, R11, 32 */
		/* 821679D0h case   10:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821679D0h case   10:*/		return 0x821679D4;
		  /* 821679D4h */ case   11:  		/* rlwnm R11, R9, R11, 0, 31 */
		/* 821679D4h case   11:*/		cpu::op::rlwnm<0,0,31>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821679D4h case   11:*/		return 0x821679D8;
		  /* 821679D8h */ case   12:  		/* addi R9, R11, -1 */
		/* 821679D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 821679D8h case   12:*/		return 0x821679DC;
		  /* 821679DCh */ case   13:  		/* nor R11, R9, R11 */
		/* 821679DCh case   13:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821679DCh case   13:*/		return 0x821679E0;
		  /* 821679E0h */ case   14:  		/* and R11, R11, R10 */
		/* 821679E0h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821679E0h case   14:*/		return 0x821679E4;
	}
	return 0x821679E4;
} // Block from 821679A8h-821679E4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821679E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821679E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821679E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821679E4);
		  /* 821679E4h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821679E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821679E4h case    0:*/		return 0x821679E8;
		  /* 821679E8h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 821679E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821679F0;  }
		/* 821679E8h case    1:*/		return 0x821679EC;
		  /* 821679ECh */ case    2:  		/* li R22, 1 */
		/* 821679ECh case    2:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821679ECh case    2:*/		return 0x821679F0;
	}
	return 0x821679F0;
} // Block from 821679E4h-821679F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821679F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821679F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821679F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821679F0);
		  /* 821679F0h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 821679F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 821679F0h case    0:*/		return 0x821679F4;
		  /* 821679F4h */ case    1:  		/* li R26, 0 */
		/* 821679F4h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821679F4h case    1:*/		return 0x821679F8;
		  /* 821679F8h */ case    2:  		/* li R28, 1 */
		/* 821679F8h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 821679F8h case    2:*/		return 0x821679FC;
		  /* 821679FCh */ case    3:  		/* li R25, 1 */
		/* 821679FCh case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821679FCh case    3:*/		return 0x82167A00;
		  /* 82167A00h */ case    4:  		/* bc 4, CR0_EQ, 212 */
		/* 82167A00h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82167AD4;  }
		/* 82167A00h case    4:*/		return 0x82167A04;
		  /* 82167A04h */ case    5:  		/* lwz R11, <#[R20 + 4]> */
		/* 82167A04h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000004) );
		/* 82167A04h case    5:*/		return 0x82167A08;
		  /* 82167A08h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167A08h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167A08h case    6:*/		return 0x82167A0C;
		  /* 82167A0Ch */ case    7:  		/* bc 4, CR0_EQ, 196 */
		/* 82167A0Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82167AD0;  }
		/* 82167A0Ch case    7:*/		return 0x82167A10;
		  /* 82167A10h */ case    8:  		/* mr R29, R11 */
		/* 82167A10h case    8:*/		regs.R29 = regs.R11;
		/* 82167A10h case    8:*/		return 0x82167A14;
		  /* 82167A14h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 82167A14h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82167A14h case    9:*/		return 0x82167A18;
		  /* 82167A18h */ case   10:  		/* bc 12, CR0_EQ, 184 */
		/* 82167A18h case   10:*/		if ( regs.CR[0].eq ) { return 0x82167AD0;  }
		/* 82167A18h case   10:*/		return 0x82167A1C;
		  /* 82167A1Ch */ case   11:  		/* mr R3, R29 */
		/* 82167A1Ch case   11:*/		regs.R3 = regs.R29;
		/* 82167A1Ch case   11:*/		return 0x82167A20;
		  /* 82167A20h */ case   12:  		/* bl -14472 */
		/* 82167A20h case   12:*/		regs.LR = 0x82167A24; return 0x82164198;
		/* 82167A20h case   12:*/		return 0x82167A24;
		  /* 82167A24h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167A24h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167A24h case   13:*/		return 0x82167A28;
		  /* 82167A28h */ case   14:  		/* bc 12, CR0_EQ, 140 */
		/* 82167A28h case   14:*/		if ( regs.CR[0].eq ) { return 0x82167AB4;  }
		/* 82167A28h case   14:*/		return 0x82167A2C;
		  /* 82167A2Ch */ case   15:  		/* lwz R11, <#[R29 + 20]> */
		/* 82167A2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 82167A2Ch case   15:*/		return 0x82167A30;
		  /* 82167A30h */ case   16:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82167A30h case   16:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82167A30h case   16:*/		return 0x82167A34;
		  /* 82167A34h */ case   17:  		/* cmplw CR6, R11, R27 */
		/* 82167A34h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82167A34h case   17:*/		return 0x82167A38;
		  /* 82167A38h */ case   18:  		/* bc 12, CR6_GT, 152 */
		/* 82167A38h case   18:*/		if ( regs.CR[6].gt ) { return 0x82167AD0;  }
		/* 82167A38h case   18:*/		return 0x82167A3C;
		  /* 82167A3Ch */ case   19:  		/* lwz R31, <#[R29 + 4]> */
		/* 82167A3Ch case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 82167A3Ch case   19:*/		return 0x82167A40;
		  /* 82167A40h */ case   20:  		/* cmplwi CR6, R31, 0 */
		/* 82167A40h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82167A40h case   20:*/		return 0x82167A44;
		  /* 82167A44h */ case   21:  		/* bc 12, CR6_EQ, 112 */
		/* 82167A44h case   21:*/		if ( regs.CR[6].eq ) { return 0x82167AB4;  }
		/* 82167A44h case   21:*/		return 0x82167A48;
		  /* 82167A48h */ case   22:  		/* lwz R30, <#[R31 + 16]> */
		/* 82167A48h case   22:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 82167A48h case   22:*/		return 0x82167A4C;
		  /* 82167A4Ch */ case   23:  		/* cmplwi CR6, R30, 0 */
		/* 82167A4Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82167A4Ch case   23:*/		return 0x82167A50;
		  /* 82167A50h */ case   24:  		/* bc 12, CR6_EQ, 88 */
		/* 82167A50h case   24:*/		if ( regs.CR[6].eq ) { return 0x82167AA8;  }
		/* 82167A50h case   24:*/		return 0x82167A54;
		  /* 82167A54h */ case   25:  		/* lwz R10, <#[R31]> */
		/* 82167A54h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82167A54h case   25:*/		return 0x82167A58;
		  /* 82167A58h */ case   26:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 82167A58h case   26:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 82167A58h case   26:*/		return 0x82167A5C;
		  /* 82167A5Ch */ case   27:  		/* bc 12, CR0_EQ, 16 */
		/* 82167A5Ch case   27:*/		if ( regs.CR[0].eq ) { return 0x82167A6C;  }
		/* 82167A5Ch case   27:*/		return 0x82167A60;
		  /* 82167A60h */ case   28:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82167A60h case   28:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82167A60h case   28:*/		return 0x82167A64;
		  /* 82167A64h */ case   29:  		/* li R11, 1 */
		/* 82167A64h case   29:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82167A64h case   29:*/		return 0x82167A68;
		  /* 82167A68h */ case   30:  		/* bc 12, CR0_EQ, 8 */
		/* 82167A68h case   30:*/		if ( regs.CR[0].eq ) { return 0x82167A70;  }
		/* 82167A68h case   30:*/		return 0x82167A6C;
	}
	return 0x82167A6C;
} // Block from 821679F0h-82167A6Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 82167A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167A6C);
		  /* 82167A6Ch */ case    0:  		/* li R11, 0 */
		/* 82167A6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82167A6Ch case    0:*/		return 0x82167A70;
	}
	return 0x82167A70;
} // Block from 82167A6Ch-82167A70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167A70);
		  /* 82167A70h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167A70h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167A70h case    0:*/		return 0x82167A74;
		  /* 82167A74h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82167A74h case    1:*/		if ( regs.CR[0].eq ) { return 0x82167AA8;  }
		/* 82167A74h case    1:*/		return 0x82167A78;
		  /* 82167A78h */ case    2:  		/* rlwinm. R11, R10, 19, 20, 31 */
		/* 82167A78h case    2:*/		cpu::op::rlwinm<1,19,20,31>(regs,&regs.R11,regs.R10);
		/* 82167A78h case    2:*/		return 0x82167A7C;
		  /* 82167A7Ch */ case    3:  		/* bc 12, CR0_LT, 44 */
		/* 82167A7Ch case    3:*/		if ( regs.CR[0].lt ) { return 0x82167AA8;  }
		/* 82167A7Ch case    3:*/		return 0x82167A80;
		  /* 82167A80h */ case    4:  		/* cmpwi CR6, R11, 6 */
		/* 82167A80h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 82167A80h case    4:*/		return 0x82167A84;
		  /* 82167A84h */ case    5:  		/* bc 12, CR6_GT, 36 */
		/* 82167A84h case    5:*/		if ( regs.CR[6].gt ) { return 0x82167AA8;  }
		/* 82167A84h case    5:*/		return 0x82167A88;
		  /* 82167A88h */ case    6:  		/* mr R3, R30 */
		/* 82167A88h case    6:*/		regs.R3 = regs.R30;
		/* 82167A88h case    6:*/		return 0x82167A8C;
		  /* 82167A8Ch */ case    7:  		/* bl -14580 */
		/* 82167A8Ch case    7:*/		regs.LR = 0x82167A90; return 0x82164198;
		/* 82167A8Ch case    7:*/		return 0x82167A90;
		  /* 82167A90h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167A90h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167A90h case    8:*/		return 0x82167A94;
		  /* 82167A94h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 82167A94h case    9:*/		if ( regs.CR[0].eq ) { return 0x82167AA8;  }
		/* 82167A94h case    9:*/		return 0x82167A98;
		  /* 82167A98h */ case   10:  		/* lwz R11, <#[R30 + 20]> */
		/* 82167A98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82167A98h case   10:*/		return 0x82167A9C;
		  /* 82167A9Ch */ case   11:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82167A9Ch case   11:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82167A9Ch case   11:*/		return 0x82167AA0;
		  /* 82167AA0h */ case   12:  		/* cmplw CR6, R11, R27 */
		/* 82167AA0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82167AA0h case   12:*/		return 0x82167AA4;
		  /* 82167AA4h */ case   13:  		/* bc 12, CR6_GT, 12 */
		/* 82167AA4h case   13:*/		if ( regs.CR[6].gt ) { return 0x82167AB0;  }
		/* 82167AA4h case   13:*/		return 0x82167AA8;
	}
	return 0x82167AA8;
} // Block from 82167A70h-82167AA8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82167AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167AA8);
		  /* 82167AA8h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82167AA8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82167AA8h case    0:*/		return 0x82167AAC;
		  /* 82167AACh */ case    1:  		/* b -108 */
		/* 82167AACh case    1:*/		return 0x82167A40;
		/* 82167AACh case    1:*/		return 0x82167AB0;
	}
	return 0x82167AB0;
} // Block from 82167AA8h-82167AB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167AB0);
		  /* 82167AB0h */ case    0:  		/* li R28, 0 */
		/* 82167AB0h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82167AB0h case    0:*/		return 0x82167AB4;
	}
	return 0x82167AB4;
} // Block from 82167AB0h-82167AB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167AB4);
		  /* 82167AB4h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 82167AB4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 82167AB4h case    0:*/		return 0x82167AB8;
		  /* 82167AB8h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82167AB8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82167AB8h case    1:*/		return 0x82167ABC;
		  /* 82167ABCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167ABCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167ABCh case    2:*/		return 0x82167AC0;
		  /* 82167AC0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82167AC0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82167AD0;  }
		/* 82167AC0h case    3:*/		return 0x82167AC4;
		  /* 82167AC4h */ case    4:  		/* mr R29, R11 */
		/* 82167AC4h case    4:*/		regs.R29 = regs.R11;
		/* 82167AC4h case    4:*/		return 0x82167AC8;
		  /* 82167AC8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82167AC8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167AC8h case    5:*/		return 0x82167ACC;
		  /* 82167ACCh */ case    6:  		/* bc 4, CR6_EQ, -176 */
		/* 82167ACCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x82167A1C;  }
		/* 82167ACCh case    6:*/		return 0x82167AD0;
	}
	return 0x82167AD0;
} // Block from 82167AB4h-82167AD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82167AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167AD0);
		  /* 82167AD0h */ case    0:  		/* mr R29, R28 */
		/* 82167AD0h case    0:*/		regs.R29 = regs.R28;
		/* 82167AD0h case    0:*/		return 0x82167AD4;
	}
	return 0x82167AD4;
} // Block from 82167AD0h-82167AD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167AD4);
		  /* 82167AD4h */ case    0:  		/* cmpwi CR6, R19, -1 */
		/* 82167AD4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0xFFFFFFFF);
		/* 82167AD4h case    0:*/		return 0x82167AD8;
		  /* 82167AD8h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82167AD8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82167AFC;  }
		/* 82167AD8h case    1:*/		return 0x82167ADC;
		  /* 82167ADCh */ case    2:  		/* cmplw CR6, R27, R21 */
		/* 82167ADCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R21);
		/* 82167ADCh case    2:*/		return 0x82167AE0;
		  /* 82167AE0h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 82167AE0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82167AFC;  }
		/* 82167AE0h case    3:*/		return 0x82167AE4;
		  /* 82167AE4h */ case    4:  		/* mr R5, R21 */
		/* 82167AE4h case    4:*/		regs.R5 = regs.R21;
		/* 82167AE4h case    4:*/		return 0x82167AE8;
		  /* 82167AE8h */ case    5:  		/* mr R4, R19 */
		/* 82167AE8h case    5:*/		regs.R4 = regs.R19;
		/* 82167AE8h case    5:*/		return 0x82167AEC;
		  /* 82167AECh */ case    6:  		/* mr R3, R15 */
		/* 82167AECh case    6:*/		regs.R3 = regs.R15;
		/* 82167AECh case    6:*/		return 0x82167AF0;
		  /* 82167AF0h */ case    7:  		/* bl -12064 */
		/* 82167AF0h case    7:*/		regs.LR = 0x82167AF4; return 0x82164BD0;
		/* 82167AF0h case    7:*/		return 0x82167AF4;
		  /* 82167AF4h */ case    8:  		/* li R19, -1 */
		/* 82167AF4h case    8:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 82167AF4h case    8:*/		return 0x82167AF8;
		  /* 82167AF8h */ case    9:  		/* li R21, 0 */
		/* 82167AF8h case    9:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82167AF8h case    9:*/		return 0x82167AFC;
	}
	return 0x82167AFC;
} // Block from 82167AD4h-82167AFCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82167AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167AFC);
		  /* 82167AFCh */ case    0:  		/* mr R30, R18 */
		/* 82167AFCh case    0:*/		regs.R30 = regs.R18;
		/* 82167AFCh case    0:*/		return 0x82167B00;
	}
	return 0x82167B00;
} // Block from 82167AFCh-82167B00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167B00);
		  /* 82167B00h */ case    0:  		/* lwz R11, <#[R24 + 20]> */
		/* 82167B00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82167B00h case    0:*/		return 0x82167B04;
		  /* 82167B04h */ case    1:  		/* rlwinm R27, R11, 0, 20, 31 */
		/* 82167B04h case    1:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R27,regs.R11);
		/* 82167B04h case    1:*/		return 0x82167B08;
		  /* 82167B08h */ case    2:  		/* cmplw CR6, R27, R16 */
		/* 82167B08h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R16);
		/* 82167B08h case    2:*/		return 0x82167B0C;
		  /* 82167B0Ch */ case    3:  		/* bc 4, CR6_LT, 680 */
		/* 82167B0Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82167DB4;  }
		/* 82167B0Ch case    3:*/		return 0x82167B10;
		  /* 82167B10h */ case    4:  		/* mr R4, R27 */
		/* 82167B10h case    4:*/		regs.R4 = regs.R27;
		/* 82167B10h case    4:*/		return 0x82167B14;
		  /* 82167B14h */ case    5:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167B14h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167B14h case    5:*/		return 0x82167B18;
		  /* 82167B18h */ case    6:  		/* bl -1038456 */
		/* 82167B18h case    6:*/		regs.LR = 0x82167B1C; return 0x8206A2A0;
		/* 82167B18h case    6:*/		return 0x82167B1C;
		  /* 82167B1Ch */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 82167B1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82167B1Ch case    7:*/		return 0x82167B20;
		  /* 82167B20h */ case    8:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82167B20h case    8:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82167B20h case    8:*/		return 0x82167B24;
		  /* 82167B24h */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 82167B24h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82167B24h case    9:*/		return 0x82167B28;
		  /* 82167B28h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82167B28h case   10:*/		if ( regs.CR[6].eq ) { return 0x82167B34;  }
		/* 82167B28h case   10:*/		return 0x82167B2C;
		  /* 82167B2Ch */ case   11:  		/* cmplwi CR6, R11, 5 */
		/* 82167B2Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82167B2Ch case   11:*/		return 0x82167B30;
		  /* 82167B30h */ case   12:  		/* bc 4, CR6_EQ, 644 */
		/* 82167B30h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82167DB4;  }
		/* 82167B30h case   12:*/		return 0x82167B34;
	}
	return 0x82167B34;
} // Block from 82167B00h-82167B34h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82167B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167B34);
		  /* 82167B34h */ case    0:  		/* mr R3, R24 */
		/* 82167B34h case    0:*/		regs.R3 = regs.R24;
		/* 82167B34h case    0:*/		return 0x82167B38;
		  /* 82167B38h */ case    1:  		/* mr R18, R24 */
		/* 82167B38h case    1:*/		regs.R18 = regs.R24;
		/* 82167B38h case    1:*/		return 0x82167B3C;
		  /* 82167B3Ch */ case    2:  		/* bl -14988 */
		/* 82167B3Ch case    2:*/		regs.LR = 0x82167B40; return 0x821640B0;
		/* 82167B3Ch case    2:*/		return 0x82167B40;
		  /* 82167B40h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167B40h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167B40h case    3:*/		return 0x82167B44;
		  /* 82167B44h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82167B44h case    4:*/		if ( regs.CR[0].eq ) { return 0x82167B50;  }
		/* 82167B44h case    4:*/		return 0x82167B48;
		  /* 82167B48h */ case    5:  		/* li R25, 0 */
		/* 82167B48h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82167B48h case    5:*/		return 0x82167B4C;
		  /* 82167B4Ch */ case    6:  		/* li R29, 0 */
		/* 82167B4Ch case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82167B4Ch case    6:*/		return 0x82167B50;
	}
	return 0x82167B50;
} // Block from 82167B34h-82167B50h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82167B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167B50);
		  /* 82167B50h */ case    0:  		/* lwz R31, <#[R24 + 8]> */
		/* 82167B50h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000008) );
		/* 82167B50h case    0:*/		return 0x82167B54;
		  /* 82167B54h */ case    1:  		/* rlwinm. R11, R31, 15, 31, 31 */
		/* 82167B54h case    1:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R31);
		/* 82167B54h case    1:*/		return 0x82167B58;
		  /* 82167B58h */ case    2:  		/* bc 12, CR0_EQ, 56 */
		/* 82167B58h case    2:*/		if ( regs.CR[0].eq ) { return 0x82167B90;  }
		/* 82167B58h case    2:*/		return 0x82167B5C;
		  /* 82167B5Ch */ case    3:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 82167B5Ch case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 82167B5Ch case    3:*/		return 0x82167B60;
		  /* 82167B60h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 82167B60h case    4:*/		if ( regs.CR[0].eq ) { return 0x82167B88;  }
		/* 82167B60h case    4:*/		return 0x82167B64;
		  /* 82167B64h */ case    5:  		/* rlwinm R11, R31, 14, 31, 31 */
		/* 82167B64h case    5:*/		cpu::op::rlwinm<0,14,31,31>(regs,&regs.R11,regs.R31);
		/* 82167B64h case    5:*/		return 0x82167B68;
		  /* 82167B68h */ case    6:  		/* rlwinm R10, R23, 0, 24, 31 */
		/* 82167B68h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R23);
		/* 82167B68h case    6:*/		return 0x82167B6C;
		  /* 82167B6Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82167B6Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82167B6Ch case    7:*/		return 0x82167B70;
		  /* 82167B70h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 82167B70h case    8:*/		if ( regs.CR[6].eq ) { return 0x82167B78;  }
		/* 82167B70h case    8:*/		return 0x82167B74;
		  /* 82167B74h */ case    9:  		/* li R28, 0 */
		/* 82167B74h case    9:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82167B74h case    9:*/		return 0x82167B78;
	}
	return 0x82167B78;
} // Block from 82167B50h-82167B78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82167B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167B78);
		  /* 82167B78h */ case    0:  		/* rlwinm. R11, R31, 0, 25, 25 */
		/* 82167B78h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R31);
		/* 82167B78h case    0:*/		return 0x82167B7C;
		  /* 82167B7Ch */ case    1:  		/* bc 4, CR0_EQ, 76 */
		/* 82167B7Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82167BC8;  }
		/* 82167B7Ch case    1:*/		return 0x82167B80;
		  /* 82167B80h */ case    2:  		/* li R11, 0 */
		/* 82167B80h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82167B80h case    2:*/		return 0x82167B84;
		  /* 82167B84h */ case    3:  		/* b 108 */
		/* 82167B84h case    3:*/		return 0x82167BF0;
		/* 82167B84h case    3:*/		return 0x82167B88;
	}
	return 0x82167B88;
} // Block from 82167B78h-82167B88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82167B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167B88);
		  /* 82167B88h */ case    0:  		/* rlwinm R23, R31, 14, 31, 31 */
		/* 82167B88h case    0:*/		cpu::op::rlwinm<0,14,31,31>(regs,&regs.R23,regs.R31);
		/* 82167B88h case    0:*/		return 0x82167B8C;
		  /* 82167B8Ch */ case    1:  		/* b 52 */
		/* 82167B8Ch case    1:*/		return 0x82167BC0;
		/* 82167B8Ch case    1:*/		return 0x82167B90;
	}
	return 0x82167B90;
} // Block from 82167B88h-82167B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167B90);
		  /* 82167B90h */ case    0:  		/* mr R3, R24 */
		/* 82167B90h case    0:*/		regs.R3 = regs.R24;
		/* 82167B90h case    0:*/		return 0x82167B94;
		  /* 82167B94h */ case    1:  		/* bl -14932 */
		/* 82167B94h case    1:*/		regs.LR = 0x82167B98; return 0x82164140;
		/* 82167B94h case    1:*/		return 0x82167B98;
		  /* 82167B98h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167B98h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167B98h case    2:*/		return 0x82167B9C;
		  /* 82167B9Ch */ case    3:  		/* bc 4, CR0_EQ, -40 */
		/* 82167B9Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82167B74;  }
		/* 82167B9Ch case    3:*/		return 0x82167BA0;
		  /* 82167BA0h */ case    4:  		/* lwz R11, <#[R17 + 76]> */
		/* 82167BA0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 82167BA0h case    4:*/		return 0x82167BA4;
		  /* 82167BA4h */ case    5:  		/* rlwinm. R10, R11, 10, 31, 31 */
		/* 82167BA4h case    5:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R11);
		/* 82167BA4h case    5:*/		return 0x82167BA8;
		  /* 82167BA8h */ case    6:  		/* bc 12, CR0_EQ, -52 */
		/* 82167BA8h case    6:*/		if ( regs.CR[0].eq ) { return 0x82167B74;  }
		/* 82167BA8h case    6:*/		return 0x82167BAC;
		  /* 82167BACh */ case    7:  		/* rlwinm. R10, R26, 0, 24, 31 */
		/* 82167BACh case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R26);
		/* 82167BACh case    7:*/		return 0x82167BB0;
		  /* 82167BB0h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82167BB0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82167BBC;  }
		/* 82167BB0h case    8:*/		return 0x82167BB4;
		  /* 82167BB4h */ case    9:  		/* rlwinm R11, R11, 9, 31, 31 */
		/* 82167BB4h case    9:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82167BB4h case    9:*/		return 0x82167BB8;
		  /* 82167BB8h */ case   10:  		/* b -80 */
		/* 82167BB8h case   10:*/		return 0x82167B68;
		/* 82167BB8h case   10:*/		return 0x82167BBC;
	}
	return 0x82167BBC;
} // Block from 82167B90h-82167BBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82167BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167BBC);
		  /* 82167BBCh */ case    0:  		/* rlwinm R23, R11, 9, 31, 31 */
		/* 82167BBCh case    0:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R23,regs.R11);
		/* 82167BBCh case    0:*/		return 0x82167BC0;
	}
	return 0x82167BC0;
} // Block from 82167BBCh-82167BC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167BC0);
		  /* 82167BC0h */ case    0:  		/* li R26, 1 */
		/* 82167BC0h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82167BC0h case    0:*/		return 0x82167BC4;
		  /* 82167BC4h */ case    1:  		/* b -76 */
		/* 82167BC4h case    1:*/		return 0x82167B78;
		/* 82167BC4h case    1:*/		return 0x82167BC8;
	}
	return 0x82167BC8;
} // Block from 82167BC0h-82167BC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167BC8);
		  /* 82167BC8h */ case    0:  		/* rlwinm R11, R31, 25, 25, 31 */
		/* 82167BC8h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R31);
		/* 82167BC8h case    0:*/		return 0x82167BCC;
		  /* 82167BCCh */ case    1:  		/* cmplwi CR6, R11, 30 */
		/* 82167BCCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001E);
		/* 82167BCCh case    1:*/		return 0x82167BD0;
		  /* 82167BD0h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82167BD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82167BE8;  }
		/* 82167BD0h case    2:*/		return 0x82167BD4;
		  /* 82167BD4h */ case    3:  		/* cmplwi CR6, R11, 55 */
		/* 82167BD4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000037);
		/* 82167BD4h case    3:*/		return 0x82167BD8;
		  /* 82167BD8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82167BD8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82167BE8;  }
		/* 82167BD8h case    4:*/		return 0x82167BDC;
		  /* 82167BDCh */ case    5:  		/* cmplwi CR6, R11, 56 */
		/* 82167BDCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000038);
		/* 82167BDCh case    5:*/		return 0x82167BE0;
		  /* 82167BE0h */ case    6:  		/* li R11, 0 */
		/* 82167BE0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82167BE0h case    6:*/		return 0x82167BE4;
		  /* 82167BE4h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82167BE4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82167BEC;  }
		/* 82167BE4h case    7:*/		return 0x82167BE8;
	}
	return 0x82167BE8;
} // Block from 82167BC8h-82167BE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82167BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167BE8);
		  /* 82167BE8h */ case    0:  		/* li R11, 1 */
		/* 82167BE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82167BE8h case    0:*/		return 0x82167BEC;
	}
	return 0x82167BEC;
} // Block from 82167BE8h-82167BECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167BEC);
		  /* 82167BECh */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82167BECh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167BECh case    0:*/		return 0x82167BF0;
	}
	return 0x82167BF0;
} // Block from 82167BECh-82167BF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167BF0);
		  /* 82167BF0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167BF0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167BF0h case    0:*/		return 0x82167BF4;
		  /* 82167BF4h */ case    1:  		/* bc 12, CR0_EQ, 308 */
		/* 82167BF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82167D28;  }
		/* 82167BF4h case    1:*/		return 0x82167BF8;
		  /* 82167BF8h */ case    2:  		/* cmpwi CR6, R19, -1 */
		/* 82167BF8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R19,0xFFFFFFFF);
		/* 82167BF8h case    2:*/		return 0x82167BFC;
		  /* 82167BFCh */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 82167BFCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82167C04;  }
		/* 82167BFCh case    3:*/		return 0x82167C00;
		  /* 82167C00h */ case    4:  		/* mr R19, R27 */
		/* 82167C00h case    4:*/		regs.R19 = regs.R27;
		/* 82167C00h case    4:*/		return 0x82167C04;
	}
	return 0x82167C04;
} // Block from 82167BF0h-82167C04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C04);
		  /* 82167C04h */ case    0:  		/* lwz R8, <#[R24 + 4]> */
		/* 82167C04h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000004) );
		/* 82167C04h case    0:*/		return 0x82167C08;
		  /* 82167C08h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 82167C08h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82167C08h case    1:*/		return 0x82167C0C;
		  /* 82167C0Ch */ case    2:  		/* bc 12, CR6_EQ, 284 */
		/* 82167C0Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82167D28;  }
		/* 82167C0Ch case    2:*/		return 0x82167C10;
		  /* 82167C10h */ case    3:  		/* lwz R9, <#[R8 + 16]> */
		/* 82167C10h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000010) );
		/* 82167C10h case    3:*/		return 0x82167C14;
		  /* 82167C14h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82167C14h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82167C14h case    4:*/		return 0x82167C18;
		  /* 82167C18h */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 82167C18h case    5:*/		if ( regs.CR[6].eq ) { return 0x82167C5C;  }
		/* 82167C18h case    5:*/		return 0x82167C1C;
		  /* 82167C1Ch */ case    6:  		/* lwz R10, <#[R8]> */
		/* 82167C1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82167C1Ch case    6:*/		return 0x82167C20;
		  /* 82167C20h */ case    7:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 82167C20h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 82167C20h case    7:*/		return 0x82167C24;
		  /* 82167C24h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82167C24h case    8:*/		if ( regs.CR[0].eq ) { return 0x82167C34;  }
		/* 82167C24h case    8:*/		return 0x82167C28;
		  /* 82167C28h */ case    9:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82167C28h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82167C28h case    9:*/		return 0x82167C2C;
		  /* 82167C2Ch */ case   10:  		/* li R11, 1 */
		/* 82167C2Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82167C2Ch case   10:*/		return 0x82167C30;
		  /* 82167C30h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82167C30h case   11:*/		if ( regs.CR[0].eq ) { return 0x82167C38;  }
		/* 82167C30h case   11:*/		return 0x82167C34;
	}
	return 0x82167C34;
} // Block from 82167C04h-82167C34h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82167C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C34);
		  /* 82167C34h */ case    0:  		/* li R11, 0 */
		/* 82167C34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82167C34h case    0:*/		return 0x82167C38;
	}
	return 0x82167C38;
} // Block from 82167C34h-82167C38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C38);
		  /* 82167C38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167C38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167C38h case    0:*/		return 0x82167C3C;
		  /* 82167C3Ch */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 82167C3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82167C5C;  }
		/* 82167C3Ch case    1:*/		return 0x82167C40;
		  /* 82167C40h */ case    2:  		/* rlwinm. R11, R10, 0, 7, 18 */
		/* 82167C40h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R10);
		/* 82167C40h case    2:*/		return 0x82167C44;
		  /* 82167C44h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 82167C44h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82167C5C;  }
		/* 82167C44h case    3:*/		return 0x82167C48;
		  /* 82167C48h */ case    4:  		/* lwz R11, <#[R9 + 20]> */
		/* 82167C48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82167C48h case    4:*/		return 0x82167C4C;
		  /* 82167C4Ch */ case    5:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82167C4Ch case    5:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82167C4Ch case    5:*/		return 0x82167C50;
		  /* 82167C50h */ case    6:  		/* cmplw CR6, R11, R21 */
		/* 82167C50h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 82167C50h case    6:*/		return 0x82167C54;
		  /* 82167C54h */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 82167C54h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82167C5C;  }
		/* 82167C54h case    7:*/		return 0x82167C58;
		  /* 82167C58h */ case    8:  		/* mr R21, R11 */
		/* 82167C58h case    8:*/		regs.R21 = regs.R11;
		/* 82167C58h case    8:*/		return 0x82167C5C;
	}
	return 0x82167C5C;
} // Block from 82167C38h-82167C5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82167C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C5C);
		  /* 82167C5Ch */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 82167C5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82167C5Ch case    0:*/		return 0x82167C60;
		  /* 82167C60h */ case    1:  		/* b -88 */
		/* 82167C60h case    1:*/		return 0x82167C08;
		/* 82167C60h case    1:*/		return 0x82167C64;
	}
	return 0x82167C64;
} // Block from 82167C5Ch-82167C64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C64);
		  /* 82167C64h */ case    0:  		/* cmplwi CR6, R10, 91 */
		/* 82167C64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 82167C64h case    0:*/		return 0x82167C68;
		  /* 82167C68h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82167C68h case    1:*/		if ( regs.CR[6].lt ) { return 0x82167C78;  }
		/* 82167C68h case    1:*/		return 0x82167C6C;
		  /* 82167C6Ch */ case    2:  		/* cmplwi CR6, R10, 94 */
		/* 82167C6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 82167C6Ch case    2:*/		return 0x82167C70;
		  /* 82167C70h */ case    3:  		/* li R11, 1 */
		/* 82167C70h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82167C70h case    3:*/		return 0x82167C74;
		  /* 82167C74h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82167C74h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82167C7C;  }
		/* 82167C74h case    4:*/		return 0x82167C78;
	}
	return 0x82167C78;
} // Block from 82167C64h-82167C78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C78);
		  /* 82167C78h */ case    0:  		/* li R11, 0 */
		/* 82167C78h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82167C78h case    0:*/		return 0x82167C7C;
	}
	return 0x82167C7C;
} // Block from 82167C78h-82167C7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C7C);
		  /* 82167C7Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167C7Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167C7Ch case    0:*/		return 0x82167C80;
		  /* 82167C80h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82167C80h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82167C8C;  }
		/* 82167C80h case    1:*/		return 0x82167C84;
		  /* 82167C84h */ case    2:  		/* cmplwi CR6, R10, 95 */
		/* 82167C84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005F);
		/* 82167C84h case    2:*/		return 0x82167C88;
		  /* 82167C88h */ case    3:  		/* bc 4, CR6_EQ, 304 */
		/* 82167C88h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82167DB8;  }
		/* 82167C88h case    3:*/		return 0x82167C8C;
	}
	return 0x82167C8C;
} // Block from 82167C7Ch-82167C8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82167C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167C8C);
		  /* 82167C8Ch */ case    0:  		/* cmpwi CR6, R27, -1 */
		/* 82167C8Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0xFFFFFFFF);
		/* 82167C8Ch case    0:*/		return 0x82167C90;
		  /* 82167C90h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 82167C90h case    1:*/		if ( regs.CR[6].eq ) { return 0x82167CCC;  }
		/* 82167C90h case    1:*/		return 0x82167C94;
		  /* 82167C94h */ case    2:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82167C94h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82167C94h case    2:*/		return 0x82167C98;
		  /* 82167C98h */ case    3:  		/* bc 12, CR0_EQ, 52 */
		/* 82167C98h case    3:*/		if ( regs.CR[0].eq ) { return 0x82167CCC;  }
		/* 82167C98h case    3:*/		return 0x82167C9C;
		  /* 82167C9Ch */ case    4:  		/* mr R7, R23 */
		/* 82167C9Ch case    4:*/		regs.R7 = regs.R23;
		/* 82167C9Ch case    4:*/		return 0x82167CA0;
		  /* 82167CA0h */ case    5:  		/* mr R6, R30 */
		/* 82167CA0h case    5:*/		regs.R6 = regs.R30;
		/* 82167CA0h case    5:*/		return 0x82167CA4;
		  /* 82167CA4h */ case    6:  		/* mr R5, R22 */
		/* 82167CA4h case    6:*/		regs.R5 = regs.R22;
		/* 82167CA4h case    6:*/		return 0x82167CA8;
		  /* 82167CA8h */ case    7:  		/* mr R4, R27 */
		/* 82167CA8h case    7:*/		regs.R4 = regs.R27;
		/* 82167CA8h case    7:*/		return 0x82167CAC;
		  /* 82167CACh */ case    8:  		/* mr R3, R15 */
		/* 82167CACh case    8:*/		regs.R3 = regs.R15;
		/* 82167CACh case    8:*/		return 0x82167CB0;
		  /* 82167CB0h */ case    9:  		/* bl -12736 */
		/* 82167CB0h case    9:*/		regs.LR = 0x82167CB4; return 0x82164AF0;
		/* 82167CB0h case    9:*/		return 0x82167CB4;
		  /* 82167CB4h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167CB4h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167CB4h case   10:*/		return 0x82167CB8;
		  /* 82167CB8h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 82167CB8h case   11:*/		if ( regs.CR[0].eq ) { return 0x82167CCC;  }
		/* 82167CB8h case   11:*/		return 0x82167CBC;
		  /* 82167CBCh */ case   12:  		/* mr R5, R23 */
		/* 82167CBCh case   12:*/		regs.R5 = regs.R23;
		/* 82167CBCh case   12:*/		return 0x82167CC0;
		  /* 82167CC0h */ case   13:  		/* mr R4, R27 */
		/* 82167CC0h case   13:*/		regs.R4 = regs.R27;
		/* 82167CC0h case   13:*/		return 0x82167CC4;
		  /* 82167CC4h */ case   14:  		/* mr R3, R15 */
		/* 82167CC4h case   14:*/		regs.R3 = regs.R15;
		/* 82167CC4h case   14:*/		return 0x82167CC8;
		  /* 82167CC8h */ case   15:  		/* bl -12616 */
		/* 82167CC8h case   15:*/		regs.LR = 0x82167CCC; return 0x82164B80;
		/* 82167CC8h case   15:*/		return 0x82167CCC;
	}
	return 0x82167CCC;
} // Block from 82167C8Ch-82167CCCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82167CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167CCC);
		  /* 82167CCCh */ case    0:  		/* lwz R10, <#[R24 + 8]> */
		/* 82167CCCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 82167CCCh case    0:*/		return 0x82167CD0;
		  /* 82167CD0h */ case    1:  		/* li R26, 0 */
		/* 82167CD0h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82167CD0h case    1:*/		return 0x82167CD4;
		  /* 82167CD4h */ case    2:  		/* li R28, 1 */
		/* 82167CD4h case    2:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82167CD4h case    2:*/		return 0x82167CD8;
		  /* 82167CD8h */ case    3:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 82167CD8h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 82167CD8h case    3:*/		return 0x82167CDC;
		  /* 82167CDCh */ case    4:  		/* li R27, -1 */
		/* 82167CDCh case    4:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 82167CDCh case    4:*/		return 0x82167CE0;
		  /* 82167CE0h */ case    5:  		/* li R25, 1 */
		/* 82167CE0h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82167CE0h case    5:*/		return 0x82167CE4;
		  /* 82167CE4h */ case    6:  		/* cmplwi CR6, R11, 91 */
		/* 82167CE4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005B);
		/* 82167CE4h case    6:*/		return 0x82167CE8;
		  /* 82167CE8h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 82167CE8h case    7:*/		if ( regs.CR[6].lt ) { return 0x82167CF8;  }
		/* 82167CE8h case    7:*/		return 0x82167CEC;
		  /* 82167CECh */ case    8:  		/* cmplwi CR6, R11, 94 */
		/* 82167CECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005E);
		/* 82167CECh case    8:*/		return 0x82167CF0;
		  /* 82167CF0h */ case    9:  		/* li R9, 1 */
		/* 82167CF0h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82167CF0h case    9:*/		return 0x82167CF4;
		  /* 82167CF4h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 82167CF4h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82167CFC;  }
		/* 82167CF4h case   10:*/		return 0x82167CF8;
	}
	return 0x82167CF8;
} // Block from 82167CCCh-82167CF8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82167CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167CF8);
		  /* 82167CF8h */ case    0:  		/* li R9, 0 */
		/* 82167CF8h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82167CF8h case    0:*/		return 0x82167CFC;
	}
	return 0x82167CFC;
} // Block from 82167CF8h-82167CFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167CFC);
		  /* 82167CFCh */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82167CFCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82167CFCh case    0:*/		return 0x82167D00;
		  /* 82167D00h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82167D00h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82167D10;  }
		/* 82167D00h case    1:*/		return 0x82167D04;
		  /* 82167D04h */ case    2:  		/* cmplwi CR6, R11, 123 */
		/* 82167D04h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007B);
		/* 82167D04h case    2:*/		return 0x82167D08;
		  /* 82167D08h */ case    3:  		/* li R11, 0 */
		/* 82167D08h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82167D08h case    3:*/		return 0x82167D0C;
		  /* 82167D0Ch */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82167D0Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82167D14;  }
		/* 82167D0Ch case    4:*/		return 0x82167D10;
	}
	return 0x82167D10;
} // Block from 82167CFCh-82167D10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167D10);
		  /* 82167D10h */ case    0:  		/* li R11, 1 */
		/* 82167D10h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82167D10h case    0:*/		return 0x82167D14;
	}
	return 0x82167D14;
} // Block from 82167D10h-82167D14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167D14);
		  /* 82167D14h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82167D14h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82167D14h case    0:*/		return 0x82167D18;
		  /* 82167D18h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82167D18h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82167D24;  }
		/* 82167D18h case    1:*/		return 0x82167D1C;
		  /* 82167D1Ch */ case    2:  		/* rlwinm. R11, R10, 15, 31, 31 */
		/* 82167D1Ch case    2:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R10);
		/* 82167D1Ch case    2:*/		return 0x82167D20;
		  /* 82167D20h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82167D20h case    3:*/		if ( regs.CR[0].eq ) { return 0x82167D28;  }
		/* 82167D20h case    3:*/		return 0x82167D24;
	}
	return 0x82167D24;
} // Block from 82167D14h-82167D24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82167D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167D24);
		  /* 82167D24h */ case    0:  		/* li R29, 1 */
		/* 82167D24h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82167D24h case    0:*/		return 0x82167D28;
	}
	return 0x82167D28;
} // Block from 82167D24h-82167D28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167D28);
		  /* 82167D28h */ case    0:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 82167D28h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 82167D28h case    0:*/		return 0x82167D2C;
		  /* 82167D2Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82167D2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82167D2Ch case    1:*/		return 0x82167D30;
		  /* 82167D30h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167D30h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167D30h case    2:*/		return 0x82167D34;
		  /* 82167D34h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82167D34h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82167D44;  }
		/* 82167D34h case    3:*/		return 0x82167D38;
		  /* 82167D38h */ case    4:  		/* mr R24, R11 */
		/* 82167D38h case    4:*/		regs.R24 = regs.R11;
		/* 82167D38h case    4:*/		return 0x82167D3C;
		  /* 82167D3Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82167D3Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167D3Ch case    5:*/		return 0x82167D40;
		  /* 82167D40h */ case    6:  		/* bc 4, CR6_EQ, -1192 */
		/* 82167D40h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82167898;  }
		/* 82167D40h case    6:*/		return 0x82167D44;
	}
	return 0x82167D44;
} // Block from 82167D28h-82167D44h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82167D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167D44);
		  /* 82167D44h */ case    0:  		/* rlwinm R11, R17, 0, 0, 30 */
		/* 82167D44h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R17);
		/* 82167D44h case    0:*/		return 0x82167D48;
		  /* 82167D48h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82167D48h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82167D48h case    1:*/		return 0x82167D4C;
		  /* 82167D4Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167D4Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167D4Ch case    2:*/		return 0x82167D50;
		  /* 82167D50h */ case    3:  		/* bc 4, CR0_EQ, 104 */
		/* 82167D50h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82167DB8;  }
		/* 82167D50h case    3:*/		return 0x82167D54;
		  /* 82167D54h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82167D54h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167D54h case    4:*/		return 0x82167D58;
		  /* 82167D58h */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 82167D58h case    5:*/		if ( regs.CR[6].eq ) { return 0x82167DB8;  }
		/* 82167D58h case    5:*/		return 0x82167D5C;
		  /* 82167D5Ch */ case    6:  		/* lwz R10, <#[R11 + 76]> */
		/* 82167D5Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 82167D5Ch case    6:*/		return 0x82167D60;
		  /* 82167D60h */ case    7:  		/* rlwinm. R10, R10, 0, 10, 10 */
		/* 82167D60h case    7:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R10);
		/* 82167D60h case    7:*/		return 0x82167D64;
		  /* 82167D64h */ case    8:  		/* bc 4, CR0_EQ, 84 */
		/* 82167D64h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82167DB8;  }
		/* 82167D64h case    8:*/		return 0x82167D68;
		  /* 82167D68h */ case    9:  		/* lwz R10, <#[R11 + 48]> */
		/* 82167D68h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82167D68h case    9:*/		return 0x82167D6C;
		  /* 82167D6Ch */ case   10:  		/* rlwinm. R9, R10, 8, 31, 31 */
		/* 82167D6Ch case   10:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R9,regs.R10);
		/* 82167D6Ch case   10:*/		return 0x82167D70;
		  /* 82167D70h */ case   11:  		/* bc 4, CR0_EQ, 72 */
		/* 82167D70h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82167DB8;  }
		/* 82167D70h case   11:*/		return 0x82167D74;
		  /* 82167D74h */ case   12:  		/* rlwinm. R10, R10, 0, 6, 6 */
		/* 82167D74h case   12:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R10);
		/* 82167D74h case   12:*/		return 0x82167D78;
		  /* 82167D78h */ case   13:  		/* bc 4, CR0_EQ, 64 */
		/* 82167D78h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82167DB8;  }
		/* 82167D78h case   13:*/		return 0x82167D7C;
		  /* 82167D7Ch */ case   14:  		/* lwz R10, <#[R11 + 28]> */
		/* 82167D7Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82167D7Ch case   14:*/		return 0x82167D80;
		  /* 82167D80h */ case   15:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82167D80h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82167D80h case   15:*/		return 0x82167D84;
		  /* 82167D84h */ case   16:  		/* bc 4, CR0_EQ, 380 */
		/* 82167D84h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82167F00;  }
		/* 82167D84h case   16:*/		return 0x82167D88;
		  /* 82167D88h */ case   17:  		/* cmplwi CR0, R10, 0 */
		/* 82167D88h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82167D88h case   17:*/		return 0x82167D8C;
		  /* 82167D8Ch */ case   18:  		/* bc 12, CR0_EQ, 372 */
		/* 82167D8Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x82167F00;  }
		/* 82167D8Ch case   18:*/		return 0x82167D90;
		  /* 82167D90h */ case   19:  		/* lwz R9, <#[R10 + 8]> */
		/* 82167D90h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82167D90h case   19:*/		return 0x82167D94;
		  /* 82167D94h */ case   20:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82167D94h case   20:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82167D94h case   20:*/		return 0x82167D98;
		  /* 82167D98h */ case   21:  		/* cmplwi CR6, R9, 16128 */
		/* 82167D98h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003F00);
		/* 82167D98h case   21:*/		return 0x82167D9C;
		  /* 82167D9Ch */ case   22:  		/* bc 4, CR6_EQ, 356 */
		/* 82167D9Ch case   22:*/		if ( !regs.CR[6].eq ) { return 0x82167F00;  }
		/* 82167D9Ch case   22:*/		return 0x82167DA0;
		  /* 82167DA0h */ case   23:  		/* lhz R10, <#[R10 + 20]> */
		/* 82167DA0h case   23:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 82167DA0h case   23:*/		return 0x82167DA4;
		  /* 82167DA4h */ case   24:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82167DA4h case   24:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82167DA4h case   24:*/		return 0x82167DA8;
		  /* 82167DA8h */ case   25:  		/* bc 4, CR0_EQ, 16 */
		/* 82167DA8h case   25:*/		if ( !regs.CR[0].eq ) { return 0x82167DB8;  }
		/* 82167DA8h case   25:*/		return 0x82167DAC;
		  /* 82167DACh */ case   26:  		/* mr R17, R11 */
		/* 82167DACh case   26:*/		regs.R17 = regs.R11;
		/* 82167DACh case   26:*/		return 0x82167DB0;
		  /* 82167DB0h */ case   27:  		/* b -1332 */
		/* 82167DB0h case   27:*/		return 0x8216787C;
		/* 82167DB0h case   27:*/		return 0x82167DB4;
	}
	return 0x82167DB4;
} // Block from 82167D44h-82167DB4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82167DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167DB4);
		  /* 82167DB4h */ case    0:  		/* li R27, -1 */
		/* 82167DB4h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 82167DB4h case    0:*/		return 0x82167DB8;
	}
	return 0x82167DB8;
} // Block from 82167DB4h-82167DB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167DB8);
		  /* 82167DB8h */ case    0:  		/* cmpwi CR6, R27, -1 */
		/* 82167DB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0xFFFFFFFF);
		/* 82167DB8h case    0:*/		return 0x82167DBC;
		  /* 82167DBCh */ case    1:  		/* bc 12, CR6_EQ, 100 */
		/* 82167DBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82167E20;  }
		/* 82167DBCh case    1:*/		return 0x82167DC0;
		  /* 82167DC0h */ case    2:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82167DC0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82167DC0h case    2:*/		return 0x82167DC4;
		  /* 82167DC4h */ case    3:  		/* bc 12, CR0_EQ, 92 */
		/* 82167DC4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82167E20;  }
		/* 82167DC4h case    3:*/		return 0x82167DC8;
		  /* 82167DC8h */ case    4:  		/* mr R4, R27 */
		/* 82167DC8h case    4:*/		regs.R4 = regs.R27;
		/* 82167DC8h case    4:*/		return 0x82167DCC;
		  /* 82167DCCh */ case    5:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167DCCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167DCCh case    5:*/		return 0x82167DD0;
		  /* 82167DD0h */ case    6:  		/* bl -1039152 */
		/* 82167DD0h case    6:*/		regs.LR = 0x82167DD4; return 0x8206A2A0;
		/* 82167DD0h case    6:*/		return 0x82167DD4;
		  /* 82167DD4h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 82167DD4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82167DD4h case    7:*/		return 0x82167DD8;
		  /* 82167DD8h */ case    8:  		/* lwz R10, <#[R18 + 20]> */
		/* 82167DD8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R18 + 0x00000014) );
		/* 82167DD8h case    8:*/		return 0x82167DDC;
		  /* 82167DDCh */ case    9:  		/* rlwinm R11, R11, 20, 29, 31 */
		/* 82167DDCh case    9:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R11,regs.R11);
		/* 82167DDCh case    9:*/		return 0x82167DE0;
		  /* 82167DE0h */ case   10:  		/* rlwinm R10, R10, 20, 29, 31 */
		/* 82167DE0h case   10:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R10,regs.R10);
		/* 82167DE0h case   10:*/		return 0x82167DE4;
		  /* 82167DE4h */ case   11:  		/* addi R11, R11, -1 */
		/* 82167DE4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82167DE4h case   11:*/		return 0x82167DE8;
		  /* 82167DE8h */ case   12:  		/* cmplw CR6, R10, R11 */
		/* 82167DE8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82167DE8h case   12:*/		return 0x82167DEC;
		  /* 82167DECh */ case   13:  		/* bc 4, CR6_EQ, 52 */
		/* 82167DECh case   13:*/		if ( !regs.CR[6].eq ) { return 0x82167E20;  }
		/* 82167DECh case   13:*/		return 0x82167DF0;
		  /* 82167DF0h */ case   14:  		/* mr R7, R23 */
		/* 82167DF0h case   14:*/		regs.R7 = regs.R23;
		/* 82167DF0h case   14:*/		return 0x82167DF4;
		  /* 82167DF4h */ case   15:  		/* mr R6, R30 */
		/* 82167DF4h case   15:*/		regs.R6 = regs.R30;
		/* 82167DF4h case   15:*/		return 0x82167DF8;
		  /* 82167DF8h */ case   16:  		/* mr R5, R22 */
		/* 82167DF8h case   16:*/		regs.R5 = regs.R22;
		/* 82167DF8h case   16:*/		return 0x82167DFC;
		  /* 82167DFCh */ case   17:  		/* mr R4, R27 */
		/* 82167DFCh case   17:*/		regs.R4 = regs.R27;
		/* 82167DFCh case   17:*/		return 0x82167E00;
		  /* 82167E00h */ case   18:  		/* mr R3, R15 */
		/* 82167E00h case   18:*/		regs.R3 = regs.R15;
		/* 82167E00h case   18:*/		return 0x82167E04;
		  /* 82167E04h */ case   19:  		/* bl -13076 */
		/* 82167E04h case   19:*/		regs.LR = 0x82167E08; return 0x82164AF0;
		/* 82167E04h case   19:*/		return 0x82167E08;
		  /* 82167E08h */ case   20:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82167E08h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82167E08h case   20:*/		return 0x82167E0C;
		  /* 82167E0Ch */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 82167E0Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x82167E20;  }
		/* 82167E0Ch case   21:*/		return 0x82167E10;
		  /* 82167E10h */ case   22:  		/* mr R5, R23 */
		/* 82167E10h case   22:*/		regs.R5 = regs.R23;
		/* 82167E10h case   22:*/		return 0x82167E14;
		  /* 82167E14h */ case   23:  		/* mr R4, R27 */
		/* 82167E14h case   23:*/		regs.R4 = regs.R27;
		/* 82167E14h case   23:*/		return 0x82167E18;
		  /* 82167E18h */ case   24:  		/* mr R3, R15 */
		/* 82167E18h case   24:*/		regs.R3 = regs.R15;
		/* 82167E18h case   24:*/		return 0x82167E1C;
		  /* 82167E1Ch */ case   25:  		/* bl -12956 */
		/* 82167E1Ch case   25:*/		regs.LR = 0x82167E20; return 0x82164B80;
		/* 82167E1Ch case   25:*/		return 0x82167E20;
	}
	return 0x82167E20;
} // Block from 82167DB8h-82167E20h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82167E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167E20);
		  /* 82167E20h */ case    0:  		/* cmpwi CR6, R19, -1 */
		/* 82167E20h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0xFFFFFFFF);
		/* 82167E20h case    0:*/		return 0x82167E24;
		  /* 82167E24h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 82167E24h case    1:*/		if ( regs.CR[6].eq ) { return 0x82167E4C;  }
		/* 82167E24h case    1:*/		return 0x82167E28;
		  /* 82167E28h */ case    2:  		/* lwz R11, <#[R18 + 20]> */
		/* 82167E28h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000014) );
		/* 82167E28h case    2:*/		return 0x82167E2C;
		  /* 82167E2Ch */ case    3:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82167E2Ch case    3:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82167E2Ch case    3:*/		return 0x82167E30;
		  /* 82167E30h */ case    4:  		/* cmplw CR6, R21, R11 */
		/* 82167E30h case    4:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 82167E30h case    4:*/		return 0x82167E34;
		  /* 82167E34h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 82167E34h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82167E3C;  }
		/* 82167E34h case    5:*/		return 0x82167E38;
		  /* 82167E38h */ case    6:  		/* mr R21, R11 */
		/* 82167E38h case    6:*/		regs.R21 = regs.R11;
		/* 82167E38h case    6:*/		return 0x82167E3C;
	}
	return 0x82167E3C;
} // Block from 82167E20h-82167E3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82167E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167E3C);
		  /* 82167E3Ch */ case    0:  		/* mr R5, R21 */
		/* 82167E3Ch case    0:*/		regs.R5 = regs.R21;
		/* 82167E3Ch case    0:*/		return 0x82167E40;
		  /* 82167E40h */ case    1:  		/* mr R4, R19 */
		/* 82167E40h case    1:*/		regs.R4 = regs.R19;
		/* 82167E40h case    1:*/		return 0x82167E44;
		  /* 82167E44h */ case    2:  		/* mr R3, R15 */
		/* 82167E44h case    2:*/		regs.R3 = regs.R15;
		/* 82167E44h case    2:*/		return 0x82167E48;
		  /* 82167E48h */ case    3:  		/* bl -12920 */
		/* 82167E48h case    3:*/		regs.LR = 0x82167E4C; return 0x82164BD0;
		/* 82167E48h case    3:*/		return 0x82167E4C;
	}
	return 0x82167E4C;
} // Block from 82167E3Ch-82167E4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82167E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167E4C);
		  /* 82167E4Ch */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82167E4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82167E4Ch case    0:*/		return 0x82167E50;
		  /* 82167E50h */ case    1:  		/* li R19, -1 */
		/* 82167E50h case    1:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 82167E50h case    1:*/		return 0x82167E54;
		  /* 82167E54h */ case    2:  		/* lwz R16, <#[R1 + 108]> */
		/* 82167E54h case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x0000006C) );
		/* 82167E54h case    2:*/		return 0x82167E58;
		  /* 82167E58h */ case    3:  		/* li R23, 0 */
		/* 82167E58h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82167E58h case    3:*/		return 0x82167E5C;
		  /* 82167E5Ch */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82167E5Ch case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82167E5Ch case    4:*/		return 0x82167E60;
		  /* 82167E60h */ case    5:  		/* lwz R21, <#[R1 + 100]> */
		/* 82167E60h case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 82167E60h case    5:*/		return 0x82167E64;
		  /* 82167E64h */ case    6:  		/* lwz R18, <#[R1 + 104]> */
		/* 82167E64h case    6:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 82167E64h case    6:*/		return 0x82167E68;
		  /* 82167E68h */ case    7:  		/* li R22, 1 */
		/* 82167E68h case    7:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82167E68h case    7:*/		return 0x82167E6C;
		  /* 82167E6Ch */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82167E6Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82167E6Ch case    8:*/		return 0x82167E70;
		  /* 82167E70h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82167E70h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167E70h case    9:*/		return 0x82167E74;
		  /* 82167E74h */ case   10:  		/* bc 4, CR0_EQ, 60 */
		/* 82167E74h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82167EB0;  }
		/* 82167E74h case   10:*/		return 0x82167E78;
		  /* 82167E78h */ case   11:  		/* mr R17, R11 */
		/* 82167E78h case   11:*/		regs.R17 = regs.R11;
		/* 82167E78h case   11:*/		return 0x82167E7C;
		  /* 82167E7Ch */ case   12:  		/* stw R11, <#[R1 + 96]> */
		/* 82167E7Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82167E7Ch case   12:*/		return 0x82167E80;
		  /* 82167E80h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 82167E80h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167E80h case   13:*/		return 0x82167E84;
		  /* 82167E84h */ case   14:  		/* bc 4, CR6_EQ, -2464 */
		/* 82167E84h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821674E4;  }
		/* 82167E84h case   14:*/		return 0x82167E88;
	}
	return 0x82167E88;
} // Block from 82167E4Ch-82167E88h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82167E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167E88);
		  /* 82167E88h */ case    0:  		/* lwz R14, <#[R1 + 492]> */
		/* 82167E88h case    0:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x000001EC) );
		/* 82167E88h case    0:*/		return 0x82167E8C;
		  /* 82167E8Ch */ case    1:  		/* lwz R25, <#[R1 + 476]> */
		/* 82167E8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000001DC) );
		/* 82167E8Ch case    1:*/		return 0x82167E90;
	}
	return 0x82167E90;
} // Block from 82167E88h-82167E90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167E90);
		  /* 82167E90h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82167E90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82167E90h case    0:*/		return 0x82167E94;
		  /* 82167E94h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82167E94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167E94h case    1:*/		return 0x82167E98;
		  /* 82167E98h */ case    2:  		/* bc 12, CR6_EQ, 144 */
		/* 82167E98h case    2:*/		if ( regs.CR[6].eq ) { return 0x82167F28;  }
		/* 82167E98h case    2:*/		return 0x82167E9C;
		  /* 82167E9Ch */ case    3:  		/* lwz R10, <#[R15 + 740]> */
		/* 82167E9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x000002E4) );
		/* 82167E9Ch case    3:*/		return 0x82167EA0;
		  /* 82167EA0h */ case    4:  		/* lwz R11, <#[R15 + 736]> */
		/* 82167EA0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002E0) );
		/* 82167EA0h case    4:*/		return 0x82167EA4;
		  /* 82167EA4h */ case    5:  		/* mulli R10, R10, 12 */
		/* 82167EA4h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82167EA4h case    5:*/		return 0x82167EA8;
		  /* 82167EA8h */ case    6:  		/* add R27, R10, R11 */
		/* 82167EA8h case    6:*/		cpu::op::add<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 82167EA8h case    6:*/		return 0x82167EAC;
		  /* 82167EACh */ case    7:  		/* b 128 */
		/* 82167EACh case    7:*/		return 0x82167F2C;
		/* 82167EACh case    7:*/		return 0x82167EB0;
	}
	return 0x82167EB0;
} // Block from 82167E90h-82167EB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82167EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167EB0);
		  /* 82167EB0h */ case    0:  		/* mr R17, R23 */
		/* 82167EB0h case    0:*/		regs.R17 = regs.R23;
		/* 82167EB0h case    0:*/		return 0x82167EB4;
		  /* 82167EB4h */ case    1:  		/* b -44 */
		/* 82167EB4h case    1:*/		return 0x82167E88;
		/* 82167EB4h case    1:*/		return 0x82167EB8;
	}
	return 0x82167EB8;
} // Block from 82167EB0h-82167EB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82167EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167EB8);
		  /* 82167EB8h */ case    0:  		/* li R4, 4800 */
		/* 82167EB8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167EB8h case    0:*/		return 0x82167EBC;
		  /* 82167EBCh */ case    1:  		/* mr R3, R15 */
		/* 82167EBCh case    1:*/		regs.R3 = regs.R15;
		/* 82167EBCh case    1:*/		return 0x82167EC0;
		  /* 82167EC0h */ case    2:  		/* bl -90200 */
		/* 82167EC0h case    2:*/		regs.LR = 0x82167EC4; return 0x82151E68;
		/* 82167EC0h case    2:*/		return 0x82167EC4;
	}
	return 0x82167EC4;
} // Block from 82167EB8h-82167EC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82167EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167EC4);
		  /* 82167EC4h */ case    0:  		/* rlwinm R11, R31, 0, 0, 19 */
		/* 82167EC4h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R31);
		/* 82167EC4h case    0:*/		return 0x82167EC8;
		  /* 82167EC8h */ case    1:  		/* li R4, 4800 */
		/* 82167EC8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167EC8h case    1:*/		return 0x82167ECC;
		  /* 82167ECCh */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82167ECCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82167ECCh case    2:*/		return 0x82167ED0;
		  /* 82167ED0h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82167ED0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82167ED0h case    3:*/		return 0x82167ED4;
		  /* 82167ED4h */ case    4:  		/* bl -90220 */
		/* 82167ED4h case    4:*/		regs.LR = 0x82167ED8; return 0x82151E68;
		/* 82167ED4h case    4:*/		return 0x82167ED8;
	}
	return 0x82167ED8;
} // Block from 82167EC4h-82167ED8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167ED8);
		  /* 82167ED8h */ case    0:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 82167ED8h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 82167ED8h case    0:*/		return 0x82167EDC;
		  /* 82167EDCh */ case    1:  		/* li R4, 4800 */
		/* 82167EDCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167EDCh case    1:*/		return 0x82167EE0;
		  /* 82167EE0h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82167EE0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82167EE0h case    2:*/		return 0x82167EE4;
		  /* 82167EE4h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82167EE4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82167EE4h case    3:*/		return 0x82167EE8;
		  /* 82167EE8h */ case    4:  		/* bl -90240 */
		/* 82167EE8h case    4:*/		regs.LR = 0x82167EEC; return 0x82151E68;
		/* 82167EE8h case    4:*/		return 0x82167EEC;
	}
	return 0x82167EEC;
} // Block from 82167ED8h-82167EECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167EEC);
		  /* 82167EECh */ case    0:  		/* rlwinm R11, R30, 0, 0, 19 */
		/* 82167EECh case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R30);
		/* 82167EECh case    0:*/		return 0x82167EF0;
		  /* 82167EF0h */ case    1:  		/* li R4, 4800 */
		/* 82167EF0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167EF0h case    1:*/		return 0x82167EF4;
		  /* 82167EF4h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82167EF4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82167EF4h case    2:*/		return 0x82167EF8;
		  /* 82167EF8h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82167EF8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82167EF8h case    3:*/		return 0x82167EFC;
		  /* 82167EFCh */ case    4:  		/* bl -90260 */
		/* 82167EFCh case    4:*/		regs.LR = 0x82167F00; return 0x82151E68;
		/* 82167EFCh case    4:*/		return 0x82167F00;
	}
	return 0x82167F00;
} // Block from 82167EECh-82167F00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F00);
		  /* 82167F00h */ case    0:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 82167F00h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 82167F00h case    0:*/		return 0x82167F04;
		  /* 82167F04h */ case    1:  		/* li R4, 4800 */
		/* 82167F04h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167F04h case    1:*/		return 0x82167F08;
		  /* 82167F08h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82167F08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82167F08h case    2:*/		return 0x82167F0C;
		  /* 82167F0Ch */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82167F0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82167F0Ch case    3:*/		return 0x82167F10;
		  /* 82167F10h */ case    4:  		/* bl -90280 */
		/* 82167F10h case    4:*/		regs.LR = 0x82167F14; return 0x82151E68;
		/* 82167F10h case    4:*/		return 0x82167F14;
	}
	return 0x82167F14;
} // Block from 82167F00h-82167F14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F14);
		  /* 82167F14h */ case    0:  		/* rlwinm R11, R17, 0, 0, 19 */
		/* 82167F14h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R17);
		/* 82167F14h case    0:*/		return 0x82167F18;
		  /* 82167F18h */ case    1:  		/* li R4, 4800 */
		/* 82167F18h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82167F18h case    1:*/		return 0x82167F1C;
		  /* 82167F1Ch */ case    2:  		/* lwz R11, <#[R11]> */
		/* 82167F1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82167F1Ch case    2:*/		return 0x82167F20;
		  /* 82167F20h */ case    3:  		/* lwz R3, <#[R11 + 148]> */
		/* 82167F20h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000094) );
		/* 82167F20h case    3:*/		return 0x82167F24;
		  /* 82167F24h */ case    4:  		/* bl -90300 */
		/* 82167F24h case    4:*/		regs.LR = 0x82167F28; return 0x82151E68;
		/* 82167F24h case    4:*/		return 0x82167F28;
	}
	return 0x82167F28;
} // Block from 82167F14h-82167F28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82167F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F28);
		  /* 82167F28h */ case    0:  		/* mr R27, R23 */
		/* 82167F28h case    0:*/		regs.R27 = regs.R23;
		/* 82167F28h case    0:*/		return 0x82167F2C;
	}
	return 0x82167F2C;
} // Block from 82167F28h-82167F2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F2C);
		  /* 82167F2Ch */ case    0:  		/* lwz R11, <#[R14 + 12]> */
		/* 82167F2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 82167F2Ch case    0:*/		return 0x82167F30;
		  /* 82167F30h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82167F30h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167F30h case    1:*/		return 0x82167F34;
		  /* 82167F34h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82167F34h case    2:*/		if ( regs.CR[6].eq ) { return 0x82167F4C;  }
		/* 82167F34h case    2:*/		return 0x82167F38;
		  /* 82167F38h */ case    3:  		/* lwz R10, <#[R15 + 764]> */
		/* 82167F38h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x000002FC) );
		/* 82167F38h case    3:*/		return 0x82167F3C;
		  /* 82167F3Ch */ case    4:  		/* lwz R11, <#[R15 + 760]> */
		/* 82167F3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002F8) );
		/* 82167F3Ch case    4:*/		return 0x82167F40;
		  /* 82167F40h */ case    5:  		/* mulli R10, R10, 12 */
		/* 82167F40h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82167F40h case    5:*/		return 0x82167F44;
		  /* 82167F44h */ case    6:  		/* add R29, R10, R11 */
		/* 82167F44h case    6:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 82167F44h case    6:*/		return 0x82167F48;
		  /* 82167F48h */ case    7:  		/* b 8 */
		/* 82167F48h case    7:*/		return 0x82167F50;
		/* 82167F48h case    7:*/		return 0x82167F4C;
	}
	return 0x82167F4C;
} // Block from 82167F2Ch-82167F4Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82167F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F4C);
		  /* 82167F4Ch */ case    0:  		/* mr R29, R23 */
		/* 82167F4Ch case    0:*/		regs.R29 = regs.R23;
		/* 82167F4Ch case    0:*/		return 0x82167F50;
	}
	return 0x82167F50;
} // Block from 82167F4Ch-82167F50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82167F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F50);
		  /* 82167F50h */ case    0:  		/* cmplwi CR6, R16, 0 */
		/* 82167F50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 82167F50h case    0:*/		return 0x82167F54;
		  /* 82167F54h */ case    1:  		/* bc 12, CR6_EQ, 2680 */
		/* 82167F54h case    1:*/		if ( regs.CR[6].eq ) { return 0x821689CC;  }
		/* 82167F54h case    1:*/		return 0x82167F58;
		  /* 82167F58h */ case    2:  		/* mr R3, R16 */
		/* 82167F58h case    2:*/		regs.R3 = regs.R16;
		/* 82167F58h case    2:*/		return 0x82167F5C;
		  /* 82167F5Ch */ case    3:  		/* bl 742500 */
		/* 82167F5Ch case    3:*/		regs.LR = 0x82167F60; return 0x8221D3C0;
		/* 82167F5Ch case    3:*/		return 0x82167F60;
		  /* 82167F60h */ case    4:  		/* mr R4, R3 */
		/* 82167F60h case    4:*/		regs.R4 = regs.R3;
		/* 82167F60h case    4:*/		return 0x82167F64;
		  /* 82167F64h */ case    5:  		/* lwz R3, <#[R15 + 768]> */
		/* 82167F64h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82167F64h case    5:*/		return 0x82167F68;
		  /* 82167F68h */ case    6:  		/* bl -1048552 */
		/* 82167F68h case    6:*/		regs.LR = 0x82167F6C; return 0x82067F80;
		/* 82167F68h case    6:*/		return 0x82167F6C;
		  /* 82167F6Ch */ case    7:  		/* lwz R11, <#[R15 + 568]> */
		/* 82167F6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000238) );
		/* 82167F6Ch case    7:*/		return 0x82167F70;
		  /* 82167F70h */ case    8:  		/* mr R4, R23 */
		/* 82167F70h case    8:*/		regs.R4 = regs.R23;
		/* 82167F70h case    8:*/		return 0x82167F74;
		  /* 82167F74h */ case    9:  		/* b 16 */
		/* 82167F74h case    9:*/		return 0x82167F84;
		/* 82167F74h case    9:*/		return 0x82167F78;
		  /* 82167F78h */ case   10:  		/* stw R4, <#[R11 + 24]> */
		/* 82167F78h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 82167F78h case   10:*/		return 0x82167F7C;
		  /* 82167F7Ch */ case   11:  		/* addi R4, R4, 1 */
		/* 82167F7Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82167F7Ch case   11:*/		return 0x82167F80;
		  /* 82167F80h */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 82167F80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82167F80h case   12:*/		return 0x82167F84;
	}
	return 0x82167F84;
} // Block from 82167F50h-82167F84h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82167F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167F84);
		  /* 82167F84h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82167F84h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167F84h case    0:*/		return 0x82167F88;
		  /* 82167F88h */ case    1:  		/* bc 4, CR6_EQ, -16 */
		/* 82167F88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82167F78;  }
		/* 82167F88h case    1:*/		return 0x82167F8C;
		  /* 82167F8Ch */ case    2:  		/* mr R3, R16 */
		/* 82167F8Ch case    2:*/		regs.R3 = regs.R16;
		/* 82167F8Ch case    2:*/		return 0x82167F90;
		  /* 82167F90h */ case    3:  		/* bl -118328 */
		/* 82167F90h case    3:*/		regs.LR = 0x82167F94; return 0x8214B158;
		/* 82167F90h case    3:*/		return 0x82167F94;
		  /* 82167F94h */ case    4:  		/* lwz R31, <#[R15 + 568]> */
		/* 82167F94h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R15 + 0x00000238) );
		/* 82167F94h case    4:*/		return 0x82167F98;
		  /* 82167F98h */ case    5:  		/* b 24 */
		/* 82167F98h case    5:*/		return 0x82167FB0;
		/* 82167F98h case    5:*/		return 0x82167F9C;
		  /* 82167F9Ch */ case    6:  		/* mr R3, R16 */
		/* 82167F9Ch case    6:*/		regs.R3 = regs.R16;
		/* 82167F9Ch case    6:*/		return 0x82167FA0;
		  /* 82167FA0h */ case    7:  		/* lwz R5, <#[R31]> */
		/* 82167FA0h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000000) );
		/* 82167FA0h case    7:*/		return 0x82167FA4;
		  /* 82167FA4h */ case    8:  		/* lwz R4, <#[R31 + 24]> */
		/* 82167FA4h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 82167FA4h case    8:*/		return 0x82167FA8;
		  /* 82167FA8h */ case    9:  		/* bl -115760 */
		/* 82167FA8h case    9:*/		regs.LR = 0x82167FAC; return 0x8214BB78;
		/* 82167FA8h case    9:*/		return 0x82167FAC;
		  /* 82167FACh */ case   10:  		/* lwz R31, <#[R31 + 8]> */
		/* 82167FACh case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82167FACh case   10:*/		return 0x82167FB0;
	}
	return 0x82167FB0;
} // Block from 82167F84h-82167FB0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82167FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82167FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82167FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82167FB0);
		  /* 82167FB0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82167FB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82167FB0h case    0:*/		return 0x82167FB4;
		  /* 82167FB4h */ case    1:  		/* bc 4, CR6_EQ, -24 */
		/* 82167FB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82167F9C;  }
		/* 82167FB4h case    1:*/		return 0x82167FB8;
		  /* 82167FB8h */ case    2:  		/* lwz R11, <#[R15 + 756]> */
		/* 82167FB8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002F4) );
		/* 82167FB8h case    2:*/		return 0x82167FBC;
		  /* 82167FBCh */ case    3:  		/* lis R10, 7 */
		/* 82167FBCh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x7);
		/* 82167FBCh case    3:*/		return 0x82167FC0;
		  /* 82167FC0h */ case    4:  		/* ori R28, R10, 65535 */
		/* 82167FC0h case    4:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R10,0xFFFF);
		/* 82167FC0h case    4:*/		return 0x82167FC4;
		  /* 82167FC4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82167FC4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167FC4h case    5:*/		return 0x82167FC8;
		  /* 82167FC8h */ case    6:  		/* bc 12, CR6_EQ, 156 */
		/* 82167FC8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82168064;  }
		/* 82167FC8h case    6:*/		return 0x82167FCC;
		  /* 82167FCCh */ case    7:  		/* mr R3, R16 */
		/* 82167FCCh case    7:*/		regs.R3 = regs.R16;
		/* 82167FCCh case    7:*/		return 0x82167FD0;
		  /* 82167FD0h */ case    8:  		/* lwz R4, <#[R15 + 748]> */
		/* 82167FD0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R15 + 0x000002EC) );
		/* 82167FD0h case    8:*/		return 0x82167FD4;
		  /* 82167FD4h */ case    9:  		/* bl -118364 */
		/* 82167FD4h case    9:*/		regs.LR = 0x82167FD8; return 0x8214B178;
		/* 82167FD4h case    9:*/		return 0x82167FD8;
		  /* 82167FD8h */ case   10:  		/* lwz R11, <#[R15 + 744]> */
		/* 82167FD8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x000002E8) );
		/* 82167FD8h case   10:*/		return 0x82167FDC;
		  /* 82167FDCh */ case   11:  		/* stw R23, <#[R1 + 120]> */
		/* 82167FDCh case   11:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000078) );
		/* 82167FDCh case   11:*/		return 0x82167FE0;
		  /* 82167FE0h */ case   12:  		/* stw R11, <#[R1 + 112]> */
		/* 82167FE0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82167FE0h case   12:*/		return 0x82167FE4;
		  /* 82167FE4h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 82167FE4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82167FE4h case   13:*/		return 0x82167FE8;
		  /* 82167FE8h */ case   14:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82167FE8h case   14:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82167FE8h case   14:*/		return 0x82167FEC;
		  /* 82167FECh */ case   15:  		/* addic R10, R10, -1 */
		/* 82167FECh case   15:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82167FECh case   15:*/		return 0x82167FF0;
		  /* 82167FF0h */ case   16:  		/* subfe R10, R10, R10 */
		/* 82167FF0h case   16:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82167FF0h case   16:*/		return 0x82167FF4;
		  /* 82167FF4h */ case   17:  		/* and R11, R10, R11 */
		/* 82167FF4h case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82167FF4h case   17:*/		return 0x82167FF8;
		  /* 82167FF8h */ case   18:  		/* stw R11, <#[R1 + 116]> */
		/* 82167FF8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 82167FF8h case   18:*/		return 0x82167FFC;
		  /* 82167FFCh */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82167FFCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82167FFCh case   19:*/		return 0x82168000;
		  /* 82168000h */ case   20:  		/* bc 12, CR6_EQ, 24 */
		/* 82168000h case   20:*/		if ( regs.CR[6].eq ) { return 0x82168018;  }
		/* 82168000h case   20:*/		return 0x82168004;
		  /* 82168004h */ case   21:  		/* lwz R11, <#[R11 + 8]> */
		/* 82168004h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82168004h case   21:*/		return 0x82168008;
		  /* 82168008h */ case   22:  		/* lwz R10, <#[R1 + 120]> */
		/* 82168008h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 82168008h case   22:*/		return 0x8216800C;
		  /* 8216800Ch */ case   23:  		/* cmplw CR6, R10, R11 */
		/* 8216800Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216800Ch case   23:*/		return 0x82168010;
		  /* 82168010h */ case   24:  		/* mr R11, R23 */
		/* 82168010h case   24:*/		regs.R11 = regs.R23;
		/* 82168010h case   24:*/		return 0x82168014;
		  /* 82168014h */ case   25:  		/* bc 4, CR6_EQ, 8 */
		/* 82168014h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8216801C;  }
		/* 82168014h case   25:*/		return 0x82168018;
	}
	return 0x82168018;
} // Block from 82167FB0h-82168018h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82168018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168018);
		  /* 82168018h */ case    0:  		/* mr R11, R22 */
		/* 82168018h case    0:*/		regs.R11 = regs.R22;
		/* 82168018h case    0:*/		return 0x8216801C;
	}
	return 0x8216801C;
} // Block from 82168018h-8216801Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216801Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216801C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216801C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216801C);
		  /* 8216801Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216801Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216801Ch case    0:*/		return 0x82168020;
		  /* 82168020h */ case    1:  		/* bc 4, CR0_EQ, 68 */
		/* 82168020h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82168064;  }
		/* 82168020h case    1:*/		return 0x82168024;
		  /* 82168024h */ case    2:  		/* addi R3, R1, 112 */
		/* 82168024h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82168024h case    2:*/		return 0x82168028;
		  /* 82168028h */ case    3:  		/* bl 364088 */
		/* 82168028h case    3:*/		regs.LR = 0x8216802C; return 0x821C0E60;
		/* 82168028h case    3:*/		return 0x8216802C;
		  /* 8216802Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8216802Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216802Ch case    4:*/		return 0x82168030;
		  /* 82168030h */ case    5:  		/* rlwinm R5, R11, 0, 13, 31 */
		/* 82168030h case    5:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R5,regs.R11);
		/* 82168030h case    5:*/		return 0x82168034;
		  /* 82168034h */ case    6:  		/* cmplw CR6, R5, R28 */
		/* 82168034h case    6:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R28);
		/* 82168034h case    6:*/		return 0x82168038;
		  /* 82168038h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82168038h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82168040;  }
		/* 82168038h case    7:*/		return 0x8216803C;
		  /* 8216803Ch */ case    8:  		/* mr R5, R19 */
		/* 8216803Ch case    8:*/		regs.R5 = regs.R19;
		/* 8216803Ch case    8:*/		return 0x82168040;
	}
	return 0x82168040;
} // Block from 8216801Ch-82168040h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82168040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168040);
		  /* 82168040h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82168040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82168040h case    0:*/		return 0x82168044;
		  /* 82168044h */ case    1:  		/* rlwinm R4, R11, 0, 13, 31 */
		/* 82168044h case    1:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R4,regs.R11);
		/* 82168044h case    1:*/		return 0x82168048;
		  /* 82168048h */ case    2:  		/* cmplw CR6, R4, R28 */
		/* 82168048h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R28);
		/* 82168048h case    2:*/		return 0x8216804C;
		  /* 8216804Ch */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 8216804Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82168054;  }
		/* 8216804Ch case    3:*/		return 0x82168050;
		  /* 82168050h */ case    4:  		/* mr R4, R19 */
		/* 82168050h case    4:*/		regs.R4 = regs.R19;
		/* 82168050h case    4:*/		return 0x82168054;
	}
	return 0x82168054;
} // Block from 82168040h-82168054h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82168054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168054);
		  /* 82168054h */ case    0:  		/* mr R3, R16 */
		/* 82168054h case    0:*/		regs.R3 = regs.R16;
		/* 82168054h case    0:*/		return 0x82168058;
		  /* 82168058h */ case    1:  		/* bl -118488 */
		/* 82168058h case    1:*/		regs.LR = 0x8216805C; return 0x8214B180;
		/* 82168058h case    1:*/		return 0x8216805C;
		  /* 8216805Ch */ case    2:  		/* lwz R11, <#[R1 + 116]> */
		/* 8216805Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8216805Ch case    2:*/		return 0x82168060;
		  /* 82168060h */ case    3:  		/* b -100 */
		/* 82168060h case    3:*/		return 0x82167FFC;
		/* 82168060h case    3:*/		return 0x82168064;
	}
	return 0x82168064;
} // Block from 82168054h-82168064h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82168064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168064);
		  /* 82168064h */ case    0:  		/* lwz R11, <#[R14 + 12]> */
		/* 82168064h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000000C) );
		/* 82168064h case    0:*/		return 0x82168068;
		  /* 82168068h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82168068h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168068h case    1:*/		return 0x8216806C;
		  /* 8216806Ch */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 8216806Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821680D0;  }
		/* 8216806Ch case    2:*/		return 0x82168070;
		  /* 82168070h */ case    3:  		/* subf R11, R11, R29 */
		/* 82168070h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82168070h case    3:*/		return 0x82168074;
		  /* 82168074h */ case    4:  		/* li R10, 12 */
		/* 82168074h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 82168074h case    4:*/		return 0x82168078;
		  /* 82168078h */ case    5:  		/* mr R3, R16 */
		/* 82168078h case    5:*/		regs.R3 = regs.R16;
		/* 82168078h case    5:*/		return 0x8216807C;
		  /* 8216807Ch */ case    6:  		/* divw R4, R11, R10 */
		/* 8216807Ch case    6:*/		cpu::op::divw<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 8216807Ch case    6:*/		return 0x82168080;
		  /* 82168080h */ case    7:  		/* bl -118560 */
		/* 82168080h case    7:*/		regs.LR = 0x82168084; return 0x8214B160;
		/* 82168080h case    7:*/		return 0x82168084;
		  /* 82168084h */ case    8:  		/* mr R30, R23 */
		/* 82168084h case    8:*/		regs.R30 = regs.R23;
		/* 82168084h case    8:*/		return 0x82168088;
		  /* 82168088h */ case    9:  		/* lwz R31, <#[R14 + 12]> */
		/* 82168088h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x0000000C) );
		/* 82168088h case    9:*/		return 0x8216808C;
		  /* 8216808Ch */ case   10:  		/* b 60 */
		/* 8216808Ch case   10:*/		return 0x821680C8;
		/* 8216808Ch case   10:*/		return 0x82168090;
		  /* 82168090h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 82168090h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82168090h case   11:*/		return 0x82168094;
		  /* 82168094h */ case   12:  		/* mr R4, R30 */
		/* 82168094h case   12:*/		regs.R4 = regs.R30;
		/* 82168094h case   12:*/		return 0x82168098;
		  /* 82168098h */ case   13:  		/* lwz R7, <#[R31]> */
		/* 82168098h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 82168098h case   13:*/		return 0x8216809C;
		  /* 8216809Ch */ case   14:  		/* mr R3, R16 */
		/* 8216809Ch case   14:*/		regs.R3 = regs.R16;
		/* 8216809Ch case   14:*/		return 0x821680A0;
		  /* 821680A0h */ case   15:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821680A0h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821680A0h case   15:*/		return 0x821680A4;
		  /* 821680A4h */ case   16:  		/* lwz R10, <#[R31 + 8]> */
		/* 821680A4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821680A4h case   16:*/		return 0x821680A8;
		  /* 821680A8h */ case   17:  		/* lwz R5, <#[R10 + 24]> */
		/* 821680A8h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000018) );
		/* 821680A8h case   17:*/		return 0x821680AC;
		  /* 821680ACh */ case   18:  		/* rlwinm R6, R11, 31, 31, 31 */
		/* 821680ACh case   18:*/		cpu::op::rlwinm<0,31,31,31>(regs,&regs.R6,regs.R11);
		/* 821680ACh case   18:*/		return 0x821680B0;
		  /* 821680B0h */ case   19:  		/* bc 12, CR0_EQ, 12 */
		/* 821680B0h case   19:*/		if ( regs.CR[0].eq ) { return 0x821680BC;  }
		/* 821680B0h case   19:*/		return 0x821680B4;
		  /* 821680B4h */ case   20:  		/* bl -118604 */
		/* 821680B4h case   20:*/		regs.LR = 0x821680B8; return 0x8214B168;
		/* 821680B4h case   20:*/		return 0x821680B8;
		  /* 821680B8h */ case   21:  		/* b 8 */
		/* 821680B8h case   21:*/		return 0x821680C0;
		/* 821680B8h case   21:*/		return 0x821680BC;
	}
	return 0x821680BC;
} // Block from 82168064h-821680BCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 821680BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821680BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821680BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821680BC);
		  /* 821680BCh */ case    0:  		/* bl -118604 */
		/* 821680BCh case    0:*/		regs.LR = 0x821680C0; return 0x8214B170;
		/* 821680BCh case    0:*/		return 0x821680C0;
	}
	return 0x821680C0;
} // Block from 821680BCh-821680C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821680C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821680C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821680C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821680C0);
		  /* 821680C0h */ case    0:  		/* addi R31, R31, 12 */
		/* 821680C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xC);
		/* 821680C0h case    0:*/		return 0x821680C4;
		  /* 821680C4h */ case    1:  		/* addi R30, R30, 1 */
		/* 821680C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821680C4h case    1:*/		return 0x821680C8;
	}
	return 0x821680C8;
} // Block from 821680C0h-821680C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821680C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821680C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821680C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821680C8);
		  /* 821680C8h */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 821680C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 821680C8h case    0:*/		return 0x821680CC;
		  /* 821680CCh */ case    1:  		/* bc 12, CR6_LT, -60 */
		/* 821680CCh case    1:*/		if ( regs.CR[6].lt ) { return 0x82168090;  }
		/* 821680CCh case    1:*/		return 0x821680D0;
	}
	return 0x821680D0;
} // Block from 821680C8h-821680D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821680D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821680D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821680D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821680D0);
		  /* 821680D0h */ case    0:  		/* lwz R29, <#[R15 + 16]> */
		/* 821680D0h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R15 + 0x00000010) );
		/* 821680D0h case    0:*/		return 0x821680D4;
		  /* 821680D4h */ case    1:  		/* mr R3, R16 */
		/* 821680D4h case    1:*/		regs.R3 = regs.R16;
		/* 821680D4h case    1:*/		return 0x821680D8;
		  /* 821680D8h */ case    2:  		/* mr R4, R29 */
		/* 821680D8h case    2:*/		regs.R4 = regs.R29;
		/* 821680D8h case    2:*/		return 0x821680DC;
		  /* 821680DCh */ case    3:  		/* bl -118708 */
		/* 821680DCh case    3:*/		regs.LR = 0x821680E0; return 0x8214B128;
		/* 821680DCh case    3:*/		return 0x821680E0;
		  /* 821680E0h */ case    4:  		/* mr R31, R23 */
		/* 821680E0h case    4:*/		regs.R31 = regs.R23;
		/* 821680E0h case    4:*/		return 0x821680E4;
		  /* 821680E4h */ case    5:  		/* cmplwi CR6, R29, 0 */
		/* 821680E4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821680E4h case    5:*/		return 0x821680E8;
		  /* 821680E8h */ case    6:  		/* bc 12, CR6_EQ, 100 */
		/* 821680E8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8216814C;  }
		/* 821680E8h case    6:*/		return 0x821680EC;
		  /* 821680ECh */ case    7:  		/* mr R30, R23 */
		/* 821680ECh case    7:*/		regs.R30 = regs.R23;
		/* 821680ECh case    7:*/		return 0x821680F0;
		  /* 821680F0h */ case    8:  		/* lwz R11, <#[R15 + 12]> */
		/* 821680F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000000C) );
		/* 821680F0h case    8:*/		return 0x821680F4;
		  /* 821680F4h */ case    9:  		/* add R11, R30, R11 */
		/* 821680F4h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 821680F4h case    9:*/		return 0x821680F8;
		  /* 821680F8h */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 821680F8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821680F8h case   10:*/		return 0x821680FC;
		  /* 821680FCh */ case   11:  		/* rlwinm R9, R10, 0, 13, 31 */
		/* 821680FCh case   11:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R10);
		/* 821680FCh case   11:*/		return 0x82168100;
		  /* 82168100h */ case   12:  		/* cmplw CR6, R9, R28 */
		/* 82168100h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R28);
		/* 82168100h case   12:*/		return 0x82168104;
		  /* 82168104h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 82168104h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8216810C;  }
		/* 82168104h case   13:*/		return 0x82168108;
		  /* 82168108h */ case   14:  		/* mr R9, R19 */
		/* 82168108h case   14:*/		regs.R9 = regs.R19;
		/* 82168108h case   14:*/		return 0x8216810C;
	}
	return 0x8216810C;
} // Block from 821680D0h-8216810Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216810Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216810C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216810C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216810C);
		  /* 8216810Ch */ case    0:  		/* lwz R10, <#[R11 + 32]> */
		/* 8216810Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 8216810Ch case    0:*/		return 0x82168110;
		  /* 82168110h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82168110h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82168110h case    1:*/		return 0x82168114;
		  /* 82168114h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82168114h case    2:*/		if ( regs.CR[6].eq ) { return 0x82168120;  }
		/* 82168114h case    2:*/		return 0x82168118;
		  /* 82168118h */ case    3:  		/* lwz R8, <#[R10 + 24]> */
		/* 82168118h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000018) );
		/* 82168118h case    3:*/		return 0x8216811C;
		  /* 8216811Ch */ case    4:  		/* b 8 */
		/* 8216811Ch case    4:*/		return 0x82168124;
		/* 8216811Ch case    4:*/		return 0x82168120;
	}
	return 0x82168120;
} // Block from 8216810Ch-82168120h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82168120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168120);
		  /* 82168120h */ case    0:  		/* mr R8, R19 */
		/* 82168120h case    0:*/		regs.R8 = regs.R19;
		/* 82168120h case    0:*/		return 0x82168124;
	}
	return 0x82168124;
} // Block from 82168120h-82168124h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82168124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168124);
		  /* 82168124h */ case    0:  		/* mr R4, R31 */
		/* 82168124h case    0:*/		regs.R4 = regs.R31;
		/* 82168124h case    0:*/		return 0x82168128;
		  /* 82168128h */ case    1:  		/* lwz R7, <#[R11 + 16]> */
		/* 82168128h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000010) );
		/* 82168128h case    1:*/		return 0x8216812C;
		  /* 8216812Ch */ case    2:  		/* mr R3, R16 */
		/* 8216812Ch case    2:*/		regs.R3 = regs.R16;
		/* 8216812Ch case    2:*/		return 0x82168130;
		  /* 82168130h */ case    3:  		/* lwz R6, <#[R11 + 20]> */
		/* 82168130h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000014) );
		/* 82168130h case    3:*/		return 0x82168134;
		  /* 82168134h */ case    4:  		/* lwz R5, <#[R11 + 12]> */
		/* 82168134h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 82168134h case    4:*/		return 0x82168138;
		  /* 82168138h */ case    5:  		/* bl -116168 */
		/* 82168138h case    5:*/		regs.LR = 0x8216813C; return 0x8214BB70;
		/* 82168138h case    5:*/		return 0x8216813C;
		  /* 8216813Ch */ case    6:  		/* addi R31, R31, 1 */
		/* 8216813Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8216813Ch case    6:*/		return 0x82168140;
		  /* 82168140h */ case    7:  		/* addi R30, R30, 40 */
		/* 82168140h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x28);
		/* 82168140h case    7:*/		return 0x82168144;
		  /* 82168144h */ case    8:  		/* cmplw CR6, R31, R29 */
		/* 82168144h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82168144h case    8:*/		return 0x82168148;
		  /* 82168148h */ case    9:  		/* bc 12, CR6_LT, -88 */
		/* 82168148h case    9:*/		if ( regs.CR[6].lt ) { return 0x821680F0;  }
		/* 82168148h case    9:*/		return 0x8216814C;
	}
	return 0x8216814C;
} // Block from 82168124h-8216814Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216814Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216814C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216814C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216814C);
		  /* 8216814Ch */ case    0:  		/* lwz R31, <#[R14 + 8]> */
		/* 8216814Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000008) );
		/* 8216814Ch case    0:*/		return 0x82168150;
		  /* 82168150h */ case    1:  		/* b 136 */
		/* 82168150h case    1:*/		return 0x821681D8;
		/* 82168150h case    1:*/		return 0x82168154;
		  /* 82168154h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82168154h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82168154h case    2:*/		return 0x82168158;
		  /* 82168158h */ case    3:  		/* li R6, 114 */
		/* 82168158h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x72);
		/* 82168158h case    3:*/		return 0x8216815C;
		  /* 8216815Ch */ case    4:  		/* rlwinm R11, R10, 20, 29, 31 */
		/* 8216815Ch case    4:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R11,regs.R10);
		/* 8216815Ch case    4:*/		return 0x82168160;
		  /* 82168160h */ case    5:  		/* cmplwi CR6, R11, 5 */
		/* 82168160h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82168160h case    5:*/		return 0x82168164;
		  /* 82168164h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82168164h case    6:*/		if ( regs.CR[6].eq ) { return 0x82168174;  }
		/* 82168164h case    6:*/		return 0x82168168;
		  /* 82168168h */ case    7:  		/* cmplwi CR6, R11, 2 */
		/* 82168168h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82168168h case    7:*/		return 0x8216816C;
		  /* 8216816Ch */ case    8:  		/* bc 4, CR6_EQ, 104 */
		/* 8216816Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x821681D4;  }
		/* 8216816Ch case    8:*/		return 0x82168170;
		  /* 82168170h */ case    9:  		/* li R6, 99 */
		/* 82168170h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x63);
		/* 82168170h case    9:*/		return 0x82168174;
	}
	return 0x82168174;
} // Block from 8216814Ch-82168174h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82168174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168174);
		  /* 82168174h */ case    0:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82168174h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82168174h case    0:*/		return 0x82168178;
		  /* 82168178h */ case    1:  		/* rlwinm R11, R10, 0, 28, 31 */
		/* 82168178h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R10);
		/* 82168178h case    1:*/		return 0x8216817C;
		  /* 8216817Ch */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8216817Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82168188;  }
		/* 8216817Ch case    2:*/		return 0x82168180;
		  /* 82168180h */ case    3:  		/* mr R11, R23 */
		/* 82168180h case    3:*/		regs.R11 = regs.R23;
		/* 82168180h case    3:*/		return 0x82168184;
		  /* 82168184h */ case    4:  		/* b 32 */
		/* 82168184h case    4:*/		return 0x821681A4;
		/* 82168184h case    4:*/		return 0x82168188;
	}
	return 0x82168188;
} // Block from 82168174h-82168188h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82168188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168188);
		  /* 82168188h */ case    0:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 82168188h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 82168188h case    0:*/		return 0x8216818C;
		  /* 8216818Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8216818Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82168198;  }
		/* 8216818Ch case    1:*/		return 0x82168190;
		  /* 82168190h */ case    2:  		/* mr R11, R22 */
		/* 82168190h case    2:*/		regs.R11 = regs.R22;
		/* 82168190h case    2:*/		return 0x82168194;
		  /* 82168194h */ case    3:  		/* b 16 */
		/* 82168194h case    3:*/		return 0x821681A4;
		/* 82168194h case    3:*/		return 0x82168198;
	}
	return 0x82168198;
} // Block from 82168188h-82168198h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82168198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168198);
		  /* 82168198h */ case    0:  		/* nor R11, R11, R11 */
		/* 82168198h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82168198h case    0:*/		return 0x8216819C;
		  /* 8216819Ch */ case    1:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 8216819Ch case    1:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8216819Ch case    1:*/		return 0x821681A0;
		  /* 821681A0h */ case    2:  		/* ori R11, R11, 2 */
		/* 821681A0h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821681A0h case    2:*/		return 0x821681A4;
	}
	return 0x821681A4;
} // Block from 82168198h-821681A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821681A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821681A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821681A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821681A4);
		  /* 821681A4h */ case    0:  		/* lwz R8, <#[R31]> */
		/* 821681A4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821681A4h case    0:*/		return 0x821681A8;
		  /* 821681A8h */ case    1:  		/* rlwinm R10, R10, 30, 22, 29 */
		/* 821681A8h case    1:*/		cpu::op::rlwinm<0,30,22,29>(regs,&regs.R10,regs.R10);
		/* 821681A8h case    1:*/		return 0x821681AC;
		  /* 821681ACh */ case    2:  		/* lwz R4, <#[R31 + 4]> */
		/* 821681ACh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 821681ACh case    2:*/		return 0x821681B0;
		  /* 821681B0h */ case    3:  		/* mr R3, R16 */
		/* 821681B0h case    3:*/		regs.R3 = regs.R16;
		/* 821681B0h case    3:*/		return 0x821681B4;
		  /* 821681B4h */ case    4:  		/* add R7, R10, R11 */
		/* 821681B4h case    4:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 821681B4h case    4:*/		return 0x821681B8;
		  /* 821681B8h */ case    5:  		/* rlwinm R10, R4, 1, 31, 31 */
		/* 821681B8h case    5:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R4);
		/* 821681B8h case    5:*/		return 0x821681BC;
		  /* 821681BCh */ case    6:  		/* rlwinm R9, R4, 2, 31, 31 */
		/* 821681BCh case    6:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R9,regs.R4);
		/* 821681BCh case    6:*/		return 0x821681C0;
		  /* 821681C0h */ case    7:  		/* stw R8, <#[R1 + 84]> */
		/* 821681C0h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 821681C0h case    7:*/		return 0x821681C4;
		  /* 821681C4h */ case    8:  		/* rlwinm R8, R4, 3, 31, 31 */
		/* 821681C4h case    8:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R8,regs.R4);
		/* 821681C4h case    8:*/		return 0x821681C8;
		  /* 821681C8h */ case    9:  		/* rlwinm R5, R4, 17, 18, 31 */
		/* 821681C8h case    9:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R5,regs.R4);
		/* 821681C8h case    9:*/		return 0x821681CC;
		  /* 821681CCh */ case   10:  		/* rlwinm R4, R4, 0, 17, 31 */
		/* 821681CCh case   10:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R4,regs.R4);
		/* 821681CCh case   10:*/		return 0x821681D0;
		  /* 821681D0h */ case   11:  		/* bl -118944 */
		/* 821681D0h case   11:*/		regs.LR = 0x821681D4; return 0x8214B130;
		/* 821681D0h case   11:*/		return 0x821681D4;
	}
	return 0x821681D4;
} // Block from 821681A4h-821681D4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821681D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821681D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821681D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821681D4);
		  /* 821681D4h */ case    0:  		/* addi R31, R31, 12 */
		/* 821681D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xC);
		/* 821681D4h case    0:*/		return 0x821681D8;
	}
	return 0x821681D8;
} // Block from 821681D4h-821681D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821681D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821681D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821681D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821681D8);
		  /* 821681D8h */ case    0:  		/* cmplw CR6, R31, R27 */
		/* 821681D8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R27);
		/* 821681D8h case    0:*/		return 0x821681DC;
		  /* 821681DCh */ case    1:  		/* bc 12, CR6_LT, -136 */
		/* 821681DCh case    1:*/		if ( regs.CR[6].lt ) { return 0x82168154;  }
		/* 821681DCh case    1:*/		return 0x821681E0;
		  /* 821681E0h */ case    2:  		/* lwz R11, <#[R15 + 44]> */
		/* 821681E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000002C) );
		/* 821681E0h case    2:*/		return 0x821681E4;
		  /* 821681E4h */ case    3:  		/* rlwinm. R11, R11, 0, 8, 8 */
		/* 821681E4h case    3:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R11,regs.R11);
		/* 821681E4h case    3:*/		return 0x821681E8;
		  /* 821681E8h */ case    4:  		/* bc 12, CR0_EQ, 672 */
		/* 821681E8h case    4:*/		if ( regs.CR[0].eq ) { return 0x82168488;  }
		/* 821681E8h case    4:*/		return 0x821681EC;
		  /* 821681ECh */ case    5:  		/* lwz R11, <#[R15 + 56]> */
		/* 821681ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000038) );
		/* 821681ECh case    5:*/		return 0x821681F0;
		  /* 821681F0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821681F0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821681F0h case    6:*/		return 0x821681F4;
		  /* 821681F4h */ case    7:  		/* bc 12, CR6_EQ, 652 */
		/* 821681F4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82168480;  }
		/* 821681F4h case    7:*/		return 0x821681F8;
		  /* 821681F8h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 821681F8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821681F8h case    8:*/		return 0x821681FC;
		  /* 821681FCh */ case    9:  		/* andi. R11, R11, 1280 */
		/* 821681FCh case    9:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x500);
		/* 821681FCh case    9:*/		return 0x82168200;
		  /* 82168200h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 82168200h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82168200h case   10:*/		return 0x82168204;
		  /* 82168204h */ case   11:  		/* bc 12, CR0_EQ, 636 */
		/* 82168204h case   11:*/		if ( regs.CR[0].eq ) { return 0x82168480;  }
		/* 82168204h case   11:*/		return 0x82168208;
		  /* 82168208h */ case   12:  		/* mr R3, R16 */
		/* 82168208h case   12:*/		regs.R3 = regs.R16;
		/* 82168208h case   12:*/		return 0x8216820C;
		  /* 8216820Ch */ case   13:  		/* lwz R4, <#[R15 + 556]> */
		/* 8216820Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R15 + 0x0000022C) );
		/* 8216820Ch case   13:*/		return 0x82168210;
		  /* 82168210h */ case   14:  		/* bl -118912 */
		/* 82168210h case   14:*/		regs.LR = 0x82168214; return 0x8214B190;
		/* 82168210h case   14:*/		return 0x82168214;
		  /* 82168214h */ case   15:  		/* mr R17, R25 */
		/* 82168214h case   15:*/		regs.R17 = regs.R25;
		/* 82168214h case   15:*/		return 0x82168218;
		  /* 82168218h */ case   16:  		/* cmplwi CR6, R25, 0 */
		/* 82168218h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82168218h case   16:*/		return 0x8216821C;
		  /* 8216821Ch */ case   17:  		/* bc 12, CR6_EQ, 620 */
		/* 8216821Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82168488;  }
		/* 8216821Ch case   17:*/		return 0x82168220;
		  /* 82168220h */ case   18:  		/* cmplw CR6, R17, R25 */
		/* 82168220h case   18:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R25);
		/* 82168220h case   18:*/		return 0x82168224;
		  /* 82168224h */ case   19:  		/* bc 12, CR6_EQ, 16 */
		/* 82168224h case   19:*/		if ( regs.CR[6].eq ) { return 0x82168234;  }
		/* 82168224h case   19:*/		return 0x82168228;
		  /* 82168228h */ case   20:  		/* lwz R11, <#[R17 + 76]> */
		/* 82168228h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 82168228h case   20:*/		return 0x8216822C;
		  /* 8216822Ch */ case   21:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 8216822Ch case   21:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 8216822Ch case   21:*/		return 0x82168230;
		  /* 82168230h */ case   22:  		/* bc 4, CR0_EQ, 600 */
		/* 82168230h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82168488;  }
		/* 82168230h case   22:*/		return 0x82168234;
	}
	return 0x82168234;
} // Block from 821681D8h-82168234h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82168234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168234);
		  /* 82168234h */ case    0:  		/* lwz R11, <#[R17 + 68]> */
		/* 82168234h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000044) );
		/* 82168234h case    0:*/		return 0x82168238;
		  /* 82168238h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 82168238h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 82168238h case    1:*/		return 0x8216823C;
		  /* 8216823Ch */ case    2:  		/* bc 12, CR0_EQ, 528 */
		/* 8216823Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8216844C;  }
		/* 8216823Ch case    2:*/		return 0x82168240;
		  /* 82168240h */ case    3:  		/* lwz R11, <#[R17 + 28]> */
		/* 82168240h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000001C) );
		/* 82168240h case    3:*/		return 0x82168244;
		  /* 82168244h */ case    4:  		/* addi R31, R17, 24 */
		/* 82168244h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R17,0x18);
		/* 82168244h case    4:*/		return 0x82168248;
		  /* 82168248h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82168248h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82168248h case    5:*/		return 0x8216824C;
		  /* 8216824Ch */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 8216824Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82168258;  }
		/* 8216824Ch case    6:*/		return 0x82168250;
		  /* 82168250h */ case    7:  		/* mr R10, R23 */
		/* 82168250h case    7:*/		regs.R10 = regs.R23;
		/* 82168250h case    7:*/		return 0x82168254;
		  /* 82168254h */ case    8:  		/* b 16 */
		/* 82168254h case    8:*/		return 0x82168264;
		/* 82168254h case    8:*/		return 0x82168258;
	}
	return 0x82168258;
} // Block from 82168234h-82168258h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82168258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168258);
		  /* 82168258h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82168258h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82168258h case    0:*/		return 0x8216825C;
		  /* 8216825Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8216825Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8216825Ch case    1:*/		return 0x82168260;
		  /* 82168260h */ case    2:  		/* addi R10, R11, -40 */
		/* 82168260h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFD8);
		/* 82168260h case    2:*/		return 0x82168264;
	}
	return 0x82168264;
} // Block from 82168258h-82168264h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82168264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168264);
		  /* 82168264h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 82168264h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82168264h case    0:*/		return 0x82168268;
		  /* 82168268h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82168268h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82168268h case    1:*/		return 0x8216826C;
		  /* 8216826Ch */ case    2:  		/* cmplwi CR6, R11, 11392 */
		/* 8216826Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002C80);
		/* 8216826Ch case    2:*/		return 0x82168270;
		  /* 82168270h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 82168270h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216828C;  }
		/* 82168270h case    3:*/		return 0x82168274;
		  /* 82168274h */ case    4:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 82168274h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 82168274h case    4:*/		return 0x82168278;
		  /* 82168278h */ case    5:  		/* lwz R11, <#[R11 + 36]> */
		/* 82168278h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82168278h case    5:*/		return 0x8216827C;
		  /* 8216827Ch */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216827Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216827Ch case    6:*/		return 0x82168280;
		  /* 82168280h */ case    7:  		/* bc 4, CR0_EQ, 136 */
		/* 82168280h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82168308;  }
		/* 82168280h case    7:*/		return 0x82168284;
		  /* 82168284h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82168284h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82168284h case    8:*/		return 0x82168288;
		  /* 82168288h */ case    9:  		/* addi R10, R11, -40 */
		/* 82168288h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFD8);
		/* 82168288h case    9:*/		return 0x8216828C;
	}
	return 0x8216828C;
} // Block from 82168264h-8216828Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216828Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216828C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216828C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216828C);
		  /* 8216828Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8216828Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216828Ch case    0:*/		return 0x82168290;
		  /* 82168290h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 82168290h case    1:*/		if ( regs.CR[6].eq ) { return 0x82168308;  }
		/* 82168290h case    1:*/		return 0x82168294;
		  /* 82168294h */ case    2:  		/* lwz R11, <#[R10 + 8]> */
		/* 82168294h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82168294h case    2:*/		return 0x82168298;
		  /* 82168298h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82168298h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82168298h case    3:*/		return 0x8216829C;
		  /* 8216829Ch */ case    4:  		/* cmplwi CR6, R11, 11520 */
		/* 8216829Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002D00);
		/* 8216829Ch case    4:*/		return 0x821682A0;
		  /* 821682A0h */ case    5:  		/* bc 4, CR6_EQ, 104 */
		/* 821682A0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82168308;  }
		/* 821682A0h case    5:*/		return 0x821682A4;
		  /* 821682A4h */ case    6:  		/* lwz R9, <#[R17 + 12]> */
		/* 821682A4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x0000000C) );
		/* 821682A4h case    6:*/		return 0x821682A8;
		  /* 821682A8h */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 821682A8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821682A8h case    7:*/		return 0x821682AC;
		  /* 821682ACh */ case    8:  		/* bc 12, CR6_EQ, 456 */
		/* 821682ACh case    8:*/		if ( regs.CR[6].eq ) { return 0x82168474;  }
		/* 821682ACh case    8:*/		return 0x821682B0;
		  /* 821682B0h */ case    9:  		/* lwz R3, <#[R9]> */
		/* 821682B0h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000000) );
		/* 821682B0h case    9:*/		return 0x821682B4;
		  /* 821682B4h */ case   10:  		/* lwz R11, <#[R3 + 68]> */
		/* 821682B4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 821682B4h case   10:*/		return 0x821682B8;
		  /* 821682B8h */ case   11:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 821682B8h case   11:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 821682B8h case   11:*/		return 0x821682BC;
		  /* 821682BCh */ case   12:  		/* bc 4, CR0_EQ, 48 */
		/* 821682BCh case   12:*/		if ( !regs.CR[0].eq ) { return 0x821682EC;  }
		/* 821682BCh case   12:*/		return 0x821682C0;
		  /* 821682C0h */ case   13:  		/* lwz R11, <#[R3 + 12]> */
		/* 821682C0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821682C0h case   13:*/		return 0x821682C4;
		  /* 821682C4h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821682C4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821682C4h case   14:*/		return 0x821682C8;
		  /* 821682C8h */ case   15:  		/* bc 12, CR6_EQ, 28 */
		/* 821682C8h case   15:*/		if ( regs.CR[6].eq ) { return 0x821682E4;  }
		/* 821682C8h case   15:*/		return 0x821682CC;
		  /* 821682CCh */ case   16:  		/* lwz R3, <#[R11]> */
		/* 821682CCh case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 821682CCh case   16:*/		return 0x821682D0;
		  /* 821682D0h */ case   17:  		/* cmplwi CR6, R3, 0 */
		/* 821682D0h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821682D0h case   17:*/		return 0x821682D4;
		  /* 821682D4h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 821682D4h case   18:*/		if ( regs.CR[6].eq ) { return 0x821682E4;  }
		/* 821682D4h case   18:*/		return 0x821682D8;
		  /* 821682D8h */ case   19:  		/* lwz R11, <#[R3 + 68]> */
		/* 821682D8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 821682D8h case   19:*/		return 0x821682DC;
		  /* 821682DCh */ case   20:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 821682DCh case   20:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 821682DCh case   20:*/		return 0x821682E0;
		  /* 821682E0h */ case   21:  		/* bc 4, CR0_EQ, 12 */
		/* 821682E0h case   21:*/		if ( !regs.CR[0].eq ) { return 0x821682EC;  }
		/* 821682E0h case   21:*/		return 0x821682E4;
	}
	return 0x821682E4;
} // Block from 8216828Ch-821682E4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821682E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821682E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821682E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821682E4);
		  /* 821682E4h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 821682E4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821682E4h case    0:*/		return 0x821682E8;
		  /* 821682E8h */ case    1:  		/* b -64 */
		/* 821682E8h case    1:*/		return 0x821682A8;
		/* 821682E8h case    1:*/		return 0x821682EC;
	}
	return 0x821682EC;
} // Block from 821682E4h-821682ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821682ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821682EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821682EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821682EC);
		  /* 821682ECh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 821682ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821682ECh case    0:*/		return 0x821682F0;
		  /* 821682F0h */ case    1:  		/* bc 12, CR6_EQ, 388 */
		/* 821682F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82168474;  }
		/* 821682F0h case    1:*/		return 0x821682F4;
		  /* 821682F4h */ case    2:  		/* lwz R11, <#[R10 + 20]> */
		/* 821682F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 821682F4h case    2:*/		return 0x821682F8;
		  /* 821682F8h */ case    3:  		/* rlwinm R28, R11, 0, 20, 31 */
		/* 821682F8h case    3:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R28,regs.R11);
		/* 821682F8h case    3:*/		return 0x821682FC;
		  /* 821682FCh */ case    4:  		/* bl -13532 */
		/* 821682FCh case    4:*/		regs.LR = 0x82168300; return 0x82164E20;
		/* 821682FCh case    4:*/		return 0x82168300;
		  /* 82168300h */ case    5:  		/* mr R27, R3 */
		/* 82168300h case    5:*/		regs.R27 = regs.R3;
		/* 82168300h case    5:*/		return 0x82168304;
		  /* 82168304h */ case    6:  		/* b 20 */
		/* 82168304h case    6:*/		return 0x82168318;
		/* 82168304h case    6:*/		return 0x82168308;
	}
	return 0x82168308;
} // Block from 821682ECh-82168308h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82168308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168308);
		  /* 82168308h */ case    0:  		/* mr R3, R17 */
		/* 82168308h case    0:*/		regs.R3 = regs.R17;
		/* 82168308h case    0:*/		return 0x8216830C;
		  /* 8216830Ch */ case    1:  		/* bl -13548 */
		/* 8216830Ch case    1:*/		regs.LR = 0x82168310; return 0x82164E20;
		/* 8216830Ch case    1:*/		return 0x82168310;
		  /* 82168310h */ case    2:  		/* mr R28, R3 */
		/* 82168310h case    2:*/		regs.R28 = regs.R3;
		/* 82168310h case    2:*/		return 0x82168314;
		  /* 82168314h */ case    3:  		/* mr R27, R19 */
		/* 82168314h case    3:*/		regs.R27 = regs.R19;
		/* 82168314h case    3:*/		return 0x82168318;
	}
	return 0x82168318;
} // Block from 82168308h-82168318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82168318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168318);
		  /* 82168318h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82168318h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82168318h case    0:*/		return 0x8216831C;
		  /* 8216831Ch */ case    1:  		/* mr R29, R23 */
		/* 8216831Ch case    1:*/		regs.R29 = regs.R23;
		/* 8216831Ch case    1:*/		return 0x82168320;
		  /* 82168320h */ case    2:  		/* mr R30, R23 */
		/* 82168320h case    2:*/		regs.R30 = regs.R23;
		/* 82168320h case    2:*/		return 0x82168324;
		  /* 82168324h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82168324h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82168324h case    3:*/		return 0x82168328;
		  /* 82168328h */ case    4:  		/* bc 4, CR0_EQ, 292 */
		/* 82168328h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216844C;  }
		/* 82168328h case    4:*/		return 0x8216832C;
		  /* 8216832Ch */ case    5:  		/* mr R31, R11 */
		/* 8216832Ch case    5:*/		regs.R31 = regs.R11;
		/* 8216832Ch case    5:*/		return 0x82168330;
		  /* 82168330h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82168330h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82168330h case    6:*/		return 0x82168334;
		  /* 82168334h */ case    7:  		/* bc 12, CR0_EQ, 280 */
		/* 82168334h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216844C;  }
		/* 82168334h case    7:*/		return 0x82168338;
		  /* 82168338h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 82168338h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82168338h case    8:*/		return 0x8216833C;
		  /* 8216833Ch */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216833Ch case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216833Ch case    9:*/		return 0x82168340;
		  /* 82168340h */ case   10:  		/* cmplwi CR6, R11, 14976 */
		/* 82168340h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 82168340h case   10:*/		return 0x82168344;
		  /* 82168344h */ case   11:  		/* bc 4, CR6_EQ, 68 */
		/* 82168344h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82168388;  }
		/* 82168344h case   11:*/		return 0x82168348;
		  /* 82168348h */ case   12:  		/* li R6, 0 */
		/* 82168348h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82168348h case   12:*/		return 0x8216834C;
		  /* 8216834Ch */ case   13:  		/* li R5, 0 */
		/* 8216834Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8216834Ch case   13:*/		return 0x82168350;
		  /* 82168350h */ case   14:  		/* li R4, 117 */
		/* 82168350h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 82168350h case   14:*/		return 0x82168354;
		  /* 82168354h */ case   15:  		/* mr R3, R15 */
		/* 82168354h case   15:*/		regs.R3 = regs.R15;
		/* 82168354h case   15:*/		return 0x82168358;
		  /* 82168358h */ case   16:  		/* bl -16168 */
		/* 82168358h case   16:*/		regs.LR = 0x8216835C; return 0x82164430;
		/* 82168358h case   16:*/		return 0x8216835C;
		  /* 8216835Ch */ case   17:  		/* addi R11, R31, -16 */
		/* 8216835Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 8216835Ch case   17:*/		return 0x82168360;
		  /* 82168360h */ case   18:  		/* add R11, R3, R11 */
		/* 82168360h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82168360h case   18:*/		return 0x82168364;
		  /* 82168364h */ case   19:  		/* lwz R10, <#[R11]> */
		/* 82168364h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82168364h case   19:*/		return 0x82168368;
		  /* 82168368h */ case   20:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 82168368h case   20:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 82168368h case   20:*/		return 0x8216836C;
		  /* 8216836Ch */ case   21:  		/* cmplwi CR6, R10, 7 */
		/* 8216836Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 8216836Ch case   21:*/		return 0x82168370;
		  /* 82168370h */ case   22:  		/* bc 4, CR6_EQ, 24 */
		/* 82168370h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82168388;  }
		/* 82168370h case   22:*/		return 0x82168374;
		  /* 82168374h */ case   23:  		/* lwz R10, <#[R11 + 4]> */
		/* 82168374h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82168374h case   23:*/		return 0x82168378;
		  /* 82168378h */ case   24:  		/* cmpwi CR6, R10, 2 */
		/* 82168378h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 82168378h case   24:*/		return 0x8216837C;
		  /* 8216837Ch */ case   25:  		/* bc 4, CR6_EQ, 12 */
		/* 8216837Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x82168388;  }
		/* 8216837Ch case   25:*/		return 0x82168380;
		  /* 82168380h */ case   26:  		/* lwz R29, <#[R11 + 8]> */
		/* 82168380h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 82168380h case   26:*/		return 0x82168384;
		  /* 82168384h */ case   27:  		/* lwz R30, <#[R11 + 12]> */
		/* 82168384h case   27:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 82168384h case   27:*/		return 0x82168388;
	}
	return 0x82168388;
} // Block from 82168318h-82168388h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82168388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168388);
		  /* 82168388h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82168388h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82168388h case    0:*/		return 0x8216838C;
		  /* 8216838Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8216838Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8216838Ch case    1:*/		return 0x82168390;
		  /* 82168390h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82168390h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82168390h case    2:*/		return 0x82168394;
		  /* 82168394h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82168394h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821683A4;  }
		/* 82168394h case    3:*/		return 0x82168398;
		  /* 82168398h */ case    4:  		/* mr R31, R11 */
		/* 82168398h case    4:*/		regs.R31 = regs.R11;
		/* 82168398h case    4:*/		return 0x8216839C;
		  /* 8216839Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216839Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216839Ch case    5:*/		return 0x821683A0;
		  /* 821683A0h */ case    6:  		/* bc 4, CR6_EQ, -104 */
		/* 821683A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82168338;  }
		/* 821683A0h case    6:*/		return 0x821683A4;
	}
	return 0x821683A4;
} // Block from 82168388h-821683A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821683A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821683A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821683A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821683A4);
		  /* 821683A4h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821683A4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821683A4h case    0:*/		return 0x821683A8;
		  /* 821683A8h */ case    1:  		/* bc 12, CR6_EQ, 164 */
		/* 821683A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216844C;  }
		/* 821683A8h case    1:*/		return 0x821683AC;
		  /* 821683ACh */ case    2:  		/* mr R4, R30 */
		/* 821683ACh case    2:*/		regs.R4 = regs.R30;
		/* 821683ACh case    2:*/		return 0x821683B0;
		  /* 821683B0h */ case    3:  		/* mr R3, R15 */
		/* 821683B0h case    3:*/		regs.R3 = regs.R15;
		/* 821683B0h case    3:*/		return 0x821683B4;
		  /* 821683B4h */ case    4:  		/* bl 538756 */
		/* 821683B4h case    4:*/		regs.LR = 0x821683B8; return 0x821EBC38;
		/* 821683B4h case    4:*/		return 0x821683B8;
		  /* 821683B8h */ case    5:  		/* lwz R11, <#[R3 + 28]> */
		/* 821683B8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 821683B8h case    5:*/		return 0x821683BC;
		  /* 821683BCh */ case    6:  		/* cmpwi CR6, R11, 32 */
		/* 821683BCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000020);
		/* 821683BCh case    6:*/		return 0x821683C0;
		  /* 821683C0h */ case    7:  		/* bc 4, CR6_EQ, 140 */
		/* 821683C0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8216844C;  }
		/* 821683C0h case    7:*/		return 0x821683C4;
		  /* 821683C4h */ case    8:  		/* lwz R11, <#[R3 + 32]> */
		/* 821683C4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 821683C4h case    8:*/		return 0x821683C8;
		  /* 821683C8h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 821683C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821683C8h case    9:*/		return 0x821683CC;
		  /* 821683CCh */ case   10:  		/* lwz R11, <#[R11 + 24]> */
		/* 821683CCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821683CCh case   10:*/		return 0x821683D0;
		  /* 821683D0h */ case   11:  		/* cmpwi CR6, R11, 5 */
		/* 821683D0h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821683D0h case   11:*/		return 0x821683D4;
		  /* 821683D4h */ case   12:  		/* bc 4, CR6_EQ, 120 */
		/* 821683D4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216844C;  }
		/* 821683D4h case   12:*/		return 0x821683D8;
		  /* 821683D8h */ case   13:  		/* mr R3, R30 */
		/* 821683D8h case   13:*/		regs.R3 = regs.R30;
		/* 821683D8h case   13:*/		return 0x821683DC;
		  /* 821683DCh */ case   14:  		/* bl -753620 */
		/* 821683DCh case   14:*/		regs.LR = 0x821683E0; return 0x820B0408;
		/* 821683DCh case   14:*/		return 0x821683E0;
		  /* 821683E0h */ case   15:  		/* or. R31, R3, R3 */
		/* 821683E0h case   15:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 821683E0h case   15:*/		return 0x821683E4;
		  /* 821683E4h */ case   16:  		/* bc 12, CR0_EQ, 104 */
		/* 821683E4h case   16:*/		if ( regs.CR[0].eq ) { return 0x8216844C;  }
		/* 821683E4h case   16:*/		return 0x821683E8;
		  /* 821683E8h */ case   17:  		/* li R4, 40 */
		/* 821683E8h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 821683E8h case   17:*/		return 0x821683EC;
		  /* 821683ECh */ case   18:  		/* lwz R3, <#[R31 + 32]> */
		/* 821683ECh case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 821683ECh case   18:*/		return 0x821683F0;
		  /* 821683F0h */ case   19:  		/* bl 1047184 */
		/* 821683F0h case   19:*/		regs.LR = 0x821683F4; return 0x82267E80;
		/* 821683F0h case   19:*/		return 0x821683F4;
		  /* 821683F4h */ case   20:  		/* addi R26, R3, 1 */
		/* 821683F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0x1);
		/* 821683F4h case   20:*/		return 0x821683F8;
		  /* 821683F8h */ case   21:  		/* mr R4, R30 */
		/* 821683F8h case   21:*/		regs.R4 = regs.R30;
		/* 821683F8h case   21:*/		return 0x821683FC;
		  /* 821683FCh */ case   22:  		/* mr R3, R15 */
		/* 821683FCh case   22:*/		regs.R3 = regs.R15;
		/* 821683FCh case   22:*/		return 0x82168400;
		  /* 82168400h */ case   23:  		/* bl 538680 */
		/* 82168400h case   23:*/		regs.LR = 0x82168404; return 0x821EBC38;
		/* 82168400h case   23:*/		return 0x82168404;
		  /* 82168404h */ case   24:  		/* lwz R11, <#[R3 + 36]> */
		/* 82168404h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 82168404h case   24:*/		return 0x82168408;
		  /* 82168408h */ case   25:  		/* mr R3, R15 */
		/* 82168408h case   25:*/		regs.R3 = regs.R15;
		/* 82168408h case   25:*/		return 0x8216840C;
		  /* 8216840Ch */ case   26:  		/* lwz R11, <#[R11 + 8]> */
		/* 8216840Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8216840Ch case   26:*/		return 0x82168410;
		  /* 82168410h */ case   27:  		/* lwz R4, <#[R11 + 8]> */
		/* 82168410h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 82168410h case   27:*/		return 0x82168414;
		  /* 82168414h */ case   28:  		/* bl 538660 */
		/* 82168414h case   28:*/		regs.LR = 0x82168418; return 0x821EBC38;
		/* 82168414h case   28:*/		return 0x82168418;
		  /* 82168418h */ case   29:  		/* mr R11, R3 */
		/* 82168418h case   29:*/		regs.R11 = regs.R3;
		/* 82168418h case   29:*/		return 0x8216841C;
		  /* 8216841Ch */ case   30:  		/* lwz R8, <#[R31 + 24]> */
		/* 8216841Ch case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 8216841Ch case   30:*/		return 0x82168420;
		  /* 82168420h */ case   31:  		/* mr R6, R27 */
		/* 82168420h case   31:*/		regs.R6 = regs.R27;
		/* 82168420h case   31:*/		return 0x82168424;
		  /* 82168424h */ case   32:  		/* lwz R7, <#[R31 + 16]> */
		/* 82168424h case   32:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82168424h case   32:*/		return 0x82168428;
		  /* 82168428h */ case   33:  		/* mr R5, R28 */
		/* 82168428h case   33:*/		regs.R5 = regs.R28;
		/* 82168428h case   33:*/		return 0x8216842C;
		  /* 8216842Ch */ case   34:  		/* mr R4, R29 */
		/* 8216842Ch case   34:*/		regs.R4 = regs.R29;
		/* 8216842Ch case   34:*/		return 0x82168430;
		  /* 82168430h */ case   35:  		/* mr R3, R16 */
		/* 82168430h case   35:*/		regs.R3 = regs.R16;
		/* 82168430h case   35:*/		return 0x82168434;
		  /* 82168434h */ case   36:  		/* lwz R10, <#[R11 + 84]> */
		/* 82168434h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 82168434h case   36:*/		return 0x82168438;
		  /* 82168438h */ case   37:  		/* mr R9, R26 */
		/* 82168438h case   37:*/		regs.R9 = regs.R26;
		/* 82168438h case   37:*/		return 0x8216843C;
		  /* 8216843Ch */ case   38:  		/* lwz R11, <#[R11 + 80]> */
		/* 8216843Ch case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 8216843Ch case   38:*/		return 0x82168440;
		  /* 82168440h */ case   39:  		/* add R11, R10, R11 */
		/* 82168440h case   39:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82168440h case   39:*/		return 0x82168444;
		  /* 82168444h */ case   40:  		/* subf R10, R26, R11 */
		/* 82168444h case   40:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R26,regs.R11);
		/* 82168444h case   40:*/		return 0x82168448;
		  /* 82168448h */ case   41:  		/* bl -116936 */
		/* 82168448h case   41:*/		regs.LR = 0x8216844C; return 0x8214BB80;
		/* 82168448h case   41:*/		return 0x8216844C;
	}
	return 0x8216844C;
} // Block from 821683A4h-8216844Ch (42 instructions)

//////////////////////////////////////////////////////
// Block at 8216844Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216844C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216844C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216844C);
		  /* 8216844Ch */ case    0:  		/* rlwinm R11, R17, 0, 0, 30 */
		/* 8216844Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R17);
		/* 8216844Ch case    0:*/		return 0x82168450;
		  /* 82168450h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82168450h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82168450h case    1:*/		return 0x82168454;
		  /* 82168454h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82168454h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82168454h case    2:*/		return 0x82168458;
		  /* 82168458h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 82168458h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216846C;  }
		/* 82168458h case    3:*/		return 0x8216845C;
		  /* 8216845Ch */ case    4:  		/* mr R17, R11 */
		/* 8216845Ch case    4:*/		regs.R17 = regs.R11;
		/* 8216845Ch case    4:*/		return 0x82168460;
		  /* 82168460h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82168460h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168460h case    5:*/		return 0x82168464;
		  /* 82168464h */ case    6:  		/* bc 4, CR6_EQ, -580 */
		/* 82168464h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82168220;  }
		/* 82168464h case    6:*/		return 0x82168468;
		  /* 82168468h */ case    7:  		/* b 32 */
		/* 82168468h case    7:*/		return 0x82168488;
		/* 82168468h case    7:*/		return 0x8216846C;
	}
	return 0x8216846C;
} // Block from 8216844Ch-8216846Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216846Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216846C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216846C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216846C);
		  /* 8216846Ch */ case    0:  		/* mr R17, R23 */
		/* 8216846Ch case    0:*/		regs.R17 = regs.R23;
		/* 8216846Ch case    0:*/		return 0x82168470;
		  /* 82168470h */ case    1:  		/* b 24 */
		/* 82168470h case    1:*/		return 0x82168488;
		/* 82168470h case    1:*/		return 0x82168474;
	}
	return 0x82168474;
} // Block from 8216846Ch-82168474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168474);
		  /* 82168474h */ case    0:  		/* li R4, 4800 */
		/* 82168474h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82168474h case    0:*/		return 0x82168478;
		  /* 82168478h */ case    1:  		/* mr R3, R15 */
		/* 82168478h case    1:*/		regs.R3 = regs.R15;
		/* 82168478h case    1:*/		return 0x8216847C;
		  /* 8216847Ch */ case    2:  		/* bl -91668 */
		/* 8216847Ch case    2:*/		regs.LR = 0x82168480; return 0x82151E68;
		/* 8216847Ch case    2:*/		return 0x82168480;
	}
	return 0x82168480;
} // Block from 82168474h-82168480h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82168480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168480);
		  /* 82168480h */ case    0:  		/* mr R3, R16 */
		/* 82168480h case    0:*/		regs.R3 = regs.R16;
		/* 82168480h case    0:*/		return 0x82168484;
		  /* 82168484h */ case    1:  		/* bl -138956 */
		/* 82168484h case    1:*/		regs.LR = 0x82168488; return 0x821465B8;
		/* 82168484h case    1:*/		return 0x82168488;
	}
	return 0x82168488;
} // Block from 82168480h-82168488h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168488);
		  /* 82168488h */ case    0:  		/* lwz R11, <#[R15 + 44]> */
		/* 82168488h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000002C) );
		/* 82168488h case    0:*/		return 0x8216848C;
		  /* 8216848Ch */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 8216848Ch case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 8216848Ch case    1:*/		return 0x82168490;
		  /* 82168490h */ case    2:  		/* bc 12, CR0_EQ, 1340 */
		/* 82168490h case    2:*/		if ( regs.CR[0].eq ) { return 0x821689CC;  }
		/* 82168490h case    2:*/		return 0x82168494;
		  /* 82168494h */ case    3:  		/* lwz R11, <#[R15 + 56]> */
		/* 82168494h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000038) );
		/* 82168494h case    3:*/		return 0x82168498;
		  /* 82168498h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82168498h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168498h case    4:*/		return 0x8216849C;
		  /* 8216849Ch */ case    5:  		/* bc 12, CR6_EQ, 1320 */
		/* 8216849Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821689C4;  }
		/* 8216849Ch case    5:*/		return 0x821684A0;
		  /* 821684A0h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 821684A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821684A0h case    6:*/		return 0x821684A4;
		  /* 821684A4h */ case    7:  		/* rlwinm. R11, R11, 0, 19, 20 */
		/* 821684A4h case    7:*/		cpu::op::rlwinm<1,0,19,20>(regs,&regs.R11,regs.R11);
		/* 821684A4h case    7:*/		return 0x821684A8;
		  /* 821684A8h */ case    8:  		/* bc 12, CR0_EQ, 1308 */
		/* 821684A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x821689C4;  }
		/* 821684A8h case    8:*/		return 0x821684AC;
		  /* 821684ACh */ case    9:  		/* mr R3, R16 */
		/* 821684ACh case    9:*/		regs.R3 = regs.R16;
		/* 821684ACh case    9:*/		return 0x821684B0;
		  /* 821684B0h */ case   10:  		/* lwz R4, <#[R15 + 560]> */
		/* 821684B0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R15 + 0x00000230) );
		/* 821684B0h case   10:*/		return 0x821684B4;
		  /* 821684B4h */ case   11:  		/* bl -119580 */
		/* 821684B4h case   11:*/		regs.LR = 0x821684B8; return 0x8214B198;
		/* 821684B4h case   11:*/		return 0x821684B8;
		  /* 821684B8h */ case   12:  		/* mr R17, R25 */
		/* 821684B8h case   12:*/		regs.R17 = regs.R25;
		/* 821684B8h case   12:*/		return 0x821684BC;
		  /* 821684BCh */ case   13:  		/* cmplwi CR6, R25, 0 */
		/* 821684BCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821684BCh case   13:*/		return 0x821684C0;
		  /* 821684C0h */ case   14:  		/* b 1216 */
		/* 821684C0h case   14:*/		return 0x82168980;
		/* 821684C0h case   14:*/		return 0x821684C4;
		  /* 821684C4h */ case   15:  		/* cmplw CR6, R17, R25 */
		/* 821684C4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R25);
		/* 821684C4h case   15:*/		return 0x821684C8;
		  /* 821684C8h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 821684C8h case   16:*/		if ( regs.CR[6].eq ) { return 0x821684D8;  }
		/* 821684C8h case   16:*/		return 0x821684CC;
		  /* 821684CCh */ case   17:  		/* lwz R11, <#[R17 + 76]> */
		/* 821684CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 821684CCh case   17:*/		return 0x821684D0;
		  /* 821684D0h */ case   18:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 821684D0h case   18:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 821684D0h case   18:*/		return 0x821684D4;
		  /* 821684D4h */ case   19:  		/* bc 4, CR0_EQ, 1272 */
		/* 821684D4h case   19:*/		if ( !regs.CR[0].eq ) { return 0x821689CC;  }
		/* 821684D4h case   19:*/		return 0x821684D8;
	}
	return 0x821684D8;
} // Block from 82168488h-821684D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821684D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821684D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821684D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821684D8);
		  /* 821684D8h */ case    0:  		/* lwz R11, <#[R17 + 76]> */
		/* 821684D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000004C) );
		/* 821684D8h case    0:*/		return 0x821684DC;
		  /* 821684DCh */ case    1:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 821684DCh case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 821684DCh case    1:*/		return 0x821684E0;
		  /* 821684E0h */ case    2:  		/* bc 12, CR0_EQ, 1160 */
		/* 821684E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82168968;  }
		/* 821684E0h case    2:*/		return 0x821684E4;
		  /* 821684E4h */ case    3:  		/* lwz R11, <#[R15 + 56]> */
		/* 821684E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000038) );
		/* 821684E4h case    3:*/		return 0x821684E8;
		  /* 821684E8h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 821684E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821684E8h case    4:*/		return 0x821684EC;
		  /* 821684ECh */ case    5:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 821684ECh case    5:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 821684ECh case    5:*/		return 0x821684F0;
		  /* 821684F0h */ case    6:  		/* lwz R11, <#[R17 + 28]> */
		/* 821684F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x0000001C) );
		/* 821684F0h case    6:*/		return 0x821684F4;
		  /* 821684F4h */ case    7:  		/* bc 12, CR0_EQ, 160 */
		/* 821684F4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82168594;  }
		/* 821684F4h case    7:*/		return 0x821684F8;
		  /* 821684F8h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821684F8h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821684F8h case    8:*/		return 0x821684FC;
		  /* 821684FCh */ case    9:  		/* bc 4, CR0_EQ, 1176 */
		/* 821684FCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x82168994;  }
		/* 821684FCh case    9:*/		return 0x82168500;
		  /* 82168500h */ case   10:  		/* mr R27, R11 */
		/* 82168500h case   10:*/		regs.R27 = regs.R11;
		/* 82168500h case   10:*/		return 0x82168504;
		  /* 82168504h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82168504h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82168504h case   11:*/		return 0x82168508;
		  /* 82168508h */ case   12:  		/* bc 12, CR0_EQ, 1164 */
		/* 82168508h case   12:*/		if ( regs.CR[0].eq ) { return 0x82168994;  }
		/* 82168508h case   12:*/		return 0x8216850C;
		  /* 8216850Ch */ case   13:  		/* lwz R11, <#[R27 + 8]> */
		/* 8216850Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8216850Ch case   13:*/		return 0x82168510;
		  /* 82168510h */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82168510h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82168510h case   14:*/		return 0x82168514;
		  /* 82168514h */ case   15:  		/* cmplwi CR6, R11, 12032 */
		/* 82168514h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002F00);
		/* 82168514h case   15:*/		return 0x82168518;
		  /* 82168518h */ case   16:  		/* bc 4, CR6_EQ, 40 */
		/* 82168518h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82168540;  }
		/* 82168518h case   16:*/		return 0x8216851C;
		  /* 8216851Ch */ case   17:  		/* li R6, 0 */
		/* 8216851Ch case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216851Ch case   17:*/		return 0x82168520;
		  /* 82168520h */ case   18:  		/* li R5, 0 */
		/* 82168520h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168520h case   18:*/		return 0x82168524;
		  /* 82168524h */ case   19:  		/* li R4, 94 */
		/* 82168524h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x5E);
		/* 82168524h case   19:*/		return 0x82168528;
		  /* 82168528h */ case   20:  		/* mr R3, R15 */
		/* 82168528h case   20:*/		regs.R3 = regs.R15;
		/* 82168528h case   20:*/		return 0x8216852C;
		  /* 8216852Ch */ case   21:  		/* bl -16636 */
		/* 8216852Ch case   21:*/		regs.LR = 0x82168530; return 0x82164430;
		/* 8216852Ch case   21:*/		return 0x82168530;
		  /* 82168530h */ case   22:  		/* addi R11, R27, -8 */
		/* 82168530h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFF8);
		/* 82168530h case   22:*/		return 0x82168534;
		  /* 82168534h */ case   23:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82168534h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82168534h case   23:*/		return 0x82168538;
		  /* 82168538h */ case   24:  		/* cmplwi CR6, R11, 0 */
		/* 82168538h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168538h case   24:*/		return 0x8216853C;
		  /* 8216853Ch */ case   25:  		/* bc 4, CR6_EQ, 32 */
		/* 8216853Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x8216855C;  }
		/* 8216853Ch case   25:*/		return 0x82168540;
	}
	return 0x82168540;
} // Block from 821684D8h-82168540h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82168540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168540);
		  /* 82168540h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 82168540h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 82168540h case    0:*/		return 0x82168544;
		  /* 82168544h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82168544h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82168544h case    1:*/		return 0x82168548;
		  /* 82168548h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82168548h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82168548h case    2:*/		return 0x8216854C;
		  /* 8216854Ch */ case    3:  		/* bc 4, CR0_EQ, 1096 */
		/* 8216854Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82168994;  }
		/* 8216854Ch case    3:*/		return 0x82168550;
		  /* 82168550h */ case    4:  		/* mr R27, R11 */
		/* 82168550h case    4:*/		regs.R27 = regs.R11;
		/* 82168550h case    4:*/		return 0x82168554;
		  /* 82168554h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82168554h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168554h case    5:*/		return 0x82168558;
		  /* 82168558h */ case    6:  		/* bc 4, CR6_EQ, -76 */
		/* 82168558h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216850C;  }
		/* 82168558h case    6:*/		return 0x8216855C;
	}
	return 0x8216855C;
} // Block from 82168540h-8216855Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216855Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216855C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216855C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216855C);
		  /* 8216855Ch */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 8216855Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8216855Ch case    0:*/		return 0x82168560;
		  /* 82168560h */ case    1:  		/* bc 12, CR6_EQ, 1076 */
		/* 82168560h case    1:*/		if ( regs.CR[6].eq ) { return 0x82168994;  }
		/* 82168560h case    1:*/		return 0x82168564;
		  /* 82168564h */ case    2:  		/* li R6, 0 */
		/* 82168564h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82168564h case    2:*/		return 0x82168568;
		  /* 82168568h */ case    3:  		/* li R5, 0 */
		/* 82168568h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168568h case    3:*/		return 0x8216856C;
		  /* 8216856Ch */ case    4:  		/* li R4, 94 */
		/* 8216856Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x5E);
		/* 8216856Ch case    4:*/		return 0x82168570;
		  /* 82168570h */ case    5:  		/* mr R3, R15 */
		/* 82168570h case    5:*/		regs.R3 = regs.R15;
		/* 82168570h case    5:*/		return 0x82168574;
		  /* 82168574h */ case    6:  		/* bl -16708 */
		/* 82168574h case    6:*/		regs.LR = 0x82168578; return 0x82164430;
		/* 82168574h case    6:*/		return 0x82168578;
		  /* 82168578h */ case    7:  		/* add R10, R3, R27 */
		/* 82168578h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R27);
		/* 82168578h case    7:*/		return 0x8216857C;
		  /* 8216857Ch */ case    8:  		/* add R9, R3, R27 */
		/* 8216857Ch case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R3,regs.R27);
		/* 8216857Ch case    8:*/		return 0x82168580;
		  /* 82168580h */ case    9:  		/* lwz R11, <#[R27 + 20]> */
		/* 82168580h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82168580h case    9:*/		return 0x82168584;
		  /* 82168584h */ case   10:  		/* rlwinm R30, R11, 0, 20, 31 */
		/* 82168584h case   10:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R30,regs.R11);
		/* 82168584h case   10:*/		return 0x82168588;
		  /* 82168588h */ case   11:  		/* lwz R31, <#[R10 - 8]> */
		/* 82168588h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0xFFFFFFF8) );
		/* 82168588h case   11:*/		return 0x8216858C;
		  /* 8216858Ch */ case   12:  		/* lwz R25, <#[R9 - 4]> */
		/* 8216858Ch case   12:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 8216858Ch case   12:*/		return 0x82168590;
		  /* 82168590h */ case   13:  		/* b 184 */
		/* 82168590h case   13:*/		return 0x82168648;
		/* 82168590h case   13:*/		return 0x82168594;
	}
	return 0x82168594;
} // Block from 8216855Ch-82168594h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82168594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168594);
		  /* 82168594h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82168594h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82168594h case    0:*/		return 0x82168598;
		  /* 82168598h */ case    1:  		/* bc 4, CR0_EQ, 1032 */
		/* 82168598h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821689A0;  }
		/* 82168598h case    1:*/		return 0x8216859C;
		  /* 8216859Ch */ case    2:  		/* mr R27, R11 */
		/* 8216859Ch case    2:*/		regs.R27 = regs.R11;
		/* 8216859Ch case    2:*/		return 0x821685A0;
		  /* 821685A0h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 821685A0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821685A0h case    3:*/		return 0x821685A4;
		  /* 821685A4h */ case    4:  		/* bc 12, CR0_EQ, 1020 */
		/* 821685A4h case    4:*/		if ( regs.CR[0].eq ) { return 0x821689A0;  }
		/* 821685A4h case    4:*/		return 0x821685A8;
		  /* 821685A8h */ case    5:  		/* lwz R11, <#[R27 + 8]> */
		/* 821685A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821685A8h case    5:*/		return 0x821685AC;
		  /* 821685ACh */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821685ACh case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821685ACh case    6:*/		return 0x821685B0;
		  /* 821685B0h */ case    7:  		/* cmplwi CR6, R11, 14976 */
		/* 821685B0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821685B0h case    7:*/		return 0x821685B4;
		  /* 821685B4h */ case    8:  		/* bc 4, CR6_EQ, 60 */
		/* 821685B4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821685F0;  }
		/* 821685B4h case    8:*/		return 0x821685B8;
		  /* 821685B8h */ case    9:  		/* li R6, 0 */
		/* 821685B8h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821685B8h case    9:*/		return 0x821685BC;
		  /* 821685BCh */ case   10:  		/* li R5, 0 */
		/* 821685BCh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821685BCh case   10:*/		return 0x821685C0;
		  /* 821685C0h */ case   11:  		/* li R4, 117 */
		/* 821685C0h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821685C0h case   11:*/		return 0x821685C4;
		  /* 821685C4h */ case   12:  		/* mr R3, R15 */
		/* 821685C4h case   12:*/		regs.R3 = regs.R15;
		/* 821685C4h case   12:*/		return 0x821685C8;
		  /* 821685C8h */ case   13:  		/* bl -16792 */
		/* 821685C8h case   13:*/		regs.LR = 0x821685CC; return 0x82164430;
		/* 821685C8h case   13:*/		return 0x821685CC;
		  /* 821685CCh */ case   14:  		/* add R11, R3, R27 */
		/* 821685CCh case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R27);
		/* 821685CCh case   14:*/		return 0x821685D0;
		  /* 821685D0h */ case   15:  		/* lwz R11, <#[R11 - 16]> */
		/* 821685D0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 821685D0h case   15:*/		return 0x821685D4;
		  /* 821685D4h */ case   16:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 821685D4h case   16:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821685D4h case   16:*/		return 0x821685D8;
		  /* 821685D8h */ case   17:  		/* cmplwi CR6, R11, 7 */
		/* 821685D8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 821685D8h case   17:*/		return 0x821685DC;
		  /* 821685DCh */ case   18:  		/* bc 4, CR6_EQ, 20 */
		/* 821685DCh case   18:*/		if ( !regs.CR[6].eq ) { return 0x821685F0;  }
		/* 821685DCh case   18:*/		return 0x821685E0;
		  /* 821685E0h */ case   19:  		/* add R11, R3, R27 */
		/* 821685E0h case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R27);
		/* 821685E0h case   19:*/		return 0x821685E4;
		  /* 821685E4h */ case   20:  		/* lwz R11, <#[R11 - 12]> */
		/* 821685E4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF4) );
		/* 821685E4h case   20:*/		return 0x821685E8;
		  /* 821685E8h */ case   21:  		/* cmpwi CR6, R11, 3 */
		/* 821685E8h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821685E8h case   21:*/		return 0x821685EC;
		  /* 821685ECh */ case   22:  		/* bc 12, CR6_EQ, 32 */
		/* 821685ECh case   22:*/		if ( regs.CR[6].eq ) { return 0x8216860C;  }
		/* 821685ECh case   22:*/		return 0x821685F0;
	}
	return 0x821685F0;
} // Block from 82168594h-821685F0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821685F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821685F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821685F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821685F0);
		  /* 821685F0h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821685F0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821685F0h case    0:*/		return 0x821685F4;
		  /* 821685F4h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821685F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821685F4h case    1:*/		return 0x821685F8;
		  /* 821685F8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821685F8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821685F8h case    2:*/		return 0x821685FC;
		  /* 821685FCh */ case    3:  		/* bc 4, CR0_EQ, 932 */
		/* 821685FCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821689A0;  }
		/* 821685FCh case    3:*/		return 0x82168600;
		  /* 82168600h */ case    4:  		/* mr R27, R11 */
		/* 82168600h case    4:*/		regs.R27 = regs.R11;
		/* 82168600h case    4:*/		return 0x82168604;
		  /* 82168604h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82168604h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168604h case    5:*/		return 0x82168608;
		  /* 82168608h */ case    6:  		/* bc 4, CR6_EQ, -96 */
		/* 82168608h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821685A8;  }
		/* 82168608h case    6:*/		return 0x8216860C;
	}
	return 0x8216860C;
} // Block from 821685F0h-8216860Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216860Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216860C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216860C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216860C);
		  /* 8216860Ch */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 8216860Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8216860Ch case    0:*/		return 0x82168610;
		  /* 82168610h */ case    1:  		/* bc 12, CR6_EQ, 912 */
		/* 82168610h case    1:*/		if ( regs.CR[6].eq ) { return 0x821689A0;  }
		/* 82168610h case    1:*/		return 0x82168614;
		  /* 82168614h */ case    2:  		/* li R6, 0 */
		/* 82168614h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82168614h case    2:*/		return 0x82168618;
		  /* 82168618h */ case    3:  		/* li R5, 0 */
		/* 82168618h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168618h case    3:*/		return 0x8216861C;
		  /* 8216861Ch */ case    4:  		/* li R4, 117 */
		/* 8216861Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 8216861Ch case    4:*/		return 0x82168620;
		  /* 82168620h */ case    5:  		/* mr R3, R15 */
		/* 82168620h case    5:*/		regs.R3 = regs.R15;
		/* 82168620h case    5:*/		return 0x82168624;
		  /* 82168624h */ case    6:  		/* bl -16884 */
		/* 82168624h case    6:*/		regs.LR = 0x82168628; return 0x82164430;
		/* 82168624h case    6:*/		return 0x82168628;
		  /* 82168628h */ case    7:  		/* mr R11, R3 */
		/* 82168628h case    7:*/		regs.R11 = regs.R3;
		/* 82168628h case    7:*/		return 0x8216862C;
		  /* 8216862Ch */ case    8:  		/* mr R3, R17 */
		/* 8216862Ch case    8:*/		regs.R3 = regs.R17;
		/* 8216862Ch case    8:*/		return 0x82168630;
		  /* 82168630h */ case    9:  		/* add R10, R11, R27 */
		/* 82168630h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R27);
		/* 82168630h case    9:*/		return 0x82168634;
		  /* 82168634h */ case   10:  		/* add R11, R11, R27 */
		/* 82168634h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82168634h case   10:*/		return 0x82168638;
		  /* 82168638h */ case   11:  		/* lwz R31, <#[R10 - 4]> */
		/* 82168638h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 82168638h case   11:*/		return 0x8216863C;
		  /* 8216863Ch */ case   12:  		/* lwz R25, <#[R11 - 8]> */
		/* 8216863Ch case   12:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8216863Ch case   12:*/		return 0x82168640;
		  /* 82168640h */ case   13:  		/* bl -14368 */
		/* 82168640h case   13:*/		regs.LR = 0x82168644; return 0x82164E20;
		/* 82168640h case   13:*/		return 0x82168644;
		  /* 82168644h */ case   14:  		/* mr R30, R3 */
		/* 82168644h case   14:*/		regs.R30 = regs.R3;
		/* 82168644h case   14:*/		return 0x82168648;
	}
	return 0x82168648;
} // Block from 8216860Ch-82168648h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82168648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168648);
		  /* 82168648h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82168648h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82168648h case    0:*/		return 0x8216864C;
		  /* 8216864Ch */ case    1:  		/* bc 12, CR6_EQ, 792 */
		/* 8216864Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82168964;  }
		/* 8216864Ch case    1:*/		return 0x82168650;
		  /* 82168650h */ case    2:  		/* mr R4, R31 */
		/* 82168650h case    2:*/		regs.R4 = regs.R31;
		/* 82168650h case    2:*/		return 0x82168654;
		  /* 82168654h */ case    3:  		/* mr R3, R15 */
		/* 82168654h case    3:*/		regs.R3 = regs.R15;
		/* 82168654h case    3:*/		return 0x82168658;
		  /* 82168658h */ case    4:  		/* bl 538080 */
		/* 82168658h case    4:*/		regs.LR = 0x8216865C; return 0x821EBC38;
		/* 82168658h case    4:*/		return 0x8216865C;
		  /* 8216865Ch */ case    5:  		/* lwz R10, <#[R3 + 28]> */
		/* 8216865Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 8216865Ch case    5:*/		return 0x82168660;
		  /* 82168660h */ case    6:  		/* mr R11, R3 */
		/* 82168660h case    6:*/		regs.R11 = regs.R3;
		/* 82168660h case    6:*/		return 0x82168664;
		  /* 82168664h */ case    7:  		/* cmpwi CR6, R10, 32 */
		/* 82168664h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000020);
		/* 82168664h case    7:*/		return 0x82168668;
		  /* 82168668h */ case    8:  		/* bc 4, CR6_EQ, 764 */
		/* 82168668h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82168964;  }
		/* 82168668h case    8:*/		return 0x8216866C;
		  /* 8216866Ch */ case    9:  		/* lwz R10, <#[R3 + 32]> */
		/* 8216866Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 8216866Ch case    9:*/		return 0x82168670;
		  /* 82168670h */ case   10:  		/* lwz R10, <#[R10 + 8]> */
		/* 82168670h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82168670h case   10:*/		return 0x82168674;
		  /* 82168674h */ case   11:  		/* lwz R10, <#[R10 + 24]> */
		/* 82168674h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 82168674h case   11:*/		return 0x82168678;
		  /* 82168678h */ case   12:  		/* cmpwi CR6, R10, 14 */
		/* 82168678h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000E);
		/* 82168678h case   12:*/		return 0x8216867C;
		  /* 8216867Ch */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 8216867Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82168688;  }
		/* 8216867Ch case   13:*/		return 0x82168680;
		  /* 82168680h */ case   14:  		/* cmpwi CR6, R10, 15 */
		/* 82168680h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000F);
		/* 82168680h case   14:*/		return 0x82168684;
		  /* 82168684h */ case   15:  		/* bc 4, CR6_EQ, 736 */
		/* 82168684h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82168964;  }
		/* 82168684h case   15:*/		return 0x82168688;
	}
	return 0x82168688;
} // Block from 82168648h-82168688h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82168688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168688);
		  /* 82168688h */ case    0:  		/* mr R3, R15 */
		/* 82168688h case    0:*/		regs.R3 = regs.R15;
		/* 82168688h case    0:*/		return 0x8216868C;
		  /* 8216868Ch */ case    1:  		/* lwz R4, <#[R11 + 36]> */
		/* 8216868Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000024) );
		/* 8216868Ch case    1:*/		return 0x82168690;
		  /* 82168690h */ case    2:  		/* bl 538288 */
		/* 82168690h case    2:*/		regs.LR = 0x82168694; return 0x821EBD40;
		/* 82168690h case    2:*/		return 0x82168694;
		  /* 82168694h */ case    3:  		/* lwz R4, <#[R3 + 8]> */
		/* 82168694h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000008) );
		/* 82168694h case    3:*/		return 0x82168698;
		  /* 82168698h */ case    4:  		/* mr R3, R15 */
		/* 82168698h case    4:*/		regs.R3 = regs.R15;
		/* 82168698h case    4:*/		return 0x8216869C;
		  /* 8216869Ch */ case    5:  		/* bl 538276 */
		/* 8216869Ch case    5:*/		regs.LR = 0x821686A0; return 0x821EBD40;
		/* 8216869Ch case    5:*/		return 0x821686A0;
		  /* 821686A0h */ case    6:  		/* mr R29, R3 */
		/* 821686A0h case    6:*/		regs.R29 = regs.R3;
		/* 821686A0h case    6:*/		return 0x821686A4;
		  /* 821686A4h */ case    7:  		/* mr R4, R3 */
		/* 821686A4h case    7:*/		regs.R4 = regs.R3;
		/* 821686A4h case    7:*/		return 0x821686A8;
		  /* 821686A8h */ case    8:  		/* mr R5, R15 */
		/* 821686A8h case    8:*/		regs.R5 = regs.R15;
		/* 821686A8h case    8:*/		return 0x821686AC;
		  /* 821686ACh */ case    9:  		/* addi R3, R1, 112 */
		/* 821686ACh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821686ACh case    9:*/		return 0x821686B0;
		  /* 821686B0h */ case   10:  		/* bl 583368 */
		/* 821686B0h case   10:*/		regs.LR = 0x821686B4; return 0x821F6D78;
		/* 821686B0h case   10:*/		return 0x821686B4;
		  /* 821686B4h */ case   11:  		/* addi R3, R1, 112 */
		/* 821686B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821686B4h case   11:*/		return 0x821686B8;
		  /* 821686B8h */ case   12:  		/* bl 583552 */
		/* 821686B8h case   12:*/		regs.LR = 0x821686BC; return 0x821F6E38;
		/* 821686B8h case   12:*/		return 0x821686BC;
		  /* 821686BCh */ case   13:  		/* mr R4, R3 */
		/* 821686BCh case   13:*/		regs.R4 = regs.R3;
		/* 821686BCh case   13:*/		return 0x821686C0;
		  /* 821686C0h */ case   14:  		/* mr R3, R15 */
		/* 821686C0h case   14:*/		regs.R3 = regs.R15;
		/* 821686C0h case   14:*/		return 0x821686C4;
		  /* 821686C4h */ case   15:  		/* li R5, 0 */
		/* 821686C4h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821686C4h case   15:*/		return 0x821686C8;
		  /* 821686C8h */ case   16:  		/* li R6, 1 */
		/* 821686C8h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821686C8h case   16:*/		return 0x821686CC;
		  /* 821686CCh */ case   17:  		/* bl 538060 */
		/* 821686CCh case   17:*/		regs.LR = 0x821686D0; return 0x821EBC98;
		/* 821686CCh case   17:*/		return 0x821686D0;
		  /* 821686D0h */ case   18:  		/* lwz R4, <#[R3 + 32]> */
		/* 821686D0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000020) );
		/* 821686D0h case   18:*/		return 0x821686D4;
		  /* 821686D4h */ case   19:  		/* li R6, 1 */
		/* 821686D4h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821686D4h case   19:*/		return 0x821686D8;
		  /* 821686D8h */ case   20:  		/* li R5, 0 */
		/* 821686D8h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821686D8h case   20:*/		return 0x821686DC;
		  /* 821686DCh */ case   21:  		/* mr R3, R15 */
		/* 821686DCh case   21:*/		regs.R3 = regs.R15;
		/* 821686DCh case   21:*/		return 0x821686E0;
		  /* 821686E0h */ case   22:  		/* bl 538040 */
		/* 821686E0h case   22:*/		regs.LR = 0x821686E4; return 0x821EBC98;
		/* 821686E0h case   22:*/		return 0x821686E4;
		  /* 821686E4h */ case   23:  		/* lwz R4, <#[R3 + 32]> */
		/* 821686E4h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000020) );
		/* 821686E4h case   23:*/		return 0x821686E8;
		  /* 821686E8h */ case   24:  		/* mr R3, R15 */
		/* 821686E8h case   24:*/		regs.R3 = regs.R15;
		/* 821686E8h case   24:*/		return 0x821686EC;
		  /* 821686ECh */ case   25:  		/* bl 538196 */
		/* 821686ECh case   25:*/		regs.LR = 0x821686F0; return 0x821EBD40;
		/* 821686ECh case   25:*/		return 0x821686F0;
		  /* 821686F0h */ case   26:  		/* mr R11, R3 */
		/* 821686F0h case   26:*/		regs.R11 = regs.R3;
		/* 821686F0h case   26:*/		return 0x821686F4;
		  /* 821686F4h */ case   27:  		/* mr R3, R15 */
		/* 821686F4h case   27:*/		regs.R3 = regs.R15;
		/* 821686F4h case   27:*/		return 0x821686F8;
		  /* 821686F8h */ case   28:  		/* lwz R4, <#[R11 + 8]> */
		/* 821686F8h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 821686F8h case   28:*/		return 0x821686FC;
		  /* 821686FCh */ case   29:  		/* bl 538140 */
		/* 821686FCh case   29:*/		regs.LR = 0x82168700; return 0x821EBD18;
		/* 821686FCh case   29:*/		return 0x82168700;
		  /* 82168700h */ case   30:  		/* lwz R11, <#[R3 + 16]> */
		/* 82168700h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82168700h case   30:*/		return 0x82168704;
		  /* 82168704h */ case   31:  		/* cmpwi CR6, R11, 5 */
		/* 82168704h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 82168704h case   31:*/		return 0x82168708;
		  /* 82168708h */ case   32:  		/* bc 4, CR6_EQ, 596 */
		/* 82168708h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8216895C;  }
		/* 82168708h case   32:*/		return 0x8216870C;
		  /* 8216870Ch */ case   33:  		/* lwz R5, <#[R3 + 24]> */
		/* 8216870Ch case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000018) );
		/* 8216870Ch case   33:*/		return 0x82168710;
		  /* 82168710h */ case   34:  		/* mr R6, R30 */
		/* 82168710h case   34:*/		regs.R6 = regs.R30;
		/* 82168710h case   34:*/		return 0x82168714;
		  /* 82168714h */ case   35:  		/* mr R4, R25 */
		/* 82168714h case   35:*/		regs.R4 = regs.R25;
		/* 82168714h case   35:*/		return 0x82168718;
		  /* 82168718h */ case   36:  		/* mr R3, R16 */
		/* 82168718h case   36:*/		regs.R3 = regs.R16;
		/* 82168718h case   36:*/		return 0x8216871C;
		  /* 8216871Ch */ case   37:  		/* bl -120188 */
		/* 8216871Ch case   37:*/		regs.LR = 0x82168720; return 0x8214B1A0;
		/* 8216871Ch case   37:*/		return 0x82168720;
		  /* 82168720h */ case   38:  		/* addi R3, R1, 112 */
		/* 82168720h case   38:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82168720h case   38:*/		return 0x82168724;
		  /* 82168724h */ case   39:  		/* mr R31, R23 */
		/* 82168724h case   39:*/		regs.R31 = regs.R23;
		/* 82168724h case   39:*/		return 0x82168728;
		  /* 82168728h */ case   40:  		/* bl 583440 */
		/* 82168728h case   40:*/		regs.LR = 0x8216872C; return 0x821F6E38;
		/* 82168728h case   40:*/		return 0x8216872C;
		  /* 8216872Ch */ case   41:  		/* cmplwi CR0, R3, 0 */
		/* 8216872Ch case   41:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8216872Ch case   41:*/		return 0x82168730;
		  /* 82168730h */ case   42:  		/* bc 12, CR0_EQ, 556 */
		/* 82168730h case   42:*/		if ( regs.CR[0].eq ) { return 0x8216895C;  }
		/* 82168730h case   42:*/		return 0x82168734;
		  /* 82168734h */ case   43:  		/* addi R3, R1, 112 */
		/* 82168734h case   43:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82168734h case   43:*/		return 0x82168738;
		  /* 82168738h */ case   44:  		/* addi R31, R31, 1 */
		/* 82168738h case   44:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82168738h case   44:*/		return 0x8216873C;
		  /* 8216873Ch */ case   45:  		/* bl 583420 */
		/* 8216873Ch case   45:*/		regs.LR = 0x82168740; return 0x821F6E38;
		/* 8216873Ch case   45:*/		return 0x82168740;
		  /* 82168740h */ case   46:  		/* cmplwi CR0, R3, 0 */
		/* 82168740h case   46:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82168740h case   46:*/		return 0x82168744;
		  /* 82168744h */ case   47:  		/* bc 4, CR0_EQ, -16 */
		/* 82168744h case   47:*/		if ( !regs.CR[0].eq ) { return 0x82168734;  }
		/* 82168744h case   47:*/		return 0x82168748;
		  /* 82168748h */ case   48:  		/* cmplwi CR6, R31, 0 */
		/* 82168748h case   48:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82168748h case   48:*/		return 0x8216874C;
		  /* 8216874Ch */ case   49:  		/* bc 12, CR6_EQ, 528 */
		/* 8216874Ch case   49:*/		if ( regs.CR[6].eq ) { return 0x8216895C;  }
		/* 8216874Ch case   49:*/		return 0x82168750;
		  /* 82168750h */ case   50:  		/* mr R5, R31 */
		/* 82168750h case   50:*/		regs.R5 = regs.R31;
		/* 82168750h case   50:*/		return 0x82168754;
		  /* 82168754h */ case   51:  		/* mr R4, R25 */
		/* 82168754h case   51:*/		regs.R4 = regs.R25;
		/* 82168754h case   51:*/		return 0x82168758;
		  /* 82168758h */ case   52:  		/* mr R3, R16 */
		/* 82168758h case   52:*/		regs.R3 = regs.R16;
		/* 82168758h case   52:*/		return 0x8216875C;
		  /* 8216875Ch */ case   53:  		/* bl -120244 */
		/* 8216875Ch case   53:*/		regs.LR = 0x82168760; return 0x8214B1A8;
		/* 8216875Ch case   53:*/		return 0x82168760;
		  /* 82168760h */ case   54:  		/* mr R4, R29 */
		/* 82168760h case   54:*/		regs.R4 = regs.R29;
		/* 82168760h case   54:*/		return 0x82168764;
		  /* 82168764h */ case   55:  		/* addi R3, R1, 112 */
		/* 82168764h case   55:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82168764h case   55:*/		return 0x82168768;
		  /* 82168768h */ case   56:  		/* bl 583696 */
		/* 82168768h case   56:*/		regs.LR = 0x8216876C; return 0x821F6F78;
		/* 82168768h case   56:*/		return 0x8216876C;
		  /* 8216876Ch */ case   57:  		/* addi R3, R1, 112 */
		/* 8216876Ch case   57:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8216876Ch case   57:*/		return 0x82168770;
		  /* 82168770h */ case   58:  		/* bl 583368 */
		/* 82168770h case   58:*/		regs.LR = 0x82168774; return 0x821F6E38;
		/* 82168770h case   58:*/		return 0x82168774;
		  /* 82168774h */ case   59:  		/* addi R3, R1, 112 */
		/* 82168774h case   59:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82168774h case   59:*/		return 0x82168778;
		  /* 82168778h */ case   60:  		/* mr R26, R23 */
		/* 82168778h case   60:*/		regs.R26 = regs.R23;
		/* 82168778h case   60:*/		return 0x8216877C;
		  /* 8216877Ch */ case   61:  		/* bl 583356 */
		/* 8216877Ch case   61:*/		regs.LR = 0x82168780; return 0x821F6E38;
		/* 8216877Ch case   61:*/		return 0x82168780;
		  /* 82168780h */ case   62:  		/* cmplwi CR0, R3, 0 */
		/* 82168780h case   62:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82168780h case   62:*/		return 0x82168784;
		  /* 82168784h */ case   63:  		/* bc 12, CR0_EQ, 472 */
		/* 82168784h case   63:*/		if ( regs.CR[0].eq ) { return 0x8216895C;  }
		/* 82168784h case   63:*/		return 0x82168788;
		  /* 82168788h */ case   64:  		/* cmplwi CR6, R27, 0 */
		/* 82168788h case   64:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82168788h case   64:*/		return 0x8216878C;
		  /* 8216878Ch */ case   65:  		/* bc 12, CR6_EQ, 544 */
		/* 8216878Ch case   65:*/		if ( regs.CR[6].eq ) { return 0x821689AC;  }
		/* 8216878Ch case   65:*/		return 0x82168790;
		  /* 82168790h */ case   66:  		/* mr R4, R3 */
		/* 82168790h case   66:*/		regs.R4 = regs.R3;
		/* 82168790h case   66:*/		return 0x82168794;
		  /* 82168794h */ case   67:  		/* li R5, 0 */
		/* 82168794h case   67:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168794h case   67:*/		return 0x82168798;
		  /* 82168798h */ case   68:  		/* mr R3, R15 */
		/* 82168798h case   68:*/		regs.R3 = regs.R15;
		/* 82168798h case   68:*/		return 0x8216879C;
		  /* 8216879Ch */ case   69:  		/* bl 537796 */
		/* 8216879Ch case   69:*/		regs.LR = 0x821687A0; return 0x821EBC60;
		/* 8216879Ch case   69:*/		return 0x821687A0;
		  /* 821687A0h */ case   70:  		/* lwz R4, <#[R3 + 16]> */
		/* 821687A0h case   70:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 821687A0h case   70:*/		return 0x821687A4;
		  /* 821687A4h */ case   71:  		/* mr R31, R3 */
		/* 821687A4h case   71:*/		regs.R31 = regs.R3;
		/* 821687A4h case   71:*/		return 0x821687A8;
		  /* 821687A8h */ case   72:  		/* cmplwi CR6, R4, 0 */
		/* 821687A8h case   72:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821687A8h case   72:*/		return 0x821687AC;
		  /* 821687ACh */ case   73:  		/* bc 12, CR6_EQ, 20 */
		/* 821687ACh case   73:*/		if ( regs.CR[6].eq ) { return 0x821687C0;  }
		/* 821687ACh case   73:*/		return 0x821687B0;
		  /* 821687B0h */ case   74:  		/* mr R3, R15 */
		/* 821687B0h case   74:*/		regs.R3 = regs.R15;
		/* 821687B0h case   74:*/		return 0x821687B4;
		  /* 821687B4h */ case   75:  		/* bl 537916 */
		/* 821687B4h case   75:*/		regs.LR = 0x821687B8; return 0x821EBCF0;
		/* 821687B4h case   75:*/		return 0x821687B8;
		  /* 821687B8h */ case   76:  		/* lwz R6, <#[R3 + 20]> */
		/* 821687B8h case   76:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 821687B8h case   76:*/		return 0x821687BC;
		  /* 821687BCh */ case   77:  		/* b 8 */
		/* 821687BCh case   77:*/		return 0x821687C4;
		/* 821687BCh case   77:*/		return 0x821687C0;
	}
	return 0x821687C0;
} // Block from 82168688h-821687C0h (78 instructions)

//////////////////////////////////////////////////////
// Block at 821687C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821687C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821687C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821687C0);
		  /* 821687C0h */ case    0:  		/* li R6, 55 */
		/* 821687C0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x37);
		/* 821687C0h case    0:*/		return 0x821687C4;
	}
	return 0x821687C4;
} // Block from 821687C0h-821687C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821687C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821687C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821687C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821687C4);
		  /* 821687C4h */ case    0:  		/* mr R5, R26 */
		/* 821687C4h case    0:*/		regs.R5 = regs.R26;
		/* 821687C4h case    0:*/		return 0x821687C8;
		  /* 821687C8h */ case    1:  		/* lwz R8, <#[R31 + 24]> */
		/* 821687C8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 821687C8h case    1:*/		return 0x821687CC;
		  /* 821687CCh */ case    2:  		/* mr R4, R25 */
		/* 821687CCh case    2:*/		regs.R4 = regs.R25;
		/* 821687CCh case    2:*/		return 0x821687D0;
		  /* 821687D0h */ case    3:  		/* lwz R7, <#[R31 + 20]> */
		/* 821687D0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 821687D0h case    3:*/		return 0x821687D4;
		  /* 821687D4h */ case    4:  		/* mr R3, R16 */
		/* 821687D4h case    4:*/		regs.R3 = regs.R16;
		/* 821687D4h case    4:*/		return 0x821687D8;
		  /* 821687D8h */ case    5:  		/* bl -120360 */
		/* 821687D8h case    5:*/		regs.LR = 0x821687DC; return 0x8214B1B0;
		/* 821687D8h case    5:*/		return 0x821687DC;
		  /* 821687DCh */ case    6:  		/* lwz R11, <#[R15 + 56]> */
		/* 821687DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000038) );
		/* 821687DCh case    6:*/		return 0x821687E0;
		  /* 821687E0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 821687E0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821687E0h case    7:*/		return 0x821687E4;
		  /* 821687E4h */ case    8:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 821687E4h case    8:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 821687E4h case    8:*/		return 0x821687E8;
		  /* 821687E8h */ case    9:  		/* bc 12, CR0_EQ, 324 */
		/* 821687E8h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216892C;  }
		/* 821687E8h case    9:*/		return 0x821687EC;
		  /* 821687ECh */ case   10:  		/* lwz R11, <#[R31 + 20]> */
		/* 821687ECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821687ECh case   10:*/		return 0x821687F0;
		  /* 821687F0h */ case   11:  		/* mr R5, R26 */
		/* 821687F0h case   11:*/		regs.R5 = regs.R26;
		/* 821687F0h case   11:*/		return 0x821687F4;
		  /* 821687F4h */ case   12:  		/* lwz R10, <#[R31 + 24]> */
		/* 821687F4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 821687F4h case   12:*/		return 0x821687F8;
		  /* 821687F8h */ case   13:  		/* mr R4, R25 */
		/* 821687F8h case   13:*/		regs.R4 = regs.R25;
		/* 821687F8h case   13:*/		return 0x821687FC;
		  /* 821687FCh */ case   14:  		/* lwz R23, <#[R1 + 108]> */
		/* 821687FCh case   14:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000006C) );
		/* 821687FCh case   14:*/		return 0x82168800;
		  /* 82168800h */ case   15:  		/* mullw R24, R11, R10 */
		/* 82168800h case   15:*/		cpu::op::mullw<0>(regs,&regs.R24,regs.R11,regs.R10);
		/* 82168800h case   15:*/		return 0x82168804;
		  /* 82168804h */ case   16:  		/* mr R3, R23 */
		/* 82168804h case   16:*/		regs.R3 = regs.R23;
		/* 82168804h case   16:*/		return 0x82168808;
		  /* 82168808h */ case   17:  		/* mr R6, R24 */
		/* 82168808h case   17:*/		regs.R6 = regs.R24;
		/* 82168808h case   17:*/		return 0x8216880C;
		  /* 8216880Ch */ case   18:  		/* bl -120404 */
		/* 8216880Ch case   18:*/		regs.LR = 0x82168810; return 0x8214B1B8;
		/* 8216880Ch case   18:*/		return 0x82168810;
		  /* 82168810h */ case   19:  		/* li R28, 0 */
		/* 82168810h case   19:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82168810h case   19:*/		return 0x82168814;
		  /* 82168814h */ case   20:  		/* cmplwi CR6, R24, 0 */
		/* 82168814h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82168814h case   20:*/		return 0x82168818;
		  /* 82168818h */ case   21:  		/* bc 12, CR6_EQ, 276 */
		/* 82168818h case   21:*/		if ( regs.CR[6].eq ) { return 0x8216892C;  }
		/* 82168818h case   21:*/		return 0x8216881C;
		  /* 8216881Ch */ case   22:  		/* lwz R29, <#[R27]> */
		/* 8216881Ch case   22:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 8216881Ch case   22:*/		return 0x82168820;
		  /* 82168820h */ case   23:  		/* cmplwi CR6, R29, 0 */
		/* 82168820h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82168820h case   23:*/		return 0x82168824;
		  /* 82168824h */ case   24:  		/* bc 12, CR6_EQ, 404 */
		/* 82168824h case   24:*/		if ( regs.CR[6].eq ) { return 0x821689B8;  }
		/* 82168824h case   24:*/		return 0x82168828;
		  /* 82168828h */ case   25:  		/* lwz R11, <#[R29]> */
		/* 82168828h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82168828h case   25:*/		return 0x8216882C;
		  /* 8216882Ch */ case   26:  		/* rlwinm. R10, R11, 7, 29, 31 */
		/* 8216882Ch case   26:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R10,regs.R11);
		/* 8216882Ch case   26:*/		return 0x82168830;
		  /* 82168830h */ case   27:  		/* bc 4, CR0_EQ, 12 */
		/* 82168830h case   27:*/		if ( !regs.CR[0].eq ) { return 0x8216883C;  }
		/* 82168830h case   27:*/		return 0x82168834;
		  /* 82168834h */ case   28:  		/* lwz R29, <#[R29 + 4]> */
		/* 82168834h case   28:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 82168834h case   28:*/		return 0x82168838;
		  /* 82168838h */ case   29:  		/* b -24 */
		/* 82168838h case   29:*/		return 0x82168820;
		/* 82168838h case   29:*/		return 0x8216883C;
	}
	return 0x8216883C;
} // Block from 821687C4h-8216883Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 8216883Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216883C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216883C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216883C);
		  /* 8216883Ch */ case    0:  		/* li R30, 0 */
		/* 8216883Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216883Ch case    0:*/		return 0x82168840;
		  /* 82168840h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82168840h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82168840h case    1:*/		return 0x82168844;
		  /* 82168844h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 82168844h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216888C;  }
		/* 82168844h case    2:*/		return 0x82168848;
		  /* 82168848h */ case    3:  		/* li R31, 0 */
		/* 82168848h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82168848h case    3:*/		return 0x8216884C;
		  /* 8216884Ch */ case    4:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 8216884Ch case    4:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 8216884Ch case    4:*/		return 0x82168850;
		  /* 82168850h */ case    5:  		/* mr R6, R28 */
		/* 82168850h case    5:*/		regs.R6 = regs.R28;
		/* 82168850h case    5:*/		return 0x82168854;
		  /* 82168854h */ case    6:  		/* srw R10, R10, R31 */
		/* 82168854h case    6:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82168854h case    6:*/		return 0x82168858;
		  /* 82168858h */ case    7:  		/* rlwimi R10, R11, 17, 22, 29 */
		/* 82168858h case    7:*/		cpu::op::rlwimi<0,17,22,29>(regs,&regs.R10,regs.R11);
		/* 82168858h case    7:*/		return 0x8216885C;
		  /* 8216885Ch */ case    8:  		/* mr R5, R26 */
		/* 8216885Ch case    8:*/		regs.R5 = regs.R26;
		/* 8216885Ch case    8:*/		return 0x82168860;
		  /* 82168860h */ case    9:  		/* rlwinm R7, R10, 0, 22, 31 */
		/* 82168860h case    9:*/		cpu::op::rlwinm<0,0,22,31>(regs,&regs.R7,regs.R10);
		/* 82168860h case    9:*/		return 0x82168864;
		  /* 82168864h */ case   10:  		/* mr R4, R25 */
		/* 82168864h case   10:*/		regs.R4 = regs.R25;
		/* 82168864h case   10:*/		return 0x82168868;
		  /* 82168868h */ case   11:  		/* mr R3, R23 */
		/* 82168868h case   11:*/		regs.R3 = regs.R23;
		/* 82168868h case   11:*/		return 0x8216886C;
		  /* 8216886Ch */ case   12:  		/* bl -120492 */
		/* 8216886Ch case   12:*/		regs.LR = 0x82168870; return 0x8214B1C0;
		/* 8216886Ch case   12:*/		return 0x82168870;
		  /* 82168870h */ case   13:  		/* lwz R11, <#[R29]> */
		/* 82168870h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82168870h case   13:*/		return 0x82168874;
		  /* 82168874h */ case   14:  		/* addi R30, R30, 1 */
		/* 82168874h case   14:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82168874h case   14:*/		return 0x82168878;
		  /* 82168878h */ case   15:  		/* rlwinm R10, R11, 7, 29, 31 */
		/* 82168878h case   15:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R11);
		/* 82168878h case   15:*/		return 0x8216887C;
		  /* 8216887Ch */ case   16:  		/* addi R28, R28, 1 */
		/* 8216887Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8216887Ch case   16:*/		return 0x82168880;
		  /* 82168880h */ case   17:  		/* addi R31, R31, 2 */
		/* 82168880h case   17:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 82168880h case   17:*/		return 0x82168884;
		  /* 82168884h */ case   18:  		/* cmplw CR6, R30, R10 */
		/* 82168884h case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 82168884h case   18:*/		return 0x82168888;
		  /* 82168888h */ case   19:  		/* bc 12, CR6_LT, -60 */
		/* 82168888h case   19:*/		if ( regs.CR[6].lt ) { return 0x8216884C;  }
		/* 82168888h case   19:*/		return 0x8216888C;
	}
	return 0x8216888C;
} // Block from 8216883Ch-8216888Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216888Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216888C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216888C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216888C);
		  /* 8216888Ch */ case    0:  		/* lwz R30, <#[R27 + 4]> */
		/* 8216888Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000004) );
		/* 8216888Ch case    0:*/		return 0x82168890;
		  /* 82168890h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82168890h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82168890h case    1:*/		return 0x82168894;
		  /* 82168894h */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 82168894h case    2:*/		if ( regs.CR[6].eq ) { return 0x82168920;  }
		/* 82168894h case    2:*/		return 0x82168898;
		  /* 82168898h */ case    3:  		/* lwz R31, <#[R30 + 16]> */
		/* 82168898h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82168898h case    3:*/		return 0x8216889C;
		  /* 8216889Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8216889Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8216889Ch case    4:*/		return 0x821688A0;
		  /* 821688A0h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 821688A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82168910;  }
		/* 821688A0h case    5:*/		return 0x821688A4;
		  /* 821688A4h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 821688A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821688A4h case    6:*/		return 0x821688A8;
		  /* 821688A8h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 821688A8h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 821688A8h case    7:*/		return 0x821688AC;
		  /* 821688ACh */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821688ACh case    8:*/		if ( !regs.CR[0].eq ) { return 0x821688BC;  }
		/* 821688ACh case    8:*/		return 0x821688B0;
		  /* 821688B0h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821688B0h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821688B0h case    9:*/		return 0x821688B4;
		  /* 821688B4h */ case   10:  		/* li R11, 1 */
		/* 821688B4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821688B4h case   10:*/		return 0x821688B8;
		  /* 821688B8h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 821688B8h case   11:*/		if ( regs.CR[0].eq ) { return 0x821688C0;  }
		/* 821688B8h case   11:*/		return 0x821688BC;
	}
	return 0x821688BC;
} // Block from 8216888Ch-821688BCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821688BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821688BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821688BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821688BC);
		  /* 821688BCh */ case    0:  		/* li R11, 0 */
		/* 821688BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821688BCh case    0:*/		return 0x821688C0;
	}
	return 0x821688C0;
} // Block from 821688BCh-821688C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821688C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821688C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821688C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821688C0);
		  /* 821688C0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821688C0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821688C0h case    0:*/		return 0x821688C4;
		  /* 821688C4h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 821688C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82168910;  }
		/* 821688C4h case    1:*/		return 0x821688C8;
		  /* 821688C8h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821688C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821688C8h case    2:*/		return 0x821688CC;
		  /* 821688CCh */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821688CCh case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821688CCh case    3:*/		return 0x821688D0;
		  /* 821688D0h */ case    4:  		/* cmplwi CR6, R11, 14976 */
		/* 821688D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821688D0h case    4:*/		return 0x821688D4;
		  /* 821688D4h */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 821688D4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82168910;  }
		/* 821688D4h case    5:*/		return 0x821688D8;
		  /* 821688D8h */ case    6:  		/* li R6, 0 */
		/* 821688D8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821688D8h case    6:*/		return 0x821688DC;
		  /* 821688DCh */ case    7:  		/* li R5, 0 */
		/* 821688DCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821688DCh case    7:*/		return 0x821688E0;
		  /* 821688E0h */ case    8:  		/* li R4, 117 */
		/* 821688E0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821688E0h case    8:*/		return 0x821688E4;
		  /* 821688E4h */ case    9:  		/* mr R3, R15 */
		/* 821688E4h case    9:*/		regs.R3 = regs.R15;
		/* 821688E4h case    9:*/		return 0x821688E8;
		  /* 821688E8h */ case   10:  		/* bl -17592 */
		/* 821688E8h case   10:*/		regs.LR = 0x821688EC; return 0x82164430;
		/* 821688E8h case   10:*/		return 0x821688EC;
		  /* 821688ECh */ case   11:  		/* add R11, R3, R31 */
		/* 821688ECh case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 821688ECh case   11:*/		return 0x821688F0;
		  /* 821688F0h */ case   12:  		/* lwz R11, <#[R11 - 16]> */
		/* 821688F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 821688F0h case   12:*/		return 0x821688F4;
		  /* 821688F4h */ case   13:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 821688F4h case   13:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821688F4h case   13:*/		return 0x821688F8;
		  /* 821688F8h */ case   14:  		/* cmplwi CR6, R11, 7 */
		/* 821688F8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 821688F8h case   14:*/		return 0x821688FC;
		  /* 821688FCh */ case   15:  		/* bc 4, CR6_EQ, 20 */
		/* 821688FCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82168910;  }
		/* 821688FCh case   15:*/		return 0x82168900;
		  /* 82168900h */ case   16:  		/* add R11, R3, R31 */
		/* 82168900h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R31);
		/* 82168900h case   16:*/		return 0x82168904;
		  /* 82168904h */ case   17:  		/* lwz R11, <#[R11 - 12]> */
		/* 82168904h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF4) );
		/* 82168904h case   17:*/		return 0x82168908;
		  /* 82168908h */ case   18:  		/* cmpwi CR6, R11, 3 */
		/* 82168908h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82168908h case   18:*/		return 0x8216890C;
		  /* 8216890Ch */ case   19:  		/* bc 12, CR6_EQ, 12 */
		/* 8216890Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82168918;  }
		/* 8216890Ch case   19:*/		return 0x82168910;
	}
	return 0x82168910;
} // Block from 821688C0h-82168910h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82168910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168910);
		  /* 82168910h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82168910h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82168910h case    0:*/		return 0x82168914;
		  /* 82168914h */ case    1:  		/* b -132 */
		/* 82168914h case    1:*/		return 0x82168890;
		/* 82168914h case    1:*/		return 0x82168918;
	}
	return 0x82168918;
} // Block from 82168910h-82168918h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168918);
		  /* 82168918h */ case    0:  		/* mr R27, R31 */
		/* 82168918h case    0:*/		regs.R27 = regs.R31;
		/* 82168918h case    0:*/		return 0x8216891C;
		  /* 8216891Ch */ case    1:  		/* b 8 */
		/* 8216891Ch case    1:*/		return 0x82168924;
		/* 8216891Ch case    1:*/		return 0x82168920;
	}
	return 0x82168920;
} // Block from 82168918h-82168920h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168920);
		  /* 82168920h */ case    0:  		/* li R27, 0 */
		/* 82168920h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82168920h case    0:*/		return 0x82168924;
	}
	return 0x82168924;
} // Block from 82168920h-82168924h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82168924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168924);
		  /* 82168924h */ case    0:  		/* cmplw CR6, R28, R24 */
		/* 82168924h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R24);
		/* 82168924h case    0:*/		return 0x82168928;
		  /* 82168928h */ case    1:  		/* bc 12, CR6_LT, -268 */
		/* 82168928h case    1:*/		if ( regs.CR[6].lt ) { return 0x8216881C;  }
		/* 82168928h case    1:*/		return 0x8216892C;
	}
	return 0x8216892C;
} // Block from 82168924h-8216892Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216892Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216892C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216892C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216892C);
		  /* 8216892Ch */ case    0:  		/* addi R3, R1, 112 */
		/* 8216892Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8216892Ch case    0:*/		return 0x82168930;
		  /* 82168930h */ case    1:  		/* addi R26, R26, 1 */
		/* 82168930h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82168930h case    1:*/		return 0x82168934;
		  /* 82168934h */ case    2:  		/* bl 582916 */
		/* 82168934h case    2:*/		regs.LR = 0x82168938; return 0x821F6E38;
		/* 82168934h case    2:*/		return 0x82168938;
		  /* 82168938h */ case    3:  		/* lwz R16, <#[R1 + 108]> */
		/* 82168938h case    3:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x0000006C) );
		/* 82168938h case    3:*/		return 0x8216893C;
		  /* 8216893Ch */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 8216893Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8216893Ch case    4:*/		return 0x82168940;
		  /* 82168940h */ case    5:  		/* bc 4, CR0_EQ, -440 */
		/* 82168940h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82168788;  }
		/* 82168940h case    5:*/		return 0x82168944;
		  /* 82168944h */ case    6:  		/* lwz R21, <#[R1 + 100]> */
		/* 82168944h case    6:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000064) );
		/* 82168944h case    6:*/		return 0x82168948;
		  /* 82168948h */ case    7:  		/* li R23, 0 */
		/* 82168948h case    7:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82168948h case    7:*/		return 0x8216894C;
		  /* 8216894Ch */ case    8:  		/* lwz R18, <#[R1 + 104]> */
		/* 8216894Ch case    8:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000068) );
		/* 8216894Ch case    8:*/		return 0x82168950;
		  /* 82168950h */ case    9:  		/* li R22, 1 */
		/* 82168950h case    9:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82168950h case    9:*/		return 0x82168954;
		  /* 82168954h */ case   10:  		/* lwz R17, <#[R1 + 96]> */
		/* 82168954h case   10:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000060) );
		/* 82168954h case   10:*/		return 0x82168958;
		  /* 82168958h */ case   11:  		/* lwz R14, <#[R1 + 492]> */
		/* 82168958h case   11:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x000001EC) );
		/* 82168958h case   11:*/		return 0x8216895C;
	}
	return 0x8216895C;
} // Block from 8216892Ch-8216895Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216895Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216895C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216895C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216895C);
		  /* 8216895Ch */ case    0:  		/* addi R3, R1, 112 */
		/* 8216895Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8216895Ch case    0:*/		return 0x82168960;
		  /* 82168960h */ case    1:  		/* bl 544976 */
		/* 82168960h case    1:*/		regs.LR = 0x82168964; return 0x821EDA30;
		/* 82168960h case    1:*/		return 0x82168964;
	}
	return 0x82168964;
} // Block from 8216895Ch-82168964h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168964);
		  /* 82168964h */ case    0:  		/* lwz R25, <#[R1 + 476]> */
		/* 82168964h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000001DC) );
		/* 82168964h case    0:*/		return 0x82168968;
	}
	return 0x82168968;
} // Block from 82168964h-82168968h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82168968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168968);
		  /* 82168968h */ case    0:  		/* rlwinm R11, R17, 0, 0, 30 */
		/* 82168968h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R17);
		/* 82168968h case    0:*/		return 0x8216896C;
		  /* 8216896Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8216896Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216896Ch case    1:*/		return 0x82168970;
		  /* 82168970h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82168970h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82168970h case    2:*/		return 0x82168974;
		  /* 82168974h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 82168974h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216898C;  }
		/* 82168974h case    3:*/		return 0x82168978;
		  /* 82168978h */ case    4:  		/* mr R17, R11 */
		/* 82168978h case    4:*/		regs.R17 = regs.R11;
		/* 82168978h case    4:*/		return 0x8216897C;
		  /* 8216897Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8216897Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216897Ch case    5:*/		return 0x82168980;
	}
	return 0x82168980;
} // Block from 82168968h-82168980h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82168980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168980);
		  /* 82168980h */ case    0:  		/* stw R17, <#[R1 + 96]> */
		/* 82168980h case    0:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000060) );
		/* 82168980h case    0:*/		return 0x82168984;
		  /* 82168984h */ case    1:  		/* bc 4, CR6_EQ, -1216 */
		/* 82168984h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821684C4;  }
		/* 82168984h case    1:*/		return 0x82168988;
		  /* 82168988h */ case    2:  		/* b 68 */
		/* 82168988h case    2:*/		return 0x821689CC;
		/* 82168988h case    2:*/		return 0x8216898C;
	}
	return 0x8216898C;
} // Block from 82168980h-8216898Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216898Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216898C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216898C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216898C);
		  /* 8216898Ch */ case    0:  		/* mr R17, R23 */
		/* 8216898Ch case    0:*/		regs.R17 = regs.R23;
		/* 8216898Ch case    0:*/		return 0x82168990;
		  /* 82168990h */ case    1:  		/* b 60 */
		/* 82168990h case    1:*/		return 0x821689CC;
		/* 82168990h case    1:*/		return 0x82168994;
	}
	return 0x82168994;
} // Block from 8216898Ch-82168994h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168994);
		  /* 82168994h */ case    0:  		/* li R4, 4800 */
		/* 82168994h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82168994h case    0:*/		return 0x82168998;
		  /* 82168998h */ case    1:  		/* mr R3, R15 */
		/* 82168998h case    1:*/		regs.R3 = regs.R15;
		/* 82168998h case    1:*/		return 0x8216899C;
		  /* 8216899Ch */ case    2:  		/* bl -92980 */
		/* 8216899Ch case    2:*/		regs.LR = 0x821689A0; return 0x82151E68;
		/* 8216899Ch case    2:*/		return 0x821689A0;
	}
	return 0x821689A0;
} // Block from 82168994h-821689A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821689A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689A0);
		  /* 821689A0h */ case    0:  		/* li R4, 4800 */
		/* 821689A0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821689A0h case    0:*/		return 0x821689A4;
		  /* 821689A4h */ case    1:  		/* mr R3, R15 */
		/* 821689A4h case    1:*/		regs.R3 = regs.R15;
		/* 821689A4h case    1:*/		return 0x821689A8;
		  /* 821689A8h */ case    2:  		/* bl -92992 */
		/* 821689A8h case    2:*/		regs.LR = 0x821689AC; return 0x82151E68;
		/* 821689A8h case    2:*/		return 0x821689AC;
	}
	return 0x821689AC;
} // Block from 821689A0h-821689ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821689ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689AC);
		  /* 821689ACh */ case    0:  		/* li R4, 4800 */
		/* 821689ACh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821689ACh case    0:*/		return 0x821689B0;
		  /* 821689B0h */ case    1:  		/* mr R3, R15 */
		/* 821689B0h case    1:*/		regs.R3 = regs.R15;
		/* 821689B0h case    1:*/		return 0x821689B4;
		  /* 821689B4h */ case    2:  		/* bl -93004 */
		/* 821689B4h case    2:*/		regs.LR = 0x821689B8; return 0x82151E68;
		/* 821689B4h case    2:*/		return 0x821689B8;
	}
	return 0x821689B8;
} // Block from 821689ACh-821689B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821689B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689B8);
		  /* 821689B8h */ case    0:  		/* li R4, 4800 */
		/* 821689B8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821689B8h case    0:*/		return 0x821689BC;
		  /* 821689BCh */ case    1:  		/* mr R3, R15 */
		/* 821689BCh case    1:*/		regs.R3 = regs.R15;
		/* 821689BCh case    1:*/		return 0x821689C0;
		  /* 821689C0h */ case    2:  		/* bl -93016 */
		/* 821689C0h case    2:*/		regs.LR = 0x821689C4; return 0x82151E68;
		/* 821689C0h case    2:*/		return 0x821689C4;
	}
	return 0x821689C4;
} // Block from 821689B8h-821689C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821689C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689C4);
		  /* 821689C4h */ case    0:  		/* mr R3, R16 */
		/* 821689C4h case    0:*/		regs.R3 = regs.R16;
		/* 821689C4h case    0:*/		return 0x821689C8;
		  /* 821689C8h */ case    1:  		/* bl -140288 */
		/* 821689C8h case    1:*/		regs.LR = 0x821689CC; return 0x821465C8;
		/* 821689C8h case    1:*/		return 0x821689CC;
	}
	return 0x821689CC;
} // Block from 821689C4h-821689CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821689CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689CC);
		  /* 821689CCh */ case    0:  		/* lwz R11, <#[R15 + 44]> */
		/* 821689CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000002C) );
		/* 821689CCh case    0:*/		return 0x821689D0;
		  /* 821689D0h */ case    1:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 821689D0h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 821689D0h case    1:*/		return 0x821689D4;
		  /* 821689D4h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 821689D4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821689E4;  }
		/* 821689D4h case    2:*/		return 0x821689D8;
		  /* 821689D8h */ case    3:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 821689D8h case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 821689D8h case    3:*/		return 0x821689DC;
		  /* 821689DCh */ case    4:  		/* mr R11, R22 */
		/* 821689DCh case    4:*/		regs.R11 = regs.R22;
		/* 821689DCh case    4:*/		return 0x821689E0;
		  /* 821689E0h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 821689E0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821689E8;  }
		/* 821689E0h case    5:*/		return 0x821689E4;
	}
	return 0x821689E4;
} // Block from 821689CCh-821689E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821689E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689E4);
		  /* 821689E4h */ case    0:  		/* mr R11, R23 */
		/* 821689E4h case    0:*/		regs.R11 = regs.R23;
		/* 821689E4h case    0:*/		return 0x821689E8;
	}
	return 0x821689E8;
} // Block from 821689E4h-821689E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821689E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821689E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821689E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821689E8);
		  /* 821689E8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821689E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821689E8h case    0:*/		return 0x821689EC;
		  /* 821689ECh */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 821689ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x82168A1C;  }
		/* 821689ECh case    1:*/		return 0x821689F0;
		  /* 821689F0h */ case    2:  		/* lwz R3, <#[R15 + 768]> */
		/* 821689F0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 821689F0h case    2:*/		return 0x821689F4;
		  /* 821689F4h */ case    3:  		/* bl -1029300 */
		/* 821689F4h case    3:*/		regs.LR = 0x821689F8; return 0x8206D540;
		/* 821689F4h case    3:*/		return 0x821689F8;
		  /* 821689F8h */ case    4:  		/* lwz R11, <#[R14 + 16]> */
		/* 821689F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 821689F8h case    4:*/		return 0x821689FC;
		  /* 821689FCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821689FCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821689FCh case    5:*/		return 0x82168A00;
		  /* 82168A00h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 82168A00h case    6:*/		if ( regs.CR[6].eq ) { return 0x82168A1C;  }
		/* 82168A00h case    6:*/		return 0x82168A04;
		  /* 82168A04h */ case    7:  		/* lwz R3, <#[R15 + 768]> */
		/* 82168A04h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R15 + 0x00000300) );
		/* 82168A04h case    7:*/		return 0x82168A08;
		  /* 82168A08h */ case    8:  		/* bl -1027080 */
		/* 82168A08h case    8:*/		regs.LR = 0x82168A0C; return 0x8206DE00;
		/* 82168A08h case    8:*/		return 0x82168A0C;
		  /* 82168A0Ch */ case    9:  		/* addi R11, R3, 1 */
		/* 82168A0Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 82168A0Ch case    9:*/		return 0x82168A10;
		  /* 82168A10h */ case   10:  		/* lwz R3, <#[R14 + 16]> */
		/* 82168A10h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R14 + 0x00000010) );
		/* 82168A10h case   10:*/		return 0x82168A14;
		  /* 82168A14h */ case   11:  		/* rlwinm R4, R11, 31, 1, 31 */
		/* 82168A14h case   11:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R4,regs.R11);
		/* 82168A14h case   11:*/		return 0x82168A18;
		  /* 82168A18h */ case   12:  		/* bl -140400 */
		/* 82168A18h case   12:*/		regs.LR = 0x82168A1C; return 0x821465A8;
		/* 82168A18h case   12:*/		return 0x82168A1C;
	}
	return 0x82168A1C;
} // Block from 821689E8h-82168A1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82168A1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168A1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168A1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168A1C);
		  /* 82168A1Ch */ case    0:  		/* stw R18, <#[R14 + 8]> */
		/* 82168A1Ch case    0:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R14 + 0x00000008) );
		/* 82168A1Ch case    0:*/		return 0x82168A20;
		  /* 82168A20h */ case    1:  		/* mr R3, R17 */
		/* 82168A20h case    1:*/		regs.R3 = regs.R17;
		/* 82168A20h case    1:*/		return 0x82168A24;
		  /* 82168A24h */ case    2:  		/* stw R21, <#[R14 + 12]> */
		/* 82168A24h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R14 + 0x0000000C) );
		/* 82168A24h case    2:*/		return 0x82168A28;
		  /* 82168A28h */ case    3:  		/* addi R1, R1, 448 */
		/* 82168A28h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1C0);
		/* 82168A28h case    3:*/		return 0x82168A2C;
		  /* 82168A2Ch */ case    4:  		/* b -882620 */
		/* 82168A2Ch case    4:*/		return 0x82091270;
		/* 82168A2Ch case    4:*/		return 0x82168A30;
	}
	return 0x82168A30;
} // Block from 82168A1Ch-82168A30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82168A30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168A30);
		  /* 82168A30h */ case    0:  		/* mfspr R12, LR */
		/* 82168A30h case    0:*/		regs.R12 = regs.LR;
		/* 82168A30h case    0:*/		return 0x82168A34;
		  /* 82168A34h */ case    1:  		/* bl -882708 */
		/* 82168A34h case    1:*/		regs.LR = 0x82168A38; return 0x82091220;
		/* 82168A34h case    1:*/		return 0x82168A38;
		  /* 82168A38h */ case    2:  		/* stfd FR29, <#[R1 - 176]> */
		/* 82168A38h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 82168A38h case    2:*/		return 0x82168A3C;
		  /* 82168A3Ch */ case    3:  		/* stfd FR30, <#[R1 - 168]> */
		/* 82168A3Ch case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 82168A3Ch case    3:*/		return 0x82168A40;
		  /* 82168A40h */ case    4:  		/* stfd FR31, <#[R1 - 160]> */
		/* 82168A40h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82168A40h case    4:*/		return 0x82168A44;
		  /* 82168A44h */ case    5:  		/* stwu R1, <#[R1 - 416]> */
		/* 82168A44h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE60);
		/* 82168A44h case    5:*/		return 0x82168A48;
		  /* 82168A48h */ case    6:  		/* lwz R11, <#[R3 + 48]> */
		/* 82168A48h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82168A48h case    6:*/		return 0x82168A4C;
		  /* 82168A4Ch */ case    7:  		/* lis R14, -1 */
		/* 82168A4Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R14,0xFFFFFFFF);
		/* 82168A4Ch case    7:*/		return 0x82168A50;
		  /* 82168A50h */ case    8:  		/* mr R22, R3 */
		/* 82168A50h case    8:*/		regs.R22 = regs.R3;
		/* 82168A50h case    8:*/		return 0x82168A54;
		  /* 82168A54h */ case    9:  		/* stw R4, <#[R1 + 444]> */
		/* 82168A54h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000001BC) );
		/* 82168A54h case    9:*/		return 0x82168A58;
		  /* 82168A58h */ case   10:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82168A58h case   10:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82168A58h case   10:*/		return 0x82168A5C;
		  /* 82168A5Ch */ case   11:  		/* stw R6, <#[R1 + 460]> */
		/* 82168A5Ch case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000001CC) );
		/* 82168A5Ch case   11:*/		return 0x82168A60;
		  /* 82168A60h */ case   12:  		/* mr R21, R4 */
		/* 82168A60h case   12:*/		regs.R21 = regs.R4;
		/* 82168A60h case   12:*/		return 0x82168A64;
		  /* 82168A64h */ case   13:  		/* stw R7, <#[R1 + 468]> */
		/* 82168A64h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000001D4) );
		/* 82168A64h case   13:*/		return 0x82168A68;
		  /* 82168A68h */ case   14:  		/* mr R29, R5 */
		/* 82168A68h case   14:*/		regs.R29 = regs.R5;
		/* 82168A68h case   14:*/		return 0x82168A6C;
		  /* 82168A6Ch */ case   15:  		/* li R31, 128 */
		/* 82168A6Ch case   15:*/		cpu::op::li<0>(regs,&regs.R31,0x80);
		/* 82168A6Ch case   15:*/		return 0x82168A70;
		  /* 82168A70h */ case   16:  		/* cmplw CR6, R11, R14 */
		/* 82168A70h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 82168A70h case   16:*/		return 0x82168A74;
		  /* 82168A74h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 82168A74h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82168A7C;  }
		/* 82168A74h case   17:*/		return 0x82168A78;
		  /* 82168A78h */ case   18:  		/* li R31, 132 */
		/* 82168A78h case   18:*/		cpu::op::li<0>(regs,&regs.R31,0x84);
		/* 82168A78h case   18:*/		return 0x82168A7C;
	}
	return 0x82168A7C;
} // Block from 82168A30h-82168A7Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82168A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168A7C);
		  /* 82168A7Ch */ case    0:  		/* lwz R11, <#[R22 + 44]> */
		/* 82168A7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000002C) );
		/* 82168A7Ch case    0:*/		return 0x82168A80;
		  /* 82168A80h */ case    1:  		/* li R19, 0 */
		/* 82168A80h case    1:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82168A80h case    1:*/		return 0x82168A84;
		  /* 82168A84h */ case    2:  		/* li R30, 1 */
		/* 82168A84h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82168A84h case    2:*/		return 0x82168A88;
		  /* 82168A88h */ case    3:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 82168A88h case    3:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 82168A88h case    3:*/		return 0x82168A8C;
		  /* 82168A8Ch */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82168A8Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82168A9C;  }
		/* 82168A8Ch case    4:*/		return 0x82168A90;
		  /* 82168A90h */ case    5:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82168A90h case    5:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82168A90h case    5:*/		return 0x82168A94;
		  /* 82168A94h */ case    6:  		/* mr R11, R30 */
		/* 82168A94h case    6:*/		regs.R11 = regs.R30;
		/* 82168A94h case    6:*/		return 0x82168A98;
		  /* 82168A98h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 82168A98h case    7:*/		if ( regs.CR[0].eq ) { return 0x82168AA0;  }
		/* 82168A98h case    7:*/		return 0x82168A9C;
	}
	return 0x82168A9C;
} // Block from 82168A7Ch-82168A9Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82168A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168A9C);
		  /* 82168A9Ch */ case    0:  		/* mr R11, R19 */
		/* 82168A9Ch case    0:*/		regs.R11 = regs.R19;
		/* 82168A9Ch case    0:*/		return 0x82168AA0;
	}
	return 0x82168AA0;
} // Block from 82168A9Ch-82168AA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82168AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168AA0);
		  /* 82168AA0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82168AA0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82168AA0h case    0:*/		return 0x82168AA4;
		  /* 82168AA4h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82168AA4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82168AAC;  }
		/* 82168AA4h case    1:*/		return 0x82168AA8;
		  /* 82168AA8h */ case    2:  		/* ori R31, R31, 64 */
		/* 82168AA8h case    2:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x40);
		/* 82168AA8h case    2:*/		return 0x82168AAC;
	}
	return 0x82168AAC;
} // Block from 82168AA0h-82168AACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82168AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168AAC);
		  /* 82168AACh */ case    0:  		/* bl -1032556 */
		/* 82168AACh case    0:*/		regs.LR = 0x82168AB0; return 0x8206C940;
		/* 82168AACh case    0:*/		return 0x82168AB0;
		  /* 82168AB0h */ case    1:  		/* stw R3, <#[R22 + 768]> */
		/* 82168AB0h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 82168AB0h case    1:*/		return 0x82168AB4;
		  /* 82168AB4h */ case    2:  		/* mr R4, R31 */
		/* 82168AB4h case    2:*/		regs.R4 = regs.R31;
		/* 82168AB4h case    2:*/		return 0x82168AB8;
		  /* 82168AB8h */ case    3:  		/* bl -1027760 */
		/* 82168AB8h case    3:*/		regs.LR = 0x82168ABC; return 0x8206DC08;
		/* 82168AB8h case    3:*/		return 0x82168ABC;
		  /* 82168ABCh */ case    4:  		/* lwz R3, <#[R22 + 56]> */
		/* 82168ABCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000038) );
		/* 82168ABCh case    4:*/		return 0x82168AC0;
		  /* 82168AC0h */ case    5:  		/* mr R20, R19 */
		/* 82168AC0h case    5:*/		regs.R20 = regs.R19;
		/* 82168AC0h case    5:*/		return 0x82168AC4;
		  /* 82168AC4h */ case    6:  		/* stw R19, <#[R1 + 92]> */
		/* 82168AC4h case    6:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x0000005C) );
		/* 82168AC4h case    6:*/		return 0x82168AC8;
		  /* 82168AC8h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 82168AC8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82168AC8h case    7:*/		return 0x82168ACC;
		  /* 82168ACCh */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 82168ACCh case    8:*/		if ( regs.CR[6].eq ) { return 0x82168AE4;  }
		/* 82168ACCh case    8:*/		return 0x82168AD0;
		  /* 82168AD0h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 82168AD0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82168AD0h case    9:*/		return 0x82168AD4;
		  /* 82168AD4h */ case   10:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82168AD4h case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82168AD4h case   10:*/		return 0x82168AD8;
		  /* 82168AD8h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82168AD8h case   11:*/		if ( regs.CR[0].eq ) { return 0x82168AE4;  }
		/* 82168AD8h case   11:*/		return 0x82168ADC;
		  /* 82168ADCh */ case   12:  		/* lwz R20, <#[R3 + 20]> */
		/* 82168ADCh case   12:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R3 + 0x00000014) );
		/* 82168ADCh case   12:*/		return 0x82168AE0;
		  /* 82168AE0h */ case   13:  		/* stw R20, <#[R1 + 92]> */
		/* 82168AE0h case   13:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x0000005C) );
		/* 82168AE0h case   13:*/		return 0x82168AE4;
	}
	return 0x82168AE4;
} // Block from 82168AACh-82168AE4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82168AE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168AE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168AE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168AE4);
		  /* 82168AE4h */ case    0:  		/* lwz R11, <#[R22 + 48]> */
		/* 82168AE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000030) );
		/* 82168AE4h case    0:*/		return 0x82168AE8;
		  /* 82168AE8h */ case    1:  		/* mr R10, R19 */
		/* 82168AE8h case    1:*/		regs.R10 = regs.R19;
		/* 82168AE8h case    1:*/		return 0x82168AEC;
		  /* 82168AECh */ case    2:  		/* mr R6, R19 */
		/* 82168AECh case    2:*/		regs.R6 = regs.R19;
		/* 82168AECh case    2:*/		return 0x82168AF0;
		  /* 82168AF0h */ case    3:  		/* stw R19, <#[R1 + 80]> */
		/* 82168AF0h case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 82168AF0h case    3:*/		return 0x82168AF4;
		  /* 82168AF4h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82168AF4h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82168AF4h case    4:*/		return 0x82168AF8;
		  /* 82168AF8h */ case    5:  		/* stw R19, <#[R1 + 88]> */
		/* 82168AF8h case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000058) );
		/* 82168AF8h case    5:*/		return 0x82168AFC;
		  /* 82168AFCh */ case    6:  		/* cmplw CR6, R11, R14 */
		/* 82168AFCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 82168AFCh case    6:*/		return 0x82168B00;
		  /* 82168B00h */ case    7:  		/* bc 12, CR6_EQ, 408 */
		/* 82168B00h case    7:*/		if ( regs.CR[6].eq ) { return 0x82168C98;  }
		/* 82168B00h case    7:*/		return 0x82168B04;
		  /* 82168B04h */ case    8:  		/* lwz R11, <#[R22 + 336]> */
		/* 82168B04h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000150) );
		/* 82168B04h case    8:*/		return 0x82168B08;
		  /* 82168B08h */ case    9:  		/* mr R5, R19 */
		/* 82168B08h case    9:*/		regs.R5 = regs.R19;
		/* 82168B08h case    9:*/		return 0x82168B0C;
		  /* 82168B0Ch */ case   10:  		/* mr R7, R19 */
		/* 82168B0Ch case   10:*/		regs.R7 = regs.R19;
		/* 82168B0Ch case   10:*/		return 0x82168B10;
		  /* 82168B10h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82168B10h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168B10h case   11:*/		return 0x82168B14;
		  /* 82168B14h */ case   12:  		/* bc 4, CR6_GT, 96 */
		/* 82168B14h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82168B74;  }
		/* 82168B14h case   12:*/		return 0x82168B18;
		  /* 82168B18h */ case   13:  		/* rlwinm R4, R11, 0, 0, 31 */
		/* 82168B18h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R4,regs.R11);
		/* 82168B18h case   13:*/		return 0x82168B1C;
		  /* 82168B1Ch */ case   14:  		/* addi R9, R22, 128 */
		/* 82168B1Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R22,0x80);
		/* 82168B1Ch case   14:*/		return 0x82168B20;
		  /* 82168B20h */ case   15:  		/* lwz R8, <#[R9]> */
		/* 82168B20h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82168B20h case   15:*/		return 0x82168B24;
		  /* 82168B24h */ case   16:  		/* rlwinm R11, R8, 28, 4, 31 */
		/* 82168B24h case   16:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R8);
		/* 82168B24h case   16:*/		return 0x82168B28;
		  /* 82168B28h */ case   17:  		/* cmplwi CR6, R11, 15 */
		/* 82168B28h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82168B28h case   17:*/		return 0x82168B2C;
		  /* 82168B2Ch */ case   18:  		/* bc 12, CR6_GT, 20 */
		/* 82168B2Ch case   18:*/		if ( regs.CR[6].gt ) { return 0x82168B40;  }
		/* 82168B2Ch case   18:*/		return 0x82168B30;
		  /* 82168B30h */ case   19:  		/* rlwinm R31, R10, 12, 28, 31 */
		/* 82168B30h case   19:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R31,regs.R10);
		/* 82168B30h case   19:*/		return 0x82168B34;
		  /* 82168B34h */ case   20:  		/* cmplw CR6, R11, R31 */
		/* 82168B34h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82168B34h case   20:*/		return 0x82168B38;
		  /* 82168B38h */ case   21:  		/* bc 4, CR6_GT, 8 */
		/* 82168B38h case   21:*/		if ( !regs.CR[6].gt ) { return 0x82168B40;  }
		/* 82168B38h case   21:*/		return 0x82168B3C;
		  /* 82168B3Ch */ case   22:  		/* rlwimi R10, R11, 20, 8, 11 */
		/* 82168B3Ch case   22:*/		cpu::op::rlwimi<0,20,8,11>(regs,&regs.R10,regs.R11);
		/* 82168B3Ch case   22:*/		return 0x82168B40;
	}
	return 0x82168B40;
} // Block from 82168AE4h-82168B40h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82168B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168B40);
		  /* 82168B40h */ case    0:  		/* cmplwi CR6, R11, 62 */
		/* 82168B40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003E);
		/* 82168B40h case    0:*/		return 0x82168B44;
		  /* 82168B44h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82168B44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82168B50;  }
		/* 82168B44h case    1:*/		return 0x82168B48;
		  /* 82168B48h */ case    2:  		/* mr R5, R30 */
		/* 82168B48h case    2:*/		regs.R5 = regs.R30;
		/* 82168B48h case    2:*/		return 0x82168B4C;
		  /* 82168B4Ch */ case    3:  		/* b 20 */
		/* 82168B4Ch case    3:*/		return 0x82168B60;
		/* 82168B4Ch case    3:*/		return 0x82168B50;
	}
	return 0x82168B50;
} // Block from 82168B40h-82168B50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82168B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168B50);
		  /* 82168B50h */ case    0:  		/* cmplwi CR6, R11, 63 */
		/* 82168B50h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003F);
		/* 82168B50h case    0:*/		return 0x82168B54;
		  /* 82168B54h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82168B54h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82168B60;  }
		/* 82168B54h case    1:*/		return 0x82168B58;
		  /* 82168B58h */ case    2:  		/* rlwinm R11, R8, 0, 28, 31 */
		/* 82168B58h case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R8);
		/* 82168B58h case    2:*/		return 0x82168B5C;
		  /* 82168B5Ch */ case    3:  		/* or R6, R11, R6 */
		/* 82168B5Ch case    3:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 82168B5Ch case    3:*/		return 0x82168B60;
	}
	return 0x82168B60;
} // Block from 82168B50h-82168B60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82168B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168B60);
		  /* 82168B60h */ case    0:  		/* addi R7, R7, 1 */
		/* 82168B60h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82168B60h case    0:*/		return 0x82168B64;
		  /* 82168B64h */ case    1:  		/* addi R9, R9, 12 */
		/* 82168B64h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xC);
		/* 82168B64h case    1:*/		return 0x82168B68;
		  /* 82168B68h */ case    2:  		/* cmplw CR6, R7, R4 */
		/* 82168B68h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 82168B68h case    2:*/		return 0x82168B6C;
		  /* 82168B6Ch */ case    3:  		/* bc 12, CR6_LT, -76 */
		/* 82168B6Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82168B20;  }
		/* 82168B6Ch case    3:*/		return 0x82168B70;
		  /* 82168B70h */ case    4:  		/* stw R10, <#[R1 + 80]> */
		/* 82168B70h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82168B70h case    4:*/		return 0x82168B74;
	}
	return 0x82168B74;
} // Block from 82168B60h-82168B74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82168B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168B74);
		  /* 82168B74h */ case    0:  		/* rlwinm R11, R6, 1, 0, 30 */
		/* 82168B74h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R6);
		/* 82168B74h case    0:*/		return 0x82168B78;
		  /* 82168B78h */ case    1:  		/* rlwinm R9, R5, 0, 24, 31 */
		/* 82168B78h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R5);
		/* 82168B78h case    1:*/		return 0x82168B7C;
		  /* 82168B7Ch */ case    2:  		/* or R11, R11, R9 */
		/* 82168B7Ch case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82168B7Ch case    2:*/		return 0x82168B80;
		  /* 82168B80h */ case    3:  		/* cmplwi CR6, R11, 15 */
		/* 82168B80h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82168B80h case    3:*/		return 0x82168B84;
		  /* 82168B84h */ case    4:  		/* bc 12, CR6_GT, 264 */
		/* 82168B84h case    4:*/		if ( regs.CR[6].gt ) { return 0x82168C8C;  }
		/* 82168B84h case    4:*/		return 0x82168B88;
		  /* 82168B88h */ case    5:  		/* lis R12, -32252 */
		/* 82168B88h case    5:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 82168B88h case    5:*/		return 0x82168B8C;
		  /* 82168B8Ch */ case    6:  		/* addi R12, R12, -17656 */
		/* 82168B8Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBB08);
		/* 82168B8Ch case    6:*/		return 0x82168B90;
		  /* 82168B90h */ case    7:  		/* lbzx R0, <#[R12 + R11]> */
		/* 82168B90h case    7:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 82168B90h case    7:*/		return 0x82168B94;
		  /* 82168B94h */ case    8:  		/* lis R12, -32233 */
		/* 82168B94h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8217);
		/* 82168B94h case    8:*/		return 0x82168B98;
		  /* 82168B98h */ case    9:  		/* ori R0, R0, 0 */
		/* 82168B98h case    9:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82168B98h case    9:*/		return 0x82168B9C;
		  /* 82168B9Ch */ case   10:  		/* addi R12, R12, -29776 */
		/* 82168B9Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFF8BB0);
		/* 82168B9Ch case   10:*/		return 0x82168BA0;
		  /* 82168BA0h */ case   11:  		/* ori R0, R0, 0 */
		/* 82168BA0h case   11:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82168BA0h case   11:*/		return 0x82168BA4;
		  /* 82168BA4h */ case   12:  		/* add R12, R12, R0 */
		/* 82168BA4h case   12:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82168BA4h case   12:*/		return 0x82168BA8;
		  /* 82168BA8h */ case   13:  		/* mtspr CTR, R12 */
		/* 82168BA8h case   13:*/		regs.CTR = regs.R12;
		/* 82168BA8h case   13:*/		return 0x82168BAC;
		  /* 82168BACh */ case   14:  		/* bcctr 20, CR0_LT */
		/* 82168BACh case   14:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82168BACh case   14:*/		return 0x82168BB0;
		  /* 82168BB0h */ case   15:  		/* oris R11, R10, 1792 */
		/* 82168BB0h case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x700);
		/* 82168BB0h case   15:*/		return 0x82168BB4;
		  /* 82168BB4h */ case   16:  		/* cmplwi CR6, R3, 0 */
		/* 82168BB4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82168BB4h case   16:*/		return 0x82168BB8;
		  /* 82168BB8h */ case   17:  		/* stw R11, <#[R1 + 80]> */
		/* 82168BB8h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82168BB8h case   17:*/		return 0x82168BBC;
		  /* 82168BBCh */ case   18:  		/* bc 12, CR6_EQ, 96 */
		/* 82168BBCh case   18:*/		if ( regs.CR[6].eq ) { return 0x82168C1C;  }
		/* 82168BBCh case   18:*/		return 0x82168BC0;
		  /* 82168BC0h */ case   19:  		/* stw R30, <#[R3 + 28]> */
		/* 82168BC0h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000001C) );
		/* 82168BC0h case   19:*/		return 0x82168BC4;
		  /* 82168BC4h */ case   20:  		/* b 88 */
		/* 82168BC4h case   20:*/		return 0x82168C1C;
		/* 82168BC4h case   20:*/		return 0x82168BC8;
		  /* 82168BC8h */ case   21:  		/* rlwinm R11, R10, 0, 8, 4 */
		/* 82168BC8h case   21:*/		cpu::op::rlwinm<0,0,8,4>(regs,&regs.R11,regs.R10);
		/* 82168BC8h case   21:*/		return 0x82168BCC;
		  /* 82168BCCh */ case   22:  		/* stw R11, <#[R1 + 80]> */
		/* 82168BCCh case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82168BCCh case   22:*/		return 0x82168BD0;
		  /* 82168BD0h */ case   23:  		/* b 76 */
		/* 82168BD0h case   23:*/		return 0x82168C1C;
		/* 82168BD0h case   23:*/		return 0x82168BD4;
		  /* 82168BD4h */ case   24:  		/* li R4, 3547 */
		/* 82168BD4h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0xDDB);
		/* 82168BD4h case   24:*/		return 0x82168BD8;
		  /* 82168BD8h */ case   25:  		/* mr R3, R22 */
		/* 82168BD8h case   25:*/		regs.R3 = regs.R22;
		/* 82168BD8h case   25:*/		return 0x82168BDC;
		  /* 82168BDCh */ case   26:  		/* bl -93556 */
		/* 82168BDCh case   26:*/		regs.LR = 0x82168BE0; return 0x82151E68;
		/* 82168BDCh case   26:*/		return 0x82168BE0;
		  /* 82168BE0h */ case   27:  		/* rlwimi R10, R30, 25, 5, 7 */
		/* 82168BE0h case   27:*/		cpu::op::rlwimi<0,25,5,7>(regs,&regs.R10,regs.R30);
		/* 82168BE0h case   27:*/		return 0x82168BE4;
		  /* 82168BE4h */ case   28:  		/* b 52 */
		/* 82168BE4h case   28:*/		return 0x82168C18;
		/* 82168BE4h case   28:*/		return 0x82168BE8;
		  /* 82168BE8h */ case   29:  		/* li R11, 3 */
		/* 82168BE8h case   29:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82168BE8h case   29:*/		return 0x82168BEC;
		  /* 82168BECh */ case   30:  		/* rlwimi R10, R11, 24, 5, 7 */
		/* 82168BECh case   30:*/		cpu::op::rlwimi<0,24,5,7>(regs,&regs.R10,regs.R11);
		/* 82168BECh case   30:*/		return 0x82168BF0;
		  /* 82168BF0h */ case   31:  		/* b 40 */
		/* 82168BF0h case   31:*/		return 0x82168C18;
		/* 82168BF0h case   31:*/		return 0x82168BF4;
		  /* 82168BF4h */ case   32:  		/* li R4, 3635 */
		/* 82168BF4h case   32:*/		cpu::op::li<0>(regs,&regs.R4,0xE33);
		/* 82168BF4h case   32:*/		return 0x82168BF8;
		  /* 82168BF8h */ case   33:  		/* mr R3, R22 */
		/* 82168BF8h case   33:*/		regs.R3 = regs.R22;
		/* 82168BF8h case   33:*/		return 0x82168BFC;
		  /* 82168BFCh */ case   34:  		/* bl -93588 */
		/* 82168BFCh case   34:*/		regs.LR = 0x82168C00; return 0x82151E68;
		/* 82168BFCh case   34:*/		return 0x82168C00;
		  /* 82168C00h */ case   35:  		/* rlwimi R10, R30, 26, 5, 7 */
		/* 82168C00h case   35:*/		cpu::op::rlwimi<0,26,5,7>(regs,&regs.R10,regs.R30);
		/* 82168C00h case   35:*/		return 0x82168C04;
		  /* 82168C04h */ case   36:  		/* b 20 */
		/* 82168C04h case   36:*/		return 0x82168C18;
		/* 82168C04h case   36:*/		return 0x82168C08;
		  /* 82168C08h */ case   37:  		/* li R11, 5 */
		/* 82168C08h case   37:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 82168C08h case   37:*/		return 0x82168C0C;
		  /* 82168C0Ch */ case   38:  		/* b -32 */
		/* 82168C0Ch case   38:*/		return 0x82168BEC;
		/* 82168C0Ch case   38:*/		return 0x82168C10;
		  /* 82168C10h */ case   39:  		/* li R11, 3 */
		/* 82168C10h case   39:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82168C10h case   39:*/		return 0x82168C14;
		  /* 82168C14h */ case   40:  		/* rlwimi R10, R11, 25, 5, 7 */
		/* 82168C14h case   40:*/		cpu::op::rlwimi<0,25,5,7>(regs,&regs.R10,regs.R11);
		/* 82168C14h case   40:*/		return 0x82168C18;
	}
	return 0x82168C18;
} // Block from 82168B74h-82168C18h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82168C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168C18);
		  /* 82168C18h */ case    0:  		/* stw R10, <#[R1 + 80]> */
		/* 82168C18h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82168C18h case    0:*/		return 0x82168C1C;
	}
	return 0x82168C1C;
} // Block from 82168C18h-82168C1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82168C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168C1C);
		  /* 82168C1Ch */ case    0:  		/* lwz R11, <#[R22 + 536]> */
		/* 82168C1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000218) );
		/* 82168C1Ch case    0:*/		return 0x82168C20;
		  /* 82168C20h */ case    1:  		/* mr R10, R19 */
		/* 82168C20h case    1:*/		regs.R10 = regs.R19;
		/* 82168C20h case    1:*/		return 0x82168C24;
		  /* 82168C24h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82168C24h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168C24h case    2:*/		return 0x82168C28;
		  /* 82168C28h */ case    3:  		/* bc 4, CR6_GT, 56 */
		/* 82168C28h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82168C60;  }
		/* 82168C28h case    3:*/		return 0x82168C2C;
		  /* 82168C2Ch */ case    4:  		/* rlwinm R9, R11, 0, 0, 31 */
		/* 82168C2Ch case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R11);
		/* 82168C2Ch case    4:*/		return 0x82168C30;
		  /* 82168C30h */ case    5:  		/* addi R11, R22, 348 */
		/* 82168C30h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x15C);
		/* 82168C30h case    5:*/		return 0x82168C34;
		  /* 82168C34h */ case    6:  		/* lwz R8, <#[R11]> */
		/* 82168C34h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82168C34h case    6:*/		return 0x82168C38;
		  /* 82168C38h */ case    7:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 82168C38h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 82168C38h case    7:*/		return 0x82168C3C;
		  /* 82168C3Ch */ case    8:  		/* cmplwi CR6, R8, 18 */
		/* 82168C3Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000012);
		/* 82168C3Ch case    8:*/		return 0x82168C40;
		  /* 82168C40h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82168C40h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82168C50;  }
		/* 82168C40h case    9:*/		return 0x82168C44;
		  /* 82168C44h */ case   10:  		/* lwz R8, <#[R1 + 80]> */
		/* 82168C44h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82168C44h case   10:*/		return 0x82168C48;
		  /* 82168C48h */ case   11:  		/* oris R8, R8, 32768 */
		/* 82168C48h case   11:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x8000);
		/* 82168C48h case   11:*/		return 0x82168C4C;
		  /* 82168C4Ch */ case   12:  		/* stw R8, <#[R1 + 80]> */
		/* 82168C4Ch case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82168C4Ch case   12:*/		return 0x82168C50;
	}
	return 0x82168C50;
} // Block from 82168C1Ch-82168C50h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82168C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168C50);
		  /* 82168C50h */ case    0:  		/* addi R10, R10, 1 */
		/* 82168C50h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82168C50h case    0:*/		return 0x82168C54;
		  /* 82168C54h */ case    1:  		/* addi R11, R11, 12 */
		/* 82168C54h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82168C54h case    1:*/		return 0x82168C58;
		  /* 82168C58h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 82168C58h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82168C58h case    2:*/		return 0x82168C5C;
		  /* 82168C5Ch */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 82168C5Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82168C34;  }
		/* 82168C5Ch case    3:*/		return 0x82168C60;
	}
	return 0x82168C60;
} // Block from 82168C50h-82168C60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82168C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168C60);
		  /* 82168C60h */ case    0:  		/* addi R4, R22, 972 */
		/* 82168C60h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R22,0x3CC);
		/* 82168C60h case    0:*/		return 0x82168C64;
		  /* 82168C64h */ case    1:  		/* li R3, 16 */
		/* 82168C64h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 82168C64h case    1:*/		return 0x82168C68;
		  /* 82168C68h */ case    2:  		/* bl -17376 */
		/* 82168C68h case    2:*/		regs.LR = 0x82168C6C; return 0x82164888;
		/* 82168C68h case    2:*/		return 0x82168C6C;
		  /* 82168C6Ch */ case    3:  		/* or. R31, R3, R3 */
		/* 82168C6Ch case    3:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82168C6Ch case    3:*/		return 0x82168C70;
		  /* 82168C70h */ case    4:  		/* bc 12, CR0_EQ, 472 */
		/* 82168C70h case    4:*/		if ( regs.CR[0].eq ) { return 0x82168E48;  }
		/* 82168C70h case    4:*/		return 0x82168C74;
		  /* 82168C74h */ case    5:  		/* lis R4, 16961 */
		/* 82168C74h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x4241);
		/* 82168C74h case    5:*/		return 0x82168C78;
		  /* 82168C78h */ case    6:  		/* mr R3, R31 */
		/* 82168C78h case    6:*/		regs.R3 = regs.R31;
		/* 82168C78h case    6:*/		return 0x82168C7C;
		  /* 82168C7Ch */ case    7:  		/* ori R4, R4, 21571 */
		/* 82168C7Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x5443);
		/* 82168C7Ch case    7:*/		return 0x82168C80;
		  /* 82168C80h */ case    8:  		/* bl -633536 */
		/* 82168C80h case    8:*/		regs.LR = 0x82168C84; return 0x820CE1C0;
		/* 82168C80h case    8:*/		return 0x82168C84;
		  /* 82168C84h */ case    9:  		/* mr R3, R31 */
		/* 82168C84h case    9:*/		regs.R3 = regs.R31;
		/* 82168C84h case    9:*/		return 0x82168C88;
		  /* 82168C88h */ case   10:  		/* b 452 */
		/* 82168C88h case   10:*/		return 0x82168E4C;
		/* 82168C88h case   10:*/		return 0x82168C8C;
	}
	return 0x82168C8C;
} // Block from 82168C60h-82168C8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82168C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168C8C);
		  /* 82168C8Ch */ case    0:  		/* li R4, 4800 */
		/* 82168C8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 82168C8Ch case    0:*/		return 0x82168C90;
		  /* 82168C90h */ case    1:  		/* mr R3, R22 */
		/* 82168C90h case    1:*/		regs.R3 = regs.R22;
		/* 82168C90h case    1:*/		return 0x82168C94;
		  /* 82168C94h */ case    2:  		/* bl -93740 */
		/* 82168C94h case    2:*/		regs.LR = 0x82168C98; return 0x82151E68;
		/* 82168C94h case    2:*/		return 0x82168C98;
	}
	return 0x82168C98;
} // Block from 82168C8Ch-82168C98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82168C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168C98);
		  /* 82168C98h */ case    0:  		/* lwz R11, <#[R22 + 536]> */
		/* 82168C98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000218) );
		/* 82168C98h case    0:*/		return 0x82168C9C;
		  /* 82168C9Ch */ case    1:  		/* mr R30, R19 */
		/* 82168C9Ch case    1:*/		regs.R30 = regs.R19;
		/* 82168C9Ch case    1:*/		return 0x82168CA0;
		  /* 82168CA0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82168CA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168CA0h case    2:*/		return 0x82168CA4;
		  /* 82168CA4h */ case    3:  		/* bc 4, CR6_GT, -68 */
		/* 82168CA4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82168C60;  }
		/* 82168CA4h case    3:*/		return 0x82168CA8;
		  /* 82168CA8h */ case    4:  		/* addi R31, R22, 348 */
		/* 82168CA8h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R22,0x15C);
		/* 82168CA8h case    4:*/		return 0x82168CAC;
		  /* 82168CACh */ case    5:  		/* lwz R8, <#[R31 + 4]> */
		/* 82168CACh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82168CACh case    5:*/		return 0x82168CB0;
		  /* 82168CB0h */ case    6:  		/* lwz R11, <#[R8 + 8]> */
		/* 82168CB0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 82168CB0h case    6:*/		return 0x82168CB4;
		  /* 82168CB4h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82168CB4h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82168CB4h case    7:*/		return 0x82168CB8;
		  /* 82168CB8h */ case    8:  		/* cmplwi CR6, R11, 14720 */
		/* 82168CB8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003980);
		/* 82168CB8h case    8:*/		return 0x82168CBC;
		  /* 82168CBCh */ case    9:  		/* bc 12, CR6_EQ, 372 */
		/* 82168CBCh case    9:*/		if ( regs.CR[6].eq ) { return 0x82168E30;  }
		/* 82168CBCh case    9:*/		return 0x82168CC0;
		  /* 82168CC0h */ case   10:  		/* lwz R9, <#[R8 + 4]> */
		/* 82168CC0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000004) );
		/* 82168CC0h case   10:*/		return 0x82168CC4;
		  /* 82168CC4h */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 82168CC4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82168CC4h case   11:*/		return 0x82168CC8;
		  /* 82168CC8h */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 82168CC8h case   12:*/		if ( regs.CR[6].eq ) { return 0x82168CFC;  }
		/* 82168CC8h case   12:*/		return 0x82168CCC;
		  /* 82168CCCh */ case   13:  		/* lwz R11, <#[R9 + 16]> */
		/* 82168CCCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 82168CCCh case   13:*/		return 0x82168CD0;
		  /* 82168CD0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82168CD0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168CD0h case   14:*/		return 0x82168CD4;
		  /* 82168CD4h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82168CD4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82168CF4;  }
		/* 82168CD4h case   15:*/		return 0x82168CD8;
		  /* 82168CD8h */ case   16:  		/* lwz R7, <#[R9]> */
		/* 82168CD8h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82168CD8h case   16:*/		return 0x82168CDC;
		  /* 82168CDCh */ case   17:  		/* rlwinm. R7, R7, 0, 4, 6 */
		/* 82168CDCh case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R7,regs.R7);
		/* 82168CDCh case   17:*/		return 0x82168CE0;
		  /* 82168CE0h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 82168CE0h case   18:*/		if ( regs.CR[0].eq ) { return 0x82168CF4;  }
		/* 82168CE0h case   18:*/		return 0x82168CE4;
		  /* 82168CE4h */ case   19:  		/* lwz R11, <#[R11 + 8]> */
		/* 82168CE4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82168CE4h case   19:*/		return 0x82168CE8;
		  /* 82168CE8h */ case   20:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82168CE8h case   20:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82168CE8h case   20:*/		return 0x82168CEC;
		  /* 82168CECh */ case   21:  		/* cmplwi CR6, R11, 14976 */
		/* 82168CECh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 82168CECh case   21:*/		return 0x82168CF0;
		  /* 82168CF0h */ case   22:  		/* bc 4, CR6_EQ, 12 */
		/* 82168CF0h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82168CFC;  }
		/* 82168CF0h case   22:*/		return 0x82168CF4;
	}
	return 0x82168CF4;
} // Block from 82168C98h-82168CF4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82168CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168CF4);
		  /* 82168CF4h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 82168CF4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82168CF4h case    0:*/		return 0x82168CF8;
		  /* 82168CF8h */ case    1:  		/* b -52 */
		/* 82168CF8h case    1:*/		return 0x82168CC4;
		/* 82168CF8h case    1:*/		return 0x82168CFC;
	}
	return 0x82168CFC;
} // Block from 82168CF4h-82168CFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168CFC);
		  /* 82168CFCh */ case    0:  		/* lwz R7, <#[R31]> */
		/* 82168CFCh case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 82168CFCh case    0:*/		return 0x82168D00;
		  /* 82168D00h */ case    1:  		/* rlwinm. R11, R7, 0, 27, 31 */
		/* 82168D00h case    1:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R7);
		/* 82168D00h case    1:*/		return 0x82168D04;
		  /* 82168D04h */ case    2:  		/* bc 12, CR0_EQ, 232 */
		/* 82168D04h case    2:*/		if ( regs.CR[0].eq ) { return 0x82168DEC;  }
		/* 82168D04h case    2:*/		return 0x82168D08;
		  /* 82168D08h */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 82168D08h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82168D08h case    3:*/		return 0x82168D0C;
		  /* 82168D0Ch */ case    4:  		/* bc 12, CR6_EQ, 196 */
		/* 82168D0Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82168DD0;  }
		/* 82168D0Ch case    4:*/		return 0x82168D10;
		  /* 82168D10h */ case    5:  		/* cmplwi CR6, R11, 17 */
		/* 82168D10h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 82168D10h case    5:*/		return 0x82168D14;
		  /* 82168D14h */ case    6:  		/* bc 12, CR6_EQ, 96 */
		/* 82168D14h case    6:*/		if ( regs.CR[6].eq ) { return 0x82168D74;  }
		/* 82168D14h case    6:*/		return 0x82168D18;
		  /* 82168D18h */ case    7:  		/* cmplwi CR6, R11, 18 */
		/* 82168D18h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 82168D18h case    7:*/		return 0x82168D1C;
		  /* 82168D1Ch */ case    8:  		/* bc 4, CR6_EQ, 236 */
		/* 82168D1Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82168E08;  }
		/* 82168D1Ch case    8:*/		return 0x82168D20;
		  /* 82168D20h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 82168D20h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82168D20h case    9:*/		return 0x82168D24;
		  /* 82168D24h */ case   10:  		/* bc 12, CR6_EQ, 268 */
		/* 82168D24h case   10:*/		if ( regs.CR[6].eq ) { return 0x82168E30;  }
		/* 82168D24h case   10:*/		return 0x82168D28;
		  /* 82168D28h */ case   11:  		/* oris R10, R10, 4 */
		/* 82168D28h case   11:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82168D28h case   11:*/		return 0x82168D2C;
		  /* 82168D2Ch */ case   12:  		/* stw R10, <#[R1 + 80]> */
		/* 82168D2Ch case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82168D2Ch case   12:*/		return 0x82168D30;
		  /* 82168D30h */ case   13:  		/* lwz R11, <#[R8 + 4]> */
		/* 82168D30h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82168D30h case   13:*/		return 0x82168D34;
		  /* 82168D34h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82168D34h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168D34h case   14:*/		return 0x82168D38;
		  /* 82168D38h */ case   15:  		/* bc 12, CR6_EQ, 24 */
		/* 82168D38h case   15:*/		if ( regs.CR[6].eq ) { return 0x82168D50;  }
		/* 82168D38h case   15:*/		return 0x82168D3C;
		  /* 82168D3Ch */ case   16:  		/* lwz R9, <#[R11]> */
		/* 82168D3Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82168D3Ch case   16:*/		return 0x82168D40;
		  /* 82168D40h */ case   17:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82168D40h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82168D40h case   17:*/		return 0x82168D44;
		  /* 82168D44h */ case   18:  		/* bc 4, CR0_EQ, 12 */
		/* 82168D44h case   18:*/		if ( !regs.CR[0].eq ) { return 0x82168D50;  }
		/* 82168D44h case   18:*/		return 0x82168D48;
		  /* 82168D48h */ case   19:  		/* lwz R11, <#[R11 + 8]> */
		/* 82168D48h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82168D48h case   19:*/		return 0x82168D4C;
		  /* 82168D4Ch */ case   20:  		/* b -24 */
		/* 82168D4Ch case   20:*/		return 0x82168D34;
		/* 82168D4Ch case   20:*/		return 0x82168D50;
	}
	return 0x82168D50;
} // Block from 82168CFCh-82168D50h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82168D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168D50);
		  /* 82168D50h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82168D50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82168D50h case    0:*/		return 0x82168D54;
		  /* 82168D54h */ case    1:  		/* oris R10, R10, 8 */
		/* 82168D54h case    1:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82168D54h case    1:*/		return 0x82168D58;
		  /* 82168D58h */ case    2:  		/* lwz R9, <#[R8 + 8]> */
		/* 82168D58h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 82168D58h case    2:*/		return 0x82168D5C;
		  /* 82168D5Ch */ case    3:  		/* stw R10, <#[R1 + 80]> */
		/* 82168D5Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82168D5Ch case    3:*/		return 0x82168D60;
		  /* 82168D60h */ case    4:  		/* rlwimi R9, R11, 20, 19, 26 */
		/* 82168D60h case    4:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R9,regs.R11);
		/* 82168D60h case    4:*/		return 0x82168D64;
		  /* 82168D64h */ case    5:  		/* rlwinm R11, R9, 27, 24, 31 */
		/* 82168D64h case    5:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R9);
		/* 82168D64h case    5:*/		return 0x82168D68;
		  /* 82168D68h */ case    6:  		/* addi R11, R11, -1 */
		/* 82168D68h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82168D68h case    6:*/		return 0x82168D6C;
		  /* 82168D6Ch */ case    7:  		/* rlwimi R6, R11, 8, 16, 23 */
		/* 82168D6Ch case    7:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R6,regs.R11);
		/* 82168D6Ch case    7:*/		return 0x82168D70;
		  /* 82168D70h */ case    8:  		/* b 88 */
		/* 82168D70h case    8:*/		return 0x82168DC8;
		/* 82168D70h case    8:*/		return 0x82168D74;
	}
	return 0x82168D74;
} // Block from 82168D50h-82168D74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82168D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168D74);
		  /* 82168D74h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82168D74h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82168D74h case    0:*/		return 0x82168D78;
		  /* 82168D78h */ case    1:  		/* bc 12, CR6_EQ, 184 */
		/* 82168D78h case    1:*/		if ( regs.CR[6].eq ) { return 0x82168E30;  }
		/* 82168D78h case    1:*/		return 0x82168D7C;
		  /* 82168D7Ch */ case    2:  		/* oris R10, R10, 4 */
		/* 82168D7Ch case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82168D7Ch case    2:*/		return 0x82168D80;
		  /* 82168D80h */ case    3:  		/* stw R10, <#[R1 + 80]> */
		/* 82168D80h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82168D80h case    3:*/		return 0x82168D84;
		  /* 82168D84h */ case    4:  		/* lwz R11, <#[R8 + 4]> */
		/* 82168D84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82168D84h case    4:*/		return 0x82168D88;
		  /* 82168D88h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82168D88h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82168D88h case    5:*/		return 0x82168D8C;
		  /* 82168D8Ch */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82168D8Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82168DA4;  }
		/* 82168D8Ch case    6:*/		return 0x82168D90;
		  /* 82168D90h */ case    7:  		/* lwz R9, <#[R11]> */
		/* 82168D90h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82168D90h case    7:*/		return 0x82168D94;
		  /* 82168D94h */ case    8:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82168D94h case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82168D94h case    8:*/		return 0x82168D98;
		  /* 82168D98h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 82168D98h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82168DA4;  }
		/* 82168D98h case    9:*/		return 0x82168D9C;
		  /* 82168D9Ch */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 82168D9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82168D9Ch case   10:*/		return 0x82168DA0;
		  /* 82168DA0h */ case   11:  		/* b -24 */
		/* 82168DA0h case   11:*/		return 0x82168D88;
		/* 82168DA0h case   11:*/		return 0x82168DA4;
	}
	return 0x82168DA4;
} // Block from 82168D74h-82168DA4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82168DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168DA4);
		  /* 82168DA4h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82168DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82168DA4h case    0:*/		return 0x82168DA8;
		  /* 82168DA8h */ case    1:  		/* rlwinm R9, R7, 17, 30, 30 */
		/* 82168DA8h case    1:*/		cpu::op::rlwinm<0,17,30,30>(regs,&regs.R9,regs.R7);
		/* 82168DA8h case    1:*/		return 0x82168DAC;
		  /* 82168DACh */ case    2:  		/* lwz R8, <#[R8 + 8]> */
		/* 82168DACh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82168DACh case    2:*/		return 0x82168DB0;
		  /* 82168DB0h */ case    3:  		/* rlwinm R7, R6, 0, 31, 29 */
		/* 82168DB0h case    3:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R7,regs.R6);
		/* 82168DB0h case    3:*/		return 0x82168DB4;
		  /* 82168DB4h */ case    4:  		/* rlwimi R8, R11, 20, 19, 26 */
		/* 82168DB4h case    4:*/		cpu::op::rlwimi<0,20,19,26>(regs,&regs.R8,regs.R11);
		/* 82168DB4h case    4:*/		return 0x82168DB8;
		  /* 82168DB8h */ case    5:  		/* rlwinm R7, R7, 0, 24, 15 */
		/* 82168DB8h case    5:*/		cpu::op::rlwinm<0,0,24,15>(regs,&regs.R7,regs.R7);
		/* 82168DB8h case    5:*/		return 0x82168DBC;
		  /* 82168DBCh */ case    6:  		/* rlwinm R11, R8, 3, 16, 23 */
		/* 82168DBCh case    6:*/		cpu::op::rlwinm<0,3,16,23>(regs,&regs.R11,regs.R8);
		/* 82168DBCh case    6:*/		return 0x82168DC0;
		  /* 82168DC0h */ case    7:  		/* or R11, R9, R11 */
		/* 82168DC0h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82168DC0h case    7:*/		return 0x82168DC4;
		  /* 82168DC4h */ case    8:  		/* or R6, R11, R7 */
		/* 82168DC4h case    8:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R7);
		/* 82168DC4h case    8:*/		return 0x82168DC8;
	}
	return 0x82168DC8;
} // Block from 82168DA4h-82168DC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82168DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168DC8);
		  /* 82168DC8h */ case    0:  		/* stw R6, <#[R1 + 88]> */
		/* 82168DC8h case    0:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 82168DC8h case    0:*/		return 0x82168DCC;
		  /* 82168DCCh */ case    1:  		/* b 100 */
		/* 82168DCCh case    1:*/		return 0x82168E30;
		/* 82168DCCh case    1:*/		return 0x82168DD0;
	}
	return 0x82168DD0;
} // Block from 82168DC8h-82168DD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82168DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168DD0);
		  /* 82168DD0h */ case    0:  		/* rlwinm. R11, R7, 0, 23, 26 */
		/* 82168DD0h case    0:*/		cpu::op::rlwinm<1,0,23,26>(regs,&regs.R11,regs.R7);
		/* 82168DD0h case    0:*/		return 0x82168DD4;
		  /* 82168DD4h */ case    1:  		/* bc 4, CR0_EQ, 52 */
		/* 82168DD4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82168E08;  }
		/* 82168DD4h case    1:*/		return 0x82168DD8;
		  /* 82168DD8h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82168DD8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82168DD8h case    2:*/		return 0x82168DDC;
		  /* 82168DDCh */ case    3:  		/* bc 12, CR6_EQ, 84 */
		/* 82168DDCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82168E30;  }
		/* 82168DDCh case    3:*/		return 0x82168DE0;
		  /* 82168DE0h */ case    4:  		/* li R4, 3550 */
		/* 82168DE0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xDDE);
		/* 82168DE0h case    4:*/		return 0x82168DE4;
		  /* 82168DE4h */ case    5:  		/* mr R3, R22 */
		/* 82168DE4h case    5:*/		regs.R3 = regs.R22;
		/* 82168DE4h case    5:*/		return 0x82168DE8;
		  /* 82168DE8h */ case    6:  		/* bl -94080 */
		/* 82168DE8h case    6:*/		regs.LR = 0x82168DEC; return 0x82151E68;
		/* 82168DE8h case    6:*/		return 0x82168DEC;
	}
	return 0x82168DEC;
} // Block from 82168DD0h-82168DECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82168DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168DEC);
		  /* 82168DECh */ case    0:  		/* rlwinm. R11, R7, 0, 23, 26 */
		/* 82168DECh case    0:*/		cpu::op::rlwinm<1,0,23,26>(regs,&regs.R11,regs.R7);
		/* 82168DECh case    0:*/		return 0x82168DF0;
		  /* 82168DF0h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 82168DF0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82168E08;  }
		/* 82168DF0h case    1:*/		return 0x82168DF4;
		  /* 82168DF4h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82168DF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82168DF4h case    2:*/		return 0x82168DF8;
		  /* 82168DF8h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 82168DF8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82168E30;  }
		/* 82168DF8h case    3:*/		return 0x82168DFC;
		  /* 82168DFCh */ case    4:  		/* li R4, 3549 */
		/* 82168DFCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xDDD);
		/* 82168DFCh case    4:*/		return 0x82168E00;
		  /* 82168E00h */ case    5:  		/* mr R3, R22 */
		/* 82168E00h case    5:*/		regs.R3 = regs.R22;
		/* 82168E00h case    5:*/		return 0x82168E04;
		  /* 82168E04h */ case    6:  		/* bl -94108 */
		/* 82168E04h case    6:*/		regs.LR = 0x82168E08; return 0x82151E68;
		/* 82168E04h case    6:*/		return 0x82168E08;
	}
	return 0x82168E08;
} // Block from 82168DECh-82168E08h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82168E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168E08);
		  /* 82168E08h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82168E08h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82168E08h case    0:*/		return 0x82168E0C;
		  /* 82168E0Ch */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82168E0Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82168E30;  }
		/* 82168E0Ch case    1:*/		return 0x82168E10;
		  /* 82168E10h */ case    2:  		/* rlwinm. R11, R7, 0, 14, 14 */
		/* 82168E10h case    2:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R11,regs.R7);
		/* 82168E10h case    2:*/		return 0x82168E14;
		  /* 82168E14h */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 82168E14h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82168E30;  }
		/* 82168E14h case    3:*/		return 0x82168E18;
		  /* 82168E18h */ case    4:  		/* li R4, 3596 */
		/* 82168E18h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xE0C);
		/* 82168E18h case    4:*/		return 0x82168E1C;
		  /* 82168E1Ch */ case    5:  		/* lwz R5, <#[R31 - 4]> */
		/* 82168E1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82168E1Ch case    5:*/		return 0x82168E20;
		  /* 82168E20h */ case    6:  		/* mr R3, R22 */
		/* 82168E20h case    6:*/		regs.R3 = regs.R22;
		/* 82168E20h case    6:*/		return 0x82168E24;
		  /* 82168E24h */ case    7:  		/* bl -94380 */
		/* 82168E24h case    7:*/		regs.LR = 0x82168E28; return 0x82151D78;
		/* 82168E24h case    7:*/		return 0x82168E28;
		  /* 82168E28h */ case    8:  		/* lwz R10, <#[R1 + 80]> */
		/* 82168E28h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82168E28h case    8:*/		return 0x82168E2C;
		  /* 82168E2Ch */ case    9:  		/* lwz R6, <#[R1 + 88]> */
		/* 82168E2Ch case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 82168E2Ch case    9:*/		return 0x82168E30;
	}
	return 0x82168E30;
} // Block from 82168E08h-82168E30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82168E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168E30);
		  /* 82168E30h */ case    0:  		/* lwz R11, <#[R22 + 536]> */
		/* 82168E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000218) );
		/* 82168E30h case    0:*/		return 0x82168E34;
		  /* 82168E34h */ case    1:  		/* addi R30, R30, 1 */
		/* 82168E34h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82168E34h case    1:*/		return 0x82168E38;
		  /* 82168E38h */ case    2:  		/* addi R31, R31, 12 */
		/* 82168E38h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xC);
		/* 82168E38h case    2:*/		return 0x82168E3C;
		  /* 82168E3Ch */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 82168E3Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82168E3Ch case    3:*/		return 0x82168E40;
		  /* 82168E40h */ case    4:  		/* bc 12, CR6_LT, -404 */
		/* 82168E40h case    4:*/		if ( regs.CR[6].lt ) { return 0x82168CAC;  }
		/* 82168E40h case    4:*/		return 0x82168E44;
		  /* 82168E44h */ case    5:  		/* b -484 */
		/* 82168E44h case    5:*/		return 0x82168C60;
		/* 82168E44h case    5:*/		return 0x82168E48;
	}
	return 0x82168E48;
} // Block from 82168E30h-82168E48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82168E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168E48);
		  /* 82168E48h */ case    0:  		/* mr R3, R19 */
		/* 82168E48h case    0:*/		regs.R3 = regs.R19;
		/* 82168E48h case    0:*/		return 0x82168E4C;
	}
	return 0x82168E4C;
} // Block from 82168E48h-82168E4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82168E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168E4C);
		  /* 82168E4Ch */ case    0:  		/* addi R11, R1, 208 */
		/* 82168E4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 82168E4Ch case    0:*/		return 0x82168E50;
		  /* 82168E50h */ case    1:  		/* stw R3, <#[R22 + 772]> */
		/* 82168E50h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 82168E50h case    1:*/		return 0x82168E54;
		  /* 82168E54h */ case    2:  		/* li R10, 28 */
		/* 82168E54h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1C);
		/* 82168E54h case    2:*/		return 0x82168E58;
		  /* 82168E58h */ case    3:  		/* li R8, 3 */
		/* 82168E58h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 82168E58h case    3:*/		return 0x82168E5C;
		  /* 82168E5Ch */ case    4:  		/* li R7, 0 */
		/* 82168E5Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82168E5Ch case    4:*/		return 0x82168E60;
		  /* 82168E60h */ case    5:  		/* li R6, 1 */
		/* 82168E60h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82168E60h case    5:*/		return 0x82168E64;
		  /* 82168E64h */ case    6:  		/* std R19, <#[R11]> */
		/* 82168E64h case    6:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 82168E64h case    6:*/		return 0x82168E68;
		  /* 82168E68h */ case    7:  		/* li R5, 28 */
		/* 82168E68h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 82168E68h case    7:*/		return 0x82168E6C;
		  /* 82168E6Ch */ case    8:  		/* std R19, <#[R11 + 8]> */
		/* 82168E6Ch case    8:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 82168E6Ch case    8:*/		return 0x82168E70;
		  /* 82168E70h */ case    9:  		/* addi R4, R1, 208 */
		/* 82168E70h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xD0);
		/* 82168E70h case    9:*/		return 0x82168E74;
		  /* 82168E74h */ case   10:  		/* std R19, <#[R11 + 16]> */
		/* 82168E74h case   10:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000010) );
		/* 82168E74h case   10:*/		return 0x82168E78;
		  /* 82168E78h */ case   11:  		/* stw R19, <#[R11 + 24]> */
		/* 82168E78h case   11:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000018) );
		/* 82168E78h case   11:*/		return 0x82168E7C;
		  /* 82168E7Ch */ case   12:  		/* stw R10, <#[R1 + 208]> */
		/* 82168E7Ch case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000D0) );
		/* 82168E7Ch case   12:*/		return 0x82168E80;
		  /* 82168E80h */ case   13:  		/* stw R21, <#[R1 + 216]> */
		/* 82168E80h case   13:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x000000D8) );
		/* 82168E80h case   13:*/		return 0x82168E84;
		  /* 82168E84h */ case   14:  		/* stw R29, <#[R1 + 228]> */
		/* 82168E84h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x000000E4) );
		/* 82168E84h case   14:*/		return 0x82168E88;
		  /* 82168E88h */ case   15:  		/* bl -633880 */
		/* 82168E88h case   15:*/		regs.LR = 0x82168E8C; return 0x820CE270;
		/* 82168E88h case   15:*/		return 0x82168E8C;
		  /* 82168E8Ch */ case   16:  		/* or. R5, R3, R3 */
		/* 82168E8Ch case   16:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82168E8Ch case   16:*/		return 0x82168E90;
		  /* 82168E90h */ case   17:  		/* bc 4, CR0_LT, 20 */
		/* 82168E90h case   17:*/		if ( !regs.CR[0].lt ) { return 0x82168EA4;  }
		/* 82168E90h case   17:*/		return 0x82168E94;
		  /* 82168E94h */ case   18:  		/* stw R5, <#[R22 + 2480]> */
		/* 82168E94h case   18:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 82168E94h case   18:*/		return 0x82168E98;
		  /* 82168E98h */ case   19:  		/* li R4, 3525 */
		/* 82168E98h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 82168E98h case   19:*/		return 0x82168E9C;
		  /* 82168E9Ch */ case   20:  		/* mr R3, R22 */
		/* 82168E9Ch case   20:*/		regs.R3 = regs.R22;
		/* 82168E9Ch case   20:*/		return 0x82168EA0;
		  /* 82168EA0h */ case   21:  		/* bl -94264 */
		/* 82168EA0h case   21:*/		regs.LR = 0x82168EA4; return 0x82151E68;
		/* 82168EA0h case   21:*/		return 0x82168EA4;
	}
	return 0x82168EA4;
} // Block from 82168E4Ch-82168EA4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82168EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168EA4);
		  /* 82168EA4h */ case    0:  		/* lwz R31, <#[R22 + 16]> */
		/* 82168EA4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R22 + 0x00000010) );
		/* 82168EA4h case    0:*/		return 0x82168EA8;
		  /* 82168EA8h */ case    1:  		/* mr R17, R19 */
		/* 82168EA8h case    1:*/		regs.R17 = regs.R19;
		/* 82168EA8h case    1:*/		return 0x82168EAC;
		  /* 82168EACh */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82168EACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82168EACh case    2:*/		return 0x82168EB0;
		  /* 82168EB0h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 82168EB0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82168EE0;  }
		/* 82168EB0h case    3:*/		return 0x82168EB4;
		  /* 82168EB4h */ case    4:  		/* lwz R7, <#[R22 + 12]> */
		/* 82168EB4h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R22 + 0x0000000C) );
		/* 82168EB4h case    4:*/		return 0x82168EB8;
		  /* 82168EB8h */ case    5:  		/* mr R9, R19 */
		/* 82168EB8h case    5:*/		regs.R9 = regs.R19;
		/* 82168EB8h case    5:*/		return 0x82168EBC;
		  /* 82168EBCh */ case    6:  		/* mr R8, R31 */
		/* 82168EBCh case    6:*/		regs.R8 = regs.R31;
		/* 82168EBCh case    6:*/		return 0x82168EC0;
		  /* 82168EC0h */ case    7:  		/* add R3, R7, R9 */
		/* 82168EC0h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R7,regs.R9);
		/* 82168EC0h case    7:*/		return 0x82168EC4;
		  /* 82168EC4h */ case    8:  		/* bl -18716 */
		/* 82168EC4h case    8:*/		regs.LR = 0x82168EC8; return 0x821645A8;
		/* 82168EC4h case    8:*/		return 0x82168EC8;
		  /* 82168EC8h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82168EC8h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82168EC8h case    9:*/		return 0x82168ECC;
		  /* 82168ECCh */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 82168ECCh case   10:*/		if ( regs.CR[0].eq ) { return 0x82168ED4;  }
		/* 82168ECCh case   10:*/		return 0x82168ED0;
		  /* 82168ED0h */ case   11:  		/* addi R17, R17, 1 */
		/* 82168ED0h case   11:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 82168ED0h case   11:*/		return 0x82168ED4;
	}
	return 0x82168ED4;
} // Block from 82168EA4h-82168ED4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82168ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168ED4);
		  /* 82168ED4h */ case    0:  		/* addic. R8, R8, -1 */
		/* 82168ED4h case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82168ED4h case    0:*/		return 0x82168ED8;
		  /* 82168ED8h */ case    1:  		/* addi R9, R9, 40 */
		/* 82168ED8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x28);
		/* 82168ED8h case    1:*/		return 0x82168EDC;
		  /* 82168EDCh */ case    2:  		/* bc 4, CR0_EQ, -28 */
		/* 82168EDCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82168EC0;  }
		/* 82168EDCh case    2:*/		return 0x82168EE0;
	}
	return 0x82168EE0;
} // Block from 82168ED4h-82168EE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82168EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168EE0);
		  /* 82168EE0h */ case    0:  		/* lis R11, -32256 */
		/* 82168EE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82168EE0h case    0:*/		return 0x82168EE4;
		  /* 82168EE4h */ case    1:  		/* stw R17, <#[R1 + 220]> */
		/* 82168EE4h case    1:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x000000DC) );
		/* 82168EE4h case    1:*/		return 0x82168EE8;
		  /* 82168EE8h */ case    2:  		/* li R15, -1 */
		/* 82168EE8h case    2:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFFFFFF);
		/* 82168EE8h case    2:*/		return 0x82168EEC;
		  /* 82168EECh */ case    3:  		/* cmplwi CR6, R17, 0 */
		/* 82168EECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82168EECh case    3:*/		return 0x82168EF0;
		  /* 82168EF0h */ case    4:  		/* lfd FR29, <#[R11 + 1808]> */
		/* 82168EF0h case    4:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R11 + 0x00000710) );
		/* 82168EF0h case    4:*/		return 0x82168EF4;
		  /* 82168EF4h */ case    5:  		/* bc 12, CR6_EQ, 1444 */
		/* 82168EF4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82169498;  }
		/* 82168EF4h case    5:*/		return 0x82168EF8;
		  /* 82168EF8h */ case    6:  		/* rlwinm R27, R17, 2, 0, 29 */
		/* 82168EF8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R17);
		/* 82168EF8h case    6:*/		return 0x82168EFC;
		  /* 82168EFCh */ case    7:  		/* li R5, 0 */
		/* 82168EFCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168EFCh case    7:*/		return 0x82168F00;
		  /* 82168F00h */ case    8:  		/* mr R4, R27 */
		/* 82168F00h case    8:*/		regs.R4 = regs.R27;
		/* 82168F00h case    8:*/		return 0x82168F04;
		  /* 82168F04h */ case    9:  		/* mr R3, R22 */
		/* 82168F04h case    9:*/		regs.R3 = regs.R22;
		/* 82168F04h case    9:*/		return 0x82168F08;
		  /* 82168F08h */ case   10:  		/* bl -16080 */
		/* 82168F08h case   10:*/		regs.LR = 0x82168F0C; return 0x82165038;
		/* 82168F08h case   10:*/		return 0x82168F0C;
		  /* 82168F0Ch */ case   11:  		/* mr R25, R3 */
		/* 82168F0Ch case   11:*/		regs.R25 = regs.R3;
		/* 82168F0Ch case   11:*/		return 0x82168F10;
		  /* 82168F10h */ case   12:  		/* mr R18, R19 */
		/* 82168F10h case   12:*/		regs.R18 = regs.R19;
		/* 82168F10h case   12:*/		return 0x82168F14;
		  /* 82168F14h */ case   13:  		/* mr R16, R19 */
		/* 82168F14h case   13:*/		regs.R16 = regs.R19;
		/* 82168F14h case   13:*/		return 0x82168F18;
		  /* 82168F18h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 82168F18h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82168F18h case   14:*/		return 0x82168F1C;
		  /* 82168F1Ch */ case   15:  		/* bc 12, CR6_EQ, 248 */
		/* 82168F1Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82169014;  }
		/* 82168F1Ch case   15:*/		return 0x82168F20;
		  /* 82168F20h */ case   16:  		/* lis R11, -32255 */
		/* 82168F20h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82168F20h case   16:*/		return 0x82168F24;
		  /* 82168F24h */ case   17:  		/* mr R28, R19 */
		/* 82168F24h case   17:*/		regs.R28 = regs.R19;
		/* 82168F24h case   17:*/		return 0x82168F28;
		  /* 82168F28h */ case   18:  		/* mr R24, R19 */
		/* 82168F28h case   18:*/		regs.R24 = regs.R19;
		/* 82168F28h case   18:*/		return 0x82168F2C;
		  /* 82168F2Ch */ case   19:  		/* mr R23, R31 */
		/* 82168F2Ch case   19:*/		regs.R23 = regs.R31;
		/* 82168F2Ch case   19:*/		return 0x82168F30;
		  /* 82168F30h */ case   20:  		/* addi R26, R11, 9360 */
		/* 82168F30h case   20:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x2490);
		/* 82168F30h case   20:*/		return 0x82168F34;
		  /* 82168F34h */ case   21:  		/* lwz R11, <#[R22 + 12]> */
		/* 82168F34h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 82168F34h case   21:*/		return 0x82168F38;
		  /* 82168F38h */ case   22:  		/* add R9, R24, R11 */
		/* 82168F38h case   22:*/		cpu::op::add<0>(regs,&regs.R9,regs.R24,regs.R11);
		/* 82168F38h case   22:*/		return 0x82168F3C;
		  /* 82168F3Ch */ case   23:  		/* mr R3, R9 */
		/* 82168F3Ch case   23:*/		regs.R3 = regs.R9;
		/* 82168F3Ch case   23:*/		return 0x82168F40;
		  /* 82168F40h */ case   24:  		/* bl -18840 */
		/* 82168F40h case   24:*/		regs.LR = 0x82168F44; return 0x821645A8;
		/* 82168F40h case   24:*/		return 0x82168F44;
		  /* 82168F44h */ case   25:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82168F44h case   25:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82168F44h case   25:*/		return 0x82168F48;
		  /* 82168F48h */ case   26:  		/* bc 12, CR0_EQ, 192 */
		/* 82168F48h case   26:*/		if ( regs.CR[0].eq ) { return 0x82169008;  }
		/* 82168F48h case   26:*/		return 0x82168F4C;
		  /* 82168F4Ch */ case   27:  		/* stwx R9, <#[R28 + R25]> */
		/* 82168F4Ch case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + regs.R25 + 0x00000000) );
		/* 82168F4Ch case   27:*/		return 0x82168F50;
		  /* 82168F50h */ case   28:  		/* lwz R11, <#[R9 + 12]> */
		/* 82168F50h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82168F50h case   28:*/		return 0x82168F54;
		  /* 82168F54h */ case   29:  		/* lwz R10, <#[R9]> */
		/* 82168F54h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82168F54h case   29:*/		return 0x82168F58;
		  /* 82168F58h */ case   30:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 82168F58h case   30:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 82168F58h case   30:*/		return 0x82168F5C;
		  /* 82168F5Ch */ case   31:  		/* lwz R11, <#[R11 + 20]> */
		/* 82168F5Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82168F5Ch case   31:*/		return 0x82168F60;
		  /* 82168F60h */ case   32:  		/* addi R29, R11, 24 */
		/* 82168F60h case   32:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x18);
		/* 82168F60h case   32:*/		return 0x82168F64;
		  /* 82168F64h */ case   33:  		/* lwz R30, <#[R11 + 24]> */
		/* 82168F64h case   33:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000018) );
		/* 82168F64h case   33:*/		return 0x82168F68;
		  /* 82168F68h */ case   34:  		/* bc 12, CR0_EQ, 156 */
		/* 82168F68h case   34:*/		if ( regs.CR[0].eq ) { return 0x82169004;  }
		/* 82168F68h case   34:*/		return 0x82168F6C;
		  /* 82168F6Ch */ case   35:  		/* lbz R11, <#[R30]> */
		/* 82168F6Ch case   35:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82168F6Ch case   35:*/		return 0x82168F70;
		  /* 82168F70h */ case   36:  		/* cmplwi CR6, R11, 36 */
		/* 82168F70h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000024);
		/* 82168F70h case   36:*/		return 0x82168F74;
		  /* 82168F74h */ case   37:  		/* bc 12, CR6_EQ, 144 */
		/* 82168F74h case   37:*/		if ( regs.CR[6].eq ) { return 0x82169004;  }
		/* 82168F74h case   37:*/		return 0x82168F78;
		  /* 82168F78h */ case   38:  		/* mr R11, R30 */
		/* 82168F78h case   38:*/		regs.R11 = regs.R30;
		/* 82168F78h case   38:*/		return 0x82168F7C;
		  /* 82168F7Ch */ case   39:  		/* lbz R10, <#[R11]> */
		/* 82168F7Ch case   39:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82168F7Ch case   39:*/		return 0x82168F80;
		  /* 82168F80h */ case   40:  		/* addi R11, R11, 1 */
		/* 82168F80h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82168F80h case   40:*/		return 0x82168F84;
		  /* 82168F84h */ case   41:  		/* cmplwi CR6, R10, 0 */
		/* 82168F84h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82168F84h case   41:*/		return 0x82168F88;
		  /* 82168F88h */ case   42:  		/* bc 4, CR6_EQ, -12 */
		/* 82168F88h case   42:*/		if ( !regs.CR[6].eq ) { return 0x82168F7C;  }
		/* 82168F88h case   42:*/		return 0x82168F8C;
		  /* 82168F8Ch */ case   43:  		/* subf R11, R30, R11 */
		/* 82168F8Ch case   43:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82168F8Ch case   43:*/		return 0x82168F90;
		  /* 82168F90h */ case   44:  		/* li R5, 0 */
		/* 82168F90h case   44:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168F90h case   44:*/		return 0x82168F94;
		  /* 82168F94h */ case   45:  		/* addi R11, R11, -1 */
		/* 82168F94h case   45:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82168F94h case   45:*/		return 0x82168F98;
		  /* 82168F98h */ case   46:  		/* mr R3, R22 */
		/* 82168F98h case   46:*/		regs.R3 = regs.R22;
		/* 82168F98h case   46:*/		return 0x82168F9C;
		  /* 82168F9Ch */ case   47:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82168F9Ch case   47:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82168F9Ch case   47:*/		return 0x82168FA0;
		  /* 82168FA0h */ case   48:  		/* addi R31, R11, 2 */
		/* 82168FA0h case   48:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x2);
		/* 82168FA0h case   48:*/		return 0x82168FA4;
		  /* 82168FA4h */ case   49:  		/* mr R4, R31 */
		/* 82168FA4h case   49:*/		regs.R4 = regs.R31;
		/* 82168FA4h case   49:*/		return 0x82168FA8;
		  /* 82168FA8h */ case   50:  		/* bl -16072 */
		/* 82168FA8h case   50:*/		regs.LR = 0x82168FAC; return 0x821650E0;
		/* 82168FA8h case   50:*/		return 0x82168FAC;
		  /* 82168FACh */ case   51:  		/* mr R5, R26 */
		/* 82168FACh case   51:*/		regs.R5 = regs.R26;
		/* 82168FACh case   51:*/		return 0x82168FB0;
		  /* 82168FB0h */ case   52:  		/* mr R6, R30 */
		/* 82168FB0h case   52:*/		regs.R6 = regs.R30;
		/* 82168FB0h case   52:*/		return 0x82168FB4;
		  /* 82168FB4h */ case   53:  		/* stw R3, <#[R1 + 96]> */
		/* 82168FB4h case   53:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 82168FB4h case   53:*/		return 0x82168FB8;
		  /* 82168FB8h */ case   54:  		/* mr R4, R31 */
		/* 82168FB8h case   54:*/		regs.R4 = regs.R31;
		/* 82168FB8h case   54:*/		return 0x82168FBC;
		  /* 82168FBCh */ case   55:  		/* mr R11, R3 */
		/* 82168FBCh case   55:*/		regs.R11 = regs.R3;
		/* 82168FBCh case   55:*/		return 0x82168FC0;
		  /* 82168FC0h */ case   56:  		/* bl 1048040 */
		/* 82168FC0h case   56:*/		regs.LR = 0x82168FC4; return 0x82268DA8;
		/* 82168FC0h case   56:*/		return 0x82168FC4;
		  /* 82168FC4h */ case   57:  		/* lwz R11, <#[R1 + 96]> */
		/* 82168FC4h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82168FC4h case   57:*/		return 0x82168FC8;
		  /* 82168FC8h */ case   58:  		/* cmplwi CR6, R18, 0 */
		/* 82168FC8h case   58:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82168FC8h case   58:*/		return 0x82168FCC;
		  /* 82168FCCh */ case   59:  		/* stw R11, <#[R29]> */
		/* 82168FCCh case   59:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82168FCCh case   59:*/		return 0x82168FD0;
		  /* 82168FD0h */ case   60:  		/* bc 4, CR6_EQ, 44 */
		/* 82168FD0h case   60:*/		if ( !regs.CR[6].eq ) { return 0x82168FFC;  }
		/* 82168FD0h case   60:*/		return 0x82168FD4;
		  /* 82168FD4h */ case   61:  		/* li R5, 0 */
		/* 82168FD4h case   61:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168FD4h case   61:*/		return 0x82168FD8;
		  /* 82168FD8h */ case   62:  		/* mr R4, R27 */
		/* 82168FD8h case   62:*/		regs.R4 = regs.R27;
		/* 82168FD8h case   62:*/		return 0x82168FDC;
		  /* 82168FDCh */ case   63:  		/* mr R3, R22 */
		/* 82168FDCh case   63:*/		regs.R3 = regs.R22;
		/* 82168FDCh case   63:*/		return 0x82168FE0;
		  /* 82168FE0h */ case   64:  		/* bl -16296 */
		/* 82168FE0h case   64:*/		regs.LR = 0x82168FE4; return 0x82165038;
		/* 82168FE0h case   64:*/		return 0x82168FE4;
		  /* 82168FE4h */ case   65:  		/* mr R18, R3 */
		/* 82168FE4h case   65:*/		regs.R18 = regs.R3;
		/* 82168FE4h case   65:*/		return 0x82168FE8;
		  /* 82168FE8h */ case   66:  		/* li R5, 0 */
		/* 82168FE8h case   66:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82168FE8h case   66:*/		return 0x82168FEC;
		  /* 82168FECh */ case   67:  		/* mr R4, R27 */
		/* 82168FECh case   67:*/		regs.R4 = regs.R27;
		/* 82168FECh case   67:*/		return 0x82168FF0;
		  /* 82168FF0h */ case   68:  		/* mr R3, R22 */
		/* 82168FF0h case   68:*/		regs.R3 = regs.R22;
		/* 82168FF0h case   68:*/		return 0x82168FF4;
		  /* 82168FF4h */ case   69:  		/* bl -16316 */
		/* 82168FF4h case   69:*/		regs.LR = 0x82168FF8; return 0x82165038;
		/* 82168FF4h case   69:*/		return 0x82168FF8;
		  /* 82168FF8h */ case   70:  		/* mr R16, R3 */
		/* 82168FF8h case   70:*/		regs.R16 = regs.R3;
		/* 82168FF8h case   70:*/		return 0x82168FFC;
	}
	return 0x82168FFC;
} // Block from 82168EE0h-82168FFCh (71 instructions)

//////////////////////////////////////////////////////
// Block at 82168FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82168FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82168FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82168FFC);
		  /* 82168FFCh */ case    0:  		/* stwx R30, <#[R28 + R18]> */
		/* 82168FFCh case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + regs.R18 + 0x00000000) );
		/* 82168FFCh case    0:*/		return 0x82169000;
		  /* 82169000h */ case    1:  		/* stwx R29, <#[R28 + R16]> */
		/* 82169000h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + regs.R16 + 0x00000000) );
		/* 82169000h case    1:*/		return 0x82169004;
	}
	return 0x82169004;
} // Block from 82168FFCh-82169004h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169004);
		  /* 82169004h */ case    0:  		/* addi R28, R28, 4 */
		/* 82169004h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82169004h case    0:*/		return 0x82169008;
	}
	return 0x82169008;
} // Block from 82169004h-82169008h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82169008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169008);
		  /* 82169008h */ case    0:  		/* addic. R23, R23, -1 */
		/* 82169008h case    0:*/		cpu::op::addic<1>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 82169008h case    0:*/		return 0x8216900C;
		  /* 8216900Ch */ case    1:  		/* addi R24, R24, 40 */
		/* 8216900Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x28);
		/* 8216900Ch case    1:*/		return 0x82169010;
		  /* 82169010h */ case    2:  		/* bc 4, CR0_EQ, -220 */
		/* 82169010h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82168F34;  }
		/* 82169010h case    2:*/		return 0x82169014;
	}
	return 0x82169014;
} // Block from 82169008h-82169014h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169014);
		  /* 82169014h */ case    0:  		/* lis R11, -32234 */
		/* 82169014h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8216);
		/* 82169014h case    0:*/		return 0x82169018;
		  /* 82169018h */ case    1:  		/* li R5, 4 */
		/* 82169018h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82169018h case    1:*/		return 0x8216901C;
		  /* 8216901Ch */ case    2:  		/* addi R6, R11, 17584 */
		/* 8216901Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x44B0);
		/* 8216901Ch case    2:*/		return 0x82169020;
		  /* 82169020h */ case    3:  		/* mr R4, R17 */
		/* 82169020h case    3:*/		regs.R4 = regs.R17;
		/* 82169020h case    3:*/		return 0x82169024;
		  /* 82169024h */ case    4:  		/* mr R3, R25 */
		/* 82169024h case    4:*/		regs.R3 = regs.R25;
		/* 82169024h case    4:*/		return 0x82169028;
		  /* 82169028h */ case    5:  		/* bl -880712 */
		/* 82169028h case    5:*/		regs.LR = 0x8216902C; return 0x82091FE0;
		/* 82169028h case    5:*/		return 0x8216902C;
		  /* 8216902Ch */ case    6:  		/* mulli R30, R17, 20 */
		/* 8216902Ch case    6:*/		cpu::op::mulli<0>(regs,&regs.R30,regs.R17,0x14);
		/* 8216902Ch case    6:*/		return 0x82169030;
		  /* 82169030h */ case    7:  		/* mr R4, R30 */
		/* 82169030h case    7:*/		regs.R4 = regs.R30;
		/* 82169030h case    7:*/		return 0x82169034;
		  /* 82169034h */ case    8:  		/* li R5, 0 */
		/* 82169034h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82169034h case    8:*/		return 0x82169038;
		  /* 82169038h */ case    9:  		/* mr R3, R22 */
		/* 82169038h case    9:*/		regs.R3 = regs.R22;
		/* 82169038h case    9:*/		return 0x8216903C;
		  /* 8216903Ch */ case   10:  		/* bl -16388 */
		/* 8216903Ch case   10:*/		regs.LR = 0x82169040; return 0x82165038;
		/* 8216903Ch case   10:*/		return 0x82169040;
		  /* 82169040h */ case   11:  		/* mr R31, R3 */
		/* 82169040h case   11:*/		regs.R31 = regs.R3;
		/* 82169040h case   11:*/		return 0x82169044;
		  /* 82169044h */ case   12:  		/* li R8, 2 */
		/* 82169044h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82169044h case   12:*/		return 0x82169048;
		  /* 82169048h */ case   13:  		/* lwz R3, <#[R22 + 772]> */
		/* 82169048h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 82169048h case   13:*/		return 0x8216904C;
		  /* 8216904Ch */ case   14:  		/* addi R7, R1, 224 */
		/* 8216904Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xE0);
		/* 8216904Ch case   14:*/		return 0x82169050;
		  /* 82169050h */ case   15:  		/* li R6, 1 */
		/* 82169050h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82169050h case   15:*/		return 0x82169054;
		  /* 82169054h */ case   16:  		/* mr R5, R30 */
		/* 82169054h case   16:*/		regs.R5 = regs.R30;
		/* 82169054h case   16:*/		return 0x82169058;
		  /* 82169058h */ case   17:  		/* mr R4, R31 */
		/* 82169058h case   17:*/		regs.R4 = regs.R31;
		/* 82169058h case   17:*/		return 0x8216905C;
		  /* 8216905Ch */ case   18:  		/* bl -634348 */
		/* 8216905Ch case   18:*/		regs.LR = 0x82169060; return 0x820CE270;
		/* 8216905Ch case   18:*/		return 0x82169060;
		  /* 82169060h */ case   19:  		/* or. R5, R3, R3 */
		/* 82169060h case   19:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82169060h case   19:*/		return 0x82169064;
		  /* 82169064h */ case   20:  		/* bc 4, CR0_LT, 20 */
		/* 82169064h case   20:*/		if ( !regs.CR[0].lt ) { return 0x82169078;  }
		/* 82169064h case   20:*/		return 0x82169068;
		  /* 82169068h */ case   21:  		/* stw R5, <#[R22 + 2480]> */
		/* 82169068h case   21:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 82169068h case   21:*/		return 0x8216906C;
		  /* 8216906Ch */ case   22:  		/* li R4, 3525 */
		/* 8216906Ch case   22:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 8216906Ch case   22:*/		return 0x82169070;
		  /* 82169070h */ case   23:  		/* mr R3, R22 */
		/* 82169070h case   23:*/		regs.R3 = regs.R22;
		/* 82169070h case   23:*/		return 0x82169074;
		  /* 82169074h */ case   24:  		/* bl -94732 */
		/* 82169074h case   24:*/		regs.LR = 0x82169078; return 0x82151E68;
		/* 82169074h case   24:*/		return 0x82169078;
	}
	return 0x82169078;
} // Block from 82169014h-82169078h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82169078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169078);
		  /* 82169078h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 82169078h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82169078h case    0:*/		return 0x8216907C;
		  /* 8216907Ch */ case    1:  		/* bc 12, CR6_EQ, 996 */
		/* 8216907Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82169460;  }
		/* 8216907Ch case    1:*/		return 0x82169080;
		  /* 82169080h */ case    2:  		/* lis R11, -32256 */
		/* 82169080h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82169080h case    2:*/		return 0x82169084;
		  /* 82169084h */ case    3:  		/* lis R10, -32256 */
		/* 82169084h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82169084h case    3:*/		return 0x82169088;
		  /* 82169088h */ case    4:  		/* addi R21, R31, 6 */
		/* 82169088h case    4:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R31,0x6);
		/* 82169088h case    4:*/		return 0x8216908C;
		  /* 8216908Ch */ case    5:  		/* lfs FR30, <#[R11 + 1816]> */
		/* 8216908Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000718) );
		/* 8216908Ch case    5:*/		return 0x82169090;
		  /* 82169090h */ case    6:  		/* lfs FR31, <#[R10 + 1792]> */
		/* 82169090h case    6:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000700) );
		/* 82169090h case    6:*/		return 0x82169094;
		  /* 82169094h */ case    7:  		/* lwz R28, <#[R25]> */
		/* 82169094h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R25 + 0x00000000) );
		/* 82169094h case    7:*/		return 0x82169098;
		  /* 82169098h */ case    8:  		/* addi R20, R21, -6 */
		/* 82169098h case    8:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R21,0xFFFFFFFA);
		/* 82169098h case    8:*/		return 0x8216909C;
		  /* 8216909Ch */ case    9:  		/* mr R3, R28 */
		/* 8216909Ch case    9:*/		regs.R3 = regs.R28;
		/* 8216909Ch case    9:*/		return 0x821690A0;
		  /* 821690A0h */ case   10:  		/* bl -19192 */
		/* 821690A0h case   10:*/		regs.LR = 0x821690A4; return 0x821645A8;
		/* 821690A0h case   10:*/		return 0x821690A4;
		  /* 821690A4h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821690A4h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821690A4h case   11:*/		return 0x821690A8;
		  /* 821690A8h */ case   12:  		/* bc 12, CR0_EQ, 920 */
		/* 821690A8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82169440;  }
		/* 821690A8h case   12:*/		return 0x821690AC;
		  /* 821690ACh */ case   13:  		/* lwz R11, <#[R28 + 16]> */
		/* 821690ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821690ACh case   13:*/		return 0x821690B0;
		  /* 821690B0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821690B0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821690B0h case   14:*/		return 0x821690B4;
		  /* 821690B4h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 821690B4h case   15:*/		if ( regs.CR[6].eq ) { return 0x821690C4;  }
		/* 821690B4h case   15:*/		return 0x821690B8;
		  /* 821690B8h */ case   16:  		/* lwz R11, <#[R11 + 52]> */
		/* 821690B8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 821690B8h case   16:*/		return 0x821690BC;
		  /* 821690BCh */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 821690BCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821690BCh case   17:*/		return 0x821690C0;
		  /* 821690C0h */ case   18:  		/* bc 4, CR6_EQ, 1036 */
		/* 821690C0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821694CC;  }
		/* 821690C0h case   18:*/		return 0x821690C4;
	}
	return 0x821690C4;
} // Block from 82169078h-821690C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821690C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821690C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821690C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821690C4);
		  /* 821690C4h */ case    0:  		/* lwz R11, <#[R22 + 12]> */
		/* 821690C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000000C) );
		/* 821690C4h case    0:*/		return 0x821690C8;
		  /* 821690C8h */ case    1:  		/* li R10, 40 */
		/* 821690C8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x28);
		/* 821690C8h case    1:*/		return 0x821690CC;
		  /* 821690CCh */ case    2:  		/* lwz R9, <#[R28]> */
		/* 821690CCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 821690CCh case    2:*/		return 0x821690D0;
		  /* 821690D0h */ case    3:  		/* mr R3, R22 */
		/* 821690D0h case    3:*/		regs.R3 = regs.R22;
		/* 821690D0h case    3:*/		return 0x821690D4;
		  /* 821690D4h */ case    4:  		/* subf R11, R11, R28 */
		/* 821690D4h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 821690D4h case    4:*/		return 0x821690D8;
		  /* 821690D8h */ case    5:  		/* rlwinm R30, R9, 29, 18, 31 */
		/* 821690D8h case    5:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R30,regs.R9);
		/* 821690D8h case    5:*/		return 0x821690DC;
		  /* 821690DCh */ case    6:  		/* divw R4, R11, R10 */
		/* 821690DCh case    6:*/		cpu::op::divw<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 821690DCh case    6:*/		return 0x821690E0;
		  /* 821690E0h */ case    7:  		/* bl 538976 */
		/* 821690E0h case    7:*/		regs.LR = 0x821690E4; return 0x821ECA40;
		/* 821690E0h case    7:*/		return 0x821690E4;
		  /* 821690E4h */ case    8:  		/* mr R4, R3 */
		/* 821690E4h case    8:*/		regs.R4 = regs.R3;
		/* 821690E4h case    8:*/		return 0x821690E8;
		  /* 821690E8h */ case    9:  		/* mr R5, R15 */
		/* 821690E8h case    9:*/		regs.R5 = regs.R15;
		/* 821690E8h case    9:*/		return 0x821690EC;
		  /* 821690ECh */ case   10:  		/* lwz R3, <#[R22 + 772]> */
		/* 821690ECh case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 821690ECh case   10:*/		return 0x821690F0;
		  /* 821690F0h */ case   11:  		/* li R6, 7 */
		/* 821690F0h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 821690F0h case   11:*/		return 0x821690F4;
		  /* 821690F4h */ case   12:  		/* mr R7, R20 */
		/* 821690F4h case   12:*/		regs.R7 = regs.R20;
		/* 821690F4h case   12:*/		return 0x821690F8;
		  /* 821690F8h */ case   13:  		/* li R8, 1 */
		/* 821690F8h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821690F8h case   13:*/		return 0x821690FC;
		  /* 821690FCh */ case   14:  		/* bl -634508 */
		/* 821690FCh case   14:*/		regs.LR = 0x82169100; return 0x820CE270;
		/* 821690FCh case   14:*/		return 0x82169100;
		  /* 82169100h */ case   15:  		/* or. R5, R3, R3 */
		/* 82169100h case   15:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82169100h case   15:*/		return 0x82169104;
		  /* 82169104h */ case   16:  		/* bc 12, CR0_LT, 988 */
		/* 82169104h case   16:*/		if ( regs.CR[0].lt ) { return 0x821694E0;  }
		/* 82169104h case   16:*/		return 0x82169108;
		  /* 82169108h */ case   17:  		/* lwz R11, <#[R28]> */
		/* 82169108h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82169108h case   17:*/		return 0x8216910C;
		  /* 8216910Ch */ case   18:  		/* rlwinm R11, R11, 12, 23, 31 */
		/* 8216910Ch case   18:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R11,regs.R11);
		/* 8216910Ch case   18:*/		return 0x82169110;
		  /* 82169110h */ case   19:  		/* sth R11, <#[R21]> */
		/* 82169110h case   19:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82169110h case   19:*/		return 0x82169114;
		  /* 82169114h */ case   20:  		/* lwz R11, <#[R28 + 4]> */
		/* 82169114h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82169114h case   20:*/		return 0x82169118;
		  /* 82169118h */ case   21:  		/* rlwinm R11, R11, 25, 23, 31 */
		/* 82169118h case   21:*/		cpu::op::rlwinm<0,25,23,31>(regs,&regs.R11,regs.R11);
		/* 82169118h case   21:*/		return 0x8216911C;
		  /* 8216911Ch */ case   22:  		/* sth R11, <#[R21 + 2]> */
		/* 8216911Ch case   22:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R21 + 0x00000002) );
		/* 8216911Ch case   22:*/		return 0x82169120;
		  /* 82169120h */ case   23:  		/* lwz R11, <#[R28 + 4]> */
		/* 82169120h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82169120h case   23:*/		return 0x82169124;
		  /* 82169124h */ case   24:  		/* rlwinm R11, R11, 28, 29, 31 */
		/* 82169124h case   24:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R11);
		/* 82169124h case   24:*/		return 0x82169128;
		  /* 82169128h */ case   25:  		/* sth R11, <#[R21 - 2]> */
		/* 82169128h case   25:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R21 + 0xFFFFFFFE) );
		/* 82169128h case   25:*/		return 0x8216912C;
		  /* 8216912Ch */ case   26:  		/* lwz R11, <#[R28 + 4]> */
		/* 8216912Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8216912Ch case   26:*/		return 0x82169130;
		  /* 82169130h */ case   27:  		/* rlwinm R11, R11, 28, 29, 31 */
		/* 82169130h case   27:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R11);
		/* 82169130h case   27:*/		return 0x82169134;
		  /* 82169134h */ case   28:  		/* cmplwi CR6, R11, 1 */
		/* 82169134h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82169134h case   28:*/		return 0x82169138;
		  /* 82169138h */ case   29:  		/* bc 12, CR6_LT, 72 */
		/* 82169138h case   29:*/		if ( regs.CR[6].lt ) { return 0x82169180;  }
		/* 82169138h case   29:*/		return 0x8216913C;
		  /* 8216913Ch */ case   30:  		/* bc 12, CR6_EQ, 36 */
		/* 8216913Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x82169160;  }
		/* 8216913Ch case   30:*/		return 0x82169140;
		  /* 82169140h */ case   31:  		/* cmplwi CR6, R11, 3 */
		/* 82169140h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82169140h case   31:*/		return 0x82169144;
		  /* 82169144h */ case   32:  		/* bc 12, CR6_LT, 92 */
		/* 82169144h case   32:*/		if ( regs.CR[6].lt ) { return 0x821691A0;  }
		/* 82169144h case   32:*/		return 0x82169148;
		  /* 82169148h */ case   33:  		/* mr R3, R22 */
		/* 82169148h case   33:*/		regs.R3 = regs.R22;
		/* 82169148h case   33:*/		return 0x8216914C;
		  /* 8216914Ch */ case   34:  		/* bc 4, CR6_EQ, 932 */
		/* 8216914Ch case   34:*/		if ( !regs.CR[6].eq ) { return 0x821694F0;  }
		/* 8216914Ch case   34:*/		return 0x82169150;
		  /* 82169150h */ case   35:  		/* bl -19896 */
		/* 82169150h case   35:*/		regs.LR = 0x82169154; return 0x82164398;
		/* 82169150h case   35:*/		return 0x82169154;
		  /* 82169154h */ case   36:  		/* lhz R11, <#[R21]> */
		/* 82169154h case   36:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82169154h case   36:*/		return 0x82169158;
		  /* 82169158h */ case   37:  		/* subf R11, R3, R11 */
		/* 82169158h case   37:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82169158h case   37:*/		return 0x8216915C;
		  /* 8216915Ch */ case   38:  		/* b 64 */
		/* 8216915Ch case   38:*/		return 0x8216919C;
		/* 8216915Ch case   38:*/		return 0x82169160;
	}
	return 0x82169160;
} // Block from 821690C4h-82169160h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82169160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169160);
		  /* 82169160h */ case    0:  		/* lwz R11, <#[R22 + 48]> */
		/* 82169160h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000030) );
		/* 82169160h case    0:*/		return 0x82169164;
		  /* 82169164h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82169164h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82169164h case    1:*/		return 0x82169168;
		  /* 82169168h */ case    2:  		/* cmplw CR6, R11, R14 */
		/* 82169168h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 82169168h case    2:*/		return 0x8216916C;
		  /* 8216916Ch */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 8216916Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821691A0;  }
		/* 8216916Ch case    3:*/		return 0x82169170;
		  /* 82169170h */ case    4:  		/* lhz R11, <#[R21]> */
		/* 82169170h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82169170h case    4:*/		return 0x82169174;
		  /* 82169174h */ case    5:  		/* addis R11, R11, 1 */
		/* 82169174h case    5:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169174h case    5:*/		return 0x82169178;
		  /* 82169178h */ case    6:  		/* addi R11, R11, -16 */
		/* 82169178h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 82169178h case    6:*/		return 0x8216917C;
		  /* 8216917Ch */ case    7:  		/* b 32 */
		/* 8216917Ch case    7:*/		return 0x8216919C;
		/* 8216917Ch case    7:*/		return 0x82169180;
	}
	return 0x82169180;
} // Block from 82169160h-82169180h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82169180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169180);
		  /* 82169180h */ case    0:  		/* lwz R11, <#[R22 + 48]> */
		/* 82169180h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000030) );
		/* 82169180h case    0:*/		return 0x82169184;
		  /* 82169184h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 82169184h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 82169184h case    1:*/		return 0x82169188;
		  /* 82169188h */ case    2:  		/* cmplw CR6, R11, R14 */
		/* 82169188h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 82169188h case    2:*/		return 0x8216918C;
		  /* 8216918Ch */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 8216918Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821691A0;  }
		/* 8216918Ch case    3:*/		return 0x82169190;
		  /* 82169190h */ case    4:  		/* lhz R11, <#[R21]> */
		/* 82169190h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 82169190h case    4:*/		return 0x82169194;
		  /* 82169194h */ case    5:  		/* addis R11, R11, 1 */
		/* 82169194h case    5:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169194h case    5:*/		return 0x82169198;
		  /* 82169198h */ case    6:  		/* addi R11, R11, -128 */
		/* 82169198h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFF80);
		/* 82169198h case    6:*/		return 0x8216919C;
	}
	return 0x8216919C;
} // Block from 82169180h-8216919Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216919Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216919C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216919C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216919C);
		  /* 8216919Ch */ case    0:  		/* sth R11, <#[R21]> */
		/* 8216919Ch case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8216919Ch case    0:*/		return 0x821691A0;
	}
	return 0x821691A0;
} // Block from 8216919Ch-821691A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821691A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821691A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821691A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821691A0);
		  /* 821691A0h */ case    0:  		/* addi R7, R21, 6 */
		/* 821691A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R21,0x6);
		/* 821691A0h case    0:*/		return 0x821691A4;
		  /* 821691A4h */ case    1:  		/* lwz R4, <#[R28 + 20]> */
		/* 821691A4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000014) );
		/* 821691A4h case    1:*/		return 0x821691A8;
		  /* 821691A8h */ case    2:  		/* li R6, 0 */
		/* 821691A8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821691A8h case    2:*/		return 0x821691AC;
		  /* 821691ACh */ case    3:  		/* lwz R3, <#[R22 + 772]> */
		/* 821691ACh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 821691ACh case    3:*/		return 0x821691B0;
		  /* 821691B0h */ case    4:  		/* li R5, 1 */
		/* 821691B0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821691B0h case    4:*/		return 0x821691B4;
		  /* 821691B4h */ case    5:  		/* bl -490300 */
		/* 821691B4h case    5:*/		regs.LR = 0x821691B8; return 0x820F1678;
		/* 821691B4h case    5:*/		return 0x821691B8;
		  /* 821691B8h */ case    6:  		/* or. R5, R3, R3 */
		/* 821691B8h case    6:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 821691B8h case    6:*/		return 0x821691BC;
		  /* 821691BCh */ case    7:  		/* bc 12, CR0_LT, 828 */
		/* 821691BCh case    7:*/		if ( regs.CR[0].lt ) { return 0x821694F8;  }
		/* 821691BCh case    7:*/		return 0x821691C0;
		  /* 821691C0h */ case    8:  		/* lwz R11, <#[R28 + 4]> */
		/* 821691C0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821691C0h case    8:*/		return 0x821691C4;
		  /* 821691C4h */ case    9:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821691C4h case    9:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821691C4h case    9:*/		return 0x821691C8;
		  /* 821691C8h */ case   10:  		/* cmplwi CR6, R11, 48 */
		/* 821691C8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821691C8h case   10:*/		return 0x821691CC;
		  /* 821691CCh */ case   11:  		/* bc 12, CR6_EQ, 628 */
		/* 821691CCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82169440;  }
		/* 821691CCh case   11:*/		return 0x821691D0;
		  /* 821691D0h */ case   12:  		/* lwz R24, <#[R28 + 16]> */
		/* 821691D0h case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R28 + 0x00000010) );
		/* 821691D0h case   12:*/		return 0x821691D4;
		  /* 821691D4h */ case   13:  		/* cmplwi CR6, R24, 0 */
		/* 821691D4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821691D4h case   13:*/		return 0x821691D8;
		  /* 821691D8h */ case   14:  		/* bc 12, CR6_EQ, 616 */
		/* 821691D8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82169440;  }
		/* 821691D8h case   14:*/		return 0x821691DC;
		  /* 821691DCh */ case   15:  		/* lwz R11, <#[R24 + 76]> */
		/* 821691DCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000004C) );
		/* 821691DCh case   15:*/		return 0x821691E0;
		  /* 821691E0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 821691E0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821691E0h case   16:*/		return 0x821691E4;
		  /* 821691E4h */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 821691E4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821691F4;  }
		/* 821691E4h case   17:*/		return 0x821691E8;
		  /* 821691E8h */ case   18:  		/* lwz R11, <#[R24 + 56]> */
		/* 821691E8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 821691E8h case   18:*/		return 0x821691EC;
		  /* 821691ECh */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 821691ECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821691ECh case   19:*/		return 0x821691F0;
		  /* 821691F0h */ case   20:  		/* bc 12, CR6_EQ, 592 */
		/* 821691F0h case   20:*/		if ( regs.CR[6].eq ) { return 0x82169440;  }
		/* 821691F0h case   20:*/		return 0x821691F4;
	}
	return 0x821691F4;
} // Block from 821691A0h-821691F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821691F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821691F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821691F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821691F4);
		  /* 821691F4h */ case    0:  		/* lhz R11, <#[R21 + 2]> */
		/* 821691F4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000002) );
		/* 821691F4h case    0:*/		return 0x821691F8;
		  /* 821691F8h */ case    1:  		/* li R5, 0 */
		/* 821691F8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821691F8h case    1:*/		return 0x821691FC;
		  /* 821691FCh */ case    2:  		/* mr R3, R22 */
		/* 821691FCh case    2:*/		regs.R3 = regs.R22;
		/* 821691FCh case    2:*/		return 0x82169200;
		  /* 82169200h */ case    3:  		/* rlwinm R11, R11, 2, 0, 31 */
		/* 82169200h case    3:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R11,regs.R11);
		/* 82169200h case    3:*/		return 0x82169204;
		  /* 82169204h */ case    4:  		/* addi R11, R11, 3 */
		/* 82169204h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82169204h case    4:*/		return 0x82169208;
		  /* 82169208h */ case    5:  		/* rlwinm R27, R11, 0, 0, 29 */
		/* 82169208h case    5:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R27,regs.R11);
		/* 82169208h case    5:*/		return 0x8216920C;
		  /* 8216920Ch */ case    6:  		/* rlwinm R23, R27, 2, 0, 29 */
		/* 8216920Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R27);
		/* 8216920Ch case    6:*/		return 0x82169210;
		  /* 82169210h */ case    7:  		/* mr R4, R23 */
		/* 82169210h case    7:*/		regs.R4 = regs.R23;
		/* 82169210h case    7:*/		return 0x82169214;
		  /* 82169214h */ case    8:  		/* bl -16860 */
		/* 82169214h case    8:*/		regs.LR = 0x82169218; return 0x82165038;
		/* 82169214h case    8:*/		return 0x82169218;
		  /* 82169218h */ case    9:  		/* lwz R11, <#[R28 + 28]> */
		/* 82169218h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000001C) );
		/* 82169218h case    9:*/		return 0x8216921C;
		  /* 8216921Ch */ case   10:  		/* rlwinm R10, R30, 3, 0, 28 */
		/* 8216921Ch case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R30);
		/* 8216921Ch case   10:*/		return 0x82169220;
		  /* 82169220h */ case   11:  		/* lwz R4, <#[R24 + 56]> */
		/* 82169220h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + 0x00000038) );
		/* 82169220h case   11:*/		return 0x82169224;
		  /* 82169224h */ case   12:  		/* mr R29, R3 */
		/* 82169224h case   12:*/		regs.R29 = regs.R3;
		/* 82169224h case   12:*/		return 0x82169228;
		  /* 82169228h */ case   13:  		/* add R11, R10, R11 */
		/* 82169228h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82169228h case   13:*/		return 0x8216922C;
		  /* 8216922Ch */ case   14:  		/* li R31, 0 */
		/* 8216922Ch case   14:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8216922Ch case   14:*/		return 0x82169230;
		  /* 82169230h */ case   15:  		/* li R26, 0 */
		/* 82169230h case   15:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82169230h case   15:*/		return 0x82169234;
		  /* 82169234h */ case   16:  		/* cmplwi CR6, R4, 0 */
		/* 82169234h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82169234h case   16:*/		return 0x82169238;
		  /* 82169238h */ case   17:  		/* lwz R11, <#[R11 - 8]> */
		/* 82169238h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82169238h case   17:*/		return 0x8216923C;
		  /* 8216923Ch */ case   18:  		/* rlwinm R11, R11, 28, 18, 31 */
		/* 8216923Ch case   18:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R11,regs.R11);
		/* 8216923Ch case   18:*/		return 0x82169240;
		  /* 82169240h */ case   19:  		/* addi R11, R11, 1 */
		/* 82169240h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169240h case   19:*/		return 0x82169244;
		  /* 82169244h */ case   20:  		/* divwu R30, R30, R11 */
		/* 82169244h case   20:*/		cpu::op::divwu<0>(regs,&regs.R30,regs.R30,regs.R11);
		/* 82169244h case   20:*/		return 0x82169248;
		  /* 82169248h */ case   21:  		/* twi 6, R11, 0 */
		/* 82169248h case   21:*/		cpu::op::tw<6>(regs, 0x82169248, regs.R11, 0x00000000);
		/* 82169248h case   21:*/		return 0x8216924C;
		  /* 8216924Ch */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 8216924Ch case   22:*/		if ( regs.CR[6].eq ) { return 0x8216925C;  }
		/* 8216924Ch case   22:*/		return 0x82169250;
		  /* 82169250h */ case   23:  		/* mr R3, R22 */
		/* 82169250h case   23:*/		regs.R3 = regs.R22;
		/* 82169250h case   23:*/		return 0x82169254;
		  /* 82169254h */ case   24:  		/* bl 535012 */
		/* 82169254h case   24:*/		regs.LR = 0x82169258; return 0x821EBC38;
		/* 82169254h case   24:*/		return 0x82169258;
		  /* 82169258h */ case   25:  		/* lwz R26, <#[R3 + 32]> */
		/* 82169258h case   25:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000020) );
		/* 82169258h case   25:*/		return 0x8216925C;
	}
	return 0x8216925C;
} // Block from 821691F4h-8216925Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216925Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216925C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216925C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216925C);
		  /* 8216925Ch */ case    0:  		/* lwz R11, <#[R24 + 56]> */
		/* 8216925Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 8216925Ch case    0:*/		return 0x82169260;
		  /* 82169260h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82169260h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82169260h case    1:*/		return 0x82169264;
		  /* 82169264h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82169264h case    2:*/		if ( regs.CR[6].eq ) { return 0x82169288;  }
		/* 82169264h case    2:*/		return 0x82169268;
		  /* 82169268h */ case    3:  		/* cmplwi CR6, R26, 0 */
		/* 82169268h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82169268h case    3:*/		return 0x8216926C;
		  /* 8216926Ch */ case    4:  		/* bc 12, CR6_EQ, 380 */
		/* 8216926Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821693E8;  }
		/* 8216926Ch case    4:*/		return 0x82169270;
		  /* 82169270h */ case    5:  		/* mr R3, R22 */
		/* 82169270h case    5:*/		regs.R3 = regs.R22;
		/* 82169270h case    5:*/		return 0x82169274;
		  /* 82169274h */ case    6:  		/* lwz R4, <#[R26 + 8]> */
		/* 82169274h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000008) );
		/* 82169274h case    6:*/		return 0x82169278;
		  /* 82169278h */ case    7:  		/* bl 535200 */
		/* 82169278h case    7:*/		regs.LR = 0x8216927C; return 0x821EBD18;
		/* 82169278h case    7:*/		return 0x8216927C;
		  /* 8216927Ch */ case    8:  		/* lwz R26, <#[R26 + 12]> */
		/* 8216927Ch case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216927Ch case    8:*/		return 0x82169280;
		  /* 82169280h */ case    9:  		/* addi R11, R3, 16 */
		/* 82169280h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 82169280h case    9:*/		return 0x82169284;
		  /* 82169284h */ case   10:  		/* b 28 */
		/* 82169284h case   10:*/		return 0x821692A0;
		/* 82169284h case   10:*/		return 0x82169288;
	}
	return 0x82169288;
} // Block from 8216925Ch-82169288h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82169288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169288);
		  /* 82169288h */ case    0:  		/* lwz R11, <#[R24 + 76]> */
		/* 82169288h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000004C) );
		/* 82169288h case    0:*/		return 0x8216928C;
		  /* 8216928Ch */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 8216928Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8216928Ch case    1:*/		return 0x82169290;
		  /* 82169290h */ case    2:  		/* bc 4, CR6_LT, 344 */
		/* 82169290h case    2:*/		if ( !regs.CR[6].lt ) { return 0x821693E8;  }
		/* 82169290h case    2:*/		return 0x82169294;
		  /* 82169294h */ case    3:  		/* lwz R11, <#[R24 + 80]> */
		/* 82169294h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000050) );
		/* 82169294h case    3:*/		return 0x82169298;
		  /* 82169298h */ case    4:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82169298h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82169298h case    4:*/		return 0x8216929C;
		  /* 8216929Ch */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8216929Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8216929Ch case    5:*/		return 0x821692A0;
	}
	return 0x821692A0;
} // Block from 82169288h-821692A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821692A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821692A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821692A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821692A0);
		  /* 821692A0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821692A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821692A0h case    0:*/		return 0x821692A4;
		  /* 821692A4h */ case    1:  		/* bc 12, CR6_EQ, 288 */
		/* 821692A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821693C4;  }
		/* 821692A4h case    1:*/		return 0x821692A8;
		  /* 821692A8h */ case    2:  		/* cmplw CR6, R31, R27 */
		/* 821692A8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R27);
		/* 821692A8h case    2:*/		return 0x821692AC;
		  /* 821692ACh */ case    3:  		/* bc 4, CR6_LT, 316 */
		/* 821692ACh case    3:*/		if ( !regs.CR[6].lt ) { return 0x821693E8;  }
		/* 821692ACh case    3:*/		return 0x821692B0;
		  /* 821692B0h */ case    4:  		/* lwz R10, <#[R28 + 4]> */
		/* 821692B0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 821692B0h case    4:*/		return 0x821692B4;
		  /* 821692B4h */ case    5:  		/* rlwinm R10, R10, 28, 29, 31 */
		/* 821692B4h case    5:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R10,regs.R10);
		/* 821692B4h case    5:*/		return 0x821692B8;
		  /* 821692B8h */ case    6:  		/* cmplwi CR6, R10, 1 */
		/* 821692B8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821692B8h case    6:*/		return 0x821692BC;
		  /* 821692BCh */ case    7:  		/* bc 12, CR6_LT, 192 */
		/* 821692BCh case    7:*/		if ( regs.CR[6].lt ) { return 0x8216937C;  }
		/* 821692BCh case    7:*/		return 0x821692C0;
		  /* 821692C0h */ case    8:  		/* bc 12, CR6_EQ, 132 */
		/* 821692C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82169344;  }
		/* 821692C0h case    8:*/		return 0x821692C4;
		  /* 821692C4h */ case    9:  		/* cmplwi CR6, R10, 3 */
		/* 821692C4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 821692C4h case    9:*/		return 0x821692C8;
		  /* 821692C8h */ case   10:  		/* bc 4, CR6_LT, 592 */
		/* 821692C8h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82169518;  }
		/* 821692C8h case   10:*/		return 0x821692CC;
		  /* 821692CCh */ case   11:  		/* lwz R10, <#[R11]> */
		/* 821692CCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821692CCh case   11:*/		return 0x821692D0;
		  /* 821692D0h */ case   12:  		/* cmplwi CR6, R10, 1 */
		/* 821692D0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821692D0h case   12:*/		return 0x821692D4;
		  /* 821692D4h */ case   13:  		/* bc 12, CR6_LT, 76 */
		/* 821692D4h case   13:*/		if ( regs.CR[6].lt ) { return 0x82169320;  }
		/* 821692D4h case   13:*/		return 0x821692D8;
		  /* 821692D8h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 821692D8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82169300;  }
		/* 821692D8h case   14:*/		return 0x821692DC;
		  /* 821692DCh */ case   15:  		/* cmplwi CR6, R10, 3 */
		/* 821692DCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 821692DCh case   15:*/		return 0x821692E0;
		  /* 821692E0h */ case   16:  		/* bc 12, CR6_LT, 16 */
		/* 821692E0h case   16:*/		if ( regs.CR[6].lt ) { return 0x821692F0;  }
		/* 821692E0h case   16:*/		return 0x821692E4;
		  /* 821692E4h */ case   17:  		/* bc 4, CR6_EQ, 576 */
		/* 821692E4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82169524;  }
		/* 821692E4h case   17:*/		return 0x821692E8;
		  /* 821692E8h */ case   18:  		/* lfd FR0, <#[R11 + 8]> */
		/* 821692E8h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 821692E8h case   18:*/		return 0x821692EC;
		  /* 821692ECh */ case   19:  		/* b 36 */
		/* 821692ECh case   19:*/		return 0x82169310;
		/* 821692ECh case   19:*/		return 0x821692F0;
	}
	return 0x821692F0;
} // Block from 821692A0h-821692F0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821692F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821692F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821692F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821692F0);
		  /* 821692F0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821692F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821692F0h case    0:*/		return 0x821692F4;
		  /* 821692F4h */ case    1:  		/* std R11, <#[R1 + 96]> */
		/* 821692F4h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 821692F4h case    1:*/		return 0x821692F8;
		  /* 821692F8h */ case    2:  		/* lfd FR0, <#[R1 + 96]> */
		/* 821692F8h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 821692F8h case    2:*/		return 0x821692FC;
		  /* 821692FCh */ case    3:  		/* b 16 */
		/* 821692FCh case    3:*/		return 0x8216930C;
		/* 821692FCh case    3:*/		return 0x82169300;
	}
	return 0x82169300;
} // Block from 821692F0h-82169300h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82169300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169300);
		  /* 82169300h */ case    0:  		/* lwa R11, <#[R11 + 8]> */
		/* 82169300h case    0:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82169300h case    0:*/		return 0x82169304;
		  /* 82169304h */ case    1:  		/* std R11, <#[R1 + 112]> */
		/* 82169304h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82169304h case    1:*/		return 0x82169308;
		  /* 82169308h */ case    2:  		/* lfd FR0, <#[R1 + 112]> */
		/* 82169308h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 82169308h case    2:*/		return 0x8216930C;
	}
	return 0x8216930C;
} // Block from 82169300h-8216930Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216930Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216930C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216930C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216930C);
		  /* 8216930Ch */ case    0:  		/* fcfid FR0, FR0 */
		/* 8216930Ch case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8216930Ch case    0:*/		return 0x82169310;
	}
	return 0x82169310;
} // Block from 8216930Ch-82169310h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82169310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169310);
		  /* 82169310h */ case    0:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82169310h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82169310h case    0:*/		return 0x82169314;
		  /* 82169314h */ case    1:  		/* frsp FR0, FR0 */
		/* 82169314h case    1:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82169314h case    1:*/		return 0x82169318;
		  /* 82169318h */ case    2:  		/* stfsx FR0, <#[R10 + R29]> */
		/* 82169318h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 82169318h case    2:*/		return 0x8216931C;
		  /* 8216931Ch */ case    3:  		/* b 168 */
		/* 8216931Ch case    3:*/		return 0x821693C4;
		/* 8216931Ch case    3:*/		return 0x82169320;
	}
	return 0x82169320;
} // Block from 82169310h-82169320h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82169320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169320);
		  /* 82169320h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82169320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82169320h case    0:*/		return 0x82169324;
		  /* 82169324h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82169324h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82169324h case    1:*/		return 0x82169328;
		  /* 82169328h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82169328h case    2:*/		if ( regs.CR[6].eq ) { return 0x82169334;  }
		/* 82169328h case    2:*/		return 0x8216932C;
		  /* 8216932Ch */ case    3:  		/* fmr FR0, FR31 */
		/* 8216932Ch case    3:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR31);
		/* 8216932Ch case    3:*/		return 0x82169330;
		  /* 82169330h */ case    4:  		/* b 8 */
		/* 82169330h case    4:*/		return 0x82169338;
		/* 82169330h case    4:*/		return 0x82169334;
	}
	return 0x82169334;
} // Block from 82169320h-82169334h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82169334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169334);
		  /* 82169334h */ case    0:  		/* fmr FR0, FR30 */
		/* 82169334h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR30);
		/* 82169334h case    0:*/		return 0x82169338;
	}
	return 0x82169338;
} // Block from 82169334h-82169338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82169338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169338);
		  /* 82169338h */ case    0:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 82169338h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 82169338h case    0:*/		return 0x8216933C;
		  /* 8216933Ch */ case    1:  		/* stfsx FR0, <#[R11 + R29]> */
		/* 8216933Ch case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8216933Ch case    1:*/		return 0x82169340;
		  /* 82169340h */ case    2:  		/* b 132 */
		/* 82169340h case    2:*/		return 0x821693C4;
		/* 82169340h case    2:*/		return 0x82169344;
	}
	return 0x82169344;
} // Block from 82169338h-82169344h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169344);
		  /* 82169344h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82169344h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82169344h case    0:*/		return 0x82169348;
		  /* 82169348h */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 82169348h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82169348h case    1:*/		return 0x8216934C;
		  /* 8216934Ch */ case    2:  		/* bc 12, CR6_LT, 100 */
		/* 8216934Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x821693B0;  }
		/* 8216934Ch case    2:*/		return 0x82169350;
		  /* 82169350h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 82169350h case    3:*/		if ( regs.CR[6].eq ) { return 0x82169374;  }
		/* 82169350h case    3:*/		return 0x82169354;
		  /* 82169354h */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 82169354h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 82169354h case    4:*/		return 0x82169358;
		  /* 82169358h */ case    5:  		/* bc 12, CR6_LT, 28 */
		/* 82169358h case    5:*/		if ( regs.CR[6].lt ) { return 0x82169374;  }
		/* 82169358h case    5:*/		return 0x8216935C;
		  /* 8216935Ch */ case    6:  		/* bc 4, CR6_EQ, 468 */
		/* 8216935Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82169530;  }
		/* 8216935Ch case    6:*/		return 0x82169360;
		  /* 82169360h */ case    7:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82169360h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82169360h case    7:*/		return 0x82169364;
		  /* 82169364h */ case    8:  		/* lfd FR0, <#[R11 + 8]> */
		/* 82169364h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 82169364h case    8:*/		return 0x82169368;
		  /* 82169368h */ case    9:  		/* fctiwz FR0, FR0 */
		/* 82169368h case    9:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82169368h case    9:*/		return 0x8216936C;
		  /* 8216936Ch */ case   10:  		/* stfiwx FR0, <#[R10 + R29]> */
		/* 8216936Ch case   10:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8216936Ch case   10:*/		return 0x82169370;
		  /* 82169370h */ case   11:  		/* b 84 */
		/* 82169370h case   11:*/		return 0x821693C4;
		/* 82169370h case   11:*/		return 0x82169374;
	}
	return 0x82169374;
} // Block from 82169344h-82169374h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82169374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169374);
		  /* 82169374h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82169374h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82169374h case    0:*/		return 0x82169378;
		  /* 82169378h */ case    1:  		/* b 68 */
		/* 82169378h case    1:*/		return 0x821693BC;
		/* 82169378h case    1:*/		return 0x8216937C;
	}
	return 0x8216937C;
} // Block from 82169374h-8216937Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216937Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216937C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216937C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216937C);
		  /* 8216937Ch */ case    0:  		/* lwz R10, <#[R11]> */
		/* 8216937Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216937Ch case    0:*/		return 0x82169380;
		  /* 82169380h */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 82169380h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82169380h case    1:*/		return 0x82169384;
		  /* 82169384h */ case    2:  		/* bc 12, CR6_LT, 44 */
		/* 82169384h case    2:*/		if ( regs.CR[6].lt ) { return 0x821693B0;  }
		/* 82169384h case    2:*/		return 0x82169388;
		  /* 82169388h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82169388h case    3:*/		if ( regs.CR[6].eq ) { return 0x821693B0;  }
		/* 82169388h case    3:*/		return 0x8216938C;
		  /* 8216938Ch */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 8216938Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8216938Ch case    4:*/		return 0x82169390;
		  /* 82169390h */ case    5:  		/* bc 12, CR6_LT, 32 */
		/* 82169390h case    5:*/		if ( regs.CR[6].lt ) { return 0x821693B0;  }
		/* 82169390h case    5:*/		return 0x82169394;
		  /* 82169394h */ case    6:  		/* bc 4, CR6_EQ, 424 */
		/* 82169394h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216953C;  }
		/* 82169394h case    6:*/		return 0x82169398;
		  /* 82169398h */ case    7:  		/* lfd FR0, <#[R11 + 8]> */
		/* 82169398h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 82169398h case    7:*/		return 0x8216939C;
		  /* 8216939Ch */ case    8:  		/* li R11, 1 */
		/* 8216939Ch case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216939Ch case    8:*/		return 0x821693A0;
		  /* 821693A0h */ case    9:  		/* fcmpu CR6, FR0, FR29 */
		/* 821693A0h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR29);
		/* 821693A0h case    9:*/		return 0x821693A4;
		  /* 821693A4h */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 821693A4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821693BC;  }
		/* 821693A4h case   10:*/		return 0x821693A8;
		  /* 821693A8h */ case   11:  		/* li R11, 0 */
		/* 821693A8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821693A8h case   11:*/		return 0x821693AC;
		  /* 821693ACh */ case   12:  		/* b 16 */
		/* 821693ACh case   12:*/		return 0x821693BC;
		/* 821693ACh case   12:*/		return 0x821693B0;
	}
	return 0x821693B0;
} // Block from 8216937Ch-821693B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821693B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821693B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821693B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821693B0);
		  /* 821693B0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821693B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821693B0h case    0:*/		return 0x821693B4;
		  /* 821693B4h */ case    1:  		/* addic R9, R11, -1 */
		/* 821693B4h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 821693B4h case    1:*/		return 0x821693B8;
		  /* 821693B8h */ case    2:  		/* subfe R11, R9, R11 */
		/* 821693B8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821693B8h case    2:*/		return 0x821693BC;
	}
	return 0x821693BC;
} // Block from 821693B0h-821693BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821693BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821693BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821693BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821693BC);
		  /* 821693BCh */ case    0:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 821693BCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 821693BCh case    0:*/		return 0x821693C0;
		  /* 821693C0h */ case    1:  		/* stwx R11, <#[R10 + R29]> */
		/* 821693C0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 821693C0h case    1:*/		return 0x821693C4;
	}
	return 0x821693C4;
} // Block from 821693BCh-821693C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821693C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821693C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821693C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821693C4);
		  /* 821693C4h */ case    0:  		/* addi R31, R31, 1 */
		/* 821693C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821693C4h case    0:*/		return 0x821693C8;
		  /* 821693C8h */ case    1:  		/* twi 6, R30, 0 */
		/* 821693C8h case    1:*/		cpu::op::tw<6>(regs, 0x821693C8, regs.R30, 0x00000000);
		/* 821693C8h case    1:*/		return 0x821693CC;
		  /* 821693CCh */ case    2:  		/* divwu R11, R31, R30 */
		/* 821693CCh case    2:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 821693CCh case    2:*/		return 0x821693D0;
		  /* 821693D0h */ case    3:  		/* mullw R11, R11, R30 */
		/* 821693D0h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821693D0h case    3:*/		return 0x821693D4;
		  /* 821693D4h */ case    4:  		/* subf. R11, R11, R31 */
		/* 821693D4h case    4:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821693D4h case    4:*/		return 0x821693D8;
		  /* 821693D8h */ case    5:  		/* bc 4, CR0_EQ, -380 */
		/* 821693D8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216925C;  }
		/* 821693D8h case    5:*/		return 0x821693DC;
		  /* 821693DCh */ case    6:  		/* addi R11, R31, 3 */
		/* 821693DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3);
		/* 821693DCh case    6:*/		return 0x821693E0;
		  /* 821693E0h */ case    7:  		/* rlwinm R31, R11, 0, 0, 29 */
		/* 821693E0h case    7:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R31,regs.R11);
		/* 821693E0h case    7:*/		return 0x821693E4;
		  /* 821693E4h */ case    8:  		/* b -392 */
		/* 821693E4h case    8:*/		return 0x8216925C;
		/* 821693E4h case    8:*/		return 0x821693E8;
	}
	return 0x821693E8;
} // Block from 821693C4h-821693E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821693E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821693E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821693E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821693E8);
		  /* 821693E8h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 821693E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821693E8h case    0:*/		return 0x821693EC;
		  /* 821693ECh */ case    1:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821693ECh case    1:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821693ECh case    1:*/		return 0x821693F0;
		  /* 821693F0h */ case    2:  		/* cmplwi CR6, R11, 16 */
		/* 821693F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 821693F0h case    2:*/		return 0x821693F4;
		  /* 821693F4h */ case    3:  		/* bc 4, CR6_EQ, 40 */
		/* 821693F4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216941C;  }
		/* 821693F4h case    3:*/		return 0x821693F8;
		  /* 821693F8h */ case    4:  		/* rlwinm. R9, R27, 30, 2, 31 */
		/* 821693F8h case    4:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R9,regs.R27);
		/* 821693F8h case    4:*/		return 0x821693FC;
		  /* 821693FCh */ case    5:  		/* li R11, 0 */
		/* 821693FCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821693FCh case    5:*/		return 0x82169400;
		  /* 82169400h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82169400h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216941C;  }
		/* 82169400h case    6:*/		return 0x82169404;
		  /* 82169404h */ case    7:  		/* addi R10, R29, -8 */
		/* 82169404h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFF8);
		/* 82169404h case    7:*/		return 0x82169408;
		  /* 82169408h */ case    8:  		/* addi R11, R11, 1 */
		/* 82169408h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169408h case    8:*/		return 0x8216940C;
		  /* 8216940Ch */ case    9:  		/* li R8, 1 */
		/* 8216940Ch case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8216940Ch case    9:*/		return 0x82169410;
		  /* 82169410h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 82169410h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82169410h case   10:*/		return 0x82169414;
		  /* 82169414h */ case   11:  		/* stwu R8, <#[R10 + 16]> */
		/* 82169414h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000010) );
		regs.R10 = (uint32)(regs.R10 + 0x00000010);
		/* 82169414h case   11:*/		return 0x82169418;
		  /* 82169418h */ case   12:  		/* bc 12, CR6_LT, -16 */
		/* 82169418h case   12:*/		if ( regs.CR[6].lt ) { return 0x82169408;  }
		/* 82169418h case   12:*/		return 0x8216941C;
	}
	return 0x8216941C;
} // Block from 821693E8h-8216941Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216941Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216941C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216941C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216941C);
		  /* 8216941Ch */ case    0:  		/* li R8, 0 */
		/* 8216941Ch case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216941Ch case    0:*/		return 0x82169420;
		  /* 82169420h */ case    1:  		/* lwz R3, <#[R22 + 772]> */
		/* 82169420h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 82169420h case    1:*/		return 0x82169424;
		  /* 82169424h */ case    2:  		/* addi R7, R20, 16 */
		/* 82169424h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R20,0x10);
		/* 82169424h case    2:*/		return 0x82169428;
		  /* 82169428h */ case    3:  		/* li R6, 3 */
		/* 82169428h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 82169428h case    3:*/		return 0x8216942C;
		  /* 8216942Ch */ case    4:  		/* mr R5, R23 */
		/* 8216942Ch case    4:*/		regs.R5 = regs.R23;
		/* 8216942Ch case    4:*/		return 0x82169430;
		  /* 82169430h */ case    5:  		/* mr R4, R29 */
		/* 82169430h case    5:*/		regs.R4 = regs.R29;
		/* 82169430h case    5:*/		return 0x82169434;
		  /* 82169434h */ case    6:  		/* bl -635332 */
		/* 82169434h case    6:*/		regs.LR = 0x82169438; return 0x820CE270;
		/* 82169434h case    6:*/		return 0x82169438;
		  /* 82169438h */ case    7:  		/* or. R5, R3, R3 */
		/* 82169438h case    7:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82169438h case    7:*/		return 0x8216943C;
		  /* 8216943Ch */ case    8:  		/* bc 12, CR0_LT, 204 */
		/* 8216943Ch case    8:*/		if ( regs.CR[0].lt ) { return 0x82169508;  }
		/* 8216943Ch case    8:*/		return 0x82169440;
	}
	return 0x82169440;
} // Block from 8216941Ch-82169440h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82169440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169440);
		  /* 82169440h */ case    0:  		/* addi R19, R19, 1 */
		/* 82169440h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 82169440h case    0:*/		return 0x82169444;
		  /* 82169444h */ case    1:  		/* addi R25, R25, 4 */
		/* 82169444h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82169444h case    1:*/		return 0x82169448;
		  /* 82169448h */ case    2:  		/* addi R21, R21, 20 */
		/* 82169448h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x14);
		/* 82169448h case    2:*/		return 0x8216944C;
		  /* 8216944Ch */ case    3:  		/* cmplw CR6, R19, R17 */
		/* 8216944Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R17);
		/* 8216944Ch case    3:*/		return 0x82169450;
		  /* 82169450h */ case    4:  		/* bc 12, CR6_LT, -956 */
		/* 82169450h case    4:*/		if ( regs.CR[6].lt ) { return 0x82169094;  }
		/* 82169450h case    4:*/		return 0x82169454;
		  /* 82169454h */ case    5:  		/* lwz R20, <#[R1 + 92]> */
		/* 82169454h case    5:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000005C) );
		/* 82169454h case    5:*/		return 0x82169458;
		  /* 82169458h */ case    6:  		/* li R19, 0 */
		/* 82169458h case    6:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82169458h case    6:*/		return 0x8216945C;
		  /* 8216945Ch */ case    7:  		/* lwz R21, <#[R1 + 444]> */
		/* 8216945Ch case    7:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000001BC) );
		/* 8216945Ch case    7:*/		return 0x82169460;
	}
	return 0x82169460;
} // Block from 82169440h-82169460h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82169460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169460);
		  /* 82169460h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 82169460h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82169460h case    0:*/		return 0x82169464;
		  /* 82169464h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 82169464h case    1:*/		if ( regs.CR[6].eq ) { return 0x82169498;  }
		/* 82169464h case    1:*/		return 0x82169468;
		  /* 82169468h */ case    2:  		/* cmplwi CR6, R17, 0 */
		/* 82169468h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82169468h case    2:*/		return 0x8216946C;
		  /* 8216946Ch */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 8216946Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82169498;  }
		/* 8216946Ch case    3:*/		return 0x82169470;
		  /* 82169470h */ case    4:  		/* mr R11, R18 */
		/* 82169470h case    4:*/		regs.R11 = regs.R18;
		/* 82169470h case    4:*/		return 0x82169474;
		  /* 82169474h */ case    5:  		/* mtspr CTR, R17 */
		/* 82169474h case    5:*/		regs.CTR = regs.R17;
		/* 82169474h case    5:*/		return 0x82169478;
		  /* 82169478h */ case    6:  		/* subf R9, R18, R16 */
		/* 82169478h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R18,regs.R16);
		/* 82169478h case    6:*/		return 0x8216947C;
		  /* 8216947Ch */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8216947Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216947Ch case    7:*/		return 0x82169480;
		  /* 82169480h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82169480h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82169480h case    8:*/		return 0x82169484;
		  /* 82169484h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 82169484h case    9:*/		if ( regs.CR[6].eq ) { return 0x82169490;  }
		/* 82169484h case    9:*/		return 0x82169488;
		  /* 82169488h */ case   10:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82169488h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82169488h case   10:*/		return 0x8216948C;
		  /* 8216948Ch */ case   11:  		/* stw R10, <#[R8]> */
		/* 8216948Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8216948Ch case   11:*/		return 0x82169490;
	}
	return 0x82169490;
} // Block from 82169460h-82169490h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82169490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169490);
		  /* 82169490h */ case    0:  		/* addi R11, R11, 4 */
		/* 82169490h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82169490h case    0:*/		return 0x82169494;
		  /* 82169494h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 82169494h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8216947C;  }
		/* 82169494h case    1:*/		return 0x82169498;
	}
	return 0x82169498;
} // Block from 82169490h-82169498h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169498);
		  /* 82169498h */ case    0:  		/* addi R11, R1, 120 */
		/* 82169498h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x78);
		/* 82169498h case    0:*/		return 0x8216949C;
		  /* 8216949Ch */ case    1:  		/* addi R5, R1, 120 */
		/* 8216949Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x78);
		/* 8216949Ch case    1:*/		return 0x821694A0;
	}
	return 0x821694A0;
} // Block from 82169498h-821694A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821694A0h
// Function '?Emit@Compiler@D3DXShader@@AAAXKKPAPAUID3DXBuffer@@PAPAUID3DXConstantTable@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821694A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821694A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821694A0);
		  /* 821694A0h */ case    0:  		/* li R4, 0 */
		/* 821694A0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821694A0h case    0:*/		return 0x821694A4;
		  /* 821694A4h */ case    1:  		/* mr R3, R21 */
		/* 821694A4h case    1:*/		regs.R3 = regs.R21;
		/* 821694A4h case    1:*/		return 0x821694A8;
		  /* 821694A8h */ case    2:  		/* std R19, <#[R11]> */
		/* 821694A8h case    2:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 821694A8h case    2:*/		return 0x821694AC;
		  /* 821694ACh */ case    3:  		/* stw R19, <#[R11 + 8]> */
		/* 821694ACh case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		/* 821694ACh case    3:*/		return 0x821694B0;
		  /* 821694B0h */ case    4:  		/* bl -829000 */
		/* 821694B0h case    4:*/		regs.LR = 0x821694B4; return 0x8209EE68;
		/* 821694B0h case    4:*/		return 0x821694B4;
		  /* 821694B4h */ case    5:  		/* or. R5, R3, R3 */
		/* 821694B4h case    5:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 821694B4h case    5:*/		return 0x821694B8;
		  /* 821694B8h */ case    6:  		/* bc 4, CR0_LT, 144 */
		/* 821694B8h case    6:*/		if ( !regs.CR[0].lt ) { return 0x82169548;  }
		/* 821694B8h case    6:*/		return 0x821694BC;
		  /* 821694BCh */ case    7:  		/* stw R5, <#[R22 + 2480]> */
		/* 821694BCh case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 821694BCh case    7:*/		return 0x821694C0;
		  /* 821694C0h */ case    8:  		/* li R4, 3525 */
		/* 821694C0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 821694C0h case    8:*/		return 0x821694C4;
		  /* 821694C4h */ case    9:  		/* mr R3, R22 */
		/* 821694C4h case    9:*/		regs.R3 = regs.R22;
		/* 821694C4h case    9:*/		return 0x821694C8;
		  /* 821694C8h */ case   10:  		/* bl -95840 */
		/* 821694C8h case   10:*/		regs.LR = 0x821694CC; return 0x82151E68;
		/* 821694C8h case   10:*/		return 0x821694CC;
	}
	return 0x821694CC;
} // Block from 821694A0h-821694CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821694CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821694CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821694CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821694CC);
		  /* 821694CCh */ case    0:  		/* lis R11, -32252 */
		/* 821694CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821694CCh case    0:*/		return 0x821694D0;
		  /* 821694D0h */ case    1:  		/* li R4, 3500 */
		/* 821694D0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 821694D0h case    1:*/		return 0x821694D4;
		  /* 821694D4h */ case    2:  		/* addi R5, R11, -17372 */
		/* 821694D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBC24);
		/* 821694D4h case    2:*/		return 0x821694D8;
		  /* 821694D8h */ case    3:  		/* mr R3, R22 */
		/* 821694D8h case    3:*/		regs.R3 = regs.R22;
		/* 821694D8h case    3:*/		return 0x821694DC;
		  /* 821694DCh */ case    4:  		/* bl -95860 */
		/* 821694DCh case    4:*/		regs.LR = 0x821694E0; return 0x82151E68;
		/* 821694DCh case    4:*/		return 0x821694E0;
	}
	return 0x821694E0;
} // Block from 821694CCh-821694E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821694E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821694E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821694E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821694E0);
		  /* 821694E0h */ case    0:  		/* stw R5, <#[R22 + 2480]> */
		/* 821694E0h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 821694E0h case    0:*/		return 0x821694E4;
		  /* 821694E4h */ case    1:  		/* li R4, 3525 */
		/* 821694E4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 821694E4h case    1:*/		return 0x821694E8;
		  /* 821694E8h */ case    2:  		/* mr R3, R22 */
		/* 821694E8h case    2:*/		regs.R3 = regs.R22;
		/* 821694E8h case    2:*/		return 0x821694EC;
		  /* 821694ECh */ case    3:  		/* bl -95876 */
		/* 821694ECh case    3:*/		regs.LR = 0x821694F0; return 0x82151E68;
		/* 821694ECh case    3:*/		return 0x821694F0;
	}
	return 0x821694F0;
} // Block from 821694E0h-821694F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821694F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821694F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821694F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821694F0);
		  /* 821694F0h */ case    0:  		/* li R4, 4800 */
		/* 821694F0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821694F0h case    0:*/		return 0x821694F4;
		  /* 821694F4h */ case    1:  		/* bl -95884 */
		/* 821694F4h case    1:*/		regs.LR = 0x821694F8; return 0x82151E68;
		/* 821694F4h case    1:*/		return 0x821694F8;
	}
	return 0x821694F8;
} // Block from 821694F0h-821694F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821694F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821694F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821694F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821694F8);
		  /* 821694F8h */ case    0:  		/* stw R5, <#[R22 + 2480]> */
		/* 821694F8h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 821694F8h case    0:*/		return 0x821694FC;
		  /* 821694FCh */ case    1:  		/* li R4, 3525 */
		/* 821694FCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 821694FCh case    1:*/		return 0x82169500;
		  /* 82169500h */ case    2:  		/* mr R3, R22 */
		/* 82169500h case    2:*/		regs.R3 = regs.R22;
		/* 82169500h case    2:*/		return 0x82169504;
		  /* 82169504h */ case    3:  		/* bl -95900 */
		/* 82169504h case    3:*/		regs.LR = 0x82169508; return 0x82151E68;
		/* 82169504h case    3:*/		return 0x82169508;
	}
	return 0x82169508;
} // Block from 821694F8h-82169508h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82169508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169508);
		  /* 82169508h */ case    0:  		/* stw R5, <#[R22 + 2480]> */
		/* 82169508h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 82169508h case    0:*/		return 0x8216950C;
		  /* 8216950Ch */ case    1:  		/* li R4, 3525 */
		/* 8216950Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 8216950Ch case    1:*/		return 0x82169510;
		  /* 82169510h */ case    2:  		/* mr R3, R22 */
		/* 82169510h case    2:*/		regs.R3 = regs.R22;
		/* 82169510h case    2:*/		return 0x82169514;
		  /* 82169514h */ case    3:  		/* bl -95916 */
		/* 82169514h case    3:*/		regs.LR = 0x82169518; return 0x82151E68;
		/* 82169514h case    3:*/		return 0x82169518;
	}
	return 0x82169518;
} // Block from 82169508h-82169518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82169518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169518);
		  /* 82169518h */ case    0:  		/* li R4, 4801 */
		/* 82169518h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 82169518h case    0:*/		return 0x8216951C;
		  /* 8216951Ch */ case    1:  		/* mr R3, R22 */
		/* 8216951Ch case    1:*/		regs.R3 = regs.R22;
		/* 8216951Ch case    1:*/		return 0x82169520;
		  /* 82169520h */ case    2:  		/* bl -95928 */
		/* 82169520h case    2:*/		regs.LR = 0x82169524; return 0x82151E68;
		/* 82169520h case    2:*/		return 0x82169524;
	}
	return 0x82169524;
} // Block from 82169518h-82169524h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169524);
		  /* 82169524h */ case    0:  		/* li R4, 4801 */
		/* 82169524h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 82169524h case    0:*/		return 0x82169528;
		  /* 82169528h */ case    1:  		/* mr R3, R22 */
		/* 82169528h case    1:*/		regs.R3 = regs.R22;
		/* 82169528h case    1:*/		return 0x8216952C;
		  /* 8216952Ch */ case    2:  		/* bl -95940 */
		/* 8216952Ch case    2:*/		regs.LR = 0x82169530; return 0x82151E68;
		/* 8216952Ch case    2:*/		return 0x82169530;
	}
	return 0x82169530;
} // Block from 82169524h-82169530h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169530);
		  /* 82169530h */ case    0:  		/* li R4, 4801 */
		/* 82169530h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 82169530h case    0:*/		return 0x82169534;
		  /* 82169534h */ case    1:  		/* mr R3, R22 */
		/* 82169534h case    1:*/		regs.R3 = regs.R22;
		/* 82169534h case    1:*/		return 0x82169538;
		  /* 82169538h */ case    2:  		/* bl -95952 */
		/* 82169538h case    2:*/		regs.LR = 0x8216953C; return 0x82151E68;
		/* 82169538h case    2:*/		return 0x8216953C;
	}
	return 0x8216953C;
} // Block from 82169530h-8216953Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216953Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216953C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216953C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216953C);
		  /* 8216953Ch */ case    0:  		/* li R4, 4801 */
		/* 8216953Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 8216953Ch case    0:*/		return 0x82169540;
		  /* 82169540h */ case    1:  		/* mr R3, R22 */
		/* 82169540h case    1:*/		regs.R3 = regs.R22;
		/* 82169540h case    1:*/		return 0x82169544;
		  /* 82169544h */ case    2:  		/* bl -95964 */
		/* 82169544h case    2:*/		regs.LR = 0x82169548; return 0x82151E68;
		/* 82169544h case    2:*/		return 0x82169548;
	}
	return 0x82169548;
} // Block from 8216953Ch-82169548h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169548);
		  /* 82169548h */ case    0:  		/* li R8, 1 */
		/* 82169548h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82169548h case    0:*/		return 0x8216954C;
		  /* 8216954Ch */ case    1:  		/* lwz R3, <#[R22 + 772]> */
		/* 8216954Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 8216954Ch case    1:*/		return 0x82169550;
		  /* 82169550h */ case    2:  		/* addi R7, R1, 232 */
		/* 82169550h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xE8);
		/* 82169550h case    2:*/		return 0x82169554;
		  /* 82169554h */ case    3:  		/* lwz R4, <#[R1 + 120]> */
		/* 82169554h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000078) );
		/* 82169554h case    3:*/		return 0x82169558;
		  /* 82169558h */ case    4:  		/* li R6, 5 */
		/* 82169558h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 82169558h case    4:*/		return 0x8216955C;
		  /* 8216955Ch */ case    5:  		/* mr R5, R15 */
		/* 8216955Ch case    5:*/		regs.R5 = regs.R15;
		/* 8216955Ch case    5:*/		return 0x82169560;
		  /* 82169560h */ case    6:  		/* bl -635632 */
		/* 82169560h case    6:*/		regs.LR = 0x82169564; return 0x820CE270;
		/* 82169560h case    6:*/		return 0x82169564;
		  /* 82169564h */ case    7:  		/* or. R5, R3, R3 */
		/* 82169564h case    7:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82169564h case    7:*/		return 0x82169568;
		  /* 82169568h */ case    8:  		/* bc 4, CR0_LT, 20 */
		/* 82169568h case    8:*/		if ( !regs.CR[0].lt ) { return 0x8216957C;  }
		/* 82169568h case    8:*/		return 0x8216956C;
		  /* 8216956Ch */ case    9:  		/* stw R5, <#[R22 + 2480]> */
		/* 8216956Ch case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 8216956Ch case    9:*/		return 0x82169570;
		  /* 82169570h */ case   10:  		/* li R4, 3525 */
		/* 82169570h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 82169570h case   10:*/		return 0x82169574;
		  /* 82169574h */ case   11:  		/* mr R3, R22 */
		/* 82169574h case   11:*/		regs.R3 = regs.R22;
		/* 82169574h case   11:*/		return 0x82169578;
		  /* 82169578h */ case   12:  		/* bl -96016 */
		/* 82169578h case   12:*/		regs.LR = 0x8216957C; return 0x82151E68;
		/* 82169578h case   12:*/		return 0x8216957C;
	}
	return 0x8216957C;
} // Block from 82169548h-8216957Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216957Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216957C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216957C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216957C);
		  /* 8216957Ch */ case    0:  		/* lis R11, -32252 */
		/* 8216957Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8216957Ch case    0:*/		return 0x82169580;
		  /* 82169580h */ case    1:  		/* lwz R3, <#[R22 + 772]> */
		/* 82169580h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 82169580h case    1:*/		return 0x82169584;
		  /* 82169584h */ case    2:  		/* li R8, 1 */
		/* 82169584h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82169584h case    2:*/		return 0x82169588;
		  /* 82169588h */ case    3:  		/* addi R4, R11, -17384 */
		/* 82169588h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBC18);
		/* 82169588h case    3:*/		return 0x8216958C;
		  /* 8216958Ch */ case    4:  		/* addi R7, R1, 212 */
		/* 8216958Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xD4);
		/* 8216958Ch case    4:*/		return 0x82169590;
		  /* 82169590h */ case    5:  		/* li R6, 5 */
		/* 82169590h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 82169590h case    5:*/		return 0x82169594;
		  /* 82169594h */ case    6:  		/* mr R5, R15 */
		/* 82169594h case    6:*/		regs.R5 = regs.R15;
		/* 82169594h case    6:*/		return 0x82169598;
		  /* 82169598h */ case    7:  		/* bl -635688 */
		/* 82169598h case    7:*/		regs.LR = 0x8216959C; return 0x820CE270;
		/* 82169598h case    7:*/		return 0x8216959C;
		  /* 8216959Ch */ case    8:  		/* or. R5, R3, R3 */
		/* 8216959Ch case    8:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 8216959Ch case    8:*/		return 0x821695A0;
		  /* 821695A0h */ case    9:  		/* bc 4, CR0_LT, 20 */
		/* 821695A0h case    9:*/		if ( !regs.CR[0].lt ) { return 0x821695B4;  }
		/* 821695A0h case    9:*/		return 0x821695A4;
		  /* 821695A4h */ case   10:  		/* stw R5, <#[R22 + 2480]> */
		/* 821695A4h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 821695A4h case   10:*/		return 0x821695A8;
		  /* 821695A8h */ case   11:  		/* li R4, 3525 */
		/* 821695A8h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 821695A8h case   11:*/		return 0x821695AC;
		  /* 821695ACh */ case   12:  		/* mr R3, R22 */
		/* 821695ACh case   12:*/		regs.R3 = regs.R22;
		/* 821695ACh case   12:*/		return 0x821695B0;
		  /* 821695B0h */ case   13:  		/* bl -96072 */
		/* 821695B0h case   13:*/		regs.LR = 0x821695B4; return 0x82151E68;
		/* 821695B0h case   13:*/		return 0x821695B4;
	}
	return 0x821695B4;
} // Block from 8216957Ch-821695B4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821695B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821695B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821695B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821695B4);
		  /* 821695B4h */ case    0:  		/* lwz R3, <#[R22 + 772]> */
		/* 821695B4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 821695B4h case    0:*/		return 0x821695B8;
		  /* 821695B8h */ case    1:  		/* bl -635864 */
		/* 821695B8h case    1:*/		regs.LR = 0x821695BC; return 0x820CE1E0;
		/* 821695B8h case    1:*/		return 0x821695BC;
		  /* 821695BCh */ case    2:  		/* mr R31, R3 */
		/* 821695BCh case    2:*/		regs.R31 = regs.R3;
		/* 821695BCh case    2:*/		return 0x821695C0;
		  /* 821695C0h */ case    3:  		/* cmplwi CR6, R3, 32768 */
		/* 821695C0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00008000);
		/* 821695C0h case    3:*/		return 0x821695C4;
		  /* 821695C4h */ case    4:  		/* mr R3, R22 */
		/* 821695C4h case    4:*/		regs.R3 = regs.R22;
		/* 821695C4h case    4:*/		return 0x821695C8;
		  /* 821695C8h */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 821695C8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821695D4;  }
		/* 821695C8h case    5:*/		return 0x821695CC;
		  /* 821695CCh */ case    6:  		/* li R4, 4548 */
		/* 821695CCh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x11C4);
		/* 821695CCh case    6:*/		return 0x821695D0;
		  /* 821695D0h */ case    7:  		/* bl -96104 */
		/* 821695D0h case    7:*/		regs.LR = 0x821695D4; return 0x82151E68;
		/* 821695D0h case    7:*/		return 0x821695D4;
	}
	return 0x821695D4;
} // Block from 821695B4h-821695D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821695D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821695D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821695D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821695D4);
		  /* 821695D4h */ case    0:  		/* li R5, 0 */
		/* 821695D4h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821695D4h case    0:*/		return 0x821695D8;
		  /* 821695D8h */ case    1:  		/* rlwinm R4, R31, 2, 0, 29 */
		/* 821695D8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R31);
		/* 821695D8h case    1:*/		return 0x821695DC;
		  /* 821695DCh */ case    2:  		/* bl -17828 */
		/* 821695DCh case    2:*/		regs.LR = 0x821695E0; return 0x82165038;
		/* 821695DCh case    2:*/		return 0x821695E0;
		  /* 821695E0h */ case    3:  		/* mr R30, R3 */
		/* 821695E0h case    3:*/		regs.R30 = regs.R3;
		/* 821695E0h case    3:*/		return 0x821695E4;
		  /* 821695E4h */ case    4:  		/* li R6, 0 */
		/* 821695E4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821695E4h case    4:*/		return 0x821695E8;
		  /* 821695E8h */ case    5:  		/* lwz R3, <#[R22 + 772]> */
		/* 821695E8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000304) );
		/* 821695E8h case    5:*/		return 0x821695EC;
		  /* 821695ECh */ case    6:  		/* mr R5, R31 */
		/* 821695ECh case    6:*/		regs.R5 = regs.R31;
		/* 821695ECh case    6:*/		return 0x821695F0;
		  /* 821695F0h */ case    7:  		/* mr R4, R30 */
		/* 821695F0h case    7:*/		regs.R4 = regs.R30;
		/* 821695F0h case    7:*/		return 0x821695F4;
		  /* 821695F4h */ case    8:  		/* bl -635044 */
		/* 821695F4h case    8:*/		regs.LR = 0x821695F8; return 0x820CE550;
		/* 821695F4h case    8:*/		return 0x821695F8;
		  /* 821695F8h */ case    9:  		/* or. R5, R3, R3 */
		/* 821695F8h case    9:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 821695F8h case    9:*/		return 0x821695FC;
		  /* 821695FCh */ case   10:  		/* bc 4, CR0_LT, 20 */
		/* 821695FCh case   10:*/		if ( !regs.CR[0].lt ) { return 0x82169610;  }
		/* 821695FCh case   10:*/		return 0x82169600;
		  /* 82169600h */ case   11:  		/* stw R5, <#[R22 + 2480]> */
		/* 82169600h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 82169600h case   11:*/		return 0x82169604;
		  /* 82169604h */ case   12:  		/* li R4, 3525 */
		/* 82169604h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 82169604h case   12:*/		return 0x82169608;
		  /* 82169608h */ case   13:  		/* mr R3, R22 */
		/* 82169608h case   13:*/		regs.R3 = regs.R22;
		/* 82169608h case   13:*/		return 0x8216960C;
		  /* 8216960Ch */ case   14:  		/* bl -96164 */
		/* 8216960Ch case   14:*/		regs.LR = 0x82169610; return 0x82151E68;
		/* 8216960Ch case   14:*/		return 0x82169610;
	}
	return 0x82169610;
} // Block from 821695D4h-82169610h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82169610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169610);
		  /* 82169610h */ case    0:  		/* addi R11, R31, -2 */
		/* 82169610h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFE);
		/* 82169610h case    0:*/		return 0x82169614;
		  /* 82169614h */ case    1:  		/* lwz R3, <#[R22 + 768]> */
		/* 82169614h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 82169614h case    1:*/		return 0x82169618;
		  /* 82169618h */ case    2:  		/* addi R31, R30, 8 */
		/* 82169618h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0x8);
		/* 82169618h case    2:*/		return 0x8216961C;
		  /* 8216961Ch */ case    3:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 8216961Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 8216961Ch case    3:*/		return 0x82169620;
		  /* 82169620h */ case    4:  		/* mr R4, R31 */
		/* 82169620h case    4:*/		regs.R4 = regs.R31;
		/* 82169620h case    4:*/		return 0x82169624;
		  /* 82169624h */ case    5:  		/* mr R5, R30 */
		/* 82169624h case    5:*/		regs.R5 = regs.R30;
		/* 82169624h case    5:*/		return 0x82169628;
		  /* 82169628h */ case    6:  		/* bl -1030680 */
		/* 82169628h case    6:*/		regs.LR = 0x8216962C; return 0x8206DC10;
		/* 82169628h case    6:*/		return 0x8216962C;
		  /* 8216962Ch */ case    7:  		/* cmplwi CR6, R20, 0 */
		/* 8216962Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8216962Ch case    7:*/		return 0x82169630;
		  /* 82169630h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82169630h case    8:*/		if ( regs.CR[6].eq ) { return 0x82169644;  }
		/* 82169630h case    8:*/		return 0x82169634;
		  /* 82169634h */ case    9:  		/* mr R5, R30 */
		/* 82169634h case    9:*/		regs.R5 = regs.R30;
		/* 82169634h case    9:*/		return 0x82169638;
		  /* 82169638h */ case   10:  		/* mr R4, R31 */
		/* 82169638h case   10:*/		regs.R4 = regs.R31;
		/* 82169638h case   10:*/		return 0x8216963C;
		  /* 8216963Ch */ case   11:  		/* mr R3, R20 */
		/* 8216963Ch case   11:*/		regs.R3 = regs.R20;
		/* 8216963Ch case   11:*/		return 0x82169640;
		  /* 82169640h */ case   12:  		/* bl -135368 */
		/* 82169640h case   12:*/		regs.LR = 0x82169644; return 0x82148578;
		/* 82169640h case   12:*/		return 0x82169644;
	}
	return 0x82169644;
} // Block from 82169610h-82169644h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82169644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169644);
		  /* 82169644h */ case    0:  		/* lwz R11, <#[R22 + 40]> */
		/* 82169644h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000028) );
		/* 82169644h case    0:*/		return 0x82169648;
		  /* 82169648h */ case    1:  		/* rlwinm. R11, R11, 0, 7, 7 */
		/* 82169648h case    1:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R11);
		/* 82169648h case    1:*/		return 0x8216964C;
		  /* 8216964Ch */ case    2:  		/* bc 12, CR0_EQ, 440 */
		/* 8216964Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82169804;  }
		/* 8216964Ch case    2:*/		return 0x82169650;
		  /* 82169650h */ case    3:  		/* lwz R11, <#[R22 + 4]> */
		/* 82169650h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82169650h case    3:*/		return 0x82169654;
		  /* 82169654h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82169654h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82169654h case    4:*/		return 0x82169658;
		  /* 82169658h */ case    5:  		/* bc 4, CR0_EQ, 308 */
		/* 82169658h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216978C;  }
		/* 82169658h case    5:*/		return 0x8216965C;
		  /* 8216965Ch */ case    6:  		/* mr R30, R11 */
		/* 8216965Ch case    6:*/		regs.R30 = regs.R11;
		/* 8216965Ch case    6:*/		return 0x82169660;
		  /* 82169660h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82169660h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82169660h case    7:*/		return 0x82169664;
		  /* 82169664h */ case    8:  		/* bc 12, CR0_EQ, 296 */
		/* 82169664h case    8:*/		if ( regs.CR[0].eq ) { return 0x8216978C;  }
		/* 82169664h case    8:*/		return 0x82169668;
		  /* 82169668h */ case    9:  		/* lwz R11, <#[R30 + 28]> */
		/* 82169668h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82169668h case    9:*/		return 0x8216966C;
		  /* 8216966Ch */ case   10:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216966Ch case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216966Ch case   10:*/		return 0x82169670;
		  /* 82169670h */ case   11:  		/* bc 4, CR0_EQ, 256 */
		/* 82169670h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82169770;  }
		/* 82169670h case   11:*/		return 0x82169674;
		  /* 82169674h */ case   12:  		/* mr R31, R11 */
		/* 82169674h case   12:*/		regs.R31 = regs.R11;
		/* 82169674h case   12:*/		return 0x82169678;
		  /* 82169678h */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 82169678h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82169678h case   13:*/		return 0x8216967C;
		  /* 8216967Ch */ case   14:  		/* bc 12, CR0_EQ, 244 */
		/* 8216967Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x82169770;  }
		/* 8216967Ch case   14:*/		return 0x82169680;
		  /* 82169680h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 82169680h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82169680h case   15:*/		return 0x82169684;
		  /* 82169684h */ case   16:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82169684h case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82169684h case   16:*/		return 0x82169688;
		  /* 82169688h */ case   17:  		/* cmplwi CR6, R10, 25 */
		/* 82169688h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000019);
		/* 82169688h case   17:*/		return 0x8216968C;
		  /* 8216968Ch */ case   18:  		/* bc 12, CR6_LT, 12 */
		/* 8216968Ch case   18:*/		if ( regs.CR[6].lt ) { return 0x82169698;  }
		/* 8216968Ch case   18:*/		return 0x82169690;
		  /* 82169690h */ case   19:  		/* cmplwi CR6, R10, 28 */
		/* 82169690h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001C);
		/* 82169690h case   19:*/		return 0x82169694;
		  /* 82169694h */ case   20:  		/* bc 4, CR6_GT, 20 */
		/* 82169694h case   20:*/		if ( !regs.CR[6].gt ) { return 0x821696A8;  }
		/* 82169694h case   20:*/		return 0x82169698;
	}
	return 0x82169698;
} // Block from 82169644h-82169698h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82169698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169698);
		  /* 82169698h */ case    0:  		/* cmplwi CR6, R10, 67 */
		/* 82169698h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000043);
		/* 82169698h case    0:*/		return 0x8216969C;
		  /* 8216969Ch */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8216969Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x821696B0;  }
		/* 8216969Ch case    1:*/		return 0x821696A0;
		  /* 821696A0h */ case    2:  		/* cmplwi CR6, R10, 71 */
		/* 821696A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000047);
		/* 821696A0h case    2:*/		return 0x821696A4;
		  /* 821696A4h */ case    3:  		/* bc 12, CR6_GT, 12 */
		/* 821696A4h case    3:*/		if ( regs.CR[6].gt ) { return 0x821696B0;  }
		/* 821696A4h case    3:*/		return 0x821696A8;
	}
	return 0x821696A8;
} // Block from 82169698h-821696A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821696A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821696A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821696A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821696A8);
		  /* 821696A8h */ case    0:  		/* li R11, 1 */
		/* 821696A8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821696A8h case    0:*/		return 0x821696AC;
		  /* 821696ACh */ case    1:  		/* b 8 */
		/* 821696ACh case    1:*/		return 0x821696B4;
		/* 821696ACh case    1:*/		return 0x821696B0;
	}
	return 0x821696B0;
} // Block from 821696A8h-821696B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821696B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821696B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821696B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821696B0);
		  /* 821696B0h */ case    0:  		/* mr R11, R19 */
		/* 821696B0h case    0:*/		regs.R11 = regs.R19;
		/* 821696B0h case    0:*/		return 0x821696B4;
	}
	return 0x821696B4;
} // Block from 821696B0h-821696B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821696B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821696B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821696B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821696B4);
		  /* 821696B4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821696B4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821696B4h case    0:*/		return 0x821696B8;
		  /* 821696B8h */ case    1:  		/* bc 12, CR0_EQ, 156 */
		/* 821696B8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82169754;  }
		/* 821696B8h case    1:*/		return 0x821696BC;
		  /* 821696BCh */ case    2:  		/* cmplwi CR6, R10, 26 */
		/* 821696BCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001A);
		/* 821696BCh case    2:*/		return 0x821696C0;
		  /* 821696C0h */ case    3:  		/* bc 4, CR6_EQ, 72 */
		/* 821696C0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82169708;  }
		/* 821696C0h case    3:*/		return 0x821696C4;
		  /* 821696C4h */ case    4:  		/* lwz R3, <#[R31 + 44]> */
		/* 821696C4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821696C4h case    4:*/		return 0x821696C8;
		  /* 821696C8h */ case    5:  		/* fmr FR1, FR29 */
		/* 821696C8h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 821696C8h case    5:*/		return 0x821696CC;
		  /* 821696CCh */ case    6:  		/* bl -14620 */
		/* 821696CCh case    6:*/		regs.LR = 0x821696D0; return 0x82165DB0;
		/* 821696CCh case    6:*/		return 0x821696D0;
		  /* 821696D0h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821696D0h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821696D0h case    7:*/		return 0x821696D4;
		  /* 821696D4h */ case    8:  		/* bc 12, CR0_EQ, 52 */
		/* 821696D4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82169708;  }
		/* 821696D4h case    8:*/		return 0x821696D8;
		  /* 821696D8h */ case    9:  		/* lwz R11, <#[R31 + 48]> */
		/* 821696D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821696D8h case    9:*/		return 0x821696DC;
		  /* 821696DCh */ case   10:  		/* lwz R11, <#[R11 + 12]> */
		/* 821696DCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821696DCh case   10:*/		return 0x821696E0;
		  /* 821696E0h */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 821696E0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821696E0h case   11:*/		return 0x821696E4;
		  /* 821696E4h */ case   12:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821696E4h case   12:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821696E4h case   12:*/		return 0x821696E8;
		  /* 821696E8h */ case   13:  		/* cmplwi CR6, R11, 125 */
		/* 821696E8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821696E8h case   13:*/		return 0x821696EC;
		  /* 821696ECh */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 821696ECh case   14:*/		if ( regs.CR[6].eq ) { return 0x821696FC;  }
		/* 821696ECh case   14:*/		return 0x821696F0;
		  /* 821696F0h */ case   15:  		/* cmplwi CR6, R11, 124 */
		/* 821696F0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821696F0h case   15:*/		return 0x821696F4;
		  /* 821696F4h */ case   16:  		/* mr R11, R19 */
		/* 821696F4h case   16:*/		regs.R11 = regs.R19;
		/* 821696F4h case   16:*/		return 0x821696F8;
		  /* 821696F8h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 821696F8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82169700;  }
		/* 821696F8h case   17:*/		return 0x821696FC;
	}
	return 0x821696FC;
} // Block from 821696B4h-821696FCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 821696FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821696FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821696FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821696FC);
		  /* 821696FCh */ case    0:  		/* li R11, 1 */
		/* 821696FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821696FCh case    0:*/		return 0x82169700;
	}
	return 0x82169700;
} // Block from 821696FCh-82169700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82169700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169700);
		  /* 82169700h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82169700h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82169700h case    0:*/		return 0x82169704;
		  /* 82169704h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 82169704h case    1:*/		if ( regs.CR[0].eq ) { return 0x82169754;  }
		/* 82169704h case    1:*/		return 0x82169708;
	}
	return 0x82169708;
} // Block from 82169700h-82169708h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169708);
		  /* 82169708h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82169708h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82169708h case    0:*/		return 0x8216970C;
		  /* 8216970Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8216970Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8216970Ch case    1:*/		return 0x82169710;
		  /* 82169710h */ case    2:  		/* cmplwi CR6, R11, 8704 */
		/* 82169710h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002200);
		/* 82169710h case    2:*/		return 0x82169714;
		  /* 82169714h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 82169714h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82169748;  }
		/* 82169714h case    3:*/		return 0x82169718;
		  /* 82169718h */ case    4:  		/* lwz R11, <#[R31 + 44]> */
		/* 82169718h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82169718h case    4:*/		return 0x8216971C;
		  /* 8216971Ch */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216971Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216971Ch case    5:*/		return 0x82169720;
		  /* 82169720h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 82169720h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82169720h case    6:*/		return 0x82169724;
		  /* 82169724h */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82169724h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82169724h case    7:*/		return 0x82169728;
		  /* 82169728h */ case    8:  		/* cmplwi CR6, R11, 125 */
		/* 82169728h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82169728h case    8:*/		return 0x8216972C;
		  /* 8216972Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8216972Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8216973C;  }
		/* 8216972Ch case    9:*/		return 0x82169730;
		  /* 82169730h */ case   10:  		/* cmplwi CR6, R11, 124 */
		/* 82169730h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82169730h case   10:*/		return 0x82169734;
		  /* 82169734h */ case   11:  		/* mr R11, R19 */
		/* 82169734h case   11:*/		regs.R11 = regs.R19;
		/* 82169734h case   11:*/		return 0x82169738;
		  /* 82169738h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 82169738h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82169740;  }
		/* 82169738h case   12:*/		return 0x8216973C;
	}
	return 0x8216973C;
} // Block from 82169708h-8216973Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216973Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216973C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216973C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216973C);
		  /* 8216973Ch */ case    0:  		/* li R11, 1 */
		/* 8216973Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8216973Ch case    0:*/		return 0x82169740;
	}
	return 0x82169740;
} // Block from 8216973Ch-82169740h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82169740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169740);
		  /* 82169740h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82169740h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82169740h case    0:*/		return 0x82169744;
		  /* 82169744h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82169744h case    1:*/		if ( regs.CR[0].eq ) { return 0x82169754;  }
		/* 82169744h case    1:*/		return 0x82169748;
	}
	return 0x82169748;
} // Block from 82169740h-82169748h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169748);
		  /* 82169748h */ case    0:  		/* lwz R11, <#[R30 + 68]> */
		/* 82169748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000044) );
		/* 82169748h case    0:*/		return 0x8216974C;
		  /* 8216974Ch */ case    1:  		/* oris R11, R11, 4096 */
		/* 8216974Ch case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8216974Ch case    1:*/		return 0x82169750;
		  /* 82169750h */ case    2:  		/* stw R11, <#[R30 + 68]> */
		/* 82169750h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000044) );
		/* 82169750h case    2:*/		return 0x82169754;
	}
	return 0x82169754;
} // Block from 82169748h-82169754h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169754);
		  /* 82169754h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 82169754h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 82169754h case    0:*/		return 0x82169758;
		  /* 82169758h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82169758h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82169758h case    1:*/		return 0x8216975C;
		  /* 8216975Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8216975Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8216975Ch case    2:*/		return 0x82169760;
		  /* 82169760h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82169760h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82169770;  }
		/* 82169760h case    3:*/		return 0x82169764;
		  /* 82169764h */ case    4:  		/* mr R31, R11 */
		/* 82169764h case    4:*/		regs.R31 = regs.R11;
		/* 82169764h case    4:*/		return 0x82169768;
		  /* 82169768h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82169768h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82169768h case    5:*/		return 0x8216976C;
		  /* 8216976Ch */ case    6:  		/* bc 4, CR6_EQ, -236 */
		/* 8216976Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82169680;  }
		/* 8216976Ch case    6:*/		return 0x82169770;
	}
	return 0x82169770;
} // Block from 82169754h-82169770h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82169770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169770);
		  /* 82169770h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82169770h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82169770h case    0:*/		return 0x82169774;
		  /* 82169774h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82169774h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82169774h case    1:*/		return 0x82169778;
		  /* 82169778h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82169778h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82169778h case    2:*/		return 0x8216977C;
		  /* 8216977Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8216977Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216978C;  }
		/* 8216977Ch case    3:*/		return 0x82169780;
		  /* 82169780h */ case    4:  		/* mr R30, R11 */
		/* 82169780h case    4:*/		regs.R30 = regs.R11;
		/* 82169780h case    4:*/		return 0x82169784;
		  /* 82169784h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82169784h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82169784h case    5:*/		return 0x82169788;
		  /* 82169788h */ case    6:  		/* bc 4, CR6_EQ, -288 */
		/* 82169788h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82169668;  }
		/* 82169788h case    6:*/		return 0x8216978C;
	}
	return 0x8216978C;
} // Block from 82169770h-8216978Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216978Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216978C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216978C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216978C);
		  /* 8216978Ch */ case    0:  		/* lwz R11, <#[R22 + 4]> */
		/* 8216978Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 8216978Ch case    0:*/		return 0x82169790;
		  /* 82169790h */ case    1:  		/* mr R8, R19 */
		/* 82169790h case    1:*/		regs.R8 = regs.R19;
		/* 82169790h case    1:*/		return 0x82169794;
		  /* 82169794h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82169794h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82169794h case    2:*/		return 0x82169798;
		  /* 82169798h */ case    3:  		/* addic R10, R10, -1 */
		/* 82169798h case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82169798h case    3:*/		return 0x8216979C;
		  /* 8216979Ch */ case    4:  		/* subfe R10, R10, R10 */
		/* 8216979Ch case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8216979Ch case    4:*/		return 0x821697A0;
		  /* 821697A0h */ case    5:  		/* and R11, R10, R11 */
		/* 821697A0h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821697A0h case    5:*/		return 0x821697A4;
		  /* 821697A4h */ case    6:  		/* b 64 */
		/* 821697A4h case    6:*/		return 0x821697E4;
		/* 821697A4h case    6:*/		return 0x821697A8;
		  /* 821697A8h */ case    7:  		/* lwz R9, <#[R11 + 68]> */
		/* 821697A8h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000044) );
		/* 821697A8h case    7:*/		return 0x821697AC;
		  /* 821697ACh */ case    8:  		/* rlwinm. R10, R9, 0, 3, 3 */
		/* 821697ACh case    8:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R9);
		/* 821697ACh case    8:*/		return 0x821697B0;
		  /* 821697B0h */ case    9:  		/* bc 4, CR0_EQ, 52 */
		/* 821697B0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821697E4;  }
		/* 821697B0h case    9:*/		return 0x821697B4;
		  /* 821697B4h */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 821697B4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821697B4h case   10:*/		return 0x821697B8;
		  /* 821697B8h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 821697B8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821697B8h case   11:*/		return 0x821697BC;
		  /* 821697BCh */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 821697BCh case   12:*/		if ( regs.CR[6].eq ) { return 0x821697D8;  }
		/* 821697BCh case   12:*/		return 0x821697C0;
		  /* 821697C0h */ case   13:  		/* lwz R7, <#[R10 + 4]> */
		/* 821697C0h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 821697C0h case   13:*/		return 0x821697C4;
		  /* 821697C4h */ case   14:  		/* lwz R7, <#[R7 + 68]> */
		/* 821697C4h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000044) );
		/* 821697C4h case   14:*/		return 0x821697C8;
		  /* 821697C8h */ case   15:  		/* rlwinm. R7, R7, 0, 3, 3 */
		/* 821697C8h case   15:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R7,regs.R7);
		/* 821697C8h case   15:*/		return 0x821697CC;
		  /* 821697CCh */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 821697CCh case   16:*/		if ( regs.CR[0].eq ) { return 0x821697E4;  }
		/* 821697CCh case   16:*/		return 0x821697D0;
		  /* 821697D0h */ case   17:  		/* lwz R10, <#[R10 + 12]> */
		/* 821697D0h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 821697D0h case   17:*/		return 0x821697D4;
		  /* 821697D4h */ case   18:  		/* b -28 */
		/* 821697D4h case   18:*/		return 0x821697B8;
		/* 821697D4h case   18:*/		return 0x821697D8;
	}
	return 0x821697D8;
} // Block from 8216978Ch-821697D8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821697D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821697D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821697D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821697D8);
		  /* 821697D8h */ case    0:  		/* oris R10, R9, 4096 */
		/* 821697D8h case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R9,0x1000);
		/* 821697D8h case    0:*/		return 0x821697DC;
		  /* 821697DCh */ case    1:  		/* li R8, 1 */
		/* 821697DCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821697DCh case    1:*/		return 0x821697E0;
		  /* 821697E0h */ case    2:  		/* stw R10, <#[R11 + 68]> */
		/* 821697E0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 821697E0h case    2:*/		return 0x821697E4;
	}
	return 0x821697E4;
} // Block from 821697D8h-821697E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821697E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821697E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821697E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821697E4);
		  /* 821697E4h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821697E4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821697E4h case    0:*/		return 0x821697E8;
		  /* 821697E8h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821697E8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821697E8h case    1:*/		return 0x821697EC;
		  /* 821697ECh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821697ECh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821697ECh case    2:*/		return 0x821697F0;
		  /* 821697F0h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821697F0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821697FC;  }
		/* 821697F0h case    3:*/		return 0x821697F4;
		  /* 821697F4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821697F4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821697F4h case    4:*/		return 0x821697F8;
		  /* 821697F8h */ case    5:  		/* bc 4, CR6_EQ, -80 */
		/* 821697F8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821697A8;  }
		/* 821697F8h case    5:*/		return 0x821697FC;
	}
	return 0x821697FC;
} // Block from 821697E4h-821697FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821697FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821697FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821697FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821697FC);
		  /* 821697FCh */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 821697FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 821697FCh case    0:*/		return 0x82169800;
		  /* 82169800h */ case    1:  		/* bc 4, CR0_EQ, -116 */
		/* 82169800h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216978C;  }
		/* 82169800h case    1:*/		return 0x82169804;
	}
	return 0x82169804;
} // Block from 821697FCh-82169804h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169804);
		  /* 82169804h */ case    0:  		/* lwz R11, <#[R22 + 736]> */
		/* 82169804h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x000002E0) );
		/* 82169804h case    0:*/		return 0x82169808;
		  /* 82169808h */ case    1:  		/* addi R10, R1, 80 */
		/* 82169808h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82169808h case    1:*/		return 0x8216980C;
		  /* 8216980Ch */ case    2:  		/* lwz R9, <#[R22 + 760]> */
		/* 8216980Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x000002F8) );
		/* 8216980Ch case    2:*/		return 0x82169810;
		  /* 82169810h */ case    3:  		/* addi R8, R1, 88 */
		/* 82169810h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x58);
		/* 82169810h case    3:*/		return 0x82169814;
		  /* 82169814h */ case    4:  		/* stw R10, <#[R1 + 176]> */
		/* 82169814h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000B0) );
		/* 82169814h case    4:*/		return 0x82169818;
		  /* 82169818h */ case    5:  		/* addi R6, R1, 176 */
		/* 82169818h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB0);
		/* 82169818h case    5:*/		return 0x8216981C;
		  /* 8216981Ch */ case    6:  		/* stw R8, <#[R1 + 180]> */
		/* 8216981Ch case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000B4) );
		/* 8216981Ch case    6:*/		return 0x82169820;
		  /* 82169820h */ case    7:  		/* li R5, 0 */
		/* 82169820h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82169820h case    7:*/		return 0x82169824;
		  /* 82169824h */ case    8:  		/* stw R20, <#[R1 + 192]> */
		/* 82169824h case    8:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x000000C0) );
		/* 82169824h case    8:*/		return 0x82169828;
		  /* 82169828h */ case    9:  		/* mr R3, R22 */
		/* 82169828h case    9:*/		regs.R3 = regs.R22;
		/* 82169828h case    9:*/		return 0x8216982C;
		  /* 8216982Ch */ case   10:  		/* stw R11, <#[R1 + 184]> */
		/* 8216982Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000B8) );
		/* 8216982Ch case   10:*/		return 0x82169830;
		  /* 82169830h */ case   11:  		/* stw R9, <#[R1 + 188]> */
		/* 82169830h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000BC) );
		/* 82169830h case   11:*/		return 0x82169834;
		  /* 82169834h */ case   12:  		/* lwz R11, <#[R22 + 4]> */
		/* 82169834h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82169834h case   12:*/		return 0x82169838;
		  /* 82169838h */ case   13:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82169838h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82169838h case   13:*/		return 0x8216983C;
		  /* 8216983Ch */ case   14:  		/* addic R10, R10, -1 */
		/* 8216983Ch case   14:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8216983Ch case   14:*/		return 0x82169840;
		  /* 82169840h */ case   15:  		/* subfe R10, R10, R10 */
		/* 82169840h case   15:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82169840h case   15:*/		return 0x82169844;
		  /* 82169844h */ case   16:  		/* and R4, R10, R11 */
		/* 82169844h case   16:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 82169844h case   16:*/		return 0x82169848;
		  /* 82169848h */ case   17:  		/* bl -14128 */
		/* 82169848h case   17:*/		regs.LR = 0x8216984C; return 0x82166118;
		/* 82169848h case   17:*/		return 0x8216984C;
		  /* 8216984Ch */ case   18:  		/* mr R31, R3 */
		/* 8216984Ch case   18:*/		regs.R31 = regs.R3;
		/* 8216984Ch case   18:*/		return 0x82169850;
		  /* 82169850h */ case   19:  		/* cmplwi CR6, R20, 0 */
		/* 82169850h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 82169850h case   19:*/		return 0x82169854;
		  /* 82169854h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 82169854h case   20:*/		if ( regs.CR[6].eq ) { return 0x82169870;  }
		/* 82169854h case   20:*/		return 0x82169858;
		  /* 82169858h */ case   21:  		/* addi R4, R1, 136 */
		/* 82169858h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 82169858h case   21:*/		return 0x8216985C;
		  /* 8216985Ch */ case   22:  		/* mr R3, R20 */
		/* 8216985Ch case   22:*/		regs.R3 = regs.R20;
		/* 8216985Ch case   22:*/		return 0x82169860;
		  /* 82169860h */ case   23:  		/* bl -124744 */
		/* 82169860h case   23:*/		regs.LR = 0x82169864; return 0x8214B118;
		/* 82169860h case   23:*/		return 0x82169864;
		  /* 82169864h */ case   24:  		/* addi R4, R1, 136 */
		/* 82169864h case   24:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 82169864h case   24:*/		return 0x82169868;
		  /* 82169868h */ case   25:  		/* lwz R3, <#[R22 + 768]> */
		/* 82169868h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 82169868h case   25:*/		return 0x8216986C;
		  /* 8216986Ch */ case   26:  		/* bl -1046124 */
		/* 8216986Ch case   26:*/		regs.LR = 0x82169870; return 0x8206A200;
		/* 8216986Ch case   26:*/		return 0x82169870;
	}
	return 0x82169870;
} // Block from 82169804h-82169870h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82169870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169870);
		  /* 82169870h */ case    0:  		/* lwz R11, <#[R22 + 44]> */
		/* 82169870h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x0000002C) );
		/* 82169870h case    0:*/		return 0x82169874;
		  /* 82169874h */ case    1:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 82169874h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 82169874h case    1:*/		return 0x82169878;
		  /* 82169878h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82169878h case    2:*/		if ( regs.CR[0].eq ) { return 0x82169888;  }
		/* 82169878h case    2:*/		return 0x8216987C;
		  /* 8216987Ch */ case    3:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8216987Ch case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8216987Ch case    3:*/		return 0x82169880;
		  /* 82169880h */ case    4:  		/* li R11, 1 */
		/* 82169880h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82169880h case    4:*/		return 0x82169884;
		  /* 82169884h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82169884h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216988C;  }
		/* 82169884h case    5:*/		return 0x82169888;
	}
	return 0x82169888;
} // Block from 82169870h-82169888h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82169888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169888);
		  /* 82169888h */ case    0:  		/* mr R11, R19 */
		/* 82169888h case    0:*/		regs.R11 = regs.R19;
		/* 82169888h case    0:*/		return 0x8216988C;
	}
	return 0x8216988C;
} // Block from 82169888h-8216988Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216988Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216988C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216988C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216988C);
		  /* 8216988Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8216988Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216988Ch case    0:*/		return 0x82169890;
		  /* 82169890h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82169890h case    1:*/		if ( regs.CR[0].eq ) { return 0x821698A8;  }
		/* 82169890h case    1:*/		return 0x82169894;
		  /* 82169894h */ case    2:  		/* addi R6, R1, 176 */
		/* 82169894h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB0);
		/* 82169894h case    2:*/		return 0x82169898;
		  /* 82169898h */ case    3:  		/* li R5, 1 */
		/* 82169898h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82169898h case    3:*/		return 0x8216989C;
		  /* 8216989Ch */ case    4:  		/* mr R4, R31 */
		/* 8216989Ch case    4:*/		regs.R4 = regs.R31;
		/* 8216989Ch case    4:*/		return 0x821698A0;
		  /* 821698A0h */ case    5:  		/* mr R3, R22 */
		/* 821698A0h case    5:*/		regs.R3 = regs.R22;
		/* 821698A0h case    5:*/		return 0x821698A4;
		  /* 821698A4h */ case    6:  		/* bl -14220 */
		/* 821698A4h case    6:*/		regs.LR = 0x821698A8; return 0x82166118;
		/* 821698A4h case    6:*/		return 0x821698A8;
	}
	return 0x821698A8;
} // Block from 8216988Ch-821698A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821698A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821698A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821698A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821698A8);
		  /* 821698A8h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 821698A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821698A8h case    0:*/		return 0x821698AC;
		  /* 821698ACh */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821698ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x821698DC;  }
		/* 821698ACh case    1:*/		return 0x821698B0;
		  /* 821698B0h */ case    2:  		/* lwz R11, <#[R22 + 56]> */
		/* 821698B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000038) );
		/* 821698B0h case    2:*/		return 0x821698B4;
		  /* 821698B4h */ case    3:  		/* lwz R3, <#[R22 + 768]> */
		/* 821698B4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 821698B4h case    3:*/		return 0x821698B8;
		  /* 821698B8h */ case    4:  		/* lwz R5, <#[R11 + 8]> */
		/* 821698B8h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 821698B8h case    4:*/		return 0x821698BC;
		  /* 821698BCh */ case    5:  		/* lwz R4, <#[R11 + 4]> */
		/* 821698BCh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 821698BCh case    5:*/		return 0x821698C0;
		  /* 821698C0h */ case    6:  		/* bl -1031240 */
		/* 821698C0h case    6:*/		regs.LR = 0x821698C4; return 0x8206DC78;
		/* 821698C0h case    6:*/		return 0x821698C4;
		  /* 821698C4h */ case    7:  		/* addi R4, R1, 152 */
		/* 821698C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 821698C4h case    7:*/		return 0x821698C8;
		  /* 821698C8h */ case    8:  		/* mr R3, R20 */
		/* 821698C8h case    8:*/		regs.R3 = regs.R20;
		/* 821698C8h case    8:*/		return 0x821698CC;
		  /* 821698CCh */ case    9:  		/* bl -124852 */
		/* 821698CCh case    9:*/		regs.LR = 0x821698D0; return 0x8214B118;
		/* 821698CCh case    9:*/		return 0x821698D0;
		  /* 821698D0h */ case   10:  		/* addi R4, R1, 152 */
		/* 821698D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 821698D0h case   10:*/		return 0x821698D4;
		  /* 821698D4h */ case   11:  		/* lwz R3, <#[R22 + 768]> */
		/* 821698D4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 821698D4h case   11:*/		return 0x821698D8;
		  /* 821698D8h */ case   12:  		/* bl -1046232 */
		/* 821698D8h case   12:*/		regs.LR = 0x821698DC; return 0x8206A200;
		/* 821698D8h case   12:*/		return 0x821698DC;
	}
	return 0x821698DC;
} // Block from 821698A8h-821698DCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821698DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821698DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821698DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821698DC);
		  /* 821698DCh */ case    0:  		/* lwz R3, <#[R22 + 768]> */
		/* 821698DCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 821698DCh case    0:*/		return 0x821698E0;
		  /* 821698E0h */ case    1:  		/* bl -1031264 */
		/* 821698E0h case    1:*/		regs.LR = 0x821698E4; return 0x8206DC80;
		/* 821698E0h case    1:*/		return 0x821698E4;
		  /* 821698E4h */ case    2:  		/* cmplwi CR6, R20, 0 */
		/* 821698E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821698E4h case    2:*/		return 0x821698E8;
		  /* 821698E8h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 821698E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82169904;  }
		/* 821698E8h case    3:*/		return 0x821698EC;
		  /* 821698ECh */ case    4:  		/* lwz R3, <#[R22 + 768]> */
		/* 821698ECh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 821698ECh case    4:*/		return 0x821698F0;
		  /* 821698F0h */ case    5:  		/* bl -1030896 */
		/* 821698F0h case    5:*/		regs.LR = 0x821698F4; return 0x8206DE00;
		/* 821698F0h case    5:*/		return 0x821698F4;
		  /* 821698F4h */ case    6:  		/* addi R11, R3, 1 */
		/* 821698F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 821698F4h case    6:*/		return 0x821698F8;
		  /* 821698F8h */ case    7:  		/* mr R3, R20 */
		/* 821698F8h case    7:*/		regs.R3 = regs.R20;
		/* 821698F8h case    7:*/		return 0x821698FC;
		  /* 821698FCh */ case    8:  		/* rlwinm R4, R11, 31, 1, 31 */
		/* 821698FCh case    8:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R4,regs.R11);
		/* 821698FCh case    8:*/		return 0x82169900;
		  /* 82169900h */ case    9:  		/* bl -144264 */
		/* 82169900h case    9:*/		regs.LR = 0x82169904; return 0x82146578;
		/* 82169900h case    9:*/		return 0x82169904;
	}
	return 0x82169904;
} // Block from 821698DCh-82169904h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82169904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169904);
		  /* 82169904h */ case    0:  		/* lwz R3, <#[R22 + 768]> */
		/* 82169904h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 82169904h case    0:*/		return 0x82169908;
		  /* 82169908h */ case    1:  		/* bl -1030848 */
		/* 82169908h case    1:*/		regs.LR = 0x8216990C; return 0x8206DE48;
		/* 82169908h case    1:*/		return 0x8216990C;
		  /* 8216990Ch */ case    2:  		/* addi R4, R1, 84 */
		/* 8216990Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8216990Ch case    2:*/		return 0x82169910;
		  /* 82169910h */ case    3:  		/* bl -802560 */
		/* 82169910h case    3:*/		regs.LR = 0x82169914; return 0x820A5A10;
		/* 82169910h case    3:*/		return 0x82169914;
		  /* 82169914h */ case    4:  		/* or. R5, R3, R3 */
		/* 82169914h case    4:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 82169914h case    4:*/		return 0x82169918;
		  /* 82169918h */ case    5:  		/* bc 4, CR0_LT, 20 */
		/* 82169918h case    5:*/		if ( !regs.CR[0].lt ) { return 0x8216992C;  }
		/* 82169918h case    5:*/		return 0x8216991C;
		  /* 8216991Ch */ case    6:  		/* stw R5, <#[R22 + 2480]> */
		/* 8216991Ch case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R22 + 0x000009B0) );
		/* 8216991Ch case    6:*/		return 0x82169920;
		  /* 82169920h */ case    7:  		/* li R4, 3525 */
		/* 82169920h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 82169920h case    7:*/		return 0x82169924;
		  /* 82169924h */ case    8:  		/* mr R3, R22 */
		/* 82169924h case    8:*/		regs.R3 = regs.R22;
		/* 82169924h case    8:*/		return 0x82169928;
		  /* 82169928h */ case    9:  		/* bl -96960 */
		/* 82169928h case    9:*/		regs.LR = 0x8216992C; return 0x82151E68;
		/* 82169928h case    9:*/		return 0x8216992C;
	}
	return 0x8216992C;
} // Block from 82169904h-8216992Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216992Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216992C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216992C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216992C);
		  /* 8216992Ch */ case    0:  		/* lwz R3, <#[R1 + 84]> */
		/* 8216992Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8216992Ch case    0:*/		return 0x82169930;
		  /* 82169930h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82169930h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82169930h case    1:*/		return 0x82169934;
		  /* 82169934h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 82169934h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82169934h case    2:*/		return 0x82169938;
		  /* 82169938h */ case    3:  		/* mtspr CTR, R11 */
		/* 82169938h case    3:*/		regs.CTR = regs.R11;
		/* 82169938h case    3:*/		return 0x8216993C;
		  /* 8216993Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8216993Ch case    4:*/		if ( 1 ) { regs.LR = 0x82169940; return (uint32)regs.CTR; }
		/* 8216993Ch case    4:*/		return 0x82169940;
		  /* 82169940h */ case    5:  		/* lwz R11, <#[R1 + 84]> */
		/* 82169940h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82169940h case    5:*/		return 0x82169944;
		  /* 82169944h */ case    6:  		/* mr R31, R3 */
		/* 82169944h case    6:*/		regs.R31 = regs.R3;
		/* 82169944h case    6:*/		return 0x82169948;
		  /* 82169948h */ case    7:  		/* mr R3, R11 */
		/* 82169948h case    7:*/		regs.R3 = regs.R11;
		/* 82169948h case    7:*/		return 0x8216994C;
		  /* 8216994Ch */ case    8:  		/* lwz R10, <#[R11]> */
		/* 8216994Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216994Ch case    8:*/		return 0x82169950;
		  /* 82169950h */ case    9:  		/* lwz R11, <#[R10 + 12]> */
		/* 82169950h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82169950h case    9:*/		return 0x82169954;
		  /* 82169954h */ case   10:  		/* mtspr CTR, R11 */
		/* 82169954h case   10:*/		regs.CTR = regs.R11;
		/* 82169954h case   10:*/		return 0x82169958;
		  /* 82169958h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82169958h case   11:*/		if ( 1 ) { regs.LR = 0x8216995C; return (uint32)regs.CTR; }
		/* 82169958h case   11:*/		return 0x8216995C;
		  /* 8216995Ch */ case   12:  		/* li R4, 0 */
		/* 8216995Ch case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216995Ch case   12:*/		return 0x82169960;
		  /* 82169960h */ case   13:  		/* mr R5, R31 */
		/* 82169960h case   13:*/		regs.R5 = regs.R31;
		/* 82169960h case   13:*/		return 0x82169964;
		  /* 82169964h */ case   14:  		/* bl -886308 */
		/* 82169964h case   14:*/		regs.LR = 0x82169968; return 0x82091340;
		/* 82169964h case   14:*/		return 0x82169968;
		  /* 82169968h */ case   15:  		/* stw R19, <#[R1 + 104]> */
		/* 82169968h case   15:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000068) );
		/* 82169968h case   15:*/		return 0x8216996C;
		  /* 8216996Ch */ case   16:  		/* lwz R3, <#[R1 + 84]> */
		/* 8216996Ch case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8216996Ch case   16:*/		return 0x82169970;
		  /* 82169970h */ case   17:  		/* lwz R11, <#[R3]> */
		/* 82169970h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82169970h case   17:*/		return 0x82169974;
		  /* 82169974h */ case   18:  		/* lwz R11, <#[R11 + 16]> */
		/* 82169974h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82169974h case   18:*/		return 0x82169978;
		  /* 82169978h */ case   19:  		/* mtspr CTR, R11 */
		/* 82169978h case   19:*/		regs.CTR = regs.R11;
		/* 82169978h case   19:*/		return 0x8216997C;
		  /* 8216997Ch */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 8216997Ch case   20:*/		if ( 1 ) { regs.LR = 0x82169980; return (uint32)regs.CTR; }
		/* 8216997Ch case   20:*/		return 0x82169980;
		  /* 82169980h */ case   21:  		/* lwz R11, <#[R1 + 84]> */
		/* 82169980h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82169980h case   21:*/		return 0x82169984;
		  /* 82169984h */ case   22:  		/* mr R31, R3 */
		/* 82169984h case   22:*/		regs.R31 = regs.R3;
		/* 82169984h case   22:*/		return 0x82169988;
		  /* 82169988h */ case   23:  		/* mr R3, R11 */
		/* 82169988h case   23:*/		regs.R3 = regs.R11;
		/* 82169988h case   23:*/		return 0x8216998C;
		  /* 8216998Ch */ case   24:  		/* lwz R10, <#[R11]> */
		/* 8216998Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216998Ch case   24:*/		return 0x82169990;
		  /* 82169990h */ case   25:  		/* lwz R11, <#[R10 + 12]> */
		/* 82169990h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82169990h case   25:*/		return 0x82169994;
		  /* 82169994h */ case   26:  		/* mtspr CTR, R11 */
		/* 82169994h case   26:*/		regs.CTR = regs.R11;
		/* 82169994h case   26:*/		return 0x82169998;
		  /* 82169998h */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 82169998h case   27:*/		if ( 1 ) { regs.LR = 0x8216999C; return (uint32)regs.CTR; }
		/* 82169998h case   27:*/		return 0x8216999C;
		  /* 8216999Ch */ case   28:  		/* lwz R11, <#[R22 + 768]> */
		/* 8216999Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000300) );
		/* 8216999Ch case   28:*/		return 0x821699A0;
		  /* 821699A0h */ case   29:  		/* mr R4, R3 */
		/* 821699A0h case   29:*/		regs.R4 = regs.R3;
		/* 821699A0h case   29:*/		return 0x821699A4;
		  /* 821699A4h */ case   30:  		/* addi R6, R1, 104 */
		/* 821699A4h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x68);
		/* 821699A4h case   30:*/		return 0x821699A8;
		  /* 821699A8h */ case   31:  		/* mr R5, R31 */
		/* 821699A8h case   31:*/		regs.R5 = regs.R31;
		/* 821699A8h case   31:*/		return 0x821699AC;
		  /* 821699ACh */ case   32:  		/* mr R3, R11 */
		/* 821699ACh case   32:*/		regs.R3 = regs.R11;
		/* 821699ACh case   32:*/		return 0x821699B0;
		  /* 821699B0h */ case   33:  		/* bl -1031464 */
		/* 821699B0h case   33:*/		regs.LR = 0x821699B4; return 0x8206DC88;
		/* 821699B0h case   33:*/		return 0x821699B4;
		  /* 821699B4h */ case   34:  		/* mr R31, R3 */
		/* 821699B4h case   34:*/		regs.R31 = regs.R3;
		/* 821699B4h case   34:*/		return 0x821699B8;
		  /* 821699B8h */ case   35:  		/* lwz R3, <#[R22 + 768]> */
		/* 821699B8h case   35:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000300) );
		/* 821699B8h case   35:*/		return 0x821699BC;
		  /* 821699BCh */ case   36:  		/* bl -1031612 */
		/* 821699BCh case   36:*/		regs.LR = 0x821699C0; return 0x8206DC00;
		/* 821699BCh case   36:*/		return 0x821699C0;
		  /* 821699C0h */ case   37:  		/* cmpwi CR6, R31, 0 */
		/* 821699C0h case   37:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 821699C0h case   37:*/		return 0x821699C4;
		  /* 821699C4h */ case   38:  		/* stw R19, <#[R22 + 768]> */
		/* 821699C4h case   38:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R22 + 0x00000300) );
		/* 821699C4h case   38:*/		return 0x821699C8;
		  /* 821699C8h */ case   39:  		/* bc 12, CR6_LT, 120 */
		/* 821699C8h case   39:*/		if ( regs.CR[6].lt ) { return 0x82169A40;  }
		/* 821699C8h case   39:*/		return 0x821699CC;
		  /* 821699CCh */ case   40:  		/* cmplwi CR6, R20, 0 */
		/* 821699CCh case   40:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821699CCh case   40:*/		return 0x821699D0;
		  /* 821699D0h */ case   41:  		/* bc 12, CR6_EQ, 40 */
		/* 821699D0h case   41:*/		if ( regs.CR[6].eq ) { return 0x821699F8;  }
		/* 821699D0h case   41:*/		return 0x821699D4;
		  /* 821699D4h */ case   42:  		/* lwz R3, <#[R1 + 84]> */
		/* 821699D4h case   42:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 821699D4h case   42:*/		return 0x821699D8;
		  /* 821699D8h */ case   43:  		/* lwz R11, <#[R3]> */
		/* 821699D8h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821699D8h case   43:*/		return 0x821699DC;
		  /* 821699DCh */ case   44:  		/* lwz R11, <#[R11 + 12]> */
		/* 821699DCh case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821699DCh case   44:*/		return 0x821699E0;
		  /* 821699E0h */ case   45:  		/* mtspr CTR, R11 */
		/* 821699E0h case   45:*/		regs.CTR = regs.R11;
		/* 821699E0h case   45:*/		return 0x821699E4;
		  /* 821699E4h */ case   46:  		/* bcctrl 20, CR0_LT */
		/* 821699E4h case   46:*/		if ( 1 ) { regs.LR = 0x821699E8; return (uint32)regs.CTR; }
		/* 821699E4h case   46:*/		return 0x821699E8;
		  /* 821699E8h */ case   47:  		/* lis R11, -32235 */
		/* 821699E8h case   47:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8215);
		/* 821699E8h case   47:*/		return 0x821699EC;
		  /* 821699ECh */ case   48:  		/* mr R4, R20 */
		/* 821699ECh case   48:*/		regs.R4 = regs.R20;
		/* 821699ECh case   48:*/		return 0x821699F0;
		  /* 821699F0h */ case   49:  		/* addi R5, R11, -20088 */
		/* 821699F0h case   49:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB188);
		/* 821699F0h case   49:*/		return 0x821699F4;
		  /* 821699F4h */ case   50:  		/* bl -1045500 */
		/* 821699F4h case   50:*/		regs.LR = 0x821699F8; return 0x8206A5F8;
		/* 821699F4h case   50:*/		return 0x821699F8;
	}
	return 0x821699F8;
} // Block from 8216992Ch-821699F8h (51 instructions)

//////////////////////////////////////////////////////
// Block at 821699F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821699F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821699F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821699F8);
		  /* 821699F8h */ case    0:  		/* lwz R30, <#[R1 + 468]> */
		/* 821699F8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000001D4) );
		/* 821699F8h case    0:*/		return 0x821699FC;
		  /* 821699FCh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821699FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821699FCh case    1:*/		return 0x82169A00;
		  /* 82169A00h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 82169A00h case    2:*/		if ( regs.CR[6].eq ) { return 0x82169A40;  }
		/* 82169A00h case    2:*/		return 0x82169A04;
		  /* 82169A04h */ case    3:  		/* lwz R3, <#[R1 + 84]> */
		/* 82169A04h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82169A04h case    3:*/		return 0x82169A08;
		  /* 82169A08h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 82169A08h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82169A08h case    4:*/		return 0x82169A0C;
		  /* 82169A0Ch */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 82169A0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82169A0Ch case    5:*/		return 0x82169A10;
		  /* 82169A10h */ case    6:  		/* mtspr CTR, R11 */
		/* 82169A10h case    6:*/		regs.CTR = regs.R11;
		/* 82169A10h case    6:*/		return 0x82169A14;
		  /* 82169A14h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82169A14h case    7:*/		if ( 1 ) { regs.LR = 0x82169A18; return (uint32)regs.CTR; }
		/* 82169A14h case    7:*/		return 0x82169A18;
		  /* 82169A18h */ case    8:  		/* mr R4, R30 */
		/* 82169A18h case    8:*/		regs.R4 = regs.R30;
		/* 82169A18h case    8:*/		return 0x82169A1C;
		  /* 82169A1Ch */ case    9:  		/* bl -827252 */
		/* 82169A1Ch case    9:*/		regs.LR = 0x82169A20; return 0x8209FAA8;
		/* 82169A1Ch case    9:*/		return 0x82169A20;
		  /* 82169A20h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82169A20h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82169A20h case   10:*/		return 0x82169A24;
		  /* 82169A24h */ case   11:  		/* bc 4, CR0_LT, 28 */
		/* 82169A24h case   11:*/		if ( !regs.CR[0].lt ) { return 0x82169A40;  }
		/* 82169A24h case   11:*/		return 0x82169A28;
		  /* 82169A28h */ case   12:  		/* lwz R3, <#[R1 + 84]> */
		/* 82169A28h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82169A28h case   12:*/		return 0x82169A2C;
		  /* 82169A2Ch */ case   13:  		/* lwz R11, <#[R3]> */
		/* 82169A2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82169A2Ch case   13:*/		return 0x82169A30;
		  /* 82169A30h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 82169A30h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82169A30h case   14:*/		return 0x82169A34;
		  /* 82169A34h */ case   15:  		/* mtspr CTR, R11 */
		/* 82169A34h case   15:*/		regs.CTR = regs.R11;
		/* 82169A34h case   15:*/		return 0x82169A38;
		  /* 82169A38h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 82169A38h case   16:*/		if ( 1 ) { regs.LR = 0x82169A3C; return (uint32)regs.CTR; }
		/* 82169A38h case   16:*/		return 0x82169A3C;
		  /* 82169A3Ch */ case   17:  		/* stw R19, <#[R1 + 84]> */
		/* 82169A3Ch case   17:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000054) );
		/* 82169A3Ch case   17:*/		return 0x82169A40;
	}
	return 0x82169A40;
} // Block from 821699F8h-82169A40h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82169A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169A40);
		  /* 82169A40h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 82169A40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82169A40h case    0:*/		return 0x82169A44;
		  /* 82169A44h */ case    1:  		/* cmpwi CR6, R31, 0 */
		/* 82169A44h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82169A44h case    1:*/		return 0x82169A48;
		  /* 82169A48h */ case    2:  		/* lwz R10, <#[R1 + 460]> */
		/* 82169A48h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000001CC) );
		/* 82169A48h case    2:*/		return 0x82169A4C;
		  /* 82169A4Ch */ case    3:  		/* stw R11, <#[R10]> */
		/* 82169A4Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82169A4Ch case    3:*/		return 0x82169A50;
		  /* 82169A50h */ case    4:  		/* bc 4, CR6_LT, 24 */
		/* 82169A50h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82169A68;  }
		/* 82169A50h case    4:*/		return 0x82169A54;
		  /* 82169A54h */ case    5:  		/* stw R31, <#[R22 + 2480]> */
		/* 82169A54h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R22 + 0x000009B0) );
		/* 82169A54h case    5:*/		return 0x82169A58;
		  /* 82169A58h */ case    6:  		/* mr R5, R31 */
		/* 82169A58h case    6:*/		regs.R5 = regs.R31;
		/* 82169A58h case    6:*/		return 0x82169A5C;
		  /* 82169A5Ch */ case    7:  		/* li R4, 3525 */
		/* 82169A5Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xDC5);
		/* 82169A5Ch case    7:*/		return 0x82169A60;
		  /* 82169A60h */ case    8:  		/* mr R3, R22 */
		/* 82169A60h case    8:*/		regs.R3 = regs.R22;
		/* 82169A60h case    8:*/		return 0x82169A64;
		  /* 82169A64h */ case    9:  		/* bl -97276 */
		/* 82169A64h case    9:*/		regs.LR = 0x82169A68; return 0x82151E68;
		/* 82169A64h case    9:*/		return 0x82169A68;
	}
	return 0x82169A68;
} // Block from 82169A40h-82169A68h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82169A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169A68);
		  /* 82169A68h */ case    0:  		/* addi R1, R1, 416 */
		/* 82169A68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1A0);
		/* 82169A68h case    0:*/		return 0x82169A6C;
		  /* 82169A6Ch */ case    1:  		/* lfd FR29, <#[R1 - 176]> */
		/* 82169A6Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFF50) );
		/* 82169A6Ch case    1:*/		return 0x82169A70;
		  /* 82169A70h */ case    2:  		/* lfd FR30, <#[R1 - 168]> */
		/* 82169A70h case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 82169A70h case    2:*/		return 0x82169A74;
		  /* 82169A74h */ case    3:  		/* lfd FR31, <#[R1 - 160]> */
		/* 82169A74h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82169A74h case    3:*/		return 0x82169A78;
		  /* 82169A78h */ case    4:  		/* b -886792 */
		/* 82169A78h case    4:*/		return 0x82091270;
		/* 82169A78h case    4:*/		return 0x82169A7C;
		  /* 82169A7Ch */ case    5:  		/* nop */
		/* 82169A7Ch case    5:*/		cpu::op::nop();
		/* 82169A7Ch case    5:*/		return 0x82169A80;
	}
	return 0x82169A80;
} // Block from 82169A68h-82169A80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82169A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169A80);
		  /* 82169A80h */ case    0:  		/* mfspr R12, LR */
		/* 82169A80h case    0:*/		regs.R12 = regs.LR;
		/* 82169A80h case    0:*/		return 0x82169A84;
		  /* 82169A84h */ case    1:  		/* bl -886824 */
		/* 82169A84h case    1:*/		regs.LR = 0x82169A88; return 0x8209125C;
		/* 82169A84h case    1:*/		return 0x82169A88;
		  /* 82169A88h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82169A88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82169A88h case    2:*/		return 0x82169A8C;
		  /* 82169A8Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82169A8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82169A8Ch case    3:*/		return 0x82169A90;
		  /* 82169A90h */ case    4:  		/* lis R9, 1 */
		/* 82169A90h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 82169A90h case    4:*/		return 0x82169A94;
		  /* 82169A94h */ case    5:  		/* mr R10, R4 */
		/* 82169A94h case    5:*/		regs.R10 = regs.R4;
		/* 82169A94h case    5:*/		return 0x82169A98;
		  /* 82169A98h */ case    6:  		/* addi R11, R11, 1 */
		/* 82169A98h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169A98h case    6:*/		return 0x82169A9C;
		  /* 82169A9Ch */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 82169A9Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82169A9Ch case    7:*/		return 0x82169AA0;
		  /* 82169AA0h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 82169AA0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82169AA0h case    8:*/		return 0x82169AA4;
		  /* 82169AA4h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 82169AA4h case    9:*/		if ( regs.CR[6].lt ) { return 0x82169AB4;  }
		/* 82169AA4h case    9:*/		return 0x82169AA8;
		  /* 82169AA8h */ case   10:  		/* lis R3, -32768 */
		/* 82169AA8h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82169AA8h case   10:*/		return 0x82169AAC;
		  /* 82169AACh */ case   11:  		/* ori R3, R3, 16389 */
		/* 82169AACh case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82169AACh case   11:*/		return 0x82169AB0;
		  /* 82169AB0h */ case   12:  		/* b 216 */
		/* 82169AB0h case   12:*/		return 0x82169B88;
		/* 82169AB0h case   12:*/		return 0x82169AB4;
	}
	return 0x82169AB4;
} // Block from 82169A80h-82169AB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82169AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169AB4);
		  /* 82169AB4h */ case    0:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 82169AB4h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 82169AB4h case    0:*/		return 0x82169AB8;
		  /* 82169AB8h */ case    1:  		/* cmplwi CR6, R10, 8192 */
		/* 82169AB8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002000);
		/* 82169AB8h case    1:*/		return 0x82169ABC;
		  /* 82169ABCh */ case    2:  		/* add R11, R11, R3 */
		/* 82169ABCh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82169ABCh case    2:*/		return 0x82169AC0;
		  /* 82169AC0h */ case    3:  		/* addi R31, R11, 12 */
		/* 82169AC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xC);
		/* 82169AC0h case    3:*/		return 0x82169AC4;
		  /* 82169AC4h */ case    4:  		/* bc 4, CR6_LT, -28 */
		/* 82169AC4h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82169AA8;  }
		/* 82169AC4h case    4:*/		return 0x82169AC8;
		  /* 82169AC8h */ case    5:  		/* cmplwi CR6, R5, 4 */
		/* 82169AC8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000004);
		/* 82169AC8h case    5:*/		return 0x82169ACC;
		  /* 82169ACCh */ case    6:  		/* bc 12, CR6_GT, -36 */
		/* 82169ACCh case    6:*/		if ( regs.CR[6].gt ) { return 0x82169AA8;  }
		/* 82169ACCh case    6:*/		return 0x82169AD0;
		  /* 82169AD0h */ case    7:  		/* cmplwi CR6, R6, 4 */
		/* 82169AD0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000004);
		/* 82169AD0h case    7:*/		return 0x82169AD4;
		  /* 82169AD4h */ case    8:  		/* bc 12, CR6_GT, -44 */
		/* 82169AD4h case    8:*/		if ( regs.CR[6].gt ) { return 0x82169AA8;  }
		/* 82169AD4h case    8:*/		return 0x82169AD8;
		  /* 82169AD8h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82169AD8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169AD8h case    9:*/		return 0x82169ADC;
		  /* 82169ADCh */ case   10:  		/* rlwinm R10, R10, 19, 0, 12 */
		/* 82169ADCh case   10:*/		cpu::op::rlwinm<0,19,0,12>(regs,&regs.R10,regs.R10);
		/* 82169ADCh case   10:*/		return 0x82169AE0;
		  /* 82169AE0h */ case   11:  		/* lwz R9, <#[R3]> */
		/* 82169AE0h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82169AE0h case   11:*/		return 0x82169AE4;
		  /* 82169AE4h */ case   12:  		/* rlwimi R6, R5, 3, 26, 28 */
		/* 82169AE4h case   12:*/		cpu::op::rlwimi<0,3,26,28>(regs,&regs.R6,regs.R5);
		/* 82169AE4h case   12:*/		return 0x82169AE8;
		  /* 82169AE8h */ case   13:  		/* rlwinm R8, R11, 0, 19, 31 */
		/* 82169AE8h case   13:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R8,regs.R11);
		/* 82169AE8h case   13:*/		return 0x82169AEC;
		  /* 82169AECh */ case   14:  		/* rlwinm R11, R9, 4, 0, 27 */
		/* 82169AECh case   14:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R9);
		/* 82169AECh case   14:*/		return 0x82169AF0;
		  /* 82169AF0h */ case   15:  		/* or R30, R10, R8 */
		/* 82169AF0h case   15:*/		cpu::op::or<0>(regs,&regs.R30,regs.R10,regs.R8);
		/* 82169AF0h case   15:*/		return 0x82169AF4;
		  /* 82169AF4h */ case   16:  		/* add R29, R11, R3 */
		/* 82169AF4h case   16:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R3);
		/* 82169AF4h case   16:*/		return 0x82169AF8;
		  /* 82169AF8h */ case   17:  		/* rlwimi R30, R6, 13, 13, 18 */
		/* 82169AF8h case   17:*/		cpu::op::rlwimi<0,13,13,18>(regs,&regs.R30,regs.R6);
		/* 82169AF8h case   17:*/		return 0x82169AFC;
		  /* 82169AFCh */ case   18:  		/* cmplwi CR6, R7, 0 */
		/* 82169AFCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82169AFCh case   18:*/		return 0x82169B00;
		  /* 82169B00h */ case   19:  		/* stw R30, <#[R31]> */
		/* 82169B00h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B00h case   19:*/		return 0x82169B04;
		  /* 82169B04h */ case   20:  		/* bc 12, CR6_EQ, -92 */
		/* 82169B04h case   20:*/		if ( regs.CR[6].eq ) { return 0x82169AA8;  }
		/* 82169B04h case   20:*/		return 0x82169B08;
		  /* 82169B08h */ case   21:  		/* addi R3, R31, 4 */
		/* 82169B08h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82169B08h case   21:*/		return 0x82169B0C;
		  /* 82169B0Ch */ case   22:  		/* li R5, 9 */
		/* 82169B0Ch case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 82169B0Ch case   22:*/		return 0x82169B10;
		  /* 82169B10h */ case   23:  		/* mr R4, R7 */
		/* 82169B10h case   23:*/		regs.R4 = regs.R7;
		/* 82169B10h case   23:*/		return 0x82169B14;
		  /* 82169B14h */ case   24:  		/* bl -885092 */
		/* 82169B14h case   24:*/		regs.LR = 0x82169B18; return 0x820919B0;
		/* 82169B14h case   24:*/		return 0x82169B18;
		  /* 82169B18h */ case   25:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B18h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B18h case   25:*/		return 0x82169B1C;
		  /* 82169B1Ch */ case   26:  		/* li R3, 0 */
		/* 82169B1Ch case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82169B1Ch case   26:*/		return 0x82169B20;
		  /* 82169B20h */ case   27:  		/* rlwimi R30, R11, 0, 19, 19 */
		/* 82169B20h case   27:*/		cpu::op::rlwimi<0,0,19,19>(regs,&regs.R30,regs.R11);
		/* 82169B20h case   27:*/		return 0x82169B24;
		  /* 82169B24h */ case   28:  		/* rlwinm R10, R30, 0, 0, 31 */
		/* 82169B24h case   28:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R30);
		/* 82169B24h case   28:*/		return 0x82169B28;
		  /* 82169B28h */ case   29:  		/* stw R30, <#[R31]> */
		/* 82169B28h case   29:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B28h case   29:*/		return 0x82169B2C;
		  /* 82169B2Ch */ case   30:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B2Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B2Ch case   30:*/		return 0x82169B30;
		  /* 82169B30h */ case   31:  		/* rlwimi R11, R10, 0, 21, 19 */
		/* 82169B30h case   31:*/		cpu::op::rlwimi<0,0,21,19>(regs,&regs.R11,regs.R10);
		/* 82169B30h case   31:*/		return 0x82169B34;
		  /* 82169B34h */ case   32:  		/* stw R11, <#[R31]> */
		/* 82169B34h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B34h case   32:*/		return 0x82169B38;
		  /* 82169B38h */ case   33:  		/* lwz R10, <#[R31]> */
		/* 82169B38h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B38h case   33:*/		return 0x82169B3C;
		  /* 82169B3Ch */ case   34:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B3Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B3Ch case   34:*/		return 0x82169B40;
		  /* 82169B40h */ case   35:  		/* rlwimi R11, R10, 0, 22, 20 */
		/* 82169B40h case   35:*/		cpu::op::rlwimi<0,0,22,20>(regs,&regs.R11,regs.R10);
		/* 82169B40h case   35:*/		return 0x82169B44;
		  /* 82169B44h */ case   36:  		/* stw R11, <#[R31]> */
		/* 82169B44h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B44h case   36:*/		return 0x82169B48;
		  /* 82169B48h */ case   37:  		/* lwz R10, <#[R31]> */
		/* 82169B48h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B48h case   37:*/		return 0x82169B4C;
		  /* 82169B4Ch */ case   38:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B4Ch case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B4Ch case   38:*/		return 0x82169B50;
		  /* 82169B50h */ case   39:  		/* rlwimi R11, R10, 0, 23, 21 */
		/* 82169B50h case   39:*/		cpu::op::rlwimi<0,0,23,21>(regs,&regs.R11,regs.R10);
		/* 82169B50h case   39:*/		return 0x82169B54;
		  /* 82169B54h */ case   40:  		/* stw R11, <#[R31]> */
		/* 82169B54h case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B54h case   40:*/		return 0x82169B58;
		  /* 82169B58h */ case   41:  		/* lwz R10, <#[R31]> */
		/* 82169B58h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B58h case   41:*/		return 0x82169B5C;
		  /* 82169B5Ch */ case   42:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B5Ch case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B5Ch case   42:*/		return 0x82169B60;
		  /* 82169B60h */ case   43:  		/* rlwimi R11, R10, 0, 24, 22 */
		/* 82169B60h case   43:*/		cpu::op::rlwimi<0,0,24,22>(regs,&regs.R11,regs.R10);
		/* 82169B60h case   43:*/		return 0x82169B64;
		  /* 82169B64h */ case   44:  		/* stw R11, <#[R31]> */
		/* 82169B64h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B64h case   44:*/		return 0x82169B68;
		  /* 82169B68h */ case   45:  		/* lwz R10, <#[R31]> */
		/* 82169B68h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B68h case   45:*/		return 0x82169B6C;
		  /* 82169B6Ch */ case   46:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B6Ch case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B6Ch case   46:*/		return 0x82169B70;
		  /* 82169B70h */ case   47:  		/* rlwimi R11, R10, 0, 25, 23 */
		/* 82169B70h case   47:*/		cpu::op::rlwimi<0,0,25,23>(regs,&regs.R11,regs.R10);
		/* 82169B70h case   47:*/		return 0x82169B74;
		  /* 82169B74h */ case   48:  		/* stw R11, <#[R31]> */
		/* 82169B74h case   48:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B74h case   48:*/		return 0x82169B78;
		  /* 82169B78h */ case   49:  		/* lwz R11, <#[R29 + 12]> */
		/* 82169B78h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82169B78h case   49:*/		return 0x82169B7C;
		  /* 82169B7Ch */ case   50:  		/* lwz R10, <#[R31]> */
		/* 82169B7Ch case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B7Ch case   50:*/		return 0x82169B80;
		  /* 82169B80h */ case   51:  		/* rlwimi R11, R10, 0, 26, 24 */
		/* 82169B80h case   51:*/		cpu::op::rlwimi<0,0,26,24>(regs,&regs.R11,regs.R10);
		/* 82169B80h case   51:*/		return 0x82169B84;
		  /* 82169B84h */ case   52:  		/* stw R11, <#[R31]> */
		/* 82169B84h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82169B84h case   52:*/		return 0x82169B88;
	}
	return 0x82169B88;
} // Block from 82169AB4h-82169B88h (53 instructions)

//////////////////////////////////////////////////////
// Block at 82169B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169B88);
		  /* 82169B88h */ case    0:  		/* addi R1, R1, 112 */
		/* 82169B88h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82169B88h case    0:*/		return 0x82169B8C;
		  /* 82169B8Ch */ case    1:  		/* b -887008 */
		/* 82169B8Ch case    1:*/		return 0x820912AC;
		/* 82169B8Ch case    1:*/		return 0x82169B90;
	}
	return 0x82169B90;
} // Block from 82169B88h-82169B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169B90);
		  /* 82169B90h */ case    0:  		/* mfspr R12, LR */
		/* 82169B90h case    0:*/		regs.R12 = regs.LR;
		/* 82169B90h case    0:*/		return 0x82169B94;
		  /* 82169B94h */ case    1:  		/* bl -887104 */
		/* 82169B94h case    1:*/		regs.LR = 0x82169B98; return 0x82091254;
		/* 82169B94h case    1:*/		return 0x82169B98;
		  /* 82169B98h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82169B98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82169B98h case    2:*/		return 0x82169B9C;
		  /* 82169B9Ch */ case    3:  		/* mr R30, R3 */
		/* 82169B9Ch case    3:*/		regs.R30 = regs.R3;
		/* 82169B9Ch case    3:*/		return 0x82169BA0;
		  /* 82169BA0h */ case    4:  		/* mr R29, R4 */
		/* 82169BA0h case    4:*/		regs.R29 = regs.R4;
		/* 82169BA0h case    4:*/		return 0x82169BA4;
		  /* 82169BA4h */ case    5:  		/* mr R28, R5 */
		/* 82169BA4h case    5:*/		regs.R28 = regs.R5;
		/* 82169BA4h case    5:*/		return 0x82169BA8;
		  /* 82169BA8h */ case    6:  		/* mr R27, R6 */
		/* 82169BA8h case    6:*/		regs.R27 = regs.R6;
		/* 82169BA8h case    6:*/		return 0x82169BAC;
		  /* 82169BACh */ case    7:  		/* mr R31, R8 */
		/* 82169BACh case    7:*/		regs.R31 = regs.R8;
		/* 82169BACh case    7:*/		return 0x82169BB0;
		  /* 82169BB0h */ case    8:  		/* cmplwi CR6, R7, 0 */
		/* 82169BB0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82169BB0h case    8:*/		return 0x82169BB4;
		  /* 82169BB4h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82169BB4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82169BC4;  }
		/* 82169BB4h case    9:*/		return 0x82169BB8;
		  /* 82169BB8h */ case   10:  		/* lis R3, -32768 */
		/* 82169BB8h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82169BB8h case   10:*/		return 0x82169BBC;
		  /* 82169BBCh */ case   11:  		/* ori R3, R3, 16389 */
		/* 82169BBCh case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82169BBCh case   11:*/		return 0x82169BC0;
		  /* 82169BC0h */ case   12:  		/* b 168 */
		/* 82169BC0h case   12:*/		return 0x82169C68;
		/* 82169BC0h case   12:*/		return 0x82169BC4;
	}
	return 0x82169BC4;
} // Block from 82169B90h-82169BC4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82169BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169BC4);
		  /* 82169BC4h */ case    0:  		/* addi R3, R1, 80 */
		/* 82169BC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82169BC4h case    0:*/		return 0x82169BC8;
		  /* 82169BC8h */ case    1:  		/* li R5, 9 */
		/* 82169BC8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 82169BC8h case    1:*/		return 0x82169BCC;
		  /* 82169BCCh */ case    2:  		/* mr R4, R7 */
		/* 82169BCCh case    2:*/		regs.R4 = regs.R7;
		/* 82169BCCh case    2:*/		return 0x82169BD0;
		  /* 82169BD0h */ case    3:  		/* bl -885280 */
		/* 82169BD0h case    3:*/		regs.LR = 0x82169BD4; return 0x820919B0;
		/* 82169BD0h case    3:*/		return 0x82169BD4;
		  /* 82169BD4h */ case    4:  		/* li R11, 0 */
		/* 82169BD4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82169BD4h case    4:*/		return 0x82169BD8;
		  /* 82169BD8h */ case    5:  		/* addi R10, R1, 80 */
		/* 82169BD8h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82169BD8h case    5:*/		return 0x82169BDC;
		  /* 82169BDCh */ case    6:  		/* lbz R9, <#[R10]> */
		/* 82169BDCh case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169BDCh case    6:*/		return 0x82169BE0;
		  /* 82169BE0h */ case    7:  		/* cmplwi CR6, R9, 35 */
		/* 82169BE0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000023);
		/* 82169BE0h case    7:*/		return 0x82169BE4;
		  /* 82169BE4h */ case    8:  		/* bc 4, CR6_LT, -44 */
		/* 82169BE4h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82169BB8;  }
		/* 82169BE4h case    8:*/		return 0x82169BE8;
		  /* 82169BE8h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 82169BE8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82169BE8h case    9:*/		return 0x82169BEC;
		  /* 82169BECh */ case   10:  		/* bc 12, CR6_EQ, -52 */
		/* 82169BECh case   10:*/		if ( regs.CR[6].eq ) { return 0x82169BB8;  }
		/* 82169BECh case   10:*/		return 0x82169BF0;
		  /* 82169BF0h */ case   11:  		/* cmplwi CR6, R9, 34 */
		/* 82169BF0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000022);
		/* 82169BF0h case   11:*/		return 0x82169BF4;
		  /* 82169BF4h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 82169BF4h case   12:*/		if ( regs.CR[6].eq ) { return 0x82169C0C;  }
		/* 82169BF4h case   12:*/		return 0x82169BF8;
		  /* 82169BF8h */ case   13:  		/* addi R11, R11, 1 */
		/* 82169BF8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169BF8h case   13:*/		return 0x82169BFC;
		  /* 82169BFCh */ case   14:  		/* addi R10, R10, 1 */
		/* 82169BFCh case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82169BFCh case   14:*/		return 0x82169C00;
		  /* 82169C00h */ case   15:  		/* cmpwi CR6, R11, 8 */
		/* 82169C00h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82169C00h case   15:*/		return 0x82169C04;
		  /* 82169C04h */ case   16:  		/* bc 12, CR6_LT, -40 */
		/* 82169C04h case   16:*/		if ( regs.CR[6].lt ) { return 0x82169BDC;  }
		/* 82169C04h case   16:*/		return 0x82169C08;
		  /* 82169C08h */ case   17:  		/* b -80 */
		/* 82169C08h case   17:*/		return 0x82169BB8;
		/* 82169C08h case   17:*/		return 0x82169C0C;
	}
	return 0x82169C0C;
} // Block from 82169BC4h-82169C0Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 82169C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169C0C);
		  /* 82169C0Ch */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82169C0Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82169C0Ch case    0:*/		return 0x82169C10;
		  /* 82169C10h */ case    1:  		/* bc 12, CR6_LT, 36 */
		/* 82169C10h case    1:*/		if ( regs.CR[6].lt ) { return 0x82169C34;  }
		/* 82169C10h case    1:*/		return 0x82169C14;
		  /* 82169C14h */ case    2:  		/* addi R10, R11, 1 */
		/* 82169C14h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 82169C14h case    2:*/		return 0x82169C18;
		  /* 82169C18h */ case    3:  		/* mtspr CTR, R10 */
		/* 82169C18h case    3:*/		regs.CTR = regs.R10;
		/* 82169C18h case    3:*/		return 0x82169C1C;
		  /* 82169C1Ch */ case    4:  		/* addi R10, R1, 81 */
		/* 82169C1Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x51);
		/* 82169C1Ch case    4:*/		return 0x82169C20;
		  /* 82169C20h */ case    5:  		/* add R10, R11, R10 */
		/* 82169C20h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82169C20h case    5:*/		return 0x82169C24;
		  /* 82169C24h */ case    6:  		/* addi R11, R11, -1 */
		/* 82169C24h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82169C24h case    6:*/		return 0x82169C28;
		  /* 82169C28h */ case    7:  		/* lbz R9, <#[R10 - 1]> */
		/* 82169C28h case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFF) );
		/* 82169C28h case    7:*/		return 0x82169C2C;
		  /* 82169C2Ch */ case    8:  		/* stb R9, <#[R10]> */
		/* 82169C2Ch case    8:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169C2Ch case    8:*/		return 0x82169C30;
		  /* 82169C30h */ case    9:  		/* bc 16, CR0_LT, -20 */
		/* 82169C30h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82169C1C;  }
		/* 82169C30h case    9:*/		return 0x82169C34;
	}
	return 0x82169C34;
} // Block from 82169C0Ch-82169C34h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82169C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169C34);
		  /* 82169C34h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82169C34h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82169C34h case    0:*/		return 0x82169C38;
		  /* 82169C38h */ case    1:  		/* bc 12, CR6_EQ, -128 */
		/* 82169C38h case    1:*/		if ( regs.CR[6].eq ) { return 0x82169BB8;  }
		/* 82169C38h case    1:*/		return 0x82169C3C;
		  /* 82169C3Ch */ case    2:  		/* cmpwi CR6, R31, 34 */
		/* 82169C3Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000022);
		/* 82169C3Ch case    2:*/		return 0x82169C40;
		  /* 82169C40h */ case    3:  		/* bc 12, CR6_EQ, -136 */
		/* 82169C40h case    3:*/		if ( regs.CR[6].eq ) { return 0x82169BB8;  }
		/* 82169C40h case    3:*/		return 0x82169C44;
		  /* 82169C44h */ case    4:  		/* cmpwi CR6, R31, 35 */
		/* 82169C44h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000023);
		/* 82169C44h case    4:*/		return 0x82169C48;
		  /* 82169C48h */ case    5:  		/* bc 4, CR6_LT, -144 */
		/* 82169C48h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82169BB8;  }
		/* 82169C48h case    5:*/		return 0x82169C4C;
		  /* 82169C4Ch */ case    6:  		/* stb R31, <#[R1 + 80]> */
		/* 82169C4Ch case    6:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82169C4Ch case    6:*/		return 0x82169C50;
		  /* 82169C50h */ case    7:  		/* addi R7, R1, 80 */
		/* 82169C50h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82169C50h case    7:*/		return 0x82169C54;
		  /* 82169C54h */ case    8:  		/* mr R6, R27 */
		/* 82169C54h case    8:*/		regs.R6 = regs.R27;
		/* 82169C54h case    8:*/		return 0x82169C58;
		  /* 82169C58h */ case    9:  		/* mr R5, R28 */
		/* 82169C58h case    9:*/		regs.R5 = regs.R28;
		/* 82169C58h case    9:*/		return 0x82169C5C;
		  /* 82169C5Ch */ case   10:  		/* mr R4, R29 */
		/* 82169C5Ch case   10:*/		regs.R4 = regs.R29;
		/* 82169C5Ch case   10:*/		return 0x82169C60;
		  /* 82169C60h */ case   11:  		/* mr R3, R30 */
		/* 82169C60h case   11:*/		regs.R3 = regs.R30;
		/* 82169C60h case   11:*/		return 0x82169C64;
		  /* 82169C64h */ case   12:  		/* bl -484 */
		/* 82169C64h case   12:*/		regs.LR = 0x82169C68; return 0x82169A80;
		/* 82169C64h case   12:*/		return 0x82169C68;
	}
	return 0x82169C68;
} // Block from 82169C34h-82169C68h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82169C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169C68);
		  /* 82169C68h */ case    0:  		/* addi R1, R1, 144 */
		/* 82169C68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82169C68h case    0:*/		return 0x82169C6C;
		  /* 82169C6Ch */ case    1:  		/* b -887240 */
		/* 82169C6Ch case    1:*/		return 0x820912A4;
		/* 82169C6Ch case    1:*/		return 0x82169C70;
	}
	return 0x82169C70;
} // Block from 82169C68h-82169C70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82169C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169C70);
		  /* 82169C70h */ case    0:  		/* mfspr R12, LR */
		/* 82169C70h case    0:*/		regs.R12 = regs.LR;
		/* 82169C70h case    0:*/		return 0x82169C74;
		  /* 82169C74h */ case    1:  		/* bl -887328 */
		/* 82169C74h case    1:*/		regs.LR = 0x82169C78; return 0x82091254;
		/* 82169C74h case    1:*/		return 0x82169C78;
		  /* 82169C78h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82169C78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82169C78h case    2:*/		return 0x82169C7C;
		  /* 82169C7Ch */ case    3:  		/* mr R30, R3 */
		/* 82169C7Ch case    3:*/		regs.R30 = regs.R3;
		/* 82169C7Ch case    3:*/		return 0x82169C80;
		  /* 82169C80h */ case    4:  		/* mr R29, R4 */
		/* 82169C80h case    4:*/		regs.R29 = regs.R4;
		/* 82169C80h case    4:*/		return 0x82169C84;
		  /* 82169C84h */ case    5:  		/* mr R28, R5 */
		/* 82169C84h case    5:*/		regs.R28 = regs.R5;
		/* 82169C84h case    5:*/		return 0x82169C88;
		  /* 82169C88h */ case    6:  		/* mr R27, R6 */
		/* 82169C88h case    6:*/		regs.R27 = regs.R6;
		/* 82169C88h case    6:*/		return 0x82169C8C;
		  /* 82169C8Ch */ case    7:  		/* mr R31, R8 */
		/* 82169C8Ch case    7:*/		regs.R31 = regs.R8;
		/* 82169C8Ch case    7:*/		return 0x82169C90;
		  /* 82169C90h */ case    8:  		/* cmplwi CR6, R7, 0 */
		/* 82169C90h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82169C90h case    8:*/		return 0x82169C94;
		  /* 82169C94h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82169C94h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82169CA4;  }
		/* 82169C94h case    9:*/		return 0x82169C98;
		  /* 82169C98h */ case   10:  		/* lis R3, -32768 */
		/* 82169C98h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82169C98h case   10:*/		return 0x82169C9C;
		  /* 82169C9Ch */ case   11:  		/* ori R3, R3, 16389 */
		/* 82169C9Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82169C9Ch case   11:*/		return 0x82169CA0;
		  /* 82169CA0h */ case   12:  		/* b 268 */
		/* 82169CA0h case   12:*/		return 0x82169DAC;
		/* 82169CA0h case   12:*/		return 0x82169CA4;
	}
	return 0x82169CA4;
} // Block from 82169C70h-82169CA4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82169CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169CA4);
		  /* 82169CA4h */ case    0:  		/* addi R3, R1, 80 */
		/* 82169CA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82169CA4h case    0:*/		return 0x82169CA8;
		  /* 82169CA8h */ case    1:  		/* li R5, 9 */
		/* 82169CA8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 82169CA8h case    1:*/		return 0x82169CAC;
		  /* 82169CACh */ case    2:  		/* mr R4, R7 */
		/* 82169CACh case    2:*/		regs.R4 = regs.R7;
		/* 82169CACh case    2:*/		return 0x82169CB0;
		  /* 82169CB0h */ case    3:  		/* bl -885504 */
		/* 82169CB0h case    3:*/		regs.LR = 0x82169CB4; return 0x820919B0;
		/* 82169CB0h case    3:*/		return 0x82169CB4;
		  /* 82169CB4h */ case    4:  		/* lbz R11, <#[R1 + 80]> */
		/* 82169CB4h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82169CB4h case    4:*/		return 0x82169CB8;
		  /* 82169CB8h */ case    5:  		/* cmplwi CR6, R11, 34 */
		/* 82169CB8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000022);
		/* 82169CB8h case    5:*/		return 0x82169CBC;
		  /* 82169CBCh */ case    6:  		/* bc 12, CR6_EQ, -36 */
		/* 82169CBCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82169C98;  }
		/* 82169CBCh case    6:*/		return 0x82169CC0;
		  /* 82169CC0h */ case    7:  		/* li R11, 0 */
		/* 82169CC0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82169CC0h case    7:*/		return 0x82169CC4;
		  /* 82169CC4h */ case    8:  		/* addi R10, R1, 80 */
		/* 82169CC4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82169CC4h case    8:*/		return 0x82169CC8;
		  /* 82169CC8h */ case    9:  		/* cmpwi CR6, R11, 8 */
		/* 82169CC8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82169CC8h case    9:*/		return 0x82169CCC;
		  /* 82169CCCh */ case   10:  		/* bc 4, CR6_LT, -52 */
		/* 82169CCCh case   10:*/		if ( !regs.CR[6].lt ) { return 0x82169C98;  }
		/* 82169CCCh case   10:*/		return 0x82169CD0;
		  /* 82169CD0h */ case   11:  		/* lbz R9, <#[R10 + 1]> */
		/* 82169CD0h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000001) );
		/* 82169CD0h case   11:*/		return 0x82169CD4;
		  /* 82169CD4h */ case   12:  		/* addi R11, R11, 1 */
		/* 82169CD4h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169CD4h case   12:*/		return 0x82169CD8;
		  /* 82169CD8h */ case   13:  		/* stb R9, <#[R10]> */
		/* 82169CD8h case   13:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169CD8h case   13:*/		return 0x82169CDC;
		  /* 82169CDCh */ case   14:  		/* lbzu R9, <#[R10 + 1]> */
		/* 82169CDCh case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 82169CDCh case   14:*/		return 0x82169CE0;
		  /* 82169CE0h */ case   15:  		/* cmplwi CR6, R9, 34 */
		/* 82169CE0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000022);
		/* 82169CE0h case   15:*/		return 0x82169CE4;
		  /* 82169CE4h */ case   16:  		/* bc 4, CR6_EQ, -28 */
		/* 82169CE4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82169CC8;  }
		/* 82169CE4h case   16:*/		return 0x82169CE8;
		  /* 82169CE8h */ case   17:  		/* cmpwi CR6, R11, 9 */
		/* 82169CE8h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 82169CE8h case   17:*/		return 0x82169CEC;
		  /* 82169CECh */ case   18:  		/* bc 4, CR6_LT, 44 */
		/* 82169CECh case   18:*/		if ( !regs.CR[6].lt ) { return 0x82169D18;  }
		/* 82169CECh case   18:*/		return 0x82169CF0;
		  /* 82169CF0h */ case   19:  		/* addi R9, R1, 80 */
		/* 82169CF0h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 82169CF0h case   19:*/		return 0x82169CF4;
		  /* 82169CF4h */ case   20:  		/* subfic R10, R11, 9 */
		/* 82169CF4h case   20:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R11,0x9);
		/* 82169CF4h case   20:*/		return 0x82169CF8;
		  /* 82169CF8h */ case   21:  		/* add R11, R11, R9 */
		/* 82169CF8h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82169CF8h case   21:*/		return 0x82169CFC;
		  /* 82169CFCh */ case   22:  		/* li R9, 0 */
		/* 82169CFCh case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82169CFCh case   22:*/		return 0x82169D00;
		  /* 82169D00h */ case   23:  		/* addi R11, R11, -1 */
		/* 82169D00h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82169D00h case   23:*/		return 0x82169D04;
		  /* 82169D04h */ case   24:  		/* cmplwi CR6, R10, 0 */
		/* 82169D04h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82169D04h case   24:*/		return 0x82169D08;
		  /* 82169D08h */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 82169D08h case   25:*/		if ( regs.CR[6].eq ) { return 0x82169D18;  }
		/* 82169D08h case   25:*/		return 0x82169D0C;
		  /* 82169D0Ch */ case   26:  		/* mtspr CTR, R10 */
		/* 82169D0Ch case   26:*/		regs.CTR = regs.R10;
		/* 82169D0Ch case   26:*/		return 0x82169D10;
		  /* 82169D10h */ case   27:  		/* stbu R9, <#[R11 + 1]> */
		/* 82169D10h case   27:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82169D10h case   27:*/		return 0x82169D14;
		  /* 82169D14h */ case   28:  		/* bc 16, CR0_LT, -4 */
		/* 82169D14h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82169D10;  }
		/* 82169D14h case   28:*/		return 0x82169D18;
	}
	return 0x82169D18;
} // Block from 82169CA4h-82169D18h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82169D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169D18);
		  /* 82169D18h */ case    0:  		/* li R11, 0 */
		/* 82169D18h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82169D18h case    0:*/		return 0x82169D1C;
		  /* 82169D1Ch */ case    1:  		/* addi R10, R1, 80 */
		/* 82169D1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82169D1Ch case    1:*/		return 0x82169D20;
		  /* 82169D20h */ case    2:  		/* lbz R9, <#[R10]> */
		/* 82169D20h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169D20h case    2:*/		return 0x82169D24;
		  /* 82169D24h */ case    3:  		/* cmplwi CR6, R9, 35 */
		/* 82169D24h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000023);
		/* 82169D24h case    3:*/		return 0x82169D28;
		  /* 82169D28h */ case    4:  		/* bc 4, CR6_LT, -144 */
		/* 82169D28h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82169C98;  }
		/* 82169D28h case    4:*/		return 0x82169D2C;
		  /* 82169D2Ch */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 82169D2Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82169D2Ch case    5:*/		return 0x82169D30;
		  /* 82169D30h */ case    6:  		/* bc 12, CR6_EQ, -152 */
		/* 82169D30h case    6:*/		if ( regs.CR[6].eq ) { return 0x82169C98;  }
		/* 82169D30h case    6:*/		return 0x82169D34;
		  /* 82169D34h */ case    7:  		/* cmplwi CR6, R9, 34 */
		/* 82169D34h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000022);
		/* 82169D34h case    7:*/		return 0x82169D38;
		  /* 82169D38h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 82169D38h case    8:*/		if ( regs.CR[6].eq ) { return 0x82169D50;  }
		/* 82169D38h case    8:*/		return 0x82169D3C;
		  /* 82169D3Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 82169D3Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169D3Ch case    9:*/		return 0x82169D40;
		  /* 82169D40h */ case   10:  		/* addi R10, R10, 1 */
		/* 82169D40h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82169D40h case   10:*/		return 0x82169D44;
		  /* 82169D44h */ case   11:  		/* cmpwi CR6, R11, 8 */
		/* 82169D44h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82169D44h case   11:*/		return 0x82169D48;
		  /* 82169D48h */ case   12:  		/* bc 12, CR6_LT, -40 */
		/* 82169D48h case   12:*/		if ( regs.CR[6].lt ) { return 0x82169D20;  }
		/* 82169D48h case   12:*/		return 0x82169D4C;
		  /* 82169D4Ch */ case   13:  		/* b -180 */
		/* 82169D4Ch case   13:*/		return 0x82169C98;
		/* 82169D4Ch case   13:*/		return 0x82169D50;
	}
	return 0x82169D50;
} // Block from 82169D18h-82169D50h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82169D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169D50);
		  /* 82169D50h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82169D50h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82169D50h case    0:*/		return 0x82169D54;
		  /* 82169D54h */ case    1:  		/* bc 12, CR6_LT, 36 */
		/* 82169D54h case    1:*/		if ( regs.CR[6].lt ) { return 0x82169D78;  }
		/* 82169D54h case    1:*/		return 0x82169D58;
		  /* 82169D58h */ case    2:  		/* addi R10, R11, 1 */
		/* 82169D58h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 82169D58h case    2:*/		return 0x82169D5C;
		  /* 82169D5Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 82169D5Ch case    3:*/		regs.CTR = regs.R10;
		/* 82169D5Ch case    3:*/		return 0x82169D60;
		  /* 82169D60h */ case    4:  		/* addi R10, R1, 81 */
		/* 82169D60h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x51);
		/* 82169D60h case    4:*/		return 0x82169D64;
		  /* 82169D64h */ case    5:  		/* add R10, R11, R10 */
		/* 82169D64h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82169D64h case    5:*/		return 0x82169D68;
		  /* 82169D68h */ case    6:  		/* addi R11, R11, -1 */
		/* 82169D68h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82169D68h case    6:*/		return 0x82169D6C;
		  /* 82169D6Ch */ case    7:  		/* lbz R9, <#[R10 - 1]> */
		/* 82169D6Ch case    7:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFFFF) );
		/* 82169D6Ch case    7:*/		return 0x82169D70;
		  /* 82169D70h */ case    8:  		/* stb R9, <#[R10]> */
		/* 82169D70h case    8:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169D70h case    8:*/		return 0x82169D74;
		  /* 82169D74h */ case    9:  		/* bc 16, CR0_LT, -20 */
		/* 82169D74h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82169D60;  }
		/* 82169D74h case    9:*/		return 0x82169D78;
	}
	return 0x82169D78;
} // Block from 82169D50h-82169D78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82169D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169D78);
		  /* 82169D78h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82169D78h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82169D78h case    0:*/		return 0x82169D7C;
		  /* 82169D7Ch */ case    1:  		/* bc 12, CR6_EQ, -228 */
		/* 82169D7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82169C98;  }
		/* 82169D7Ch case    1:*/		return 0x82169D80;
		  /* 82169D80h */ case    2:  		/* cmpwi CR6, R31, 34 */
		/* 82169D80h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000022);
		/* 82169D80h case    2:*/		return 0x82169D84;
		  /* 82169D84h */ case    3:  		/* bc 12, CR6_EQ, -236 */
		/* 82169D84h case    3:*/		if ( regs.CR[6].eq ) { return 0x82169C98;  }
		/* 82169D84h case    3:*/		return 0x82169D88;
		  /* 82169D88h */ case    4:  		/* cmpwi CR6, R31, 35 */
		/* 82169D88h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000023);
		/* 82169D88h case    4:*/		return 0x82169D8C;
		  /* 82169D8Ch */ case    5:  		/* bc 4, CR6_LT, -244 */
		/* 82169D8Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x82169C98;  }
		/* 82169D8Ch case    5:*/		return 0x82169D90;
		  /* 82169D90h */ case    6:  		/* stb R31, <#[R1 + 80]> */
		/* 82169D90h case    6:*/		cpu::mem::store8( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82169D90h case    6:*/		return 0x82169D94;
		  /* 82169D94h */ case    7:  		/* addi R7, R1, 80 */
		/* 82169D94h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82169D94h case    7:*/		return 0x82169D98;
		  /* 82169D98h */ case    8:  		/* mr R6, R27 */
		/* 82169D98h case    8:*/		regs.R6 = regs.R27;
		/* 82169D98h case    8:*/		return 0x82169D9C;
		  /* 82169D9Ch */ case    9:  		/* mr R5, R28 */
		/* 82169D9Ch case    9:*/		regs.R5 = regs.R28;
		/* 82169D9Ch case    9:*/		return 0x82169DA0;
		  /* 82169DA0h */ case   10:  		/* mr R4, R29 */
		/* 82169DA0h case   10:*/		regs.R4 = regs.R29;
		/* 82169DA0h case   10:*/		return 0x82169DA4;
		  /* 82169DA4h */ case   11:  		/* mr R3, R30 */
		/* 82169DA4h case   11:*/		regs.R3 = regs.R30;
		/* 82169DA4h case   11:*/		return 0x82169DA8;
		  /* 82169DA8h */ case   12:  		/* bl -808 */
		/* 82169DA8h case   12:*/		regs.LR = 0x82169DAC; return 0x82169A80;
		/* 82169DA8h case   12:*/		return 0x82169DAC;
	}
	return 0x82169DAC;
} // Block from 82169D78h-82169DACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82169DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169DAC);
		  /* 82169DACh */ case    0:  		/* addi R1, R1, 144 */
		/* 82169DACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82169DACh case    0:*/		return 0x82169DB0;
		  /* 82169DB0h */ case    1:  		/* b -887564 */
		/* 82169DB0h case    1:*/		return 0x820912A4;
		/* 82169DB0h case    1:*/		return 0x82169DB4;
		  /* 82169DB4h */ case    2:  		/* nop */
		/* 82169DB4h case    2:*/		cpu::op::nop();
		/* 82169DB4h case    2:*/		return 0x82169DB8;
	}
	return 0x82169DB8;
} // Block from 82169DACh-82169DB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82169DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169DB8);
		  /* 82169DB8h */ case    0:  		/* mfspr R12, LR */
		/* 82169DB8h case    0:*/		regs.R12 = regs.LR;
		/* 82169DB8h case    0:*/		return 0x82169DBC;
		  /* 82169DBCh */ case    1:  		/* bl -887652 */
		/* 82169DBCh case    1:*/		regs.LR = 0x82169DC0; return 0x82091258;
		/* 82169DBCh case    1:*/		return 0x82169DC0;
		  /* 82169DC0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82169DC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82169DC0h case    2:*/		return 0x82169DC4;
		  /* 82169DC4h */ case    3:  		/* mr R31, R3 */
		/* 82169DC4h case    3:*/		regs.R31 = regs.R3;
		/* 82169DC4h case    3:*/		return 0x82169DC8;
		  /* 82169DC8h */ case    4:  		/* mr R30, R4 */
		/* 82169DC8h case    4:*/		regs.R30 = regs.R4;
		/* 82169DC8h case    4:*/		return 0x82169DCC;
		  /* 82169DCCh */ case    5:  		/* mr R29, R5 */
		/* 82169DCCh case    5:*/		regs.R29 = regs.R5;
		/* 82169DCCh case    5:*/		return 0x82169DD0;
		  /* 82169DD0h */ case    6:  		/* mr R28, R6 */
		/* 82169DD0h case    6:*/		regs.R28 = regs.R6;
		/* 82169DD0h case    6:*/		return 0x82169DD4;
		  /* 82169DD4h */ case    7:  		/* cmplwi CR6, R7, 0 */
		/* 82169DD4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82169DD4h case    7:*/		return 0x82169DD8;
		  /* 82169DD8h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82169DD8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82169DE8;  }
		/* 82169DD8h case    8:*/		return 0x82169DDC;
		  /* 82169DDCh */ case    9:  		/* lis R3, -32768 */
		/* 82169DDCh case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82169DDCh case    9:*/		return 0x82169DE0;
		  /* 82169DE0h */ case   10:  		/* ori R3, R3, 16389 */
		/* 82169DE0h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82169DE0h case   10:*/		return 0x82169DE4;
		  /* 82169DE4h */ case   11:  		/* b 144 */
		/* 82169DE4h case   11:*/		return 0x82169E74;
		/* 82169DE4h case   11:*/		return 0x82169DE8;
	}
	return 0x82169DE8;
} // Block from 82169DB8h-82169DE8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82169DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169DE8);
		  /* 82169DE8h */ case    0:  		/* addi R3, R1, 80 */
		/* 82169DE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82169DE8h case    0:*/		return 0x82169DEC;
		  /* 82169DECh */ case    1:  		/* li R5, 9 */
		/* 82169DECh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 82169DECh case    1:*/		return 0x82169DF0;
		  /* 82169DF0h */ case    2:  		/* mr R4, R7 */
		/* 82169DF0h case    2:*/		regs.R4 = regs.R7;
		/* 82169DF0h case    2:*/		return 0x82169DF4;
		  /* 82169DF4h */ case    3:  		/* bl -885828 */
		/* 82169DF4h case    3:*/		regs.LR = 0x82169DF8; return 0x820919B0;
		/* 82169DF4h case    3:*/		return 0x82169DF8;
		  /* 82169DF8h */ case    4:  		/* lbz R11, <#[R1 + 80]> */
		/* 82169DF8h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82169DF8h case    4:*/		return 0x82169DFC;
		  /* 82169DFCh */ case    5:  		/* cmplwi CR6, R11, 34 */
		/* 82169DFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000022);
		/* 82169DFCh case    5:*/		return 0x82169E00;
		  /* 82169E00h */ case    6:  		/* bc 12, CR6_EQ, -36 */
		/* 82169E00h case    6:*/		if ( regs.CR[6].eq ) { return 0x82169DDC;  }
		/* 82169E00h case    6:*/		return 0x82169E04;
		  /* 82169E04h */ case    7:  		/* li R11, 0 */
		/* 82169E04h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82169E04h case    7:*/		return 0x82169E08;
		  /* 82169E08h */ case    8:  		/* addi R10, R1, 80 */
		/* 82169E08h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82169E08h case    8:*/		return 0x82169E0C;
		  /* 82169E0Ch */ case    9:  		/* cmpwi CR6, R11, 8 */
		/* 82169E0Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 82169E0Ch case    9:*/		return 0x82169E10;
		  /* 82169E10h */ case   10:  		/* bc 4, CR6_LT, -52 */
		/* 82169E10h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82169DDC;  }
		/* 82169E10h case   10:*/		return 0x82169E14;
		  /* 82169E14h */ case   11:  		/* lbz R9, <#[R10 + 1]> */
		/* 82169E14h case   11:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000001) );
		/* 82169E14h case   11:*/		return 0x82169E18;
		  /* 82169E18h */ case   12:  		/* addi R11, R11, 1 */
		/* 82169E18h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169E18h case   12:*/		return 0x82169E1C;
		  /* 82169E1Ch */ case   13:  		/* stb R9, <#[R10]> */
		/* 82169E1Ch case   13:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169E1Ch case   13:*/		return 0x82169E20;
		  /* 82169E20h */ case   14:  		/* lbzu R9, <#[R10 + 1]> */
		/* 82169E20h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000001) );
		regs.R10 = (uint32)(regs.R10 + 0x00000001);
		/* 82169E20h case   14:*/		return 0x82169E24;
		  /* 82169E24h */ case   15:  		/* cmplwi CR6, R9, 34 */
		/* 82169E24h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000022);
		/* 82169E24h case   15:*/		return 0x82169E28;
		  /* 82169E28h */ case   16:  		/* bc 4, CR6_EQ, -28 */
		/* 82169E28h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82169E0C;  }
		/* 82169E28h case   16:*/		return 0x82169E2C;
		  /* 82169E2Ch */ case   17:  		/* cmpwi CR6, R11, 9 */
		/* 82169E2Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 82169E2Ch case   17:*/		return 0x82169E30;
		  /* 82169E30h */ case   18:  		/* bc 4, CR6_LT, 44 */
		/* 82169E30h case   18:*/		if ( !regs.CR[6].lt ) { return 0x82169E5C;  }
		/* 82169E30h case   18:*/		return 0x82169E34;
		  /* 82169E34h */ case   19:  		/* addi R9, R1, 80 */
		/* 82169E34h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 82169E34h case   19:*/		return 0x82169E38;
		  /* 82169E38h */ case   20:  		/* subfic R10, R11, 9 */
		/* 82169E38h case   20:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R11,0x9);
		/* 82169E38h case   20:*/		return 0x82169E3C;
		  /* 82169E3Ch */ case   21:  		/* add R11, R11, R9 */
		/* 82169E3Ch case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82169E3Ch case   21:*/		return 0x82169E40;
		  /* 82169E40h */ case   22:  		/* li R9, 0 */
		/* 82169E40h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82169E40h case   22:*/		return 0x82169E44;
		  /* 82169E44h */ case   23:  		/* addi R11, R11, -1 */
		/* 82169E44h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82169E44h case   23:*/		return 0x82169E48;
		  /* 82169E48h */ case   24:  		/* cmplwi CR6, R10, 0 */
		/* 82169E48h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82169E48h case   24:*/		return 0x82169E4C;
		  /* 82169E4Ch */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 82169E4Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x82169E5C;  }
		/* 82169E4Ch case   25:*/		return 0x82169E50;
		  /* 82169E50h */ case   26:  		/* mtspr CTR, R10 */
		/* 82169E50h case   26:*/		regs.CTR = regs.R10;
		/* 82169E50h case   26:*/		return 0x82169E54;
		  /* 82169E54h */ case   27:  		/* stbu R9, <#[R11 + 1]> */
		/* 82169E54h case   27:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00000001) );
		regs.R11 = (uint32)(regs.R11 + 0x00000001);
		/* 82169E54h case   27:*/		return 0x82169E58;
		  /* 82169E58h */ case   28:  		/* bc 16, CR0_LT, -4 */
		/* 82169E58h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82169E54;  }
		/* 82169E58h case   28:*/		return 0x82169E5C;
	}
	return 0x82169E5C;
} // Block from 82169DE8h-82169E5Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 82169E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169E5C);
		  /* 82169E5Ch */ case    0:  		/* addi R7, R1, 80 */
		/* 82169E5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 82169E5Ch case    0:*/		return 0x82169E60;
		  /* 82169E60h */ case    1:  		/* mr R6, R28 */
		/* 82169E60h case    1:*/		regs.R6 = regs.R28;
		/* 82169E60h case    1:*/		return 0x82169E64;
		  /* 82169E64h */ case    2:  		/* mr R5, R29 */
		/* 82169E64h case    2:*/		regs.R5 = regs.R29;
		/* 82169E64h case    2:*/		return 0x82169E68;
		  /* 82169E68h */ case    3:  		/* mr R4, R30 */
		/* 82169E68h case    3:*/		regs.R4 = regs.R30;
		/* 82169E68h case    3:*/		return 0x82169E6C;
		  /* 82169E6Ch */ case    4:  		/* mr R3, R31 */
		/* 82169E6Ch case    4:*/		regs.R3 = regs.R31;
		/* 82169E6Ch case    4:*/		return 0x82169E70;
		  /* 82169E70h */ case    5:  		/* bl -1008 */
		/* 82169E70h case    5:*/		regs.LR = 0x82169E74; return 0x82169A80;
		/* 82169E70h case    5:*/		return 0x82169E74;
	}
	return 0x82169E74;
} // Block from 82169E5Ch-82169E74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82169E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169E74);
		  /* 82169E74h */ case    0:  		/* addi R1, R1, 144 */
		/* 82169E74h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82169E74h case    0:*/		return 0x82169E78;
		  /* 82169E78h */ case    1:  		/* b -887760 */
		/* 82169E78h case    1:*/		return 0x820912A8;
		/* 82169E78h case    1:*/		return 0x82169E7C;
		  /* 82169E7Ch */ case    2:  		/* nop */
		/* 82169E7Ch case    2:*/		cpu::op::nop();
		/* 82169E7Ch case    2:*/		return 0x82169E80;
		  /* 82169E80h */ case    3:  		/* mulli R11, R4, 12 */
		/* 82169E80h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0xC);
		/* 82169E80h case    3:*/		return 0x82169E84;
		  /* 82169E84h */ case    4:  		/* lwzx R10, <#[R11 + R3]> */
		/* 82169E84h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82169E84h case    4:*/		return 0x82169E88;
		  /* 82169E88h */ case    5:  		/* add R8, R11, R3 */
		/* 82169E88h case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R3);
		/* 82169E88h case    5:*/		return 0x82169E8C;
		  /* 82169E8Ch */ case    6:  		/* rlwinm. R11, R10, 0, 13, 13 */
		/* 82169E8Ch case    6:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R10);
		/* 82169E8Ch case    6:*/		return 0x82169E90;
		  /* 82169E90h */ case    7:  		/* bc 4, CR0_EQ, 360 */
		/* 82169E90h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82169FF8;  }
		/* 82169E90h case    7:*/		return 0x82169E94;
		  /* 82169E94h */ case    8:  		/* rlwinm. R11, R10, 0, 20, 20 */
		/* 82169E94h case    8:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R10);
		/* 82169E94h case    8:*/		return 0x82169E98;
		  /* 82169E98h */ case    9:  		/* bc 4, CR0_EQ, 352 */
		/* 82169E98h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82169FF8;  }
		/* 82169E98h case    9:*/		return 0x82169E9C;
		  /* 82169E9Ch */ case   10:  		/* lwz R11, <#[R5 + 32]> */
		/* 82169E9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000020) );
		/* 82169E9Ch case   10:*/		return 0x82169EA0;
		  /* 82169EA0h */ case   11:  		/* rlwinm R9, R10, 20, 26, 31 */
		/* 82169EA0h case   11:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R9,regs.R10);
		/* 82169EA0h case   11:*/		return 0x82169EA4;
		  /* 82169EA4h */ case   12:  		/* cmplw CR6, R9, R11 */
		/* 82169EA4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82169EA4h case   12:*/		return 0x82169EA8;
		  /* 82169EA8h */ case   13:  		/* bc 12, CR6_GT, 336 */
		/* 82169EA8h case   13:*/		if ( regs.CR[6].gt ) { return 0x82169FF8;  }
		/* 82169EA8h case   13:*/		return 0x82169EAC;
		  /* 82169EACh */ case   14:  		/* rlwinm R9, R10, 27, 26, 31 */
		/* 82169EACh case   14:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R9,regs.R10);
		/* 82169EACh case   14:*/		return 0x82169EB0;
		  /* 82169EB0h */ case   15:  		/* cmplw CR6, R9, R11 */
		/* 82169EB0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82169EB0h case   15:*/		return 0x82169EB4;
		  /* 82169EB4h */ case   16:  		/* bc 12, CR6_GT, 324 */
		/* 82169EB4h case   16:*/		if ( regs.CR[6].gt ) { return 0x82169FF8;  }
		/* 82169EB4h case   16:*/		return 0x82169EB8;
		  /* 82169EB8h */ case   17:  		/* lwz R9, <#[R8 + 4]> */
		/* 82169EB8h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000004) );
		/* 82169EB8h case   17:*/		return 0x82169EBC;
		  /* 82169EBCh */ case   18:  		/* rlwinm R11, R10, 0, 27, 31 */
		/* 82169EBCh case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R10);
		/* 82169EBCh case   18:*/		return 0x82169EC0;
		  /* 82169EC0h */ case   19:  		/* rlwinm R7, R9, 0, 29, 31 */
		/* 82169EC0h case   19:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R7,regs.R9);
		/* 82169EC0h case   19:*/		return 0x82169EC4;
		  /* 82169EC4h */ case   20:  		/* rlwinm R6, R9, 29, 29, 31 */
		/* 82169EC4h case   20:*/		cpu::op::rlwinm<0,29,29,31>(regs,&regs.R6,regs.R9);
		/* 82169EC4h case   20:*/		return 0x82169EC8;
		  /* 82169EC8h */ case   21:  		/* rlwinm R4, R9, 26, 29, 31 */
		/* 82169EC8h case   21:*/		cpu::op::rlwinm<0,26,29,31>(regs,&regs.R4,regs.R9);
		/* 82169EC8h case   21:*/		return 0x82169ECC;
		  /* 82169ECCh */ case   22:  		/* stw R7, <#[R1 - 16]> */
		/* 82169ECCh case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82169ECCh case   22:*/		return 0x82169ED0;
		  /* 82169ED0h */ case   23:  		/* rlwinm R9, R9, 23, 29, 31 */
		/* 82169ED0h case   23:*/		cpu::op::rlwinm<0,23,29,31>(regs,&regs.R9,regs.R9);
		/* 82169ED0h case   23:*/		return 0x82169ED4;
		  /* 82169ED4h */ case   24:  		/* stw R6, <#[R1 - 12]> */
		/* 82169ED4h case   24:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82169ED4h case   24:*/		return 0x82169ED8;
		  /* 82169ED8h */ case   25:  		/* cmplwi CR6, R11, 1 */
		/* 82169ED8h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82169ED8h case   25:*/		return 0x82169EDC;
		  /* 82169EDCh */ case   26:  		/* stw R4, <#[R1 - 8]> */
		/* 82169EDCh case   26:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82169EDCh case   26:*/		return 0x82169EE0;
		  /* 82169EE0h */ case   27:  		/* stw R9, <#[R1 - 4]> */
		/* 82169EE0h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 82169EE0h case   27:*/		return 0x82169EE4;
		  /* 82169EE4h */ case   28:  		/* bc 12, CR6_EQ, 72 */
		/* 82169EE4h case   28:*/		if ( regs.CR[6].eq ) { return 0x82169F2C;  }
		/* 82169EE4h case   28:*/		return 0x82169EE8;
		  /* 82169EE8h */ case   29:  		/* cmplwi CR6, R11, 15 */
		/* 82169EE8h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82169EE8h case   29:*/		return 0x82169EEC;
		  /* 82169EECh */ case   30:  		/* bc 4, CR6_GT, 268 */
		/* 82169EECh case   30:*/		if ( !regs.CR[6].gt ) { return 0x82169FF8;  }
		/* 82169EECh case   30:*/		return 0x82169EF0;
		  /* 82169EF0h */ case   31:  		/* cmplwi CR6, R11, 19 */
		/* 82169EF0h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 82169EF0h case   31:*/		return 0x82169EF4;
		  /* 82169EF4h */ case   32:  		/* bc 4, CR6_GT, 56 */
		/* 82169EF4h case   32:*/		if ( !regs.CR[6].gt ) { return 0x82169F2C;  }
		/* 82169EF4h case   32:*/		return 0x82169EF8;
		  /* 82169EF8h */ case   33:  		/* cmplwi CR6, R11, 23 */
		/* 82169EF8h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 82169EF8h case   33:*/		return 0x82169EFC;
		  /* 82169EFCh */ case   34:  		/* bc 4, CR6_GT, 252 */
		/* 82169EFCh case   34:*/		if ( !regs.CR[6].gt ) { return 0x82169FF8;  }
		/* 82169EFCh case   34:*/		return 0x82169F00;
		  /* 82169F00h */ case   35:  		/* cmplwi CR6, R11, 26 */
		/* 82169F00h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001A);
		/* 82169F00h case   35:*/		return 0x82169F04;
		  /* 82169F04h */ case   36:  		/* bc 12, CR6_GT, 244 */
		/* 82169F04h case   36:*/		if ( regs.CR[6].gt ) { return 0x82169FF8;  }
		/* 82169F04h case   36:*/		return 0x82169F08;
		  /* 82169F08h */ case   37:  		/* li R11, 0 */
		/* 82169F08h case   37:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82169F08h case   37:*/		return 0x82169F0C;
		  /* 82169F0Ch */ case   38:  		/* addi R9, R1, -16 */
		/* 82169F0Ch case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFFF0);
		/* 82169F0Ch case   38:*/		return 0x82169F10;
		  /* 82169F10h */ case   39:  		/* lwz R7, <#[R9]> */
		/* 82169F10h case   39:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 82169F10h case   39:*/		return 0x82169F14;
		  /* 82169F14h */ case   40:  		/* cmpwi CR6, R7, 7 */
		/* 82169F14h case   40:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000007);
		/* 82169F14h case   40:*/		return 0x82169F18;
		  /* 82169F18h */ case   41:  		/* bc 4, CR6_EQ, 224 */
		/* 82169F18h case   41:*/		if ( !regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169F18h case   41:*/		return 0x82169F1C;
		  /* 82169F1Ch */ case   42:  		/* addi R11, R11, 1 */
		/* 82169F1Ch case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169F1Ch case   42:*/		return 0x82169F20;
		  /* 82169F20h */ case   43:  		/* addi R9, R9, 4 */
		/* 82169F20h case   43:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82169F20h case   43:*/		return 0x82169F24;
		  /* 82169F24h */ case   44:  		/* cmpwi CR6, R11, 4 */
		/* 82169F24h case   44:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82169F24h case   44:*/		return 0x82169F28;
		  /* 82169F28h */ case   45:  		/* bc 12, CR6_LT, -24 */
		/* 82169F28h case   45:*/		if ( regs.CR[6].lt ) { return 0x82169F10;  }
		/* 82169F28h case   45:*/		return 0x82169F2C;
	}
	return 0x82169F2C;
} // Block from 82169E74h-82169F2Ch (46 instructions)

//////////////////////////////////////////////////////
// Block at 82169F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169F2C);
		  /* 82169F2Ch */ case    0:  		/* rlwinm. R11, R10, 0, 12, 12 */
		/* 82169F2Ch case    0:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R10);
		/* 82169F2Ch case    0:*/		return 0x82169F30;
		  /* 82169F30h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82169F30h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82169F40;  }
		/* 82169F30h case    1:*/		return 0x82169F34;
		  /* 82169F34h */ case    2:  		/* lbz R11, <#[R5 + 40]> */
		/* 82169F34h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000028) );
		/* 82169F34h case    2:*/		return 0x82169F38;
		  /* 82169F38h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82169F38h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82169F38h case    3:*/		return 0x82169F3C;
		  /* 82169F3Ch */ case    4:  		/* bc 12, CR0_EQ, 188 */
		/* 82169F3Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82169FF8;  }
		/* 82169F3Ch case    4:*/		return 0x82169F40;
	}
	return 0x82169F40;
} // Block from 82169F2Ch-82169F40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82169F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169F40);
		  /* 82169F40h */ case    0:  		/* li R11, 0 */
		/* 82169F40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82169F40h case    0:*/		return 0x82169F44;
		  /* 82169F44h */ case    1:  		/* addi R10, R1, -16 */
		/* 82169F44h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFFF0);
		/* 82169F44h case    1:*/		return 0x82169F48;
		  /* 82169F48h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 82169F48h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82169F48h case    2:*/		return 0x82169F4C;
		  /* 82169F4Ch */ case    3:  		/* cmplwi CR6, R9, 6 */
		/* 82169F4Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000006);
		/* 82169F4Ch case    3:*/		return 0x82169F50;
		  /* 82169F50h */ case    4:  		/* bc 12, CR6_EQ, 168 */
		/* 82169F50h case    4:*/		if ( regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169F50h case    4:*/		return 0x82169F54;
		  /* 82169F54h */ case    5:  		/* addi R11, R11, 1 */
		/* 82169F54h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82169F54h case    5:*/		return 0x82169F58;
		  /* 82169F58h */ case    6:  		/* addi R10, R10, 4 */
		/* 82169F58h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82169F58h case    6:*/		return 0x82169F5C;
		  /* 82169F5Ch */ case    7:  		/* cmpwi CR6, R11, 4 */
		/* 82169F5Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82169F5Ch case    7:*/		return 0x82169F60;
		  /* 82169F60h */ case    8:  		/* bc 12, CR6_LT, -24 */
		/* 82169F60h case    8:*/		if ( regs.CR[6].lt ) { return 0x82169F48;  }
		/* 82169F60h case    8:*/		return 0x82169F64;
		  /* 82169F64h */ case    9:  		/* lwz R11, <#[R8 + 4]> */
		/* 82169F64h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82169F64h case    9:*/		return 0x82169F68;
		  /* 82169F68h */ case   10:  		/* rlwinm R10, R11, 0, 18, 19 */
		/* 82169F68h case   10:*/		cpu::op::rlwinm<0,0,18,19>(regs,&regs.R10,regs.R11);
		/* 82169F68h case   10:*/		return 0x82169F6C;
		  /* 82169F6Ch */ case   11:  		/* cmplwi CR6, R10, 8192 */
		/* 82169F6Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002000);
		/* 82169F6Ch case   11:*/		return 0x82169F70;
		  /* 82169F70h */ case   12:  		/* bc 12, CR6_EQ, 136 */
		/* 82169F70h case   12:*/		if ( regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169F70h case   12:*/		return 0x82169F74;
		  /* 82169F74h */ case   13:  		/* rlwinm R10, R11, 0, 16, 17 */
		/* 82169F74h case   13:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R10,regs.R11);
		/* 82169F74h case   13:*/		return 0x82169F78;
		  /* 82169F78h */ case   14:  		/* cmplwi CR6, R10, 32768 */
		/* 82169F78h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00008000);
		/* 82169F78h case   14:*/		return 0x82169F7C;
		  /* 82169F7Ch */ case   15:  		/* bc 12, CR6_EQ, 124 */
		/* 82169F7Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169F7Ch case   15:*/		return 0x82169F80;
		  /* 82169F80h */ case   16:  		/* rlwinm R10, R11, 14, 29, 31 */
		/* 82169F80h case   16:*/		cpu::op::rlwinm<0,14,29,31>(regs,&regs.R10,regs.R11);
		/* 82169F80h case   16:*/		return 0x82169F84;
		  /* 82169F84h */ case   17:  		/* cmplwi CR6, R10, 6 */
		/* 82169F84h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000006);
		/* 82169F84h case   17:*/		return 0x82169F88;
		  /* 82169F88h */ case   18:  		/* bc 12, CR6_EQ, 112 */
		/* 82169F88h case   18:*/		if ( regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169F88h case   18:*/		return 0x82169F8C;
		  /* 82169F8Ch */ case   19:  		/* cmplwi CR6, R10, 0 */
		/* 82169F8Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82169F8Ch case   19:*/		return 0x82169F90;
		  /* 82169F90h */ case   20:  		/* bc 12, CR6_EQ, 24 */
		/* 82169F90h case   20:*/		if ( regs.CR[6].eq ) { return 0x82169FA8;  }
		/* 82169F90h case   20:*/		return 0x82169F94;
		  /* 82169F94h */ case   21:  		/* cmplwi CR6, R10, 7 */
		/* 82169F94h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 82169F94h case   21:*/		return 0x82169F98;
		  /* 82169F98h */ case   22:  		/* bc 4, CR6_LT, 16 */
		/* 82169F98h case   22:*/		if ( !regs.CR[6].lt ) { return 0x82169FA8;  }
		/* 82169F98h case   22:*/		return 0x82169F9C;
		  /* 82169F9Ch */ case   23:  		/* lbz R10, <#[R5 + 40]> */
		/* 82169F9Ch case   23:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000028) );
		/* 82169F9Ch case   23:*/		return 0x82169FA0;
		  /* 82169FA0h */ case   24:  		/* cmplwi CR0, R10, 0 */
		/* 82169FA0h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82169FA0h case   24:*/		return 0x82169FA4;
		  /* 82169FA4h */ case   25:  		/* bc 12, CR0_EQ, 84 */
		/* 82169FA4h case   25:*/		if ( regs.CR[0].eq ) { return 0x82169FF8;  }
		/* 82169FA4h case   25:*/		return 0x82169FA8;
	}
	return 0x82169FA8;
} // Block from 82169F40h-82169FA8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82169FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169FA8);
		  /* 82169FA8h */ case    0:  		/* rlwinm R10, R11, 0, 6, 7 */
		/* 82169FA8h case    0:*/		cpu::op::rlwinm<0,0,6,7>(regs,&regs.R10,regs.R11);
		/* 82169FA8h case    0:*/		return 0x82169FAC;
		  /* 82169FACh */ case    1:  		/* lis R9, 512 */
		/* 82169FACh case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x200);
		/* 82169FACh case    1:*/		return 0x82169FB0;
		  /* 82169FB0h */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 82169FB0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82169FB0h case    2:*/		return 0x82169FB4;
		  /* 82169FB4h */ case    3:  		/* bc 12, CR6_EQ, 68 */
		/* 82169FB4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169FB4h case    3:*/		return 0x82169FB8;
		  /* 82169FB8h */ case    4:  		/* rlwinm R10, R11, 0, 4, 5 */
		/* 82169FB8h case    4:*/		cpu::op::rlwinm<0,0,4,5>(regs,&regs.R10,regs.R11);
		/* 82169FB8h case    4:*/		return 0x82169FBC;
		  /* 82169FBCh */ case    5:  		/* lis R9, 2048 */
		/* 82169FBCh case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x800);
		/* 82169FBCh case    5:*/		return 0x82169FC0;
		  /* 82169FC0h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 82169FC0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82169FC0h case    6:*/		return 0x82169FC4;
		  /* 82169FC4h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 82169FC4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82169FF8;  }
		/* 82169FC4h case    7:*/		return 0x82169FC8;
		  /* 82169FC8h */ case    8:  		/* rlwinm. R10, R11, 0, 8, 10 */
		/* 82169FC8h case    8:*/		cpu::op::rlwinm<1,0,8,10>(regs,&regs.R10,regs.R11);
		/* 82169FC8h case    8:*/		return 0x82169FCC;
		  /* 82169FCCh */ case    9:  		/* bc 4, CR0_EQ, 44 */
		/* 82169FCCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x82169FF8;  }
		/* 82169FCCh case    9:*/		return 0x82169FD0;
		  /* 82169FD0h */ case   10:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82169FD0h case   10:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82169FD0h case   10:*/		return 0x82169FD4;
		  /* 82169FD4h */ case   11:  		/* bc 4, CR0_EQ, 36 */
		/* 82169FD4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82169FF8;  }
		/* 82169FD4h case   11:*/		return 0x82169FD8;
		  /* 82169FD8h */ case   12:  		/* lwz R11, <#[R8 + 8]> */
		/* 82169FD8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 82169FD8h case   12:*/		return 0x82169FDC;
		  /* 82169FDCh */ case   13:  		/* lis R10, -32768 */
		/* 82169FDCh case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82169FDCh case   13:*/		return 0x82169FE0;
		  /* 82169FE0h */ case   14:  		/* rlwinm R11, R11, 0, 18, 22 */
		/* 82169FE0h case   14:*/		cpu::op::rlwinm<0,0,18,22>(regs,&regs.R11,regs.R11);
		/* 82169FE0h case   14:*/		return 0x82169FE4;
		  /* 82169FE4h */ case   15:  		/* ori R10, R10, 16389 */
		/* 82169FE4h case   15:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4005);
		/* 82169FE4h case   15:*/		return 0x82169FE8;
		  /* 82169FE8h */ case   16:  		/* subfic R11, R11, 0 */
		/* 82169FE8h case   16:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82169FE8h case   16:*/		return 0x82169FEC;
		  /* 82169FECh */ case   17:  		/* subfe R11, R11, R11 */
		/* 82169FECh case   17:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82169FECh case   17:*/		return 0x82169FF0;
		  /* 82169FF0h */ case   18:  		/* and R3, R11, R10 */
		/* 82169FF0h case   18:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82169FF0h case   18:*/		return 0x82169FF4;
		  /* 82169FF4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 82169FF4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82169FF4h case   19:*/		return 0x82169FF8;
	}
	return 0x82169FF8;
} // Block from 82169FA8h-82169FF8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82169FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82169FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82169FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82169FF8);
		  /* 82169FF8h */ case    0:  		/* lis R3, -32768 */
		/* 82169FF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82169FF8h case    0:*/		return 0x82169FFC;
		  /* 82169FFCh */ case    1:  		/* ori R3, R3, 16389 */
		/* 82169FFCh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82169FFCh case    1:*/		return 0x8216A000;
		  /* 8216A000h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216A000h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A000h case    2:*/		return 0x8216A004;
	}
	return 0x8216A004;
} // Block from 82169FF8h-8216A004h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216A004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A004);
		  /* 8216A004h */ case    0:  		/* nop */
		/* 8216A004h case    0:*/		cpu::op::nop();
		/* 8216A004h case    0:*/		return 0x8216A008;
		  /* 8216A008h */ case    1:  		/* lbz R11, <#[R5 + 40]> */
		/* 8216A008h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000028) );
		/* 8216A008h case    1:*/		return 0x8216A00C;
		  /* 8216A00Ch */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 8216A00Ch case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216A00Ch case    2:*/		return 0x8216A010;
		  /* 8216A010h */ case    3:  		/* bc 4, CR0_EQ, 108 */
		/* 8216A010h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216A07C;  }
		/* 8216A010h case    3:*/		return 0x8216A014;
		  /* 8216A014h */ case    4:  		/* lwz R9, <#[R5]> */
		/* 8216A014h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8216A014h case    4:*/		return 0x8216A018;
		  /* 8216A018h */ case    5:  		/* lwz R11, <#[R5 + 16]> */
		/* 8216A018h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 8216A018h case    5:*/		return 0x8216A01C;
		  /* 8216A01Ch */ case    6:  		/* lwz R10, <#[R5 + 68]> */
		/* 8216A01Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000044) );
		/* 8216A01Ch case    6:*/		return 0x8216A020;
		  /* 8216A020h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 8216A020h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216A020h case    7:*/		return 0x8216A024;
		  /* 8216A024h */ case    8:  		/* lwz R6, <#[R9 + 28]> */
		/* 8216A024h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x0000001C) );
		/* 8216A024h case    8:*/		return 0x8216A028;
		  /* 8216A028h */ case    9:  		/* bc 12, CR6_LT, 180 */
		/* 8216A028h case    9:*/		if ( regs.CR[6].lt ) { return 0x8216A0DC;  }
		/* 8216A028h case    9:*/		return 0x8216A02C;
		  /* 8216A02Ch */ case   10:  		/* rldicl R7, R10, 0, 32 */
		/* 8216A02Ch case   10:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R10);
		/* 8216A02Ch case   10:*/		return 0x8216A030;
		  /* 8216A030h */ case   11:  		/* lwz R8, <#[R5 + 72]> */
		/* 8216A030h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000048) );
		/* 8216A030h case   11:*/		return 0x8216A034;
		  /* 8216A034h */ case   12:  		/* li R10, 0 */
		/* 8216A034h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216A034h case   12:*/		return 0x8216A038;
		  /* 8216A038h */ case   13:  		/* rldicl R9, R11, 0, 32 */
		/* 8216A038h case   13:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R11);
		/* 8216A038h case   13:*/		return 0x8216A03C;
		  /* 8216A03Ch */ case   14:  		/* rldimi R10, R6, 2, 30 */
		/* 8216A03Ch case   14:*/		cpu::op::rldimi<0,2,30>(regs,&regs.R10,regs.R6);
		/* 8216A03Ch case   14:*/		return 0x8216A040;
		  /* 8216A040h */ case   15:  		/* add R8, R8, R7 */
		/* 8216A040h case   15:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8216A040h case   15:*/		return 0x8216A044;
		  /* 8216A044h */ case   16:  		/* add R10, R10, R9 */
		/* 8216A044h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216A044h case   16:*/		return 0x8216A048;
		  /* 8216A048h */ case   17:  		/* cmpld CR6, R10, R8 */
		/* 8216A048h case   17:*/		cpu::op::cmpld<6>(regs,regs.R10,regs.R8);
		/* 8216A048h case   17:*/		return 0x8216A04C;
		  /* 8216A04Ch */ case   18:  		/* bc 12, CR6_GT, 144 */
		/* 8216A04Ch case   18:*/		if ( regs.CR[6].gt ) { return 0x8216A0DC;  }
		/* 8216A04Ch case   18:*/		return 0x8216A050;
		  /* 8216A050h */ case   19:  		/* li R10, 0 */
		/* 8216A050h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216A050h case   19:*/		return 0x8216A054;
		  /* 8216A054h */ case   20:  		/* cmplwi CR6, R6, 0 */
		/* 8216A054h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8216A054h case   20:*/		return 0x8216A058;
		  /* 8216A058h */ case   21:  		/* bc 12, CR6_EQ, 36 */
		/* 8216A058h case   21:*/		if ( regs.CR[6].eq ) { return 0x8216A07C;  }
		/* 8216A058h case   21:*/		return 0x8216A05C;
		  /* 8216A05Ch */ case   22:  		/* lwz R9, <#[R11]> */
		/* 8216A05Ch case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216A05Ch case   22:*/		return 0x8216A060;
		  /* 8216A060h */ case   23:  		/* rlwinm R9, R9, 0, 20, 31 */
		/* 8216A060h case   23:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R9);
		/* 8216A060h case   23:*/		return 0x8216A064;
		  /* 8216A064h */ case   24:  		/* cmplw CR6, R4, R9 */
		/* 8216A064h case   24:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 8216A064h case   24:*/		return 0x8216A068;
		  /* 8216A068h */ case   25:  		/* bc 12, CR6_EQ, 84 */
		/* 8216A068h case   25:*/		if ( regs.CR[6].eq ) { return 0x8216A0BC;  }
		/* 8216A068h case   25:*/		return 0x8216A06C;
		  /* 8216A06Ch */ case   26:  		/* addi R10, R10, 1 */
		/* 8216A06Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216A06Ch case   26:*/		return 0x8216A070;
		  /* 8216A070h */ case   27:  		/* addi R11, R11, 4 */
		/* 8216A070h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8216A070h case   27:*/		return 0x8216A074;
		  /* 8216A074h */ case   28:  		/* cmplw CR6, R10, R6 */
		/* 8216A074h case   28:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8216A074h case   28:*/		return 0x8216A078;
		  /* 8216A078h */ case   29:  		/* bc 12, CR6_LT, -28 */
		/* 8216A078h case   29:*/		if ( regs.CR[6].lt ) { return 0x8216A05C;  }
		/* 8216A078h case   29:*/		return 0x8216A07C;
	}
	return 0x8216A07C;
} // Block from 8216A004h-8216A07Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 8216A07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A07C);
		  /* 8216A07Ch */ case    0:  		/* mulli R11, R4, 12 */
		/* 8216A07Ch case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0xC);
		/* 8216A07Ch case    0:*/		return 0x8216A080;
		  /* 8216A080h */ case    1:  		/* add R11, R11, R3 */
		/* 8216A080h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8216A080h case    1:*/		return 0x8216A084;
		  /* 8216A084h */ case    2:  		/* lhz R11, <#[R11 + 4]> */
		/* 8216A084h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8216A084h case    2:*/		return 0x8216A088;
		  /* 8216A088h */ case    3:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 8216A088h case    3:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8216A088h case    3:*/		return 0x8216A08C;
		  /* 8216A08Ch */ case    4:  		/* cmpwi CR6, R11, 26 */
		/* 8216A08Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001A);
		/* 8216A08Ch case    4:*/		return 0x8216A090;
		  /* 8216A090h */ case    5:  		/* bc 12, CR6_GT, 52 */
		/* 8216A090h case    5:*/		if ( regs.CR[6].gt ) { return 0x8216A0C4;  }
		/* 8216A090h case    5:*/		return 0x8216A094;
		  /* 8216A094h */ case    6:  		/* cmpwi CR6, R11, 25 */
		/* 8216A094h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000019);
		/* 8216A094h case    6:*/		return 0x8216A098;
		  /* 8216A098h */ case    7:  		/* bc 4, CR6_LT, 36 */
		/* 8216A098h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8216A0BC;  }
		/* 8216A098h case    7:*/		return 0x8216A09C;
		  /* 8216A09Ch */ case    8:  		/* cmpwi CR6, R11, 6 */
		/* 8216A09Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 8216A09Ch case    8:*/		return 0x8216A0A0;
		  /* 8216A0A0h */ case    9:  		/* bc 12, CR6_LT, 60 */
		/* 8216A0A0h case    9:*/		if ( regs.CR[6].lt ) { return 0x8216A0DC;  }
		/* 8216A0A0h case    9:*/		return 0x8216A0A4;
		  /* 8216A0A4h */ case   10:  		/* cmpwi CR6, R11, 7 */
		/* 8216A0A4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 8216A0A4h case   10:*/		return 0x8216A0A8;
		  /* 8216A0A8h */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 8216A0A8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8216A0BC;  }
		/* 8216A0A8h case   11:*/		return 0x8216A0AC;
		  /* 8216A0ACh */ case   12:  		/* cmpwi CR6, R11, 15 */
		/* 8216A0ACh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 8216A0ACh case   12:*/		return 0x8216A0B0;
		  /* 8216A0B0h */ case   13:  		/* bc 4, CR6_GT, 44 */
		/* 8216A0B0h case   13:*/		if ( !regs.CR[6].gt ) { return 0x8216A0DC;  }
		/* 8216A0B0h case   13:*/		return 0x8216A0B4;
		  /* 8216A0B4h */ case   14:  		/* cmpwi CR6, R11, 17 */
		/* 8216A0B4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000011);
		/* 8216A0B4h case   14:*/		return 0x8216A0B8;
		  /* 8216A0B8h */ case   15:  		/* bc 12, CR6_GT, 36 */
		/* 8216A0B8h case   15:*/		if ( regs.CR[6].gt ) { return 0x8216A0DC;  }
		/* 8216A0B8h case   15:*/		return 0x8216A0BC;
	}
	return 0x8216A0BC;
} // Block from 8216A07Ch-8216A0BCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8216A0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A0BC);
		  /* 8216A0BCh */ case    0:  		/* li R3, 0 */
		/* 8216A0BCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A0BCh case    0:*/		return 0x8216A0C0;
		  /* 8216A0C0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216A0C0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A0C0h case    1:*/		return 0x8216A0C4;
	}
	return 0x8216A0C4;
} // Block from 8216A0BCh-8216A0C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A0C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A0C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A0C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A0C4);
		  /* 8216A0C4h */ case    0:  		/* cmpwi CR6, R11, 31 */
		/* 8216A0C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001F);
		/* 8216A0C4h case    0:*/		return 0x8216A0C8;
		  /* 8216A0C8h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8216A0C8h case    1:*/		if ( regs.CR[6].lt ) { return 0x8216A0DC;  }
		/* 8216A0C8h case    1:*/		return 0x8216A0CC;
		  /* 8216A0CCh */ case    2:  		/* cmpwi CR6, R11, 38 */
		/* 8216A0CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000026);
		/* 8216A0CCh case    2:*/		return 0x8216A0D0;
		  /* 8216A0D0h */ case    3:  		/* bc 4, CR6_GT, -20 */
		/* 8216A0D0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216A0BC;  }
		/* 8216A0D0h case    3:*/		return 0x8216A0D4;
		  /* 8216A0D4h */ case    4:  		/* cmpwi CR6, R11, 57 */
		/* 8216A0D4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8216A0D4h case    4:*/		return 0x8216A0D8;
		  /* 8216A0D8h */ case    5:  		/* bc 12, CR6_EQ, -28 */
		/* 8216A0D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216A0BC;  }
		/* 8216A0D8h case    5:*/		return 0x8216A0DC;
	}
	return 0x8216A0DC;
} // Block from 8216A0C4h-8216A0DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A0DC);
		  /* 8216A0DCh */ case    0:  		/* lis R3, -32768 */
		/* 8216A0DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A0DCh case    0:*/		return 0x8216A0E0;
		  /* 8216A0E0h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216A0E0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A0E0h case    1:*/		return 0x8216A0E4;
		  /* 8216A0E4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216A0E4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A0E4h case    2:*/		return 0x8216A0E8;
	}
	return 0x8216A0E8;
} // Block from 8216A0DCh-8216A0E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216A0E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A0E8);
		  /* 8216A0E8h */ case    0:  		/* mfspr R12, LR */
		/* 8216A0E8h case    0:*/		regs.R12 = regs.LR;
		/* 8216A0E8h case    0:*/		return 0x8216A0EC;
		  /* 8216A0ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216A0ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216A0ECh case    1:*/		return 0x8216A0F0;
		  /* 8216A0F0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8216A0F0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216A0F0h case    2:*/		return 0x8216A0F4;
		  /* 8216A0F4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8216A0F4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216A0F4h case    3:*/		return 0x8216A0F8;
		  /* 8216A0F8h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 8216A0F8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8216A0F8h case    4:*/		return 0x8216A0FC;
		  /* 8216A0FCh */ case    5:  		/* mulli R11, R4, 12 */
		/* 8216A0FCh case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0xC);
		/* 8216A0FCh case    5:*/		return 0x8216A100;
		  /* 8216A100h */ case    6:  		/* add R10, R11, R3 */
		/* 8216A100h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R3);
		/* 8216A100h case    6:*/		return 0x8216A104;
		  /* 8216A104h */ case    7:  		/* lwzx R11, <#[R11 + R3]> */
		/* 8216A104h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216A104h case    7:*/		return 0x8216A108;
		  /* 8216A108h */ case    8:  		/* rlwinm. R9, R11, 0, 13, 13 */
		/* 8216A108h case    8:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R9,regs.R11);
		/* 8216A108h case    8:*/		return 0x8216A10C;
		  /* 8216A10Ch */ case    9:  		/* bc 4, CR0_EQ, 192 */
		/* 8216A10Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8216A1CC;  }
		/* 8216A10Ch case    9:*/		return 0x8216A110;
		  /* 8216A110h */ case   10:  		/* rlwinm. R9, R11, 0, 20, 20 */
		/* 8216A110h case   10:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R11);
		/* 8216A110h case   10:*/		return 0x8216A114;
		  /* 8216A114h */ case   11:  		/* bc 4, CR0_EQ, 184 */
		/* 8216A114h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8216A1CC;  }
		/* 8216A114h case   11:*/		return 0x8216A118;
		  /* 8216A118h */ case   12:  		/* lwz R9, <#[R6 + 32]> */
		/* 8216A118h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000020) );
		/* 8216A118h case   12:*/		return 0x8216A11C;
		  /* 8216A11Ch */ case   13:  		/* rlwinm R8, R11, 20, 26, 31 */
		/* 8216A11Ch case   13:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R8,regs.R11);
		/* 8216A11Ch case   13:*/		return 0x8216A120;
		  /* 8216A120h */ case   14:  		/* cmplw CR6, R8, R9 */
		/* 8216A120h case   14:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8216A120h case   14:*/		return 0x8216A124;
		  /* 8216A124h */ case   15:  		/* bc 12, CR6_GT, 168 */
		/* 8216A124h case   15:*/		if ( regs.CR[6].gt ) { return 0x8216A1CC;  }
		/* 8216A124h case   15:*/		return 0x8216A128;
		  /* 8216A128h */ case   16:  		/* rlwinm R8, R11, 27, 26, 31 */
		/* 8216A128h case   16:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R8,regs.R11);
		/* 8216A128h case   16:*/		return 0x8216A12C;
		  /* 8216A12Ch */ case   17:  		/* cmplw CR6, R8, R9 */
		/* 8216A12Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8216A12Ch case   17:*/		return 0x8216A130;
		  /* 8216A130h */ case   18:  		/* bc 12, CR6_GT, 156 */
		/* 8216A130h case   18:*/		if ( regs.CR[6].gt ) { return 0x8216A1CC;  }
		/* 8216A130h case   18:*/		return 0x8216A134;
		  /* 8216A134h */ case   19:  		/* lwz R9, <#[R10 + 4]> */
		/* 8216A134h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8216A134h case   19:*/		return 0x8216A138;
		  /* 8216A138h */ case   20:  		/* rlwinm. R8, R11, 0, 12, 12 */
		/* 8216A138h case   20:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R8,regs.R11);
		/* 8216A138h case   20:*/		return 0x8216A13C;
		  /* 8216A13Ch */ case   21:  		/* rlwinm R7, R9, 0, 29, 31 */
		/* 8216A13Ch case   21:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R7,regs.R9);
		/* 8216A13Ch case   21:*/		return 0x8216A140;
		  /* 8216A140h */ case   22:  		/* rlwinm R31, R9, 29, 29, 31 */
		/* 8216A140h case   22:*/		cpu::op::rlwinm<0,29,29,31>(regs,&regs.R31,regs.R9);
		/* 8216A140h case   22:*/		return 0x8216A144;
		  /* 8216A144h */ case   23:  		/* rlwinm R30, R9, 26, 29, 31 */
		/* 8216A144h case   23:*/		cpu::op::rlwinm<0,26,29,31>(regs,&regs.R30,regs.R9);
		/* 8216A144h case   23:*/		return 0x8216A148;
		  /* 8216A148h */ case   24:  		/* stw R7, <#[R1 + 80]> */
		/* 8216A148h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8216A148h case   24:*/		return 0x8216A14C;
		  /* 8216A14Ch */ case   25:  		/* rlwinm R9, R9, 23, 29, 31 */
		/* 8216A14Ch case   25:*/		cpu::op::rlwinm<0,23,29,31>(regs,&regs.R9,regs.R9);
		/* 8216A14Ch case   25:*/		return 0x8216A150;
		  /* 8216A150h */ case   26:  		/* stw R31, <#[R1 + 84]> */
		/* 8216A150h case   26:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8216A150h case   26:*/		return 0x8216A154;
		  /* 8216A154h */ case   27:  		/* stw R30, <#[R1 + 88]> */
		/* 8216A154h case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 8216A154h case   27:*/		return 0x8216A158;
		  /* 8216A158h */ case   28:  		/* stw R9, <#[R1 + 92]> */
		/* 8216A158h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 8216A158h case   28:*/		return 0x8216A15C;
		  /* 8216A15Ch */ case   29:  		/* bc 12, CR0_EQ, 112 */
		/* 8216A15Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x8216A1CC;  }
		/* 8216A15Ch case   29:*/		return 0x8216A160;
		  /* 8216A160h */ case   30:  		/* lwz R8, <#[R10 + 4]> */
		/* 8216A160h case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 8216A160h case   30:*/		return 0x8216A164;
		  /* 8216A164h */ case   31:  		/* rlwinm. R10, R8, 0, 17, 17 */
		/* 8216A164h case   31:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R10,regs.R8);
		/* 8216A164h case   31:*/		return 0x8216A168;
		  /* 8216A168h */ case   32:  		/* bc 4, CR0_EQ, 100 */
		/* 8216A168h case   32:*/		if ( !regs.CR[0].eq ) { return 0x8216A1CC;  }
		/* 8216A168h case   32:*/		return 0x8216A16C;
		  /* 8216A16Ch */ case   33:  		/* rlwinm. R10, R8, 0, 8, 9 */
		/* 8216A16Ch case   33:*/		cpu::op::rlwinm<1,0,8,9>(regs,&regs.R10,regs.R8);
		/* 8216A16Ch case   33:*/		return 0x8216A170;
		  /* 8216A170h */ case   34:  		/* bc 4, CR0_EQ, 92 */
		/* 8216A170h case   34:*/		if ( !regs.CR[0].eq ) { return 0x8216A1CC;  }
		/* 8216A170h case   34:*/		return 0x8216A174;
		  /* 8216A174h */ case   35:  		/* li R10, 0 */
		/* 8216A174h case   35:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8216A174h case   35:*/		return 0x8216A178;
		  /* 8216A178h */ case   36:  		/* addi R9, R1, 80 */
		/* 8216A178h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8216A178h case   36:*/		return 0x8216A17C;
		  /* 8216A17Ch */ case   37:  		/* lwz R7, <#[R9]> */
		/* 8216A17Ch case   37:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8216A17Ch case   37:*/		return 0x8216A180;
		  /* 8216A180h */ case   38:  		/* cmplwi CR6, R7, 6 */
		/* 8216A180h case   38:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000006);
		/* 8216A180h case   38:*/		return 0x8216A184;
		  /* 8216A184h */ case   39:  		/* bc 12, CR6_EQ, 72 */
		/* 8216A184h case   39:*/		if ( regs.CR[6].eq ) { return 0x8216A1CC;  }
		/* 8216A184h case   39:*/		return 0x8216A188;
		  /* 8216A188h */ case   40:  		/* addi R10, R10, 1 */
		/* 8216A188h case   40:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216A188h case   40:*/		return 0x8216A18C;
		  /* 8216A18Ch */ case   41:  		/* addi R9, R9, 4 */
		/* 8216A18Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8216A18Ch case   41:*/		return 0x8216A190;
		  /* 8216A190h */ case   42:  		/* cmpwi CR6, R10, 4 */
		/* 8216A190h case   42:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 8216A190h case   42:*/		return 0x8216A194;
		  /* 8216A194h */ case   43:  		/* bc 12, CR6_LT, -24 */
		/* 8216A194h case   43:*/		if ( regs.CR[6].lt ) { return 0x8216A17C;  }
		/* 8216A194h case   43:*/		return 0x8216A198;
		  /* 8216A198h */ case   44:  		/* rlwinm R11, R11, 0, 5, 6 */
		/* 8216A198h case   44:*/		cpu::op::rlwinm<0,0,5,6>(regs,&regs.R11,regs.R11);
		/* 8216A198h case   44:*/		return 0x8216A19C;
		  /* 8216A19Ch */ case   45:  		/* lis R10, 1536 */
		/* 8216A19Ch case   45:*/		cpu::op::lis<0>(regs,&regs.R10,0x600);
		/* 8216A19Ch case   45:*/		return 0x8216A1A0;
		  /* 8216A1A0h */ case   46:  		/* cmplw CR6, R11, R10 */
		/* 8216A1A0h case   46:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216A1A0h case   46:*/		return 0x8216A1A4;
		  /* 8216A1A4h */ case   47:  		/* bc 12, CR6_EQ, 40 */
		/* 8216A1A4h case   47:*/		if ( regs.CR[6].eq ) { return 0x8216A1CC;  }
		/* 8216A1A4h case   47:*/		return 0x8216A1A8;
		  /* 8216A1A8h */ case   48:  		/* rlwinm. R11, R8, 0, 1, 1 */
		/* 8216A1A8h case   48:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R8);
		/* 8216A1A8h case   48:*/		return 0x8216A1AC;
		  /* 8216A1ACh */ case   49:  		/* bc 12, CR0_EQ, 12 */
		/* 8216A1ACh case   49:*/		if ( regs.CR[0].eq ) { return 0x8216A1B8;  }
		/* 8216A1ACh case   49:*/		return 0x8216A1B0;
		  /* 8216A1B0h */ case   50:  		/* cmpwi CR6, R5, 0 */
		/* 8216A1B0h case   50:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8216A1B0h case   50:*/		return 0x8216A1B4;
		  /* 8216A1B4h */ case   51:  		/* bc 12, CR6_EQ, 24 */
		/* 8216A1B4h case   51:*/		if ( regs.CR[6].eq ) { return 0x8216A1CC;  }
		/* 8216A1B4h case   51:*/		return 0x8216A1B8;
	}
	return 0x8216A1B8;
} // Block from 8216A0E8h-8216A1B8h (52 instructions)

//////////////////////////////////////////////////////
// Block at 8216A1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A1B8);
		  /* 8216A1B8h */ case    0:  		/* mr R5, R6 */
		/* 8216A1B8h case    0:*/		regs.R5 = regs.R6;
		/* 8216A1B8h case    0:*/		return 0x8216A1BC;
		  /* 8216A1BCh */ case    1:  		/* bl -436 */
		/* 8216A1BCh case    1:*/		regs.LR = 0x8216A1C0; return 0x8216A008;
		/* 8216A1BCh case    1:*/		return 0x8216A1C0;
		  /* 8216A1C0h */ case    2:  		/* srawi R11, R3, 31 */
		/* 8216A1C0h case    2:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 8216A1C0h case    2:*/		return 0x8216A1C4;
		  /* 8216A1C4h */ case    3:  		/* and R3, R11, R3 */
		/* 8216A1C4h case    3:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 8216A1C4h case    3:*/		return 0x8216A1C8;
		  /* 8216A1C8h */ case    4:  		/* b 12 */
		/* 8216A1C8h case    4:*/		return 0x8216A1D4;
		/* 8216A1C8h case    4:*/		return 0x8216A1CC;
	}
	return 0x8216A1CC;
} // Block from 8216A1B8h-8216A1CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216A1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A1CC);
		  /* 8216A1CCh */ case    0:  		/* lis R3, -32768 */
		/* 8216A1CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A1CCh case    0:*/		return 0x8216A1D0;
		  /* 8216A1D0h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216A1D0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A1D0h case    1:*/		return 0x8216A1D4;
	}
	return 0x8216A1D4;
} // Block from 8216A1CCh-8216A1D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A1D4);
		  /* 8216A1D4h */ case    0:  		/* addi R1, R1, 128 */
		/* 8216A1D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8216A1D4h case    0:*/		return 0x8216A1D8;
		  /* 8216A1D8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216A1D8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216A1D8h case    1:*/		return 0x8216A1DC;
		  /* 8216A1DCh */ case    2:  		/* mtspr LR, R12 */
		/* 8216A1DCh case    2:*/		regs.LR = regs.R12;
		/* 8216A1DCh case    2:*/		return 0x8216A1E0;
		  /* 8216A1E0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8216A1E0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8216A1E0h case    3:*/		return 0x8216A1E4;
		  /* 8216A1E4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8216A1E4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216A1E4h case    4:*/		return 0x8216A1E8;
		  /* 8216A1E8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8216A1E8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A1E8h case    5:*/		return 0x8216A1EC;
	}
	return 0x8216A1EC;
} // Block from 8216A1D4h-8216A1ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A1EC);
		  /* 8216A1ECh */ case    0:  		/* nop */
		/* 8216A1ECh case    0:*/		cpu::op::nop();
		/* 8216A1ECh case    0:*/		return 0x8216A1F0;
		  /* 8216A1F0h */ case    1:  		/* mulli R11, R4, 12 */
		/* 8216A1F0h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0xC);
		/* 8216A1F0h case    1:*/		return 0x8216A1F4;
		  /* 8216A1F4h */ case    2:  		/* add R10, R11, R3 */
		/* 8216A1F4h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R3);
		/* 8216A1F4h case    2:*/		return 0x8216A1F8;
		  /* 8216A1F8h */ case    3:  		/* li R9, 0 */
		/* 8216A1F8h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8216A1F8h case    3:*/		return 0x8216A1FC;
		  /* 8216A1FCh */ case    4:  		/* li R7, 0 */
		/* 8216A1FCh case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216A1FCh case    4:*/		return 0x8216A200;
		  /* 8216A200h */ case    5:  		/* li R8, 0 */
		/* 8216A200h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216A200h case    5:*/		return 0x8216A204;
		  /* 8216A204h */ case    6:  		/* lbz R11, <#[R10 + 8]> */
		/* 8216A204h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8216A204h case    6:*/		return 0x8216A208;
		  /* 8216A208h */ case    7:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8216A208h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8216A208h case    7:*/		return 0x8216A20C;
		  /* 8216A20Ch */ case    8:  		/* cmplwi CR6, R11, 27 */
		/* 8216A20Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001B);
		/* 8216A20Ch case    8:*/		return 0x8216A210;
		  /* 8216A210h */ case    9:  		/* bc 12, CR6_GT, 60 */
		/* 8216A210h case    9:*/		if ( regs.CR[6].gt ) { return 0x8216A24C;  }
		/* 8216A210h case    9:*/		return 0x8216A214;
		  /* 8216A214h */ case   10:  		/* cmplwi CR6, R11, 24 */
		/* 8216A214h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8216A214h case   10:*/		return 0x8216A218;
		  /* 8216A218h */ case   11:  		/* bc 4, CR6_LT, 32 */
		/* 8216A218h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8216A238;  }
		/* 8216A218h case   11:*/		return 0x8216A21C;
		  /* 8216A21Ch */ case   12:  		/* cmplwi CR6, R11, 20 */
		/* 8216A21Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000014);
		/* 8216A21Ch case   12:*/		return 0x8216A220;
		  /* 8216A220h */ case   13:  		/* bc 12, CR6_LT, 64 */
		/* 8216A220h case   13:*/		if ( regs.CR[6].lt ) { return 0x8216A260;  }
		/* 8216A220h case   13:*/		return 0x8216A224;
		  /* 8216A224h */ case   14:  		/* cmplwi CR6, R11, 24 */
		/* 8216A224h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8216A224h case   14:*/		return 0x8216A228;
		  /* 8216A228h */ case   15:  		/* bc 4, CR6_LT, 104 */
		/* 8216A228h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8216A290;  }
		/* 8216A228h case   15:*/		return 0x8216A22C;
		  /* 8216A22Ch */ case   16:  		/* li R9, 1 */
		/* 8216A22Ch case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8216A22Ch case   16:*/		return 0x8216A230;
		  /* 8216A230h */ case   17:  		/* li R8, 1 */
		/* 8216A230h case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8216A230h case   17:*/		return 0x8216A234;
		  /* 8216A234h */ case   18:  		/* b 44 */
		/* 8216A234h case   18:*/		return 0x8216A260;
		/* 8216A234h case   18:*/		return 0x8216A238;
	}
	return 0x8216A238;
} // Block from 8216A1ECh-8216A238h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216A238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A238);
		  /* 8216A238h */ case    0:  		/* lbz R11, <#[R6 + 40]> */
		/* 8216A238h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000028) );
		/* 8216A238h case    0:*/		return 0x8216A23C;
		  /* 8216A23Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8216A23Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216A23Ch case    1:*/		return 0x8216A240;
		  /* 8216A240h */ case    2:  		/* bc 12, CR0_EQ, 80 */
		/* 8216A240h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216A290;  }
		/* 8216A240h case    2:*/		return 0x8216A244;
		  /* 8216A244h */ case    3:  		/* li R9, 1 */
		/* 8216A244h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8216A244h case    3:*/		return 0x8216A248;
		  /* 8216A248h */ case    4:  		/* b 24 */
		/* 8216A248h case    4:*/		return 0x8216A260;
		/* 8216A248h case    4:*/		return 0x8216A24C;
	}
	return 0x8216A24C;
} // Block from 8216A238h-8216A24Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216A24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A24C);
		  /* 8216A24Ch */ case    0:  		/* cmplwi CR6, R11, 28 */
		/* 8216A24Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 8216A24Ch case    0:*/		return 0x8216A250;
		  /* 8216A250h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8216A250h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216A260;  }
		/* 8216A250h case    1:*/		return 0x8216A254;
		  /* 8216A254h */ case    2:  		/* cmplwi CR6, R11, 29 */
		/* 8216A254h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001D);
		/* 8216A254h case    2:*/		return 0x8216A258;
		  /* 8216A258h */ case    3:  		/* bc 4, CR6_EQ, 56 */
		/* 8216A258h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216A290;  }
		/* 8216A258h case    3:*/		return 0x8216A25C;
		  /* 8216A25Ch */ case    4:  		/* li R7, 1 */
		/* 8216A25Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8216A25Ch case    4:*/		return 0x8216A260;
	}
	return 0x8216A260;
} // Block from 8216A24Ch-8216A260h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216A260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A260);
		  /* 8216A260h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 8216A260h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216A260h case    0:*/		return 0x8216A264;
		  /* 8216A264h */ case    1:  		/* rlwinm R11, R11, 6, 26, 31 */
		/* 8216A264h case    1:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R11,regs.R11);
		/* 8216A264h case    1:*/		return 0x8216A268;
		  /* 8216A268h */ case    2:  		/* cmplwi CR6, R11, 34 */
		/* 8216A268h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000022);
		/* 8216A268h case    2:*/		return 0x8216A26C;
		  /* 8216A26Ch */ case    3:  		/* bc 12, CR6_GT, 64 */
		/* 8216A26Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8216A2AC;  }
		/* 8216A26Ch case    3:*/		return 0x8216A270;
		  /* 8216A270h */ case    4:  		/* cmplwi CR6, R11, 27 */
		/* 8216A270h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001B);
		/* 8216A270h case    4:*/		return 0x8216A274;
		  /* 8216A274h */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 8216A274h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8216A2A4;  }
		/* 8216A274h case    5:*/		return 0x8216A278;
		  /* 8216A278h */ case    6:  		/* cmplwi CR6, R11, 23 */
		/* 8216A278h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 8216A278h case    6:*/		return 0x8216A27C;
		  /* 8216A27Ch */ case    7:  		/* bc 12, CR6_LT, 108 */
		/* 8216A27Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x8216A2E8;  }
		/* 8216A27Ch case    7:*/		return 0x8216A280;
		  /* 8216A280h */ case    8:  		/* cmplwi CR6, R11, 25 */
		/* 8216A280h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 8216A280h case    8:*/		return 0x8216A284;
		  /* 8216A284h */ case    9:  		/* bc 12, CR6_LT, 24 */
		/* 8216A284h case    9:*/		if ( regs.CR[6].lt ) { return 0x8216A29C;  }
		/* 8216A284h case    9:*/		return 0x8216A288;
		  /* 8216A288h */ case   10:  		/* cmplwi CR6, R11, 27 */
		/* 8216A288h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001B);
		/* 8216A288h case   10:*/		return 0x8216A28C;
		  /* 8216A28Ch */ case   11:  		/* bc 12, CR6_LT, 92 */
		/* 8216A28Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x8216A2E8;  }
		/* 8216A28Ch case   11:*/		return 0x8216A290;
	}
	return 0x8216A290;
} // Block from 8216A260h-8216A290h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216A290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A290);
		  /* 8216A290h */ case    0:  		/* lis R3, -32768 */
		/* 8216A290h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A290h case    0:*/		return 0x8216A294;
		  /* 8216A294h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216A294h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A294h case    1:*/		return 0x8216A298;
		  /* 8216A298h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216A298h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A298h case    2:*/		return 0x8216A29C;
	}
	return 0x8216A29C;
} // Block from 8216A290h-8216A29Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216A29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A29C);
		  /* 8216A29Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 8216A29Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8216A29Ch case    0:*/		return 0x8216A2A0;
		  /* 8216A2A0h */ case    1:  		/* b 72 */
		/* 8216A2A0h case    1:*/		return 0x8216A2E8;
		/* 8216A2A0h case    1:*/		return 0x8216A2A4;
	}
	return 0x8216A2A4;
} // Block from 8216A29Ch-8216A2A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A2A4);
		  /* 8216A2A4h */ case    0:  		/* li R8, 1 */
		/* 8216A2A4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8216A2A4h case    0:*/		return 0x8216A2A8;
		  /* 8216A2A8h */ case    1:  		/* b 60 */
		/* 8216A2A8h case    1:*/		return 0x8216A2E4;
		/* 8216A2A8h case    1:*/		return 0x8216A2AC;
	}
	return 0x8216A2AC;
} // Block from 8216A2A4h-8216A2ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A2AC);
		  /* 8216A2ACh */ case    0:  		/* cmplwi CR6, R11, 35 */
		/* 8216A2ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000023);
		/* 8216A2ACh case    0:*/		return 0x8216A2B0;
		  /* 8216A2B0h */ case    1:  		/* bc 12, CR6_LT, -32 */
		/* 8216A2B0h case    1:*/		if ( regs.CR[6].lt ) { return 0x8216A290;  }
		/* 8216A2B0h case    1:*/		return 0x8216A2B4;
		  /* 8216A2B4h */ case    2:  		/* cmplwi CR6, R11, 39 */
		/* 8216A2B4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000027);
		/* 8216A2B4h case    2:*/		return 0x8216A2B8;
		  /* 8216A2B8h */ case    3:  		/* bc 4, CR6_GT, 32 */
		/* 8216A2B8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216A2D8;  }
		/* 8216A2B8h case    3:*/		return 0x8216A2BC;
		  /* 8216A2BCh */ case    4:  		/* cmplwi CR6, R11, 40 */
		/* 8216A2BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000028);
		/* 8216A2BCh case    4:*/		return 0x8216A2C0;
		  /* 8216A2C0h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 8216A2C0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216A2E8;  }
		/* 8216A2C0h case    5:*/		return 0x8216A2C4;
		  /* 8216A2C4h */ case    6:  		/* cmplwi CR6, R11, 41 */
		/* 8216A2C4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000029);
		/* 8216A2C4h case    6:*/		return 0x8216A2C8;
		  /* 8216A2C8h */ case    7:  		/* bc 4, CR6_GT, -56 */
		/* 8216A2C8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8216A290;  }
		/* 8216A2C8h case    7:*/		return 0x8216A2CC;
		  /* 8216A2CCh */ case    8:  		/* cmplwi CR6, R11, 50 */
		/* 8216A2CCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000032);
		/* 8216A2CCh case    8:*/		return 0x8216A2D0;
		  /* 8216A2D0h */ case    9:  		/* bc 12, CR6_GT, -64 */
		/* 8216A2D0h case    9:*/		if ( regs.CR[6].gt ) { return 0x8216A290;  }
		/* 8216A2D0h case    9:*/		return 0x8216A2D4;
		  /* 8216A2D4h */ case   10:  		/* b 20 */
		/* 8216A2D4h case   10:*/		return 0x8216A2E8;
		/* 8216A2D4h case   10:*/		return 0x8216A2D8;
	}
	return 0x8216A2D8;
} // Block from 8216A2ACh-8216A2D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216A2D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A2D8);
		  /* 8216A2D8h */ case    0:  		/* lbz R11, <#[R6 + 40]> */
		/* 8216A2D8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000028) );
		/* 8216A2D8h case    0:*/		return 0x8216A2DC;
		  /* 8216A2DCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8216A2DCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8216A2DCh case    1:*/		return 0x8216A2E0;
		  /* 8216A2E0h */ case    2:  		/* bc 12, CR0_EQ, -80 */
		/* 8216A2E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216A290;  }
		/* 8216A2E0h case    2:*/		return 0x8216A2E4;
	}
	return 0x8216A2E4;
} // Block from 8216A2D8h-8216A2E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216A2E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A2E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A2E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A2E4);
		  /* 8216A2E4h */ case    0:  		/* addi R9, R9, 1 */
		/* 8216A2E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216A2E4h case    0:*/		return 0x8216A2E8;
	}
	return 0x8216A2E8;
} // Block from 8216A2E4h-8216A2E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A2E8);
		  /* 8216A2E8h */ case    0:  		/* cmpwi CR6, R9, 1 */
		/* 8216A2E8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 8216A2E8h case    0:*/		return 0x8216A2EC;
		  /* 8216A2ECh */ case    1:  		/* bc 12, CR6_GT, -92 */
		/* 8216A2ECh case    1:*/		if ( regs.CR[6].gt ) { return 0x8216A290;  }
		/* 8216A2ECh case    1:*/		return 0x8216A2F0;
		  /* 8216A2F0h */ case    2:  		/* cmpwi CR6, R7, 1 */
		/* 8216A2F0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 8216A2F0h case    2:*/		return 0x8216A2F4;
		  /* 8216A2F4h */ case    3:  		/* bc 12, CR6_GT, -100 */
		/* 8216A2F4h case    3:*/		if ( regs.CR[6].gt ) { return 0x8216A290;  }
		/* 8216A2F4h case    3:*/		return 0x8216A2F8;
		  /* 8216A2F8h */ case    4:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 8216A2F8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 8216A2F8h case    4:*/		return 0x8216A2FC;
		  /* 8216A2FCh */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8216A2FCh case    5:*/		if ( regs.CR[0].eq ) { return 0x8216A308;  }
		/* 8216A2FCh case    5:*/		return 0x8216A300;
		  /* 8216A300h */ case    6:  		/* rlwinm. R11, R5, 0, 24, 31 */
		/* 8216A300h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R5);
		/* 8216A300h case    6:*/		return 0x8216A304;
		  /* 8216A304h */ case    7:  		/* bc 12, CR0_EQ, -116 */
		/* 8216A304h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216A290;  }
		/* 8216A304h case    7:*/		return 0x8216A308;
	}
	return 0x8216A308;
} // Block from 8216A2E8h-8216A308h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216A308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A308);
		  /* 8216A308h */ case    0:  		/* li R3, 0 */
		/* 8216A308h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A308h case    0:*/		return 0x8216A30C;
		  /* 8216A30Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216A30Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A30Ch case    1:*/		return 0x8216A310;
	}
	return 0x8216A310;
} // Block from 8216A308h-8216A310h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A310);
		  /* 8216A310h */ case    0:  		/* mulli R11, R4, 12 */
		/* 8216A310h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0xC);
		/* 8216A310h case    0:*/		return 0x8216A314;
		  /* 8216A314h */ case    1:  		/* lwzx R11, <#[R11 + R3]> */
		/* 8216A314h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8216A314h case    1:*/		return 0x8216A318;
		  /* 8216A318h */ case    2:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 8216A318h case    2:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 8216A318h case    2:*/		return 0x8216A31C;
		  /* 8216A31Ch */ case    3:  		/* bc 12, CR0_EQ, 300 */
		/* 8216A31Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8216A448;  }
		/* 8216A31Ch case    3:*/		return 0x8216A320;
		  /* 8216A320h */ case    4:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 8216A320h case    4:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 8216A320h case    4:*/		return 0x8216A324;
		  /* 8216A324h */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 8216A324h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A324h case    5:*/		return 0x8216A328;
		  /* 8216A328h */ case    6:  		/* rlwinm. R10, R11, 0, 18, 23 */
		/* 8216A328h case    6:*/		cpu::op::rlwinm<1,0,18,23>(regs,&regs.R10,regs.R11);
		/* 8216A328h case    6:*/		return 0x8216A32C;
		  /* 8216A32Ch */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 8216A32Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A32Ch case    7:*/		return 0x8216A330;
		  /* 8216A330h */ case    8:  		/* rlwinm R8, R11, 0, 26, 31 */
		/* 8216A330h case    8:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R8,regs.R11);
		/* 8216A330h case    8:*/		return 0x8216A334;
		  /* 8216A334h */ case    9:  		/* cmplwi CR6, R8, 15 */
		/* 8216A334h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000000F);
		/* 8216A334h case    9:*/		return 0x8216A338;
		  /* 8216A338h */ case   10:  		/* bc 4, CR6_GT, 24 */
		/* 8216A338h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8216A350;  }
		/* 8216A338h case   10:*/		return 0x8216A33C;
		  /* 8216A33Ch */ case   11:  		/* cmplwi CR6, R8, 61 */
		/* 8216A33Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003D);
		/* 8216A33Ch case   11:*/		return 0x8216A340;
		  /* 8216A340h */ case   12:  		/* bc 4, CR6_LT, 40 */
		/* 8216A340h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8216A368;  }
		/* 8216A340h case   12:*/		return 0x8216A344;
	}
	return 0x8216A344;
} // Block from 8216A310h-8216A344h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216A344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A344);
		  /* 8216A344h */ case    0:  		/* lis R3, -32768 */
		/* 8216A344h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A344h case    0:*/		return 0x8216A348;
		  /* 8216A348h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216A348h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A348h case    1:*/		return 0x8216A34C;
		  /* 8216A34Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216A34Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A34Ch case    2:*/		return 0x8216A350;
	}
	return 0x8216A350;
} // Block from 8216A344h-8216A350h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216A350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A350);
		  /* 8216A350h */ case    0:  		/* lis R10, 0 */
		/* 8216A350h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8216A350h case    0:*/		return 0x8216A354;
		  /* 8216A354h */ case    1:  		/* ori R10, R10, 32856 */
		/* 8216A354h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8058);
		/* 8216A354h case    1:*/		return 0x8216A358;
		  /* 8216A358h */ case    2:  		/* lwzx R10, <#[R5 + R10]> */
		/* 8216A358h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 8216A358h case    2:*/		return 0x8216A35C;
		  /* 8216A35Ch */ case    3:  		/* cmplw CR6, R8, R10 */
		/* 8216A35Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 8216A35Ch case    3:*/		return 0x8216A360;
		  /* 8216A360h */ case    4:  		/* bc 4, CR6_LT, -28 */
		/* 8216A360h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8216A344;  }
		/* 8216A360h case    4:*/		return 0x8216A364;
		  /* 8216A364h */ case    5:  		/* cmplwi CR6, R8, 61 */
		/* 8216A364h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003D);
		/* 8216A364h case    5:*/		return 0x8216A368;
	}
	return 0x8216A368;
} // Block from 8216A350h-8216A368h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A368);
		  /* 8216A368h */ case    0:  		/* bc 4, CR6_EQ, 172 */
		/* 8216A368h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8216A414;  }
		/* 8216A368h case    0:*/		return 0x8216A36C;
		  /* 8216A36Ch */ case    1:  		/* lis R10, 0 */
		/* 8216A36Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8216A36Ch case    1:*/		return 0x8216A370;
		  /* 8216A370h */ case    2:  		/* ori R10, R10, 32860 */
		/* 8216A370h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x805C);
		/* 8216A370h case    2:*/		return 0x8216A374;
		  /* 8216A374h */ case    3:  		/* lwzx R10, <#[R5 + R10]> */
		/* 8216A374h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 8216A374h case    3:*/		return 0x8216A378;
		  /* 8216A378h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 8216A378h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8216A378h case    4:*/		return 0x8216A37C;
		  /* 8216A37Ch */ case    5:  		/* bc 12, CR6_EQ, -56 */
		/* 8216A37Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8216A344;  }
		/* 8216A37Ch case    5:*/		return 0x8216A380;
		  /* 8216A380h */ case    6:  		/* li R9, 1 */
		/* 8216A380h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8216A380h case    6:*/		return 0x8216A384;
		  /* 8216A384h */ case    7:  		/* li R10, 1 */
		/* 8216A384h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8216A384h case    7:*/		return 0x8216A388;
		  /* 8216A388h */ case    8:  		/* rlwinm R7, R11, 12, 20, 31 */
		/* 8216A388h case    8:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R7,regs.R11);
		/* 8216A388h case    8:*/		return 0x8216A38C;
		  /* 8216A38Ch */ case    9:  		/* slw R10, R10, R9 */
		/* 8216A38Ch case    9:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216A38Ch case    9:*/		return 0x8216A390;
		  /* 8216A390h */ case   10:  		/* and R7, R7, R10 */
		/* 8216A390h case   10:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 8216A390h case   10:*/		return 0x8216A394;
		  /* 8216A394h */ case   11:  		/* rlwinm. R7, R7, 0, 28, 31 */
		/* 8216A394h case   11:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R7,regs.R7);
		/* 8216A394h case   11:*/		return 0x8216A398;
		  /* 8216A398h */ case   12:  		/* bc 4, CR0_EQ, -84 */
		/* 8216A398h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A398h case   12:*/		return 0x8216A39C;
		  /* 8216A39Ch */ case   13:  		/* rlwinm R7, R11, 16, 16, 31 */
		/* 8216A39Ch case   13:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R7,regs.R11);
		/* 8216A39Ch case   13:*/		return 0x8216A3A0;
		  /* 8216A3A0h */ case   14:  		/* and R10, R7, R10 */
		/* 8216A3A0h case   14:*/		cpu::op::and<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 8216A3A0h case   14:*/		return 0x8216A3A4;
		  /* 8216A3A4h */ case   15:  		/* rlwinm. R10, R10, 0, 28, 31 */
		/* 8216A3A4h case   15:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R10,regs.R10);
		/* 8216A3A4h case   15:*/		return 0x8216A3A8;
		  /* 8216A3A8h */ case   16:  		/* bc 4, CR0_EQ, -100 */
		/* 8216A3A8h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A3A8h case   16:*/		return 0x8216A3AC;
		  /* 8216A3ACh */ case   17:  		/* rlwinm. R10, R11, 0, 17, 17 */
		/* 8216A3ACh case   17:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R10,regs.R11);
		/* 8216A3ACh case   17:*/		return 0x8216A3B0;
		  /* 8216A3B0h */ case   18:  		/* bc 4, CR0_EQ, -108 */
		/* 8216A3B0h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A3B0h case   18:*/		return 0x8216A3B4;
		  /* 8216A3B4h */ case   19:  		/* addi R9, R9, 1 */
		/* 8216A3B4h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216A3B4h case   19:*/		return 0x8216A3B8;
		  /* 8216A3B8h */ case   20:  		/* cmpwi CR6, R9, 4 */
		/* 8216A3B8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000004);
		/* 8216A3B8h case   20:*/		return 0x8216A3BC;
		  /* 8216A3BCh */ case   21:  		/* bc 12, CR6_LT, -56 */
		/* 8216A3BCh case   21:*/		if ( regs.CR[6].lt ) { return 0x8216A384;  }
		/* 8216A3BCh case   21:*/		return 0x8216A3C0;
		  /* 8216A3C0h */ case   22:  		/* lwz R11, <#[R6]> */
		/* 8216A3C0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8216A3C0h case   22:*/		return 0x8216A3C4;
		  /* 8216A3C4h */ case   23:  		/* cmplwi CR6, R8, 62 */
		/* 8216A3C4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003E);
		/* 8216A3C4h case   23:*/		return 0x8216A3C8;
		  /* 8216A3C8h */ case   24:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216A3C8h case   24:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216A3C8h case   24:*/		return 0x8216A3CC;
		  /* 8216A3CCh */ case   25:  		/* add R11, R11, R6 */
		/* 8216A3CCh case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8216A3CCh case   25:*/		return 0x8216A3D0;
		  /* 8216A3D0h */ case   26:  		/* bc 12, CR6_LT, 36 */
		/* 8216A3D0h case   26:*/		if ( regs.CR[6].lt ) { return 0x8216A3F4;  }
		/* 8216A3D0h case   26:*/		return 0x8216A3D4;
		  /* 8216A3D4h */ case   27:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216A3D4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A3D4h case   27:*/		return 0x8216A3D8;
		  /* 8216A3D8h */ case   28:  		/* rlwinm. R10, R10, 0, 19, 19 */
		/* 8216A3D8h case   28:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8216A3D8h case   28:*/		return 0x8216A3DC;
		  /* 8216A3DCh */ case   29:  		/* bc 12, CR0_EQ, -152 */
		/* 8216A3DCh case   29:*/		if ( regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A3DCh case   29:*/		return 0x8216A3E0;
		  /* 8216A3E0h */ case   30:  		/* cmplwi CR6, R8, 62 */
		/* 8216A3E0h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003E);
		/* 8216A3E0h case   30:*/		return 0x8216A3E4;
		  /* 8216A3E4h */ case   31:  		/* bc 4, CR6_EQ, 16 */
		/* 8216A3E4h case   31:*/		if ( !regs.CR[6].eq ) { return 0x8216A3F4;  }
		/* 8216A3E4h case   31:*/		return 0x8216A3E8;
		  /* 8216A3E8h */ case   32:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216A3E8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A3E8h case   32:*/		return 0x8216A3EC;
		  /* 8216A3ECh */ case   33:  		/* ori R10, R10, 128 */
		/* 8216A3ECh case   33:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x80);
		/* 8216A3ECh case   33:*/		return 0x8216A3F0;
		  /* 8216A3F0h */ case   34:  		/* stw R10, <#[R11 + 12]> */
		/* 8216A3F0h case   34:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A3F0h case   34:*/		return 0x8216A3F4;
	}
	return 0x8216A3F4;
} // Block from 8216A368h-8216A3F4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8216A3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A3F4);
		  /* 8216A3F4h */ case    0:  		/* cmplwi CR6, R8, 61 */
		/* 8216A3F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003D);
		/* 8216A3F4h case    0:*/		return 0x8216A3F8;
		  /* 8216A3F8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8216A3F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216A404;  }
		/* 8216A3F8h case    1:*/		return 0x8216A3FC;
		  /* 8216A3FCh */ case    2:  		/* cmplwi CR6, R8, 15 */
		/* 8216A3FCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000000F);
		/* 8216A3FCh case    2:*/		return 0x8216A400;
		  /* 8216A400h */ case    3:  		/* bc 12, CR6_GT, 116 */
		/* 8216A400h case    3:*/		if ( regs.CR[6].gt ) { return 0x8216A474;  }
		/* 8216A400h case    3:*/		return 0x8216A404;
	}
	return 0x8216A404;
} // Block from 8216A3F4h-8216A404h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216A404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A404);
		  /* 8216A404h */ case    0:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216A404h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A404h case    0:*/		return 0x8216A408;
		  /* 8216A408h */ case    1:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 8216A408h case    1:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 8216A408h case    1:*/		return 0x8216A40C;
		  /* 8216A40Ch */ case    2:  		/* bc 4, CR0_EQ, 104 */
		/* 8216A40Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216A474;  }
		/* 8216A40Ch case    2:*/		return 0x8216A410;
		  /* 8216A410h */ case    3:  		/* b -204 */
		/* 8216A410h case    3:*/		return 0x8216A344;
		/* 8216A410h case    3:*/		return 0x8216A414;
	}
	return 0x8216A414;
} // Block from 8216A404h-8216A414h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216A414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A414);
		  /* 8216A414h */ case    0:  		/* cmplwi CR6, R8, 62 */
		/* 8216A414h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003E);
		/* 8216A414h case    0:*/		return 0x8216A418;
		  /* 8216A418h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 8216A418h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216A434;  }
		/* 8216A418h case    1:*/		return 0x8216A41C;
		  /* 8216A41Ch */ case    2:  		/* lis R11, 0 */
		/* 8216A41Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 8216A41Ch case    2:*/		return 0x8216A420;
		  /* 8216A420h */ case    3:  		/* ori R11, R11, 32864 */
		/* 8216A420h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8060);
		/* 8216A420h case    3:*/		return 0x8216A424;
		  /* 8216A424h */ case    4:  		/* lwzx R11, <#[R5 + R11]> */
		/* 8216A424h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8216A424h case    4:*/		return 0x8216A428;
		  /* 8216A428h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 8216A428h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216A428h case    5:*/		return 0x8216A42C;
		  /* 8216A42Ch */ case    6:  		/* bc 4, CR6_EQ, -108 */
		/* 8216A42Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8216A3C0;  }
		/* 8216A42Ch case    6:*/		return 0x8216A430;
		  /* 8216A430h */ case    7:  		/* b -236 */
		/* 8216A430h case    7:*/		return 0x8216A344;
		/* 8216A430h case    7:*/		return 0x8216A434;
	}
	return 0x8216A434;
} // Block from 8216A414h-8216A434h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216A434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A434);
		  /* 8216A434h */ case    0:  		/* cmplwi CR6, R8, 63 */
		/* 8216A434h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000003F);
		/* 8216A434h case    0:*/		return 0x8216A438;
		  /* 8216A438h */ case    1:  		/* bc 4, CR6_EQ, -120 */
		/* 8216A438h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216A3C0;  }
		/* 8216A438h case    1:*/		return 0x8216A43C;
		  /* 8216A43Ch */ case    2:  		/* lis R10, 0 */
		/* 8216A43Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8216A43Ch case    2:*/		return 0x8216A440;
		  /* 8216A440h */ case    3:  		/* ori R10, R10, 32868 */
		/* 8216A440h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8064);
		/* 8216A440h case    3:*/		return 0x8216A444;
		  /* 8216A444h */ case    4:  		/* b -208 */
		/* 8216A444h case    4:*/		return 0x8216A374;
		/* 8216A444h case    4:*/		return 0x8216A448;
	}
	return 0x8216A448;
} // Block from 8216A434h-8216A448h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216A448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A448);
		  /* 8216A448h */ case    0:  		/* rlwinm. R10, R11, 0, 17, 17 */
		/* 8216A448h case    0:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R10,regs.R11);
		/* 8216A448h case    0:*/		return 0x8216A44C;
		  /* 8216A44Ch */ case    1:  		/* bc 4, CR0_EQ, -264 */
		/* 8216A44Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A44Ch case    1:*/		return 0x8216A450;
		  /* 8216A450h */ case    2:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 8216A450h case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 8216A450h case    2:*/		return 0x8216A454;
		  /* 8216A454h */ case    3:  		/* bc 4, CR0_EQ, -272 */
		/* 8216A454h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216A344;  }
		/* 8216A454h case    3:*/		return 0x8216A458;
		  /* 8216A458h */ case    4:  		/* lwz R10, <#[R5 + 32]> */
		/* 8216A458h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000020) );
		/* 8216A458h case    4:*/		return 0x8216A45C;
		  /* 8216A45Ch */ case    5:  		/* rlwinm R9, R11, 24, 26, 31 */
		/* 8216A45Ch case    5:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R9,regs.R11);
		/* 8216A45Ch case    5:*/		return 0x8216A460;
		  /* 8216A460h */ case    6:  		/* cmplw CR6, R9, R10 */
		/* 8216A460h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8216A460h case    6:*/		return 0x8216A464;
		  /* 8216A464h */ case    7:  		/* bc 12, CR6_GT, -288 */
		/* 8216A464h case    7:*/		if ( regs.CR[6].gt ) { return 0x8216A344;  }
		/* 8216A464h case    7:*/		return 0x8216A468;
		  /* 8216A468h */ case    8:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 8216A468h case    8:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8216A468h case    8:*/		return 0x8216A46C;
		  /* 8216A46Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8216A46Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8216A46Ch case    9:*/		return 0x8216A470;
		  /* 8216A470h */ case   10:  		/* bc 12, CR6_GT, -300 */
		/* 8216A470h case   10:*/		if ( regs.CR[6].gt ) { return 0x8216A344;  }
		/* 8216A470h case   10:*/		return 0x8216A474;
	}
	return 0x8216A474;
} // Block from 8216A448h-8216A474h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216A474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A474);
		  /* 8216A474h */ case    0:  		/* li R3, 0 */
		/* 8216A474h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A474h case    0:*/		return 0x8216A478;
		  /* 8216A478h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216A478h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A478h case    1:*/		return 0x8216A47C;
	}
	return 0x8216A47C;
} // Block from 8216A474h-8216A47Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A47C);
		  /* 8216A47Ch */ case    0:  		/* nop */
		/* 8216A47Ch case    0:*/		cpu::op::nop();
		/* 8216A47Ch case    0:*/		return 0x8216A480;
	}
	return 0x8216A480;
} // Block from 8216A47Ch-8216A480h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A480);
		  /* 8216A480h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8216A480h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216A480h case    0:*/		return 0x8216A484;
		  /* 8216A484h */ case    1:  		/* mulli R11, R4, 12 */
		/* 8216A484h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0xC);
		/* 8216A484h case    1:*/		return 0x8216A488;
		  /* 8216A488h */ case    2:  		/* add R10, R11, R3 */
		/* 8216A488h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R3);
		/* 8216A488h case    2:*/		return 0x8216A48C;
		  /* 8216A48Ch */ case    3:  		/* li R8, 0 */
		/* 8216A48Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216A48Ch case    3:*/		return 0x8216A490;
		  /* 8216A490h */ case    4:  		/* li R3, 0 */
		/* 8216A490h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A490h case    4:*/		return 0x8216A494;
		  /* 8216A494h */ case    5:  		/* lwz R11, <#[R10]> */
		/* 8216A494h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216A494h case    5:*/		return 0x8216A498;
		  /* 8216A498h */ case    6:  		/* rlwinm R11, R11, 6, 26, 31 */
		/* 8216A498h case    6:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R11,regs.R11);
		/* 8216A498h case    6:*/		return 0x8216A49C;
		  /* 8216A49Ch */ case    7:  		/* cmplwi CR6, R11, 42 */
		/* 8216A49Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002A);
		/* 8216A49Ch case    7:*/		return 0x8216A4A0;
		  /* 8216A4A0h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8216A4A0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8216A4D0;  }
		/* 8216A4A0h case    8:*/		return 0x8216A4A4;
		  /* 8216A4A4h */ case    9:  		/* cmplwi CR6, R11, 43 */
		/* 8216A4A4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002B);
		/* 8216A4A4h case    9:*/		return 0x8216A4A8;
		  /* 8216A4A8h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 8216A4A8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8216A4CC;  }
		/* 8216A4A8h case   10:*/		return 0x8216A4AC;
		  /* 8216A4ACh */ case   11:  		/* cmplwi CR6, R11, 44 */
		/* 8216A4ACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002C);
		/* 8216A4ACh case   11:*/		return 0x8216A4B0;
		  /* 8216A4B0h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 8216A4B0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8216A4D0;  }
		/* 8216A4B0h case   12:*/		return 0x8216A4B4;
		  /* 8216A4B4h */ case   13:  		/* cmplwi CR6, R11, 45 */
		/* 8216A4B4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002D);
		/* 8216A4B4h case   13:*/		return 0x8216A4B8;
		  /* 8216A4B8h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 8216A4B8h case   14:*/		if ( regs.CR[6].eq ) { return 0x8216A4CC;  }
		/* 8216A4B8h case   14:*/		return 0x8216A4BC;
		  /* 8216A4BCh */ case   15:  		/* cmplwi CR6, R11, 46 */
		/* 8216A4BCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002E);
		/* 8216A4BCh case   15:*/		return 0x8216A4C0;
		  /* 8216A4C0h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 8216A4C0h case   16:*/		if ( regs.CR[6].eq ) { return 0x8216A4D0;  }
		/* 8216A4C0h case   16:*/		return 0x8216A4C4;
		  /* 8216A4C4h */ case   17:  		/* cmplwi CR6, R11, 47 */
		/* 8216A4C4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000002F);
		/* 8216A4C4h case   17:*/		return 0x8216A4C8;
		  /* 8216A4C8h */ case   18:  		/* bc 4, CR6_EQ, 108 */
		/* 8216A4C8h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8216A534;  }
		/* 8216A4C8h case   18:*/		return 0x8216A4CC;
	}
	return 0x8216A4CC;
} // Block from 8216A480h-8216A4CCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216A4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A4CC);
		  /* 8216A4CCh */ case    0:  		/* li R8, 1 */
		/* 8216A4CCh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8216A4CCh case    0:*/		return 0x8216A4D0;
	}
	return 0x8216A4D0;
} // Block from 8216A4CCh-8216A4D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A4D0);
		  /* 8216A4D0h */ case    0:  		/* lwz R9, <#[R10 + 8]> */
		/* 8216A4D0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8216A4D0h case    0:*/		return 0x8216A4D4;
		  /* 8216A4D4h */ case    1:  		/* rlwinm R11, R9, 8, 27, 31 */
		/* 8216A4D4h case    1:*/		cpu::op::rlwinm<0,8,27,31>(regs,&regs.R11,regs.R9);
		/* 8216A4D4h case    1:*/		return 0x8216A4D8;
		  /* 8216A4D8h */ case    2:  		/* cmplwi CR6, R11, 11 */
		/* 8216A4D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 8216A4D8h case    2:*/		return 0x8216A4DC;
		  /* 8216A4DCh */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 8216A4DCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8216A4E8;  }
		/* 8216A4DCh case    3:*/		return 0x8216A4E0;
		  /* 8216A4E0h */ case    4:  		/* cmplwi CR6, R11, 14 */
		/* 8216A4E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000E);
		/* 8216A4E0h case    4:*/		return 0x8216A4E4;
		  /* 8216A4E4h */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 8216A4E4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8216A4F0;  }
		/* 8216A4E4h case    5:*/		return 0x8216A4E8;
	}
	return 0x8216A4E8;
} // Block from 8216A4D0h-8216A4E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A4E8);
		  /* 8216A4E8h */ case    0:  		/* cmplwi CR6, R11, 17 */
		/* 8216A4E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 8216A4E8h case    0:*/		return 0x8216A4EC;
		  /* 8216A4ECh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8216A4ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216A4FC;  }
		/* 8216A4ECh case    1:*/		return 0x8216A4F0;
	}
	return 0x8216A4F0;
} // Block from 8216A4E8h-8216A4F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A4F0h
// Function '?AddTodo@@YAJPAUTODO_LIST@@KKKPBUEXPECTED_END_STACK@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A4F0);
		  /* 8216A4F0h */ case    0:  		/* lis R3, -32768 */
		/* 8216A4F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A4F0h case    0:*/		return 0x8216A4F4;
		  /* 8216A4F4h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216A4F4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A4F4h case    1:*/		return 0x8216A4F8;
		  /* 8216A4F8h */ case    2:  		/* b 248 */
		/* 8216A4F8h case    2:*/		return 0x8216A5F0;
		/* 8216A4F8h case    2:*/		return 0x8216A4FC;
	}
	return 0x8216A4FC;
} // Block from 8216A4F0h-8216A4FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216A4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A4FC);
		  /* 8216A4FCh */ case    0:  		/* lwz R7, <#[R10 + 4]> */
		/* 8216A4FCh case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8216A4FCh case    0:*/		return 0x8216A500;
		  /* 8216A500h */ case    1:  		/* li R3, 1 */
		/* 8216A500h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8216A500h case    1:*/		return 0x8216A504;
		  /* 8216A504h */ case    2:  		/* rlwinm R11, R7, 26, 6, 31 */
		/* 8216A504h case    2:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R7);
		/* 8216A504h case    2:*/		return 0x8216A508;
		  /* 8216A508h */ case    3:  		/* addi R11, R11, -1 */
		/* 8216A508h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8216A508h case    3:*/		return 0x8216A50C;
		  /* 8216A50Ch */ case    4:  		/* xor R11, R11, R7 */
		/* 8216A50Ch case    4:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8216A50Ch case    4:*/		return 0x8216A510;
		  /* 8216A510h */ case    5:  		/* rlwinm. R11, R11, 0, 30, 31 */
		/* 8216A510h case    5:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8216A510h case    5:*/		return 0x8216A514;
		  /* 8216A514h */ case    6:  		/* bc 12, CR0_EQ, -36 */
		/* 8216A514h case    6:*/		if ( regs.CR[0].eq ) { return 0x8216A4F0;  }
		/* 8216A514h case    6:*/		return 0x8216A518;
		  /* 8216A518h */ case    7:  		/* rlwinm R11, R7, 0, 0, 31 */
		/* 8216A518h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R7);
		/* 8216A518h case    7:*/		return 0x8216A51C;
		  /* 8216A51Ch */ case    8:  		/* lwz R7, <#[R5 + 32]> */
		/* 8216A51Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000020) );
		/* 8216A51Ch case    8:*/		return 0x8216A520;
		  /* 8216A520h */ case    9:  		/* rlwimi R11, R9, 4, 30, 30 */
		/* 8216A520h case    9:*/		cpu::op::rlwimi<0,4,30,30>(regs,&regs.R11,regs.R9);
		/* 8216A520h case    9:*/		return 0x8216A524;
		  /* 8216A524h */ case   10:  		/* rlwinm R11, R11, 0, 26, 30 */
		/* 8216A524h case   10:*/		cpu::op::rlwinm<0,0,26,30>(regs,&regs.R11,regs.R11);
		/* 8216A524h case   10:*/		return 0x8216A528;
		  /* 8216A528h */ case   11:  		/* or R11, R11, R8 */
		/* 8216A528h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8216A528h case   11:*/		return 0x8216A52C;
		  /* 8216A52Ch */ case   12:  		/* cmplw CR6, R11, R7 */
		/* 8216A52Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8216A52Ch case   12:*/		return 0x8216A530;
		  /* 8216A530h */ case   13:  		/* bc 12, CR6_GT, -64 */
		/* 8216A530h case   13:*/		if ( regs.CR[6].gt ) { return 0x8216A4F0;  }
		/* 8216A530h case   13:*/		return 0x8216A534;
	}
	return 0x8216A534;
} // Block from 8216A4FCh-8216A534h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216A534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A534);
		  /* 8216A534h */ case    0:  		/* lwz R4, <#[R10 + 8]> */
		/* 8216A534h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000008) );
		/* 8216A534h case    0:*/		return 0x8216A538;
		  /* 8216A538h */ case    1:  		/* li R9, 0 */
		/* 8216A538h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8216A538h case    1:*/		return 0x8216A53C;
		  /* 8216A53Ch */ case    2:  		/* subfic R11, R9, 31 */
		/* 8216A53Ch case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R9,0x1F);
		/* 8216A53Ch case    2:*/		return 0x8216A540;
		  /* 8216A540h */ case    3:  		/* li R7, 1 */
		/* 8216A540h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8216A540h case    3:*/		return 0x8216A544;
		  /* 8216A544h */ case    4:  		/* li R8, 0 */
		/* 8216A544h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216A544h case    4:*/		return 0x8216A548;
		  /* 8216A548h */ case    5:  		/* slw R7, R7, R11 */
		/* 8216A548h case    5:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 8216A548h case    5:*/		return 0x8216A54C;
		  /* 8216A54Ch */ case    6:  		/* and. R11, R7, R4 */
		/* 8216A54Ch case    6:*/		cpu::op::and<1>(regs,&regs.R11,regs.R7,regs.R4);
		/* 8216A54Ch case    6:*/		return 0x8216A550;
		  /* 8216A550h */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 8216A550h case    7:*/		if ( regs.CR[0].eq ) { return 0x8216A590;  }
		/* 8216A550h case    7:*/		return 0x8216A554;
		  /* 8216A554h */ case    8:  		/* cmpwi CR6, R9, 2 */
		/* 8216A554h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000002);
		/* 8216A554h case    8:*/		return 0x8216A558;
		  /* 8216A558h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 8216A558h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8216A564;  }
		/* 8216A558h case    9:*/		return 0x8216A55C;
		  /* 8216A55Ch */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8216A55Ch case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8216A55Ch case   10:*/		return 0x8216A560;
		  /* 8216A560h */ case   11:  		/* bc 4, CR0_EQ, 48 */
		/* 8216A560h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8216A590;  }
		/* 8216A560h case   11:*/		return 0x8216A564;
	}
	return 0x8216A564;
} // Block from 8216A534h-8216A564h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216A564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A564);
		  /* 8216A564h */ case    0:  		/* subfic R11, R9, 2 */
		/* 8216A564h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R9,0x2);
		/* 8216A564h case    0:*/		return 0x8216A568;
		  /* 8216A568h */ case    1:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8216A568h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8216A568h case    1:*/		return 0x8216A56C;
		  /* 8216A56Ch */ case    2:  		/* srw R11, R4, R11 */
		/* 8216A56Ch case    2:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 8216A56Ch case    2:*/		return 0x8216A570;
		  /* 8216A570h */ case    3:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8216A570h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8216A570h case    3:*/		return 0x8216A574;
		  /* 8216A574h */ case    4:  		/* rlwinm. R31, R11, 0, 25, 25 */
		/* 8216A574h case    4:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R31,regs.R11);
		/* 8216A574h case    4:*/		return 0x8216A578;
		  /* 8216A578h */ case    5:  		/* bc 4, CR0_EQ, -136 */
		/* 8216A578h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216A4F0;  }
		/* 8216A578h case    5:*/		return 0x8216A57C;
		  /* 8216A57Ch */ case    6:  		/* lwz R31, <#[R5 + 32]> */
		/* 8216A57Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000020) );
		/* 8216A57Ch case    6:*/		return 0x8216A580;
		  /* 8216A580h */ case    7:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 8216A580h case    7:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8216A580h case    7:*/		return 0x8216A584;
		  /* 8216A584h */ case    8:  		/* cmplw CR6, R11, R31 */
		/* 8216A584h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8216A584h case    8:*/		return 0x8216A588;
		  /* 8216A588h */ case    9:  		/* bc 12, CR6_GT, -152 */
		/* 8216A588h case    9:*/		if ( regs.CR[6].gt ) { return 0x8216A4F0;  }
		/* 8216A588h case    9:*/		return 0x8216A58C;
		  /* 8216A58Ch */ case   10:  		/* b 72 */
		/* 8216A58Ch case   10:*/		return 0x8216A5D4;
		/* 8216A58Ch case   10:*/		return 0x8216A590;
	}
	return 0x8216A590;
} // Block from 8216A564h-8216A590h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216A590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A590);
		  /* 8216A590h */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 8216A590h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8216A590h case    0:*/		return 0x8216A594;
		  /* 8216A594h */ case    1:  		/* rlwinm. R31, R11, 0, 0, 0 */
		/* 8216A594h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R31,regs.R11);
		/* 8216A594h case    1:*/		return 0x8216A598;
		  /* 8216A598h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 8216A598h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8216A5AC;  }
		/* 8216A598h case    2:*/		return 0x8216A59C;
		  /* 8216A59Ch */ case    3:  		/* rlwinm. R31, R11, 0, 1, 1 */
		/* 8216A59Ch case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R31,regs.R11);
		/* 8216A59Ch case    3:*/		return 0x8216A5A0;
		  /* 8216A5A0h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 8216A5A0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216A5AC;  }
		/* 8216A5A0h case    4:*/		return 0x8216A5A4;
		  /* 8216A5A4h */ case    5:  		/* rlwinm. R31, R11, 0, 2, 2 */
		/* 8216A5A4h case    5:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R31,regs.R11);
		/* 8216A5A4h case    5:*/		return 0x8216A5A8;
		  /* 8216A5A8h */ case    6:  		/* bc 4, CR0_EQ, -184 */
		/* 8216A5A8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216A4F0;  }
		/* 8216A5A8h case    6:*/		return 0x8216A5AC;
	}
	return 0x8216A5AC;
} // Block from 8216A590h-8216A5ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216A5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A5AC);
		  /* 8216A5ACh */ case    0:  		/* rlwinm. R31, R11, 0, 0, 0 */
		/* 8216A5ACh case    0:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R31,regs.R11);
		/* 8216A5ACh case    0:*/		return 0x8216A5B0;
		  /* 8216A5B0h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 8216A5B0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216A5D4;  }
		/* 8216A5B0h case    1:*/		return 0x8216A5B4;
		  /* 8216A5B4h */ case    2:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8216A5B4h case    2:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8216A5B4h case    2:*/		return 0x8216A5B8;
		  /* 8216A5B8h */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 8216A5B8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216A5D4;  }
		/* 8216A5B8h case    3:*/		return 0x8216A5BC;
		  /* 8216A5BCh */ case    4:  		/* lwz R11, <#[R6]> */
		/* 8216A5BCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8216A5BCh case    4:*/		return 0x8216A5C0;
		  /* 8216A5C0h */ case    5:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216A5C0h case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216A5C0h case    5:*/		return 0x8216A5C4;
		  /* 8216A5C4h */ case    6:  		/* add R11, R11, R6 */
		/* 8216A5C4h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8216A5C4h case    6:*/		return 0x8216A5C8;
		  /* 8216A5C8h */ case    7:  		/* lhz R11, <#[R11 + 12]> */
		/* 8216A5C8h case    7:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A5C8h case    7:*/		return 0x8216A5CC;
		  /* 8216A5CCh */ case    8:  		/* rlwinm. R11, R11, 0, 29, 31 */
		/* 8216A5CCh case    8:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8216A5CCh case    8:*/		return 0x8216A5D0;
		  /* 8216A5D0h */ case    9:  		/* bc 12, CR0_EQ, -224 */
		/* 8216A5D0h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216A4F0;  }
		/* 8216A5D0h case    9:*/		return 0x8216A5D4;
	}
	return 0x8216A5D4;
} // Block from 8216A5ACh-8216A5D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216A5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A5D4);
		  /* 8216A5D4h */ case    0:  		/* addi R8, R8, 1 */
		/* 8216A5D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216A5D4h case    0:*/		return 0x8216A5D8;
		  /* 8216A5D8h */ case    1:  		/* cmpwi CR6, R8, 4 */
		/* 8216A5D8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000004);
		/* 8216A5D8h case    1:*/		return 0x8216A5DC;
		  /* 8216A5DCh */ case    2:  		/* bc 12, CR6_LT, -144 */
		/* 8216A5DCh case    2:*/		if ( regs.CR[6].lt ) { return 0x8216A54C;  }
		/* 8216A5DCh case    2:*/		return 0x8216A5E0;
		  /* 8216A5E0h */ case    3:  		/* addi R9, R9, 1 */
		/* 8216A5E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216A5E0h case    3:*/		return 0x8216A5E4;
		  /* 8216A5E4h */ case    4:  		/* cmpwi CR6, R9, 3 */
		/* 8216A5E4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000003);
		/* 8216A5E4h case    4:*/		return 0x8216A5E8;
		  /* 8216A5E8h */ case    5:  		/* bc 12, CR6_LT, -172 */
		/* 8216A5E8h case    5:*/		if ( regs.CR[6].lt ) { return 0x8216A53C;  }
		/* 8216A5E8h case    5:*/		return 0x8216A5EC;
		  /* 8216A5ECh */ case    6:  		/* li R3, 0 */
		/* 8216A5ECh case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A5ECh case    6:*/		return 0x8216A5F0;
	}
	return 0x8216A5F0;
} // Block from 8216A5D4h-8216A5F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216A5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A5F0);
		  /* 8216A5F0h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 8216A5F0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216A5F0h case    0:*/		return 0x8216A5F4;
		  /* 8216A5F4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8216A5F4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216A5F4h case    1:*/		return 0x8216A5F8;
	}
	return 0x8216A5F8;
} // Block from 8216A5F0h-8216A5F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A5F8);
		  /* 8216A5F8h */ case    0:  		/* mfspr R12, LR */
		/* 8216A5F8h case    0:*/		regs.R12 = regs.LR;
		/* 8216A5F8h case    0:*/		return 0x8216A5FC;
		  /* 8216A5FCh */ case    1:  		/* bl -889776 */
		/* 8216A5FCh case    1:*/		regs.LR = 0x8216A600; return 0x8209124C;
		/* 8216A5FCh case    1:*/		return 0x8216A600;
	}
	return 0x8216A600;
} // Block from 8216A5F8h-8216A600h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A600h
// Function '?AddTodo_Push@@YAJPAUTODO_LIST@@KKKPBUEXPECTED_END_STACK@@W4EXPECTED_END@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A600);
		  /* 8216A600h */ case    0:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216A600h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216A600h case    0:*/		return 0x8216A604;
		  /* 8216A604h */ case    1:  		/* mr R29, R10 */
		/* 8216A604h case    1:*/		regs.R29 = regs.R10;
		/* 8216A604h case    1:*/		return 0x8216A608;
		  /* 8216A608h */ case    2:  		/* lwz R11, <#[R9]> */
		/* 8216A608h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8216A608h case    2:*/		return 0x8216A60C;
		  /* 8216A60Ch */ case    3:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 8216A60Ch case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 8216A60Ch case    3:*/		return 0x8216A610;
		  /* 8216A610h */ case    4:  		/* mr R30, R3 */
		/* 8216A610h case    4:*/		regs.R30 = regs.R3;
		/* 8216A610h case    4:*/		return 0x8216A614;
		  /* 8216A614h */ case    5:  		/* mr R31, R4 */
		/* 8216A614h case    5:*/		regs.R31 = regs.R4;
		/* 8216A614h case    5:*/		return 0x8216A618;
		  /* 8216A618h */ case    6:  		/* mr R27, R8 */
		/* 8216A618h case    6:*/		regs.R27 = regs.R8;
		/* 8216A618h case    6:*/		return 0x8216A61C;
		  /* 8216A61Ch */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 8216A61Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216A61Ch case    7:*/		return 0x8216A620;
		  /* 8216A620h */ case    8:  		/* bc 12, CR6_LT, 16 */
		/* 8216A620h case    8:*/		if ( regs.CR[6].lt ) { return 0x8216A630;  }
		/* 8216A620h case    8:*/		return 0x8216A624;
		  /* 8216A624h */ case    9:  		/* lis R3, -32768 */
		/* 8216A624h case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A624h case    9:*/		return 0x8216A628;
		  /* 8216A628h */ case   10:  		/* ori R3, R3, 16389 */
		/* 8216A628h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A628h case   10:*/		return 0x8216A62C;
		  /* 8216A62Ch */ case   11:  		/* b 412 */
		/* 8216A62Ch case   11:*/		return 0x8216A7C8;
		/* 8216A62Ch case   11:*/		return 0x8216A630;
	}
	return 0x8216A630;
} // Block from 8216A600h-8216A630h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216A630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A630);
		  /* 8216A630h */ case    0:  		/* lwz R28, <#[R1 + 228]> */
		/* 8216A630h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000E4) );
		/* 8216A630h case    0:*/		return 0x8216A634;
		  /* 8216A634h */ case    1:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 8216A634h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 8216A634h case    1:*/		return 0x8216A638;
		  /* 8216A638h */ case    2:  		/* lwz R11, <#[R28]> */
		/* 8216A638h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8216A638h case    2:*/		return 0x8216A63C;
		  /* 8216A63Ch */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216A63Ch case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216A63Ch case    3:*/		return 0x8216A640;
		  /* 8216A640h */ case    4:  		/* add R26, R11, R28 */
		/* 8216A640h case    4:*/		cpu::op::add<0>(regs,&regs.R26,regs.R11,regs.R28);
		/* 8216A640h case    4:*/		return 0x8216A644;
		  /* 8216A644h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8216A644h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216A658;  }
		/* 8216A644h case    5:*/		return 0x8216A648;
		  /* 8216A648h */ case    6:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216A648h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A648h case    6:*/		return 0x8216A64C;
		  /* 8216A64Ch */ case    7:  		/* li R12, -4417 */
		/* 8216A64Ch case    7:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFEEBF);
		/* 8216A64Ch case    7:*/		return 0x8216A650;
		  /* 8216A650h */ case    8:  		/* and R11, R11, R12 */
		/* 8216A650h case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8216A650h case    8:*/		return 0x8216A654;
		  /* 8216A654h */ case    9:  		/* stw R11, <#[R26 + 12]> */
		/* 8216A654h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A654h case    9:*/		return 0x8216A658;
	}
	return 0x8216A658;
} // Block from 8216A630h-8216A658h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216A658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A658);
		  /* 8216A658h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216A658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A658h case    0:*/		return 0x8216A65C;
		  /* 8216A65Ch */ case    1:  		/* rlwinm. R25, R7, 0, 24, 31 */
		/* 8216A65Ch case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R25,regs.R7);
		/* 8216A65Ch case    1:*/		return 0x8216A660;
		  /* 8216A660h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 8216A660h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216A674;  }
		/* 8216A660h case    2:*/		return 0x8216A664;
		  /* 8216A664h */ case    3:  		/* rlwinm R11, R11, 0, 24, 21 */
		/* 8216A664h case    3:*/		cpu::op::rlwinm<0,0,24,21>(regs,&regs.R11,regs.R11);
		/* 8216A664h case    3:*/		return 0x8216A668;
		  /* 8216A668h */ case    4:  		/* li R6, 3 */
		/* 8216A668h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 8216A668h case    4:*/		return 0x8216A66C;
		  /* 8216A66Ch */ case    5:  		/* rlwinm R11, R11, 0, 20, 18 */
		/* 8216A66Ch case    5:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R11,regs.R11);
		/* 8216A66Ch case    5:*/		return 0x8216A670;
		  /* 8216A670h */ case    6:  		/* b 44 */
		/* 8216A670h case    6:*/		return 0x8216A69C;
		/* 8216A670h case    6:*/		return 0x8216A674;
	}
	return 0x8216A674;
} // Block from 8216A658h-8216A674h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216A674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A674);
		  /* 8216A674h */ case    0:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 8216A674h case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 8216A674h case    0:*/		return 0x8216A678;
		  /* 8216A678h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8216A678h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216A684;  }
		/* 8216A678h case    1:*/		return 0x8216A67C;
		  /* 8216A67Ch */ case    2:  		/* rlwinm R11, R11, 0, 20, 18 */
		/* 8216A67Ch case    2:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R11,regs.R11);
		/* 8216A67Ch case    2:*/		return 0x8216A680;
		  /* 8216A680h */ case    3:  		/* stw R11, <#[R26 + 12]> */
		/* 8216A680h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A680h case    3:*/		return 0x8216A684;
	}
	return 0x8216A684;
} // Block from 8216A674h-8216A684h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216A684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A684);
		  /* 8216A684h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216A684h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A684h case    0:*/		return 0x8216A688;
		  /* 8216A688h */ case    1:  		/* li R10, 512 */
		/* 8216A688h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x200);
		/* 8216A688h case    1:*/		return 0x8216A68C;
		  /* 8216A68Ch */ case    2:  		/* li R6, 2 */
		/* 8216A68Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 8216A68Ch case    2:*/		return 0x8216A690;
		  /* 8216A690h */ case    3:  		/* rlwimi R10, R27, 8, 23, 23 */
		/* 8216A690h case    3:*/		cpu::op::rlwimi<0,8,23,23>(regs,&regs.R10,regs.R27);
		/* 8216A690h case    3:*/		return 0x8216A694;
		  /* 8216A694h */ case    4:  		/* rlwinm R11, R11, 0, 24, 22 */
		/* 8216A694h case    4:*/		cpu::op::rlwinm<0,0,24,22>(regs,&regs.R11,regs.R11);
		/* 8216A694h case    4:*/		return 0x8216A698;
		  /* 8216A698h */ case    5:  		/* or R11, R10, R11 */
		/* 8216A698h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216A698h case    5:*/		return 0x8216A69C;
	}
	return 0x8216A69C;
} // Block from 8216A684h-8216A69Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A69Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A69C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A69C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A69C);
		  /* 8216A69Ch */ case    0:  		/* stw R11, <#[R26 + 12]> */
		/* 8216A69Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A69Ch case    0:*/		return 0x8216A6A0;
		  /* 8216A6A0h */ case    1:  		/* li R11, 0 */
		/* 8216A6A0h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216A6A0h case    1:*/		return 0x8216A6A4;
		  /* 8216A6A4h */ case    2:  		/* rlwinm R7, R31, 1, 0, 30 */
		/* 8216A6A4h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R31);
		/* 8216A6A4h case    2:*/		return 0x8216A6A8;
		  /* 8216A6A8h */ case    3:  		/* add R10, R7, R11 */
		/* 8216A6A8h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R11);
		/* 8216A6A8h case    3:*/		return 0x8216A6AC;
		  /* 8216A6ACh */ case    4:  		/* addi R10, R10, 1 */
		/* 8216A6ACh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216A6ACh case    4:*/		return 0x8216A6B0;
		  /* 8216A6B0h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8216A6B0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8216A6B0h case    5:*/		return 0x8216A6B4;
		  /* 8216A6B4h */ case    6:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8216A6B4h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8216A6B4h case    6:*/		return 0x8216A6B8;
		  /* 8216A6B8h */ case    7:  		/* rlwinm. R8, R8, 2, 30, 31 */
		/* 8216A6B8h case    7:*/		cpu::op::rlwinm<1,2,30,31>(regs,&regs.R8,regs.R8);
		/* 8216A6B8h case    7:*/		return 0x8216A6BC;
		  /* 8216A6BCh */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 8216A6BCh case    8:*/		if ( regs.CR[0].eq ) { return 0x8216A6C8;  }
		/* 8216A6BCh case    8:*/		return 0x8216A6C0;
		  /* 8216A6C0h */ case    9:  		/* cmplw CR6, R8, R6 */
		/* 8216A6C0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R6);
		/* 8216A6C0h case    9:*/		return 0x8216A6C4;
		  /* 8216A6C4h */ case   10:  		/* bc 4, CR6_EQ, -160 */
		/* 8216A6C4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8216A624;  }
		/* 8216A6C4h case   10:*/		return 0x8216A6C8;
	}
	return 0x8216A6C8;
} // Block from 8216A69Ch-8216A6C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216A6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A6C8);
		  /* 8216A6C8h */ case    0:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8216A6C8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8216A6C8h case    0:*/		return 0x8216A6CC;
		  /* 8216A6CCh */ case    1:  		/* addi R11, R11, 1 */
		/* 8216A6CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216A6CCh case    1:*/		return 0x8216A6D0;
		  /* 8216A6D0h */ case    2:  		/* rlwimi R8, R6, 30, 0, 1 */
		/* 8216A6D0h case    2:*/		cpu::op::rlwimi<0,30,0,1>(regs,&regs.R8,regs.R6);
		/* 8216A6D0h case    2:*/		return 0x8216A6D4;
		  /* 8216A6D4h */ case    3:  		/* cmpwi CR6, R11, 2 */
		/* 8216A6D4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8216A6D4h case    3:*/		return 0x8216A6D8;
		  /* 8216A6D8h */ case    4:  		/* stwx R8, <#[R10 + R9]> */
		/* 8216A6D8h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8216A6D8h case    4:*/		return 0x8216A6DC;
		  /* 8216A6DCh */ case    5:  		/* bc 12, CR6_LT, -52 */
		/* 8216A6DCh case    5:*/		if ( regs.CR[6].lt ) { return 0x8216A6A8;  }
		/* 8216A6DCh case    5:*/		return 0x8216A6E0;
	}
	return 0x8216A6E0;
} // Block from 8216A6C8h-8216A6E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A6E0h
// Function '?AddTodo_Change@@YAJPAUTODO_LIST@@KKKPBUEXPECTED_END_STACK@@W4EXPECTED_END@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A6E0);
		  /* 8216A6E0h */ case    0:  		/* rlwinm. R5, R5, 0, 24, 31 */
		/* 8216A6E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R5,regs.R5);
		/* 8216A6E0h case    0:*/		return 0x8216A6E4;
		  /* 8216A6E4h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8216A6E4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8216A6E4h case    1:*/		return 0x8216A6E8;
		  /* 8216A6E8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8216A6E8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8216A6F4;  }
		/* 8216A6E8h case    2:*/		return 0x8216A6EC;
		  /* 8216A6ECh */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8216A6ECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216A6F8;  }
		/* 8216A6ECh case    3:*/		return 0x8216A6F0;
		  /* 8216A6F0h */ case    4:  		/* b -204 */
		/* 8216A6F0h case    4:*/		return 0x8216A624;
		/* 8216A6F0h case    4:*/		return 0x8216A6F4;
	}
	return 0x8216A6F4;
} // Block from 8216A6E0h-8216A6F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216A6F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A6F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A6F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A6F4);
		  /* 8216A6F4h */ case    0:  		/* bc 12, CR6_EQ, 100 */
		/* 8216A6F4h case    0:*/		if ( regs.CR[6].eq ) { return 0x8216A758;  }
		/* 8216A6F4h case    0:*/		return 0x8216A6F8;
	}
	return 0x8216A6F8;
} // Block from 8216A6F4h-8216A6F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A6F8);
		  /* 8216A6F8h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 8216A6F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8216A6F8h case    0:*/		return 0x8216A6FC;
		  /* 8216A6FCh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8216A6FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8216A710;  }
		/* 8216A6FCh case    1:*/		return 0x8216A700;
		  /* 8216A700h */ case    2:  		/* mulli R11, R31, 12 */
		/* 8216A700h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0xC);
		/* 8216A700h case    2:*/		return 0x8216A704;
		  /* 8216A704h */ case    3:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8216A704h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8216A704h case    3:*/		return 0x8216A708;
		  /* 8216A708h */ case    4:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8216A708h case    4:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8216A708h case    4:*/		return 0x8216A70C;
		  /* 8216A70Ch */ case    5:  		/* bc 4, CR0_EQ, -232 */
		/* 8216A70Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8216A624;  }
		/* 8216A70Ch case    5:*/		return 0x8216A710;
	}
	return 0x8216A710;
} // Block from 8216A6F8h-8216A710h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216A710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A710);
		  /* 8216A710h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 8216A710h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8216A710h case    0:*/		return 0x8216A714;
		  /* 8216A714h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 8216A714h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216A758;  }
		/* 8216A714h case    1:*/		return 0x8216A718;
		  /* 8216A718h */ case    2:  		/* mulli R11, R31, 12 */
		/* 8216A718h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0xC);
		/* 8216A718h case    2:*/		return 0x8216A71C;
		  /* 8216A71Ch */ case    3:  		/* lwzx R11, <#[R11 + R30]> */
		/* 8216A71Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8216A71Ch case    3:*/		return 0x8216A720;
		  /* 8216A720h */ case    4:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8216A720h case    4:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8216A720h case    4:*/		return 0x8216A724;
		  /* 8216A724h */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 8216A724h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216A73C;  }
		/* 8216A724h case    5:*/		return 0x8216A728;
		  /* 8216A728h */ case    6:  		/* mr R5, R29 */
		/* 8216A728h case    6:*/		regs.R5 = regs.R29;
		/* 8216A728h case    6:*/		return 0x8216A72C;
		  /* 8216A72Ch */ case    7:  		/* mr R4, R31 */
		/* 8216A72Ch case    7:*/		regs.R4 = regs.R31;
		/* 8216A72Ch case    7:*/		return 0x8216A730;
		  /* 8216A730h */ case    8:  		/* mr R3, R30 */
		/* 8216A730h case    8:*/		regs.R3 = regs.R30;
		/* 8216A730h case    8:*/		return 0x8216A734;
		  /* 8216A734h */ case    9:  		/* bl -2228 */
		/* 8216A734h case    9:*/		regs.LR = 0x8216A738; return 0x82169E80;
		/* 8216A734h case    9:*/		return 0x8216A738;
		  /* 8216A738h */ case   10:  		/* b 112 */
		/* 8216A738h case   10:*/		return 0x8216A7A8;
		/* 8216A738h case   10:*/		return 0x8216A73C;
	}
	return 0x8216A73C;
} // Block from 8216A710h-8216A73Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216A73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A73C);
		  /* 8216A73Ch */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 8216A73Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8216A73Ch case    0:*/		return 0x8216A740;
		  /* 8216A740h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8216A740h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216A758;  }
		/* 8216A740h case    1:*/		return 0x8216A744;
		  /* 8216A744h */ case    2:  		/* mr R6, R29 */
		/* 8216A744h case    2:*/		regs.R6 = regs.R29;
		/* 8216A744h case    2:*/		return 0x8216A748;
		  /* 8216A748h */ case    3:  		/* mr R4, R31 */
		/* 8216A748h case    3:*/		regs.R4 = regs.R31;
		/* 8216A748h case    3:*/		return 0x8216A74C;
		  /* 8216A74Ch */ case    4:  		/* mr R3, R30 */
		/* 8216A74Ch case    4:*/		regs.R3 = regs.R30;
		/* 8216A74Ch case    4:*/		return 0x8216A750;
		  /* 8216A750h */ case    5:  		/* bl -1640 */
		/* 8216A750h case    5:*/		regs.LR = 0x8216A754; return 0x8216A0E8;
		/* 8216A750h case    5:*/		return 0x8216A754;
		  /* 8216A754h */ case    6:  		/* b 84 */
		/* 8216A754h case    6:*/		return 0x8216A7A8;
		/* 8216A754h case    6:*/		return 0x8216A758;
	}
	return 0x8216A758;
} // Block from 8216A73Ch-8216A758h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216A758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A758);
		  /* 8216A758h */ case    0:  		/* mr R6, R28 */
		/* 8216A758h case    0:*/		regs.R6 = regs.R28;
		/* 8216A758h case    0:*/		return 0x8216A75C;
		  /* 8216A75Ch */ case    1:  		/* mr R5, R29 */
		/* 8216A75Ch case    1:*/		regs.R5 = regs.R29;
		/* 8216A75Ch case    1:*/		return 0x8216A760;
		  /* 8216A760h */ case    2:  		/* mr R4, R31 */
		/* 8216A760h case    2:*/		regs.R4 = regs.R31;
		/* 8216A760h case    2:*/		return 0x8216A764;
		  /* 8216A764h */ case    3:  		/* mr R3, R30 */
		/* 8216A764h case    3:*/		regs.R3 = regs.R30;
		/* 8216A764h case    3:*/		return 0x8216A768;
		  /* 8216A768h */ case    4:  		/* bl -744 */
		/* 8216A768h case    4:*/		regs.LR = 0x8216A76C; return 0x8216A480;
		/* 8216A768h case    4:*/		return 0x8216A76C;
		  /* 8216A76Ch */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8216A76Ch case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216A76Ch case    5:*/		return 0x8216A770;
		  /* 8216A770h */ case    6:  		/* bc 12, CR0_LT, 56 */
		/* 8216A770h case    6:*/		if ( regs.CR[0].lt ) { return 0x8216A7A8;  }
		/* 8216A770h case    6:*/		return 0x8216A774;
		  /* 8216A774h */ case    7:  		/* mr R6, R29 */
		/* 8216A774h case    7:*/		regs.R6 = regs.R29;
		/* 8216A774h case    7:*/		return 0x8216A778;
		  /* 8216A778h */ case    8:  		/* mr R5, R27 */
		/* 8216A778h case    8:*/		regs.R5 = regs.R27;
		/* 8216A778h case    8:*/		return 0x8216A77C;
		  /* 8216A77Ch */ case    9:  		/* mr R4, R31 */
		/* 8216A77Ch case    9:*/		regs.R4 = regs.R31;
		/* 8216A77Ch case    9:*/		return 0x8216A780;
		  /* 8216A780h */ case   10:  		/* mr R3, R30 */
		/* 8216A780h case   10:*/		regs.R3 = regs.R30;
		/* 8216A780h case   10:*/		return 0x8216A784;
		  /* 8216A784h */ case   11:  		/* bl -1428 */
		/* 8216A784h case   11:*/		regs.LR = 0x8216A788; return 0x8216A1F0;
		/* 8216A784h case   11:*/		return 0x8216A788;
		  /* 8216A788h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 8216A788h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216A788h case   12:*/		return 0x8216A78C;
		  /* 8216A78Ch */ case   13:  		/* bc 12, CR0_LT, 28 */
		/* 8216A78Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x8216A7A8;  }
		/* 8216A78Ch case   13:*/		return 0x8216A790;
		  /* 8216A790h */ case   14:  		/* mr R6, R28 */
		/* 8216A790h case   14:*/		regs.R6 = regs.R28;
		/* 8216A790h case   14:*/		return 0x8216A794;
		  /* 8216A794h */ case   15:  		/* mr R5, R29 */
		/* 8216A794h case   15:*/		regs.R5 = regs.R29;
		/* 8216A794h case   15:*/		return 0x8216A798;
		  /* 8216A798h */ case   16:  		/* mr R3, R30 */
		/* 8216A798h case   16:*/		regs.R3 = regs.R30;
		/* 8216A798h case   16:*/		return 0x8216A79C;
		  /* 8216A79Ch */ case   17:  		/* bl -1164 */
		/* 8216A79Ch case   17:*/		regs.LR = 0x8216A7A0; return 0x8216A310;
		/* 8216A79Ch case   17:*/		return 0x8216A7A0;
		  /* 8216A7A0h */ case   18:  		/* srawi R11, R3, 31 */
		/* 8216A7A0h case   18:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 8216A7A0h case   18:*/		return 0x8216A7A4;
		  /* 8216A7A4h */ case   19:  		/* and R3, R11, R3 */
		/* 8216A7A4h case   19:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 8216A7A4h case   19:*/		return 0x8216A7A8;
	}
	return 0x8216A7A8;
} // Block from 8216A758h-8216A7A8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216A7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A7A8);
		  /* 8216A7A8h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 8216A7A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8216A7A8h case    0:*/		return 0x8216A7AC;
		  /* 8216A7ACh */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 8216A7ACh case    1:*/		if ( regs.CR[6].lt ) { return 0x8216A7C8;  }
		/* 8216A7ACh case    1:*/		return 0x8216A7B0;
		  /* 8216A7B0h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 8216A7B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8216A7B0h case    2:*/		return 0x8216A7B4;
		  /* 8216A7B4h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8216A7B4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216A7C4;  }
		/* 8216A7B4h case    3:*/		return 0x8216A7B8;
		  /* 8216A7B8h */ case    4:  		/* lwz R11, <#[R26 + 12]> */
		/* 8216A7B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A7B8h case    4:*/		return 0x8216A7BC;
		  /* 8216A7BCh */ case    5:  		/* ori R11, R11, 64 */
		/* 8216A7BCh case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 8216A7BCh case    5:*/		return 0x8216A7C0;
		  /* 8216A7C0h */ case    6:  		/* stw R11, <#[R26 + 12]> */
		/* 8216A7C0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8216A7C0h case    6:*/		return 0x8216A7C4;
	}
	return 0x8216A7C4;
} // Block from 8216A7A8h-8216A7C4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216A7C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A7C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A7C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A7C4);
		  /* 8216A7C4h */ case    0:  		/* li R3, 0 */
		/* 8216A7C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A7C4h case    0:*/		return 0x8216A7C8;
	}
	return 0x8216A7C8;
} // Block from 8216A7C4h-8216A7C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A7C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A7C8);
		  /* 8216A7C8h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216A7C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216A7C8h case    0:*/		return 0x8216A7CC;
		  /* 8216A7CCh */ case    1:  		/* b -890160 */
		/* 8216A7CCh case    1:*/		return 0x8209129C;
		/* 8216A7CCh case    1:*/		return 0x8216A7D0;
	}
	return 0x8216A7D0;
} // Block from 8216A7C8h-8216A7D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A7D0);
		  /* 8216A7D0h */ case    0:  		/* mfspr R12, LR */
		/* 8216A7D0h case    0:*/		regs.R12 = regs.LR;
		/* 8216A7D0h case    0:*/		return 0x8216A7D4;
		  /* 8216A7D4h */ case    1:  		/* bl -890264 */
		/* 8216A7D4h case    1:*/		regs.LR = 0x8216A7D8; return 0x8209123C;
		/* 8216A7D4h case    1:*/		return 0x8216A7D8;
		  /* 8216A7D8h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 8216A7D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8216A7D8h case    2:*/		return 0x8216A7DC;
		  /* 8216A7DCh */ case    3:  		/* std R3, <#[R1 + 208]> */
		/* 8216A7DCh case    3:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x000000D0) );
		/* 8216A7DCh case    3:*/		return 0x8216A7E0;
		  /* 8216A7E0h */ case    4:  		/* mr R25, R4 */
		/* 8216A7E0h case    4:*/		regs.R25 = regs.R4;
		/* 8216A7E0h case    4:*/		return 0x8216A7E4;
		  /* 8216A7E4h */ case    5:  		/* lwz R29, <#[R1 + 208]> */
		/* 8216A7E4h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000D0) );
		/* 8216A7E4h case    5:*/		return 0x8216A7E8;
		  /* 8216A7E8h */ case    6:  		/* rlwinm R22, R29, 20, 29, 31 */
		/* 8216A7E8h case    6:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R22,regs.R29);
		/* 8216A7E8h case    6:*/		return 0x8216A7EC;
		  /* 8216A7ECh */ case    7:  		/* mr R26, R5 */
		/* 8216A7ECh case    7:*/		regs.R26 = regs.R5;
		/* 8216A7ECh case    7:*/		return 0x8216A7F0;
		  /* 8216A7F0h */ case    8:  		/* mr R24, R6 */
		/* 8216A7F0h case    8:*/		regs.R24 = regs.R6;
		/* 8216A7F0h case    8:*/		return 0x8216A7F4;
		  /* 8216A7F4h */ case    9:  		/* mr R23, R7 */
		/* 8216A7F4h case    9:*/		regs.R23 = regs.R7;
		/* 8216A7F4h case    9:*/		return 0x8216A7F8;
		  /* 8216A7F8h */ case   10:  		/* cmplwi CR6, R22, 6 */
		/* 8216A7F8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000006);
		/* 8216A7F8h case   10:*/		return 0x8216A7FC;
		  /* 8216A7FCh */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 8216A7FCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x8216A80C;  }
		/* 8216A7FCh case   11:*/		return 0x8216A800;
		  /* 8216A800h */ case   12:  		/* lis R3, -32768 */
		/* 8216A800h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216A800h case   12:*/		return 0x8216A804;
		  /* 8216A804h */ case   13:  		/* ori R3, R3, 16389 */
		/* 8216A804h case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216A804h case   13:*/		return 0x8216A808;
		  /* 8216A808h */ case   14:  		/* b 272 */
		/* 8216A808h case   14:*/		return 0x8216A918;
		/* 8216A808h case   14:*/		return 0x8216A80C;
	}
	return 0x8216A80C;
} // Block from 8216A7D0h-8216A80Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216A80Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A80C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A80C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A80C);
		  /* 8216A80Ch */ case    0:  		/* li R30, 0 */
		/* 8216A80Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8216A80Ch case    0:*/		return 0x8216A810;
		  /* 8216A810h */ case    1:  		/* cmplwi CR6, R22, 0 */
		/* 8216A810h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8216A810h case    1:*/		return 0x8216A814;
		  /* 8216A814h */ case    2:  		/* bc 12, CR6_EQ, 220 */
		/* 8216A814h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216A8F0;  }
		/* 8216A814h case    2:*/		return 0x8216A818;
		  /* 8216A818h */ case    3:  		/* lwz R28, <#[R1 + 212]> */
		/* 8216A818h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000D4) );
		/* 8216A818h case    3:*/		return 0x8216A81C;
		  /* 8216A81Ch */ case    4:  		/* rlwinm R21, R29, 0, 20, 31 */
		/* 8216A81Ch case    4:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R21,regs.R29);
		/* 8216A81Ch case    4:*/		return 0x8216A820;
		  /* 8216A820h */ case    5:  		/* li R31, 0 */
		/* 8216A820h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8216A820h case    5:*/		return 0x8216A824;
		  /* 8216A824h */ case    6:  		/* li R27, 1 */
		/* 8216A824h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8216A824h case    6:*/		return 0x8216A828;
	}
	return 0x8216A828;
} // Block from 8216A80Ch-8216A828h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216A828h
// Function '?AddTodo_Pop@@YAJPAUTODO_LIST@@KKKPBUEXPECTED_END_STACK@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A828);
		  /* 8216A828h */ case    0:  		/* add R4, R21, R30 */
		/* 8216A828h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R21,regs.R30);
		/* 8216A828h case    0:*/		return 0x8216A82C;
		  /* 8216A82Ch */ case    1:  		/* lwz R11, <#[R26]> */
		/* 8216A82Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8216A82Ch case    1:*/		return 0x8216A830;
		  /* 8216A830h */ case    2:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 8216A830h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 8216A830h case    2:*/		return 0x8216A834;
		  /* 8216A834h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 8216A834h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216A834h case    3:*/		return 0x8216A838;
		  /* 8216A838h */ case    4:  		/* bc 4, CR6_LT, -56 */
		/* 8216A838h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8216A800;  }
		/* 8216A838h case    4:*/		return 0x8216A83C;
		  /* 8216A83Ch */ case    5:  		/* rlwinm R10, R29, 4, 28, 31 */
		/* 8216A83Ch case    5:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R10,regs.R29);
		/* 8216A83Ch case    5:*/		return 0x8216A840;
		  /* 8216A840h */ case    6:  		/* rlwinm R11, R28, 4, 26, 27 */
		/* 8216A840h case    6:*/		cpu::op::rlwinm<0,4,26,27>(regs,&regs.R11,regs.R28);
		/* 8216A840h case    6:*/		return 0x8216A844;
		  /* 8216A844h */ case    7:  		/* li R9, 2 */
		/* 8216A844h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8216A844h case    7:*/		return 0x8216A848;
		  /* 8216A848h */ case    8:  		/* or R11, R11, R10 */
		/* 8216A848h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216A848h case    8:*/		return 0x8216A84C;
		  /* 8216A84Ch */ case    9:  		/* slw R10, R27, R30 */
		/* 8216A84Ch case    9:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R30);
		/* 8216A84Ch case    9:*/		return 0x8216A850;
		  /* 8216A850h */ case   10:  		/* slw R9, R9, R31 */
		/* 8216A850h case   10:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 8216A850h case   10:*/		return 0x8216A854;
		  /* 8216A854h */ case   11:  		/* rlwinm R8, R29, 16, 16, 31 */
		/* 8216A854h case   11:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R29);
		/* 8216A854h case   11:*/		return 0x8216A858;
		  /* 8216A858h */ case   12:  		/* and R11, R11, R10 */
		/* 8216A858h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8216A858h case   12:*/		return 0x8216A85C;
		  /* 8216A85Ch */ case   13:  		/* and R10, R9, R8 */
		/* 8216A85Ch case   13:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R8);
		/* 8216A85Ch case   13:*/		return 0x8216A860;
		  /* 8216A860h */ case   14:  		/* slw R9, R27, R31 */
		/* 8216A860h case   14:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R31);
		/* 8216A860h case   14:*/		return 0x8216A864;
		  /* 8216A864h */ case   15:  		/* addic R7, R11, -1 */
		/* 8216A864h case   15:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 8216A864h case   15:*/		return 0x8216A868;
		  /* 8216A868h */ case   16:  		/* rlwinm R10, R10, 0, 20, 31 */
		/* 8216A868h case   16:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R10);
		/* 8216A868h case   16:*/		return 0x8216A86C;
		  /* 8216A86Ch */ case   17:  		/* and R9, R9, R8 */
		/* 8216A86Ch case   17:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216A86Ch case   17:*/		return 0x8216A870;
		  /* 8216A870h */ case   18:  		/* subfe R5, R7, R11 */
		/* 8216A870h case   18:*/		cpu::op::subfe<0>(regs,&regs.R5,regs.R7,regs.R11);
		/* 8216A870h case   18:*/		return 0x8216A874;
		  /* 8216A874h */ case   19:  		/* addic R11, R10, -1 */
		/* 8216A874h case   19:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8216A874h case   19:*/		return 0x8216A878;
		  /* 8216A878h */ case   20:  		/* rlwinm R9, R9, 0, 20, 31 */
		/* 8216A878h case   20:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R9);
		/* 8216A878h case   20:*/		return 0x8216A87C;
		  /* 8216A87Ch */ case   21:  		/* subfe R6, R11, R10 */
		/* 8216A87Ch case   21:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R11,regs.R10);
		/* 8216A87Ch case   21:*/		return 0x8216A880;
		  /* 8216A880h */ case   22:  		/* addic R10, R9, -1 */
		/* 8216A880h case   22:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 8216A880h case   22:*/		return 0x8216A884;
		  /* 8216A884h */ case   23:  		/* rlwinm R11, R28, 20, 28, 31 */
		/* 8216A884h case   23:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R28);
		/* 8216A884h case   23:*/		return 0x8216A888;
		  /* 8216A888h */ case   24:  		/* subfe R7, R10, R9 */
		/* 8216A888h case   24:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R10,regs.R9);
		/* 8216A888h case   24:*/		return 0x8216A88C;
		  /* 8216A88Ch */ case   25:  		/* cmplwi CR6, R11, 3 */
		/* 8216A88Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8216A88Ch case   25:*/		return 0x8216A890;
		  /* 8216A890h */ case   26:  		/* bc 12, CR6_EQ, 48 */
		/* 8216A890h case   26:*/		if ( regs.CR[6].eq ) { return 0x8216A8C0;  }
		/* 8216A890h case   26:*/		return 0x8216A894;
		  /* 8216A894h */ case   27:  		/* cmplwi CR6, R11, 4 */
		/* 8216A894h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8216A894h case   27:*/		return 0x8216A898;
		  /* 8216A898h */ case   28:  		/* bc 12, CR6_EQ, 40 */
		/* 8216A898h case   28:*/		if ( regs.CR[6].eq ) { return 0x8216A8C0;  }
		/* 8216A898h case   28:*/		return 0x8216A89C;
		  /* 8216A89Ch */ case   29:  		/* cmplwi CR6, R11, 13 */
		/* 8216A89Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000D);
		/* 8216A89Ch case   29:*/		return 0x8216A8A0;
		  /* 8216A8A0h */ case   30:  		/* bc 12, CR6_EQ, 24 */
		/* 8216A8A0h case   30:*/		if ( regs.CR[6].eq ) { return 0x8216A8B8;  }
		/* 8216A8A0h case   30:*/		return 0x8216A8A4;
		  /* 8216A8A4h */ case   31:  		/* cmplwi CR6, R11, 14 */
		/* 8216A8A4h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000E);
		/* 8216A8A4h case   31:*/		return 0x8216A8A8;
		  /* 8216A8A8h */ case   32:  		/* bc 12, CR6_EQ, 16 */
		/* 8216A8A8h case   32:*/		if ( regs.CR[6].eq ) { return 0x8216A8B8;  }
		/* 8216A8A8h case   32:*/		return 0x8216A8AC;
		  /* 8216A8ACh */ case   33:  		/* nor R11, R28, R28 */
		/* 8216A8ACh case   33:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R28,regs.R28);
		/* 8216A8ACh case   33:*/		return 0x8216A8B0;
		  /* 8216A8B0h */ case   34:  		/* rlwinm R8, R11, 23, 31, 31 */
		/* 8216A8B0h case   34:*/		cpu::op::rlwinm<0,23,31,31>(regs,&regs.R8,regs.R11);
		/* 8216A8B0h case   34:*/		return 0x8216A8B4;
		  /* 8216A8B4h */ case   35:  		/* b 16 */
		/* 8216A8B4h case   35:*/		return 0x8216A8C4;
		/* 8216A8B4h case   35:*/		return 0x8216A8B8;
	}
	return 0x8216A8B8;
} // Block from 8216A828h-8216A8B8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 8216A8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A8B8);
		  /* 8216A8B8h */ case    0:  		/* li R8, 0 */
		/* 8216A8B8h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8216A8B8h case    0:*/		return 0x8216A8BC;
		  /* 8216A8BCh */ case    1:  		/* b 8 */
		/* 8216A8BCh case    1:*/		return 0x8216A8C4;
		/* 8216A8BCh case    1:*/		return 0x8216A8C0;
	}
	return 0x8216A8C0;
} // Block from 8216A8B8h-8216A8C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A8C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A8C0);
		  /* 8216A8C0h */ case    0:  		/* mr R8, R27 */
		/* 8216A8C0h case    0:*/		regs.R8 = regs.R27;
		/* 8216A8C0h case    0:*/		return 0x8216A8C4;
	}
	return 0x8216A8C4;
} // Block from 8216A8C0h-8216A8C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A8C4);
		  /* 8216A8C4h */ case    0:  		/* mr R10, R23 */
		/* 8216A8C4h case    0:*/		regs.R10 = regs.R23;
		/* 8216A8C4h case    0:*/		return 0x8216A8C8;
		  /* 8216A8C8h */ case    1:  		/* stw R25, <#[R1 + 84]> */
		/* 8216A8C8h case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 8216A8C8h case    1:*/		return 0x8216A8CC;
		  /* 8216A8CCh */ case    2:  		/* mr R9, R26 */
		/* 8216A8CCh case    2:*/		regs.R9 = regs.R26;
		/* 8216A8CCh case    2:*/		return 0x8216A8D0;
		  /* 8216A8D0h */ case    3:  		/* mr R3, R24 */
		/* 8216A8D0h case    3:*/		regs.R3 = regs.R24;
		/* 8216A8D0h case    3:*/		return 0x8216A8D4;
		  /* 8216A8D4h */ case    4:  		/* bl -732 */
		/* 8216A8D4h case    4:*/		regs.LR = 0x8216A8D8; return 0x8216A5F8;
		/* 8216A8D4h case    4:*/		return 0x8216A8D8;
		  /* 8216A8D8h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 8216A8D8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216A8D8h case    5:*/		return 0x8216A8DC;
		  /* 8216A8DCh */ case    6:  		/* bc 12, CR0_LT, -220 */
		/* 8216A8DCh case    6:*/		if ( regs.CR[0].lt ) { return 0x8216A800;  }
		/* 8216A8DCh case    6:*/		return 0x8216A8E0;
		  /* 8216A8E0h */ case    7:  		/* addi R30, R30, 1 */
		/* 8216A8E0h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8216A8E0h case    7:*/		return 0x8216A8E4;
		  /* 8216A8E4h */ case    8:  		/* addi R31, R31, 2 */
		/* 8216A8E4h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 8216A8E4h case    8:*/		return 0x8216A8E8;
		  /* 8216A8E8h */ case    9:  		/* cmplw CR6, R30, R22 */
		/* 8216A8E8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R22);
		/* 8216A8E8h case    9:*/		return 0x8216A8EC;
		  /* 8216A8ECh */ case   10:  		/* bc 12, CR6_LT, -196 */
		/* 8216A8ECh case   10:*/		if ( regs.CR[6].lt ) { return 0x8216A828;  }
		/* 8216A8ECh case   10:*/		return 0x8216A8F0;
	}
	return 0x8216A8F0;
} // Block from 8216A8C4h-8216A8F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216A8F0h
// Function '?ValidateTFetch@@YAJPBTGPUSHADER_INSTRUCTION@@HPBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A8F0);
		  /* 8216A8F0h */ case    0:  		/* rlwinm. R11, R29, 0, 16, 16 */
		/* 8216A8F0h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R29);
		/* 8216A8F0h case    0:*/		return 0x8216A8F4;
		  /* 8216A8F4h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8216A8F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8216A914;  }
		/* 8216A8F4h case    1:*/		return 0x8216A8F8;
		  /* 8216A8F8h */ case    2:  		/* lwz R11, <#[R25]> */
		/* 8216A8F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8216A8F8h case    2:*/		return 0x8216A8FC;
		  /* 8216A8FCh */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216A8FCh case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216A8FCh case    3:*/		return 0x8216A900;
		  /* 8216A900h */ case    4:  		/* add R11, R11, R25 */
		/* 8216A900h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 8216A900h case    4:*/		return 0x8216A904;
		  /* 8216A904h */ case    5:  		/* addi R10, R11, 12 */
		/* 8216A904h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xC);
		/* 8216A904h case    5:*/		return 0x8216A908;
		  /* 8216A908h */ case    6:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216A908h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A908h case    6:*/		return 0x8216A90C;
		  /* 8216A90Ch */ case    7:  		/* rlwinm R10, R10, 0, 20, 18 */
		/* 8216A90Ch case    7:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R10,regs.R10);
		/* 8216A90Ch case    7:*/		return 0x8216A910;
		  /* 8216A910h */ case    8:  		/* stw R10, <#[R11 + 12]> */
		/* 8216A910h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216A910h case    8:*/		return 0x8216A914;
	}
	return 0x8216A914;
} // Block from 8216A8F0h-8216A914h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216A914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A914);
		  /* 8216A914h */ case    0:  		/* li R3, 0 */
		/* 8216A914h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216A914h case    0:*/		return 0x8216A918;
	}
	return 0x8216A918;
} // Block from 8216A914h-8216A918h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216A918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A918);
		  /* 8216A918h */ case    0:  		/* addi R1, R1, 192 */
		/* 8216A918h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8216A918h case    0:*/		return 0x8216A91C;
		  /* 8216A91Ch */ case    1:  		/* b -890512 */
		/* 8216A91Ch case    1:*/		return 0x8209128C;
		/* 8216A91Ch case    1:*/		return 0x8216A920;
	}
	return 0x8216A920;
} // Block from 8216A918h-8216A920h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216A920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A920);
		  /* 8216A920h */ case    0:  		/* mfspr R12, LR */
		/* 8216A920h case    0:*/		regs.R12 = regs.LR;
		/* 8216A920h case    0:*/		return 0x8216A924;
		  /* 8216A924h */ case    1:  		/* bl -890580 */
		/* 8216A924h case    1:*/		regs.LR = 0x8216A928; return 0x82091250;
		/* 8216A924h case    1:*/		return 0x8216A928;
		  /* 8216A928h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216A928h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216A928h case    2:*/		return 0x8216A92C;
		  /* 8216A92Ch */ case    3:  		/* addi R8, R1, 80 */
		/* 8216A92Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8216A92Ch case    3:*/		return 0x8216A930;
		  /* 8216A930h */ case    4:  		/* std R3, <#[R1 + 160]> */
		/* 8216A930h case    4:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x000000A0) );
		/* 8216A930h case    4:*/		return 0x8216A934;
		  /* 8216A934h */ case    5:  		/* li R7, 0 */
		/* 8216A934h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216A934h case    5:*/		return 0x8216A938;
		  /* 8216A938h */ case    6:  		/* lwz R9, <#[R1 + 164]> */
		/* 8216A938h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 8216A938h case    6:*/		return 0x8216A93C;
		  /* 8216A93Ch */ case    7:  		/* lwz R27, <#[R1 + 160]> */
		/* 8216A93Ch case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000A0) );
		/* 8216A93Ch case    7:*/		return 0x8216A940;
		  /* 8216A940h */ case    8:  		/* mr R26, R6 */
		/* 8216A940h case    8:*/		regs.R26 = regs.R6;
		/* 8216A940h case    8:*/		return 0x8216A944;
		  /* 8216A944h */ case    9:  		/* mr R6, R27 */
		/* 8216A944h case    9:*/		regs.R6 = regs.R27;
		/* 8216A944h case    9:*/		return 0x8216A948;
		  /* 8216A948h */ case   10:  		/* std R7, <#[R8]> */
		/* 8216A948h case   10:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 8216A948h case   10:*/		return 0x8216A94C;
		  /* 8216A94Ch */ case   11:  		/* mr R30, R4 */
		/* 8216A94Ch case   11:*/		regs.R30 = regs.R4;
		/* 8216A94Ch case   11:*/		return 0x8216A950;
		  /* 8216A950h */ case   12:  		/* addi R11, R1, 80 */
		/* 8216A950h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8216A950h case   12:*/		return 0x8216A954;
		  /* 8216A954h */ case   13:  		/* addi R10, R1, 160 */
		/* 8216A954h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 8216A954h case   13:*/		return 0x8216A958;
		  /* 8216A958h */ case   14:  		/* addi R8, R11, 8 */
		/* 8216A958h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8216A958h case   14:*/		return 0x8216A95C;
		  /* 8216A95Ch */ case   15:  		/* lwz R7, <#[R1 + 84]> */
		/* 8216A95Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8216A95Ch case   15:*/		return 0x8216A960;
		  /* 8216A960h */ case   16:  		/* lwz R4, <#[R1 + 80]> */
		/* 8216A960h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8216A960h case   16:*/		return 0x8216A964;
		  /* 8216A964h */ case   17:  		/* rlwimi R4, R6, 0, 19, 31 */
		/* 8216A964h case   17:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R4,regs.R6);
		/* 8216A964h case   17:*/		return 0x8216A968;
		  /* 8216A968h */ case   18:  		/* rlwimi R7, R9, 0, 20, 20 */
		/* 8216A968h case   18:*/		cpu::op::rlwimi<0,0,20,20>(regs,&regs.R7,regs.R9);
		/* 8216A968h case   18:*/		return 0x8216A96C;
		  /* 8216A96Ch */ case   19:  		/* rlwimi R4, R27, 0, 11, 15 */
		/* 8216A96Ch case   19:*/		cpu::op::rlwimi<0,0,11,15>(regs,&regs.R4,regs.R27);
		/* 8216A96Ch case   19:*/		return 0x8216A970;
		  /* 8216A970h */ case   20:  		/* rlwimi R7, R9, 0, 16, 19 */
		/* 8216A970h case   20:*/		cpu::op::rlwimi<0,0,16,19>(regs,&regs.R7,regs.R9);
		/* 8216A970h case   20:*/		return 0x8216A974;
		  /* 8216A974h */ case   21:  		/* rlwimi R4, R27, 0, 18, 18 */
		/* 8216A974h case   21:*/		cpu::op::rlwimi<0,0,18,18>(regs,&regs.R4,regs.R27);
		/* 8216A974h case   21:*/		return 0x8216A978;
		  /* 8216A978h */ case   22:  		/* stw R7, <#[R1 + 84]> */
		/* 8216A978h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8216A978h case   22:*/		return 0x8216A97C;
		  /* 8216A97Ch */ case   23:  		/* stw R4, <#[R1 + 80]> */
		/* 8216A97Ch case   23:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8216A97Ch case   23:*/		return 0x8216A980;
		  /* 8216A980h */ case   24:  		/* lbz R9, <#[R11]> */
		/* 8216A980h case   24:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216A980h case   24:*/		return 0x8216A984;
		  /* 8216A984h */ case   25:  		/* lbz R7, <#[R10]> */
		/* 8216A984h case   25:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8216A984h case   25:*/		return 0x8216A988;
		  /* 8216A988h */ case   26:  		/* subf. R9, R7, R9 */
		/* 8216A988h case   26:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8216A988h case   26:*/		return 0x8216A98C;
		  /* 8216A98Ch */ case   27:  		/* bc 4, CR0_EQ, 20 */
		/* 8216A98Ch case   27:*/		if ( !regs.CR[0].eq ) { return 0x8216A9A0;  }
		/* 8216A98Ch case   27:*/		return 0x8216A990;
		  /* 8216A990h */ case   28:  		/* addi R11, R11, 1 */
		/* 8216A990h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216A990h case   28:*/		return 0x8216A994;
		  /* 8216A994h */ case   29:  		/* addi R10, R10, 1 */
		/* 8216A994h case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216A994h case   29:*/		return 0x8216A998;
		  /* 8216A998h */ case   30:  		/* cmpw CR6, R11, R8 */
		/* 8216A998h case   30:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8216A998h case   30:*/		return 0x8216A99C;
		  /* 8216A99Ch */ case   31:  		/* bc 4, CR6_EQ, -28 */
		/* 8216A99Ch case   31:*/		if ( !regs.CR[6].eq ) { return 0x8216A980;  }
		/* 8216A99Ch case   31:*/		return 0x8216A9A0;
	}
	return 0x8216A9A0;
} // Block from 8216A920h-8216A9A0h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8216A9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216A9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216A9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216A9A0);
		  /* 8216A9A0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 8216A9A0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 8216A9A0h case    0:*/		return 0x8216A9A4;
		  /* 8216A9A4h */ case    1:  		/* bc 4, CR0_EQ, 152 */
		/* 8216A9A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216AA3C;  }
		/* 8216A9A4h case    1:*/		return 0x8216A9A8;
		  /* 8216A9A8h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 8216A9A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8216A9A8h case    2:*/		return 0x8216A9AC;
		  /* 8216A9ACh */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216A9ACh case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216A9ACh case    3:*/		return 0x8216A9B0;
		  /* 8216A9B0h */ case    4:  		/* add R11, R11, R30 */
		/* 8216A9B0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8216A9B0h case    4:*/		return 0x8216A9B4;
		  /* 8216A9B4h */ case    5:  		/* addi R11, R11, 12 */
		/* 8216A9B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8216A9B4h case    5:*/		return 0x8216A9B8;
		  /* 8216A9B8h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 8216A9B8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216A9B8h case    6:*/		return 0x8216A9BC;
		  /* 8216A9BCh */ case    7:  		/* rlwinm. R31, R10, 16, 29, 31 */
		/* 8216A9BCh case    7:*/		cpu::op::rlwinm<1,16,29,31>(regs,&regs.R31,regs.R10);
		/* 8216A9BCh case    7:*/		return 0x8216A9C0;
		  /* 8216A9C0h */ case    8:  		/* rlwinm R28, R10, 19, 29, 31 */
		/* 8216A9C0h case    8:*/		cpu::op::rlwinm<0,19,29,31>(regs,&regs.R28,regs.R10);
		/* 8216A9C0h case    8:*/		return 0x8216A9C4;
		  /* 8216A9C4h */ case    9:  		/* bc 12, CR0_LT, 120 */
		/* 8216A9C4h case    9:*/		if ( regs.CR[0].lt ) { return 0x8216AA3C;  }
		/* 8216A9C4h case    9:*/		return 0x8216A9C8;
		  /* 8216A9C8h */ case   10:  		/* cmpwi CR6, R31, 4 */
		/* 8216A9C8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8216A9C8h case   10:*/		return 0x8216A9CC;
		  /* 8216A9CCh */ case   11:  		/* bc 4, CR6_LT, 112 */
		/* 8216A9CCh case   11:*/		if ( !regs.CR[6].lt ) { return 0x8216AA3C;  }
		/* 8216A9CCh case   11:*/		return 0x8216A9D0;
		  /* 8216A9D0h */ case   12:  		/* rlwinm R4, R27, 0, 19, 31 */
		/* 8216A9D0h case   12:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R4,regs.R27);
		/* 8216A9D0h case   12:*/		return 0x8216A9D4;
		  /* 8216A9D4h */ case   13:  		/* cmplw CR6, R4, R26 */
		/* 8216A9D4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R26);
		/* 8216A9D4h case   13:*/		return 0x8216A9D8;
		  /* 8216A9D8h */ case   14:  		/* bc 4, CR6_GT, 100 */
		/* 8216A9D8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8216AA3C;  }
		/* 8216A9D8h case   14:*/		return 0x8216A9DC;
		  /* 8216A9DCh */ case   15:  		/* lwz R10, <#[R5]> */
		/* 8216A9DCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8216A9DCh case   15:*/		return 0x8216A9E0;
		  /* 8216A9E0h */ case   16:  		/* cmplw CR6, R4, R10 */
		/* 8216A9E0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8216A9E0h case   16:*/		return 0x8216A9E4;
		  /* 8216A9E4h */ case   17:  		/* bc 4, CR6_LT, 88 */
		/* 8216A9E4h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8216AA3C;  }
		/* 8216A9E4h case   17:*/		return 0x8216A9E8;
		  /* 8216A9E8h */ case   18:  		/* addi R29, R11, 4 */
		/* 8216A9E8h case   18:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4);
		/* 8216A9E8h case   18:*/		return 0x8216A9EC;
		  /* 8216A9ECh */ case   19:  		/* mr R6, R28 */
		/* 8216A9ECh case   19:*/		regs.R6 = regs.R28;
		/* 8216A9ECh case   19:*/		return 0x8216A9F0;
		  /* 8216A9F0h */ case   20:  		/* mr R7, R29 */
		/* 8216A9F0h case   20:*/		regs.R7 = regs.R29;
		/* 8216A9F0h case   20:*/		return 0x8216A9F4;
		  /* 8216A9F4h */ case   21:  		/* mr R5, R31 */
		/* 8216A9F4h case   21:*/		regs.R5 = regs.R31;
		/* 8216A9F4h case   21:*/		return 0x8216A9F8;
		  /* 8216A9F8h */ case   22:  		/* mr R3, R30 */
		/* 8216A9F8h case   22:*/		regs.R3 = regs.R30;
		/* 8216A9F8h case   22:*/		return 0x8216A9FC;
		  /* 8216A9FCh */ case   23:  		/* bl -3964 */
		/* 8216A9FCh case   23:*/		regs.LR = 0x8216AA00; return 0x82169A80;
		/* 8216A9FCh case   23:*/		return 0x8216AA00;
		  /* 8216AA00h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 8216AA00h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216AA00h case   24:*/		return 0x8216AA04;
		  /* 8216AA04h */ case   25:  		/* bc 12, CR0_LT, 56 */
		/* 8216AA04h case   25:*/		if ( regs.CR[0].lt ) { return 0x8216AA3C;  }
		/* 8216AA04h case   25:*/		return 0x8216AA08;
		  /* 8216AA08h */ case   26:  		/* rlwinm R11, R27, 16, 27, 31 */
		/* 8216AA08h case   26:*/		cpu::op::rlwinm<0,16,27,31>(regs,&regs.R11,regs.R27);
		/* 8216AA08h case   26:*/		return 0x8216AA0C;
		  /* 8216AA0Ch */ case   27:  		/* mr R7, R29 */
		/* 8216AA0Ch case   27:*/		regs.R7 = regs.R29;
		/* 8216AA0Ch case   27:*/		return 0x8216AA10;
		  /* 8216AA10h */ case   28:  		/* addi R8, R11, 1 */
		/* 8216AA10h case   28:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x1);
		/* 8216AA10h case   28:*/		return 0x8216AA14;
		  /* 8216AA14h */ case   29:  		/* mr R6, R28 */
		/* 8216AA14h case   29:*/		regs.R6 = regs.R28;
		/* 8216AA14h case   29:*/		return 0x8216AA18;
		  /* 8216AA18h */ case   30:  		/* addi R5, R31, 1 */
		/* 8216AA18h case   30:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x1);
		/* 8216AA18h case   30:*/		return 0x8216AA1C;
		  /* 8216AA1Ch */ case   31:  		/* addi R4, R26, 1 */
		/* 8216AA1Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0x1);
		/* 8216AA1Ch case   31:*/		return 0x8216AA20;
		  /* 8216AA20h */ case   32:  		/* mr R3, R30 */
		/* 8216AA20h case   32:*/		regs.R3 = regs.R30;
		/* 8216AA20h case   32:*/		return 0x8216AA24;
		  /* 8216AA24h */ case   33:  		/* bl -3732 */
		/* 8216AA24h case   33:*/		regs.LR = 0x8216AA28; return 0x82169B90;
		/* 8216AA24h case   33:*/		return 0x8216AA28;
		  /* 8216AA28h */ case   34:  		/* lis R11, -32768 */
		/* 8216AA28h case   34:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 8216AA28h case   34:*/		return 0x8216AA2C;
		  /* 8216AA2Ch */ case   35:  		/* srawi R10, R3, 31 */
		/* 8216AA2Ch case   35:*/		cpu::op::srawi<0,31>(regs,&regs.R10,regs.R3);
		/* 8216AA2Ch case   35:*/		return 0x8216AA30;
		  /* 8216AA30h */ case   36:  		/* ori R11, R11, 16389 */
		/* 8216AA30h case   36:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4005);
		/* 8216AA30h case   36:*/		return 0x8216AA34;
		  /* 8216AA34h */ case   37:  		/* and R3, R10, R11 */
		/* 8216AA34h case   37:*/		cpu::op::and<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8216AA34h case   37:*/		return 0x8216AA38;
		  /* 8216AA38h */ case   38:  		/* b 12 */
		/* 8216AA38h case   38:*/		return 0x8216AA44;
		/* 8216AA38h case   38:*/		return 0x8216AA3C;
	}
	return 0x8216AA3C;
} // Block from 8216A9A0h-8216AA3Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8216AA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AA3C);
		  /* 8216AA3Ch */ case    0:  		/* lis R3, -32768 */
		/* 8216AA3Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216AA3Ch case    0:*/		return 0x8216AA40;
		  /* 8216AA40h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216AA40h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216AA40h case    1:*/		return 0x8216AA44;
	}
	return 0x8216AA44;
} // Block from 8216AA3Ch-8216AA44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216AA44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AA44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AA44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AA44);
		  /* 8216AA44h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216AA44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216AA44h case    0:*/		return 0x8216AA48;
		  /* 8216AA48h */ case    1:  		/* b -890792 */
		/* 8216AA48h case    1:*/		return 0x820912A0;
		/* 8216AA48h case    1:*/		return 0x8216AA4C;
		  /* 8216AA4Ch */ case    2:  		/* nop */
		/* 8216AA4Ch case    2:*/		cpu::op::nop();
		/* 8216AA4Ch case    2:*/		return 0x8216AA50;
	}
	return 0x8216AA50;
} // Block from 8216AA44h-8216AA50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216AA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AA50);
		  /* 8216AA50h */ case    0:  		/* mfspr R12, LR */
		/* 8216AA50h case    0:*/		regs.R12 = regs.LR;
		/* 8216AA50h case    0:*/		return 0x8216AA54;
		  /* 8216AA54h */ case    1:  		/* bl -890880 */
		/* 8216AA54h case    1:*/		regs.LR = 0x8216AA58; return 0x82091254;
		/* 8216AA54h case    1:*/		return 0x8216AA58;
		  /* 8216AA58h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216AA58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216AA58h case    2:*/		return 0x8216AA5C;
		  /* 8216AA5Ch */ case    3:  		/* addi R8, R1, 80 */
		/* 8216AA5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8216AA5Ch case    3:*/		return 0x8216AA60;
		  /* 8216AA60h */ case    4:  		/* std R3, <#[R1 + 160]> */
		/* 8216AA60h case    4:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x000000A0) );
		/* 8216AA60h case    4:*/		return 0x8216AA64;
		  /* 8216AA64h */ case    5:  		/* mr R27, R6 */
		/* 8216AA64h case    5:*/		regs.R27 = regs.R6;
		/* 8216AA64h case    5:*/		return 0x8216AA68;
		  /* 8216AA68h */ case    6:  		/* lwz R9, <#[R1 + 164]> */
		/* 8216AA68h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 8216AA68h case    6:*/		return 0x8216AA6C;
		  /* 8216AA6Ch */ case    7:  		/* li R6, 0 */
		/* 8216AA6Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216AA6Ch case    7:*/		return 0x8216AA70;
		  /* 8216AA70h */ case    8:  		/* lwz R7, <#[R1 + 160]> */
		/* 8216AA70h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000A0) );
		/* 8216AA70h case    8:*/		return 0x8216AA74;
		  /* 8216AA74h */ case    9:  		/* mr R29, R4 */
		/* 8216AA74h case    9:*/		regs.R29 = regs.R4;
		/* 8216AA74h case    9:*/		return 0x8216AA78;
	}
	return 0x8216AA78;
} // Block from 8216AA50h-8216AA78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216AA78h
// Function '?ValidateVFetchFormat@@YAJPBTGPUSHADER_INSTRUCTION@@HPBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AA78);
		  /* 8216AA78h */ case    0:  		/* mr R4, R7 */
		/* 8216AA78h case    0:*/		regs.R4 = regs.R7;
		/* 8216AA78h case    0:*/		return 0x8216AA7C;
		  /* 8216AA7Ch */ case    1:  		/* std R6, <#[R8]> */
		/* 8216AA7Ch case    1:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 8216AA7Ch case    1:*/		return 0x8216AA80;
		  /* 8216AA80h */ case    2:  		/* addi R11, R1, 80 */
		/* 8216AA80h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8216AA80h case    2:*/		return 0x8216AA84;
		  /* 8216AA84h */ case    3:  		/* addi R10, R1, 160 */
		/* 8216AA84h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 8216AA84h case    3:*/		return 0x8216AA88;
		  /* 8216AA88h */ case    4:  		/* addi R8, R11, 8 */
		/* 8216AA88h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8216AA88h case    4:*/		return 0x8216AA8C;
		  /* 8216AA8Ch */ case    5:  		/* lwz R6, <#[R1 + 84]> */
		/* 8216AA8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8216AA8Ch case    5:*/		return 0x8216AA90;
		  /* 8216AA90h */ case    6:  		/* lwz R3, <#[R1 + 80]> */
		/* 8216AA90h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8216AA90h case    6:*/		return 0x8216AA94;
		  /* 8216AA94h */ case    7:  		/* rlwimi R3, R4, 0, 19, 31 */
		/* 8216AA94h case    7:*/		cpu::op::rlwimi<0,0,19,31>(regs,&regs.R3,regs.R4);
		/* 8216AA94h case    7:*/		return 0x8216AA98;
		  /* 8216AA98h */ case    8:  		/* rlwimi R6, R9, 0, 20, 21 */
		/* 8216AA98h case    8:*/		cpu::op::rlwimi<0,0,20,21>(regs,&regs.R6,regs.R9);
		/* 8216AA98h case    8:*/		return 0x8216AA9C;
		  /* 8216AA9Ch */ case    9:  		/* rlwimi R3, R7, 0, 11, 15 */
		/* 8216AA9Ch case    9:*/		cpu::op::rlwimi<0,0,11,15>(regs,&regs.R3,regs.R7);
		/* 8216AA9Ch case    9:*/		return 0x8216AAA0;
		  /* 8216AAA0h */ case   10:  		/* rlwimi R6, R9, 0, 16, 19 */
		/* 8216AAA0h case   10:*/		cpu::op::rlwimi<0,0,16,19>(regs,&regs.R6,regs.R9);
		/* 8216AAA0h case   10:*/		return 0x8216AAA4;
		  /* 8216AAA4h */ case   11:  		/* rlwimi R3, R7, 0, 10, 10 */
		/* 8216AAA4h case   11:*/		cpu::op::rlwimi<0,0,10,10>(regs,&regs.R3,regs.R7);
		/* 8216AAA4h case   11:*/		return 0x8216AAA8;
		  /* 8216AAA8h */ case   12:  		/* stw R6, <#[R1 + 84]> */
		/* 8216AAA8h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8216AAA8h case   12:*/		return 0x8216AAAC;
		  /* 8216AAACh */ case   13:  		/* stw R3, <#[R1 + 80]> */
		/* 8216AAACh case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8216AAACh case   13:*/		return 0x8216AAB0;
		  /* 8216AAB0h */ case   14:  		/* lbz R9, <#[R11]> */
		/* 8216AAB0h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216AAB0h case   14:*/		return 0x8216AAB4;
		  /* 8216AAB4h */ case   15:  		/* lbz R6, <#[R10]> */
		/* 8216AAB4h case   15:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8216AAB4h case   15:*/		return 0x8216AAB8;
		  /* 8216AAB8h */ case   16:  		/* subf. R9, R6, R9 */
		/* 8216AAB8h case   16:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8216AAB8h case   16:*/		return 0x8216AABC;
		  /* 8216AABCh */ case   17:  		/* bc 4, CR0_EQ, 20 */
		/* 8216AABCh case   17:*/		if ( !regs.CR[0].eq ) { return 0x8216AAD0;  }
		/* 8216AABCh case   17:*/		return 0x8216AAC0;
		  /* 8216AAC0h */ case   18:  		/* addi R11, R11, 1 */
		/* 8216AAC0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216AAC0h case   18:*/		return 0x8216AAC4;
		  /* 8216AAC4h */ case   19:  		/* addi R10, R10, 1 */
		/* 8216AAC4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216AAC4h case   19:*/		return 0x8216AAC8;
		  /* 8216AAC8h */ case   20:  		/* cmpw CR6, R11, R8 */
		/* 8216AAC8h case   20:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8216AAC8h case   20:*/		return 0x8216AACC;
		  /* 8216AACCh */ case   21:  		/* bc 4, CR6_EQ, -28 */
		/* 8216AACCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x8216AAB0;  }
		/* 8216AACCh case   21:*/		return 0x8216AAD0;
	}
	return 0x8216AAD0;
} // Block from 8216AA78h-8216AAD0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8216AAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AAD0);
		  /* 8216AAD0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 8216AAD0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 8216AAD0h case    0:*/		return 0x8216AAD4;
		  /* 8216AAD4h */ case    1:  		/* bc 4, CR0_EQ, 188 */
		/* 8216AAD4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216AB90;  }
		/* 8216AAD4h case    1:*/		return 0x8216AAD8;
		  /* 8216AAD8h */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8216AAD8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8216AAD8h case    2:*/		return 0x8216AADC;
		  /* 8216AADCh */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216AADCh case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216AADCh case    3:*/		return 0x8216AAE0;
		  /* 8216AAE0h */ case    4:  		/* add R11, R11, R29 */
		/* 8216AAE0h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8216AAE0h case    4:*/		return 0x8216AAE4;
		  /* 8216AAE4h */ case    5:  		/* addi R11, R11, 12 */
		/* 8216AAE4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8216AAE4h case    5:*/		return 0x8216AAE8;
		  /* 8216AAE8h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 8216AAE8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216AAE8h case    6:*/		return 0x8216AAEC;
		  /* 8216AAECh */ case    7:  		/* rlwinm. R30, R10, 16, 29, 31 */
		/* 8216AAECh case    7:*/		cpu::op::rlwinm<1,16,29,31>(regs,&regs.R30,regs.R10);
		/* 8216AAECh case    7:*/		return 0x8216AAF0;
		  /* 8216AAF0h */ case    8:  		/* rlwinm R28, R10, 19, 29, 31 */
		/* 8216AAF0h case    8:*/		cpu::op::rlwinm<0,19,29,31>(regs,&regs.R28,regs.R10);
		/* 8216AAF0h case    8:*/		return 0x8216AAF4;
		  /* 8216AAF4h */ case    9:  		/* bc 4, CR0_GT, 156 */
		/* 8216AAF4h case    9:*/		if ( !regs.CR[0].gt ) { return 0x8216AB90;  }
		/* 8216AAF4h case    9:*/		return 0x8216AAF8;
		  /* 8216AAF8h */ case   10:  		/* cmpwi CR6, R30, 4 */
		/* 8216AAF8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000004);
		/* 8216AAF8h case   10:*/		return 0x8216AAFC;
		  /* 8216AAFCh */ case   11:  		/* bc 12, CR6_GT, 148 */
		/* 8216AAFCh case   11:*/		if ( regs.CR[6].gt ) { return 0x8216AB90;  }
		/* 8216AAFCh case   11:*/		return 0x8216AB00;
		  /* 8216AB00h */ case   12:  		/* rlwinm R4, R7, 0, 19, 31 */
		/* 8216AB00h case   12:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R4,regs.R7);
		/* 8216AB00h case   12:*/		return 0x8216AB04;
		  /* 8216AB04h */ case   13:  		/* cmplw CR6, R4, R27 */
		/* 8216AB04h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R27);
		/* 8216AB04h case   13:*/		return 0x8216AB08;
		  /* 8216AB08h */ case   14:  		/* bc 12, CR6_GT, 136 */
		/* 8216AB08h case   14:*/		if ( regs.CR[6].gt ) { return 0x8216AB90;  }
		/* 8216AB08h case   14:*/		return 0x8216AB0C;
		  /* 8216AB0Ch */ case   15:  		/* lwz R10, <#[R5]> */
		/* 8216AB0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8216AB0Ch case   15:*/		return 0x8216AB10;
		  /* 8216AB10h */ case   16:  		/* cmplw CR6, R4, R10 */
		/* 8216AB10h case   16:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8216AB10h case   16:*/		return 0x8216AB14;
		  /* 8216AB14h */ case   17:  		/* bc 4, CR6_LT, 124 */
		/* 8216AB14h case   17:*/		if ( !regs.CR[6].lt ) { return 0x8216AB90;  }
		/* 8216AB14h case   17:*/		return 0x8216AB18;
		  /* 8216AB18h */ case   18:  		/* addic. R31, R11, 4 */
		/* 8216AB18h case   18:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0x4);
		/* 8216AB18h case   18:*/		return 0x8216AB1C;
		  /* 8216AB1Ch */ case   19:  		/* bc 12, CR0_EQ, 24 */
		/* 8216AB1Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x8216AB34;  }
		/* 8216AB1Ch case   19:*/		return 0x8216AB20;
		  /* 8216AB20h */ case   20:  		/* lbz R11, <#[R31]> */
		/* 8216AB20h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216AB20h case   20:*/		return 0x8216AB24;
		  /* 8216AB24h */ case   21:  		/* cmpwi CR6, R11, 35 */
		/* 8216AB24h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8216AB24h case   21:*/		return 0x8216AB28;
		  /* 8216AB28h */ case   22:  		/* bc 4, CR6_LT, 12 */
		/* 8216AB28h case   22:*/		if ( !regs.CR[6].lt ) { return 0x8216AB34;  }
		/* 8216AB28h case   22:*/		return 0x8216AB2C;
		  /* 8216AB2Ch */ case   23:  		/* cmpwi CR6, R11, 0 */
		/* 8216AB2Ch case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216AB2Ch case   23:*/		return 0x8216AB30;
		  /* 8216AB30h */ case   24:  		/* bc 12, CR6_GT, 8 */
		/* 8216AB30h case   24:*/		if ( regs.CR[6].gt ) { return 0x8216AB38;  }
		/* 8216AB30h case   24:*/		return 0x8216AB34;
	}
	return 0x8216AB34;
} // Block from 8216AAD0h-8216AB34h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8216AB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AB34);
		  /* 8216AB34h */ case    0:  		/* li R11, 0 */
		/* 8216AB34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216AB34h case    0:*/		return 0x8216AB38;
	}
	return 0x8216AB38;
} // Block from 8216AB34h-8216AB38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216AB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AB38);
		  /* 8216AB38h */ case    0:  		/* rlwinm R10, R7, 16, 27, 31 */
		/* 8216AB38h case    0:*/		cpu::op::rlwinm<0,16,27,31>(regs,&regs.R10,regs.R7);
		/* 8216AB38h case    0:*/		return 0x8216AB3C;
		  /* 8216AB3Ch */ case    1:  		/* addi R8, R10, 1 */
		/* 8216AB3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 8216AB3Ch case    1:*/		return 0x8216AB40;
		  /* 8216AB40h */ case    2:  		/* cmplw CR6, R11, R8 */
		/* 8216AB40h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8216AB40h case    2:*/		return 0x8216AB44;
		  /* 8216AB44h */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 8216AB44h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216AB90;  }
		/* 8216AB44h case    3:*/		return 0x8216AB48;
		  /* 8216AB48h */ case    4:  		/* mr R7, R31 */
		/* 8216AB48h case    4:*/		regs.R7 = regs.R31;
		/* 8216AB48h case    4:*/		return 0x8216AB4C;
		  /* 8216AB4Ch */ case    5:  		/* mr R6, R28 */
		/* 8216AB4Ch case    5:*/		regs.R6 = regs.R28;
		/* 8216AB4Ch case    5:*/		return 0x8216AB50;
		  /* 8216AB50h */ case    6:  		/* mr R5, R30 */
		/* 8216AB50h case    6:*/		regs.R5 = regs.R30;
		/* 8216AB50h case    6:*/		return 0x8216AB54;
		  /* 8216AB54h */ case    7:  		/* mr R3, R29 */
		/* 8216AB54h case    7:*/		regs.R3 = regs.R29;
		/* 8216AB54h case    7:*/		return 0x8216AB58;
	}
	return 0x8216AB58;
} // Block from 8216AB38h-8216AB58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216AB58h
// Function '?ValidateVFetch@@YAJPBTGPUSHADER_INSTRUCTION@@HHPBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AB58);
		  /* 8216AB58h */ case    0:  		/* bl -3816 */
		/* 8216AB58h case    0:*/		regs.LR = 0x8216AB5C; return 0x82169C70;
		/* 8216AB58h case    0:*/		return 0x8216AB5C;
		  /* 8216AB5Ch */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 8216AB5Ch case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216AB5Ch case    1:*/		return 0x8216AB60;
		  /* 8216AB60h */ case    2:  		/* bc 12, CR0_LT, 48 */
		/* 8216AB60h case    2:*/		if ( regs.CR[0].lt ) { return 0x8216AB90;  }
		/* 8216AB60h case    2:*/		return 0x8216AB64;
		  /* 8216AB64h */ case    3:  		/* mr R7, R31 */
		/* 8216AB64h case    3:*/		regs.R7 = regs.R31;
		/* 8216AB64h case    3:*/		return 0x8216AB68;
		  /* 8216AB68h */ case    4:  		/* mr R6, R28 */
		/* 8216AB68h case    4:*/		regs.R6 = regs.R28;
		/* 8216AB68h case    4:*/		return 0x8216AB6C;
		  /* 8216AB6Ch */ case    5:  		/* addi R5, R30, -1 */
		/* 8216AB6Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0xFFFFFFFF);
		/* 8216AB6Ch case    5:*/		return 0x8216AB70;
		  /* 8216AB70h */ case    6:  		/* addi R4, R27, 1 */
		/* 8216AB70h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0x1);
		/* 8216AB70h case    6:*/		return 0x8216AB74;
		  /* 8216AB74h */ case    7:  		/* mr R3, R29 */
		/* 8216AB74h case    7:*/		regs.R3 = regs.R29;
		/* 8216AB74h case    7:*/		return 0x8216AB78;
		  /* 8216AB78h */ case    8:  		/* bl -3520 */
		/* 8216AB78h case    8:*/		regs.LR = 0x8216AB7C; return 0x82169DB8;
		/* 8216AB78h case    8:*/		return 0x8216AB7C;
		  /* 8216AB7Ch */ case    9:  		/* lis R11, -32768 */
		/* 8216AB7Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 8216AB7Ch case    9:*/		return 0x8216AB80;
		  /* 8216AB80h */ case   10:  		/* srawi R10, R3, 31 */
		/* 8216AB80h case   10:*/		cpu::op::srawi<0,31>(regs,&regs.R10,regs.R3);
		/* 8216AB80h case   10:*/		return 0x8216AB84;
		  /* 8216AB84h */ case   11:  		/* ori R11, R11, 16389 */
		/* 8216AB84h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4005);
		/* 8216AB84h case   11:*/		return 0x8216AB88;
		  /* 8216AB88h */ case   12:  		/* and R3, R10, R11 */
		/* 8216AB88h case   12:*/		cpu::op::and<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8216AB88h case   12:*/		return 0x8216AB8C;
		  /* 8216AB8Ch */ case   13:  		/* b 12 */
		/* 8216AB8Ch case   13:*/		return 0x8216AB98;
		/* 8216AB8Ch case   13:*/		return 0x8216AB90;
	}
	return 0x8216AB90;
} // Block from 8216AB58h-8216AB90h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216AB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AB90);
		  /* 8216AB90h */ case    0:  		/* lis R3, -32768 */
		/* 8216AB90h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216AB90h case    0:*/		return 0x8216AB94;
		  /* 8216AB94h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216AB94h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216AB94h case    1:*/		return 0x8216AB98;
	}
	return 0x8216AB98;
} // Block from 8216AB90h-8216AB98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216AB98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AB98);
		  /* 8216AB98h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216AB98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216AB98h case    0:*/		return 0x8216AB9C;
		  /* 8216AB9Ch */ case    1:  		/* b -891128 */
		/* 8216AB9Ch case    1:*/		return 0x820912A4;
		/* 8216AB9Ch case    1:*/		return 0x8216ABA0;
	}
	return 0x8216ABA0;
} // Block from 8216AB98h-8216ABA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216ABA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ABA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ABA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ABA0);
		  /* 8216ABA0h */ case    0:  		/* mfspr R12, LR */
		/* 8216ABA0h case    0:*/		regs.R12 = regs.LR;
		/* 8216ABA0h case    0:*/		return 0x8216ABA4;
		  /* 8216ABA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8216ABA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216ABA4h case    1:*/		return 0x8216ABA8;
		  /* 8216ABA8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8216ABA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8216ABA8h case    2:*/		return 0x8216ABAC;
		  /* 8216ABACh */ case    3:  		/* addi R6, R1, 80 */
		/* 8216ABACh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8216ABACh case    3:*/		return 0x8216ABB0;
		  /* 8216ABB0h */ case    4:  		/* std R3, <#[R1 + 112]> */
		/* 8216ABB0h case    4:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8216ABB0h case    4:*/		return 0x8216ABB4;
		  /* 8216ABB4h */ case    5:  		/* mr R3, R4 */
		/* 8216ABB4h case    5:*/		regs.R3 = regs.R4;
		/* 8216ABB4h case    5:*/		return 0x8216ABB8;
		  /* 8216ABB8h */ case    6:  		/* lwz R7, <#[R1 + 112]> */
		/* 8216ABB8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 8216ABB8h case    6:*/		return 0x8216ABBC;
		  /* 8216ABBCh */ case    7:  		/* li R4, 0 */
		/* 8216ABBCh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8216ABBCh case    7:*/		return 0x8216ABC0;
		  /* 8216ABC0h */ case    8:  		/* lwz R9, <#[R1 + 116]> */
		/* 8216ABC0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000074) );
		/* 8216ABC0h case    8:*/		return 0x8216ABC4;
		  /* 8216ABC4h */ case    9:  		/* addi R11, R1, 80 */
		/* 8216ABC4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8216ABC4h case    9:*/		return 0x8216ABC8;
		  /* 8216ABC8h */ case   10:  		/* addi R10, R1, 112 */
		/* 8216ABC8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8216ABC8h case   10:*/		return 0x8216ABCC;
		  /* 8216ABCCh */ case   11:  		/* std R4, <#[R6]> */
		/* 8216ABCCh case   11:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R6 + 0x00000000) );
		/* 8216ABCCh case   11:*/		return 0x8216ABD0;
		  /* 8216ABD0h */ case   12:  		/* addi R8, R11, 8 */
		/* 8216ABD0h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8216ABD0h case   12:*/		return 0x8216ABD4;
		  /* 8216ABD4h */ case   13:  		/* lwz R4, <#[R1 + 80]> */
		/* 8216ABD4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8216ABD4h case   13:*/		return 0x8216ABD8;
		  /* 8216ABD8h */ case   14:  		/* lwz R6, <#[R1 + 84]> */
		/* 8216ABD8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8216ABD8h case   14:*/		return 0x8216ABDC;
		  /* 8216ABDCh */ case   15:  		/* rlwimi R6, R9, 0, 20, 29 */
		/* 8216ABDCh case   15:*/		cpu::op::rlwimi<0,0,20,29>(regs,&regs.R6,regs.R9);
		/* 8216ABDCh case   15:*/		return 0x8216ABE0;
		  /* 8216ABE0h */ case   16:  		/* rlwimi R4, R7, 0, 18, 31 */
		/* 8216ABE0h case   16:*/		cpu::op::rlwimi<0,0,18,31>(regs,&regs.R4,regs.R7);
		/* 8216ABE0h case   16:*/		return 0x8216ABE4;
		  /* 8216ABE4h */ case   17:  		/* rlwimi R6, R9, 0, 16, 19 */
		/* 8216ABE4h case   17:*/		cpu::op::rlwimi<0,0,16,19>(regs,&regs.R6,regs.R9);
		/* 8216ABE4h case   17:*/		return 0x8216ABE8;
		  /* 8216ABE8h */ case   18:  		/* rlwimi R4, R7, 0, 17, 17 */
		/* 8216ABE8h case   18:*/		cpu::op::rlwimi<0,0,17,17>(regs,&regs.R4,regs.R7);
		/* 8216ABE8h case   18:*/		return 0x8216ABEC;
		  /* 8216ABECh */ case   19:  		/* stw R6, <#[R1 + 84]> */
		/* 8216ABECh case   19:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8216ABECh case   19:*/		return 0x8216ABF0;
		  /* 8216ABF0h */ case   20:  		/* stw R4, <#[R1 + 80]> */
		/* 8216ABF0h case   20:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8216ABF0h case   20:*/		return 0x8216ABF4;
		  /* 8216ABF4h */ case   21:  		/* lbz R9, <#[R11]> */
		/* 8216ABF4h case   21:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216ABF4h case   21:*/		return 0x8216ABF8;
		  /* 8216ABF8h */ case   22:  		/* lbz R6, <#[R10]> */
		/* 8216ABF8h case   22:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8216ABF8h case   22:*/		return 0x8216ABFC;
		  /* 8216ABFCh */ case   23:  		/* subf. R9, R6, R9 */
		/* 8216ABFCh case   23:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8216ABFCh case   23:*/		return 0x8216AC00;
		  /* 8216AC00h */ case   24:  		/* bc 4, CR0_EQ, 20 */
		/* 8216AC00h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8216AC14;  }
		/* 8216AC00h case   24:*/		return 0x8216AC04;
		  /* 8216AC04h */ case   25:  		/* addi R11, R11, 1 */
		/* 8216AC04h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216AC04h case   25:*/		return 0x8216AC08;
		  /* 8216AC08h */ case   26:  		/* addi R10, R10, 1 */
		/* 8216AC08h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216AC08h case   26:*/		return 0x8216AC0C;
		  /* 8216AC0Ch */ case   27:  		/* cmpw CR6, R11, R8 */
		/* 8216AC0Ch case   27:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8216AC0Ch case   27:*/		return 0x8216AC10;
		  /* 8216AC10h */ case   28:  		/* bc 4, CR6_EQ, -28 */
		/* 8216AC10h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8216ABF4;  }
		/* 8216AC10h case   28:*/		return 0x8216AC14;
	}
	return 0x8216AC14;
} // Block from 8216ABA0h-8216AC14h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8216AC14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AC14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AC14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AC14);
		  /* 8216AC14h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 8216AC14h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 8216AC14h case    0:*/		return 0x8216AC18;
		  /* 8216AC18h */ case    1:  		/* bc 4, CR0_EQ, 100 */
		/* 8216AC18h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216AC7C;  }
		/* 8216AC18h case    1:*/		return 0x8216AC1C;
		  /* 8216AC1Ch */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8216AC1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8216AC1Ch case    2:*/		return 0x8216AC20;
		  /* 8216AC20h */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216AC20h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216AC20h case    3:*/		return 0x8216AC24;
		  /* 8216AC24h */ case    4:  		/* add R11, R11, R3 */
		/* 8216AC24h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8216AC24h case    4:*/		return 0x8216AC28;
		  /* 8216AC28h */ case    5:  		/* addi R10, R11, 12 */
		/* 8216AC28h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xC);
		/* 8216AC28h case    5:*/		return 0x8216AC2C;
		  /* 8216AC2Ch */ case    6:  		/* lwz R9, <#[R11 + 12]> */
		/* 8216AC2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AC2Ch case    6:*/		return 0x8216AC30;
		  /* 8216AC30h */ case    7:  		/* rlwinm. R11, R9, 19, 29, 31 */
		/* 8216AC30h case    7:*/		cpu::op::rlwinm<1,19,29,31>(regs,&regs.R11,regs.R9);
		/* 8216AC30h case    7:*/		return 0x8216AC34;
		  /* 8216AC34h */ case    8:  		/* rlwinm R9, R9, 16, 29, 31 */
		/* 8216AC34h case    8:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R9,regs.R9);
		/* 8216AC34h case    8:*/		return 0x8216AC38;
		  /* 8216AC38h */ case    9:  		/* bc 12, CR0_LT, 68 */
		/* 8216AC38h case    9:*/		if ( regs.CR[0].lt ) { return 0x8216AC7C;  }
		/* 8216AC38h case    9:*/		return 0x8216AC3C;
		  /* 8216AC3Ch */ case   10:  		/* cmpwi CR6, R11, 4 */
		/* 8216AC3Ch case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 8216AC3Ch case   10:*/		return 0x8216AC40;
		  /* 8216AC40h */ case   11:  		/* bc 4, CR6_LT, 60 */
		/* 8216AC40h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8216AC7C;  }
		/* 8216AC40h case   11:*/		return 0x8216AC44;
		  /* 8216AC44h */ case   12:  		/* lwz R8, <#[R5]> */
		/* 8216AC44h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 8216AC44h case   12:*/		return 0x8216AC48;
		  /* 8216AC48h */ case   13:  		/* rlwinm R4, R7, 0, 19, 31 */
		/* 8216AC48h case   13:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R4,regs.R7);
		/* 8216AC48h case   13:*/		return 0x8216AC4C;
		  /* 8216AC4Ch */ case   14:  		/* cmplw CR6, R4, R8 */
		/* 8216AC4Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 8216AC4Ch case   14:*/		return 0x8216AC50;
		  /* 8216AC50h */ case   15:  		/* bc 4, CR6_LT, 44 */
		/* 8216AC50h case   15:*/		if ( !regs.CR[6].lt ) { return 0x8216AC7C;  }
		/* 8216AC50h case   15:*/		return 0x8216AC54;
		  /* 8216AC54h */ case   16:  		/* li R8, 33 */
		/* 8216AC54h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x21);
		/* 8216AC54h case   16:*/		return 0x8216AC58;
		  /* 8216AC58h */ case   17:  		/* addi R7, R10, 4 */
		/* 8216AC58h case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x4);
		/* 8216AC58h case   17:*/		return 0x8216AC5C;
		  /* 8216AC5Ch */ case   18:  		/* addi R6, R11, 1 */
		/* 8216AC5Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1);
		/* 8216AC5Ch case   18:*/		return 0x8216AC60;
	}
	return 0x8216AC60;
} // Block from 8216AC14h-8216AC60h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8216AC60h
// Function '?ValidateALUOpcodes@@YAJPBTGPUSHADER_INSTRUCTION@@H_NPBUR500StuffLite@@PAUTODO_LIST@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AC60);
		  /* 8216AC60h */ case    0:  		/* mr R5, R9 */
		/* 8216AC60h case    0:*/		regs.R5 = regs.R9;
		/* 8216AC60h case    0:*/		return 0x8216AC64;
		  /* 8216AC64h */ case    1:  		/* bl -4308 */
		/* 8216AC64h case    1:*/		regs.LR = 0x8216AC68; return 0x82169B90;
		/* 8216AC64h case    1:*/		return 0x8216AC68;
		  /* 8216AC68h */ case    2:  		/* lis R11, -32768 */
		/* 8216AC68h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 8216AC68h case    2:*/		return 0x8216AC6C;
		  /* 8216AC6Ch */ case    3:  		/* srawi R10, R3, 31 */
		/* 8216AC6Ch case    3:*/		cpu::op::srawi<0,31>(regs,&regs.R10,regs.R3);
		/* 8216AC6Ch case    3:*/		return 0x8216AC70;
		  /* 8216AC70h */ case    4:  		/* ori R11, R11, 16389 */
		/* 8216AC70h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4005);
		/* 8216AC70h case    4:*/		return 0x8216AC74;
		  /* 8216AC74h */ case    5:  		/* and R3, R10, R11 */
		/* 8216AC74h case    5:*/		cpu::op::and<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8216AC74h case    5:*/		return 0x8216AC78;
		  /* 8216AC78h */ case    6:  		/* b 12 */
		/* 8216AC78h case    6:*/		return 0x8216AC84;
		/* 8216AC78h case    6:*/		return 0x8216AC7C;
	}
	return 0x8216AC7C;
} // Block from 8216AC60h-8216AC7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216AC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AC7C);
		  /* 8216AC7Ch */ case    0:  		/* lis R3, -32768 */
		/* 8216AC7Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216AC7Ch case    0:*/		return 0x8216AC80;
		  /* 8216AC80h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216AC80h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216AC80h case    1:*/		return 0x8216AC84;
	}
	return 0x8216AC84;
} // Block from 8216AC7Ch-8216AC84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216AC84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AC84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AC84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AC84);
		  /* 8216AC84h */ case    0:  		/* addi R1, R1, 96 */
		/* 8216AC84h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8216AC84h case    0:*/		return 0x8216AC88;
		  /* 8216AC88h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8216AC88h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216AC88h case    1:*/		return 0x8216AC8C;
		  /* 8216AC8Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8216AC8Ch case    2:*/		regs.LR = regs.R12;
		/* 8216AC8Ch case    2:*/		return 0x8216AC90;
		  /* 8216AC90h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8216AC90h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216AC90h case    3:*/		return 0x8216AC94;
	}
	return 0x8216AC94;
} // Block from 8216AC84h-8216AC94h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216AC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AC94);
		  /* 8216AC94h */ case    0:  		/* nop */
		/* 8216AC94h case    0:*/		cpu::op::nop();
		/* 8216AC94h case    0:*/		return 0x8216AC98;
		  /* 8216AC98h */ case    1:  		/* addi R9, R1, -16 */
		/* 8216AC98h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFFF0);
		/* 8216AC98h case    1:*/		return 0x8216AC9C;
		  /* 8216AC9Ch */ case    2:  		/* std R3, <#[R1 + 16]> */
		/* 8216AC9Ch case    2:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000010) );
		/* 8216AC9Ch case    2:*/		return 0x8216ACA0;
		  /* 8216ACA0h */ case    3:  		/* li R6, 0 */
		/* 8216ACA0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8216ACA0h case    3:*/		return 0x8216ACA4;
		  /* 8216ACA4h */ case    4:  		/* lwz R7, <#[R1 + 20]> */
		/* 8216ACA4h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000014) );
		/* 8216ACA4h case    4:*/		return 0x8216ACA8;
		  /* 8216ACA8h */ case    5:  		/* addi R11, R1, -16 */
		/* 8216ACA8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFFF0);
		/* 8216ACA8h case    5:*/		return 0x8216ACAC;
		  /* 8216ACACh */ case    6:  		/* addi R10, R1, 16 */
		/* 8216ACACh case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x10);
		/* 8216ACACh case    6:*/		return 0x8216ACB0;
		  /* 8216ACB0h */ case    7:  		/* addi R8, R11, 8 */
		/* 8216ACB0h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8216ACB0h case    7:*/		return 0x8216ACB4;
		  /* 8216ACB4h */ case    8:  		/* std R6, <#[R9]> */
		/* 8216ACB4h case    8:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 8216ACB4h case    8:*/		return 0x8216ACB8;
		  /* 8216ACB8h */ case    9:  		/* lwz R9, <#[R1 - 12]> */
		/* 8216ACB8h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 8216ACB8h case    9:*/		return 0x8216ACBC;
		  /* 8216ACBCh */ case   10:  		/* rlwimi R9, R7, 0, 16, 20 */
		/* 8216ACBCh case   10:*/		cpu::op::rlwimi<0,0,16,20>(regs,&regs.R9,regs.R7);
		/* 8216ACBCh case   10:*/		return 0x8216ACC0;
		  /* 8216ACC0h */ case   11:  		/* stw R9, <#[R1 - 12]> */
		/* 8216ACC0h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 8216ACC0h case   11:*/		return 0x8216ACC4;
		  /* 8216ACC4h */ case   12:  		/* lbz R9, <#[R11]> */
		/* 8216ACC4h case   12:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8216ACC4h case   12:*/		return 0x8216ACC8;
		  /* 8216ACC8h */ case   13:  		/* lbz R7, <#[R10]> */
		/* 8216ACC8h case   13:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8216ACC8h case   13:*/		return 0x8216ACCC;
		  /* 8216ACCCh */ case   14:  		/* subf. R9, R7, R9 */
		/* 8216ACCCh case   14:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8216ACCCh case   14:*/		return 0x8216ACD0;
		  /* 8216ACD0h */ case   15:  		/* bc 4, CR0_EQ, 20 */
		/* 8216ACD0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8216ACE4;  }
		/* 8216ACD0h case   15:*/		return 0x8216ACD4;
		  /* 8216ACD4h */ case   16:  		/* addi R11, R11, 1 */
		/* 8216ACD4h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216ACD4h case   16:*/		return 0x8216ACD8;
		  /* 8216ACD8h */ case   17:  		/* addi R10, R10, 1 */
		/* 8216ACD8h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216ACD8h case   17:*/		return 0x8216ACDC;
		  /* 8216ACDCh */ case   18:  		/* cmpw CR6, R11, R8 */
		/* 8216ACDCh case   18:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8216ACDCh case   18:*/		return 0x8216ACE0;
		  /* 8216ACE0h */ case   19:  		/* bc 4, CR6_EQ, -28 */
		/* 8216ACE0h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8216ACC4;  }
		/* 8216ACE0h case   19:*/		return 0x8216ACE4;
	}
	return 0x8216ACE4;
} // Block from 8216AC94h-8216ACE4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8216ACE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ACE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ACE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ACE4);
		  /* 8216ACE4h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 8216ACE4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 8216ACE4h case    0:*/		return 0x8216ACE8;
		  /* 8216ACE8h */ case    1:  		/* bc 4, CR0_EQ, 92 */
		/* 8216ACE8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216AD44;  }
		/* 8216ACE8h case    1:*/		return 0x8216ACEC;
		  /* 8216ACECh */ case    2:  		/* lwz R11, <#[R4]> */
		/* 8216ACECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8216ACECh case    2:*/		return 0x8216ACF0;
		  /* 8216ACF0h */ case    3:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216ACF0h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216ACF0h case    3:*/		return 0x8216ACF4;
		  /* 8216ACF4h */ case    4:  		/* add R11, R11, R4 */
		/* 8216ACF4h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8216ACF4h case    4:*/		return 0x8216ACF8;
		  /* 8216ACF8h */ case    5:  		/* addi R10, R11, 12 */
		/* 8216ACF8h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xC);
		/* 8216ACF8h case    5:*/		return 0x8216ACFC;
		  /* 8216ACFCh */ case    6:  		/* addic. R10, R10, 4 */
		/* 8216ACFCh case    6:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0x4);
		/* 8216ACFCh case    6:*/		return 0x8216AD00;
		  /* 8216AD00h */ case    7:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216AD00h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AD00h case    7:*/		return 0x8216AD04;
		  /* 8216AD04h */ case    8:  		/* rlwinm R9, R11, 19, 29, 31 */
		/* 8216AD04h case    8:*/		cpu::op::rlwinm<0,19,29,31>(regs,&regs.R9,regs.R11);
		/* 8216AD04h case    8:*/		return 0x8216AD08;
		  /* 8216AD08h */ case    9:  		/* bc 12, CR0_EQ, 60 */
		/* 8216AD08h case    9:*/		if ( regs.CR[0].eq ) { return 0x8216AD44;  }
		/* 8216AD08h case    9:*/		return 0x8216AD0C;
		  /* 8216AD0Ch */ case   10:  		/* lbz R11, <#[R10]> */
		/* 8216AD0Ch case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216AD0Ch case   10:*/		return 0x8216AD10;
		  /* 8216AD10h */ case   11:  		/* cmpwi CR6, R11, 35 */
		/* 8216AD10h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8216AD10h case   11:*/		return 0x8216AD14;
		  /* 8216AD14h */ case   12:  		/* bc 4, CR6_LT, 12 */
		/* 8216AD14h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8216AD20;  }
		/* 8216AD14h case   12:*/		return 0x8216AD18;
		  /* 8216AD18h */ case   13:  		/* cmpwi CR6, R11, 0 */
		/* 8216AD18h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216AD18h case   13:*/		return 0x8216AD1C;
		  /* 8216AD1Ch */ case   14:  		/* bc 12, CR6_GT, 8 */
		/* 8216AD1Ch case   14:*/		if ( regs.CR[6].gt ) { return 0x8216AD24;  }
		/* 8216AD1Ch case   14:*/		return 0x8216AD20;
	}
	return 0x8216AD20;
} // Block from 8216ACE4h-8216AD20h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8216AD20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AD20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AD20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AD20);
		  /* 8216AD20h */ case    0:  		/* li R11, 0 */
		/* 8216AD20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8216AD20h case    0:*/		return 0x8216AD24;
	}
	return 0x8216AD24;
} // Block from 8216AD20h-8216AD24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216AD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AD24);
		  /* 8216AD24h */ case    0:  		/* cmpwi CR6, R11, 33 */
		/* 8216AD24h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000021);
		/* 8216AD24h case    0:*/		return 0x8216AD28;
		  /* 8216AD28h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 8216AD28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216AD44;  }
		/* 8216AD28h case    1:*/		return 0x8216AD2C;
		  /* 8216AD2Ch */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 8216AD2Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8216AD2Ch case    2:*/		return 0x8216AD30;
		  /* 8216AD30h */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 8216AD30h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8216AD44;  }
		/* 8216AD30h case    3:*/		return 0x8216AD34;
		  /* 8216AD34h */ case    4:  		/* cmpwi CR6, R9, 4 */
		/* 8216AD34h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000004);
		/* 8216AD34h case    4:*/		return 0x8216AD38;
		  /* 8216AD38h */ case    5:  		/* bc 12, CR6_GT, 12 */
		/* 8216AD38h case    5:*/		if ( regs.CR[6].gt ) { return 0x8216AD44;  }
		/* 8216AD38h case    5:*/		return 0x8216AD3C;
		  /* 8216AD3Ch */ case    6:  		/* li R3, 0 */
		/* 8216AD3Ch case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216AD3Ch case    6:*/		return 0x8216AD40;
		  /* 8216AD40h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8216AD40h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216AD40h case    7:*/		return 0x8216AD44;
	}
	return 0x8216AD44;
} // Block from 8216AD24h-8216AD44h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216AD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AD44);
		  /* 8216AD44h */ case    0:  		/* lis R3, -32768 */
		/* 8216AD44h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216AD44h case    0:*/		return 0x8216AD48;
		  /* 8216AD48h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216AD48h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216AD48h case    1:*/		return 0x8216AD4C;
		  /* 8216AD4Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 8216AD4Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216AD4Ch case    2:*/		return 0x8216AD50;
	}
	return 0x8216AD50;
} // Block from 8216AD44h-8216AD50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216AD50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AD50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AD50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AD50);
		  /* 8216AD50h */ case    0:  		/* mfspr R12, LR */
		/* 8216AD50h case    0:*/		regs.R12 = regs.LR;
		/* 8216AD50h case    0:*/		return 0x8216AD54;
		  /* 8216AD54h */ case    1:  		/* bl -891652 */
		/* 8216AD54h case    1:*/		regs.LR = 0x8216AD58; return 0x82091250;
		/* 8216AD54h case    1:*/		return 0x8216AD58;
		  /* 8216AD58h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8216AD58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8216AD58h case    2:*/		return 0x8216AD5C;
		  /* 8216AD5Ch */ case    3:  		/* addi R8, R1, 80 */
		/* 8216AD5Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8216AD5Ch case    3:*/		return 0x8216AD60;
		  /* 8216AD60h */ case    4:  		/* std R3, <#[R1 + 160]> */
		/* 8216AD60h case    4:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x000000A0) );
		/* 8216AD60h case    4:*/		return 0x8216AD64;
		  /* 8216AD64h */ case    5:  		/* li R7, 0 */
		/* 8216AD64h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8216AD64h case    5:*/		return 0x8216AD68;
		  /* 8216AD68h */ case    6:  		/* lwz R9, <#[R1 + 164]> */
		/* 8216AD68h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 8216AD68h case    6:*/		return 0x8216AD6C;
		  /* 8216AD6Ch */ case    7:  		/* mr R27, R6 */
		/* 8216AD6Ch case    7:*/		regs.R27 = regs.R6;
		/* 8216AD6Ch case    7:*/		return 0x8216AD70;
		  /* 8216AD70h */ case    8:  		/* lwz R26, <#[R1 + 160]> */
		/* 8216AD70h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000A0) );
		/* 8216AD70h case    8:*/		return 0x8216AD74;
		  /* 8216AD74h */ case    9:  		/* mr R31, R4 */
		/* 8216AD74h case    9:*/		regs.R31 = regs.R4;
		/* 8216AD74h case    9:*/		return 0x8216AD78;
		  /* 8216AD78h */ case   10:  		/* rlwinm R4, R26, 0, 19, 31 */
		/* 8216AD78h case   10:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R4,regs.R26);
		/* 8216AD78h case   10:*/		return 0x8216AD7C;
		  /* 8216AD7Ch */ case   11:  		/* std R7, <#[R8]> */
		/* 8216AD7Ch case   11:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 8216AD7Ch case   11:*/		return 0x8216AD80;
	}
	return 0x8216AD80;
} // Block from 8216AD50h-8216AD80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8216AD80h
// Function '?ValidateALUOutputs@@YAJPBTGPUSHADER_INSTRUCTION@@HPBUR500StuffLite@@PAUTODO_LIST@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AD80);
		  /* 8216AD80h */ case    0:  		/* addi R11, R1, 80 */
		/* 8216AD80h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8216AD80h case    0:*/		return 0x8216AD84;
		  /* 8216AD84h */ case    1:  		/* addi R10, R1, 160 */
		/* 8216AD84h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 8216AD84h case    1:*/		return 0x8216AD88;
		  /* 8216AD88h */ case    2:  		/* addi R8, R11, 8 */
		/* 8216AD88h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8216AD88h case    2:*/		return 0x8216AD8C;
		  /* 8216AD8Ch */ case    3:  		/* lwz R7, <#[R1 + 84]> */
		/* 8216AD8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8216AD8Ch case    3:*/		return 0x8216AD90;
		  /* 8216AD90h */ case    4:  		/* lwz R6, <#[R1 + 80]> */
		/* 8216AD90h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8216AD90h case    4:*/		return 0x8216AD94;
		  /* 8216AD94h */ case    5:  		/* rlwimi R6, R26, 0, 18, 18 */
		/* 8216AD94h case    5:*/		cpu::op::rlwimi<0,0,18,18>(regs,&regs.R6,regs.R26);
		/* 8216AD94h case    5:*/		return 0x8216AD98;
		  /* 8216AD98h */ case    6:  		/* rlwimi R7, R9, 0, 20, 29 */
		/* 8216AD98h case    6:*/		cpu::op::rlwimi<0,0,20,29>(regs,&regs.R7,regs.R9);
		/* 8216AD98h case    6:*/		return 0x8216AD9C;
		  /* 8216AD9Ch */ case    7:  		/* rlwinm R6, R6, 0, 0, 18 */
		/* 8216AD9Ch case    7:*/		cpu::op::rlwinm<0,0,0,18>(regs,&regs.R6,regs.R6);
		/* 8216AD9Ch case    7:*/		return 0x8216ADA0;
		  /* 8216ADA0h */ case    8:  		/* rlwimi R7, R9, 0, 30, 30 */
		/* 8216ADA0h case    8:*/		cpu::op::rlwimi<0,0,30,30>(regs,&regs.R7,regs.R9);
		/* 8216ADA0h case    8:*/		return 0x8216ADA4;
		  /* 8216ADA4h */ case    9:  		/* or R6, R6, R4 */
		/* 8216ADA4h case    9:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R4);
		/* 8216ADA4h case    9:*/		return 0x8216ADA8;
		  /* 8216ADA8h */ case   10:  		/* rlwimi R7, R9, 0, 16, 19 */
		/* 8216ADA8h case   10:*/		cpu::op::rlwimi<0,0,16,19>(regs,&regs.R7,regs.R9);
		/* 8216ADA8h case   10:*/		return 0x8216ADAC;
		  /* 8216ADACh */ case   11:  		/* rlwimi R6, R26, 0, 17, 17 */
		/* 8216ADACh case   11:*/		cpu::op::rlwimi<0,0,17,17>(regs,&regs.R6,regs.R26);
		/* 8216ADACh case   11:*/		return 0x8216ADB0;
		  /* 8216ADB0h */ case   12:  		/* stw R7, <#[R1 + 84]> */
		/* 8216ADB0h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 8216ADB0h case   12:*/		return 0x8216ADB4;
		  /* 8216ADB4h */ case   13:  		/* stw R6, <#[R1 + 80]> */
		/* 8216ADB4h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8216ADB4h case   13:*/		return 0x8216ADB8;
		  /* 8216ADB8h */ case   14:  		/* lbz R7, <#[R11]> */
		/* 8216ADB8h case   14:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8216ADB8h case   14:*/		return 0x8216ADBC;
		  /* 8216ADBCh */ case   15:  		/* lbz R6, <#[R10]> */
		/* 8216ADBCh case   15:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8216ADBCh case   15:*/		return 0x8216ADC0;
		  /* 8216ADC0h */ case   16:  		/* subf. R7, R6, R7 */
		/* 8216ADC0h case   16:*/		cpu::op::subf<1>(regs,&regs.R7,regs.R6,regs.R7);
		/* 8216ADC0h case   16:*/		return 0x8216ADC4;
		  /* 8216ADC4h */ case   17:  		/* bc 4, CR0_EQ, 20 */
		/* 8216ADC4h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8216ADD8;  }
		/* 8216ADC4h case   17:*/		return 0x8216ADC8;
		  /* 8216ADC8h */ case   18:  		/* addi R11, R11, 1 */
		/* 8216ADC8h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216ADC8h case   18:*/		return 0x8216ADCC;
		  /* 8216ADCCh */ case   19:  		/* addi R10, R10, 1 */
		/* 8216ADCCh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216ADCCh case   19:*/		return 0x8216ADD0;
		  /* 8216ADD0h */ case   20:  		/* cmpw CR6, R11, R8 */
		/* 8216ADD0h case   20:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8216ADD0h case   20:*/		return 0x8216ADD4;
		  /* 8216ADD4h */ case   21:  		/* bc 4, CR6_EQ, -28 */
		/* 8216ADD4h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8216ADB8;  }
		/* 8216ADD4h case   21:*/		return 0x8216ADD8;
	}
	return 0x8216ADD8;
} // Block from 8216AD80h-8216ADD8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8216ADD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ADD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ADD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ADD8);
		  /* 8216ADD8h */ case    0:  		/* cmpwi CR0, R7, 0 */
		/* 8216ADD8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R7,0x00000000);
		/* 8216ADD8h case    0:*/		return 0x8216ADDC;
		  /* 8216ADDCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8216ADDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216ADEC;  }
		/* 8216ADDCh case    1:*/		return 0x8216ADE0;
		  /* 8216ADE0h */ case    2:  		/* lis R3, -32768 */
		/* 8216ADE0h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216ADE0h case    2:*/		return 0x8216ADE4;
		  /* 8216ADE4h */ case    3:  		/* ori R3, R3, 16389 */
		/* 8216ADE4h case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216ADE4h case    3:*/		return 0x8216ADE8;
		  /* 8216ADE8h */ case    4:  		/* b 136 */
		/* 8216ADE8h case    4:*/		return 0x8216AE70;
		/* 8216ADE8h case    4:*/		return 0x8216ADEC;
	}
	return 0x8216ADEC;
} // Block from 8216ADD8h-8216ADECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216ADECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216ADEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216ADEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216ADEC);
		  /* 8216ADECh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8216ADECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216ADECh case    0:*/		return 0x8216ADF0;
		  /* 8216ADF0h */ case    1:  		/* cmplw CR6, R4, R27 */
		/* 8216ADF0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R27);
		/* 8216ADF0h case    1:*/		return 0x8216ADF4;
		  /* 8216ADF4h */ case    2:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216ADF4h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216ADF4h case    2:*/		return 0x8216ADF8;
		  /* 8216ADF8h */ case    3:  		/* add R11, R11, R31 */
		/* 8216ADF8h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8216ADF8h case    3:*/		return 0x8216ADFC;
		  /* 8216ADFCh */ case    4:  		/* addi R11, R11, 12 */
		/* 8216ADFCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8216ADFCh case    4:*/		return 0x8216AE00;
		  /* 8216AE00h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 8216AE00h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8216AE00h case    5:*/		return 0x8216AE04;
		  /* 8216AE04h */ case    6:  		/* rlwinm R29, R10, 16, 29, 31 */
		/* 8216AE04h case    6:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R29,regs.R10);
		/* 8216AE04h case    6:*/		return 0x8216AE08;
		  /* 8216AE08h */ case    7:  		/* rlwinm R28, R10, 19, 29, 31 */
		/* 8216AE08h case    7:*/		cpu::op::rlwinm<0,19,29,31>(regs,&regs.R28,regs.R10);
		/* 8216AE08h case    7:*/		return 0x8216AE0C;
		  /* 8216AE0Ch */ case    8:  		/* bc 12, CR6_GT, 12 */
		/* 8216AE0Ch case    8:*/		if ( regs.CR[6].gt ) { return 0x8216AE18;  }
		/* 8216AE0Ch case    8:*/		return 0x8216AE10;
		  /* 8216AE10h */ case    9:  		/* rlwinm. R10, R9, 0, 30, 30 */
		/* 8216AE10h case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R9);
		/* 8216AE10h case    9:*/		return 0x8216AE14;
		  /* 8216AE14h */ case   10:  		/* bc 4, CR0_EQ, -52 */
		/* 8216AE14h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8216ADE0;  }
		/* 8216AE14h case   10:*/		return 0x8216AE18;
	}
	return 0x8216AE18;
} // Block from 8216ADECh-8216AE18h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216AE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AE18);
		  /* 8216AE18h */ case    0:  		/* lwz R10, <#[R5]> */
		/* 8216AE18h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8216AE18h case    0:*/		return 0x8216AE1C;
		  /* 8216AE1Ch */ case    1:  		/* cmplw CR6, R4, R10 */
		/* 8216AE1Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8216AE1Ch case    1:*/		return 0x8216AE20;
		  /* 8216AE20h */ case    2:  		/* bc 4, CR6_LT, -64 */
		/* 8216AE20h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8216ADE0;  }
		/* 8216AE20h case    2:*/		return 0x8216AE24;
		  /* 8216AE24h */ case    3:  		/* addi R30, R11, 4 */
		/* 8216AE24h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 8216AE24h case    3:*/		return 0x8216AE28;
		  /* 8216AE28h */ case    4:  		/* mr R6, R28 */
		/* 8216AE28h case    4:*/		regs.R6 = regs.R28;
		/* 8216AE28h case    4:*/		return 0x8216AE2C;
		  /* 8216AE2Ch */ case    5:  		/* mr R7, R30 */
		/* 8216AE2Ch case    5:*/		regs.R7 = regs.R30;
		/* 8216AE2Ch case    5:*/		return 0x8216AE30;
		  /* 8216AE30h */ case    6:  		/* mr R5, R29 */
		/* 8216AE30h case    6:*/		regs.R5 = regs.R29;
		/* 8216AE30h case    6:*/		return 0x8216AE34;
		  /* 8216AE34h */ case    7:  		/* mr R3, R31 */
		/* 8216AE34h case    7:*/		regs.R3 = regs.R31;
		/* 8216AE34h case    7:*/		return 0x8216AE38;
		  /* 8216AE38h */ case    8:  		/* bl -5048 */
		/* 8216AE38h case    8:*/		regs.LR = 0x8216AE3C; return 0x82169A80;
		/* 8216AE38h case    8:*/		return 0x8216AE3C;
		  /* 8216AE3Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8216AE3Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216AE3Ch case    9:*/		return 0x8216AE40;
		  /* 8216AE40h */ case   10:  		/* bc 12, CR0_LT, -96 */
		/* 8216AE40h case   10:*/		if ( regs.CR[0].lt ) { return 0x8216ADE0;  }
		/* 8216AE40h case   10:*/		return 0x8216AE44;
		  /* 8216AE44h */ case   11:  		/* rlwinm. R11, R26, 0, 18, 18 */
		/* 8216AE44h case   11:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R26);
		/* 8216AE44h case   11:*/		return 0x8216AE48;
		  /* 8216AE48h */ case   12:  		/* bc 4, CR0_EQ, 36 */
		/* 8216AE48h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8216AE6C;  }
		/* 8216AE48h case   12:*/		return 0x8216AE4C;
		  /* 8216AE4Ch */ case   13:  		/* mr R7, R30 */
		/* 8216AE4Ch case   13:*/		regs.R7 = regs.R30;
		/* 8216AE4Ch case   13:*/		return 0x8216AE50;
		  /* 8216AE50h */ case   14:  		/* mr R6, R28 */
		/* 8216AE50h case   14:*/		regs.R6 = regs.R28;
		/* 8216AE50h case   14:*/		return 0x8216AE54;
		  /* 8216AE54h */ case   15:  		/* mr R5, R29 */
		/* 8216AE54h case   15:*/		regs.R5 = regs.R29;
		/* 8216AE54h case   15:*/		return 0x8216AE58;
		  /* 8216AE58h */ case   16:  		/* addi R4, R27, 1 */
		/* 8216AE58h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R27,0x1);
		/* 8216AE58h case   16:*/		return 0x8216AE5C;
		  /* 8216AE5Ch */ case   17:  		/* mr R3, R31 */
		/* 8216AE5Ch case   17:*/		regs.R3 = regs.R31;
		/* 8216AE5Ch case   17:*/		return 0x8216AE60;
		  /* 8216AE60h */ case   18:  		/* bl -5088 */
		/* 8216AE60h case   18:*/		regs.LR = 0x8216AE64; return 0x82169A80;
		/* 8216AE60h case   18:*/		return 0x8216AE64;
		  /* 8216AE64h */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 8216AE64h case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8216AE64h case   19:*/		return 0x8216AE68;
		  /* 8216AE68h */ case   20:  		/* bc 12, CR0_LT, -136 */
		/* 8216AE68h case   20:*/		if ( regs.CR[0].lt ) { return 0x8216ADE0;  }
		/* 8216AE68h case   20:*/		return 0x8216AE6C;
	}
	return 0x8216AE6C;
} // Block from 8216AE18h-8216AE6Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216AE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AE6C);
		  /* 8216AE6Ch */ case    0:  		/* li R3, 0 */
		/* 8216AE6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216AE6Ch case    0:*/		return 0x8216AE70;
	}
	return 0x8216AE70;
} // Block from 8216AE6Ch-8216AE70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216AE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AE70);
		  /* 8216AE70h */ case    0:  		/* addi R1, R1, 144 */
		/* 8216AE70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8216AE70h case    0:*/		return 0x8216AE74;
		  /* 8216AE74h */ case    1:  		/* b -891860 */
		/* 8216AE74h case    1:*/		return 0x820912A0;
		/* 8216AE74h case    1:*/		return 0x8216AE78;
	}
	return 0x8216AE78;
} // Block from 8216AE70h-8216AE78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216AE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AE78);
		  /* 8216AE78h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 8216AE78h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216AE78h case    0:*/		return 0x8216AE7C;
		  /* 8216AE7Ch */ case    1:  		/* addi R10, R1, -16 */
		/* 8216AE7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFFF0);
		/* 8216AE7Ch case    1:*/		return 0x8216AE80;
		  /* 8216AE80h */ case    2:  		/* std R3, <#[R1 + 16]> */
		/* 8216AE80h case    2:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000010) );
		/* 8216AE80h case    2:*/		return 0x8216AE84;
		  /* 8216AE84h */ case    3:  		/* li R9, 0 */
		/* 8216AE84h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8216AE84h case    3:*/		return 0x8216AE88;
		  /* 8216AE88h */ case    4:  		/* lwz R11, <#[R1 + 16]> */
		/* 8216AE88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 8216AE88h case    4:*/		return 0x8216AE8C;
		  /* 8216AE8Ch */ case    5:  		/* lwz R6, <#[R1 + 20]> */
		/* 8216AE8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000014) );
		/* 8216AE8Ch case    5:*/		return 0x8216AE90;
		  /* 8216AE90h */ case    6:  		/* mr R8, R6 */
		/* 8216AE90h case    6:*/		regs.R8 = regs.R6;
		/* 8216AE90h case    6:*/		return 0x8216AE94;
		  /* 8216AE94h */ case    7:  		/* std R9, <#[R10]> */
		/* 8216AE94h case    7:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8216AE94h case    7:*/		return 0x8216AE98;
		  /* 8216AE98h */ case    8:  		/* rlwinm R7, R11, 0, 29, 31 */
		/* 8216AE98h case    8:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R7,regs.R11);
		/* 8216AE98h case    8:*/		return 0x8216AE9C;
		  /* 8216AE9Ch */ case    9:  		/* addi R11, R1, -16 */
		/* 8216AE9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFFF0);
		/* 8216AE9Ch case    9:*/		return 0x8216AEA0;
		  /* 8216AEA0h */ case   10:  		/* addi R10, R1, 16 */
		/* 8216AEA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x10);
		/* 8216AEA0h case   10:*/		return 0x8216AEA4;
		  /* 8216AEA4h */ case   11:  		/* addi R9, R11, 8 */
		/* 8216AEA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x8);
		/* 8216AEA4h case   11:*/		return 0x8216AEA8;
		  /* 8216AEA8h */ case   12:  		/* lwz R31, <#[R1 - 12]> */
		/* 8216AEA8h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 8216AEA8h case   12:*/		return 0x8216AEAC;
		  /* 8216AEACh */ case   13:  		/* lwz R3, <#[R1 - 16]> */
		/* 8216AEACh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216AEACh case   13:*/		return 0x8216AEB0;
		  /* 8216AEB0h */ case   14:  		/* rlwinm R3, R3, 0, 0, 28 */
		/* 8216AEB0h case   14:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R3,regs.R3);
		/* 8216AEB0h case   14:*/		return 0x8216AEB4;
		  /* 8216AEB4h */ case   15:  		/* rlwimi R31, R8, 0, 21, 23 */
		/* 8216AEB4h case   15:*/		cpu::op::rlwimi<0,0,21,23>(regs,&regs.R31,regs.R8);
		/* 8216AEB4h case   15:*/		return 0x8216AEB8;
		  /* 8216AEB8h */ case   16:  		/* or R8, R3, R7 */
		/* 8216AEB8h case   16:*/		cpu::op::or<0>(regs,&regs.R8,regs.R3,regs.R7);
		/* 8216AEB8h case   16:*/		return 0x8216AEBC;
		  /* 8216AEBCh */ case   17:  		/* rlwimi R31, R6, 0, 16, 19 */
		/* 8216AEBCh case   17:*/		cpu::op::rlwimi<0,0,16,19>(regs,&regs.R31,regs.R6);
		/* 8216AEBCh case   17:*/		return 0x8216AEC0;
		  /* 8216AEC0h */ case   18:  		/* stw R8, <#[R1 - 16]> */
		/* 8216AEC0h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8216AEC0h case   18:*/		return 0x8216AEC4;
		  /* 8216AEC4h */ case   19:  		/* stw R31, <#[R1 - 12]> */
		/* 8216AEC4h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 8216AEC4h case   19:*/		return 0x8216AEC8;
		  /* 8216AEC8h */ case   20:  		/* lbz R8, <#[R11]> */
		/* 8216AEC8h case   20:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8216AEC8h case   20:*/		return 0x8216AECC;
		  /* 8216AECCh */ case   21:  		/* lbz R3, <#[R10]> */
		/* 8216AECCh case   21:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000000) );
		/* 8216AECCh case   21:*/		return 0x8216AED0;
		  /* 8216AED0h */ case   22:  		/* subf. R8, R3, R8 */
		/* 8216AED0h case   22:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R3,regs.R8);
		/* 8216AED0h case   22:*/		return 0x8216AED4;
		  /* 8216AED4h */ case   23:  		/* bc 4, CR0_EQ, 20 */
		/* 8216AED4h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8216AEE8;  }
		/* 8216AED4h case   23:*/		return 0x8216AED8;
		  /* 8216AED8h */ case   24:  		/* addi R11, R11, 1 */
		/* 8216AED8h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8216AED8h case   24:*/		return 0x8216AEDC;
		  /* 8216AEDCh */ case   25:  		/* addi R10, R10, 1 */
		/* 8216AEDCh case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216AEDCh case   25:*/		return 0x8216AEE0;
		  /* 8216AEE0h */ case   26:  		/* cmpw CR6, R11, R9 */
		/* 8216AEE0h case   26:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 8216AEE0h case   26:*/		return 0x8216AEE4;
		  /* 8216AEE4h */ case   27:  		/* bc 4, CR6_EQ, -28 */
		/* 8216AEE4h case   27:*/		if ( !regs.CR[6].eq ) { return 0x8216AEC8;  }
		/* 8216AEE4h case   27:*/		return 0x8216AEE8;
	}
	return 0x8216AEE8;
} // Block from 8216AE78h-8216AEE8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8216AEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AEE8);
		  /* 8216AEE8h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 8216AEE8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 8216AEE8h case    0:*/		return 0x8216AEEC;
		  /* 8216AEECh */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 8216AEECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216AF24;  }
		/* 8216AEECh case    1:*/		return 0x8216AEF0;
	}
	return 0x8216AEF0;
} // Block from 8216AEE8h-8216AEF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216AEF0h
// Function '?ValidateALUInputs@@YAJPBTGPUSHADER_INSTRUCTION@@HPBUR500StuffLite@@PBUTODO_LIST@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AEF0);
		  /* 8216AEF0h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 8216AEF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8216AEF0h case    0:*/		return 0x8216AEF4;
		  /* 8216AEF4h */ case    1:  		/* rlwinm R10, R6, 23, 30, 31 */
		/* 8216AEF4h case    1:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R10,regs.R6);
		/* 8216AEF4h case    1:*/		return 0x8216AEF8;
		  /* 8216AEF8h */ case    2:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216AEF8h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216AEF8h case    2:*/		return 0x8216AEFC;
		  /* 8216AEFCh */ case    3:  		/* cmplwi CR6, R10, 1 */
		/* 8216AEFCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8216AEFCh case    3:*/		return 0x8216AF00;
		  /* 8216AF00h */ case    4:  		/* add R11, R11, R4 */
		/* 8216AF00h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8216AF00h case    4:*/		return 0x8216AF04;
		  /* 8216AF04h */ case    5:  		/* lwz R9, <#[R11 + 12]> */
		/* 8216AF04h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AF04h case    5:*/		return 0x8216AF08;
		  /* 8216AF08h */ case    6:  		/* rlwinm R9, R9, 0, 20, 18 */
		/* 8216AF08h case    6:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R9,regs.R9);
		/* 8216AF08h case    6:*/		return 0x8216AF0C;
		  /* 8216AF0Ch */ case    7:  		/* stw R9, <#[R11 + 12]> */
		/* 8216AF0Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AF0Ch case    7:*/		return 0x8216AF10;
		  /* 8216AF10h */ case    8:  		/* bc 12, CR6_LT, 20 */
		/* 8216AF10h case    8:*/		if ( regs.CR[6].lt ) { return 0x8216AF24;  }
		/* 8216AF10h case    8:*/		return 0x8216AF14;
		  /* 8216AF14h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 8216AF14h case    9:*/		if ( regs.CR[6].eq ) { return 0x8216AF4C;  }
		/* 8216AF14h case    9:*/		return 0x8216AF18;
		  /* 8216AF18h */ case   10:  		/* cmplwi CR6, R10, 3 */
		/* 8216AF18h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8216AF18h case   10:*/		return 0x8216AF1C;
		  /* 8216AF1Ch */ case   11:  		/* bc 12, CR6_LT, 24 */
		/* 8216AF1Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x8216AF34;  }
		/* 8216AF1Ch case   11:*/		return 0x8216AF20;
		  /* 8216AF20h */ case   12:  		/* bc 4, CR6_EQ, 80 */
		/* 8216AF20h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8216AF70;  }
		/* 8216AF20h case   12:*/		return 0x8216AF24;
	}
	return 0x8216AF24;
} // Block from 8216AEF0h-8216AF24h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF24);
		  /* 8216AF24h */ case    0:  		/* lis R3, -32768 */
		/* 8216AF24h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216AF24h case    0:*/		return 0x8216AF28;
		  /* 8216AF28h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216AF28h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216AF28h case    1:*/		return 0x8216AF2C;
		  /* 8216AF2Ch */ case    2:  		/* ld R31, <#[R1 - 8]> */
		/* 8216AF2Ch case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8216AF2Ch case    2:*/		return 0x8216AF30;
		  /* 8216AF30h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8216AF30h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8216AF30h case    3:*/		return 0x8216AF34;
	}
	return 0x8216AF34;
} // Block from 8216AF24h-8216AF34h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF34);
		  /* 8216AF34h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 8216AF34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8216AF34h case    0:*/		return 0x8216AF38;
		  /* 8216AF38h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8216AF38h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216AF24;  }
		/* 8216AF38h case    1:*/		return 0x8216AF3C;
		  /* 8216AF3Ch */ case    2:  		/* rlwinm. R10, R9, 0, 21, 21 */
		/* 8216AF3Ch case    2:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R9);
		/* 8216AF3Ch case    2:*/		return 0x8216AF40;
		  /* 8216AF40h */ case    3:  		/* bc 4, CR0_EQ, -28 */
		/* 8216AF40h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8216AF24;  }
		/* 8216AF40h case    3:*/		return 0x8216AF44;
		  /* 8216AF44h */ case    4:  		/* ori R10, R9, 1024 */
		/* 8216AF44h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R9,0x400);
		/* 8216AF44h case    4:*/		return 0x8216AF48;
		  /* 8216AF48h */ case    5:  		/* b 36 */
		/* 8216AF48h case    5:*/		return 0x8216AF6C;
		/* 8216AF48h case    5:*/		return 0x8216AF4C;
	}
	return 0x8216AF4C;
} // Block from 8216AF34h-8216AF4Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF4C);
		  /* 8216AF4Ch */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 8216AF4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8216AF4Ch case    0:*/		return 0x8216AF50;
		  /* 8216AF50h */ case    1:  		/* bc 4, CR6_EQ, -44 */
		/* 8216AF50h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216AF24;  }
		/* 8216AF50h case    1:*/		return 0x8216AF54;
		  /* 8216AF54h */ case    2:  		/* lbz R10, <#[R5 + 40]> */
		/* 8216AF54h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000028) );
		/* 8216AF54h case    2:*/		return 0x8216AF58;
		  /* 8216AF58h */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 8216AF58h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8216AF58h case    3:*/		return 0x8216AF5C;
		  /* 8216AF5Ch */ case    4:  		/* bc 4, CR0_EQ, -56 */
		/* 8216AF5Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216AF24;  }
		/* 8216AF5Ch case    4:*/		return 0x8216AF60;
		  /* 8216AF60h */ case    5:  		/* rlwinm. R10, R9, 0, 20, 20 */
		/* 8216AF60h case    5:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R9);
		/* 8216AF60h case    5:*/		return 0x8216AF64;
		  /* 8216AF64h */ case    6:  		/* bc 4, CR0_EQ, -64 */
		/* 8216AF64h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8216AF24;  }
		/* 8216AF64h case    6:*/		return 0x8216AF68;
		  /* 8216AF68h */ case    7:  		/* ori R10, R9, 6144 */
		/* 8216AF68h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R9,0x1800);
		/* 8216AF68h case    7:*/		return 0x8216AF6C;
	}
	return 0x8216AF6C;
} // Block from 8216AF4Ch-8216AF6Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF6C);
		  /* 8216AF6Ch */ case    0:  		/* stw R10, <#[R11 + 12]> */
		/* 8216AF6Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AF6Ch case    0:*/		return 0x8216AF70;
	}
	return 0x8216AF70;
} // Block from 8216AF6Ch-8216AF70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF70);
		  /* 8216AF70h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 8216AF70h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AF70h case    0:*/		return 0x8216AF74;
		  /* 8216AF74h */ case    1:  		/* rlwinm. R9, R6, 0, 23, 23 */
		/* 8216AF74h case    1:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R6);
		/* 8216AF74h case    1:*/		return 0x8216AF78;
		  /* 8216AF78h */ case    2:  		/* ori R10, R10, 512 */
		/* 8216AF78h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8216AF78h case    2:*/		return 0x8216AF7C;
		  /* 8216AF7Ch */ case    3:  		/* stw R10, <#[R11 + 12]> */
		/* 8216AF7Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AF7Ch case    3:*/		return 0x8216AF80;
		  /* 8216AF80h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 8216AF80h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8216AF8C;  }
		/* 8216AF80h case    4:*/		return 0x8216AF84;
		  /* 8216AF84h */ case    5:  		/* rlwinm R10, R10, 0, 26, 24 */
		/* 8216AF84h case    5:*/		cpu::op::rlwinm<0,0,26,24>(regs,&regs.R10,regs.R10);
		/* 8216AF84h case    5:*/		return 0x8216AF88;
		  /* 8216AF88h */ case    6:  		/* stw R10, <#[R11 + 12]> */
		/* 8216AF88h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AF88h case    6:*/		return 0x8216AF8C;
	}
	return 0x8216AF8C;
} // Block from 8216AF70h-8216AF8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF8C);
		  /* 8216AF8Ch */ case    0:  		/* li R3, 0 */
		/* 8216AF8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216AF8Ch case    0:*/		return 0x8216AF90;
		  /* 8216AF90h */ case    1:  		/* b -100 */
		/* 8216AF90h case    1:*/		return 0x8216AF2C;
		/* 8216AF90h case    1:*/		return 0x8216AF94;
		  /* 8216AF94h */ case    2:  		/* nop */
		/* 8216AF94h case    2:*/		cpu::op::nop();
		/* 8216AF94h case    2:*/		return 0x8216AF98;
	}
	return 0x8216AF98;
} // Block from 8216AF8Ch-8216AF98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216AF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216AF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216AF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216AF98);
		  /* 8216AF98h */ case    0:  		/* mfspr R12, LR */
		/* 8216AF98h case    0:*/		regs.R12 = regs.LR;
		/* 8216AF98h case    0:*/		return 0x8216AF9C;
		  /* 8216AF9Ch */ case    1:  		/* bl -892280 */
		/* 8216AF9Ch case    1:*/		regs.LR = 0x8216AFA0; return 0x82091224;
		/* 8216AF9Ch case    1:*/		return 0x8216AFA0;
		  /* 8216AFA0h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 8216AFA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8216AFA0h case    2:*/		return 0x8216AFA4;
		  /* 8216AFA4h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 8216AFA4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8216AFA4h case    3:*/		return 0x8216AFA8;
		  /* 8216AFA8h */ case    4:  		/* mr R22, R3 */
		/* 8216AFA8h case    4:*/		regs.R22 = regs.R3;
		/* 8216AFA8h case    4:*/		return 0x8216AFAC;
		  /* 8216AFACh */ case    5:  		/* mr R28, R4 */
		/* 8216AFACh case    5:*/		regs.R28 = regs.R4;
		/* 8216AFACh case    5:*/		return 0x8216AFB0;
		  /* 8216AFB0h */ case    6:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8216AFB0h case    6:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8216AFB0h case    6:*/		return 0x8216AFB4;
		  /* 8216AFB4h */ case    7:  		/* mr R26, R5 */
		/* 8216AFB4h case    7:*/		regs.R26 = regs.R5;
		/* 8216AFB4h case    7:*/		return 0x8216AFB8;
		  /* 8216AFB8h */ case    8:  		/* add R11, R11, R4 */
		/* 8216AFB8h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8216AFB8h case    8:*/		return 0x8216AFBC;
		  /* 8216AFBCh */ case    9:  		/* mr R23, R6 */
		/* 8216AFBCh case    9:*/		regs.R23 = regs.R6;
		/* 8216AFBCh case    9:*/		return 0x8216AFC0;
		  /* 8216AFC0h */ case   10:  		/* addi R27, R11, 12 */
		/* 8216AFC0h case   10:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xC);
		/* 8216AFC0h case   10:*/		return 0x8216AFC4;
		  /* 8216AFC4h */ case   11:  		/* lwz R11, <#[R11 + 12]> */
		/* 8216AFC4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8216AFC4h case   11:*/		return 0x8216AFC8;
		  /* 8216AFC8h */ case   12:  		/* rlwinm. R21, R11, 19, 29, 31 */
		/* 8216AFC8h case   12:*/		cpu::op::rlwinm<1,19,29,31>(regs,&regs.R21,regs.R11);
		/* 8216AFC8h case   12:*/		return 0x8216AFCC;
		  /* 8216AFCCh */ case   13:  		/* rlwinm R24, R11, 13, 19, 31 */
		/* 8216AFCCh case   13:*/		cpu::op::rlwinm<0,13,19,31>(regs,&regs.R24,regs.R11);
		/* 8216AFCCh case   13:*/		return 0x8216AFD0;
		  /* 8216AFD0h */ case   14:  		/* rlwinm R20, R11, 16, 29, 31 */
		/* 8216AFD0h case   14:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R20,regs.R11);
		/* 8216AFD0h case   14:*/		return 0x8216AFD4;
		  /* 8216AFD4h */ case   15:  		/* bc 12, CR0_LT, 1068 */
		/* 8216AFD4h case   15:*/		if ( regs.CR[0].lt ) { return 0x8216B400;  }
		/* 8216AFD4h case   15:*/		return 0x8216AFD8;
		  /* 8216AFD8h */ case   16:  		/* cmpwi CR6, R21, 4 */
		/* 8216AFD8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000004);
		/* 8216AFD8h case   16:*/		return 0x8216AFDC;
		  /* 8216AFDCh */ case   17:  		/* bc 12, CR6_GT, 1060 */
		/* 8216AFDCh case   17:*/		if ( regs.CR[6].gt ) { return 0x8216B400;  }
		/* 8216AFDCh case   17:*/		return 0x8216AFE0;
		  /* 8216AFE0h */ case   18:  		/* cmpwi CR6, R20, 0 */
		/* 8216AFE0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8216AFE0h case   18:*/		return 0x8216AFE4;
		  /* 8216AFE4h */ case   19:  		/* bc 12, CR6_LT, 1052 */
		/* 8216AFE4h case   19:*/		if ( regs.CR[6].lt ) { return 0x8216B400;  }
		/* 8216AFE4h case   19:*/		return 0x8216AFE8;
		  /* 8216AFE8h */ case   20:  		/* cmpwi CR6, R20, 4 */
		/* 8216AFE8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000004);
		/* 8216AFE8h case   20:*/		return 0x8216AFEC;
		  /* 8216AFECh */ case   21:  		/* bc 12, CR6_GT, 1044 */
		/* 8216AFECh case   21:*/		if ( regs.CR[6].gt ) { return 0x8216B400;  }
		/* 8216AFECh case   21:*/		return 0x8216AFF0;
		  /* 8216AFF0h */ case   22:  		/* cmpwi CR6, R24, 0 */
		/* 8216AFF0h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8216AFF0h case   22:*/		return 0x8216AFF4;
		  /* 8216AFF4h */ case   23:  		/* bc 12, CR6_LT, 1036 */
		/* 8216AFF4h case   23:*/		if ( regs.CR[6].lt ) { return 0x8216B400;  }
		/* 8216AFF4h case   23:*/		return 0x8216AFF8;
		  /* 8216AFF8h */ case   24:  		/* addi R11, R24, 1 */
		/* 8216AFF8h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0x1);
		/* 8216AFF8h case   24:*/		return 0x8216AFFC;
		  /* 8216AFFCh */ case   25:  		/* li R25, 0 */
		/* 8216AFFCh case   25:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8216AFFCh case   25:*/		return 0x8216B000;
		  /* 8216B000h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8216B000h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8216B000h case   26:*/		return 0x8216B004;
		  /* 8216B004h */ case   27:  		/* li R30, 1 */
		/* 8216B004h case   27:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8216B004h case   27:*/		return 0x8216B008;
		  /* 8216B008h */ case   28:  		/* add R31, R11, R5 */
		/* 8216B008h case   28:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R5);
		/* 8216B008h case   28:*/		return 0x8216B00C;
		  /* 8216B00Ch */ case   29:  		/* lwz R11, <#[R26]> */
		/* 8216B00Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8216B00Ch case   29:*/		return 0x8216B010;
		  /* 8216B010h */ case   30:  		/* cmplw CR6, R24, R11 */
		/* 8216B010h case   30:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 8216B010h case   30:*/		return 0x8216B014;
		  /* 8216B014h */ case   31:  		/* bc 4, CR6_LT, 1004 */
		/* 8216B014h case   31:*/		if ( !regs.CR[6].lt ) { return 0x8216B400;  }
		/* 8216B014h case   31:*/		return 0x8216B018;
		  /* 8216B018h */ case   32:  		/* srawi R11, R24, 1 */
		/* 8216B018h case   32:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R24);
		/* 8216B018h case   32:*/		return 0x8216B01C;
		  /* 8216B01Ch */ case   33:  		/* rlwinm. R10, R24, 0, 31, 31 */
		/* 8216B01Ch case   33:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R24);
		/* 8216B01Ch case   33:*/		return 0x8216B020;
		  /* 8216B020h */ case   34:  		/* mulli R11, R11, 12 */
		/* 8216B020h case   34:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8216B020h case   34:*/		return 0x8216B024;
		  /* 8216B024h */ case   35:  		/* add R11, R11, R22 */
		/* 8216B024h case   35:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R22);
		/* 8216B024h case   35:*/		return 0x8216B028;
		  /* 8216B028h */ case   36:  		/* lwz R10, <#[R11 + 4]> */
		/* 8216B028h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8216B028h case   36:*/		return 0x8216B02C;
		  /* 8216B02Ch */ case   37:  		/* lwz R9, <#[R11 + 8]> */
		/* 8216B02Ch case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8216B02Ch case   37:*/		return 0x8216B030;
		  /* 8216B030h */ case   38:  		/* rlwinm R8, R10, 16, 16, 31 */
		/* 8216B030h case   38:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R10);
		/* 8216B030h case   38:*/		return 0x8216B034;
		  /* 8216B034h */ case   39:  		/* lwz R11, <#[R11]> */
		/* 8216B034h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216B034h case   39:*/		return 0x8216B038;
		  /* 8216B038h */ case   40:  		/* rlwinm R7, R9, 16, 0, 15 */
		/* 8216B038h case   40:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R9);
		/* 8216B038h case   40:*/		return 0x8216B03C;
		  /* 8216B03Ch */ case   41:  		/* rlwinm R9, R9, 16, 16, 31 */
		/* 8216B03Ch case   41:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R9,regs.R9);
		/* 8216B03Ch case   41:*/		return 0x8216B040;
		  /* 8216B040h */ case   42:  		/* or R8, R7, R8 */
		/* 8216B040h case   42:*/		cpu::op::or<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8216B040h case   42:*/		return 0x8216B044;
		  /* 8216B044h */ case   43:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8216B044h case   43:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8216B044h case   43:*/		return 0x8216B048;
		  /* 8216B048h */ case   44:  		/* stw R9, <#[R1 + 124]> */
		/* 8216B048h case   44:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 8216B048h case   44:*/		return 0x8216B04C;
		  /* 8216B04Ch */ case   45:  		/* stw R8, <#[R1 + 120]> */
		/* 8216B04Ch case   45:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8216B04Ch case   45:*/		return 0x8216B050;
		  /* 8216B050h */ case   46:  		/* ld R3, <#[R1 + 120]> */
		/* 8216B050h case   46:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0x00000078) );
		/* 8216B050h case   46:*/		return 0x8216B054;
		  /* 8216B054h */ case   47:  		/* stw R10, <#[R1 + 132]> */
		/* 8216B054h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 8216B054h case   47:*/		return 0x8216B058;
		  /* 8216B058h */ case   48:  		/* stw R11, <#[R1 + 128]> */
		/* 8216B058h case   48:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 8216B058h case   48:*/		return 0x8216B05C;
		  /* 8216B05Ch */ case   49:  		/* bc 4, CR0_EQ, 8 */
		/* 8216B05Ch case   49:*/		if ( !regs.CR[0].eq ) { return 0x8216B064;  }
		/* 8216B05Ch case   49:*/		return 0x8216B060;
		  /* 8216B060h */ case   50:  		/* ld R3, <#[R1 + 128]> */
		/* 8216B060h case   50:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R1 + 0x00000080) );
		/* 8216B060h case   50:*/		return 0x8216B064;
	}
	return 0x8216B064;
} // Block from 8216AF98h-8216B064h (51 instructions)

//////////////////////////////////////////////////////
// Block at 8216B064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B064);
		  /* 8216B064h */ case    0:  		/* lwz R8, <#[R31]> */
		/* 8216B064h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B064h case    0:*/		return 0x8216B068;
	}
	return 0x8216B068;
} // Block from 8216B064h-8216B068h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B068h
// Function '?ValidateAluOrFetchInstruction@@YAJPBTGPUSHADER_INSTRUCTION@@H_N111PAUInstructionUsageLite@@PBUR500StuffLite@@PAUTODO_LIST@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B068);
		  /* 8216B068h */ case    0:  		/* std R3, <#[R1 + 96]> */
		/* 8216B068h case    0:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8216B068h case    0:*/		return 0x8216B06C;
		  /* 8216B06Ch */ case    1:  		/* rlwinm R11, R8, 2, 30, 31 */
		/* 8216B06Ch case    1:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R11,regs.R8);
		/* 8216B06Ch case    1:*/		return 0x8216B070;
		  /* 8216B070h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 8216B070h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8216B070h case    2:*/		return 0x8216B074;
		  /* 8216B074h */ case    3:  		/* bc 4, CR6_EQ, 328 */
		/* 8216B074h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8216B1BC;  }
		/* 8216B074h case    3:*/		return 0x8216B078;
		  /* 8216B078h */ case    4:  		/* addic. R9, R27, 4 */
		/* 8216B078h case    4:*/		cpu::op::addic<1>(regs,&regs.R9,regs.R27,0x4);
		/* 8216B078h case    4:*/		return 0x8216B07C;
		  /* 8216B07Ch */ case    5:  		/* bc 12, CR0_EQ, 24 */
		/* 8216B07Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8216B094;  }
		/* 8216B07Ch case    5:*/		return 0x8216B080;
		  /* 8216B080h */ case    6:  		/* lbz R11, <#[R9]> */
		/* 8216B080h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B080h case    6:*/		return 0x8216B084;
		  /* 8216B084h */ case    7:  		/* cmpwi CR6, R11, 35 */
		/* 8216B084h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8216B084h case    7:*/		return 0x8216B088;
		  /* 8216B088h */ case    8:  		/* bc 4, CR6_LT, 12 */
		/* 8216B088h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8216B094;  }
		/* 8216B088h case    8:*/		return 0x8216B08C;
		  /* 8216B08Ch */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8216B08Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216B08Ch case    9:*/		return 0x8216B090;
		  /* 8216B090h */ case   10:  		/* bc 12, CR6_GT, 8 */
		/* 8216B090h case   10:*/		if ( regs.CR[6].gt ) { return 0x8216B098;  }
		/* 8216B090h case   10:*/		return 0x8216B094;
	}
	return 0x8216B094;
} // Block from 8216B068h-8216B094h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8216B094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B094);
		  /* 8216B094h */ case    0:  		/* mr R11, R25 */
		/* 8216B094h case    0:*/		regs.R11 = regs.R25;
		/* 8216B094h case    0:*/		return 0x8216B098;
	}
	return 0x8216B098;
} // Block from 8216B094h-8216B098h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B098);
		  /* 8216B098h */ case    0:  		/* rlwinm R10, R8, 0, 26, 31 */
		/* 8216B098h case    0:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R8);
		/* 8216B098h case    0:*/		return 0x8216B09C;
		  /* 8216B09Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8216B09Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8216B09Ch case    1:*/		return 0x8216B0A0;
		  /* 8216B0A0h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 8216B0A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216B0DC;  }
		/* 8216B0A0h case    2:*/		return 0x8216B0A4;
		  /* 8216B0A4h */ case    3:  		/* cmplwi CR0, R9, 0 */
		/* 8216B0A4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 8216B0A4h case    3:*/		return 0x8216B0A8;
		  /* 8216B0A8h */ case    4:  		/* bc 12, CR0_EQ, 856 */
		/* 8216B0A8h case    4:*/		if ( regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B0A8h case    4:*/		return 0x8216B0AC;
		  /* 8216B0ACh */ case    5:  		/* lbz R11, <#[R9]> */
		/* 8216B0ACh case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B0ACh case    5:*/		return 0x8216B0B0;
		  /* 8216B0B0h */ case    6:  		/* cmpwi CR6, R11, 35 */
		/* 8216B0B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8216B0B0h case    6:*/		return 0x8216B0B4;
		  /* 8216B0B4h */ case    7:  		/* bc 4, CR6_LT, 12 */
		/* 8216B0B4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8216B0C0;  }
		/* 8216B0B4h case    7:*/		return 0x8216B0B8;
		  /* 8216B0B8h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 8216B0B8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216B0B8h case    8:*/		return 0x8216B0BC;
		  /* 8216B0BCh */ case    9:  		/* bc 12, CR6_GT, 16 */
		/* 8216B0BCh case    9:*/		if ( regs.CR[6].gt ) { return 0x8216B0CC;  }
		/* 8216B0BCh case    9:*/		return 0x8216B0C0;
	}
	return 0x8216B0C0;
} // Block from 8216B098h-8216B0C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8216B0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B0C0);
		  /* 8216B0C0h */ case    0:  		/* mr R11, R25 */
		/* 8216B0C0h case    0:*/		regs.R11 = regs.R25;
		/* 8216B0C0h case    0:*/		return 0x8216B0C4;
		  /* 8216B0C4h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 8216B0C4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8216B0C4h case    1:*/		return 0x8216B0C8;
		  /* 8216B0C8h */ case    2:  		/* bc 12, CR6_EQ, 824 */
		/* 8216B0C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B0C8h case    2:*/		return 0x8216B0CC;
	}
	return 0x8216B0CC;
} // Block from 8216B0C0h-8216B0CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8216B0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B0CC);
		  /* 8216B0CCh */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8216B0CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8216B0CCh case    0:*/		return 0x8216B0D0;
		  /* 8216B0D0h */ case    1:  		/* bc 4, CR6_EQ, 816 */
		/* 8216B0D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B0D0h case    1:*/		return 0x8216B0D4;
		  /* 8216B0D4h */ case    2:  		/* rlwimi R8, R11, 0, 26, 31 */
		/* 8216B0D4h case    2:*/		cpu::op::rlwimi<0,0,26,31>(regs,&regs.R8,regs.R11);
		/* 8216B0D4h case    2:*/		return 0x8216B0D8;
		  /* 8216B0D8h */ case    3:  		/* stw R8, <#[R31]> */
		/* 8216B0D8h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B0D8h case    3:*/		return 0x8216B0DC;
	}
	return 0x8216B0DC;
} // Block from 8216B0CCh-8216B0DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216B0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B0DC);
		  /* 8216B0DCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8216B0DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B0DCh case    0:*/		return 0x8216B0E0;
		  /* 8216B0E0h */ case    1:  		/* slw R10, R30, R21 */
		/* 8216B0E0h case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R30,regs.R21);
		/* 8216B0E0h case    1:*/		return 0x8216B0E4;
		  /* 8216B0E4h */ case    2:  		/* rlwinm R9, R11, 7, 25, 31 */
		/* 8216B0E4h case    2:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R9,regs.R11);
		/* 8216B0E4h case    2:*/		return 0x8216B0E8;
		  /* 8216B0E8h */ case    3:  		/* and R10, R9, R10 */
		/* 8216B0E8h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216B0E8h case    3:*/		return 0x8216B0EC;
		  /* 8216B0ECh */ case    4:  		/* rlwinm. R10, R10, 0, 27, 31 */
		/* 8216B0ECh case    4:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8216B0ECh case    4:*/		return 0x8216B0F0;
		  /* 8216B0F0h */ case    5:  		/* bc 12, CR0_EQ, 252 */
		/* 8216B0F0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B0F0h case    5:*/		return 0x8216B0F4;
		  /* 8216B0F4h */ case    6:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 8216B0F4h case    6:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 8216B0F4h case    6:*/		return 0x8216B0F8;
		  /* 8216B0F8h */ case    7:  		/* slw R9, R30, R20 */
		/* 8216B0F8h case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R20);
		/* 8216B0F8h case    7:*/		return 0x8216B0FC;
		  /* 8216B0FCh */ case    8:  		/* and R10, R10, R9 */
		/* 8216B0FCh case    8:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8216B0FCh case    8:*/		return 0x8216B100;
		  /* 8216B100h */ case    9:  		/* rlwinm. R10, R10, 0, 27, 31 */
		/* 8216B100h case    9:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8216B100h case    9:*/		return 0x8216B104;
		  /* 8216B104h */ case   10:  		/* bc 12, CR0_EQ, 232 */
		/* 8216B104h case   10:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B104h case   10:*/		return 0x8216B108;
		  /* 8216B108h */ case   11:  		/* lwz R10, <#[R27]> */
		/* 8216B108h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B108h case   11:*/		return 0x8216B10C;
		  /* 8216B10Ch */ case   12:  		/* rlwinm R9, R11, 14, 18, 31 */
		/* 8216B10Ch case   12:*/		cpu::op::rlwinm<0,14,18,31>(regs,&regs.R9,regs.R11);
		/* 8216B10Ch case   12:*/		return 0x8216B110;
		  /* 8216B110h */ case   13:  		/* rlwinm R8, R10, 20, 31, 31 */
		/* 8216B110h case   13:*/		cpu::op::rlwinm<0,20,31,31>(regs,&regs.R8,regs.R10);
		/* 8216B110h case   13:*/		return 0x8216B114;
		  /* 8216B114h */ case   14:  		/* slw R8, R30, R8 */
		/* 8216B114h case   14:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R30,regs.R8);
		/* 8216B114h case   14:*/		return 0x8216B118;
		  /* 8216B118h */ case   15:  		/* and R9, R8, R9 */
		/* 8216B118h case   15:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8216B118h case   15:*/		return 0x8216B11C;
		  /* 8216B11Ch */ case   16:  		/* rlwinm. R9, R9, 0, 30, 31 */
		/* 8216B11Ch case   16:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8216B11Ch case   16:*/		return 0x8216B120;
		  /* 8216B120h */ case   17:  		/* bc 12, CR0_EQ, 204 */
		/* 8216B120h case   17:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B120h case   17:*/		return 0x8216B124;
		  /* 8216B124h */ case   18:  		/* rlwinm R9, R10, 21, 31, 31 */
		/* 8216B124h case   18:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B124h case   18:*/		return 0x8216B128;
		  /* 8216B128h */ case   19:  		/* rlwinm R8, R11, 16, 16, 31 */
		/* 8216B128h case   19:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R11);
		/* 8216B128h case   19:*/		return 0x8216B12C;
		  /* 8216B12Ch */ case   20:  		/* slw R9, R30, R9 */
		/* 8216B12Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B12Ch case   20:*/		return 0x8216B130;
		  /* 8216B130h */ case   21:  		/* and R9, R9, R8 */
		/* 8216B130h case   21:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216B130h case   21:*/		return 0x8216B134;
		  /* 8216B134h */ case   22:  		/* rlwinm. R9, R9, 0, 30, 31 */
		/* 8216B134h case   22:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8216B134h case   22:*/		return 0x8216B138;
		  /* 8216B138h */ case   23:  		/* bc 12, CR0_EQ, 180 */
		/* 8216B138h case   23:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B138h case   23:*/		return 0x8216B13C;
		  /* 8216B13Ch */ case   24:  		/* rlwinm R9, R10, 22, 31, 31 */
		/* 8216B13Ch case   24:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B13Ch case   24:*/		return 0x8216B140;
		  /* 8216B140h */ case   25:  		/* rlwinm R8, R11, 18, 14, 31 */
		/* 8216B140h case   25:*/		cpu::op::rlwinm<0,18,14,31>(regs,&regs.R8,regs.R11);
		/* 8216B140h case   25:*/		return 0x8216B144;
		  /* 8216B144h */ case   26:  		/* slw R9, R30, R9 */
		/* 8216B144h case   26:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B144h case   26:*/		return 0x8216B148;
		  /* 8216B148h */ case   27:  		/* and R9, R9, R8 */
		/* 8216B148h case   27:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216B148h case   27:*/		return 0x8216B14C;
		  /* 8216B14Ch */ case   28:  		/* rlwinm. R9, R9, 0, 30, 31 */
		/* 8216B14Ch case   28:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8216B14Ch case   28:*/		return 0x8216B150;
		  /* 8216B150h */ case   29:  		/* bc 12, CR0_EQ, 156 */
		/* 8216B150h case   29:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B150h case   29:*/		return 0x8216B154;
		  /* 8216B154h */ case   30:  		/* rlwinm R9, R10, 23, 31, 31 */
		/* 8216B154h case   30:*/		cpu::op::rlwinm<0,23,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B154h case   30:*/		return 0x8216B158;
		  /* 8216B158h */ case   31:  		/* rlwinm R8, R11, 20, 12, 31 */
		/* 8216B158h case   31:*/		cpu::op::rlwinm<0,20,12,31>(regs,&regs.R8,regs.R11);
		/* 8216B158h case   31:*/		return 0x8216B15C;
		  /* 8216B15Ch */ case   32:  		/* slw R9, R30, R9 */
		/* 8216B15Ch case   32:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B15Ch case   32:*/		return 0x8216B160;
		  /* 8216B160h */ case   33:  		/* and R9, R9, R8 */
		/* 8216B160h case   33:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216B160h case   33:*/		return 0x8216B164;
		  /* 8216B164h */ case   34:  		/* rlwinm. R9, R9, 0, 30, 31 */
		/* 8216B164h case   34:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8216B164h case   34:*/		return 0x8216B168;
		  /* 8216B168h */ case   35:  		/* bc 12, CR0_EQ, 132 */
		/* 8216B168h case   35:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B168h case   35:*/		return 0x8216B16C;
		  /* 8216B16Ch */ case   36:  		/* rlwinm R9, R10, 24, 31, 31 */
		/* 8216B16Ch case   36:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B16Ch case   36:*/		return 0x8216B170;
		  /* 8216B170h */ case   37:  		/* rlwinm R8, R11, 22, 10, 31 */
		/* 8216B170h case   37:*/		cpu::op::rlwinm<0,22,10,31>(regs,&regs.R8,regs.R11);
		/* 8216B170h case   37:*/		return 0x8216B174;
		  /* 8216B174h */ case   38:  		/* slw R9, R30, R9 */
		/* 8216B174h case   38:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B174h case   38:*/		return 0x8216B178;
		  /* 8216B178h */ case   39:  		/* and R9, R9, R8 */
		/* 8216B178h case   39:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216B178h case   39:*/		return 0x8216B17C;
		  /* 8216B17Ch */ case   40:  		/* rlwinm. R9, R9, 0, 30, 31 */
		/* 8216B17Ch case   40:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8216B17Ch case   40:*/		return 0x8216B180;
		  /* 8216B180h */ case   41:  		/* bc 12, CR0_EQ, 108 */
		/* 8216B180h case   41:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B180h case   41:*/		return 0x8216B184;
		  /* 8216B184h */ case   42:  		/* rlwinm R9, R10, 25, 31, 31 */
		/* 8216B184h case   42:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B184h case   42:*/		return 0x8216B188;
		  /* 8216B188h */ case   43:  		/* rlwinm R8, R11, 24, 8, 31 */
		/* 8216B188h case   43:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R8,regs.R11);
		/* 8216B188h case   43:*/		return 0x8216B18C;
		  /* 8216B18Ch */ case   44:  		/* slw R9, R30, R9 */
		/* 8216B18Ch case   44:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B18Ch case   44:*/		return 0x8216B190;
		  /* 8216B190h */ case   45:  		/* and R9, R9, R8 */
		/* 8216B190h case   45:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8216B190h case   45:*/		return 0x8216B194;
		  /* 8216B194h */ case   46:  		/* rlwinm. R9, R9, 0, 30, 31 */
		/* 8216B194h case   46:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8216B194h case   46:*/		return 0x8216B198;
		  /* 8216B198h */ case   47:  		/* bc 12, CR0_EQ, 84 */
		/* 8216B198h case   47:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B198h case   47:*/		return 0x8216B19C;
		  /* 8216B19Ch */ case   48:  		/* rlwinm R10, R10, 26, 31, 31 */
		/* 8216B19Ch case   48:*/		cpu::op::rlwinm<0,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8216B19Ch case   48:*/		return 0x8216B1A0;
		  /* 8216B1A0h */ case   49:  		/* rlwinm R11, R11, 26, 6, 31 */
		/* 8216B1A0h case   49:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R11);
		/* 8216B1A0h case   49:*/		return 0x8216B1A4;
		  /* 8216B1A4h */ case   50:  		/* slw R10, R30, R10 */
		/* 8216B1A4h case   50:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 8216B1A4h case   50:*/		return 0x8216B1A8;
		  /* 8216B1A8h */ case   51:  		/* and R11, R10, R11 */
		/* 8216B1A8h case   51:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216B1A8h case   51:*/		return 0x8216B1AC;
		  /* 8216B1ACh */ case   52:  		/* rlwinm. R11, R11, 0, 30, 31 */
		/* 8216B1ACh case   52:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8216B1ACh case   52:*/		return 0x8216B1B0;
		  /* 8216B1B0h */ case   53:  		/* bc 12, CR0_EQ, 60 */
		/* 8216B1B0h case   53:*/		if ( regs.CR[0].eq ) { return 0x8216B1EC;  }
		/* 8216B1B0h case   53:*/		return 0x8216B1B4;
		  /* 8216B1B4h */ case   54:  		/* li R3, 0 */
		/* 8216B1B4h case   54:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8216B1B4h case   54:*/		return 0x8216B1B8;
		  /* 8216B1B8h */ case   55:  		/* b 592 */
		/* 8216B1B8h case   55:*/		return 0x8216B408;
		/* 8216B1B8h case   55:*/		return 0x8216B1BC;
	}
	return 0x8216B1BC;
} // Block from 8216B0DCh-8216B1BCh (56 instructions)

//////////////////////////////////////////////////////
// Block at 8216B1BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B1BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B1BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B1BC);
		  /* 8216B1BCh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8216B1BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8216B1BCh case    0:*/		return 0x8216B1C0;
		  /* 8216B1C0h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 8216B1C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8216B1EC;  }
		/* 8216B1C0h case    1:*/		return 0x8216B1C4;
		  /* 8216B1C4h */ case    2:  		/* addic. R11, R27, 4 */
		/* 8216B1C4h case    2:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R27,0x4);
		/* 8216B1C4h case    2:*/		return 0x8216B1C8;
		  /* 8216B1C8h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 8216B1C8h case    3:*/		if ( regs.CR[0].eq ) { return 0x8216B1E0;  }
		/* 8216B1C8h case    3:*/		return 0x8216B1CC;
		  /* 8216B1CCh */ case    4:  		/* lbz R11, <#[R11]> */
		/* 8216B1CCh case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8216B1CCh case    4:*/		return 0x8216B1D0;
		  /* 8216B1D0h */ case    5:  		/* cmpwi CR6, R11, 35 */
		/* 8216B1D0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000023);
		/* 8216B1D0h case    5:*/		return 0x8216B1D4;
		  /* 8216B1D4h */ case    6:  		/* bc 4, CR6_LT, 12 */
		/* 8216B1D4h case    6:*/		if ( !regs.CR[6].lt ) { return 0x8216B1E0;  }
		/* 8216B1D4h case    6:*/		return 0x8216B1D8;
		  /* 8216B1D8h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 8216B1D8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8216B1D8h case    7:*/		return 0x8216B1DC;
		  /* 8216B1DCh */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 8216B1DCh case    8:*/		if ( regs.CR[6].gt ) { return 0x8216B1E4;  }
		/* 8216B1DCh case    8:*/		return 0x8216B1E0;
	}
	return 0x8216B1E0;
} // Block from 8216B1BCh-8216B1E0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8216B1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B1E0);
		  /* 8216B1E0h */ case    0:  		/* mr R11, R25 */
		/* 8216B1E0h case    0:*/		regs.R11 = regs.R25;
		/* 8216B1E0h case    0:*/		return 0x8216B1E4;
	}
	return 0x8216B1E4;
} // Block from 8216B1E0h-8216B1E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B1E4);
		  /* 8216B1E4h */ case    0:  		/* rlwimi R8, R11, 0, 26, 31 */
		/* 8216B1E4h case    0:*/		cpu::op::rlwimi<0,0,26,31>(regs,&regs.R8,regs.R11);
		/* 8216B1E4h case    0:*/		return 0x8216B1E8;
		  /* 8216B1E8h */ case    1:  		/* stw R8, <#[R31]> */
		/* 8216B1E8h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B1E8h case    1:*/		return 0x8216B1EC;
	}
	return 0x8216B1EC;
} // Block from 8216B1E4h-8216B1ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B1EC);
		  /* 8216B1ECh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8216B1ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B1ECh case    0:*/		return 0x8216B1F0;
		  /* 8216B1F0h */ case    1:  		/* rlwinm R10, R11, 2, 30, 31 */
		/* 8216B1F0h case    1:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R10,regs.R11);
		/* 8216B1F0h case    1:*/		return 0x8216B1F4;
		  /* 8216B1F4h */ case    2:  		/* cmplwi CR6, R10, 2 */
		/* 8216B1F4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 8216B1F4h case    2:*/		return 0x8216B1F8;
		  /* 8216B1F8h */ case    3:  		/* bc 12, CR6_EQ, 520 */
		/* 8216B1F8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B1F8h case    3:*/		return 0x8216B1FC;
		  /* 8216B1FCh */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 8216B1FCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8216B1FCh case    4:*/		return 0x8216B200;
		  /* 8216B200h */ case    5:  		/* bc 12, CR6_EQ, 512 */
		/* 8216B200h case    5:*/		if ( regs.CR[6].eq ) { return 0x8216B400;  }
		/* 8216B200h case    5:*/		return 0x8216B204;
		  /* 8216B204h */ case    6:  		/* slw R10, R30, R21 */
		/* 8216B204h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R30,regs.R21);
		/* 8216B204h case    6:*/		return 0x8216B208;
		  /* 8216B208h */ case    7:  		/* li R9, 1024 */
		/* 8216B208h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x400);
		/* 8216B208h case    7:*/		return 0x8216B20C;
		  /* 8216B20Ch */ case    8:  		/* slw R8, R30, R20 */
		/* 8216B20Ch case    8:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R30,regs.R20);
		/* 8216B20Ch case    8:*/		return 0x8216B210;
		  /* 8216B210h */ case    9:  		/* rlwimi R9, R10, 5, 22, 26 */
		/* 8216B210h case    9:*/		cpu::op::rlwimi<0,5,22,26>(regs,&regs.R9,regs.R10);
		/* 8216B210h case    9:*/		return 0x8216B214;
		  /* 8216B214h */ case   10:  		/* rlwinm R10, R8, 0, 27, 31 */
		/* 8216B214h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R8);
		/* 8216B214h case   10:*/		return 0x8216B218;
		  /* 8216B218h */ case   11:  		/* rlwinm R8, R11, 0, 2, 31 */
		/* 8216B218h case   11:*/		cpu::op::rlwinm<0,0,2,31>(regs,&regs.R8,regs.R11);
		/* 8216B218h case   11:*/		return 0x8216B21C;
		  /* 8216B21Ch */ case   12:  		/* lwz R11, <#[R1 + 100]> */
		/* 8216B21Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8216B21Ch case   12:*/		return 0x8216B220;
		  /* 8216B220h */ case   13:  		/* or R10, R9, R10 */
		/* 8216B220h case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8216B220h case   13:*/		return 0x8216B224;
		  /* 8216B224h */ case   14:  		/* rlwinm. R9, R11, 0, 20, 20 */
		/* 8216B224h case   14:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R11);
		/* 8216B224h case   14:*/		return 0x8216B228;
		  /* 8216B228h */ case   15:  		/* rlwinm R10, R10, 20, 0, 11 */
		/* 8216B228h case   15:*/		cpu::op::rlwinm<0,20,0,11>(regs,&regs.R10,regs.R10);
		/* 8216B228h case   15:*/		return 0x8216B22C;
		  /* 8216B22Ch */ case   16:  		/* or R10, R10, R8 */
		/* 8216B22Ch case   16:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8216B22Ch case   16:*/		return 0x8216B230;
		  /* 8216B230h */ case   17:  		/* stw R10, <#[R31]> */
		/* 8216B230h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B230h case   17:*/		return 0x8216B234;
		  /* 8216B234h */ case   18:  		/* lwz R9, <#[R27]> */
		/* 8216B234h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B234h case   18:*/		return 0x8216B238;
		  /* 8216B238h */ case   19:  		/* rlwinm R9, R9, 20, 31, 31 */
		/* 8216B238h case   19:*/		cpu::op::rlwinm<0,20,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B238h case   19:*/		return 0x8216B23C;
		  /* 8216B23Ch */ case   20:  		/* slw R9, R30, R9 */
		/* 8216B23Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B23Ch case   20:*/		return 0x8216B240;
	}
	return 0x8216B240;
} // Block from 8216B1ECh-8216B240h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8216B240h
// Function '?ValidateExecCommon@@YAJTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PAUInstructionUsageLite@@PBT1@HPBUR500StuffLite@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B240);
		  /* 8216B240h */ case    0:  		/* rlwinm R9, R9, 18, 0, 13 */
		/* 8216B240h case    0:*/		cpu::op::rlwinm<0,18,0,13>(regs,&regs.R9,regs.R9);
		/* 8216B240h case    0:*/		return 0x8216B244;
		  /* 8216B244h */ case    1:  		/* or R9, R9, R10 */
		/* 8216B244h case    1:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B244h case    1:*/		return 0x8216B248;
		  /* 8216B248h */ case    2:  		/* rlwimi R9, R10, 0, 14, 11 */
		/* 8216B248h case    2:*/		cpu::op::rlwimi<0,0,14,11>(regs,&regs.R9,regs.R10);
		/* 8216B248h case    2:*/		return 0x8216B24C;
		  /* 8216B24Ch */ case    3:  		/* stw R9, <#[R31]> */
		/* 8216B24Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B24Ch case    3:*/		return 0x8216B250;
		  /* 8216B250h */ case    4:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8216B250h case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8216B250h case    4:*/		return 0x8216B254;
		  /* 8216B254h */ case    5:  		/* lwz R9, <#[R27]> */
		/* 8216B254h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B254h case    5:*/		return 0x8216B258;
		  /* 8216B258h */ case    6:  		/* rlwinm R9, R9, 21, 31, 31 */
		/* 8216B258h case    6:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B258h case    6:*/		return 0x8216B25C;
		  /* 8216B25Ch */ case    7:  		/* slw R9, R30, R9 */
		/* 8216B25Ch case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B25Ch case    7:*/		return 0x8216B260;
		  /* 8216B260h */ case    8:  		/* rlwinm R9, R9, 16, 0, 15 */
		/* 8216B260h case    8:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R9,regs.R9);
		/* 8216B260h case    8:*/		return 0x8216B264;
		  /* 8216B264h */ case    9:  		/* or R9, R9, R10 */
		/* 8216B264h case    9:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B264h case    9:*/		return 0x8216B268;
		  /* 8216B268h */ case   10:  		/* rlwimi R9, R10, 0, 16, 13 */
		/* 8216B268h case   10:*/		cpu::op::rlwimi<0,0,16,13>(regs,&regs.R9,regs.R10);
		/* 8216B268h case   10:*/		return 0x8216B26C;
		  /* 8216B26Ch */ case   11:  		/* stw R9, <#[R31]> */
		/* 8216B26Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B26Ch case   11:*/		return 0x8216B270;
		  /* 8216B270h */ case   12:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8216B270h case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8216B270h case   12:*/		return 0x8216B274;
		  /* 8216B274h */ case   13:  		/* lwz R9, <#[R27]> */
		/* 8216B274h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B274h case   13:*/		return 0x8216B278;
		  /* 8216B278h */ case   14:  		/* rlwinm R9, R9, 22, 31, 31 */
		/* 8216B278h case   14:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B278h case   14:*/		return 0x8216B27C;
		  /* 8216B27Ch */ case   15:  		/* slw R9, R30, R9 */
		/* 8216B27Ch case   15:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B27Ch case   15:*/		return 0x8216B280;
		  /* 8216B280h */ case   16:  		/* rlwinm R9, R9, 14, 0, 17 */
		/* 8216B280h case   16:*/		cpu::op::rlwinm<0,14,0,17>(regs,&regs.R9,regs.R9);
		/* 8216B280h case   16:*/		return 0x8216B284;
		  /* 8216B284h */ case   17:  		/* or R9, R9, R10 */
		/* 8216B284h case   17:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B284h case   17:*/		return 0x8216B288;
		  /* 8216B288h */ case   18:  		/* rlwimi R9, R10, 0, 18, 15 */
		/* 8216B288h case   18:*/		cpu::op::rlwimi<0,0,18,15>(regs,&regs.R9,regs.R10);
		/* 8216B288h case   18:*/		return 0x8216B28C;
		  /* 8216B28Ch */ case   19:  		/* stw R9, <#[R31]> */
		/* 8216B28Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B28Ch case   19:*/		return 0x8216B290;
		  /* 8216B290h */ case   20:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8216B290h case   20:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8216B290h case   20:*/		return 0x8216B294;
		  /* 8216B294h */ case   21:  		/* lwz R9, <#[R27]> */
		/* 8216B294h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B294h case   21:*/		return 0x8216B298;
		  /* 8216B298h */ case   22:  		/* rlwinm R9, R9, 23, 31, 31 */
		/* 8216B298h case   22:*/		cpu::op::rlwinm<0,23,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B298h case   22:*/		return 0x8216B29C;
		  /* 8216B29Ch */ case   23:  		/* slw R9, R30, R9 */
		/* 8216B29Ch case   23:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B29Ch case   23:*/		return 0x8216B2A0;
		  /* 8216B2A0h */ case   24:  		/* rlwinm R9, R9, 12, 0, 19 */
		/* 8216B2A0h case   24:*/		cpu::op::rlwinm<0,12,0,19>(regs,&regs.R9,regs.R9);
		/* 8216B2A0h case   24:*/		return 0x8216B2A4;
		  /* 8216B2A4h */ case   25:  		/* or R9, R9, R10 */
		/* 8216B2A4h case   25:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B2A4h case   25:*/		return 0x8216B2A8;
		  /* 8216B2A8h */ case   26:  		/* rlwimi R9, R10, 0, 20, 17 */
		/* 8216B2A8h case   26:*/		cpu::op::rlwimi<0,0,20,17>(regs,&regs.R9,regs.R10);
		/* 8216B2A8h case   26:*/		return 0x8216B2AC;
		  /* 8216B2ACh */ case   27:  		/* stw R9, <#[R31]> */
		/* 8216B2ACh case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B2ACh case   27:*/		return 0x8216B2B0;
		  /* 8216B2B0h */ case   28:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8216B2B0h case   28:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8216B2B0h case   28:*/		return 0x8216B2B4;
		  /* 8216B2B4h */ case   29:  		/* lwz R9, <#[R27]> */
		/* 8216B2B4h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B2B4h case   29:*/		return 0x8216B2B8;
		  /* 8216B2B8h */ case   30:  		/* rlwinm R9, R9, 24, 31, 31 */
		/* 8216B2B8h case   30:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B2B8h case   30:*/		return 0x8216B2BC;
		  /* 8216B2BCh */ case   31:  		/* slw R9, R30, R9 */
		/* 8216B2BCh case   31:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B2BCh case   31:*/		return 0x8216B2C0;
		  /* 8216B2C0h */ case   32:  		/* rlwinm R9, R9, 10, 0, 21 */
		/* 8216B2C0h case   32:*/		cpu::op::rlwinm<0,10,0,21>(regs,&regs.R9,regs.R9);
		/* 8216B2C0h case   32:*/		return 0x8216B2C4;
		  /* 8216B2C4h */ case   33:  		/* or R9, R9, R10 */
		/* 8216B2C4h case   33:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B2C4h case   33:*/		return 0x8216B2C8;
		  /* 8216B2C8h */ case   34:  		/* rlwimi R9, R10, 0, 22, 19 */
		/* 8216B2C8h case   34:*/		cpu::op::rlwimi<0,0,22,19>(regs,&regs.R9,regs.R10);
		/* 8216B2C8h case   34:*/		return 0x8216B2CC;
		  /* 8216B2CCh */ case   35:  		/* stw R9, <#[R31]> */
		/* 8216B2CCh case   35:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B2CCh case   35:*/		return 0x8216B2D0;
		  /* 8216B2D0h */ case   36:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8216B2D0h case   36:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8216B2D0h case   36:*/		return 0x8216B2D4;
		  /* 8216B2D4h */ case   37:  		/* lwz R9, <#[R27]> */
		/* 8216B2D4h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B2D4h case   37:*/		return 0x8216B2D8;
		  /* 8216B2D8h */ case   38:  		/* rlwinm R9, R9, 25, 31, 31 */
		/* 8216B2D8h case   38:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B2D8h case   38:*/		return 0x8216B2DC;
		  /* 8216B2DCh */ case   39:  		/* slw R9, R30, R9 */
		/* 8216B2DCh case   39:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B2DCh case   39:*/		return 0x8216B2E0;
		  /* 8216B2E0h */ case   40:  		/* rlwinm R9, R9, 8, 0, 23 */
		/* 8216B2E0h case   40:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R9,regs.R9);
		/* 8216B2E0h case   40:*/		return 0x8216B2E4;
		  /* 8216B2E4h */ case   41:  		/* or R9, R9, R10 */
		/* 8216B2E4h case   41:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B2E4h case   41:*/		return 0x8216B2E8;
		  /* 8216B2E8h */ case   42:  		/* rlwimi R9, R10, 0, 24, 21 */
		/* 8216B2E8h case   42:*/		cpu::op::rlwimi<0,0,24,21>(regs,&regs.R9,regs.R10);
		/* 8216B2E8h case   42:*/		return 0x8216B2EC;
		  /* 8216B2ECh */ case   43:  		/* stw R9, <#[R31]> */
		/* 8216B2ECh case   43:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B2ECh case   43:*/		return 0x8216B2F0;
		  /* 8216B2F0h */ case   44:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 8216B2F0h case   44:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 8216B2F0h case   44:*/		return 0x8216B2F4;
		  /* 8216B2F4h */ case   45:  		/* lwz R9, <#[R27]> */
		/* 8216B2F4h case   45:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B2F4h case   45:*/		return 0x8216B2F8;
		  /* 8216B2F8h */ case   46:  		/* rlwinm R9, R9, 26, 31, 31 */
		/* 8216B2F8h case   46:*/		cpu::op::rlwinm<0,26,31,31>(regs,&regs.R9,regs.R9);
		/* 8216B2F8h case   46:*/		return 0x8216B2FC;
		  /* 8216B2FCh */ case   47:  		/* slw R9, R30, R9 */
		/* 8216B2FCh case   47:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 8216B2FCh case   47:*/		return 0x8216B300;
		  /* 8216B300h */ case   48:  		/* rlwinm R9, R9, 6, 0, 25 */
		/* 8216B300h case   48:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R9,regs.R9);
		/* 8216B300h case   48:*/		return 0x8216B304;
		  /* 8216B304h */ case   49:  		/* or R9, R9, R10 */
		/* 8216B304h case   49:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8216B304h case   49:*/		return 0x8216B308;
		  /* 8216B308h */ case   50:  		/* rlwimi R9, R10, 0, 26, 23 */
		/* 8216B308h case   50:*/		cpu::op::rlwimi<0,0,26,23>(regs,&regs.R9,regs.R10);
		/* 8216B308h case   50:*/		return 0x8216B30C;
		  /* 8216B30Ch */ case   51:  		/* stw R9, <#[R31]> */
		/* 8216B30Ch case   51:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8216B30Ch case   51:*/		return 0x8216B310;
		  /* 8216B310h */ case   52:  		/* bc 4, CR0_EQ, 240 */
		/* 8216B310h case   52:*/		if ( !regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B310h case   52:*/		return 0x8216B314;
		  /* 8216B314h */ case   53:  		/* lwz R8, <#[R27]> */
		/* 8216B314h case   53:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B314h case   53:*/		return 0x8216B318;
		  /* 8216B318h */ case   54:  		/* lwz R10, <#[R1 + 96]> */
		/* 8216B318h case   54:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8216B318h case   54:*/		return 0x8216B31C;
		  /* 8216B31Ch */ case   55:  		/* rlwinm. R9, R8, 0, 23, 23 */
		/* 8216B31Ch case   55:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R8);
		/* 8216B31Ch case   55:*/		return 0x8216B320;
		  /* 8216B320h */ case   56:  		/* bc 12, CR0_EQ, 96 */
		/* 8216B320h case   56:*/		if ( regs.CR[0].eq ) { return 0x8216B380;  }
		/* 8216B320h case   56:*/		return 0x8216B324;
		  /* 8216B324h */ case   57:  		/* rlwinm R9, R11, 20, 28, 31 */
		/* 8216B324h case   57:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R9,regs.R11);
		/* 8216B324h case   57:*/		return 0x8216B328;
		  /* 8216B328h */ case   58:  		/* cmplwi CR6, R9, 15 */
		/* 8216B328h case   58:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000F);
		/* 8216B328h case   58:*/		return 0x8216B32C;
		  /* 8216B32Ch */ case   59:  		/* bc 12, CR6_GT, 60 */
		/* 8216B32Ch case   59:*/		if ( regs.CR[6].gt ) { return 0x8216B368;  }
		/* 8216B32Ch case   59:*/		return 0x8216B330;
		  /* 8216B330h */ case   60:  		/* lis R12, -32252 */
		/* 8216B330h case   60:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 8216B330h case   60:*/		return 0x8216B334;
		  /* 8216B334h */ case   61:  		/* addi R12, R12, -17272 */
		/* 8216B334h case   61:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBC88);
		/* 8216B334h case   61:*/		return 0x8216B338;
		  /* 8216B338h */ case   62:  		/* lbzx R0, <#[R12 + R9]> */
		/* 8216B338h case   62:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R9 + 0x00000000) );
		/* 8216B338h case   62:*/		return 0x8216B33C;
		  /* 8216B33Ch */ case   63:  		/* lis R12, -32233 */
		/* 8216B33Ch case   63:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8217);
		/* 8216B33Ch case   63:*/		return 0x8216B340;
		  /* 8216B340h */ case   64:  		/* ori R0, R0, 0 */
		/* 8216B340h case   64:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8216B340h case   64:*/		return 0x8216B344;
		  /* 8216B344h */ case   65:  		/* addi R12, R12, -19624 */
		/* 8216B344h case   65:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFB358);
		/* 8216B344h case   65:*/		return 0x8216B348;
		  /* 8216B348h */ case   66:  		/* ori R0, R0, 0 */
		/* 8216B348h case   66:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8216B348h case   66:*/		return 0x8216B34C;
		  /* 8216B34Ch */ case   67:  		/* add R12, R12, R0 */
		/* 8216B34Ch case   67:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 8216B34Ch case   67:*/		return 0x8216B350;
		  /* 8216B350h */ case   68:  		/* mtspr CTR, R12 */
		/* 8216B350h case   68:*/		regs.CTR = regs.R12;
		/* 8216B350h case   68:*/		return 0x8216B354;
		  /* 8216B354h */ case   69:  		/* bcctr 20, CR0_LT */
		/* 8216B354h case   69:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8216B354h case   69:*/		return 0x8216B358;
		  /* 8216B358h */ case   70:  		/* rlwinm R9, R10, 18, 31, 31 */
		/* 8216B358h case   70:*/		cpu::op::rlwinm<0,18,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B358h case   70:*/		return 0x8216B35C;
		  /* 8216B35Ch */ case   71:  		/* b 16 */
		/* 8216B35Ch case   71:*/		return 0x8216B36C;
		/* 8216B35Ch case   71:*/		return 0x8216B360;
		  /* 8216B360h */ case   72:  		/* rlwinm R9, R10, 11, 31, 31 */
		/* 8216B360h case   72:*/		cpu::op::rlwinm<0,11,31,31>(regs,&regs.R9,regs.R10);
		/* 8216B360h case   72:*/		return 0x8216B364;
		  /* 8216B364h */ case   73:  		/* b 8 */
		/* 8216B364h case   73:*/		return 0x8216B36C;
		/* 8216B364h case   73:*/		return 0x8216B368;
	}
	return 0x8216B368;
} // Block from 8216B240h-8216B368h (74 instructions)

//////////////////////////////////////////////////////
// Block at 8216B368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B368);
		  /* 8216B368h */ case    0:  		/* mr R9, R30 */
		/* 8216B368h case    0:*/		regs.R9 = regs.R30;
		/* 8216B368h case    0:*/		return 0x8216B36C;
	}
	return 0x8216B36C;
} // Block from 8216B368h-8216B36Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8216B36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B36C);
		  /* 8216B36Ch */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 8216B36Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8216B36Ch case    0:*/		return 0x8216B370;
		  /* 8216B370h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8216B370h case    1:*/		if ( regs.CR[6].eq ) { return 0x8216B380;  }
		/* 8216B370h case    1:*/		return 0x8216B374;
		  /* 8216B374h */ case    2:  		/* rlwinm R9, R8, 0, 24, 22 */
		/* 8216B374h case    2:*/		cpu::op::rlwinm<0,0,24,22>(regs,&regs.R9,regs.R8);
		/* 8216B374h case    2:*/		return 0x8216B378;
		  /* 8216B378h */ case    3:  		/* rlwinm R9, R9, 0, 20, 18 */
		/* 8216B378h case    3:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R9,regs.R9);
		/* 8216B378h case    3:*/		return 0x8216B37C;
		  /* 8216B37Ch */ case    4:  		/* stw R9, <#[R27]> */
		/* 8216B37Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8216B37Ch case    4:*/		return 0x8216B380;
	}
	return 0x8216B380;
} // Block from 8216B36Ch-8216B380h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8216B380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B380);
		  /* 8216B380h */ case    0:  		/* rlwinm R29, R11, 20, 28, 31 */
		/* 8216B380h case    0:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R29,regs.R11);
		/* 8216B380h case    0:*/		return 0x8216B384;
		  /* 8216B384h */ case    1:  		/* cmplwi CR6, R29, 15 */
		/* 8216B384h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 8216B384h case    1:*/		return 0x8216B388;
		  /* 8216B388h */ case    2:  		/* bc 12, CR6_GT, 120 */
		/* 8216B388h case    2:*/		if ( regs.CR[6].gt ) { return 0x8216B400;  }
		/* 8216B388h case    2:*/		return 0x8216B38C;
		  /* 8216B38Ch */ case    3:  		/* lis R12, -32252 */
		/* 8216B38Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 8216B38Ch case    3:*/		return 0x8216B390;
	}
	return 0x8216B390;
} // Block from 8216B380h-8216B390h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8216B390h
// Function '?ValidateLoopStart@@YAJTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PBUInstructionUsageLite@@PBT1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B390);
		  /* 8216B390h */ case    0:  		/* addi R12, R12, -17288 */
		/* 8216B390h case    0:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFBC78);
		/* 8216B390h case    0:*/		return 0x8216B394;
		  /* 8216B394h */ case    1:  		/* lbzx R0, <#[R12 + R29]> */
		/* 8216B394h case    1:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R29 + 0x00000000) );
		/* 8216B394h case    1:*/		return 0x8216B398;
		  /* 8216B398h */ case    2:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 8216B398h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 8216B398h case    2:*/		return 0x8216B39C;
		  /* 8216B39Ch */ case    3:  		/* lis R12, -32233 */
		/* 8216B39Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8217);
		/* 8216B39Ch case    3:*/		return 0x8216B3A0;
		  /* 8216B3A0h */ case    4:  		/* ori R0, R0, 0 */
		/* 8216B3A0h case    4:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 8216B3A0h case    4:*/		return 0x8216B3A4;
		  /* 8216B3A4h */ case    5:  		/* addi R12, R12, -19532 */
		/* 8216B3A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFB3B4);
		/* 8216B3A4h case    5:*/		return 0x8216B3A8;
		  /* 8216B3A8h */ case    6:  		/* add R12, R12, R0 */
		/* 8216B3A8h case    6:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 8216B3A8h case    6:*/		return 0x8216B3AC;
		  /* 8216B3ACh */ case    7:  		/* mtspr CTR, R12 */
		/* 8216B3ACh case    7:*/		regs.CTR = regs.R12;
		/* 8216B3ACh case    7:*/		return 0x8216B3B0;
		  /* 8216B3B0h */ case    8:  		/* bcctr 20, CR0_LT */
		/* 8216B3B0h case    8:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 8216B3B0h case    8:*/		return 0x8216B3B4;
		  /* 8216B3B4h */ case    9:  		/* addi R7, R1, 104 */
		/* 8216B3B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x68);
		/* 8216B3B4h case    9:*/		return 0x8216B3B8;
		  /* 8216B3B8h */ case   10:  		/* std R3, <#[R1 + 96]> */
		/* 8216B3B8h case   10:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8216B3B8h case   10:*/		return 0x8216B3BC;
		  /* 8216B3BCh */ case   11:  		/* addi R10, R1, 104 */
		/* 8216B3BCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 8216B3BCh case   11:*/		return 0x8216B3C0;
		  /* 8216B3C0h */ case   12:  		/* addi R9, R1, 96 */
		/* 8216B3C0h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8216B3C0h case   12:*/		return 0x8216B3C4;
		  /* 8216B3C4h */ case   13:  		/* addi R8, R10, 8 */
		/* 8216B3C4h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x8);
		/* 8216B3C4h case   13:*/		return 0x8216B3C8;
		  /* 8216B3C8h */ case   14:  		/* std R25, <#[R7]> */
		/* 8216B3C8h case   14:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R7 + 0x00000000) );
		/* 8216B3C8h case   14:*/		return 0x8216B3CC;
		  /* 8216B3CCh */ case   15:  		/* lwz R7, <#[R1 + 108]> */
		/* 8216B3CCh case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000006C) );
		/* 8216B3CCh case   15:*/		return 0x8216B3D0;
		  /* 8216B3D0h */ case   16:  		/* rlwimi R11, R7, 0, 21, 15 */
		/* 8216B3D0h case   16:*/		cpu::op::rlwimi<0,0,21,15>(regs,&regs.R11,regs.R7);
		/* 8216B3D0h case   16:*/		return 0x8216B3D4;
		  /* 8216B3D4h */ case   17:  		/* stw R11, <#[R1 + 108]> */
		/* 8216B3D4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8216B3D4h case   17:*/		return 0x8216B3D8;
		  /* 8216B3D8h */ case   18:  		/* lbz R11, <#[R10]> */
		/* 8216B3D8h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216B3D8h case   18:*/		return 0x8216B3DC;
		  /* 8216B3DCh */ case   19:  		/* lbz R7, <#[R9]> */
		/* 8216B3DCh case   19:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B3DCh case   19:*/		return 0x8216B3E0;
		  /* 8216B3E0h */ case   20:  		/* subf. R11, R7, R11 */
		/* 8216B3E0h case   20:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8216B3E0h case   20:*/		return 0x8216B3E4;
		  /* 8216B3E4h */ case   21:  		/* bc 4, CR0_EQ, 20 */
		/* 8216B3E4h case   21:*/		if ( !regs.CR[0].eq ) { return 0x8216B3F8;  }
		/* 8216B3E4h case   21:*/		return 0x8216B3E8;
		  /* 8216B3E8h */ case   22:  		/* addi R10, R10, 1 */
		/* 8216B3E8h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216B3E8h case   22:*/		return 0x8216B3EC;
		  /* 8216B3ECh */ case   23:  		/* addi R9, R9, 1 */
		/* 8216B3ECh case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216B3ECh case   23:*/		return 0x8216B3F0;
		  /* 8216B3F0h */ case   24:  		/* cmpw CR6, R10, R8 */
		/* 8216B3F0h case   24:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 8216B3F0h case   24:*/		return 0x8216B3F4;
		  /* 8216B3F4h */ case   25:  		/* bc 4, CR6_EQ, -28 */
		/* 8216B3F4h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8216B3D8;  }
		/* 8216B3F4h case   25:*/		return 0x8216B3F8;
	}
	return 0x8216B3F8;
} // Block from 8216B390h-8216B3F8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8216B3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B3F8);
		  /* 8216B3F8h */ case    0:  		/* cmpwi CR0, R11, 0 */
		/* 8216B3F8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8216B3F8h case    0:*/		return 0x8216B3FC;
		  /* 8216B3FCh */ case    1:  		/* bc 12, CR0_EQ, 516 */
		/* 8216B3FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8216B600;  }
		/* 8216B3FCh case    1:*/		return 0x8216B400;
	}
	return 0x8216B400;
} // Block from 8216B3F8h-8216B400h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B400);
		  /* 8216B400h */ case    0:  		/* lis R3, -32768 */
		/* 8216B400h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8216B400h case    0:*/		return 0x8216B404;
		  /* 8216B404h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8216B404h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8216B404h case    1:*/		return 0x8216B408;
	}
	return 0x8216B408;
} // Block from 8216B400h-8216B408h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8216B408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B408);
		  /* 8216B408h */ case    0:  		/* addi R1, R1, 288 */
		/* 8216B408h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8216B408h case    0:*/		return 0x8216B40C;
		  /* 8216B40Ch */ case    1:  		/* b -893336 */
		/* 8216B40Ch case    1:*/		return 0x82091274;
		/* 8216B40Ch case    1:*/		return 0x8216B410;
		  /* 8216B410h */ case    2:  		/* addi R9, R1, 80 */
		/* 8216B410h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8216B410h case    2:*/		return 0x8216B414;
		  /* 8216B414h */ case    3:  		/* std R3, <#[R1 + 96]> */
		/* 8216B414h case    3:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8216B414h case    3:*/		return 0x8216B418;
		  /* 8216B418h */ case    4:  		/* mr R6, R10 */
		/* 8216B418h case    4:*/		regs.R6 = regs.R10;
		/* 8216B418h case    4:*/		return 0x8216B41C;
		  /* 8216B41Ch */ case    5:  		/* mr R5, R11 */
		/* 8216B41Ch case    5:*/		regs.R5 = regs.R11;
		/* 8216B41Ch case    5:*/		return 0x8216B420;
		  /* 8216B420h */ case    6:  		/* mr R4, R10 */
		/* 8216B420h case    6:*/		regs.R4 = regs.R10;
		/* 8216B420h case    6:*/		return 0x8216B424;
		  /* 8216B424h */ case    7:  		/* mr R19, R11 */
		/* 8216B424h case    7:*/		regs.R19 = regs.R11;
		/* 8216B424h case    7:*/		return 0x8216B428;
		  /* 8216B428h */ case    8:  		/* std R25, <#[R9]> */
		/* 8216B428h case    8:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B428h case    8:*/		return 0x8216B42C;
		  /* 8216B42Ch */ case    9:  		/* addi R9, R1, 80 */
		/* 8216B42Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8216B42Ch case    9:*/		return 0x8216B430;
		  /* 8216B430h */ case   10:  		/* addi R8, R1, 96 */
		/* 8216B430h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8216B430h case   10:*/		return 0x8216B434;
		  /* 8216B434h */ case   11:  		/* addi R7, R9, 8 */
		/* 8216B434h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R9,0x8);
		/* 8216B434h case   11:*/		return 0x8216B438;
		  /* 8216B438h */ case   12:  		/* lwz R17, <#[R1 + 80]> */
		/* 8216B438h case   12:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000050) );
		/* 8216B438h case   12:*/		return 0x8216B43C;
		  /* 8216B43Ch */ case   13:  		/* lwz R18, <#[R1 + 84]> */
		/* 8216B43Ch case   13:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000054) );
		/* 8216B43Ch case   13:*/		return 0x8216B440;
		  /* 8216B440h */ case   14:  		/* rlwimi R5, R18, 0, 21, 19 */
		/* 8216B440h case   14:*/		cpu::op::rlwimi<0,0,21,19>(regs,&regs.R5,regs.R18);
		/* 8216B440h case   14:*/		return 0x8216B444;
		  /* 8216B444h */ case   15:  		/* rlwimi R6, R17, 0, 0, 16 */
		/* 8216B444h case   15:*/		cpu::op::rlwimi<0,0,0,16>(regs,&regs.R6,regs.R17);
		/* 8216B444h case   15:*/		return 0x8216B448;
		  /* 8216B448h */ case   16:  		/* rlwimi R19, R5, 0, 23, 15 */
		/* 8216B448h case   16:*/		cpu::op::rlwimi<0,0,23,15>(regs,&regs.R19,regs.R5);
		/* 8216B448h case   16:*/		return 0x8216B44C;
		  /* 8216B44Ch */ case   17:  		/* rlwimi R4, R6, 0, 16, 3 */
		/* 8216B44Ch case   17:*/		cpu::op::rlwimi<0,0,16,3>(regs,&regs.R4,regs.R6);
		/* 8216B44Ch case   17:*/		return 0x8216B450;
		  /* 8216B450h */ case   18:  		/* rlwimi R19, R5, 0, 20, 21 */
		/* 8216B450h case   18:*/		cpu::op::rlwimi<0,0,20,21>(regs,&regs.R19,regs.R5);
		/* 8216B450h case   18:*/		return 0x8216B454;
		  /* 8216B454h */ case   19:  		/* rlwimi R10, R4, 0, 17, 31 */
		/* 8216B454h case   19:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R10,regs.R4);
		/* 8216B454h case   19:*/		return 0x8216B458;
		  /* 8216B458h */ case   20:  		/* rlwimi R11, R19, 0, 0, 29 */
		/* 8216B458h case   20:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R11,regs.R19);
		/* 8216B458h case   20:*/		return 0x8216B45C;
		  /* 8216B45Ch */ case   21:  		/* rlwimi R10, R4, 0, 4, 15 */
		/* 8216B45Ch case   21:*/		cpu::op::rlwimi<0,0,4,15>(regs,&regs.R10,regs.R4);
		/* 8216B45Ch case   21:*/		return 0x8216B460;
		  /* 8216B460h */ case   22:  		/* stw R11, <#[R1 + 84]> */
		/* 8216B460h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8216B460h case   22:*/		return 0x8216B464;
		  /* 8216B464h */ case   23:  		/* stw R10, <#[R1 + 80]> */
		/* 8216B464h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8216B464h case   23:*/		return 0x8216B468;
		  /* 8216B468h */ case   24:  		/* lbz R11, <#[R9]> */
		/* 8216B468h case   24:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B468h case   24:*/		return 0x8216B46C;
		  /* 8216B46Ch */ case   25:  		/* lbz R10, <#[R8]> */
		/* 8216B46Ch case   25:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8216B46Ch case   25:*/		return 0x8216B470;
		  /* 8216B470h */ case   26:  		/* subf. R11, R10, R11 */
		/* 8216B470h case   26:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216B470h case   26:*/		return 0x8216B474;
		  /* 8216B474h */ case   27:  		/* bc 4, CR0_EQ, 20 */
		/* 8216B474h case   27:*/		if ( !regs.CR[0].eq ) { return 0x8216B488;  }
		/* 8216B474h case   27:*/		return 0x8216B478;
		  /* 8216B478h */ case   28:  		/* addi R9, R9, 1 */
		/* 8216B478h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216B478h case   28:*/		return 0x8216B47C;
		  /* 8216B47Ch */ case   29:  		/* addi R8, R8, 1 */
		/* 8216B47Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216B47Ch case   29:*/		return 0x8216B480;
		  /* 8216B480h */ case   30:  		/* cmpw CR6, R9, R7 */
		/* 8216B480h case   30:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R7);
		/* 8216B480h case   30:*/		return 0x8216B484;
		  /* 8216B484h */ case   31:  		/* bc 4, CR6_EQ, -28 */
		/* 8216B484h case   31:*/		if ( !regs.CR[6].eq ) { return 0x8216B468;  }
		/* 8216B484h case   31:*/		return 0x8216B488;
	}
	return 0x8216B488;
} // Block from 8216B408h-8216B488h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8216B488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B488);
		  /* 8216B488h */ case    0:  		/* cmpwi CR0, R11, 0 */
		/* 8216B488h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8216B488h case    0:*/		return 0x8216B48C;
		  /* 8216B48Ch */ case    1:  		/* bc 4, CR0_EQ, -140 */
		/* 8216B48Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8216B400;  }
		/* 8216B48Ch case    1:*/		return 0x8216B490;
		  /* 8216B490h */ case    2:  		/* mr R7, R23 */
		/* 8216B490h case    2:*/		regs.R7 = regs.R23;
		/* 8216B490h case    2:*/		return 0x8216B494;
		  /* 8216B494h */ case    3:  		/* mr R6, R22 */
		/* 8216B494h case    3:*/		regs.R6 = regs.R22;
		/* 8216B494h case    3:*/		return 0x8216B498;
		  /* 8216B498h */ case    4:  		/* mr R5, R26 */
		/* 8216B498h case    4:*/		regs.R5 = regs.R26;
		/* 8216B498h case    4:*/		return 0x8216B49C;
		  /* 8216B49Ch */ case    5:  		/* mr R4, R28 */
		/* 8216B49Ch case    5:*/		regs.R4 = regs.R28;
		/* 8216B49Ch case    5:*/		return 0x8216B4A0;
		  /* 8216B4A0h */ case    6:  		/* bl -3280 */
		/* 8216B4A0h case    6:*/		regs.LR = 0x8216B4A4; return 0x8216A7D0;
		/* 8216B4A0h case    6:*/		return 0x8216B4A4;
		  /* 8216B4A4h */ case    7:  		/* b 340 */
		/* 8216B4A4h case    7:*/		return 0x8216B5F8;
		/* 8216B4A4h case    7:*/		return 0x8216B4A8;
		  /* 8216B4A8h */ case    8:  		/* addi R9, R1, 88 */
		/* 8216B4A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8216B4A8h case    8:*/		return 0x8216B4AC;
		  /* 8216B4ACh */ case    9:  		/* std R3, <#[R1 + 96]> */
		/* 8216B4ACh case    9:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8216B4ACh case    9:*/		return 0x8216B4B0;
		  /* 8216B4B0h */ case   10:  		/* mr R6, R10 */
		/* 8216B4B0h case   10:*/		regs.R6 = regs.R10;
		/* 8216B4B0h case   10:*/		return 0x8216B4B4;
		  /* 8216B4B4h */ case   11:  		/* mr R5, R11 */
		/* 8216B4B4h case   11:*/		regs.R5 = regs.R11;
		/* 8216B4B4h case   11:*/		return 0x8216B4B8;
		  /* 8216B4B8h */ case   12:  		/* mr R4, R10 */
		/* 8216B4B8h case   12:*/		regs.R4 = regs.R10;
		/* 8216B4B8h case   12:*/		return 0x8216B4BC;
		  /* 8216B4BCh */ case   13:  		/* mr R19, R11 */
		/* 8216B4BCh case   13:*/		regs.R19 = regs.R11;
		/* 8216B4BCh case   13:*/		return 0x8216B4C0;
	}
	return 0x8216B4C0;
} // Block from 8216B488h-8216B4C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8216B4C0h
// Function '?ValidateLoopEnd@@YAJTGPUFLOW_INSTRUCTION@@PAUTODO_LIST@@PBUInstructionUsageLite@@PBT1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8216B4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8216B4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8216B4C0);
		  /* 8216B4C0h */ case    0:  		/* std R25, <#[R9]> */
		/* 8216B4C0h case    0:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B4C0h case    0:*/		return 0x8216B4C4;
		  /* 8216B4C4h */ case    1:  		/* mr R18, R10 */
		/* 8216B4C4h case    1:*/		regs.R18 = regs.R10;
		/* 8216B4C4h case    1:*/		return 0x8216B4C8;
		  /* 8216B4C8h */ case    2:  		/* mr R17, R11 */
		/* 8216B4C8h case    2:*/		regs.R17 = regs.R11;
		/* 8216B4C8h case    2:*/		return 0x8216B4CC;
		  /* 8216B4CCh */ case    3:  		/* addi R9, R1, 88 */
		/* 8216B4CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8216B4CCh case    3:*/		return 0x8216B4D0;
		  /* 8216B4D0h */ case    4:  		/* addi R8, R1, 96 */
		/* 8216B4D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8216B4D0h case    4:*/		return 0x8216B4D4;
		  /* 8216B4D4h */ case    5:  		/* addi R7, R9, 8 */
		/* 8216B4D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R9,0x8);
		/* 8216B4D4h case    5:*/		return 0x8216B4D8;
		  /* 8216B4D8h */ case    6:  		/* lwz R15, <#[R1 + 88]> */
		/* 8216B4D8h case    6:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000058) );
		/* 8216B4D8h case    6:*/		return 0x8216B4DC;
		  /* 8216B4DCh */ case    7:  		/* lwz R16, <#[R1 + 92]> */
		/* 8216B4DCh case    7:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x0000005C) );
		/* 8216B4DCh case    7:*/		return 0x8216B4E0;
		  /* 8216B4E0h */ case    8:  		/* rlwimi R5, R16, 0, 21, 19 */
		/* 8216B4E0h case    8:*/		cpu::op::rlwimi<0,0,21,19>(regs,&regs.R5,regs.R16);
		/* 8216B4E0h case    8:*/		return 0x8216B4E4;
		  /* 8216B4E4h */ case    9:  		/* rlwimi R6, R15, 0, 0, 19 */
		/* 8216B4E4h case    9:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R6,regs.R15);
		/* 8216B4E4h case    9:*/		return 0x8216B4E8;
		  /* 8216B4E8h */ case   10:  		/* rlwimi R19, R5, 0, 22, 20 */
		/* 8216B4E8h case   10:*/		cpu::op::rlwimi<0,0,22,20>(regs,&regs.R19,regs.R5);
		/* 8216B4E8h case   10:*/		return 0x8216B4EC;
		  /* 8216B4ECh */ case   11:  		/* rlwimi R4, R6, 0, 20, 16 */
		/* 8216B4ECh case   11:*/		cpu::op::rlwimi<0,0,20,16>(regs,&regs.R4,regs.R6);
		/* 8216B4ECh case   11:*/		return 0x8216B4F0;
		  /* 8216B4F0h */ case   12:  		/* rlwimi R17, R19, 0, 23, 15 */
		/* 8216B4F0h case   12:*/		cpu::op::rlwimi<0,0,23,15>(regs,&regs.R17,regs.R19);
		/* 8216B4F0h case   12:*/		return 0x8216B4F4;
		  /* 8216B4F4h */ case   13:  		/* rlwimi R18, R4, 0, 16, 3 */
		/* 8216B4F4h case   13:*/		cpu::op::rlwimi<0,0,16,3>(regs,&regs.R18,regs.R4);
		/* 8216B4F4h case   13:*/		return 0x8216B4F8;
		  /* 8216B4F8h */ case   14:  		/* rlwimi R17, R19, 0, 20, 21 */
		/* 8216B4F8h case   14:*/		cpu::op::rlwimi<0,0,20,21>(regs,&regs.R17,regs.R19);
		/* 8216B4F8h case   14:*/		return 0x8216B4FC;
		  /* 8216B4FCh */ case   15:  		/* rlwimi R10, R18, 0, 17, 31 */
		/* 8216B4FCh case   15:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R10,regs.R18);
		/* 8216B4FCh case   15:*/		return 0x8216B500;
		  /* 8216B500h */ case   16:  		/* rlwimi R11, R17, 0, 0, 29 */
		/* 8216B500h case   16:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R11,regs.R17);
		/* 8216B500h case   16:*/		return 0x8216B504;
		  /* 8216B504h */ case   17:  		/* rlwimi R10, R18, 0, 4, 15 */
		/* 8216B504h case   17:*/		cpu::op::rlwimi<0,0,4,15>(regs,&regs.R10,regs.R18);
		/* 8216B504h case   17:*/		return 0x8216B508;
		  /* 8216B508h */ case   18:  		/* stw R11, <#[R1 + 92]> */
		/* 8216B508h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8216B508h case   18:*/		return 0x8216B50C;
		  /* 8216B50Ch */ case   19:  		/* stw R10, <#[R1 + 88]> */
		/* 8216B50Ch case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8216B50Ch case   19:*/		return 0x8216B510;
		  /* 8216B510h */ case   20:  		/* lbz R11, <#[R9]> */
		/* 8216B510h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B510h case   20:*/		return 0x8216B514;
		  /* 8216B514h */ case   21:  		/* lbz R10, <#[R8]> */
		/* 8216B514h case   21:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8216B514h case   21:*/		return 0x8216B518;
		  /* 8216B518h */ case   22:  		/* subf. R11, R10, R11 */
		/* 8216B518h case   22:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8216B518h case   22:*/		return 0x8216B51C;
		  /* 8216B51Ch */ case   23:  		/* bc 4, CR0_EQ, -148 */
		/* 8216B51Ch case   23:*/		if ( !regs.CR[0].eq ) { return 0x8216B488;  }
		/* 8216B51Ch case   23:*/		return 0x8216B520;
		  /* 8216B520h */ case   24:  		/* addi R9, R9, 1 */
		/* 8216B520h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216B520h case   24:*/		return 0x8216B524;
		  /* 8216B524h */ case   25:  		/* addi R8, R8, 1 */
		/* 8216B524h case   25:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8216B524h case   25:*/		return 0x8216B528;
		  /* 8216B528h */ case   26:  		/* cmpw CR6, R9, R7 */
		/* 8216B528h case   26:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R7);
		/* 8216B528h case   26:*/		return 0x8216B52C;
		  /* 8216B52Ch */ case   27:  		/* bc 4, CR6_EQ, -28 */
		/* 8216B52Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x8216B510;  }
		/* 8216B52Ch case   27:*/		return 0x8216B530;
		  /* 8216B530h */ case   28:  		/* b -168 */
		/* 8216B530h case   28:*/		return 0x8216B488;
		/* 8216B530h case   28:*/		return 0x8216B534;
		  /* 8216B534h */ case   29:  		/* mr R6, R24 */
		/* 8216B534h case   29:*/		regs.R6 = regs.R24;
		/* 8216B534h case   29:*/		return 0x8216B538;
		  /* 8216B538h */ case   30:  		/* mr R5, R26 */
		/* 8216B538h case   30:*/		regs.R5 = regs.R26;
		/* 8216B538h case   30:*/		return 0x8216B53C;
		  /* 8216B53Ch */ case   31:  		/* mr R4, R28 */
		/* 8216B53Ch case   31:*/		regs.R4 = regs.R28;
		/* 8216B53Ch case   31:*/		return 0x8216B540;
		  /* 8216B540h */ case   32:  		/* bl -3104 */
		/* 8216B540h case   32:*/		regs.LR = 0x8216B544; return 0x8216A920;
		/* 8216B540h case   32:*/		return 0x8216B544;
		  /* 8216B544h */ case   33:  		/* b 180 */
		/* 8216B544h case   33:*/		return 0x8216B5F8;
		/* 8216B544h case   33:*/		return 0x8216B548;
		  /* 8216B548h */ case   34:  		/* mr R6, R24 */
		/* 8216B548h case   34:*/		regs.R6 = regs.R24;
		/* 8216B548h case   34:*/		return 0x8216B54C;
		  /* 8216B54Ch */ case   35:  		/* mr R5, R26 */
		/* 8216B54Ch case   35:*/		regs.R5 = regs.R26;
		/* 8216B54Ch case   35:*/		return 0x8216B550;
		  /* 8216B550h */ case   36:  		/* mr R4, R28 */
		/* 8216B550h case   36:*/		regs.R4 = regs.R28;
		/* 8216B550h case   36:*/		return 0x8216B554;
		  /* 8216B554h */ case   37:  		/* bl -2820 */
		/* 8216B554h case   37:*/		regs.LR = 0x8216B558; return 0x8216AA50;
		/* 8216B554h case   37:*/		return 0x8216B558;
		  /* 8216B558h */ case   38:  		/* b 160 */
		/* 8216B558h case   38:*/		return 0x8216B5F8;
		/* 8216B558h case   38:*/		return 0x8216B55C;
		  /* 8216B55Ch */ case   39:  		/* mr R5, R26 */
		/* 8216B55Ch case   39:*/		regs.R5 = regs.R26;
		/* 8216B55Ch case   39:*/		return 0x8216B560;
		  /* 8216B560h */ case   40:  		/* mr R4, R28 */
		/* 8216B560h case   40:*/		regs.R4 = regs.R28;
		/* 8216B560h case   40:*/		return 0x8216B564;
		  /* 8216B564h */ case   41:  		/* bl -2500 */
		/* 8216B564h case   41:*/		regs.LR = 0x8216B568; return 0x8216ABA0;
		/* 8216B564h case   41:*/		return 0x8216B568;
		  /* 8216B568h */ case   42:  		/* b 144 */
		/* 8216B568h case   42:*/		return 0x8216B5F8;
		/* 8216B568h case   42:*/		return 0x8216B56C;
		  /* 8216B56Ch */ case   43:  		/* mr R4, R28 */
		/* 8216B56Ch case   43:*/		regs.R4 = regs.R28;
		/* 8216B56Ch case   43:*/		return 0x8216B570;
		  /* 8216B570h */ case   44:  		/* bl -2264 */
		/* 8216B570h case   44:*/		regs.LR = 0x8216B574; return 0x8216AC98;
		/* 8216B570h case   44:*/		return 0x8216B574;
		  /* 8216B574h */ case   45:  		/* b 132 */
		/* 8216B574h case   45:*/		return 0x8216B5F8;
		/* 8216B574h case   45:*/		return 0x8216B578;
		  /* 8216B578h */ case   46:  		/* mr R6, R24 */
		/* 8216B578h case   46:*/		regs.R6 = regs.R24;
		/* 8216B578h case   46:*/		return 0x8216B57C;
		  /* 8216B57Ch */ case   47:  		/* mr R5, R26 */
		/* 8216B57Ch case   47:*/		regs.R5 = regs.R26;
		/* 8216B57Ch case   47:*/		return 0x8216B580;
		  /* 8216B580h */ case   48:  		/* mr R4, R28 */
		/* 8216B580h case   48:*/		regs.R4 = regs.R28;
		/* 8216B580h case   48:*/		return 0x8216B584;
		  /* 8216B584h */ case   49:  		/* bl -2100 */
		/* 8216B584h case   49:*/		regs.LR = 0x8216B588; return 0x8216AD50;
		/* 8216B584h case   49:*/		return 0x8216B588;
		  /* 8216B588h */ case   50:  		/* b 112 */
		/* 8216B588h case   50:*/		return 0x8216B5F8;
		/* 8216B588h case   50:*/		return 0x8216B58C;
		  /* 8216B58Ch */ case   51:  		/* mr R5, R23 */
		/* 8216B58Ch case   51:*/		regs.R5 = regs.R23;
		/* 8216B58Ch case   51:*/		return 0x8216B590;
		  /* 8216B590h */ case   52:  		/* mr R4, R28 */
		/* 8216B590h case   52:*/		regs.R4 = regs.R28;
		/* 8216B590h case   52:*/		return 0x8216B594;
		  /* 8216B594h */ case   53:  		/* bl -1820 */
		/* 8216B594h case   53:*/		regs.LR = 0x8216B598; return 0x8216AE78;
		/* 8216B594h case   53:*/		return 0x8216B598;
		  /* 8216B598h */ case   54:  		/* b 96 */
		/* 8216B598h case   54:*/		return 0x8216B5F8;
		/* 8216B598h case   54:*/		return 0x8216B59C;
		  /* 8216B59Ch */ case   55:  		/* addi R7, R1, 112 */
		/* 8216B59Ch case   55:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 8216B59Ch case   55:*/		return 0x8216B5A0;
		  /* 8216B5A0h */ case   56:  		/* std R3, <#[R1 + 96]> */
		/* 8216B5A0h case   56:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8216B5A0h case   56:*/		return 0x8216B5A4;
		  /* 8216B5A4h */ case   57:  		/* addi R10, R1, 112 */
		/* 8216B5A4h case   57:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8216B5A4h case   57:*/		return 0x8216B5A8;
		  /* 8216B5A8h */ case   58:  		/* addi R9, R1, 96 */
		/* 8216B5A8h case   58:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8216B5A8h case   58:*/		return 0x8216B5AC;
		  /* 8216B5ACh */ case   59:  		/* addi R8, R10, 8 */
		/* 8216B5ACh case   59:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x8);
		/* 8216B5ACh case   59:*/		return 0x8216B5B0;
		  /* 8216B5B0h */ case   60:  		/* std R25, <#[R7]> */
		/* 8216B5B0h case   60:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R7 + 0x00000000) );
		/* 8216B5B0h case   60:*/		return 0x8216B5B4;
		  /* 8216B5B4h */ case   61:  		/* lwz R7, <#[R1 + 116]> */
		/* 8216B5B4h case   61:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 8216B5B4h case   61:*/		return 0x8216B5B8;
		  /* 8216B5B8h */ case   62:  		/* rlwimi R11, R7, 0, 20, 15 */
		/* 8216B5B8h case   62:*/		cpu::op::rlwimi<0,0,20,15>(regs,&regs.R11,regs.R7);
		/* 8216B5B8h case   62:*/		return 0x8216B5BC;
		  /* 8216B5BCh */ case   63:  		/* stw R11, <#[R1 + 116]> */
		/* 8216B5BCh case   63:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8216B5BCh case   63:*/		return 0x8216B5C0;
		  /* 8216B5C0h */ case   64:  		/* lbz R11, <#[R10]> */
		/* 8216B5C0h case   64:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8216B5C0h case   64:*/		return 0x8216B5C4;
		  /* 8216B5C4h */ case   65:  		/* lbz R7, <#[R9]> */
		/* 8216B5C4h case   65:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8216B5C4h case   65:*/		return 0x8216B5C8;
		  /* 8216B5C8h */ case   66:  		/* subf. R11, R7, R11 */
		/* 8216B5C8h case   66:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8216B5C8h case   66:*/		return 0x8216B5CC;
		  /* 8216B5CCh */ case   67:  		/* bc 4, CR0_EQ, 20 */
		/* 8216B5CCh case   67:*/		if ( !regs.CR[0].eq ) { return 0x8216B5E0;  }
		/* 8216B5CCh case   67:*/		return 0x8216B5D0;
		  /* 8216B5D0h */ case   68:  		/* addi R10, R10, 1 */
		/* 8216B5D0h case   68:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8216B5D0h case   68:*/		return 0x8216B5D4;
		  /* 8216B5D4h */ case   69:  		/* addi R9, R9, 1 */
		/* 8216B5D4h case   69:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8216B5D4h case   69:*/		return 0x8216B5D8;
		  /* 8216B5D8h */ case   70:  		/* cmpw CR6, R10, R8 */
		/* 8216B5D8h case   70:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 8216B5D8h case   70:*/		return 0x8216B5DC;
		  /* 8216B5DCh */ case   71:  		/* bc 4, CR6_EQ, -28 */
		/* 8216B5DCh case   71:*/		if ( !regs.CR[6].eq ) { return 0x8216B5C0;  }
		/* 8216B5DCh case   71:*/		return 0x8216B5E0;
	}
	return 0x8216B5E0;
} // Block from 8216B4C0h-8216B5E0h (72 instructions)

