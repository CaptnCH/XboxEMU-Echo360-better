#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 821EB718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB718);
		  /* 821EB718h */ case    0:  		/* lwz R11, <#[R27 + 44]> */
		/* 821EB718h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 821EB718h case    0:*/		return 0x821EB71C;
		  /* 821EB71Ch */ case    1:  		/* mr R4, R28 */
		/* 821EB71Ch case    1:*/		regs.R4 = regs.R28;
		/* 821EB71Ch case    1:*/		return 0x821EB720;
		  /* 821EB720h */ case    2:  		/* stw R30, <#[R27 + 92]> */
		/* 821EB720h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + 0x0000005C) );
		/* 821EB720h case    2:*/		return 0x821EB724;
		  /* 821EB724h */ case    3:  		/* mr R3, R27 */
		/* 821EB724h case    3:*/		regs.R3 = regs.R27;
		/* 821EB724h case    3:*/		return 0x821EB728;
		  /* 821EB728h */ case    4:  		/* oris R11, R11, 4 */
		/* 821EB728h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821EB728h case    4:*/		return 0x821EB72C;
		  /* 821EB72Ch */ case    5:  		/* stw R11, <#[R27 + 44]> */
		/* 821EB72Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 821EB72Ch case    5:*/		return 0x821EB730;
		  /* 821EB730h */ case    6:  		/* bl -5128 */
		/* 821EB730h case    6:*/		regs.LR = 0x821EB734; return 0x821EA328;
		/* 821EB730h case    6:*/		return 0x821EB734;
		  /* 821EB734h */ case    7:  		/* cmplwi CR6, R28, 1 */
		/* 821EB734h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 821EB734h case    7:*/		return 0x821EB738;
		  /* 821EB738h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 821EB738h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821EB748;  }
		/* 821EB738h case    8:*/		return 0x821EB73C;
		  /* 821EB73Ch */ case    9:  		/* mr R4, R28 */
		/* 821EB73Ch case    9:*/		regs.R4 = regs.R28;
		/* 821EB73Ch case    9:*/		return 0x821EB740;
		  /* 821EB740h */ case   10:  		/* mr R3, R27 */
		/* 821EB740h case   10:*/		regs.R3 = regs.R27;
		/* 821EB740h case   10:*/		return 0x821EB744;
		  /* 821EB744h */ case   11:  		/* bl -884 */
		/* 821EB744h case   11:*/		regs.LR = 0x821EB748; return 0x821EB3D0;
		/* 821EB744h case   11:*/		return 0x821EB748;
	}
	return 0x821EB748;
} // Block from 821EB718h-821EB748h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EB748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB748);
		  /* 821EB748h */ case    0:  		/* lwz R11, <#[R27 + 40]> */
		/* 821EB748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000028) );
		/* 821EB748h case    0:*/		return 0x821EB74C;
		  /* 821EB74Ch */ case    1:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 821EB74Ch case    1:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 821EB74Ch case    1:*/		return 0x821EB750;
		  /* 821EB750h */ case    2:  		/* bc 12, CR0_EQ, 728 */
		/* 821EB750h case    2:*/		if ( regs.CR[0].eq ) { return 0x821EBA28;  }
		/* 821EB750h case    2:*/		return 0x821EB754;
		  /* 821EB754h */ case    3:  		/* lis R11, -32231 */
		/* 821EB754h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8219);
		/* 821EB754h case    3:*/		return 0x821EB758;
		  /* 821EB758h */ case    4:  		/* mr R6, R27 */
		/* 821EB758h case    4:*/		regs.R6 = regs.R27;
		/* 821EB758h case    4:*/		return 0x821EB75C;
		  /* 821EB75Ch */ case    5:  		/* addi R5, R11, 28352 */
		/* 821EB75Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6EC0);
		/* 821EB75Ch case    5:*/		return 0x821EB760;
		  /* 821EB760h */ case    6:  		/* addi R4, R28, 1 */
		/* 821EB760h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0x1);
		/* 821EB760h case    6:*/		return 0x821EB764;
		  /* 821EB764h */ case    7:  		/* addi R3, R1, 80 */
		/* 821EB764h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821EB764h case    7:*/		return 0x821EB768;
		  /* 821EB768h */ case    8:  		/* bl -349288 */
		/* 821EB768h case    8:*/		regs.LR = 0x821EB76C; return 0x82196300;
		/* 821EB768h case    8:*/		return 0x821EB76C;
		  /* 821EB76Ch */ case    9:  		/* li R5, 6 */
		/* 821EB76Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 821EB76Ch case    9:*/		return 0x821EB770;
		  /* 821EB770h */ case   10:  		/* li R4, 8 */
		/* 821EB770h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 821EB770h case   10:*/		return 0x821EB774;
		  /* 821EB774h */ case   11:  		/* mr R3, R27 */
		/* 821EB774h case   11:*/		regs.R3 = regs.R27;
		/* 821EB774h case   11:*/		return 0x821EB778;
		  /* 821EB778h */ case   12:  		/* bl -552584 */
		/* 821EB778h case   12:*/		regs.LR = 0x821EB77C; return 0x821648F0;
		/* 821EB778h case   12:*/		return 0x821EB77C;
		  /* 821EB77Ch */ case   13:  		/* addi R24, R3, 4 */
		/* 821EB77Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R3,0x4);
		/* 821EB77Ch case   13:*/		return 0x821EB780;
		  /* 821EB780h */ case   14:  		/* ori R11, R3, 1 */
		/* 821EB780h case   14:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R3,0x1);
		/* 821EB780h case   14:*/		return 0x821EB784;
		  /* 821EB784h */ case   15:  		/* ori R10, R24, 1 */
		/* 821EB784h case   15:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R24,0x1);
		/* 821EB784h case   15:*/		return 0x821EB788;
		  /* 821EB788h */ case   16:  		/* stw R11, <#[R3 + 4]> */
		/* 821EB788h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821EB788h case   16:*/		return 0x821EB78C;
		  /* 821EB78Ch */ case   17:  		/* mr R26, R3 */
		/* 821EB78Ch case   17:*/		regs.R26 = regs.R3;
		/* 821EB78Ch case   17:*/		return 0x821EB790;
		  /* 821EB790h */ case   18:  		/* stw R10, <#[R3]> */
		/* 821EB790h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821EB790h case   18:*/		return 0x821EB794;
		  /* 821EB794h */ case   19:  		/* lwz R11, <#[R27 + 4]> */
		/* 821EB794h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821EB794h case   19:*/		return 0x821EB798;
		  /* 821EB798h */ case   20:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821EB798h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821EB798h case   20:*/		return 0x821EB79C;
		  /* 821EB79Ch */ case   21:  		/* bc 4, CR0_EQ, 652 */
		/* 821EB79Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x821EBA28;  }
		/* 821EB79Ch case   21:*/		return 0x821EB7A0;
		  /* 821EB7A0h */ case   22:  		/* mr R25, R11 */
		/* 821EB7A0h case   22:*/		regs.R25 = regs.R11;
		/* 821EB7A0h case   22:*/		return 0x821EB7A4;
		  /* 821EB7A4h */ case   23:  		/* cmplwi CR0, R11, 0 */
		/* 821EB7A4h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821EB7A4h case   23:*/		return 0x821EB7A8;
		  /* 821EB7A8h */ case   24:  		/* bc 12, CR0_EQ, 640 */
		/* 821EB7A8h case   24:*/		if ( regs.CR[0].eq ) { return 0x821EBA28;  }
		/* 821EB7A8h case   24:*/		return 0x821EB7AC;
		  /* 821EB7ACh */ case   25:  		/* lwz R29, <#[R1 + 80]> */
		/* 821EB7ACh case   25:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821EB7ACh case   25:*/		return 0x821EB7B0;
		  /* 821EB7B0h */ case   26:  		/* lwz R11, <#[R25 + 48]> */
		/* 821EB7B0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000030) );
		/* 821EB7B0h case   26:*/		return 0x821EB7B4;
		  /* 821EB7B4h */ case   27:  		/* rlwinm. R11, R11, 13, 31, 31 */
		/* 821EB7B4h case   27:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R11,regs.R11);
		/* 821EB7B4h case   27:*/		return 0x821EB7B8;
		  /* 821EB7B8h */ case   28:  		/* bc 12, CR0_EQ, 596 */
		/* 821EB7B8h case   28:*/		if ( regs.CR[0].eq ) { return 0x821EBA0C;  }
		/* 821EB7B8h case   28:*/		return 0x821EB7BC;
		  /* 821EB7BCh */ case   29:  		/* nor R11, R29, R29 */
		/* 821EB7BCh case   29:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R29,regs.R29);
		/* 821EB7BCh case   29:*/		return 0x821EB7C0;
		  /* 821EB7C0h */ case   30:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821EB7C0h case   30:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821EB7C0h case   30:*/		return 0x821EB7C4;
		  /* 821EB7C4h */ case   31:  		/* bc 4, CR0_EQ, 28 */
		/* 821EB7C4h case   31:*/		if ( !regs.CR[0].eq ) { return 0x821EB7E0;  }
		/* 821EB7C4h case   31:*/		return 0x821EB7C8;
		  /* 821EB7C8h */ case   32:  		/* mr R29, R23 */
		/* 821EB7C8h case   32:*/		regs.R29 = regs.R23;
		/* 821EB7C8h case   32:*/		return 0x821EB7CC;
		  /* 821EB7CCh */ case   33:  		/* stw R23, <#[R1 + 80]> */
		/* 821EB7CCh case   33:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 821EB7CCh case   33:*/		return 0x821EB7D0;
		  /* 821EB7D0h */ case   34:  		/* b 36 */
		/* 821EB7D0h case   34:*/		return 0x821EB7F4;
		/* 821EB7D0h case   34:*/		return 0x821EB7D4;
	}
	return 0x821EB7D4;
} // Block from 821EB748h-821EB7D4h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821EB7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB7D4);
		  /* 821EB7D4h */ case    0:  		/* li R4, 3529 */
		/* 821EB7D4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDC9);
		/* 821EB7D4h case    0:*/		return 0x821EB7D8;
		  /* 821EB7D8h */ case    1:  		/* mr R3, R27 */
		/* 821EB7D8h case    1:*/		regs.R3 = regs.R27;
		/* 821EB7D8h case    1:*/		return 0x821EB7DC;
		  /* 821EB7DCh */ case    2:  		/* bl -629108 */
		/* 821EB7DCh case    2:*/		regs.LR = 0x821EB7E0; return 0x82151E68;
		/* 821EB7DCh case    2:*/		return 0x821EB7E0;
	}
	return 0x821EB7E0;
} // Block from 821EB7D4h-821EB7E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EB7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB7E0);
		  /* 821EB7E0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821EB7E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821EB7E0h case    0:*/		return 0x821EB7E4;
		  /* 821EB7E4h */ case    1:  		/* li R4, 0 */
		/* 821EB7E4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821EB7E4h case    1:*/		return 0x821EB7E8;
		  /* 821EB7E8h */ case    2:  		/* addi R3, R29, 4 */
		/* 821EB7E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0x4);
		/* 821EB7E8h case    2:*/		return 0x821EB7EC;
		  /* 821EB7ECh */ case    3:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821EB7ECh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821EB7ECh case    3:*/		return 0x821EB7F0;
		  /* 821EB7F0h */ case    4:  		/* bl -1418416 */
		/* 821EB7F0h case    4:*/		regs.LR = 0x821EB7F4; return 0x82091340;
		/* 821EB7F0h case    4:*/		return 0x821EB7F4;
	}
	return 0x821EB7F4;
} // Block from 821EB7E0h-821EB7F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EB7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB7F4);
		  /* 821EB7F4h */ case    0:  		/* lwz R11, <#[R27 + 108]> */
		/* 821EB7F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000006C) );
		/* 821EB7F4h case    0:*/		return 0x821EB7F8;
		  /* 821EB7F8h */ case    1:  		/* addi R28, R11, 1 */
		/* 821EB7F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x1);
		/* 821EB7F8h case    1:*/		return 0x821EB7FC;
		  /* 821EB7FCh */ case    2:  		/* stw R28, <#[R27 + 108]> */
		/* 821EB7FCh case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R27 + 0x0000006C) );
		/* 821EB7FCh case    2:*/		return 0x821EB800;
		  /* 821EB800h */ case    3:  		/* stw R28, <#[R25 + 44]> */
		/* 821EB800h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R25 + 0x0000002C) );
		/* 821EB800h case    3:*/		return 0x821EB804;
		  /* 821EB804h */ case    4:  		/* lwz R11, <#[R27 + 4]> */
		/* 821EB804h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821EB804h case    4:*/		return 0x821EB808;
		  /* 821EB808h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821EB808h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821EB808h case    5:*/		return 0x821EB80C;
		  /* 821EB80Ch */ case    6:  		/* bc 4, CR0_EQ, 348 */
		/* 821EB80Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821EB968;  }
		/* 821EB80Ch case    6:*/		return 0x821EB810;
		  /* 821EB810h */ case    7:  		/* mr R30, R11 */
		/* 821EB810h case    7:*/		regs.R30 = regs.R11;
		/* 821EB810h case    7:*/		return 0x821EB814;
		  /* 821EB814h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 821EB814h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821EB814h case    8:*/		return 0x821EB818;
		  /* 821EB818h */ case    9:  		/* bc 12, CR0_EQ, 336 */
		/* 821EB818h case    9:*/		if ( regs.CR[0].eq ) { return 0x821EB968;  }
		/* 821EB818h case    9:*/		return 0x821EB81C;
		  /* 821EB81Ch */ case   10:  		/* lwz R11, <#[R25 + 48]> */
		/* 821EB81Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000030) );
		/* 821EB81Ch case   10:*/		return 0x821EB820;
		  /* 821EB820h */ case   11:  		/* lwz R10, <#[R30 + 40]> */
		/* 821EB820h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000028) );
		/* 821EB820h case   11:*/		return 0x821EB824;
		  /* 821EB824h */ case   12:  		/* rlwinm R9, R11, 0, 13, 31 */
		/* 821EB824h case   12:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R11);
		/* 821EB824h case   12:*/		return 0x821EB828;
		  /* 821EB828h */ case   13:  		/* rlwinm R11, R9, 27, 5, 31 */
		/* 821EB828h case   13:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R9);
		/* 821EB828h case   13:*/		return 0x821EB82C;
		  /* 821EB82Ch */ case   14:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 821EB82Ch case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821EB82Ch case   14:*/		return 0x821EB830;
		  /* 821EB830h */ case   15:  		/* addi R11, R11, 1 */
		/* 821EB830h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821EB830h case   15:*/		return 0x821EB834;
		  /* 821EB834h */ case   16:  		/* slw R9, R23, R9 */
		/* 821EB834h case   16:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R23,regs.R9);
		/* 821EB834h case   16:*/		return 0x821EB838;
		  /* 821EB838h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821EB838h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821EB838h case   17:*/		return 0x821EB83C;
		  /* 821EB83Ch */ case   18:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821EB83Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821EB83Ch case   18:*/		return 0x821EB840;
		  /* 821EB840h */ case   19:  		/* and. R11, R11, R9 */
		/* 821EB840h case   19:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821EB840h case   19:*/		return 0x821EB844;
		  /* 821EB844h */ case   20:  		/* bc 12, CR0_EQ, 264 */
		/* 821EB844h case   20:*/		if ( regs.CR[0].eq ) { return 0x821EB94C;  }
		/* 821EB844h case   20:*/		return 0x821EB848;
		  /* 821EB848h */ case   21:  		/* lwz R11, <#[R30 + 36]> */
		/* 821EB848h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821EB848h case   21:*/		return 0x821EB84C;
		  /* 821EB84Ch */ case   22:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821EB84Ch case   22:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821EB84Ch case   22:*/		return 0x821EB850;
		  /* 821EB850h */ case   23:  		/* bc 4, CR0_EQ, 252 */
		/* 821EB850h case   23:*/		if ( !regs.CR[0].eq ) { return 0x821EB94C;  }
		/* 821EB850h case   23:*/		return 0x821EB854;
		  /* 821EB854h */ case   24:  		/* lwz R11, <#[R30 + 32]> */
		/* 821EB854h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 821EB854h case   24:*/		return 0x821EB858;
		  /* 821EB858h */ case   25:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821EB858h case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821EB858h case   25:*/		return 0x821EB85C;
		  /* 821EB85Ch */ case   26:  		/* addic. R31, R11, -40 */
		/* 821EB85Ch case   26:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821EB85Ch case   26:*/		return 0x821EB860;
		  /* 821EB860h */ case   27:  		/* bc 12, CR0_EQ, 236 */
		/* 821EB860h case   27:*/		if ( regs.CR[0].eq ) { return 0x821EB94C;  }
		/* 821EB860h case   27:*/		return 0x821EB864;
		  /* 821EB864h */ case   28:  		/* lwz R11, <#[R31 + 8]> */
		/* 821EB864h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821EB864h case   28:*/		return 0x821EB868;
		  /* 821EB868h */ case   29:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821EB868h case   29:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821EB868h case   29:*/		return 0x821EB86C;
		  /* 821EB86Ch */ case   30:  		/* cmplwi CR6, R11, 86 */
		/* 821EB86Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 821EB86Ch case   30:*/		return 0x821EB870;
		  /* 821EB870h */ case   31:  		/* bc 12, CR6_EQ, 16 */
		/* 821EB870h case   31:*/		if ( regs.CR[6].eq ) { return 0x821EB880;  }
		/* 821EB870h case   31:*/		return 0x821EB874;
		  /* 821EB874h */ case   32:  		/* cmplwi CR6, R11, 87 */
		/* 821EB874h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 821EB874h case   32:*/		return 0x821EB878;
		  /* 821EB878h */ case   33:  		/* li R11, 0 */
		/* 821EB878h case   33:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821EB878h case   33:*/		return 0x821EB87C;
		  /* 821EB87Ch */ case   34:  		/* bc 4, CR6_EQ, 8 */
		/* 821EB87Ch case   34:*/		if ( !regs.CR[6].eq ) { return 0x821EB884;  }
		/* 821EB87Ch case   34:*/		return 0x821EB880;
	}
	return 0x821EB880;
} // Block from 821EB7F4h-821EB880h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821EB880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB880);
		  /* 821EB880h */ case    0:  		/* mr R11, R23 */
		/* 821EB880h case    0:*/		regs.R11 = regs.R23;
		/* 821EB880h case    0:*/		return 0x821EB884;
	}
	return 0x821EB884;
} // Block from 821EB880h-821EB884h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EB884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB884);
		  /* 821EB884h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821EB884h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821EB884h case    0:*/		return 0x821EB888;
		  /* 821EB888h */ case    1:  		/* bc 12, CR0_EQ, 196 */
		/* 821EB888h case    1:*/		if ( regs.CR[0].eq ) { return 0x821EB94C;  }
		/* 821EB888h case    1:*/		return 0x821EB88C;
		  /* 821EB88Ch */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821EB88Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821EB88Ch case    2:*/		return 0x821EB890;
		  /* 821EB890h */ case    3:  		/* mr R3, R27 */
		/* 821EB890h case    3:*/		regs.R3 = regs.R27;
		/* 821EB890h case    3:*/		return 0x821EB894;
		  /* 821EB894h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821EB894h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821EB894h case    4:*/		return 0x821EB898;
		  /* 821EB898h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821EB898h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821EB898h case    5:*/		return 0x821EB89C;
		  /* 821EB89Ch */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821EB89Ch case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821EB89Ch case    6:*/		return 0x821EB8A0;
		  /* 821EB8A0h */ case    7:  		/* bl -554096 */
		/* 821EB8A0h case    7:*/		regs.LR = 0x821EB8A4; return 0x82164430;
		/* 821EB8A0h case    7:*/		return 0x821EB8A4;
		  /* 821EB8A4h */ case    8:  		/* addi R11, R31, -16 */
		/* 821EB8A4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821EB8A4h case    8:*/		return 0x821EB8A8;
		  /* 821EB8A8h */ case    9:  		/* nor R10, R29, R29 */
		/* 821EB8A8h case    9:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R29,regs.R29);
		/* 821EB8A8h case    9:*/		return 0x821EB8AC;
		  /* 821EB8ACh */ case   10:  		/* addi R9, R29, 4 */
		/* 821EB8ACh case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x4);
		/* 821EB8ACh case   10:*/		return 0x821EB8B0;
		  /* 821EB8B0h */ case   11:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821EB8B0h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821EB8B0h case   11:*/		return 0x821EB8B4;
		  /* 821EB8B4h */ case   12:  		/* lwzx R31, <#[R3 + R11]> */
		/* 821EB8B4h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821EB8B4h case   12:*/		return 0x821EB8B8;
		  /* 821EB8B8h */ case   13:  		/* lwz R11, <#[R31 + 48]> */
		/* 821EB8B8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821EB8B8h case   13:*/		return 0x821EB8BC;
		  /* 821EB8BCh */ case   14:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 821EB8BCh case   14:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 821EB8BCh case   14:*/		return 0x821EB8C0;
		  /* 821EB8C0h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 821EB8C0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821EB8C8;  }
		/* 821EB8C0h case   15:*/		return 0x821EB8C4;
		  /* 821EB8C4h */ case   16:  		/* addi R9, R1, 80 */
		/* 821EB8C4h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 821EB8C4h case   16:*/		return 0x821EB8C8;
	}
	return 0x821EB8C8;
} // Block from 821EB884h-821EB8C8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821EB8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB8C8);
		  /* 821EB8C8h */ case    0:  		/* addi R11, R11, 1 */
		/* 821EB8C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821EB8C8h case    0:*/		return 0x821EB8CC;
		  /* 821EB8CCh */ case    1:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 821EB8CCh case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 821EB8CCh case    1:*/		return 0x821EB8D0;
		  /* 821EB8D0h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821EB8D0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821EB8D0h case    2:*/		return 0x821EB8D4;
		  /* 821EB8D4h */ case    3:  		/* slw R11, R23, R11 */
		/* 821EB8D4h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R23,regs.R11);
		/* 821EB8D4h case    3:*/		return 0x821EB8D8;
		  /* 821EB8D8h */ case    4:  		/* lwzx R8, <#[R10 + R9]> */
		/* 821EB8D8h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821EB8D8h case    4:*/		return 0x821EB8DC;
		  /* 821EB8DCh */ case    5:  		/* or R11, R11, R8 */
		/* 821EB8DCh case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821EB8DCh case    5:*/		return 0x821EB8E0;
		  /* 821EB8E0h */ case    6:  		/* stwx R11, <#[R10 + R9]> */
		/* 821EB8E0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821EB8E0h case    6:*/		return 0x821EB8E4;
		  /* 821EB8E4h */ case    7:  		/* lwz R11, <#[R31 + 44]> */
		/* 821EB8E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EB8E4h case    7:*/		return 0x821EB8E8;
		  /* 821EB8E8h */ case    8:  		/* cmplw CR6, R11, R28 */
		/* 821EB8E8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 821EB8E8h case    8:*/		return 0x821EB8EC;
		  /* 821EB8ECh */ case    9:  		/* bc 12, CR6_EQ, 92 */
		/* 821EB8ECh case    9:*/		if ( regs.CR[6].eq ) { return 0x821EB948;  }
		/* 821EB8ECh case    9:*/		return 0x821EB8F0;
		  /* 821EB8F0h */ case   10:  		/* stw R28, <#[R31 + 44]> */
		/* 821EB8F0h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EB8F0h case   10:*/		return 0x821EB8F4;
		  /* 821EB8F4h */ case   11:  		/* lwz R11, <#[R24]> */
		/* 821EB8F4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821EB8F4h case   11:*/		return 0x821EB8F8;
		  /* 821EB8F8h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821EB8F8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821EB8F8h case   12:*/		return 0x821EB8FC;
		  /* 821EB8FCh */ case   13:  		/* bc 4, CR0_EQ, 40 */
		/* 821EB8FCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x821EB924;  }
		/* 821EB8FCh case   13:*/		return 0x821EB900;
		  /* 821EB900h */ case   14:  		/* lwz R11, <#[R26]> */
		/* 821EB900h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821EB900h case   14:*/		return 0x821EB904;
		  /* 821EB904h */ case   15:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821EB904h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821EB904h case   15:*/		return 0x821EB908;
		  /* 821EB908h */ case   16:  		/* addic. R3, R11, -4 */
		/* 821EB908h case   16:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 821EB908h case   16:*/		return 0x821EB90C;
		  /* 821EB90Ch */ case   17:  		/* bc 12, CR0_EQ, 24 */
		/* 821EB90Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x821EB924;  }
		/* 821EB90Ch case   17:*/		return 0x821EB910;
		  /* 821EB910h */ case   18:  		/* lwz R11, <#[R3 + 8]> */
		/* 821EB910h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821EB910h case   18:*/		return 0x821EB914;
		  /* 821EB914h */ case   19:  		/* lwz R10, <#[R3 + 12]> */
		/* 821EB914h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821EB914h case   19:*/		return 0x821EB918;
		  /* 821EB918h */ case   20:  		/* addi R11, R11, 1 */
		/* 821EB918h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821EB918h case   20:*/		return 0x821EB91C;
		  /* 821EB91Ch */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 821EB91Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821EB91Ch case   21:*/		return 0x821EB920;
		  /* 821EB920h */ case   22:  		/* bc 4, CR6_GT, 16 */
		/* 821EB920h case   22:*/		if ( !regs.CR[6].gt ) { return 0x821EB930;  }
		/* 821EB920h case   22:*/		return 0x821EB924;
	}
	return 0x821EB924;
} // Block from 821EB8C8h-821EB924h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821EB924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB924);
		  /* 821EB924h */ case    0:  		/* li R4, 1 */
		/* 821EB924h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821EB924h case    0:*/		return 0x821EB928;
		  /* 821EB928h */ case    1:  		/* mr R3, R26 */
		/* 821EB928h case    1:*/		regs.R3 = regs.R26;
		/* 821EB928h case    1:*/		return 0x821EB92C;
		  /* 821EB92Ch */ case    2:  		/* bl -387172 */
		/* 821EB92Ch case    2:*/		regs.LR = 0x821EB930; return 0x8218D0C8;
		/* 821EB92Ch case    2:*/		return 0x821EB930;
	}
	return 0x821EB930;
} // Block from 821EB924h-821EB930h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EB930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB930);
		  /* 821EB930h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821EB930h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821EB930h case    0:*/		return 0x821EB934;
		  /* 821EB934h */ case    1:  		/* addi R10, R11, 4 */
		/* 821EB934h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821EB934h case    1:*/		return 0x821EB938;
		  /* 821EB938h */ case    2:  		/* addi R9, R11, 1 */
		/* 821EB938h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 821EB938h case    2:*/		return 0x821EB93C;
		  /* 821EB93Ch */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 821EB93Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 821EB93Ch case    3:*/		return 0x821EB940;
		  /* 821EB940h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 821EB940h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821EB940h case    4:*/		return 0x821EB944;
		  /* 821EB944h */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 821EB944h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821EB944h case    5:*/		return 0x821EB948;
	}
	return 0x821EB948;
} // Block from 821EB930h-821EB948h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EB948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB948);
		  /* 821EB948h */ case    0:  		/* lwz R29, <#[R1 + 80]> */
		/* 821EB948h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821EB948h case    0:*/		return 0x821EB94C;
	}
	return 0x821EB94C;
} // Block from 821EB948h-821EB94Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EB94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB94C);
		  /* 821EB94Ch */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821EB94Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821EB94Ch case    0:*/		return 0x821EB950;
		  /* 821EB950h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821EB950h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821EB950h case    1:*/		return 0x821EB954;
		  /* 821EB954h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821EB954h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821EB954h case    2:*/		return 0x821EB958;
		  /* 821EB958h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821EB958h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821EB968;  }
		/* 821EB958h case    3:*/		return 0x821EB95C;
		  /* 821EB95Ch */ case    4:  		/* mr R30, R11 */
		/* 821EB95Ch case    4:*/		regs.R30 = regs.R11;
		/* 821EB95Ch case    4:*/		return 0x821EB960;
		  /* 821EB960h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821EB960h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EB960h case    5:*/		return 0x821EB964;
		  /* 821EB964h */ case    6:  		/* bc 4, CR6_EQ, -328 */
		/* 821EB964h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821EB81C;  }
		/* 821EB964h case    6:*/		return 0x821EB968;
	}
	return 0x821EB968;
} // Block from 821EB94Ch-821EB968h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EB968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB968);
		  /* 821EB968h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 821EB968h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821EB968h case    0:*/		return 0x821EB96C;
		  /* 821EB96Ch */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821EB96Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821EB96Ch case    1:*/		return 0x821EB970;
		  /* 821EB970h */ case    2:  		/* bc 4, CR0_EQ, 100 */
		/* 821EB970h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821EB9D4;  }
		/* 821EB970h case    2:*/		return 0x821EB974;
		  /* 821EB974h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 821EB974h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821EB974h case    3:*/		return 0x821EB978;
		  /* 821EB978h */ case    4:  		/* bc 12, CR0_EQ, 92 */
		/* 821EB978h case    4:*/		if ( regs.CR[0].eq ) { return 0x821EB9D4;  }
		/* 821EB978h case    4:*/		return 0x821EB97C;
		  /* 821EB97Ch */ case    5:  		/* lwz R11, <#[R26]> */
		/* 821EB97Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821EB97Ch case    5:*/		return 0x821EB980;
		  /* 821EB980h */ case    6:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821EB980h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821EB980h case    6:*/		return 0x821EB984;
		  /* 821EB984h */ case    7:  		/* addi R4, R11, -4 */
		/* 821EB984h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821EB984h case    7:*/		return 0x821EB988;
		  /* 821EB988h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 821EB988h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821EB988h case    8:*/		return 0x821EB98C;
		  /* 821EB98Ch */ case    9:  		/* addic. R11, R11, -1 */
		/* 821EB98Ch case    9:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821EB98Ch case    9:*/		return 0x821EB990;
		  /* 821EB990h */ case   10:  		/* stw R11, <#[R4 + 8]> */
		/* 821EB990h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821EB990h case   10:*/		return 0x821EB994;
		  /* 821EB994h */ case   11:  		/* bc 4, CR0_EQ, -400 */
		/* 821EB994h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821EB804;  }
		/* 821EB994h case   11:*/		return 0x821EB998;
		  /* 821EB998h */ case   12:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821EB998h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821EB998h case   12:*/		return 0x821EB99C;
		  /* 821EB99Ch */ case   13:  		/* mr R3, R26 */
		/* 821EB99Ch case   13:*/		regs.R3 = regs.R26;
		/* 821EB99Ch case   13:*/		return 0x821EB9A0;
		  /* 821EB9A0h */ case   14:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EB9A0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EB9A0h case   14:*/		return 0x821EB9A4;
		  /* 821EB9A4h */ case   15:  		/* lwz R9, <#[R11]> */
		/* 821EB9A4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EB9A4h case   15:*/		return 0x821EB9A8;
		  /* 821EB9A8h */ case   16:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821EB9A8h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821EB9A8h case   16:*/		return 0x821EB9AC;
		  /* 821EB9ACh */ case   17:  		/* stw R9, <#[R10]> */
		/* 821EB9ACh case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EB9ACh case   17:*/		return 0x821EB9B0;
		  /* 821EB9B0h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 821EB9B0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821EB9B0h case   18:*/		return 0x821EB9B4;
		  /* 821EB9B4h */ case   19:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821EB9B4h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821EB9B4h case   19:*/		return 0x821EB9B8;
		  /* 821EB9B8h */ case   20:  		/* lwz R11, <#[R11 + 4]> */
		/* 821EB9B8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821EB9B8h case   20:*/		return 0x821EB9BC;
		  /* 821EB9BCh */ case   21:  		/* stw R11, <#[R10]> */
		/* 821EB9BCh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821EB9BCh case   21:*/		return 0x821EB9C0;
		  /* 821EB9C0h */ case   22:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EB9C0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EB9C0h case   22:*/		return 0x821EB9C4;
		  /* 821EB9C4h */ case   23:  		/* addi R11, R11, 4 */
		/* 821EB9C4h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821EB9C4h case   23:*/		return 0x821EB9C8;
		  /* 821EB9C8h */ case   24:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821EB9C8h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821EB9C8h case   24:*/		return 0x821EB9CC;
		  /* 821EB9CCh */ case   25:  		/* bl -629700 */
		/* 821EB9CCh case   25:*/		regs.LR = 0x821EB9D0; return 0x82151E08;
		/* 821EB9CCh case   25:*/		return 0x821EB9D0;
		  /* 821EB9D0h */ case   26:  		/* b -460 */
		/* 821EB9D0h case   26:*/		return 0x821EB804;
		/* 821EB9D0h case   26:*/		return 0x821EB9D4;
	}
	return 0x821EB9D4;
} // Block from 821EB968h-821EB9D4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821EB9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB9D4);
		  /* 821EB9D4h */ case    0:  		/* nor R11, R29, R29 */
		/* 821EB9D4h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R29,regs.R29);
		/* 821EB9D4h case    0:*/		return 0x821EB9D8;
		  /* 821EB9D8h */ case    1:  		/* lwz R10, <#[R25 + 48]> */
		/* 821EB9D8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000030) );
		/* 821EB9D8h case    1:*/		return 0x821EB9DC;
		  /* 821EB9DCh */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821EB9DCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821EB9DCh case    2:*/		return 0x821EB9E0;
		  /* 821EB9E0h */ case    3:  		/* rlwinm R11, R10, 0, 13, 31 */
		/* 821EB9E0h case    3:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R10);
		/* 821EB9E0h case    3:*/		return 0x821EB9E4;
		  /* 821EB9E4h */ case    4:  		/* addi R10, R29, 4 */
		/* 821EB9E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x4);
		/* 821EB9E4h case    4:*/		return 0x821EB9E8;
		  /* 821EB9E8h */ case    5:  		/* bc 4, CR0_EQ, 8 */
		/* 821EB9E8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821EB9F0;  }
		/* 821EB9E8h case    5:*/		return 0x821EB9EC;
		  /* 821EB9ECh */ case    6:  		/* addi R10, R1, 80 */
		/* 821EB9ECh case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821EB9ECh case    6:*/		return 0x821EB9F0;
	}
	return 0x821EB9F0;
} // Block from 821EB9D4h-821EB9F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EB9F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EB9F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EB9F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EB9F0);
		  /* 821EB9F0h */ case    0:  		/* addi R11, R11, 1 */
		/* 821EB9F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821EB9F0h case    0:*/		return 0x821EB9F4;
		  /* 821EB9F4h */ case    1:  		/* rlwinm R9, R11, 29, 3, 29 */
		/* 821EB9F4h case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R11);
		/* 821EB9F4h case    1:*/		return 0x821EB9F8;
		  /* 821EB9F8h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821EB9F8h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821EB9F8h case    2:*/		return 0x821EB9FC;
		  /* 821EB9FCh */ case    3:  		/* lwzx R10, <#[R9 + R10]> */
		/* 821EB9FCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821EB9FCh case    3:*/		return 0x821EBA00;
		  /* 821EBA00h */ case    4:  		/* srw R11, R10, R11 */
		/* 821EBA00h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EBA00h case    4:*/		return 0x821EBA04;
		  /* 821EBA04h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821EBA04h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821EBA04h case    5:*/		return 0x821EBA08;
		  /* 821EBA08h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 821EBA08h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821EBA30;  }
		/* 821EBA08h case    6:*/		return 0x821EBA0C;
	}
	return 0x821EBA0C;
} // Block from 821EB9F0h-821EBA0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBA0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBA0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBA0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBA0C);
		  /* 821EBA0Ch */ case    0:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 821EBA0Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 821EBA0Ch case    0:*/		return 0x821EBA10;
		  /* 821EBA10h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821EBA10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821EBA10h case    1:*/		return 0x821EBA14;
		  /* 821EBA14h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821EBA14h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821EBA14h case    2:*/		return 0x821EBA18;
		  /* 821EBA18h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821EBA18h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821EBA28;  }
		/* 821EBA18h case    3:*/		return 0x821EBA1C;
		  /* 821EBA1Ch */ case    4:  		/* mr R25, R11 */
		/* 821EBA1Ch case    4:*/		regs.R25 = regs.R11;
		/* 821EBA1Ch case    4:*/		return 0x821EBA20;
		  /* 821EBA20h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821EBA20h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBA20h case    5:*/		return 0x821EBA24;
		  /* 821EBA24h */ case    6:  		/* bc 4, CR6_EQ, -628 */
		/* 821EBA24h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821EB7B0;  }
		/* 821EBA24h case    6:*/		return 0x821EBA28;
	}
	return 0x821EBA28;
} // Block from 821EBA0Ch-821EBA28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBA28);
		  /* 821EBA28h */ case    0:  		/* addi R1, R1, 176 */
		/* 821EBA28h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821EBA28h case    0:*/		return 0x821EBA2C;
		  /* 821EBA2Ch */ case    1:  		/* b -1419160 */
		/* 821EBA2Ch case    1:*/		return 0x82091294;
		/* 821EBA2Ch case    1:*/		return 0x821EBA30;
	}
	return 0x821EBA30;
} // Block from 821EBA28h-821EBA30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBA30);
		  /* 821EBA30h */ case    0:  		/* lwz R11, <#[R25 + 116]> */
		/* 821EBA30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000074) );
		/* 821EBA30h case    0:*/		return 0x821EBA34;
		  /* 821EBA34h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EBA34h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBA34h case    1:*/		return 0x821EBA38;
		  /* 821EBA38h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821EBA38h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EBA74;  }
		/* 821EBA38h case    2:*/		return 0x821EBA3C;
		  /* 821EBA3Ch */ case    3:  		/* lwz R11, <#[R11]> */
		/* 821EBA3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821EBA3Ch case    3:*/		return 0x821EBA40;
		  /* 821EBA40h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EBA40h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBA40h case    4:*/		return 0x821EBA44;
		  /* 821EBA44h */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 821EBA44h case    5:*/		if ( regs.CR[6].eq ) { return 0x821EBA74;  }
		/* 821EBA44h case    5:*/		return 0x821EBA48;
		  /* 821EBA48h */ case    6:  		/* lwz R11, <#[R11 + 20]> */
		/* 821EBA48h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821EBA48h case    6:*/		return 0x821EBA4C;
		  /* 821EBA4Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EBA4Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBA4Ch case    7:*/		return 0x821EBA50;
		  /* 821EBA50h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 821EBA50h case    8:*/		if ( regs.CR[6].eq ) { return 0x821EBA74;  }
		/* 821EBA50h case    8:*/		return 0x821EBA54;
		  /* 821EBA54h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EBA54h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EBA54h case    9:*/		return 0x821EBA58;
		  /* 821EBA58h */ case   10:  		/* cmpwi CR6, R10, 3 */
		/* 821EBA58h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821EBA58h case   10:*/		return 0x821EBA5C;
		  /* 821EBA5Ch */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 821EBA5Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821EBA74;  }
		/* 821EBA5Ch case   11:*/		return 0x821EBA60;
		  /* 821EBA60h */ case   12:  		/* lwz R10, <#[R11 + 16]> */
		/* 821EBA60h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821EBA60h case   12:*/		return 0x821EBA64;
		  /* 821EBA64h */ case   13:  		/* cmpwi CR6, R10, 11 */
		/* 821EBA64h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000B);
		/* 821EBA64h case   13:*/		return 0x821EBA68;
		  /* 821EBA68h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBA68h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821EBA74;  }
		/* 821EBA68h case   14:*/		return 0x821EBA6C;
		  /* 821EBA6Ch */ case   15:  		/* lwz R5, <#[R11 + 24]> */
		/* 821EBA6Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000018) );
		/* 821EBA6Ch case   15:*/		return 0x821EBA70;
		  /* 821EBA70h */ case   16:  		/* b 8 */
		/* 821EBA70h case   16:*/		return 0x821EBA78;
		/* 821EBA70h case   16:*/		return 0x821EBA74;
	}
	return 0x821EBA74;
} // Block from 821EBA30h-821EBA74h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821EBA74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBA74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBA74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBA74);
		  /* 821EBA74h */ case    0:  		/* li R5, 0 */
		/* 821EBA74h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EBA74h case    0:*/		return 0x821EBA78;
	}
	return 0x821EBA78;
} // Block from 821EBA74h-821EBA78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EBA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBA78);
		  /* 821EBA78h */ case    0:  		/* li R4, 3614 */
		/* 821EBA78h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE1E);
		/* 821EBA78h case    0:*/		return 0x821EBA7C;
		  /* 821EBA7Ch */ case    1:  		/* mr R3, R27 */
		/* 821EBA7Ch case    1:*/		regs.R3 = regs.R27;
		/* 821EBA7Ch case    1:*/		return 0x821EBA80;
		  /* 821EBA80h */ case    2:  		/* bl -629784 */
		/* 821EBA80h case    2:*/		regs.LR = 0x821EBA84; return 0x82151E68;
		/* 821EBA80h case    2:*/		return 0x821EBA84;
		  /* 821EBA84h */ case    3:  		/* nop */
		/* 821EBA84h case    3:*/		cpu::op::nop();
		/* 821EBA84h case    3:*/		return 0x821EBA88;
		  /* 821EBA88h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 821EBA88h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821EBA88h case    4:*/		return 0x821EBA8C;
		  /* 821EBA8Ch */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821EBA8Ch case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821EBA8Ch case    5:*/		return 0x821EBA90;
		  /* 821EBA90h */ case    6:  		/* cmplwi CR6, R11, 33 */
		/* 821EBA90h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000021);
		/* 821EBA90h case    6:*/		return 0x821EBA94;
		  /* 821EBA94h */ case    7:  		/* bc 12, CR6_EQ, 44 */
		/* 821EBA94h case    7:*/		if ( regs.CR[6].eq ) { return 0x821EBAC0;  }
		/* 821EBA94h case    7:*/		return 0x821EBA98;
		  /* 821EBA98h */ case    8:  		/* cmplwi CR6, R11, 34 */
		/* 821EBA98h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000022);
		/* 821EBA98h case    8:*/		return 0x821EBA9C;
		  /* 821EBA9Ch */ case    9:  		/* bc 4, CR6_GT, 28 */
		/* 821EBA9Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x821EBAB8;  }
		/* 821EBA9Ch case    9:*/		return 0x821EBAA0;
		  /* 821EBAA0h */ case   10:  		/* cmplwi CR6, R11, 36 */
		/* 821EBAA0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000024);
		/* 821EBAA0h case   10:*/		return 0x821EBAA4;
		  /* 821EBAA4h */ case   11:  		/* bc 4, CR6_GT, 28 */
		/* 821EBAA4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x821EBAC0;  }
		/* 821EBAA4h case   11:*/		return 0x821EBAA8;
		  /* 821EBAA8h */ case   12:  		/* cmplwi CR6, R11, 58 */
		/* 821EBAA8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003A);
		/* 821EBAA8h case   12:*/		return 0x821EBAAC;
		  /* 821EBAACh */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 821EBAACh case   13:*/		if ( regs.CR[6].eq ) { return 0x821EBAC0;  }
		/* 821EBAACh case   13:*/		return 0x821EBAB0;
		  /* 821EBAB0h */ case   14:  		/* cmplwi CR6, R11, 82 */
		/* 821EBAB0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821EBAB0h case   14:*/		return 0x821EBAB4;
		  /* 821EBAB4h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBAB4h case   15:*/		if ( regs.CR[6].eq ) { return 0x821EBAC0;  }
		/* 821EBAB4h case   15:*/		return 0x821EBAB8;
	}
	return 0x821EBAB8;
} // Block from 821EBA78h-821EBAB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EBAB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBAB8);
		  /* 821EBAB8h */ case    0:  		/* li R3, 0 */
		/* 821EBAB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBAB8h case    0:*/		return 0x821EBABC;
		  /* 821EBABCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBABCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBABCh case    1:*/		return 0x821EBAC0;
	}
	return 0x821EBAC0;
} // Block from 821EBAB8h-821EBAC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBAC0);
		  /* 821EBAC0h */ case    0:  		/* li R3, 1 */
		/* 821EBAC0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EBAC0h case    0:*/		return 0x821EBAC4;
		  /* 821EBAC4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBAC4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBAC4h case    1:*/		return 0x821EBAC8;
	}
	return 0x821EBAC8;
} // Block from 821EBAC0h-821EBAC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBAC8);
		  /* 821EBAC8h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 821EBAC8h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBAC8h case    0:*/		return 0x821EBACC;
		  /* 821EBACCh */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 821EBACCh case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EBACCh case    1:*/		return 0x821EBAD0;
		  /* 821EBAD0h */ case    2:  		/* li R11, 1 */
		/* 821EBAD0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821EBAD0h case    2:*/		return 0x821EBAD4;
		  /* 821EBAD4h */ case    3:  		/* lwz R31, <#[R1 + 84]> */
		/* 821EBAD4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 821EBAD4h case    3:*/		return 0x821EBAD8;
		  /* 821EBAD8h */ case    4:  		/* lwz R30, <#[R1 + 92]> */
		/* 821EBAD8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 821EBAD8h case    4:*/		return 0x821EBADC;
		  /* 821EBADCh */ case    5:  		/* slw R3, R11, R3 */
		/* 821EBADCh case    5:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 821EBADCh case    5:*/		return 0x821EBAE0;
		  /* 821EBAE0h */ case    6:  		/* slw R4, R11, R4 */
		/* 821EBAE0h case    6:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 821EBAE0h case    6:*/		return 0x821EBAE4;
		  /* 821EBAE4h */ case    7:  		/* slw R5, R11, R5 */
		/* 821EBAE4h case    7:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 821EBAE4h case    7:*/		return 0x821EBAE8;
		  /* 821EBAE8h */ case    8:  		/* or R4, R3, R4 */
		/* 821EBAE8h case    8:*/		cpu::op::or<0>(regs,&regs.R4,regs.R3,regs.R4);
		/* 821EBAE8h case    8:*/		return 0x821EBAEC;
		  /* 821EBAECh */ case    9:  		/* slw R6, R11, R6 */
		/* 821EBAECh case    9:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 821EBAECh case    9:*/		return 0x821EBAF0;
		  /* 821EBAF0h */ case   10:  		/* or R5, R4, R5 */
		/* 821EBAF0h case   10:*/		cpu::op::or<0>(regs,&regs.R5,regs.R4,regs.R5);
		/* 821EBAF0h case   10:*/		return 0x821EBAF4;
		  /* 821EBAF4h */ case   11:  		/* slw R7, R11, R7 */
		/* 821EBAF4h case   11:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 821EBAF4h case   11:*/		return 0x821EBAF8;
		  /* 821EBAF8h */ case   12:  		/* or R6, R5, R6 */
		/* 821EBAF8h case   12:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 821EBAF8h case   12:*/		return 0x821EBAFC;
		  /* 821EBAFCh */ case   13:  		/* slw R8, R11, R8 */
		/* 821EBAFCh case   13:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 821EBAFCh case   13:*/		return 0x821EBB00;
		  /* 821EBB00h */ case   14:  		/* or R7, R6, R7 */
		/* 821EBB00h case   14:*/		cpu::op::or<0>(regs,&regs.R7,regs.R6,regs.R7);
		/* 821EBB00h case   14:*/		return 0x821EBB04;
		  /* 821EBB04h */ case   15:  		/* slw R9, R11, R9 */
		/* 821EBB04h case   15:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821EBB04h case   15:*/		return 0x821EBB08;
		  /* 821EBB08h */ case   16:  		/* or R8, R7, R8 */
		/* 821EBB08h case   16:*/		cpu::op::or<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821EBB08h case   16:*/		return 0x821EBB0C;
		  /* 821EBB0Ch */ case   17:  		/* slw R10, R11, R10 */
		/* 821EBB0Ch case   17:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821EBB0Ch case   17:*/		return 0x821EBB10;
		  /* 821EBB10h */ case   18:  		/* or R9, R8, R9 */
		/* 821EBB10h case   18:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821EBB10h case   18:*/		return 0x821EBB14;
		  /* 821EBB14h */ case   19:  		/* or R10, R9, R10 */
		/* 821EBB14h case   19:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821EBB14h case   19:*/		return 0x821EBB18;
		  /* 821EBB18h */ case   20:  		/* slw R9, R11, R31 */
		/* 821EBB18h case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R31);
		/* 821EBB18h case   20:*/		return 0x821EBB1C;
		  /* 821EBB1Ch */ case   21:  		/* or R10, R10, R9 */
		/* 821EBB1Ch case   21:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821EBB1Ch case   21:*/		return 0x821EBB20;
		  /* 821EBB20h */ case   22:  		/* slw R11, R11, R30 */
		/* 821EBB20h case   22:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821EBB20h case   22:*/		return 0x821EBB24;
		  /* 821EBB24h */ case   23:  		/* or R11, R10, R11 */
		/* 821EBB24h case   23:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EBB24h case   23:*/		return 0x821EBB28;
		  /* 821EBB28h */ case   24:  		/* rlwinm R3, R11, 0, 0, 30 */
		/* 821EBB28h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R3,regs.R11);
		/* 821EBB28h case   24:*/		return 0x821EBB2C;
		  /* 821EBB2Ch */ case   25:  		/* ld R30, <#[R1 - 16]> */
		/* 821EBB2Ch case   25:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBB2Ch case   25:*/		return 0x821EBB30;
		  /* 821EBB30h */ case   26:  		/* ld R31, <#[R1 - 8]> */
		/* 821EBB30h case   26:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EBB30h case   26:*/		return 0x821EBB34;
		  /* 821EBB34h */ case   27:  		/* bclr 20, CR0_LT */
		/* 821EBB34h case   27:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBB34h case   27:*/		return 0x821EBB38;
	}
	return 0x821EBB38;
} // Block from 821EBAC8h-821EBB38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EBB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBB38);
		  /* 821EBB38h */ case    0:  		/* stfs FR1, <#[R1 - 16]> */
		/* 821EBB38h case    0:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBB38h case    0:*/		return 0x821EBB3C;
		  /* 821EBB3Ch */ case    1:  		/* lwz R11, <#[R1 - 16]> */
		/* 821EBB3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBB3Ch case    1:*/		return 0x821EBB40;
		  /* 821EBB40h */ case    2:  		/* stfs FR1, <#[R1 + 20]> */
		/* 821EBB40h case    2:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000014) );
		/* 821EBB40h case    2:*/		return 0x821EBB44;
		  /* 821EBB44h */ case    3:  		/* rlwinm. R10, R11, 0, 1, 31 */
		/* 821EBB44h case    3:*/		cpu::op::rlwinm<1,0,1,31>(regs,&regs.R10,regs.R11);
		/* 821EBB44h case    3:*/		return 0x821EBB48;
		  /* 821EBB48h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 821EBB48h case    4:*/		if ( regs.CR[0].eq ) { return 0x821EBB58;  }
		/* 821EBB48h case    4:*/		return 0x821EBB4C;
		  /* 821EBB4Ch */ case    5:  		/* rlwinm. R11, R11, 0, 1, 8 */
		/* 821EBB4Ch case    5:*/		cpu::op::rlwinm<1,0,1,8>(regs,&regs.R11,regs.R11);
		/* 821EBB4Ch case    5:*/		return 0x821EBB50;
		  /* 821EBB50h */ case    6:  		/* li R11, 0 */
		/* 821EBB50h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821EBB50h case    6:*/		return 0x821EBB54;
		  /* 821EBB54h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 821EBB54h case    7:*/		if ( regs.CR[0].eq ) { return 0x821EBB5C;  }
		/* 821EBB54h case    7:*/		return 0x821EBB58;
	}
	return 0x821EBB58;
} // Block from 821EBB38h-821EBB58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EBB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBB58);
		  /* 821EBB58h */ case    0:  		/* li R11, 1 */
		/* 821EBB58h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821EBB58h case    0:*/		return 0x821EBB5C;
	}
	return 0x821EBB5C;
} // Block from 821EBB58h-821EBB5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EBB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBB5C);
		  /* 821EBB5Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821EBB5Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821EBB5Ch case    0:*/		return 0x821EBB60;
		  /* 821EBB60h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 821EBB60h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821EBB60h case    1:*/		return 0x821EBB64;
	}
	return 0x821EBB64;
} // Block from 821EBB5Ch-821EBB64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBB64);
		  /* 821EBB64h */ case    0:  		/* lwz R11, <#[R1 + 20]> */
		/* 821EBB64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000014) );
		/* 821EBB64h case    0:*/		return 0x821EBB68;
		  /* 821EBB68h */ case    1:  		/* rlwinm R11, R11, 0, 0, 0 */
		/* 821EBB68h case    1:*/		cpu::op::rlwinm<0,0,0,0>(regs,&regs.R11,regs.R11);
		/* 821EBB68h case    1:*/		return 0x821EBB6C;
		  /* 821EBB6Ch */ case    2:  		/* stw R11, <#[R1 + 20]> */
		/* 821EBB6Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000014) );
		/* 821EBB6Ch case    2:*/		return 0x821EBB70;
		  /* 821EBB70h */ case    3:  		/* lfs FR1, <#[R1 + 20]> */
		/* 821EBB70h case    3:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000014) );
		/* 821EBB70h case    3:*/		return 0x821EBB74;
		  /* 821EBB74h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821EBB74h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBB74h case    4:*/		return 0x821EBB78;
	}
	return 0x821EBB78;
} // Block from 821EBB64h-821EBB78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EBB78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBB78);
		  /* 821EBB78h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 821EBB78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 821EBB78h case    0:*/		return 0x821EBB7C;
		  /* 821EBB7Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EBB7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBB7Ch case    1:*/		return 0x821EBB80;
		  /* 821EBB80h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821EBB80h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EBBBC;  }
		/* 821EBB80h case    2:*/		return 0x821EBB84;
		  /* 821EBB84h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 821EBB84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821EBB84h case    3:*/		return 0x821EBB88;
		  /* 821EBB88h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EBB88h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBB88h case    4:*/		return 0x821EBB8C;
		  /* 821EBB8Ch */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 821EBB8Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821EBBBC;  }
		/* 821EBB8Ch case    5:*/		return 0x821EBB90;
		  /* 821EBB90h */ case    6:  		/* lwz R11, <#[R11 + 20]> */
		/* 821EBB90h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821EBB90h case    6:*/		return 0x821EBB94;
		  /* 821EBB94h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EBB94h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBB94h case    7:*/		return 0x821EBB98;
		  /* 821EBB98h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 821EBB98h case    8:*/		if ( regs.CR[6].eq ) { return 0x821EBBBC;  }
		/* 821EBB98h case    8:*/		return 0x821EBB9C;
		  /* 821EBB9Ch */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EBB9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EBB9Ch case    9:*/		return 0x821EBBA0;
		  /* 821EBBA0h */ case   10:  		/* cmpwi CR6, R10, 3 */
		/* 821EBBA0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821EBBA0h case   10:*/		return 0x821EBBA4;
		  /* 821EBBA4h */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 821EBBA4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821EBBBC;  }
		/* 821EBBA4h case   11:*/		return 0x821EBBA8;
		  /* 821EBBA8h */ case   12:  		/* lwz R10, <#[R11 + 16]> */
		/* 821EBBA8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821EBBA8h case   12:*/		return 0x821EBBAC;
		  /* 821EBBACh */ case   13:  		/* cmpwi CR6, R10, 11 */
		/* 821EBBACh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000B);
		/* 821EBBACh case   13:*/		return 0x821EBBB0;
		  /* 821EBBB0h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBBB0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821EBBBC;  }
		/* 821EBBB0h case   14:*/		return 0x821EBBB4;
		  /* 821EBBB4h */ case   15:  		/* lwz R3, <#[R11 + 24]> */
		/* 821EBBB4h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 821EBBB4h case   15:*/		return 0x821EBBB8;
		  /* 821EBBB8h */ case   16:  		/* bclr 20, CR0_LT */
		/* 821EBBB8h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBBB8h case   16:*/		return 0x821EBBBC;
	}
	return 0x821EBBBC;
} // Block from 821EBB78h-821EBBBCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 821EBBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBBBC);
		  /* 821EBBBCh */ case    0:  		/* li R3, 0 */
		/* 821EBBBCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBBBCh case    0:*/		return 0x821EBBC0;
		  /* 821EBBC0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBBC0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBBC0h case    1:*/		return 0x821EBBC4;
	}
	return 0x821EBBC4;
} // Block from 821EBBBCh-821EBBC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBBC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBBC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBBC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBBC4);
		  /* 821EBBC4h */ case    0:  		/* nop */
		/* 821EBBC4h case    0:*/		cpu::op::nop();
		/* 821EBBC4h case    0:*/		return 0x821EBBC8;
		  /* 821EBBC8h */ case    1:  		/* rlwinm R11, R4, 4, 0, 27 */
		/* 821EBBC8h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R4);
		/* 821EBBC8h case    1:*/		return 0x821EBBCC;
		  /* 821EBBCCh */ case    2:  		/* lwz R9, <#[R3 + 12]> */
		/* 821EBBCCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 821EBBCCh case    2:*/		return 0x821EBBD0;
		  /* 821EBBD0h */ case    3:  		/* mr R10, R3 */
		/* 821EBBD0h case    3:*/		regs.R10 = regs.R3;
		/* 821EBBD0h case    3:*/		return 0x821EBBD4;
		  /* 821EBBD4h */ case    4:  		/* or R11, R11, R4 */
		/* 821EBBD4h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821EBBD4h case    4:*/		return 0x821EBBD8;
		  /* 821EBBD8h */ case    5:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 821EBBD8h case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 821EBBD8h case    5:*/		return 0x821EBBDC;
		  /* 821EBBDCh */ case    6:  		/* or R11, R11, R4 */
		/* 821EBBDCh case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821EBBDCh case    6:*/		return 0x821EBBE0;
		  /* 821EBBE0h */ case    7:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 821EBBE0h case    7:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 821EBBE0h case    7:*/		return 0x821EBBE4;
		  /* 821EBBE4h */ case    8:  		/* or R11, R11, R4 */
		/* 821EBBE4h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821EBBE4h case    8:*/		return 0x821EBBE8;
		  /* 821EBBE8h */ case    9:  		/* and R8, R9, R11 */
		/* 821EBBE8h case    9:*/		cpu::op::and<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 821EBBE8h case    9:*/		return 0x821EBBEC;
		  /* 821EBBECh */ case   10:  		/* rlwinm R8, R8, 0, 16, 31 */
		/* 821EBBECh case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R8);
		/* 821EBBECh case   10:*/		return 0x821EBBF0;
		  /* 821EBBF0h */ case   11:  		/* cmplw CR6, R8, R11 */
		/* 821EBBF0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 821EBBF0h case   11:*/		return 0x821EBBF4;
		  /* 821EBBF4h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBBF4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821EBC00;  }
		/* 821EBBF4h case   12:*/		return 0x821EBBF8;
		  /* 821EBBF8h */ case   13:  		/* li R3, 0 */
		/* 821EBBF8h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBBF8h case   13:*/		return 0x821EBBFC;
		  /* 821EBBFCh */ case   14:  		/* bclr 20, CR0_LT */
		/* 821EBBFCh case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBBFCh case   14:*/		return 0x821EBC00;
	}
	return 0x821EBC00;
} // Block from 821EBBC4h-821EBC00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC00);
		  /* 821EBC00h */ case    0:  		/* or R11, R9, R11 */
		/* 821EBC00h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821EBC00h case    0:*/		return 0x821EBC04;
		  /* 821EBC04h */ case    1:  		/* li R3, 1 */
		/* 821EBC04h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EBC04h case    1:*/		return 0x821EBC08;
		  /* 821EBC08h */ case    2:  		/* sth R11, <#[R10 + 14]> */
		/* 821EBC08h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x0000000E) );
		/* 821EBC08h case    2:*/		return 0x821EBC0C;
		  /* 821EBC0Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 821EBC0Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBC0Ch case    3:*/		return 0x821EBC10;
	}
	return 0x821EBC10;
} // Block from 821EBC00h-821EBC10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC10);
		  /* 821EBC10h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBC10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBC10h case    0:*/		return 0x821EBC14;
		  /* 821EBC14h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821EBC14h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBC2C;  }
		/* 821EBC14h case    1:*/		return 0x821EBC18;
		  /* 821EBC18h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBC18h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBC18h case    2:*/		return 0x821EBC1C;
		  /* 821EBC1Ch */ case    3:  		/* cmpw CR6, R11, R5 */
		/* 821EBC1Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 821EBC1Ch case    3:*/		return 0x821EBC20;
		  /* 821EBC20h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBC20h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBC2C;  }
		/* 821EBC20h case    4:*/		return 0x821EBC24;
		  /* 821EBC24h */ case    5:  		/* mr R3, R4 */
		/* 821EBC24h case    5:*/		regs.R3 = regs.R4;
		/* 821EBC24h case    5:*/		return 0x821EBC28;
		  /* 821EBC28h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821EBC28h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBC28h case    6:*/		return 0x821EBC2C;
	}
	return 0x821EBC2C;
} // Block from 821EBC10h-821EBC2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC2C);
		  /* 821EBC2Ch */ case    0:  		/* li R4, 4801 */
		/* 821EBC2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBC2Ch case    0:*/		return 0x821EBC30;
		  /* 821EBC30h */ case    1:  		/* b -630216 */
		/* 821EBC30h case    1:*/		return 0x82151E68;
		/* 821EBC30h case    1:*/		return 0x821EBC34;
		  /* 821EBC34h */ case    2:  		/* nop */
		/* 821EBC34h case    2:*/		cpu::op::nop();
		/* 821EBC34h case    2:*/		return 0x821EBC38;
	}
	return 0x821EBC38;
} // Block from 821EBC2Ch-821EBC38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC38);
		  /* 821EBC38h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBC38h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBC38h case    0:*/		return 0x821EBC3C;
		  /* 821EBC3Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821EBC3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBC54;  }
		/* 821EBC3Ch case    1:*/		return 0x821EBC40;
		  /* 821EBC40h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBC40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBC40h case    2:*/		return 0x821EBC44;
		  /* 821EBC44h */ case    3:  		/* cmpwi CR6, R11, 14 */
		/* 821EBC44h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821EBC44h case    3:*/		return 0x821EBC48;
		  /* 821EBC48h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBC48h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBC54;  }
		/* 821EBC48h case    4:*/		return 0x821EBC4C;
		  /* 821EBC4Ch */ case    5:  		/* mr R3, R4 */
		/* 821EBC4Ch case    5:*/		regs.R3 = regs.R4;
		/* 821EBC4Ch case    5:*/		return 0x821EBC50;
		  /* 821EBC50h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821EBC50h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBC50h case    6:*/		return 0x821EBC54;
	}
	return 0x821EBC54;
} // Block from 821EBC38h-821EBC54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC54);
		  /* 821EBC54h */ case    0:  		/* li R4, 4801 */
		/* 821EBC54h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBC54h case    0:*/		return 0x821EBC58;
		  /* 821EBC58h */ case    1:  		/* b -630256 */
		/* 821EBC58h case    1:*/		return 0x82151E68;
		/* 821EBC58h case    1:*/		return 0x821EBC5C;
		  /* 821EBC5Ch */ case    2:  		/* nop */
		/* 821EBC5Ch case    2:*/		cpu::op::nop();
		/* 821EBC5Ch case    2:*/		return 0x821EBC60;
	}
	return 0x821EBC60;
} // Block from 821EBC54h-821EBC60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC60h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC60);
		  /* 821EBC60h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBC60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBC60h case    0:*/		return 0x821EBC64;
		  /* 821EBC64h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 821EBC64h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBC90;  }
		/* 821EBC64h case    1:*/		return 0x821EBC68;
		  /* 821EBC68h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBC68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBC68h case    2:*/		return 0x821EBC6C;
		  /* 821EBC6Ch */ case    3:  		/* cmpwi CR6, R11, 14 */
		/* 821EBC6Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821EBC6Ch case    3:*/		return 0x821EBC70;
		  /* 821EBC70h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 821EBC70h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBC90;  }
		/* 821EBC70h case    4:*/		return 0x821EBC74;
		  /* 821EBC74h */ case    5:  		/* lwz R11, <#[R4 + 28]> */
		/* 821EBC74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821EBC74h case    5:*/		return 0x821EBC78;
		  /* 821EBC78h */ case    6:  		/* cmpw CR6, R11, R5 */
		/* 821EBC78h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 821EBC78h case    6:*/		return 0x821EBC7C;
		  /* 821EBC7Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBC7Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821EBC88;  }
		/* 821EBC7Ch case    7:*/		return 0x821EBC80;
		  /* 821EBC80h */ case    8:  		/* li R4, 4801 */
		/* 821EBC80h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBC80h case    8:*/		return 0x821EBC84;
		  /* 821EBC84h */ case    9:  		/* b -630300 */
		/* 821EBC84h case    9:*/		return 0x82151E68;
		/* 821EBC84h case    9:*/		return 0x821EBC88;
	}
	return 0x821EBC88;
} // Block from 821EBC60h-821EBC88h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC88);
		  /* 821EBC88h */ case    0:  		/* mr R3, R4 */
		/* 821EBC88h case    0:*/		regs.R3 = regs.R4;
		/* 821EBC88h case    0:*/		return 0x821EBC8C;
		  /* 821EBC8Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBC8Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBC8Ch case    1:*/		return 0x821EBC90;
	}
	return 0x821EBC90;
} // Block from 821EBC88h-821EBC90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC90);
		  /* 821EBC90h */ case    0:  		/* li R4, 4801 */
		/* 821EBC90h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBC90h case    0:*/		return 0x821EBC94;
		  /* 821EBC94h */ case    1:  		/* b -630316 */
		/* 821EBC94h case    1:*/		return 0x82151E68;
		/* 821EBC94h case    1:*/		return 0x821EBC98;
	}
	return 0x821EBC98;
} // Block from 821EBC90h-821EBC98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBC98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBC98);
		  /* 821EBC98h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBC98h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBC98h case    0:*/		return 0x821EBC9C;
		  /* 821EBC9Ch */ case    1:  		/* bc 12, CR6_EQ, 72 */
		/* 821EBC9Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBCE4;  }
		/* 821EBC9Ch case    1:*/		return 0x821EBCA0;
		  /* 821EBCA0h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBCA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBCA0h case    2:*/		return 0x821EBCA4;
		  /* 821EBCA4h */ case    3:  		/* cmpwi CR6, R11, 14 */
		/* 821EBCA4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821EBCA4h case    3:*/		return 0x821EBCA8;
		  /* 821EBCA8h */ case    4:  		/* bc 4, CR6_EQ, 60 */
		/* 821EBCA8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBCE4;  }
		/* 821EBCA8h case    4:*/		return 0x821EBCAC;
		  /* 821EBCACh */ case    5:  		/* lwz R11, <#[R4 + 28]> */
		/* 821EBCACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821EBCACh case    5:*/		return 0x821EBCB0;
		  /* 821EBCB0h */ case    6:  		/* cmpw CR6, R11, R5 */
		/* 821EBCB0h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R5);
		/* 821EBCB0h case    6:*/		return 0x821EBCB4;
		  /* 821EBCB4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBCB4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821EBCC0;  }
		/* 821EBCB4h case    7:*/		return 0x821EBCB8;
		  /* 821EBCB8h */ case    8:  		/* li R4, 4801 */
		/* 821EBCB8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBCB8h case    8:*/		return 0x821EBCBC;
		  /* 821EBCBCh */ case    9:  		/* b -630356 */
		/* 821EBCBCh case    9:*/		return 0x82151E68;
		/* 821EBCBCh case    9:*/		return 0x821EBCC0;
	}
	return 0x821EBCC0;
} // Block from 821EBC98h-821EBCC0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EBCC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBCC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBCC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBCC0);
		  /* 821EBCC0h */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EBCC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EBCC0h case    0:*/		return 0x821EBCC4;
		  /* 821EBCC4h */ case    1:  		/* lwz R10, <#[R4 + 20]> */
		/* 821EBCC4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 821EBCC4h case    1:*/		return 0x821EBCC8;
		  /* 821EBCC8h */ case    2:  		/* mullw R11, R11, R10 */
		/* 821EBCC8h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821EBCC8h case    2:*/		return 0x821EBCCC;
		  /* 821EBCCCh */ case    3:  		/* cmplw CR6, R11, R6 */
		/* 821EBCCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 821EBCCCh case    3:*/		return 0x821EBCD0;
		  /* 821EBCD0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBCD0h case    4:*/		if ( regs.CR[6].eq ) { return 0x821EBCDC;  }
		/* 821EBCD0h case    4:*/		return 0x821EBCD4;
		  /* 821EBCD4h */ case    5:  		/* li R4, 4801 */
		/* 821EBCD4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBCD4h case    5:*/		return 0x821EBCD8;
		  /* 821EBCD8h */ case    6:  		/* b -630384 */
		/* 821EBCD8h case    6:*/		return 0x82151E68;
		/* 821EBCD8h case    6:*/		return 0x821EBCDC;
	}
	return 0x821EBCDC;
} // Block from 821EBCC0h-821EBCDCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBCDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBCDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBCDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBCDC);
		  /* 821EBCDCh */ case    0:  		/* mr R3, R4 */
		/* 821EBCDCh case    0:*/		regs.R3 = regs.R4;
		/* 821EBCDCh case    0:*/		return 0x821EBCE0;
		  /* 821EBCE0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBCE0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBCE0h case    1:*/		return 0x821EBCE4;
	}
	return 0x821EBCE4;
} // Block from 821EBCDCh-821EBCE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBCE4);
		  /* 821EBCE4h */ case    0:  		/* li R4, 4801 */
		/* 821EBCE4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBCE4h case    0:*/		return 0x821EBCE8;
		  /* 821EBCE8h */ case    1:  		/* b -630400 */
		/* 821EBCE8h case    1:*/		return 0x82151E68;
		/* 821EBCE8h case    1:*/		return 0x821EBCEC;
		  /* 821EBCECh */ case    2:  		/* nop */
		/* 821EBCECh case    2:*/		cpu::op::nop();
		/* 821EBCECh case    2:*/		return 0x821EBCF0;
	}
	return 0x821EBCF0;
} // Block from 821EBCE4h-821EBCF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBCF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBCF0);
		  /* 821EBCF0h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBCF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBCF0h case    0:*/		return 0x821EBCF4;
		  /* 821EBCF4h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821EBCF4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBD0C;  }
		/* 821EBCF4h case    1:*/		return 0x821EBCF8;
		  /* 821EBCF8h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBCF8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBCF8h case    2:*/		return 0x821EBCFC;
		  /* 821EBCFCh */ case    3:  		/* cmpwi CR6, R11, 9 */
		/* 821EBCFCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 821EBCFCh case    3:*/		return 0x821EBD00;
		  /* 821EBD00h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBD00h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBD0C;  }
		/* 821EBD00h case    4:*/		return 0x821EBD04;
		  /* 821EBD04h */ case    5:  		/* mr R3, R4 */
		/* 821EBD04h case    5:*/		regs.R3 = regs.R4;
		/* 821EBD04h case    5:*/		return 0x821EBD08;
		  /* 821EBD08h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821EBD08h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBD08h case    6:*/		return 0x821EBD0C;
	}
	return 0x821EBD0C;
} // Block from 821EBCF0h-821EBD0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD0C);
		  /* 821EBD0Ch */ case    0:  		/* li R4, 4801 */
		/* 821EBD0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBD0Ch case    0:*/		return 0x821EBD10;
		  /* 821EBD10h */ case    1:  		/* b -630440 */
		/* 821EBD10h case    1:*/		return 0x82151E68;
		/* 821EBD10h case    1:*/		return 0x821EBD14;
		  /* 821EBD14h */ case    2:  		/* nop */
		/* 821EBD14h case    2:*/		cpu::op::nop();
		/* 821EBD14h case    2:*/		return 0x821EBD18;
	}
	return 0x821EBD18;
} // Block from 821EBD0Ch-821EBD18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD18h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD18);
		  /* 821EBD18h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBD18h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBD18h case    0:*/		return 0x821EBD1C;
		  /* 821EBD1Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821EBD1Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBD34;  }
		/* 821EBD1Ch case    1:*/		return 0x821EBD20;
		  /* 821EBD20h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBD20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBD20h case    2:*/		return 0x821EBD24;
		  /* 821EBD24h */ case    3:  		/* cmpwi CR6, R11, 15 */
		/* 821EBD24h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 821EBD24h case    3:*/		return 0x821EBD28;
		  /* 821EBD28h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBD28h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBD34;  }
		/* 821EBD28h case    4:*/		return 0x821EBD2C;
		  /* 821EBD2Ch */ case    5:  		/* mr R3, R4 */
		/* 821EBD2Ch case    5:*/		regs.R3 = regs.R4;
		/* 821EBD2Ch case    5:*/		return 0x821EBD30;
		  /* 821EBD30h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821EBD30h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBD30h case    6:*/		return 0x821EBD34;
	}
	return 0x821EBD34;
} // Block from 821EBD18h-821EBD34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD34);
		  /* 821EBD34h */ case    0:  		/* li R4, 4801 */
		/* 821EBD34h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBD34h case    0:*/		return 0x821EBD38;
		  /* 821EBD38h */ case    1:  		/* b -630480 */
		/* 821EBD38h case    1:*/		return 0x82151E68;
		/* 821EBD38h case    1:*/		return 0x821EBD3C;
		  /* 821EBD3Ch */ case    2:  		/* nop */
		/* 821EBD3Ch case    2:*/		cpu::op::nop();
		/* 821EBD3Ch case    2:*/		return 0x821EBD40;
	}
	return 0x821EBD40;
} // Block from 821EBD34h-821EBD40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD40);
		  /* 821EBD40h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBD40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBD40h case    0:*/		return 0x821EBD44;
		  /* 821EBD44h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821EBD44h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBD5C;  }
		/* 821EBD44h case    1:*/		return 0x821EBD48;
		  /* 821EBD48h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBD48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBD48h case    2:*/		return 0x821EBD4C;
		  /* 821EBD4Ch */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 821EBD4Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EBD4Ch case    3:*/		return 0x821EBD50;
		  /* 821EBD50h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBD50h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBD5C;  }
		/* 821EBD50h case    4:*/		return 0x821EBD54;
		  /* 821EBD54h */ case    5:  		/* mr R3, R4 */
		/* 821EBD54h case    5:*/		regs.R3 = regs.R4;
		/* 821EBD54h case    5:*/		return 0x821EBD58;
		  /* 821EBD58h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821EBD58h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBD58h case    6:*/		return 0x821EBD5C;
	}
	return 0x821EBD5C;
} // Block from 821EBD40h-821EBD5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD5C);
		  /* 821EBD5Ch */ case    0:  		/* li R4, 4801 */
		/* 821EBD5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBD5Ch case    0:*/		return 0x821EBD60;
		  /* 821EBD60h */ case    1:  		/* b -630520 */
		/* 821EBD60h case    1:*/		return 0x82151E68;
		/* 821EBD60h case    1:*/		return 0x821EBD64;
		  /* 821EBD64h */ case    2:  		/* nop */
		/* 821EBD64h case    2:*/		cpu::op::nop();
		/* 821EBD64h case    2:*/		return 0x821EBD68;
	}
	return 0x821EBD68;
} // Block from 821EBD5Ch-821EBD68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD68);
		  /* 821EBD68h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EBD68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBD68h case    0:*/		return 0x821EBD6C;
		  /* 821EBD6Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821EBD6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821EBD84;  }
		/* 821EBD6Ch case    1:*/		return 0x821EBD70;
		  /* 821EBD70h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBD70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBD70h case    2:*/		return 0x821EBD74;
		  /* 821EBD74h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 821EBD74h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EBD74h case    3:*/		return 0x821EBD78;
		  /* 821EBD78h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBD78h case    4:*/		if ( regs.CR[6].eq ) { return 0x821EBD84;  }
		/* 821EBD78h case    4:*/		return 0x821EBD7C;
		  /* 821EBD7Ch */ case    5:  		/* li R4, 4801 */
		/* 821EBD7Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBD7Ch case    5:*/		return 0x821EBD80;
		  /* 821EBD80h */ case    6:  		/* b -630552 */
		/* 821EBD80h case    6:*/		return 0x82151E68;
		/* 821EBD80h case    6:*/		return 0x821EBD84;
	}
	return 0x821EBD84;
} // Block from 821EBD68h-821EBD84h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD84);
		  /* 821EBD84h */ case    0:  		/* mr R3, R4 */
		/* 821EBD84h case    0:*/		regs.R3 = regs.R4;
		/* 821EBD84h case    0:*/		return 0x821EBD88;
		  /* 821EBD88h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBD88h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBD88h case    1:*/		return 0x821EBD8C;
	}
	return 0x821EBD8C;
} // Block from 821EBD84h-821EBD8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD8C);
		  /* 821EBD8Ch */ case    0:  		/* nop */
		/* 821EBD8Ch case    0:*/		cpu::op::nop();
		/* 821EBD8Ch case    0:*/		return 0x821EBD90;
	}
	return 0x821EBD90;
} // Block from 821EBD8Ch-821EBD90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EBD90h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBD90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBD90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBD90);
		  /* 821EBD90h */ case    0:  		/* mfspr R12, LR */
		/* 821EBD90h case    0:*/		regs.R12 = regs.LR;
		/* 821EBD90h case    0:*/		return 0x821EBD94;
		  /* 821EBD94h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EBD94h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EBD94h case    1:*/		return 0x821EBD98;
		  /* 821EBD98h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821EBD98h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821EBD98h case    2:*/		return 0x821EBD9C;
		  /* 821EBD9Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821EBD9Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBD9Ch case    3:*/		return 0x821EBDA0;
		  /* 821EBDA0h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EBDA0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EBDA0h case    4:*/		return 0x821EBDA4;
		  /* 821EBDA4h */ case    5:  		/* mr R31, R3 */
		/* 821EBDA4h case    5:*/		regs.R31 = regs.R3;
		/* 821EBDA4h case    5:*/		return 0x821EBDA8;
		  /* 821EBDA8h */ case    6:  		/* mr R30, R5 */
		/* 821EBDA8h case    6:*/		regs.R30 = regs.R5;
		/* 821EBDA8h case    6:*/		return 0x821EBDAC;
		  /* 821EBDACh */ case    7:  		/* li R11, 0 */
		/* 821EBDACh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821EBDACh case    7:*/		return 0x821EBDB0;
		  /* 821EBDB0h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 821EBDB0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EBDB0h case    8:*/		return 0x821EBDB4;
		  /* 821EBDB4h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 821EBDB4h case    9:*/		if ( regs.CR[6].eq ) { return 0x821EBDD8;  }
		/* 821EBDB4h case    9:*/		return 0x821EBDB8;
		  /* 821EBDB8h */ case   10:  		/* lwz R3, <#[R4 + 24]> */
		/* 821EBDB8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000018) );
		/* 821EBDB8h case   10:*/		return 0x821EBDBC;
		  /* 821EBDBCh */ case   11:  		/* addi R5, R1, 80 */
		/* 821EBDBCh case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821EBDBCh case   11:*/		return 0x821EBDC0;
		  /* 821EBDC0h */ case   12:  		/* li R4, 0 */
		/* 821EBDC0h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821EBDC0h case   12:*/		return 0x821EBDC4;
		  /* 821EBDC4h */ case   13:  		/* bl -1364020 */
		/* 821EBDC4h case   13:*/		regs.LR = 0x821EBDC8; return 0x8209ED90;
		/* 821EBDC4h case   13:*/		return 0x821EBDC8;
		  /* 821EBDC8h */ case   14:  		/* lwz R11, <#[R1 + 84]> */
		/* 821EBDC8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821EBDC8h case   14:*/		return 0x821EBDCC;
		  /* 821EBDCCh */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 821EBDCCh case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821EBDCCh case   15:*/		return 0x821EBDD0;
		  /* 821EBDD0h */ case   16:  		/* bc 4, CR0_LT, 8 */
		/* 821EBDD0h case   16:*/		if ( !regs.CR[0].lt ) { return 0x821EBDD8;  }
		/* 821EBDD0h case   16:*/		return 0x821EBDD4;
		  /* 821EBDD4h */ case   17:  		/* li R11, -1 */
		/* 821EBDD4h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 821EBDD4h case   17:*/		return 0x821EBDD8;
	}
	return 0x821EBDD8;
} // Block from 821EBD90h-821EBDD8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EBDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBDD8);
		  /* 821EBDD8h */ case    0:  		/* rlwinm. R10, R11, 0, 0, 15 */
		/* 821EBDD8h case    0:*/		cpu::op::rlwinm<1,0,0,15>(regs,&regs.R10,regs.R11);
		/* 821EBDD8h case    0:*/		return 0x821EBDDC;
		  /* 821EBDDCh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821EBDDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821EBDF0;  }
		/* 821EBDDCh case    1:*/		return 0x821EBDE0;
		  /* 821EBDE0h */ case    2:  		/* lwz R9, <#[R31 + 48]> */
		/* 821EBDE0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 821EBDE0h case    2:*/		return 0x821EBDE4;
		  /* 821EBDE4h */ case    3:  		/* rlwinm R9, R9, 0, 0, 15 */
		/* 821EBDE4h case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R9,regs.R9);
		/* 821EBDE4h case    3:*/		return 0x821EBDE8;
		  /* 821EBDE8h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 821EBDE8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821EBDE8h case    4:*/		return 0x821EBDEC;
		  /* 821EBDECh */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 821EBDECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EBE04;  }
		/* 821EBDECh case    5:*/		return 0x821EBDF0;
	}
	return 0x821EBDF0;
} // Block from 821EBDD8h-821EBDF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EBDF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBDF0);
		  /* 821EBDF0h */ case    0:  		/* rlwinm. R10, R11, 0, 16, 31 */
		/* 821EBDF0h case    0:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R10,regs.R11);
		/* 821EBDF0h case    0:*/		return 0x821EBDF4;
		  /* 821EBDF4h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 821EBDF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821EBE0C;  }
		/* 821EBDF4h case    1:*/		return 0x821EBDF8;
	}
	return 0x821EBDF8;
} // Block from 821EBDF0h-821EBDF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBDF8h
// Function '?RebuildDominanceGraph@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBDF8);
		  /* 821EBDF8h */ case    0:  		/* lhz R9, <#[R31 + 50]> */
		/* 821EBDF8h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000032) );
		/* 821EBDF8h case    0:*/		return 0x821EBDFC;
		  /* 821EBDFCh */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 821EBDFCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821EBDFCh case    1:*/		return 0x821EBE00;
		  /* 821EBE00h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBE00h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EBE0C;  }
		/* 821EBE00h case    2:*/		return 0x821EBE04;
	}
	return 0x821EBE04;
} // Block from 821EBDF8h-821EBE04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBE04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBE04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBE04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBE04);
		  /* 821EBE04h */ case    0:  		/* li R3, 0 */
		/* 821EBE04h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBE04h case    0:*/		return 0x821EBE08;
		  /* 821EBE08h */ case    1:  		/* b 12 */
		/* 821EBE08h case    1:*/		return 0x821EBE14;
		/* 821EBE08h case    1:*/		return 0x821EBE0C;
	}
	return 0x821EBE0C;
} // Block from 821EBE04h-821EBE0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBE0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBE0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBE0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBE0C);
		  /* 821EBE0Ch */ case    0:  		/* stw R11, <#[R30]> */
		/* 821EBE0Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821EBE0Ch case    0:*/		return 0x821EBE10;
		  /* 821EBE10h */ case    1:  		/* li R3, 1 */
		/* 821EBE10h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EBE10h case    1:*/		return 0x821EBE14;
	}
	return 0x821EBE14;
} // Block from 821EBE0Ch-821EBE14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBE14);
		  /* 821EBE14h */ case    0:  		/* addi R1, R1, 128 */
		/* 821EBE14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EBE14h case    0:*/		return 0x821EBE18;
		  /* 821EBE18h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EBE18h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EBE18h case    1:*/		return 0x821EBE1C;
		  /* 821EBE1Ch */ case    2:  		/* mtspr LR, R12 */
		/* 821EBE1Ch case    2:*/		regs.LR = regs.R12;
		/* 821EBE1Ch case    2:*/		return 0x821EBE20;
		  /* 821EBE20h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821EBE20h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821EBE20h case    3:*/		return 0x821EBE24;
		  /* 821EBE24h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821EBE24h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBE24h case    4:*/		return 0x821EBE28;
		  /* 821EBE28h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821EBE28h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBE28h case    5:*/		return 0x821EBE2C;
	}
	return 0x821EBE2C;
} // Block from 821EBE14h-821EBE2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EBE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBE2C);
		  /* 821EBE2Ch */ case    0:  		/* nop */
		/* 821EBE2Ch case    0:*/		cpu::op::nop();
		/* 821EBE2Ch case    0:*/		return 0x821EBE30;
		  /* 821EBE30h */ case    1:  		/* b 80 */
		/* 821EBE30h case    1:*/		return 0x821EBE80;
		/* 821EBE30h case    1:*/		return 0x821EBE34;
		  /* 821EBE34h */ case    2:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EBE34h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EBE34h case    2:*/		return 0x821EBE38;
		  /* 821EBE38h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821EBE38h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBE38h case    3:*/		return 0x821EBE3C;
		  /* 821EBE3Ch */ case    4:  		/* bc 4, CR6_EQ, 112 */
		/* 821EBE3Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBEAC;  }
		/* 821EBE3Ch case    4:*/		return 0x821EBE40;
		  /* 821EBE40h */ case    5:  		/* lwz R11, <#[R4 + 8]> */
		/* 821EBE40h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821EBE40h case    5:*/		return 0x821EBE44;
		  /* 821EBE44h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821EBE44h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBE44h case    6:*/		return 0x821EBE48;
		  /* 821EBE48h */ case    7:  		/* bc 12, CR6_EQ, 124 */
		/* 821EBE48h case    7:*/		if ( regs.CR[6].eq ) { return 0x821EBEC4;  }
		/* 821EBE48h case    7:*/		return 0x821EBE4C;
		  /* 821EBE4Ch */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EBE4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EBE4Ch case    8:*/		return 0x821EBE50;
		  /* 821EBE50h */ case    9:  		/* cmpwi CR6, R10, 6 */
		/* 821EBE50h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000006);
		/* 821EBE50h case    9:*/		return 0x821EBE54;
		  /* 821EBE54h */ case   10:  		/* bc 4, CR6_EQ, 112 */
		/* 821EBE54h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821EBEC4;  }
		/* 821EBE54h case   10:*/		return 0x821EBE58;
		  /* 821EBE58h */ case   11:  		/* lwz R10, <#[R11 + 16]> */
		/* 821EBE58h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821EBE58h case   11:*/		return 0x821EBE5C;
		  /* 821EBE5Ch */ case   12:  		/* cmpwi CR6, R10, 1 */
		/* 821EBE5Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821EBE5Ch case   12:*/		return 0x821EBE60;
		  /* 821EBE60h */ case   13:  		/* bc 4, CR6_EQ, 84 */
		/* 821EBE60h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821EBEB4;  }
		/* 821EBE60h case   13:*/		return 0x821EBE64;
		  /* 821EBE64h */ case   14:  		/* lwz R11, <#[R11 + 24]> */
		/* 821EBE64h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821EBE64h case   14:*/		return 0x821EBE68;
		  /* 821EBE68h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EBE68h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBE68h case   15:*/		return 0x821EBE6C;
		  /* 821EBE6Ch */ case   16:  		/* bc 12, CR6_EQ, 80 */
		/* 821EBE6Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x821EBEBC;  }
		/* 821EBE6Ch case   16:*/		return 0x821EBE70;
		  /* 821EBE70h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EBE70h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EBE70h case   17:*/		return 0x821EBE74;
		  /* 821EBE74h */ case   18:  		/* cmpwi CR6, R10, 11 */
		/* 821EBE74h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000B);
		/* 821EBE74h case   18:*/		return 0x821EBE78;
		  /* 821EBE78h */ case   19:  		/* bc 4, CR6_EQ, 68 */
		/* 821EBE78h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821EBEBC;  }
		/* 821EBE78h case   19:*/		return 0x821EBE7C;
		  /* 821EBE7Ch */ case   20:  		/* lwz R4, <#[R11 + 48]> */
		/* 821EBE7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000030) );
		/* 821EBE7Ch case   20:*/		return 0x821EBE80;
	}
	return 0x821EBE80;
} // Block from 821EBE2Ch-821EBE80h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EBE80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBE80);
		  /* 821EBE80h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBE80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBE80h case    0:*/		return 0x821EBE84;
		  /* 821EBE84h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 821EBE84h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EBE84h case    1:*/		return 0x821EBE88;
		  /* 821EBE88h */ case    2:  		/* bc 12, CR6_EQ, -84 */
		/* 821EBE88h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EBE34;  }
		/* 821EBE88h case    2:*/		return 0x821EBE8C;
		  /* 821EBE8Ch */ case    3:  		/* cmpwi CR6, R11, 9 */
		/* 821EBE8Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000009);
		/* 821EBE8Ch case    3:*/		return 0x821EBE90;
		  /* 821EBE90h */ case    4:  		/* bc 4, CR6_EQ, 60 */
		/* 821EBE90h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBECC;  }
		/* 821EBE90h case    4:*/		return 0x821EBE94;
		  /* 821EBE94h */ case    5:  		/* lwz R11, <#[R4 + 28]> */
		/* 821EBE94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821EBE94h case    5:*/		return 0x821EBE98;
		  /* 821EBE98h */ case    6:  		/* li R3, 1 */
		/* 821EBE98h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EBE98h case    6:*/		return 0x821EBE9C;
		  /* 821EBE9Ch */ case    7:  		/* stw R11, <#[R5]> */
		/* 821EBE9Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EBE9Ch case    7:*/		return 0x821EBEA0;
		  /* 821EBEA0h */ case    8:  		/* lwz R11, <#[R4 + 32]> */
		/* 821EBEA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 821EBEA0h case    8:*/		return 0x821EBEA4;
		  /* 821EBEA4h */ case    9:  		/* stw R11, <#[R6]> */
		/* 821EBEA4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 821EBEA4h case    9:*/		return 0x821EBEA8;
	}
	return 0x821EBEA8;
} // Block from 821EBE80h-821EBEA8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EBEA8h
// Function '?BuildDominanceFrontierSets@Compiler@D3DXShader@@AAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBEA8);
		  /* 821EBEA8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 821EBEA8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBEA8h case    0:*/		return 0x821EBEAC;
	}
	return 0x821EBEAC;
} // Block from 821EBEA8h-821EBEACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EBEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBEAC);
		  /* 821EBEACh */ case    0:  		/* li R3, 0 */
		/* 821EBEACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBEACh case    0:*/		return 0x821EBEB0;
		  /* 821EBEB0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBEB0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBEB0h case    1:*/		return 0x821EBEB4;
	}
	return 0x821EBEB4;
} // Block from 821EBEACh-821EBEB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBEB4);
		  /* 821EBEB4h */ case    0:  		/* li R4, 4801 */
		/* 821EBEB4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBEB4h case    0:*/		return 0x821EBEB8;
		  /* 821EBEB8h */ case    1:  		/* b -630864 */
		/* 821EBEB8h case    1:*/		return 0x82151E68;
		/* 821EBEB8h case    1:*/		return 0x821EBEBC;
	}
	return 0x821EBEBC;
} // Block from 821EBEB4h-821EBEBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBEBC);
		  /* 821EBEBCh */ case    0:  		/* li R4, 4801 */
		/* 821EBEBCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBEBCh case    0:*/		return 0x821EBEC0;
		  /* 821EBEC0h */ case    1:  		/* b -630872 */
		/* 821EBEC0h case    1:*/		return 0x82151E68;
		/* 821EBEC0h case    1:*/		return 0x821EBEC4;
	}
	return 0x821EBEC4;
} // Block from 821EBEBCh-821EBEC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBEC4);
		  /* 821EBEC4h */ case    0:  		/* li R4, 4801 */
		/* 821EBEC4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBEC4h case    0:*/		return 0x821EBEC8;
		  /* 821EBEC8h */ case    1:  		/* b -630880 */
		/* 821EBEC8h case    1:*/		return 0x82151E68;
		/* 821EBEC8h case    1:*/		return 0x821EBECC;
	}
	return 0x821EBECC;
} // Block from 821EBEC4h-821EBECCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBECC);
		  /* 821EBECCh */ case    0:  		/* li R4, 4801 */
		/* 821EBECCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EBECCh case    0:*/		return 0x821EBED0;
		  /* 821EBED0h */ case    1:  		/* b -630888 */
		/* 821EBED0h case    1:*/		return 0x82151E68;
		/* 821EBED0h case    1:*/		return 0x821EBED4;
		  /* 821EBED4h */ case    2:  		/* nop */
		/* 821EBED4h case    2:*/		cpu::op::nop();
		/* 821EBED4h case    2:*/		return 0x821EBED8;
		  /* 821EBED8h */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBED8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBED8h case    3:*/		return 0x821EBEDC;
		  /* 821EBEDCh */ case    4:  		/* cmpwi CR6, R11, 14 */
		/* 821EBEDCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821EBEDCh case    4:*/		return 0x821EBEE0;
		  /* 821EBEE0h */ case    5:  		/* bc 12, CR6_EQ, 92 */
		/* 821EBEE0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821EBF3C;  }
		/* 821EBEE0h case    5:*/		return 0x821EBEE4;
		  /* 821EBEE4h */ case    6:  		/* cmpwi CR6, R11, 15 */
		/* 821EBEE4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 821EBEE4h case    6:*/		return 0x821EBEE8;
		  /* 821EBEE8h */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 821EBEE8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821EBF00;  }
		/* 821EBEE8h case    7:*/		return 0x821EBEEC;
		  /* 821EBEECh */ case    8:  		/* lwz R11, <#[R4 + 16]> */
		/* 821EBEECh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821EBEECh case    8:*/		return 0x821EBEF0;
		  /* 821EBEF0h */ case    9:  		/* cmplwi CR6, R11, 4 */
		/* 821EBEF0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821EBEF0h case    9:*/		return 0x821EBEF4;
		  /* 821EBEF4h */ case   10:  		/* bc 12, CR6_LT, 64 */
		/* 821EBEF4h case   10:*/		if ( regs.CR[6].lt ) { return 0x821EBF34;  }
		/* 821EBEF4h case   10:*/		return 0x821EBEF8;
		  /* 821EBEF8h */ case   11:  		/* cmplwi CR6, R11, 6 */
		/* 821EBEF8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 821EBEF8h case   11:*/		return 0x821EBEFC;
		  /* 821EBEFCh */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBEFCh case   12:*/		if ( regs.CR[6].eq ) { return 0x821EBF08;  }
		/* 821EBEFCh case   12:*/		return 0x821EBF00;
	}
	return 0x821EBF00;
} // Block from 821EBECCh-821EBF00h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF00);
		  /* 821EBF00h */ case    0:  		/* li R3, 0 */
		/* 821EBF00h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBF00h case    0:*/		return 0x821EBF04;
		  /* 821EBF04h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBF04h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBF04h case    1:*/		return 0x821EBF08;
	}
	return 0x821EBF08;
} // Block from 821EBF00h-821EBF08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF08);
		  /* 821EBF08h */ case    0:  		/* lwz R11, <#[R4 + 28]> */
		/* 821EBF08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821EBF08h case    0:*/		return 0x821EBF0C;
		  /* 821EBF0Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EBF0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBF0Ch case    1:*/		return 0x821EBF10;
		  /* 821EBF10h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 821EBF10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EBF1C;  }
		/* 821EBF10h case    2:*/		return 0x821EBF14;
		  /* 821EBF14h */ case    3:  		/* stw R11, <#[R5]> */
		/* 821EBF14h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EBF14h case    3:*/		return 0x821EBF18;
		  /* 821EBF18h */ case    4:  		/* b 48 */
		/* 821EBF18h case    4:*/		return 0x821EBF48;
		/* 821EBF18h case    4:*/		return 0x821EBF1C;
	}
	return 0x821EBF1C;
} // Block from 821EBF08h-821EBF1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF1C);
		  /* 821EBF1Ch */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EBF1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EBF1Ch case    0:*/		return 0x821EBF20;
		  /* 821EBF20h */ case    1:  		/* lwz R10, <#[R3 + 12]> */
		/* 821EBF20h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821EBF20h case    1:*/		return 0x821EBF24;
		  /* 821EBF24h */ case    2:  		/* mulli R11, R11, 40 */
		/* 821EBF24h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x28);
		/* 821EBF24h case    2:*/		return 0x821EBF28;
		  /* 821EBF28h */ case    3:  		/* add R11, R11, R10 */
		/* 821EBF28h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821EBF28h case    3:*/		return 0x821EBF2C;
		  /* 821EBF2Ch */ case    4:  		/* lwz R4, <#[R11 + 20]> */
		/* 821EBF2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000014) );
		/* 821EBF2Ch case    4:*/		return 0x821EBF30;
		  /* 821EBF30h */ case    5:  		/* b -256 */
		/* 821EBF30h case    5:*/		return 0x821EBE30;
		/* 821EBF30h case    5:*/		return 0x821EBF34;
	}
	return 0x821EBF34;
} // Block from 821EBF1Ch-821EBF34h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF34);
		  /* 821EBF34h */ case    0:  		/* li R11, 1 */
		/* 821EBF34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821EBF34h case    0:*/		return 0x821EBF38;
		  /* 821EBF38h */ case    1:  		/* b -36 */
		/* 821EBF38h case    1:*/		return 0x821EBF14;
		/* 821EBF38h case    1:*/		return 0x821EBF3C;
	}
	return 0x821EBF3C;
} // Block from 821EBF34h-821EBF3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF3C);
		  /* 821EBF3Ch */ case    0:  		/* lwz R11, <#[R4 + 20]> */
		/* 821EBF3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821EBF3Ch case    0:*/		return 0x821EBF40;
		  /* 821EBF40h */ case    1:  		/* stw R11, <#[R5]> */
		/* 821EBF40h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EBF40h case    1:*/		return 0x821EBF44;
		  /* 821EBF44h */ case    2:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EBF44h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EBF44h case    2:*/		return 0x821EBF48;
	}
	return 0x821EBF48;
} // Block from 821EBF3Ch-821EBF48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF48);
		  /* 821EBF48h */ case    0:  		/* li R3, 1 */
		/* 821EBF48h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EBF48h case    0:*/		return 0x821EBF4C;
		  /* 821EBF4Ch */ case    1:  		/* stw R11, <#[R6]> */
		/* 821EBF4Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 821EBF4Ch case    1:*/		return 0x821EBF50;
		  /* 821EBF50h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821EBF50h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBF50h case    2:*/		return 0x821EBF54;
	}
	return 0x821EBF54;
} // Block from 821EBF48h-821EBF54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF54);
		  /* 821EBF54h */ case    0:  		/* nop */
		/* 821EBF54h case    0:*/		cpu::op::nop();
		/* 821EBF54h case    0:*/		return 0x821EBF58;
		  /* 821EBF58h */ case    1:  		/* b 20 */
		/* 821EBF58h case    1:*/		return 0x821EBF6C;
		/* 821EBF58h case    1:*/		return 0x821EBF5C;
		  /* 821EBF5Ch */ case    2:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EBF5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EBF5Ch case    2:*/		return 0x821EBF60;
		  /* 821EBF60h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821EBF60h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBF60h case    3:*/		return 0x821EBF64;
		  /* 821EBF64h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821EBF64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EBF7C;  }
		/* 821EBF64h case    4:*/		return 0x821EBF68;
		  /* 821EBF68h */ case    5:  		/* lwz R4, <#[R4 + 8]> */
		/* 821EBF68h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 821EBF68h case    5:*/		return 0x821EBF6C;
	}
	return 0x821EBF6C;
} // Block from 821EBF54h-821EBF6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF6C);
		  /* 821EBF6Ch */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBF6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBF6Ch case    0:*/		return 0x821EBF70;
		  /* 821EBF70h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 821EBF70h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EBF70h case    1:*/		return 0x821EBF74;
		  /* 821EBF74h */ case    2:  		/* bc 12, CR6_EQ, -24 */
		/* 821EBF74h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EBF5C;  }
		/* 821EBF74h case    2:*/		return 0x821EBF78;
		  /* 821EBF78h */ case    3:  		/* b -160 */
		/* 821EBF78h case    3:*/		return 0x821EBED8;
		/* 821EBF78h case    3:*/		return 0x821EBF7C;
	}
	return 0x821EBF7C;
} // Block from 821EBF6Ch-821EBF7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF7C);
		  /* 821EBF7Ch */ case    0:  		/* li R3, 0 */
		/* 821EBF7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBF7Ch case    0:*/		return 0x821EBF80;
		  /* 821EBF80h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EBF80h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EBF80h case    1:*/		return 0x821EBF84;
	}
	return 0x821EBF84;
} // Block from 821EBF7Ch-821EBF84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF84);
		  /* 821EBF84h */ case    0:  		/* nop */
		/* 821EBF84h case    0:*/		cpu::op::nop();
		/* 821EBF84h case    0:*/		return 0x821EBF88;
	}
	return 0x821EBF88;
} // Block from 821EBF84h-821EBF88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EBF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBF88);
		  /* 821EBF88h */ case    0:  		/* mfspr R12, LR */
		/* 821EBF88h case    0:*/		regs.R12 = regs.LR;
		/* 821EBF88h case    0:*/		return 0x821EBF8C;
		  /* 821EBF8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EBF8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EBF8Ch case    1:*/		return 0x821EBF90;
		  /* 821EBF90h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821EBF90h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EBF90h case    2:*/		return 0x821EBF94;
		  /* 821EBF94h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EBF94h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EBF94h case    3:*/		return 0x821EBF98;
		  /* 821EBF98h */ case    4:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EBF98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EBF98h case    4:*/		return 0x821EBF9C;
		  /* 821EBF9Ch */ case    5:  		/* mr R31, R5 */
		/* 821EBF9Ch case    5:*/		regs.R31 = regs.R5;
		/* 821EBF9Ch case    5:*/		return 0x821EBFA0;
		  /* 821EBFA0h */ case    6:  		/* cmpwi CR6, R11, 1 */
		/* 821EBFA0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EBFA0h case    6:*/		return 0x821EBFA4;
		  /* 821EBFA4h */ case    7:  		/* bc 4, CR6_EQ, 44 */
		/* 821EBFA4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821EBFD0;  }
		/* 821EBFA4h case    7:*/		return 0x821EBFA8;
		  /* 821EBFA8h */ case    8:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EBFA8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EBFA8h case    8:*/		return 0x821EBFAC;
		  /* 821EBFACh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 821EBFACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EBFACh case    9:*/		return 0x821EBFB0;
		  /* 821EBFB0h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 821EBFB0h case   10:*/		if ( regs.CR[6].eq ) { return 0x821EBFBC;  }
		/* 821EBFB0h case   10:*/		return 0x821EBFB4;
		  /* 821EBFB4h */ case   11:  		/* li R3, 0 */
		/* 821EBFB4h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBFB4h case   11:*/		return 0x821EBFB8;
		  /* 821EBFB8h */ case   12:  		/* b 36 */
		/* 821EBFB8h case   12:*/		return 0x821EBFDC;
		/* 821EBFB8h case   12:*/		return 0x821EBFBC;
	}
	return 0x821EBFBC;
} // Block from 821EBF88h-821EBFBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821EBFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBFBC);
		  /* 821EBFBCh */ case    0:  		/* addi R6, R1, 80 */
		/* 821EBFBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 821EBFBCh case    0:*/		return 0x821EBFC0;
		  /* 821EBFC0h */ case    1:  		/* lwz R4, <#[R4 + 8]> */
		/* 821EBFC0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 821EBFC0h case    1:*/		return 0x821EBFC4;
		  /* 821EBFC4h */ case    2:  		/* addi R5, R1, 84 */
		/* 821EBFC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 821EBFC4h case    2:*/		return 0x821EBFC8;
		  /* 821EBFC8h */ case    3:  		/* bl -112 */
		/* 821EBFC8h case    3:*/		regs.LR = 0x821EBFCC; return 0x821EBF58;
		/* 821EBFC8h case    3:*/		return 0x821EBFCC;
		  /* 821EBFCCh */ case    4:  		/* b 16 */
		/* 821EBFCCh case    4:*/		return 0x821EBFDC;
		/* 821EBFCCh case    4:*/		return 0x821EBFD0;
	}
	return 0x821EBFD0;
} // Block from 821EBFBCh-821EBFD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EBFD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBFD0);
		  /* 821EBFD0h */ case    0:  		/* addi R6, R1, 80 */
		/* 821EBFD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 821EBFD0h case    0:*/		return 0x821EBFD4;
		  /* 821EBFD4h */ case    1:  		/* addi R5, R1, 84 */
		/* 821EBFD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 821EBFD4h case    1:*/		return 0x821EBFD8;
		  /* 821EBFD8h */ case    2:  		/* bl -256 */
		/* 821EBFD8h case    2:*/		regs.LR = 0x821EBFDC; return 0x821EBED8;
		/* 821EBFD8h case    2:*/		return 0x821EBFDC;
	}
	return 0x821EBFDC;
} // Block from 821EBFD0h-821EBFDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EBFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBFDC);
		  /* 821EBFDCh */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821EBFDCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821EBFDCh case    0:*/		return 0x821EBFE0;
		  /* 821EBFE0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821EBFE0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821EBFEC;  }
		/* 821EBFE0h case    1:*/		return 0x821EBFE4;
		  /* 821EBFE4h */ case    2:  		/* li R3, 0 */
		/* 821EBFE4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EBFE4h case    2:*/		return 0x821EBFE8;
		  /* 821EBFE8h */ case    3:  		/* b 24 */
		/* 821EBFE8h case    3:*/		return 0x821EC000;
		/* 821EBFE8h case    3:*/		return 0x821EBFEC;
	}
	return 0x821EBFEC;
} // Block from 821EBFDCh-821EBFECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EBFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EBFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EBFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EBFEC);
		  /* 821EBFECh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 821EBFECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821EBFECh case    0:*/		return 0x821EBFF0;
		  /* 821EBFF0h */ case    1:  		/* li R3, 1 */
		/* 821EBFF0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EBFF0h case    1:*/		return 0x821EBFF4;
		  /* 821EBFF4h */ case    2:  		/* lwz R10, <#[R1 + 84]> */
		/* 821EBFF4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 821EBFF4h case    2:*/		return 0x821EBFF8;
		  /* 821EBFF8h */ case    3:  		/* mullw R11, R10, R11 */
		/* 821EBFF8h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EBFF8h case    3:*/		return 0x821EBFFC;
		  /* 821EBFFCh */ case    4:  		/* stw R11, <#[R31]> */
		/* 821EBFFCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821EBFFCh case    4:*/		return 0x821EC000;
	}
	return 0x821EC000;
} // Block from 821EBFECh-821EC000h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC000);
		  /* 821EC000h */ case    0:  		/* addi R1, R1, 112 */
		/* 821EC000h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EC000h case    0:*/		return 0x821EC004;
		  /* 821EC004h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EC004h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC004h case    1:*/		return 0x821EC008;
		  /* 821EC008h */ case    2:  		/* mtspr LR, R12 */
		/* 821EC008h case    2:*/		regs.LR = regs.R12;
		/* 821EC008h case    2:*/		return 0x821EC00C;
		  /* 821EC00Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821EC00Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC00Ch case    3:*/		return 0x821EC010;
		  /* 821EC010h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821EC010h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC010h case    4:*/		return 0x821EC014;
	}
	return 0x821EC014;
} // Block from 821EC000h-821EC014h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC014);
		  /* 821EC014h */ case    0:  		/* nop */
		/* 821EC014h case    0:*/		cpu::op::nop();
		/* 821EC014h case    0:*/		return 0x821EC018;
		  /* 821EC018h */ case    1:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EC018h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EC018h case    1:*/		return 0x821EC01C;
		  /* 821EC01Ch */ case    2:  		/* cmpwi CR6, R11, 3 */
		/* 821EC01Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821EC01Ch case    2:*/		return 0x821EC020;
		  /* 821EC020h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 821EC020h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821EC02C;  }
		/* 821EC020h case    3:*/		return 0x821EC024;
		  /* 821EC024h */ case    4:  		/* mr R3, R4 */
		/* 821EC024h case    4:*/		regs.R3 = regs.R4;
		/* 821EC024h case    4:*/		return 0x821EC028;
		  /* 821EC028h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821EC028h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC028h case    5:*/		return 0x821EC02C;
	}
	return 0x821EC02C;
} // Block from 821EC014h-821EC02Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EC02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC02C);
		  /* 821EC02Ch */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 821EC02Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EC02Ch case    0:*/		return 0x821EC030;
		  /* 821EC030h */ case    1:  		/* bc 4, CR6_EQ, 64 */
		/* 821EC030h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821EC070;  }
		/* 821EC030h case    1:*/		return 0x821EC034;
		  /* 821EC034h */ case    2:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EC034h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EC034h case    2:*/		return 0x821EC038;
		  /* 821EC038h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821EC038h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC038h case    3:*/		return 0x821EC03C;
		  /* 821EC03Ch */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 821EC03Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821EC048;  }
		/* 821EC03Ch case    4:*/		return 0x821EC040;
		  /* 821EC040h */ case    5:  		/* li R4, 4801 */
		/* 821EC040h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC040h case    5:*/		return 0x821EC044;
		  /* 821EC044h */ case    6:  		/* b -631260 */
		/* 821EC044h case    6:*/		return 0x82151E68;
		/* 821EC044h case    6:*/		return 0x821EC048;
	}
	return 0x821EC048;
} // Block from 821EC02Ch-821EC048h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EC048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC048);
		  /* 821EC048h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821EC048h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821EC048h case    0:*/		return 0x821EC04C;
		  /* 821EC04Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EC04Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC04Ch case    1:*/		return 0x821EC050;
		  /* 821EC050h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821EC050h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EC068;  }
		/* 821EC050h case    2:*/		return 0x821EC054;
		  /* 821EC054h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC054h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC054h case    3:*/		return 0x821EC058;
		  /* 821EC058h */ case    4:  		/* cmpwi CR6, R10, 3 */
		/* 821EC058h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821EC058h case    4:*/		return 0x821EC05C;
		  /* 821EC05Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 821EC05Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EC068;  }
		/* 821EC05Ch case    5:*/		return 0x821EC060;
		  /* 821EC060h */ case    6:  		/* mr R3, R11 */
		/* 821EC060h case    6:*/		regs.R3 = regs.R11;
		/* 821EC060h case    6:*/		return 0x821EC064;
		  /* 821EC064h */ case    7:  		/* bclr 20, CR0_LT */
		/* 821EC064h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC064h case    7:*/		return 0x821EC068;
	}
	return 0x821EC068;
} // Block from 821EC048h-821EC068h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC068);
		  /* 821EC068h */ case    0:  		/* li R4, 4801 */
		/* 821EC068h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC068h case    0:*/		return 0x821EC06C;
		  /* 821EC06Ch */ case    1:  		/* b -631300 */
		/* 821EC06Ch case    1:*/		return 0x82151E68;
		/* 821EC06Ch case    1:*/		return 0x821EC070;
	}
	return 0x821EC070;
} // Block from 821EC068h-821EC070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC070);
		  /* 821EC070h */ case    0:  		/* li R4, 4801 */
		/* 821EC070h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC070h case    0:*/		return 0x821EC074;
		  /* 821EC074h */ case    1:  		/* b -631308 */
		/* 821EC074h case    1:*/		return 0x82151E68;
		/* 821EC074h case    1:*/		return 0x821EC078;
	}
	return 0x821EC078;
} // Block from 821EC070h-821EC078h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC078);
		  /* 821EC078h */ case    0:  		/* mfspr R12, LR */
		/* 821EC078h case    0:*/		regs.R12 = regs.LR;
		/* 821EC078h case    0:*/		return 0x821EC07C;
		  /* 821EC07Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EC07Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC07Ch case    1:*/		return 0x821EC080;
		  /* 821EC080h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821EC080h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821EC080h case    2:*/		return 0x821EC084;
		  /* 821EC084h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 821EC084h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EC084h case    3:*/		return 0x821EC088;
		  /* 821EC088h */ case    4:  		/* bc 12, CR6_EQ, 120 */
		/* 821EC088h case    4:*/		if ( regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC088h case    4:*/		return 0x821EC08C;
		  /* 821EC08Ch */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EC08Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EC08Ch case    5:*/		return 0x821EC090;
		  /* 821EC090h */ case    6:  		/* cmpwi CR6, R11, 14 */
		/* 821EC090h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821EC090h case    6:*/		return 0x821EC094;
		  /* 821EC094h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821EC094h case    7:*/		if ( regs.CR[6].eq ) { return 0x821EC0A4;  }
		/* 821EC094h case    7:*/		return 0x821EC098;
		  /* 821EC098h */ case    8:  		/* lwz R11, <#[R4 + 28]> */
		/* 821EC098h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821EC098h case    8:*/		return 0x821EC09C;
		  /* 821EC09Ch */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 821EC09Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821EC09Ch case    9:*/		return 0x821EC0A0;
		  /* 821EC0A0h */ case   10:  		/* bc 4, CR6_EQ, 96 */
		/* 821EC0A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC0A0h case   10:*/		return 0x821EC0A4;
	}
	return 0x821EC0A4;
} // Block from 821EC078h-821EC0A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EC0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC0A4);
		  /* 821EC0A4h */ case    0:  		/* lwz R11, <#[R4 + 20]> */
		/* 821EC0A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821EC0A4h case    0:*/		return 0x821EC0A8;
		  /* 821EC0A8h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 821EC0A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821EC0A8h case    1:*/		return 0x821EC0AC;
		  /* 821EC0ACh */ case    2:  		/* bc 4, CR6_EQ, 84 */
		/* 821EC0ACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC0ACh case    2:*/		return 0x821EC0B0;
		  /* 821EC0B0h */ case    3:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC0B0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC0B0h case    3:*/		return 0x821EC0B4;
		  /* 821EC0B4h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 821EC0B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821EC0B4h case    4:*/		return 0x821EC0B8;
		  /* 821EC0B8h */ case    5:  		/* bc 4, CR6_EQ, 72 */
		/* 821EC0B8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC0B8h case    5:*/		return 0x821EC0BC;
		  /* 821EC0BCh */ case    6:  		/* lwz R11, <#[R4 + 16]> */
		/* 821EC0BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821EC0BCh case    6:*/		return 0x821EC0C0;
		  /* 821EC0C0h */ case    7:  		/* li R8, 0 */
		/* 821EC0C0h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821EC0C0h case    7:*/		return 0x821EC0C4;
		  /* 821EC0C4h */ case    8:  		/* li R9, 0 */
		/* 821EC0C4h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821EC0C4h case    8:*/		return 0x821EC0C8;
		  /* 821EC0C8h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 821EC0C8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC0C8h case    9:*/		return 0x821EC0CC;
		  /* 821EC0CCh */ case   10:  		/* bc 12, CR6_EQ, 272 */
		/* 821EC0CCh case   10:*/		if ( regs.CR[6].eq ) { return 0x821EC1DC;  }
		/* 821EC0CCh case   10:*/		return 0x821EC0D0;
		  /* 821EC0D0h */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC0D0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC0D0h case   11:*/		return 0x821EC0D4;
		  /* 821EC0D4h */ case   12:  		/* cmpwi CR6, R10, 9 */
		/* 821EC0D4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 821EC0D4h case   12:*/		return 0x821EC0D8;
		  /* 821EC0D8h */ case   13:  		/* bc 4, CR6_EQ, 260 */
		/* 821EC0D8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821EC1DC;  }
		/* 821EC0D8h case   13:*/		return 0x821EC0DC;
		  /* 821EC0DCh */ case   14:  		/* lwz R11, <#[R11 + 20]> */
		/* 821EC0DCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821EC0DCh case   14:*/		return 0x821EC0E0;
		  /* 821EC0E0h */ case   15:  		/* cmpwi CR6, R11, 1 */
		/* 821EC0E0h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EC0E0h case   15:*/		return 0x821EC0E4;
		  /* 821EC0E4h */ case   16:  		/* bc 12, CR6_EQ, 48 */
		/* 821EC0E4h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EC114;  }
		/* 821EC0E4h case   16:*/		return 0x821EC0E8;
		  /* 821EC0E8h */ case   17:  		/* cmpwi CR6, R11, 2 */
		/* 821EC0E8h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 821EC0E8h case   17:*/		return 0x821EC0EC;
		  /* 821EC0ECh */ case   18:  		/* bc 12, CR6_EQ, 44 */
		/* 821EC0ECh case   18:*/		if ( regs.CR[6].eq ) { return 0x821EC118;  }
		/* 821EC0ECh case   18:*/		return 0x821EC0F0;
		  /* 821EC0F0h */ case   19:  		/* cmpwi CR6, R11, 6 */
		/* 821EC0F0h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 821EC0F0h case   19:*/		return 0x821EC0F4;
		  /* 821EC0F4h */ case   20:  		/* bc 12, CR6_EQ, 32 */
		/* 821EC0F4h case   20:*/		if ( regs.CR[6].eq ) { return 0x821EC114;  }
		/* 821EC0F4h case   20:*/		return 0x821EC0F8;
		  /* 821EC0F8h */ case   21:  		/* cmpwi CR6, R11, 10 */
		/* 821EC0F8h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 821EC0F8h case   21:*/		return 0x821EC0FC;
		  /* 821EC0FCh */ case   22:  		/* bc 12, CR6_EQ, 32 */
		/* 821EC0FCh case   22:*/		if ( regs.CR[6].eq ) { return 0x821EC11C;  }
		/* 821EC0FCh case   22:*/		return 0x821EC100;
	}
	return 0x821EC100;
} // Block from 821EC0A4h-821EC100h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821EC100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC100);
		  /* 821EC100h */ case    0:  		/* li R3, 0 */
		/* 821EC100h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EC100h case    0:*/		return 0x821EC104;
		  /* 821EC104h */ case    1:  		/* addi R1, R1, 96 */
		/* 821EC104h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821EC104h case    1:*/		return 0x821EC108;
		  /* 821EC108h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EC108h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC108h case    2:*/		return 0x821EC10C;
		  /* 821EC10Ch */ case    3:  		/* mtspr LR, R12 */
		/* 821EC10Ch case    3:*/		regs.LR = regs.R12;
		/* 821EC10Ch case    3:*/		return 0x821EC110;
		  /* 821EC110h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821EC110h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC110h case    4:*/		return 0x821EC114;
	}
	return 0x821EC114;
} // Block from 821EC100h-821EC114h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC114);
		  /* 821EC114h */ case    0:  		/* li R8, 1 */
		/* 821EC114h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EC114h case    0:*/		return 0x821EC118;
	}
	return 0x821EC118;
} // Block from 821EC114h-821EC118h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC118);
		  /* 821EC118h */ case    0:  		/* li R9, 1 */
		/* 821EC118h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821EC118h case    0:*/		return 0x821EC11C;
	}
	return 0x821EC11C;
} // Block from 821EC118h-821EC11Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC11Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC11C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC11C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC11C);
		  /* 821EC11Ch */ case    0:  		/* lwz R11, <#[R4 + 32]> */
		/* 821EC11Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 821EC11Ch case    0:*/		return 0x821EC120;
	}
	return 0x821EC120;
} // Block from 821EC11Ch-821EC120h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC120h
// Function '?BuildControlFlowGraphs@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC120);
		  /* 821EC120h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC120h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC120h case    0:*/		return 0x821EC124;
		  /* 821EC124h */ case    1:  		/* cmpwi CR6, R10, 1 */
		/* 821EC124h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821EC124h case    1:*/		return 0x821EC128;
		  /* 821EC128h */ case    2:  		/* bc 4, CR6_EQ, -40 */
		/* 821EC128h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC128h case    2:*/		return 0x821EC12C;
		  /* 821EC12Ch */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 821EC12Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821EC12Ch case    3:*/		return 0x821EC130;
		  /* 821EC130h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821EC130h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821EC130h case    4:*/		return 0x821EC134;
		  /* 821EC134h */ case    5:  		/* bc 4, CR6_EQ, -52 */
		/* 821EC134h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC134h case    5:*/		return 0x821EC138;
		  /* 821EC138h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 821EC138h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821EC138h case    6:*/		return 0x821EC13C;
		  /* 821EC13Ch */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC13Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC13Ch case    7:*/		return 0x821EC140;
		  /* 821EC140h */ case    8:  		/* cmpwi CR6, R10, 15 */
		/* 821EC140h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000F);
		/* 821EC140h case    8:*/		return 0x821EC144;
		  /* 821EC144h */ case    9:  		/* bc 4, CR6_EQ, -68 */
		/* 821EC144h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC144h case    9:*/		return 0x821EC148;
		  /* 821EC148h */ case   10:  		/* lwz R10, <#[R11 + 16]> */
		/* 821EC148h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821EC148h case   10:*/		return 0x821EC14C;
		  /* 821EC14Ch */ case   11:  		/* cmpwi CR6, R10, 1 */
		/* 821EC14Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821EC14Ch case   11:*/		return 0x821EC150;
		  /* 821EC150h */ case   12:  		/* bc 12, CR6_EQ, 104 */
		/* 821EC150h case   12:*/		if ( regs.CR[6].eq ) { return 0x821EC1B8;  }
		/* 821EC150h case   12:*/		return 0x821EC154;
		  /* 821EC154h */ case   13:  		/* cmpwi CR6, R10, 2 */
		/* 821EC154h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 821EC154h case   13:*/		return 0x821EC158;
		  /* 821EC158h */ case   14:  		/* bc 12, CR6_EQ, 116 */
		/* 821EC158h case   14:*/		if ( regs.CR[6].eq ) { return 0x821EC1CC;  }
		/* 821EC158h case   14:*/		return 0x821EC15C;
		  /* 821EC15Ch */ case   15:  		/* cmpwi CR6, R10, 3 */
		/* 821EC15Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821EC15Ch case   15:*/		return 0x821EC160;
		  /* 821EC160h */ case   16:  		/* bc 4, CR6_EQ, -96 */
		/* 821EC160h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821EC100;  }
		/* 821EC160h case   16:*/		return 0x821EC164;
		  /* 821EC164h */ case   17:  		/* rlwinm. R10, R8, 0, 24, 31 */
		/* 821EC164h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R8);
		/* 821EC164h case   17:*/		return 0x821EC168;
		  /* 821EC168h */ case   18:  		/* bc 4, CR0_EQ, 24 */
		/* 821EC168h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821EC180;  }
		/* 821EC168h case   18:*/		return 0x821EC16C;
		  /* 821EC16Ch */ case   19:  		/* lis R10, -32256 */
		/* 821EC16Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821EC16Ch case   19:*/		return 0x821EC170;
		  /* 821EC170h */ case   20:  		/* lfd FR13, <#[R11 + 24]> */
		/* 821EC170h case   20:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000018) );
		/* 821EC170h case   20:*/		return 0x821EC174;
		  /* 821EC174h */ case   21:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 821EC174h case   21:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 821EC174h case   21:*/		return 0x821EC178;
		  /* 821EC178h */ case   22:  		/* fcmpu CR6, FR13, FR0 */
		/* 821EC178h case   22:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821EC178h case   22:*/		return 0x821EC17C;
		  /* 821EC17Ch */ case   23:  		/* bc 12, CR6_LT, -124 */
		/* 821EC17Ch case   23:*/		if ( regs.CR[6].lt ) { return 0x821EC100;  }
		/* 821EC17Ch case   23:*/		return 0x821EC180;
	}
	return 0x821EC180;
} // Block from 821EC120h-821EC180h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821EC180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC180);
		  /* 821EC180h */ case    0:  		/* lfd FR0, <#[R11 + 24]> */
		/* 821EC180h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000018) );
		/* 821EC180h case    0:*/		return 0x821EC184;
		  /* 821EC184h */ case    1:  		/* rlwinm. R10, R9, 0, 24, 31 */
		/* 821EC184h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R9);
		/* 821EC184h case    1:*/		return 0x821EC188;
		  /* 821EC188h */ case    2:  		/* fctidz FR13, FR0 */
		/* 821EC188h case    2:*/		cpu::op::fctidz<0>(regs,&regs.FR13,regs.FR0);
		/* 821EC188h case    2:*/		return 0x821EC18C;
		  /* 821EC18Ch */ case    3:  		/* stfd FR13, <#[R1 + 80]> */
		/* 821EC18Ch case    3:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821EC18Ch case    3:*/		return 0x821EC190;
		  /* 821EC190h */ case    4:  		/* lwz R11, <#[R1 + 84]> */
		/* 821EC190h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821EC190h case    4:*/		return 0x821EC194;
		  /* 821EC194h */ case    5:  		/* bc 4, CR0_EQ, 60 */
		/* 821EC194h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821EC1D0;  }
		/* 821EC194h case    5:*/		return 0x821EC198;
		  /* 821EC198h */ case    6:  		/* rldicl R10, R11, 0, 32 */
		/* 821EC198h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R11);
		/* 821EC198h case    6:*/		return 0x821EC19C;
		  /* 821EC19Ch */ case    7:  		/* std R10, <#[R1 + 80]> */
		/* 821EC19Ch case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821EC19Ch case    7:*/		return 0x821EC1A0;
		  /* 821EC1A0h */ case    8:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821EC1A0h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821EC1A0h case    8:*/		return 0x821EC1A4;
		  /* 821EC1A4h */ case    9:  		/* fcfid FR13, FR13 */
		/* 821EC1A4h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821EC1A4h case    9:*/		return 0x821EC1A8;
		  /* 821EC1A8h */ case   10:  		/* frsp FR13, FR13 */
		/* 821EC1A8h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821EC1A8h case   10:*/		return 0x821EC1AC;
		  /* 821EC1ACh */ case   11:  		/* fcmpu CR6, FR13, FR0 */
		/* 821EC1ACh case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821EC1ACh case   11:*/		return 0x821EC1B0;
		  /* 821EC1B0h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 821EC1B0h case   12:*/		if ( regs.CR[6].eq ) { return 0x821EC1D0;  }
		/* 821EC1B0h case   12:*/		return 0x821EC1B4;
		  /* 821EC1B4h */ case   13:  		/* b -180 */
		/* 821EC1B4h case   13:*/		return 0x821EC100;
		/* 821EC1B4h case   13:*/		return 0x821EC1B8;
	}
	return 0x821EC1B8;
} // Block from 821EC180h-821EC1B8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EC1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC1B8);
		  /* 821EC1B8h */ case    0:  		/* rlwinm. R10, R8, 0, 24, 31 */
		/* 821EC1B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R8);
		/* 821EC1B8h case    0:*/		return 0x821EC1BC;
		  /* 821EC1BCh */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 821EC1BCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821EC1CC;  }
		/* 821EC1BCh case    1:*/		return 0x821EC1C0;
		  /* 821EC1C0h */ case    2:  		/* lwz R10, <#[R11 + 24]> */
		/* 821EC1C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 821EC1C0h case    2:*/		return 0x821EC1C4;
		  /* 821EC1C4h */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 821EC1C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821EC1C4h case    3:*/		return 0x821EC1C8;
		  /* 821EC1C8h */ case    4:  		/* bc 12, CR6_LT, -200 */
		/* 821EC1C8h case    4:*/		if ( regs.CR[6].lt ) { return 0x821EC100;  }
		/* 821EC1C8h case    4:*/		return 0x821EC1CC;
	}
	return 0x821EC1CC;
} // Block from 821EC1B8h-821EC1CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC1CC);
		  /* 821EC1CCh */ case    0:  		/* lwz R11, <#[R11 + 24]> */
		/* 821EC1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821EC1CCh case    0:*/		return 0x821EC1D0;
	}
	return 0x821EC1D0;
} // Block from 821EC1CCh-821EC1D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC1D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC1D0);
		  /* 821EC1D0h */ case    0:  		/* stw R11, <#[R5]> */
		/* 821EC1D0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EC1D0h case    0:*/		return 0x821EC1D4;
		  /* 821EC1D4h */ case    1:  		/* li R3, 1 */
		/* 821EC1D4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EC1D4h case    1:*/		return 0x821EC1D8;
		  /* 821EC1D8h */ case    2:  		/* b -212 */
		/* 821EC1D8h case    2:*/		return 0x821EC104;
		/* 821EC1D8h case    2:*/		return 0x821EC1DC;
	}
	return 0x821EC1DC;
} // Block from 821EC1D0h-821EC1DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC1DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC1DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC1DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC1DC);
		  /* 821EC1DCh */ case    0:  		/* li R4, 4801 */
		/* 821EC1DCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC1DCh case    0:*/		return 0x821EC1E0;
		  /* 821EC1E0h */ case    1:  		/* bl -631672 */
		/* 821EC1E0h case    1:*/		regs.LR = 0x821EC1E4; return 0x82151E68;
		/* 821EC1E0h case    1:*/		return 0x821EC1E4;
		  /* 821EC1E4h */ case    2:  		/* nop */
		/* 821EC1E4h case    2:*/		cpu::op::nop();
		/* 821EC1E4h case    2:*/		return 0x821EC1E8;
		  /* 821EC1E8h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 821EC1E8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EC1E8h case    3:*/		return 0x821EC1EC;
		  /* 821EC1ECh */ case    4:  		/* bc 12, CR6_EQ, 180 */
		/* 821EC1ECh case    4:*/		if ( regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC1ECh case    4:*/		return 0x821EC1F0;
		  /* 821EC1F0h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EC1F0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EC1F0h case    5:*/		return 0x821EC1F4;
		  /* 821EC1F4h */ case    6:  		/* cmpwi CR6, R11, 14 */
		/* 821EC1F4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821EC1F4h case    6:*/		return 0x821EC1F8;
		  /* 821EC1F8h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821EC1F8h case    7:*/		if ( regs.CR[6].eq ) { return 0x821EC208;  }
		/* 821EC1F8h case    7:*/		return 0x821EC1FC;
		  /* 821EC1FCh */ case    8:  		/* lwz R11, <#[R4 + 28]> */
		/* 821EC1FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821EC1FCh case    8:*/		return 0x821EC200;
		  /* 821EC200h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 821EC200h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821EC200h case    9:*/		return 0x821EC204;
		  /* 821EC204h */ case   10:  		/* bc 4, CR6_EQ, 156 */
		/* 821EC204h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC204h case   10:*/		return 0x821EC208;
	}
	return 0x821EC208;
} // Block from 821EC1DCh-821EC208h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EC208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC208);
		  /* 821EC208h */ case    0:  		/* lwz R11, <#[R4 + 20]> */
		/* 821EC208h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821EC208h case    0:*/		return 0x821EC20C;
		  /* 821EC20Ch */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 821EC20Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821EC20Ch case    1:*/		return 0x821EC210;
		  /* 821EC210h */ case    2:  		/* bc 4, CR6_EQ, 144 */
		/* 821EC210h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC210h case    2:*/		return 0x821EC214;
		  /* 821EC214h */ case    3:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC214h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC214h case    3:*/		return 0x821EC218;
		  /* 821EC218h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 821EC218h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821EC218h case    4:*/		return 0x821EC21C;
		  /* 821EC21Ch */ case    5:  		/* bc 4, CR6_EQ, 132 */
		/* 821EC21Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC21Ch case    5:*/		return 0x821EC220;
		  /* 821EC220h */ case    6:  		/* lwz R11, <#[R4 + 16]> */
		/* 821EC220h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821EC220h case    6:*/		return 0x821EC224;
		  /* 821EC224h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EC224h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC224h case    7:*/		return 0x821EC228;
		  /* 821EC228h */ case    8:  		/* bc 12, CR6_EQ, 112 */
		/* 821EC228h case    8:*/		if ( regs.CR[6].eq ) { return 0x821EC298;  }
		/* 821EC228h case    8:*/		return 0x821EC22C;
		  /* 821EC22Ch */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC22Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC22Ch case    9:*/		return 0x821EC230;
		  /* 821EC230h */ case   10:  		/* cmpwi CR6, R10, 9 */
		/* 821EC230h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 821EC230h case   10:*/		return 0x821EC234;
		  /* 821EC234h */ case   11:  		/* bc 4, CR6_EQ, 100 */
		/* 821EC234h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821EC298;  }
		/* 821EC234h case   11:*/		return 0x821EC238;
		  /* 821EC238h */ case   12:  		/* lwz R11, <#[R11 + 20]> */
		/* 821EC238h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821EC238h case   12:*/		return 0x821EC23C;
		  /* 821EC23Ch */ case   13:  		/* cmpwi CR6, R11, 0 */
		/* 821EC23Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821EC23Ch case   13:*/		return 0x821EC240;
		  /* 821EC240h */ case   14:  		/* bc 4, CR6_EQ, 96 */
		/* 821EC240h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC240h case   14:*/		return 0x821EC244;
		  /* 821EC244h */ case   15:  		/* lwz R11, <#[R4 + 32]> */
		/* 821EC244h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 821EC244h case   15:*/		return 0x821EC248;
		  /* 821EC248h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC248h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC248h case   16:*/		return 0x821EC24C;
		  /* 821EC24Ch */ case   17:  		/* cmpwi CR6, R10, 1 */
		/* 821EC24Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821EC24Ch case   17:*/		return 0x821EC250;
		  /* 821EC250h */ case   18:  		/* bc 4, CR6_EQ, 80 */
		/* 821EC250h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC250h case   18:*/		return 0x821EC254;
		  /* 821EC254h */ case   19:  		/* lwz R10, <#[R11 + 12]> */
		/* 821EC254h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821EC254h case   19:*/		return 0x821EC258;
		  /* 821EC258h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 821EC258h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821EC258h case   20:*/		return 0x821EC25C;
		  /* 821EC25Ch */ case   21:  		/* bc 4, CR6_EQ, 68 */
		/* 821EC25Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC25Ch case   21:*/		return 0x821EC260;
		  /* 821EC260h */ case   22:  		/* lwz R11, <#[R11 + 8]> */
		/* 821EC260h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821EC260h case   22:*/		return 0x821EC264;
		  /* 821EC264h */ case   23:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC264h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC264h case   23:*/		return 0x821EC268;
		  /* 821EC268h */ case   24:  		/* cmpwi CR6, R10, 15 */
		/* 821EC268h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000F);
		/* 821EC268h case   24:*/		return 0x821EC26C;
		  /* 821EC26Ch */ case   25:  		/* bc 4, CR6_EQ, 52 */
		/* 821EC26Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC26Ch case   25:*/		return 0x821EC270;
		  /* 821EC270h */ case   26:  		/* lwz R10, <#[R11 + 16]> */
		/* 821EC270h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821EC270h case   26:*/		return 0x821EC274;
		  /* 821EC274h */ case   27:  		/* cmpwi CR6, R10, 0 */
		/* 821EC274h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821EC274h case   27:*/		return 0x821EC278;
		  /* 821EC278h */ case   28:  		/* bc 4, CR6_EQ, 40 */
		/* 821EC278h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821EC2A0;  }
		/* 821EC278h case   28:*/		return 0x821EC27C;
		  /* 821EC27Ch */ case   29:  		/* lwz R11, <#[R11 + 24]> */
		/* 821EC27Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821EC27Ch case   29:*/		return 0x821EC280;
		  /* 821EC280h */ case   30:  		/* li R3, 1 */
		/* 821EC280h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821EC280h case   30:*/		return 0x821EC284;
		  /* 821EC284h */ case   31:  		/* addi R11, R11, 0 */
		/* 821EC284h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x0);
		/* 821EC284h case   31:*/		return 0x821EC288;
		  /* 821EC288h */ case   32:  		/* addic R10, R11, -1 */
		/* 821EC288h case   32:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 821EC288h case   32:*/		return 0x821EC28C;
		  /* 821EC28Ch */ case   33:  		/* subfe R11, R10, R11 */
		/* 821EC28Ch case   33:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EC28Ch case   33:*/		return 0x821EC290;
		  /* 821EC290h */ case   34:  		/* stb R11, <#[R5]> */
		/* 821EC290h case   34:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EC290h case   34:*/		return 0x821EC294;
		  /* 821EC294h */ case   35:  		/* bclr 20, CR0_LT */
		/* 821EC294h case   35:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC294h case   35:*/		return 0x821EC298;
	}
	return 0x821EC298;
} // Block from 821EC208h-821EC298h (36 instructions)

//////////////////////////////////////////////////////
// Block at 821EC298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC298);
		  /* 821EC298h */ case    0:  		/* li R4, 4801 */
		/* 821EC298h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC298h case    0:*/		return 0x821EC29C;
		  /* 821EC29Ch */ case    1:  		/* b -631860 */
		/* 821EC29Ch case    1:*/		return 0x82151E68;
		/* 821EC29Ch case    1:*/		return 0x821EC2A0;
	}
	return 0x821EC2A0;
} // Block from 821EC298h-821EC2A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC2A0);
		  /* 821EC2A0h */ case    0:  		/* li R3, 0 */
		/* 821EC2A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EC2A0h case    0:*/		return 0x821EC2A4;
		  /* 821EC2A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EC2A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC2A4h case    1:*/		return 0x821EC2A8;
	}
	return 0x821EC2A8;
} // Block from 821EC2A0h-821EC2A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC2A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC2A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC2A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC2A8);
		  /* 821EC2A8h */ case    0:  		/* mfspr R12, LR */
		/* 821EC2A8h case    0:*/		regs.R12 = regs.LR;
		/* 821EC2A8h case    0:*/		return 0x821EC2AC;
		  /* 821EC2ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EC2ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC2ACh case    1:*/		return 0x821EC2B0;
		  /* 821EC2B0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821EC2B0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC2B0h case    2:*/		return 0x821EC2B4;
		  /* 821EC2B4h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EC2B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EC2B4h case    3:*/		return 0x821EC2B8;
		  /* 821EC2B8h */ case    4:  		/* mr R31, R3 */
		/* 821EC2B8h case    4:*/		regs.R31 = regs.R3;
		/* 821EC2B8h case    4:*/		return 0x821EC2BC;
		  /* 821EC2BCh */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 821EC2BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EC2BCh case    5:*/		return 0x821EC2C0;
		  /* 821EC2C0h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 821EC2C0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821EC2CC;  }
		/* 821EC2C0h case    6:*/		return 0x821EC2C4;
		  /* 821EC2C4h */ case    7:  		/* li R4, 3583 */
		/* 821EC2C4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xDFF);
		/* 821EC2C4h case    7:*/		return 0x821EC2C8;
		  /* 821EC2C8h */ case    8:  		/* bl -631904 */
		/* 821EC2C8h case    8:*/		regs.LR = 0x821EC2CC; return 0x82151E68;
		/* 821EC2C8h case    8:*/		return 0x821EC2CC;
	}
	return 0x821EC2CC;
} // Block from 821EC2A8h-821EC2CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EC2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC2CC);
		  /* 821EC2CCh */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EC2CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EC2CCh case    0:*/		return 0x821EC2D0;
		  /* 821EC2D0h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 821EC2D0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EC2D0h case    1:*/		return 0x821EC2D4;
		  /* 821EC2D4h */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 821EC2D4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC324;  }
		/* 821EC2D4h case    2:*/		return 0x821EC2D8;
		  /* 821EC2D8h */ case    3:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EC2D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EC2D8h case    3:*/		return 0x821EC2DC;
		  /* 821EC2DCh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EC2DCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC2DCh case    4:*/		return 0x821EC2E0;
		  /* 821EC2E0h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821EC2E0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821EC2EC;  }
		/* 821EC2E0h case    5:*/		return 0x821EC2E4;
		  /* 821EC2E4h */ case    6:  		/* li R4, 3583 */
		/* 821EC2E4h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xDFF);
		/* 821EC2E4h case    6:*/		return 0x821EC2E8;
		  /* 821EC2E8h */ case    7:  		/* bl -631936 */
		/* 821EC2E8h case    7:*/		regs.LR = 0x821EC2EC; return 0x82151E68;
		/* 821EC2E8h case    7:*/		return 0x821EC2EC;
	}
	return 0x821EC2EC;
} // Block from 821EC2CCh-821EC2ECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC2EC);
		  /* 821EC2ECh */ case    0:  		/* addi R5, R1, 80 */
		/* 821EC2ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821EC2ECh case    0:*/		return 0x821EC2F0;
		  /* 821EC2F0h */ case    1:  		/* lwz R4, <#[R4 + 8]> */
		/* 821EC2F0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 821EC2F0h case    1:*/		return 0x821EC2F4;
		  /* 821EC2F4h */ case    2:  		/* bl -636 */
		/* 821EC2F4h case    2:*/		regs.LR = 0x821EC2F8; return 0x821EC078;
		/* 821EC2F4h case    2:*/		return 0x821EC2F8;
		  /* 821EC2F8h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821EC2F8h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821EC2F8h case    3:*/		return 0x821EC2FC;
		  /* 821EC2FCh */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 821EC2FCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x821EC30C;  }
		/* 821EC2FCh case    4:*/		return 0x821EC300;
		  /* 821EC300h */ case    5:  		/* li R4, 3583 */
		/* 821EC300h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xDFF);
		/* 821EC300h case    5:*/		return 0x821EC304;
		  /* 821EC304h */ case    6:  		/* mr R3, R31 */
		/* 821EC304h case    6:*/		regs.R3 = regs.R31;
		/* 821EC304h case    6:*/		return 0x821EC308;
		  /* 821EC308h */ case    7:  		/* bl -631968 */
		/* 821EC308h case    7:*/		regs.LR = 0x821EC30C; return 0x82151E68;
		/* 821EC308h case    7:*/		return 0x821EC30C;
	}
	return 0x821EC30C;
} // Block from 821EC2ECh-821EC30Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC30C);
		  /* 821EC30Ch */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 821EC30Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821EC30Ch case    0:*/		return 0x821EC310;
		  /* 821EC310h */ case    1:  		/* addi R1, R1, 112 */
		/* 821EC310h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EC310h case    1:*/		return 0x821EC314;
		  /* 821EC314h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EC314h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC314h case    2:*/		return 0x821EC318;
		  /* 821EC318h */ case    3:  		/* mtspr LR, R12 */
		/* 821EC318h case    3:*/		regs.LR = regs.R12;
		/* 821EC318h case    3:*/		return 0x821EC31C;
		  /* 821EC31Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821EC31Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC31Ch case    4:*/		return 0x821EC320;
		  /* 821EC320h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821EC320h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC320h case    5:*/		return 0x821EC324;
	}
	return 0x821EC324;
} // Block from 821EC30Ch-821EC324h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EC324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC324);
		  /* 821EC324h */ case    0:  		/* li R4, 4801 */
		/* 821EC324h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC324h case    0:*/		return 0x821EC328;
		  /* 821EC328h */ case    1:  		/* bl -632000 */
		/* 821EC328h case    1:*/		regs.LR = 0x821EC32C; return 0x82151E68;
		/* 821EC328h case    1:*/		return 0x821EC32C;
		  /* 821EC32Ch */ case    2:  		/* nop */
		/* 821EC32Ch case    2:*/		cpu::op::nop();
		/* 821EC32Ch case    2:*/		return 0x821EC330;
	}
	return 0x821EC330;
} // Block from 821EC324h-821EC330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC330);
		  /* 821EC330h */ case    0:  		/* mfspr R12, LR */
		/* 821EC330h case    0:*/		regs.R12 = regs.LR;
		/* 821EC330h case    0:*/		return 0x821EC334;
		  /* 821EC334h */ case    1:  		/* bl -1421528 */
		/* 821EC334h case    1:*/		regs.LR = 0x821EC338; return 0x8209125C;
		/* 821EC334h case    1:*/		return 0x821EC338;
		  /* 821EC338h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EC338h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EC338h case    2:*/		return 0x821EC33C;
		  /* 821EC33Ch */ case    3:  		/* mr R30, R3 */
		/* 821EC33Ch case    3:*/		regs.R30 = regs.R3;
		/* 821EC33Ch case    3:*/		return 0x821EC340;
		  /* 821EC340h */ case    4:  		/* mr R31, R4 */
		/* 821EC340h case    4:*/		regs.R31 = regs.R4;
		/* 821EC340h case    4:*/		return 0x821EC344;
		  /* 821EC344h */ case    5:  		/* mr R29, R6 */
		/* 821EC344h case    5:*/		regs.R29 = regs.R6;
		/* 821EC344h case    5:*/		return 0x821EC348;
		  /* 821EC348h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 821EC348h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EC348h case    6:*/		return 0x821EC34C;
		  /* 821EC34Ch */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 821EC34Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x821EC358;  }
		/* 821EC34Ch case    7:*/		return 0x821EC350;
		  /* 821EC350h */ case    8:  		/* li R4, 3583 */
		/* 821EC350h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xDFF);
		/* 821EC350h case    8:*/		return 0x821EC354;
		  /* 821EC354h */ case    9:  		/* bl -632044 */
		/* 821EC354h case    9:*/		regs.LR = 0x821EC358; return 0x82151E68;
		/* 821EC354h case    9:*/		return 0x821EC358;
	}
	return 0x821EC358;
} // Block from 821EC330h-821EC358h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EC358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC358);
		  /* 821EC358h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 821EC358h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821EC358h case    0:*/		return 0x821EC35C;
		  /* 821EC35Ch */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 821EC35Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EC35Ch case    1:*/		return 0x821EC360;
		  /* 821EC360h */ case    2:  		/* bc 4, CR6_EQ, 72 */
		/* 821EC360h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC3A8;  }
		/* 821EC360h case    2:*/		return 0x821EC364;
		  /* 821EC364h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 821EC364h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821EC364h case    3:*/		return 0x821EC368;
		  /* 821EC368h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EC368h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC368h case    4:*/		return 0x821EC36C;
		  /* 821EC36Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 821EC36Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EC378;  }
		/* 821EC36Ch case    5:*/		return 0x821EC370;
		  /* 821EC370h */ case    6:  		/* li R4, 3583 */
		/* 821EC370h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xDFF);
		/* 821EC370h case    6:*/		return 0x821EC374;
		  /* 821EC374h */ case    7:  		/* bl -632076 */
		/* 821EC374h case    7:*/		regs.LR = 0x821EC378; return 0x82151E68;
		/* 821EC374h case    7:*/		return 0x821EC378;
	}
	return 0x821EC378;
} // Block from 821EC358h-821EC378h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC378);
		  /* 821EC378h */ case    0:  		/* lwz R4, <#[R31 + 8]> */
		/* 821EC378h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 821EC378h case    0:*/		return 0x821EC37C;
		  /* 821EC37Ch */ case    1:  		/* bl -772 */
		/* 821EC37Ch case    1:*/		regs.LR = 0x821EC380; return 0x821EC078;
		/* 821EC37Ch case    1:*/		return 0x821EC380;
		  /* 821EC380h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821EC380h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821EC380h case    2:*/		return 0x821EC384;
		  /* 821EC384h */ case    3:  		/* mr R3, R30 */
		/* 821EC384h case    3:*/		regs.R3 = regs.R30;
		/* 821EC384h case    3:*/		return 0x821EC388;
		  /* 821EC388h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 821EC388h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821EC394;  }
		/* 821EC388h case    4:*/		return 0x821EC38C;
		  /* 821EC38Ch */ case    5:  		/* li R4, 3583 */
		/* 821EC38Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xDFF);
		/* 821EC38Ch case    5:*/		return 0x821EC390;
		  /* 821EC390h */ case    6:  		/* bl -632104 */
		/* 821EC390h case    6:*/		regs.LR = 0x821EC394; return 0x82151E68;
		/* 821EC390h case    6:*/		return 0x821EC394;
	}
	return 0x821EC394;
} // Block from 821EC378h-821EC394h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EC394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC394);
		  /* 821EC394h */ case    0:  		/* lwz R4, <#[R31 + 12]> */
		/* 821EC394h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 821EC394h case    0:*/		return 0x821EC398;
		  /* 821EC398h */ case    1:  		/* bl -240 */
		/* 821EC398h case    1:*/		regs.LR = 0x821EC39C; return 0x821EC2A8;
		/* 821EC398h case    1:*/		return 0x821EC39C;
		  /* 821EC39Ch */ case    2:  		/* stw R3, <#[R29]> */
		/* 821EC39Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 821EC39Ch case    2:*/		return 0x821EC3A0;
		  /* 821EC3A0h */ case    3:  		/* addi R1, R1, 112 */
		/* 821EC3A0h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EC3A0h case    3:*/		return 0x821EC3A4;
		  /* 821EC3A4h */ case    4:  		/* b -1421560 */
		/* 821EC3A4h case    4:*/		return 0x820912AC;
		/* 821EC3A4h case    4:*/		return 0x821EC3A8;
	}
	return 0x821EC3A8;
} // Block from 821EC394h-821EC3A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC3A8);
		  /* 821EC3A8h */ case    0:  		/* li R4, 4801 */
		/* 821EC3A8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC3A8h case    0:*/		return 0x821EC3AC;
		  /* 821EC3ACh */ case    1:  		/* bl -632132 */
		/* 821EC3ACh case    1:*/		regs.LR = 0x821EC3B0; return 0x82151E68;
		/* 821EC3ACh case    1:*/		return 0x821EC3B0;
	}
	return 0x821EC3B0;
} // Block from 821EC3A8h-821EC3B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC3B0);
		  /* 821EC3B0h */ case    0:  		/* mfspr R12, LR */
		/* 821EC3B0h case    0:*/		regs.R12 = regs.LR;
		/* 821EC3B0h case    0:*/		return 0x821EC3B4;
		  /* 821EC3B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EC3B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC3B4h case    1:*/		return 0x821EC3B8;
		  /* 821EC3B8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821EC3B8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC3B8h case    2:*/		return 0x821EC3BC;
		  /* 821EC3BCh */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EC3BCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EC3BCh case    3:*/		return 0x821EC3C0;
		  /* 821EC3C0h */ case    4:  		/* mr R31, R3 */
		/* 821EC3C0h case    4:*/		regs.R31 = regs.R3;
		/* 821EC3C0h case    4:*/		return 0x821EC3C4;
		  /* 821EC3C4h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 821EC3C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EC3C4h case    5:*/		return 0x821EC3C8;
		  /* 821EC3C8h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 821EC3C8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821EC3D4;  }
		/* 821EC3C8h case    6:*/		return 0x821EC3CC;
		  /* 821EC3CCh */ case    7:  		/* li R4, 3609 */
		/* 821EC3CCh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xE19);
		/* 821EC3CCh case    7:*/		return 0x821EC3D0;
		  /* 821EC3D0h */ case    8:  		/* bl -632168 */
		/* 821EC3D0h case    8:*/		regs.LR = 0x821EC3D4; return 0x82151E68;
		/* 821EC3D0h case    8:*/		return 0x821EC3D4;
	}
	return 0x821EC3D4;
} // Block from 821EC3B0h-821EC3D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EC3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC3D4);
		  /* 821EC3D4h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EC3D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EC3D4h case    0:*/		return 0x821EC3D8;
		  /* 821EC3D8h */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 821EC3D8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821EC3D8h case    1:*/		return 0x821EC3DC;
		  /* 821EC3DCh */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 821EC3DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC42C;  }
		/* 821EC3DCh case    2:*/		return 0x821EC3E0;
		  /* 821EC3E0h */ case    3:  		/* lwz R11, <#[R4 + 12]> */
		/* 821EC3E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821EC3E0h case    3:*/		return 0x821EC3E4;
		  /* 821EC3E4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EC3E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC3E4h case    4:*/		return 0x821EC3E8;
		  /* 821EC3E8h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821EC3E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821EC3F4;  }
		/* 821EC3E8h case    5:*/		return 0x821EC3EC;
		  /* 821EC3ECh */ case    6:  		/* li R4, 3609 */
		/* 821EC3ECh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xE19);
		/* 821EC3ECh case    6:*/		return 0x821EC3F0;
		  /* 821EC3F0h */ case    7:  		/* bl -632200 */
		/* 821EC3F0h case    7:*/		regs.LR = 0x821EC3F4; return 0x82151E68;
		/* 821EC3F0h case    7:*/		return 0x821EC3F4;
	}
	return 0x821EC3F4;
} // Block from 821EC3D4h-821EC3F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC3F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC3F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC3F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC3F4);
		  /* 821EC3F4h */ case    0:  		/* addi R5, R1, 80 */
		/* 821EC3F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821EC3F4h case    0:*/		return 0x821EC3F8;
		  /* 821EC3F8h */ case    1:  		/* lwz R4, <#[R4 + 8]> */
		/* 821EC3F8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 821EC3F8h case    1:*/		return 0x821EC3FC;
		  /* 821EC3FCh */ case    2:  		/* bl -532 */
		/* 821EC3FCh case    2:*/		regs.LR = 0x821EC400; return 0x821EC1E8;
		/* 821EC3FCh case    2:*/		return 0x821EC400;
		  /* 821EC400h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821EC400h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821EC400h case    3:*/		return 0x821EC404;
		  /* 821EC404h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 821EC404h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821EC414;  }
		/* 821EC404h case    4:*/		return 0x821EC408;
		  /* 821EC408h */ case    5:  		/* li R4, 3609 */
		/* 821EC408h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0xE19);
		/* 821EC408h case    5:*/		return 0x821EC40C;
		  /* 821EC40Ch */ case    6:  		/* mr R3, R31 */
		/* 821EC40Ch case    6:*/		regs.R3 = regs.R31;
		/* 821EC40Ch case    6:*/		return 0x821EC410;
		  /* 821EC410h */ case    7:  		/* bl -632232 */
		/* 821EC410h case    7:*/		regs.LR = 0x821EC414; return 0x82151E68;
		/* 821EC410h case    7:*/		return 0x821EC414;
	}
	return 0x821EC414;
} // Block from 821EC3F4h-821EC414h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC414);
		  /* 821EC414h */ case    0:  		/* lbz R3, <#[R1 + 80]> */
		/* 821EC414h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821EC414h case    0:*/		return 0x821EC418;
		  /* 821EC418h */ case    1:  		/* addi R1, R1, 112 */
		/* 821EC418h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EC418h case    1:*/		return 0x821EC41C;
		  /* 821EC41Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EC41Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC41Ch case    2:*/		return 0x821EC420;
		  /* 821EC420h */ case    3:  		/* mtspr LR, R12 */
		/* 821EC420h case    3:*/		regs.LR = regs.R12;
		/* 821EC420h case    3:*/		return 0x821EC424;
		  /* 821EC424h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821EC424h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC424h case    4:*/		return 0x821EC428;
		  /* 821EC428h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821EC428h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC428h case    5:*/		return 0x821EC42C;
	}
	return 0x821EC42C;
} // Block from 821EC414h-821EC42Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EC42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC42C);
		  /* 821EC42Ch */ case    0:  		/* li R4, 4801 */
		/* 821EC42Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC42Ch case    0:*/		return 0x821EC430;
		  /* 821EC430h */ case    1:  		/* bl -632264 */
		/* 821EC430h case    1:*/		regs.LR = 0x821EC434; return 0x82151E68;
		/* 821EC430h case    1:*/		return 0x821EC434;
		  /* 821EC434h */ case    2:  		/* nop */
		/* 821EC434h case    2:*/		cpu::op::nop();
		/* 821EC434h case    2:*/		return 0x821EC438;
	}
	return 0x821EC438;
} // Block from 821EC42Ch-821EC438h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC438);
		  /* 821EC438h */ case    0:  		/* mfspr R12, LR */
		/* 821EC438h case    0:*/		regs.R12 = regs.LR;
		/* 821EC438h case    0:*/		return 0x821EC43C;
		  /* 821EC43Ch */ case    1:  		/* bl -1421800 */
		/* 821EC43Ch case    1:*/		regs.LR = 0x821EC440; return 0x82091254;
		/* 821EC43Ch case    1:*/		return 0x821EC440;
		  /* 821EC440h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821EC440h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821EC440h case    2:*/		return 0x821EC444;
		  /* 821EC444h */ case    3:  		/* lwz R11, <#[R4 + 32]> */
		/* 821EC444h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 821EC444h case    3:*/		return 0x821EC448;
		  /* 821EC448h */ case    4:  		/* mr R27, R3 */
		/* 821EC448h case    4:*/		regs.R27 = regs.R3;
		/* 821EC448h case    4:*/		return 0x821EC44C;
		  /* 821EC44Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821EC44Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC44Ch case    5:*/		return 0x821EC450;
		  /* 821EC450h */ case    6:  		/* bc 12, CR6_EQ, 288 */
		/* 821EC450h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EC570;  }
		/* 821EC450h case    6:*/		return 0x821EC454;
		  /* 821EC454h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC454h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC454h case    7:*/		return 0x821EC458;
		  /* 821EC458h */ case    8:  		/* cmpwi CR6, R10, 1 */
		/* 821EC458h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821EC458h case    8:*/		return 0x821EC45C;
		  /* 821EC45Ch */ case    9:  		/* bc 4, CR6_EQ, 276 */
		/* 821EC45Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821EC570;  }
		/* 821EC45Ch case    9:*/		return 0x821EC460;
		  /* 821EC460h */ case   10:  		/* mr R29, R11 */
		/* 821EC460h case   10:*/		regs.R29 = regs.R11;
		/* 821EC460h case   10:*/		return 0x821EC464;
		  /* 821EC464h */ case   11:  		/* li R28, 0 */
		/* 821EC464h case   11:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821EC464h case   11:*/		return 0x821EC468;
		  /* 821EC468h */ case   12:  		/* li R30, -1 */
		/* 821EC468h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 821EC468h case   12:*/		return 0x821EC46C;
		  /* 821EC46Ch */ case   13:  		/* lwz R10, <#[R29 + 8]> */
		/* 821EC46Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821EC46Ch case   13:*/		return 0x821EC470;
		  /* 821EC470h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 821EC470h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821EC470h case   14:*/		return 0x821EC474;
		  /* 821EC474h */ case   15:  		/* bc 12, CR6_EQ, 240 */
		/* 821EC474h case   15:*/		if ( regs.CR[6].eq ) { return 0x821EC564;  }
		/* 821EC474h case   15:*/		return 0x821EC478;
		  /* 821EC478h */ case   16:  		/* lwz R11, <#[R10 + 4]> */
		/* 821EC478h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821EC478h case   16:*/		return 0x821EC47C;
		  /* 821EC47Ch */ case   17:  		/* cmpwi CR6, R11, 15 */
		/* 821EC47Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 821EC47Ch case   17:*/		return 0x821EC480;
		  /* 821EC480h */ case   18:  		/* bc 4, CR6_EQ, 228 */
		/* 821EC480h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821EC564;  }
		/* 821EC480h case   18:*/		return 0x821EC484;
		  /* 821EC484h */ case   19:  		/* lwz R11, <#[R10 + 16]> */
		/* 821EC484h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821EC484h case   19:*/		return 0x821EC488;
		  /* 821EC488h */ case   20:  		/* cmpwi CR6, R11, 2 */
		/* 821EC488h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 821EC488h case   20:*/		return 0x821EC48C;
		  /* 821EC48Ch */ case   21:  		/* bc 4, CR6_EQ, 180 */
		/* 821EC48Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x821EC540;  }
		/* 821EC48Ch case   21:*/		return 0x821EC490;
		  /* 821EC490h */ case   22:  		/* lwz R11, <#[R27 + 568]> */
		/* 821EC490h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000238) );
		/* 821EC490h case   22:*/		return 0x821EC494;
		  /* 821EC494h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 821EC494h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC494h case   23:*/		return 0x821EC498;
		  /* 821EC498h */ case   24:  		/* bc 12, CR6_EQ, 36 */
		/* 821EC498h case   24:*/		if ( regs.CR[6].eq ) { return 0x821EC4BC;  }
		/* 821EC498h case   24:*/		return 0x821EC49C;
		  /* 821EC49Ch */ case   25:  		/* lwz R10, <#[R10 + 24]> */
		/* 821EC49Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 821EC49Ch case   25:*/		return 0x821EC4A0;
		  /* 821EC4A0h */ case   26:  		/* lwz R9, <#[R11]> */
		/* 821EC4A0h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EC4A0h case   26:*/		return 0x821EC4A4;
		  /* 821EC4A4h */ case   27:  		/* lwz R9, <#[R9 + 40]> */
		/* 821EC4A4h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000028) );
		/* 821EC4A4h case   27:*/		return 0x821EC4A8;
		  /* 821EC4A8h */ case   28:  		/* cmplw CR6, R9, R10 */
		/* 821EC4A8h case   28:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 821EC4A8h case   28:*/		return 0x821EC4AC;
		  /* 821EC4ACh */ case   29:  		/* bc 12, CR6_EQ, 140 */
		/* 821EC4ACh case   29:*/		if ( regs.CR[6].eq ) { return 0x821EC538;  }
		/* 821EC4ACh case   29:*/		return 0x821EC4B0;
		  /* 821EC4B0h */ case   30:  		/* lwz R11, <#[R11 + 8]> */
		/* 821EC4B0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821EC4B0h case   30:*/		return 0x821EC4B4;
		  /* 821EC4B4h */ case   31:  		/* cmplwi CR6, R11, 0 */
		/* 821EC4B4h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC4B4h case   31:*/		return 0x821EC4B8;
		  /* 821EC4B8h */ case   32:  		/* bc 4, CR6_EQ, -24 */
		/* 821EC4B8h case   32:*/		if ( !regs.CR[6].eq ) { return 0x821EC4A0;  }
		/* 821EC4B8h case   32:*/		return 0x821EC4BC;
	}
	return 0x821EC4BC;
} // Block from 821EC438h-821EC4BCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 821EC4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC4BC);
		  /* 821EC4BCh */ case    0:  		/* li R31, 0 */
		/* 821EC4BCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821EC4BCh case    0:*/		return 0x821EC4C0;
		  /* 821EC4C0h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821EC4C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821EC4C0h case    1:*/		return 0x821EC4C4;
		  /* 821EC4C4h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821EC4C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EC500;  }
		/* 821EC4C4h case    2:*/		return 0x821EC4C8;
		  /* 821EC4C8h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 821EC4C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821EC4C8h case    3:*/		return 0x821EC4CC;
		  /* 821EC4CCh */ case    4:  		/* addi R5, R1, 80 */
		/* 821EC4CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821EC4CCh case    4:*/		return 0x821EC4D0;
		  /* 821EC4D0h */ case    5:  		/* mr R3, R27 */
		/* 821EC4D0h case    5:*/		regs.R3 = regs.R27;
		/* 821EC4D0h case    5:*/		return 0x821EC4D4;
		  /* 821EC4D4h */ case    6:  		/* lwz R4, <#[R11 + 36]> */
		/* 821EC4D4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000024) );
		/* 821EC4D4h case    6:*/		return 0x821EC4D8;
		  /* 821EC4D8h */ case    7:  		/* bl -1864 */
		/* 821EC4D8h case    7:*/		regs.LR = 0x821EC4DC; return 0x821EBD90;
		/* 821EC4D8h case    7:*/		return 0x821EC4DC;
		  /* 821EC4DCh */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821EC4DCh case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821EC4DCh case    8:*/		return 0x821EC4E0;
		  /* 821EC4E0h */ case    9:  		/* bc 12, CR0_EQ, 32 */
		/* 821EC4E0h case    9:*/		if ( regs.CR[0].eq ) { return 0x821EC500;  }
		/* 821EC4E0h case    9:*/		return 0x821EC4E4;
		  /* 821EC4E4h */ case   10:  		/* lwz R11, <#[R1 + 80]> */
		/* 821EC4E4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821EC4E4h case   10:*/		return 0x821EC4E8;
		  /* 821EC4E8h */ case   11:  		/* cmpwi CR6, R30, -1 */
		/* 821EC4E8h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 821EC4E8h case   11:*/		return 0x821EC4EC;
		  /* 821EC4ECh */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 821EC4ECh case   12:*/		if ( regs.CR[6].eq ) { return 0x821EC4F8;  }
		/* 821EC4ECh case   12:*/		return 0x821EC4F0;
		  /* 821EC4F0h */ case   13:  		/* cmplw CR6, R11, R30 */
		/* 821EC4F0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821EC4F0h case   13:*/		return 0x821EC4F4;
		  /* 821EC4F4h */ case   14:  		/* bc 4, CR6_GT, 12 */
		/* 821EC4F4h case   14:*/		if ( !regs.CR[6].gt ) { return 0x821EC500;  }
		/* 821EC4F4h case   14:*/		return 0x821EC4F8;
	}
	return 0x821EC4F8;
} // Block from 821EC4BCh-821EC4F8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821EC4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC4F8);
		  /* 821EC4F8h */ case    0:  		/* mr R28, R31 */
		/* 821EC4F8h case    0:*/		regs.R28 = regs.R31;
		/* 821EC4F8h case    0:*/		return 0x821EC4FC;
		  /* 821EC4FCh */ case    1:  		/* mr R30, R11 */
		/* 821EC4FCh case    1:*/		regs.R30 = regs.R11;
		/* 821EC4FCh case    1:*/		return 0x821EC500;
	}
	return 0x821EC500;
} // Block from 821EC4F8h-821EC500h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC500);
		  /* 821EC500h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 821EC500h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EC500h case    0:*/		return 0x821EC504;
		  /* 821EC504h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EC504h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC504h case    1:*/		return 0x821EC508;
		  /* 821EC508h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821EC508h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EC518;  }
		/* 821EC508h case    2:*/		return 0x821EC50C;
		  /* 821EC50Ch */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC50Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC50Ch case    3:*/		return 0x821EC510;
		  /* 821EC510h */ case    4:  		/* cmpwi CR6, R10, 1 */
		/* 821EC510h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821EC510h case    4:*/		return 0x821EC514;
		  /* 821EC514h */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 821EC514h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821EC54C;  }
		/* 821EC514h case    5:*/		return 0x821EC518;
	}
	return 0x821EC518;
} // Block from 821EC500h-821EC518h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EC518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC518);
		  /* 821EC518h */ case    0:  		/* mr R29, R11 */
		/* 821EC518h case    0:*/		regs.R29 = regs.R11;
		/* 821EC518h case    0:*/		return 0x821EC51C;
		  /* 821EC51Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EC51Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC51Ch case    1:*/		return 0x821EC520;
		  /* 821EC520h */ case    2:  		/* bc 4, CR6_EQ, -180 */
		/* 821EC520h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC46C;  }
		/* 821EC520h case    2:*/		return 0x821EC524;
		  /* 821EC524h */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 821EC524h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821EC524h case    3:*/		return 0x821EC528;
		  /* 821EC528h */ case    4:  		/* bc 4, CR6_EQ, 48 */
		/* 821EC528h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EC558;  }
		/* 821EC528h case    4:*/		return 0x821EC52C;
		  /* 821EC52Ch */ case    5:  		/* li R4, 4801 */
		/* 821EC52Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC52Ch case    5:*/		return 0x821EC530;
		  /* 821EC530h */ case    6:  		/* mr R3, R27 */
		/* 821EC530h case    6:*/		regs.R3 = regs.R27;
		/* 821EC530h case    6:*/		return 0x821EC534;
		  /* 821EC534h */ case    7:  		/* bl -632524 */
		/* 821EC534h case    7:*/		regs.LR = 0x821EC538; return 0x82151E68;
		/* 821EC534h case    7:*/		return 0x821EC538;
	}
	return 0x821EC538;
} // Block from 821EC518h-821EC538h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC538);
		  /* 821EC538h */ case    0:  		/* mr R31, R11 */
		/* 821EC538h case    0:*/		regs.R31 = regs.R11;
		/* 821EC538h case    0:*/		return 0x821EC53C;
		  /* 821EC53Ch */ case    1:  		/* b -124 */
		/* 821EC53Ch case    1:*/		return 0x821EC4C0;
		/* 821EC53Ch case    1:*/		return 0x821EC540;
	}
	return 0x821EC540;
} // Block from 821EC538h-821EC540h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC540);
		  /* 821EC540h */ case    0:  		/* li R4, 4801 */
		/* 821EC540h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC540h case    0:*/		return 0x821EC544;
		  /* 821EC544h */ case    1:  		/* mr R3, R27 */
		/* 821EC544h case    1:*/		regs.R3 = regs.R27;
		/* 821EC544h case    1:*/		return 0x821EC548;
		  /* 821EC548h */ case    2:  		/* bl -632544 */
		/* 821EC548h case    2:*/		regs.LR = 0x821EC54C; return 0x82151E68;
		/* 821EC548h case    2:*/		return 0x821EC54C;
	}
	return 0x821EC54C;
} // Block from 821EC540h-821EC54Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC54Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC54C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC54C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC54C);
		  /* 821EC54Ch */ case    0:  		/* li R4, 4801 */
		/* 821EC54Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC54Ch case    0:*/		return 0x821EC550;
		  /* 821EC550h */ case    1:  		/* mr R3, R27 */
		/* 821EC550h case    1:*/		regs.R3 = regs.R27;
		/* 821EC550h case    1:*/		return 0x821EC554;
		  /* 821EC554h */ case    2:  		/* bl -632556 */
		/* 821EC554h case    2:*/		regs.LR = 0x821EC558; return 0x82151E68;
		/* 821EC554h case    2:*/		return 0x821EC558;
	}
	return 0x821EC558;
} // Block from 821EC54Ch-821EC558h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC558);
		  /* 821EC558h */ case    0:  		/* mr R3, R28 */
		/* 821EC558h case    0:*/		regs.R3 = regs.R28;
		/* 821EC558h case    0:*/		return 0x821EC55C;
		  /* 821EC55Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 821EC55Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821EC55Ch case    1:*/		return 0x821EC560;
	}
	return 0x821EC560;
} // Block from 821EC558h-821EC560h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC560h
// Function '?NeedsPreviousScalarResult@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC560);
		  /* 821EC560h */ case    0:  		/* b -1422012 */
		/* 821EC560h case    0:*/		return 0x820912A4;
		/* 821EC560h case    0:*/		return 0x821EC564;
	}
	return 0x821EC564;
} // Block from 821EC560h-821EC564h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC564);
		  /* 821EC564h */ case    0:  		/* li R4, 4801 */
		/* 821EC564h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC564h case    0:*/		return 0x821EC568;
		  /* 821EC568h */ case    1:  		/* mr R3, R27 */
		/* 821EC568h case    1:*/		regs.R3 = regs.R27;
		/* 821EC568h case    1:*/		return 0x821EC56C;
		  /* 821EC56Ch */ case    2:  		/* bl -632580 */
		/* 821EC56Ch case    2:*/		regs.LR = 0x821EC570; return 0x82151E68;
		/* 821EC56Ch case    2:*/		return 0x821EC570;
	}
	return 0x821EC570;
} // Block from 821EC564h-821EC570h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC570);
		  /* 821EC570h */ case    0:  		/* li R4, 4801 */
		/* 821EC570h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC570h case    0:*/		return 0x821EC574;
		  /* 821EC574h */ case    1:  		/* mr R3, R27 */
		/* 821EC574h case    1:*/		regs.R3 = regs.R27;
		/* 821EC574h case    1:*/		return 0x821EC578;
		  /* 821EC578h */ case    2:  		/* bl -632592 */
		/* 821EC578h case    2:*/		regs.LR = 0x821EC57C; return 0x82151E68;
		/* 821EC578h case    2:*/		return 0x821EC57C;
		  /* 821EC57Ch */ case    3:  		/* nop */
		/* 821EC57Ch case    3:*/		cpu::op::nop();
		/* 821EC57Ch case    3:*/		return 0x821EC580;
	}
	return 0x821EC580;
} // Block from 821EC570h-821EC580h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EC580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC580);
		  /* 821EC580h */ case    0:  		/* mfspr R12, LR */
		/* 821EC580h case    0:*/		regs.R12 = regs.LR;
		/* 821EC580h case    0:*/		return 0x821EC584;
		  /* 821EC584h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EC584h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC584h case    1:*/		return 0x821EC588;
		  /* 821EC588h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821EC588h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC588h case    2:*/		return 0x821EC58C;
		  /* 821EC58Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821EC58Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821EC58Ch case    3:*/		return 0x821EC590;
		  /* 821EC590h */ case    4:  		/* cmplwi CR6, R4, 63 */
		/* 821EC590h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000003F);
		/* 821EC590h case    4:*/		return 0x821EC594;
		  /* 821EC594h */ case    5:  		/* bc 12, CR6_GT, 96 */
		/* 821EC594h case    5:*/		if ( regs.CR[6].gt ) { return 0x821EC5F4;  }
		/* 821EC594h case    5:*/		return 0x821EC598;
		  /* 821EC598h */ case    6:  		/* li R11, 0 */
		/* 821EC598h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821EC598h case    6:*/		return 0x821EC59C;
		  /* 821EC59Ch */ case    7:  		/* lis R9, -32255 */
		/* 821EC59Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC59Ch case    7:*/		return 0x821EC5A0;
	}
	return 0x821EC5A0;
} // Block from 821EC580h-821EC5A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC5A0h
// Function '?AttributeMask@D3DXShader@@YAIW4AttributeType@1@000000000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC5A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC5A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC5A0);
		  /* 821EC5A0h */ case    0:  		/* lis R10, -32215 */
		/* 821EC5A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821EC5A0h case    0:*/		return 0x821EC5A4;
		  /* 821EC5A4h */ case    1:  		/* addi R31, R10, -25764 */
		/* 821EC5A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B5C);
		/* 821EC5A4h case    1:*/		return 0x821EC5A8;
		  /* 821EC5A8h */ case    2:  		/* lhz R10, <#[R9 - 8732]> */
		/* 821EC5A8h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFDDE4) );
		/* 821EC5A8h case    2:*/		return 0x821EC5AC;
		  /* 821EC5ACh */ case    3:  		/* sth R10, <#[R31]> */
		/* 821EC5ACh case    3:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821EC5ACh case    3:*/		return 0x821EC5B0;
		  /* 821EC5B0h */ case    4:  		/* mr R10, R31 */
		/* 821EC5B0h case    4:*/		regs.R10 = regs.R31;
		/* 821EC5B0h case    4:*/		return 0x821EC5B4;
		  /* 821EC5B4h */ case    5:  		/* mr R9, R31 */
		/* 821EC5B4h case    5:*/		regs.R9 = regs.R31;
		/* 821EC5B4h case    5:*/		return 0x821EC5B8;
		  /* 821EC5B8h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 821EC5B8h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821EC5B8h case    6:*/		return 0x821EC5BC;
		  /* 821EC5BCh */ case    7:  		/* addi R10, R10, 1 */
		/* 821EC5BCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821EC5BCh case    7:*/		return 0x821EC5C0;
		  /* 821EC5C0h */ case    8:  		/* cmplwi CR6, R8, 0 */
		/* 821EC5C0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821EC5C0h case    8:*/		return 0x821EC5C4;
		  /* 821EC5C4h */ case    9:  		/* bc 4, CR6_EQ, -12 */
		/* 821EC5C4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821EC5B8;  }
		/* 821EC5C4h case    9:*/		return 0x821EC5C8;
		  /* 821EC5C8h */ case   10:  		/* subf R10, R9, R10 */
		/* 821EC5C8h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821EC5C8h case   10:*/		return 0x821EC5CC;
		  /* 821EC5CCh */ case   11:  		/* lis R9, -32255 */
		/* 821EC5CCh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC5CCh case   11:*/		return 0x821EC5D0;
		  /* 821EC5D0h */ case   12:  		/* addi R10, R10, -1 */
		/* 821EC5D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821EC5D0h case   12:*/		return 0x821EC5D4;
		  /* 821EC5D4h */ case   13:  		/* subf R6, R11, R4 */
		/* 821EC5D4h case   13:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R4);
		/* 821EC5D4h case   13:*/		return 0x821EC5D8;
		  /* 821EC5D8h */ case   14:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 821EC5D8h case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 821EC5D8h case   14:*/		return 0x821EC5DC;
		  /* 821EC5DCh */ case   15:  		/* addi R5, R9, -10436 */
		/* 821EC5DCh case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0xFFFFD73C);
		/* 821EC5DCh case   15:*/		return 0x821EC5E0;
		  /* 821EC5E0h */ case   16:  		/* subfic R4, R10, 15 */
		/* 821EC5E0h case   16:*/		cpu::op::subfic<0>(regs,&regs.R4,regs.R10,0xF);
		/* 821EC5E0h case   16:*/		return 0x821EC5E4;
		  /* 821EC5E4h */ case   17:  		/* add R3, R10, R31 */
		/* 821EC5E4h case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R31);
		/* 821EC5E4h case   17:*/		return 0x821EC5E8;
		  /* 821EC5E8h */ case   18:  		/* bl 509888 */
		/* 821EC5E8h case   18:*/		regs.LR = 0x821EC5EC; return 0x82268DA8;
		/* 821EC5E8h case   18:*/		return 0x821EC5EC;
		  /* 821EC5ECh */ case   19:  		/* mr R3, R31 */
		/* 821EC5ECh case   19:*/		regs.R3 = regs.R31;
		/* 821EC5ECh case   19:*/		return 0x821EC5F0;
		  /* 821EC5F0h */ case   20:  		/* b 480 */
		/* 821EC5F0h case   20:*/		return 0x821EC7D0;
		/* 821EC5F0h case   20:*/		return 0x821EC5F4;
	}
	return 0x821EC5F4;
} // Block from 821EC5A0h-821EC5F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EC5F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC5F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC5F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC5F4);
		  /* 821EC5F4h */ case    0:  		/* cmplwi CR6, R4, 319 */
		/* 821EC5F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000013F);
		/* 821EC5F4h case    0:*/		return 0x821EC5F8;
		  /* 821EC5F8h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC5F8h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC614;  }
		/* 821EC5F8h case    1:*/		return 0x821EC5FC;
		  /* 821EC5FCh */ case    2:  		/* lis R9, -32255 */
		/* 821EC5FCh case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC5FCh case    2:*/		return 0x821EC600;
		  /* 821EC600h */ case    3:  		/* lis R10, -32215 */
		/* 821EC600h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821EC600h case    3:*/		return 0x821EC604;
		  /* 821EC604h */ case    4:  		/* li R11, 64 */
		/* 821EC604h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x40);
		/* 821EC604h case    4:*/		return 0x821EC608;
		  /* 821EC608h */ case    5:  		/* addi R31, R10, -25764 */
		/* 821EC608h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B5C);
		/* 821EC608h case    5:*/		return 0x821EC60C;
		  /* 821EC60Ch */ case    6:  		/* lhz R10, <#[R9 - 8736]> */
		/* 821EC60Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFDDE0) );
		/* 821EC60Ch case    6:*/		return 0x821EC610;
	}
	return 0x821EC610;
} // Block from 821EC5F4h-821EC610h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EC610h
// Function '?XenosNormalize@D3DXShader@@YAMM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC610);
		  /* 821EC610h */ case    0:  		/* b -100 */
		/* 821EC610h case    0:*/		return 0x821EC5AC;
		/* 821EC610h case    0:*/		return 0x821EC614;
	}
	return 0x821EC614;
} // Block from 821EC610h-821EC614h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC614);
		  /* 821EC614h */ case    0:  		/* cmplwi CR6, R4, 351 */
		/* 821EC614h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000015F);
		/* 821EC614h case    0:*/		return 0x821EC618;
		  /* 821EC618h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC618h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC634;  }
		/* 821EC618h case    1:*/		return 0x821EC61C;
		  /* 821EC61Ch */ case    2:  		/* lis R9, -32255 */
		/* 821EC61Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC61Ch case    2:*/		return 0x821EC620;
		  /* 821EC620h */ case    3:  		/* lis R10, -32215 */
		/* 821EC620h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821EC620h case    3:*/		return 0x821EC624;
		  /* 821EC624h */ case    4:  		/* li R11, 320 */
		/* 821EC624h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x140);
		/* 821EC624h case    4:*/		return 0x821EC628;
		  /* 821EC628h */ case    5:  		/* addi R31, R10, -25764 */
		/* 821EC628h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B5C);
		/* 821EC628h case    5:*/		return 0x821EC62C;
		  /* 821EC62Ch */ case    6:  		/* lhz R10, <#[R9 - 8780]> */
		/* 821EC62Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFDDB4) );
		/* 821EC62Ch case    6:*/		return 0x821EC630;
		  /* 821EC630h */ case    7:  		/* b -132 */
		/* 821EC630h case    7:*/		return 0x821EC5AC;
		/* 821EC630h case    7:*/		return 0x821EC634;
	}
	return 0x821EC634;
} // Block from 821EC614h-821EC634h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC634);
		  /* 821EC634h */ case    0:  		/* cmplwi CR6, R4, 607 */
		/* 821EC634h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000025F);
		/* 821EC634h case    0:*/		return 0x821EC638;
		  /* 821EC638h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC638h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC654;  }
		/* 821EC638h case    1:*/		return 0x821EC63C;
		  /* 821EC63Ch */ case    2:  		/* lis R9, -32255 */
		/* 821EC63Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC63Ch case    2:*/		return 0x821EC640;
		  /* 821EC640h */ case    3:  		/* lis R10, -32215 */
		/* 821EC640h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821EC640h case    3:*/		return 0x821EC644;
		  /* 821EC644h */ case    4:  		/* li R11, 352 */
		/* 821EC644h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x160);
		/* 821EC644h case    4:*/		return 0x821EC648;
		  /* 821EC648h */ case    5:  		/* addi R31, R10, -25764 */
		/* 821EC648h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B5C);
		/* 821EC648h case    5:*/		return 0x821EC64C;
		  /* 821EC64Ch */ case    6:  		/* lhz R10, <#[R9 - 8800]> */
		/* 821EC64Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFDDA0) );
		/* 821EC64Ch case    6:*/		return 0x821EC650;
	}
	return 0x821EC650;
} // Block from 821EC634h-821EC650h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EC650h
// Function '?GetCurrentFunctionName@Compiler@D3DXShader@@QAAPBDXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC650);
		  /* 821EC650h */ case    0:  		/* b -164 */
		/* 821EC650h case    0:*/		return 0x821EC5AC;
		/* 821EC650h case    0:*/		return 0x821EC654;
	}
	return 0x821EC654;
} // Block from 821EC650h-821EC654h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC654);
		  /* 821EC654h */ case    0:  		/* cmplwi CR6, R4, 623 */
		/* 821EC654h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000026F);
		/* 821EC654h case    0:*/		return 0x821EC658;
		  /* 821EC658h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 821EC658h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC664;  }
		/* 821EC658h case    1:*/		return 0x821EC65C;
		  /* 821EC65Ch */ case    2:  		/* li R11, 608 */
		/* 821EC65Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x260);
		/* 821EC65Ch case    2:*/		return 0x821EC660;
		  /* 821EC660h */ case    3:  		/* b -196 */
		/* 821EC660h case    3:*/		return 0x821EC59C;
		/* 821EC660h case    3:*/		return 0x821EC664;
	}
	return 0x821EC664;
} // Block from 821EC654h-821EC664h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EC664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC664);
		  /* 821EC664h */ case    0:  		/* cmplwi CR6, R4, 687 */
		/* 821EC664h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002AF);
		/* 821EC664h case    0:*/		return 0x821EC668;
		  /* 821EC668h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC668h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC684;  }
		/* 821EC668h case    1:*/		return 0x821EC66C;
		  /* 821EC66Ch */ case    2:  		/* lis R9, -32255 */
		/* 821EC66Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC66Ch case    2:*/		return 0x821EC670;
		  /* 821EC670h */ case    3:  		/* lis R10, -32215 */
		/* 821EC670h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821EC670h case    3:*/		return 0x821EC674;
		  /* 821EC674h */ case    4:  		/* li R11, 624 */
		/* 821EC674h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x270);
		/* 821EC674h case    4:*/		return 0x821EC678;
		  /* 821EC678h */ case    5:  		/* addi R31, R10, -25764 */
		/* 821EC678h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B5C);
		/* 821EC678h case    5:*/		return 0x821EC67C;
		  /* 821EC67Ch */ case    6:  		/* lhz R10, <#[R9 - 8832]> */
		/* 821EC67Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFDD80) );
		/* 821EC67Ch case    6:*/		return 0x821EC680;
		  /* 821EC680h */ case    7:  		/* b -212 */
		/* 821EC680h case    7:*/		return 0x821EC5AC;
		/* 821EC680h case    7:*/		return 0x821EC684;
	}
	return 0x821EC684;
} // Block from 821EC664h-821EC684h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC684);
		  /* 821EC684h */ case    0:  		/* cmplwi CR6, R4, 719 */
		/* 821EC684h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002CF);
		/* 821EC684h case    0:*/		return 0x821EC688;
		  /* 821EC688h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC688h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC6A4;  }
		/* 821EC688h case    1:*/		return 0x821EC68C;
		  /* 821EC68Ch */ case    2:  		/* lis R9, -32255 */
		/* 821EC68Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 821EC68Ch case    2:*/		return 0x821EC690;
		  /* 821EC690h */ case    3:  		/* lis R10, -32215 */
		/* 821EC690h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821EC690h case    3:*/		return 0x821EC694;
		  /* 821EC694h */ case    4:  		/* li R11, 688 */
		/* 821EC694h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x2B0);
		/* 821EC694h case    4:*/		return 0x821EC698;
		  /* 821EC698h */ case    5:  		/* addi R31, R10, -25764 */
		/* 821EC698h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B5C);
		/* 821EC698h case    5:*/		return 0x821EC69C;
		  /* 821EC69Ch */ case    6:  		/* lhz R10, <#[R9 - 8796]> */
		/* 821EC69Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0xFFFFDDA4) );
		/* 821EC69Ch case    6:*/		return 0x821EC6A0;
	}
	return 0x821EC6A0;
} // Block from 821EC684h-821EC6A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EC6A0h
// Function '?SetAllConstraintFlags@Instruction@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC6A0);
		  /* 821EC6A0h */ case    0:  		/* b -244 */
		/* 821EC6A0h case    0:*/		return 0x821EC5AC;
		/* 821EC6A0h case    0:*/		return 0x821EC6A4;
	}
	return 0x821EC6A4;
} // Block from 821EC6A0h-821EC6A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC6A4);
		  /* 821EC6A4h */ case    0:  		/* cmplwi CR6, R4, 720 */
		/* 821EC6A4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D0);
		/* 821EC6A4h case    0:*/		return 0x821EC6A8;
		  /* 821EC6A8h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC6A8h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC6C4;  }
		/* 821EC6A8h case    1:*/		return 0x821EC6AC;
		  /* 821EC6ACh */ case    2:  		/* lis R10, -32255 */
		/* 821EC6ACh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 821EC6ACh case    2:*/		return 0x821EC6B0;
		  /* 821EC6B0h */ case    3:  		/* lis R11, -32215 */
		/* 821EC6B0h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC6B0h case    3:*/		return 0x821EC6B4;
		  /* 821EC6B4h */ case    4:  		/* addi R31, R11, -25764 */
		/* 821EC6B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC6B4h case    4:*/		return 0x821EC6B8;
		  /* 821EC6B8h */ case    5:  		/* lhz R11, <#[R10 - 8740]> */
		/* 821EC6B8h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFDDDC) );
		/* 821EC6B8h case    5:*/		return 0x821EC6BC;
		  /* 821EC6BCh */ case    6:  		/* sth R11, <#[R31]> */
		/* 821EC6BCh case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821EC6BCh case    6:*/		return 0x821EC6C0;
		  /* 821EC6C0h */ case    7:  		/* b -212 */
		/* 821EC6C0h case    7:*/		return 0x821EC5EC;
		/* 821EC6C0h case    7:*/		return 0x821EC6C4;
	}
	return 0x821EC6C4;
} // Block from 821EC6A4h-821EC6C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC6C4);
		  /* 821EC6C4h */ case    0:  		/* cmplwi CR6, R4, 721 */
		/* 821EC6C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D1);
		/* 821EC6C4h case    0:*/		return 0x821EC6C8;
		  /* 821EC6C8h */ case    1:  		/* bc 12, CR6_GT, 24 */
		/* 821EC6C8h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC6E0;  }
		/* 821EC6C8h case    1:*/		return 0x821EC6CC;
		  /* 821EC6CCh */ case    2:  		/* lis R10, -32255 */
		/* 821EC6CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 821EC6CCh case    2:*/		return 0x821EC6D0;
		  /* 821EC6D0h */ case    3:  		/* lis R11, -32215 */
		/* 821EC6D0h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC6D0h case    3:*/		return 0x821EC6D4;
		  /* 821EC6D4h */ case    4:  		/* addi R31, R11, -25764 */
		/* 821EC6D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC6D4h case    4:*/		return 0x821EC6D8;
		  /* 821EC6D8h */ case    5:  		/* lhz R11, <#[R10 - 8828]> */
		/* 821EC6D8h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFDD84) );
		/* 821EC6D8h case    5:*/		return 0x821EC6DC;
		  /* 821EC6DCh */ case    6:  		/* b -32 */
		/* 821EC6DCh case    6:*/		return 0x821EC6BC;
		/* 821EC6DCh case    6:*/		return 0x821EC6E0;
	}
	return 0x821EC6E0;
} // Block from 821EC6C4h-821EC6E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EC6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC6E0);
		  /* 821EC6E0h */ case    0:  		/* cmplwi CR6, R4, 722 */
		/* 821EC6E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D2);
		/* 821EC6E0h case    0:*/		return 0x821EC6E4;
		  /* 821EC6E4h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC6E4h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC700;  }
		/* 821EC6E4h case    1:*/		return 0x821EC6E8;
	}
	return 0x821EC6E8;
} // Block from 821EC6E0h-821EC6E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC6E8h
// Function '?ExpectNodeType@Compiler@D3DXShader@@AAAPAVCNode@2@PAV32@W4_D3DNODE_TYPE@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC6E8);
		  /* 821EC6E8h */ case    0:  		/* lis R10, -32252 */
		/* 821EC6E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 821EC6E8h case    0:*/		return 0x821EC6EC;
		  /* 821EC6ECh */ case    1:  		/* lis R11, -32215 */
		/* 821EC6ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC6ECh case    1:*/		return 0x821EC6F0;
		  /* 821EC6F0h */ case    2:  		/* addi R31, R11, -25764 */
		/* 821EC6F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC6F0h case    2:*/		return 0x821EC6F4;
		  /* 821EC6F4h */ case    3:  		/* lwz R11, <#[R10 - 14572]> */
		/* 821EC6F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFC714) );
		/* 821EC6F4h case    3:*/		return 0x821EC6F8;
		  /* 821EC6F8h */ case    4:  		/* stw R11, <#[R31]> */
		/* 821EC6F8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821EC6F8h case    4:*/		return 0x821EC6FC;
		  /* 821EC6FCh */ case    5:  		/* b -272 */
		/* 821EC6FCh case    5:*/		return 0x821EC5EC;
		/* 821EC6FCh case    5:*/		return 0x821EC700;
	}
	return 0x821EC700;
} // Block from 821EC6E8h-821EC700h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EC700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC700);
		  /* 821EC700h */ case    0:  		/* cmplwi CR6, R4, 723 */
		/* 821EC700h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D3);
		/* 821EC700h case    0:*/		return 0x821EC704;
		  /* 821EC704h */ case    1:  		/* bc 12, CR6_GT, 44 */
		/* 821EC704h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC730;  }
		/* 821EC704h case    1:*/		return 0x821EC708;
		  /* 821EC708h */ case    2:  		/* lis R10, -32252 */
		/* 821EC708h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 821EC708h case    2:*/		return 0x821EC70C;
		  /* 821EC70Ch */ case    3:  		/* lis R11, -32215 */
		/* 821EC70Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC70Ch case    3:*/		return 0x821EC710;
	}
	return 0x821EC710;
} // Block from 821EC700h-821EC710h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EC710h
// Function '?ExpectExpressionNode@Compiler@D3DXShader@@AAAPAVCNodeExpression@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC710);
		  /* 821EC710h */ case    0:  		/* addi R9, R10, -13888 */
		/* 821EC710h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFC9C0);
		/* 821EC710h case    0:*/		return 0x821EC714;
		  /* 821EC714h */ case    1:  		/* addi R31, R11, -25764 */
		/* 821EC714h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC714h case    1:*/		return 0x821EC718;
		  /* 821EC718h */ case    2:  		/* lwz R11, <#[R10 - 13888]> */
		/* 821EC718h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFC9C0) );
		/* 821EC718h case    2:*/		return 0x821EC71C;
		  /* 821EC71Ch */ case    3:  		/* mr R10, R31 */
		/* 821EC71Ch case    3:*/		regs.R10 = regs.R31;
		/* 821EC71Ch case    3:*/		return 0x821EC720;
		  /* 821EC720h */ case    4:  		/* lbz R9, <#[R9 + 4]> */
		/* 821EC720h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821EC720h case    4:*/		return 0x821EC724;
		  /* 821EC724h */ case    5:  		/* stw R11, <#[R31]> */
		/* 821EC724h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821EC724h case    5:*/		return 0x821EC728;
		  /* 821EC728h */ case    6:  		/* stb R9, <#[R31 + 4]> */
		/* 821EC728h case    6:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821EC728h case    6:*/		return 0x821EC72C;
		  /* 821EC72Ch */ case    7:  		/* b -320 */
		/* 821EC72Ch case    7:*/		return 0x821EC5EC;
		/* 821EC72Ch case    7:*/		return 0x821EC730;
	}
	return 0x821EC730;
} // Block from 821EC710h-821EC730h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC730);
		  /* 821EC730h */ case    0:  		/* cmplwi CR6, R4, 724 */
		/* 821EC730h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D4);
		/* 821EC730h case    0:*/		return 0x821EC734;
		  /* 821EC734h */ case    1:  		/* bc 12, CR6_GT, 52 */
		/* 821EC734h case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC768;  }
		/* 821EC734h case    1:*/		return 0x821EC738;
	}
	return 0x821EC738;
} // Block from 821EC730h-821EC738h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC738h
// Function '?ExpectExpressionNode@Compiler@D3DXShader@@AAAPAVCNodeExpression@2@PAVCNode@2@W4_D3DEXPR_OP@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC738);
		  /* 821EC738h */ case    0:  		/* lis R10, -32252 */
		/* 821EC738h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 821EC738h case    0:*/		return 0x821EC73C;
		  /* 821EC73Ch */ case    1:  		/* lis R11, -32215 */
		/* 821EC73Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC73Ch case    1:*/		return 0x821EC740;
		  /* 821EC740h */ case    2:  		/* addi R9, R10, -14584 */
		/* 821EC740h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFC708);
		/* 821EC740h case    2:*/		return 0x821EC744;
		  /* 821EC744h */ case    3:  		/* addi R31, R11, -25764 */
		/* 821EC744h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC744h case    3:*/		return 0x821EC748;
		  /* 821EC748h */ case    4:  		/* lwz R11, <#[R10 - 14584]> */
		/* 821EC748h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFC708) );
		/* 821EC748h case    4:*/		return 0x821EC74C;
		  /* 821EC74Ch */ case    5:  		/* lwz R8, <#[R9 + 4]> */
		/* 821EC74Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 821EC74Ch case    5:*/		return 0x821EC750;
		  /* 821EC750h */ case    6:  		/* mr R10, R31 */
		/* 821EC750h case    6:*/		regs.R10 = regs.R31;
		/* 821EC750h case    6:*/		return 0x821EC754;
		  /* 821EC754h */ case    7:  		/* lhz R9, <#[R9 + 8]> */
		/* 821EC754h case    7:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821EC754h case    7:*/		return 0x821EC758;
		  /* 821EC758h */ case    8:  		/* stw R11, <#[R31]> */
		/* 821EC758h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821EC758h case    8:*/		return 0x821EC75C;
		  /* 821EC75Ch */ case    9:  		/* stw R8, <#[R31 + 4]> */
		/* 821EC75Ch case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 821EC75Ch case    9:*/		return 0x821EC760;
		  /* 821EC760h */ case   10:  		/* sth R9, <#[R31 + 8]> */
		/* 821EC760h case   10:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EC760h case   10:*/		return 0x821EC764;
		  /* 821EC764h */ case   11:  		/* b -376 */
		/* 821EC764h case   11:*/		return 0x821EC5EC;
		/* 821EC764h case   11:*/		return 0x821EC768;
	}
	return 0x821EC768;
} // Block from 821EC738h-821EC768h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EC768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC768);
		  /* 821EC768h */ case    0:  		/* cmplwi CR6, R4, 725 */
		/* 821EC768h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D5);
		/* 821EC768h case    0:*/		return 0x821EC76C;
		  /* 821EC76Ch */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 821EC76Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC788;  }
		/* 821EC76Ch case    1:*/		return 0x821EC770;
	}
	return 0x821EC770;
} // Block from 821EC768h-821EC770h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC770h
// Function '?ExpectExpressionNode@Compiler@D3DXShader@@AAAPAVCNodeExpression@2@PAVCNode@2@W4_D3DEXPR_OP@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC770);
		  /* 821EC770h */ case    0:  		/* lis R10, -32252 */
		/* 821EC770h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 821EC770h case    0:*/		return 0x821EC774;
		  /* 821EC774h */ case    1:  		/* lis R11, -32215 */
		/* 821EC774h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC774h case    1:*/		return 0x821EC778;
		  /* 821EC778h */ case    2:  		/* addi R9, R10, -14596 */
		/* 821EC778h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFC6FC);
		/* 821EC778h case    2:*/		return 0x821EC77C;
		  /* 821EC77Ch */ case    3:  		/* addi R31, R11, -25764 */
		/* 821EC77Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC77Ch case    3:*/		return 0x821EC780;
		  /* 821EC780h */ case    4:  		/* lwz R11, <#[R10 - 14596]> */
		/* 821EC780h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFC6FC) );
		/* 821EC780h case    4:*/		return 0x821EC784;
		  /* 821EC784h */ case    5:  		/* b -56 */
		/* 821EC784h case    5:*/		return 0x821EC74C;
		/* 821EC784h case    5:*/		return 0x821EC788;
	}
	return 0x821EC788;
} // Block from 821EC770h-821EC788h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EC788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC788);
		  /* 821EC788h */ case    0:  		/* cmplwi CR6, R4, 726 */
		/* 821EC788h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D6);
		/* 821EC788h case    0:*/		return 0x821EC78C;
		  /* 821EC78Ch */ case    1:  		/* bc 12, CR6_GT, 60 */
		/* 821EC78Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x821EC7C8;  }
		/* 821EC78Ch case    1:*/		return 0x821EC790;
		  /* 821EC790h */ case    2:  		/* lis R10, -32252 */
		/* 821EC790h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 821EC790h case    2:*/		return 0x821EC794;
		  /* 821EC794h */ case    3:  		/* lis R11, -32215 */
		/* 821EC794h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 821EC794h case    3:*/		return 0x821EC798;
		  /* 821EC798h */ case    4:  		/* addi R9, R10, -13900 */
		/* 821EC798h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFC9B4);
		/* 821EC798h case    4:*/		return 0x821EC79C;
		  /* 821EC79Ch */ case    5:  		/* addi R31, R11, -25764 */
		/* 821EC79Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFF9B5C);
		/* 821EC79Ch case    5:*/		return 0x821EC7A0;
		  /* 821EC7A0h */ case    6:  		/* lwz R11, <#[R10 - 13900]> */
		/* 821EC7A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFC9B4) );
		/* 821EC7A0h case    6:*/		return 0x821EC7A4;
		  /* 821EC7A4h */ case    7:  		/* mr R10, R31 */
		/* 821EC7A4h case    7:*/		regs.R10 = regs.R31;
		/* 821EC7A4h case    7:*/		return 0x821EC7A8;
		  /* 821EC7A8h */ case    8:  		/* lwz R8, <#[R9 + 4]> */
		/* 821EC7A8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 821EC7A8h case    8:*/		return 0x821EC7AC;
		  /* 821EC7ACh */ case    9:  		/* lhz R7, <#[R9 + 8]> */
		/* 821EC7ACh case    9:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 821EC7ACh case    9:*/		return 0x821EC7B0;
		  /* 821EC7B0h */ case   10:  		/* lbz R9, <#[R9 + 10]> */
		/* 821EC7B0h case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000A) );
		/* 821EC7B0h case   10:*/		return 0x821EC7B4;
		  /* 821EC7B4h */ case   11:  		/* stw R11, <#[R31]> */
		/* 821EC7B4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821EC7B4h case   11:*/		return 0x821EC7B8;
		  /* 821EC7B8h */ case   12:  		/* stw R8, <#[R31 + 4]> */
		/* 821EC7B8h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 821EC7B8h case   12:*/		return 0x821EC7BC;
		  /* 821EC7BCh */ case   13:  		/* sth R7, <#[R31 + 8]> */
		/* 821EC7BCh case   13:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 821EC7BCh case   13:*/		return 0x821EC7C0;
		  /* 821EC7C0h */ case   14:  		/* stb R9, <#[R31 + 10]> */
		/* 821EC7C0h case   14:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x0000000A) );
		/* 821EC7C0h case   14:*/		return 0x821EC7C4;
		  /* 821EC7C4h */ case   15:  		/* b -472 */
		/* 821EC7C4h case   15:*/		return 0x821EC5EC;
		/* 821EC7C4h case   15:*/		return 0x821EC7C8;
	}
	return 0x821EC7C8;
} // Block from 821EC788h-821EC7C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EC7C8h
// Function '?ExpectTypeNode@Compiler@D3DXShader@@AAAPAVCNodeType@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC7C8);
		  /* 821EC7C8h */ case    0:  		/* lis R11, -32255 */
		/* 821EC7C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821EC7C8h case    0:*/		return 0x821EC7CC;
		  /* 821EC7CCh */ case    1:  		/* addi R3, R11, -15824 */
		/* 821EC7CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC230);
		/* 821EC7CCh case    1:*/		return 0x821EC7D0;
	}
	return 0x821EC7D0;
} // Block from 821EC7C8h-821EC7D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC7D0);
		  /* 821EC7D0h */ case    0:  		/* addi R1, R1, 96 */
		/* 821EC7D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821EC7D0h case    0:*/		return 0x821EC7D4;
		  /* 821EC7D4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EC7D4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC7D4h case    1:*/		return 0x821EC7D8;
		  /* 821EC7D8h */ case    2:  		/* mtspr LR, R12 */
		/* 821EC7D8h case    2:*/		regs.LR = regs.R12;
		/* 821EC7D8h case    2:*/		return 0x821EC7DC;
		  /* 821EC7DCh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821EC7DCh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC7DCh case    3:*/		return 0x821EC7E0;
		  /* 821EC7E0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821EC7E0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC7E0h case    4:*/		return 0x821EC7E4;
	}
	return 0x821EC7E4;
} // Block from 821EC7D0h-821EC7E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC7E4);
		  /* 821EC7E4h */ case    0:  		/* nop */
		/* 821EC7E4h case    0:*/		cpu::op::nop();
		/* 821EC7E4h case    0:*/		return 0x821EC7E8;
	}
	return 0x821EC7E8;
} // Block from 821EC7E4h-821EC7E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC7E8);
		  /* 821EC7E8h */ case    0:  		/* mfspr R12, LR */
		/* 821EC7E8h case    0:*/		regs.R12 = regs.LR;
		/* 821EC7E8h case    0:*/		return 0x821EC7EC;
		  /* 821EC7ECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EC7ECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC7ECh case    1:*/		return 0x821EC7F0;
	}
	return 0x821EC7F0;
} // Block from 821EC7E8h-821EC7F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EC7F0h
// Function '?ExpectValueNode@Compiler@D3DXShader@@AAAPAVCNodeValue@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC7F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC7F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC7F0);
		  /* 821EC7F0h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 821EC7F0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC7F0h case    0:*/		return 0x821EC7F4;
		  /* 821EC7F4h */ case    1:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EC7F4h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EC7F4h case    1:*/		return 0x821EC7F8;
		  /* 821EC7F8h */ case    2:  		/* lwz R11, <#[R4 + 44]> */
		/* 821EC7F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000002C) );
		/* 821EC7F8h case    2:*/		return 0x821EC7FC;
		  /* 821EC7FCh */ case    3:  		/* mr R31, R3 */
		/* 821EC7FCh case    3:*/		regs.R31 = regs.R3;
		/* 821EC7FCh case    3:*/		return 0x821EC800;
		  /* 821EC800h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EC800h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC800h case    4:*/		return 0x821EC804;
		  /* 821EC804h */ case    5:  		/* bc 12, CR6_EQ, 88 */
		/* 821EC804h case    5:*/		if ( regs.CR[6].eq ) { return 0x821EC85C;  }
		/* 821EC804h case    5:*/		return 0x821EC808;
		  /* 821EC808h */ case    6:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC808h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC808h case    6:*/		return 0x821EC80C;
		  /* 821EC80Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EC80Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC80Ch case    7:*/		return 0x821EC810;
		  /* 821EC810h */ case    8:  		/* addi R11, R11, -1 */
		/* 821EC810h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821EC810h case    8:*/		return 0x821EC814;
		  /* 821EC814h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 821EC814h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821EC81C;  }
		/* 821EC814h case    9:*/		return 0x821EC818;
	}
	return 0x821EC818;
} // Block from 821EC7F0h-821EC818h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EC818h
// Function '?ExpectListNode@Compiler@D3DXShader@@AAAPAVCNodeList@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC818);
		  /* 821EC818h */ case    0:  		/* li R11, 0 */
		/* 821EC818h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821EC818h case    0:*/		return 0x821EC81C;
	}
	return 0x821EC81C;
} // Block from 821EC818h-821EC81Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC81C);
		  /* 821EC81Ch */ case    0:  		/* stw R11, <#[R5]> */
		/* 821EC81Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EC81Ch case    0:*/		return 0x821EC820;
		  /* 821EC820h */ case    1:  		/* lwz R11, <#[R4 + 44]> */
		/* 821EC820h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000002C) );
		/* 821EC820h case    1:*/		return 0x821EC824;
		  /* 821EC824h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821EC824h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EC824h case    2:*/		return 0x821EC828;
		  /* 821EC828h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 821EC828h case    3:*/		if ( regs.CR[6].eq ) { return 0x821EC850;  }
		/* 821EC828h case    3:*/		return 0x821EC82C;
		  /* 821EC82Ch */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 821EC82Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC82Ch case    4:*/		return 0x821EC830;
		  /* 821EC830h */ case    5:  		/* cmpwi CR6, R10, 11 */
		/* 821EC830h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000B);
		/* 821EC830h case    5:*/		return 0x821EC834;
		  /* 821EC834h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 821EC834h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821EC850;  }
		/* 821EC834h case    6:*/		return 0x821EC838;
		  /* 821EC838h */ case    7:  		/* lwz R3, <#[R11 + 16]> */
		/* 821EC838h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 821EC838h case    7:*/		return 0x821EC83C;
		  /* 821EC83Ch */ case    8:  		/* addi R1, R1, 112 */
		/* 821EC83Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EC83Ch case    8:*/		return 0x821EC840;
	}
	return 0x821EC840;
} // Block from 821EC81Ch-821EC840h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EC840h
// Function '?ExpectOptionalListNode@Compiler@D3DXShader@@AAAPAVCNodeList@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC840);
		  /* 821EC840h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EC840h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EC840h case    0:*/		return 0x821EC844;
		  /* 821EC844h */ case    1:  		/* mtspr LR, R12 */
		/* 821EC844h case    1:*/		regs.LR = regs.R12;
		/* 821EC844h case    1:*/		return 0x821EC848;
		  /* 821EC848h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 821EC848h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EC848h case    2:*/		return 0x821EC84C;
		  /* 821EC84Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 821EC84Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EC84Ch case    3:*/		return 0x821EC850;
	}
	return 0x821EC850;
} // Block from 821EC840h-821EC850h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EC850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC850);
		  /* 821EC850h */ case    0:  		/* li R4, 4801 */
		/* 821EC850h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821EC850h case    0:*/		return 0x821EC854;
		  /* 821EC854h */ case    1:  		/* mr R3, R31 */
		/* 821EC854h case    1:*/		regs.R3 = regs.R31;
		/* 821EC854h case    1:*/		return 0x821EC858;
		  /* 821EC858h */ case    2:  		/* bl -633328 */
		/* 821EC858h case    2:*/		regs.LR = 0x821EC85C; return 0x82151E68;
		/* 821EC858h case    2:*/		return 0x821EC85C;
	}
	return 0x821EC85C;
} // Block from 821EC850h-821EC85Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC85C);
		  /* 821EC85Ch */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 821EC85Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821EC85Ch case    0:*/		return 0x821EC860;
		  /* 821EC860h */ case    1:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 821EC860h case    1:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 821EC860h case    1:*/		return 0x821EC864;
		  /* 821EC864h */ case    2:  		/* lwz R11, <#[R4 + 16]> */
		/* 821EC864h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821EC864h case    2:*/		return 0x821EC868;
	}
	return 0x821EC868;
} // Block from 821EC85Ch-821EC868h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC868h
// Function '?MatchesShaderTarget@Compiler@D3DXShader@@AAA_NPAVCNode@2@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC868);
		  /* 821EC868h */ case    0:  		/* bc 12, CR0_EQ, 244 */
		/* 821EC868h case    0:*/		if ( regs.CR[0].eq ) { return 0x821EC95C;  }
		/* 821EC868h case    0:*/		return 0x821EC86C;
		  /* 821EC86Ch */ case    1:  		/* cmplwi CR6, R11, 2 */
		/* 821EC86Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821EC86Ch case    1:*/		return 0x821EC870;
		  /* 821EC870h */ case    2:  		/* bc 4, CR6_EQ, 156 */
		/* 821EC870h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821EC90C;  }
		/* 821EC870h case    2:*/		return 0x821EC874;
		  /* 821EC874h */ case    3:  		/* lwz R6, <#[R31 + 16]> */
		/* 821EC874h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 821EC874h case    3:*/		return 0x821EC878;
		  /* 821EC878h */ case    4:  		/* li R3, 0 */
		/* 821EC878h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EC878h case    4:*/		return 0x821EC87C;
		  /* 821EC87Ch */ case    5:  		/* cmplwi CR6, R6, 0 */
		/* 821EC87Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821EC87Ch case    5:*/		return 0x821EC880;
		  /* 821EC880h */ case    6:  		/* bc 12, CR6_EQ, 100 */
		/* 821EC880h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EC8E4;  }
		/* 821EC880h case    6:*/		return 0x821EC884;
		  /* 821EC884h */ case    7:  		/* lwz R7, <#[R31 + 12]> */
		/* 821EC884h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 821EC884h case    7:*/		return 0x821EC888;
		  /* 821EC888h */ case    8:  		/* li R8, 0 */
		/* 821EC888h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821EC888h case    8:*/		return 0x821EC88C;
		  /* 821EC88Ch */ case    9:  		/* lwzx R10, <#[R8 + R7]> */
		/* 821EC88Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 821EC88Ch case    9:*/		return 0x821EC890;
		  /* 821EC890h */ case   10:  		/* add R11, R8, R7 */
		/* 821EC890h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R7);
		/* 821EC890h case   10:*/		return 0x821EC894;
		  /* 821EC894h */ case   11:  		/* rlwinm. R9, R10, 0, 12, 12 */
		/* 821EC894h case   11:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R9,regs.R10);
		/* 821EC894h case   11:*/		return 0x821EC898;
		  /* 821EC898h */ case   12:  		/* bc 12, CR0_EQ, 60 */
		/* 821EC898h case   12:*/		if ( regs.CR[0].eq ) { return 0x821EC8D4;  }
		/* 821EC898h case   12:*/		return 0x821EC89C;
		  /* 821EC89Ch */ case   13:  		/* lwz R9, <#[R11 + 4]> */
		/* 821EC89Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821EC89Ch case   13:*/		return 0x821EC8A0;
		  /* 821EC8A0h */ case   14:  		/* rlwinm R11, R9, 28, 29, 31 */
		/* 821EC8A0h case   14:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R9);
		/* 821EC8A0h case   14:*/		return 0x821EC8A4;
		  /* 821EC8A4h */ case   15:  		/* cmplwi CR6, R11, 2 */
		/* 821EC8A4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821EC8A4h case   15:*/		return 0x821EC8A8;
		  /* 821EC8A8h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 821EC8A8h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EC8B4;  }
		/* 821EC8A8h case   16:*/		return 0x821EC8AC;
		  /* 821EC8ACh */ case   17:  		/* cmplwi CR6, R11, 7 */
		/* 821EC8ACh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 821EC8ACh case   17:*/		return 0x821EC8B0;
		  /* 821EC8B0h */ case   18:  		/* bc 4, CR6_EQ, 36 */
		/* 821EC8B0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821EC8D4;  }
		/* 821EC8B0h case   18:*/		return 0x821EC8B4;
	}
	return 0x821EC8B4;
} // Block from 821EC868h-821EC8B4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821EC8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC8B4);
		  /* 821EC8B4h */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC8B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC8B4h case    0:*/		return 0x821EC8B8;
		  /* 821EC8B8h */ case    1:  		/* rlwinm R10, R10, 12, 23, 31 */
		/* 821EC8B8h case    1:*/		cpu::op::rlwinm<0,12,23,31>(regs,&regs.R10,regs.R10);
		/* 821EC8B8h case    1:*/		return 0x821EC8BC;
		  /* 821EC8BCh */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 821EC8BCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821EC8BCh case    2:*/		return 0x821EC8C0;
		  /* 821EC8C0h */ case    3:  		/* bc 12, CR6_LT, 20 */
		/* 821EC8C0h case    3:*/		if ( regs.CR[6].lt ) { return 0x821EC8D4;  }
		/* 821EC8C0h case    3:*/		return 0x821EC8C4;
		  /* 821EC8C4h */ case    4:  		/* rlwinm R9, R9, 16, 23, 31 */
		/* 821EC8C4h case    4:*/		cpu::op::rlwinm<0,16,23,31>(regs,&regs.R9,regs.R9);
		/* 821EC8C4h case    4:*/		return 0x821EC8C8;
		  /* 821EC8C8h */ case    5:  		/* add R10, R9, R10 */
		/* 821EC8C8h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821EC8C8h case    5:*/		return 0x821EC8CC;
		  /* 821EC8CCh */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 821EC8CCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821EC8CCh case    6:*/		return 0x821EC8D0;
		  /* 821EC8D0h */ case    7:  		/* bc 12, CR6_LT, -148 */
		/* 821EC8D0h case    7:*/		if ( regs.CR[6].lt ) { return 0x821EC83C;  }
		/* 821EC8D0h case    7:*/		return 0x821EC8D4;
	}
	return 0x821EC8D4;
} // Block from 821EC8B4h-821EC8D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EC8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC8D4);
		  /* 821EC8D4h */ case    0:  		/* addi R3, R3, 1 */
		/* 821EC8D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821EC8D4h case    0:*/		return 0x821EC8D8;
		  /* 821EC8D8h */ case    1:  		/* addi R8, R8, 40 */
		/* 821EC8D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x28);
		/* 821EC8D8h case    1:*/		return 0x821EC8DC;
		  /* 821EC8DCh */ case    2:  		/* cmplw CR6, R3, R6 */
		/* 821EC8DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R6);
		/* 821EC8DCh case    2:*/		return 0x821EC8E0;
		  /* 821EC8E0h */ case    3:  		/* bc 12, CR6_LT, -84 */
		/* 821EC8E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x821EC88C;  }
		/* 821EC8E0h case    3:*/		return 0x821EC8E4;
	}
	return 0x821EC8E4;
} // Block from 821EC8D4h-821EC8E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EC8E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC8E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC8E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC8E4);
		  /* 821EC8E4h */ case    0:  		/* lis R11, -32252 */
		/* 821EC8E4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821EC8E4h case    0:*/		return 0x821EC8E8;
		  /* 821EC8E8h */ case    1:  		/* lwz R6, <#[R4 + 24]> */
		/* 821EC8E8h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC8E8h case    1:*/		return 0x821EC8EC;
		  /* 821EC8ECh */ case    2:  		/* li R4, 10 */
		/* 821EC8ECh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xA);
		/* 821EC8ECh case    2:*/		return 0x821EC8F0;
		  /* 821EC8F0h */ case    3:  		/* addi R5, R11, -13880 */
		/* 821EC8F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFC9C8);
		/* 821EC8F0h case    3:*/		return 0x821EC8F4;
		  /* 821EC8F4h */ case    4:  		/* addi R3, R1, 80 */
		/* 821EC8F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821EC8F4h case    4:*/		return 0x821EC8F8;
		  /* 821EC8F8h */ case    5:  		/* bl 509104 */
		/* 821EC8F8h case    5:*/		regs.LR = 0x821EC8FC; return 0x82268DA8;
		/* 821EC8F8h case    5:*/		return 0x821EC8FC;
		  /* 821EC8FCh */ case    6:  		/* addi R5, R1, 80 */
		/* 821EC8FCh case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821EC8FCh case    6:*/		return 0x821EC900;
		  /* 821EC900h */ case    7:  		/* li R4, 3521 */
		/* 821EC900h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xDC1);
		/* 821EC900h case    7:*/		return 0x821EC904;
		  /* 821EC904h */ case    8:  		/* mr R3, R31 */
		/* 821EC904h case    8:*/		regs.R3 = regs.R31;
		/* 821EC904h case    8:*/		return 0x821EC908;
	}
	return 0x821EC908;
} // Block from 821EC8E4h-821EC908h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EC908h
// Function '?GetTypeShape@Compiler@D3DXShader@@AAA_NPAVCNode@2@PAI1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC908);
		  /* 821EC908h */ case    0:  		/* bl -633504 */
		/* 821EC908h case    0:*/		regs.LR = 0x821EC90C; return 0x82151E68;
		/* 821EC908h case    0:*/		return 0x821EC90C;
	}
	return 0x821EC90C;
} // Block from 821EC908h-821EC90Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EC90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC90C);
		  /* 821EC90Ch */ case    0:  		/* cmplwi CR6, R11, 4 */
		/* 821EC90Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821EC90Ch case    0:*/		return 0x821EC910;
		  /* 821EC910h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 821EC910h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EC920;  }
		/* 821EC910h case    1:*/		return 0x821EC914;
		  /* 821EC914h */ case    2:  		/* li R4, 3554 */
		/* 821EC914h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xDE2);
		/* 821EC914h case    2:*/		return 0x821EC918;
		  /* 821EC918h */ case    3:  		/* mr R3, R31 */
		/* 821EC918h case    3:*/		regs.R3 = regs.R31;
		/* 821EC918h case    3:*/		return 0x821EC91C;
		  /* 821EC91Ch */ case    4:  		/* bl -633524 */
		/* 821EC91Ch case    4:*/		regs.LR = 0x821EC920; return 0x82151E68;
		/* 821EC91Ch case    4:*/		return 0x821EC920;
	}
	return 0x821EC920;
} // Block from 821EC90Ch-821EC920h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EC920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC920);
		  /* 821EC920h */ case    0:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC920h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC920h case    0:*/		return 0x821EC924;
		  /* 821EC924h */ case    1:  		/* cmplwi CR6, R11, 32 */
		/* 821EC924h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 821EC924h case    1:*/		return 0x821EC928;
		  /* 821EC928h */ case    2:  		/* bc 12, CR6_LT, 40 */
		/* 821EC928h case    2:*/		if ( regs.CR[6].lt ) { return 0x821EC950;  }
		/* 821EC928h case    2:*/		return 0x821EC92C;
		  /* 821EC92Ch */ case    3:  		/* cmplwi CR6, R11, 37 */
		/* 821EC92Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000025);
		/* 821EC92Ch case    3:*/		return 0x821EC930;
		  /* 821EC930h */ case    4:  		/* bc 12, CR6_GT, 32 */
		/* 821EC930h case    4:*/		if ( regs.CR[6].gt ) { return 0x821EC950;  }
		/* 821EC930h case    4:*/		return 0x821EC934;
		  /* 821EC934h */ case    5:  		/* li R11, 0 */
		/* 821EC934h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821EC934h case    5:*/		return 0x821EC938;
		  /* 821EC938h */ case    6:  		/* stw R11, <#[R5]> */
		/* 821EC938h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821EC938h case    6:*/		return 0x821EC93C;
		  /* 821EC93Ch */ case    7:  		/* lwz R10, <#[R31 + 600]> */
		/* 821EC93Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000258) );
		/* 821EC93Ch case    7:*/		return 0x821EC940;
		  /* 821EC940h */ case    8:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC940h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC940h case    8:*/		return 0x821EC944;
		  /* 821EC944h */ case    9:  		/* add R11, R10, R11 */
		/* 821EC944h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EC944h case    9:*/		return 0x821EC948;
		  /* 821EC948h */ case   10:  		/* addi R3, R11, -32 */
		/* 821EC948h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFE0);
		/* 821EC948h case   10:*/		return 0x821EC94C;
		  /* 821EC94Ch */ case   11:  		/* b -272 */
		/* 821EC94Ch case   11:*/		return 0x821EC83C;
		/* 821EC94Ch case   11:*/		return 0x821EC950;
	}
	return 0x821EC950;
} // Block from 821EC920h-821EC950h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EC950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC950);
		  /* 821EC950h */ case    0:  		/* li R4, 3540 */
		/* 821EC950h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDD4);
		/* 821EC950h case    0:*/		return 0x821EC954;
		  /* 821EC954h */ case    1:  		/* mr R3, R31 */
		/* 821EC954h case    1:*/		regs.R3 = regs.R31;
		/* 821EC954h case    1:*/		return 0x821EC958;
		  /* 821EC958h */ case    2:  		/* bl -633584 */
		/* 821EC958h case    2:*/		regs.LR = 0x821EC95C; return 0x82151E68;
		/* 821EC958h case    2:*/		return 0x821EC95C;
	}
	return 0x821EC95C;
} // Block from 821EC950h-821EC95Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EC95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC95C);
		  /* 821EC95Ch */ case    0:  		/* cmplwi CR6, R11, 19 */
		/* 821EC95Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 821EC95Ch case    0:*/		return 0x821EC960;
		  /* 821EC960h */ case    1:  		/* bc 12, CR6_GT, 212 */
		/* 821EC960h case    1:*/		if ( regs.CR[6].gt ) { return 0x821ECA34;  }
		/* 821EC960h case    1:*/		return 0x821EC964;
		  /* 821EC964h */ case    2:  		/* lis R12, -32252 */
		/* 821EC964h case    2:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8204);
		/* 821EC964h case    2:*/		return 0x821EC968;
		  /* 821EC968h */ case    3:  		/* addi R12, R12, -14432 */
		/* 821EC968h case    3:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFC7A0);
		/* 821EC968h case    3:*/		return 0x821EC96C;
		  /* 821EC96Ch */ case    4:  		/* lbzx R0, <#[R12 + R11]> */
		/* 821EC96Ch case    4:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R11 + 0x00000000) );
		/* 821EC96Ch case    4:*/		return 0x821EC970;
		  /* 821EC970h */ case    5:  		/* lis R12, -32225 */
		/* 821EC970h case    5:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF821F);
		/* 821EC970h case    5:*/		return 0x821EC974;
		  /* 821EC974h */ case    6:  		/* ori R0, R0, 0 */
		/* 821EC974h case    6:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 821EC974h case    6:*/		return 0x821EC978;
		  /* 821EC978h */ case    7:  		/* addi R12, R12, -13940 */
		/* 821EC978h case    7:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFC98C);
		/* 821EC978h case    7:*/		return 0x821EC97C;
		  /* 821EC97Ch */ case    8:  		/* ori R0, R0, 0 */
		/* 821EC97Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 821EC97Ch case    8:*/		return 0x821EC980;
		  /* 821EC980h */ case    9:  		/* add R12, R12, R0 */
		/* 821EC980h case    9:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 821EC980h case    9:*/		return 0x821EC984;
		  /* 821EC984h */ case   10:  		/* mtspr CTR, R12 */
		/* 821EC984h case   10:*/		regs.CTR = regs.R12;
		/* 821EC984h case   10:*/		return 0x821EC988;
		  /* 821EC988h */ case   11:  		/* bcctr 20, CR0_LT */
		/* 821EC988h case   11:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 821EC988h case   11:*/		return 0x821EC98C;
		  /* 821EC98Ch */ case   12:  		/* lwz R3, <#[R4 + 24]> */
		/* 821EC98Ch case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC98Ch case   12:*/		return 0x821EC990;
		  /* 821EC990h */ case   13:  		/* b 84 */
		/* 821EC990h case   13:*/		return 0x821EC9E4;
		/* 821EC990h case   13:*/		return 0x821EC994;
		  /* 821EC994h */ case   14:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC994h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC994h case   14:*/		return 0x821EC998;
		  /* 821EC998h */ case   15:  		/* addi R3, R11, 64 */
		/* 821EC998h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x40);
		/* 821EC998h case   15:*/		return 0x821EC99C;
		  /* 821EC99Ch */ case   16:  		/* b 72 */
		/* 821EC99Ch case   16:*/		return 0x821EC9E4;
		/* 821EC99Ch case   16:*/		return 0x821EC9A0;
		  /* 821EC9A0h */ case   17:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC9A0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC9A0h case   17:*/		return 0x821EC9A4;
		  /* 821EC9A4h */ case   18:  		/* addi R3, R11, 720 */
		/* 821EC9A4h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2D0);
		/* 821EC9A4h case   18:*/		return 0x821EC9A8;
		  /* 821EC9A8h */ case   19:  		/* b 60 */
		/* 821EC9A8h case   19:*/		return 0x821EC9E4;
		/* 821EC9A8h case   19:*/		return 0x821EC9AC;
		  /* 821EC9ACh */ case   20:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC9ACh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC9ACh case   20:*/		return 0x821EC9B0;
	}
	return 0x821EC9B0;
} // Block from 821EC95Ch-821EC9B0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EC9B0h
// Function '?GetLeafNodeShape@Compiler@D3DXShader@@AAA_NPAVCNode@2@PAI1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC9B0);
		  /* 821EC9B0h */ case    0:  		/* addi R3, R11, 624 */
		/* 821EC9B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x270);
		/* 821EC9B0h case    0:*/		return 0x821EC9B4;
		  /* 821EC9B4h */ case    1:  		/* b 48 */
		/* 821EC9B4h case    1:*/		return 0x821EC9E4;
		/* 821EC9B4h case    1:*/		return 0x821EC9B8;
		  /* 821EC9B8h */ case    2:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC9B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC9B8h case    2:*/		return 0x821EC9BC;
		  /* 821EC9BCh */ case    3:  		/* addi R3, R11, 688 */
		/* 821EC9BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2B0);
		/* 821EC9BCh case    3:*/		return 0x821EC9C0;
		  /* 821EC9C0h */ case    4:  		/* b 36 */
		/* 821EC9C0h case    4:*/		return 0x821EC9E4;
		/* 821EC9C0h case    4:*/		return 0x821EC9C4;
		  /* 821EC9C4h */ case    5:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC9C4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC9C4h case    5:*/		return 0x821EC9C8;
		  /* 821EC9C8h */ case    6:  		/* addi R3, R11, 352 */
		/* 821EC9C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x160);
		/* 821EC9C8h case    6:*/		return 0x821EC9CC;
		  /* 821EC9CCh */ case    7:  		/* b 24 */
		/* 821EC9CCh case    7:*/		return 0x821EC9E4;
		/* 821EC9CCh case    7:*/		return 0x821EC9D0;
		  /* 821EC9D0h */ case    8:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC9D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC9D0h case    8:*/		return 0x821EC9D4;
		  /* 821EC9D4h */ case    9:  		/* addi R3, R11, 320 */
		/* 821EC9D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x140);
		/* 821EC9D4h case    9:*/		return 0x821EC9D8;
		  /* 821EC9D8h */ case   10:  		/* b 12 */
		/* 821EC9D8h case   10:*/		return 0x821EC9E4;
		/* 821EC9D8h case   10:*/		return 0x821EC9DC;
		  /* 821EC9DCh */ case   11:  		/* lwz R11, <#[R4 + 24]> */
		/* 821EC9DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 821EC9DCh case   11:*/		return 0x821EC9E0;
		  /* 821EC9E0h */ case   12:  		/* addi R3, R11, 721 */
		/* 821EC9E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2D1);
		/* 821EC9E0h case   12:*/		return 0x821EC9E4;
	}
	return 0x821EC9E4;
} // Block from 821EC9B0h-821EC9E4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821EC9E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EC9E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EC9E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EC9E4);
		  /* 821EC9E4h */ case    0:  		/* lwz R9, <#[R31 + 12]> */
		/* 821EC9E4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 821EC9E4h case    0:*/		return 0x821EC9E8;
		  /* 821EC9E8h */ case    1:  		/* mulli R11, R3, 40 */
		/* 821EC9E8h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R3,0x28);
		/* 821EC9E8h case    1:*/		return 0x821EC9EC;
		  /* 821EC9ECh */ case    2:  		/* lwzx R10, <#[R11 + R9]> */
		/* 821EC9ECh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821EC9ECh case    2:*/		return 0x821EC9F0;
		  /* 821EC9F0h */ case    3:  		/* rlwinm R8, R10, 0, 29, 31 */
		/* 821EC9F0h case    3:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R8,regs.R10);
		/* 821EC9F0h case    3:*/		return 0x821EC9F4;
		  /* 821EC9F4h */ case    4:  		/* li R10, 0 */
		/* 821EC9F4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821EC9F4h case    4:*/		return 0x821EC9F8;
		  /* 821EC9F8h */ case    5:  		/* b 32 */
		/* 821EC9F8h case    5:*/		return 0x821ECA18;
		/* 821EC9F8h case    5:*/		return 0x821EC9FC;
		  /* 821EC9FCh */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 821EC9FCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821EC9FCh case    6:*/		return 0x821ECA00;
		  /* 821ECA00h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 821ECA00h case    7:*/		if ( regs.CR[6].eq ) { return 0x821ECA28;  }
		/* 821ECA00h case    7:*/		return 0x821ECA04;
		  /* 821ECA04h */ case    8:  		/* addi R11, R11, -40 */
		/* 821ECA04h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 821ECA04h case    8:*/		return 0x821ECA08;
		  /* 821ECA08h */ case    9:  		/* addi R3, R3, -1 */
		/* 821ECA08h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFF);
		/* 821ECA08h case    9:*/		return 0x821ECA0C;
		  /* 821ECA0Ch */ case   10:  		/* addi R10, R10, 1 */
		/* 821ECA0Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821ECA0Ch case   10:*/		return 0x821ECA10;
		  /* 821ECA10h */ case   11:  		/* lwzx R8, <#[R11 + R9]> */
		/* 821ECA10h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821ECA10h case   11:*/		return 0x821ECA14;
		  /* 821ECA14h */ case   12:  		/* rlwinm R8, R8, 0, 29, 31 */
		/* 821ECA14h case   12:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R8,regs.R8);
		/* 821ECA14h case   12:*/		return 0x821ECA18;
	}
	return 0x821ECA18;
} // Block from 821EC9E4h-821ECA18h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA18);
		  /* 821ECA18h */ case    0:  		/* cmplwi CR6, R8, 5 */
		/* 821ECA18h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000005);
		/* 821ECA18h case    0:*/		return 0x821ECA1C;
		  /* 821ECA1Ch */ case    1:  		/* bc 12, CR6_EQ, -32 */
		/* 821ECA1Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821EC9FC;  }
		/* 821ECA1Ch case    1:*/		return 0x821ECA20;
		  /* 821ECA20h */ case    2:  		/* stw R10, <#[R5]> */
		/* 821ECA20h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 821ECA20h case    2:*/		return 0x821ECA24;
		  /* 821ECA24h */ case    3:  		/* b -488 */
		/* 821ECA24h case    3:*/		return 0x821EC83C;
		/* 821ECA24h case    3:*/		return 0x821ECA28;
	}
	return 0x821ECA28;
} // Block from 821ECA18h-821ECA28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA28);
		  /* 821ECA28h */ case    0:  		/* li R4, 4800 */
		/* 821ECA28h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821ECA28h case    0:*/		return 0x821ECA2C;
		  /* 821ECA2Ch */ case    1:  		/* mr R3, R31 */
		/* 821ECA2Ch case    1:*/		regs.R3 = regs.R31;
		/* 821ECA2Ch case    1:*/		return 0x821ECA30;
	}
	return 0x821ECA30;
} // Block from 821ECA28h-821ECA30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA30h
// Function '?GetNodeShape@Compiler@D3DXShader@@AAA_NPAVCNode@2@PAI1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA30);
		  /* 821ECA30h */ case    0:  		/* bl -633800 */
		/* 821ECA30h case    0:*/		regs.LR = 0x821ECA34; return 0x82151E68;
		/* 821ECA30h case    0:*/		return 0x821ECA34;
	}
	return 0x821ECA34;
} // Block from 821ECA30h-821ECA34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA34);
		  /* 821ECA34h */ case    0:  		/* li R4, 4801 */
		/* 821ECA34h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ECA34h case    0:*/		return 0x821ECA38;
		  /* 821ECA38h */ case    1:  		/* mr R3, R31 */
		/* 821ECA38h case    1:*/		regs.R3 = regs.R31;
		/* 821ECA38h case    1:*/		return 0x821ECA3C;
		  /* 821ECA3Ch */ case    2:  		/* bl -633812 */
		/* 821ECA3Ch case    2:*/		regs.LR = 0x821ECA40; return 0x82151E68;
		/* 821ECA3Ch case    2:*/		return 0x821ECA40;
	}
	return 0x821ECA40;
} // Block from 821ECA34h-821ECA40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA40);
		  /* 821ECA40h */ case    0:  		/* mfspr R12, LR */
		/* 821ECA40h case    0:*/		regs.R12 = regs.LR;
		/* 821ECA40h case    0:*/		return 0x821ECA44;
		  /* 821ECA44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821ECA44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ECA44h case    1:*/		return 0x821ECA48;
		  /* 821ECA48h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821ECA48h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ECA48h case    2:*/		return 0x821ECA4C;
		  /* 821ECA4Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821ECA4Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821ECA4Ch case    3:*/		return 0x821ECA50;
		  /* 821ECA50h */ case    4:  		/* lwz R11, <#[R3 + 12]> */
		/* 821ECA50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECA50h case    4:*/		return 0x821ECA54;
		  /* 821ECA54h */ case    5:  		/* mulli R10, R4, 40 */
		/* 821ECA54h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R4,0x28);
		/* 821ECA54h case    5:*/		return 0x821ECA58;
		  /* 821ECA58h */ case    6:  		/* add R11, R10, R11 */
		/* 821ECA58h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821ECA58h case    6:*/		return 0x821ECA5C;
		  /* 821ECA5Ch */ case    7:  		/* lwz R11, <#[R11 + 12]> */
		/* 821ECA5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821ECA5Ch case    7:*/		return 0x821ECA60;
	}
	return 0x821ECA60;
} // Block from 821ECA40h-821ECA60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA60h
// Function '?GetNodeSize@Compiler@D3DXShader@@AAA_NPAVCNode@2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA60);
		  /* 821ECA60h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821ECA60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ECA60h case    0:*/		return 0x821ECA64;
		  /* 821ECA64h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 821ECA64h case    1:*/		if ( regs.CR[6].eq ) { return 0x821ECA9C;  }
		/* 821ECA64h case    1:*/		return 0x821ECA68;
		  /* 821ECA68h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ECA68h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ECA68h case    2:*/		return 0x821ECA6C;
		  /* 821ECA6Ch */ case    3:  		/* cmpwi CR6, R10, 6 */
		/* 821ECA6Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000006);
		/* 821ECA6Ch case    3:*/		return 0x821ECA70;
		  /* 821ECA70h */ case    4:  		/* bc 4, CR6_EQ, 44 */
		/* 821ECA70h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821ECA9C;  }
		/* 821ECA70h case    4:*/		return 0x821ECA74;
		  /* 821ECA74h */ case    5:  		/* lwz R11, <#[R11 + 20]> */
		/* 821ECA74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821ECA74h case    5:*/		return 0x821ECA78;
		  /* 821ECA78h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821ECA78h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ECA78h case    6:*/		return 0x821ECA7C;
		  /* 821ECA7Ch */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 821ECA7Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821ECA94;  }
		/* 821ECA7Ch case    7:*/		return 0x821ECA80;
		  /* 821ECA80h */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ECA80h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ECA80h case    8:*/		return 0x821ECA84;
		  /* 821ECA84h */ case    9:  		/* cmpwi CR6, R10, 3 */
		/* 821ECA84h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821ECA84h case    9:*/		return 0x821ECA88;
		  /* 821ECA88h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 821ECA88h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821ECA94;  }
		/* 821ECA88h case   10:*/		return 0x821ECA8C;
		  /* 821ECA8Ch */ case   11:  		/* lwz R3, <#[R11 + 24]> */
		/* 821ECA8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000018) );
		/* 821ECA8Ch case   11:*/		return 0x821ECA90;
		  /* 821ECA90h */ case   12:  		/* b 236 */
		/* 821ECA90h case   12:*/		return 0x821ECB7C;
		/* 821ECA90h case   12:*/		return 0x821ECA94;
	}
	return 0x821ECA94;
} // Block from 821ECA60h-821ECA94h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA94);
		  /* 821ECA94h */ case    0:  		/* li R4, 4801 */
		/* 821ECA94h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ECA94h case    0:*/		return 0x821ECA98;
		  /* 821ECA98h */ case    1:  		/* bl -633904 */
		/* 821ECA98h case    1:*/		regs.LR = 0x821ECA9C; return 0x82151E68;
		/* 821ECA98h case    1:*/		return 0x821ECA9C;
	}
	return 0x821ECA9C;
} // Block from 821ECA94h-821ECA9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECA9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECA9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECA9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECA9C);
		  /* 821ECA9Ch */ case    0:  		/* lwz R11, <#[R3 + 40]> */
		/* 821ECA9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 821ECA9Ch case    0:*/		return 0x821ECAA0;
		  /* 821ECAA0h */ case    1:  		/* rlwinm. R10, R11, 0, 15, 15 */
		/* 821ECAA0h case    1:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R10,regs.R11);
		/* 821ECAA0h case    1:*/		return 0x821ECAA4;
		  /* 821ECAA4h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 821ECAA4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821ECAB8;  }
		/* 821ECAA4h case    2:*/		return 0x821ECAA8;
		  /* 821ECAA8h */ case    3:  		/* cmplwi CR6, R4, 727 */
		/* 821ECAA8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x000002D7);
		/* 821ECAA8h case    3:*/		return 0x821ECAAC;
		  /* 821ECAACh */ case    4:  		/* bc 4, CR6_LT, 12 */
		/* 821ECAACh case    4:*/		if ( !regs.CR[6].lt ) { return 0x821ECAB8;  }
		/* 821ECAACh case    4:*/		return 0x821ECAB0;
		  /* 821ECAB0h */ case    5:  		/* bl -1328 */
		/* 821ECAB0h case    5:*/		regs.LR = 0x821ECAB4; return 0x821EC580;
		/* 821ECAB0h case    5:*/		return 0x821ECAB4;
		  /* 821ECAB4h */ case    6:  		/* b 200 */
		/* 821ECAB4h case    6:*/		return 0x821ECB7C;
		/* 821ECAB4h case    6:*/		return 0x821ECAB8;
	}
	return 0x821ECAB8;
} // Block from 821ECA9Ch-821ECAB8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821ECAB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECAB8);
		  /* 821ECAB8h */ case    0:  		/* rlwinm. R11, R11, 0, 13, 13 */
		/* 821ECAB8h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R11);
		/* 821ECAB8h case    0:*/		return 0x821ECABC;
		  /* 821ECABCh */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 821ECABCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821ECAF0;  }
		/* 821ECABCh case    1:*/		return 0x821ECAC0;
		  /* 821ECAC0h */ case    2:  		/* lwz R11, <#[R3 + 600]> */
		/* 821ECAC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000258) );
		/* 821ECAC0h case    2:*/		return 0x821ECAC4;
		  /* 821ECAC4h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 821ECAC4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821ECAC4h case    3:*/		return 0x821ECAC8;
		  /* 821ECAC8h */ case    4:  		/* bc 12, CR6_LT, 40 */
		/* 821ECAC8h case    4:*/		if ( regs.CR[6].lt ) { return 0x821ECAF0;  }
		/* 821ECAC8h case    4:*/		return 0x821ECACC;
		  /* 821ECACCh */ case    5:  		/* addi R10, R11, 12 */
		/* 821ECACCh case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xC);
		/* 821ECACCh case    5:*/		return 0x821ECAD0;
		  /* 821ECAD0h */ case    6:  		/* cmplw CR6, R4, R10 */
		/* 821ECAD0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 821ECAD0h case    6:*/		return 0x821ECAD4;
		  /* 821ECAD4h */ case    7:  		/* bc 4, CR6_LT, 28 */
		/* 821ECAD4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x821ECAF0;  }
		/* 821ECAD4h case    7:*/		return 0x821ECAD8;
		  /* 821ECAD8h */ case    8:  		/* subf R11, R11, R4 */
		/* 821ECAD8h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821ECAD8h case    8:*/		return 0x821ECADC;
		  /* 821ECADCh */ case    9:  		/* lis R10, -32217 */
		/* 821ECADCh case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 821ECADCh case    9:*/		return 0x821ECAE0;
		  /* 821ECAE0h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821ECAE0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821ECAE0h case   10:*/		return 0x821ECAE4;
		  /* 821ECAE4h */ case   11:  		/* addi R10, R10, 22080 */
		/* 821ECAE4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x5640);
		/* 821ECAE4h case   11:*/		return 0x821ECAE8;
		  /* 821ECAE8h */ case   12:  		/* lwzx R3, <#[R11 + R10]> */
		/* 821ECAE8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821ECAE8h case   12:*/		return 0x821ECAEC;
		  /* 821ECAECh */ case   13:  		/* b 144 */
		/* 821ECAECh case   13:*/		return 0x821ECB7C;
		/* 821ECAECh case   13:*/		return 0x821ECAF0;
	}
	return 0x821ECAF0;
} // Block from 821ECAB8h-821ECAF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821ECAF0h
// Function '?GetSemanticToken@Compiler@D3DXShader@@AAAPAVCNodeToken@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECAF0);
		  /* 821ECAF0h */ case    0:  		/* lwz R11, <#[R3 + 604]> */
		/* 821ECAF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000025C) );
		/* 821ECAF0h case    0:*/		return 0x821ECAF4;
		  /* 821ECAF4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821ECAF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ECAF4h case    1:*/		return 0x821ECAF8;
		  /* 821ECAF8h */ case    2:  		/* bc 12, CR6_EQ, 92 */
		/* 821ECAF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821ECB54;  }
		/* 821ECAF8h case    2:*/		return 0x821ECAFC;
		  /* 821ECAFCh */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 821ECAFCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821ECAFCh case    3:*/		return 0x821ECB00;
		  /* 821ECB00h */ case    4:  		/* bc 12, CR6_LT, 84 */
		/* 821ECB00h case    4:*/		if ( regs.CR[6].lt ) { return 0x821ECB54;  }
		/* 821ECB00h case    4:*/		return 0x821ECB04;
		  /* 821ECB04h */ case    5:  		/* lwz R10, <#[R3 + 20]> */
		/* 821ECB04h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 821ECB04h case    5:*/		return 0x821ECB08;
		  /* 821ECB08h */ case    6:  		/* rlwinm R8, R11, 0, 0, 31 */
		/* 821ECB08h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R11);
		/* 821ECB08h case    6:*/		return 0x821ECB0C;
		  /* 821ECB0Ch */ case    7:  		/* lwz R9, <#[R3 + 600]> */
		/* 821ECB0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000258) );
		/* 821ECB0Ch case    7:*/		return 0x821ECB10;
		  /* 821ECB10h */ case    8:  		/* subf R10, R8, R10 */
		/* 821ECB10h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821ECB10h case    8:*/		return 0x821ECB14;
		  /* 821ECB14h */ case    9:  		/* cmplw CR6, R9, R8 */
		/* 821ECB14h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821ECB14h case    9:*/		return 0x821ECB18;
		  /* 821ECB18h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 821ECB18h case   10:*/		if ( !regs.CR[6].gt ) { return 0x821ECB20;  }
		/* 821ECB18h case   10:*/		return 0x821ECB1C;
		  /* 821ECB1Ch */ case   11:  		/* subf R10, R11, R9 */
		/* 821ECB1Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 821ECB1Ch case   11:*/		return 0x821ECB20;
	}
	return 0x821ECB20;
} // Block from 821ECAF0h-821ECB20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821ECB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECB20);
		  /* 821ECB20h */ case    0:  		/* add R10, R11, R10 */
		/* 821ECB20h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821ECB20h case    0:*/		return 0x821ECB24;
		  /* 821ECB24h */ case    1:  		/* cmplw CR6, R4, R10 */
		/* 821ECB24h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 821ECB24h case    1:*/		return 0x821ECB28;
		  /* 821ECB28h */ case    2:  		/* bc 4, CR6_LT, 44 */
		/* 821ECB28h case    2:*/		if ( !regs.CR[6].lt ) { return 0x821ECB54;  }
		/* 821ECB28h case    2:*/		return 0x821ECB2C;
		  /* 821ECB2Ch */ case    3:  		/* lis R10, -32215 */
		/* 821ECB2Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 821ECB2Ch case    3:*/		return 0x821ECB30;
		  /* 821ECB30h */ case    4:  		/* lis R9, -32252 */
		/* 821ECB30h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8204);
		/* 821ECB30h case    4:*/		return 0x821ECB34;
		  /* 821ECB34h */ case    5:  		/* addi R31, R10, -25744 */
		/* 821ECB34h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0xFFFF9B70);
		/* 821ECB34h case    5:*/		return 0x821ECB38;
		  /* 821ECB38h */ case    6:  		/* subf R6, R11, R4 */
		/* 821ECB38h case    6:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R4);
		/* 821ECB38h case    6:*/		return 0x821ECB3C;
		  /* 821ECB3Ch */ case    7:  		/* mr R3, R31 */
		/* 821ECB3Ch case    7:*/		regs.R3 = regs.R31;
		/* 821ECB3Ch case    7:*/		return 0x821ECB40;
		  /* 821ECB40h */ case    8:  		/* addi R5, R9, -13860 */
		/* 821ECB40h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0xFFFFC9DC);
		/* 821ECB40h case    8:*/		return 0x821ECB44;
		  /* 821ECB44h */ case    9:  		/* li R4, 100 */
		/* 821ECB44h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x64);
		/* 821ECB44h case    9:*/		return 0x821ECB48;
		  /* 821ECB48h */ case   10:  		/* bl 508512 */
		/* 821ECB48h case   10:*/		regs.LR = 0x821ECB4C; return 0x82268DA8;
		/* 821ECB48h case   10:*/		return 0x821ECB4C;
		  /* 821ECB4Ch */ case   11:  		/* mr R3, R31 */
		/* 821ECB4Ch case   11:*/		regs.R3 = regs.R31;
		/* 821ECB4Ch case   11:*/		return 0x821ECB50;
	}
	return 0x821ECB50;
} // Block from 821ECB20h-821ECB50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821ECB50h
// Function '?ParseIntegerCastNode@Compiler@D3DXShader@@AAA_NPAVCNode@2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECB50);
		  /* 821ECB50h */ case    0:  		/* b 44 */
		/* 821ECB50h case    0:*/		return 0x821ECB7C;
		/* 821ECB50h case    0:*/		return 0x821ECB54;
	}
	return 0x821ECB54;
} // Block from 821ECB50h-821ECB54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECB54);
		  /* 821ECB54h */ case    0:  		/* lwz R11, <#[R3 + 612]> */
		/* 821ECB54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000264) );
		/* 821ECB54h case    0:*/		return 0x821ECB58;
		  /* 821ECB58h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821ECB58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ECB58h case    1:*/		return 0x821ECB5C;
		  /* 821ECB5Ch */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821ECB5Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821ECB74;  }
		/* 821ECB5Ch case    2:*/		return 0x821ECB60;
		  /* 821ECB60h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 821ECB60h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821ECB60h case    3:*/		return 0x821ECB64;
		  /* 821ECB64h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 821ECB64h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821ECB74;  }
		/* 821ECB64h case    4:*/		return 0x821ECB68;
		  /* 821ECB68h */ case    5:  		/* lis R11, -32252 */
		/* 821ECB68h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821ECB68h case    5:*/		return 0x821ECB6C;
		  /* 821ECB6Ch */ case    6:  		/* addi R3, R11, -13876 */
		/* 821ECB6Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC9CC);
		/* 821ECB6Ch case    6:*/		return 0x821ECB70;
		  /* 821ECB70h */ case    7:  		/* b 12 */
		/* 821ECB70h case    7:*/		return 0x821ECB7C;
		/* 821ECB70h case    7:*/		return 0x821ECB74;
	}
	return 0x821ECB74;
} // Block from 821ECB54h-821ECB74h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821ECB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECB74);
		  /* 821ECB74h */ case    0:  		/* lis R11, -32255 */
		/* 821ECB74h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821ECB74h case    0:*/		return 0x821ECB78;
		  /* 821ECB78h */ case    1:  		/* addi R3, R11, -15824 */
		/* 821ECB78h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFC230);
		/* 821ECB78h case    1:*/		return 0x821ECB7C;
	}
	return 0x821ECB7C;
} // Block from 821ECB74h-821ECB7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECB7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECB7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECB7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECB7C);
		  /* 821ECB7Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 821ECB7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821ECB7Ch case    0:*/		return 0x821ECB80;
		  /* 821ECB80h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821ECB80h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ECB80h case    1:*/		return 0x821ECB84;
		  /* 821ECB84h */ case    2:  		/* mtspr LR, R12 */
		/* 821ECB84h case    2:*/		regs.LR = regs.R12;
		/* 821ECB84h case    2:*/		return 0x821ECB88;
		  /* 821ECB88h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821ECB88h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ECB88h case    3:*/		return 0x821ECB8C;
		  /* 821ECB8Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 821ECB8Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECB8Ch case    4:*/		return 0x821ECB90;
	}
	return 0x821ECB90;
} // Block from 821ECB7Ch-821ECB90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821ECB90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECB90);
		  /* 821ECB90h */ case    0:  		/* lwz R11, <#[R4 + 16]> */
		/* 821ECB90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821ECB90h case    0:*/		return 0x821ECB94;
		  /* 821ECB94h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821ECB94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ECB94h case    1:*/		return 0x821ECB98;
		  /* 821ECB98h */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 821ECB98h case    2:*/		if ( regs.CR[6].eq ) { return 0x821ECC24;  }
		/* 821ECB98h case    2:*/		return 0x821ECB9C;
		  /* 821ECB9Ch */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ECB9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ECB9Ch case    3:*/		return 0x821ECBA0;
		  /* 821ECBA0h */ case    4:  		/* cmpwi CR6, R10, 3 */
		/* 821ECBA0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821ECBA0h case    4:*/		return 0x821ECBA4;
		  /* 821ECBA4h */ case    5:  		/* bc 4, CR6_EQ, 128 */
		/* 821ECBA4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821ECC24;  }
		/* 821ECBA4h case    5:*/		return 0x821ECBA8;
		  /* 821ECBA8h */ case    6:  		/* lwz R10, <#[R11 + 16]> */
		/* 821ECBA8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821ECBA8h case    6:*/		return 0x821ECBAC;
		  /* 821ECBACh */ case    7:  		/* cmpwi CR6, R10, 11 */
		/* 821ECBACh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000B);
		/* 821ECBACh case    7:*/		return 0x821ECBB0;
		  /* 821ECBB0h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 821ECBB0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821ECBBC;  }
		/* 821ECBB0h case    8:*/		return 0x821ECBB4;
		  /* 821ECBB4h */ case    9:  		/* li R4, 4801 */
		/* 821ECBB4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ECBB4h case    9:*/		return 0x821ECBB8;
		  /* 821ECBB8h */ case   10:  		/* b -634192 */
		/* 821ECBB8h case   10:*/		return 0x82151E68;
		/* 821ECBB8h case   10:*/		return 0x821ECBBC;
	}
	return 0x821ECBBC;
} // Block from 821ECB90h-821ECBBCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821ECBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECBBC);
		  /* 821ECBBCh */ case    0:  		/* lis R10, -32217 */
		/* 821ECBBCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 821ECBBCh case    0:*/		return 0x821ECBC0;
		  /* 821ECBC0h */ case    1:  		/* lwz R6, <#[R11 + 24]> */
		/* 821ECBC0h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000018) );
		/* 821ECBC0h case    1:*/		return 0x821ECBC4;
		  /* 821ECBC4h */ case    2:  		/* li R7, 0 */
		/* 821ECBC4h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821ECBC4h case    2:*/		return 0x821ECBC8;
		  /* 821ECBC8h */ case    3:  		/* addi R9, R10, 22336 */
		/* 821ECBC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x5740);
		/* 821ECBC8h case    3:*/		return 0x821ECBCC;
		  /* 821ECBCCh */ case    4:  		/* lwz R11, <#[R9]> */
		/* 821ECBCCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821ECBCCh case    4:*/		return 0x821ECBD0;
		  /* 821ECBD0h */ case    5:  		/* mr R10, R6 */
		/* 821ECBD0h case    5:*/		regs.R10 = regs.R6;
		/* 821ECBD0h case    5:*/		return 0x821ECBD4;
		  /* 821ECBD4h */ case    6:  		/* lbz R8, <#[R11]> */
		/* 821ECBD4h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821ECBD4h case    6:*/		return 0x821ECBD8;
		  /* 821ECBD8h */ case    7:  		/* lbz R5, <#[R10]> */
		/* 821ECBD8h case    7:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 821ECBD8h case    7:*/		return 0x821ECBDC;
		  /* 821ECBDCh */ case    8:  		/* cmpwi CR0, R8, 0 */
		/* 821ECBDCh case    8:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 821ECBDCh case    8:*/		return 0x821ECBE0;
		  /* 821ECBE0h */ case    9:  		/* subf R8, R5, R8 */
		/* 821ECBE0h case    9:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 821ECBE0h case    9:*/		return 0x821ECBE4;
		  /* 821ECBE4h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 821ECBE4h case   10:*/		if ( regs.CR[0].eq ) { return 0x821ECBF8;  }
		/* 821ECBE4h case   10:*/		return 0x821ECBE8;
		  /* 821ECBE8h */ case   11:  		/* addi R11, R11, 1 */
		/* 821ECBE8h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821ECBE8h case   11:*/		return 0x821ECBEC;
		  /* 821ECBECh */ case   12:  		/* addi R10, R10, 1 */
		/* 821ECBECh case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821ECBECh case   12:*/		return 0x821ECBF0;
		  /* 821ECBF0h */ case   13:  		/* cmpwi CR6, R8, 0 */
		/* 821ECBF0h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 821ECBF0h case   13:*/		return 0x821ECBF4;
		  /* 821ECBF4h */ case   14:  		/* bc 12, CR6_EQ, -32 */
		/* 821ECBF4h case   14:*/		if ( regs.CR[6].eq ) { return 0x821ECBD4;  }
		/* 821ECBF4h case   14:*/		return 0x821ECBF8;
	}
	return 0x821ECBF8;
} // Block from 821ECBBCh-821ECBF8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821ECBF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECBF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECBF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECBF8);
		  /* 821ECBF8h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 821ECBF8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 821ECBF8h case    0:*/		return 0x821ECBFC;
		  /* 821ECBFCh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821ECBFCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821ECC10;  }
		/* 821ECBFCh case    1:*/		return 0x821ECC00;
		  /* 821ECC00h */ case    2:  		/* addi R7, R7, 1 */
		/* 821ECC00h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821ECC00h case    2:*/		return 0x821ECC04;
		  /* 821ECC04h */ case    3:  		/* addi R9, R9, 4 */
		/* 821ECC04h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821ECC04h case    3:*/		return 0x821ECC08;
		  /* 821ECC08h */ case    4:  		/* cmplwi CR6, R7, 23 */
		/* 821ECC08h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000017);
		/* 821ECC08h case    4:*/		return 0x821ECC0C;
		  /* 821ECC0Ch */ case    5:  		/* bc 12, CR6_LT, -64 */
		/* 821ECC0Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x821ECBCC;  }
		/* 821ECC0Ch case    5:*/		return 0x821ECC10;
	}
	return 0x821ECC10;
} // Block from 821ECBF8h-821ECC10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC10);
		  /* 821ECC10h */ case    0:  		/* cmplwi CR6, R7, 23 */
		/* 821ECC10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000017);
		/* 821ECC10h case    0:*/		return 0x821ECC14;
		  /* 821ECC14h */ case    1:  		/* li R3, 0 */
		/* 821ECC14h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821ECC14h case    1:*/		return 0x821ECC18;
		  /* 821ECC18h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 821ECC18h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821ECC18h case    2:*/		return 0x821ECC1C;
	}
	return 0x821ECC1C;
} // Block from 821ECC10h-821ECC1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC1C);
		  /* 821ECC1Ch */ case    0:  		/* addi R3, R7, 1 */
		/* 821ECC1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R7,0x1);
		/* 821ECC1Ch case    0:*/		return 0x821ECC20;
		  /* 821ECC20h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821ECC20h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECC20h case    1:*/		return 0x821ECC24;
	}
	return 0x821ECC24;
} // Block from 821ECC1Ch-821ECC24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC24);
		  /* 821ECC24h */ case    0:  		/* li R4, 4801 */
		/* 821ECC24h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ECC24h case    0:*/		return 0x821ECC28;
		  /* 821ECC28h */ case    1:  		/* b -634304 */
		/* 821ECC28h case    1:*/		return 0x82151E68;
		/* 821ECC28h case    1:*/		return 0x821ECC2C;
		  /* 821ECC2Ch */ case    2:  		/* nop */
		/* 821ECC2Ch case    2:*/		cpu::op::nop();
		/* 821ECC2Ch case    2:*/		return 0x821ECC30;
		  /* 821ECC30h */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 821ECC30h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821ECC30h case    3:*/		return 0x821ECC34;
		  /* 821ECC34h */ case    4:  		/* stw R11, <#[R3 + 32]> */
		/* 821ECC34h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 821ECC34h case    4:*/		return 0x821ECC38;
		  /* 821ECC38h */ case    5:  		/* lwz R11, <#[R4 + 8]> */
		/* 821ECC38h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821ECC38h case    5:*/		return 0x821ECC3C;
		  /* 821ECC3Ch */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821ECC3Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821ECC3Ch case    6:*/		return 0x821ECC40;
		  /* 821ECC40h */ case    7:  		/* lwz R11, <#[R3 + 40]> */
		/* 821ECC40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 821ECC40h case    7:*/		return 0x821ECC44;
		  /* 821ECC44h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821ECC44h case    8:*/		if ( regs.CR[0].eq ) { return 0x821ECC50;  }
		/* 821ECC44h case    8:*/		return 0x821ECC48;
		  /* 821ECC48h */ case    9:  		/* oris R11, R11, 8192 */
		/* 821ECC48h case    9:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 821ECC48h case    9:*/		return 0x821ECC4C;
		  /* 821ECC4Ch */ case   10:  		/* b 8 */
		/* 821ECC4Ch case   10:*/		return 0x821ECC54;
		/* 821ECC4Ch case   10:*/		return 0x821ECC50;
	}
	return 0x821ECC50;
} // Block from 821ECC24h-821ECC50h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC50);
		  /* 821ECC50h */ case    0:  		/* rlwinm R11, R11, 0, 3, 1 */
		/* 821ECC50h case    0:*/		cpu::op::rlwinm<0,0,3,1>(regs,&regs.R11,regs.R11);
		/* 821ECC50h case    0:*/		return 0x821ECC54;
	}
	return 0x821ECC54;
} // Block from 821ECC50h-821ECC54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC54);
		  /* 821ECC54h */ case    0:  		/* stw R11, <#[R3 + 40]> */
		/* 821ECC54h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 821ECC54h case    0:*/		return 0x821ECC58;
		  /* 821ECC58h */ case    1:  		/* lwz R11, <#[R4 + 8]> */
		/* 821ECC58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821ECC58h case    1:*/		return 0x821ECC5C;
		  /* 821ECC5Ch */ case    2:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 821ECC5Ch case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 821ECC5Ch case    2:*/		return 0x821ECC60;
		  /* 821ECC60h */ case    3:  		/* lwz R11, <#[R3 + 40]> */
		/* 821ECC60h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 821ECC60h case    3:*/		return 0x821ECC64;
		  /* 821ECC64h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 821ECC64h case    4:*/		if ( regs.CR[0].eq ) { return 0x821ECC70;  }
		/* 821ECC64h case    4:*/		return 0x821ECC68;
		  /* 821ECC68h */ case    5:  		/* ori R11, R11, 2 */
		/* 821ECC68h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821ECC68h case    5:*/		return 0x821ECC6C;
		  /* 821ECC6Ch */ case    6:  		/* b 8 */
		/* 821ECC6Ch case    6:*/		return 0x821ECC74;
		/* 821ECC6Ch case    6:*/		return 0x821ECC70;
	}
	return 0x821ECC70;
} // Block from 821ECC54h-821ECC70h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC70);
		  /* 821ECC70h */ case    0:  		/* rlwinm R11, R11, 0, 31, 29 */
		/* 821ECC70h case    0:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R11,regs.R11);
		/* 821ECC70h case    0:*/		return 0x821ECC74;
	}
	return 0x821ECC74;
} // Block from 821ECC70h-821ECC74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC74);
		  /* 821ECC74h */ case    0:  		/* stw R11, <#[R3 + 40]> */
		/* 821ECC74h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 821ECC74h case    0:*/		return 0x821ECC78;
		  /* 821ECC78h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821ECC78h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECC78h case    1:*/		return 0x821ECC7C;
	}
	return 0x821ECC7C;
} // Block from 821ECC74h-821ECC7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECC7C);
		  /* 821ECC7Ch */ case    0:  		/* nop */
		/* 821ECC7Ch case    0:*/		cpu::op::nop();
		/* 821ECC7Ch case    0:*/		return 0x821ECC80;
		  /* 821ECC80h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 821ECC80h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821ECC80h case    1:*/		return 0x821ECC84;
		  /* 821ECC84h */ case    2:  		/* lwz R10, <#[R4]> */
		/* 821ECC84h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821ECC84h case    2:*/		return 0x821ECC88;
		  /* 821ECC88h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 821ECC88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821ECC88h case    3:*/		return 0x821ECC8C;
		  /* 821ECC8Ch */ case    4:  		/* lwz R10, <#[R10]> */
		/* 821ECC8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821ECC8Ch case    4:*/		return 0x821ECC90;
		  /* 821ECC90h */ case    5:  		/* rlwinm R9, R11, 28, 18, 31 */
		/* 821ECC90h case    5:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R9,regs.R11);
		/* 821ECC90h case    5:*/		return 0x821ECC94;
		  /* 821ECC94h */ case    6:  		/* rlwinm R8, R10, 28, 18, 31 */
		/* 821ECC94h case    6:*/		cpu::op::rlwinm<0,28,18,31>(regs,&regs.R8,regs.R10);
		/* 821ECC94h case    6:*/		return 0x821ECC98;
		  /* 821ECC98h */ case    7:  		/* subf. R3, R8, R9 */
		/* 821ECC98h case    7:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R8,regs.R9);
		/* 821ECC98h case    7:*/		return 0x821ECC9C;
		  /* 821ECC9Ch */ case    8:  		/* bclr 4, CR0_EQ */
		/* 821ECC9Ch case    8:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821ECC9Ch case    8:*/		return 0x821ECCA0;
	}
	return 0x821ECCA0;
} // Block from 821ECC7Ch-821ECCA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821ECCA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECCA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECCA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECCA0);
		  /* 821ECCA0h */ case    0:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 821ECCA0h case    0:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 821ECCA0h case    0:*/		return 0x821ECCA4;
		  /* 821ECCA4h */ case    1:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 821ECCA4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 821ECCA4h case    1:*/		return 0x821ECCA8;
		  /* 821ECCA8h */ case    2:  		/* subf R3, R10, R11 */
		/* 821ECCA8h case    2:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 821ECCA8h case    2:*/		return 0x821ECCAC;
		  /* 821ECCACh */ case    3:  		/* bclr 20, CR0_LT */
		/* 821ECCACh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECCACh case    3:*/		return 0x821ECCB0;
	}
	return 0x821ECCB0;
} // Block from 821ECCA0h-821ECCB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ECCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECCB0);
		  /* 821ECCB0h */ case    0:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECCB0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECCB0h case    0:*/		return 0x821ECCB4;
		  /* 821ECCB4h */ case    1:  		/* mulli R11, R4, 40 */
		/* 821ECCB4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x28);
		/* 821ECCB4h case    1:*/		return 0x821ECCB8;
		  /* 821ECCB8h */ case    2:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821ECCB8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821ECCB8h case    2:*/		return 0x821ECCBC;
		  /* 821ECCBCh */ case    3:  		/* rlwimi R8, R6, 3, 15, 28 */
		/* 821ECCBCh case    3:*/		cpu::op::rlwimi<0,3,15,28>(regs,&regs.R8,regs.R6);
		/* 821ECCBCh case    3:*/		return 0x821ECCC0;
	}
	return 0x821ECCC0;
} // Block from 821ECCB0h-821ECCC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ECCC0h
// Function '?ParseBooleanCastNode@Compiler@D3DXShader@@AAA_NPAVCNode@2@PA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECCC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECCC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECCC0);
		  /* 821ECCC0h */ case    0:  		/* li R9, 0 */
		/* 821ECCC0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821ECCC0h case    0:*/		return 0x821ECCC4;
		  /* 821ECCC4h */ case    1:  		/* stwx R8, <#[R10 + R11]> */
		/* 821ECCC4h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821ECCC4h case    1:*/		return 0x821ECCC8;
		  /* 821ECCC8h */ case    2:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECCC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECCC8h case    2:*/		return 0x821ECCCC;
		  /* 821ECCCCh */ case    3:  		/* add R10, R10, R11 */
		/* 821ECCCCh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECCCCh case    3:*/		return 0x821ECCD0;
		  /* 821ECCD0h */ case    4:  		/* stw R9, <#[R10 + 20]> */
		/* 821ECCD0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 821ECCD0h case    4:*/		return 0x821ECCD4;
		  /* 821ECCD4h */ case    5:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECCD4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECCD4h case    5:*/		return 0x821ECCD8;
		  /* 821ECCD8h */ case    6:  		/* add R10, R10, R11 */
		/* 821ECCD8h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECCD8h case    6:*/		return 0x821ECCDC;
		  /* 821ECCDCh */ case    7:  		/* stw R9, <#[R10 + 16]> */
		/* 821ECCDCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 821ECCDCh case    7:*/		return 0x821ECCE0;
		  /* 821ECCE0h */ case    8:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECCE0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECCE0h case    8:*/		return 0x821ECCE4;
		  /* 821ECCE4h */ case    9:  		/* add R10, R10, R11 */
		/* 821ECCE4h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECCE4h case    9:*/		return 0x821ECCE8;
		  /* 821ECCE8h */ case   10:  		/* stw R9, <#[R10 + 12]> */
		/* 821ECCE8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 821ECCE8h case   10:*/		return 0x821ECCEC;
		  /* 821ECCECh */ case   11:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECCECh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECCECh case   11:*/		return 0x821ECCF0;
		  /* 821ECCF0h */ case   12:  		/* add R10, R10, R11 */
		/* 821ECCF0h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECCF0h case   12:*/		return 0x821ECCF4;
		  /* 821ECCF4h */ case   13:  		/* stw R5, <#[R10 + 32]> */
		/* 821ECCF4h case   13:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000020) );
		/* 821ECCF4h case   13:*/		return 0x821ECCF8;
		  /* 821ECCF8h */ case   14:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECCF8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECCF8h case   14:*/		return 0x821ECCFC;
		  /* 821ECCFCh */ case   15:  		/* add R10, R10, R11 */
		/* 821ECCFCh case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECCFCh case   15:*/		return 0x821ECD00;
		  /* 821ECD00h */ case   16:  		/* lwz R9, <#[R10 + 8]> */
		/* 821ECD00h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821ECD00h case   16:*/		return 0x821ECD04;
		  /* 821ECD04h */ case   17:  		/* oris R9, R9, 7 */
		/* 821ECD04h case   17:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x7);
		/* 821ECD04h case   17:*/		return 0x821ECD08;
		  /* 821ECD08h */ case   18:  		/* ori R9, R9, 65535 */
		/* 821ECD08h case   18:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0xFFFF);
		/* 821ECD08h case   18:*/		return 0x821ECD0C;
		  /* 821ECD0Ch */ case   19:  		/* stw R9, <#[R10 + 8]> */
		/* 821ECD0Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821ECD0Ch case   19:*/		return 0x821ECD10;
		  /* 821ECD10h */ case   20:  		/* addi R9, R10, 8 */
		/* 821ECD10h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x8);
		/* 821ECD10h case   20:*/		return 0x821ECD14;
		  /* 821ECD14h */ case   21:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECD14h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECD14h case   21:*/		return 0x821ECD18;
		  /* 821ECD18h */ case   22:  		/* add R10, R10, R11 */
		/* 821ECD18h case   22:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECD18h case   22:*/		return 0x821ECD1C;
		  /* 821ECD1Ch */ case   23:  		/* lwz R9, <#[R10 + 8]> */
		/* 821ECD1Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821ECD1Ch case   23:*/		return 0x821ECD20;
		  /* 821ECD20h */ case   24:  		/* rlwimi R9, R7, 19, 10, 12 */
		/* 821ECD20h case   24:*/		cpu::op::rlwimi<0,19,10,12>(regs,&regs.R9,regs.R7);
		/* 821ECD20h case   24:*/		return 0x821ECD24;
		  /* 821ECD24h */ case   25:  		/* stw R9, <#[R10 + 8]> */
		/* 821ECD24h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821ECD24h case   25:*/		return 0x821ECD28;
		  /* 821ECD28h */ case   26:  		/* addi R9, R10, 8 */
		/* 821ECD28h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x8);
		/* 821ECD28h case   26:*/		return 0x821ECD2C;
		  /* 821ECD2Ch */ case   27:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECD2Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECD2Ch case   27:*/		return 0x821ECD30;
		  /* 821ECD30h */ case   28:  		/* add R10, R10, R11 */
		/* 821ECD30h case   28:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECD30h case   28:*/		return 0x821ECD34;
		  /* 821ECD34h */ case   29:  		/* lwz R9, <#[R10 + 4]> */
		/* 821ECD34h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821ECD34h case   29:*/		return 0x821ECD38;
		  /* 821ECD38h */ case   30:  		/* ori R9, R9, 112 */
		/* 821ECD38h case   30:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x70);
		/* 821ECD38h case   30:*/		return 0x821ECD3C;
		  /* 821ECD3Ch */ case   31:  		/* stw R9, <#[R10 + 4]> */
		/* 821ECD3Ch case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821ECD3Ch case   31:*/		return 0x821ECD40;
		  /* 821ECD40h */ case   32:  		/* addi R9, R10, 4 */
		/* 821ECD40h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821ECD40h case   32:*/		return 0x821ECD44;
		  /* 821ECD44h */ case   33:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECD44h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECD44h case   33:*/		return 0x821ECD48;
		  /* 821ECD48h */ case   34:  		/* add R10, R10, R11 */
		/* 821ECD48h case   34:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821ECD48h case   34:*/		return 0x821ECD4C;
		  /* 821ECD4Ch */ case   35:  		/* lwz R9, <#[R10 + 4]> */
		/* 821ECD4Ch case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821ECD4Ch case   35:*/		return 0x821ECD50;
		  /* 821ECD50h */ case   36:  		/* ori R9, R9, 4 */
		/* 821ECD50h case   36:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821ECD50h case   36:*/		return 0x821ECD54;
		  /* 821ECD54h */ case   37:  		/* stw R9, <#[R10 + 4]> */
		/* 821ECD54h case   37:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821ECD54h case   37:*/		return 0x821ECD58;
		  /* 821ECD58h */ case   38:  		/* addi R9, R10, 4 */
		/* 821ECD58h case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821ECD58h case   38:*/		return 0x821ECD5C;
		  /* 821ECD5Ch */ case   39:  		/* lwz R10, <#[R3 + 12]> */
		/* 821ECD5Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECD5Ch case   39:*/		return 0x821ECD60;
		  /* 821ECD60h */ case   40:  		/* add R11, R10, R11 */
		/* 821ECD60h case   40:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821ECD60h case   40:*/		return 0x821ECD64;
		  /* 821ECD64h */ case   41:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ECD64h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ECD64h case   41:*/		return 0x821ECD68;
		  /* 821ECD68h */ case   42:  		/* ori R9, R10, 1 */
		/* 821ECD68h case   42:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R10,0x1);
		/* 821ECD68h case   42:*/		return 0x821ECD6C;
		  /* 821ECD6Ch */ case   43:  		/* addi R10, R11, 4 */
		/* 821ECD6Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821ECD6Ch case   43:*/		return 0x821ECD70;
		  /* 821ECD70h */ case   44:  		/* stw R9, <#[R11 + 4]> */
		/* 821ECD70h case   44:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821ECD70h case   44:*/		return 0x821ECD74;
		  /* 821ECD74h */ case   45:  		/* bclr 20, CR0_LT */
		/* 821ECD74h case   45:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECD74h case   45:*/		return 0x821ECD78;
	}
	return 0x821ECD78;
} // Block from 821ECCC0h-821ECD78h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821ECD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECD78);
		  /* 821ECD78h */ case    0:  		/* mfspr R12, LR */
		/* 821ECD78h case    0:*/		regs.R12 = regs.LR;
		/* 821ECD78h case    0:*/		return 0x821ECD7C;
		  /* 821ECD7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821ECD7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ECD7Ch case    1:*/		return 0x821ECD80;
	}
	return 0x821ECD80;
} // Block from 821ECD78h-821ECD80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECD80h
// Function '?ParseIntegerArgument@Compiler@D3DXShader@@AAAIPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECD80);
		  /* 821ECD80h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 821ECD80h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ECD80h case    0:*/		return 0x821ECD84;
		  /* 821ECD84h */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 821ECD84h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821ECD84h case    1:*/		return 0x821ECD88;
		  /* 821ECD88h */ case    2:  		/* lwz R10, <#[R4 + 4]> */
		/* 821ECD88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 821ECD88h case    2:*/		return 0x821ECD8C;
		  /* 821ECD8Ch */ case    3:  		/* mr R31, R5 */
		/* 821ECD8Ch case    3:*/		regs.R31 = regs.R5;
		/* 821ECD8Ch case    3:*/		return 0x821ECD90;
		  /* 821ECD90h */ case    4:  		/* rlwinm R11, R10, 0, 30, 31 */
		/* 821ECD90h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 821ECD90h case    4:*/		return 0x821ECD94;
		  /* 821ECD94h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 821ECD94h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821ECD94h case    5:*/		return 0x821ECD98;
		  /* 821ECD98h */ case    6:  		/* bc 12, CR6_LT, 116 */
		/* 821ECD98h case    6:*/		if ( regs.CR[6].lt ) { return 0x821ECE0C;  }
		/* 821ECD98h case    6:*/		return 0x821ECD9C;
		  /* 821ECD9Ch */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 821ECD9Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821ECDE4;  }
		/* 821ECD9Ch case    7:*/		return 0x821ECDA0;
		  /* 821ECDA0h */ case    8:  		/* cmplwi CR6, R11, 3 */
		/* 821ECDA0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 821ECDA0h case    8:*/		return 0x821ECDA4;
		  /* 821ECDA4h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 821ECDA4h case    9:*/		if ( regs.CR[6].lt ) { return 0x821ECDB4;  }
		/* 821ECDA4h case    9:*/		return 0x821ECDA8;
		  /* 821ECDA8h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 821ECDA8h case   10:*/		if ( regs.CR[6].eq ) { return 0x821ECE0C;  }
		/* 821ECDA8h case   10:*/		return 0x821ECDAC;
		  /* 821ECDACh */ case   11:  		/* li R4, 4800 */
		/* 821ECDACh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821ECDACh case   11:*/		return 0x821ECDB0;
		  /* 821ECDB0h */ case   12:  		/* bl -634696 */
		/* 821ECDB0h case   12:*/		regs.LR = 0x821ECDB4; return 0x82151E68;
		/* 821ECDB0h case   12:*/		return 0x821ECDB4;
	}
	return 0x821ECDB4;
} // Block from 821ECD80h-821ECDB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821ECDB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECDB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECDB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECDB4);
		  /* 821ECDB4h */ case    0:  		/* lwz R3, <#[R4]> */
		/* 821ECDB4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 821ECDB4h case    0:*/		return 0x821ECDB8;
		  /* 821ECDB8h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 821ECDB8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821ECDB8h case    1:*/		return 0x821ECDBC;
		  /* 821ECDBCh */ case    2:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 821ECDBCh case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 821ECDBCh case    2:*/		return 0x821ECDC0;
		  /* 821ECDC0h */ case    3:  		/* bc 4, CR0_EQ, 76 */
		/* 821ECDC0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821ECE0C;  }
		/* 821ECDC0h case    3:*/		return 0x821ECDC4;
		  /* 821ECDC4h */ case    4:  		/* lwz R11, <#[R3 + 12]> */
		/* 821ECDC4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ECDC4h case    4:*/		return 0x821ECDC8;
		  /* 821ECDC8h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 821ECDC8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821ECDC8h case    5:*/		return 0x821ECDCC;
		  /* 821ECDCCh */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821ECDCCh case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821ECDCCh case    6:*/		return 0x821ECDD0;
		  /* 821ECDD0h */ case    7:  		/* cmplwi CR6, R11, 16000 */
		/* 821ECDD0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821ECDD0h case    7:*/		return 0x821ECDD4;
		  /* 821ECDD4h */ case    8:  		/* bc 4, CR6_EQ, 56 */
		/* 821ECDD4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821ECE0C;  }
		/* 821ECDD4h case    8:*/		return 0x821ECDD8;
		  /* 821ECDD8h */ case    9:  		/* rlwinm R4, R10, 30, 18, 31 */
		/* 821ECDD8h case    9:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R4,regs.R10);
		/* 821ECDD8h case    9:*/		return 0x821ECDDC;
		  /* 821ECDDCh */ case   10:  		/* bl -195668 */
		/* 821ECDDCh case   10:*/		regs.LR = 0x821ECDE0; return 0x821BD188;
		/* 821ECDDCh case   10:*/		return 0x821ECDE0;
		  /* 821ECDE0h */ case   11:  		/* b 32 */
		/* 821ECDE0h case   11:*/		return 0x821ECE00;
		/* 821ECDE0h case   11:*/		return 0x821ECDE4;
	}
	return 0x821ECDE4;
} // Block from 821ECDB4h-821ECDE4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821ECDE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECDE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECDE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECDE4);
		  /* 821ECDE4h */ case    0:  		/* lwz R3, <#[R4]> */
		/* 821ECDE4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 821ECDE4h case    0:*/		return 0x821ECDE8;
		  /* 821ECDE8h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821ECDE8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821ECDE8h case    1:*/		return 0x821ECDEC;
		  /* 821ECDECh */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821ECDECh case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821ECDECh case    2:*/		return 0x821ECDF0;
		  /* 821ECDF0h */ case    3:  		/* cmplwi CR6, R11, 16000 */
		/* 821ECDF0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821ECDF0h case    3:*/		return 0x821ECDF4;
		  /* 821ECDF4h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821ECDF4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821ECE0C;  }
		/* 821ECDF4h case    4:*/		return 0x821ECDF8;
		  /* 821ECDF8h */ case    5:  		/* rlwinm R4, R10, 30, 18, 31 */
		/* 821ECDF8h case    5:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R4,regs.R10);
		/* 821ECDF8h case    5:*/		return 0x821ECDFC;
		  /* 821ECDFCh */ case    6:  		/* bl -196268 */
		/* 821ECDFCh case    6:*/		regs.LR = 0x821ECE00; return 0x821BCF50;
		/* 821ECDFCh case    6:*/		return 0x821ECE00;
	}
	return 0x821ECE00;
} // Block from 821ECDE4h-821ECE00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE00);
		  /* 821ECE00h */ case    0:  		/* stfd FR1, <#[R31]> */
		/* 821ECE00h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R31 + 0x00000000) );
		/* 821ECE00h case    0:*/		return 0x821ECE04;
		  /* 821ECE04h */ case    1:  		/* li R3, 1 */
		/* 821ECE04h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821ECE04h case    1:*/		return 0x821ECE08;
	}
	return 0x821ECE08;
} // Block from 821ECE00h-821ECE08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE08h
// Function '?ParseIntegerRangeArgument@Compiler@D3DXShader@@AAAXPAVCNode@2@PAI1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE08);
		  /* 821ECE08h */ case    0:  		/* b 8 */
		/* 821ECE08h case    0:*/		return 0x821ECE10;
		/* 821ECE08h case    0:*/		return 0x821ECE0C;
	}
	return 0x821ECE0C;
} // Block from 821ECE08h-821ECE0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE0C);
		  /* 821ECE0Ch */ case    0:  		/* li R3, 0 */
		/* 821ECE0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821ECE0Ch case    0:*/		return 0x821ECE10;
	}
	return 0x821ECE10;
} // Block from 821ECE0Ch-821ECE10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE10);
		  /* 821ECE10h */ case    0:  		/* addi R1, R1, 96 */
		/* 821ECE10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821ECE10h case    0:*/		return 0x821ECE14;
		  /* 821ECE14h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821ECE14h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ECE14h case    1:*/		return 0x821ECE18;
		  /* 821ECE18h */ case    2:  		/* mtspr LR, R12 */
		/* 821ECE18h case    2:*/		regs.LR = regs.R12;
		/* 821ECE18h case    2:*/		return 0x821ECE1C;
		  /* 821ECE1Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821ECE1Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ECE1Ch case    3:*/		return 0x821ECE20;
		  /* 821ECE20h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821ECE20h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECE20h case    4:*/		return 0x821ECE24;
	}
	return 0x821ECE24;
} // Block from 821ECE10h-821ECE24h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE24);
		  /* 821ECE24h */ case    0:  		/* nop */
		/* 821ECE24h case    0:*/		cpu::op::nop();
		/* 821ECE24h case    0:*/		return 0x821ECE28;
	}
	return 0x821ECE28;
} // Block from 821ECE24h-821ECE28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE28);
		  /* 821ECE28h */ case    0:  		/* mfspr R12, LR */
		/* 821ECE28h case    0:*/		regs.R12 = regs.LR;
		/* 821ECE28h case    0:*/		return 0x821ECE2C;
		  /* 821ECE2Ch */ case    1:  		/* bl -1424336 */
		/* 821ECE2Ch case    1:*/		regs.LR = 0x821ECE30; return 0x8209125C;
		/* 821ECE2Ch case    1:*/		return 0x821ECE30;
		  /* 821ECE30h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821ECE30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821ECE30h case    2:*/		return 0x821ECE34;
		  /* 821ECE34h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 821ECE34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821ECE34h case    3:*/		return 0x821ECE38;
		  /* 821ECE38h */ case    4:  		/* rlwinm R10, R4, 0, 24, 31 */
		/* 821ECE38h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R4);
		/* 821ECE38h case    4:*/		return 0x821ECE3C;
		  /* 821ECE3Ch */ case    5:  		/* mr R31, R3 */
		/* 821ECE3Ch case    5:*/		regs.R31 = regs.R3;
		/* 821ECE3Ch case    5:*/		return 0x821ECE40;
		  /* 821ECE40h */ case    6:  		/* rlwimi R11, R10, 18, 13, 13 */
		/* 821ECE40h case    6:*/		cpu::op::rlwimi<0,18,13,13>(regs,&regs.R11,regs.R10);
		/* 821ECE40h case    6:*/		return 0x821ECE44;
		  /* 821ECE44h */ case    7:  		/* mr R30, R5 */
		/* 821ECE44h case    7:*/		regs.R30 = regs.R5;
		/* 821ECE44h case    7:*/		return 0x821ECE48;
		  /* 821ECE48h */ case    8:  		/* oris R11, R11, 2 */
		/* 821ECE48h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821ECE48h case    8:*/		return 0x821ECE4C;
		  /* 821ECE4Ch */ case    9:  		/* mr R29, R6 */
		/* 821ECE4Ch case    9:*/		regs.R29 = regs.R6;
		/* 821ECE4Ch case    9:*/		return 0x821ECE50;
		  /* 821ECE50h */ case   10:  		/* mr R3, R7 */
		/* 821ECE50h case   10:*/		regs.R3 = regs.R7;
		/* 821ECE50h case   10:*/		return 0x821ECE54;
		  /* 821ECE54h */ case   11:  		/* stw R11, <#[R31 + 8]> */
		/* 821ECE54h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ECE54h case   11:*/		return 0x821ECE58;
		  /* 821ECE58h */ case   12:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821ECE58h case   12:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821ECE58h case   12:*/		return 0x821ECE5C;
		  /* 821ECE5Ch */ case   13:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821ECE5Ch case   13:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821ECE5Ch case   13:*/		return 0x821ECE60;
		  /* 821ECE60h */ case   14:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821ECE60h case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821ECE60h case   14:*/		return 0x821ECE64;
		  /* 821ECE64h */ case   15:  		/* bl -559668 */
		/* 821ECE64h case   15:*/		regs.LR = 0x821ECE68; return 0x82164430;
		/* 821ECE64h case   15:*/		return 0x821ECE68;
		  /* 821ECE68h */ case   16:  		/* addi R11, R31, -16 */
		/* 821ECE68h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821ECE68h case   16:*/		return 0x821ECE6C;
		  /* 821ECE6Ch */ case   17:  		/* rlwinm R10, R29, 0, 24, 31 */
		/* 821ECE6Ch case   17:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R29);
		/* 821ECE6Ch case   17:*/		return 0x821ECE70;
		  /* 821ECE70h */ case   18:  		/* add R11, R3, R11 */
		/* 821ECE70h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821ECE70h case   18:*/		return 0x821ECE74;
		  /* 821ECE74h */ case   19:  		/* lwz R9, <#[R11 + 12]> */
		/* 821ECE74h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821ECE74h case   19:*/		return 0x821ECE78;
		  /* 821ECE78h */ case   20:  		/* stw R30, <#[R11]> */
		/* 821ECE78h case   20:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 821ECE78h case   20:*/		return 0x821ECE7C;
		  /* 821ECE7Ch */ case   21:  		/* rlwimi R9, R10, 2, 29, 29 */
		/* 821ECE7Ch case   21:*/		cpu::op::rlwimi<0,2,29,29>(regs,&regs.R9,regs.R10);
		/* 821ECE7Ch case   21:*/		return 0x821ECE80;
		  /* 821ECE80h */ case   22:  		/* stw R9, <#[R11 + 12]> */
		/* 821ECE80h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821ECE80h case   22:*/		return 0x821ECE84;
		  /* 821ECE84h */ case   23:  		/* addi R1, R1, 112 */
		/* 821ECE84h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821ECE84h case   23:*/		return 0x821ECE88;
	}
	return 0x821ECE88;
} // Block from 821ECE28h-821ECE88h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE88h
// Function '?ParseBooleanArgument@Compiler@D3DXShader@@AAA_NPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE88);
		  /* 821ECE88h */ case    0:  		/* b -1424348 */
		/* 821ECE88h case    0:*/		return 0x820912AC;
		/* 821ECE88h case    0:*/		return 0x821ECE8C;
		  /* 821ECE8Ch */ case    1:  		/* nop */
		/* 821ECE8Ch case    1:*/		cpu::op::nop();
		/* 821ECE8Ch case    1:*/		return 0x821ECE90;
	}
	return 0x821ECE90;
} // Block from 821ECE88h-821ECE90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECE90);
		  /* 821ECE90h */ case    0:  		/* mfspr R12, LR */
		/* 821ECE90h case    0:*/		regs.R12 = regs.LR;
		/* 821ECE90h case    0:*/		return 0x821ECE94;
		  /* 821ECE94h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821ECE94h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ECE94h case    1:*/		return 0x821ECE98;
		  /* 821ECE98h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821ECE98h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821ECE98h case    2:*/		return 0x821ECE9C;
		  /* 821ECE9Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821ECE9Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ECE9Ch case    3:*/		return 0x821ECEA0;
		  /* 821ECEA0h */ case    4:  		/* stwu R1, <#[R1 - 160]> */
		/* 821ECEA0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821ECEA0h case    4:*/		return 0x821ECEA4;
		  /* 821ECEA4h */ case    5:  		/* mr R31, R4 */
		/* 821ECEA4h case    5:*/		regs.R31 = regs.R4;
		/* 821ECEA4h case    5:*/		return 0x821ECEA8;
		  /* 821ECEA8h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 821ECEA8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821ECEA8h case    6:*/		return 0x821ECEAC;
		  /* 821ECEACh */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 821ECEACh case    7:*/		if ( !regs.CR[6].eq ) { return 0x821ECEB8;  }
		/* 821ECEACh case    7:*/		return 0x821ECEB0;
		  /* 821ECEB0h */ case    8:  		/* li R4, 4801 */
		/* 821ECEB0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ECEB0h case    8:*/		return 0x821ECEB4;
		  /* 821ECEB4h */ case    9:  		/* bl -634956 */
		/* 821ECEB4h case    9:*/		regs.LR = 0x821ECEB8; return 0x82151E68;
		/* 821ECEB4h case    9:*/		return 0x821ECEB8;
	}
	return 0x821ECEB8;
} // Block from 821ECE90h-821ECEB8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821ECEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECEB8);
		  /* 821ECEB8h */ case    0:  		/* li R5, 17 */
		/* 821ECEB8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x11);
		/* 821ECEB8h case    0:*/		return 0x821ECEBC;
		  /* 821ECEBCh */ case    1:  		/* li R4, 56 */
		/* 821ECEBCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 821ECEBCh case    1:*/		return 0x821ECEC0;
		  /* 821ECEC0h */ case    2:  		/* bl -525080 */
		/* 821ECEC0h case    2:*/		regs.LR = 0x821ECEC4; return 0x8216CBA8;
		/* 821ECEC0h case    2:*/		return 0x821ECEC4;
		  /* 821ECEC4h */ case    3:  		/* mr R30, R3 */
		/* 821ECEC4h case    3:*/		regs.R30 = regs.R3;
		/* 821ECEC4h case    3:*/		return 0x821ECEC8;
		  /* 821ECEC8h */ case    4:  		/* addi R3, R1, 80 */
		/* 821ECEC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ECEC8h case    4:*/		return 0x821ECECC;
		  /* 821ECECCh */ case    5:  		/* bl -1193636 */
		/* 821ECECCh case    5:*/		regs.LR = 0x821ECED0; return 0x820C9828;
		/* 821ECECCh case    5:*/		return 0x821ECED0;
		  /* 821ECED0h */ case    6:  		/* lwz R9, <#[R1 + 80]> */
		/* 821ECED0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821ECED0h case    6:*/		return 0x821ECED4;
		  /* 821ECED4h */ case    7:  		/* li R11, 3 */
		/* 821ECED4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 821ECED4h case    7:*/		return 0x821ECED8;
		  /* 821ECED8h */ case    8:  		/* stw R31, <#[R30 + 24]> */
		/* 821ECED8h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000018) );
		/* 821ECED8h case    8:*/		return 0x821ECEDC;
		  /* 821ECEDCh */ case    9:  		/* li R10, 11 */
		/* 821ECEDCh case    9:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 821ECEDCh case    9:*/		return 0x821ECEE0;
		  /* 821ECEE0h */ case   10:  		/* stw R11, <#[R30 + 4]> */
		/* 821ECEE0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821ECEE0h case   10:*/		return 0x821ECEE4;
		  /* 821ECEE4h */ case   11:  		/* mr R3, R30 */
		/* 821ECEE4h case   11:*/		regs.R3 = regs.R30;
		/* 821ECEE4h case   11:*/		return 0x821ECEE8;
		  /* 821ECEE8h */ case   12:  		/* stw R10, <#[R30 + 16]> */
		/* 821ECEE8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 821ECEE8h case   12:*/		return 0x821ECEEC;
		  /* 821ECEECh */ case   13:  		/* stw R9, <#[R30]> */
		/* 821ECEECh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 821ECEECh case   13:*/		return 0x821ECEF0;
		  /* 821ECEF0h */ case   14:  		/* addi R1, R1, 160 */
		/* 821ECEF0h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821ECEF0h case   14:*/		return 0x821ECEF4;
		  /* 821ECEF4h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 821ECEF4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ECEF4h case   15:*/		return 0x821ECEF8;
		  /* 821ECEF8h */ case   16:  		/* mtspr LR, R12 */
		/* 821ECEF8h case   16:*/		regs.LR = regs.R12;
		/* 821ECEF8h case   16:*/		return 0x821ECEFC;
		  /* 821ECEFCh */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 821ECEFCh case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821ECEFCh case   17:*/		return 0x821ECF00;
		  /* 821ECF00h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 821ECF00h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ECF00h case   18:*/		return 0x821ECF04;
		  /* 821ECF04h */ case   19:  		/* bclr 20, CR0_LT */
		/* 821ECF04h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ECF04h case   19:*/		return 0x821ECF08;
	}
	return 0x821ECF08;
} // Block from 821ECEB8h-821ECF08h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821ECF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECF08);
		  /* 821ECF08h */ case    0:  		/* mfspr R12, LR */
		/* 821ECF08h case    0:*/		regs.R12 = regs.LR;
		/* 821ECF08h case    0:*/		return 0x821ECF0C;
		  /* 821ECF0Ch */ case    1:  		/* bl -1424568 */
		/* 821ECF0Ch case    1:*/		regs.LR = 0x821ECF10; return 0x82091254;
		/* 821ECF0Ch case    1:*/		return 0x821ECF10;
	}
	return 0x821ECF10;
} // Block from 821ECF08h-821ECF10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ECF10h
// Function '?FindFunctionFromCallNode@Compiler@D3DXShader@@AAAPAUFunction@2@PAVCNodeExpression@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECF10);
		  /* 821ECF10h */ case    0:  		/* stwu R1, <#[R1 - 192]> */
		/* 821ECF10h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821ECF10h case    0:*/		return 0x821ECF14;
		  /* 821ECF14h */ case    1:  		/* mr R30, R4 */
		/* 821ECF14h case    1:*/		regs.R30 = regs.R4;
		/* 821ECF14h case    1:*/		return 0x821ECF18;
		  /* 821ECF18h */ case    2:  		/* mr R29, R5 */
		/* 821ECF18h case    2:*/		regs.R29 = regs.R5;
		/* 821ECF18h case    2:*/		return 0x821ECF1C;
		  /* 821ECF1Ch */ case    3:  		/* li R5, 9 */
		/* 821ECF1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 821ECF1Ch case    3:*/		return 0x821ECF20;
		  /* 821ECF20h */ case    4:  		/* li R4, 52 */
		/* 821ECF20h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 821ECF20h case    4:*/		return 0x821ECF24;
		  /* 821ECF24h */ case    5:  		/* mr R31, R3 */
		/* 821ECF24h case    5:*/		regs.R31 = regs.R3;
		/* 821ECF24h case    5:*/		return 0x821ECF28;
		  /* 821ECF28h */ case    6:  		/* mr R28, R6 */
		/* 821ECF28h case    6:*/		regs.R28 = regs.R6;
		/* 821ECF28h case    6:*/		return 0x821ECF2C;
		  /* 821ECF2Ch */ case    7:  		/* bl -525188 */
		/* 821ECF2Ch case    7:*/		regs.LR = 0x821ECF30; return 0x8216CBA8;
		/* 821ECF2Ch case    7:*/		return 0x821ECF30;
		  /* 821ECF30h */ case    8:  		/* mr R27, R3 */
		/* 821ECF30h case    8:*/		regs.R27 = regs.R3;
		/* 821ECF30h case    8:*/		return 0x821ECF34;
		  /* 821ECF34h */ case    9:  		/* addi R3, R1, 80 */
		/* 821ECF34h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ECF34h case    9:*/		return 0x821ECF38;
		  /* 821ECF38h */ case   10:  		/* bl -1192144 */
		/* 821ECF38h case   10:*/		regs.LR = 0x821ECF3C; return 0x820C9E68;
		/* 821ECF38h case   10:*/		return 0x821ECF3C;
		  /* 821ECF3Ch */ case   11:  		/* lwz R10, <#[R1 + 80]> */
		/* 821ECF3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821ECF3Ch case   11:*/		return 0x821ECF40;
		  /* 821ECF40h */ case   12:  		/* li R11, 6 */
		/* 821ECF40h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 821ECF40h case   12:*/		return 0x821ECF44;
		  /* 821ECF44h */ case   13:  		/* stw R30, <#[R27 + 16]> */
		/* 821ECF44h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + 0x00000010) );
		/* 821ECF44h case   13:*/		return 0x821ECF48;
		  /* 821ECF48h */ case   14:  		/* mr R4, R29 */
		/* 821ECF48h case   14:*/		regs.R4 = regs.R29;
		/* 821ECF48h case   14:*/		return 0x821ECF4C;
		  /* 821ECF4Ch */ case   15:  		/* stw R11, <#[R27 + 4]> */
		/* 821ECF4Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821ECF4Ch case   15:*/		return 0x821ECF50;
		  /* 821ECF50h */ case   16:  		/* mr R3, R31 */
		/* 821ECF50h case   16:*/		regs.R3 = regs.R31;
		/* 821ECF50h case   16:*/		return 0x821ECF54;
		  /* 821ECF54h */ case   17:  		/* stw R10, <#[R27]> */
		/* 821ECF54h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821ECF54h case   17:*/		return 0x821ECF58;
		  /* 821ECF58h */ case   18:  		/* bl -200 */
		/* 821ECF58h case   18:*/		regs.LR = 0x821ECF5C; return 0x821ECE90;
		/* 821ECF58h case   18:*/		return 0x821ECF5C;
		  /* 821ECF5Ch */ case   19:  		/* stw R3, <#[R27 + 20]> */
		/* 821ECF5Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000014) );
		/* 821ECF5Ch case   19:*/		return 0x821ECF60;
		  /* 821ECF60h */ case   20:  		/* stw R28, <#[R27 + 24]> */
		/* 821ECF60h case   20:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R27 + 0x00000018) );
		/* 821ECF60h case   20:*/		return 0x821ECF64;
		  /* 821ECF64h */ case   21:  		/* mr R3, R27 */
		/* 821ECF64h case   21:*/		regs.R3 = regs.R27;
		/* 821ECF64h case   21:*/		return 0x821ECF68;
		  /* 821ECF68h */ case   22:  		/* addi R1, R1, 192 */
		/* 821ECF68h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821ECF68h case   22:*/		return 0x821ECF6C;
		  /* 821ECF6Ch */ case   23:  		/* b -1424584 */
		/* 821ECF6Ch case   23:*/		return 0x820912A4;
		/* 821ECF6Ch case   23:*/		return 0x821ECF70;
	}
	return 0x821ECF70;
} // Block from 821ECF10h-821ECF70h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821ECF70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECF70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECF70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECF70);
		  /* 821ECF70h */ case    0:  		/* mfspr R12, LR */
		/* 821ECF70h case    0:*/		regs.R12 = regs.LR;
		/* 821ECF70h case    0:*/		return 0x821ECF74;
		  /* 821ECF74h */ case    1:  		/* bl -1424668 */
		/* 821ECF74h case    1:*/		regs.LR = 0x821ECF78; return 0x82091258;
		/* 821ECF74h case    1:*/		return 0x821ECF78;
		  /* 821ECF78h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821ECF78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821ECF78h case    2:*/		return 0x821ECF7C;
		  /* 821ECF7Ch */ case    3:  		/* mr R31, R4 */
		/* 821ECF7Ch case    3:*/		regs.R31 = regs.R4;
		/* 821ECF7Ch case    3:*/		return 0x821ECF80;
		  /* 821ECF80h */ case    4:  		/* mr R30, R5 */
		/* 821ECF80h case    4:*/		regs.R30 = regs.R5;
		/* 821ECF80h case    4:*/		return 0x821ECF84;
		  /* 821ECF84h */ case    5:  		/* li R5, 12 */
		/* 821ECF84h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 821ECF84h case    5:*/		return 0x821ECF88;
		  /* 821ECF88h */ case    6:  		/* li R4, 20 */
		/* 821ECF88h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 821ECF88h case    6:*/		return 0x821ECF8C;
		  /* 821ECF8Ch */ case    7:  		/* mr R29, R6 */
		/* 821ECF8Ch case    7:*/		regs.R29 = regs.R6;
		/* 821ECF8Ch case    7:*/		return 0x821ECF90;
		  /* 821ECF90h */ case    8:  		/* bl -525288 */
		/* 821ECF90h case    8:*/		regs.LR = 0x821ECF94; return 0x8216CBA8;
		/* 821ECF90h case    8:*/		return 0x821ECF94;
		  /* 821ECF94h */ case    9:  		/* mr R28, R3 */
		/* 821ECF94h case    9:*/		regs.R28 = regs.R3;
		/* 821ECF94h case    9:*/		return 0x821ECF98;
		  /* 821ECF98h */ case   10:  		/* addi R3, R1, 80 */
		/* 821ECF98h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ECF98h case   10:*/		return 0x821ECF9C;
		  /* 821ECF9Ch */ case   11:  		/* bl -1194964 */
		/* 821ECF9Ch case   11:*/		regs.LR = 0x821ECFA0; return 0x820C93C8;
		/* 821ECF9Ch case   11:*/		return 0x821ECFA0;
		  /* 821ECFA0h */ case   12:  		/* lwz R10, <#[R1 + 80]> */
		/* 821ECFA0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821ECFA0h case   12:*/		return 0x821ECFA4;
		  /* 821ECFA4h */ case   13:  		/* li R11, 1 */
		/* 821ECFA4h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821ECFA4h case   13:*/		return 0x821ECFA8;
		  /* 821ECFA8h */ case   14:  		/* stw R31, <#[R28 + 8]> */
		/* 821ECFA8h case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000008) );
		/* 821ECFA8h case   14:*/		return 0x821ECFAC;
		  /* 821ECFACh */ case   15:  		/* stw R30, <#[R28 + 12]> */
		/* 821ECFACh case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x0000000C) );
		/* 821ECFACh case   15:*/		return 0x821ECFB0;
		  /* 821ECFB0h */ case   16:  		/* mr R3, R28 */
		/* 821ECFB0h case   16:*/		regs.R3 = regs.R28;
		/* 821ECFB0h case   16:*/		return 0x821ECFB4;
		  /* 821ECFB4h */ case   17:  		/* stw R11, <#[R28 + 4]> */
		/* 821ECFB4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821ECFB4h case   17:*/		return 0x821ECFB8;
		  /* 821ECFB8h */ case   18:  		/* stw R29, <#[R28 + 16]> */
		/* 821ECFB8h case   18:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000010) );
		/* 821ECFB8h case   18:*/		return 0x821ECFBC;
		  /* 821ECFBCh */ case   19:  		/* stw R10, <#[R28]> */
		/* 821ECFBCh case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 821ECFBCh case   19:*/		return 0x821ECFC0;
		  /* 821ECFC0h */ case   20:  		/* addi R1, R1, 144 */
		/* 821ECFC0h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821ECFC0h case   20:*/		return 0x821ECFC4;
		  /* 821ECFC4h */ case   21:  		/* b -1424668 */
		/* 821ECFC4h case   21:*/		return 0x820912A8;
		/* 821ECFC4h case   21:*/		return 0x821ECFC8;
	}
	return 0x821ECFC8;
} // Block from 821ECF70h-821ECFC8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821ECFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ECFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ECFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ECFC8);
		  /* 821ECFC8h */ case    0:  		/* mfspr R12, LR */
		/* 821ECFC8h case    0:*/		regs.R12 = regs.LR;
		/* 821ECFC8h case    0:*/		return 0x821ECFCC;
		  /* 821ECFCCh */ case    1:  		/* bl -1424764 */
		/* 821ECFCCh case    1:*/		regs.LR = 0x821ECFD0; return 0x82091250;
		/* 821ECFCCh case    1:*/		return 0x821ECFD0;
		  /* 821ECFD0h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821ECFD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821ECFD0h case    2:*/		return 0x821ECFD4;
		  /* 821ECFD4h */ case    3:  		/* li R11, 0 */
		/* 821ECFD4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821ECFD4h case    3:*/		return 0x821ECFD8;
		  /* 821ECFD8h */ case    4:  		/* mr R28, R3 */
		/* 821ECFD8h case    4:*/		regs.R28 = regs.R3;
		/* 821ECFD8h case    4:*/		return 0x821ECFDC;
		  /* 821ECFDCh */ case    5:  		/* addi R29, R1, 80 */
		/* 821ECFDCh case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0x50);
		/* 821ECFDCh case    5:*/		return 0x821ECFE0;
		  /* 821ECFE0h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 821ECFE0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821ECFE0h case    6:*/		return 0x821ECFE4;
		  /* 821ECFE4h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 821ECFE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821ECFE4h case    7:*/		return 0x821ECFE8;
		  /* 821ECFE8h */ case    8:  		/* bc 12, CR6_EQ, 116 */
		/* 821ECFE8h case    8:*/		if ( regs.CR[6].eq ) { return 0x821ED05C;  }
		/* 821ECFE8h case    8:*/		return 0x821ECFEC;
		  /* 821ECFECh */ case    9:  		/* lis R11, -32253 */
		/* 821ECFECh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 821ECFECh case    9:*/		return 0x821ECFF0;
		  /* 821ECFF0h */ case   10:  		/* addi R30, R4, -4 */
		/* 821ECFF0h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0xFFFFFFFC);
		/* 821ECFF0h case   10:*/		return 0x821ECFF4;
		  /* 821ECFF4h */ case   11:  		/* mr R31, R5 */
		/* 821ECFF4h case   11:*/		regs.R31 = regs.R5;
		/* 821ECFF4h case   11:*/		return 0x821ECFF8;
		  /* 821ECFF8h */ case   12:  		/* addi R27, R11, 8868 */
		/* 821ECFF8h case   12:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x22A4);
		/* 821ECFF8h case   12:*/		return 0x821ECFFC;
		  /* 821ECFFCh */ case   13:  		/* li R5, 19 */
		/* 821ECFFCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x13);
		/* 821ECFFCh case   13:*/		return 0x821ED000;
		  /* 821ED000h */ case   14:  		/* li R4, 72 */
		/* 821ED000h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 821ED000h case   14:*/		return 0x821ED004;
		  /* 821ED004h */ case   15:  		/* mr R3, R28 */
		/* 821ED004h case   15:*/		regs.R3 = regs.R28;
		/* 821ED004h case   15:*/		return 0x821ED008;
		  /* 821ED008h */ case   16:  		/* bl -525408 */
		/* 821ED008h case   16:*/		regs.LR = 0x821ED00C; return 0x8216CBA8;
		/* 821ED008h case   16:*/		return 0x821ED00C;
		  /* 821ED00Ch */ case   17:  		/* mr R26, R3 */
		/* 821ED00Ch case   17:*/		regs.R26 = regs.R3;
		/* 821ED00Ch case   17:*/		return 0x821ED010;
		  /* 821ED010h */ case   18:  		/* addi R3, R1, 96 */
		/* 821ED010h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821ED010h case   18:*/		return 0x821ED014;
		  /* 821ED014h */ case   19:  		/* bl -1183028 */
		/* 821ED014h case   19:*/		regs.LR = 0x821ED018; return 0x820CC2E0;
		/* 821ED014h case   19:*/		return 0x821ED018;
		  /* 821ED018h */ case   20:  		/* lwz R9, <#[R1 + 96]> */
		/* 821ED018h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 821ED018h case   20:*/		return 0x821ED01C;
		  /* 821ED01Ch */ case   21:  		/* li R11, 15 */
		/* 821ED01Ch case   21:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 821ED01Ch case   21:*/		return 0x821ED020;
		  /* 821ED020h */ case   22:  		/* li R10, 3 */
		/* 821ED020h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 821ED020h case   22:*/		return 0x821ED024;
		  /* 821ED024h */ case   23:  		/* stw R11, <#[R26 + 4]> */
		/* 821ED024h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821ED024h case   23:*/		return 0x821ED028;
		  /* 821ED028h */ case   24:  		/* mr R6, R27 */
		/* 821ED028h case   24:*/		regs.R6 = regs.R27;
		/* 821ED028h case   24:*/		return 0x821ED02C;
		  /* 821ED02Ch */ case   25:  		/* stw R10, <#[R26 + 16]> */
		/* 821ED02Ch case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 821ED02Ch case   25:*/		return 0x821ED030;
		  /* 821ED030h */ case   26:  		/* li R5, 0 */
		/* 821ED030h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821ED030h case   26:*/		return 0x821ED034;
		  /* 821ED034h */ case   27:  		/* stw R9, <#[R26]> */
		/* 821ED034h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 821ED034h case   27:*/		return 0x821ED038;
		  /* 821ED038h */ case   28:  		/* lfsu FR0, <#[R30 + 4]> */
		/* 821ED038h case   28:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 821ED038h case   28:*/		return 0x821ED03C;
		  /* 821ED03Ch */ case   29:  		/* stfd FR0, <#[R26 + 24]> */
		/* 821ED03Ch case   29:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R26 + 0x00000018) );
		/* 821ED03Ch case   29:*/		return 0x821ED040;
		  /* 821ED040h */ case   30:  		/* mr R3, R28 */
		/* 821ED040h case   30:*/		regs.R3 = regs.R28;
		/* 821ED040h case   30:*/		return 0x821ED044;
		  /* 821ED044h */ case   31:  		/* mr R4, R26 */
		/* 821ED044h case   31:*/		regs.R4 = regs.R26;
		/* 821ED044h case   31:*/		return 0x821ED048;
		  /* 821ED048h */ case   32:  		/* bl -216 */
		/* 821ED048h case   32:*/		regs.LR = 0x821ED04C; return 0x821ECF70;
		/* 821ED048h case   32:*/		return 0x821ED04C;
		  /* 821ED04Ch */ case   33:  		/* stw R3, <#[R29]> */
		/* 821ED04Ch case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 821ED04Ch case   33:*/		return 0x821ED050;
		  /* 821ED050h */ case   34:  		/* addic. R31, R31, -1 */
		/* 821ED050h case   34:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 821ED050h case   34:*/		return 0x821ED054;
		  /* 821ED054h */ case   35:  		/* addi R29, R3, 12 */
		/* 821ED054h case   35:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0xC);
		/* 821ED054h case   35:*/		return 0x821ED058;
	}
	return 0x821ED058;
} // Block from 821ECFC8h-821ED058h (36 instructions)

//////////////////////////////////////////////////////
// Block at 821ED058h
// Function '?GetMicrocodeVarName@Compiler@D3DXShader@@AAAPBDI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED058);
		  /* 821ED058h */ case    0:  		/* bc 4, CR0_EQ, -92 */
		/* 821ED058h case    0:*/		if ( !regs.CR[0].eq ) { return 0x821ECFFC;  }
		/* 821ED058h case    0:*/		return 0x821ED05C;
	}
	return 0x821ED05C;
} // Block from 821ED058h-821ED05Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ED05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED05C);
		  /* 821ED05Ch */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 821ED05Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED05Ch case    0:*/		return 0x821ED060;
		  /* 821ED060h */ case    1:  		/* addi R1, R1, 224 */
		/* 821ED060h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821ED060h case    1:*/		return 0x821ED064;
		  /* 821ED064h */ case    2:  		/* b -1424836 */
		/* 821ED064h case    2:*/		return 0x820912A0;
		/* 821ED064h case    2:*/		return 0x821ED068;
	}
	return 0x821ED068;
} // Block from 821ED05Ch-821ED068h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED068);
		  /* 821ED068h */ case    0:  		/* mfspr R12, LR */
		/* 821ED068h case    0:*/		regs.R12 = regs.LR;
		/* 821ED068h case    0:*/		return 0x821ED06C;
		  /* 821ED06Ch */ case    1:  		/* bl -1424912 */
		/* 821ED06Ch case    1:*/		regs.LR = 0x821ED070; return 0x8209125C;
		/* 821ED06Ch case    1:*/		return 0x821ED070;
		  /* 821ED070h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821ED070h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821ED070h case    2:*/		return 0x821ED074;
		  /* 821ED074h */ case    3:  		/* mr R31, R4 */
		/* 821ED074h case    3:*/		regs.R31 = regs.R4;
		/* 821ED074h case    3:*/		return 0x821ED078;
		  /* 821ED078h */ case    4:  		/* mr R30, R5 */
		/* 821ED078h case    4:*/		regs.R30 = regs.R5;
		/* 821ED078h case    4:*/		return 0x821ED07C;
		  /* 821ED07Ch */ case    5:  		/* li R5, 19 */
		/* 821ED07Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x13);
		/* 821ED07Ch case    5:*/		return 0x821ED080;
		  /* 821ED080h */ case    6:  		/* li R4, 72 */
		/* 821ED080h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x48);
		/* 821ED080h case    6:*/		return 0x821ED084;
		  /* 821ED084h */ case    7:  		/* bl -525532 */
		/* 821ED084h case    7:*/		regs.LR = 0x821ED088; return 0x8216CBA8;
		/* 821ED084h case    7:*/		return 0x821ED088;
		  /* 821ED088h */ case    8:  		/* mr R29, R3 */
		/* 821ED088h case    8:*/		regs.R29 = regs.R3;
		/* 821ED088h case    8:*/		return 0x821ED08C;
		  /* 821ED08Ch */ case    9:  		/* addi R3, R1, 80 */
		/* 821ED08Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ED08Ch case    9:*/		return 0x821ED090;
		  /* 821ED090h */ case   10:  		/* bl -1183152 */
		/* 821ED090h case   10:*/		regs.LR = 0x821ED094; return 0x820CC2E0;
		/* 821ED090h case   10:*/		return 0x821ED094;
		  /* 821ED094h */ case   11:  		/* lwz R9, <#[R1 + 80]> */
		/* 821ED094h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED094h case   11:*/		return 0x821ED098;
		  /* 821ED098h */ case   12:  		/* li R11, 15 */
		/* 821ED098h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 821ED098h case   12:*/		return 0x821ED09C;
		  /* 821ED09Ch */ case   13:  		/* stw R31, <#[R29 + 24]> */
		/* 821ED09Ch case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000018) );
		/* 821ED09Ch case   13:*/		return 0x821ED0A0;
		  /* 821ED0A0h */ case   14:  		/* li R10, 6 */
		/* 821ED0A0h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x6);
		/* 821ED0A0h case   14:*/		return 0x821ED0A4;
		  /* 821ED0A4h */ case   15:  		/* stw R30, <#[R29 + 28]> */
		/* 821ED0A4h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x0000001C) );
		/* 821ED0A4h case   15:*/		return 0x821ED0A8;
		  /* 821ED0A8h */ case   16:  		/* stw R11, <#[R29 + 4]> */
		/* 821ED0A8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821ED0A8h case   16:*/		return 0x821ED0AC;
		  /* 821ED0ACh */ case   17:  		/* mr R3, R29 */
		/* 821ED0ACh case   17:*/		regs.R3 = regs.R29;
		/* 821ED0ACh case   17:*/		return 0x821ED0B0;
		  /* 821ED0B0h */ case   18:  		/* stw R10, <#[R29 + 16]> */
		/* 821ED0B0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 821ED0B0h case   18:*/		return 0x821ED0B4;
		  /* 821ED0B4h */ case   19:  		/* stw R9, <#[R29]> */
		/* 821ED0B4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 821ED0B4h case   19:*/		return 0x821ED0B8;
		  /* 821ED0B8h */ case   20:  		/* addi R1, R1, 192 */
		/* 821ED0B8h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821ED0B8h case   20:*/		return 0x821ED0BC;
		  /* 821ED0BCh */ case   21:  		/* b -1424912 */
		/* 821ED0BCh case   21:*/		return 0x820912AC;
		/* 821ED0BCh case   21:*/		return 0x821ED0C0;
	}
	return 0x821ED0C0;
} // Block from 821ED068h-821ED0C0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821ED0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED0C0);
		  /* 821ED0C0h */ case    0:  		/* mfspr R12, LR */
		/* 821ED0C0h case    0:*/		regs.R12 = regs.LR;
		/* 821ED0C0h case    0:*/		return 0x821ED0C4;
		  /* 821ED0C4h */ case    1:  		/* bl -1425000 */
		/* 821ED0C4h case    1:*/		regs.LR = 0x821ED0C8; return 0x8209125C;
		/* 821ED0C4h case    1:*/		return 0x821ED0C8;
		  /* 821ED0C8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 821ED0C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 821ED0C8h case    2:*/		return 0x821ED0CC;
		  /* 821ED0CCh */ case    3:  		/* mr R31, R4 */
		/* 821ED0CCh case    3:*/		regs.R31 = regs.R4;
		/* 821ED0CCh case    3:*/		return 0x821ED0D0;
		  /* 821ED0D0h */ case    4:  		/* mr R30, R5 */
		/* 821ED0D0h case    4:*/		regs.R30 = regs.R5;
		/* 821ED0D0h case    4:*/		return 0x821ED0D4;
		  /* 821ED0D4h */ case    5:  		/* li R5, 10 */
		/* 821ED0D4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 821ED0D4h case    5:*/		return 0x821ED0D8;
		  /* 821ED0D8h */ case    6:  		/* li R4, 88 */
		/* 821ED0D8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 821ED0D8h case    6:*/		return 0x821ED0DC;
		  /* 821ED0DCh */ case    7:  		/* bl -525620 */
		/* 821ED0DCh case    7:*/		regs.LR = 0x821ED0E0; return 0x8216CBA8;
		/* 821ED0DCh case    7:*/		return 0x821ED0E0;
		  /* 821ED0E0h */ case    8:  		/* mr R29, R3 */
		/* 821ED0E0h case    8:*/		regs.R29 = regs.R3;
		/* 821ED0E0h case    8:*/		return 0x821ED0E4;
		  /* 821ED0E4h */ case    9:  		/* addi R3, R1, 80 */
		/* 821ED0E4h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ED0E4h case    9:*/		return 0x821ED0E8;
		  /* 821ED0E8h */ case   10:  		/* bl -1184192 */
		/* 821ED0E8h case   10:*/		regs.LR = 0x821ED0EC; return 0x820CBF28;
		/* 821ED0E8h case   10:*/		return 0x821ED0EC;
		  /* 821ED0ECh */ case   11:  		/* lwz R8, <#[R1 + 80]> */
		/* 821ED0ECh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED0ECh case   11:*/		return 0x821ED0F0;
		  /* 821ED0F0h */ case   12:  		/* li R11, 14 */
		/* 821ED0F0h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 821ED0F0h case   12:*/		return 0x821ED0F4;
		  /* 821ED0F4h */ case   13:  		/* stw R30, <#[R29 + 24]> */
		/* 821ED0F4h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000018) );
		/* 821ED0F4h case   13:*/		return 0x821ED0F8;
		  /* 821ED0F8h */ case   14:  		/* li R10, 1 */
		/* 821ED0F8h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED0F8h case   14:*/		return 0x821ED0FC;
		  /* 821ED0FCh */ case   15:  		/* stw R31, <#[R29 + 32]> */
		/* 821ED0FCh case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000020) );
		/* 821ED0FCh case   15:*/		return 0x821ED100;
		  /* 821ED100h */ case   16:  		/* li R9, 0 */
		/* 821ED100h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821ED100h case   16:*/		return 0x821ED104;
		  /* 821ED104h */ case   17:  		/* stw R11, <#[R29 + 4]> */
		/* 821ED104h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821ED104h case   17:*/		return 0x821ED108;
		  /* 821ED108h */ case   18:  		/* stw R10, <#[R29 + 20]> */
		/* 821ED108h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 821ED108h case   18:*/		return 0x821ED10C;
		  /* 821ED10Ch */ case   19:  		/* mr R3, R29 */
		/* 821ED10Ch case   19:*/		regs.R3 = regs.R29;
		/* 821ED10Ch case   19:*/		return 0x821ED110;
		  /* 821ED110h */ case   20:  		/* stw R9, <#[R29 + 28]> */
		/* 821ED110h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x0000001C) );
		/* 821ED110h case   20:*/		return 0x821ED114;
		  /* 821ED114h */ case   21:  		/* stw R8, <#[R29]> */
		/* 821ED114h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 821ED114h case   21:*/		return 0x821ED118;
		  /* 821ED118h */ case   22:  		/* addi R1, R1, 208 */
		/* 821ED118h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 821ED118h case   22:*/		return 0x821ED11C;
		  /* 821ED11Ch */ case   23:  		/* b -1425008 */
		/* 821ED11Ch case   23:*/		return 0x820912AC;
		/* 821ED11Ch case   23:*/		return 0x821ED120;
	}
	return 0x821ED120;
} // Block from 821ED0C0h-821ED120h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821ED120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED120);
		  /* 821ED120h */ case    0:  		/* mfspr R12, LR */
		/* 821ED120h case    0:*/		regs.R12 = regs.LR;
		/* 821ED120h case    0:*/		return 0x821ED124;
		  /* 821ED124h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821ED124h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ED124h case    1:*/		return 0x821ED128;
		  /* 821ED128h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821ED128h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ED128h case    2:*/		return 0x821ED12C;
		  /* 821ED12Ch */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 821ED12Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821ED12Ch case    3:*/		return 0x821ED130;
		  /* 821ED130h */ case    4:  		/* li R5, 16 */
		/* 821ED130h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 821ED130h case    4:*/		return 0x821ED134;
		  /* 821ED134h */ case    5:  		/* li R4, 52 */
		/* 821ED134h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 821ED134h case    5:*/		return 0x821ED138;
		  /* 821ED138h */ case    6:  		/* bl -525712 */
		/* 821ED138h case    6:*/		regs.LR = 0x821ED13C; return 0x8216CBA8;
		/* 821ED138h case    6:*/		return 0x821ED13C;
		  /* 821ED13Ch */ case    7:  		/* mr R31, R3 */
		/* 821ED13Ch case    7:*/		regs.R31 = regs.R3;
		/* 821ED13Ch case    7:*/		return 0x821ED140;
		  /* 821ED140h */ case    8:  		/* addi R3, R1, 80 */
		/* 821ED140h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ED140h case    8:*/		return 0x821ED144;
		  /* 821ED144h */ case    9:  		/* bl -1185556 */
		/* 821ED144h case    9:*/		regs.LR = 0x821ED148; return 0x820CBA30;
		/* 821ED144h case    9:*/		return 0x821ED148;
		  /* 821ED148h */ case   10:  		/* lwz R10, <#[R1 + 80]> */
		/* 821ED148h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED148h case   10:*/		return 0x821ED14C;
		  /* 821ED14Ch */ case   11:  		/* li R11, 12 */
		/* 821ED14Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 821ED14Ch case   11:*/		return 0x821ED150;
		  /* 821ED150h */ case   12:  		/* mr R3, R31 */
		/* 821ED150h case   12:*/		regs.R3 = regs.R31;
		/* 821ED150h case   12:*/		return 0x821ED154;
		  /* 821ED154h */ case   13:  		/* stw R11, <#[R31 + 4]> */
		/* 821ED154h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821ED154h case   13:*/		return 0x821ED158;
		  /* 821ED158h */ case   14:  		/* stw R10, <#[R31]> */
		/* 821ED158h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821ED158h case   14:*/		return 0x821ED15C;
		  /* 821ED15Ch */ case   15:  		/* addi R1, R1, 160 */
		/* 821ED15Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821ED15Ch case   15:*/		return 0x821ED160;
		  /* 821ED160h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 821ED160h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ED160h case   16:*/		return 0x821ED164;
		  /* 821ED164h */ case   17:  		/* mtspr LR, R12 */
		/* 821ED164h case   17:*/		regs.LR = regs.R12;
		/* 821ED164h case   17:*/		return 0x821ED168;
		  /* 821ED168h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 821ED168h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ED168h case   18:*/		return 0x821ED16C;
		  /* 821ED16Ch */ case   19:  		/* bclr 20, CR0_LT */
		/* 821ED16Ch case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ED16Ch case   19:*/		return 0x821ED170;
	}
	return 0x821ED170;
} // Block from 821ED120h-821ED170h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821ED170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED170);
		  /* 821ED170h */ case    0:  		/* mfspr R12, LR */
		/* 821ED170h case    0:*/		regs.R12 = regs.LR;
		/* 821ED170h case    0:*/		return 0x821ED174;
		  /* 821ED174h */ case    1:  		/* bl -1425184 */
		/* 821ED174h case    1:*/		regs.LR = 0x821ED178; return 0x82091254;
		/* 821ED174h case    1:*/		return 0x821ED178;
		  /* 821ED178h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821ED178h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821ED178h case    2:*/		return 0x821ED17C;
		  /* 821ED17Ch */ case    3:  		/* mr R30, R5 */
		/* 821ED17Ch case    3:*/		regs.R30 = regs.R5;
		/* 821ED17Ch case    3:*/		return 0x821ED180;
		  /* 821ED180h */ case    4:  		/* mr R5, R6 */
		/* 821ED180h case    4:*/		regs.R5 = regs.R6;
		/* 821ED180h case    4:*/		return 0x821ED184;
		  /* 821ED184h */ case    5:  		/* mr R31, R3 */
		/* 821ED184h case    5:*/		regs.R31 = regs.R3;
		/* 821ED184h case    5:*/		return 0x821ED188;
		  /* 821ED188h */ case    6:  		/* mr R29, R6 */
		/* 821ED188h case    6:*/		regs.R29 = regs.R6;
		/* 821ED188h case    6:*/		return 0x821ED18C;
		  /* 821ED18Ch */ case    7:  		/* bl -292 */
		/* 821ED18Ch case    7:*/		regs.LR = 0x821ED190; return 0x821ED068;
		/* 821ED18Ch case    7:*/		return 0x821ED190;
		  /* 821ED190h */ case    8:  		/* mr R28, R3 */
		/* 821ED190h case    8:*/		regs.R28 = regs.R3;
		/* 821ED190h case    8:*/		return 0x821ED194;
		  /* 821ED194h */ case    9:  		/* mr R3, R31 */
		/* 821ED194h case    9:*/		regs.R3 = regs.R31;
		/* 821ED194h case    9:*/		return 0x821ED198;
		  /* 821ED198h */ case   10:  		/* li R5, 10 */
		/* 821ED198h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 821ED198h case   10:*/		return 0x821ED19C;
		  /* 821ED19Ch */ case   11:  		/* li R4, 88 */
		/* 821ED19Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 821ED19Ch case   11:*/		return 0x821ED1A0;
		  /* 821ED1A0h */ case   12:  		/* bl -525816 */
		/* 821ED1A0h case   12:*/		regs.LR = 0x821ED1A4; return 0x8216CBA8;
		/* 821ED1A0h case   12:*/		return 0x821ED1A4;
		  /* 821ED1A4h */ case   13:  		/* mr R27, R3 */
		/* 821ED1A4h case   13:*/		regs.R27 = regs.R3;
		/* 821ED1A4h case   13:*/		return 0x821ED1A8;
		  /* 821ED1A8h */ case   14:  		/* addi R3, R1, 80 */
		/* 821ED1A8h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ED1A8h case   14:*/		return 0x821ED1AC;
		  /* 821ED1ACh */ case   15:  		/* bl -1184388 */
		/* 821ED1ACh case   15:*/		regs.LR = 0x821ED1B0; return 0x820CBF28;
		/* 821ED1ACh case   15:*/		return 0x821ED1B0;
		  /* 821ED1B0h */ case   16:  		/* lwz R8, <#[R1 + 80]> */
		/* 821ED1B0h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED1B0h case   16:*/		return 0x821ED1B4;
		  /* 821ED1B4h */ case   17:  		/* li R11, 14 */
		/* 821ED1B4h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 821ED1B4h case   17:*/		return 0x821ED1B8;
		  /* 821ED1B8h */ case   18:  		/* stw R29, <#[R27 + 24]> */
		/* 821ED1B8h case   18:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000018) );
		/* 821ED1B8h case   18:*/		return 0x821ED1BC;
		  /* 821ED1BCh */ case   19:  		/* li R10, 1 */
		/* 821ED1BCh case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED1BCh case   19:*/		return 0x821ED1C0;
		  /* 821ED1C0h */ case   20:  		/* li R9, 27 */
		/* 821ED1C0h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x1B);
		/* 821ED1C0h case   20:*/		return 0x821ED1C4;
		  /* 821ED1C4h */ case   21:  		/* stw R11, <#[R27 + 4]> */
		/* 821ED1C4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821ED1C4h case   21:*/		return 0x821ED1C8;
		  /* 821ED1C8h */ case   22:  		/* stw R10, <#[R27 + 20]> */
		/* 821ED1C8h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 821ED1C8h case   22:*/		return 0x821ED1CC;
		  /* 821ED1CCh */ case   23:  		/* mr R5, R29 */
		/* 821ED1CCh case   23:*/		regs.R5 = regs.R29;
		/* 821ED1CCh case   23:*/		return 0x821ED1D0;
		  /* 821ED1D0h */ case   24:  		/* stw R9, <#[R27 + 28]> */
		/* 821ED1D0h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R27 + 0x0000001C) );
		/* 821ED1D0h case   24:*/		return 0x821ED1D4;
		  /* 821ED1D4h */ case   25:  		/* mr R3, R31 */
		/* 821ED1D4h case   25:*/		regs.R3 = regs.R31;
		/* 821ED1D4h case   25:*/		return 0x821ED1D8;
		  /* 821ED1D8h */ case   26:  		/* stw R8, <#[R27]> */
		/* 821ED1D8h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R27 + 0x00000000) );
		/* 821ED1D8h case   26:*/		return 0x821ED1DC;
		  /* 821ED1DCh */ case   27:  		/* mr R4, R28 */
		/* 821ED1DCh case   27:*/		regs.R4 = regs.R28;
		/* 821ED1DCh case   27:*/		return 0x821ED1E0;
		  /* 821ED1E0h */ case   28:  		/* bl -288 */
		/* 821ED1E0h case   28:*/		regs.LR = 0x821ED1E4; return 0x821ED0C0;
		/* 821ED1E0h case   28:*/		return 0x821ED1E4;
		  /* 821ED1E4h */ case   29:  		/* stw R3, <#[R27 + 32]> */
		/* 821ED1E4h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000020) );
		/* 821ED1E4h case   29:*/		return 0x821ED1E8;
		  /* 821ED1E8h */ case   30:  		/* mr R5, R29 */
		/* 821ED1E8h case   30:*/		regs.R5 = regs.R29;
		/* 821ED1E8h case   30:*/		return 0x821ED1EC;
		  /* 821ED1ECh */ case   31:  		/* mr R4, R30 */
		/* 821ED1ECh case   31:*/		regs.R4 = regs.R30;
		/* 821ED1ECh case   31:*/		return 0x821ED1F0;
		  /* 821ED1F0h */ case   32:  		/* mr R3, R31 */
		/* 821ED1F0h case   32:*/		regs.R3 = regs.R31;
		/* 821ED1F0h case   32:*/		return 0x821ED1F4;
		  /* 821ED1F4h */ case   33:  		/* bl -308 */
		/* 821ED1F4h case   33:*/		regs.LR = 0x821ED1F8; return 0x821ED0C0;
		/* 821ED1F4h case   33:*/		return 0x821ED1F8;
		  /* 821ED1F8h */ case   34:  		/* stw R3, <#[R27 + 36]> */
		/* 821ED1F8h case   34:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000024) );
		/* 821ED1F8h case   34:*/		return 0x821ED1FC;
		  /* 821ED1FCh */ case   35:  		/* mr R3, R27 */
		/* 821ED1FCh case   35:*/		regs.R3 = regs.R27;
		/* 821ED1FCh case   35:*/		return 0x821ED200;
		  /* 821ED200h */ case   36:  		/* addi R1, R1, 224 */
		/* 821ED200h case   36:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821ED200h case   36:*/		return 0x821ED204;
		  /* 821ED204h */ case   37:  		/* b -1425248 */
		/* 821ED204h case   37:*/		return 0x820912A4;
		/* 821ED204h case   37:*/		return 0x821ED208;
	}
	return 0x821ED208;
} // Block from 821ED170h-821ED208h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821ED208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED208);
		  /* 821ED208h */ case    0:  		/* mfspr R12, LR */
		/* 821ED208h case    0:*/		regs.R12 = regs.LR;
		/* 821ED208h case    0:*/		return 0x821ED20C;
		  /* 821ED20Ch */ case    1:  		/* bl -1425328 */
		/* 821ED20Ch case    1:*/		regs.LR = 0x821ED210; return 0x8209125C;
		/* 821ED20Ch case    1:*/		return 0x821ED210;
		  /* 821ED210h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821ED210h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821ED210h case    2:*/		return 0x821ED214;
		  /* 821ED214h */ case    3:  		/* mr R30, R4 */
		/* 821ED214h case    3:*/		regs.R30 = regs.R4;
		/* 821ED214h case    3:*/		return 0x821ED218;
		  /* 821ED218h */ case    4:  		/* mr R4, R5 */
		/* 821ED218h case    4:*/		regs.R4 = regs.R5;
		/* 821ED218h case    4:*/		return 0x821ED21C;
		  /* 821ED21Ch */ case    5:  		/* mr R5, R6 */
		/* 821ED21Ch case    5:*/		regs.R5 = regs.R6;
		/* 821ED21Ch case    5:*/		return 0x821ED220;
		  /* 821ED220h */ case    6:  		/* mr R31, R3 */
		/* 821ED220h case    6:*/		regs.R31 = regs.R3;
		/* 821ED220h case    6:*/		return 0x821ED224;
		  /* 821ED224h */ case    7:  		/* mr R29, R6 */
		/* 821ED224h case    7:*/		regs.R29 = regs.R6;
		/* 821ED224h case    7:*/		return 0x821ED228;
		  /* 821ED228h */ case    8:  		/* bl -448 */
		/* 821ED228h case    8:*/		regs.LR = 0x821ED22C; return 0x821ED068;
		/* 821ED228h case    8:*/		return 0x821ED22C;
		  /* 821ED22Ch */ case    9:  		/* mr R5, R3 */
		/* 821ED22Ch case    9:*/		regs.R5 = regs.R3;
		/* 821ED22Ch case    9:*/		return 0x821ED230;
		  /* 821ED230h */ case   10:  		/* mr R3, R31 */
		/* 821ED230h case   10:*/		regs.R3 = regs.R31;
		/* 821ED230h case   10:*/		return 0x821ED234;
		  /* 821ED234h */ case   11:  		/* mr R6, R29 */
		/* 821ED234h case   11:*/		regs.R6 = regs.R29;
		/* 821ED234h case   11:*/		return 0x821ED238;
		  /* 821ED238h */ case   12:  		/* mr R4, R30 */
		/* 821ED238h case   12:*/		regs.R4 = regs.R30;
		/* 821ED238h case   12:*/		return 0x821ED23C;
		  /* 821ED23Ch */ case   13:  		/* bl -204 */
		/* 821ED23Ch case   13:*/		regs.LR = 0x821ED240; return 0x821ED170;
		/* 821ED23Ch case   13:*/		return 0x821ED240;
		  /* 821ED240h */ case   14:  		/* mr R30, R3 */
		/* 821ED240h case   14:*/		regs.R30 = regs.R3;
		/* 821ED240h case   14:*/		return 0x821ED244;
		  /* 821ED244h */ case   15:  		/* mr R3, R31 */
		/* 821ED244h case   15:*/		regs.R3 = regs.R31;
		/* 821ED244h case   15:*/		return 0x821ED248;
		  /* 821ED248h */ case   16:  		/* bl -296 */
		/* 821ED248h case   16:*/		regs.LR = 0x821ED24C; return 0x821ED120;
		/* 821ED248h case   16:*/		return 0x821ED24C;
		  /* 821ED24Ch */ case   17:  		/* li R11, 0 */
		/* 821ED24Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821ED24Ch case   17:*/		return 0x821ED250;
		  /* 821ED250h */ case   18:  		/* stw R30, <#[R3 + 20]> */
		/* 821ED250h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000014) );
		/* 821ED250h case   18:*/		return 0x821ED254;
		  /* 821ED254h */ case   19:  		/* stw R11, <#[R3 + 16]> */
		/* 821ED254h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 821ED254h case   19:*/		return 0x821ED258;
		  /* 821ED258h */ case   20:  		/* addi R1, R1, 112 */
		/* 821ED258h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821ED258h case   20:*/		return 0x821ED25C;
		  /* 821ED25Ch */ case   21:  		/* b -1425328 */
		/* 821ED25Ch case   21:*/		return 0x820912AC;
		/* 821ED25Ch case   21:*/		return 0x821ED260;
	}
	return 0x821ED260;
} // Block from 821ED208h-821ED260h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821ED260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED260);
		  /* 821ED260h */ case    0:  		/* mfspr R12, LR */
		/* 821ED260h case    0:*/		regs.R12 = regs.LR;
		/* 821ED260h case    0:*/		return 0x821ED264;
		  /* 821ED264h */ case    1:  		/* bl -1425424 */
		/* 821ED264h case    1:*/		regs.LR = 0x821ED268; return 0x82091254;
		/* 821ED264h case    1:*/		return 0x821ED268;
		  /* 821ED268h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821ED268h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821ED268h case    2:*/		return 0x821ED26C;
		  /* 821ED26Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 821ED26Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821ED26Ch case    3:*/		return 0x821ED270;
		  /* 821ED270h */ case    4:  		/* mulli R29, R4, 40 */
		/* 821ED270h case    4:*/		cpu::op::mulli<0>(regs,&regs.R29,regs.R4,0x28);
		/* 821ED270h case    4:*/		return 0x821ED274;
		  /* 821ED274h */ case    5:  		/* lwzx R11, <#[R11 + R29]> */
		/* 821ED274h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821ED274h case    5:*/		return 0x821ED278;
		  /* 821ED278h */ case    6:  		/* mr R30, R5 */
		/* 821ED278h case    6:*/		regs.R30 = regs.R5;
		/* 821ED278h case    6:*/		return 0x821ED27C;
		  /* 821ED27Ch */ case    7:  		/* rlwinm R5, R11, 29, 18, 31 */
		/* 821ED27Ch case    7:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R5,regs.R11);
		/* 821ED27Ch case    7:*/		return 0x821ED280;
		  /* 821ED280h */ case    8:  		/* mr R31, R3 */
		/* 821ED280h case    8:*/		regs.R31 = regs.R3;
		/* 821ED280h case    8:*/		return 0x821ED284;
		  /* 821ED284h */ case    9:  		/* bl -540 */
		/* 821ED284h case    9:*/		regs.LR = 0x821ED288; return 0x821ED068;
		/* 821ED284h case    9:*/		return 0x821ED288;
		  /* 821ED288h */ case   10:  		/* mr R28, R3 */
		/* 821ED288h case   10:*/		regs.R28 = regs.R3;
		/* 821ED288h case   10:*/		return 0x821ED28C;
		  /* 821ED28Ch */ case   11:  		/* mr R3, R31 */
		/* 821ED28Ch case   11:*/		regs.R3 = regs.R31;
		/* 821ED28Ch case   11:*/		return 0x821ED290;
		  /* 821ED290h */ case   12:  		/* li R5, 10 */
		/* 821ED290h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 821ED290h case   12:*/		return 0x821ED294;
		  /* 821ED294h */ case   13:  		/* li R4, 88 */
		/* 821ED294h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 821ED294h case   13:*/		return 0x821ED298;
		  /* 821ED298h */ case   14:  		/* bl -526064 */
		/* 821ED298h case   14:*/		regs.LR = 0x821ED29C; return 0x8216CBA8;
		/* 821ED298h case   14:*/		return 0x821ED29C;
		  /* 821ED29Ch */ case   15:  		/* mr R27, R3 */
		/* 821ED29Ch case   15:*/		regs.R27 = regs.R3;
		/* 821ED29Ch case   15:*/		return 0x821ED2A0;
		  /* 821ED2A0h */ case   16:  		/* addi R3, R1, 80 */
		/* 821ED2A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ED2A0h case   16:*/		return 0x821ED2A4;
		  /* 821ED2A4h */ case   17:  		/* bl -1184636 */
		/* 821ED2A4h case   17:*/		regs.LR = 0x821ED2A8; return 0x820CBF28;
		/* 821ED2A4h case   17:*/		return 0x821ED2A8;
		  /* 821ED2A8h */ case   18:  		/* lwz R8, <#[R1 + 80]> */
		/* 821ED2A8h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED2A8h case   18:*/		return 0x821ED2AC;
		  /* 821ED2ACh */ case   19:  		/* li R11, 14 */
		/* 821ED2ACh case   19:*/		cpu::op::li<0>(regs,&regs.R11,0xE);
		/* 821ED2ACh case   19:*/		return 0x821ED2B0;
		  /* 821ED2B0h */ case   20:  		/* li R10, 1 */
		/* 821ED2B0h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED2B0h case   20:*/		return 0x821ED2B4;
		  /* 821ED2B4h */ case   21:  		/* stw R11, <#[R27 + 4]> */
		/* 821ED2B4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821ED2B4h case   21:*/		return 0x821ED2B8;
		  /* 821ED2B8h */ case   22:  		/* li R9, 19 */
		/* 821ED2B8h case   22:*/		cpu::op::li<0>(regs,&regs.R9,0x13);
		/* 821ED2B8h case   22:*/		return 0x821ED2BC;
		  /* 821ED2BCh */ case   23:  		/* stw R10, <#[R27 + 20]> */
		/* 821ED2BCh case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 821ED2BCh case   23:*/		return 0x821ED2C0;
	}
	return 0x821ED2C0;
} // Block from 821ED260h-821ED2C0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821ED2C0h
// Function '?GetVarIndexFromRegisterNode@Compiler@D3DXShader@@AAAIPAVCNodeUAsmRegister@2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED2C0);
		  /* 821ED2C0h */ case    0:  		/* mr R3, R31 */
		/* 821ED2C0h case    0:*/		regs.R3 = regs.R31;
		/* 821ED2C0h case    0:*/		return 0x821ED2C4;
		  /* 821ED2C4h */ case    1:  		/* stw R8, <#[R27]> */
		/* 821ED2C4h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R27 + 0x00000000) );
		/* 821ED2C4h case    1:*/		return 0x821ED2C8;
		  /* 821ED2C8h */ case    2:  		/* mr R4, R28 */
		/* 821ED2C8h case    2:*/		regs.R4 = regs.R28;
		/* 821ED2C8h case    2:*/		return 0x821ED2CC;
		  /* 821ED2CCh */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 821ED2CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821ED2CCh case    3:*/		return 0x821ED2D0;
		  /* 821ED2D0h */ case    4:  		/* lwzx R11, <#[R11 + R29]> */
		/* 821ED2D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821ED2D0h case    4:*/		return 0x821ED2D4;
		  /* 821ED2D4h */ case    5:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 821ED2D4h case    5:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 821ED2D4h case    5:*/		return 0x821ED2D8;
		  /* 821ED2D8h */ case    6:  		/* stw R11, <#[R27 + 24]> */
		/* 821ED2D8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 821ED2D8h case    6:*/		return 0x821ED2DC;
		  /* 821ED2DCh */ case    7:  		/* stw R9, <#[R27 + 28]> */
		/* 821ED2DCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R27 + 0x0000001C) );
		/* 821ED2DCh case    7:*/		return 0x821ED2E0;
		  /* 821ED2E0h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 821ED2E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821ED2E0h case    8:*/		return 0x821ED2E4;
		  /* 821ED2E4h */ case    9:  		/* lwzx R11, <#[R11 + R29]> */
		/* 821ED2E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821ED2E4h case    9:*/		return 0x821ED2E8;
		  /* 821ED2E8h */ case   10:  		/* rlwinm R5, R11, 29, 18, 31 */
		/* 821ED2E8h case   10:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R5,regs.R11);
		/* 821ED2E8h case   10:*/		return 0x821ED2EC;
		  /* 821ED2ECh */ case   11:  		/* bl -556 */
		/* 821ED2ECh case   11:*/		regs.LR = 0x821ED2F0; return 0x821ED0C0;
		/* 821ED2ECh case   11:*/		return 0x821ED2F0;
		  /* 821ED2F0h */ case   12:  		/* stw R3, <#[R27 + 32]> */
		/* 821ED2F0h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000020) );
		/* 821ED2F0h case   12:*/		return 0x821ED2F4;
		  /* 821ED2F4h */ case   13:  		/* lwz R11, <#[R31 + 12]> */
		/* 821ED2F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821ED2F4h case   13:*/		return 0x821ED2F8;
		  /* 821ED2F8h */ case   14:  		/* mr R4, R30 */
		/* 821ED2F8h case   14:*/		regs.R4 = regs.R30;
		/* 821ED2F8h case   14:*/		return 0x821ED2FC;
		  /* 821ED2FCh */ case   15:  		/* mr R3, R31 */
		/* 821ED2FCh case   15:*/		regs.R3 = regs.R31;
		/* 821ED2FCh case   15:*/		return 0x821ED300;
		  /* 821ED300h */ case   16:  		/* lwzx R11, <#[R11 + R29]> */
		/* 821ED300h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821ED300h case   16:*/		return 0x821ED304;
		  /* 821ED304h */ case   17:  		/* rlwinm R5, R11, 29, 18, 31 */
		/* 821ED304h case   17:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R5,regs.R11);
		/* 821ED304h case   17:*/		return 0x821ED308;
		  /* 821ED308h */ case   18:  		/* bl -584 */
		/* 821ED308h case   18:*/		regs.LR = 0x821ED30C; return 0x821ED0C0;
		/* 821ED308h case   18:*/		return 0x821ED30C;
		  /* 821ED30Ch */ case   19:  		/* stw R3, <#[R27 + 36]> */
		/* 821ED30Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000024) );
		/* 821ED30Ch case   19:*/		return 0x821ED310;
		  /* 821ED310h */ case   20:  		/* mr R3, R27 */
		/* 821ED310h case   20:*/		regs.R3 = regs.R27;
		/* 821ED310h case   20:*/		return 0x821ED314;
		  /* 821ED314h */ case   21:  		/* addi R1, R1, 224 */
		/* 821ED314h case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821ED314h case   21:*/		return 0x821ED318;
		  /* 821ED318h */ case   22:  		/* b -1425524 */
		/* 821ED318h case   22:*/		return 0x820912A4;
		/* 821ED318h case   22:*/		return 0x821ED31C;
		  /* 821ED31Ch */ case   23:  		/* nop */
		/* 821ED31Ch case   23:*/		cpu::op::nop();
		/* 821ED31Ch case   23:*/		return 0x821ED320;
	}
	return 0x821ED320;
} // Block from 821ED2C0h-821ED320h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821ED320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED320);
		  /* 821ED320h */ case    0:  		/* mfspr R12, LR */
		/* 821ED320h case    0:*/		regs.R12 = regs.LR;
		/* 821ED320h case    0:*/		return 0x821ED324;
		  /* 821ED324h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821ED324h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ED324h case    1:*/		return 0x821ED328;
		  /* 821ED328h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821ED328h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821ED328h case    2:*/		return 0x821ED32C;
		  /* 821ED32Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821ED32Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ED32Ch case    3:*/		return 0x821ED330;
		  /* 821ED330h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821ED330h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821ED330h case    4:*/		return 0x821ED334;
		  /* 821ED334h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 821ED334h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821ED334h case    5:*/		return 0x821ED338;
		  /* 821ED338h */ case    6:  		/* mr R30, R3 */
		/* 821ED338h case    6:*/		regs.R30 = regs.R3;
		/* 821ED338h case    6:*/		return 0x821ED33C;
		  /* 821ED33Ch */ case    7:  		/* mr R31, R4 */
		/* 821ED33Ch case    7:*/		regs.R31 = regs.R4;
		/* 821ED33Ch case    7:*/		return 0x821ED340;
		  /* 821ED340h */ case    8:  		/* cmpwi CR6, R11, 14 */
		/* 821ED340h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 821ED340h case    8:*/		return 0x821ED344;
		  /* 821ED344h */ case    9:  		/* bc 12, CR6_EQ, 240 */
		/* 821ED344h case    9:*/		if ( regs.CR[6].eq ) { return 0x821ED434;  }
		/* 821ED344h case    9:*/		return 0x821ED348;
		  /* 821ED348h */ case   10:  		/* cmpwi CR6, R11, 15 */
		/* 821ED348h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 821ED348h case   10:*/		return 0x821ED34C;
		  /* 821ED34Ch */ case   11:  		/* bc 12, CR6_EQ, 184 */
		/* 821ED34Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x821ED404;  }
		/* 821ED34Ch case   11:*/		return 0x821ED350;
		  /* 821ED350h */ case   12:  		/* cmpwi CR6, R11, 28 */
		/* 821ED350h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001C);
		/* 821ED350h case   12:*/		return 0x821ED354;
		  /* 821ED354h */ case   13:  		/* bc 4, CR6_EQ, 196 */
		/* 821ED354h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821ED418;  }
		/* 821ED354h case   13:*/		return 0x821ED358;
		  /* 821ED358h */ case   14:  		/* addi R5, R1, 80 */
		/* 821ED358h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821ED358h case   14:*/		return 0x821ED35C;
		  /* 821ED35Ch */ case   15:  		/* bl -2932 */
		/* 821ED35Ch case   15:*/		regs.LR = 0x821ED360; return 0x821EC7E8;
		/* 821ED35Ch case   15:*/		return 0x821ED360;
		  /* 821ED360h */ case   16:  		/* lwz R10, <#[R30 + 12]> */
		/* 821ED360h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000000C) );
		/* 821ED360h case   16:*/		return 0x821ED364;
		  /* 821ED364h */ case   17:  		/* mulli R11, R3, 40 */
		/* 821ED364h case   17:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R3,0x28);
		/* 821ED364h case   17:*/		return 0x821ED368;
		  /* 821ED368h */ case   18:  		/* add R11, R11, R10 */
		/* 821ED368h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821ED368h case   18:*/		return 0x821ED36C;
		  /* 821ED36Ch */ case   19:  		/* lwz R11, <#[R11 + 16]> */
		/* 821ED36Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 821ED36Ch case   19:*/		return 0x821ED370;
		  /* 821ED370h */ case   20:  		/* lwz R11, <#[R11 + 48]> */
		/* 821ED370h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821ED370h case   20:*/		return 0x821ED374;
		  /* 821ED374h */ case   21:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ED374h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ED374h case   21:*/		return 0x821ED378;
		  /* 821ED378h */ case   22:  		/* cmpwi CR6, R10, 8 */
		/* 821ED378h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000008);
		/* 821ED378h case   22:*/		return 0x821ED37C;
		  /* 821ED37Ch */ case   23:  		/* bc 4, CR6_EQ, 40 */
		/* 821ED37Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x821ED3A4;  }
		/* 821ED37Ch case   23:*/		return 0x821ED380;
		  /* 821ED380h */ case   24:  		/* lwz R10, <#[R31 + 24]> */
		/* 821ED380h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 821ED380h case   24:*/		return 0x821ED384;
		  /* 821ED384h */ case   25:  		/* cmplwi CR6, R10, 0 */
		/* 821ED384h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821ED384h case   25:*/		return 0x821ED388;
		  /* 821ED388h */ case   26:  		/* bc 12, CR6_EQ, 144 */
		/* 821ED388h case   26:*/		if ( regs.CR[6].eq ) { return 0x821ED418;  }
		/* 821ED388h case   26:*/		return 0x821ED38C;
		  /* 821ED38Ch */ case   27:  		/* lwz R11, <#[R11 + 16]> */
		/* 821ED38Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 821ED38Ch case   27:*/		return 0x821ED390;
		  /* 821ED390h */ case   28:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ED390h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ED390h case   28:*/		return 0x821ED394;
		  /* 821ED394h */ case   29:  		/* cmpwi CR6, R10, 9 */
		/* 821ED394h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 821ED394h case   29:*/		return 0x821ED398;
		  /* 821ED398h */ case   30:  		/* bc 12, CR6_EQ, 32 */
		/* 821ED398h case   30:*/		if ( regs.CR[6].eq ) { return 0x821ED3B8;  }
		/* 821ED398h case   30:*/		return 0x821ED39C;
		  /* 821ED39Ch */ case   31:  		/* li R11, 0 */
		/* 821ED39Ch case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821ED39Ch case   31:*/		return 0x821ED3A0;
		  /* 821ED3A0h */ case   32:  		/* b 24 */
		/* 821ED3A0h case   32:*/		return 0x821ED3B8;
		/* 821ED3A0h case   32:*/		return 0x821ED3A4;
	}
	return 0x821ED3A4;
} // Block from 821ED320h-821ED3A4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821ED3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED3A4);
		  /* 821ED3A4h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 821ED3A4h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821ED3A4h case    0:*/		return 0x821ED3A8;
		  /* 821ED3A8h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 821ED3A8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED3F8;  }
		/* 821ED3A8h case    1:*/		return 0x821ED3AC;
		  /* 821ED3ACh */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ED3ACh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ED3ACh case    2:*/		return 0x821ED3B0;
		  /* 821ED3B0h */ case    3:  		/* cmpwi CR6, R10, 9 */
		/* 821ED3B0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000009);
		/* 821ED3B0h case    3:*/		return 0x821ED3B4;
		  /* 821ED3B4h */ case    4:  		/* bc 4, CR6_EQ, 68 */
		/* 821ED3B4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821ED3F8;  }
		/* 821ED3B4h case    4:*/		return 0x821ED3B8;
	}
	return 0x821ED3B8;
} // Block from 821ED3A4h-821ED3B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821ED3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED3B8);
		  /* 821ED3B8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821ED3B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED3B8h case    0:*/		return 0x821ED3BC;
		  /* 821ED3BCh */ case    1:  		/* bc 12, CR6_EQ, 92 */
		/* 821ED3BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821ED418;  }
		/* 821ED3BCh case    1:*/		return 0x821ED3C0;
		  /* 821ED3C0h */ case    2:  		/* lwz R10, <#[R11 + 16]> */
		/* 821ED3C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821ED3C0h case    2:*/		return 0x821ED3C4;
		  /* 821ED3C4h */ case    3:  		/* cmpwi CR6, R10, 2 */
		/* 821ED3C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 821ED3C4h case    3:*/		return 0x821ED3C8;
		  /* 821ED3C8h */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 821ED3C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821ED3E8;  }
		/* 821ED3C8h case    4:*/		return 0x821ED3CC;
		  /* 821ED3CCh */ case    5:  		/* lwz R10, <#[R11 + 36]> */
		/* 821ED3CCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 821ED3CCh case    5:*/		return 0x821ED3D0;
		  /* 821ED3D0h */ case    6:  		/* rlwinm. R10, R10, 0, 21, 21 */
		/* 821ED3D0h case    6:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R10);
		/* 821ED3D0h case    6:*/		return 0x821ED3D4;
		  /* 821ED3D4h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED3D4h case    7:*/		if ( regs.CR[0].eq ) { return 0x821ED3E0;  }
		/* 821ED3D4h case    7:*/		return 0x821ED3D8;
		  /* 821ED3D8h */ case    8:  		/* lwz R3, <#[R11 + 32]> */
		/* 821ED3D8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000020) );
		/* 821ED3D8h case    8:*/		return 0x821ED3DC;
		  /* 821ED3DCh */ case    9:  		/* b 100 */
		/* 821ED3DCh case    9:*/		return 0x821ED440;
		/* 821ED3DCh case    9:*/		return 0x821ED3E0;
	}
	return 0x821ED3E0;
} // Block from 821ED3B8h-821ED3E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821ED3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED3E0);
		  /* 821ED3E0h */ case    0:  		/* lwz R3, <#[R11 + 28]> */
		/* 821ED3E0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000001C) );
		/* 821ED3E0h case    0:*/		return 0x821ED3E4;
		  /* 821ED3E4h */ case    1:  		/* b 92 */
		/* 821ED3E4h case    1:*/		return 0x821ED440;
		/* 821ED3E4h case    1:*/		return 0x821ED3E8;
	}
	return 0x821ED3E8;
} // Block from 821ED3E0h-821ED3E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED3E8);
		  /* 821ED3E8h */ case    0:  		/* lwz R10, <#[R11 + 28]> */
		/* 821ED3E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 821ED3E8h case    0:*/		return 0x821ED3EC;
		  /* 821ED3ECh */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 821ED3ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821ED3ECh case    1:*/		return 0x821ED3F0;
		  /* 821ED3F0h */ case    2:  		/* bc 4, CR6_EQ, 40 */
		/* 821ED3F0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821ED418;  }
		/* 821ED3F0h case    2:*/		return 0x821ED3F4;
		  /* 821ED3F4h */ case    3:  		/* b -28 */
		/* 821ED3F4h case    3:*/		return 0x821ED3D8;
		/* 821ED3F4h case    3:*/		return 0x821ED3F8;
	}
	return 0x821ED3F8;
} // Block from 821ED3E8h-821ED3F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ED3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED3F8);
		  /* 821ED3F8h */ case    0:  		/* li R4, 4801 */
		/* 821ED3F8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ED3F8h case    0:*/		return 0x821ED3FC;
		  /* 821ED3FCh */ case    1:  		/* mr R3, R30 */
		/* 821ED3FCh case    1:*/		regs.R3 = regs.R30;
		/* 821ED3FCh case    1:*/		return 0x821ED400;
		  /* 821ED400h */ case    2:  		/* bl -636312 */
		/* 821ED400h case    2:*/		regs.LR = 0x821ED404; return 0x82151E68;
		/* 821ED400h case    2:*/		return 0x821ED404;
	}
	return 0x821ED404;
} // Block from 821ED3F8h-821ED404h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED404);
		  /* 821ED404h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 821ED404h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821ED404h case    0:*/		return 0x821ED408;
		  /* 821ED408h */ case    1:  		/* cmplwi CR6, R11, 4 */
		/* 821ED408h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821ED408h case    1:*/		return 0x821ED40C;
		  /* 821ED40Ch */ case    2:  		/* bc 12, CR6_LT, 32 */
		/* 821ED40Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x821ED42C;  }
		/* 821ED40Ch case    2:*/		return 0x821ED410;
		  /* 821ED410h */ case    3:  		/* cmplwi CR6, R11, 6 */
		/* 821ED410h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 821ED410h case    3:*/		return 0x821ED414;
		  /* 821ED414h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 821ED414h case    4:*/		if ( regs.CR[6].eq ) { return 0x821ED424;  }
		/* 821ED414h case    4:*/		return 0x821ED418;
	}
	return 0x821ED418;
} // Block from 821ED404h-821ED418h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821ED418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED418);
		  /* 821ED418h */ case    0:  		/* li R4, 4801 */
		/* 821ED418h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ED418h case    0:*/		return 0x821ED41C;
		  /* 821ED41Ch */ case    1:  		/* mr R3, R30 */
		/* 821ED41Ch case    1:*/		regs.R3 = regs.R30;
		/* 821ED41Ch case    1:*/		return 0x821ED420;
		  /* 821ED420h */ case    2:  		/* bl -636344 */
		/* 821ED420h case    2:*/		regs.LR = 0x821ED424; return 0x82151E68;
		/* 821ED420h case    2:*/		return 0x821ED424;
	}
	return 0x821ED424;
} // Block from 821ED418h-821ED424h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED424);
		  /* 821ED424h */ case    0:  		/* lwz R3, <#[R31 + 28]> */
		/* 821ED424h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 821ED424h case    0:*/		return 0x821ED428;
		  /* 821ED428h */ case    1:  		/* b 24 */
		/* 821ED428h case    1:*/		return 0x821ED440;
		/* 821ED428h case    1:*/		return 0x821ED42C;
	}
	return 0x821ED42C;
} // Block from 821ED424h-821ED42Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED42C);
		  /* 821ED42Ch */ case    0:  		/* li R3, 1 */
		/* 821ED42Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821ED42Ch case    0:*/		return 0x821ED430;
		  /* 821ED430h */ case    1:  		/* b 16 */
		/* 821ED430h case    1:*/		return 0x821ED440;
		/* 821ED430h case    1:*/		return 0x821ED434;
	}
	return 0x821ED434;
} // Block from 821ED42Ch-821ED434h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED434);
		  /* 821ED434h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 821ED434h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 821ED434h case    0:*/		return 0x821ED438;
		  /* 821ED438h */ case    1:  		/* lwz R10, <#[R31 + 20]> */
		/* 821ED438h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821ED438h case    1:*/		return 0x821ED43C;
		  /* 821ED43Ch */ case    2:  		/* mullw R3, R11, R10 */
		/* 821ED43Ch case    2:*/		cpu::op::mullw<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 821ED43Ch case    2:*/		return 0x821ED440;
	}
	return 0x821ED440;
} // Block from 821ED434h-821ED440h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED440);
		  /* 821ED440h */ case    0:  		/* addi R1, R1, 112 */
		/* 821ED440h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821ED440h case    0:*/		return 0x821ED444;
		  /* 821ED444h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821ED444h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ED444h case    1:*/		return 0x821ED448;
		  /* 821ED448h */ case    2:  		/* mtspr LR, R12 */
		/* 821ED448h case    2:*/		regs.LR = regs.R12;
		/* 821ED448h case    2:*/		return 0x821ED44C;
		  /* 821ED44Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821ED44Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821ED44Ch case    3:*/		return 0x821ED450;
		  /* 821ED450h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821ED450h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ED450h case    4:*/		return 0x821ED454;
		  /* 821ED454h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821ED454h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821ED454h case    5:*/		return 0x821ED458;
	}
	return 0x821ED458;
} // Block from 821ED440h-821ED458h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED458);
		  /* 821ED458h */ case    0:  		/* mfspr R12, LR */
		/* 821ED458h case    0:*/		regs.R12 = regs.LR;
		/* 821ED458h case    0:*/		return 0x821ED45C;
		  /* 821ED45Ch */ case    1:  		/* bl -1425920 */
		/* 821ED45Ch case    1:*/		regs.LR = 0x821ED460; return 0x8209125C;
		/* 821ED45Ch case    1:*/		return 0x821ED460;
		  /* 821ED460h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821ED460h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821ED460h case    2:*/		return 0x821ED464;
		  /* 821ED464h */ case    3:  		/* mr R29, R3 */
		/* 821ED464h case    3:*/		regs.R29 = regs.R3;
		/* 821ED464h case    3:*/		return 0x821ED468;
		  /* 821ED468h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 821ED468h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821ED468h case    4:*/		return 0x821ED46C;
		  /* 821ED46Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 821ED46Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821ED478;  }
		/* 821ED46Ch case    5:*/		return 0x821ED470;
		  /* 821ED470h */ case    6:  		/* li R4, 4801 */
		/* 821ED470h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ED470h case    6:*/		return 0x821ED474;
		  /* 821ED474h */ case    7:  		/* bl -636428 */
		/* 821ED474h case    7:*/		regs.LR = 0x821ED478; return 0x82151E68;
		/* 821ED474h case    7:*/		return 0x821ED478;
	}
	return 0x821ED478;
} // Block from 821ED458h-821ED478h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821ED478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED478);
		  /* 821ED478h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821ED478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821ED478h case    0:*/		return 0x821ED47C;
		  /* 821ED47Ch */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 821ED47Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821ED47Ch case    1:*/		return 0x821ED480;
		  /* 821ED480h */ case    2:  		/* bc 4, CR6_EQ, 92 */
		/* 821ED480h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821ED4DC;  }
		/* 821ED480h case    2:*/		return 0x821ED484;
		  /* 821ED484h */ case    3:  		/* li R30, 0 */
		/* 821ED484h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821ED484h case    3:*/		return 0x821ED488;
		  /* 821ED488h */ case    4:  		/* mr R31, R4 */
		/* 821ED488h case    4:*/		regs.R31 = regs.R4;
		/* 821ED488h case    4:*/		return 0x821ED48C;
		  /* 821ED48Ch */ case    5:  		/* lwz R4, <#[R31 + 8]> */
		/* 821ED48Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED48Ch case    5:*/		return 0x821ED490;
		  /* 821ED490h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 821ED490h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821ED490h case    6:*/		return 0x821ED494;
		  /* 821ED494h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821ED494h case    7:*/		if ( regs.CR[6].eq ) { return 0x821ED4A4;  }
		/* 821ED494h case    7:*/		return 0x821ED498;
		  /* 821ED498h */ case    8:  		/* mr R3, R29 */
		/* 821ED498h case    8:*/		regs.R3 = regs.R29;
		/* 821ED498h case    8:*/		return 0x821ED49C;
		  /* 821ED49Ch */ case    9:  		/* bl -380 */
		/* 821ED49Ch case    9:*/		regs.LR = 0x821ED4A0; return 0x821ED320;
		/* 821ED49Ch case    9:*/		return 0x821ED4A0;
		  /* 821ED4A0h */ case   10:  		/* add R30, R3, R30 */
		/* 821ED4A0h case   10:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R30);
		/* 821ED4A0h case   10:*/		return 0x821ED4A4;
	}
	return 0x821ED4A4;
} // Block from 821ED478h-821ED4A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821ED4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED4A4);
		  /* 821ED4A4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821ED4A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821ED4A4h case    0:*/		return 0x821ED4A8;
		  /* 821ED4A8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821ED4A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED4A8h case    1:*/		return 0x821ED4AC;
		  /* 821ED4ACh */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821ED4ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821ED4BC;  }
		/* 821ED4ACh case    2:*/		return 0x821ED4B0;
		  /* 821ED4B0h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821ED4B0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821ED4B0h case    3:*/		return 0x821ED4B4;
		  /* 821ED4B4h */ case    4:  		/* cmpwi CR6, R10, 1 */
		/* 821ED4B4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821ED4B4h case    4:*/		return 0x821ED4B8;
		  /* 821ED4B8h */ case    5:  		/* bc 4, CR6_EQ, 24 */
		/* 821ED4B8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821ED4D0;  }
		/* 821ED4B8h case    5:*/		return 0x821ED4BC;
	}
	return 0x821ED4BC;
} // Block from 821ED4A4h-821ED4BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED4BC);
		  /* 821ED4BCh */ case    0:  		/* mr R31, R11 */
		/* 821ED4BCh case    0:*/		regs.R31 = regs.R11;
		/* 821ED4BCh case    0:*/		return 0x821ED4C0;
		  /* 821ED4C0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821ED4C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED4C0h case    1:*/		return 0x821ED4C4;
		  /* 821ED4C4h */ case    2:  		/* bc 4, CR6_EQ, -56 */
		/* 821ED4C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821ED48C;  }
		/* 821ED4C4h case    2:*/		return 0x821ED4C8;
		  /* 821ED4C8h */ case    3:  		/* mr R3, R30 */
		/* 821ED4C8h case    3:*/		regs.R3 = regs.R30;
		/* 821ED4C8h case    3:*/		return 0x821ED4CC;
		  /* 821ED4CCh */ case    4:  		/* b 24 */
		/* 821ED4CCh case    4:*/		return 0x821ED4E4;
		/* 821ED4CCh case    4:*/		return 0x821ED4D0;
	}
	return 0x821ED4D0;
} // Block from 821ED4BCh-821ED4D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821ED4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED4D0);
		  /* 821ED4D0h */ case    0:  		/* li R4, 4801 */
		/* 821ED4D0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ED4D0h case    0:*/		return 0x821ED4D4;
		  /* 821ED4D4h */ case    1:  		/* mr R3, R29 */
		/* 821ED4D4h case    1:*/		regs.R3 = regs.R29;
		/* 821ED4D4h case    1:*/		return 0x821ED4D8;
		  /* 821ED4D8h */ case    2:  		/* bl -636528 */
		/* 821ED4D8h case    2:*/		regs.LR = 0x821ED4DC; return 0x82151E68;
		/* 821ED4D8h case    2:*/		return 0x821ED4DC;
	}
	return 0x821ED4DC;
} // Block from 821ED4D0h-821ED4DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED4DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED4DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED4DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED4DC);
		  /* 821ED4DCh */ case    0:  		/* mr R3, R29 */
		/* 821ED4DCh case    0:*/		regs.R3 = regs.R29;
		/* 821ED4DCh case    0:*/		return 0x821ED4E0;
		  /* 821ED4E0h */ case    1:  		/* bl -448 */
		/* 821ED4E0h case    1:*/		regs.LR = 0x821ED4E4; return 0x821ED320;
		/* 821ED4E0h case    1:*/		return 0x821ED4E4;
	}
	return 0x821ED4E4;
} // Block from 821ED4DCh-821ED4E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED4E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED4E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED4E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED4E4);
		  /* 821ED4E4h */ case    0:  		/* addi R1, R1, 112 */
		/* 821ED4E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821ED4E4h case    0:*/		return 0x821ED4E8;
		  /* 821ED4E8h */ case    1:  		/* b -1425980 */
		/* 821ED4E8h case    1:*/		return 0x820912AC;
		/* 821ED4E8h case    1:*/		return 0x821ED4EC;
		  /* 821ED4ECh */ case    2:  		/* nop */
		/* 821ED4ECh case    2:*/		cpu::op::nop();
		/* 821ED4ECh case    2:*/		return 0x821ED4F0;
	}
	return 0x821ED4F0;
} // Block from 821ED4E4h-821ED4F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED4F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED4F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED4F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED4F0);
		  /* 821ED4F0h */ case    0:  		/* mfspr R12, LR */
		/* 821ED4F0h case    0:*/		regs.R12 = regs.LR;
		/* 821ED4F0h case    0:*/		return 0x821ED4F4;
		  /* 821ED4F4h */ case    1:  		/* bl -1426084 */
		/* 821ED4F4h case    1:*/		regs.LR = 0x821ED4F8; return 0x82091250;
		/* 821ED4F4h case    1:*/		return 0x821ED4F8;
		  /* 821ED4F8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821ED4F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821ED4F8h case    2:*/		return 0x821ED4FC;
		  /* 821ED4FCh */ case    3:  		/* mr R29, R3 */
		/* 821ED4FCh case    3:*/		regs.R29 = regs.R3;
		/* 821ED4FCh case    3:*/		return 0x821ED500;
		  /* 821ED500h */ case    4:  		/* li R26, 0 */
		/* 821ED500h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821ED500h case    4:*/		return 0x821ED504;
		  /* 821ED504h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 821ED504h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821ED504h case    5:*/		return 0x821ED508;
		  /* 821ED508h */ case    6:  		/* bc 12, CR6_EQ, 300 */
		/* 821ED508h case    6:*/		if ( regs.CR[6].eq ) { return 0x821ED634;  }
		/* 821ED508h case    6:*/		return 0x821ED50C;
		  /* 821ED50Ch */ case    7:  		/* lwz R11, <#[R4 + 4]> */
		/* 821ED50Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821ED50Ch case    7:*/		return 0x821ED510;
		  /* 821ED510h */ case    8:  		/* cmpwi CR6, R11, 1 */
		/* 821ED510h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821ED510h case    8:*/		return 0x821ED514;
		  /* 821ED514h */ case    9:  		/* bc 4, CR6_EQ, 288 */
		/* 821ED514h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821ED634;  }
		/* 821ED514h case    9:*/		return 0x821ED518;
	}
	return 0x821ED518;
} // Block from 821ED4F0h-821ED518h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821ED518h
// Function '?GetVarName@Compiler@D3DXShader@@QAAPBDI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED518);
		  /* 821ED518h */ case    0:  		/* lwz R11, <#[R4 + 12]> */
		/* 821ED518h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821ED518h case    0:*/		return 0x821ED51C;
		  /* 821ED51Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821ED51Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED51Ch case    1:*/		return 0x821ED520;
		  /* 821ED520h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 821ED520h case    2:*/		if ( regs.CR[6].eq ) { return 0x821ED52C;  }
		/* 821ED520h case    2:*/		return 0x821ED524;
		  /* 821ED524h */ case    3:  		/* li R4, 4801 */
		/* 821ED524h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ED524h case    3:*/		return 0x821ED528;
		  /* 821ED528h */ case    4:  		/* bl -636608 */
		/* 821ED528h case    4:*/		regs.LR = 0x821ED52C; return 0x82151E68;
		/* 821ED528h case    4:*/		return 0x821ED52C;
	}
	return 0x821ED52C;
} // Block from 821ED518h-821ED52Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821ED52Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED52C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED52C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED52C);
		  /* 821ED52Ch */ case    0:  		/* lwz R28, <#[R4 + 8]> */
		/* 821ED52Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000008) );
		/* 821ED52Ch case    0:*/		return 0x821ED530;
		  /* 821ED530h */ case    1:  		/* li R31, 0 */
		/* 821ED530h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821ED530h case    1:*/		return 0x821ED534;
		  /* 821ED534h */ case    2:  		/* cmplwi CR6, R28, 0 */
		/* 821ED534h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821ED534h case    2:*/		return 0x821ED538;
		  /* 821ED538h */ case    3:  		/* bc 12, CR6_EQ, 240 */
		/* 821ED538h case    3:*/		if ( regs.CR[6].eq ) { return 0x821ED628;  }
		/* 821ED538h case    3:*/		return 0x821ED53C;
		  /* 821ED53Ch */ case    4:  		/* lis R11, -32255 */
		/* 821ED53Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821ED53Ch case    4:*/		return 0x821ED540;
		  /* 821ED540h */ case    5:  		/* addi R27, R11, 9252 */
		/* 821ED540h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x2424);
		/* 821ED540h case    5:*/		return 0x821ED544;
		  /* 821ED544h */ case    6:  		/* mr R6, R27 */
		/* 821ED544h case    6:*/		regs.R6 = regs.R27;
		/* 821ED544h case    6:*/		return 0x821ED548;
		  /* 821ED548h */ case    7:  		/* mr R5, R26 */
		/* 821ED548h case    7:*/		regs.R5 = regs.R26;
		/* 821ED548h case    7:*/		return 0x821ED54C;
		  /* 821ED54Ch */ case    8:  		/* mr R4, R28 */
		/* 821ED54Ch case    8:*/		regs.R4 = regs.R28;
		/* 821ED54Ch case    8:*/		return 0x821ED550;
		  /* 821ED550h */ case    9:  		/* mr R3, R29 */
		/* 821ED550h case    9:*/		regs.R3 = regs.R29;
		/* 821ED550h case    9:*/		return 0x821ED554;
		  /* 821ED554h */ case   10:  		/* bl -1508 */
		/* 821ED554h case   10:*/		regs.LR = 0x821ED558; return 0x821ECF70;
		/* 821ED554h case   10:*/		return 0x821ED558;
		  /* 821ED558h */ case   11:  		/* lwz R11, <#[R29 + 40]> */
		/* 821ED558h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000028) );
		/* 821ED558h case   11:*/		return 0x821ED55C;
		  /* 821ED55Ch */ case   12:  		/* mr R26, R3 */
		/* 821ED55Ch case   12:*/		regs.R26 = regs.R3;
		/* 821ED55Ch case   12:*/		return 0x821ED560;
		  /* 821ED560h */ case   13:  		/* rlwinm. R11, R11, 0, 15, 15 */
		/* 821ED560h case   13:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R11,regs.R11);
		/* 821ED560h case   13:*/		return 0x821ED564;
		  /* 821ED564h */ case   14:  		/* bc 12, CR0_EQ, 184 */
		/* 821ED564h case   14:*/		if ( regs.CR[0].eq ) { return 0x821ED61C;  }
		/* 821ED564h case   14:*/		return 0x821ED568;
		  /* 821ED568h */ case   15:  		/* lwz R11, <#[R28 + 4]> */
		/* 821ED568h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821ED568h case   15:*/		return 0x821ED56C;
		  /* 821ED56Ch */ case   16:  		/* cmpwi CR6, R11, 27 */
		/* 821ED56Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001B);
		/* 821ED56Ch case   16:*/		return 0x821ED570;
		  /* 821ED570h */ case   17:  		/* bc 4, CR6_EQ, 172 */
		/* 821ED570h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821ED61C;  }
		/* 821ED570h case   17:*/		return 0x821ED574;
		  /* 821ED574h */ case   18:  		/* lwz R11, <#[R28 + 56]> */
		/* 821ED574h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000038) );
		/* 821ED574h case   18:*/		return 0x821ED578;
		  /* 821ED578h */ case   19:  		/* cmplwi CR6, R11, 5 */
		/* 821ED578h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 821ED578h case   19:*/		return 0x821ED57C;
		  /* 821ED57Ch */ case   20:  		/* bc 4, CR6_EQ, 160 */
		/* 821ED57Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x821ED61C;  }
		/* 821ED57Ch case   20:*/		return 0x821ED580;
		  /* 821ED580h */ case   21:  		/* lwz R11, <#[R28 + 60]> */
		/* 821ED580h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000003C) );
		/* 821ED580h case   21:*/		return 0x821ED584;
		  /* 821ED584h */ case   22:  		/* cmplwi CR6, R11, 2 */
		/* 821ED584h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821ED584h case   22:*/		return 0x821ED588;
		  /* 821ED588h */ case   23:  		/* bc 12, CR6_EQ, 28 */
		/* 821ED588h case   23:*/		if ( regs.CR[6].eq ) { return 0x821ED5A4;  }
		/* 821ED588h case   23:*/		return 0x821ED58C;
		  /* 821ED58Ch */ case   24:  		/* cmplwi CR6, R11, 4 */
		/* 821ED58Ch case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821ED58Ch case   24:*/		return 0x821ED590;
		  /* 821ED590h */ case   25:  		/* bc 12, CR6_EQ, 20 */
		/* 821ED590h case   25:*/		if ( regs.CR[6].eq ) { return 0x821ED5A4;  }
		/* 821ED590h case   25:*/		return 0x821ED594;
		  /* 821ED594h */ case   26:  		/* cmplwi CR6, R11, 6 */
		/* 821ED594h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 821ED594h case   26:*/		return 0x821ED598;
		  /* 821ED598h */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 821ED598h case   27:*/		if ( regs.CR[6].eq ) { return 0x821ED5A4;  }
		/* 821ED598h case   27:*/		return 0x821ED59C;
		  /* 821ED59Ch */ case   28:  		/* cmplwi CR6, R11, 14 */
		/* 821ED59Ch case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000E);
		/* 821ED59Ch case   28:*/		return 0x821ED5A0;
		  /* 821ED5A0h */ case   29:  		/* bc 4, CR6_EQ, 120 */
		/* 821ED5A0h case   29:*/		if ( !regs.CR[6].eq ) { return 0x821ED618;  }
		/* 821ED5A0h case   29:*/		return 0x821ED5A4;
	}
	return 0x821ED5A4;
} // Block from 821ED52Ch-821ED5A4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821ED5A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED5A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED5A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED5A4);
		  /* 821ED5A4h */ case    0:  		/* mr R3, R29 */
		/* 821ED5A4h case    0:*/		regs.R3 = regs.R29;
		/* 821ED5A4h case    0:*/		return 0x821ED5A8;
		  /* 821ED5A8h */ case    1:  		/* bl -1160 */
		/* 821ED5A8h case    1:*/		regs.LR = 0x821ED5AC; return 0x821ED120;
		/* 821ED5A8h case    1:*/		return 0x821ED5AC;
		  /* 821ED5ACh */ case    2:  		/* li R11, 1 */
		/* 821ED5ACh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821ED5ACh case    2:*/		return 0x821ED5B0;
		  /* 821ED5B0h */ case    3:  		/* mr R30, R3 */
		/* 821ED5B0h case    3:*/		regs.R30 = regs.R3;
		/* 821ED5B0h case    3:*/		return 0x821ED5B4;
		  /* 821ED5B4h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821ED5B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821ED5B4h case    4:*/		return 0x821ED5B8;
		  /* 821ED5B8h */ case    5:  		/* stw R11, <#[R3 + 16]> */
		/* 821ED5B8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 821ED5B8h case    5:*/		return 0x821ED5BC;
		  /* 821ED5BCh */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 821ED5BCh case    6:*/		if ( regs.CR[6].eq ) { return 0x821ED5E0;  }
		/* 821ED5BCh case    6:*/		return 0x821ED5C0;
		  /* 821ED5C0h */ case    7:  		/* mr R6, R27 */
		/* 821ED5C0h case    7:*/		regs.R6 = regs.R27;
		/* 821ED5C0h case    7:*/		return 0x821ED5C4;
		  /* 821ED5C4h */ case    8:  		/* lwz R4, <#[R31 + 8]> */
		/* 821ED5C4h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED5C4h case    8:*/		return 0x821ED5C8;
		  /* 821ED5C8h */ case    9:  		/* mr R3, R29 */
		/* 821ED5C8h case    9:*/		regs.R3 = regs.R29;
		/* 821ED5C8h case    9:*/		return 0x821ED5CC;
		  /* 821ED5CCh */ case   10:  		/* lwz R5, <#[R31 + 12]> */
		/* 821ED5CCh case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 821ED5CCh case   10:*/		return 0x821ED5D0;
		  /* 821ED5D0h */ case   11:  		/* bl -1632 */
		/* 821ED5D0h case   11:*/		regs.LR = 0x821ED5D4; return 0x821ECF70;
		/* 821ED5D0h case   11:*/		return 0x821ED5D4;
		  /* 821ED5D4h */ case   12:  		/* stw R3, <#[R31 + 12]> */
		/* 821ED5D4h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 821ED5D4h case   12:*/		return 0x821ED5D8;
		  /* 821ED5D8h */ case   13:  		/* stw R30, <#[R31 + 8]> */
		/* 821ED5D8h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED5D8h case   13:*/		return 0x821ED5DC;
		  /* 821ED5DCh */ case   14:  		/* b 60 */
		/* 821ED5DCh case   14:*/		return 0x821ED618;
		/* 821ED5DCh case   14:*/		return 0x821ED5E0;
	}
	return 0x821ED5E0;
} // Block from 821ED5A4h-821ED5E0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821ED5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED5E0);
		  /* 821ED5E0h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 821ED5E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 821ED5E0h case    0:*/		return 0x821ED5E4;
		  /* 821ED5E4h */ case    1:  		/* addi R31, R26, 12 */
		/* 821ED5E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R26,0xC);
		/* 821ED5E4h case    1:*/		return 0x821ED5E8;
		  /* 821ED5E8h */ case    2:  		/* b 16 */
		/* 821ED5E8h case    2:*/		return 0x821ED5F8;
		/* 821ED5E8h case    2:*/		return 0x821ED5EC;
		  /* 821ED5ECh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 821ED5ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821ED5ECh case    3:*/		return 0x821ED5F0;
		  /* 821ED5F0h */ case    4:  		/* addi R31, R11, 12 */
		/* 821ED5F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xC);
		/* 821ED5F0h case    4:*/		return 0x821ED5F4;
		  /* 821ED5F4h */ case    5:  		/* lwz R11, <#[R11 + 12]> */
		/* 821ED5F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821ED5F4h case    5:*/		return 0x821ED5F8;
	}
	return 0x821ED5F8;
} // Block from 821ED5E0h-821ED5F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED5F8);
		  /* 821ED5F8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821ED5F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED5F8h case    0:*/		return 0x821ED5FC;
		  /* 821ED5FCh */ case    1:  		/* bc 4, CR6_EQ, -16 */
		/* 821ED5FCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821ED5EC;  }
		/* 821ED5FCh case    1:*/		return 0x821ED600;
		  /* 821ED600h */ case    2:  		/* mr R6, R27 */
		/* 821ED600h case    2:*/		regs.R6 = regs.R27;
		/* 821ED600h case    2:*/		return 0x821ED604;
		  /* 821ED604h */ case    3:  		/* li R5, 0 */
		/* 821ED604h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821ED604h case    3:*/		return 0x821ED608;
		  /* 821ED608h */ case    4:  		/* mr R4, R30 */
		/* 821ED608h case    4:*/		regs.R4 = regs.R30;
		/* 821ED608h case    4:*/		return 0x821ED60C;
		  /* 821ED60Ch */ case    5:  		/* mr R3, R29 */
		/* 821ED60Ch case    5:*/		regs.R3 = regs.R29;
		/* 821ED60Ch case    5:*/		return 0x821ED610;
		  /* 821ED610h */ case    6:  		/* bl -1696 */
		/* 821ED610h case    6:*/		regs.LR = 0x821ED614; return 0x821ECF70;
		/* 821ED610h case    6:*/		return 0x821ED614;
		  /* 821ED614h */ case    7:  		/* stw R3, <#[R31]> */
		/* 821ED614h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 821ED614h case    7:*/		return 0x821ED618;
	}
	return 0x821ED618;
} // Block from 821ED5F8h-821ED618h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821ED618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED618);
		  /* 821ED618h */ case    0:  		/* mr R31, R26 */
		/* 821ED618h case    0:*/		regs.R31 = regs.R26;
		/* 821ED618h case    0:*/		return 0x821ED61C;
	}
	return 0x821ED61C;
} // Block from 821ED618h-821ED61Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ED61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED61C);
		  /* 821ED61Ch */ case    0:  		/* lwz R28, <#[R28 + 12]> */
		/* 821ED61Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x0000000C) );
		/* 821ED61Ch case    0:*/		return 0x821ED620;
		  /* 821ED620h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 821ED620h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821ED620h case    1:*/		return 0x821ED624;
		  /* 821ED624h */ case    2:  		/* bc 4, CR6_EQ, -224 */
		/* 821ED624h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821ED544;  }
		/* 821ED624h case    2:*/		return 0x821ED628;
	}
	return 0x821ED628;
} // Block from 821ED61Ch-821ED628h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED628);
		  /* 821ED628h */ case    0:  		/* mr R3, R26 */
		/* 821ED628h case    0:*/		regs.R3 = regs.R26;
		/* 821ED628h case    0:*/		return 0x821ED62C;
		  /* 821ED62Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 821ED62Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821ED62Ch case    1:*/		return 0x821ED630;
		  /* 821ED630h */ case    2:  		/* b -1426320 */
		/* 821ED630h case    2:*/		return 0x820912A0;
		/* 821ED630h case    2:*/		return 0x821ED634;
	}
	return 0x821ED634;
} // Block from 821ED628h-821ED634h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED634);
		  /* 821ED634h */ case    0:  		/* li R4, 4801 */
		/* 821ED634h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821ED634h case    0:*/		return 0x821ED638;
		  /* 821ED638h */ case    1:  		/* mr R3, R29 */
		/* 821ED638h case    1:*/		regs.R3 = regs.R29;
		/* 821ED638h case    1:*/		return 0x821ED63C;
		  /* 821ED63Ch */ case    2:  		/* bl -636884 */
		/* 821ED63Ch case    2:*/		regs.LR = 0x821ED640; return 0x82151E68;
		/* 821ED63Ch case    2:*/		return 0x821ED640;
	}
	return 0x821ED640;
} // Block from 821ED634h-821ED640h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED640h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED640);
		  /* 821ED640h */ case    0:  		/* mfspr R12, LR */
		/* 821ED640h case    0:*/		regs.R12 = regs.LR;
		/* 821ED640h case    0:*/		return 0x821ED644;
		  /* 821ED644h */ case    1:  		/* bl -1426412 */
		/* 821ED644h case    1:*/		regs.LR = 0x821ED648; return 0x82091258;
		/* 821ED644h case    1:*/		return 0x821ED648;
		  /* 821ED648h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821ED648h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821ED648h case    2:*/		return 0x821ED64C;
		  /* 821ED64Ch */ case    3:  		/* mr R31, R4 */
		/* 821ED64Ch case    3:*/		regs.R31 = regs.R4;
		/* 821ED64Ch case    3:*/		return 0x821ED650;
		  /* 821ED650h */ case    4:  		/* mr R30, R5 */
		/* 821ED650h case    4:*/		regs.R30 = regs.R5;
		/* 821ED650h case    4:*/		return 0x821ED654;
		  /* 821ED654h */ case    5:  		/* li R5, 18 */
		/* 821ED654h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x12);
		/* 821ED654h case    5:*/		return 0x821ED658;
		  /* 821ED658h */ case    6:  		/* li R4, 40 */
		/* 821ED658h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 821ED658h case    6:*/		return 0x821ED65C;
		  /* 821ED65Ch */ case    7:  		/* mr R29, R6 */
		/* 821ED65Ch case    7:*/		regs.R29 = regs.R6;
		/* 821ED65Ch case    7:*/		return 0x821ED660;
		  /* 821ED660h */ case    8:  		/* bl -527032 */
		/* 821ED660h case    8:*/		regs.LR = 0x821ED664; return 0x8216CBA8;
		/* 821ED660h case    8:*/		return 0x821ED664;
		  /* 821ED664h */ case    9:  		/* mr R28, R3 */
		/* 821ED664h case    9:*/		regs.R28 = regs.R3;
		/* 821ED664h case    9:*/		return 0x821ED668;
	}
	return 0x821ED668;
} // Block from 821ED640h-821ED668h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821ED668h
// Function '?IdentifyAttributeNode@Compiler@D3DXShader@@AAA?AW4AttributeType@2@PAVCNodeAttribute@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED668);
		  /* 821ED668h */ case    0:  		/* addi R3, R1, 80 */
		/* 821ED668h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821ED668h case    0:*/		return 0x821ED66C;
		  /* 821ED66Ch */ case    1:  		/* bl -1190444 */
		/* 821ED66Ch case    1:*/		regs.LR = 0x821ED670; return 0x820CAC40;
		/* 821ED66Ch case    1:*/		return 0x821ED670;
		  /* 821ED670h */ case    2:  		/* lwz R9, <#[R1 + 80]> */
		/* 821ED670h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821ED670h case    2:*/		return 0x821ED674;
		  /* 821ED674h */ case    3:  		/* li R11, 9 */
		/* 821ED674h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x9);
		/* 821ED674h case    3:*/		return 0x821ED678;
		  /* 821ED678h */ case    4:  		/* stw R31, <#[R28 + 20]> */
		/* 821ED678h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000014) );
		/* 821ED678h case    4:*/		return 0x821ED67C;
		  /* 821ED67Ch */ case    5:  		/* li R10, 1024 */
		/* 821ED67Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x400);
		/* 821ED67Ch case    5:*/		return 0x821ED680;
		  /* 821ED680h */ case    6:  		/* stw R30, <#[R28 + 28]> */
		/* 821ED680h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R28 + 0x0000001C) );
		/* 821ED680h case    6:*/		return 0x821ED684;
		  /* 821ED684h */ case    7:  		/* stw R11, <#[R28 + 4]> */
		/* 821ED684h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821ED684h case    7:*/		return 0x821ED688;
		  /* 821ED688h */ case    8:  		/* mr R3, R28 */
		/* 821ED688h case    8:*/		regs.R3 = regs.R28;
		/* 821ED688h case    8:*/		return 0x821ED68C;
		  /* 821ED68Ch */ case    9:  		/* stw R29, <#[R28 + 32]> */
		/* 821ED68Ch case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000020) );
		/* 821ED68Ch case    9:*/		return 0x821ED690;
		  /* 821ED690h */ case   10:  		/* stw R9, <#[R28]> */
		/* 821ED690h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 821ED690h case   10:*/		return 0x821ED694;
		  /* 821ED694h */ case   11:  		/* stw R10, <#[R28 + 36]> */
		/* 821ED694h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000024) );
		/* 821ED694h case   11:*/		return 0x821ED698;
		  /* 821ED698h */ case   12:  		/* addi R1, R1, 160 */
		/* 821ED698h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821ED698h case   12:*/		return 0x821ED69C;
		  /* 821ED69Ch */ case   13:  		/* b -1426420 */
		/* 821ED69Ch case   13:*/		return 0x820912A8;
		/* 821ED69Ch case   13:*/		return 0x821ED6A0;
	}
	return 0x821ED6A0;
} // Block from 821ED668h-821ED6A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821ED6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED6A0);
		  /* 821ED6A0h */ case    0:  		/* mfspr R12, LR */
		/* 821ED6A0h case    0:*/		regs.R12 = regs.LR;
		/* 821ED6A0h case    0:*/		return 0x821ED6A4;
		  /* 821ED6A4h */ case    1:  		/* bl -1426508 */
		/* 821ED6A4h case    1:*/		regs.LR = 0x821ED6A8; return 0x82091258;
		/* 821ED6A4h case    1:*/		return 0x821ED6A8;
		  /* 821ED6A8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821ED6A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821ED6A8h case    2:*/		return 0x821ED6AC;
		  /* 821ED6ACh */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 821ED6ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821ED6ACh case    3:*/		return 0x821ED6B0;
		  /* 821ED6B0h */ case    4:  		/* mr R30, R4 */
		/* 821ED6B0h case    4:*/		regs.R30 = regs.R4;
		/* 821ED6B0h case    4:*/		return 0x821ED6B4;
		  /* 821ED6B4h */ case    5:  		/* mr R28, R5 */
		/* 821ED6B4h case    5:*/		regs.R28 = regs.R5;
		/* 821ED6B4h case    5:*/		return 0x821ED6B8;
		  /* 821ED6B8h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821ED6B8h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821ED6B8h case    6:*/		return 0x821ED6BC;
		  /* 821ED6BCh */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821ED6BCh case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821ED6BCh case    7:*/		return 0x821ED6C0;
		  /* 821ED6C0h */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821ED6C0h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821ED6C0h case    8:*/		return 0x821ED6C4;
		  /* 821ED6C4h */ case    9:  		/* mr R29, R3 */
		/* 821ED6C4h case    9:*/		regs.R29 = regs.R3;
		/* 821ED6C4h case    9:*/		return 0x821ED6C8;
		  /* 821ED6C8h */ case   10:  		/* bl -561816 */
		/* 821ED6C8h case   10:*/		regs.LR = 0x821ED6CC; return 0x82164430;
		/* 821ED6C8h case   10:*/		return 0x821ED6CC;
		  /* 821ED6CCh */ case   11:  		/* lwz R11, <#[R28]> */
		/* 821ED6CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821ED6CCh case   11:*/		return 0x821ED6D0;
		  /* 821ED6D0h */ case   12:  		/* addi R10, R30, -16 */
		/* 821ED6D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFF0);
		/* 821ED6D0h case   12:*/		return 0x821ED6D4;
		  /* 821ED6D4h */ case   13:  		/* rlwinm. R9, R11, 0, 28, 28 */
		/* 821ED6D4h case   13:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R11);
		/* 821ED6D4h case   13:*/		return 0x821ED6D8;
		  /* 821ED6D8h */ case   14:  		/* add R31, R3, R10 */
		/* 821ED6D8h case   14:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R10);
		/* 821ED6D8h case   14:*/		return 0x821ED6DC;
		  /* 821ED6DCh */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED6DCh case   15:*/		if ( regs.CR[0].eq ) { return 0x821ED6E8;  }
		/* 821ED6DCh case   15:*/		return 0x821ED6E0;
		  /* 821ED6E0h */ case   16:  		/* li R10, 1 */
		/* 821ED6E0h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED6E0h case   16:*/		return 0x821ED6E4;
		  /* 821ED6E4h */ case   17:  		/* b 264 */
		/* 821ED6E4h case   17:*/		return 0x821ED7EC;
		/* 821ED6E4h case   17:*/		return 0x821ED6E8;
	}
	return 0x821ED6E8;
} // Block from 821ED6A0h-821ED6E8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821ED6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED6E8);
		  /* 821ED6E8h */ case    0:  		/* rlwinm. R10, R11, 0, 22, 22 */
		/* 821ED6E8h case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R11);
		/* 821ED6E8h case    0:*/		return 0x821ED6EC;
		  /* 821ED6ECh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821ED6ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED700;  }
		/* 821ED6ECh case    1:*/		return 0x821ED6F0;
		  /* 821ED6F0h */ case    2:  		/* li R10, 5 */
		/* 821ED6F0h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 821ED6F0h case    2:*/		return 0x821ED6F4;
		  /* 821ED6F4h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 821ED6F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED6F4h case    3:*/		return 0x821ED6F8;
		  /* 821ED6F8h */ case    4:  		/* rlwimi R11, R10, 3, 23, 31 */
		/* 821ED6F8h case    4:*/		cpu::op::rlwimi<0,3,23,31>(regs,&regs.R11,regs.R10);
		/* 821ED6F8h case    4:*/		return 0x821ED6FC;
		  /* 821ED6FCh */ case    5:  		/* b 248 */
		/* 821ED6FCh case    5:*/		return 0x821ED7F4;
		/* 821ED6FCh case    5:*/		return 0x821ED700;
	}
	return 0x821ED700;
} // Block from 821ED6E8h-821ED700h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED700);
		  /* 821ED700h */ case    0:  		/* rlwinm. R10, R11, 0, 21, 21 */
		/* 821ED700h case    0:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R11);
		/* 821ED700h case    0:*/		return 0x821ED704;
		  /* 821ED704h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 821ED704h case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED738;  }
		/* 821ED704h case    1:*/		return 0x821ED708;
	}
	return 0x821ED708;
} // Block from 821ED700h-821ED708h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED708h
// Function '?RestoreAttributeState@Compiler@D3DXShader@@AAAXPAUAttributeStateStackEntry@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED708);
		  /* 821ED708h */ case    0:  		/* lwz R4, <#[R28 + 12]> */
		/* 821ED708h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x0000000C) );
		/* 821ED708h case    0:*/		return 0x821ED70C;
		  /* 821ED70Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 821ED70Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821ED70Ch case    1:*/		return 0x821ED710;
		  /* 821ED710h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 821ED710h case    2:*/		if ( regs.CR[6].eq ) { return 0x821ED730;  }
		/* 821ED710h case    2:*/		return 0x821ED714;
		  /* 821ED714h */ case    3:  		/* mr R3, R30 */
		/* 821ED714h case    3:*/		regs.R3 = regs.R30;
		/* 821ED714h case    3:*/		return 0x821ED718;
		  /* 821ED718h */ case    4:  		/* bl -480592 */
		/* 821ED718h case    4:*/		regs.LR = 0x821ED71C; return 0x821781C8;
		/* 821ED718h case    4:*/		return 0x821ED71C;
		  /* 821ED71Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 821ED71Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED71Ch case    5:*/		return 0x821ED720;
		  /* 821ED720h */ case    6:  		/* li R10, 1 */
		/* 821ED720h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED720h case    6:*/		return 0x821ED724;
		  /* 821ED724h */ case    7:  		/* stw R3, <#[R31 + 4]> */
		/* 821ED724h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 821ED724h case    7:*/		return 0x821ED728;
		  /* 821ED728h */ case    8:  		/* rlwimi R11, R10, 0, 30, 31 */
		/* 821ED728h case    8:*/		cpu::op::rlwimi<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 821ED728h case    8:*/		return 0x821ED72C;
		  /* 821ED72Ch */ case    9:  		/* b 200 */
		/* 821ED72Ch case    9:*/		return 0x821ED7F4;
		/* 821ED72Ch case    9:*/		return 0x821ED730;
	}
	return 0x821ED730;
} // Block from 821ED708h-821ED730h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821ED730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED730);
		  /* 821ED730h */ case    0:  		/* li R10, 7 */
		/* 821ED730h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 821ED730h case    0:*/		return 0x821ED734;
		  /* 821ED734h */ case    1:  		/* b 184 */
		/* 821ED734h case    1:*/		return 0x821ED7EC;
		/* 821ED734h case    1:*/		return 0x821ED738;
	}
	return 0x821ED738;
} // Block from 821ED730h-821ED738h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED738);
		  /* 821ED738h */ case    0:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 821ED738h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 821ED738h case    0:*/		return 0x821ED73C;
		  /* 821ED73Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED73Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED748;  }
		/* 821ED73Ch case    1:*/		return 0x821ED740;
		  /* 821ED740h */ case    2:  		/* li R10, 1 */
		/* 821ED740h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED740h case    2:*/		return 0x821ED744;
		  /* 821ED744h */ case    3:  		/* b -80 */
		/* 821ED744h case    3:*/		return 0x821ED6F4;
		/* 821ED744h case    3:*/		return 0x821ED748;
	}
	return 0x821ED748;
} // Block from 821ED738h-821ED748h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ED748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED748);
		  /* 821ED748h */ case    0:  		/* rlwinm. R10, R11, 0, 26, 26 */
		/* 821ED748h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R11);
		/* 821ED748h case    0:*/		return 0x821ED74C;
		  /* 821ED74Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED74Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED758;  }
		/* 821ED74Ch case    1:*/		return 0x821ED750;
		  /* 821ED750h */ case    2:  		/* li R10, 3 */
		/* 821ED750h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 821ED750h case    2:*/		return 0x821ED754;
		  /* 821ED754h */ case    3:  		/* b 152 */
		/* 821ED754h case    3:*/		return 0x821ED7EC;
		/* 821ED754h case    3:*/		return 0x821ED758;
	}
	return 0x821ED758;
} // Block from 821ED748h-821ED758h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ED758h
// Function '?SortVariableComponentInfoByReg@D3DXShader@@YAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED758);
		  /* 821ED758h */ case    0:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 821ED758h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 821ED758h case    0:*/		return 0x821ED75C;
		  /* 821ED75Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821ED75Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED770;  }
		/* 821ED75Ch case    1:*/		return 0x821ED760;
		  /* 821ED760h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821ED760h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED760h case    2:*/		return 0x821ED764;
		  /* 821ED764h */ case    3:  		/* li R10, 1 */
		/* 821ED764h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED764h case    3:*/		return 0x821ED768;
		  /* 821ED768h */ case    4:  		/* rlwimi R11, R10, 4, 23, 31 */
		/* 821ED768h case    4:*/		cpu::op::rlwimi<0,4,23,31>(regs,&regs.R11,regs.R10);
		/* 821ED768h case    4:*/		return 0x821ED76C;
		  /* 821ED76Ch */ case    5:  		/* b 136 */
		/* 821ED76Ch case    5:*/		return 0x821ED7F4;
		/* 821ED76Ch case    5:*/		return 0x821ED770;
	}
	return 0x821ED770;
} // Block from 821ED758h-821ED770h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED770);
		  /* 821ED770h */ case    0:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 821ED770h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 821ED770h case    0:*/		return 0x821ED774;
		  /* 821ED774h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821ED774h case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED788;  }
		/* 821ED774h case    1:*/		return 0x821ED778;
		  /* 821ED778h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821ED778h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED778h case    2:*/		return 0x821ED77C;
		  /* 821ED77Ch */ case    3:  		/* li R10, 1 */
		/* 821ED77Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED77Ch case    3:*/		return 0x821ED780;
		  /* 821ED780h */ case    4:  		/* rlwimi R11, R10, 5, 23, 31 */
		/* 821ED780h case    4:*/		cpu::op::rlwimi<0,5,23,31>(regs,&regs.R11,regs.R10);
		/* 821ED780h case    4:*/		return 0x821ED784;
		  /* 821ED784h */ case    5:  		/* b 112 */
		/* 821ED784h case    5:*/		return 0x821ED7F4;
		/* 821ED784h case    5:*/		return 0x821ED788;
	}
	return 0x821ED788;
} // Block from 821ED770h-821ED788h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED788h
// Function '?InitInternalImportVariable@Compiler@D3DXShader@@AAAXIPAUFunction@2@IW4_D3DSCOPE_TYPE@2@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED788);
		  /* 821ED788h */ case    0:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 821ED788h case    0:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 821ED788h case    0:*/		return 0x821ED78C;
		  /* 821ED78Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED78Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED798;  }
		/* 821ED78Ch case    1:*/		return 0x821ED790;
		  /* 821ED790h */ case    2:  		/* li R10, 9 */
		/* 821ED790h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x9);
		/* 821ED790h case    2:*/		return 0x821ED794;
		  /* 821ED794h */ case    3:  		/* b 88 */
		/* 821ED794h case    3:*/		return 0x821ED7EC;
		/* 821ED794h case    3:*/		return 0x821ED798;
	}
	return 0x821ED798;
} // Block from 821ED788h-821ED798h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821ED798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED798);
		  /* 821ED798h */ case    0:  		/* lwz R10, <#[R29 + 52]> */
		/* 821ED798h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000034) );
		/* 821ED798h case    0:*/		return 0x821ED79C;
		  /* 821ED79Ch */ case    1:  		/* rlwinm. R11, R10, 0, 21, 21 */
		/* 821ED79Ch case    1:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R10);
		/* 821ED79Ch case    1:*/		return 0x821ED7A0;
		  /* 821ED7A0h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 821ED7A0h case    2:*/		if ( regs.CR[0].eq ) { return 0x821ED7B8;  }
		/* 821ED7A0h case    2:*/		return 0x821ED7A4;
		  /* 821ED7A4h */ case    3:  		/* lwz R9, <#[R28 + 4]> */
		/* 821ED7A4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000004) );
		/* 821ED7A4h case    3:*/		return 0x821ED7A8;
		  /* 821ED7A8h */ case    4:  		/* rlwinm. R9, R9, 0, 28, 28 */
		/* 821ED7A8h case    4:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R9);
		/* 821ED7A8h case    4:*/		return 0x821ED7AC;
		  /* 821ED7ACh */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED7ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x821ED7B8;  }
		/* 821ED7ACh case    5:*/		return 0x821ED7B0;
		  /* 821ED7B0h */ case    6:  		/* li R10, 33 */
		/* 821ED7B0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x21);
		/* 821ED7B0h case    6:*/		return 0x821ED7B4;
		  /* 821ED7B4h */ case    7:  		/* b 56 */
		/* 821ED7B4h case    7:*/		return 0x821ED7EC;
		/* 821ED7B4h case    7:*/		return 0x821ED7B8;
	}
	return 0x821ED7B8;
} // Block from 821ED798h-821ED7B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821ED7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED7B8);
		  /* 821ED7B8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821ED7B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED7B8h case    0:*/		return 0x821ED7BC;
		  /* 821ED7BCh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821ED7BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821ED7D4;  }
		/* 821ED7BCh case    1:*/		return 0x821ED7C0;
		  /* 821ED7C0h */ case    2:  		/* lwz R11, <#[R28 + 4]> */
		/* 821ED7C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821ED7C0h case    2:*/		return 0x821ED7C4;
		  /* 821ED7C4h */ case    3:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 821ED7C4h case    3:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 821ED7C4h case    3:*/		return 0x821ED7C8;
		  /* 821ED7C8h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 821ED7C8h case    4:*/		if ( regs.CR[0].eq ) { return 0x821ED7D4;  }
		/* 821ED7C8h case    4:*/		return 0x821ED7CC;
		  /* 821ED7CCh */ case    5:  		/* li R10, 21 */
		/* 821ED7CCh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x15);
		/* 821ED7CCh case    5:*/		return 0x821ED7D0;
		  /* 821ED7D0h */ case    6:  		/* b -220 */
		/* 821ED7D0h case    6:*/		return 0x821ED6F4;
		/* 821ED7D0h case    6:*/		return 0x821ED7D4;
	}
	return 0x821ED7D4;
} // Block from 821ED7B8h-821ED7D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821ED7D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED7D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED7D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED7D4);
		  /* 821ED7D4h */ case    0:  		/* rlwinm. R11, R10, 0, 22, 22 */
		/* 821ED7D4h case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R10);
		/* 821ED7D4h case    0:*/		return 0x821ED7D8;
		  /* 821ED7D8h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821ED7D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821ED7F8;  }
		/* 821ED7D8h case    1:*/		return 0x821ED7DC;
		  /* 821ED7DCh */ case    2:  		/* lwz R11, <#[R28 + 4]> */
		/* 821ED7DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821ED7DCh case    2:*/		return 0x821ED7E0;
		  /* 821ED7E0h */ case    3:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 821ED7E0h case    3:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 821ED7E0h case    3:*/		return 0x821ED7E4;
		  /* 821ED7E4h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 821ED7E4h case    4:*/		if ( regs.CR[0].eq ) { return 0x821ED7F8;  }
		/* 821ED7E4h case    4:*/		return 0x821ED7E8;
		  /* 821ED7E8h */ case    5:  		/* li R10, 39 */
		/* 821ED7E8h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x27);
		/* 821ED7E8h case    5:*/		return 0x821ED7EC;
	}
	return 0x821ED7EC;
} // Block from 821ED7D4h-821ED7ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821ED7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED7EC);
		  /* 821ED7ECh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821ED7ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED7ECh case    0:*/		return 0x821ED7F0;
		  /* 821ED7F0h */ case    1:  		/* rlwimi R11, R10, 2, 23, 31 */
		/* 821ED7F0h case    1:*/		cpu::op::rlwimi<0,2,23,31>(regs,&regs.R11,regs.R10);
		/* 821ED7F0h case    1:*/		return 0x821ED7F4;
	}
	return 0x821ED7F4;
} // Block from 821ED7ECh-821ED7F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED7F4);
		  /* 821ED7F4h */ case    0:  		/* stw R11, <#[R31 + 8]> */
		/* 821ED7F4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED7F4h case    0:*/		return 0x821ED7F8;
	}
	return 0x821ED7F8;
} // Block from 821ED7F4h-821ED7F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821ED7F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED7F8);
		  /* 821ED7F8h */ case    0:  		/* addi R1, R1, 128 */
		/* 821ED7F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821ED7F8h case    0:*/		return 0x821ED7FC;
		  /* 821ED7FCh */ case    1:  		/* b -1426772 */
		/* 821ED7FCh case    1:*/		return 0x820912A8;
		/* 821ED7FCh case    1:*/		return 0x821ED800;
	}
	return 0x821ED800;
} // Block from 821ED7F8h-821ED800h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821ED800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED800);
		  /* 821ED800h */ case    0:  		/* mfspr R12, LR */
		/* 821ED800h case    0:*/		regs.R12 = regs.LR;
		/* 821ED800h case    0:*/		return 0x821ED804;
		  /* 821ED804h */ case    1:  		/* bl -1426864 */
		/* 821ED804h case    1:*/		regs.LR = 0x821ED808; return 0x82091254;
		/* 821ED804h case    1:*/		return 0x821ED808;
		  /* 821ED808h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821ED808h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821ED808h case    2:*/		return 0x821ED80C;
		  /* 821ED80Ch */ case    3:  		/* addi R29, R4, 16 */
		/* 821ED80Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R4,0x10);
		/* 821ED80Ch case    3:*/		return 0x821ED810;
		  /* 821ED810h */ case    4:  		/* mr R27, R5 */
		/* 821ED810h case    4:*/		regs.R27 = regs.R5;
		/* 821ED810h case    4:*/		return 0x821ED814;
		  /* 821ED814h */ case    5:  		/* mr R5, R29 */
		/* 821ED814h case    5:*/		regs.R5 = regs.R29;
		/* 821ED814h case    5:*/		return 0x821ED818;
		  /* 821ED818h */ case    6:  		/* li R8, 0 */
		/* 821ED818h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821ED818h case    6:*/		return 0x821ED81C;
		  /* 821ED81Ch */ case    7:  		/* li R7, 0 */
		/* 821ED81Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821ED81Ch case    7:*/		return 0x821ED820;
		  /* 821ED820h */ case    8:  		/* li R6, 117 */
		/* 821ED820h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821ED820h case    8:*/		return 0x821ED824;
		  /* 821ED824h */ case    9:  		/* mr R28, R3 */
		/* 821ED824h case    9:*/		regs.R28 = regs.R3;
		/* 821ED824h case    9:*/		return 0x821ED828;
		  /* 821ED828h */ case   10:  		/* mr R30, R4 */
		/* 821ED828h case   10:*/		regs.R30 = regs.R4;
		/* 821ED828h case   10:*/		return 0x821ED82C;
		  /* 821ED82Ch */ case   11:  		/* bl 225644 */
		/* 821ED82Ch case   11:*/		regs.LR = 0x821ED830; return 0x82224998;
		/* 821ED82Ch case   11:*/		return 0x821ED830;
		  /* 821ED830h */ case   12:  		/* mr R31, R3 */
		/* 821ED830h case   12:*/		regs.R31 = regs.R3;
		/* 821ED830h case   12:*/		return 0x821ED834;
		  /* 821ED834h */ case   13:  		/* mr R3, R28 */
		/* 821ED834h case   13:*/		regs.R3 = regs.R28;
		/* 821ED834h case   13:*/		return 0x821ED838;
		  /* 821ED838h */ case   14:  		/* li R8, 0 */
		/* 821ED838h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821ED838h case   14:*/		return 0x821ED83C;
		  /* 821ED83Ch */ case   15:  		/* li R7, 0 */
		/* 821ED83Ch case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821ED83Ch case   15:*/		return 0x821ED840;
		  /* 821ED840h */ case   16:  		/* li R6, 117 */
		/* 821ED840h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821ED840h case   16:*/		return 0x821ED844;
		  /* 821ED844h */ case   17:  		/* mr R5, R29 */
		/* 821ED844h case   17:*/		regs.R5 = regs.R29;
		/* 821ED844h case   17:*/		return 0x821ED848;
		  /* 821ED848h */ case   18:  		/* mr R4, R30 */
		/* 821ED848h case   18:*/		regs.R4 = regs.R30;
		/* 821ED848h case   18:*/		return 0x821ED84C;
		  /* 821ED84Ch */ case   19:  		/* bl 225612 */
		/* 821ED84Ch case   19:*/		regs.LR = 0x821ED850; return 0x82224998;
		/* 821ED84Ch case   19:*/		return 0x821ED850;
	}
	return 0x821ED850;
} // Block from 821ED800h-821ED850h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821ED850h
// Function '?GetFloatConstant@Compiler@D3DXShader@@AAA_NPAVResult@2@PAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED850);
		  /* 821ED850h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821ED850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED850h case    0:*/		return 0x821ED854;
		  /* 821ED854h */ case    1:  		/* mr R5, R28 */
		/* 821ED854h case    1:*/		regs.R5 = regs.R28;
		/* 821ED854h case    1:*/		return 0x821ED858;
		  /* 821ED858h */ case    2:  		/* oris R11, R11, 512 */
		/* 821ED858h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821ED858h case    2:*/		return 0x821ED85C;
		  /* 821ED85Ch */ case    3:  		/* mr R4, R31 */
		/* 821ED85Ch case    3:*/		regs.R4 = regs.R31;
		/* 821ED85Ch case    3:*/		return 0x821ED860;
		  /* 821ED860h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 821ED860h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821ED860h case    4:*/		return 0x821ED864;
		  /* 821ED864h */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 821ED864h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821ED864h case    5:*/		return 0x821ED868;
		  /* 821ED868h */ case    6:  		/* oris R11, R11, 512 */
		/* 821ED868h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821ED868h case    6:*/		return 0x821ED86C;
		  /* 821ED86Ch */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 821ED86Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821ED86Ch case    7:*/		return 0x821ED870;
		  /* 821ED870h */ case    8:  		/* bl -480840 */
		/* 821ED870h case    8:*/		regs.LR = 0x821ED874; return 0x82178228;
		/* 821ED870h case    8:*/		return 0x821ED874;
		  /* 821ED874h */ case    9:  		/* li R6, 0 */
		/* 821ED874h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821ED874h case    9:*/		return 0x821ED878;
		  /* 821ED878h */ case   10:  		/* li R5, 0 */
		/* 821ED878h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821ED878h case   10:*/		return 0x821ED87C;
		  /* 821ED87Ch */ case   11:  		/* li R4, 117 */
		/* 821ED87Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821ED87Ch case   11:*/		return 0x821ED880;
		  /* 821ED880h */ case   12:  		/* mr R3, R28 */
		/* 821ED880h case   12:*/		regs.R3 = regs.R28;
		/* 821ED880h case   12:*/		return 0x821ED884;
		  /* 821ED884h */ case   13:  		/* bl -562260 */
		/* 821ED884h case   13:*/		regs.LR = 0x821ED888; return 0x82164430;
		/* 821ED884h case   13:*/		return 0x821ED888;
		  /* 821ED888h */ case   14:  		/* addi R11, R31, -16 */
		/* 821ED888h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821ED888h case   14:*/		return 0x821ED88C;
		  /* 821ED88Ch */ case   15:  		/* li R10, 1 */
		/* 821ED88Ch case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED88Ch case   15:*/		return 0x821ED890;
		  /* 821ED890h */ case   16:  		/* add R11, R3, R11 */
		/* 821ED890h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821ED890h case   16:*/		return 0x821ED894;
		  /* 821ED894h */ case   17:  		/* lwz R9, <#[R11]> */
		/* 821ED894h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821ED894h case   17:*/		return 0x821ED898;
		  /* 821ED898h */ case   18:  		/* stw R27, <#[R11 + 4]> */
		/* 821ED898h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 821ED898h case   18:*/		return 0x821ED89C;
		  /* 821ED89Ch */ case   19:  		/* rlwimi R9, R10, 0, 29, 31 */
		/* 821ED89Ch case   19:*/		cpu::op::rlwimi<0,0,29,31>(regs,&regs.R9,regs.R10);
		/* 821ED89Ch case   19:*/		return 0x821ED8A0;
		  /* 821ED8A0h */ case   20:  		/* stw R9, <#[R11]> */
		/* 821ED8A0h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821ED8A0h case   20:*/		return 0x821ED8A4;
		  /* 821ED8A4h */ case   21:  		/* addi R1, R1, 128 */
		/* 821ED8A4h case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821ED8A4h case   21:*/		return 0x821ED8A8;
		  /* 821ED8A8h */ case   22:  		/* b -1426948 */
		/* 821ED8A8h case   22:*/		return 0x820912A4;
		/* 821ED8A8h case   22:*/		return 0x821ED8AC;
		  /* 821ED8ACh */ case   23:  		/* nop */
		/* 821ED8ACh case   23:*/		cpu::op::nop();
		/* 821ED8ACh case   23:*/		return 0x821ED8B0;
	}
	return 0x821ED8B0;
} // Block from 821ED850h-821ED8B0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821ED8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED8B0);
		  /* 821ED8B0h */ case    0:  		/* mfspr R12, LR */
		/* 821ED8B0h case    0:*/		regs.R12 = regs.LR;
		/* 821ED8B0h case    0:*/		return 0x821ED8B4;
		  /* 821ED8B4h */ case    1:  		/* bl -1427040 */
		/* 821ED8B4h case    1:*/		regs.LR = 0x821ED8B8; return 0x82091254;
		/* 821ED8B4h case    1:*/		return 0x821ED8B8;
		  /* 821ED8B8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821ED8B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821ED8B8h case    2:*/		return 0x821ED8BC;
		  /* 821ED8BCh */ case    3:  		/* lwz R11, <#[R3 + 744]> */
		/* 821ED8BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002E8) );
		/* 821ED8BCh case    3:*/		return 0x821ED8C0;
		  /* 821ED8C0h */ case    4:  		/* mr R31, R3 */
		/* 821ED8C0h case    4:*/		regs.R31 = regs.R3;
		/* 821ED8C0h case    4:*/		return 0x821ED8C4;
		  /* 821ED8C4h */ case    5:  		/* mr R29, R4 */
		/* 821ED8C4h case    5:*/		regs.R29 = regs.R4;
		/* 821ED8C4h case    5:*/		return 0x821ED8C8;
		  /* 821ED8C8h */ case    6:  		/* mr R28, R5 */
		/* 821ED8C8h case    6:*/		regs.R28 = regs.R5;
		/* 821ED8C8h case    6:*/		return 0x821ED8CC;
		  /* 821ED8CCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821ED8CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821ED8CCh case    7:*/		return 0x821ED8D0;
		  /* 821ED8D0h */ case    8:  		/* bc 12, CR6_EQ, 164 */
		/* 821ED8D0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821ED974;  }
		/* 821ED8D0h case    8:*/		return 0x821ED8D4;
		  /* 821ED8D4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821ED8D4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821ED8D4h case    9:*/		return 0x821ED8D8;
		  /* 821ED8D8h */ case   10:  		/* li R8, 0 */
		/* 821ED8D8h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821ED8D8h case   10:*/		return 0x821ED8DC;
		  /* 821ED8DCh */ case   11:  		/* li R7, 0 */
		/* 821ED8DCh case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821ED8DCh case   11:*/		return 0x821ED8E0;
		  /* 821ED8E0h */ case   12:  		/* addi R5, R4, 24 */
		/* 821ED8E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821ED8E0h case   12:*/		return 0x821ED8E4;
		  /* 821ED8E4h */ case   13:  		/* li R6, 117 */
		/* 821ED8E4h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821ED8E4h case   13:*/		return 0x821ED8E8;
		  /* 821ED8E8h */ case   14:  		/* bl 225456 */
		/* 821ED8E8h case   14:*/		regs.LR = 0x821ED8EC; return 0x82224998;
		/* 821ED8E8h case   14:*/		return 0x821ED8EC;
		  /* 821ED8ECh */ case   15:  		/* lwz R4, <#[R31 + 564]> */
		/* 821ED8ECh case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821ED8ECh case   15:*/		return 0x821ED8F0;
		  /* 821ED8F0h */ case   16:  		/* mr R30, R3 */
		/* 821ED8F0h case   16:*/		regs.R30 = regs.R3;
		/* 821ED8F0h case   16:*/		return 0x821ED8F4;
		  /* 821ED8F4h */ case   17:  		/* addi R5, R4, 24 */
		/* 821ED8F4h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821ED8F4h case   17:*/		return 0x821ED8F8;
		  /* 821ED8F8h */ case   18:  		/* li R8, 0 */
		/* 821ED8F8h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821ED8F8h case   18:*/		return 0x821ED8FC;
		  /* 821ED8FCh */ case   19:  		/* li R7, 0 */
		/* 821ED8FCh case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821ED8FCh case   19:*/		return 0x821ED900;
	}
	return 0x821ED900;
} // Block from 821ED8B0h-821ED900h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821ED900h
// Function '?InitJump@Instruction@D3DXShader@@QAAX_NPAVBlock@2@0PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED900);
		  /* 821ED900h */ case    0:  		/* li R6, 117 */
		/* 821ED900h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821ED900h case    0:*/		return 0x821ED904;
		  /* 821ED904h */ case    1:  		/* mr R3, R31 */
		/* 821ED904h case    1:*/		regs.R3 = regs.R31;
		/* 821ED904h case    1:*/		return 0x821ED908;
		  /* 821ED908h */ case    2:  		/* bl 225424 */
		/* 821ED908h case    2:*/		regs.LR = 0x821ED90C; return 0x82224998;
		/* 821ED908h case    2:*/		return 0x821ED90C;
		  /* 821ED90Ch */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 821ED90Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821ED90Ch case    3:*/		return 0x821ED910;
		  /* 821ED910h */ case    4:  		/* mr R5, R31 */
		/* 821ED910h case    4:*/		regs.R5 = regs.R31;
		/* 821ED910h case    4:*/		return 0x821ED914;
		  /* 821ED914h */ case    5:  		/* oris R11, R11, 512 */
		/* 821ED914h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821ED914h case    5:*/		return 0x821ED918;
		  /* 821ED918h */ case    6:  		/* mr R4, R30 */
		/* 821ED918h case    6:*/		regs.R4 = regs.R30;
		/* 821ED918h case    6:*/		return 0x821ED91C;
		  /* 821ED91Ch */ case    7:  		/* stw R11, <#[R30 + 8]> */
		/* 821ED91Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821ED91Ch case    7:*/		return 0x821ED920;
		  /* 821ED920h */ case    8:  		/* mr R27, R3 */
		/* 821ED920h case    8:*/		regs.R27 = regs.R3;
		/* 821ED920h case    8:*/		return 0x821ED924;
		  /* 821ED924h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 821ED924h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821ED924h case    9:*/		return 0x821ED928;
		  /* 821ED928h */ case   10:  		/* oris R11, R11, 512 */
		/* 821ED928h case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821ED928h case   10:*/		return 0x821ED92C;
		  /* 821ED92Ch */ case   11:  		/* stw R11, <#[R3 + 8]> */
		/* 821ED92Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821ED92Ch case   11:*/		return 0x821ED930;
		  /* 821ED930h */ case   12:  		/* bl -481032 */
		/* 821ED930h case   12:*/		regs.LR = 0x821ED934; return 0x82178228;
		/* 821ED930h case   12:*/		return 0x821ED934;
		  /* 821ED934h */ case   13:  		/* mr R5, R31 */
		/* 821ED934h case   13:*/		regs.R5 = regs.R31;
		/* 821ED934h case   13:*/		return 0x821ED938;
		  /* 821ED938h */ case   14:  		/* mr R4, R27 */
		/* 821ED938h case   14:*/		regs.R4 = regs.R27;
		/* 821ED938h case   14:*/		return 0x821ED93C;
		  /* 821ED93Ch */ case   15:  		/* mr R3, R29 */
		/* 821ED93Ch case   15:*/		regs.R3 = regs.R29;
		/* 821ED93Ch case   15:*/		return 0x821ED940;
		  /* 821ED940h */ case   16:  		/* bl -481048 */
		/* 821ED940h case   16:*/		regs.LR = 0x821ED944; return 0x82178228;
		/* 821ED940h case   16:*/		return 0x821ED944;
		  /* 821ED944h */ case   17:  		/* li R6, 0 */
		/* 821ED944h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821ED944h case   17:*/		return 0x821ED948;
		  /* 821ED948h */ case   18:  		/* li R5, 0 */
		/* 821ED948h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821ED948h case   18:*/		return 0x821ED94C;
		  /* 821ED94Ch */ case   19:  		/* li R4, 117 */
		/* 821ED94Ch case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821ED94Ch case   19:*/		return 0x821ED950;
		  /* 821ED950h */ case   20:  		/* mr R3, R31 */
		/* 821ED950h case   20:*/		regs.R3 = regs.R31;
		/* 821ED950h case   20:*/		return 0x821ED954;
		  /* 821ED954h */ case   21:  		/* bl -562468 */
		/* 821ED954h case   21:*/		regs.LR = 0x821ED958; return 0x82164430;
		/* 821ED954h case   21:*/		return 0x821ED958;
		  /* 821ED958h */ case   22:  		/* addi R11, R30, -16 */
		/* 821ED958h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF0);
		/* 821ED958h case   22:*/		return 0x821ED95C;
		  /* 821ED95Ch */ case   23:  		/* li R10, 1 */
		/* 821ED95Ch case   23:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821ED95Ch case   23:*/		return 0x821ED960;
		  /* 821ED960h */ case   24:  		/* add R11, R3, R11 */
		/* 821ED960h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821ED960h case   24:*/		return 0x821ED964;
		  /* 821ED964h */ case   25:  		/* lwz R9, <#[R11]> */
		/* 821ED964h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821ED964h case   25:*/		return 0x821ED968;
	}
	return 0x821ED968;
} // Block from 821ED900h-821ED968h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821ED968h
// Function '?CreateTokenIdNode@Compiler@D3DXShader@@AAAPAVCNodeToken@2@PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED968);
		  /* 821ED968h */ case    0:  		/* stw R28, <#[R11 + 4]> */
		/* 821ED968h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 821ED968h case    0:*/		return 0x821ED96C;
		  /* 821ED96Ch */ case    1:  		/* rlwimi R9, R10, 1, 29, 31 */
		/* 821ED96Ch case    1:*/		cpu::op::rlwimi<0,1,29,31>(regs,&regs.R9,regs.R10);
		/* 821ED96Ch case    1:*/		return 0x821ED970;
		  /* 821ED970h */ case    2:  		/* stw R9, <#[R11]> */
		/* 821ED970h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821ED970h case    2:*/		return 0x821ED974;
	}
	return 0x821ED974;
} // Block from 821ED968h-821ED974h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED974);
		  /* 821ED974h */ case    0:  		/* addi R1, R1, 128 */
		/* 821ED974h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821ED974h case    0:*/		return 0x821ED978;
		  /* 821ED978h */ case    1:  		/* b -1427156 */
		/* 821ED978h case    1:*/		return 0x820912A4;
		/* 821ED978h case    1:*/		return 0x821ED97C;
		  /* 821ED97Ch */ case    2:  		/* nop */
		/* 821ED97Ch case    2:*/		cpu::op::nop();
		/* 821ED97Ch case    2:*/		return 0x821ED980;
	}
	return 0x821ED980;
} // Block from 821ED974h-821ED980h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821ED980h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED980);
		  /* 821ED980h */ case    0:  		/* mfspr R12, LR */
		/* 821ED980h case    0:*/		regs.R12 = regs.LR;
		/* 821ED980h case    0:*/		return 0x821ED984;
		  /* 821ED984h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821ED984h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821ED984h case    1:*/		return 0x821ED988;
		  /* 821ED988h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821ED988h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821ED988h case    2:*/		return 0x821ED98C;
		  /* 821ED98Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821ED98Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821ED98Ch case    3:*/		return 0x821ED990;
		  /* 821ED990h */ case    4:  		/* lwz R11, <#[R4]> */
		/* 821ED990h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821ED990h case    4:*/		return 0x821ED994;
		  /* 821ED994h */ case    5:  		/* lis R10, 512 */
		/* 821ED994h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 821ED994h case    5:*/		return 0x821ED998;
		  /* 821ED998h */ case    6:  		/* mr R31, R5 */
		/* 821ED998h case    6:*/		regs.R31 = regs.R5;
		/* 821ED998h case    6:*/		return 0x821ED99C;
		  /* 821ED99Ch */ case    7:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821ED99Ch case    7:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821ED99Ch case    7:*/		return 0x821ED9A0;
		  /* 821ED9A0h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 821ED9A0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821ED9A0h case    8:*/		return 0x821ED9A4;
		  /* 821ED9A4h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 821ED9A4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821ED9B0;  }
		/* 821ED9A4h case    9:*/		return 0x821ED9A8;
		  /* 821ED9A8h */ case   10:  		/* cmpwi CR6, R5, 0 */
		/* 821ED9A8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 821ED9A8h case   10:*/		return 0x821ED9AC;
		  /* 821ED9ACh */ case   11:  		/* bc 12, CR6_EQ, 108 */
		/* 821ED9ACh case   11:*/		if ( regs.CR[6].eq ) { return 0x821EDA18;  }
		/* 821ED9ACh case   11:*/		return 0x821ED9B0;
	}
	return 0x821ED9B0;
} // Block from 821ED980h-821ED9B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821ED9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED9B0);
		  /* 821ED9B0h */ case    0:  		/* lwz R5, <#[R4 + 12]> */
		/* 821ED9B0h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 821ED9B0h case    0:*/		return 0x821ED9B4;
		  /* 821ED9B4h */ case    1:  		/* bl -510148 */
		/* 821ED9B4h case    1:*/		regs.LR = 0x821ED9B8; return 0x821710F0;
		/* 821ED9B4h case    1:*/		return 0x821ED9B8;
		  /* 821ED9B8h */ case    2:  		/* lwz R7, <#[R3]> */
		/* 821ED9B8h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 821ED9B8h case    2:*/		return 0x821ED9BC;
		  /* 821ED9BCh */ case    3:  		/* ori R11, R31, 228 */
		/* 821ED9BCh case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R31,0xE4);
		/* 821ED9BCh case    3:*/		return 0x821ED9C0;
		  /* 821ED9C0h */ case    4:  		/* lis R10, 1 */
		/* 821ED9C0h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 821ED9C0h case    4:*/		return 0x821ED9C4;
		  /* 821ED9C4h */ case    5:  		/* mr R5, R7 */
		/* 821ED9C4h case    5:*/		regs.R5 = regs.R7;
		/* 821ED9C4h case    5:*/		return 0x821ED9C8;
		  /* 821ED9C8h */ case    6:  		/* rlwinm R9, R11, 27, 29, 30 */
		/* 821ED9C8h case    6:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R11);
		/* 821ED9C8h case    6:*/		return 0x821ED9CC;
		  /* 821ED9CCh */ case    7:  		/* rlwinm R7, R7, 27, 24, 31 */
		/* 821ED9CCh case    7:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R7);
		/* 821ED9CCh case    7:*/		return 0x821ED9D0;
		  /* 821ED9D0h */ case    8:  		/* rlwinm R8, R11, 29, 29, 30 */
		/* 821ED9D0h case    8:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R8,regs.R11);
		/* 821ED9D0h case    8:*/		return 0x821ED9D4;
		  /* 821ED9D4h */ case    9:  		/* srw R9, R7, R9 */
		/* 821ED9D4h case    9:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 821ED9D4h case    9:*/		return 0x821ED9D8;
		  /* 821ED9D8h */ case   10:  		/* srw R8, R7, R8 */
		/* 821ED9D8h case   10:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821ED9D8h case   10:*/		return 0x821ED9DC;
		  /* 821ED9DCh */ case   11:  		/* rlwimi R10, R9, 2, 28, 29 */
		/* 821ED9DCh case   11:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R10,regs.R9);
		/* 821ED9DCh case   11:*/		return 0x821ED9E0;
	}
	return 0x821ED9E0;
} // Block from 821ED9B0h-821ED9E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821ED9E0h
// Function '?CreateDeclNode@Compiler@D3DXShader@@AAAPAVCNodeDecl@2@W4_D3DDECL_TYPE@2@PBDPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821ED9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821ED9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821ED9E0);
		  /* 821ED9E0h */ case    0:  		/* rlwinm R6, R11, 31, 29, 30 */
		/* 821ED9E0h case    0:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R6,regs.R11);
		/* 821ED9E0h case    0:*/		return 0x821ED9E4;
		  /* 821ED9E4h */ case    1:  		/* rlwinm R9, R8, 0, 30, 31 */
		/* 821ED9E4h case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R8);
		/* 821ED9E4h case    1:*/		return 0x821ED9E8;
		  /* 821ED9E8h */ case    2:  		/* rlwinm R11, R11, 1, 29, 30 */
		/* 821ED9E8h case    2:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R11,regs.R11);
		/* 821ED9E8h case    2:*/		return 0x821ED9EC;
		  /* 821ED9ECh */ case    3:  		/* srw R8, R7, R6 */
		/* 821ED9ECh case    3:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R7,regs.R6);
		/* 821ED9ECh case    3:*/		return 0x821ED9F0;
		  /* 821ED9F0h */ case    4:  		/* or R10, R10, R9 */
		/* 821ED9F0h case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821ED9F0h case    4:*/		return 0x821ED9F4;
		  /* 821ED9F4h */ case    5:  		/* srw R11, R7, R11 */
		/* 821ED9F4h case    5:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 821ED9F4h case    5:*/		return 0x821ED9F8;
		  /* 821ED9F8h */ case    6:  		/* rlwimi R8, R10, 2, 0, 29 */
		/* 821ED9F8h case    6:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R10);
		/* 821ED9F8h case    6:*/		return 0x821ED9FC;
		  /* 821ED9FCh */ case    7:  		/* rlwinm R5, R5, 0, 27, 18 */
		/* 821ED9FCh case    7:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R5,regs.R5);
		/* 821ED9FCh case    7:*/		return 0x821EDA00;
		  /* 821EDA00h */ case    8:  		/* rlwimi R11, R8, 2, 0, 29 */
		/* 821EDA00h case    8:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 821EDA00h case    8:*/		return 0x821EDA04;
		  /* 821EDA04h */ case    9:  		/* rlwinm R5, R5, 0, 6, 3 */
		/* 821EDA04h case    9:*/		cpu::op::rlwinm<0,0,6,3>(regs,&regs.R5,regs.R5);
		/* 821EDA04h case    9:*/		return 0x821EDA08;
		  /* 821EDA08h */ case   10:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821EDA08h case   10:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821EDA08h case   10:*/		return 0x821EDA0C;
		  /* 821EDA0Ch */ case   11:  		/* mr R4, R3 */
		/* 821EDA0Ch case   11:*/		regs.R4 = regs.R3;
		/* 821EDA0Ch case   11:*/		return 0x821EDA10;
		  /* 821EDA10h */ case   12:  		/* or R11, R11, R5 */
		/* 821EDA10h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 821EDA10h case   12:*/		return 0x821EDA14;
		  /* 821EDA14h */ case   13:  		/* stw R11, <#[R3]> */
		/* 821EDA14h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821EDA14h case   13:*/		return 0x821EDA18;
	}
	return 0x821EDA18;
} // Block from 821ED9E0h-821EDA18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EDA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDA18);
		  /* 821EDA18h */ case    0:  		/* mr R3, R4 */
		/* 821EDA18h case    0:*/		regs.R3 = regs.R4;
		/* 821EDA18h case    0:*/		return 0x821EDA1C;
		  /* 821EDA1Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 821EDA1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821EDA1Ch case    1:*/		return 0x821EDA20;
		  /* 821EDA20h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EDA20h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDA20h case    2:*/		return 0x821EDA24;
		  /* 821EDA24h */ case    3:  		/* mtspr LR, R12 */
		/* 821EDA24h case    3:*/		regs.LR = regs.R12;
		/* 821EDA24h case    3:*/		return 0x821EDA28;
		  /* 821EDA28h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821EDA28h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EDA28h case    4:*/		return 0x821EDA2C;
		  /* 821EDA2Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 821EDA2Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EDA2Ch case    5:*/		return 0x821EDA30;
	}
	return 0x821EDA30;
} // Block from 821EDA18h-821EDA30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EDA30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDA30);
		  /* 821EDA30h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821EDA30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821EDA30h case    0:*/		return 0x821EDA34;
		  /* 821EDA34h */ case    1:  		/* lwz R10, <#[R3 + 4]> */
		/* 821EDA34h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821EDA34h case    1:*/		return 0x821EDA38;
		  /* 821EDA38h */ case    2:  		/* addi R11, R11, 972 */
		/* 821EDA38h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3CC);
		/* 821EDA38h case    2:*/		return 0x821EDA3C;
		  /* 821EDA3Ch */ case    3:  		/* lwz R9, <#[R11 + 4]> */
		/* 821EDA3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821EDA3Ch case    3:*/		return 0x821EDA40;
		  /* 821EDA40h */ case    4:  		/* stw R9, <#[R10]> */
		/* 821EDA40h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EDA40h case    4:*/		return 0x821EDA44;
		  /* 821EDA44h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 821EDA44h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821EDA44h case    5:*/		return 0x821EDA48;
	}
	return 0x821EDA48;
} // Block from 821EDA30h-821EDA48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EDA48h
// Function '?CreateListNode@Compiler@D3DXShader@@AAAPAVCNodeList@2@PAVCNode@2@0PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDA48);
		  /* 821EDA48h */ case    0:  		/* bclr 20, CR0_LT */
		/* 821EDA48h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EDA48h case    0:*/		return 0x821EDA4C;
	}
	return 0x821EDA4C;
} // Block from 821EDA48h-821EDA4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EDA4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDA4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDA4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDA4C);
		  /* 821EDA4Ch */ case    0:  		/* nop */
		/* 821EDA4Ch case    0:*/		cpu::op::nop();
		/* 821EDA4Ch case    0:*/		return 0x821EDA50;
	}
	return 0x821EDA50;
} // Block from 821EDA4Ch-821EDA50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EDA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDA50);
		  /* 821EDA50h */ case    0:  		/* mfspr R12, LR */
		/* 821EDA50h case    0:*/		regs.R12 = regs.LR;
		/* 821EDA50h case    0:*/		return 0x821EDA54;
		  /* 821EDA54h */ case    1:  		/* bl -1427448 */
		/* 821EDA54h case    1:*/		regs.LR = 0x821EDA58; return 0x8209125C;
		/* 821EDA54h case    1:*/		return 0x821EDA58;
		  /* 821EDA58h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EDA58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EDA58h case    2:*/		return 0x821EDA5C;
		  /* 821EDA5Ch */ case    3:  		/* li R8, 0 */
		/* 821EDA5Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821EDA5Ch case    3:*/		return 0x821EDA60;
		  /* 821EDA60h */ case    4:  		/* li R7, 0 */
		/* 821EDA60h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821EDA60h case    4:*/		return 0x821EDA64;
		  /* 821EDA64h */ case    5:  		/* li R6, 88 */
		/* 821EDA64h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x58);
		/* 821EDA64h case    5:*/		return 0x821EDA68;
		  /* 821EDA68h */ case    6:  		/* addi R5, R4, 32 */
		/* 821EDA68h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x20);
		/* 821EDA68h case    6:*/		return 0x821EDA6C;
		  /* 821EDA6Ch */ case    7:  		/* mr R30, R3 */
		/* 821EDA6Ch case    7:*/		regs.R30 = regs.R3;
		/* 821EDA6Ch case    7:*/		return 0x821EDA70;
		  /* 821EDA70h */ case    8:  		/* mr R31, R4 */
		/* 821EDA70h case    8:*/		regs.R31 = regs.R4;
		/* 821EDA70h case    8:*/		return 0x821EDA74;
		  /* 821EDA74h */ case    9:  		/* bl 225060 */
		/* 821EDA74h case    9:*/		regs.LR = 0x821EDA78; return 0x82224998;
		/* 821EDA74h case    9:*/		return 0x821EDA78;
		  /* 821EDA78h */ case   10:  		/* lwz R11, <#[R31 + 48]> */
		/* 821EDA78h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821EDA78h case   10:*/		return 0x821EDA7C;
		  /* 821EDA7Ch */ case   11:  		/* mr R29, R3 */
		/* 821EDA7Ch case   11:*/		regs.R29 = regs.R3;
		/* 821EDA7Ch case   11:*/		return 0x821EDA80;
		  /* 821EDA80h */ case   12:  		/* oris R11, R11, 16 */
		/* 821EDA80h case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 821EDA80h case   12:*/		return 0x821EDA84;
		  /* 821EDA84h */ case   13:  		/* stw R11, <#[R31 + 48]> */
		/* 821EDA84h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821EDA84h case   13:*/		return 0x821EDA88;
		  /* 821EDA88h */ case   14:  		/* lwz R11, <#[R30 + 24]> */
		/* 821EDA88h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 821EDA88h case   14:*/		return 0x821EDA8C;
		  /* 821EDA8Ch */ case   15:  		/* lwz R10, <#[R11 + 16]> */
		/* 821EDA8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821EDA8Ch case   15:*/		return 0x821EDA90;
		  /* 821EDA90h */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 821EDA90h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821EDA90h case   16:*/		return 0x821EDA94;
		  /* 821EDA94h */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 821EDA94h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821EDAA0;  }
		/* 821EDA94h case   17:*/		return 0x821EDA98;
		  /* 821EDA98h */ case   18:  		/* stw R31, <#[R11 + 16]> */
		/* 821EDA98h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000010) );
		/* 821EDA98h case   18:*/		return 0x821EDA9C;
		  /* 821EDA9Ch */ case   19:  		/* b 44 */
		/* 821EDA9Ch case   19:*/		return 0x821EDAC8;
		/* 821EDA9Ch case   19:*/		return 0x821EDAA0;
	}
	return 0x821EDAA0;
} // Block from 821EDA50h-821EDAA0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EDAA0h
// Function '?CreateValueListNode@Compiler@D3DXShader@@AAAPAVCNodeList@2@PAMK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDAA0);
		  /* 821EDAA0h */ case    0:  		/* li R5, 56 */
		/* 821EDAA0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x38);
		/* 821EDAA0h case    0:*/		return 0x821EDAA4;
		  /* 821EDAA4h */ case    1:  		/* li R4, 8 */
		/* 821EDAA4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 821EDAA4h case    1:*/		return 0x821EDAA8;
		  /* 821EDAA8h */ case    2:  		/* mr R3, R30 */
		/* 821EDAA8h case    2:*/		regs.R3 = regs.R30;
		/* 821EDAA8h case    2:*/		return 0x821EDAAC;
		  /* 821EDAACh */ case    3:  		/* bl -528132 */
		/* 821EDAACh case    3:*/		regs.LR = 0x821EDAB0; return 0x8216CBA8;
		/* 821EDAACh case    3:*/		return 0x821EDAB0;
		  /* 821EDAB0h */ case    4:  		/* stw R31, <#[R3]> */
		/* 821EDAB0h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 821EDAB0h case    4:*/		return 0x821EDAB4;
		  /* 821EDAB4h */ case    5:  		/* lwz R11, <#[R30 + 24]> */
		/* 821EDAB4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 821EDAB4h case    5:*/		return 0x821EDAB8;
		  /* 821EDAB8h */ case    6:  		/* lwz R11, <#[R11 + 20]> */
		/* 821EDAB8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821EDAB8h case    6:*/		return 0x821EDABC;
		  /* 821EDABCh */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 821EDABCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821EDABCh case    7:*/		return 0x821EDAC0;
		  /* 821EDAC0h */ case    8:  		/* lwz R11, <#[R30 + 24]> */
		/* 821EDAC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 821EDAC0h case    8:*/		return 0x821EDAC4;
		  /* 821EDAC4h */ case    9:  		/* stw R3, <#[R11 + 20]> */
		/* 821EDAC4h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000014) );
		/* 821EDAC4h case    9:*/		return 0x821EDAC8;
	}
	return 0x821EDAC8;
} // Block from 821EDAA0h-821EDAC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EDAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDAC8);
		  /* 821EDAC8h */ case    0:  		/* mr R4, R29 */
		/* 821EDAC8h case    0:*/		regs.R4 = regs.R29;
		/* 821EDAC8h case    0:*/		return 0x821EDACC;
		  /* 821EDACCh */ case    1:  		/* lwz R5, <#[R30 + 24]> */
		/* 821EDACCh case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000018) );
		/* 821EDACCh case    1:*/		return 0x821EDAD0;
		  /* 821EDAD0h */ case    2:  		/* mr R3, R30 */
		/* 821EDAD0h case    2:*/		regs.R3 = regs.R30;
		/* 821EDAD0h case    2:*/		return 0x821EDAD4;
		  /* 821EDAD4h */ case    3:  		/* bl -548 */
		/* 821EDAD4h case    3:*/		regs.LR = 0x821EDAD8; return 0x821ED8B0;
		/* 821EDAD4h case    3:*/		return 0x821EDAD8;
		  /* 821EDAD8h */ case    4:  		/* mr R3, R29 */
		/* 821EDAD8h case    4:*/		regs.R3 = regs.R29;
		/* 821EDAD8h case    4:*/		return 0x821EDADC;
		  /* 821EDADCh */ case    5:  		/* addi R1, R1, 112 */
		/* 821EDADCh case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EDADCh case    5:*/		return 0x821EDAE0;
		  /* 821EDAE0h */ case    6:  		/* b -1427508 */
		/* 821EDAE0h case    6:*/		return 0x820912AC;
		/* 821EDAE0h case    6:*/		return 0x821EDAE4;
		  /* 821EDAE4h */ case    7:  		/* nop */
		/* 821EDAE4h case    7:*/		cpu::op::nop();
		/* 821EDAE4h case    7:*/		return 0x821EDAE8;
	}
	return 0x821EDAE8;
} // Block from 821EDAC8h-821EDAE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EDAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDAE8);
		  /* 821EDAE8h */ case    0:  		/* mfspr R12, LR */
		/* 821EDAE8h case    0:*/		regs.R12 = regs.LR;
		/* 821EDAE8h case    0:*/		return 0x821EDAEC;
		  /* 821EDAECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EDAECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDAECh case    1:*/		return 0x821EDAF0;
		  /* 821EDAF0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821EDAF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821EDAF0h case    2:*/		return 0x821EDAF4;
		  /* 821EDAF4h */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EDAF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EDAF4h case    3:*/		return 0x821EDAF8;
		  /* 821EDAF8h */ case    4:  		/* rlwinm R10, R11, 0, 30, 31 */
		/* 821EDAF8h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R11);
		/* 821EDAF8h case    4:*/		return 0x821EDAFC;
		  /* 821EDAFCh */ case    5:  		/* cmplwi CR6, R10, 1 */
		/* 821EDAFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821EDAFCh case    5:*/		return 0x821EDB00;
		  /* 821EDB00h */ case    6:  		/* bc 12, CR6_LT, 56 */
		/* 821EDB00h case    6:*/		if ( regs.CR[6].lt ) { return 0x821EDB38;  }
		/* 821EDB00h case    6:*/		return 0x821EDB04;
		  /* 821EDB04h */ case    7:  		/* bc 12, CR6_EQ, 160 */
		/* 821EDB04h case    7:*/		if ( regs.CR[6].eq ) { return 0x821EDBA4;  }
		/* 821EDB04h case    7:*/		return 0x821EDB08;
		  /* 821EDB08h */ case    8:  		/* cmplwi CR6, R10, 3 */
		/* 821EDB08h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 821EDB08h case    8:*/		return 0x821EDB0C;
		  /* 821EDB0Ch */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 821EDB0Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x821EDB1C;  }
		/* 821EDB0Ch case    9:*/		return 0x821EDB10;
		  /* 821EDB10h */ case   10:  		/* bc 12, CR6_EQ, 112 */
		/* 821EDB10h case   10:*/		if ( regs.CR[6].eq ) { return 0x821EDB80;  }
		/* 821EDB10h case   10:*/		return 0x821EDB14;
		  /* 821EDB14h */ case   11:  		/* li R4, 4800 */
		/* 821EDB14h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821EDB14h case   11:*/		return 0x821EDB18;
		  /* 821EDB18h */ case   12:  		/* bl -638128 */
		/* 821EDB18h case   12:*/		regs.LR = 0x821EDB1C; return 0x82151E68;
		/* 821EDB18h case   12:*/		return 0x821EDB1C;
	}
	return 0x821EDB1C;
} // Block from 821EDAE8h-821EDB1Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821EDB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDB1C);
		  /* 821EDB1Ch */ case    0:  		/* lwz R10, <#[R4]> */
		/* 821EDB1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821EDB1Ch case    0:*/		return 0x821EDB20;
		  /* 821EDB20h */ case    1:  		/* rlwinm R11, R11, 31, 17, 30 */
		/* 821EDB20h case    1:*/		cpu::op::rlwinm<0,31,17,30>(regs,&regs.R11,regs.R11);
		/* 821EDB20h case    1:*/		return 0x821EDB24;
		  /* 821EDB24h */ case    2:  		/* lwz R10, <#[R10]> */
		/* 821EDB24h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EDB24h case    2:*/		return 0x821EDB28;
		  /* 821EDB28h */ case    3:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 821EDB28h case    3:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 821EDB28h case    3:*/		return 0x821EDB2C;
		  /* 821EDB2Ch */ case    4:  		/* srw R11, R10, R11 */
		/* 821EDB2Ch case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EDB2Ch case    4:*/		return 0x821EDB30;
		  /* 821EDB30h */ case    5:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 821EDB30h case    5:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 821EDB30h case    5:*/		return 0x821EDB34;
		  /* 821EDB34h */ case    6:  		/* b 116 */
		/* 821EDB34h case    6:*/		return 0x821EDBA8;
		/* 821EDB34h case    6:*/		return 0x821EDB38;
	}
	return 0x821EDB38;
} // Block from 821EDB1Ch-821EDB38h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EDB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDB38);
		  /* 821EDB38h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 821EDB38h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821EDB38h case    0:*/		return 0x821EDB3C;
		  /* 821EDB3Ch */ case    1:  		/* lwz R9, <#[R3 + 564]> */
		/* 821EDB3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000234) );
		/* 821EDB3Ch case    1:*/		return 0x821EDB40;
	}
	return 0x821EDB40;
} // Block from 821EDB38h-821EDB40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EDB40h
// Function '?CreateVariableValueNode@Compiler@D3DXShader@@AAAPAVCNodeValue@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDB40);
		  /* 821EDB40h */ case    0:  		/* rlwinm R8, R10, 0, 31, 31 */
		/* 821EDB40h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R10);
		/* 821EDB40h case    0:*/		return 0x821EDB44;
		  /* 821EDB44h */ case    1:  		/* addic R8, R8, -1 */
		/* 821EDB44h case    1:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821EDB44h case    1:*/		return 0x821EDB48;
		  /* 821EDB48h */ case    2:  		/* subfe R8, R8, R8 */
		/* 821EDB48h case    2:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821EDB48h case    2:*/		return 0x821EDB4C;
		  /* 821EDB4Ch */ case    3:  		/* and R10, R8, R10 */
		/* 821EDB4Ch case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821EDB4Ch case    3:*/		return 0x821EDB50;
		  /* 821EDB50h */ case    4:  		/* cmplw CR6, R9, R10 */
		/* 821EDB50h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 821EDB50h case    4:*/		return 0x821EDB54;
		  /* 821EDB54h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 821EDB54h case    5:*/		if ( regs.CR[6].eq ) { return 0x821EDB88;  }
		/* 821EDB54h case    5:*/		return 0x821EDB58;
		  /* 821EDB58h */ case    6:  		/* rlwinm R10, R11, 15, 17, 31 */
		/* 821EDB58h case    6:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R10,regs.R11);
		/* 821EDB58h case    6:*/		return 0x821EDB5C;
		  /* 821EDB5Ch */ case    7:  		/* lwz R11, <#[R3 + 12]> */
		/* 821EDB5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821EDB5Ch case    7:*/		return 0x821EDB60;
		  /* 821EDB60h */ case    8:  		/* mulli R10, R10, 40 */
		/* 821EDB60h case    8:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821EDB60h case    8:*/		return 0x821EDB64;
		  /* 821EDB64h */ case    9:  		/* add R11, R10, R11 */
		/* 821EDB64h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EDB64h case    9:*/		return 0x821EDB68;
		  /* 821EDB68h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 821EDB68h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821EDB68h case   10:*/		return 0x821EDB6C;
		  /* 821EDB6Ch */ case   11:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 821EDB6Ch case   11:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 821EDB6Ch case   11:*/		return 0x821EDB70;
		  /* 821EDB70h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 821EDB70h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821EDB80;  }
		/* 821EDB70h case   12:*/		return 0x821EDB74;
		  /* 821EDB74h */ case   13:  		/* lwz R11, <#[R3 + 44]> */
		/* 821EDB74h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 821EDB74h case   13:*/		return 0x821EDB78;
		  /* 821EDB78h */ case   14:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 821EDB78h case   14:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 821EDB78h case   14:*/		return 0x821EDB7C;
		  /* 821EDB7Ch */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 821EDB7Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x821EDB88;  }
		/* 821EDB7Ch case   15:*/		return 0x821EDB80;
	}
	return 0x821EDB80;
} // Block from 821EDB40h-821EDB80h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EDB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDB80);
		  /* 821EDB80h */ case    0:  		/* li R3, 0 */
		/* 821EDB80h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821EDB80h case    0:*/		return 0x821EDB84;
		  /* 821EDB84h */ case    1:  		/* b 36 */
		/* 821EDB84h case    1:*/		return 0x821EDBA8;
		/* 821EDB84h case    1:*/		return 0x821EDB88;
	}
	return 0x821EDB88;
} // Block from 821EDB80h-821EDB88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EDB88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDB88);
		  /* 821EDB88h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821EDB88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821EDB88h case    0:*/		return 0x821EDB8C;
		  /* 821EDB8Ch */ case    1:  		/* mr R4, R3 */
		/* 821EDB8Ch case    1:*/		regs.R4 = regs.R3;
		/* 821EDB8Ch case    1:*/		return 0x821EDB90;
		  /* 821EDB90h */ case    2:  		/* addi R3, R1, 80 */
		/* 821EDB90h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821EDB90h case    2:*/		return 0x821EDB94;
		  /* 821EDB94h */ case    3:  		/* rlwinm R6, R11, 30, 18, 31 */
		/* 821EDB94h case    3:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R6,regs.R11);
		/* 821EDB94h case    3:*/		return 0x821EDB98;
	}
	return 0x821EDB98;
} // Block from 821EDB88h-821EDB98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EDB98h
// Function '?CreateCastNode@Compiler@D3DXShader@@AAAPAVCNodeExpression@2@PAVCNode@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDB98);
		  /* 821EDB98h */ case    0:  		/* rlwinm R5, R11, 15, 17, 31 */
		/* 821EDB98h case    0:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R5,regs.R11);
		/* 821EDB98h case    0:*/		return 0x821EDB9C;
		  /* 821EDB9Ch */ case    1:  		/* bl 251772 */
		/* 821EDB9Ch case    1:*/		regs.LR = 0x821EDBA0; return 0x8222B318;
		/* 821EDB9Ch case    1:*/		return 0x821EDBA0;
		  /* 821EDBA0h */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 821EDBA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821EDBA0h case    2:*/		return 0x821EDBA4;
	}
	return 0x821EDBA4;
} // Block from 821EDB98h-821EDBA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EDBA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDBA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDBA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDBA4);
		  /* 821EDBA4h */ case    0:  		/* rlwinm R3, R11, 30, 18, 31 */
		/* 821EDBA4h case    0:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R3,regs.R11);
		/* 821EDBA4h case    0:*/		return 0x821EDBA8;
	}
	return 0x821EDBA8;
} // Block from 821EDBA4h-821EDBA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EDBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDBA8);
		  /* 821EDBA8h */ case    0:  		/* addi R1, R1, 96 */
		/* 821EDBA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821EDBA8h case    0:*/		return 0x821EDBAC;
		  /* 821EDBACh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EDBACh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDBACh case    1:*/		return 0x821EDBB0;
		  /* 821EDBB0h */ case    2:  		/* mtspr LR, R12 */
		/* 821EDBB0h case    2:*/		regs.LR = regs.R12;
		/* 821EDBB0h case    2:*/		return 0x821EDBB4;
		  /* 821EDBB4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 821EDBB4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EDBB4h case    3:*/		return 0x821EDBB8;
	}
	return 0x821EDBB8;
} // Block from 821EDBA8h-821EDBB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EDBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDBB8);
		  /* 821EDBB8h */ case    0:  		/* mfspr R12, LR */
		/* 821EDBB8h case    0:*/		regs.R12 = regs.LR;
		/* 821EDBB8h case    0:*/		return 0x821EDBBC;
		  /* 821EDBBCh */ case    1:  		/* bl -1427828 */
		/* 821EDBBCh case    1:*/		regs.LR = 0x821EDBC0; return 0x82091248;
		/* 821EDBBCh case    1:*/		return 0x821EDBC0;
		  /* 821EDBC0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821EDBC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821EDBC0h case    2:*/		return 0x821EDBC4;
		  /* 821EDBC4h */ case    3:  		/* mr R30, R3 */
		/* 821EDBC4h case    3:*/		regs.R30 = regs.R3;
		/* 821EDBC4h case    3:*/		return 0x821EDBC8;
		  /* 821EDBC8h */ case    4:  		/* mr R26, R6 */
		/* 821EDBC8h case    4:*/		regs.R26 = regs.R6;
		/* 821EDBC8h case    4:*/		return 0x821EDBCC;
		  /* 821EDBCCh */ case    5:  		/* mr R24, R7 */
		/* 821EDBCCh case    5:*/		regs.R24 = regs.R7;
		/* 821EDBCCh case    5:*/		return 0x821EDBD0;
		  /* 821EDBD0h */ case    6:  		/* mr R29, R8 */
		/* 821EDBD0h case    6:*/		regs.R29 = regs.R8;
		/* 821EDBD0h case    6:*/		return 0x821EDBD4;
		  /* 821EDBD4h */ case    7:  		/* mr R28, R9 */
		/* 821EDBD4h case    7:*/		regs.R28 = regs.R9;
		/* 821EDBD4h case    7:*/		return 0x821EDBD8;
		  /* 821EDBD8h */ case    8:  		/* mr R25, R10 */
		/* 821EDBD8h case    8:*/		regs.R25 = regs.R10;
		/* 821EDBD8h case    8:*/		return 0x821EDBDC;
		  /* 821EDBDCh */ case    9:  		/* li R31, 2 */
		/* 821EDBDCh case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 821EDBDCh case    9:*/		return 0x821EDBE0;
		  /* 821EDBE0h */ case   10:  		/* bl -608 */
		/* 821EDBE0h case   10:*/		regs.LR = 0x821EDBE4; return 0x821ED980;
		/* 821EDBE0h case   10:*/		return 0x821EDBE4;
		  /* 821EDBE4h */ case   11:  		/* mr R27, R3 */
		/* 821EDBE4h case   11:*/		regs.R27 = regs.R3;
		/* 821EDBE4h case   11:*/		return 0x821EDBE8;
		  /* 821EDBE8h */ case   12:  		/* mr R5, R24 */
		/* 821EDBE8h case   12:*/		regs.R5 = regs.R24;
		/* 821EDBE8h case   12:*/		return 0x821EDBEC;
		  /* 821EDBECh */ case   13:  		/* mr R4, R26 */
		/* 821EDBECh case   13:*/		regs.R4 = regs.R26;
		/* 821EDBECh case   13:*/		return 0x821EDBF0;
		  /* 821EDBF0h */ case   14:  		/* mr R3, R30 */
		/* 821EDBF0h case   14:*/		regs.R3 = regs.R30;
		/* 821EDBF0h case   14:*/		return 0x821EDBF4;
		  /* 821EDBF4h */ case   15:  		/* bl -628 */
		/* 821EDBF4h case   15:*/		regs.LR = 0x821EDBF8; return 0x821ED980;
		/* 821EDBF4h case   15:*/		return 0x821EDBF8;
	}
	return 0x821EDBF8;
} // Block from 821EDBB8h-821EDBF8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EDBF8h
// Function '?CreateStatementNode@Compiler@D3DXShader@@AAAPAVCNodeStatement@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDBF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDBF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDBF8);
		  /* 821EDBF8h */ case    0:  		/* mr R26, R3 */
		/* 821EDBF8h case    0:*/		regs.R26 = regs.R3;
		/* 821EDBF8h case    0:*/		return 0x821EDBFC;
		  /* 821EDBFCh */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 821EDBFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821EDBFCh case    1:*/		return 0x821EDC00;
		  /* 821EDC00h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 821EDC00h case    2:*/		if ( regs.CR[6].eq ) { return 0x821EDC1C;  }
		/* 821EDC00h case    2:*/		return 0x821EDC04;
		  /* 821EDC04h */ case    3:  		/* mr R5, R28 */
		/* 821EDC04h case    3:*/		regs.R5 = regs.R28;
		/* 821EDC04h case    3:*/		return 0x821EDC08;
		  /* 821EDC08h */ case    4:  		/* mr R4, R29 */
		/* 821EDC08h case    4:*/		regs.R4 = regs.R29;
		/* 821EDC08h case    4:*/		return 0x821EDC0C;
		  /* 821EDC0Ch */ case    5:  		/* mr R3, R30 */
		/* 821EDC0Ch case    5:*/		regs.R3 = regs.R30;
		/* 821EDC0Ch case    5:*/		return 0x821EDC10;
		  /* 821EDC10h */ case    6:  		/* bl -656 */
		/* 821EDC10h case    6:*/		regs.LR = 0x821EDC14; return 0x821ED980;
		/* 821EDC10h case    6:*/		return 0x821EDC14;
		  /* 821EDC14h */ case    7:  		/* mr R29, R3 */
		/* 821EDC14h case    7:*/		regs.R29 = regs.R3;
		/* 821EDC14h case    7:*/		return 0x821EDC18;
		  /* 821EDC18h */ case    8:  		/* li R31, 3 */
		/* 821EDC18h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x3);
		/* 821EDC18h case    8:*/		return 0x821EDC1C;
	}
	return 0x821EDC1C;
} // Block from 821EDBF8h-821EDC1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EDC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDC1C);
		  /* 821EDC1Ch */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 821EDC1Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821EDC1Ch case    0:*/		return 0x821EDC20;
		  /* 821EDC20h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 821EDC20h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EDC3C;  }
		/* 821EDC20h case    1:*/		return 0x821EDC24;
		  /* 821EDC24h */ case    2:  		/* mr R4, R25 */
		/* 821EDC24h case    2:*/		regs.R4 = regs.R25;
		/* 821EDC24h case    2:*/		return 0x821EDC28;
		  /* 821EDC28h */ case    3:  		/* lwz R5, <#[R1 + 244]> */
		/* 821EDC28h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000F4) );
		/* 821EDC28h case    3:*/		return 0x821EDC2C;
		  /* 821EDC2Ch */ case    4:  		/* mr R3, R30 */
		/* 821EDC2Ch case    4:*/		regs.R3 = regs.R30;
		/* 821EDC2Ch case    4:*/		return 0x821EDC30;
		  /* 821EDC30h */ case    5:  		/* bl -688 */
		/* 821EDC30h case    5:*/		regs.LR = 0x821EDC34; return 0x821ED980;
		/* 821EDC30h case    5:*/		return 0x821EDC34;
		  /* 821EDC34h */ case    6:  		/* mr R25, R3 */
		/* 821EDC34h case    6:*/		regs.R25 = regs.R3;
		/* 821EDC34h case    6:*/		return 0x821EDC38;
		  /* 821EDC38h */ case    7:  		/* addi R31, R31, 1 */
		/* 821EDC38h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821EDC38h case    7:*/		return 0x821EDC3C;
	}
	return 0x821EDC3C;
} // Block from 821EDC1Ch-821EDC3Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EDC3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDC3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDC3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDC3C);
		  /* 821EDC3Ch */ case    0:  		/* lwz R4, <#[R30 + 564]> */
		/* 821EDC3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000234) );
		/* 821EDC3Ch case    0:*/		return 0x821EDC40;
		  /* 821EDC40h */ case    1:  		/* mr R6, R31 */
		/* 821EDC40h case    1:*/		regs.R6 = regs.R31;
		/* 821EDC40h case    1:*/		return 0x821EDC44;
		  /* 821EDC44h */ case    2:  		/* mr R3, R30 */
		/* 821EDC44h case    2:*/		regs.R3 = regs.R30;
		/* 821EDC44h case    2:*/		return 0x821EDC48;
	}
	return 0x821EDC48;
} // Block from 821EDC3Ch-821EDC48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EDC48h
// Function '?CreateAssignmentExpressionNode@Compiler@D3DXShader@@AAAPAVCNodeExpression@2@IPAVCNode@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDC48);
		  /* 821EDC48h */ case    0:  		/* addi R5, R4, 24 */
		/* 821EDC48h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821EDC48h case    0:*/		return 0x821EDC4C;
		  /* 821EDC4Ch */ case    1:  		/* bl 224948 */
		/* 821EDC4Ch case    1:*/		regs.LR = 0x821EDC50; return 0x82224B00;
		/* 821EDC4Ch case    1:*/		return 0x821EDC50;
		  /* 821EDC50h */ case    2:  		/* mr R4, R27 */
		/* 821EDC50h case    2:*/		regs.R4 = regs.R27;
		/* 821EDC50h case    2:*/		return 0x821EDC54;
		  /* 821EDC54h */ case    3:  		/* mr R31, R3 */
		/* 821EDC54h case    3:*/		regs.R31 = regs.R3;
		/* 821EDC54h case    3:*/		return 0x821EDC58;
		  /* 821EDC58h */ case    4:  		/* bl -481936 */
		/* 821EDC58h case    4:*/		regs.LR = 0x821EDC5C; return 0x821781C8;
		/* 821EDC58h case    4:*/		return 0x821EDC5C;
		  /* 821EDC5Ch */ case    5:  		/* stw R3, <#[R31 + 44]> */
		/* 821EDC5Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EDC5Ch case    5:*/		return 0x821EDC60;
		  /* 821EDC60h */ case    6:  		/* mr R4, R26 */
		/* 821EDC60h case    6:*/		regs.R4 = regs.R26;
		/* 821EDC60h case    6:*/		return 0x821EDC64;
		  /* 821EDC64h */ case    7:  		/* mr R3, R31 */
		/* 821EDC64h case    7:*/		regs.R3 = regs.R31;
		/* 821EDC64h case    7:*/		return 0x821EDC68;
		  /* 821EDC68h */ case    8:  		/* bl -481952 */
		/* 821EDC68h case    8:*/		regs.LR = 0x821EDC6C; return 0x821781C8;
		/* 821EDC68h case    8:*/		return 0x821EDC6C;
		  /* 821EDC6Ch */ case    9:  		/* stw R3, <#[R31 + 48]> */
		/* 821EDC6Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EDC6Ch case    9:*/		return 0x821EDC70;
		  /* 821EDC70h */ case   10:  		/* li R28, 2 */
		/* 821EDC70h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 821EDC70h case   10:*/		return 0x821EDC74;
		  /* 821EDC74h */ case   11:  		/* cmplwi CR6, R29, 0 */
		/* 821EDC74h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821EDC74h case   11:*/		return 0x821EDC78;
		  /* 821EDC78h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 821EDC78h case   12:*/		if ( regs.CR[6].eq ) { return 0x821EDC90;  }
		/* 821EDC78h case   12:*/		return 0x821EDC7C;
		  /* 821EDC7Ch */ case   13:  		/* mr R4, R29 */
		/* 821EDC7Ch case   13:*/		regs.R4 = regs.R29;
		/* 821EDC7Ch case   13:*/		return 0x821EDC80;
		  /* 821EDC80h */ case   14:  		/* mr R3, R31 */
		/* 821EDC80h case   14:*/		regs.R3 = regs.R31;
		/* 821EDC80h case   14:*/		return 0x821EDC84;
		  /* 821EDC84h */ case   15:  		/* bl -481980 */
		/* 821EDC84h case   15:*/		regs.LR = 0x821EDC88; return 0x821781C8;
		/* 821EDC84h case   15:*/		return 0x821EDC88;
		  /* 821EDC88h */ case   16:  		/* stw R3, <#[R31 + 52]> */
		/* 821EDC88h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 821EDC88h case   16:*/		return 0x821EDC8C;
		  /* 821EDC8Ch */ case   17:  		/* li R28, 3 */
		/* 821EDC8Ch case   17:*/		cpu::op::li<0>(regs,&regs.R28,0x3);
		/* 821EDC8Ch case   17:*/		return 0x821EDC90;
	}
	return 0x821EDC90;
} // Block from 821EDC48h-821EDC90h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EDC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDC90);
		  /* 821EDC90h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 821EDC90h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821EDC90h case    0:*/		return 0x821EDC94;
		  /* 821EDC94h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 821EDC94h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EDCB0;  }
		/* 821EDC94h case    1:*/		return 0x821EDC98;
		  /* 821EDC98h */ case    2:  		/* mr R4, R25 */
		/* 821EDC98h case    2:*/		regs.R4 = regs.R25;
		/* 821EDC98h case    2:*/		return 0x821EDC9C;
		  /* 821EDC9Ch */ case    3:  		/* mr R3, R31 */
		/* 821EDC9Ch case    3:*/		regs.R3 = regs.R31;
		/* 821EDC9Ch case    3:*/		return 0x821EDCA0;
		  /* 821EDCA0h */ case    4:  		/* bl -482008 */
		/* 821EDCA0h case    4:*/		regs.LR = 0x821EDCA4; return 0x821781C8;
		/* 821EDCA0h case    4:*/		return 0x821EDCA4;
		  /* 821EDCA4h */ case    5:  		/* addi R11, R28, 11 */
		/* 821EDCA4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xB);
		/* 821EDCA4h case    5:*/		return 0x821EDCA8;
		  /* 821EDCA8h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821EDCA8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821EDCA8h case    6:*/		return 0x821EDCAC;
		  /* 821EDCACh */ case    7:  		/* stwx R3, <#[R11 + R31]> */
		/* 821EDCACh case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821EDCACh case    7:*/		return 0x821EDCB0;
	}
	return 0x821EDCB0;
} // Block from 821EDC90h-821EDCB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EDCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDCB0);
		  /* 821EDCB0h */ case    0:  		/* mr R4, R31 */
		/* 821EDCB0h case    0:*/		regs.R4 = regs.R31;
		/* 821EDCB0h case    0:*/		return 0x821EDCB4;
		  /* 821EDCB4h */ case    1:  		/* mr R3, R30 */
		/* 821EDCB4h case    1:*/		regs.R3 = regs.R30;
		/* 821EDCB4h case    1:*/		return 0x821EDCB8;
		  /* 821EDCB8h */ case    2:  		/* bl -482488 */
		/* 821EDCB8h case    2:*/		regs.LR = 0x821EDCBC; return 0x82178000;
		/* 821EDCB8h case    2:*/		return 0x821EDCBC;
		  /* 821EDCBCh */ case    3:  		/* addi R1, R1, 160 */
		/* 821EDCBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821EDCBCh case    3:*/		return 0x821EDCC0;
		  /* 821EDCC0h */ case    4:  		/* b -1428008 */
		/* 821EDCC0h case    4:*/		return 0x82091298;
		/* 821EDCC0h case    4:*/		return 0x821EDCC4;
		  /* 821EDCC4h */ case    5:  		/* nop */
		/* 821EDCC4h case    5:*/		cpu::op::nop();
		/* 821EDCC4h case    5:*/		return 0x821EDCC8;
	}
	return 0x821EDCC8;
} // Block from 821EDCB0h-821EDCC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EDCC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDCC8);
		  /* 821EDCC8h */ case    0:  		/* mfspr R12, LR */
		/* 821EDCC8h case    0:*/		regs.R12 = regs.LR;
		/* 821EDCC8h case    0:*/		return 0x821EDCCC;
		  /* 821EDCCCh */ case    1:  		/* bl -1428104 */
		/* 821EDCCCh case    1:*/		regs.LR = 0x821EDCD0; return 0x82091244;
		/* 821EDCCCh case    1:*/		return 0x821EDCD0;
		  /* 821EDCD0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821EDCD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821EDCD0h case    2:*/		return 0x821EDCD4;
		  /* 821EDCD4h */ case    3:  		/* mr R31, R3 */
		/* 821EDCD4h case    3:*/		regs.R31 = regs.R3;
		/* 821EDCD4h case    3:*/		return 0x821EDCD8;
		  /* 821EDCD8h */ case    4:  		/* mr R27, R5 */
		/* 821EDCD8h case    4:*/		regs.R27 = regs.R5;
		/* 821EDCD8h case    4:*/		return 0x821EDCDC;
		  /* 821EDCDCh */ case    5:  		/* mr R29, R6 */
		/* 821EDCDCh case    5:*/		regs.R29 = regs.R6;
		/* 821EDCDCh case    5:*/		return 0x821EDCE0;
	}
	return 0x821EDCE0;
} // Block from 821EDCC8h-821EDCE0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EDCE0h
// Function '?CreateVariableCopyStatementNode@Compiler@D3DXShader@@AAAPAVCNodeStatement@2@III@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDCE0);
		  /* 821EDCE0h */ case    0:  		/* mr R26, R7 */
		/* 821EDCE0h case    0:*/		regs.R26 = regs.R7;
		/* 821EDCE0h case    0:*/		return 0x821EDCE4;
		  /* 821EDCE4h */ case    1:  		/* mr R30, R8 */
		/* 821EDCE4h case    1:*/		regs.R30 = regs.R8;
		/* 821EDCE4h case    1:*/		return 0x821EDCE8;
		  /* 821EDCE8h */ case    2:  		/* mr R25, R9 */
		/* 821EDCE8h case    2:*/		regs.R25 = regs.R9;
		/* 821EDCE8h case    2:*/		return 0x821EDCEC;
		  /* 821EDCECh */ case    3:  		/* mr R28, R10 */
		/* 821EDCECh case    3:*/		regs.R28 = regs.R10;
		/* 821EDCECh case    3:*/		return 0x821EDCF0;
		  /* 821EDCF0h */ case    4:  		/* bl -482544 */
		/* 821EDCF0h case    4:*/		regs.LR = 0x821EDCF4; return 0x82178000;
		/* 821EDCF0h case    4:*/		return 0x821EDCF4;
		  /* 821EDCF4h */ case    5:  		/* mr R24, R3 */
		/* 821EDCF4h case    5:*/		regs.R24 = regs.R3;
		/* 821EDCF4h case    5:*/		return 0x821EDCF8;
		  /* 821EDCF8h */ case    6:  		/* mr R4, R29 */
		/* 821EDCF8h case    6:*/		regs.R4 = regs.R29;
		/* 821EDCF8h case    6:*/		return 0x821EDCFC;
		  /* 821EDCFCh */ case    7:  		/* mr R3, R31 */
		/* 821EDCFCh case    7:*/		regs.R3 = regs.R31;
		/* 821EDCFCh case    7:*/		return 0x821EDD00;
		  /* 821EDD00h */ case    8:  		/* bl -482560 */
		/* 821EDD00h case    8:*/		regs.LR = 0x821EDD04; return 0x82178000;
		/* 821EDD00h case    8:*/		return 0x821EDD04;
		  /* 821EDD04h */ case    9:  		/* mr R23, R3 */
		/* 821EDD04h case    9:*/		regs.R23 = regs.R3;
		/* 821EDD04h case    9:*/		return 0x821EDD08;
		  /* 821EDD08h */ case   10:  		/* li R29, 0 */
		/* 821EDD08h case   10:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821EDD08h case   10:*/		return 0x821EDD0C;
		  /* 821EDD0Ch */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 821EDD0Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821EDD0Ch case   11:*/		return 0x821EDD10;
		  /* 821EDD10h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 821EDD10h case   12:*/		if ( regs.CR[6].eq ) { return 0x821EDD24;  }
		/* 821EDD10h case   12:*/		return 0x821EDD14;
		  /* 821EDD14h */ case   13:  		/* mr R4, R30 */
		/* 821EDD14h case   13:*/		regs.R4 = regs.R30;
		/* 821EDD14h case   13:*/		return 0x821EDD18;
		  /* 821EDD18h */ case   14:  		/* mr R3, R31 */
		/* 821EDD18h case   14:*/		regs.R3 = regs.R31;
		/* 821EDD18h case   14:*/		return 0x821EDD1C;
		  /* 821EDD1Ch */ case   15:  		/* bl -482588 */
		/* 821EDD1Ch case   15:*/		regs.LR = 0x821EDD20; return 0x82178000;
		/* 821EDD1Ch case   15:*/		return 0x821EDD20;
		  /* 821EDD20h */ case   16:  		/* mr R29, R3 */
		/* 821EDD20h case   16:*/		regs.R29 = regs.R3;
		/* 821EDD20h case   16:*/		return 0x821EDD24;
	}
	return 0x821EDD24;
} // Block from 821EDCE0h-821EDD24h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821EDD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDD24);
		  /* 821EDD24h */ case    0:  		/* li R10, 0 */
		/* 821EDD24h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821EDD24h case    0:*/		return 0x821EDD28;
		  /* 821EDD28h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 821EDD28h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821EDD28h case    1:*/		return 0x821EDD2C;
		  /* 821EDD2Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 821EDD2Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821EDD40;  }
		/* 821EDD2Ch case    2:*/		return 0x821EDD30;
		  /* 821EDD30h */ case    3:  		/* mr R4, R28 */
		/* 821EDD30h case    3:*/		regs.R4 = regs.R28;
		/* 821EDD30h case    3:*/		return 0x821EDD34;
		  /* 821EDD34h */ case    4:  		/* mr R3, R31 */
		/* 821EDD34h case    4:*/		regs.R3 = regs.R31;
		/* 821EDD34h case    4:*/		return 0x821EDD38;
	}
	return 0x821EDD38;
} // Block from 821EDD24h-821EDD38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EDD38h
// Function '?CreateVariableComparisonExpressionNode@Compiler@D3DXShader@@AAAPAVCNodeExpression@2@IPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDD38);
		  /* 821EDD38h */ case    0:  		/* bl -482616 */
		/* 821EDD38h case    0:*/		regs.LR = 0x821EDD3C; return 0x82178000;
		/* 821EDD38h case    0:*/		return 0x821EDD3C;
		  /* 821EDD3Ch */ case    1:  		/* mr R10, R3 */
		/* 821EDD3Ch case    1:*/		regs.R10 = regs.R3;
		/* 821EDD3Ch case    1:*/		return 0x821EDD40;
	}
	return 0x821EDD40;
} // Block from 821EDD38h-821EDD40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EDD40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDD40);
		  /* 821EDD40h */ case    0:  		/* lwz R11, <#[R1 + 260]> */
		/* 821EDD40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000104) );
		/* 821EDD40h case    0:*/		return 0x821EDD44;
		  /* 821EDD44h */ case    1:  		/* mr R9, R25 */
		/* 821EDD44h case    1:*/		regs.R9 = regs.R25;
		/* 821EDD44h case    1:*/		return 0x821EDD48;
		  /* 821EDD48h */ case    2:  		/* mr R8, R29 */
		/* 821EDD48h case    2:*/		regs.R8 = regs.R29;
		/* 821EDD48h case    2:*/		return 0x821EDD4C;
		  /* 821EDD4Ch */ case    3:  		/* mr R7, R26 */
		/* 821EDD4Ch case    3:*/		regs.R7 = regs.R26;
		/* 821EDD4Ch case    3:*/		return 0x821EDD50;
		  /* 821EDD50h */ case    4:  		/* mr R6, R23 */
		/* 821EDD50h case    4:*/		regs.R6 = regs.R23;
		/* 821EDD50h case    4:*/		return 0x821EDD54;
		  /* 821EDD54h */ case    5:  		/* mr R5, R27 */
		/* 821EDD54h case    5:*/		regs.R5 = regs.R27;
		/* 821EDD54h case    5:*/		return 0x821EDD58;
		  /* 821EDD58h */ case    6:  		/* mr R4, R24 */
		/* 821EDD58h case    6:*/		regs.R4 = regs.R24;
		/* 821EDD58h case    6:*/		return 0x821EDD5C;
		  /* 821EDD5Ch */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 821EDD5Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821EDD5Ch case    7:*/		return 0x821EDD60;
		  /* 821EDD60h */ case    8:  		/* mr R3, R31 */
		/* 821EDD60h case    8:*/		regs.R3 = regs.R31;
		/* 821EDD60h case    8:*/		return 0x821EDD64;
		  /* 821EDD64h */ case    9:  		/* bl -428 */
		/* 821EDD64h case    9:*/		regs.LR = 0x821EDD68; return 0x821EDBB8;
		/* 821EDD64h case    9:*/		return 0x821EDD68;
		  /* 821EDD68h */ case   10:  		/* addi R1, R1, 176 */
		/* 821EDD68h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821EDD68h case   10:*/		return 0x821EDD6C;
		  /* 821EDD6Ch */ case   11:  		/* b -1428184 */
		/* 821EDD6Ch case   11:*/		return 0x82091294;
		/* 821EDD6Ch case   11:*/		return 0x821EDD70;
	}
	return 0x821EDD70;
} // Block from 821EDD40h-821EDD70h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EDD70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDD70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDD70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDD70);
		  /* 821EDD70h */ case    0:  		/* mfspr R12, LR */
		/* 821EDD70h case    0:*/		regs.R12 = regs.LR;
		/* 821EDD70h case    0:*/		return 0x821EDD74;
		  /* 821EDD74h */ case    1:  		/* bl -1428248 */
		/* 821EDD74h case    1:*/		regs.LR = 0x821EDD78; return 0x8209125C;
		/* 821EDD74h case    1:*/		return 0x821EDD78;
		  /* 821EDD78h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EDD78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EDD78h case    2:*/		return 0x821EDD7C;
		  /* 821EDD7Ch */ case    3:  		/* mr R29, R4 */
		/* 821EDD7Ch case    3:*/		regs.R29 = regs.R4;
		/* 821EDD7Ch case    3:*/		return 0x821EDD80;
		  /* 821EDD80h */ case    4:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EDD80h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EDD80h case    4:*/		return 0x821EDD84;
		  /* 821EDD84h */ case    5:  		/* li R7, 1 */
		/* 821EDD84h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EDD84h case    5:*/		return 0x821EDD88;
		  /* 821EDD88h */ case    6:  		/* li R6, 104 */
		/* 821EDD88h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x68);
		/* 821EDD88h case    6:*/		return 0x821EDD8C;
		  /* 821EDD8Ch */ case    7:  		/* addi R5, R4, 24 */
		/* 821EDD8Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821EDD8Ch case    7:*/		return 0x821EDD90;
		  /* 821EDD90h */ case    8:  		/* mr R30, R3 */
		/* 821EDD90h case    8:*/		regs.R30 = regs.R3;
		/* 821EDD90h case    8:*/		return 0x821EDD94;
		  /* 821EDD94h */ case    9:  		/* lwz R11, <#[R29]> */
		/* 821EDD94h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821EDD94h case    9:*/		return 0x821EDD98;
		  /* 821EDD98h */ case   10:  		/* rlwinm R8, R11, 7, 29, 31 */
		/* 821EDD98h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R11);
		/* 821EDD98h case   10:*/		return 0x821EDD9C;
		  /* 821EDD9Ch */ case   11:  		/* bl 224252 */
		/* 821EDD9Ch case   11:*/		regs.LR = 0x821EDDA0; return 0x82224998;
		/* 821EDD9Ch case   11:*/		return 0x821EDDA0;
		  /* 821EDDA0h */ case   12:  		/* mr R4, R29 */
		/* 821EDDA0h case   12:*/		regs.R4 = regs.R29;
		/* 821EDDA0h case   12:*/		return 0x821EDDA4;
		  /* 821EDDA4h */ case   13:  		/* mr R31, R3 */
		/* 821EDDA4h case   13:*/		regs.R31 = regs.R3;
		/* 821EDDA4h case   13:*/		return 0x821EDDA8;
		  /* 821EDDA8h */ case   14:  		/* bl -482272 */
		/* 821EDDA8h case   14:*/		regs.LR = 0x821EDDAC; return 0x821781C8;
		/* 821EDDA8h case   14:*/		return 0x821EDDAC;
		  /* 821EDDACh */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 821EDDACh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821EDDACh case   15:*/		return 0x821EDDB0;
		  /* 821EDDB0h */ case   16:  		/* stw R3, <#[R31 + 44]> */
		/* 821EDDB0h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EDDB0h case   16:*/		return 0x821EDDB4;
		  /* 821EDDB4h */ case   17:  		/* mr R3, R30 */
		/* 821EDDB4h case   17:*/		regs.R3 = regs.R30;
		/* 821EDDB4h case   17:*/		return 0x821EDDB8;
		  /* 821EDDB8h */ case   18:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821EDDB8h case   18:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821EDDB8h case   18:*/		return 0x821EDDBC;
		  /* 821EDDBCh */ case   19:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821EDDBCh case   19:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821EDDBCh case   19:*/		return 0x821EDDC0;
		  /* 821EDDC0h */ case   20:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821EDDC0h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821EDDC0h case   20:*/		return 0x821EDDC4;
		  /* 821EDDC4h */ case   21:  		/* bl -563604 */
		/* 821EDDC4h case   21:*/		regs.LR = 0x821EDDC8; return 0x82164430;
		/* 821EDDC4h case   21:*/		return 0x821EDDC8;
		  /* 821EDDC8h */ case   22:  		/* addi R11, R31, -4 */
		/* 821EDDC8h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 821EDDC8h case   22:*/		return 0x821EDDCC;
		  /* 821EDDCCh */ case   23:  		/* add R11, R3, R11 */
		/* 821EDDCCh case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821EDDCCh case   23:*/		return 0x821EDDD0;
		  /* 821EDDD0h */ case   24:  		/* mr R3, R31 */
		/* 821EDDD0h case   24:*/		regs.R3 = regs.R31;
		/* 821EDDD0h case   24:*/		return 0x821EDDD4;
		  /* 821EDDD4h */ case   25:  		/* lwz R10, <#[R11]> */
		/* 821EDDD4h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821EDDD4h case   25:*/		return 0x821EDDD8;
		  /* 821EDDD8h */ case   26:  		/* oris R10, R10, 32 */
		/* 821EDDD8h case   26:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x20);
		/* 821EDDD8h case   26:*/		return 0x821EDDDC;
		  /* 821EDDDCh */ case   27:  		/* stw R10, <#[R11]> */
		/* 821EDDDCh case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821EDDDCh case   27:*/		return 0x821EDDE0;
		  /* 821EDDE0h */ case   28:  		/* lwz R11, <#[R30 + 44]> */
		/* 821EDDE0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821EDDE0h case   28:*/		return 0x821EDDE4;
		  /* 821EDDE4h */ case   29:  		/* ori R11, R11, 4 */
		/* 821EDDE4h case   29:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821EDDE4h case   29:*/		return 0x821EDDE8;
		  /* 821EDDE8h */ case   30:  		/* stw R11, <#[R30 + 44]> */
		/* 821EDDE8h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821EDDE8h case   30:*/		return 0x821EDDEC;
		  /* 821EDDECh */ case   31:  		/* addi R1, R1, 112 */
		/* 821EDDECh case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EDDECh case   31:*/		return 0x821EDDF0;
		  /* 821EDDF0h */ case   32:  		/* b -1428292 */
		/* 821EDDF0h case   32:*/		return 0x820912AC;
		/* 821EDDF0h case   32:*/		return 0x821EDDF4;
		  /* 821EDDF4h */ case   33:  		/* nop */
		/* 821EDDF4h case   33:*/		cpu::op::nop();
		/* 821EDDF4h case   33:*/		return 0x821EDDF8;
	}
	return 0x821EDDF8;
} // Block from 821EDD70h-821EDDF8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821EDDF8h
// Function '?CountLeafNodeComponents@Compiler@D3DXShader@@AAAIPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDDF8);
		  /* 821EDDF8h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 821EDDF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821EDDF8h case    0:*/		return 0x821EDDFC;
		  /* 821EDDFCh */ case    1:  		/* bclr 12, CR6_EQ */
		/* 821EDDFCh case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821EDDFCh case    1:*/		return 0x821EDE00;
	}
	return 0x821EDE00;
} // Block from 821EDDF8h-821EDE00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EDE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDE00);
		  /* 821EDE00h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 821EDE00h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821EDE00h case    0:*/		return 0x821EDE04;
		  /* 821EDE04h */ case    1:  		/* mr R8, R4 */
		/* 821EDE04h case    1:*/		regs.R8 = regs.R4;
		/* 821EDE04h case    1:*/		return 0x821EDE08;
		  /* 821EDE08h */ case    2:  		/* lwz R9, <#[R3 + 8]> */
		/* 821EDE08h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821EDE08h case    2:*/		return 0x821EDE0C;
		  /* 821EDE0Ch */ case    3:  		/* lwz R11, <#[R10 + 8]> */
		/* 821EDE0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821EDE0Ch case    3:*/		return 0x821EDE10;
		  /* 821EDE10h */ case    4:  		/* subf R11, R9, R11 */
		/* 821EDE10h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821EDE10h case    4:*/		return 0x821EDE14;
		  /* 821EDE14h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 821EDE14h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821EDE14h case    5:*/		return 0x821EDE18;
		  /* 821EDE18h */ case    6:  		/* bc 12, CR6_LT, 8 */
		/* 821EDE18h case    6:*/		if ( regs.CR[6].lt ) { return 0x821EDE20;  }
		/* 821EDE18h case    6:*/		return 0x821EDE1C;
		  /* 821EDE1Ch */ case    7:  		/* mr R8, R11 */
		/* 821EDE1Ch case    7:*/		regs.R8 = regs.R11;
		/* 821EDE1Ch case    7:*/		return 0x821EDE20;
	}
	return 0x821EDE20;
} // Block from 821EDE00h-821EDE20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EDE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDE20);
		  /* 821EDE20h */ case    0:  		/* add R11, R9, R8 */
		/* 821EDE20h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R8);
		/* 821EDE20h case    0:*/		return 0x821EDE24;
		  /* 821EDE24h */ case    1:  		/* stw R11, <#[R3 + 8]> */
		/* 821EDE24h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821EDE24h case    1:*/		return 0x821EDE28;
		  /* 821EDE28h */ case    2:  		/* lwz R9, <#[R10 + 8]> */
		/* 821EDE28h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821EDE28h case    2:*/		return 0x821EDE2C;
		  /* 821EDE2Ch */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 821EDE2Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821EDE2Ch case    3:*/		return 0x821EDE30;
		  /* 821EDE30h */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 821EDE30h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821EDE58;  }
		/* 821EDE30h case    4:*/		return 0x821EDE34;
		  /* 821EDE34h */ case    5:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 821EDE34h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 821EDE34h case    5:*/		return 0x821EDE38;
		  /* 821EDE38h */ case    6:  		/* li R10, 0 */
		/* 821EDE38h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821EDE38h case    6:*/		return 0x821EDE3C;
		  /* 821EDE3Ch */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 821EDE3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821EDE3Ch case    7:*/		return 0x821EDE40;
		  /* 821EDE40h */ case    8:  		/* stw R10, <#[R3 + 8]> */
		/* 821EDE40h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821EDE40h case    8:*/		return 0x821EDE44;
		  /* 821EDE44h */ case    9:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821EDE44h case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821EDE44h case    9:*/		return 0x821EDE48;
		  /* 821EDE48h */ case   10:  		/* addic R10, R10, -1 */
		/* 821EDE48h case   10:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821EDE48h case   10:*/		return 0x821EDE4C;
		  /* 821EDE4Ch */ case   11:  		/* subfe R10, R10, R10 */
		/* 821EDE4Ch case   11:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821EDE4Ch case   11:*/		return 0x821EDE50;
		  /* 821EDE50h */ case   12:  		/* and R11, R10, R11 */
		/* 821EDE50h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821EDE50h case   12:*/		return 0x821EDE54;
		  /* 821EDE54h */ case   13:  		/* stw R11, <#[R3 + 4]> */
		/* 821EDE54h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821EDE54h case   13:*/		return 0x821EDE58;
	}
	return 0x821EDE58;
} // Block from 821EDE20h-821EDE58h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EDE58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDE58);
		  /* 821EDE58h */ case    0:  		/* subf. R4, R8, R4 */
		/* 821EDE58h case    0:*/		cpu::op::subf<1>(regs,&regs.R4,regs.R8,regs.R4);
		/* 821EDE58h case    0:*/		return 0x821EDE5C;
		  /* 821EDE5Ch */ case    1:  		/* bc 4, CR0_EQ, -92 */
		/* 821EDE5Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821EDE00;  }
		/* 821EDE5Ch case    1:*/		return 0x821EDE60;
		  /* 821EDE60h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821EDE60h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EDE60h case    2:*/		return 0x821EDE64;
	}
	return 0x821EDE64;
} // Block from 821EDE58h-821EDE64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EDE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDE64);
		  /* 821EDE64h */ case    0:  		/* nop */
		/* 821EDE64h case    0:*/		cpu::op::nop();
		/* 821EDE64h case    0:*/		return 0x821EDE68;
	}
	return 0x821EDE68;
} // Block from 821EDE64h-821EDE68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EDE68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDE68);
		  /* 821EDE68h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 821EDE68h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDE68h case    0:*/		return 0x821EDE6C;
		  /* 821EDE6Ch */ case    1:  		/* lwz R10, <#[R4 + 4]> */
		/* 821EDE6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 821EDE6Ch case    1:*/		return 0x821EDE70;
		  /* 821EDE70h */ case    2:  		/* addi R11, R4, 4 */
		/* 821EDE70h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x4);
		/* 821EDE70h case    2:*/		return 0x821EDE74;
		  /* 821EDE74h */ case    3:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 821EDE74h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821EDE74h case    3:*/		return 0x821EDE78;
		  /* 821EDE78h */ case    4:  		/* bc 4, CR0_EQ, 72 */
		/* 821EDE78h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821EDEC0;  }
		/* 821EDE78h case    4:*/		return 0x821EDE7C;
		  /* 821EDE7Ch */ case    5:  		/* lwz R9, <#[R3]> */
		/* 821EDE7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821EDE7Ch case    5:*/		return 0x821EDE80;
		  /* 821EDE80h */ case    6:  		/* rlwinm R8, R10, 0, 0, 30 */
		/* 821EDE80h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R10);
		/* 821EDE80h case    6:*/		return 0x821EDE84;
		  /* 821EDE84h */ case    7:  		/* lwz R10, <#[R4]> */
		/* 821EDE84h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821EDE84h case    7:*/		return 0x821EDE88;
		  /* 821EDE88h */ case    8:  		/* ori R7, R3, 1 */
		/* 821EDE88h case    8:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R3,0x1);
		/* 821EDE88h case    8:*/		return 0x821EDE8C;
		  /* 821EDE8Ch */ case    9:  		/* ori R6, R4, 1 */
		/* 821EDE8Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R4,0x1);
		/* 821EDE8Ch case    9:*/		return 0x821EDE90;
		  /* 821EDE90h */ case   10:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821EDE90h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821EDE90h case   10:*/		return 0x821EDE94;
		  /* 821EDE94h */ case   11:  		/* ori R5, R11, 1 */
		/* 821EDE94h case   11:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R11,0x1);
		/* 821EDE94h case   11:*/		return 0x821EDE98;
		  /* 821EDE98h */ case   12:  		/* stw R9, <#[R8]> */
		/* 821EDE98h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 821EDE98h case   12:*/		return 0x821EDE9C;
		  /* 821EDE9Ch */ case   13:  		/* addi R10, R10, -4 */
		/* 821EDE9Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821EDE9Ch case   13:*/		return 0x821EDEA0;
		  /* 821EDEA0h */ case   14:  		/* lwz R9, <#[R3]> */
		/* 821EDEA0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821EDEA0h case   14:*/		return 0x821EDEA4;
		  /* 821EDEA4h */ case   15:  		/* rlwinm R31, R9, 0, 0, 30 */
		/* 821EDEA4h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R31,regs.R9);
		/* 821EDEA4h case   15:*/		return 0x821EDEA8;
		  /* 821EDEA8h */ case   16:  		/* addi R9, R10, 4 */
		/* 821EDEA8h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EDEA8h case   16:*/		return 0x821EDEAC;
		  /* 821EDEACh */ case   17:  		/* stw R8, <#[R31]> */
		/* 821EDEACh case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821EDEACh case   17:*/		return 0x821EDEB0;
		  /* 821EDEB0h */ case   18:  		/* stw R7, <#[R10 + 4]> */
		/* 821EDEB0h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 821EDEB0h case   18:*/		return 0x821EDEB4;
		  /* 821EDEB4h */ case   19:  		/* stw R9, <#[R3]> */
		/* 821EDEB4h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821EDEB4h case   19:*/		return 0x821EDEB8;
		  /* 821EDEB8h */ case   20:  		/* stw R6, <#[R11]> */
		/* 821EDEB8h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821EDEB8h case   20:*/		return 0x821EDEBC;
		  /* 821EDEBCh */ case   21:  		/* stw R5, <#[R4]> */
		/* 821EDEBCh case   21:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 821EDEBCh case   21:*/		return 0x821EDEC0;
	}
	return 0x821EDEC0;
} // Block from 821EDE68h-821EDEC0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EDEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDEC0);
		  /* 821EDEC0h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 821EDEC0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDEC0h case    0:*/		return 0x821EDEC4;
		  /* 821EDEC4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821EDEC4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EDEC4h case    1:*/		return 0x821EDEC8;
	}
	return 0x821EDEC8;
} // Block from 821EDEC0h-821EDEC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EDEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDEC8);
		  /* 821EDEC8h */ case    0:  		/* mfspr R12, LR */
		/* 821EDEC8h case    0:*/		regs.R12 = regs.LR;
		/* 821EDEC8h case    0:*/		return 0x821EDECC;
		  /* 821EDECCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EDECCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDECCh case    1:*/		return 0x821EDED0;
		  /* 821EDED0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821EDED0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EDED0h case    2:*/		return 0x821EDED4;
		  /* 821EDED4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821EDED4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821EDED4h case    3:*/		return 0x821EDED8;
		  /* 821EDED8h */ case    4:  		/* addi R10, R4, 3 */
		/* 821EDED8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x3);
		/* 821EDED8h case    4:*/		return 0x821EDEDC;
		  /* 821EDEDCh */ case    5:  		/* addi R11, R3, 812 */
		/* 821EDEDCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x32C);
		/* 821EDEDCh case    5:*/		return 0x821EDEE0;
		  /* 821EDEE0h */ case    6:  		/* rlwinm R4, R10, 0, 0, 29 */
		/* 821EDEE0h case    6:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R10);
		/* 821EDEE0h case    6:*/		return 0x821EDEE4;
		  /* 821EDEE4h */ case    7:  		/* cmplwi CR6, R4, 132 */
		/* 821EDEE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000084);
		/* 821EDEE4h case    7:*/		return 0x821EDEE8;
		  /* 821EDEE8h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 821EDEE8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821EDEF8;  }
		/* 821EDEE8h case    8:*/		return 0x821EDEEC;
		  /* 821EDEECh */ case    9:  		/* mr R3, R11 */
		/* 821EDEECh case    9:*/		regs.R3 = regs.R11;
		/* 821EDEECh case    9:*/		return 0x821EDEF0;
		  /* 821EDEF0h */ case   10:  		/* bl -561120 */
		/* 821EDEF0h case   10:*/		regs.LR = 0x821EDEF4; return 0x82164F10;
		/* 821EDEF0h case   10:*/		return 0x821EDEF4;
		  /* 821EDEF4h */ case   11:  		/* b 112 */
		/* 821EDEF4h case   11:*/		return 0x821EDF64;
		/* 821EDEF4h case   11:*/		return 0x821EDEF8;
	}
	return 0x821EDEF8;
} // Block from 821EDEC8h-821EDEF8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EDEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDEF8);
		  /* 821EDEF8h */ case    0:  		/* lwz R9, <#[R11 + 140]> */
		/* 821EDEF8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000008C) );
		/* 821EDEF8h case    0:*/		return 0x821EDEFC;
		  /* 821EDEFCh */ case    1:  		/* lwz R10, <#[R11 + 144]> */
		/* 821EDEFCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000090) );
		/* 821EDEFCh case    1:*/		return 0x821EDF00;
		  /* 821EDF00h */ case    2:  		/* subf R9, R10, R9 */
		/* 821EDF00h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 821EDF00h case    2:*/		return 0x821EDF04;
		  /* 821EDF04h */ case    3:  		/* addi R9, R9, 4096 */
		/* 821EDF04h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 821EDF04h case    3:*/		return 0x821EDF08;
		  /* 821EDF08h */ case    4:  		/* cmplw CR6, R9, R4 */
		/* 821EDF08h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 821EDF08h case    4:*/		return 0x821EDF0C;
		  /* 821EDF0Ch */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 821EDF0Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x821EDF1C;  }
		/* 821EDF0Ch case    5:*/		return 0x821EDF10;
		  /* 821EDF10h */ case    6:  		/* add R9, R10, R4 */
		/* 821EDF10h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 821EDF10h case    6:*/		return 0x821EDF14;
		  /* 821EDF14h */ case    7:  		/* stw R9, <#[R11 + 144]> */
		/* 821EDF14h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000090) );
		/* 821EDF14h case    7:*/		return 0x821EDF18;
		  /* 821EDF18h */ case    8:  		/* b 72 */
		/* 821EDF18h case    8:*/		return 0x821EDF60;
		/* 821EDF18h case    8:*/		return 0x821EDF1C;
	}
	return 0x821EDF1C;
} // Block from 821EDEF8h-821EDF1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EDF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDF1C);
		  /* 821EDF1Ch */ case    0:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 821EDF1Ch case    0:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 821EDF1Ch case    0:*/		return 0x821EDF20;
		  /* 821EDF20h */ case    1:  		/* addi R10, R10, -1 */
		/* 821EDF20h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821EDF20h case    1:*/		return 0x821EDF24;
		  /* 821EDF24h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821EDF24h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821EDF24h case    2:*/		return 0x821EDF28;
		  /* 821EDF28h */ case    3:  		/* lwzx R31, <#[R10 + R11]> */
		/* 821EDF28h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821EDF28h case    3:*/		return 0x821EDF2C;
		  /* 821EDF2Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821EDF2Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821EDF2Ch case    4:*/		return 0x821EDF30;
	}
	return 0x821EDF30;
} // Block from 821EDF1Ch-821EDF30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EDF30h
// Function '?CountComponents@Compiler@D3DXShader@@AAAIPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDF30);
		  /* 821EDF30h */ case    0:  		/* bc 12, CR6_EQ, 36 */
		/* 821EDF30h case    0:*/		if ( regs.CR[6].eq ) { return 0x821EDF54;  }
		/* 821EDF30h case    0:*/		return 0x821EDF34;
		  /* 821EDF34h */ case    1:  		/* lwz R9, <#[R31]> */
		/* 821EDF34h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821EDF34h case    1:*/		return 0x821EDF38;
		  /* 821EDF38h */ case    2:  		/* mr R5, R4 */
		/* 821EDF38h case    2:*/		regs.R5 = regs.R4;
		/* 821EDF38h case    2:*/		return 0x821EDF3C;
		  /* 821EDF3Ch */ case    3:  		/* li R4, 0 */
		/* 821EDF3Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821EDF3Ch case    3:*/		return 0x821EDF40;
		  /* 821EDF40h */ case    4:  		/* mr R3, R31 */
		/* 821EDF40h case    4:*/		regs.R3 = regs.R31;
		/* 821EDF40h case    4:*/		return 0x821EDF44;
		  /* 821EDF44h */ case    5:  		/* stwx R9, <#[R10 + R11]> */
		/* 821EDF44h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821EDF44h case    5:*/		return 0x821EDF48;
		  /* 821EDF48h */ case    6:  		/* bl -1428488 */
		/* 821EDF48h case    6:*/		regs.LR = 0x821EDF4C; return 0x82091340;
		/* 821EDF48h case    6:*/		return 0x821EDF4C;
		  /* 821EDF4Ch */ case    7:  		/* mr R10, R31 */
		/* 821EDF4Ch case    7:*/		regs.R10 = regs.R31;
		/* 821EDF4Ch case    7:*/		return 0x821EDF50;
		  /* 821EDF50h */ case    8:  		/* b 16 */
		/* 821EDF50h case    8:*/		return 0x821EDF60;
		/* 821EDF50h case    8:*/		return 0x821EDF54;
	}
	return 0x821EDF54;
} // Block from 821EDF30h-821EDF54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EDF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDF54);
		  /* 821EDF54h */ case    0:  		/* mr R3, R11 */
		/* 821EDF54h case    0:*/		regs.R3 = regs.R11;
		/* 821EDF54h case    0:*/		return 0x821EDF58;
		  /* 821EDF58h */ case    1:  		/* bl -563560 */
		/* 821EDF58h case    1:*/		regs.LR = 0x821EDF5C; return 0x821645F0;
		/* 821EDF58h case    1:*/		return 0x821EDF5C;
		  /* 821EDF5Ch */ case    2:  		/* mr R10, R3 */
		/* 821EDF5Ch case    2:*/		regs.R10 = regs.R3;
		/* 821EDF5Ch case    2:*/		return 0x821EDF60;
	}
	return 0x821EDF60;
} // Block from 821EDF54h-821EDF60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EDF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDF60);
		  /* 821EDF60h */ case    0:  		/* mr R3, R10 */
		/* 821EDF60h case    0:*/		regs.R3 = regs.R10;
		/* 821EDF60h case    0:*/		return 0x821EDF64;
	}
	return 0x821EDF64;
} // Block from 821EDF60h-821EDF64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EDF64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDF64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDF64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDF64);
		  /* 821EDF64h */ case    0:  		/* addi R1, R1, 96 */
		/* 821EDF64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821EDF64h case    0:*/		return 0x821EDF68;
		  /* 821EDF68h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EDF68h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDF68h case    1:*/		return 0x821EDF6C;
		  /* 821EDF6Ch */ case    2:  		/* mtspr LR, R12 */
		/* 821EDF6Ch case    2:*/		regs.LR = regs.R12;
		/* 821EDF6Ch case    2:*/		return 0x821EDF70;
		  /* 821EDF70h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821EDF70h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EDF70h case    3:*/		return 0x821EDF74;
		  /* 821EDF74h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821EDF74h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EDF74h case    4:*/		return 0x821EDF78;
	}
	return 0x821EDF78;
} // Block from 821EDF64h-821EDF78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EDF78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDF78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDF78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDF78);
		  /* 821EDF78h */ case    0:  		/* mfspr R12, LR */
		/* 821EDF78h case    0:*/		regs.R12 = regs.LR;
		/* 821EDF78h case    0:*/		return 0x821EDF7C;
		  /* 821EDF7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821EDF7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EDF7Ch case    1:*/		return 0x821EDF80;
		  /* 821EDF80h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821EDF80h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EDF80h case    2:*/		return 0x821EDF84;
		  /* 821EDF84h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821EDF84h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821EDF84h case    3:*/		return 0x821EDF88;
		  /* 821EDF88h */ case    4:  		/* li R5, 5 */
		/* 821EDF88h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 821EDF88h case    4:*/		return 0x821EDF8C;
		  /* 821EDF8Ch */ case    5:  		/* li R4, 116 */
		/* 821EDF8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x74);
		/* 821EDF8Ch case    5:*/		return 0x821EDF90;
		  /* 821EDF90h */ case    6:  		/* mr R31, R3 */
		/* 821EDF90h case    6:*/		regs.R31 = regs.R3;
		/* 821EDF90h case    6:*/		return 0x821EDF94;
		  /* 821EDF94h */ case    7:  		/* bl -529388 */
		/* 821EDF94h case    7:*/		regs.LR = 0x821EDF98; return 0x8216CBA8;
		/* 821EDF94h case    7:*/		return 0x821EDF98;
		  /* 821EDF98h */ case    8:  		/* addi R11, R3, 16 */
		/* 821EDF98h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 821EDF98h case    8:*/		return 0x821EDF9C;
		  /* 821EDF9Ch */ case    9:  		/* addi R10, R3, 24 */
		/* 821EDF9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x18);
		/* 821EDF9Ch case    9:*/		return 0x821EDFA0;
		  /* 821EDFA0h */ case   10:  		/* addi R8, R11, 4 */
		/* 821EDFA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 821EDFA0h case   10:*/		return 0x821EDFA4;
		  /* 821EDFA4h */ case   11:  		/* addi R6, R11, -36 */
		/* 821EDFA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 821EDFA4h case   11:*/		return 0x821EDFA8;
		  /* 821EDFA8h */ case   12:  		/* addi R11, R10, 4 */
		/* 821EDFA8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 821EDFA8h case   12:*/		return 0x821EDFAC;
		  /* 821EDFACh */ case   13:  		/* addi R9, R3, 32 */
		/* 821EDFACh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x20);
		/* 821EDFACh case   13:*/		return 0x821EDFB0;
		  /* 821EDFB0h */ case   14:  		/* addi R5, R10, -36 */
		/* 821EDFB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFFDC);
		/* 821EDFB0h case   14:*/		return 0x821EDFB4;
		  /* 821EDFB4h */ case   15:  		/* ori R6, R6, 1 */
		/* 821EDFB4h case   15:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EDFB4h case   15:*/		return 0x821EDFB8;
		  /* 821EDFB8h */ case   16:  		/* ori R8, R8, 1 */
		/* 821EDFB8h case   16:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EDFB8h case   16:*/		return 0x821EDFBC;
		  /* 821EDFBCh */ case   17:  		/* ori R11, R11, 1 */
		/* 821EDFBCh case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821EDFBCh case   17:*/		return 0x821EDFC0;
		  /* 821EDFC0h */ case   18:  		/* stw R6, <#[R3 + 20]> */
		/* 821EDFC0h case   18:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 821EDFC0h case   18:*/		return 0x821EDFC4;
		  /* 821EDFC4h */ case   19:  		/* addi R10, R9, 4 */
		/* 821EDFC4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 821EDFC4h case   19:*/		return 0x821EDFC8;
	}
	return 0x821EDFC8;
} // Block from 821EDF78h-821EDFC8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EDFC8h
// Function '?ImportASMNodeList@Compiler@D3DXShader@@AAAPAVCNode@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EDFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EDFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EDFC8);
		  /* 821EDFC8h */ case    0:  		/* stw R8, <#[R3 + 16]> */
		/* 821EDFC8h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 821EDFC8h case    0:*/		return 0x821EDFCC;
		  /* 821EDFCCh */ case    1:  		/* addi R9, R9, -36 */
		/* 821EDFCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFDC);
		/* 821EDFCCh case    1:*/		return 0x821EDFD0;
		  /* 821EDFD0h */ case    2:  		/* stw R11, <#[R3 + 24]> */
		/* 821EDFD0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 821EDFD0h case    2:*/		return 0x821EDFD4;
		  /* 821EDFD4h */ case    3:  		/* ori R6, R5, 1 */
		/* 821EDFD4h case    3:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R5,0x1);
		/* 821EDFD4h case    3:*/		return 0x821EDFD8;
		  /* 821EDFD8h */ case    4:  		/* ori R11, R10, 1 */
		/* 821EDFD8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0x1);
		/* 821EDFD8h case    4:*/		return 0x821EDFDC;
		  /* 821EDFDCh */ case    5:  		/* ori R9, R9, 1 */
		/* 821EDFDCh case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821EDFDCh case    5:*/		return 0x821EDFE0;
		  /* 821EDFE0h */ case    6:  		/* stw R6, <#[R3 + 28]> */
		/* 821EDFE0h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000001C) );
		/* 821EDFE0h case    6:*/		return 0x821EDFE4;
		  /* 821EDFE4h */ case    7:  		/* stw R11, <#[R3 + 32]> */
		/* 821EDFE4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 821EDFE4h case    7:*/		return 0x821EDFE8;
		  /* 821EDFE8h */ case    8:  		/* li R7, 1 */
		/* 821EDFE8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EDFE8h case    8:*/		return 0x821EDFEC;
		  /* 821EDFECh */ case    9:  		/* stw R9, <#[R3 + 36]> */
		/* 821EDFECh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000024) );
		/* 821EDFECh case    9:*/		return 0x821EDFF0;
		  /* 821EDFF0h */ case   10:  		/* lwz R10, <#[R3 + 76]> */
		/* 821EDFF0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000004C) );
		/* 821EDFF0h case   10:*/		return 0x821EDFF4;
		  /* 821EDFF4h */ case   11:  		/* lwz R11, <#[R3 + 68]> */
		/* 821EDFF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 821EDFF4h case   11:*/		return 0x821EDFF8;
		  /* 821EDFF8h */ case   12:  		/* rlwimi R11, R7, 0, 4, 31 */
		/* 821EDFF8h case   12:*/		cpu::op::rlwimi<0,0,4,31>(regs,&regs.R11,regs.R7);
		/* 821EDFF8h case   12:*/		return 0x821EDFFC;
		  /* 821EDFFCh */ case   13:  		/* stw R11, <#[R3 + 68]> */
		/* 821EDFFCh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 821EDFFCh case   13:*/		return 0x821EE000;
		  /* 821EE000h */ case   14:  		/* lwz R11, <#[R31 + 32]> */
		/* 821EE000h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 821EE000h case   14:*/		return 0x821EE004;
		  /* 821EE004h */ case   15:  		/* rlwimi R11, R10, 0, 0, 12 */
		/* 821EE004h case   15:*/		cpu::op::rlwimi<0,0,0,12>(regs,&regs.R11,regs.R10);
		/* 821EE004h case   15:*/		return 0x821EE008;
		  /* 821EE008h */ case   16:  		/* stw R11, <#[R3 + 76]> */
		/* 821EE008h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 821EE008h case   16:*/		return 0x821EE00C;
		  /* 821EE00Ch */ case   17:  		/* lwz R10, <#[R31 + 40]> */
		/* 821EE00Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 821EE00Ch case   17:*/		return 0x821EE010;
		  /* 821EE010h */ case   18:  		/* rlwinm. R10, R10, 0, 2, 2 */
		/* 821EE010h case   18:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R10);
		/* 821EE010h case   18:*/		return 0x821EE014;
		  /* 821EE014h */ case   19:  		/* bc 12, CR0_EQ, 12 */
		/* 821EE014h case   19:*/		if ( regs.CR[0].eq ) { return 0x821EE020;  }
		/* 821EE014h case   19:*/		return 0x821EE018;
		  /* 821EE018h */ case   20:  		/* oris R11, R11, 8 */
		/* 821EE018h case   20:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821EE018h case   20:*/		return 0x821EE01C;
		  /* 821EE01Ch */ case   21:  		/* stw R11, <#[R3 + 76]> */
		/* 821EE01Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000004C) );
		/* 821EE01Ch case   21:*/		return 0x821EE020;
	}
	return 0x821EE020;
} // Block from 821EDFC8h-821EE020h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EE020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE020);
		  /* 821EE020h */ case    0:  		/* lwz R9, <#[R31]> */
		/* 821EE020h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821EE020h case    0:*/		return 0x821EE024;
		  /* 821EE024h */ case    1:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821EE024h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821EE024h case    1:*/		return 0x821EE028;
		  /* 821EE028h */ case    2:  		/* ori R8, R31, 1 */
		/* 821EE028h case    2:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 821EE028h case    2:*/		return 0x821EE02C;
		  /* 821EE02Ch */ case    3:  		/* addi R10, R11, 4 */
		/* 821EE02Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821EE02Ch case    3:*/		return 0x821EE030;
		  /* 821EE030h */ case    4:  		/* stw R9, <#[R11]> */
		/* 821EE030h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE030h case    4:*/		return 0x821EE034;
		  /* 821EE034h */ case    5:  		/* lwz R9, <#[R31]> */
		/* 821EE034h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821EE034h case    5:*/		return 0x821EE038;
		  /* 821EE038h */ case    6:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821EE038h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821EE038h case    6:*/		return 0x821EE03C;
		  /* 821EE03Ch */ case    7:  		/* stw R11, <#[R9]> */
		/* 821EE03Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821EE03Ch case    7:*/		return 0x821EE040;
		  /* 821EE040h */ case    8:  		/* stw R8, <#[R11 + 4]> */
		/* 821EE040h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE040h case    8:*/		return 0x821EE044;
		  /* 821EE044h */ case    9:  		/* stw R10, <#[R31]> */
		/* 821EE044h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821EE044h case    9:*/		return 0x821EE048;
		  /* 821EE048h */ case   10:  		/* addi R1, R1, 96 */
		/* 821EE048h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821EE048h case   10:*/		return 0x821EE04C;
		  /* 821EE04Ch */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 821EE04Ch case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821EE04Ch case   11:*/		return 0x821EE050;
		  /* 821EE050h */ case   12:  		/* mtspr LR, R12 */
		/* 821EE050h case   12:*/		regs.LR = regs.R12;
		/* 821EE050h case   12:*/		return 0x821EE054;
		  /* 821EE054h */ case   13:  		/* ld R31, <#[R1 - 16]> */
		/* 821EE054h case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821EE054h case   13:*/		return 0x821EE058;
		  /* 821EE058h */ case   14:  		/* bclr 20, CR0_LT */
		/* 821EE058h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821EE058h case   14:*/		return 0x821EE05C;
	}
	return 0x821EE05C;
} // Block from 821EE020h-821EE05Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821EE05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE05C);
		  /* 821EE05Ch */ case    0:  		/* nop */
		/* 821EE05Ch case    0:*/		cpu::op::nop();
		/* 821EE05Ch case    0:*/		return 0x821EE060;
	}
	return 0x821EE060;
} // Block from 821EE05Ch-821EE060h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821EE060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE060);
		  /* 821EE060h */ case    0:  		/* mfspr R12, LR */
		/* 821EE060h case    0:*/		regs.R12 = regs.LR;
		/* 821EE060h case    0:*/		return 0x821EE064;
		  /* 821EE064h */ case    1:  		/* bl -1429000 */
		/* 821EE064h case    1:*/		regs.LR = 0x821EE068; return 0x8209125C;
		/* 821EE064h case    1:*/		return 0x821EE068;
		  /* 821EE068h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EE068h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EE068h case    2:*/		return 0x821EE06C;
		  /* 821EE06Ch */ case    3:  		/* mr R29, R4 */
		/* 821EE06Ch case    3:*/		regs.R29 = regs.R4;
		/* 821EE06Ch case    3:*/		return 0x821EE070;
		  /* 821EE070h */ case    4:  		/* li R5, 5 */
		/* 821EE070h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 821EE070h case    4:*/		return 0x821EE074;
		  /* 821EE074h */ case    5:  		/* li R4, 124 */
		/* 821EE074h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x7C);
		/* 821EE074h case    5:*/		return 0x821EE078;
		  /* 821EE078h */ case    6:  		/* mr R30, R3 */
		/* 821EE078h case    6:*/		regs.R30 = regs.R3;
		/* 821EE078h case    6:*/		return 0x821EE07C;
		  /* 821EE07Ch */ case    7:  		/* bl -529620 */
		/* 821EE07Ch case    7:*/		regs.LR = 0x821EE080; return 0x8216CBA8;
		/* 821EE07Ch case    7:*/		return 0x821EE080;
		  /* 821EE080h */ case    8:  		/* addi R11, R3, 16 */
		/* 821EE080h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x10);
		/* 821EE080h case    8:*/		return 0x821EE084;
		  /* 821EE084h */ case    9:  		/* addi R10, R3, 24 */
		/* 821EE084h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x18);
		/* 821EE084h case    9:*/		return 0x821EE088;
		  /* 821EE088h */ case   10:  		/* addi R6, R11, -36 */
		/* 821EE088h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFDC);
		/* 821EE088h case   10:*/		return 0x821EE08C;
		  /* 821EE08Ch */ case   11:  		/* addi R9, R3, 32 */
		/* 821EE08Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x20);
		/* 821EE08Ch case   11:*/		return 0x821EE090;
		  /* 821EE090h */ case   12:  		/* addi R8, R11, 4 */
		/* 821EE090h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 821EE090h case   12:*/		return 0x821EE094;
		  /* 821EE094h */ case   13:  		/* addi R11, R10, 4 */
		/* 821EE094h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 821EE094h case   13:*/		return 0x821EE098;
		  /* 821EE098h */ case   14:  		/* addi R5, R10, -36 */
		/* 821EE098h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFFDC);
		/* 821EE098h case   14:*/		return 0x821EE09C;
		  /* 821EE09Ch */ case   15:  		/* ori R6, R6, 1 */
		/* 821EE09Ch case   15:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE09Ch case   15:*/		return 0x821EE0A0;
		  /* 821EE0A0h */ case   16:  		/* addi R10, R9, 4 */
		/* 821EE0A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 821EE0A0h case   16:*/		return 0x821EE0A4;
		  /* 821EE0A4h */ case   17:  		/* addi R9, R9, -36 */
		/* 821EE0A4h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFDC);
		/* 821EE0A4h case   17:*/		return 0x821EE0A8;
		  /* 821EE0A8h */ case   18:  		/* stw R6, <#[R3 + 20]> */
		/* 821EE0A8h case   18:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 821EE0A8h case   18:*/		return 0x821EE0AC;
		  /* 821EE0ACh */ case   19:  		/* ori R8, R8, 1 */
		/* 821EE0ACh case   19:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EE0ACh case   19:*/		return 0x821EE0B0;
		  /* 821EE0B0h */ case   20:  		/* ori R11, R11, 1 */
		/* 821EE0B0h case   20:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821EE0B0h case   20:*/		return 0x821EE0B4;
		  /* 821EE0B4h */ case   21:  		/* ori R6, R5, 1 */
		/* 821EE0B4h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R5,0x1);
		/* 821EE0B4h case   21:*/		return 0x821EE0B8;
		  /* 821EE0B8h */ case   22:  		/* stw R8, <#[R3 + 16]> */
		/* 821EE0B8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 821EE0B8h case   22:*/		return 0x821EE0BC;
		  /* 821EE0BCh */ case   23:  		/* ori R10, R10, 1 */
		/* 821EE0BCh case   23:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821EE0BCh case   23:*/		return 0x821EE0C0;
		  /* 821EE0C0h */ case   24:  		/* stw R11, <#[R3 + 24]> */
		/* 821EE0C0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 821EE0C0h case   24:*/		return 0x821EE0C4;
		  /* 821EE0C4h */ case   25:  		/* ori R9, R9, 1 */
		/* 821EE0C4h case   25:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821EE0C4h case   25:*/		return 0x821EE0C8;
		  /* 821EE0C8h */ case   26:  		/* stw R6, <#[R3 + 28]> */
		/* 821EE0C8h case   26:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000001C) );
		/* 821EE0C8h case   26:*/		return 0x821EE0CC;
		  /* 821EE0CCh */ case   27:  		/* stw R10, <#[R3 + 32]> */
		/* 821EE0CCh case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 821EE0CCh case   27:*/		return 0x821EE0D0;
		  /* 821EE0D0h */ case   28:  		/* li R7, 1 */
		/* 821EE0D0h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EE0D0h case   28:*/		return 0x821EE0D4;
		  /* 821EE0D4h */ case   29:  		/* stw R9, <#[R3 + 36]> */
		/* 821EE0D4h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000024) );
		/* 821EE0D4h case   29:*/		return 0x821EE0D8;
		  /* 821EE0D8h */ case   30:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821EE0D8h case   30:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821EE0D8h case   30:*/		return 0x821EE0DC;
		  /* 821EE0DCh */ case   31:  		/* lwz R6, <#[R3 + 68]> */
		/* 821EE0DCh case   31:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000044) );
		/* 821EE0DCh case   31:*/		return 0x821EE0E0;
		  /* 821EE0E0h */ case   32:  		/* ori R9, R30, 1 */
		/* 821EE0E0h case   32:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R30,0x1);
		/* 821EE0E0h case   32:*/		return 0x821EE0E4;
		  /* 821EE0E4h */ case   33:  		/* lwz R8, <#[R3 + 48]> */
		/* 821EE0E4h case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000030) );
		/* 821EE0E4h case   33:*/		return 0x821EE0E8;
		  /* 821EE0E8h */ case   34:  		/* oris R8, R8, 8 */
		/* 821EE0E8h case   34:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x8);
		/* 821EE0E8h case   34:*/		return 0x821EE0EC;
		  /* 821EE0ECh */ case   35:  		/* rlwimi R6, R7, 0, 4, 31 */
		/* 821EE0ECh case   35:*/		cpu::op::rlwimi<0,0,4,31>(regs,&regs.R6,regs.R7);
		/* 821EE0ECh case   35:*/		return 0x821EE0F0;
		  /* 821EE0F0h */ case   36:  		/* stw R8, <#[R3 + 48]> */
		/* 821EE0F0h case   36:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000030) );
		/* 821EE0F0h case   36:*/		return 0x821EE0F4;
		  /* 821EE0F4h */ case   37:  		/* addi R10, R11, 4 */
		/* 821EE0F4h case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821EE0F4h case   37:*/		return 0x821EE0F8;
		  /* 821EE0F8h */ case   38:  		/* stw R6, <#[R3 + 68]> */
		/* 821EE0F8h case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000044) );
		/* 821EE0F8h case   38:*/		return 0x821EE0FC;
		  /* 821EE0FCh */ case   39:  		/* mr R31, R3 */
		/* 821EE0FCh case   39:*/		regs.R31 = regs.R3;
		/* 821EE0FCh case   39:*/		return 0x821EE100;
		  /* 821EE100h */ case   40:  		/* stw R29, <#[R3 + 116]> */
		/* 821EE100h case   40:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000074) );
		/* 821EE100h case   40:*/		return 0x821EE104;
		  /* 821EE104h */ case   41:  		/* lwz R8, <#[R30]> */
		/* 821EE104h case   41:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 821EE104h case   41:*/		return 0x821EE108;
		  /* 821EE108h */ case   42:  		/* stw R8, <#[R11]> */
		/* 821EE108h case   42:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE108h case   42:*/		return 0x821EE10C;
		  /* 821EE10Ch */ case   43:  		/* lwz R8, <#[R30]> */
		/* 821EE10Ch case   43:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 821EE10Ch case   43:*/		return 0x821EE110;
		  /* 821EE110h */ case   44:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821EE110h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821EE110h case   44:*/		return 0x821EE114;
		  /* 821EE114h */ case   45:  		/* stw R11, <#[R8]> */
		/* 821EE114h case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821EE114h case   45:*/		return 0x821EE118;
	}
	return 0x821EE118;
} // Block from 821EE060h-821EE118h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821EE118h
// Function '?CreateSimpleTypeNode@Compiler@D3DXShader@@AAAPAVCNodeType@2@W4_D3DCOMPONENT_TYPE@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE118);
		  /* 821EE118h */ case    0:  		/* stw R9, <#[R11 + 4]> */
		/* 821EE118h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE118h case    0:*/		return 0x821EE11C;
		  /* 821EE11Ch */ case    1:  		/* lwz R11, <#[R30 + 744]> */
		/* 821EE11Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000002E8) );
		/* 821EE11Ch case    1:*/		return 0x821EE120;
		  /* 821EE120h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821EE120h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE120h case    2:*/		return 0x821EE124;
		  /* 821EE124h */ case    3:  		/* stw R10, <#[R30]> */
		/* 821EE124h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821EE124h case    3:*/		return 0x821EE128;
		  /* 821EE128h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE128h case    4:*/		if ( regs.CR[6].eq ) { return 0x821EE13C;  }
		/* 821EE128h case    4:*/		return 0x821EE12C;
		  /* 821EE12Ch */ case    5:  		/* mr R4, R3 */
		/* 821EE12Ch case    5:*/		regs.R4 = regs.R3;
		/* 821EE12Ch case    5:*/		return 0x821EE130;
		  /* 821EE130h */ case    6:  		/* mr R5, R29 */
		/* 821EE130h case    6:*/		regs.R5 = regs.R29;
		/* 821EE130h case    6:*/		return 0x821EE134;
		  /* 821EE134h */ case    7:  		/* mr R3, R30 */
		/* 821EE134h case    7:*/		regs.R3 = regs.R30;
		/* 821EE134h case    7:*/		return 0x821EE138;
		  /* 821EE138h */ case    8:  		/* bl -2360 */
		/* 821EE138h case    8:*/		regs.LR = 0x821EE13C; return 0x821ED800;
		/* 821EE138h case    8:*/		return 0x821EE13C;
	}
	return 0x821EE13C;
} // Block from 821EE118h-821EE13Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EE13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE13C);
		  /* 821EE13Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE13Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE13Ch case    0:*/		return 0x821EE140;
		  /* 821EE140h */ case    1:  		/* addi R1, R1, 112 */
		/* 821EE140h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EE140h case    1:*/		return 0x821EE144;
		  /* 821EE144h */ case    2:  		/* b -1429144 */
		/* 821EE144h case    2:*/		return 0x820912AC;
		/* 821EE144h case    2:*/		return 0x821EE148;
	}
	return 0x821EE148;
} // Block from 821EE13Ch-821EE148h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EE148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE148);
		  /* 821EE148h */ case    0:  		/* mfspr R12, LR */
		/* 821EE148h case    0:*/		regs.R12 = regs.LR;
		/* 821EE148h case    0:*/		return 0x821EE14C;
		  /* 821EE14Ch */ case    1:  		/* bl -1429236 */
		/* 821EE14Ch case    1:*/		regs.LR = 0x821EE150; return 0x82091258;
		/* 821EE14Ch case    1:*/		return 0x821EE150;
		  /* 821EE150h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE150h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE150h case    2:*/		return 0x821EE154;
		  /* 821EE154h */ case    3:  		/* mr R28, R5 */
		/* 821EE154h case    3:*/		regs.R28 = regs.R5;
		/* 821EE154h case    3:*/		return 0x821EE158;
		  /* 821EE158h */ case    4:  		/* li R8, 4 */
		/* 821EE158h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE158h case    4:*/		return 0x821EE15C;
		  /* 821EE15Ch */ case    5:  		/* li R7, 2 */
		/* 821EE15Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE15Ch case    5:*/		return 0x821EE160;
		  /* 821EE160h */ case    6:  		/* li R6, 1 */
		/* 821EE160h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821EE160h case    6:*/		return 0x821EE164;
		  /* 821EE164h */ case    7:  		/* li R5, 0 */
		/* 821EE164h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE164h case    7:*/		return 0x821EE168;
		  /* 821EE168h */ case    8:  		/* mr R29, R4 */
		/* 821EE168h case    8:*/		regs.R29 = regs.R4;
		/* 821EE168h case    8:*/		return 0x821EE16C;
		  /* 821EE16Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE16Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE16Ch case    9:*/		return 0x821EE170;
		  /* 821EE170h */ case   10:  		/* mr R30, R3 */
		/* 821EE170h case   10:*/		regs.R30 = regs.R3;
		/* 821EE170h case   10:*/		return 0x821EE174;
		  /* 821EE174h */ case   11:  		/* bl 223268 */
		/* 821EE174h case   11:*/		regs.LR = 0x821EE178; return 0x82224998;
		/* 821EE174h case   11:*/		return 0x821EE178;
	}
	return 0x821EE178;
} // Block from 821EE148h-821EE178h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EE178h
// Function '?ApplyBranchAttributes@Compiler@D3DXShader@@AAAXPAVInstruction@2@PAUCommittedAttributeState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE178);
		  /* 821EE178h */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE178h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE178h case    0:*/		return 0x821EE17C;
		  /* 821EE17Ch */ case    1:  		/* mr R31, R3 */
		/* 821EE17Ch case    1:*/		regs.R31 = regs.R3;
		/* 821EE17Ch case    1:*/		return 0x821EE180;
		  /* 821EE180h */ case    2:  		/* mr R4, R29 */
		/* 821EE180h case    2:*/		regs.R4 = regs.R29;
		/* 821EE180h case    2:*/		return 0x821EE184;
		  /* 821EE184h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821EE184h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE184h case    3:*/		return 0x821EE188;
		  /* 821EE188h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE188h case    4:*/		if ( regs.CR[6].eq ) { return 0x821EE19C;  }
		/* 821EE188h case    4:*/		return 0x821EE18C;
		  /* 821EE18Ch */ case    5:  		/* mr R3, R30 */
		/* 821EE18Ch case    5:*/		regs.R3 = regs.R30;
		/* 821EE18Ch case    5:*/		return 0x821EE190;
		  /* 821EE190h */ case    6:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE190h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE190h case    6:*/		return 0x821EE194;
		  /* 821EE194h */ case    7:  		/* bl -512164 */
		/* 821EE194h case    7:*/		regs.LR = 0x821EE198; return 0x821710F0;
		/* 821EE194h case    7:*/		return 0x821EE198;
		  /* 821EE198h */ case    8:  		/* mr R4, R3 */
		/* 821EE198h case    8:*/		regs.R4 = regs.R3;
		/* 821EE198h case    8:*/		return 0x821EE19C;
	}
	return 0x821EE19C;
} // Block from 821EE178h-821EE19Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821EE19Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE19C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE19C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE19C);
		  /* 821EE19Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE19Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE19Ch case    0:*/		return 0x821EE1A0;
		  /* 821EE1A0h */ case    1:  		/* bl -483288 */
		/* 821EE1A0h case    1:*/		regs.LR = 0x821EE1A4; return 0x821781C8;
		/* 821EE1A0h case    1:*/		return 0x821EE1A4;
		  /* 821EE1A4h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE1A4h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE1A4h case    2:*/		return 0x821EE1A8;
		  /* 821EE1A8h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE1A8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE1A8h case    3:*/		return 0x821EE1AC;
		  /* 821EE1ACh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE1ACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE1ACh case    4:*/		return 0x821EE1B0;
		  /* 821EE1B0h */ case    5:  		/* mr R4, R28 */
		/* 821EE1B0h case    5:*/		regs.R4 = regs.R28;
		/* 821EE1B0h case    5:*/		return 0x821EE1B4;
		  /* 821EE1B4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE1B4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE1C8;  }
		/* 821EE1B4h case    6:*/		return 0x821EE1B8;
		  /* 821EE1B8h */ case    7:  		/* mr R3, R30 */
		/* 821EE1B8h case    7:*/		regs.R3 = regs.R30;
		/* 821EE1B8h case    7:*/		return 0x821EE1BC;
		  /* 821EE1BCh */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE1BCh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE1BCh case    8:*/		return 0x821EE1C0;
		  /* 821EE1C0h */ case    9:  		/* bl -512208 */
		/* 821EE1C0h case    9:*/		regs.LR = 0x821EE1C4; return 0x821710F0;
		/* 821EE1C0h case    9:*/		return 0x821EE1C4;
		  /* 821EE1C4h */ case   10:  		/* mr R4, R3 */
		/* 821EE1C4h case   10:*/		regs.R4 = regs.R3;
		/* 821EE1C4h case   10:*/		return 0x821EE1C8;
	}
	return 0x821EE1C8;
} // Block from 821EE19Ch-821EE1C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EE1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE1C8);
		  /* 821EE1C8h */ case    0:  		/* mr R3, R31 */
		/* 821EE1C8h case    0:*/		regs.R3 = regs.R31;
		/* 821EE1C8h case    0:*/		return 0x821EE1CC;
		  /* 821EE1CCh */ case    1:  		/* bl -483332 */
		/* 821EE1CCh case    1:*/		regs.LR = 0x821EE1D0; return 0x821781C8;
		/* 821EE1CCh case    1:*/		return 0x821EE1D0;
		  /* 821EE1D0h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE1D0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE1D0h case    2:*/		return 0x821EE1D4;
		  /* 821EE1D4h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE1D4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE1D4h case    3:*/		return 0x821EE1D8;
		  /* 821EE1D8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE1D8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE1D8h case    4:*/		return 0x821EE1DC;
		  /* 821EE1DCh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE1DCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE1DCh case    5:*/		return 0x821EE1E0;
		  /* 821EE1E0h */ case    6:  		/* mr R3, R31 */
		/* 821EE1E0h case    6:*/		regs.R3 = regs.R31;
		/* 821EE1E0h case    6:*/		return 0x821EE1E4;
		  /* 821EE1E4h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE1E4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE1E4h case    7:*/		return 0x821EE1E8;
		  /* 821EE1E8h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE1E8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE1E8h case    8:*/		return 0x821EE1EC;
		  /* 821EE1ECh */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE1ECh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE1ECh case    9:*/		return 0x821EE1F0;
		  /* 821EE1F0h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE1F0h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE1F0h case   10:*/		return 0x821EE1F4;
		  /* 821EE1F4h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EE1F4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE1F4h case   11:*/		return 0x821EE1F8;
		  /* 821EE1F8h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE1F8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE1F8h case   12:*/		return 0x821EE1FC;
		  /* 821EE1FCh */ case   13:  		/* addi R9, R11, 4 */
		/* 821EE1FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE1FCh case   13:*/		return 0x821EE200;
		  /* 821EE200h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE200h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE200h case   14:*/		return 0x821EE204;
		  /* 821EE204h */ case   15:  		/* addi R10, R10, 24 */
		/* 821EE204h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE204h case   15:*/		return 0x821EE208;
		  /* 821EE208h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EE208h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE208h case   16:*/		return 0x821EE20C;
		  /* 821EE20Ch */ case   17:  		/* addi R6, R10, -36 */
		/* 821EE20Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE20Ch case   17:*/		return 0x821EE210;
		  /* 821EE210h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EE210h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE210h case   18:*/		return 0x821EE214;
		  /* 821EE214h */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EE214h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE214h case   19:*/		return 0x821EE218;
		  /* 821EE218h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE218h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE218h case   20:*/		return 0x821EE21C;
		  /* 821EE21Ch */ case   21:  		/* ori R6, R6, 1 */
		/* 821EE21Ch case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE21Ch case   21:*/		return 0x821EE220;
		  /* 821EE220h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EE220h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE220h case   22:*/		return 0x821EE224;
		  /* 821EE224h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE224h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE224h case   23:*/		return 0x821EE228;
		  /* 821EE228h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EE228h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE228h case   24:*/		return 0x821EE22C;
		  /* 821EE22Ch */ case   25:  		/* addi R1, R1, 128 */
		/* 821EE22Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE22Ch case   25:*/		return 0x821EE230;
		  /* 821EE230h */ case   26:  		/* b -1429384 */
		/* 821EE230h case   26:*/		return 0x820912A8;
		/* 821EE230h case   26:*/		return 0x821EE234;
		  /* 821EE234h */ case   27:  		/* nop */
		/* 821EE234h case   27:*/		cpu::op::nop();
		/* 821EE234h case   27:*/		return 0x821EE238;
	}
	return 0x821EE238;
} // Block from 821EE1C8h-821EE238h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EE238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE238);
		  /* 821EE238h */ case    0:  		/* mfspr R12, LR */
		/* 821EE238h case    0:*/		regs.R12 = regs.LR;
		/* 821EE238h case    0:*/		return 0x821EE23C;
		  /* 821EE23Ch */ case    1:  		/* bl -1429476 */
		/* 821EE23Ch case    1:*/		regs.LR = 0x821EE240; return 0x82091258;
		/* 821EE23Ch case    1:*/		return 0x821EE240;
		  /* 821EE240h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE240h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE240h case    2:*/		return 0x821EE244;
		  /* 821EE244h */ case    3:  		/* mr R28, R5 */
		/* 821EE244h case    3:*/		regs.R28 = regs.R5;
		/* 821EE244h case    3:*/		return 0x821EE248;
		  /* 821EE248h */ case    4:  		/* li R8, 4 */
		/* 821EE248h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE248h case    4:*/		return 0x821EE24C;
		  /* 821EE24Ch */ case    5:  		/* li R7, 2 */
		/* 821EE24Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE24Ch case    5:*/		return 0x821EE250;
		  /* 821EE250h */ case    6:  		/* li R6, 2 */
		/* 821EE250h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821EE250h case    6:*/		return 0x821EE254;
		  /* 821EE254h */ case    7:  		/* li R5, 0 */
		/* 821EE254h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE254h case    7:*/		return 0x821EE258;
		  /* 821EE258h */ case    8:  		/* mr R29, R4 */
		/* 821EE258h case    8:*/		regs.R29 = regs.R4;
		/* 821EE258h case    8:*/		return 0x821EE25C;
		  /* 821EE25Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE25Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE25Ch case    9:*/		return 0x821EE260;
		  /* 821EE260h */ case   10:  		/* mr R30, R3 */
		/* 821EE260h case   10:*/		regs.R30 = regs.R3;
		/* 821EE260h case   10:*/		return 0x821EE264;
		  /* 821EE264h */ case   11:  		/* bl 223028 */
		/* 821EE264h case   11:*/		regs.LR = 0x821EE268; return 0x82224998;
		/* 821EE264h case   11:*/		return 0x821EE268;
		  /* 821EE268h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE268h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE268h case   12:*/		return 0x821EE26C;
		  /* 821EE26Ch */ case   13:  		/* mr R31, R3 */
		/* 821EE26Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EE26Ch case   13:*/		return 0x821EE270;
		  /* 821EE270h */ case   14:  		/* mr R4, R29 */
		/* 821EE270h case   14:*/		regs.R4 = regs.R29;
		/* 821EE270h case   14:*/		return 0x821EE274;
		  /* 821EE274h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EE274h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE274h case   15:*/		return 0x821EE278;
		  /* 821EE278h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE278h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EE28C;  }
		/* 821EE278h case   16:*/		return 0x821EE27C;
		  /* 821EE27Ch */ case   17:  		/* mr R3, R30 */
		/* 821EE27Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EE27Ch case   17:*/		return 0x821EE280;
		  /* 821EE280h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE280h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE280h case   18:*/		return 0x821EE284;
		  /* 821EE284h */ case   19:  		/* bl -512404 */
		/* 821EE284h case   19:*/		regs.LR = 0x821EE288; return 0x821710F0;
		/* 821EE284h case   19:*/		return 0x821EE288;
		  /* 821EE288h */ case   20:  		/* mr R4, R3 */
		/* 821EE288h case   20:*/		regs.R4 = regs.R3;
		/* 821EE288h case   20:*/		return 0x821EE28C;
	}
	return 0x821EE28C;
} // Block from 821EE238h-821EE28Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EE28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE28C);
		  /* 821EE28Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE28Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE28Ch case    0:*/		return 0x821EE290;
		  /* 821EE290h */ case    1:  		/* bl -483528 */
		/* 821EE290h case    1:*/		regs.LR = 0x821EE294; return 0x821781C8;
		/* 821EE290h case    1:*/		return 0x821EE294;
		  /* 821EE294h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE294h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE294h case    2:*/		return 0x821EE298;
		  /* 821EE298h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE298h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE298h case    3:*/		return 0x821EE29C;
		  /* 821EE29Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE29Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE29Ch case    4:*/		return 0x821EE2A0;
		  /* 821EE2A0h */ case    5:  		/* mr R4, R28 */
		/* 821EE2A0h case    5:*/		regs.R4 = regs.R28;
		/* 821EE2A0h case    5:*/		return 0x821EE2A4;
		  /* 821EE2A4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE2A4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE2B8;  }
		/* 821EE2A4h case    6:*/		return 0x821EE2A8;
		  /* 821EE2A8h */ case    7:  		/* mr R3, R30 */
		/* 821EE2A8h case    7:*/		regs.R3 = regs.R30;
		/* 821EE2A8h case    7:*/		return 0x821EE2AC;
		  /* 821EE2ACh */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE2ACh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE2ACh case    8:*/		return 0x821EE2B0;
		  /* 821EE2B0h */ case    9:  		/* bl -512448 */
		/* 821EE2B0h case    9:*/		regs.LR = 0x821EE2B4; return 0x821710F0;
		/* 821EE2B0h case    9:*/		return 0x821EE2B4;
		  /* 821EE2B4h */ case   10:  		/* mr R4, R3 */
		/* 821EE2B4h case   10:*/		regs.R4 = regs.R3;
		/* 821EE2B4h case   10:*/		return 0x821EE2B8;
	}
	return 0x821EE2B8;
} // Block from 821EE28Ch-821EE2B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EE2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE2B8);
		  /* 821EE2B8h */ case    0:  		/* mr R3, R31 */
		/* 821EE2B8h case    0:*/		regs.R3 = regs.R31;
		/* 821EE2B8h case    0:*/		return 0x821EE2BC;
		  /* 821EE2BCh */ case    1:  		/* bl -483572 */
		/* 821EE2BCh case    1:*/		regs.LR = 0x821EE2C0; return 0x821781C8;
		/* 821EE2BCh case    1:*/		return 0x821EE2C0;
		  /* 821EE2C0h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE2C0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE2C0h case    2:*/		return 0x821EE2C4;
		  /* 821EE2C4h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE2C4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE2C4h case    3:*/		return 0x821EE2C8;
		  /* 821EE2C8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE2C8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE2C8h case    4:*/		return 0x821EE2CC;
		  /* 821EE2CCh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE2CCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE2CCh case    5:*/		return 0x821EE2D0;
		  /* 821EE2D0h */ case    6:  		/* mr R3, R31 */
		/* 821EE2D0h case    6:*/		regs.R3 = regs.R31;
		/* 821EE2D0h case    6:*/		return 0x821EE2D4;
		  /* 821EE2D4h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE2D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE2D4h case    7:*/		return 0x821EE2D8;
	}
	return 0x821EE2D8;
} // Block from 821EE2B8h-821EE2D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EE2D8h
// Function '?PrepareFunctionEntryBlock@Compiler@D3DXShader@@AAAXPAVBlock@2@PAUFunction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE2D8);
		  /* 821EE2D8h */ case    0:  		/* lwz R10, <#[R10]> */
		/* 821EE2D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE2D8h case    0:*/		return 0x821EE2DC;
		  /* 821EE2DCh */ case    1:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE2DCh case    1:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE2DCh case    1:*/		return 0x821EE2E0;
		  /* 821EE2E0h */ case    2:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE2E0h case    2:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE2E0h case    2:*/		return 0x821EE2E4;
		  /* 821EE2E4h */ case    3:  		/* addi R8, R11, -36 */
		/* 821EE2E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE2E4h case    3:*/		return 0x821EE2E8;
		  /* 821EE2E8h */ case    4:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE2E8h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE2E8h case    4:*/		return 0x821EE2EC;
		  /* 821EE2ECh */ case    5:  		/* addi R9, R11, 4 */
		/* 821EE2ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE2ECh case    5:*/		return 0x821EE2F0;
		  /* 821EE2F0h */ case    6:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE2F0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE2F0h case    6:*/		return 0x821EE2F4;
		  /* 821EE2F4h */ case    7:  		/* addi R10, R10, 24 */
		/* 821EE2F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE2F4h case    7:*/		return 0x821EE2F8;
		  /* 821EE2F8h */ case    8:  		/* lwz R7, <#[R10]> */
		/* 821EE2F8h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE2F8h case    8:*/		return 0x821EE2FC;
		  /* 821EE2FCh */ case    9:  		/* addi R6, R10, -36 */
		/* 821EE2FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE2FCh case    9:*/		return 0x821EE300;
		  /* 821EE300h */ case   10:  		/* stw R7, <#[R11]> */
		/* 821EE300h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE300h case   10:*/		return 0x821EE304;
		  /* 821EE304h */ case   11:  		/* lwz R7, <#[R10]> */
		/* 821EE304h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE304h case   11:*/		return 0x821EE308;
		  /* 821EE308h */ case   12:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE308h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE308h case   12:*/		return 0x821EE30C;
		  /* 821EE30Ch */ case   13:  		/* ori R6, R6, 1 */
		/* 821EE30Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE30Ch case   13:*/		return 0x821EE310;
		  /* 821EE310h */ case   14:  		/* stw R8, <#[R7]> */
		/* 821EE310h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE310h case   14:*/		return 0x821EE314;
		  /* 821EE314h */ case   15:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE314h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE314h case   15:*/		return 0x821EE318;
		  /* 821EE318h */ case   16:  		/* stw R9, <#[R10]> */
		/* 821EE318h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE318h case   16:*/		return 0x821EE31C;
		  /* 821EE31Ch */ case   17:  		/* addi R1, R1, 128 */
		/* 821EE31Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE31Ch case   17:*/		return 0x821EE320;
		  /* 821EE320h */ case   18:  		/* b -1429624 */
		/* 821EE320h case   18:*/		return 0x820912A8;
		/* 821EE320h case   18:*/		return 0x821EE324;
		  /* 821EE324h */ case   19:  		/* nop */
		/* 821EE324h case   19:*/		cpu::op::nop();
		/* 821EE324h case   19:*/		return 0x821EE328;
	}
	return 0x821EE328;
} // Block from 821EE2D8h-821EE328h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EE328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE328);
		  /* 821EE328h */ case    0:  		/* mfspr R12, LR */
		/* 821EE328h case    0:*/		regs.R12 = regs.LR;
		/* 821EE328h case    0:*/		return 0x821EE32C;
		  /* 821EE32Ch */ case    1:  		/* bl -1429716 */
		/* 821EE32Ch case    1:*/		regs.LR = 0x821EE330; return 0x82091258;
		/* 821EE32Ch case    1:*/		return 0x821EE330;
		  /* 821EE330h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE330h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE330h case    2:*/		return 0x821EE334;
		  /* 821EE334h */ case    3:  		/* mr R28, R5 */
		/* 821EE334h case    3:*/		regs.R28 = regs.R5;
		/* 821EE334h case    3:*/		return 0x821EE338;
		  /* 821EE338h */ case    4:  		/* li R8, 4 */
		/* 821EE338h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE338h case    4:*/		return 0x821EE33C;
		  /* 821EE33Ch */ case    5:  		/* li R7, 2 */
		/* 821EE33Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE33Ch case    5:*/		return 0x821EE340;
		  /* 821EE340h */ case    6:  		/* li R6, 3 */
		/* 821EE340h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821EE340h case    6:*/		return 0x821EE344;
		  /* 821EE344h */ case    7:  		/* li R5, 0 */
		/* 821EE344h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE344h case    7:*/		return 0x821EE348;
		  /* 821EE348h */ case    8:  		/* mr R29, R4 */
		/* 821EE348h case    8:*/		regs.R29 = regs.R4;
		/* 821EE348h case    8:*/		return 0x821EE34C;
		  /* 821EE34Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE34Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE34Ch case    9:*/		return 0x821EE350;
		  /* 821EE350h */ case   10:  		/* mr R30, R3 */
		/* 821EE350h case   10:*/		regs.R30 = regs.R3;
		/* 821EE350h case   10:*/		return 0x821EE354;
		  /* 821EE354h */ case   11:  		/* bl 222788 */
		/* 821EE354h case   11:*/		regs.LR = 0x821EE358; return 0x82224998;
		/* 821EE354h case   11:*/		return 0x821EE358;
		  /* 821EE358h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE358h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE358h case   12:*/		return 0x821EE35C;
		  /* 821EE35Ch */ case   13:  		/* mr R31, R3 */
		/* 821EE35Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EE35Ch case   13:*/		return 0x821EE360;
		  /* 821EE360h */ case   14:  		/* mr R4, R29 */
		/* 821EE360h case   14:*/		regs.R4 = regs.R29;
		/* 821EE360h case   14:*/		return 0x821EE364;
		  /* 821EE364h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EE364h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE364h case   15:*/		return 0x821EE368;
		  /* 821EE368h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE368h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EE37C;  }
		/* 821EE368h case   16:*/		return 0x821EE36C;
		  /* 821EE36Ch */ case   17:  		/* mr R3, R30 */
		/* 821EE36Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EE36Ch case   17:*/		return 0x821EE370;
		  /* 821EE370h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE370h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE370h case   18:*/		return 0x821EE374;
		  /* 821EE374h */ case   19:  		/* bl -512644 */
		/* 821EE374h case   19:*/		regs.LR = 0x821EE378; return 0x821710F0;
		/* 821EE374h case   19:*/		return 0x821EE378;
		  /* 821EE378h */ case   20:  		/* mr R4, R3 */
		/* 821EE378h case   20:*/		regs.R4 = regs.R3;
		/* 821EE378h case   20:*/		return 0x821EE37C;
	}
	return 0x821EE37C;
} // Block from 821EE328h-821EE37Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EE37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE37C);
		  /* 821EE37Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE37Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE37Ch case    0:*/		return 0x821EE380;
		  /* 821EE380h */ case    1:  		/* bl -483768 */
		/* 821EE380h case    1:*/		regs.LR = 0x821EE384; return 0x821781C8;
		/* 821EE380h case    1:*/		return 0x821EE384;
		  /* 821EE384h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE384h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE384h case    2:*/		return 0x821EE388;
	}
	return 0x821EE388;
} // Block from 821EE37Ch-821EE388h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821EE388h
// Function '?AddFunctionExitAnnotation@Compiler@D3DXShader@@AAAXPAVInstruction@2@PAUFunction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE388);
		  /* 821EE388h */ case    0:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE388h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE388h case    0:*/		return 0x821EE38C;
		  /* 821EE38Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821EE38Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE38Ch case    1:*/		return 0x821EE390;
		  /* 821EE390h */ case    2:  		/* mr R4, R28 */
		/* 821EE390h case    2:*/		regs.R4 = regs.R28;
		/* 821EE390h case    2:*/		return 0x821EE394;
		  /* 821EE394h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE394h case    3:*/		if ( regs.CR[6].eq ) { return 0x821EE3A8;  }
		/* 821EE394h case    3:*/		return 0x821EE398;
		  /* 821EE398h */ case    4:  		/* mr R3, R30 */
		/* 821EE398h case    4:*/		regs.R3 = regs.R30;
		/* 821EE398h case    4:*/		return 0x821EE39C;
		  /* 821EE39Ch */ case    5:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE39Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE39Ch case    5:*/		return 0x821EE3A0;
		  /* 821EE3A0h */ case    6:  		/* bl -512688 */
		/* 821EE3A0h case    6:*/		regs.LR = 0x821EE3A4; return 0x821710F0;
		/* 821EE3A0h case    6:*/		return 0x821EE3A4;
		  /* 821EE3A4h */ case    7:  		/* mr R4, R3 */
		/* 821EE3A4h case    7:*/		regs.R4 = regs.R3;
		/* 821EE3A4h case    7:*/		return 0x821EE3A8;
	}
	return 0x821EE3A8;
} // Block from 821EE388h-821EE3A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EE3A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE3A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE3A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE3A8);
		  /* 821EE3A8h */ case    0:  		/* mr R3, R31 */
		/* 821EE3A8h case    0:*/		regs.R3 = regs.R31;
		/* 821EE3A8h case    0:*/		return 0x821EE3AC;
		  /* 821EE3ACh */ case    1:  		/* bl -483812 */
		/* 821EE3ACh case    1:*/		regs.LR = 0x821EE3B0; return 0x821781C8;
		/* 821EE3ACh case    1:*/		return 0x821EE3B0;
		  /* 821EE3B0h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE3B0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE3B0h case    2:*/		return 0x821EE3B4;
		  /* 821EE3B4h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE3B4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE3B4h case    3:*/		return 0x821EE3B8;
		  /* 821EE3B8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE3B8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE3B8h case    4:*/		return 0x821EE3BC;
		  /* 821EE3BCh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE3BCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE3BCh case    5:*/		return 0x821EE3C0;
		  /* 821EE3C0h */ case    6:  		/* mr R3, R31 */
		/* 821EE3C0h case    6:*/		regs.R3 = regs.R31;
		/* 821EE3C0h case    6:*/		return 0x821EE3C4;
		  /* 821EE3C4h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE3C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE3C4h case    7:*/		return 0x821EE3C8;
		  /* 821EE3C8h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE3C8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE3C8h case    8:*/		return 0x821EE3CC;
		  /* 821EE3CCh */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE3CCh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE3CCh case    9:*/		return 0x821EE3D0;
		  /* 821EE3D0h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE3D0h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE3D0h case   10:*/		return 0x821EE3D4;
		  /* 821EE3D4h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EE3D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE3D4h case   11:*/		return 0x821EE3D8;
		  /* 821EE3D8h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE3D8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE3D8h case   12:*/		return 0x821EE3DC;
		  /* 821EE3DCh */ case   13:  		/* addi R9, R11, 4 */
		/* 821EE3DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE3DCh case   13:*/		return 0x821EE3E0;
		  /* 821EE3E0h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE3E0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE3E0h case   14:*/		return 0x821EE3E4;
		  /* 821EE3E4h */ case   15:  		/* addi R10, R10, 24 */
		/* 821EE3E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE3E4h case   15:*/		return 0x821EE3E8;
		  /* 821EE3E8h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EE3E8h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE3E8h case   16:*/		return 0x821EE3EC;
		  /* 821EE3ECh */ case   17:  		/* addi R6, R10, -36 */
		/* 821EE3ECh case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE3ECh case   17:*/		return 0x821EE3F0;
		  /* 821EE3F0h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EE3F0h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE3F0h case   18:*/		return 0x821EE3F4;
		  /* 821EE3F4h */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EE3F4h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE3F4h case   19:*/		return 0x821EE3F8;
		  /* 821EE3F8h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE3F8h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE3F8h case   20:*/		return 0x821EE3FC;
		  /* 821EE3FCh */ case   21:  		/* ori R6, R6, 1 */
		/* 821EE3FCh case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE3FCh case   21:*/		return 0x821EE400;
		  /* 821EE400h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EE400h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE400h case   22:*/		return 0x821EE404;
		  /* 821EE404h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE404h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE404h case   23:*/		return 0x821EE408;
		  /* 821EE408h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EE408h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE408h case   24:*/		return 0x821EE40C;
		  /* 821EE40Ch */ case   25:  		/* addi R1, R1, 128 */
		/* 821EE40Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE40Ch case   25:*/		return 0x821EE410;
		  /* 821EE410h */ case   26:  		/* b -1429864 */
		/* 821EE410h case   26:*/		return 0x820912A8;
		/* 821EE410h case   26:*/		return 0x821EE414;
		  /* 821EE414h */ case   27:  		/* nop */
		/* 821EE414h case   27:*/		cpu::op::nop();
		/* 821EE414h case   27:*/		return 0x821EE418;
	}
	return 0x821EE418;
} // Block from 821EE3A8h-821EE418h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EE418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE418);
		  /* 821EE418h */ case    0:  		/* mfspr R12, LR */
		/* 821EE418h case    0:*/		regs.R12 = regs.LR;
		/* 821EE418h case    0:*/		return 0x821EE41C;
		  /* 821EE41Ch */ case    1:  		/* bl -1429956 */
		/* 821EE41Ch case    1:*/		regs.LR = 0x821EE420; return 0x82091258;
		/* 821EE41Ch case    1:*/		return 0x821EE420;
		  /* 821EE420h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE420h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE420h case    2:*/		return 0x821EE424;
		  /* 821EE424h */ case    3:  		/* mr R28, R5 */
		/* 821EE424h case    3:*/		regs.R28 = regs.R5;
		/* 821EE424h case    3:*/		return 0x821EE428;
		  /* 821EE428h */ case    4:  		/* li R8, 4 */
		/* 821EE428h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE428h case    4:*/		return 0x821EE42C;
		  /* 821EE42Ch */ case    5:  		/* li R7, 2 */
		/* 821EE42Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE42Ch case    5:*/		return 0x821EE430;
		  /* 821EE430h */ case    6:  		/* li R6, 4 */
		/* 821EE430h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 821EE430h case    6:*/		return 0x821EE434;
		  /* 821EE434h */ case    7:  		/* li R5, 0 */
		/* 821EE434h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE434h case    7:*/		return 0x821EE438;
		  /* 821EE438h */ case    8:  		/* mr R29, R4 */
		/* 821EE438h case    8:*/		regs.R29 = regs.R4;
		/* 821EE438h case    8:*/		return 0x821EE43C;
		  /* 821EE43Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE43Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE43Ch case    9:*/		return 0x821EE440;
		  /* 821EE440h */ case   10:  		/* mr R30, R3 */
		/* 821EE440h case   10:*/		regs.R30 = regs.R3;
		/* 821EE440h case   10:*/		return 0x821EE444;
		  /* 821EE444h */ case   11:  		/* bl 222548 */
		/* 821EE444h case   11:*/		regs.LR = 0x821EE448; return 0x82224998;
		/* 821EE444h case   11:*/		return 0x821EE448;
		  /* 821EE448h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE448h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE448h case   12:*/		return 0x821EE44C;
		  /* 821EE44Ch */ case   13:  		/* mr R31, R3 */
		/* 821EE44Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EE44Ch case   13:*/		return 0x821EE450;
		  /* 821EE450h */ case   14:  		/* mr R4, R29 */
		/* 821EE450h case   14:*/		regs.R4 = regs.R29;
		/* 821EE450h case   14:*/		return 0x821EE454;
		  /* 821EE454h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EE454h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE454h case   15:*/		return 0x821EE458;
	}
	return 0x821EE458;
} // Block from 821EE418h-821EE458h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EE458h
// Function '?GetScalarDependency@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@W4Component@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE458);
		  /* 821EE458h */ case    0:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE458h case    0:*/		if ( regs.CR[6].eq ) { return 0x821EE46C;  }
		/* 821EE458h case    0:*/		return 0x821EE45C;
		  /* 821EE45Ch */ case    1:  		/* mr R3, R30 */
		/* 821EE45Ch case    1:*/		regs.R3 = regs.R30;
		/* 821EE45Ch case    1:*/		return 0x821EE460;
		  /* 821EE460h */ case    2:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE460h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE460h case    2:*/		return 0x821EE464;
		  /* 821EE464h */ case    3:  		/* bl -512884 */
		/* 821EE464h case    3:*/		regs.LR = 0x821EE468; return 0x821710F0;
		/* 821EE464h case    3:*/		return 0x821EE468;
		  /* 821EE468h */ case    4:  		/* mr R4, R3 */
		/* 821EE468h case    4:*/		regs.R4 = regs.R3;
		/* 821EE468h case    4:*/		return 0x821EE46C;
	}
	return 0x821EE46C;
} // Block from 821EE458h-821EE46Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821EE46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE46C);
		  /* 821EE46Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE46Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE46Ch case    0:*/		return 0x821EE470;
		  /* 821EE470h */ case    1:  		/* bl -484008 */
		/* 821EE470h case    1:*/		regs.LR = 0x821EE474; return 0x821781C8;
		/* 821EE470h case    1:*/		return 0x821EE474;
		  /* 821EE474h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE474h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE474h case    2:*/		return 0x821EE478;
		  /* 821EE478h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE478h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE478h case    3:*/		return 0x821EE47C;
		  /* 821EE47Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE47Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE47Ch case    4:*/		return 0x821EE480;
		  /* 821EE480h */ case    5:  		/* mr R4, R28 */
		/* 821EE480h case    5:*/		regs.R4 = regs.R28;
		/* 821EE480h case    5:*/		return 0x821EE484;
		  /* 821EE484h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE484h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE498;  }
		/* 821EE484h case    6:*/		return 0x821EE488;
		  /* 821EE488h */ case    7:  		/* mr R3, R30 */
		/* 821EE488h case    7:*/		regs.R3 = regs.R30;
		/* 821EE488h case    7:*/		return 0x821EE48C;
		  /* 821EE48Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE48Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE48Ch case    8:*/		return 0x821EE490;
		  /* 821EE490h */ case    9:  		/* bl -512928 */
		/* 821EE490h case    9:*/		regs.LR = 0x821EE494; return 0x821710F0;
		/* 821EE490h case    9:*/		return 0x821EE494;
		  /* 821EE494h */ case   10:  		/* mr R4, R3 */
		/* 821EE494h case   10:*/		regs.R4 = regs.R3;
		/* 821EE494h case   10:*/		return 0x821EE498;
	}
	return 0x821EE498;
} // Block from 821EE46Ch-821EE498h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EE498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE498);
		  /* 821EE498h */ case    0:  		/* mr R3, R31 */
		/* 821EE498h case    0:*/		regs.R3 = regs.R31;
		/* 821EE498h case    0:*/		return 0x821EE49C;
		  /* 821EE49Ch */ case    1:  		/* bl -484052 */
		/* 821EE49Ch case    1:*/		regs.LR = 0x821EE4A0; return 0x821781C8;
		/* 821EE49Ch case    1:*/		return 0x821EE4A0;
		  /* 821EE4A0h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE4A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE4A0h case    2:*/		return 0x821EE4A4;
		  /* 821EE4A4h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE4A4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE4A4h case    3:*/		return 0x821EE4A8;
		  /* 821EE4A8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE4A8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE4A8h case    4:*/		return 0x821EE4AC;
		  /* 821EE4ACh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE4ACh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE4ACh case    5:*/		return 0x821EE4B0;
		  /* 821EE4B0h */ case    6:  		/* mr R3, R31 */
		/* 821EE4B0h case    6:*/		regs.R3 = regs.R31;
		/* 821EE4B0h case    6:*/		return 0x821EE4B4;
		  /* 821EE4B4h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE4B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE4B4h case    7:*/		return 0x821EE4B8;
		  /* 821EE4B8h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE4B8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE4B8h case    8:*/		return 0x821EE4BC;
		  /* 821EE4BCh */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE4BCh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE4BCh case    9:*/		return 0x821EE4C0;
		  /* 821EE4C0h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE4C0h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE4C0h case   10:*/		return 0x821EE4C4;
		  /* 821EE4C4h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EE4C4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE4C4h case   11:*/		return 0x821EE4C8;
		  /* 821EE4C8h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE4C8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE4C8h case   12:*/		return 0x821EE4CC;
		  /* 821EE4CCh */ case   13:  		/* addi R9, R11, 4 */
		/* 821EE4CCh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE4CCh case   13:*/		return 0x821EE4D0;
		  /* 821EE4D0h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE4D0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE4D0h case   14:*/		return 0x821EE4D4;
		  /* 821EE4D4h */ case   15:  		/* addi R10, R10, 24 */
		/* 821EE4D4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE4D4h case   15:*/		return 0x821EE4D8;
		  /* 821EE4D8h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EE4D8h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE4D8h case   16:*/		return 0x821EE4DC;
		  /* 821EE4DCh */ case   17:  		/* addi R6, R10, -36 */
		/* 821EE4DCh case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE4DCh case   17:*/		return 0x821EE4E0;
		  /* 821EE4E0h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EE4E0h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE4E0h case   18:*/		return 0x821EE4E4;
		  /* 821EE4E4h */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EE4E4h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE4E4h case   19:*/		return 0x821EE4E8;
		  /* 821EE4E8h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE4E8h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE4E8h case   20:*/		return 0x821EE4EC;
		  /* 821EE4ECh */ case   21:  		/* ori R6, R6, 1 */
		/* 821EE4ECh case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE4ECh case   21:*/		return 0x821EE4F0;
		  /* 821EE4F0h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EE4F0h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE4F0h case   22:*/		return 0x821EE4F4;
		  /* 821EE4F4h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE4F4h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE4F4h case   23:*/		return 0x821EE4F8;
		  /* 821EE4F8h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EE4F8h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE4F8h case   24:*/		return 0x821EE4FC;
		  /* 821EE4FCh */ case   25:  		/* addi R1, R1, 128 */
		/* 821EE4FCh case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE4FCh case   25:*/		return 0x821EE500;
		  /* 821EE500h */ case   26:  		/* b -1430104 */
		/* 821EE500h case   26:*/		return 0x820912A8;
		/* 821EE500h case   26:*/		return 0x821EE504;
		  /* 821EE504h */ case   27:  		/* nop */
		/* 821EE504h case   27:*/		cpu::op::nop();
		/* 821EE504h case   27:*/		return 0x821EE508;
	}
	return 0x821EE508;
} // Block from 821EE498h-821EE508h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EE508h
// Function '??1CNodeListWalker@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE508);
		  /* 821EE508h */ case    0:  		/* mfspr R12, LR */
		/* 821EE508h case    0:*/		regs.R12 = regs.LR;
		/* 821EE508h case    0:*/		return 0x821EE50C;
		  /* 821EE50Ch */ case    1:  		/* bl -1430196 */
		/* 821EE50Ch case    1:*/		regs.LR = 0x821EE510; return 0x82091258;
		/* 821EE50Ch case    1:*/		return 0x821EE510;
		  /* 821EE510h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE510h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE510h case    2:*/		return 0x821EE514;
		  /* 821EE514h */ case    3:  		/* mr R28, R5 */
		/* 821EE514h case    3:*/		regs.R28 = regs.R5;
		/* 821EE514h case    3:*/		return 0x821EE518;
		  /* 821EE518h */ case    4:  		/* li R8, 4 */
		/* 821EE518h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE518h case    4:*/		return 0x821EE51C;
		  /* 821EE51Ch */ case    5:  		/* li R7, 2 */
		/* 821EE51Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE51Ch case    5:*/		return 0x821EE520;
		  /* 821EE520h */ case    6:  		/* li R6, 5 */
		/* 821EE520h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 821EE520h case    6:*/		return 0x821EE524;
		  /* 821EE524h */ case    7:  		/* li R5, 0 */
		/* 821EE524h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE524h case    7:*/		return 0x821EE528;
	}
	return 0x821EE528;
} // Block from 821EE508h-821EE528h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EE528h
// Function '?GenerateSubroutineReturn@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE528);
		  /* 821EE528h */ case    0:  		/* mr R29, R4 */
		/* 821EE528h case    0:*/		regs.R29 = regs.R4;
		/* 821EE528h case    0:*/		return 0x821EE52C;
		  /* 821EE52Ch */ case    1:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE52Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE52Ch case    1:*/		return 0x821EE530;
		  /* 821EE530h */ case    2:  		/* mr R30, R3 */
		/* 821EE530h case    2:*/		regs.R30 = regs.R3;
		/* 821EE530h case    2:*/		return 0x821EE534;
		  /* 821EE534h */ case    3:  		/* bl 222308 */
		/* 821EE534h case    3:*/		regs.LR = 0x821EE538; return 0x82224998;
		/* 821EE534h case    3:*/		return 0x821EE538;
		  /* 821EE538h */ case    4:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE538h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE538h case    4:*/		return 0x821EE53C;
		  /* 821EE53Ch */ case    5:  		/* mr R31, R3 */
		/* 821EE53Ch case    5:*/		regs.R31 = regs.R3;
		/* 821EE53Ch case    5:*/		return 0x821EE540;
		  /* 821EE540h */ case    6:  		/* mr R4, R29 */
		/* 821EE540h case    6:*/		regs.R4 = regs.R29;
		/* 821EE540h case    6:*/		return 0x821EE544;
		  /* 821EE544h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EE544h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE544h case    7:*/		return 0x821EE548;
		  /* 821EE548h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE548h case    8:*/		if ( regs.CR[6].eq ) { return 0x821EE55C;  }
		/* 821EE548h case    8:*/		return 0x821EE54C;
		  /* 821EE54Ch */ case    9:  		/* mr R3, R30 */
		/* 821EE54Ch case    9:*/		regs.R3 = regs.R30;
		/* 821EE54Ch case    9:*/		return 0x821EE550;
		  /* 821EE550h */ case   10:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE550h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE550h case   10:*/		return 0x821EE554;
		  /* 821EE554h */ case   11:  		/* bl -513124 */
		/* 821EE554h case   11:*/		regs.LR = 0x821EE558; return 0x821710F0;
		/* 821EE554h case   11:*/		return 0x821EE558;
		  /* 821EE558h */ case   12:  		/* mr R4, R3 */
		/* 821EE558h case   12:*/		regs.R4 = regs.R3;
		/* 821EE558h case   12:*/		return 0x821EE55C;
	}
	return 0x821EE55C;
} // Block from 821EE528h-821EE55Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821EE55Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE55C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE55C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE55C);
		  /* 821EE55Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE55Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE55Ch case    0:*/		return 0x821EE560;
		  /* 821EE560h */ case    1:  		/* bl -484248 */
		/* 821EE560h case    1:*/		regs.LR = 0x821EE564; return 0x821781C8;
		/* 821EE560h case    1:*/		return 0x821EE564;
		  /* 821EE564h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE564h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE564h case    2:*/		return 0x821EE568;
		  /* 821EE568h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE568h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE568h case    3:*/		return 0x821EE56C;
		  /* 821EE56Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE56Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE56Ch case    4:*/		return 0x821EE570;
		  /* 821EE570h */ case    5:  		/* mr R4, R28 */
		/* 821EE570h case    5:*/		regs.R4 = regs.R28;
		/* 821EE570h case    5:*/		return 0x821EE574;
		  /* 821EE574h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE574h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE588;  }
		/* 821EE574h case    6:*/		return 0x821EE578;
		  /* 821EE578h */ case    7:  		/* mr R3, R30 */
		/* 821EE578h case    7:*/		regs.R3 = regs.R30;
		/* 821EE578h case    7:*/		return 0x821EE57C;
		  /* 821EE57Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE57Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE57Ch case    8:*/		return 0x821EE580;
		  /* 821EE580h */ case    9:  		/* bl -513168 */
		/* 821EE580h case    9:*/		regs.LR = 0x821EE584; return 0x821710F0;
		/* 821EE580h case    9:*/		return 0x821EE584;
		  /* 821EE584h */ case   10:  		/* mr R4, R3 */
		/* 821EE584h case   10:*/		regs.R4 = regs.R3;
		/* 821EE584h case   10:*/		return 0x821EE588;
	}
	return 0x821EE588;
} // Block from 821EE55Ch-821EE588h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EE588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE588);
		  /* 821EE588h */ case    0:  		/* mr R3, R31 */
		/* 821EE588h case    0:*/		regs.R3 = regs.R31;
		/* 821EE588h case    0:*/		return 0x821EE58C;
		  /* 821EE58Ch */ case    1:  		/* bl -484292 */
		/* 821EE58Ch case    1:*/		regs.LR = 0x821EE590; return 0x821781C8;
		/* 821EE58Ch case    1:*/		return 0x821EE590;
		  /* 821EE590h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE590h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE590h case    2:*/		return 0x821EE594;
		  /* 821EE594h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE594h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE594h case    3:*/		return 0x821EE598;
		  /* 821EE598h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE598h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE598h case    4:*/		return 0x821EE59C;
		  /* 821EE59Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE59Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE59Ch case    5:*/		return 0x821EE5A0;
		  /* 821EE5A0h */ case    6:  		/* mr R3, R31 */
		/* 821EE5A0h case    6:*/		regs.R3 = regs.R31;
		/* 821EE5A0h case    6:*/		return 0x821EE5A4;
		  /* 821EE5A4h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE5A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE5A4h case    7:*/		return 0x821EE5A8;
		  /* 821EE5A8h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE5A8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE5A8h case    8:*/		return 0x821EE5AC;
		  /* 821EE5ACh */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE5ACh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE5ACh case    9:*/		return 0x821EE5B0;
		  /* 821EE5B0h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE5B0h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE5B0h case   10:*/		return 0x821EE5B4;
		  /* 821EE5B4h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EE5B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE5B4h case   11:*/		return 0x821EE5B8;
		  /* 821EE5B8h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE5B8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE5B8h case   12:*/		return 0x821EE5BC;
		  /* 821EE5BCh */ case   13:  		/* addi R9, R11, 4 */
		/* 821EE5BCh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE5BCh case   13:*/		return 0x821EE5C0;
	}
	return 0x821EE5C0;
} // Block from 821EE588h-821EE5C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EE5C0h
// Function '?GetComponentFromResult@Compiler@D3DXShader@@AAA?AW4Component@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE5C0);
		  /* 821EE5C0h */ case    0:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE5C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE5C0h case    0:*/		return 0x821EE5C4;
		  /* 821EE5C4h */ case    1:  		/* addi R10, R10, 24 */
		/* 821EE5C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE5C4h case    1:*/		return 0x821EE5C8;
		  /* 821EE5C8h */ case    2:  		/* lwz R7, <#[R10]> */
		/* 821EE5C8h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE5C8h case    2:*/		return 0x821EE5CC;
		  /* 821EE5CCh */ case    3:  		/* addi R6, R10, -36 */
		/* 821EE5CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE5CCh case    3:*/		return 0x821EE5D0;
		  /* 821EE5D0h */ case    4:  		/* stw R7, <#[R11]> */
		/* 821EE5D0h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE5D0h case    4:*/		return 0x821EE5D4;
		  /* 821EE5D4h */ case    5:  		/* lwz R7, <#[R10]> */
		/* 821EE5D4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE5D4h case    5:*/		return 0x821EE5D8;
		  /* 821EE5D8h */ case    6:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE5D8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE5D8h case    6:*/		return 0x821EE5DC;
		  /* 821EE5DCh */ case    7:  		/* ori R6, R6, 1 */
		/* 821EE5DCh case    7:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE5DCh case    7:*/		return 0x821EE5E0;
		  /* 821EE5E0h */ case    8:  		/* stw R8, <#[R7]> */
		/* 821EE5E0h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE5E0h case    8:*/		return 0x821EE5E4;
		  /* 821EE5E4h */ case    9:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE5E4h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE5E4h case    9:*/		return 0x821EE5E8;
		  /* 821EE5E8h */ case   10:  		/* stw R9, <#[R10]> */
		/* 821EE5E8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE5E8h case   10:*/		return 0x821EE5EC;
		  /* 821EE5ECh */ case   11:  		/* addi R1, R1, 128 */
		/* 821EE5ECh case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE5ECh case   11:*/		return 0x821EE5F0;
		  /* 821EE5F0h */ case   12:  		/* b -1430344 */
		/* 821EE5F0h case   12:*/		return 0x820912A8;
		/* 821EE5F0h case   12:*/		return 0x821EE5F4;
		  /* 821EE5F4h */ case   13:  		/* nop */
		/* 821EE5F4h case   13:*/		cpu::op::nop();
		/* 821EE5F4h case   13:*/		return 0x821EE5F8;
	}
	return 0x821EE5F8;
} // Block from 821EE5C0h-821EE5F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EE5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE5F8);
		  /* 821EE5F8h */ case    0:  		/* mfspr R12, LR */
		/* 821EE5F8h case    0:*/		regs.R12 = regs.LR;
		/* 821EE5F8h case    0:*/		return 0x821EE5FC;
		  /* 821EE5FCh */ case    1:  		/* bl -1430436 */
		/* 821EE5FCh case    1:*/		regs.LR = 0x821EE600; return 0x82091258;
		/* 821EE5FCh case    1:*/		return 0x821EE600;
		  /* 821EE600h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE600h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE600h case    2:*/		return 0x821EE604;
		  /* 821EE604h */ case    3:  		/* mr R28, R5 */
		/* 821EE604h case    3:*/		regs.R28 = regs.R5;
		/* 821EE604h case    3:*/		return 0x821EE608;
		  /* 821EE608h */ case    4:  		/* li R8, 4 */
		/* 821EE608h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE608h case    4:*/		return 0x821EE60C;
		  /* 821EE60Ch */ case    5:  		/* li R7, 2 */
		/* 821EE60Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE60Ch case    5:*/		return 0x821EE610;
		  /* 821EE610h */ case    6:  		/* li R6, 6 */
		/* 821EE610h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 821EE610h case    6:*/		return 0x821EE614;
		  /* 821EE614h */ case    7:  		/* li R5, 0 */
		/* 821EE614h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE614h case    7:*/		return 0x821EE618;
		  /* 821EE618h */ case    8:  		/* mr R29, R4 */
		/* 821EE618h case    8:*/		regs.R29 = regs.R4;
		/* 821EE618h case    8:*/		return 0x821EE61C;
		  /* 821EE61Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE61Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE61Ch case    9:*/		return 0x821EE620;
		  /* 821EE620h */ case   10:  		/* mr R30, R3 */
		/* 821EE620h case   10:*/		regs.R30 = regs.R3;
		/* 821EE620h case   10:*/		return 0x821EE624;
		  /* 821EE624h */ case   11:  		/* bl 222068 */
		/* 821EE624h case   11:*/		regs.LR = 0x821EE628; return 0x82224998;
		/* 821EE624h case   11:*/		return 0x821EE628;
		  /* 821EE628h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE628h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE628h case   12:*/		return 0x821EE62C;
		  /* 821EE62Ch */ case   13:  		/* mr R31, R3 */
		/* 821EE62Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EE62Ch case   13:*/		return 0x821EE630;
		  /* 821EE630h */ case   14:  		/* mr R4, R29 */
		/* 821EE630h case   14:*/		regs.R4 = regs.R29;
		/* 821EE630h case   14:*/		return 0x821EE634;
		  /* 821EE634h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EE634h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE634h case   15:*/		return 0x821EE638;
		  /* 821EE638h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE638h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EE64C;  }
		/* 821EE638h case   16:*/		return 0x821EE63C;
		  /* 821EE63Ch */ case   17:  		/* mr R3, R30 */
		/* 821EE63Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EE63Ch case   17:*/		return 0x821EE640;
		  /* 821EE640h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE640h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE640h case   18:*/		return 0x821EE644;
		  /* 821EE644h */ case   19:  		/* bl -513364 */
		/* 821EE644h case   19:*/		regs.LR = 0x821EE648; return 0x821710F0;
		/* 821EE644h case   19:*/		return 0x821EE648;
		  /* 821EE648h */ case   20:  		/* mr R4, R3 */
		/* 821EE648h case   20:*/		regs.R4 = regs.R3;
		/* 821EE648h case   20:*/		return 0x821EE64C;
	}
	return 0x821EE64C;
} // Block from 821EE5F8h-821EE64Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EE64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE64C);
		  /* 821EE64Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE64Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE64Ch case    0:*/		return 0x821EE650;
		  /* 821EE650h */ case    1:  		/* bl -484488 */
		/* 821EE650h case    1:*/		regs.LR = 0x821EE654; return 0x821781C8;
		/* 821EE650h case    1:*/		return 0x821EE654;
		  /* 821EE654h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE654h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE654h case    2:*/		return 0x821EE658;
		  /* 821EE658h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE658h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE658h case    3:*/		return 0x821EE65C;
		  /* 821EE65Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE65Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE65Ch case    4:*/		return 0x821EE660;
		  /* 821EE660h */ case    5:  		/* mr R4, R28 */
		/* 821EE660h case    5:*/		regs.R4 = regs.R28;
		/* 821EE660h case    5:*/		return 0x821EE664;
		  /* 821EE664h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE664h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE678;  }
		/* 821EE664h case    6:*/		return 0x821EE668;
		  /* 821EE668h */ case    7:  		/* mr R3, R30 */
		/* 821EE668h case    7:*/		regs.R3 = regs.R30;
		/* 821EE668h case    7:*/		return 0x821EE66C;
		  /* 821EE66Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE66Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE66Ch case    8:*/		return 0x821EE670;
		  /* 821EE670h */ case    9:  		/* bl -513408 */
		/* 821EE670h case    9:*/		regs.LR = 0x821EE674; return 0x821710F0;
		/* 821EE670h case    9:*/		return 0x821EE674;
		  /* 821EE674h */ case   10:  		/* mr R4, R3 */
		/* 821EE674h case   10:*/		regs.R4 = regs.R3;
		/* 821EE674h case   10:*/		return 0x821EE678;
	}
	return 0x821EE678;
} // Block from 821EE64Ch-821EE678h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EE678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE678);
		  /* 821EE678h */ case    0:  		/* mr R3, R31 */
		/* 821EE678h case    0:*/		regs.R3 = regs.R31;
		/* 821EE678h case    0:*/		return 0x821EE67C;
		  /* 821EE67Ch */ case    1:  		/* bl -484532 */
		/* 821EE67Ch case    1:*/		regs.LR = 0x821EE680; return 0x821781C8;
		/* 821EE67Ch case    1:*/		return 0x821EE680;
		  /* 821EE680h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE680h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE680h case    2:*/		return 0x821EE684;
		  /* 821EE684h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE684h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE684h case    3:*/		return 0x821EE688;
		  /* 821EE688h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE688h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE688h case    4:*/		return 0x821EE68C;
		  /* 821EE68Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE68Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE68Ch case    5:*/		return 0x821EE690;
	}
	return 0x821EE690;
} // Block from 821EE678h-821EE690h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EE690h
// Function '?MergeDependencies@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@W4Component@2@010101@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE690);
		  /* 821EE690h */ case    0:  		/* mr R3, R31 */
		/* 821EE690h case    0:*/		regs.R3 = regs.R31;
		/* 821EE690h case    0:*/		return 0x821EE694;
		  /* 821EE694h */ case    1:  		/* addi R11, R11, 36 */
		/* 821EE694h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE694h case    1:*/		return 0x821EE698;
		  /* 821EE698h */ case    2:  		/* lwz R10, <#[R10]> */
		/* 821EE698h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE698h case    2:*/		return 0x821EE69C;
		  /* 821EE69Ch */ case    3:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE69Ch case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE69Ch case    3:*/		return 0x821EE6A0;
		  /* 821EE6A0h */ case    4:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE6A0h case    4:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE6A0h case    4:*/		return 0x821EE6A4;
		  /* 821EE6A4h */ case    5:  		/* addi R8, R11, -36 */
		/* 821EE6A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE6A4h case    5:*/		return 0x821EE6A8;
		  /* 821EE6A8h */ case    6:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE6A8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE6A8h case    6:*/		return 0x821EE6AC;
		  /* 821EE6ACh */ case    7:  		/* addi R9, R11, 4 */
		/* 821EE6ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE6ACh case    7:*/		return 0x821EE6B0;
		  /* 821EE6B0h */ case    8:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE6B0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE6B0h case    8:*/		return 0x821EE6B4;
		  /* 821EE6B4h */ case    9:  		/* addi R10, R10, 24 */
		/* 821EE6B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE6B4h case    9:*/		return 0x821EE6B8;
		  /* 821EE6B8h */ case   10:  		/* lwz R7, <#[R10]> */
		/* 821EE6B8h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE6B8h case   10:*/		return 0x821EE6BC;
		  /* 821EE6BCh */ case   11:  		/* addi R6, R10, -36 */
		/* 821EE6BCh case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE6BCh case   11:*/		return 0x821EE6C0;
		  /* 821EE6C0h */ case   12:  		/* stw R7, <#[R11]> */
		/* 821EE6C0h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE6C0h case   12:*/		return 0x821EE6C4;
		  /* 821EE6C4h */ case   13:  		/* lwz R7, <#[R10]> */
		/* 821EE6C4h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE6C4h case   13:*/		return 0x821EE6C8;
		  /* 821EE6C8h */ case   14:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE6C8h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE6C8h case   14:*/		return 0x821EE6CC;
		  /* 821EE6CCh */ case   15:  		/* ori R6, R6, 1 */
		/* 821EE6CCh case   15:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE6CCh case   15:*/		return 0x821EE6D0;
		  /* 821EE6D0h */ case   16:  		/* stw R8, <#[R7]> */
		/* 821EE6D0h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE6D0h case   16:*/		return 0x821EE6D4;
		  /* 821EE6D4h */ case   17:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE6D4h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE6D4h case   17:*/		return 0x821EE6D8;
		  /* 821EE6D8h */ case   18:  		/* stw R9, <#[R10]> */
		/* 821EE6D8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE6D8h case   18:*/		return 0x821EE6DC;
		  /* 821EE6DCh */ case   19:  		/* addi R1, R1, 128 */
		/* 821EE6DCh case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE6DCh case   19:*/		return 0x821EE6E0;
		  /* 821EE6E0h */ case   20:  		/* b -1430584 */
		/* 821EE6E0h case   20:*/		return 0x820912A8;
		/* 821EE6E0h case   20:*/		return 0x821EE6E4;
		  /* 821EE6E4h */ case   21:  		/* nop */
		/* 821EE6E4h case   21:*/		cpu::op::nop();
		/* 821EE6E4h case   21:*/		return 0x821EE6E8;
	}
	return 0x821EE6E8;
} // Block from 821EE690h-821EE6E8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EE6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE6E8);
		  /* 821EE6E8h */ case    0:  		/* mfspr R12, LR */
		/* 821EE6E8h case    0:*/		regs.R12 = regs.LR;
		/* 821EE6E8h case    0:*/		return 0x821EE6EC;
		  /* 821EE6ECh */ case    1:  		/* bl -1430676 */
		/* 821EE6ECh case    1:*/		regs.LR = 0x821EE6F0; return 0x82091258;
		/* 821EE6ECh case    1:*/		return 0x821EE6F0;
		  /* 821EE6F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE6F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE6F0h case    2:*/		return 0x821EE6F4;
		  /* 821EE6F4h */ case    3:  		/* mr R28, R5 */
		/* 821EE6F4h case    3:*/		regs.R28 = regs.R5;
		/* 821EE6F4h case    3:*/		return 0x821EE6F8;
		  /* 821EE6F8h */ case    4:  		/* li R8, 4 */
		/* 821EE6F8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE6F8h case    4:*/		return 0x821EE6FC;
		  /* 821EE6FCh */ case    5:  		/* li R7, 2 */
		/* 821EE6FCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE6FCh case    5:*/		return 0x821EE700;
		  /* 821EE700h */ case    6:  		/* li R6, 7 */
		/* 821EE700h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 821EE700h case    6:*/		return 0x821EE704;
		  /* 821EE704h */ case    7:  		/* li R5, 0 */
		/* 821EE704h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE704h case    7:*/		return 0x821EE708;
		  /* 821EE708h */ case    8:  		/* mr R29, R4 */
		/* 821EE708h case    8:*/		regs.R29 = regs.R4;
		/* 821EE708h case    8:*/		return 0x821EE70C;
		  /* 821EE70Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE70Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE70Ch case    9:*/		return 0x821EE710;
		  /* 821EE710h */ case   10:  		/* mr R30, R3 */
		/* 821EE710h case   10:*/		regs.R30 = regs.R3;
		/* 821EE710h case   10:*/		return 0x821EE714;
		  /* 821EE714h */ case   11:  		/* bl 221828 */
		/* 821EE714h case   11:*/		regs.LR = 0x821EE718; return 0x82224998;
		/* 821EE714h case   11:*/		return 0x821EE718;
		  /* 821EE718h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE718h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE718h case   12:*/		return 0x821EE71C;
		  /* 821EE71Ch */ case   13:  		/* mr R31, R3 */
		/* 821EE71Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EE71Ch case   13:*/		return 0x821EE720;
		  /* 821EE720h */ case   14:  		/* mr R4, R29 */
		/* 821EE720h case   14:*/		regs.R4 = regs.R29;
		/* 821EE720h case   14:*/		return 0x821EE724;
		  /* 821EE724h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EE724h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE724h case   15:*/		return 0x821EE728;
		  /* 821EE728h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE728h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EE73C;  }
		/* 821EE728h case   16:*/		return 0x821EE72C;
		  /* 821EE72Ch */ case   17:  		/* mr R3, R30 */
		/* 821EE72Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EE72Ch case   17:*/		return 0x821EE730;
		  /* 821EE730h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE730h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE730h case   18:*/		return 0x821EE734;
		  /* 821EE734h */ case   19:  		/* bl -513604 */
		/* 821EE734h case   19:*/		regs.LR = 0x821EE738; return 0x821710F0;
		/* 821EE734h case   19:*/		return 0x821EE738;
		  /* 821EE738h */ case   20:  		/* mr R4, R3 */
		/* 821EE738h case   20:*/		regs.R4 = regs.R3;
		/* 821EE738h case   20:*/		return 0x821EE73C;
	}
	return 0x821EE73C;
} // Block from 821EE6E8h-821EE73Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EE73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE73C);
		  /* 821EE73Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE73Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE73Ch case    0:*/		return 0x821EE740;
		  /* 821EE740h */ case    1:  		/* bl -484728 */
		/* 821EE740h case    1:*/		regs.LR = 0x821EE744; return 0x821781C8;
		/* 821EE740h case    1:*/		return 0x821EE744;
		  /* 821EE744h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE744h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE744h case    2:*/		return 0x821EE748;
		  /* 821EE748h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE748h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE748h case    3:*/		return 0x821EE74C;
		  /* 821EE74Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE74Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE74Ch case    4:*/		return 0x821EE750;
		  /* 821EE750h */ case    5:  		/* mr R4, R28 */
		/* 821EE750h case    5:*/		regs.R4 = regs.R28;
		/* 821EE750h case    5:*/		return 0x821EE754;
		  /* 821EE754h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE754h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE768;  }
		/* 821EE754h case    6:*/		return 0x821EE758;
		  /* 821EE758h */ case    7:  		/* mr R3, R30 */
		/* 821EE758h case    7:*/		regs.R3 = regs.R30;
		/* 821EE758h case    7:*/		return 0x821EE75C;
		  /* 821EE75Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE75Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE75Ch case    8:*/		return 0x821EE760;
		  /* 821EE760h */ case    9:  		/* bl -513648 */
		/* 821EE760h case    9:*/		regs.LR = 0x821EE764; return 0x821710F0;
		/* 821EE760h case    9:*/		return 0x821EE764;
		  /* 821EE764h */ case   10:  		/* mr R4, R3 */
		/* 821EE764h case   10:*/		regs.R4 = regs.R3;
		/* 821EE764h case   10:*/		return 0x821EE768;
	}
	return 0x821EE768;
} // Block from 821EE73Ch-821EE768h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EE768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE768);
		  /* 821EE768h */ case    0:  		/* mr R3, R31 */
		/* 821EE768h case    0:*/		regs.R3 = regs.R31;
		/* 821EE768h case    0:*/		return 0x821EE76C;
		  /* 821EE76Ch */ case    1:  		/* bl -484772 */
		/* 821EE76Ch case    1:*/		regs.LR = 0x821EE770; return 0x821781C8;
		/* 821EE76Ch case    1:*/		return 0x821EE770;
		  /* 821EE770h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE770h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE770h case    2:*/		return 0x821EE774;
		  /* 821EE774h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE774h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE774h case    3:*/		return 0x821EE778;
		  /* 821EE778h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE778h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE778h case    4:*/		return 0x821EE77C;
		  /* 821EE77Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE77Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE77Ch case    5:*/		return 0x821EE780;
		  /* 821EE780h */ case    6:  		/* mr R3, R31 */
		/* 821EE780h case    6:*/		regs.R3 = regs.R31;
		/* 821EE780h case    6:*/		return 0x821EE784;
		  /* 821EE784h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE784h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE784h case    7:*/		return 0x821EE788;
		  /* 821EE788h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE788h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE788h case    8:*/		return 0x821EE78C;
		  /* 821EE78Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE78Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE78Ch case    9:*/		return 0x821EE790;
		  /* 821EE790h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE790h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE790h case   10:*/		return 0x821EE794;
		  /* 821EE794h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EE794h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE794h case   11:*/		return 0x821EE798;
		  /* 821EE798h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE798h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE798h case   12:*/		return 0x821EE79C;
		  /* 821EE79Ch */ case   13:  		/* addi R9, R11, 4 */
		/* 821EE79Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE79Ch case   13:*/		return 0x821EE7A0;
	}
	return 0x821EE7A0;
} // Block from 821EE768h-821EE7A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EE7A0h
// Function '?MergeInstructions@Compiler@D3DXShader@@QAAPAVDependency@2@PAVInstruction@2@W4Component@2@010101@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE7A0);
		  /* 821EE7A0h */ case    0:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE7A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE7A0h case    0:*/		return 0x821EE7A4;
		  /* 821EE7A4h */ case    1:  		/* addi R10, R10, 24 */
		/* 821EE7A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE7A4h case    1:*/		return 0x821EE7A8;
		  /* 821EE7A8h */ case    2:  		/* lwz R7, <#[R10]> */
		/* 821EE7A8h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE7A8h case    2:*/		return 0x821EE7AC;
		  /* 821EE7ACh */ case    3:  		/* addi R6, R10, -36 */
		/* 821EE7ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE7ACh case    3:*/		return 0x821EE7B0;
		  /* 821EE7B0h */ case    4:  		/* stw R7, <#[R11]> */
		/* 821EE7B0h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE7B0h case    4:*/		return 0x821EE7B4;
		  /* 821EE7B4h */ case    5:  		/* lwz R7, <#[R10]> */
		/* 821EE7B4h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE7B4h case    5:*/		return 0x821EE7B8;
		  /* 821EE7B8h */ case    6:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE7B8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE7B8h case    6:*/		return 0x821EE7BC;
		  /* 821EE7BCh */ case    7:  		/* ori R6, R6, 1 */
		/* 821EE7BCh case    7:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE7BCh case    7:*/		return 0x821EE7C0;
		  /* 821EE7C0h */ case    8:  		/* stw R8, <#[R7]> */
		/* 821EE7C0h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE7C0h case    8:*/		return 0x821EE7C4;
		  /* 821EE7C4h */ case    9:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE7C4h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE7C4h case    9:*/		return 0x821EE7C8;
		  /* 821EE7C8h */ case   10:  		/* stw R9, <#[R10]> */
		/* 821EE7C8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE7C8h case   10:*/		return 0x821EE7CC;
		  /* 821EE7CCh */ case   11:  		/* addi R1, R1, 128 */
		/* 821EE7CCh case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE7CCh case   11:*/		return 0x821EE7D0;
		  /* 821EE7D0h */ case   12:  		/* b -1430824 */
		/* 821EE7D0h case   12:*/		return 0x820912A8;
		/* 821EE7D0h case   12:*/		return 0x821EE7D4;
		  /* 821EE7D4h */ case   13:  		/* nop */
		/* 821EE7D4h case   13:*/		cpu::op::nop();
		/* 821EE7D4h case   13:*/		return 0x821EE7D8;
	}
	return 0x821EE7D8;
} // Block from 821EE7A0h-821EE7D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EE7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE7D8);
		  /* 821EE7D8h */ case    0:  		/* mfspr R12, LR */
		/* 821EE7D8h case    0:*/		regs.R12 = regs.LR;
		/* 821EE7D8h case    0:*/		return 0x821EE7DC;
		  /* 821EE7DCh */ case    1:  		/* bl -1430916 */
		/* 821EE7DCh case    1:*/		regs.LR = 0x821EE7E0; return 0x82091258;
		/* 821EE7DCh case    1:*/		return 0x821EE7E0;
		  /* 821EE7E0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EE7E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EE7E0h case    2:*/		return 0x821EE7E4;
		  /* 821EE7E4h */ case    3:  		/* mr R28, R5 */
		/* 821EE7E4h case    3:*/		regs.R28 = regs.R5;
		/* 821EE7E4h case    3:*/		return 0x821EE7E8;
		  /* 821EE7E8h */ case    4:  		/* li R8, 4 */
		/* 821EE7E8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE7E8h case    4:*/		return 0x821EE7EC;
		  /* 821EE7ECh */ case    5:  		/* li R7, 2 */
		/* 821EE7ECh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EE7ECh case    5:*/		return 0x821EE7F0;
		  /* 821EE7F0h */ case    6:  		/* li R6, 8 */
		/* 821EE7F0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x8);
		/* 821EE7F0h case    6:*/		return 0x821EE7F4;
		  /* 821EE7F4h */ case    7:  		/* li R5, 0 */
		/* 821EE7F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE7F4h case    7:*/		return 0x821EE7F8;
		  /* 821EE7F8h */ case    8:  		/* mr R29, R4 */
		/* 821EE7F8h case    8:*/		regs.R29 = regs.R4;
		/* 821EE7F8h case    8:*/		return 0x821EE7FC;
		  /* 821EE7FCh */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE7FCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE7FCh case    9:*/		return 0x821EE800;
		  /* 821EE800h */ case   10:  		/* mr R30, R3 */
		/* 821EE800h case   10:*/		regs.R30 = regs.R3;
		/* 821EE800h case   10:*/		return 0x821EE804;
		  /* 821EE804h */ case   11:  		/* bl 221588 */
		/* 821EE804h case   11:*/		regs.LR = 0x821EE808; return 0x82224998;
		/* 821EE804h case   11:*/		return 0x821EE808;
		  /* 821EE808h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE808h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE808h case   12:*/		return 0x821EE80C;
		  /* 821EE80Ch */ case   13:  		/* mr R31, R3 */
		/* 821EE80Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EE80Ch case   13:*/		return 0x821EE810;
		  /* 821EE810h */ case   14:  		/* mr R4, R29 */
		/* 821EE810h case   14:*/		regs.R4 = regs.R29;
		/* 821EE810h case   14:*/		return 0x821EE814;
		  /* 821EE814h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EE814h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE814h case   15:*/		return 0x821EE818;
		  /* 821EE818h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE818h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EE82C;  }
		/* 821EE818h case   16:*/		return 0x821EE81C;
		  /* 821EE81Ch */ case   17:  		/* mr R3, R30 */
		/* 821EE81Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EE81Ch case   17:*/		return 0x821EE820;
		  /* 821EE820h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE820h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE820h case   18:*/		return 0x821EE824;
		  /* 821EE824h */ case   19:  		/* bl -513844 */
		/* 821EE824h case   19:*/		regs.LR = 0x821EE828; return 0x821710F0;
		/* 821EE824h case   19:*/		return 0x821EE828;
		  /* 821EE828h */ case   20:  		/* mr R4, R3 */
		/* 821EE828h case   20:*/		regs.R4 = regs.R3;
		/* 821EE828h case   20:*/		return 0x821EE82C;
	}
	return 0x821EE82C;
} // Block from 821EE7D8h-821EE82Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EE82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE82C);
		  /* 821EE82Ch */ case    0:  		/* mr R3, R31 */
		/* 821EE82Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EE82Ch case    0:*/		return 0x821EE830;
		  /* 821EE830h */ case    1:  		/* bl -484968 */
		/* 821EE830h case    1:*/		regs.LR = 0x821EE834; return 0x821781C8;
		/* 821EE830h case    1:*/		return 0x821EE834;
		  /* 821EE834h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE834h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE834h case    2:*/		return 0x821EE838;
		  /* 821EE838h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EE838h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EE838h case    3:*/		return 0x821EE83C;
		  /* 821EE83Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EE83Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE83Ch case    4:*/		return 0x821EE840;
		  /* 821EE840h */ case    5:  		/* mr R4, R28 */
		/* 821EE840h case    5:*/		regs.R4 = regs.R28;
		/* 821EE840h case    5:*/		return 0x821EE844;
		  /* 821EE844h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE844h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EE858;  }
		/* 821EE844h case    6:*/		return 0x821EE848;
	}
	return 0x821EE848;
} // Block from 821EE82Ch-821EE848h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821EE848h
// Function '?IsolateComputation@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE848);
		  /* 821EE848h */ case    0:  		/* mr R3, R30 */
		/* 821EE848h case    0:*/		regs.R3 = regs.R30;
		/* 821EE848h case    0:*/		return 0x821EE84C;
		  /* 821EE84Ch */ case    1:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EE84Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EE84Ch case    1:*/		return 0x821EE850;
		  /* 821EE850h */ case    2:  		/* bl -513888 */
		/* 821EE850h case    2:*/		regs.LR = 0x821EE854; return 0x821710F0;
		/* 821EE850h case    2:*/		return 0x821EE854;
		  /* 821EE854h */ case    3:  		/* mr R4, R3 */
		/* 821EE854h case    3:*/		regs.R4 = regs.R3;
		/* 821EE854h case    3:*/		return 0x821EE858;
	}
	return 0x821EE858;
} // Block from 821EE848h-821EE858h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EE858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE858);
		  /* 821EE858h */ case    0:  		/* mr R3, R31 */
		/* 821EE858h case    0:*/		regs.R3 = regs.R31;
		/* 821EE858h case    0:*/		return 0x821EE85C;
		  /* 821EE85Ch */ case    1:  		/* bl -485012 */
		/* 821EE85Ch case    1:*/		regs.LR = 0x821EE860; return 0x821781C8;
		/* 821EE85Ch case    1:*/		return 0x821EE860;
		  /* 821EE860h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EE860h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE860h case    2:*/		return 0x821EE864;
		  /* 821EE864h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EE864h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EE864h case    3:*/		return 0x821EE868;
		  /* 821EE868h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE868h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE868h case    4:*/		return 0x821EE86C;
		  /* 821EE86Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE86Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE86Ch case    5:*/		return 0x821EE870;
		  /* 821EE870h */ case    6:  		/* mr R3, R31 */
		/* 821EE870h case    6:*/		regs.R3 = regs.R31;
		/* 821EE870h case    6:*/		return 0x821EE874;
		  /* 821EE874h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE874h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE874h case    7:*/		return 0x821EE878;
		  /* 821EE878h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE878h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE878h case    8:*/		return 0x821EE87C;
		  /* 821EE87Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE87Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE87Ch case    9:*/		return 0x821EE880;
		  /* 821EE880h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE880h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE880h case   10:*/		return 0x821EE884;
		  /* 821EE884h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EE884h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE884h case   11:*/		return 0x821EE888;
		  /* 821EE888h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE888h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE888h case   12:*/		return 0x821EE88C;
		  /* 821EE88Ch */ case   13:  		/* addi R9, R11, 4 */
		/* 821EE88Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE88Ch case   13:*/		return 0x821EE890;
		  /* 821EE890h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE890h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE890h case   14:*/		return 0x821EE894;
		  /* 821EE894h */ case   15:  		/* addi R10, R10, 24 */
		/* 821EE894h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE894h case   15:*/		return 0x821EE898;
		  /* 821EE898h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EE898h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE898h case   16:*/		return 0x821EE89C;
		  /* 821EE89Ch */ case   17:  		/* addi R6, R10, -36 */
		/* 821EE89Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE89Ch case   17:*/		return 0x821EE8A0;
		  /* 821EE8A0h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EE8A0h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE8A0h case   18:*/		return 0x821EE8A4;
		  /* 821EE8A4h */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EE8A4h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE8A4h case   19:*/		return 0x821EE8A8;
		  /* 821EE8A8h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE8A8h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE8A8h case   20:*/		return 0x821EE8AC;
		  /* 821EE8ACh */ case   21:  		/* ori R6, R6, 1 */
		/* 821EE8ACh case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE8ACh case   21:*/		return 0x821EE8B0;
		  /* 821EE8B0h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EE8B0h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE8B0h case   22:*/		return 0x821EE8B4;
		  /* 821EE8B4h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE8B4h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE8B4h case   23:*/		return 0x821EE8B8;
		  /* 821EE8B8h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EE8B8h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE8B8h case   24:*/		return 0x821EE8BC;
		  /* 821EE8BCh */ case   25:  		/* addi R1, R1, 128 */
		/* 821EE8BCh case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EE8BCh case   25:*/		return 0x821EE8C0;
		  /* 821EE8C0h */ case   26:  		/* b -1431064 */
		/* 821EE8C0h case   26:*/		return 0x820912A8;
		/* 821EE8C0h case   26:*/		return 0x821EE8C4;
		  /* 821EE8C4h */ case   27:  		/* nop */
		/* 821EE8C4h case   27:*/		cpu::op::nop();
		/* 821EE8C4h case   27:*/		return 0x821EE8C8;
	}
	return 0x821EE8C8;
} // Block from 821EE858h-821EE8C8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EE8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE8C8);
		  /* 821EE8C8h */ case    0:  		/* mfspr R12, LR */
		/* 821EE8C8h case    0:*/		regs.R12 = regs.LR;
		/* 821EE8C8h case    0:*/		return 0x821EE8CC;
		  /* 821EE8CCh */ case    1:  		/* bl -1431152 */
		/* 821EE8CCh case    1:*/		regs.LR = 0x821EE8D0; return 0x8209125C;
		/* 821EE8CCh case    1:*/		return 0x821EE8D0;
	}
	return 0x821EE8D0;
} // Block from 821EE8C8h-821EE8D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EE8D0h
// Function '?SkipForward@?$ArrayListEnumerator@VResult@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE8D0);
		  /* 821EE8D0h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EE8D0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EE8D0h case    0:*/		return 0x821EE8D4;
		  /* 821EE8D4h */ case    1:  		/* li R8, 4 */
		/* 821EE8D4h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE8D4h case    1:*/		return 0x821EE8D8;
		  /* 821EE8D8h */ case    2:  		/* li R7, 1 */
		/* 821EE8D8h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EE8D8h case    2:*/		return 0x821EE8DC;
		  /* 821EE8DCh */ case    3:  		/* li R6, 9 */
		/* 821EE8DCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x9);
		/* 821EE8DCh case    3:*/		return 0x821EE8E0;
		  /* 821EE8E0h */ case    4:  		/* li R5, 0 */
		/* 821EE8E0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE8E0h case    4:*/		return 0x821EE8E4;
		  /* 821EE8E4h */ case    5:  		/* mr R29, R4 */
		/* 821EE8E4h case    5:*/		regs.R29 = regs.R4;
		/* 821EE8E4h case    5:*/		return 0x821EE8E8;
		  /* 821EE8E8h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE8E8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE8E8h case    6:*/		return 0x821EE8EC;
		  /* 821EE8ECh */ case    7:  		/* mr R30, R3 */
		/* 821EE8ECh case    7:*/		regs.R30 = regs.R3;
		/* 821EE8ECh case    7:*/		return 0x821EE8F0;
		  /* 821EE8F0h */ case    8:  		/* bl 221352 */
		/* 821EE8F0h case    8:*/		regs.LR = 0x821EE8F4; return 0x82224998;
		/* 821EE8F0h case    8:*/		return 0x821EE8F4;
		  /* 821EE8F4h */ case    9:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE8F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE8F4h case    9:*/		return 0x821EE8F8;
		  /* 821EE8F8h */ case   10:  		/* mr R31, R3 */
		/* 821EE8F8h case   10:*/		regs.R31 = regs.R3;
		/* 821EE8F8h case   10:*/		return 0x821EE8FC;
		  /* 821EE8FCh */ case   11:  		/* mr R4, R29 */
		/* 821EE8FCh case   11:*/		regs.R4 = regs.R29;
		/* 821EE8FCh case   11:*/		return 0x821EE900;
		  /* 821EE900h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821EE900h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE900h case   12:*/		return 0x821EE904;
		  /* 821EE904h */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE904h case   13:*/		if ( regs.CR[6].eq ) { return 0x821EE918;  }
		/* 821EE904h case   13:*/		return 0x821EE908;
		  /* 821EE908h */ case   14:  		/* mr R3, R30 */
		/* 821EE908h case   14:*/		regs.R3 = regs.R30;
		/* 821EE908h case   14:*/		return 0x821EE90C;
		  /* 821EE90Ch */ case   15:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE90Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE90Ch case   15:*/		return 0x821EE910;
		  /* 821EE910h */ case   16:  		/* bl -514080 */
		/* 821EE910h case   16:*/		regs.LR = 0x821EE914; return 0x821710F0;
		/* 821EE910h case   16:*/		return 0x821EE914;
		  /* 821EE914h */ case   17:  		/* mr R4, R3 */
		/* 821EE914h case   17:*/		regs.R4 = regs.R3;
		/* 821EE914h case   17:*/		return 0x821EE918;
	}
	return 0x821EE918;
} // Block from 821EE8D0h-821EE918h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EE918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE918);
		  /* 821EE918h */ case    0:  		/* mr R3, R31 */
		/* 821EE918h case    0:*/		regs.R3 = regs.R31;
		/* 821EE918h case    0:*/		return 0x821EE91C;
		  /* 821EE91Ch */ case    1:  		/* bl -485204 */
		/* 821EE91Ch case    1:*/		regs.LR = 0x821EE920; return 0x821781C8;
		/* 821EE91Ch case    1:*/		return 0x821EE920;
		  /* 821EE920h */ case    2:  		/* mr R10, R3 */
		/* 821EE920h case    2:*/		regs.R10 = regs.R3;
		/* 821EE920h case    2:*/		return 0x821EE924;
		  /* 821EE924h */ case    3:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE924h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE924h case    3:*/		return 0x821EE928;
		  /* 821EE928h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE928h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE928h case    4:*/		return 0x821EE92C;
		  /* 821EE92Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE92Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE92Ch case    5:*/		return 0x821EE930;
		  /* 821EE930h */ case    6:  		/* mr R3, R31 */
		/* 821EE930h case    6:*/		regs.R3 = regs.R31;
		/* 821EE930h case    6:*/		return 0x821EE934;
		  /* 821EE934h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EE934h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE934h case    7:*/		return 0x821EE938;
		  /* 821EE938h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EE938h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE938h case    8:*/		return 0x821EE93C;
		  /* 821EE93Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE93Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE93Ch case    9:*/		return 0x821EE940;
	}
	return 0x821EE940;
} // Block from 821EE918h-821EE940h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EE940h
// Function '?AllocAlignedFunctionMem@Compiler@D3DXShader@@QAAPAXKW4CompilerHeapStructTypes@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE940);
		  /* 821EE940h */ case    0:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EE940h case    0:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EE940h case    0:*/		return 0x821EE944;
		  /* 821EE944h */ case    1:  		/* addi R8, R11, -36 */
		/* 821EE944h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EE944h case    1:*/		return 0x821EE948;
		  /* 821EE948h */ case    2:  		/* stw R9, <#[R31 + 8]> */
		/* 821EE948h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE948h case    2:*/		return 0x821EE94C;
		  /* 821EE94Ch */ case    3:  		/* addi R9, R11, 4 */
		/* 821EE94Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EE94Ch case    3:*/		return 0x821EE950;
		  /* 821EE950h */ case    4:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EE950h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EE950h case    4:*/		return 0x821EE954;
		  /* 821EE954h */ case    5:  		/* addi R10, R10, 24 */
		/* 821EE954h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EE954h case    5:*/		return 0x821EE958;
		  /* 821EE958h */ case    6:  		/* lwz R7, <#[R10]> */
		/* 821EE958h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE958h case    6:*/		return 0x821EE95C;
		  /* 821EE95Ch */ case    7:  		/* addi R6, R10, -36 */
		/* 821EE95Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EE95Ch case    7:*/		return 0x821EE960;
		  /* 821EE960h */ case    8:  		/* stw R7, <#[R11]> */
		/* 821EE960h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EE960h case    8:*/		return 0x821EE964;
		  /* 821EE964h */ case    9:  		/* lwz R7, <#[R10]> */
		/* 821EE964h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE964h case    9:*/		return 0x821EE968;
		  /* 821EE968h */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EE968h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EE968h case   10:*/		return 0x821EE96C;
		  /* 821EE96Ch */ case   11:  		/* ori R6, R6, 1 */
		/* 821EE96Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EE96Ch case   11:*/		return 0x821EE970;
		  /* 821EE970h */ case   12:  		/* stw R8, <#[R7]> */
		/* 821EE970h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EE970h case   12:*/		return 0x821EE974;
		  /* 821EE974h */ case   13:  		/* stw R6, <#[R11 + 4]> */
		/* 821EE974h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EE974h case   13:*/		return 0x821EE978;
		  /* 821EE978h */ case   14:  		/* stw R9, <#[R10]> */
		/* 821EE978h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE978h case   14:*/		return 0x821EE97C;
		  /* 821EE97Ch */ case   15:  		/* addi R1, R1, 112 */
		/* 821EE97Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EE97Ch case   15:*/		return 0x821EE980;
		  /* 821EE980h */ case   16:  		/* b -1431252 */
		/* 821EE980h case   16:*/		return 0x820912AC;
		/* 821EE980h case   16:*/		return 0x821EE984;
		  /* 821EE984h */ case   17:  		/* nop */
		/* 821EE984h case   17:*/		cpu::op::nop();
		/* 821EE984h case   17:*/		return 0x821EE988;
	}
	return 0x821EE988;
} // Block from 821EE940h-821EE988h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EE988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE988);
		  /* 821EE988h */ case    0:  		/* mfspr R12, LR */
		/* 821EE988h case    0:*/		regs.R12 = regs.LR;
		/* 821EE988h case    0:*/		return 0x821EE98C;
		  /* 821EE98Ch */ case    1:  		/* bl -1431344 */
		/* 821EE98Ch case    1:*/		regs.LR = 0x821EE990; return 0x8209125C;
		/* 821EE98Ch case    1:*/		return 0x821EE990;
		  /* 821EE990h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EE990h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EE990h case    2:*/		return 0x821EE994;
		  /* 821EE994h */ case    3:  		/* li R8, 4 */
		/* 821EE994h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EE994h case    3:*/		return 0x821EE998;
		  /* 821EE998h */ case    4:  		/* li R7, 1 */
		/* 821EE998h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EE998h case    4:*/		return 0x821EE99C;
		  /* 821EE99Ch */ case    5:  		/* li R6, 10 */
		/* 821EE99Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0xA);
		/* 821EE99Ch case    5:*/		return 0x821EE9A0;
		  /* 821EE9A0h */ case    6:  		/* li R5, 0 */
		/* 821EE9A0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EE9A0h case    6:*/		return 0x821EE9A4;
		  /* 821EE9A4h */ case    7:  		/* mr R29, R4 */
		/* 821EE9A4h case    7:*/		regs.R29 = regs.R4;
		/* 821EE9A4h case    7:*/		return 0x821EE9A8;
		  /* 821EE9A8h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EE9A8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EE9A8h case    8:*/		return 0x821EE9AC;
		  /* 821EE9ACh */ case    9:  		/* mr R30, R3 */
		/* 821EE9ACh case    9:*/		regs.R30 = regs.R3;
		/* 821EE9ACh case    9:*/		return 0x821EE9B0;
		  /* 821EE9B0h */ case   10:  		/* bl 221160 */
		/* 821EE9B0h case   10:*/		regs.LR = 0x821EE9B4; return 0x82224998;
		/* 821EE9B0h case   10:*/		return 0x821EE9B4;
		  /* 821EE9B4h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EE9B4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EE9B4h case   11:*/		return 0x821EE9B8;
		  /* 821EE9B8h */ case   12:  		/* mr R31, R3 */
		/* 821EE9B8h case   12:*/		regs.R31 = regs.R3;
		/* 821EE9B8h case   12:*/		return 0x821EE9BC;
		  /* 821EE9BCh */ case   13:  		/* mr R4, R29 */
		/* 821EE9BCh case   13:*/		regs.R4 = regs.R29;
		/* 821EE9BCh case   13:*/		return 0x821EE9C0;
		  /* 821EE9C0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EE9C0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EE9C0h case   14:*/		return 0x821EE9C4;
		  /* 821EE9C4h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EE9C4h case   15:*/		if ( regs.CR[6].eq ) { return 0x821EE9D8;  }
		/* 821EE9C4h case   15:*/		return 0x821EE9C8;
		  /* 821EE9C8h */ case   16:  		/* mr R3, R30 */
		/* 821EE9C8h case   16:*/		regs.R3 = regs.R30;
		/* 821EE9C8h case   16:*/		return 0x821EE9CC;
		  /* 821EE9CCh */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EE9CCh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EE9CCh case   17:*/		return 0x821EE9D0;
		  /* 821EE9D0h */ case   18:  		/* bl -514272 */
		/* 821EE9D0h case   18:*/		regs.LR = 0x821EE9D4; return 0x821710F0;
		/* 821EE9D0h case   18:*/		return 0x821EE9D4;
		  /* 821EE9D4h */ case   19:  		/* mr R4, R3 */
		/* 821EE9D4h case   19:*/		regs.R4 = regs.R3;
		/* 821EE9D4h case   19:*/		return 0x821EE9D8;
	}
	return 0x821EE9D8;
} // Block from 821EE988h-821EE9D8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EE9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE9D8);
		  /* 821EE9D8h */ case    0:  		/* mr R3, R31 */
		/* 821EE9D8h case    0:*/		regs.R3 = regs.R31;
		/* 821EE9D8h case    0:*/		return 0x821EE9DC;
		  /* 821EE9DCh */ case    1:  		/* bl -485396 */
		/* 821EE9DCh case    1:*/		regs.LR = 0x821EE9E0; return 0x821781C8;
		/* 821EE9DCh case    1:*/		return 0x821EE9E0;
		  /* 821EE9E0h */ case    2:  		/* mr R10, R3 */
		/* 821EE9E0h case    2:*/		regs.R10 = regs.R3;
		/* 821EE9E0h case    2:*/		return 0x821EE9E4;
		  /* 821EE9E4h */ case    3:  		/* stw R3, <#[R31 + 44]> */
		/* 821EE9E4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EE9E4h case    3:*/		return 0x821EE9E8;
		  /* 821EE9E8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EE9E8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EE9E8h case    4:*/		return 0x821EE9EC;
		  /* 821EE9ECh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EE9ECh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EE9ECh case    5:*/		return 0x821EE9F0;
	}
	return 0x821EE9F0;
} // Block from 821EE9D8h-821EE9F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EE9F0h
// Function '?CreateBlock@Compiler@D3DXShader@@AAAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EE9F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EE9F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EE9F0);
		  /* 821EE9F0h */ case    0:  		/* mr R3, R31 */
		/* 821EE9F0h case    0:*/		regs.R3 = regs.R31;
		/* 821EE9F0h case    0:*/		return 0x821EE9F4;
		  /* 821EE9F4h */ case    1:  		/* addi R11, R11, 36 */
		/* 821EE9F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EE9F4h case    1:*/		return 0x821EE9F8;
		  /* 821EE9F8h */ case    2:  		/* lwz R10, <#[R10]> */
		/* 821EE9F8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EE9F8h case    2:*/		return 0x821EE9FC;
		  /* 821EE9FCh */ case    3:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EE9FCh case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EE9FCh case    3:*/		return 0x821EEA00;
		  /* 821EEA00h */ case    4:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EEA00h case    4:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EEA00h case    4:*/		return 0x821EEA04;
		  /* 821EEA04h */ case    5:  		/* addi R8, R11, -36 */
		/* 821EEA04h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EEA04h case    5:*/		return 0x821EEA08;
		  /* 821EEA08h */ case    6:  		/* stw R9, <#[R31 + 8]> */
		/* 821EEA08h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEA08h case    6:*/		return 0x821EEA0C;
		  /* 821EEA0Ch */ case    7:  		/* addi R9, R11, 4 */
		/* 821EEA0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EEA0Ch case    7:*/		return 0x821EEA10;
		  /* 821EEA10h */ case    8:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EEA10h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EEA10h case    8:*/		return 0x821EEA14;
		  /* 821EEA14h */ case    9:  		/* addi R10, R10, 24 */
		/* 821EEA14h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EEA14h case    9:*/		return 0x821EEA18;
		  /* 821EEA18h */ case   10:  		/* lwz R7, <#[R10]> */
		/* 821EEA18h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEA18h case   10:*/		return 0x821EEA1C;
		  /* 821EEA1Ch */ case   11:  		/* addi R6, R10, -36 */
		/* 821EEA1Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EEA1Ch case   11:*/		return 0x821EEA20;
		  /* 821EEA20h */ case   12:  		/* stw R7, <#[R11]> */
		/* 821EEA20h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEA20h case   12:*/		return 0x821EEA24;
		  /* 821EEA24h */ case   13:  		/* lwz R7, <#[R10]> */
		/* 821EEA24h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEA24h case   13:*/		return 0x821EEA28;
		  /* 821EEA28h */ case   14:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EEA28h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EEA28h case   14:*/		return 0x821EEA2C;
		  /* 821EEA2Ch */ case   15:  		/* ori R6, R6, 1 */
		/* 821EEA2Ch case   15:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EEA2Ch case   15:*/		return 0x821EEA30;
		  /* 821EEA30h */ case   16:  		/* stw R8, <#[R7]> */
		/* 821EEA30h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EEA30h case   16:*/		return 0x821EEA34;
		  /* 821EEA34h */ case   17:  		/* stw R6, <#[R11 + 4]> */
		/* 821EEA34h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EEA34h case   17:*/		return 0x821EEA38;
		  /* 821EEA38h */ case   18:  		/* stw R9, <#[R10]> */
		/* 821EEA38h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEA38h case   18:*/		return 0x821EEA3C;
		  /* 821EEA3Ch */ case   19:  		/* addi R1, R1, 112 */
		/* 821EEA3Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EEA3Ch case   19:*/		return 0x821EEA40;
		  /* 821EEA40h */ case   20:  		/* b -1431444 */
		/* 821EEA40h case   20:*/		return 0x820912AC;
		/* 821EEA40h case   20:*/		return 0x821EEA44;
		  /* 821EEA44h */ case   21:  		/* nop */
		/* 821EEA44h case   21:*/		cpu::op::nop();
		/* 821EEA44h case   21:*/		return 0x821EEA48;
	}
	return 0x821EEA48;
} // Block from 821EE9F0h-821EEA48h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EEA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEA48);
		  /* 821EEA48h */ case    0:  		/* mfspr R12, LR */
		/* 821EEA48h case    0:*/		regs.R12 = regs.LR;
		/* 821EEA48h case    0:*/		return 0x821EEA4C;
		  /* 821EEA4Ch */ case    1:  		/* bl -1431536 */
		/* 821EEA4Ch case    1:*/		regs.LR = 0x821EEA50; return 0x8209125C;
		/* 821EEA4Ch case    1:*/		return 0x821EEA50;
		  /* 821EEA50h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EEA50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EEA50h case    2:*/		return 0x821EEA54;
		  /* 821EEA54h */ case    3:  		/* li R8, 4 */
		/* 821EEA54h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EEA54h case    3:*/		return 0x821EEA58;
		  /* 821EEA58h */ case    4:  		/* li R7, 1 */
		/* 821EEA58h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EEA58h case    4:*/		return 0x821EEA5C;
		  /* 821EEA5Ch */ case    5:  		/* li R6, 11 */
		/* 821EEA5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0xB);
		/* 821EEA5Ch case    5:*/		return 0x821EEA60;
		  /* 821EEA60h */ case    6:  		/* li R5, 0 */
		/* 821EEA60h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EEA60h case    6:*/		return 0x821EEA64;
		  /* 821EEA64h */ case    7:  		/* mr R29, R4 */
		/* 821EEA64h case    7:*/		regs.R29 = regs.R4;
		/* 821EEA64h case    7:*/		return 0x821EEA68;
		  /* 821EEA68h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EEA68h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EEA68h case    8:*/		return 0x821EEA6C;
		  /* 821EEA6Ch */ case    9:  		/* mr R30, R3 */
		/* 821EEA6Ch case    9:*/		regs.R30 = regs.R3;
		/* 821EEA6Ch case    9:*/		return 0x821EEA70;
		  /* 821EEA70h */ case   10:  		/* bl 220968 */
		/* 821EEA70h case   10:*/		regs.LR = 0x821EEA74; return 0x82224998;
		/* 821EEA70h case   10:*/		return 0x821EEA74;
		  /* 821EEA74h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EEA74h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EEA74h case   11:*/		return 0x821EEA78;
		  /* 821EEA78h */ case   12:  		/* mr R31, R3 */
		/* 821EEA78h case   12:*/		regs.R31 = regs.R3;
		/* 821EEA78h case   12:*/		return 0x821EEA7C;
		  /* 821EEA7Ch */ case   13:  		/* mr R4, R29 */
		/* 821EEA7Ch case   13:*/		regs.R4 = regs.R29;
		/* 821EEA7Ch case   13:*/		return 0x821EEA80;
		  /* 821EEA80h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EEA80h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEA80h case   14:*/		return 0x821EEA84;
		  /* 821EEA84h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEA84h case   15:*/		if ( regs.CR[6].eq ) { return 0x821EEA98;  }
		/* 821EEA84h case   15:*/		return 0x821EEA88;
		  /* 821EEA88h */ case   16:  		/* mr R3, R30 */
		/* 821EEA88h case   16:*/		regs.R3 = regs.R30;
		/* 821EEA88h case   16:*/		return 0x821EEA8C;
		  /* 821EEA8Ch */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EEA8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EEA8Ch case   17:*/		return 0x821EEA90;
		  /* 821EEA90h */ case   18:  		/* bl -514464 */
		/* 821EEA90h case   18:*/		regs.LR = 0x821EEA94; return 0x821710F0;
		/* 821EEA90h case   18:*/		return 0x821EEA94;
		  /* 821EEA94h */ case   19:  		/* mr R4, R3 */
		/* 821EEA94h case   19:*/		regs.R4 = regs.R3;
		/* 821EEA94h case   19:*/		return 0x821EEA98;
	}
	return 0x821EEA98;
} // Block from 821EEA48h-821EEA98h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EEA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEA98);
		  /* 821EEA98h */ case    0:  		/* mr R3, R31 */
		/* 821EEA98h case    0:*/		regs.R3 = regs.R31;
		/* 821EEA98h case    0:*/		return 0x821EEA9C;
		  /* 821EEA9Ch */ case    1:  		/* bl -485588 */
		/* 821EEA9Ch case    1:*/		regs.LR = 0x821EEAA0; return 0x821781C8;
		/* 821EEA9Ch case    1:*/		return 0x821EEAA0;
		  /* 821EEAA0h */ case    2:  		/* mr R10, R3 */
		/* 821EEAA0h case    2:*/		regs.R10 = regs.R3;
		/* 821EEAA0h case    2:*/		return 0x821EEAA4;
		  /* 821EEAA4h */ case    3:  		/* stw R3, <#[R31 + 44]> */
		/* 821EEAA4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEAA4h case    3:*/		return 0x821EEAA8;
		  /* 821EEAA8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EEAA8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EEAA8h case    4:*/		return 0x821EEAAC;
		  /* 821EEAACh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EEAACh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEAACh case    5:*/		return 0x821EEAB0;
		  /* 821EEAB0h */ case    6:  		/* mr R3, R31 */
		/* 821EEAB0h case    6:*/		regs.R3 = regs.R31;
		/* 821EEAB0h case    6:*/		return 0x821EEAB4;
		  /* 821EEAB4h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EEAB4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EEAB4h case    7:*/		return 0x821EEAB8;
		  /* 821EEAB8h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EEAB8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEAB8h case    8:*/		return 0x821EEABC;
		  /* 821EEABCh */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EEABCh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EEABCh case    9:*/		return 0x821EEAC0;
		  /* 821EEAC0h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EEAC0h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EEAC0h case   10:*/		return 0x821EEAC4;
		  /* 821EEAC4h */ case   11:  		/* addi R8, R11, -36 */
		/* 821EEAC4h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EEAC4h case   11:*/		return 0x821EEAC8;
		  /* 821EEAC8h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EEAC8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEAC8h case   12:*/		return 0x821EEACC;
		  /* 821EEACCh */ case   13:  		/* addi R9, R11, 4 */
		/* 821EEACCh case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EEACCh case   13:*/		return 0x821EEAD0;
		  /* 821EEAD0h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EEAD0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EEAD0h case   14:*/		return 0x821EEAD4;
		  /* 821EEAD4h */ case   15:  		/* addi R10, R10, 24 */
		/* 821EEAD4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EEAD4h case   15:*/		return 0x821EEAD8;
	}
	return 0x821EEAD8;
} // Block from 821EEA98h-821EEAD8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EEAD8h
// Function '?CreateSubEntryBlock@Compiler@D3DXShader@@AAAPAVBlock@2@PAUFunction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEAD8);
		  /* 821EEAD8h */ case    0:  		/* lwz R7, <#[R10]> */
		/* 821EEAD8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEAD8h case    0:*/		return 0x821EEADC;
		  /* 821EEADCh */ case    1:  		/* addi R6, R10, -36 */
		/* 821EEADCh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EEADCh case    1:*/		return 0x821EEAE0;
		  /* 821EEAE0h */ case    2:  		/* stw R7, <#[R11]> */
		/* 821EEAE0h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEAE0h case    2:*/		return 0x821EEAE4;
		  /* 821EEAE4h */ case    3:  		/* lwz R7, <#[R10]> */
		/* 821EEAE4h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEAE4h case    3:*/		return 0x821EEAE8;
		  /* 821EEAE8h */ case    4:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EEAE8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EEAE8h case    4:*/		return 0x821EEAEC;
		  /* 821EEAECh */ case    5:  		/* ori R6, R6, 1 */
		/* 821EEAECh case    5:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EEAECh case    5:*/		return 0x821EEAF0;
		  /* 821EEAF0h */ case    6:  		/* stw R8, <#[R7]> */
		/* 821EEAF0h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EEAF0h case    6:*/		return 0x821EEAF4;
		  /* 821EEAF4h */ case    7:  		/* stw R6, <#[R11 + 4]> */
		/* 821EEAF4h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EEAF4h case    7:*/		return 0x821EEAF8;
		  /* 821EEAF8h */ case    8:  		/* stw R9, <#[R10]> */
		/* 821EEAF8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEAF8h case    8:*/		return 0x821EEAFC;
		  /* 821EEAFCh */ case    9:  		/* addi R1, R1, 112 */
		/* 821EEAFCh case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EEAFCh case    9:*/		return 0x821EEB00;
		  /* 821EEB00h */ case   10:  		/* b -1431636 */
		/* 821EEB00h case   10:*/		return 0x820912AC;
		/* 821EEB00h case   10:*/		return 0x821EEB04;
		  /* 821EEB04h */ case   11:  		/* nop */
		/* 821EEB04h case   11:*/		cpu::op::nop();
		/* 821EEB04h case   11:*/		return 0x821EEB08;
	}
	return 0x821EEB08;
} // Block from 821EEAD8h-821EEB08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EEB08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEB08);
		  /* 821EEB08h */ case    0:  		/* mfspr R12, LR */
		/* 821EEB08h case    0:*/		regs.R12 = regs.LR;
		/* 821EEB08h case    0:*/		return 0x821EEB0C;
		  /* 821EEB0Ch */ case    1:  		/* bl -1431736 */
		/* 821EEB0Ch case    1:*/		regs.LR = 0x821EEB10; return 0x82091254;
		/* 821EEB0Ch case    1:*/		return 0x821EEB10;
		  /* 821EEB10h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EEB10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EEB10h case    2:*/		return 0x821EEB14;
		  /* 821EEB14h */ case    3:  		/* mr R28, R5 */
		/* 821EEB14h case    3:*/		regs.R28 = regs.R5;
		/* 821EEB14h case    3:*/		return 0x821EEB18;
		  /* 821EEB18h */ case    4:  		/* mr R27, R6 */
		/* 821EEB18h case    4:*/		regs.R27 = regs.R6;
		/* 821EEB18h case    4:*/		return 0x821EEB1C;
		  /* 821EEB1Ch */ case    5:  		/* li R8, 4 */
		/* 821EEB1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EEB1Ch case    5:*/		return 0x821EEB20;
		  /* 821EEB20h */ case    6:  		/* li R7, 3 */
		/* 821EEB20h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821EEB20h case    6:*/		return 0x821EEB24;
		  /* 821EEB24h */ case    7:  		/* li R6, 13 */
		/* 821EEB24h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0xD);
		/* 821EEB24h case    7:*/		return 0x821EEB28;
		  /* 821EEB28h */ case    8:  		/* li R5, 0 */
		/* 821EEB28h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EEB28h case    8:*/		return 0x821EEB2C;
		  /* 821EEB2Ch */ case    9:  		/* mr R29, R4 */
		/* 821EEB2Ch case    9:*/		regs.R29 = regs.R4;
		/* 821EEB2Ch case    9:*/		return 0x821EEB30;
		  /* 821EEB30h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EEB30h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EEB30h case   10:*/		return 0x821EEB34;
		  /* 821EEB34h */ case   11:  		/* mr R30, R3 */
		/* 821EEB34h case   11:*/		regs.R30 = regs.R3;
		/* 821EEB34h case   11:*/		return 0x821EEB38;
		  /* 821EEB38h */ case   12:  		/* bl 220768 */
		/* 821EEB38h case   12:*/		regs.LR = 0x821EEB3C; return 0x82224998;
		/* 821EEB38h case   12:*/		return 0x821EEB3C;
		  /* 821EEB3Ch */ case   13:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EEB3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EEB3Ch case   13:*/		return 0x821EEB40;
		  /* 821EEB40h */ case   14:  		/* mr R31, R3 */
		/* 821EEB40h case   14:*/		regs.R31 = regs.R3;
		/* 821EEB40h case   14:*/		return 0x821EEB44;
		  /* 821EEB44h */ case   15:  		/* mr R4, R29 */
		/* 821EEB44h case   15:*/		regs.R4 = regs.R29;
		/* 821EEB44h case   15:*/		return 0x821EEB48;
		  /* 821EEB48h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 821EEB48h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEB48h case   16:*/		return 0x821EEB4C;
		  /* 821EEB4Ch */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEB4Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x821EEB60;  }
		/* 821EEB4Ch case   17:*/		return 0x821EEB50;
		  /* 821EEB50h */ case   18:  		/* mr R3, R30 */
		/* 821EEB50h case   18:*/		regs.R3 = regs.R30;
		/* 821EEB50h case   18:*/		return 0x821EEB54;
		  /* 821EEB54h */ case   19:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EEB54h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EEB54h case   19:*/		return 0x821EEB58;
		  /* 821EEB58h */ case   20:  		/* bl -514664 */
		/* 821EEB58h case   20:*/		regs.LR = 0x821EEB5C; return 0x821710F0;
		/* 821EEB58h case   20:*/		return 0x821EEB5C;
		  /* 821EEB5Ch */ case   21:  		/* mr R4, R3 */
		/* 821EEB5Ch case   21:*/		regs.R4 = regs.R3;
		/* 821EEB5Ch case   21:*/		return 0x821EEB60;
	}
	return 0x821EEB60;
} // Block from 821EEB08h-821EEB60h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EEB60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEB60);
		  /* 821EEB60h */ case    0:  		/* mr R3, R31 */
		/* 821EEB60h case    0:*/		regs.R3 = regs.R31;
		/* 821EEB60h case    0:*/		return 0x821EEB64;
		  /* 821EEB64h */ case    1:  		/* bl -485788 */
		/* 821EEB64h case    1:*/		regs.LR = 0x821EEB68; return 0x821781C8;
		/* 821EEB64h case    1:*/		return 0x821EEB68;
		  /* 821EEB68h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EEB68h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEB68h case    2:*/		return 0x821EEB6C;
		  /* 821EEB6Ch */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EEB6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EEB6Ch case    3:*/		return 0x821EEB70;
		  /* 821EEB70h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EEB70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEB70h case    4:*/		return 0x821EEB74;
		  /* 821EEB74h */ case    5:  		/* mr R4, R28 */
		/* 821EEB74h case    5:*/		regs.R4 = regs.R28;
		/* 821EEB74h case    5:*/		return 0x821EEB78;
		  /* 821EEB78h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEB78h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EEB8C;  }
		/* 821EEB78h case    6:*/		return 0x821EEB7C;
		  /* 821EEB7Ch */ case    7:  		/* mr R3, R30 */
		/* 821EEB7Ch case    7:*/		regs.R3 = regs.R30;
		/* 821EEB7Ch case    7:*/		return 0x821EEB80;
		  /* 821EEB80h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EEB80h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EEB80h case    8:*/		return 0x821EEB84;
		  /* 821EEB84h */ case    9:  		/* bl -514708 */
		/* 821EEB84h case    9:*/		regs.LR = 0x821EEB88; return 0x821710F0;
		/* 821EEB84h case    9:*/		return 0x821EEB88;
		  /* 821EEB88h */ case   10:  		/* mr R4, R3 */
		/* 821EEB88h case   10:*/		regs.R4 = regs.R3;
		/* 821EEB88h case   10:*/		return 0x821EEB8C;
	}
	return 0x821EEB8C;
} // Block from 821EEB60h-821EEB8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EEB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEB8C);
		  /* 821EEB8Ch */ case    0:  		/* mr R3, R31 */
		/* 821EEB8Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EEB8Ch case    0:*/		return 0x821EEB90;
		  /* 821EEB90h */ case    1:  		/* bl -485832 */
		/* 821EEB90h case    1:*/		regs.LR = 0x821EEB94; return 0x821781C8;
		/* 821EEB90h case    1:*/		return 0x821EEB94;
		  /* 821EEB94h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821EEB94h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EEB94h case    2:*/		return 0x821EEB98;
		  /* 821EEB98h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 821EEB98h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 821EEB98h case    3:*/		return 0x821EEB9C;
		  /* 821EEB9Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EEB9Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEB9Ch case    4:*/		return 0x821EEBA0;
		  /* 821EEBA0h */ case    5:  		/* mr R4, R27 */
		/* 821EEBA0h case    5:*/		regs.R4 = regs.R27;
		/* 821EEBA0h case    5:*/		return 0x821EEBA4;
		  /* 821EEBA4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEBA4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EEBB8;  }
		/* 821EEBA4h case    6:*/		return 0x821EEBA8;
		  /* 821EEBA8h */ case    7:  		/* mr R3, R30 */
		/* 821EEBA8h case    7:*/		regs.R3 = regs.R30;
		/* 821EEBA8h case    7:*/		return 0x821EEBAC;
		  /* 821EEBACh */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 821EEBACh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 821EEBACh case    8:*/		return 0x821EEBB0;
		  /* 821EEBB0h */ case    9:  		/* bl -514752 */
		/* 821EEBB0h case    9:*/		regs.LR = 0x821EEBB4; return 0x821710F0;
		/* 821EEBB0h case    9:*/		return 0x821EEBB4;
		  /* 821EEBB4h */ case   10:  		/* mr R4, R3 */
		/* 821EEBB4h case   10:*/		regs.R4 = regs.R3;
		/* 821EEBB4h case   10:*/		return 0x821EEBB8;
	}
	return 0x821EEBB8;
} // Block from 821EEB8Ch-821EEBB8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EEBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEBB8);
		  /* 821EEBB8h */ case    0:  		/* mr R3, R31 */
		/* 821EEBB8h case    0:*/		regs.R3 = regs.R31;
		/* 821EEBB8h case    0:*/		return 0x821EEBBC;
		  /* 821EEBBCh */ case    1:  		/* bl -485876 */
		/* 821EEBBCh case    1:*/		regs.LR = 0x821EEBC0; return 0x821781C8;
		/* 821EEBBCh case    1:*/		return 0x821EEBC0;
	}
	return 0x821EEBC0;
} // Block from 821EEBB8h-821EEBC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EEBC0h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEBC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEBC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEBC0);
		  /* 821EEBC0h */ case    0:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EEBC0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEBC0h case    0:*/		return 0x821EEBC4;
		  /* 821EEBC4h */ case    1:  		/* stw R3, <#[R31 + 52]> */
		/* 821EEBC4h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 821EEBC4h case    1:*/		return 0x821EEBC8;
		  /* 821EEBC8h */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EEBC8h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EEBC8h case    2:*/		return 0x821EEBCC;
		  /* 821EEBCCh */ case    3:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EEBCCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEBCCh case    3:*/		return 0x821EEBD0;
		  /* 821EEBD0h */ case    4:  		/* mr R3, R31 */
		/* 821EEBD0h case    4:*/		regs.R3 = regs.R31;
		/* 821EEBD0h case    4:*/		return 0x821EEBD4;
		  /* 821EEBD4h */ case    5:  		/* addi R11, R11, 36 */
		/* 821EEBD4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EEBD4h case    5:*/		return 0x821EEBD8;
		  /* 821EEBD8h */ case    6:  		/* lwz R10, <#[R10]> */
		/* 821EEBD8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEBD8h case    6:*/		return 0x821EEBDC;
		  /* 821EEBDCh */ case    7:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EEBDCh case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EEBDCh case    7:*/		return 0x821EEBE0;
		  /* 821EEBE0h */ case    8:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EEBE0h case    8:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EEBE0h case    8:*/		return 0x821EEBE4;
		  /* 821EEBE4h */ case    9:  		/* addi R8, R11, -36 */
		/* 821EEBE4h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EEBE4h case    9:*/		return 0x821EEBE8;
		  /* 821EEBE8h */ case   10:  		/* stw R9, <#[R31 + 8]> */
		/* 821EEBE8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEBE8h case   10:*/		return 0x821EEBEC;
		  /* 821EEBECh */ case   11:  		/* addi R9, R11, 4 */
		/* 821EEBECh case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EEBECh case   11:*/		return 0x821EEBF0;
		  /* 821EEBF0h */ case   12:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EEBF0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EEBF0h case   12:*/		return 0x821EEBF4;
		  /* 821EEBF4h */ case   13:  		/* addi R10, R10, 24 */
		/* 821EEBF4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EEBF4h case   13:*/		return 0x821EEBF8;
		  /* 821EEBF8h */ case   14:  		/* lwz R7, <#[R10]> */
		/* 821EEBF8h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEBF8h case   14:*/		return 0x821EEBFC;
		  /* 821EEBFCh */ case   15:  		/* addi R6, R10, -36 */
		/* 821EEBFCh case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EEBFCh case   15:*/		return 0x821EEC00;
		  /* 821EEC00h */ case   16:  		/* stw R7, <#[R11]> */
		/* 821EEC00h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEC00h case   16:*/		return 0x821EEC04;
		  /* 821EEC04h */ case   17:  		/* lwz R7, <#[R10]> */
		/* 821EEC04h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEC04h case   17:*/		return 0x821EEC08;
		  /* 821EEC08h */ case   18:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EEC08h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EEC08h case   18:*/		return 0x821EEC0C;
		  /* 821EEC0Ch */ case   19:  		/* ori R6, R6, 1 */
		/* 821EEC0Ch case   19:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EEC0Ch case   19:*/		return 0x821EEC10;
		  /* 821EEC10h */ case   20:  		/* stw R8, <#[R7]> */
		/* 821EEC10h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EEC10h case   20:*/		return 0x821EEC14;
		  /* 821EEC14h */ case   21:  		/* stw R6, <#[R11 + 4]> */
		/* 821EEC14h case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EEC14h case   21:*/		return 0x821EEC18;
		  /* 821EEC18h */ case   22:  		/* stw R9, <#[R10]> */
		/* 821EEC18h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEC18h case   22:*/		return 0x821EEC1C;
		  /* 821EEC1Ch */ case   23:  		/* addi R1, R1, 128 */
		/* 821EEC1Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EEC1Ch case   23:*/		return 0x821EEC20;
		  /* 821EEC20h */ case   24:  		/* b -1431932 */
		/* 821EEC20h case   24:*/		return 0x820912A4;
		/* 821EEC20h case   24:*/		return 0x821EEC24;
		  /* 821EEC24h */ case   25:  		/* nop */
		/* 821EEC24h case   25:*/		cpu::op::nop();
		/* 821EEC24h case   25:*/		return 0x821EEC28;
	}
	return 0x821EEC28;
} // Block from 821EEBC0h-821EEC28h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821EEC28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEC28);
		  /* 821EEC28h */ case    0:  		/* mfspr R12, LR */
		/* 821EEC28h case    0:*/		regs.R12 = regs.LR;
		/* 821EEC28h case    0:*/		return 0x821EEC2C;
		  /* 821EEC2Ch */ case    1:  		/* bl -1432020 */
		/* 821EEC2Ch case    1:*/		regs.LR = 0x821EEC30; return 0x82091258;
		/* 821EEC2Ch case    1:*/		return 0x821EEC30;
		  /* 821EEC30h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EEC30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EEC30h case    2:*/		return 0x821EEC34;
		  /* 821EEC34h */ case    3:  		/* mr R28, R5 */
		/* 821EEC34h case    3:*/		regs.R28 = regs.R5;
		/* 821EEC34h case    3:*/		return 0x821EEC38;
		  /* 821EEC38h */ case    4:  		/* li R8, 4 */
		/* 821EEC38h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EEC38h case    4:*/		return 0x821EEC3C;
		  /* 821EEC3Ch */ case    5:  		/* li R7, 2 */
		/* 821EEC3Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EEC3Ch case    5:*/		return 0x821EEC40;
		  /* 821EEC40h */ case    6:  		/* li R6, 16 */
		/* 821EEC40h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x10);
		/* 821EEC40h case    6:*/		return 0x821EEC44;
		  /* 821EEC44h */ case    7:  		/* li R5, 0 */
		/* 821EEC44h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EEC44h case    7:*/		return 0x821EEC48;
		  /* 821EEC48h */ case    8:  		/* mr R29, R4 */
		/* 821EEC48h case    8:*/		regs.R29 = regs.R4;
		/* 821EEC48h case    8:*/		return 0x821EEC4C;
		  /* 821EEC4Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EEC4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EEC4Ch case    9:*/		return 0x821EEC50;
		  /* 821EEC50h */ case   10:  		/* mr R30, R3 */
		/* 821EEC50h case   10:*/		regs.R30 = regs.R3;
		/* 821EEC50h case   10:*/		return 0x821EEC54;
		  /* 821EEC54h */ case   11:  		/* bl 220484 */
		/* 821EEC54h case   11:*/		regs.LR = 0x821EEC58; return 0x82224998;
		/* 821EEC54h case   11:*/		return 0x821EEC58;
		  /* 821EEC58h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EEC58h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EEC58h case   12:*/		return 0x821EEC5C;
		  /* 821EEC5Ch */ case   13:  		/* mr R31, R3 */
		/* 821EEC5Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EEC5Ch case   13:*/		return 0x821EEC60;
		  /* 821EEC60h */ case   14:  		/* mr R4, R29 */
		/* 821EEC60h case   14:*/		regs.R4 = regs.R29;
		/* 821EEC60h case   14:*/		return 0x821EEC64;
		  /* 821EEC64h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EEC64h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEC64h case   15:*/		return 0x821EEC68;
		  /* 821EEC68h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEC68h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EEC7C;  }
		/* 821EEC68h case   16:*/		return 0x821EEC6C;
		  /* 821EEC6Ch */ case   17:  		/* mr R3, R30 */
		/* 821EEC6Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EEC6Ch case   17:*/		return 0x821EEC70;
		  /* 821EEC70h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EEC70h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EEC70h case   18:*/		return 0x821EEC74;
		  /* 821EEC74h */ case   19:  		/* bl -514948 */
		/* 821EEC74h case   19:*/		regs.LR = 0x821EEC78; return 0x821710F0;
		/* 821EEC74h case   19:*/		return 0x821EEC78;
		  /* 821EEC78h */ case   20:  		/* mr R4, R3 */
		/* 821EEC78h case   20:*/		regs.R4 = regs.R3;
		/* 821EEC78h case   20:*/		return 0x821EEC7C;
	}
	return 0x821EEC7C;
} // Block from 821EEC28h-821EEC7Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EEC7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEC7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEC7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEC7C);
		  /* 821EEC7Ch */ case    0:  		/* mr R3, R31 */
		/* 821EEC7Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EEC7Ch case    0:*/		return 0x821EEC80;
		  /* 821EEC80h */ case    1:  		/* bl -486072 */
		/* 821EEC80h case    1:*/		regs.LR = 0x821EEC84; return 0x821781C8;
		/* 821EEC80h case    1:*/		return 0x821EEC84;
		  /* 821EEC84h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EEC84h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEC84h case    2:*/		return 0x821EEC88;
		  /* 821EEC88h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EEC88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EEC88h case    3:*/		return 0x821EEC8C;
		  /* 821EEC8Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EEC8Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEC8Ch case    4:*/		return 0x821EEC90;
		  /* 821EEC90h */ case    5:  		/* mr R4, R28 */
		/* 821EEC90h case    5:*/		regs.R4 = regs.R28;
		/* 821EEC90h case    5:*/		return 0x821EEC94;
		  /* 821EEC94h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEC94h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EECA8;  }
		/* 821EEC94h case    6:*/		return 0x821EEC98;
		  /* 821EEC98h */ case    7:  		/* mr R3, R30 */
		/* 821EEC98h case    7:*/		regs.R3 = regs.R30;
		/* 821EEC98h case    7:*/		return 0x821EEC9C;
		  /* 821EEC9Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EEC9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EEC9Ch case    8:*/		return 0x821EECA0;
		  /* 821EECA0h */ case    9:  		/* bl -514992 */
		/* 821EECA0h case    9:*/		regs.LR = 0x821EECA4; return 0x821710F0;
		/* 821EECA0h case    9:*/		return 0x821EECA4;
		  /* 821EECA4h */ case   10:  		/* mr R4, R3 */
		/* 821EECA4h case   10:*/		regs.R4 = regs.R3;
		/* 821EECA4h case   10:*/		return 0x821EECA8;
	}
	return 0x821EECA8;
} // Block from 821EEC7Ch-821EECA8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EECA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EECA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EECA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EECA8);
		  /* 821EECA8h */ case    0:  		/* mr R3, R31 */
		/* 821EECA8h case    0:*/		regs.R3 = regs.R31;
		/* 821EECA8h case    0:*/		return 0x821EECAC;
		  /* 821EECACh */ case    1:  		/* bl -486116 */
		/* 821EECACh case    1:*/		regs.LR = 0x821EECB0; return 0x821781C8;
		/* 821EECACh case    1:*/		return 0x821EECB0;
	}
	return 0x821EECB0;
} // Block from 821EECA8h-821EECB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EECB0h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EECB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EECB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EECB0);
		  /* 821EECB0h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821EECB0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821EECB0h case    0:*/		return 0x821EECB4;
		  /* 821EECB4h */ case    1:  		/* li R9, 1 */
		/* 821EECB4h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821EECB4h case    1:*/		return 0x821EECB8;
		  /* 821EECB8h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821EECB8h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EECB8h case    2:*/		return 0x821EECBC;
		  /* 821EECBCh */ case    3:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EECBCh case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EECBCh case    3:*/		return 0x821EECC0;
		  /* 821EECC0h */ case    4:  		/* rlwimi R10, R9, 14, 15, 17 */
		/* 821EECC0h case    4:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R9);
		/* 821EECC0h case    4:*/		return 0x821EECC4;
		  /* 821EECC4h */ case    5:  		/* addi R11, R11, 36 */
		/* 821EECC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EECC4h case    5:*/		return 0x821EECC8;
		  /* 821EECC8h */ case    6:  		/* stw R10, <#[R31 + 8]> */
		/* 821EECC8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821EECC8h case    6:*/		return 0x821EECCC;
		  /* 821EECCCh */ case    7:  		/* mr R3, R31 */
		/* 821EECCCh case    7:*/		regs.R3 = regs.R31;
		/* 821EECCCh case    7:*/		return 0x821EECD0;
		  /* 821EECD0h */ case    8:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EECD0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EECD0h case    8:*/		return 0x821EECD4;
		  /* 821EECD4h */ case    9:  		/* addi R10, R10, 24 */
		/* 821EECD4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EECD4h case    9:*/		return 0x821EECD8;
		  /* 821EECD8h */ case   10:  		/* lwz R9, <#[R10]> */
		/* 821EECD8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EECD8h case   10:*/		return 0x821EECDC;
		  /* 821EECDCh */ case   11:  		/* addi R8, R10, -36 */
		/* 821EECDCh case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFDC);
		/* 821EECDCh case   11:*/		return 0x821EECE0;
		  /* 821EECE0h */ case   12:  		/* stw R9, <#[R11]> */
		/* 821EECE0h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EECE0h case   12:*/		return 0x821EECE4;
		  /* 821EECE4h */ case   13:  		/* addi R9, R11, -36 */
		/* 821EECE4h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821EECE4h case   13:*/		return 0x821EECE8;
		  /* 821EECE8h */ case   14:  		/* lwz R7, <#[R10]> */
		/* 821EECE8h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EECE8h case   14:*/		return 0x821EECEC;
		  /* 821EECECh */ case   15:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EECECh case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EECECh case   15:*/		return 0x821EECF0;
		  /* 821EECF0h */ case   16:  		/* stw R9, <#[R7]> */
		/* 821EECF0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821EECF0h case   16:*/		return 0x821EECF4;
		  /* 821EECF4h */ case   17:  		/* ori R8, R8, 1 */
		/* 821EECF4h case   17:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EECF4h case   17:*/		return 0x821EECF8;
		  /* 821EECF8h */ case   18:  		/* addi R9, R11, 4 */
		/* 821EECF8h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EECF8h case   18:*/		return 0x821EECFC;
		  /* 821EECFCh */ case   19:  		/* stw R8, <#[R11 + 4]> */
		/* 821EECFCh case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821EECFCh case   19:*/		return 0x821EED00;
		  /* 821EED00h */ case   20:  		/* stw R9, <#[R10]> */
		/* 821EED00h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EED00h case   20:*/		return 0x821EED04;
		  /* 821EED04h */ case   21:  		/* addi R1, R1, 128 */
		/* 821EED04h case   21:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EED04h case   21:*/		return 0x821EED08;
		  /* 821EED08h */ case   22:  		/* b -1432160 */
		/* 821EED08h case   22:*/		return 0x820912A8;
		/* 821EED08h case   22:*/		return 0x821EED0C;
		  /* 821EED0Ch */ case   23:  		/* nop */
		/* 821EED0Ch case   23:*/		cpu::op::nop();
		/* 821EED0Ch case   23:*/		return 0x821EED10;
	}
	return 0x821EED10;
} // Block from 821EECB0h-821EED10h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821EED10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EED10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EED10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EED10);
		  /* 821EED10h */ case    0:  		/* mfspr R12, LR */
		/* 821EED10h case    0:*/		regs.R12 = regs.LR;
		/* 821EED10h case    0:*/		return 0x821EED14;
		  /* 821EED14h */ case    1:  		/* bl -1432252 */
		/* 821EED14h case    1:*/		regs.LR = 0x821EED18; return 0x82091258;
		/* 821EED14h case    1:*/		return 0x821EED18;
		  /* 821EED18h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EED18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EED18h case    2:*/		return 0x821EED1C;
		  /* 821EED1Ch */ case    3:  		/* mr R28, R5 */
		/* 821EED1Ch case    3:*/		regs.R28 = regs.R5;
		/* 821EED1Ch case    3:*/		return 0x821EED20;
		  /* 821EED20h */ case    4:  		/* li R8, 4 */
		/* 821EED20h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EED20h case    4:*/		return 0x821EED24;
		  /* 821EED24h */ case    5:  		/* li R7, 2 */
		/* 821EED24h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EED24h case    5:*/		return 0x821EED28;
		  /* 821EED28h */ case    6:  		/* li R6, 19 */
		/* 821EED28h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x13);
		/* 821EED28h case    6:*/		return 0x821EED2C;
		  /* 821EED2Ch */ case    7:  		/* li R5, 0 */
		/* 821EED2Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EED2Ch case    7:*/		return 0x821EED30;
		  /* 821EED30h */ case    8:  		/* mr R29, R4 */
		/* 821EED30h case    8:*/		regs.R29 = regs.R4;
		/* 821EED30h case    8:*/		return 0x821EED34;
		  /* 821EED34h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EED34h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EED34h case    9:*/		return 0x821EED38;
		  /* 821EED38h */ case   10:  		/* mr R30, R3 */
		/* 821EED38h case   10:*/		regs.R30 = regs.R3;
		/* 821EED38h case   10:*/		return 0x821EED3C;
		  /* 821EED3Ch */ case   11:  		/* bl 220252 */
		/* 821EED3Ch case   11:*/		regs.LR = 0x821EED40; return 0x82224998;
		/* 821EED3Ch case   11:*/		return 0x821EED40;
		  /* 821EED40h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EED40h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EED40h case   12:*/		return 0x821EED44;
		  /* 821EED44h */ case   13:  		/* mr R31, R3 */
		/* 821EED44h case   13:*/		regs.R31 = regs.R3;
		/* 821EED44h case   13:*/		return 0x821EED48;
		  /* 821EED48h */ case   14:  		/* mr R4, R29 */
		/* 821EED48h case   14:*/		regs.R4 = regs.R29;
		/* 821EED48h case   14:*/		return 0x821EED4C;
		  /* 821EED4Ch */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EED4Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EED4Ch case   15:*/		return 0x821EED50;
		  /* 821EED50h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EED50h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EED64;  }
		/* 821EED50h case   16:*/		return 0x821EED54;
		  /* 821EED54h */ case   17:  		/* mr R3, R30 */
		/* 821EED54h case   17:*/		regs.R3 = regs.R30;
		/* 821EED54h case   17:*/		return 0x821EED58;
		  /* 821EED58h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EED58h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EED58h case   18:*/		return 0x821EED5C;
		  /* 821EED5Ch */ case   19:  		/* bl -515180 */
		/* 821EED5Ch case   19:*/		regs.LR = 0x821EED60; return 0x821710F0;
		/* 821EED5Ch case   19:*/		return 0x821EED60;
		  /* 821EED60h */ case   20:  		/* mr R4, R3 */
		/* 821EED60h case   20:*/		regs.R4 = regs.R3;
		/* 821EED60h case   20:*/		return 0x821EED64;
	}
	return 0x821EED64;
} // Block from 821EED10h-821EED64h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EED64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EED64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EED64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EED64);
		  /* 821EED64h */ case    0:  		/* mr R3, R31 */
		/* 821EED64h case    0:*/		regs.R3 = regs.R31;
		/* 821EED64h case    0:*/		return 0x821EED68;
		  /* 821EED68h */ case    1:  		/* bl -486304 */
		/* 821EED68h case    1:*/		regs.LR = 0x821EED6C; return 0x821781C8;
		/* 821EED68h case    1:*/		return 0x821EED6C;
		  /* 821EED6Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EED6Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EED6Ch case    2:*/		return 0x821EED70;
		  /* 821EED70h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EED70h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EED70h case    3:*/		return 0x821EED74;
		  /* 821EED74h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EED74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EED74h case    4:*/		return 0x821EED78;
		  /* 821EED78h */ case    5:  		/* mr R4, R28 */
		/* 821EED78h case    5:*/		regs.R4 = regs.R28;
		/* 821EED78h case    5:*/		return 0x821EED7C;
		  /* 821EED7Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EED7Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821EED90;  }
		/* 821EED7Ch case    6:*/		return 0x821EED80;
		  /* 821EED80h */ case    7:  		/* mr R3, R30 */
		/* 821EED80h case    7:*/		regs.R3 = regs.R30;
		/* 821EED80h case    7:*/		return 0x821EED84;
		  /* 821EED84h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EED84h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EED84h case    8:*/		return 0x821EED88;
		  /* 821EED88h */ case    9:  		/* bl -515224 */
		/* 821EED88h case    9:*/		regs.LR = 0x821EED8C; return 0x821710F0;
		/* 821EED88h case    9:*/		return 0x821EED8C;
		  /* 821EED8Ch */ case   10:  		/* mr R4, R3 */
		/* 821EED8Ch case   10:*/		regs.R4 = regs.R3;
		/* 821EED8Ch case   10:*/		return 0x821EED90;
	}
	return 0x821EED90;
} // Block from 821EED64h-821EED90h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EED90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EED90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EED90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EED90);
		  /* 821EED90h */ case    0:  		/* mr R3, R31 */
		/* 821EED90h case    0:*/		regs.R3 = regs.R31;
		/* 821EED90h case    0:*/		return 0x821EED94;
		  /* 821EED94h */ case    1:  		/* bl -486348 */
		/* 821EED94h case    1:*/		regs.LR = 0x821EED98; return 0x821781C8;
		/* 821EED94h case    1:*/		return 0x821EED98;
		  /* 821EED98h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821EED98h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EED98h case    2:*/		return 0x821EED9C;
		  /* 821EED9Ch */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EED9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EED9Ch case    3:*/		return 0x821EEDA0;
	}
	return 0x821EEDA0;
} // Block from 821EED90h-821EEDA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EEDA0h
// Function '?MakeInstr_V_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEDA0);
		  /* 821EEDA0h */ case    0:  		/* addi R11, R11, 24 */
		/* 821EEDA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EEDA0h case    0:*/		return 0x821EEDA4;
		  /* 821EEDA4h */ case    1:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EEDA4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EEDA4h case    1:*/		return 0x821EEDA8;
		  /* 821EEDA8h */ case    2:  		/* lwz R9, <#[R11]> */
		/* 821EEDA8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEDA8h case    2:*/		return 0x821EEDAC;
		  /* 821EEDACh */ case    3:  		/* addi R8, R11, -36 */
		/* 821EEDACh case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EEDACh case    3:*/		return 0x821EEDB0;
		  /* 821EEDB0h */ case    4:  		/* addi R10, R10, 36 */
		/* 821EEDB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EEDB0h case    4:*/		return 0x821EEDB4;
		  /* 821EEDB4h */ case    5:  		/* stw R9, <#[R10]> */
		/* 821EEDB4h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEDB4h case    5:*/		return 0x821EEDB8;
		  /* 821EEDB8h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EEDB8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEDB8h case    6:*/		return 0x821EEDBC;
		  /* 821EEDBCh */ case    7:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EEDBCh case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EEDBCh case    7:*/		return 0x821EEDC0;
		  /* 821EEDC0h */ case    8:  		/* addi R6, R10, -36 */
		/* 821EEDC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EEDC0h case    8:*/		return 0x821EEDC4;
		  /* 821EEDC4h */ case    9:  		/* ori R8, R8, 1 */
		/* 821EEDC4h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EEDC4h case    9:*/		return 0x821EEDC8;
		  /* 821EEDC8h */ case   10:  		/* addi R9, R10, 4 */
		/* 821EEDC8h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EEDC8h case   10:*/		return 0x821EEDCC;
		  /* 821EEDCCh */ case   11:  		/* stw R6, <#[R7]> */
		/* 821EEDCCh case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EEDCCh case   11:*/		return 0x821EEDD0;
		  /* 821EEDD0h */ case   12:  		/* stw R8, <#[R10 + 4]> */
		/* 821EEDD0h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EEDD0h case   12:*/		return 0x821EEDD4;
		  /* 821EEDD4h */ case   13:  		/* mr R3, R31 */
		/* 821EEDD4h case   13:*/		regs.R3 = regs.R31;
		/* 821EEDD4h case   13:*/		return 0x821EEDD8;
		  /* 821EEDD8h */ case   14:  		/* stw R9, <#[R11]> */
		/* 821EEDD8h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEDD8h case   14:*/		return 0x821EEDDC;
		  /* 821EEDDCh */ case   15:  		/* addi R1, R1, 128 */
		/* 821EEDDCh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EEDDCh case   15:*/		return 0x821EEDE0;
		  /* 821EEDE0h */ case   16:  		/* b -1432376 */
		/* 821EEDE0h case   16:*/		return 0x820912A8;
		/* 821EEDE0h case   16:*/		return 0x821EEDE4;
		  /* 821EEDE4h */ case   17:  		/* nop */
		/* 821EEDE4h case   17:*/		cpu::op::nop();
		/* 821EEDE4h case   17:*/		return 0x821EEDE8;
	}
	return 0x821EEDE8;
} // Block from 821EEDA0h-821EEDE8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EEDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEDE8);
		  /* 821EEDE8h */ case    0:  		/* mfspr R12, LR */
		/* 821EEDE8h case    0:*/		regs.R12 = regs.LR;
		/* 821EEDE8h case    0:*/		return 0x821EEDEC;
		  /* 821EEDECh */ case    1:  		/* bl -1432464 */
		/* 821EEDECh case    1:*/		regs.LR = 0x821EEDF0; return 0x8209125C;
		/* 821EEDECh case    1:*/		return 0x821EEDF0;
		  /* 821EEDF0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EEDF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EEDF0h case    2:*/		return 0x821EEDF4;
		  /* 821EEDF4h */ case    3:  		/* li R8, 4 */
		/* 821EEDF4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EEDF4h case    3:*/		return 0x821EEDF8;
		  /* 821EEDF8h */ case    4:  		/* li R7, 1 */
		/* 821EEDF8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EEDF8h case    4:*/		return 0x821EEDFC;
		  /* 821EEDFCh */ case    5:  		/* li R6, 20 */
		/* 821EEDFCh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x14);
		/* 821EEDFCh case    5:*/		return 0x821EEE00;
		  /* 821EEE00h */ case    6:  		/* li R5, 0 */
		/* 821EEE00h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EEE00h case    6:*/		return 0x821EEE04;
		  /* 821EEE04h */ case    7:  		/* mr R29, R4 */
		/* 821EEE04h case    7:*/		regs.R29 = regs.R4;
		/* 821EEE04h case    7:*/		return 0x821EEE08;
		  /* 821EEE08h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EEE08h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EEE08h case    8:*/		return 0x821EEE0C;
		  /* 821EEE0Ch */ case    9:  		/* mr R30, R3 */
		/* 821EEE0Ch case    9:*/		regs.R30 = regs.R3;
		/* 821EEE0Ch case    9:*/		return 0x821EEE10;
		  /* 821EEE10h */ case   10:  		/* bl 220040 */
		/* 821EEE10h case   10:*/		regs.LR = 0x821EEE14; return 0x82224998;
		/* 821EEE10h case   10:*/		return 0x821EEE14;
		  /* 821EEE14h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EEE14h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EEE14h case   11:*/		return 0x821EEE18;
		  /* 821EEE18h */ case   12:  		/* mr R31, R3 */
		/* 821EEE18h case   12:*/		regs.R31 = regs.R3;
		/* 821EEE18h case   12:*/		return 0x821EEE1C;
		  /* 821EEE1Ch */ case   13:  		/* mr R4, R29 */
		/* 821EEE1Ch case   13:*/		regs.R4 = regs.R29;
		/* 821EEE1Ch case   13:*/		return 0x821EEE20;
		  /* 821EEE20h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EEE20h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEE20h case   14:*/		return 0x821EEE24;
		  /* 821EEE24h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEE24h case   15:*/		if ( regs.CR[6].eq ) { return 0x821EEE38;  }
		/* 821EEE24h case   15:*/		return 0x821EEE28;
		  /* 821EEE28h */ case   16:  		/* mr R3, R30 */
		/* 821EEE28h case   16:*/		regs.R3 = regs.R30;
		/* 821EEE28h case   16:*/		return 0x821EEE2C;
		  /* 821EEE2Ch */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EEE2Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EEE2Ch case   17:*/		return 0x821EEE30;
		  /* 821EEE30h */ case   18:  		/* bl -515392 */
		/* 821EEE30h case   18:*/		regs.LR = 0x821EEE34; return 0x821710F0;
		/* 821EEE30h case   18:*/		return 0x821EEE34;
		  /* 821EEE34h */ case   19:  		/* mr R4, R3 */
		/* 821EEE34h case   19:*/		regs.R4 = regs.R3;
		/* 821EEE34h case   19:*/		return 0x821EEE38;
	}
	return 0x821EEE38;
} // Block from 821EEDE8h-821EEE38h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EEE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEE38);
		  /* 821EEE38h */ case    0:  		/* mr R3, R31 */
		/* 821EEE38h case    0:*/		regs.R3 = regs.R31;
		/* 821EEE38h case    0:*/		return 0x821EEE3C;
		  /* 821EEE3Ch */ case    1:  		/* bl -486516 */
		/* 821EEE3Ch case    1:*/		regs.LR = 0x821EEE40; return 0x821781C8;
		/* 821EEE3Ch case    1:*/		return 0x821EEE40;
		  /* 821EEE40h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821EEE40h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEE40h case    2:*/		return 0x821EEE44;
		  /* 821EEE44h */ case    3:  		/* li R9, 1 */
		/* 821EEE44h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821EEE44h case    3:*/		return 0x821EEE48;
		  /* 821EEE48h */ case    4:  		/* stw R3, <#[R31 + 44]> */
		/* 821EEE48h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEE48h case    4:*/		return 0x821EEE4C;
		  /* 821EEE4Ch */ case    5:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EEE4Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EEE4Ch case    5:*/		return 0x821EEE50;
		  /* 821EEE50h */ case    6:  		/* rlwimi R10, R9, 14, 15, 17 */
		/* 821EEE50h case    6:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R9);
		/* 821EEE50h case    6:*/		return 0x821EEE54;
		  /* 821EEE54h */ case    7:  		/* addi R11, R11, 36 */
		/* 821EEE54h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EEE54h case    7:*/		return 0x821EEE58;
		  /* 821EEE58h */ case    8:  		/* stw R10, <#[R31 + 8]> */
		/* 821EEE58h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEE58h case    8:*/		return 0x821EEE5C;
		  /* 821EEE5Ch */ case    9:  		/* mr R3, R31 */
		/* 821EEE5Ch case    9:*/		regs.R3 = regs.R31;
		/* 821EEE5Ch case    9:*/		return 0x821EEE60;
		  /* 821EEE60h */ case   10:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EEE60h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EEE60h case   10:*/		return 0x821EEE64;
		  /* 821EEE64h */ case   11:  		/* addi R10, R10, 24 */
		/* 821EEE64h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EEE64h case   11:*/		return 0x821EEE68;
		  /* 821EEE68h */ case   12:  		/* lwz R9, <#[R10]> */
		/* 821EEE68h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEE68h case   12:*/		return 0x821EEE6C;
		  /* 821EEE6Ch */ case   13:  		/* addi R8, R10, -36 */
		/* 821EEE6Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFDC);
		/* 821EEE6Ch case   13:*/		return 0x821EEE70;
		  /* 821EEE70h */ case   14:  		/* stw R9, <#[R11]> */
		/* 821EEE70h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEE70h case   14:*/		return 0x821EEE74;
		  /* 821EEE74h */ case   15:  		/* addi R9, R11, -36 */
		/* 821EEE74h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821EEE74h case   15:*/		return 0x821EEE78;
		  /* 821EEE78h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EEE78h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEE78h case   16:*/		return 0x821EEE7C;
		  /* 821EEE7Ch */ case   17:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EEE7Ch case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EEE7Ch case   17:*/		return 0x821EEE80;
		  /* 821EEE80h */ case   18:  		/* stw R9, <#[R7]> */
		/* 821EEE80h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821EEE80h case   18:*/		return 0x821EEE84;
		  /* 821EEE84h */ case   19:  		/* ori R8, R8, 1 */
		/* 821EEE84h case   19:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EEE84h case   19:*/		return 0x821EEE88;
		  /* 821EEE88h */ case   20:  		/* addi R9, R11, 4 */
		/* 821EEE88h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EEE88h case   20:*/		return 0x821EEE8C;
		  /* 821EEE8Ch */ case   21:  		/* stw R8, <#[R11 + 4]> */
		/* 821EEE8Ch case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821EEE8Ch case   21:*/		return 0x821EEE90;
	}
	return 0x821EEE90;
} // Block from 821EEE38h-821EEE90h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EEE90h
// Function '?MakeInstr_V_MIN@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEE90);
		  /* 821EEE90h */ case    0:  		/* stw R9, <#[R10]> */
		/* 821EEE90h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEE90h case    0:*/		return 0x821EEE94;
		  /* 821EEE94h */ case    1:  		/* addi R1, R1, 112 */
		/* 821EEE94h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EEE94h case    1:*/		return 0x821EEE98;
		  /* 821EEE98h */ case    2:  		/* b -1432556 */
		/* 821EEE98h case    2:*/		return 0x820912AC;
		/* 821EEE98h case    2:*/		return 0x821EEE9C;
		  /* 821EEE9Ch */ case    3:  		/* nop */
		/* 821EEE9Ch case    3:*/		cpu::op::nop();
		/* 821EEE9Ch case    3:*/		return 0x821EEEA0;
	}
	return 0x821EEEA0;
} // Block from 821EEE90h-821EEEA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EEEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEEA0);
		  /* 821EEEA0h */ case    0:  		/* mfspr R12, LR */
		/* 821EEEA0h case    0:*/		regs.R12 = regs.LR;
		/* 821EEEA0h case    0:*/		return 0x821EEEA4;
		  /* 821EEEA4h */ case    1:  		/* bl -1432652 */
		/* 821EEEA4h case    1:*/		regs.LR = 0x821EEEA8; return 0x82091258;
		/* 821EEEA4h case    1:*/		return 0x821EEEA8;
		  /* 821EEEA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EEEA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EEEA8h case    2:*/		return 0x821EEEAC;
		  /* 821EEEACh */ case    3:  		/* mr R28, R5 */
		/* 821EEEACh case    3:*/		regs.R28 = regs.R5;
		/* 821EEEACh case    3:*/		return 0x821EEEB0;
		  /* 821EEEB0h */ case    4:  		/* li R8, 4 */
		/* 821EEEB0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EEEB0h case    4:*/		return 0x821EEEB4;
		  /* 821EEEB4h */ case    5:  		/* li R7, 2 */
		/* 821EEEB4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EEEB4h case    5:*/		return 0x821EEEB8;
		  /* 821EEEB8h */ case    6:  		/* li R6, 26 */
		/* 821EEEB8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 821EEEB8h case    6:*/		return 0x821EEEBC;
		  /* 821EEEBCh */ case    7:  		/* li R5, 0 */
		/* 821EEEBCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EEEBCh case    7:*/		return 0x821EEEC0;
		  /* 821EEEC0h */ case    8:  		/* mr R29, R4 */
		/* 821EEEC0h case    8:*/		regs.R29 = regs.R4;
		/* 821EEEC0h case    8:*/		return 0x821EEEC4;
		  /* 821EEEC4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EEEC4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EEEC4h case    9:*/		return 0x821EEEC8;
		  /* 821EEEC8h */ case   10:  		/* mr R30, R3 */
		/* 821EEEC8h case   10:*/		regs.R30 = regs.R3;
		/* 821EEEC8h case   10:*/		return 0x821EEECC;
		  /* 821EEECCh */ case   11:  		/* bl 219852 */
		/* 821EEECCh case   11:*/		regs.LR = 0x821EEED0; return 0x82224998;
		/* 821EEECCh case   11:*/		return 0x821EEED0;
		  /* 821EEED0h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EEED0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EEED0h case   12:*/		return 0x821EEED4;
		  /* 821EEED4h */ case   13:  		/* mr R31, R3 */
		/* 821EEED4h case   13:*/		regs.R31 = regs.R3;
		/* 821EEED4h case   13:*/		return 0x821EEED8;
		  /* 821EEED8h */ case   14:  		/* mr R4, R29 */
		/* 821EEED8h case   14:*/		regs.R4 = regs.R29;
		/* 821EEED8h case   14:*/		return 0x821EEEDC;
		  /* 821EEEDCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EEEDCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEEDCh case   15:*/		return 0x821EEEE0;
		  /* 821EEEE0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEEE0h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EEEF4;  }
		/* 821EEEE0h case   16:*/		return 0x821EEEE4;
		  /* 821EEEE4h */ case   17:  		/* mr R3, R30 */
		/* 821EEEE4h case   17:*/		regs.R3 = regs.R30;
		/* 821EEEE4h case   17:*/		return 0x821EEEE8;
		  /* 821EEEE8h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EEEE8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EEEE8h case   18:*/		return 0x821EEEEC;
		  /* 821EEEECh */ case   19:  		/* bl -515580 */
		/* 821EEEECh case   19:*/		regs.LR = 0x821EEEF0; return 0x821710F0;
		/* 821EEEECh case   19:*/		return 0x821EEEF0;
		  /* 821EEEF0h */ case   20:  		/* mr R4, R3 */
		/* 821EEEF0h case   20:*/		regs.R4 = regs.R3;
		/* 821EEEF0h case   20:*/		return 0x821EEEF4;
	}
	return 0x821EEEF4;
} // Block from 821EEEA0h-821EEEF4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EEEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEEF4);
		  /* 821EEEF4h */ case    0:  		/* mr R3, R31 */
		/* 821EEEF4h case    0:*/		regs.R3 = regs.R31;
		/* 821EEEF4h case    0:*/		return 0x821EEEF8;
		  /* 821EEEF8h */ case    1:  		/* bl -486704 */
		/* 821EEEF8h case    1:*/		regs.LR = 0x821EEEFC; return 0x821781C8;
		/* 821EEEF8h case    1:*/		return 0x821EEEFC;
		  /* 821EEEFCh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EEEFCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEEFCh case    2:*/		return 0x821EEF00;
		  /* 821EEF00h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EEF00h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EEF00h case    3:*/		return 0x821EEF04;
		  /* 821EEF04h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EEF04h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEF04h case    4:*/		return 0x821EEF08;
		  /* 821EEF08h */ case    5:  		/* mr R4, R28 */
		/* 821EEF08h case    5:*/		regs.R4 = regs.R28;
		/* 821EEF08h case    5:*/		return 0x821EEF0C;
		  /* 821EEF0Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEF0Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821EEF20;  }
		/* 821EEF0Ch case    6:*/		return 0x821EEF10;
		  /* 821EEF10h */ case    7:  		/* mr R3, R30 */
		/* 821EEF10h case    7:*/		regs.R3 = regs.R30;
		/* 821EEF10h case    7:*/		return 0x821EEF14;
		  /* 821EEF14h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EEF14h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EEF14h case    8:*/		return 0x821EEF18;
		  /* 821EEF18h */ case    9:  		/* bl -515624 */
		/* 821EEF18h case    9:*/		regs.LR = 0x821EEF1C; return 0x821710F0;
		/* 821EEF18h case    9:*/		return 0x821EEF1C;
		  /* 821EEF1Ch */ case   10:  		/* mr R4, R3 */
		/* 821EEF1Ch case   10:*/		regs.R4 = regs.R3;
		/* 821EEF1Ch case   10:*/		return 0x821EEF20;
	}
	return 0x821EEF20;
} // Block from 821EEEF4h-821EEF20h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EEF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEF20);
		  /* 821EEF20h */ case    0:  		/* mr R3, R31 */
		/* 821EEF20h case    0:*/		regs.R3 = regs.R31;
		/* 821EEF20h case    0:*/		return 0x821EEF24;
		  /* 821EEF24h */ case    1:  		/* bl -486748 */
		/* 821EEF24h case    1:*/		regs.LR = 0x821EEF28; return 0x821781C8;
		/* 821EEF24h case    1:*/		return 0x821EEF28;
		  /* 821EEF28h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EEF28h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEF28h case    2:*/		return 0x821EEF2C;
		  /* 821EEF2Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EEF2Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EEF2Ch case    3:*/		return 0x821EEF30;
		  /* 821EEF30h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EEF30h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EEF30h case    4:*/		return 0x821EEF34;
		  /* 821EEF34h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EEF34h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEF34h case    5:*/		return 0x821EEF38;
		  /* 821EEF38h */ case    6:  		/* mr R3, R31 */
		/* 821EEF38h case    6:*/		regs.R3 = regs.R31;
		/* 821EEF38h case    6:*/		return 0x821EEF3C;
		  /* 821EEF3Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821EEF3Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EEF3Ch case    7:*/		return 0x821EEF40;
		  /* 821EEF40h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EEF40h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEF40h case    8:*/		return 0x821EEF44;
		  /* 821EEF44h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EEF44h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EEF44h case    9:*/		return 0x821EEF48;
		  /* 821EEF48h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EEF48h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EEF48h case   10:*/		return 0x821EEF4C;
		  /* 821EEF4Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EEF4Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EEF4Ch case   11:*/		return 0x821EEF50;
		  /* 821EEF50h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EEF50h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EEF50h case   12:*/		return 0x821EEF54;
		  /* 821EEF54h */ case   13:  		/* addi R9, R11, 4 */
		/* 821EEF54h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EEF54h case   13:*/		return 0x821EEF58;
		  /* 821EEF58h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EEF58h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EEF58h case   14:*/		return 0x821EEF5C;
		  /* 821EEF5Ch */ case   15:  		/* addi R10, R10, 24 */
		/* 821EEF5Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EEF5Ch case   15:*/		return 0x821EEF60;
		  /* 821EEF60h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EEF60h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEF60h case   16:*/		return 0x821EEF64;
		  /* 821EEF64h */ case   17:  		/* addi R6, R10, -36 */
		/* 821EEF64h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EEF64h case   17:*/		return 0x821EEF68;
		  /* 821EEF68h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EEF68h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EEF68h case   18:*/		return 0x821EEF6C;
		  /* 821EEF6Ch */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EEF6Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEF6Ch case   19:*/		return 0x821EEF70;
		  /* 821EEF70h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EEF70h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EEF70h case   20:*/		return 0x821EEF74;
		  /* 821EEF74h */ case   21:  		/* ori R6, R6, 1 */
		/* 821EEF74h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EEF74h case   21:*/		return 0x821EEF78;
		  /* 821EEF78h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EEF78h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EEF78h case   22:*/		return 0x821EEF7C;
		  /* 821EEF7Ch */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EEF7Ch case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EEF7Ch case   23:*/		return 0x821EEF80;
	}
	return 0x821EEF80;
} // Block from 821EEF20h-821EEF80h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821EEF80h
// Function '?MakeInstr_V_SETE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEF80);
		  /* 821EEF80h */ case    0:  		/* stw R9, <#[R10]> */
		/* 821EEF80h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EEF80h case    0:*/		return 0x821EEF84;
		  /* 821EEF84h */ case    1:  		/* addi R1, R1, 128 */
		/* 821EEF84h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EEF84h case    1:*/		return 0x821EEF88;
		  /* 821EEF88h */ case    2:  		/* b -1432800 */
		/* 821EEF88h case    2:*/		return 0x820912A8;
		/* 821EEF88h case    2:*/		return 0x821EEF8C;
		  /* 821EEF8Ch */ case    3:  		/* nop */
		/* 821EEF8Ch case    3:*/		cpu::op::nop();
		/* 821EEF8Ch case    3:*/		return 0x821EEF90;
	}
	return 0x821EEF90;
} // Block from 821EEF80h-821EEF90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EEF90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEF90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEF90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEF90);
		  /* 821EEF90h */ case    0:  		/* mfspr R12, LR */
		/* 821EEF90h case    0:*/		regs.R12 = regs.LR;
		/* 821EEF90h case    0:*/		return 0x821EEF94;
		  /* 821EEF94h */ case    1:  		/* bl -1432892 */
		/* 821EEF94h case    1:*/		regs.LR = 0x821EEF98; return 0x82091258;
		/* 821EEF94h case    1:*/		return 0x821EEF98;
		  /* 821EEF98h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EEF98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EEF98h case    2:*/		return 0x821EEF9C;
		  /* 821EEF9Ch */ case    3:  		/* mr R28, R5 */
		/* 821EEF9Ch case    3:*/		regs.R28 = regs.R5;
		/* 821EEF9Ch case    3:*/		return 0x821EEFA0;
		  /* 821EEFA0h */ case    4:  		/* li R8, 4 */
		/* 821EEFA0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EEFA0h case    4:*/		return 0x821EEFA4;
		  /* 821EEFA4h */ case    5:  		/* li R7, 2 */
		/* 821EEFA4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EEFA4h case    5:*/		return 0x821EEFA8;
		  /* 821EEFA8h */ case    6:  		/* li R6, 29 */
		/* 821EEFA8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1D);
		/* 821EEFA8h case    6:*/		return 0x821EEFAC;
		  /* 821EEFACh */ case    7:  		/* li R5, 0 */
		/* 821EEFACh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EEFACh case    7:*/		return 0x821EEFB0;
		  /* 821EEFB0h */ case    8:  		/* mr R29, R4 */
		/* 821EEFB0h case    8:*/		regs.R29 = regs.R4;
		/* 821EEFB0h case    8:*/		return 0x821EEFB4;
		  /* 821EEFB4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EEFB4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EEFB4h case    9:*/		return 0x821EEFB8;
		  /* 821EEFB8h */ case   10:  		/* mr R30, R3 */
		/* 821EEFB8h case   10:*/		regs.R30 = regs.R3;
		/* 821EEFB8h case   10:*/		return 0x821EEFBC;
		  /* 821EEFBCh */ case   11:  		/* bl 219612 */
		/* 821EEFBCh case   11:*/		regs.LR = 0x821EEFC0; return 0x82224998;
		/* 821EEFBCh case   11:*/		return 0x821EEFC0;
		  /* 821EEFC0h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EEFC0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EEFC0h case   12:*/		return 0x821EEFC4;
		  /* 821EEFC4h */ case   13:  		/* mr R31, R3 */
		/* 821EEFC4h case   13:*/		regs.R31 = regs.R3;
		/* 821EEFC4h case   13:*/		return 0x821EEFC8;
		  /* 821EEFC8h */ case   14:  		/* mr R4, R29 */
		/* 821EEFC8h case   14:*/		regs.R4 = regs.R29;
		/* 821EEFC8h case   14:*/		return 0x821EEFCC;
		  /* 821EEFCCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EEFCCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEFCCh case   15:*/		return 0x821EEFD0;
		  /* 821EEFD0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEFD0h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EEFE4;  }
		/* 821EEFD0h case   16:*/		return 0x821EEFD4;
		  /* 821EEFD4h */ case   17:  		/* mr R3, R30 */
		/* 821EEFD4h case   17:*/		regs.R3 = regs.R30;
		/* 821EEFD4h case   17:*/		return 0x821EEFD8;
		  /* 821EEFD8h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EEFD8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EEFD8h case   18:*/		return 0x821EEFDC;
		  /* 821EEFDCh */ case   19:  		/* bl -515820 */
		/* 821EEFDCh case   19:*/		regs.LR = 0x821EEFE0; return 0x821710F0;
		/* 821EEFDCh case   19:*/		return 0x821EEFE0;
		  /* 821EEFE0h */ case   20:  		/* mr R4, R3 */
		/* 821EEFE0h case   20:*/		regs.R4 = regs.R3;
		/* 821EEFE0h case   20:*/		return 0x821EEFE4;
	}
	return 0x821EEFE4;
} // Block from 821EEF90h-821EEFE4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EEFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EEFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EEFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EEFE4);
		  /* 821EEFE4h */ case    0:  		/* mr R3, R31 */
		/* 821EEFE4h case    0:*/		regs.R3 = regs.R31;
		/* 821EEFE4h case    0:*/		return 0x821EEFE8;
		  /* 821EEFE8h */ case    1:  		/* bl -486944 */
		/* 821EEFE8h case    1:*/		regs.LR = 0x821EEFEC; return 0x821781C8;
		/* 821EEFE8h case    1:*/		return 0x821EEFEC;
		  /* 821EEFECh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EEFECh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EEFECh case    2:*/		return 0x821EEFF0;
		  /* 821EEFF0h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EEFF0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EEFF0h case    3:*/		return 0x821EEFF4;
		  /* 821EEFF4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EEFF4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EEFF4h case    4:*/		return 0x821EEFF8;
		  /* 821EEFF8h */ case    5:  		/* mr R4, R28 */
		/* 821EEFF8h case    5:*/		regs.R4 = regs.R28;
		/* 821EEFF8h case    5:*/		return 0x821EEFFC;
		  /* 821EEFFCh */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EEFFCh case    6:*/		if ( regs.CR[6].eq ) { return 0x821EF010;  }
		/* 821EEFFCh case    6:*/		return 0x821EF000;
		  /* 821EF000h */ case    7:  		/* mr R3, R30 */
		/* 821EF000h case    7:*/		regs.R3 = regs.R30;
		/* 821EF000h case    7:*/		return 0x821EF004;
		  /* 821EF004h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EF004h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EF004h case    8:*/		return 0x821EF008;
		  /* 821EF008h */ case    9:  		/* bl -515864 */
		/* 821EF008h case    9:*/		regs.LR = 0x821EF00C; return 0x821710F0;
		/* 821EF008h case    9:*/		return 0x821EF00C;
		  /* 821EF00Ch */ case   10:  		/* mr R4, R3 */
		/* 821EF00Ch case   10:*/		regs.R4 = regs.R3;
		/* 821EF00Ch case   10:*/		return 0x821EF010;
	}
	return 0x821EF010;
} // Block from 821EEFE4h-821EF010h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EF010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF010);
		  /* 821EF010h */ case    0:  		/* mr R3, R31 */
		/* 821EF010h case    0:*/		regs.R3 = regs.R31;
		/* 821EF010h case    0:*/		return 0x821EF014;
		  /* 821EF014h */ case    1:  		/* bl -486988 */
		/* 821EF014h case    1:*/		regs.LR = 0x821EF018; return 0x821781C8;
		/* 821EF014h case    1:*/		return 0x821EF018;
		  /* 821EF018h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821EF018h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EF018h case    2:*/		return 0x821EF01C;
		  /* 821EF01Ch */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF01Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF01Ch case    3:*/		return 0x821EF020;
		  /* 821EF020h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF020h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF020h case    4:*/		return 0x821EF024;
		  /* 821EF024h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF024h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF024h case    5:*/		return 0x821EF028;
		  /* 821EF028h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF028h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF028h case    6:*/		return 0x821EF02C;
		  /* 821EF02Ch */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF02Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF02Ch case    7:*/		return 0x821EF030;
		  /* 821EF030h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF030h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF030h case    8:*/		return 0x821EF034;
		  /* 821EF034h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF034h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF034h case    9:*/		return 0x821EF038;
		  /* 821EF038h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF038h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF038h case   10:*/		return 0x821EF03C;
		  /* 821EF03Ch */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF03Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF03Ch case   11:*/		return 0x821EF040;
		  /* 821EF040h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF040h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF040h case   12:*/		return 0x821EF044;
		  /* 821EF044h */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF044h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF044h case   13:*/		return 0x821EF048;
		  /* 821EF048h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF048h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF048h case   14:*/		return 0x821EF04C;
		  /* 821EF04Ch */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF04Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF04Ch case   15:*/		return 0x821EF050;
		  /* 821EF050h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF050h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF050h case   16:*/		return 0x821EF054;
		  /* 821EF054h */ case   17:  		/* mr R3, R31 */
		/* 821EF054h case   17:*/		regs.R3 = regs.R31;
		/* 821EF054h case   17:*/		return 0x821EF058;
		  /* 821EF058h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF058h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF058h case   18:*/		return 0x821EF05C;
		  /* 821EF05Ch */ case   19:  		/* addi R1, R1, 128 */
		/* 821EF05Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EF05Ch case   19:*/		return 0x821EF060;
		  /* 821EF060h */ case   20:  		/* b -1433016 */
		/* 821EF060h case   20:*/		return 0x820912A8;
		/* 821EF060h case   20:*/		return 0x821EF064;
		  /* 821EF064h */ case   21:  		/* nop */
		/* 821EF064h case   21:*/		cpu::op::nop();
		/* 821EF064h case   21:*/		return 0x821EF068;
	}
	return 0x821EF068;
} // Block from 821EF010h-821EF068h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF068);
		  /* 821EF068h */ case    0:  		/* mfspr R12, LR */
		/* 821EF068h case    0:*/		regs.R12 = regs.LR;
		/* 821EF068h case    0:*/		return 0x821EF06C;
		  /* 821EF06Ch */ case    1:  		/* bl -1433108 */
		/* 821EF06Ch case    1:*/		regs.LR = 0x821EF070; return 0x82091258;
		/* 821EF06Ch case    1:*/		return 0x821EF070;
	}
	return 0x821EF070;
} // Block from 821EF068h-821EF070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EF070h
// Function '?MakeInstr_V_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF070);
		  /* 821EF070h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EF070h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EF070h case    0:*/		return 0x821EF074;
		  /* 821EF074h */ case    1:  		/* mr R28, R5 */
		/* 821EF074h case    1:*/		regs.R28 = regs.R5;
		/* 821EF074h case    1:*/		return 0x821EF078;
		  /* 821EF078h */ case    2:  		/* li R8, 4 */
		/* 821EF078h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF078h case    2:*/		return 0x821EF07C;
		  /* 821EF07Ch */ case    3:  		/* li R7, 2 */
		/* 821EF07Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EF07Ch case    3:*/		return 0x821EF080;
		  /* 821EF080h */ case    4:  		/* li R6, 30 */
		/* 821EF080h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x1E);
		/* 821EF080h case    4:*/		return 0x821EF084;
		  /* 821EF084h */ case    5:  		/* li R5, 0 */
		/* 821EF084h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF084h case    5:*/		return 0x821EF088;
		  /* 821EF088h */ case    6:  		/* mr R29, R4 */
		/* 821EF088h case    6:*/		regs.R29 = regs.R4;
		/* 821EF088h case    6:*/		return 0x821EF08C;
		  /* 821EF08Ch */ case    7:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF08Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF08Ch case    7:*/		return 0x821EF090;
		  /* 821EF090h */ case    8:  		/* mr R30, R3 */
		/* 821EF090h case    8:*/		regs.R30 = regs.R3;
		/* 821EF090h case    8:*/		return 0x821EF094;
		  /* 821EF094h */ case    9:  		/* bl 219396 */
		/* 821EF094h case    9:*/		regs.LR = 0x821EF098; return 0x82224998;
		/* 821EF094h case    9:*/		return 0x821EF098;
		  /* 821EF098h */ case   10:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF098h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF098h case   10:*/		return 0x821EF09C;
		  /* 821EF09Ch */ case   11:  		/* mr R31, R3 */
		/* 821EF09Ch case   11:*/		regs.R31 = regs.R3;
		/* 821EF09Ch case   11:*/		return 0x821EF0A0;
		  /* 821EF0A0h */ case   12:  		/* mr R4, R29 */
		/* 821EF0A0h case   12:*/		regs.R4 = regs.R29;
		/* 821EF0A0h case   12:*/		return 0x821EF0A4;
		  /* 821EF0A4h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821EF0A4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF0A4h case   13:*/		return 0x821EF0A8;
		  /* 821EF0A8h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF0A8h case   14:*/		if ( regs.CR[6].eq ) { return 0x821EF0BC;  }
		/* 821EF0A8h case   14:*/		return 0x821EF0AC;
		  /* 821EF0ACh */ case   15:  		/* mr R3, R30 */
		/* 821EF0ACh case   15:*/		regs.R3 = regs.R30;
		/* 821EF0ACh case   15:*/		return 0x821EF0B0;
		  /* 821EF0B0h */ case   16:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF0B0h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF0B0h case   16:*/		return 0x821EF0B4;
		  /* 821EF0B4h */ case   17:  		/* bl -516036 */
		/* 821EF0B4h case   17:*/		regs.LR = 0x821EF0B8; return 0x821710F0;
		/* 821EF0B4h case   17:*/		return 0x821EF0B8;
		  /* 821EF0B8h */ case   18:  		/* mr R4, R3 */
		/* 821EF0B8h case   18:*/		regs.R4 = regs.R3;
		/* 821EF0B8h case   18:*/		return 0x821EF0BC;
	}
	return 0x821EF0BC;
} // Block from 821EF070h-821EF0BCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821EF0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF0BC);
		  /* 821EF0BCh */ case    0:  		/* mr R3, R31 */
		/* 821EF0BCh case    0:*/		regs.R3 = regs.R31;
		/* 821EF0BCh case    0:*/		return 0x821EF0C0;
		  /* 821EF0C0h */ case    1:  		/* bl -487160 */
		/* 821EF0C0h case    1:*/		regs.LR = 0x821EF0C4; return 0x821781C8;
		/* 821EF0C0h case    1:*/		return 0x821EF0C4;
		  /* 821EF0C4h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF0C4h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF0C4h case    2:*/		return 0x821EF0C8;
		  /* 821EF0C8h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EF0C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EF0C8h case    3:*/		return 0x821EF0CC;
		  /* 821EF0CCh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EF0CCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF0CCh case    4:*/		return 0x821EF0D0;
		  /* 821EF0D0h */ case    5:  		/* mr R4, R28 */
		/* 821EF0D0h case    5:*/		regs.R4 = regs.R28;
		/* 821EF0D0h case    5:*/		return 0x821EF0D4;
		  /* 821EF0D4h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF0D4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EF0E8;  }
		/* 821EF0D4h case    6:*/		return 0x821EF0D8;
		  /* 821EF0D8h */ case    7:  		/* mr R3, R30 */
		/* 821EF0D8h case    7:*/		regs.R3 = regs.R30;
		/* 821EF0D8h case    7:*/		return 0x821EF0DC;
		  /* 821EF0DCh */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EF0DCh case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EF0DCh case    8:*/		return 0x821EF0E0;
		  /* 821EF0E0h */ case    9:  		/* bl -516080 */
		/* 821EF0E0h case    9:*/		regs.LR = 0x821EF0E4; return 0x821710F0;
		/* 821EF0E0h case    9:*/		return 0x821EF0E4;
		  /* 821EF0E4h */ case   10:  		/* mr R4, R3 */
		/* 821EF0E4h case   10:*/		regs.R4 = regs.R3;
		/* 821EF0E4h case   10:*/		return 0x821EF0E8;
	}
	return 0x821EF0E8;
} // Block from 821EF0BCh-821EF0E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EF0E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF0E8);
		  /* 821EF0E8h */ case    0:  		/* mr R3, R31 */
		/* 821EF0E8h case    0:*/		regs.R3 = regs.R31;
		/* 821EF0E8h case    0:*/		return 0x821EF0EC;
		  /* 821EF0ECh */ case    1:  		/* bl -487204 */
		/* 821EF0ECh case    1:*/		regs.LR = 0x821EF0F0; return 0x821781C8;
		/* 821EF0ECh case    1:*/		return 0x821EF0F0;
		  /* 821EF0F0h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821EF0F0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EF0F0h case    2:*/		return 0x821EF0F4;
		  /* 821EF0F4h */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF0F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF0F4h case    3:*/		return 0x821EF0F8;
		  /* 821EF0F8h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF0F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF0F8h case    4:*/		return 0x821EF0FC;
		  /* 821EF0FCh */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF0FCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF0FCh case    5:*/		return 0x821EF100;
		  /* 821EF100h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF100h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF100h case    6:*/		return 0x821EF104;
		  /* 821EF104h */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF104h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF104h case    7:*/		return 0x821EF108;
		  /* 821EF108h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF108h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF108h case    8:*/		return 0x821EF10C;
		  /* 821EF10Ch */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF10Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF10Ch case    9:*/		return 0x821EF110;
		  /* 821EF110h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF110h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF110h case   10:*/		return 0x821EF114;
		  /* 821EF114h */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF114h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF114h case   11:*/		return 0x821EF118;
		  /* 821EF118h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF118h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF118h case   12:*/		return 0x821EF11C;
		  /* 821EF11Ch */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF11Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF11Ch case   13:*/		return 0x821EF120;
		  /* 821EF120h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF120h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF120h case   14:*/		return 0x821EF124;
		  /* 821EF124h */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF124h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF124h case   15:*/		return 0x821EF128;
		  /* 821EF128h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF128h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF128h case   16:*/		return 0x821EF12C;
		  /* 821EF12Ch */ case   17:  		/* mr R3, R31 */
		/* 821EF12Ch case   17:*/		regs.R3 = regs.R31;
		/* 821EF12Ch case   17:*/		return 0x821EF130;
		  /* 821EF130h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF130h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF130h case   18:*/		return 0x821EF134;
		  /* 821EF134h */ case   19:  		/* addi R1, R1, 128 */
		/* 821EF134h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EF134h case   19:*/		return 0x821EF138;
		  /* 821EF138h */ case   20:  		/* b -1433232 */
		/* 821EF138h case   20:*/		return 0x820912A8;
		/* 821EF138h case   20:*/		return 0x821EF13C;
		  /* 821EF13Ch */ case   21:  		/* nop */
		/* 821EF13Ch case   21:*/		cpu::op::nop();
		/* 821EF13Ch case   21:*/		return 0x821EF140;
	}
	return 0x821EF140;
} // Block from 821EF0E8h-821EF140h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF140);
		  /* 821EF140h */ case    0:  		/* mfspr R12, LR */
		/* 821EF140h case    0:*/		regs.R12 = regs.LR;
		/* 821EF140h case    0:*/		return 0x821EF144;
		  /* 821EF144h */ case    1:  		/* bl -1433320 */
		/* 821EF144h case    1:*/		regs.LR = 0x821EF148; return 0x8209125C;
		/* 821EF144h case    1:*/		return 0x821EF148;
		  /* 821EF148h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF148h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF148h case    2:*/		return 0x821EF14C;
		  /* 821EF14Ch */ case    3:  		/* li R8, 1 */
		/* 821EF14Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EF14Ch case    3:*/		return 0x821EF150;
		  /* 821EF150h */ case    4:  		/* li R7, 1 */
		/* 821EF150h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF150h case    4:*/		return 0x821EF154;
		  /* 821EF154h */ case    5:  		/* li R6, 46 */
		/* 821EF154h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x2E);
		/* 821EF154h case    5:*/		return 0x821EF158;
		  /* 821EF158h */ case    6:  		/* li R5, 0 */
		/* 821EF158h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF158h case    6:*/		return 0x821EF15C;
		  /* 821EF15Ch */ case    7:  		/* mr R29, R4 */
		/* 821EF15Ch case    7:*/		regs.R29 = regs.R4;
		/* 821EF15Ch case    7:*/		return 0x821EF160;
	}
	return 0x821EF160;
} // Block from 821EF140h-821EF160h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EF160h
// Function '?MakeInstr_V_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF160);
		  /* 821EF160h */ case    0:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF160h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF160h case    0:*/		return 0x821EF164;
		  /* 821EF164h */ case    1:  		/* mr R30, R3 */
		/* 821EF164h case    1:*/		regs.R30 = regs.R3;
		/* 821EF164h case    1:*/		return 0x821EF168;
		  /* 821EF168h */ case    2:  		/* bl 219184 */
		/* 821EF168h case    2:*/		regs.LR = 0x821EF16C; return 0x82224998;
		/* 821EF168h case    2:*/		return 0x821EF16C;
		  /* 821EF16Ch */ case    3:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF16Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF16Ch case    3:*/		return 0x821EF170;
		  /* 821EF170h */ case    4:  		/* mr R31, R3 */
		/* 821EF170h case    4:*/		regs.R31 = regs.R3;
		/* 821EF170h case    4:*/		return 0x821EF174;
		  /* 821EF174h */ case    5:  		/* mr R4, R29 */
		/* 821EF174h case    5:*/		regs.R4 = regs.R29;
		/* 821EF174h case    5:*/		return 0x821EF178;
		  /* 821EF178h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821EF178h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF178h case    6:*/		return 0x821EF17C;
		  /* 821EF17Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF17Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821EF190;  }
		/* 821EF17Ch case    7:*/		return 0x821EF180;
		  /* 821EF180h */ case    8:  		/* mr R3, R30 */
		/* 821EF180h case    8:*/		regs.R3 = regs.R30;
		/* 821EF180h case    8:*/		return 0x821EF184;
		  /* 821EF184h */ case    9:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF184h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF184h case    9:*/		return 0x821EF188;
		  /* 821EF188h */ case   10:  		/* bl -516248 */
		/* 821EF188h case   10:*/		regs.LR = 0x821EF18C; return 0x821710F0;
		/* 821EF188h case   10:*/		return 0x821EF18C;
		  /* 821EF18Ch */ case   11:  		/* mr R4, R3 */
		/* 821EF18Ch case   11:*/		regs.R4 = regs.R3;
		/* 821EF18Ch case   11:*/		return 0x821EF190;
	}
	return 0x821EF190;
} // Block from 821EF160h-821EF190h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EF190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF190);
		  /* 821EF190h */ case    0:  		/* mr R3, R31 */
		/* 821EF190h case    0:*/		regs.R3 = regs.R31;
		/* 821EF190h case    0:*/		return 0x821EF194;
		  /* 821EF194h */ case    1:  		/* bl -487372 */
		/* 821EF194h case    1:*/		regs.LR = 0x821EF198; return 0x821781C8;
		/* 821EF194h case    1:*/		return 0x821EF198;
		  /* 821EF198h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF198h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF198h case    2:*/		return 0x821EF19C;
		  /* 821EF19Ch */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF19Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF19Ch case    3:*/		return 0x821EF1A0;
		  /* 821EF1A0h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF1A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF1A0h case    4:*/		return 0x821EF1A4;
		  /* 821EF1A4h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF1A4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF1A4h case    5:*/		return 0x821EF1A8;
		  /* 821EF1A8h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF1A8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF1A8h case    6:*/		return 0x821EF1AC;
		  /* 821EF1ACh */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF1ACh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF1ACh case    7:*/		return 0x821EF1B0;
		  /* 821EF1B0h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF1B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF1B0h case    8:*/		return 0x821EF1B4;
		  /* 821EF1B4h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF1B4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF1B4h case    9:*/		return 0x821EF1B8;
		  /* 821EF1B8h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF1B8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF1B8h case   10:*/		return 0x821EF1BC;
		  /* 821EF1BCh */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF1BCh case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF1BCh case   11:*/		return 0x821EF1C0;
		  /* 821EF1C0h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF1C0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF1C0h case   12:*/		return 0x821EF1C4;
		  /* 821EF1C4h */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF1C4h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF1C4h case   13:*/		return 0x821EF1C8;
		  /* 821EF1C8h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF1C8h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF1C8h case   14:*/		return 0x821EF1CC;
		  /* 821EF1CCh */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF1CCh case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF1CCh case   15:*/		return 0x821EF1D0;
		  /* 821EF1D0h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF1D0h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF1D0h case   16:*/		return 0x821EF1D4;
		  /* 821EF1D4h */ case   17:  		/* mr R3, R31 */
		/* 821EF1D4h case   17:*/		regs.R3 = regs.R31;
		/* 821EF1D4h case   17:*/		return 0x821EF1D8;
		  /* 821EF1D8h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF1D8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF1D8h case   18:*/		return 0x821EF1DC;
		  /* 821EF1DCh */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF1DCh case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF1DCh case   19:*/		return 0x821EF1E0;
		  /* 821EF1E0h */ case   20:  		/* b -1433396 */
		/* 821EF1E0h case   20:*/		return 0x820912AC;
		/* 821EF1E0h case   20:*/		return 0x821EF1E4;
		  /* 821EF1E4h */ case   21:  		/* nop */
		/* 821EF1E4h case   21:*/		cpu::op::nop();
		/* 821EF1E4h case   21:*/		return 0x821EF1E8;
	}
	return 0x821EF1E8;
} // Block from 821EF190h-821EF1E8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF1E8);
		  /* 821EF1E8h */ case    0:  		/* mfspr R12, LR */
		/* 821EF1E8h case    0:*/		regs.R12 = regs.LR;
		/* 821EF1E8h case    0:*/		return 0x821EF1EC;
		  /* 821EF1ECh */ case    1:  		/* bl -1433488 */
		/* 821EF1ECh case    1:*/		regs.LR = 0x821EF1F0; return 0x8209125C;
		/* 821EF1ECh case    1:*/		return 0x821EF1F0;
		  /* 821EF1F0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF1F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF1F0h case    2:*/		return 0x821EF1F4;
		  /* 821EF1F4h */ case    3:  		/* li R8, 1 */
		/* 821EF1F4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EF1F4h case    3:*/		return 0x821EF1F8;
		  /* 821EF1F8h */ case    4:  		/* li R7, 1 */
		/* 821EF1F8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF1F8h case    4:*/		return 0x821EF1FC;
		  /* 821EF1FCh */ case    5:  		/* li R6, 51 */
		/* 821EF1FCh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x33);
		/* 821EF1FCh case    5:*/		return 0x821EF200;
		  /* 821EF200h */ case    6:  		/* li R5, 0 */
		/* 821EF200h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF200h case    6:*/		return 0x821EF204;
		  /* 821EF204h */ case    7:  		/* mr R29, R4 */
		/* 821EF204h case    7:*/		regs.R29 = regs.R4;
		/* 821EF204h case    7:*/		return 0x821EF208;
		  /* 821EF208h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF208h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF208h case    8:*/		return 0x821EF20C;
		  /* 821EF20Ch */ case    9:  		/* mr R30, R3 */
		/* 821EF20Ch case    9:*/		regs.R30 = regs.R3;
		/* 821EF20Ch case    9:*/		return 0x821EF210;
		  /* 821EF210h */ case   10:  		/* bl 219016 */
		/* 821EF210h case   10:*/		regs.LR = 0x821EF214; return 0x82224998;
		/* 821EF210h case   10:*/		return 0x821EF214;
		  /* 821EF214h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF214h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF214h case   11:*/		return 0x821EF218;
		  /* 821EF218h */ case   12:  		/* mr R31, R3 */
		/* 821EF218h case   12:*/		regs.R31 = regs.R3;
		/* 821EF218h case   12:*/		return 0x821EF21C;
		  /* 821EF21Ch */ case   13:  		/* mr R4, R29 */
		/* 821EF21Ch case   13:*/		regs.R4 = regs.R29;
		/* 821EF21Ch case   13:*/		return 0x821EF220;
		  /* 821EF220h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EF220h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF220h case   14:*/		return 0x821EF224;
		  /* 821EF224h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF224h case   15:*/		if ( regs.CR[6].eq ) { return 0x821EF238;  }
		/* 821EF224h case   15:*/		return 0x821EF228;
		  /* 821EF228h */ case   16:  		/* mr R3, R30 */
		/* 821EF228h case   16:*/		regs.R3 = regs.R30;
		/* 821EF228h case   16:*/		return 0x821EF22C;
		  /* 821EF22Ch */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF22Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF22Ch case   17:*/		return 0x821EF230;
		  /* 821EF230h */ case   18:  		/* bl -516416 */
		/* 821EF230h case   18:*/		regs.LR = 0x821EF234; return 0x821710F0;
		/* 821EF230h case   18:*/		return 0x821EF234;
		  /* 821EF234h */ case   19:  		/* mr R4, R3 */
		/* 821EF234h case   19:*/		regs.R4 = regs.R3;
		/* 821EF234h case   19:*/		return 0x821EF238;
	}
	return 0x821EF238;
} // Block from 821EF1E8h-821EF238h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EF238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF238);
		  /* 821EF238h */ case    0:  		/* mr R3, R31 */
		/* 821EF238h case    0:*/		regs.R3 = regs.R31;
		/* 821EF238h case    0:*/		return 0x821EF23C;
		  /* 821EF23Ch */ case    1:  		/* bl -487540 */
		/* 821EF23Ch case    1:*/		regs.LR = 0x821EF240; return 0x821781C8;
		/* 821EF23Ch case    1:*/		return 0x821EF240;
		  /* 821EF240h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF240h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF240h case    2:*/		return 0x821EF244;
		  /* 821EF244h */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF244h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF244h case    3:*/		return 0x821EF248;
		  /* 821EF248h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF248h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF248h case    4:*/		return 0x821EF24C;
		  /* 821EF24Ch */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF24Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF24Ch case    5:*/		return 0x821EF250;
	}
	return 0x821EF250;
} // Block from 821EF238h-821EF250h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EF250h
// Function '?MakeInstr_V_SETNE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF250);
		  /* 821EF250h */ case    0:  		/* lwz R9, <#[R11]> */
		/* 821EF250h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF250h case    0:*/		return 0x821EF254;
		  /* 821EF254h */ case    1:  		/* addi R8, R11, -36 */
		/* 821EF254h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF254h case    1:*/		return 0x821EF258;
		  /* 821EF258h */ case    2:  		/* addi R10, R10, 36 */
		/* 821EF258h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF258h case    2:*/		return 0x821EF25C;
		  /* 821EF25Ch */ case    3:  		/* stw R9, <#[R10]> */
		/* 821EF25Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF25Ch case    3:*/		return 0x821EF260;
		  /* 821EF260h */ case    4:  		/* lwz R9, <#[R11]> */
		/* 821EF260h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF260h case    4:*/		return 0x821EF264;
		  /* 821EF264h */ case    5:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF264h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF264h case    5:*/		return 0x821EF268;
		  /* 821EF268h */ case    6:  		/* addi R6, R10, -36 */
		/* 821EF268h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF268h case    6:*/		return 0x821EF26C;
		  /* 821EF26Ch */ case    7:  		/* ori R8, R8, 1 */
		/* 821EF26Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF26Ch case    7:*/		return 0x821EF270;
		  /* 821EF270h */ case    8:  		/* addi R9, R10, 4 */
		/* 821EF270h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF270h case    8:*/		return 0x821EF274;
		  /* 821EF274h */ case    9:  		/* stw R6, <#[R7]> */
		/* 821EF274h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF274h case    9:*/		return 0x821EF278;
		  /* 821EF278h */ case   10:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF278h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF278h case   10:*/		return 0x821EF27C;
		  /* 821EF27Ch */ case   11:  		/* mr R3, R31 */
		/* 821EF27Ch case   11:*/		regs.R3 = regs.R31;
		/* 821EF27Ch case   11:*/		return 0x821EF280;
		  /* 821EF280h */ case   12:  		/* stw R9, <#[R11]> */
		/* 821EF280h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF280h case   12:*/		return 0x821EF284;
		  /* 821EF284h */ case   13:  		/* addi R1, R1, 112 */
		/* 821EF284h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF284h case   13:*/		return 0x821EF288;
		  /* 821EF288h */ case   14:  		/* b -1433564 */
		/* 821EF288h case   14:*/		return 0x820912AC;
		/* 821EF288h case   14:*/		return 0x821EF28C;
		  /* 821EF28Ch */ case   15:  		/* nop */
		/* 821EF28Ch case   15:*/		cpu::op::nop();
		/* 821EF28Ch case   15:*/		return 0x821EF290;
	}
	return 0x821EF290;
} // Block from 821EF250h-821EF290h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EF290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF290);
		  /* 821EF290h */ case    0:  		/* mfspr R12, LR */
		/* 821EF290h case    0:*/		regs.R12 = regs.LR;
		/* 821EF290h case    0:*/		return 0x821EF294;
		  /* 821EF294h */ case    1:  		/* bl -1433656 */
		/* 821EF294h case    1:*/		regs.LR = 0x821EF298; return 0x8209125C;
		/* 821EF294h case    1:*/		return 0x821EF298;
		  /* 821EF298h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF298h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF298h case    2:*/		return 0x821EF29C;
		  /* 821EF29Ch */ case    3:  		/* li R8, 1 */
		/* 821EF29Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EF29Ch case    3:*/		return 0x821EF2A0;
		  /* 821EF2A0h */ case    4:  		/* li R7, 1 */
		/* 821EF2A0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF2A0h case    4:*/		return 0x821EF2A4;
		  /* 821EF2A4h */ case    5:  		/* li R6, 55 */
		/* 821EF2A4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x37);
		/* 821EF2A4h case    5:*/		return 0x821EF2A8;
		  /* 821EF2A8h */ case    6:  		/* li R5, 0 */
		/* 821EF2A8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF2A8h case    6:*/		return 0x821EF2AC;
		  /* 821EF2ACh */ case    7:  		/* mr R29, R4 */
		/* 821EF2ACh case    7:*/		regs.R29 = regs.R4;
		/* 821EF2ACh case    7:*/		return 0x821EF2B0;
		  /* 821EF2B0h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF2B0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF2B0h case    8:*/		return 0x821EF2B4;
		  /* 821EF2B4h */ case    9:  		/* mr R30, R3 */
		/* 821EF2B4h case    9:*/		regs.R30 = regs.R3;
		/* 821EF2B4h case    9:*/		return 0x821EF2B8;
		  /* 821EF2B8h */ case   10:  		/* bl 218848 */
		/* 821EF2B8h case   10:*/		regs.LR = 0x821EF2BC; return 0x82224998;
		/* 821EF2B8h case   10:*/		return 0x821EF2BC;
		  /* 821EF2BCh */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF2BCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF2BCh case   11:*/		return 0x821EF2C0;
		  /* 821EF2C0h */ case   12:  		/* mr R31, R3 */
		/* 821EF2C0h case   12:*/		regs.R31 = regs.R3;
		/* 821EF2C0h case   12:*/		return 0x821EF2C4;
		  /* 821EF2C4h */ case   13:  		/* mr R4, R29 */
		/* 821EF2C4h case   13:*/		regs.R4 = regs.R29;
		/* 821EF2C4h case   13:*/		return 0x821EF2C8;
		  /* 821EF2C8h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EF2C8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF2C8h case   14:*/		return 0x821EF2CC;
		  /* 821EF2CCh */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF2CCh case   15:*/		if ( regs.CR[6].eq ) { return 0x821EF2E0;  }
		/* 821EF2CCh case   15:*/		return 0x821EF2D0;
		  /* 821EF2D0h */ case   16:  		/* mr R3, R30 */
		/* 821EF2D0h case   16:*/		regs.R3 = regs.R30;
		/* 821EF2D0h case   16:*/		return 0x821EF2D4;
		  /* 821EF2D4h */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF2D4h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF2D4h case   17:*/		return 0x821EF2D8;
		  /* 821EF2D8h */ case   18:  		/* bl -516584 */
		/* 821EF2D8h case   18:*/		regs.LR = 0x821EF2DC; return 0x821710F0;
		/* 821EF2D8h case   18:*/		return 0x821EF2DC;
		  /* 821EF2DCh */ case   19:  		/* mr R4, R3 */
		/* 821EF2DCh case   19:*/		regs.R4 = regs.R3;
		/* 821EF2DCh case   19:*/		return 0x821EF2E0;
	}
	return 0x821EF2E0;
} // Block from 821EF290h-821EF2E0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EF2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF2E0);
		  /* 821EF2E0h */ case    0:  		/* mr R3, R31 */
		/* 821EF2E0h case    0:*/		regs.R3 = regs.R31;
		/* 821EF2E0h case    0:*/		return 0x821EF2E4;
		  /* 821EF2E4h */ case    1:  		/* bl -487708 */
		/* 821EF2E4h case    1:*/		regs.LR = 0x821EF2E8; return 0x821781C8;
		/* 821EF2E4h case    1:*/		return 0x821EF2E8;
		  /* 821EF2E8h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF2E8h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF2E8h case    2:*/		return 0x821EF2EC;
		  /* 821EF2ECh */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF2ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF2ECh case    3:*/		return 0x821EF2F0;
		  /* 821EF2F0h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF2F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF2F0h case    4:*/		return 0x821EF2F4;
		  /* 821EF2F4h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF2F4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF2F4h case    5:*/		return 0x821EF2F8;
		  /* 821EF2F8h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF2F8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF2F8h case    6:*/		return 0x821EF2FC;
		  /* 821EF2FCh */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF2FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF2FCh case    7:*/		return 0x821EF300;
		  /* 821EF300h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF300h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF300h case    8:*/		return 0x821EF304;
		  /* 821EF304h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF304h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF304h case    9:*/		return 0x821EF308;
		  /* 821EF308h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF308h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF308h case   10:*/		return 0x821EF30C;
		  /* 821EF30Ch */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF30Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF30Ch case   11:*/		return 0x821EF310;
		  /* 821EF310h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF310h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF310h case   12:*/		return 0x821EF314;
		  /* 821EF314h */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF314h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF314h case   13:*/		return 0x821EF318;
		  /* 821EF318h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF318h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF318h case   14:*/		return 0x821EF31C;
		  /* 821EF31Ch */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF31Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF31Ch case   15:*/		return 0x821EF320;
		  /* 821EF320h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF320h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF320h case   16:*/		return 0x821EF324;
		  /* 821EF324h */ case   17:  		/* mr R3, R31 */
		/* 821EF324h case   17:*/		regs.R3 = regs.R31;
		/* 821EF324h case   17:*/		return 0x821EF328;
		  /* 821EF328h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF328h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF328h case   18:*/		return 0x821EF32C;
		  /* 821EF32Ch */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF32Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF32Ch case   19:*/		return 0x821EF330;
		  /* 821EF330h */ case   20:  		/* b -1433732 */
		/* 821EF330h case   20:*/		return 0x820912AC;
		/* 821EF330h case   20:*/		return 0x821EF334;
		  /* 821EF334h */ case   21:  		/* nop */
		/* 821EF334h case   21:*/		cpu::op::nop();
		/* 821EF334h case   21:*/		return 0x821EF338;
	}
	return 0x821EF338;
} // Block from 821EF2E0h-821EF338h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF338);
		  /* 821EF338h */ case    0:  		/* mfspr R12, LR */
		/* 821EF338h case    0:*/		regs.R12 = regs.LR;
		/* 821EF338h case    0:*/		return 0x821EF33C;
		  /* 821EF33Ch */ case    1:  		/* bl -1433824 */
		/* 821EF33Ch case    1:*/		regs.LR = 0x821EF340; return 0x8209125C;
		/* 821EF33Ch case    1:*/		return 0x821EF340;
	}
	return 0x821EF340;
} // Block from 821EF338h-821EF340h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821EF340h
// Function '?MakeInstr_V_FRACT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF340);
		  /* 821EF340h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF340h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF340h case    0:*/		return 0x821EF344;
		  /* 821EF344h */ case    1:  		/* li R8, 1 */
		/* 821EF344h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EF344h case    1:*/		return 0x821EF348;
		  /* 821EF348h */ case    2:  		/* li R7, 1 */
		/* 821EF348h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF348h case    2:*/		return 0x821EF34C;
		  /* 821EF34Ch */ case    3:  		/* li R6, 72 */
		/* 821EF34Ch case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x48);
		/* 821EF34Ch case    3:*/		return 0x821EF350;
		  /* 821EF350h */ case    4:  		/* li R5, 0 */
		/* 821EF350h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF350h case    4:*/		return 0x821EF354;
		  /* 821EF354h */ case    5:  		/* mr R29, R4 */
		/* 821EF354h case    5:*/		regs.R29 = regs.R4;
		/* 821EF354h case    5:*/		return 0x821EF358;
		  /* 821EF358h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF358h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF358h case    6:*/		return 0x821EF35C;
		  /* 821EF35Ch */ case    7:  		/* mr R30, R3 */
		/* 821EF35Ch case    7:*/		regs.R30 = regs.R3;
		/* 821EF35Ch case    7:*/		return 0x821EF360;
		  /* 821EF360h */ case    8:  		/* bl 218680 */
		/* 821EF360h case    8:*/		regs.LR = 0x821EF364; return 0x82224998;
		/* 821EF360h case    8:*/		return 0x821EF364;
		  /* 821EF364h */ case    9:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF364h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF364h case    9:*/		return 0x821EF368;
		  /* 821EF368h */ case   10:  		/* mr R31, R3 */
		/* 821EF368h case   10:*/		regs.R31 = regs.R3;
		/* 821EF368h case   10:*/		return 0x821EF36C;
		  /* 821EF36Ch */ case   11:  		/* mr R4, R29 */
		/* 821EF36Ch case   11:*/		regs.R4 = regs.R29;
		/* 821EF36Ch case   11:*/		return 0x821EF370;
		  /* 821EF370h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821EF370h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF370h case   12:*/		return 0x821EF374;
		  /* 821EF374h */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF374h case   13:*/		if ( regs.CR[6].eq ) { return 0x821EF388;  }
		/* 821EF374h case   13:*/		return 0x821EF378;
		  /* 821EF378h */ case   14:  		/* mr R3, R30 */
		/* 821EF378h case   14:*/		regs.R3 = regs.R30;
		/* 821EF378h case   14:*/		return 0x821EF37C;
		  /* 821EF37Ch */ case   15:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF37Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF37Ch case   15:*/		return 0x821EF380;
		  /* 821EF380h */ case   16:  		/* bl -516752 */
		/* 821EF380h case   16:*/		regs.LR = 0x821EF384; return 0x821710F0;
		/* 821EF380h case   16:*/		return 0x821EF384;
		  /* 821EF384h */ case   17:  		/* mr R4, R3 */
		/* 821EF384h case   17:*/		regs.R4 = regs.R3;
		/* 821EF384h case   17:*/		return 0x821EF388;
	}
	return 0x821EF388;
} // Block from 821EF340h-821EF388h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EF388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF388);
		  /* 821EF388h */ case    0:  		/* mr R3, R31 */
		/* 821EF388h case    0:*/		regs.R3 = regs.R31;
		/* 821EF388h case    0:*/		return 0x821EF38C;
		  /* 821EF38Ch */ case    1:  		/* bl -487876 */
		/* 821EF38Ch case    1:*/		regs.LR = 0x821EF390; return 0x821781C8;
		/* 821EF38Ch case    1:*/		return 0x821EF390;
		  /* 821EF390h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF390h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF390h case    2:*/		return 0x821EF394;
		  /* 821EF394h */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF394h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF394h case    3:*/		return 0x821EF398;
		  /* 821EF398h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF398h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF398h case    4:*/		return 0x821EF39C;
		  /* 821EF39Ch */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF39Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF39Ch case    5:*/		return 0x821EF3A0;
		  /* 821EF3A0h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF3A0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF3A0h case    6:*/		return 0x821EF3A4;
		  /* 821EF3A4h */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF3A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF3A4h case    7:*/		return 0x821EF3A8;
		  /* 821EF3A8h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF3A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF3A8h case    8:*/		return 0x821EF3AC;
		  /* 821EF3ACh */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF3ACh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF3ACh case    9:*/		return 0x821EF3B0;
		  /* 821EF3B0h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF3B0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF3B0h case   10:*/		return 0x821EF3B4;
		  /* 821EF3B4h */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF3B4h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF3B4h case   11:*/		return 0x821EF3B8;
		  /* 821EF3B8h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF3B8h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF3B8h case   12:*/		return 0x821EF3BC;
		  /* 821EF3BCh */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF3BCh case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF3BCh case   13:*/		return 0x821EF3C0;
		  /* 821EF3C0h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF3C0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF3C0h case   14:*/		return 0x821EF3C4;
		  /* 821EF3C4h */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF3C4h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF3C4h case   15:*/		return 0x821EF3C8;
		  /* 821EF3C8h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF3C8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF3C8h case   16:*/		return 0x821EF3CC;
		  /* 821EF3CCh */ case   17:  		/* mr R3, R31 */
		/* 821EF3CCh case   17:*/		regs.R3 = regs.R31;
		/* 821EF3CCh case   17:*/		return 0x821EF3D0;
		  /* 821EF3D0h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF3D0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF3D0h case   18:*/		return 0x821EF3D4;
		  /* 821EF3D4h */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF3D4h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF3D4h case   19:*/		return 0x821EF3D8;
		  /* 821EF3D8h */ case   20:  		/* b -1433900 */
		/* 821EF3D8h case   20:*/		return 0x820912AC;
		/* 821EF3D8h case   20:*/		return 0x821EF3DC;
		  /* 821EF3DCh */ case   21:  		/* nop */
		/* 821EF3DCh case   21:*/		cpu::op::nop();
		/* 821EF3DCh case   21:*/		return 0x821EF3E0;
	}
	return 0x821EF3E0;
} // Block from 821EF388h-821EF3E0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF3E0);
		  /* 821EF3E0h */ case    0:  		/* mfspr R12, LR */
		/* 821EF3E0h case    0:*/		regs.R12 = regs.LR;
		/* 821EF3E0h case    0:*/		return 0x821EF3E4;
		  /* 821EF3E4h */ case    1:  		/* bl -1433992 */
		/* 821EF3E4h case    1:*/		regs.LR = 0x821EF3E8; return 0x8209125C;
		/* 821EF3E4h case    1:*/		return 0x821EF3E8;
		  /* 821EF3E8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF3E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF3E8h case    2:*/		return 0x821EF3EC;
		  /* 821EF3ECh */ case    3:  		/* li R8, 1 */
		/* 821EF3ECh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EF3ECh case    3:*/		return 0x821EF3F0;
		  /* 821EF3F0h */ case    4:  		/* li R7, 1 */
		/* 821EF3F0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF3F0h case    4:*/		return 0x821EF3F4;
		  /* 821EF3F4h */ case    5:  		/* li R6, 80 */
		/* 821EF3F4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x50);
		/* 821EF3F4h case    5:*/		return 0x821EF3F8;
		  /* 821EF3F8h */ case    6:  		/* li R5, 0 */
		/* 821EF3F8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF3F8h case    6:*/		return 0x821EF3FC;
		  /* 821EF3FCh */ case    7:  		/* mr R29, R4 */
		/* 821EF3FCh case    7:*/		regs.R29 = regs.R4;
		/* 821EF3FCh case    7:*/		return 0x821EF400;
	}
	return 0x821EF400;
} // Block from 821EF3E0h-821EF400h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EF400h
// Function '?MakeInstr_V_TRUNC@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF400);
		  /* 821EF400h */ case    0:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF400h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF400h case    0:*/		return 0x821EF404;
		  /* 821EF404h */ case    1:  		/* mr R30, R3 */
		/* 821EF404h case    1:*/		regs.R30 = regs.R3;
		/* 821EF404h case    1:*/		return 0x821EF408;
		  /* 821EF408h */ case    2:  		/* bl 218512 */
		/* 821EF408h case    2:*/		regs.LR = 0x821EF40C; return 0x82224998;
		/* 821EF408h case    2:*/		return 0x821EF40C;
		  /* 821EF40Ch */ case    3:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF40Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF40Ch case    3:*/		return 0x821EF410;
		  /* 821EF410h */ case    4:  		/* mr R31, R3 */
		/* 821EF410h case    4:*/		regs.R31 = regs.R3;
		/* 821EF410h case    4:*/		return 0x821EF414;
		  /* 821EF414h */ case    5:  		/* mr R4, R29 */
		/* 821EF414h case    5:*/		regs.R4 = regs.R29;
		/* 821EF414h case    5:*/		return 0x821EF418;
		  /* 821EF418h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821EF418h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF418h case    6:*/		return 0x821EF41C;
		  /* 821EF41Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF41Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821EF430;  }
		/* 821EF41Ch case    7:*/		return 0x821EF420;
		  /* 821EF420h */ case    8:  		/* mr R3, R30 */
		/* 821EF420h case    8:*/		regs.R3 = regs.R30;
		/* 821EF420h case    8:*/		return 0x821EF424;
		  /* 821EF424h */ case    9:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF424h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF424h case    9:*/		return 0x821EF428;
		  /* 821EF428h */ case   10:  		/* bl -516920 */
		/* 821EF428h case   10:*/		regs.LR = 0x821EF42C; return 0x821710F0;
		/* 821EF428h case   10:*/		return 0x821EF42C;
		  /* 821EF42Ch */ case   11:  		/* mr R4, R3 */
		/* 821EF42Ch case   11:*/		regs.R4 = regs.R3;
		/* 821EF42Ch case   11:*/		return 0x821EF430;
	}
	return 0x821EF430;
} // Block from 821EF400h-821EF430h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EF430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF430);
		  /* 821EF430h */ case    0:  		/* mr R3, R31 */
		/* 821EF430h case    0:*/		regs.R3 = regs.R31;
		/* 821EF430h case    0:*/		return 0x821EF434;
		  /* 821EF434h */ case    1:  		/* bl -488044 */
		/* 821EF434h case    1:*/		regs.LR = 0x821EF438; return 0x821781C8;
		/* 821EF434h case    1:*/		return 0x821EF438;
		  /* 821EF438h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF438h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF438h case    2:*/		return 0x821EF43C;
		  /* 821EF43Ch */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF43Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF43Ch case    3:*/		return 0x821EF440;
		  /* 821EF440h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF440h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF440h case    4:*/		return 0x821EF444;
		  /* 821EF444h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF444h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF444h case    5:*/		return 0x821EF448;
		  /* 821EF448h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF448h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF448h case    6:*/		return 0x821EF44C;
		  /* 821EF44Ch */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF44Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF44Ch case    7:*/		return 0x821EF450;
		  /* 821EF450h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF450h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF450h case    8:*/		return 0x821EF454;
		  /* 821EF454h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF454h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF454h case    9:*/		return 0x821EF458;
		  /* 821EF458h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF458h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF458h case   10:*/		return 0x821EF45C;
		  /* 821EF45Ch */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF45Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF45Ch case   11:*/		return 0x821EF460;
		  /* 821EF460h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF460h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF460h case   12:*/		return 0x821EF464;
		  /* 821EF464h */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF464h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF464h case   13:*/		return 0x821EF468;
		  /* 821EF468h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF468h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF468h case   14:*/		return 0x821EF46C;
		  /* 821EF46Ch */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF46Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF46Ch case   15:*/		return 0x821EF470;
		  /* 821EF470h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF470h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF470h case   16:*/		return 0x821EF474;
		  /* 821EF474h */ case   17:  		/* mr R3, R31 */
		/* 821EF474h case   17:*/		regs.R3 = regs.R31;
		/* 821EF474h case   17:*/		return 0x821EF478;
		  /* 821EF478h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF478h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF478h case   18:*/		return 0x821EF47C;
		  /* 821EF47Ch */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF47Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF47Ch case   19:*/		return 0x821EF480;
		  /* 821EF480h */ case   20:  		/* b -1434068 */
		/* 821EF480h case   20:*/		return 0x820912AC;
		/* 821EF480h case   20:*/		return 0x821EF484;
		  /* 821EF484h */ case   21:  		/* nop */
		/* 821EF484h case   21:*/		cpu::op::nop();
		/* 821EF484h case   21:*/		return 0x821EF488;
	}
	return 0x821EF488;
} // Block from 821EF430h-821EF488h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF488);
		  /* 821EF488h */ case    0:  		/* mfspr R12, LR */
		/* 821EF488h case    0:*/		regs.R12 = regs.LR;
		/* 821EF488h case    0:*/		return 0x821EF48C;
		  /* 821EF48Ch */ case    1:  		/* bl -1434160 */
		/* 821EF48Ch case    1:*/		regs.LR = 0x821EF490; return 0x8209125C;
		/* 821EF48Ch case    1:*/		return 0x821EF490;
		  /* 821EF490h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF490h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF490h case    2:*/		return 0x821EF494;
		  /* 821EF494h */ case    3:  		/* li R8, 1 */
		/* 821EF494h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EF494h case    3:*/		return 0x821EF498;
		  /* 821EF498h */ case    4:  		/* li R7, 1 */
		/* 821EF498h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF498h case    4:*/		return 0x821EF49C;
		  /* 821EF49Ch */ case    5:  		/* li R6, 81 */
		/* 821EF49Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x51);
		/* 821EF49Ch case    5:*/		return 0x821EF4A0;
		  /* 821EF4A0h */ case    6:  		/* li R5, 0 */
		/* 821EF4A0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF4A0h case    6:*/		return 0x821EF4A4;
		  /* 821EF4A4h */ case    7:  		/* mr R29, R4 */
		/* 821EF4A4h case    7:*/		regs.R29 = regs.R4;
		/* 821EF4A4h case    7:*/		return 0x821EF4A8;
		  /* 821EF4A8h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF4A8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF4A8h case    8:*/		return 0x821EF4AC;
		  /* 821EF4ACh */ case    9:  		/* mr R30, R3 */
		/* 821EF4ACh case    9:*/		regs.R30 = regs.R3;
		/* 821EF4ACh case    9:*/		return 0x821EF4B0;
		  /* 821EF4B0h */ case   10:  		/* bl 218344 */
		/* 821EF4B0h case   10:*/		regs.LR = 0x821EF4B4; return 0x82224998;
		/* 821EF4B0h case   10:*/		return 0x821EF4B4;
		  /* 821EF4B4h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF4B4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF4B4h case   11:*/		return 0x821EF4B8;
		  /* 821EF4B8h */ case   12:  		/* mr R31, R3 */
		/* 821EF4B8h case   12:*/		regs.R31 = regs.R3;
		/* 821EF4B8h case   12:*/		return 0x821EF4BC;
		  /* 821EF4BCh */ case   13:  		/* mr R4, R29 */
		/* 821EF4BCh case   13:*/		regs.R4 = regs.R29;
		/* 821EF4BCh case   13:*/		return 0x821EF4C0;
	}
	return 0x821EF4C0;
} // Block from 821EF488h-821EF4C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EF4C0h
// Function '?MakeInstr_V_FLOOR@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF4C0);
		  /* 821EF4C0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821EF4C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF4C0h case    0:*/		return 0x821EF4C4;
		  /* 821EF4C4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF4C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821EF4D8;  }
		/* 821EF4C4h case    1:*/		return 0x821EF4C8;
		  /* 821EF4C8h */ case    2:  		/* mr R3, R30 */
		/* 821EF4C8h case    2:*/		regs.R3 = regs.R30;
		/* 821EF4C8h case    2:*/		return 0x821EF4CC;
		  /* 821EF4CCh */ case    3:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF4CCh case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF4CCh case    3:*/		return 0x821EF4D0;
		  /* 821EF4D0h */ case    4:  		/* bl -517088 */
		/* 821EF4D0h case    4:*/		regs.LR = 0x821EF4D4; return 0x821710F0;
		/* 821EF4D0h case    4:*/		return 0x821EF4D4;
		  /* 821EF4D4h */ case    5:  		/* mr R4, R3 */
		/* 821EF4D4h case    5:*/		regs.R4 = regs.R3;
		/* 821EF4D4h case    5:*/		return 0x821EF4D8;
	}
	return 0x821EF4D8;
} // Block from 821EF4C0h-821EF4D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821EF4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF4D8);
		  /* 821EF4D8h */ case    0:  		/* mr R3, R31 */
		/* 821EF4D8h case    0:*/		regs.R3 = regs.R31;
		/* 821EF4D8h case    0:*/		return 0x821EF4DC;
		  /* 821EF4DCh */ case    1:  		/* bl -488212 */
		/* 821EF4DCh case    1:*/		regs.LR = 0x821EF4E0; return 0x821781C8;
		/* 821EF4DCh case    1:*/		return 0x821EF4E0;
		  /* 821EF4E0h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF4E0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF4E0h case    2:*/		return 0x821EF4E4;
		  /* 821EF4E4h */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF4E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF4E4h case    3:*/		return 0x821EF4E8;
		  /* 821EF4E8h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF4E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF4E8h case    4:*/		return 0x821EF4EC;
		  /* 821EF4ECh */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF4ECh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF4ECh case    5:*/		return 0x821EF4F0;
		  /* 821EF4F0h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF4F0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF4F0h case    6:*/		return 0x821EF4F4;
		  /* 821EF4F4h */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF4F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF4F4h case    7:*/		return 0x821EF4F8;
		  /* 821EF4F8h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF4F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF4F8h case    8:*/		return 0x821EF4FC;
		  /* 821EF4FCh */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF4FCh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF4FCh case    9:*/		return 0x821EF500;
		  /* 821EF500h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF500h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF500h case   10:*/		return 0x821EF504;
		  /* 821EF504h */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF504h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF504h case   11:*/		return 0x821EF508;
		  /* 821EF508h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF508h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF508h case   12:*/		return 0x821EF50C;
		  /* 821EF50Ch */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF50Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF50Ch case   13:*/		return 0x821EF510;
		  /* 821EF510h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF510h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF510h case   14:*/		return 0x821EF514;
		  /* 821EF514h */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF514h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF514h case   15:*/		return 0x821EF518;
		  /* 821EF518h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF518h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF518h case   16:*/		return 0x821EF51C;
		  /* 821EF51Ch */ case   17:  		/* mr R3, R31 */
		/* 821EF51Ch case   17:*/		regs.R3 = regs.R31;
		/* 821EF51Ch case   17:*/		return 0x821EF520;
		  /* 821EF520h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF520h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF520h case   18:*/		return 0x821EF524;
		  /* 821EF524h */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF524h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF524h case   19:*/		return 0x821EF528;
		  /* 821EF528h */ case   20:  		/* b -1434236 */
		/* 821EF528h case   20:*/		return 0x820912AC;
		/* 821EF528h case   20:*/		return 0x821EF52C;
		  /* 821EF52Ch */ case   21:  		/* nop */
		/* 821EF52Ch case   21:*/		cpu::op::nop();
		/* 821EF52Ch case   21:*/		return 0x821EF530;
	}
	return 0x821EF530;
} // Block from 821EF4D8h-821EF530h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF530);
		  /* 821EF530h */ case    0:  		/* mfspr R12, LR */
		/* 821EF530h case    0:*/		regs.R12 = regs.LR;
		/* 821EF530h case    0:*/		return 0x821EF534;
		  /* 821EF534h */ case    1:  		/* bl -1434328 */
		/* 821EF534h case    1:*/		regs.LR = 0x821EF538; return 0x8209125C;
		/* 821EF534h case    1:*/		return 0x821EF538;
		  /* 821EF538h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF538h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF538h case    2:*/		return 0x821EF53C;
		  /* 821EF53Ch */ case    3:  		/* li R8, 4 */
		/* 821EF53Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF53Ch case    3:*/		return 0x821EF540;
		  /* 821EF540h */ case    4:  		/* li R7, 1 */
		/* 821EF540h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF540h case    4:*/		return 0x821EF544;
		  /* 821EF544h */ case    5:  		/* li R6, 98 */
		/* 821EF544h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x62);
		/* 821EF544h case    5:*/		return 0x821EF548;
		  /* 821EF548h */ case    6:  		/* li R5, 0 */
		/* 821EF548h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF548h case    6:*/		return 0x821EF54C;
		  /* 821EF54Ch */ case    7:  		/* mr R29, R4 */
		/* 821EF54Ch case    7:*/		regs.R29 = regs.R4;
		/* 821EF54Ch case    7:*/		return 0x821EF550;
		  /* 821EF550h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF550h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF550h case    8:*/		return 0x821EF554;
		  /* 821EF554h */ case    9:  		/* mr R30, R3 */
		/* 821EF554h case    9:*/		regs.R30 = regs.R3;
		/* 821EF554h case    9:*/		return 0x821EF558;
		  /* 821EF558h */ case   10:  		/* bl 218176 */
		/* 821EF558h case   10:*/		regs.LR = 0x821EF55C; return 0x82224998;
		/* 821EF558h case   10:*/		return 0x821EF55C;
		  /* 821EF55Ch */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF55Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF55Ch case   11:*/		return 0x821EF560;
		  /* 821EF560h */ case   12:  		/* mr R31, R3 */
		/* 821EF560h case   12:*/		regs.R31 = regs.R3;
		/* 821EF560h case   12:*/		return 0x821EF564;
		  /* 821EF564h */ case   13:  		/* mr R4, R29 */
		/* 821EF564h case   13:*/		regs.R4 = regs.R29;
		/* 821EF564h case   13:*/		return 0x821EF568;
		  /* 821EF568h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EF568h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF568h case   14:*/		return 0x821EF56C;
		  /* 821EF56Ch */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF56Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821EF580;  }
		/* 821EF56Ch case   15:*/		return 0x821EF570;
		  /* 821EF570h */ case   16:  		/* mr R3, R30 */
		/* 821EF570h case   16:*/		regs.R3 = regs.R30;
		/* 821EF570h case   16:*/		return 0x821EF574;
		  /* 821EF574h */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF574h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF574h case   17:*/		return 0x821EF578;
		  /* 821EF578h */ case   18:  		/* bl -517256 */
		/* 821EF578h case   18:*/		regs.LR = 0x821EF57C; return 0x821710F0;
		/* 821EF578h case   18:*/		return 0x821EF57C;
		  /* 821EF57Ch */ case   19:  		/* mr R4, R3 */
		/* 821EF57Ch case   19:*/		regs.R4 = regs.R3;
		/* 821EF57Ch case   19:*/		return 0x821EF580;
	}
	return 0x821EF580;
} // Block from 821EF530h-821EF580h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EF580h
// Function '?MakeInstr_V_CNDE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF580);
		  /* 821EF580h */ case    0:  		/* mr R3, R31 */
		/* 821EF580h case    0:*/		regs.R3 = regs.R31;
		/* 821EF580h case    0:*/		return 0x821EF584;
		  /* 821EF584h */ case    1:  		/* bl -488380 */
		/* 821EF584h case    1:*/		regs.LR = 0x821EF588; return 0x821781C8;
		/* 821EF584h case    1:*/		return 0x821EF588;
		  /* 821EF588h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF588h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF588h case    2:*/		return 0x821EF58C;
		  /* 821EF58Ch */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF58Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF58Ch case    3:*/		return 0x821EF590;
		  /* 821EF590h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF590h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF590h case    4:*/		return 0x821EF594;
		  /* 821EF594h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF594h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF594h case    5:*/		return 0x821EF598;
		  /* 821EF598h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF598h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF598h case    6:*/		return 0x821EF59C;
		  /* 821EF59Ch */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF59Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF59Ch case    7:*/		return 0x821EF5A0;
		  /* 821EF5A0h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF5A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF5A0h case    8:*/		return 0x821EF5A4;
		  /* 821EF5A4h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF5A4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF5A4h case    9:*/		return 0x821EF5A8;
		  /* 821EF5A8h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF5A8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF5A8h case   10:*/		return 0x821EF5AC;
		  /* 821EF5ACh */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF5ACh case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF5ACh case   11:*/		return 0x821EF5B0;
		  /* 821EF5B0h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF5B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF5B0h case   12:*/		return 0x821EF5B4;
		  /* 821EF5B4h */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF5B4h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF5B4h case   13:*/		return 0x821EF5B8;
		  /* 821EF5B8h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF5B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF5B8h case   14:*/		return 0x821EF5BC;
		  /* 821EF5BCh */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF5BCh case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF5BCh case   15:*/		return 0x821EF5C0;
		  /* 821EF5C0h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF5C0h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF5C0h case   16:*/		return 0x821EF5C4;
		  /* 821EF5C4h */ case   17:  		/* mr R3, R31 */
		/* 821EF5C4h case   17:*/		regs.R3 = regs.R31;
		/* 821EF5C4h case   17:*/		return 0x821EF5C8;
		  /* 821EF5C8h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF5C8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF5C8h case   18:*/		return 0x821EF5CC;
		  /* 821EF5CCh */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF5CCh case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF5CCh case   19:*/		return 0x821EF5D0;
		  /* 821EF5D0h */ case   20:  		/* b -1434404 */
		/* 821EF5D0h case   20:*/		return 0x820912AC;
		/* 821EF5D0h case   20:*/		return 0x821EF5D4;
		  /* 821EF5D4h */ case   21:  		/* nop */
		/* 821EF5D4h case   21:*/		cpu::op::nop();
		/* 821EF5D4h case   21:*/		return 0x821EF5D8;
	}
	return 0x821EF5D8;
} // Block from 821EF580h-821EF5D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF5D8);
		  /* 821EF5D8h */ case    0:  		/* mfspr R12, LR */
		/* 821EF5D8h case    0:*/		regs.R12 = regs.LR;
		/* 821EF5D8h case    0:*/		return 0x821EF5DC;
		  /* 821EF5DCh */ case    1:  		/* bl -1434500 */
		/* 821EF5DCh case    1:*/		regs.LR = 0x821EF5E0; return 0x82091258;
		/* 821EF5DCh case    1:*/		return 0x821EF5E0;
		  /* 821EF5E0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EF5E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EF5E0h case    2:*/		return 0x821EF5E4;
		  /* 821EF5E4h */ case    3:  		/* mr R28, R5 */
		/* 821EF5E4h case    3:*/		regs.R28 = regs.R5;
		/* 821EF5E4h case    3:*/		return 0x821EF5E8;
		  /* 821EF5E8h */ case    4:  		/* li R8, 4 */
		/* 821EF5E8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF5E8h case    4:*/		return 0x821EF5EC;
		  /* 821EF5ECh */ case    5:  		/* li R7, 2 */
		/* 821EF5ECh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EF5ECh case    5:*/		return 0x821EF5F0;
		  /* 821EF5F0h */ case    6:  		/* li R6, 100 */
		/* 821EF5F0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x64);
		/* 821EF5F0h case    6:*/		return 0x821EF5F4;
		  /* 821EF5F4h */ case    7:  		/* li R5, 0 */
		/* 821EF5F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF5F4h case    7:*/		return 0x821EF5F8;
		  /* 821EF5F8h */ case    8:  		/* mr R29, R4 */
		/* 821EF5F8h case    8:*/		regs.R29 = regs.R4;
		/* 821EF5F8h case    8:*/		return 0x821EF5FC;
		  /* 821EF5FCh */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF5FCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF5FCh case    9:*/		return 0x821EF600;
		  /* 821EF600h */ case   10:  		/* mr R30, R3 */
		/* 821EF600h case   10:*/		regs.R30 = regs.R3;
		/* 821EF600h case   10:*/		return 0x821EF604;
		  /* 821EF604h */ case   11:  		/* bl 218004 */
		/* 821EF604h case   11:*/		regs.LR = 0x821EF608; return 0x82224998;
		/* 821EF604h case   11:*/		return 0x821EF608;
		  /* 821EF608h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF608h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF608h case   12:*/		return 0x821EF60C;
		  /* 821EF60Ch */ case   13:  		/* mr R31, R3 */
		/* 821EF60Ch case   13:*/		regs.R31 = regs.R3;
		/* 821EF60Ch case   13:*/		return 0x821EF610;
		  /* 821EF610h */ case   14:  		/* mr R4, R29 */
		/* 821EF610h case   14:*/		regs.R4 = regs.R29;
		/* 821EF610h case   14:*/		return 0x821EF614;
		  /* 821EF614h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821EF614h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF614h case   15:*/		return 0x821EF618;
		  /* 821EF618h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF618h case   16:*/		if ( regs.CR[6].eq ) { return 0x821EF62C;  }
		/* 821EF618h case   16:*/		return 0x821EF61C;
		  /* 821EF61Ch */ case   17:  		/* mr R3, R30 */
		/* 821EF61Ch case   17:*/		regs.R3 = regs.R30;
		/* 821EF61Ch case   17:*/		return 0x821EF620;
		  /* 821EF620h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF620h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF620h case   18:*/		return 0x821EF624;
		  /* 821EF624h */ case   19:  		/* bl -517428 */
		/* 821EF624h case   19:*/		regs.LR = 0x821EF628; return 0x821710F0;
		/* 821EF624h case   19:*/		return 0x821EF628;
		  /* 821EF628h */ case   20:  		/* mr R4, R3 */
		/* 821EF628h case   20:*/		regs.R4 = regs.R3;
		/* 821EF628h case   20:*/		return 0x821EF62C;
	}
	return 0x821EF62C;
} // Block from 821EF5D8h-821EF62Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821EF62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF62C);
		  /* 821EF62Ch */ case    0:  		/* mr R3, R31 */
		/* 821EF62Ch case    0:*/		regs.R3 = regs.R31;
		/* 821EF62Ch case    0:*/		return 0x821EF630;
		  /* 821EF630h */ case    1:  		/* bl -488552 */
		/* 821EF630h case    1:*/		regs.LR = 0x821EF634; return 0x821781C8;
		/* 821EF630h case    1:*/		return 0x821EF634;
		  /* 821EF634h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF634h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF634h case    2:*/		return 0x821EF638;
		  /* 821EF638h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 821EF638h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821EF638h case    3:*/		return 0x821EF63C;
		  /* 821EF63Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821EF63Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF63Ch case    4:*/		return 0x821EF640;
		  /* 821EF640h */ case    5:  		/* mr R4, R28 */
		/* 821EF640h case    5:*/		regs.R4 = regs.R28;
		/* 821EF640h case    5:*/		return 0x821EF644;
		  /* 821EF644h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF644h case    6:*/		if ( regs.CR[6].eq ) { return 0x821EF658;  }
		/* 821EF644h case    6:*/		return 0x821EF648;
		  /* 821EF648h */ case    7:  		/* mr R3, R30 */
		/* 821EF648h case    7:*/		regs.R3 = regs.R30;
		/* 821EF648h case    7:*/		return 0x821EF64C;
		  /* 821EF64Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 821EF64Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821EF64Ch case    8:*/		return 0x821EF650;
		  /* 821EF650h */ case    9:  		/* bl -517472 */
		/* 821EF650h case    9:*/		regs.LR = 0x821EF654; return 0x821710F0;
		/* 821EF650h case    9:*/		return 0x821EF654;
		  /* 821EF654h */ case   10:  		/* mr R4, R3 */
		/* 821EF654h case   10:*/		regs.R4 = regs.R3;
		/* 821EF654h case   10:*/		return 0x821EF658;
	}
	return 0x821EF658;
} // Block from 821EF62Ch-821EF658h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821EF658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF658);
		  /* 821EF658h */ case    0:  		/* mr R3, R31 */
		/* 821EF658h case    0:*/		regs.R3 = regs.R31;
		/* 821EF658h case    0:*/		return 0x821EF65C;
		  /* 821EF65Ch */ case    1:  		/* bl -488596 */
		/* 821EF65Ch case    1:*/		regs.LR = 0x821EF660; return 0x821781C8;
		/* 821EF65Ch case    1:*/		return 0x821EF660;
		  /* 821EF660h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821EF660h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EF660h case    2:*/		return 0x821EF664;
		  /* 821EF664h */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF664h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF664h case    3:*/		return 0x821EF668;
		  /* 821EF668h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF668h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF668h case    4:*/		return 0x821EF66C;
		  /* 821EF66Ch */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF66Ch case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF66Ch case    5:*/		return 0x821EF670;
		  /* 821EF670h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF670h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF670h case    6:*/		return 0x821EF674;
		  /* 821EF674h */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF674h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF674h case    7:*/		return 0x821EF678;
		  /* 821EF678h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF678h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF678h case    8:*/		return 0x821EF67C;
		  /* 821EF67Ch */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF67Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF67Ch case    9:*/		return 0x821EF680;
		  /* 821EF680h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF680h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF680h case   10:*/		return 0x821EF684;
		  /* 821EF684h */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF684h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF684h case   11:*/		return 0x821EF688;
		  /* 821EF688h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF688h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF688h case   12:*/		return 0x821EF68C;
		  /* 821EF68Ch */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF68Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF68Ch case   13:*/		return 0x821EF690;
		  /* 821EF690h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF690h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF690h case   14:*/		return 0x821EF694;
		  /* 821EF694h */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF694h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF694h case   15:*/		return 0x821EF698;
		  /* 821EF698h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF698h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF698h case   16:*/		return 0x821EF69C;
		  /* 821EF69Ch */ case   17:  		/* mr R3, R31 */
		/* 821EF69Ch case   17:*/		regs.R3 = regs.R31;
		/* 821EF69Ch case   17:*/		return 0x821EF6A0;
	}
	return 0x821EF6A0;
} // Block from 821EF658h-821EF6A0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EF6A0h
// Function '?MakeInstr_V_DOT4@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF6A0);
		  /* 821EF6A0h */ case    0:  		/* stw R9, <#[R11]> */
		/* 821EF6A0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF6A0h case    0:*/		return 0x821EF6A4;
		  /* 821EF6A4h */ case    1:  		/* addi R1, R1, 128 */
		/* 821EF6A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EF6A4h case    1:*/		return 0x821EF6A8;
		  /* 821EF6A8h */ case    2:  		/* b -1434624 */
		/* 821EF6A8h case    2:*/		return 0x820912A8;
		/* 821EF6A8h case    2:*/		return 0x821EF6AC;
		  /* 821EF6ACh */ case    3:  		/* nop */
		/* 821EF6ACh case    3:*/		cpu::op::nop();
		/* 821EF6ACh case    3:*/		return 0x821EF6B0;
	}
	return 0x821EF6B0;
} // Block from 821EF6A0h-821EF6B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EF6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF6B0);
		  /* 821EF6B0h */ case    0:  		/* mfspr R12, LR */
		/* 821EF6B0h case    0:*/		regs.R12 = regs.LR;
		/* 821EF6B0h case    0:*/		return 0x821EF6B4;
		  /* 821EF6B4h */ case    1:  		/* bl -1434712 */
		/* 821EF6B4h case    1:*/		regs.LR = 0x821EF6B8; return 0x8209125C;
		/* 821EF6B4h case    1:*/		return 0x821EF6B8;
		  /* 821EF6B8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF6B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF6B8h case    2:*/		return 0x821EF6BC;
		  /* 821EF6BCh */ case    3:  		/* li R8, 4 */
		/* 821EF6BCh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF6BCh case    3:*/		return 0x821EF6C0;
		  /* 821EF6C0h */ case    4:  		/* li R7, 1 */
		/* 821EF6C0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF6C0h case    4:*/		return 0x821EF6C4;
		  /* 821EF6C4h */ case    5:  		/* li R6, 101 */
		/* 821EF6C4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x65);
		/* 821EF6C4h case    5:*/		return 0x821EF6C8;
		  /* 821EF6C8h */ case    6:  		/* li R5, 0 */
		/* 821EF6C8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF6C8h case    6:*/		return 0x821EF6CC;
		  /* 821EF6CCh */ case    7:  		/* mr R29, R4 */
		/* 821EF6CCh case    7:*/		regs.R29 = regs.R4;
		/* 821EF6CCh case    7:*/		return 0x821EF6D0;
		  /* 821EF6D0h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF6D0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF6D0h case    8:*/		return 0x821EF6D4;
		  /* 821EF6D4h */ case    9:  		/* mr R30, R3 */
		/* 821EF6D4h case    9:*/		regs.R30 = regs.R3;
		/* 821EF6D4h case    9:*/		return 0x821EF6D8;
		  /* 821EF6D8h */ case   10:  		/* bl 217792 */
		/* 821EF6D8h case   10:*/		regs.LR = 0x821EF6DC; return 0x82224998;
		/* 821EF6D8h case   10:*/		return 0x821EF6DC;
		  /* 821EF6DCh */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF6DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF6DCh case   11:*/		return 0x821EF6E0;
		  /* 821EF6E0h */ case   12:  		/* mr R31, R3 */
		/* 821EF6E0h case   12:*/		regs.R31 = regs.R3;
		/* 821EF6E0h case   12:*/		return 0x821EF6E4;
		  /* 821EF6E4h */ case   13:  		/* mr R4, R29 */
		/* 821EF6E4h case   13:*/		regs.R4 = regs.R29;
		/* 821EF6E4h case   13:*/		return 0x821EF6E8;
		  /* 821EF6E8h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821EF6E8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF6E8h case   14:*/		return 0x821EF6EC;
		  /* 821EF6ECh */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF6ECh case   15:*/		if ( regs.CR[6].eq ) { return 0x821EF700;  }
		/* 821EF6ECh case   15:*/		return 0x821EF6F0;
		  /* 821EF6F0h */ case   16:  		/* mr R3, R30 */
		/* 821EF6F0h case   16:*/		regs.R3 = regs.R30;
		/* 821EF6F0h case   16:*/		return 0x821EF6F4;
		  /* 821EF6F4h */ case   17:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF6F4h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF6F4h case   17:*/		return 0x821EF6F8;
		  /* 821EF6F8h */ case   18:  		/* bl -517640 */
		/* 821EF6F8h case   18:*/		regs.LR = 0x821EF6FC; return 0x821710F0;
		/* 821EF6F8h case   18:*/		return 0x821EF6FC;
		  /* 821EF6FCh */ case   19:  		/* mr R4, R3 */
		/* 821EF6FCh case   19:*/		regs.R4 = regs.R3;
		/* 821EF6FCh case   19:*/		return 0x821EF700;
	}
	return 0x821EF700;
} // Block from 821EF6B0h-821EF700h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821EF700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF700);
		  /* 821EF700h */ case    0:  		/* mr R3, R31 */
		/* 821EF700h case    0:*/		regs.R3 = regs.R31;
		/* 821EF700h case    0:*/		return 0x821EF704;
		  /* 821EF704h */ case    1:  		/* bl -488764 */
		/* 821EF704h case    1:*/		regs.LR = 0x821EF708; return 0x821781C8;
		/* 821EF704h case    1:*/		return 0x821EF708;
		  /* 821EF708h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF708h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF708h case    2:*/		return 0x821EF70C;
		  /* 821EF70Ch */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF70Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF70Ch case    3:*/		return 0x821EF710;
		  /* 821EF710h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF710h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF710h case    4:*/		return 0x821EF714;
		  /* 821EF714h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF714h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF714h case    5:*/		return 0x821EF718;
		  /* 821EF718h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF718h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF718h case    6:*/		return 0x821EF71C;
		  /* 821EF71Ch */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF71Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF71Ch case    7:*/		return 0x821EF720;
		  /* 821EF720h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF720h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF720h case    8:*/		return 0x821EF724;
		  /* 821EF724h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF724h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF724h case    9:*/		return 0x821EF728;
		  /* 821EF728h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF728h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF728h case   10:*/		return 0x821EF72C;
		  /* 821EF72Ch */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF72Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF72Ch case   11:*/		return 0x821EF730;
		  /* 821EF730h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF730h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF730h case   12:*/		return 0x821EF734;
		  /* 821EF734h */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF734h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF734h case   13:*/		return 0x821EF738;
		  /* 821EF738h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF738h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF738h case   14:*/		return 0x821EF73C;
		  /* 821EF73Ch */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF73Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF73Ch case   15:*/		return 0x821EF740;
		  /* 821EF740h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF740h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF740h case   16:*/		return 0x821EF744;
		  /* 821EF744h */ case   17:  		/* mr R3, R31 */
		/* 821EF744h case   17:*/		regs.R3 = regs.R31;
		/* 821EF744h case   17:*/		return 0x821EF748;
		  /* 821EF748h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF748h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF748h case   18:*/		return 0x821EF74C;
		  /* 821EF74Ch */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF74Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF74Ch case   19:*/		return 0x821EF750;
		  /* 821EF750h */ case   20:  		/* b -1434788 */
		/* 821EF750h case   20:*/		return 0x820912AC;
		/* 821EF750h case   20:*/		return 0x821EF754;
		  /* 821EF754h */ case   21:  		/* nop */
		/* 821EF754h case   21:*/		cpu::op::nop();
		/* 821EF754h case   21:*/		return 0x821EF758;
	}
	return 0x821EF758;
} // Block from 821EF700h-821EF758h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF758);
		  /* 821EF758h */ case    0:  		/* mfspr R12, LR */
		/* 821EF758h case    0:*/		regs.R12 = regs.LR;
		/* 821EF758h case    0:*/		return 0x821EF75C;
		  /* 821EF75Ch */ case    1:  		/* bl -1434880 */
		/* 821EF75Ch case    1:*/		regs.LR = 0x821EF760; return 0x8209125C;
		/* 821EF75Ch case    1:*/		return 0x821EF760;
		  /* 821EF760h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EF760h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EF760h case    2:*/		return 0x821EF764;
		  /* 821EF764h */ case    3:  		/* li R8, 4 */
		/* 821EF764h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF764h case    3:*/		return 0x821EF768;
		  /* 821EF768h */ case    4:  		/* li R7, 1 */
		/* 821EF768h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EF768h case    4:*/		return 0x821EF76C;
		  /* 821EF76Ch */ case    5:  		/* li R6, 102 */
		/* 821EF76Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x66);
		/* 821EF76Ch case    5:*/		return 0x821EF770;
		  /* 821EF770h */ case    6:  		/* li R5, 0 */
		/* 821EF770h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF770h case    6:*/		return 0x821EF774;
		  /* 821EF774h */ case    7:  		/* mr R29, R4 */
		/* 821EF774h case    7:*/		regs.R29 = regs.R4;
		/* 821EF774h case    7:*/		return 0x821EF778;
		  /* 821EF778h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF778h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF778h case    8:*/		return 0x821EF77C;
		  /* 821EF77Ch */ case    9:  		/* mr R30, R3 */
		/* 821EF77Ch case    9:*/		regs.R30 = regs.R3;
		/* 821EF77Ch case    9:*/		return 0x821EF780;
		  /* 821EF780h */ case   10:  		/* bl 217624 */
		/* 821EF780h case   10:*/		regs.LR = 0x821EF784; return 0x82224998;
		/* 821EF780h case   10:*/		return 0x821EF784;
		  /* 821EF784h */ case   11:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF784h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF784h case   11:*/		return 0x821EF788;
	}
	return 0x821EF788;
} // Block from 821EF758h-821EF788h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EF788h
// Function '?MakeInstr_V_CUBE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF788);
		  /* 821EF788h */ case    0:  		/* mr R31, R3 */
		/* 821EF788h case    0:*/		regs.R31 = regs.R3;
		/* 821EF788h case    0:*/		return 0x821EF78C;
		  /* 821EF78Ch */ case    1:  		/* mr R4, R29 */
		/* 821EF78Ch case    1:*/		regs.R4 = regs.R29;
		/* 821EF78Ch case    1:*/		return 0x821EF790;
		  /* 821EF790h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821EF790h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF790h case    2:*/		return 0x821EF794;
		  /* 821EF794h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF794h case    3:*/		if ( regs.CR[6].eq ) { return 0x821EF7A8;  }
		/* 821EF794h case    3:*/		return 0x821EF798;
		  /* 821EF798h */ case    4:  		/* mr R3, R30 */
		/* 821EF798h case    4:*/		regs.R3 = regs.R30;
		/* 821EF798h case    4:*/		return 0x821EF79C;
		  /* 821EF79Ch */ case    5:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF79Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF79Ch case    5:*/		return 0x821EF7A0;
		  /* 821EF7A0h */ case    6:  		/* bl -517808 */
		/* 821EF7A0h case    6:*/		regs.LR = 0x821EF7A4; return 0x821710F0;
		/* 821EF7A0h case    6:*/		return 0x821EF7A4;
		  /* 821EF7A4h */ case    7:  		/* mr R4, R3 */
		/* 821EF7A4h case    7:*/		regs.R4 = regs.R3;
		/* 821EF7A4h case    7:*/		return 0x821EF7A8;
	}
	return 0x821EF7A8;
} // Block from 821EF788h-821EF7A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EF7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF7A8);
		  /* 821EF7A8h */ case    0:  		/* mr R3, R31 */
		/* 821EF7A8h case    0:*/		regs.R3 = regs.R31;
		/* 821EF7A8h case    0:*/		return 0x821EF7AC;
		  /* 821EF7ACh */ case    1:  		/* bl -488932 */
		/* 821EF7ACh case    1:*/		regs.LR = 0x821EF7B0; return 0x821781C8;
		/* 821EF7ACh case    1:*/		return 0x821EF7B0;
		  /* 821EF7B0h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF7B0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF7B0h case    2:*/		return 0x821EF7B4;
		  /* 821EF7B4h */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821EF7B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF7B4h case    3:*/		return 0x821EF7B8;
		  /* 821EF7B8h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EF7B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EF7B8h case    4:*/		return 0x821EF7BC;
		  /* 821EF7BCh */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821EF7BCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821EF7BCh case    5:*/		return 0x821EF7C0;
		  /* 821EF7C0h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EF7C0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF7C0h case    6:*/		return 0x821EF7C4;
		  /* 821EF7C4h */ case    7:  		/* addi R8, R11, -36 */
		/* 821EF7C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF7C4h case    7:*/		return 0x821EF7C8;
		  /* 821EF7C8h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EF7C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EF7C8h case    8:*/		return 0x821EF7CC;
		  /* 821EF7CCh */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EF7CCh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF7CCh case    9:*/		return 0x821EF7D0;
		  /* 821EF7D0h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EF7D0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF7D0h case   10:*/		return 0x821EF7D4;
		  /* 821EF7D4h */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EF7D4h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EF7D4h case   11:*/		return 0x821EF7D8;
		  /* 821EF7D8h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EF7D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF7D8h case   12:*/		return 0x821EF7DC;
		  /* 821EF7DCh */ case   13:  		/* ori R8, R8, 1 */
		/* 821EF7DCh case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EF7DCh case   13:*/		return 0x821EF7E0;
		  /* 821EF7E0h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EF7E0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EF7E0h case   14:*/		return 0x821EF7E4;
		  /* 821EF7E4h */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EF7E4h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF7E4h case   15:*/		return 0x821EF7E8;
		  /* 821EF7E8h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EF7E8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EF7E8h case   16:*/		return 0x821EF7EC;
		  /* 821EF7ECh */ case   17:  		/* mr R3, R31 */
		/* 821EF7ECh case   17:*/		regs.R3 = regs.R31;
		/* 821EF7ECh case   17:*/		return 0x821EF7F0;
		  /* 821EF7F0h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EF7F0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF7F0h case   18:*/		return 0x821EF7F4;
		  /* 821EF7F4h */ case   19:  		/* addi R1, R1, 112 */
		/* 821EF7F4h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EF7F4h case   19:*/		return 0x821EF7F8;
		  /* 821EF7F8h */ case   20:  		/* b -1434956 */
		/* 821EF7F8h case   20:*/		return 0x820912AC;
		/* 821EF7F8h case   20:*/		return 0x821EF7FC;
		  /* 821EF7FCh */ case   21:  		/* nop */
		/* 821EF7FCh case   21:*/		cpu::op::nop();
		/* 821EF7FCh case   21:*/		return 0x821EF800;
	}
	return 0x821EF800;
} // Block from 821EF7A8h-821EF800h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821EF800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF800);
		  /* 821EF800h */ case    0:  		/* mfspr R12, LR */
		/* 821EF800h case    0:*/		regs.R12 = regs.LR;
		/* 821EF800h case    0:*/		return 0x821EF804;
		  /* 821EF804h */ case    1:  		/* bl -1435052 */
		/* 821EF804h case    1:*/		regs.LR = 0x821EF808; return 0x82091258;
		/* 821EF804h case    1:*/		return 0x821EF808;
		  /* 821EF808h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EF808h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EF808h case    2:*/		return 0x821EF80C;
		  /* 821EF80Ch */ case    3:  		/* mr R29, R5 */
		/* 821EF80Ch case    3:*/		regs.R29 = regs.R5;
		/* 821EF80Ch case    3:*/		return 0x821EF810;
		  /* 821EF810h */ case    4:  		/* li R8, 4 */
		/* 821EF810h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF810h case    4:*/		return 0x821EF814;
		  /* 821EF814h */ case    5:  		/* li R7, 2 */
		/* 821EF814h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EF814h case    5:*/		return 0x821EF818;
		  /* 821EF818h */ case    6:  		/* li R6, 1 */
		/* 821EF818h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821EF818h case    6:*/		return 0x821EF81C;
		  /* 821EF81Ch */ case    7:  		/* li R5, 0 */
		/* 821EF81Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF81Ch case    7:*/		return 0x821EF820;
		  /* 821EF820h */ case    8:  		/* mr R28, R4 */
		/* 821EF820h case    8:*/		regs.R28 = regs.R4;
		/* 821EF820h case    8:*/		return 0x821EF824;
		  /* 821EF824h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF824h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF824h case    9:*/		return 0x821EF828;
		  /* 821EF828h */ case   10:  		/* mr R30, R3 */
		/* 821EF828h case   10:*/		regs.R30 = regs.R3;
		/* 821EF828h case   10:*/		return 0x821EF82C;
		  /* 821EF82Ch */ case   11:  		/* bl 217452 */
		/* 821EF82Ch case   11:*/		regs.LR = 0x821EF830; return 0x82224998;
		/* 821EF82Ch case   11:*/		return 0x821EF830;
		  /* 821EF830h */ case   12:  		/* mr R31, R3 */
		/* 821EF830h case   12:*/		regs.R31 = regs.R3;
		/* 821EF830h case   12:*/		return 0x821EF834;
		  /* 821EF834h */ case   13:  		/* mr R4, R28 */
		/* 821EF834h case   13:*/		regs.R4 = regs.R28;
		/* 821EF834h case   13:*/		return 0x821EF838;
		  /* 821EF838h */ case   14:  		/* mr R3, R30 */
		/* 821EF838h case   14:*/		regs.R3 = regs.R30;
		/* 821EF838h case   14:*/		return 0x821EF83C;
		  /* 821EF83Ch */ case   15:  		/* bl -489532 */
		/* 821EF83Ch case   15:*/		regs.LR = 0x821EF840; return 0x82178000;
		/* 821EF83Ch case   15:*/		return 0x821EF840;
		  /* 821EF840h */ case   16:  		/* mr R4, R3 */
		/* 821EF840h case   16:*/		regs.R4 = regs.R3;
		/* 821EF840h case   16:*/		return 0x821EF844;
		  /* 821EF844h */ case   17:  		/* mr R3, R31 */
		/* 821EF844h case   17:*/		regs.R3 = regs.R31;
		/* 821EF844h case   17:*/		return 0x821EF848;
		  /* 821EF848h */ case   18:  		/* bl -489088 */
		/* 821EF848h case   18:*/		regs.LR = 0x821EF84C; return 0x821781C8;
		/* 821EF848h case   18:*/		return 0x821EF84C;
		  /* 821EF84Ch */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF84Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF84Ch case   19:*/		return 0x821EF850;
		  /* 821EF850h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF850h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF850h case   20:*/		return 0x821EF854;
		  /* 821EF854h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821EF854h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF854h case   21:*/		return 0x821EF858;
		  /* 821EF858h */ case   22:  		/* mr R4, R29 */
		/* 821EF858h case   22:*/		regs.R4 = regs.R29;
		/* 821EF858h case   22:*/		return 0x821EF85C;
		  /* 821EF85Ch */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF85Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x821EF870;  }
		/* 821EF85Ch case   23:*/		return 0x821EF860;
	}
	return 0x821EF860;
} // Block from 821EF800h-821EF860h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821EF860h
// Function '?MakeInstr_V_MAX4@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF860);
		  /* 821EF860h */ case    0:  		/* mr R3, R30 */
		/* 821EF860h case    0:*/		regs.R3 = regs.R30;
		/* 821EF860h case    0:*/		return 0x821EF864;
		  /* 821EF864h */ case    1:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF864h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF864h case    1:*/		return 0x821EF868;
		  /* 821EF868h */ case    2:  		/* bl -518008 */
		/* 821EF868h case    2:*/		regs.LR = 0x821EF86C; return 0x821710F0;
		/* 821EF868h case    2:*/		return 0x821EF86C;
		  /* 821EF86Ch */ case    3:  		/* mr R4, R3 */
		/* 821EF86Ch case    3:*/		regs.R4 = regs.R3;
		/* 821EF86Ch case    3:*/		return 0x821EF870;
	}
	return 0x821EF870;
} // Block from 821EF860h-821EF870h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EF870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF870);
		  /* 821EF870h */ case    0:  		/* mr R3, R31 */
		/* 821EF870h case    0:*/		regs.R3 = regs.R31;
		/* 821EF870h case    0:*/		return 0x821EF874;
		  /* 821EF874h */ case    1:  		/* bl -489132 */
		/* 821EF874h case    1:*/		regs.LR = 0x821EF878; return 0x821781C8;
		/* 821EF874h case    1:*/		return 0x821EF878;
		  /* 821EF878h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EF878h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF878h case    2:*/		return 0x821EF87C;
		  /* 821EF87Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EF87Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EF87Ch case    3:*/		return 0x821EF880;
		  /* 821EF880h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EF880h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EF880h case    4:*/		return 0x821EF884;
		  /* 821EF884h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EF884h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EF884h case    5:*/		return 0x821EF888;
		  /* 821EF888h */ case    6:  		/* mr R3, R31 */
		/* 821EF888h case    6:*/		regs.R3 = regs.R31;
		/* 821EF888h case    6:*/		return 0x821EF88C;
		  /* 821EF88Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821EF88Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EF88Ch case    7:*/		return 0x821EF890;
		  /* 821EF890h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EF890h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF890h case    8:*/		return 0x821EF894;
		  /* 821EF894h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EF894h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EF894h case    9:*/		return 0x821EF898;
		  /* 821EF898h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EF898h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EF898h case   10:*/		return 0x821EF89C;
		  /* 821EF89Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EF89Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF89Ch case   11:*/		return 0x821EF8A0;
		  /* 821EF8A0h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EF8A0h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EF8A0h case   12:*/		return 0x821EF8A4;
		  /* 821EF8A4h */ case   13:  		/* addi R9, R11, 4 */
		/* 821EF8A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EF8A4h case   13:*/		return 0x821EF8A8;
		  /* 821EF8A8h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EF8A8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF8A8h case   14:*/		return 0x821EF8AC;
		  /* 821EF8ACh */ case   15:  		/* addi R10, R10, 24 */
		/* 821EF8ACh case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EF8ACh case   15:*/		return 0x821EF8B0;
		  /* 821EF8B0h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EF8B0h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF8B0h case   16:*/		return 0x821EF8B4;
		  /* 821EF8B4h */ case   17:  		/* addi R6, R10, -36 */
		/* 821EF8B4h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF8B4h case   17:*/		return 0x821EF8B8;
		  /* 821EF8B8h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EF8B8h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF8B8h case   18:*/		return 0x821EF8BC;
		  /* 821EF8BCh */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EF8BCh case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF8BCh case   19:*/		return 0x821EF8C0;
		  /* 821EF8C0h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EF8C0h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EF8C0h case   20:*/		return 0x821EF8C4;
		  /* 821EF8C4h */ case   21:  		/* ori R6, R6, 1 */
		/* 821EF8C4h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EF8C4h case   21:*/		return 0x821EF8C8;
		  /* 821EF8C8h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EF8C8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF8C8h case   22:*/		return 0x821EF8CC;
		  /* 821EF8CCh */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EF8CCh case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EF8CCh case   23:*/		return 0x821EF8D0;
		  /* 821EF8D0h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EF8D0h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF8D0h case   24:*/		return 0x821EF8D4;
		  /* 821EF8D4h */ case   25:  		/* addi R1, R1, 128 */
		/* 821EF8D4h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EF8D4h case   25:*/		return 0x821EF8D8;
		  /* 821EF8D8h */ case   26:  		/* b -1435184 */
		/* 821EF8D8h case   26:*/		return 0x820912A8;
		/* 821EF8D8h case   26:*/		return 0x821EF8DC;
		  /* 821EF8DCh */ case   27:  		/* nop */
		/* 821EF8DCh case   27:*/		cpu::op::nop();
		/* 821EF8DCh case   27:*/		return 0x821EF8E0;
	}
	return 0x821EF8E0;
} // Block from 821EF870h-821EF8E0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EF8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF8E0);
		  /* 821EF8E0h */ case    0:  		/* mfspr R12, LR */
		/* 821EF8E0h case    0:*/		regs.R12 = regs.LR;
		/* 821EF8E0h case    0:*/		return 0x821EF8E4;
		  /* 821EF8E4h */ case    1:  		/* bl -1435276 */
		/* 821EF8E4h case    1:*/		regs.LR = 0x821EF8E8; return 0x82091258;
		/* 821EF8E4h case    1:*/		return 0x821EF8E8;
		  /* 821EF8E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EF8E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EF8E8h case    2:*/		return 0x821EF8EC;
		  /* 821EF8ECh */ case    3:  		/* mr R29, R5 */
		/* 821EF8ECh case    3:*/		regs.R29 = regs.R5;
		/* 821EF8ECh case    3:*/		return 0x821EF8F0;
		  /* 821EF8F0h */ case    4:  		/* li R8, 4 */
		/* 821EF8F0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF8F0h case    4:*/		return 0x821EF8F4;
		  /* 821EF8F4h */ case    5:  		/* li R7, 2 */
		/* 821EF8F4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EF8F4h case    5:*/		return 0x821EF8F8;
		  /* 821EF8F8h */ case    6:  		/* li R6, 2 */
		/* 821EF8F8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821EF8F8h case    6:*/		return 0x821EF8FC;
		  /* 821EF8FCh */ case    7:  		/* li R5, 0 */
		/* 821EF8FCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF8FCh case    7:*/		return 0x821EF900;
		  /* 821EF900h */ case    8:  		/* mr R28, R4 */
		/* 821EF900h case    8:*/		regs.R28 = regs.R4;
		/* 821EF900h case    8:*/		return 0x821EF904;
		  /* 821EF904h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF904h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF904h case    9:*/		return 0x821EF908;
		  /* 821EF908h */ case   10:  		/* mr R30, R3 */
		/* 821EF908h case   10:*/		regs.R30 = regs.R3;
		/* 821EF908h case   10:*/		return 0x821EF90C;
		  /* 821EF90Ch */ case   11:  		/* bl 217228 */
		/* 821EF90Ch case   11:*/		regs.LR = 0x821EF910; return 0x82224998;
		/* 821EF90Ch case   11:*/		return 0x821EF910;
		  /* 821EF910h */ case   12:  		/* mr R31, R3 */
		/* 821EF910h case   12:*/		regs.R31 = regs.R3;
		/* 821EF910h case   12:*/		return 0x821EF914;
		  /* 821EF914h */ case   13:  		/* mr R4, R28 */
		/* 821EF914h case   13:*/		regs.R4 = regs.R28;
		/* 821EF914h case   13:*/		return 0x821EF918;
	}
	return 0x821EF918;
} // Block from 821EF8E0h-821EF918h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EF918h
// Function '?MakeInstr_V_KILLGT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF918);
		  /* 821EF918h */ case    0:  		/* mr R3, R30 */
		/* 821EF918h case    0:*/		regs.R3 = regs.R30;
		/* 821EF918h case    0:*/		return 0x821EF91C;
		  /* 821EF91Ch */ case    1:  		/* bl -489756 */
		/* 821EF91Ch case    1:*/		regs.LR = 0x821EF920; return 0x82178000;
		/* 821EF91Ch case    1:*/		return 0x821EF920;
		  /* 821EF920h */ case    2:  		/* mr R4, R3 */
		/* 821EF920h case    2:*/		regs.R4 = regs.R3;
		/* 821EF920h case    2:*/		return 0x821EF924;
		  /* 821EF924h */ case    3:  		/* mr R3, R31 */
		/* 821EF924h case    3:*/		regs.R3 = regs.R31;
		/* 821EF924h case    3:*/		return 0x821EF928;
		  /* 821EF928h */ case    4:  		/* bl -489312 */
		/* 821EF928h case    4:*/		regs.LR = 0x821EF92C; return 0x821781C8;
		/* 821EF928h case    4:*/		return 0x821EF92C;
		  /* 821EF92Ch */ case    5:  		/* stw R3, <#[R31 + 44]> */
		/* 821EF92Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF92Ch case    5:*/		return 0x821EF930;
		  /* 821EF930h */ case    6:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EF930h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EF930h case    6:*/		return 0x821EF934;
		  /* 821EF934h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EF934h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EF934h case    7:*/		return 0x821EF938;
		  /* 821EF938h */ case    8:  		/* mr R4, R29 */
		/* 821EF938h case    8:*/		regs.R4 = regs.R29;
		/* 821EF938h case    8:*/		return 0x821EF93C;
		  /* 821EF93Ch */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821EF93Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821EF950;  }
		/* 821EF93Ch case    9:*/		return 0x821EF940;
		  /* 821EF940h */ case   10:  		/* mr R3, R30 */
		/* 821EF940h case   10:*/		regs.R3 = regs.R30;
		/* 821EF940h case   10:*/		return 0x821EF944;
		  /* 821EF944h */ case   11:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EF944h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EF944h case   11:*/		return 0x821EF948;
		  /* 821EF948h */ case   12:  		/* bl -518232 */
		/* 821EF948h case   12:*/		regs.LR = 0x821EF94C; return 0x821710F0;
		/* 821EF948h case   12:*/		return 0x821EF94C;
		  /* 821EF94Ch */ case   13:  		/* mr R4, R3 */
		/* 821EF94Ch case   13:*/		regs.R4 = regs.R3;
		/* 821EF94Ch case   13:*/		return 0x821EF950;
	}
	return 0x821EF950;
} // Block from 821EF918h-821EF950h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EF950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF950);
		  /* 821EF950h */ case    0:  		/* mr R3, R31 */
		/* 821EF950h case    0:*/		regs.R3 = regs.R31;
		/* 821EF950h case    0:*/		return 0x821EF954;
		  /* 821EF954h */ case    1:  		/* bl -489356 */
		/* 821EF954h case    1:*/		regs.LR = 0x821EF958; return 0x821781C8;
		/* 821EF954h case    1:*/		return 0x821EF958;
		  /* 821EF958h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EF958h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EF958h case    2:*/		return 0x821EF95C;
		  /* 821EF95Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EF95Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EF95Ch case    3:*/		return 0x821EF960;
		  /* 821EF960h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EF960h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EF960h case    4:*/		return 0x821EF964;
		  /* 821EF964h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EF964h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EF964h case    5:*/		return 0x821EF968;
		  /* 821EF968h */ case    6:  		/* mr R3, R31 */
		/* 821EF968h case    6:*/		regs.R3 = regs.R31;
		/* 821EF968h case    6:*/		return 0x821EF96C;
		  /* 821EF96Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821EF96Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EF96Ch case    7:*/		return 0x821EF970;
		  /* 821EF970h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EF970h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF970h case    8:*/		return 0x821EF974;
		  /* 821EF974h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EF974h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EF974h case    9:*/		return 0x821EF978;
		  /* 821EF978h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EF978h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EF978h case   10:*/		return 0x821EF97C;
		  /* 821EF97Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EF97Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EF97Ch case   11:*/		return 0x821EF980;
		  /* 821EF980h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EF980h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EF980h case   12:*/		return 0x821EF984;
		  /* 821EF984h */ case   13:  		/* addi R9, R11, 4 */
		/* 821EF984h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EF984h case   13:*/		return 0x821EF988;
		  /* 821EF988h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EF988h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EF988h case   14:*/		return 0x821EF98C;
		  /* 821EF98Ch */ case   15:  		/* addi R10, R10, 24 */
		/* 821EF98Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EF98Ch case   15:*/		return 0x821EF990;
		  /* 821EF990h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EF990h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF990h case   16:*/		return 0x821EF994;
		  /* 821EF994h */ case   17:  		/* addi R6, R10, -36 */
		/* 821EF994h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EF994h case   17:*/		return 0x821EF998;
		  /* 821EF998h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EF998h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EF998h case   18:*/		return 0x821EF99C;
		  /* 821EF99Ch */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EF99Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF99Ch case   19:*/		return 0x821EF9A0;
		  /* 821EF9A0h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EF9A0h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EF9A0h case   20:*/		return 0x821EF9A4;
		  /* 821EF9A4h */ case   21:  		/* ori R6, R6, 1 */
		/* 821EF9A4h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EF9A4h case   21:*/		return 0x821EF9A8;
		  /* 821EF9A8h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EF9A8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EF9A8h case   22:*/		return 0x821EF9AC;
		  /* 821EF9ACh */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EF9ACh case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EF9ACh case   23:*/		return 0x821EF9B0;
		  /* 821EF9B0h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EF9B0h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EF9B0h case   24:*/		return 0x821EF9B4;
		  /* 821EF9B4h */ case   25:  		/* addi R1, R1, 128 */
		/* 821EF9B4h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EF9B4h case   25:*/		return 0x821EF9B8;
		  /* 821EF9B8h */ case   26:  		/* b -1435408 */
		/* 821EF9B8h case   26:*/		return 0x820912A8;
		/* 821EF9B8h case   26:*/		return 0x821EF9BC;
		  /* 821EF9BCh */ case   27:  		/* nop */
		/* 821EF9BCh case   27:*/		cpu::op::nop();
		/* 821EF9BCh case   27:*/		return 0x821EF9C0;
	}
	return 0x821EF9C0;
} // Block from 821EF950h-821EF9C0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EF9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EF9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EF9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EF9C0);
		  /* 821EF9C0h */ case    0:  		/* mfspr R12, LR */
		/* 821EF9C0h case    0:*/		regs.R12 = regs.LR;
		/* 821EF9C0h case    0:*/		return 0x821EF9C4;
		  /* 821EF9C4h */ case    1:  		/* bl -1435500 */
		/* 821EF9C4h case    1:*/		regs.LR = 0x821EF9C8; return 0x82091258;
		/* 821EF9C4h case    1:*/		return 0x821EF9C8;
		  /* 821EF9C8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EF9C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EF9C8h case    2:*/		return 0x821EF9CC;
		  /* 821EF9CCh */ case    3:  		/* mr R29, R5 */
		/* 821EF9CCh case    3:*/		regs.R29 = regs.R5;
		/* 821EF9CCh case    3:*/		return 0x821EF9D0;
		  /* 821EF9D0h */ case    4:  		/* li R8, 4 */
		/* 821EF9D0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EF9D0h case    4:*/		return 0x821EF9D4;
		  /* 821EF9D4h */ case    5:  		/* li R7, 2 */
		/* 821EF9D4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EF9D4h case    5:*/		return 0x821EF9D8;
		  /* 821EF9D8h */ case    6:  		/* li R6, 4 */
		/* 821EF9D8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 821EF9D8h case    6:*/		return 0x821EF9DC;
		  /* 821EF9DCh */ case    7:  		/* li R5, 0 */
		/* 821EF9DCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EF9DCh case    7:*/		return 0x821EF9E0;
		  /* 821EF9E0h */ case    8:  		/* mr R28, R4 */
		/* 821EF9E0h case    8:*/		regs.R28 = regs.R4;
		/* 821EF9E0h case    8:*/		return 0x821EF9E4;
		  /* 821EF9E4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EF9E4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EF9E4h case    9:*/		return 0x821EF9E8;
		  /* 821EF9E8h */ case   10:  		/* mr R30, R3 */
		/* 821EF9E8h case   10:*/		regs.R30 = regs.R3;
		/* 821EF9E8h case   10:*/		return 0x821EF9EC;
		  /* 821EF9ECh */ case   11:  		/* bl 217004 */
		/* 821EF9ECh case   11:*/		regs.LR = 0x821EF9F0; return 0x82224998;
		/* 821EF9ECh case   11:*/		return 0x821EF9F0;
		  /* 821EF9F0h */ case   12:  		/* mr R31, R3 */
		/* 821EF9F0h case   12:*/		regs.R31 = regs.R3;
		/* 821EF9F0h case   12:*/		return 0x821EF9F4;
		  /* 821EF9F4h */ case   13:  		/* mr R4, R28 */
		/* 821EF9F4h case   13:*/		regs.R4 = regs.R28;
		/* 821EF9F4h case   13:*/		return 0x821EF9F8;
		  /* 821EF9F8h */ case   14:  		/* mr R3, R30 */
		/* 821EF9F8h case   14:*/		regs.R3 = regs.R30;
		/* 821EF9F8h case   14:*/		return 0x821EF9FC;
		  /* 821EF9FCh */ case   15:  		/* bl -489980 */
		/* 821EF9FCh case   15:*/		regs.LR = 0x821EFA00; return 0x82178000;
		/* 821EF9FCh case   15:*/		return 0x821EFA00;
		  /* 821EFA00h */ case   16:  		/* mr R4, R3 */
		/* 821EFA00h case   16:*/		regs.R4 = regs.R3;
		/* 821EFA00h case   16:*/		return 0x821EFA04;
		  /* 821EFA04h */ case   17:  		/* mr R3, R31 */
		/* 821EFA04h case   17:*/		regs.R3 = regs.R31;
		/* 821EFA04h case   17:*/		return 0x821EFA08;
	}
	return 0x821EFA08;
} // Block from 821EF9C0h-821EFA08h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821EFA08h
// Function '?MakeInstr_V_DST@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFA08);
		  /* 821EFA08h */ case    0:  		/* bl -489536 */
		/* 821EFA08h case    0:*/		regs.LR = 0x821EFA0C; return 0x821781C8;
		/* 821EFA08h case    0:*/		return 0x821EFA0C;
		  /* 821EFA0Ch */ case    1:  		/* stw R3, <#[R31 + 44]> */
		/* 821EFA0Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EFA0Ch case    1:*/		return 0x821EFA10;
		  /* 821EFA10h */ case    2:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EFA10h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EFA10h case    2:*/		return 0x821EFA14;
		  /* 821EFA14h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821EFA14h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EFA14h case    3:*/		return 0x821EFA18;
		  /* 821EFA18h */ case    4:  		/* mr R4, R29 */
		/* 821EFA18h case    4:*/		regs.R4 = regs.R29;
		/* 821EFA18h case    4:*/		return 0x821EFA1C;
		  /* 821EFA1Ch */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 821EFA1Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821EFA30;  }
		/* 821EFA1Ch case    5:*/		return 0x821EFA20;
		  /* 821EFA20h */ case    6:  		/* mr R3, R30 */
		/* 821EFA20h case    6:*/		regs.R3 = regs.R30;
		/* 821EFA20h case    6:*/		return 0x821EFA24;
		  /* 821EFA24h */ case    7:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EFA24h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EFA24h case    7:*/		return 0x821EFA28;
		  /* 821EFA28h */ case    8:  		/* bl -518456 */
		/* 821EFA28h case    8:*/		regs.LR = 0x821EFA2C; return 0x821710F0;
		/* 821EFA28h case    8:*/		return 0x821EFA2C;
		  /* 821EFA2Ch */ case    9:  		/* mr R4, R3 */
		/* 821EFA2Ch case    9:*/		regs.R4 = regs.R3;
		/* 821EFA2Ch case    9:*/		return 0x821EFA30;
	}
	return 0x821EFA30;
} // Block from 821EFA08h-821EFA30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821EFA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFA30);
		  /* 821EFA30h */ case    0:  		/* mr R3, R31 */
		/* 821EFA30h case    0:*/		regs.R3 = regs.R31;
		/* 821EFA30h case    0:*/		return 0x821EFA34;
		  /* 821EFA34h */ case    1:  		/* bl -489580 */
		/* 821EFA34h case    1:*/		regs.LR = 0x821EFA38; return 0x821781C8;
		/* 821EFA34h case    1:*/		return 0x821EFA38;
		  /* 821EFA38h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EFA38h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EFA38h case    2:*/		return 0x821EFA3C;
		  /* 821EFA3Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EFA3Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EFA3Ch case    3:*/		return 0x821EFA40;
		  /* 821EFA40h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EFA40h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EFA40h case    4:*/		return 0x821EFA44;
		  /* 821EFA44h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EFA44h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EFA44h case    5:*/		return 0x821EFA48;
		  /* 821EFA48h */ case    6:  		/* mr R3, R31 */
		/* 821EFA48h case    6:*/		regs.R3 = regs.R31;
		/* 821EFA48h case    6:*/		return 0x821EFA4C;
		  /* 821EFA4Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821EFA4Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EFA4Ch case    7:*/		return 0x821EFA50;
		  /* 821EFA50h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EFA50h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFA50h case    8:*/		return 0x821EFA54;
		  /* 821EFA54h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EFA54h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EFA54h case    9:*/		return 0x821EFA58;
		  /* 821EFA58h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EFA58h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EFA58h case   10:*/		return 0x821EFA5C;
		  /* 821EFA5Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EFA5Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFA5Ch case   11:*/		return 0x821EFA60;
		  /* 821EFA60h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EFA60h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EFA60h case   12:*/		return 0x821EFA64;
		  /* 821EFA64h */ case   13:  		/* addi R9, R11, 4 */
		/* 821EFA64h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EFA64h case   13:*/		return 0x821EFA68;
		  /* 821EFA68h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EFA68h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EFA68h case   14:*/		return 0x821EFA6C;
		  /* 821EFA6Ch */ case   15:  		/* addi R10, R10, 24 */
		/* 821EFA6Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EFA6Ch case   15:*/		return 0x821EFA70;
		  /* 821EFA70h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EFA70h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFA70h case   16:*/		return 0x821EFA74;
		  /* 821EFA74h */ case   17:  		/* addi R6, R10, -36 */
		/* 821EFA74h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFA74h case   17:*/		return 0x821EFA78;
		  /* 821EFA78h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EFA78h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFA78h case   18:*/		return 0x821EFA7C;
		  /* 821EFA7Ch */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EFA7Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFA7Ch case   19:*/		return 0x821EFA80;
		  /* 821EFA80h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EFA80h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EFA80h case   20:*/		return 0x821EFA84;
		  /* 821EFA84h */ case   21:  		/* ori R6, R6, 1 */
		/* 821EFA84h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EFA84h case   21:*/		return 0x821EFA88;
		  /* 821EFA88h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EFA88h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFA88h case   22:*/		return 0x821EFA8C;
		  /* 821EFA8Ch */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EFA8Ch case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EFA8Ch case   23:*/		return 0x821EFA90;
		  /* 821EFA90h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EFA90h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFA90h case   24:*/		return 0x821EFA94;
		  /* 821EFA94h */ case   25:  		/* addi R1, R1, 128 */
		/* 821EFA94h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EFA94h case   25:*/		return 0x821EFA98;
		  /* 821EFA98h */ case   26:  		/* b -1435632 */
		/* 821EFA98h case   26:*/		return 0x820912A8;
		/* 821EFA98h case   26:*/		return 0x821EFA9C;
		  /* 821EFA9Ch */ case   27:  		/* nop */
		/* 821EFA9Ch case   27:*/		cpu::op::nop();
		/* 821EFA9Ch case   27:*/		return 0x821EFAA0;
	}
	return 0x821EFAA0;
} // Block from 821EFA30h-821EFAA0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EFAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFAA0);
		  /* 821EFAA0h */ case    0:  		/* mfspr R12, LR */
		/* 821EFAA0h case    0:*/		regs.R12 = regs.LR;
		/* 821EFAA0h case    0:*/		return 0x821EFAA4;
		  /* 821EFAA4h */ case    1:  		/* bl -1435724 */
		/* 821EFAA4h case    1:*/		regs.LR = 0x821EFAA8; return 0x82091258;
		/* 821EFAA4h case    1:*/		return 0x821EFAA8;
		  /* 821EFAA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EFAA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EFAA8h case    2:*/		return 0x821EFAAC;
		  /* 821EFAACh */ case    3:  		/* mr R29, R5 */
		/* 821EFAACh case    3:*/		regs.R29 = regs.R5;
		/* 821EFAACh case    3:*/		return 0x821EFAB0;
		  /* 821EFAB0h */ case    4:  		/* li R8, 4 */
		/* 821EFAB0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EFAB0h case    4:*/		return 0x821EFAB4;
		  /* 821EFAB4h */ case    5:  		/* li R7, 2 */
		/* 821EFAB4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EFAB4h case    5:*/		return 0x821EFAB8;
		  /* 821EFAB8h */ case    6:  		/* li R6, 5 */
		/* 821EFAB8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 821EFAB8h case    6:*/		return 0x821EFABC;
		  /* 821EFABCh */ case    7:  		/* li R5, 0 */
		/* 821EFABCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFABCh case    7:*/		return 0x821EFAC0;
		  /* 821EFAC0h */ case    8:  		/* mr R28, R4 */
		/* 821EFAC0h case    8:*/		regs.R28 = regs.R4;
		/* 821EFAC0h case    8:*/		return 0x821EFAC4;
		  /* 821EFAC4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFAC4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFAC4h case    9:*/		return 0x821EFAC8;
		  /* 821EFAC8h */ case   10:  		/* mr R30, R3 */
		/* 821EFAC8h case   10:*/		regs.R30 = regs.R3;
		/* 821EFAC8h case   10:*/		return 0x821EFACC;
		  /* 821EFACCh */ case   11:  		/* bl 216780 */
		/* 821EFACCh case   11:*/		regs.LR = 0x821EFAD0; return 0x82224998;
		/* 821EFACCh case   11:*/		return 0x821EFAD0;
		  /* 821EFAD0h */ case   12:  		/* mr R31, R3 */
		/* 821EFAD0h case   12:*/		regs.R31 = regs.R3;
		/* 821EFAD0h case   12:*/		return 0x821EFAD4;
		  /* 821EFAD4h */ case   13:  		/* mr R4, R28 */
		/* 821EFAD4h case   13:*/		regs.R4 = regs.R28;
		/* 821EFAD4h case   13:*/		return 0x821EFAD8;
		  /* 821EFAD8h */ case   14:  		/* mr R3, R30 */
		/* 821EFAD8h case   14:*/		regs.R3 = regs.R30;
		/* 821EFAD8h case   14:*/		return 0x821EFADC;
		  /* 821EFADCh */ case   15:  		/* bl -490204 */
		/* 821EFADCh case   15:*/		regs.LR = 0x821EFAE0; return 0x82178000;
		/* 821EFADCh case   15:*/		return 0x821EFAE0;
	}
	return 0x821EFAE0;
} // Block from 821EFAA0h-821EFAE0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EFAE0h
// Function '?MakeInstr_V_MAXA@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFAE0);
		  /* 821EFAE0h */ case    0:  		/* mr R4, R3 */
		/* 821EFAE0h case    0:*/		regs.R4 = regs.R3;
		/* 821EFAE0h case    0:*/		return 0x821EFAE4;
		  /* 821EFAE4h */ case    1:  		/* mr R3, R31 */
		/* 821EFAE4h case    1:*/		regs.R3 = regs.R31;
		/* 821EFAE4h case    1:*/		return 0x821EFAE8;
		  /* 821EFAE8h */ case    2:  		/* bl -489760 */
		/* 821EFAE8h case    2:*/		regs.LR = 0x821EFAEC; return 0x821781C8;
		/* 821EFAE8h case    2:*/		return 0x821EFAEC;
		  /* 821EFAECh */ case    3:  		/* stw R3, <#[R31 + 44]> */
		/* 821EFAECh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EFAECh case    3:*/		return 0x821EFAF0;
		  /* 821EFAF0h */ case    4:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EFAF0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EFAF0h case    4:*/		return 0x821EFAF4;
		  /* 821EFAF4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821EFAF4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EFAF4h case    5:*/		return 0x821EFAF8;
		  /* 821EFAF8h */ case    6:  		/* mr R4, R29 */
		/* 821EFAF8h case    6:*/		regs.R4 = regs.R29;
		/* 821EFAF8h case    6:*/		return 0x821EFAFC;
		  /* 821EFAFCh */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821EFAFCh case    7:*/		if ( regs.CR[6].eq ) { return 0x821EFB10;  }
		/* 821EFAFCh case    7:*/		return 0x821EFB00;
		  /* 821EFB00h */ case    8:  		/* mr R3, R30 */
		/* 821EFB00h case    8:*/		regs.R3 = regs.R30;
		/* 821EFB00h case    8:*/		return 0x821EFB04;
		  /* 821EFB04h */ case    9:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EFB04h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EFB04h case    9:*/		return 0x821EFB08;
		  /* 821EFB08h */ case   10:  		/* bl -518680 */
		/* 821EFB08h case   10:*/		regs.LR = 0x821EFB0C; return 0x821710F0;
		/* 821EFB08h case   10:*/		return 0x821EFB0C;
		  /* 821EFB0Ch */ case   11:  		/* mr R4, R3 */
		/* 821EFB0Ch case   11:*/		regs.R4 = regs.R3;
		/* 821EFB0Ch case   11:*/		return 0x821EFB10;
	}
	return 0x821EFB10;
} // Block from 821EFAE0h-821EFB10h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EFB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFB10);
		  /* 821EFB10h */ case    0:  		/* mr R3, R31 */
		/* 821EFB10h case    0:*/		regs.R3 = regs.R31;
		/* 821EFB10h case    0:*/		return 0x821EFB14;
		  /* 821EFB14h */ case    1:  		/* bl -489804 */
		/* 821EFB14h case    1:*/		regs.LR = 0x821EFB18; return 0x821781C8;
		/* 821EFB14h case    1:*/		return 0x821EFB18;
		  /* 821EFB18h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EFB18h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EFB18h case    2:*/		return 0x821EFB1C;
		  /* 821EFB1Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EFB1Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EFB1Ch case    3:*/		return 0x821EFB20;
		  /* 821EFB20h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EFB20h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EFB20h case    4:*/		return 0x821EFB24;
		  /* 821EFB24h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EFB24h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EFB24h case    5:*/		return 0x821EFB28;
		  /* 821EFB28h */ case    6:  		/* mr R3, R31 */
		/* 821EFB28h case    6:*/		regs.R3 = regs.R31;
		/* 821EFB28h case    6:*/		return 0x821EFB2C;
		  /* 821EFB2Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821EFB2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EFB2Ch case    7:*/		return 0x821EFB30;
		  /* 821EFB30h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EFB30h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFB30h case    8:*/		return 0x821EFB34;
		  /* 821EFB34h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EFB34h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EFB34h case    9:*/		return 0x821EFB38;
		  /* 821EFB38h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EFB38h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EFB38h case   10:*/		return 0x821EFB3C;
		  /* 821EFB3Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EFB3Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFB3Ch case   11:*/		return 0x821EFB40;
		  /* 821EFB40h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EFB40h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EFB40h case   12:*/		return 0x821EFB44;
		  /* 821EFB44h */ case   13:  		/* addi R9, R11, 4 */
		/* 821EFB44h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EFB44h case   13:*/		return 0x821EFB48;
		  /* 821EFB48h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EFB48h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EFB48h case   14:*/		return 0x821EFB4C;
		  /* 821EFB4Ch */ case   15:  		/* addi R10, R10, 24 */
		/* 821EFB4Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EFB4Ch case   15:*/		return 0x821EFB50;
		  /* 821EFB50h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EFB50h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFB50h case   16:*/		return 0x821EFB54;
		  /* 821EFB54h */ case   17:  		/* addi R6, R10, -36 */
		/* 821EFB54h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFB54h case   17:*/		return 0x821EFB58;
		  /* 821EFB58h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EFB58h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFB58h case   18:*/		return 0x821EFB5C;
		  /* 821EFB5Ch */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EFB5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFB5Ch case   19:*/		return 0x821EFB60;
		  /* 821EFB60h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EFB60h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EFB60h case   20:*/		return 0x821EFB64;
		  /* 821EFB64h */ case   21:  		/* ori R6, R6, 1 */
		/* 821EFB64h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EFB64h case   21:*/		return 0x821EFB68;
		  /* 821EFB68h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EFB68h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFB68h case   22:*/		return 0x821EFB6C;
		  /* 821EFB6Ch */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EFB6Ch case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EFB6Ch case   23:*/		return 0x821EFB70;
		  /* 821EFB70h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EFB70h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFB70h case   24:*/		return 0x821EFB74;
		  /* 821EFB74h */ case   25:  		/* addi R1, R1, 128 */
		/* 821EFB74h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EFB74h case   25:*/		return 0x821EFB78;
		  /* 821EFB78h */ case   26:  		/* b -1435856 */
		/* 821EFB78h case   26:*/		return 0x820912A8;
		/* 821EFB78h case   26:*/		return 0x821EFB7C;
		  /* 821EFB7Ch */ case   27:  		/* nop */
		/* 821EFB7Ch case   27:*/		cpu::op::nop();
		/* 821EFB7Ch case   27:*/		return 0x821EFB80;
	}
	return 0x821EFB80;
} // Block from 821EFB10h-821EFB80h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EFB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFB80);
		  /* 821EFB80h */ case    0:  		/* mfspr R12, LR */
		/* 821EFB80h case    0:*/		regs.R12 = regs.LR;
		/* 821EFB80h case    0:*/		return 0x821EFB84;
		  /* 821EFB84h */ case    1:  		/* bl -1435948 */
		/* 821EFB84h case    1:*/		regs.LR = 0x821EFB88; return 0x82091258;
		/* 821EFB84h case    1:*/		return 0x821EFB88;
		  /* 821EFB88h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821EFB88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821EFB88h case    2:*/		return 0x821EFB8C;
		  /* 821EFB8Ch */ case    3:  		/* mr R29, R5 */
		/* 821EFB8Ch case    3:*/		regs.R29 = regs.R5;
		/* 821EFB8Ch case    3:*/		return 0x821EFB90;
		  /* 821EFB90h */ case    4:  		/* li R8, 4 */
		/* 821EFB90h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EFB90h case    4:*/		return 0x821EFB94;
		  /* 821EFB94h */ case    5:  		/* li R7, 2 */
		/* 821EFB94h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821EFB94h case    5:*/		return 0x821EFB98;
		  /* 821EFB98h */ case    6:  		/* li R6, 7 */
		/* 821EFB98h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 821EFB98h case    6:*/		return 0x821EFB9C;
		  /* 821EFB9Ch */ case    7:  		/* li R5, 0 */
		/* 821EFB9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFB9Ch case    7:*/		return 0x821EFBA0;
		  /* 821EFBA0h */ case    8:  		/* mr R28, R4 */
		/* 821EFBA0h case    8:*/		regs.R28 = regs.R4;
		/* 821EFBA0h case    8:*/		return 0x821EFBA4;
		  /* 821EFBA4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFBA4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFBA4h case    9:*/		return 0x821EFBA8;
		  /* 821EFBA8h */ case   10:  		/* mr R30, R3 */
		/* 821EFBA8h case   10:*/		regs.R30 = regs.R3;
		/* 821EFBA8h case   10:*/		return 0x821EFBAC;
		  /* 821EFBACh */ case   11:  		/* bl 216556 */
		/* 821EFBACh case   11:*/		regs.LR = 0x821EFBB0; return 0x82224998;
		/* 821EFBACh case   11:*/		return 0x821EFBB0;
		  /* 821EFBB0h */ case   12:  		/* mr R31, R3 */
		/* 821EFBB0h case   12:*/		regs.R31 = regs.R3;
		/* 821EFBB0h case   12:*/		return 0x821EFBB4;
		  /* 821EFBB4h */ case   13:  		/* mr R4, R28 */
		/* 821EFBB4h case   13:*/		regs.R4 = regs.R28;
		/* 821EFBB4h case   13:*/		return 0x821EFBB8;
	}
	return 0x821EFBB8;
} // Block from 821EFB80h-821EFBB8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EFBB8h
// Function '?MakeInstr_S_EXP_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFBB8);
		  /* 821EFBB8h */ case    0:  		/* mr R3, R30 */
		/* 821EFBB8h case    0:*/		regs.R3 = regs.R30;
		/* 821EFBB8h case    0:*/		return 0x821EFBBC;
		  /* 821EFBBCh */ case    1:  		/* bl -490428 */
		/* 821EFBBCh case    1:*/		regs.LR = 0x821EFBC0; return 0x82178000;
		/* 821EFBBCh case    1:*/		return 0x821EFBC0;
		  /* 821EFBC0h */ case    2:  		/* mr R4, R3 */
		/* 821EFBC0h case    2:*/		regs.R4 = regs.R3;
		/* 821EFBC0h case    2:*/		return 0x821EFBC4;
		  /* 821EFBC4h */ case    3:  		/* mr R3, R31 */
		/* 821EFBC4h case    3:*/		regs.R3 = regs.R31;
		/* 821EFBC4h case    3:*/		return 0x821EFBC8;
		  /* 821EFBC8h */ case    4:  		/* bl -489984 */
		/* 821EFBC8h case    4:*/		regs.LR = 0x821EFBCC; return 0x821781C8;
		/* 821EFBC8h case    4:*/		return 0x821EFBCC;
		  /* 821EFBCCh */ case    5:  		/* stw R3, <#[R31 + 44]> */
		/* 821EFBCCh case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EFBCCh case    5:*/		return 0x821EFBD0;
		  /* 821EFBD0h */ case    6:  		/* lwz R11, <#[R29 + 16]> */
		/* 821EFBD0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821EFBD0h case    6:*/		return 0x821EFBD4;
		  /* 821EFBD4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821EFBD4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821EFBD4h case    7:*/		return 0x821EFBD8;
		  /* 821EFBD8h */ case    8:  		/* mr R4, R29 */
		/* 821EFBD8h case    8:*/		regs.R4 = regs.R29;
		/* 821EFBD8h case    8:*/		return 0x821EFBDC;
		  /* 821EFBDCh */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821EFBDCh case    9:*/		if ( regs.CR[6].eq ) { return 0x821EFBF0;  }
		/* 821EFBDCh case    9:*/		return 0x821EFBE0;
		  /* 821EFBE0h */ case   10:  		/* mr R3, R30 */
		/* 821EFBE0h case   10:*/		regs.R3 = regs.R30;
		/* 821EFBE0h case   10:*/		return 0x821EFBE4;
		  /* 821EFBE4h */ case   11:  		/* lwz R5, <#[R29 + 12]> */
		/* 821EFBE4h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821EFBE4h case   11:*/		return 0x821EFBE8;
		  /* 821EFBE8h */ case   12:  		/* bl -518904 */
		/* 821EFBE8h case   12:*/		regs.LR = 0x821EFBEC; return 0x821710F0;
		/* 821EFBE8h case   12:*/		return 0x821EFBEC;
		  /* 821EFBECh */ case   13:  		/* mr R4, R3 */
		/* 821EFBECh case   13:*/		regs.R4 = regs.R3;
		/* 821EFBECh case   13:*/		return 0x821EFBF0;
	}
	return 0x821EFBF0;
} // Block from 821EFBB8h-821EFBF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821EFBF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFBF0);
		  /* 821EFBF0h */ case    0:  		/* mr R3, R31 */
		/* 821EFBF0h case    0:*/		regs.R3 = regs.R31;
		/* 821EFBF0h case    0:*/		return 0x821EFBF4;
		  /* 821EFBF4h */ case    1:  		/* bl -490028 */
		/* 821EFBF4h case    1:*/		regs.LR = 0x821EFBF8; return 0x821781C8;
		/* 821EFBF4h case    1:*/		return 0x821EFBF8;
		  /* 821EFBF8h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821EFBF8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821EFBF8h case    2:*/		return 0x821EFBFC;
		  /* 821EFBFCh */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821EFBFCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821EFBFCh case    3:*/		return 0x821EFC00;
		  /* 821EFC00h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821EFC00h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821EFC00h case    4:*/		return 0x821EFC04;
		  /* 821EFC04h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821EFC04h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EFC04h case    5:*/		return 0x821EFC08;
		  /* 821EFC08h */ case    6:  		/* mr R3, R31 */
		/* 821EFC08h case    6:*/		regs.R3 = regs.R31;
		/* 821EFC08h case    6:*/		return 0x821EFC0C;
		  /* 821EFC0Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821EFC0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EFC0Ch case    7:*/		return 0x821EFC10;
		  /* 821EFC10h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821EFC10h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFC10h case    8:*/		return 0x821EFC14;
		  /* 821EFC14h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821EFC14h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821EFC14h case    9:*/		return 0x821EFC18;
		  /* 821EFC18h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821EFC18h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821EFC18h case   10:*/		return 0x821EFC1C;
		  /* 821EFC1Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EFC1Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFC1Ch case   11:*/		return 0x821EFC20;
		  /* 821EFC20h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821EFC20h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821EFC20h case   12:*/		return 0x821EFC24;
		  /* 821EFC24h */ case   13:  		/* addi R9, R11, 4 */
		/* 821EFC24h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EFC24h case   13:*/		return 0x821EFC28;
		  /* 821EFC28h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821EFC28h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821EFC28h case   14:*/		return 0x821EFC2C;
		  /* 821EFC2Ch */ case   15:  		/* addi R10, R10, 24 */
		/* 821EFC2Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EFC2Ch case   15:*/		return 0x821EFC30;
		  /* 821EFC30h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821EFC30h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFC30h case   16:*/		return 0x821EFC34;
		  /* 821EFC34h */ case   17:  		/* addi R6, R10, -36 */
		/* 821EFC34h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFC34h case   17:*/		return 0x821EFC38;
		  /* 821EFC38h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821EFC38h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFC38h case   18:*/		return 0x821EFC3C;
		  /* 821EFC3Ch */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821EFC3Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFC3Ch case   19:*/		return 0x821EFC40;
		  /* 821EFC40h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EFC40h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EFC40h case   20:*/		return 0x821EFC44;
		  /* 821EFC44h */ case   21:  		/* ori R6, R6, 1 */
		/* 821EFC44h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EFC44h case   21:*/		return 0x821EFC48;
		  /* 821EFC48h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821EFC48h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFC48h case   22:*/		return 0x821EFC4C;
		  /* 821EFC4Ch */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821EFC4Ch case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EFC4Ch case   23:*/		return 0x821EFC50;
		  /* 821EFC50h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821EFC50h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFC50h case   24:*/		return 0x821EFC54;
		  /* 821EFC54h */ case   25:  		/* addi R1, R1, 128 */
		/* 821EFC54h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821EFC54h case   25:*/		return 0x821EFC58;
		  /* 821EFC58h */ case   26:  		/* b -1436080 */
		/* 821EFC58h case   26:*/		return 0x820912A8;
		/* 821EFC58h case   26:*/		return 0x821EFC5C;
		  /* 821EFC5Ch */ case   27:  		/* nop */
		/* 821EFC5Ch case   27:*/		cpu::op::nop();
		/* 821EFC5Ch case   27:*/		return 0x821EFC60;
	}
	return 0x821EFC60;
} // Block from 821EFBF0h-821EFC60h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821EFC60h
// Function '?MakeInstr_S_RECIP_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFC60);
		  /* 821EFC60h */ case    0:  		/* mfspr R12, LR */
		/* 821EFC60h case    0:*/		regs.R12 = regs.LR;
		/* 821EFC60h case    0:*/		return 0x821EFC64;
		  /* 821EFC64h */ case    1:  		/* bl -1436168 */
		/* 821EFC64h case    1:*/		regs.LR = 0x821EFC68; return 0x8209125C;
		/* 821EFC64h case    1:*/		return 0x821EFC68;
		  /* 821EFC68h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EFC68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EFC68h case    2:*/		return 0x821EFC6C;
		  /* 821EFC6Ch */ case    3:  		/* li R8, 4 */
		/* 821EFC6Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821EFC6Ch case    3:*/		return 0x821EFC70;
		  /* 821EFC70h */ case    4:  		/* li R7, 1 */
		/* 821EFC70h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EFC70h case    4:*/		return 0x821EFC74;
		  /* 821EFC74h */ case    5:  		/* li R6, 9 */
		/* 821EFC74h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x9);
		/* 821EFC74h case    5:*/		return 0x821EFC78;
		  /* 821EFC78h */ case    6:  		/* li R5, 0 */
		/* 821EFC78h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFC78h case    6:*/		return 0x821EFC7C;
		  /* 821EFC7Ch */ case    7:  		/* mr R30, R4 */
		/* 821EFC7Ch case    7:*/		regs.R30 = regs.R4;
		/* 821EFC7Ch case    7:*/		return 0x821EFC80;
		  /* 821EFC80h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFC80h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFC80h case    8:*/		return 0x821EFC84;
		  /* 821EFC84h */ case    9:  		/* mr R31, R3 */
		/* 821EFC84h case    9:*/		regs.R31 = regs.R3;
		/* 821EFC84h case    9:*/		return 0x821EFC88;
		  /* 821EFC88h */ case   10:  		/* bl 216336 */
		/* 821EFC88h case   10:*/		regs.LR = 0x821EFC8C; return 0x82224998;
		/* 821EFC88h case   10:*/		return 0x821EFC8C;
		  /* 821EFC8Ch */ case   11:  		/* mr R29, R3 */
		/* 821EFC8Ch case   11:*/		regs.R29 = regs.R3;
		/* 821EFC8Ch case   11:*/		return 0x821EFC90;
		  /* 821EFC90h */ case   12:  		/* mr R4, R30 */
		/* 821EFC90h case   12:*/		regs.R4 = regs.R30;
		/* 821EFC90h case   12:*/		return 0x821EFC94;
		  /* 821EFC94h */ case   13:  		/* mr R3, R31 */
		/* 821EFC94h case   13:*/		regs.R3 = regs.R31;
		/* 821EFC94h case   13:*/		return 0x821EFC98;
		  /* 821EFC98h */ case   14:  		/* bl -490648 */
		/* 821EFC98h case   14:*/		regs.LR = 0x821EFC9C; return 0x82178000;
		/* 821EFC98h case   14:*/		return 0x821EFC9C;
		  /* 821EFC9Ch */ case   15:  		/* mr R4, R3 */
		/* 821EFC9Ch case   15:*/		regs.R4 = regs.R3;
		/* 821EFC9Ch case   15:*/		return 0x821EFCA0;
		  /* 821EFCA0h */ case   16:  		/* mr R3, R29 */
		/* 821EFCA0h case   16:*/		regs.R3 = regs.R29;
		/* 821EFCA0h case   16:*/		return 0x821EFCA4;
		  /* 821EFCA4h */ case   17:  		/* bl -490204 */
		/* 821EFCA4h case   17:*/		regs.LR = 0x821EFCA8; return 0x821781C8;
		/* 821EFCA4h case   17:*/		return 0x821EFCA8;
		  /* 821EFCA8h */ case   18:  		/* stw R3, <#[R29 + 44]> */
		/* 821EFCA8h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821EFCA8h case   18:*/		return 0x821EFCAC;
		  /* 821EFCACh */ case   19:  		/* lwz R9, <#[R3]> */
		/* 821EFCACh case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821EFCACh case   19:*/		return 0x821EFCB0;
		  /* 821EFCB0h */ case   20:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 821EFCB0h case   20:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 821EFCB0h case   20:*/		return 0x821EFCB4;
		  /* 821EFCB4h */ case   21:  		/* lwz R10, <#[R29 + 8]> */
		/* 821EFCB4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821EFCB4h case   21:*/		return 0x821EFCB8;
		  /* 821EFCB8h */ case   22:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821EFCB8h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821EFCB8h case   22:*/		return 0x821EFCBC;
		  /* 821EFCBCh */ case   23:  		/* mr R3, R29 */
		/* 821EFCBCh case   23:*/		regs.R3 = regs.R29;
		/* 821EFCBCh case   23:*/		return 0x821EFCC0;
		  /* 821EFCC0h */ case   24:  		/* rlwimi R10, R9, 14, 15, 17 */
		/* 821EFCC0h case   24:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R9);
		/* 821EFCC0h case   24:*/		return 0x821EFCC4;
		  /* 821EFCC4h */ case   25:  		/* addi R11, R11, 36 */
		/* 821EFCC4h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821EFCC4h case   25:*/		return 0x821EFCC8;
		  /* 821EFCC8h */ case   26:  		/* stw R10, <#[R29 + 8]> */
		/* 821EFCC8h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821EFCC8h case   26:*/		return 0x821EFCCC;
		  /* 821EFCCCh */ case   27:  		/* lwz R10, <#[R31 + 564]> */
		/* 821EFCCCh case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821EFCCCh case   27:*/		return 0x821EFCD0;
		  /* 821EFCD0h */ case   28:  		/* addi R10, R10, 24 */
		/* 821EFCD0h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821EFCD0h case   28:*/		return 0x821EFCD4;
		  /* 821EFCD4h */ case   29:  		/* lwz R7, <#[R10]> */
		/* 821EFCD4h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFCD4h case   29:*/		return 0x821EFCD8;
		  /* 821EFCD8h */ case   30:  		/* addi R6, R10, -36 */
		/* 821EFCD8h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFCD8h case   30:*/		return 0x821EFCDC;
		  /* 821EFCDCh */ case   31:  		/* stw R7, <#[R11]> */
		/* 821EFCDCh case   31:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFCDCh case   31:*/		return 0x821EFCE0;
		  /* 821EFCE0h */ case   32:  		/* addi R8, R11, -36 */
		/* 821EFCE0h case   32:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFCE0h case   32:*/		return 0x821EFCE4;
		  /* 821EFCE4h */ case   33:  		/* lwz R7, <#[R10]> */
		/* 821EFCE4h case   33:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFCE4h case   33:*/		return 0x821EFCE8;
		  /* 821EFCE8h */ case   34:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821EFCE8h case   34:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821EFCE8h case   34:*/		return 0x821EFCEC;
		  /* 821EFCECh */ case   35:  		/* ori R6, R6, 1 */
		/* 821EFCECh case   35:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821EFCECh case   35:*/		return 0x821EFCF0;
		  /* 821EFCF0h */ case   36:  		/* stw R8, <#[R7]> */
		/* 821EFCF0h case   36:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFCF0h case   36:*/		return 0x821EFCF4;
		  /* 821EFCF4h */ case   37:  		/* addi R9, R11, 4 */
		/* 821EFCF4h case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821EFCF4h case   37:*/		return 0x821EFCF8;
		  /* 821EFCF8h */ case   38:  		/* stw R6, <#[R11 + 4]> */
		/* 821EFCF8h case   38:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821EFCF8h case   38:*/		return 0x821EFCFC;
		  /* 821EFCFCh */ case   39:  		/* stw R9, <#[R10]> */
		/* 821EFCFCh case   39:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFCFCh case   39:*/		return 0x821EFD00;
		  /* 821EFD00h */ case   40:  		/* addi R1, R1, 112 */
		/* 821EFD00h case   40:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EFD00h case   40:*/		return 0x821EFD04;
		  /* 821EFD04h */ case   41:  		/* b -1436248 */
		/* 821EFD04h case   41:*/		return 0x820912AC;
		/* 821EFD04h case   41:*/		return 0x821EFD08;
	}
	return 0x821EFD08;
} // Block from 821EFC60h-821EFD08h (42 instructions)

//////////////////////////////////////////////////////
// Block at 821EFD08h
// Function '?MakeInstr_S_MAXA@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFD08);
		  /* 821EFD08h */ case    0:  		/* mfspr R12, LR */
		/* 821EFD08h case    0:*/		regs.R12 = regs.LR;
		/* 821EFD08h case    0:*/		return 0x821EFD0C;
		  /* 821EFD0Ch */ case    1:  		/* bl -1436336 */
		/* 821EFD0Ch case    1:*/		regs.LR = 0x821EFD10; return 0x8209125C;
		/* 821EFD0Ch case    1:*/		return 0x821EFD10;
		  /* 821EFD10h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EFD10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EFD10h case    2:*/		return 0x821EFD14;
		  /* 821EFD14h */ case    3:  		/* li R8, 1 */
		/* 821EFD14h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EFD14h case    3:*/		return 0x821EFD18;
		  /* 821EFD18h */ case    4:  		/* li R7, 1 */
		/* 821EFD18h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EFD18h case    4:*/		return 0x821EFD1C;
		  /* 821EFD1Ch */ case    5:  		/* li R6, 46 */
		/* 821EFD1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x2E);
		/* 821EFD1Ch case    5:*/		return 0x821EFD20;
		  /* 821EFD20h */ case    6:  		/* li R5, 0 */
		/* 821EFD20h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFD20h case    6:*/		return 0x821EFD24;
		  /* 821EFD24h */ case    7:  		/* mr R30, R4 */
		/* 821EFD24h case    7:*/		regs.R30 = regs.R4;
		/* 821EFD24h case    7:*/		return 0x821EFD28;
		  /* 821EFD28h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFD28h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFD28h case    8:*/		return 0x821EFD2C;
		  /* 821EFD2Ch */ case    9:  		/* mr R31, R3 */
		/* 821EFD2Ch case    9:*/		regs.R31 = regs.R3;
		/* 821EFD2Ch case    9:*/		return 0x821EFD30;
		  /* 821EFD30h */ case   10:  		/* bl 216168 */
		/* 821EFD30h case   10:*/		regs.LR = 0x821EFD34; return 0x82224998;
		/* 821EFD30h case   10:*/		return 0x821EFD34;
		  /* 821EFD34h */ case   11:  		/* mr R29, R3 */
		/* 821EFD34h case   11:*/		regs.R29 = regs.R3;
		/* 821EFD34h case   11:*/		return 0x821EFD38;
		  /* 821EFD38h */ case   12:  		/* mr R4, R30 */
		/* 821EFD38h case   12:*/		regs.R4 = regs.R30;
		/* 821EFD38h case   12:*/		return 0x821EFD3C;
		  /* 821EFD3Ch */ case   13:  		/* mr R3, R31 */
		/* 821EFD3Ch case   13:*/		regs.R3 = regs.R31;
		/* 821EFD3Ch case   13:*/		return 0x821EFD40;
		  /* 821EFD40h */ case   14:  		/* bl -490816 */
		/* 821EFD40h case   14:*/		regs.LR = 0x821EFD44; return 0x82178000;
		/* 821EFD40h case   14:*/		return 0x821EFD44;
		  /* 821EFD44h */ case   15:  		/* mr R4, R3 */
		/* 821EFD44h case   15:*/		regs.R4 = regs.R3;
		/* 821EFD44h case   15:*/		return 0x821EFD48;
		  /* 821EFD48h */ case   16:  		/* mr R3, R29 */
		/* 821EFD48h case   16:*/		regs.R3 = regs.R29;
		/* 821EFD48h case   16:*/		return 0x821EFD4C;
		  /* 821EFD4Ch */ case   17:  		/* bl -490372 */
		/* 821EFD4Ch case   17:*/		regs.LR = 0x821EFD50; return 0x821781C8;
		/* 821EFD4Ch case   17:*/		return 0x821EFD50;
		  /* 821EFD50h */ case   18:  		/* stw R3, <#[R29 + 44]> */
		/* 821EFD50h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821EFD50h case   18:*/		return 0x821EFD54;
		  /* 821EFD54h */ case   19:  		/* lwz R11, <#[R31 + 564]> */
		/* 821EFD54h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821EFD54h case   19:*/		return 0x821EFD58;
		  /* 821EFD58h */ case   20:  		/* addi R11, R11, 24 */
		/* 821EFD58h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EFD58h case   20:*/		return 0x821EFD5C;
		  /* 821EFD5Ch */ case   21:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821EFD5Ch case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821EFD5Ch case   21:*/		return 0x821EFD60;
		  /* 821EFD60h */ case   22:  		/* lwz R9, <#[R11]> */
		/* 821EFD60h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFD60h case   22:*/		return 0x821EFD64;
		  /* 821EFD64h */ case   23:  		/* addi R8, R11, -36 */
		/* 821EFD64h case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFD64h case   23:*/		return 0x821EFD68;
		  /* 821EFD68h */ case   24:  		/* addi R10, R10, 36 */
		/* 821EFD68h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EFD68h case   24:*/		return 0x821EFD6C;
		  /* 821EFD6Ch */ case   25:  		/* stw R9, <#[R10]> */
		/* 821EFD6Ch case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFD6Ch case   25:*/		return 0x821EFD70;
		  /* 821EFD70h */ case   26:  		/* lwz R9, <#[R11]> */
		/* 821EFD70h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFD70h case   26:*/		return 0x821EFD74;
		  /* 821EFD74h */ case   27:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EFD74h case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EFD74h case   27:*/		return 0x821EFD78;
		  /* 821EFD78h */ case   28:  		/* addi R6, R10, -36 */
		/* 821EFD78h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFD78h case   28:*/		return 0x821EFD7C;
		  /* 821EFD7Ch */ case   29:  		/* ori R8, R8, 1 */
		/* 821EFD7Ch case   29:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EFD7Ch case   29:*/		return 0x821EFD80;
		  /* 821EFD80h */ case   30:  		/* addi R9, R10, 4 */
		/* 821EFD80h case   30:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EFD80h case   30:*/		return 0x821EFD84;
		  /* 821EFD84h */ case   31:  		/* stw R6, <#[R7]> */
		/* 821EFD84h case   31:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFD84h case   31:*/		return 0x821EFD88;
		  /* 821EFD88h */ case   32:  		/* stw R8, <#[R10 + 4]> */
		/* 821EFD88h case   32:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EFD88h case   32:*/		return 0x821EFD8C;
		  /* 821EFD8Ch */ case   33:  		/* mr R3, R29 */
		/* 821EFD8Ch case   33:*/		regs.R3 = regs.R29;
		/* 821EFD8Ch case   33:*/		return 0x821EFD90;
		  /* 821EFD90h */ case   34:  		/* stw R9, <#[R11]> */
		/* 821EFD90h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFD90h case   34:*/		return 0x821EFD94;
		  /* 821EFD94h */ case   35:  		/* addi R1, R1, 112 */
		/* 821EFD94h case   35:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EFD94h case   35:*/		return 0x821EFD98;
		  /* 821EFD98h */ case   36:  		/* b -1436396 */
		/* 821EFD98h case   36:*/		return 0x820912AC;
		/* 821EFD98h case   36:*/		return 0x821EFD9C;
		  /* 821EFD9Ch */ case   37:  		/* nop */
		/* 821EFD9Ch case   37:*/		cpu::op::nop();
		/* 821EFD9Ch case   37:*/		return 0x821EFDA0;
	}
	return 0x821EFDA0;
} // Block from 821EFD08h-821EFDA0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821EFDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFDA0);
		  /* 821EFDA0h */ case    0:  		/* mfspr R12, LR */
		/* 821EFDA0h case    0:*/		regs.R12 = regs.LR;
		/* 821EFDA0h case    0:*/		return 0x821EFDA4;
		  /* 821EFDA4h */ case    1:  		/* bl -1436488 */
		/* 821EFDA4h case    1:*/		regs.LR = 0x821EFDA8; return 0x8209125C;
		/* 821EFDA4h case    1:*/		return 0x821EFDA8;
		  /* 821EFDA8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EFDA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EFDA8h case    2:*/		return 0x821EFDAC;
		  /* 821EFDACh */ case    3:  		/* li R8, 1 */
		/* 821EFDACh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EFDACh case    3:*/		return 0x821EFDB0;
	}
	return 0x821EFDB0;
} // Block from 821EFDA0h-821EFDB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821EFDB0h
// Function '?MakeInstr_S_SQRT_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFDB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFDB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFDB0);
		  /* 821EFDB0h */ case    0:  		/* li R7, 1 */
		/* 821EFDB0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EFDB0h case    0:*/		return 0x821EFDB4;
		  /* 821EFDB4h */ case    1:  		/* li R6, 48 */
		/* 821EFDB4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x30);
		/* 821EFDB4h case    1:*/		return 0x821EFDB8;
		  /* 821EFDB8h */ case    2:  		/* li R5, 0 */
		/* 821EFDB8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFDB8h case    2:*/		return 0x821EFDBC;
		  /* 821EFDBCh */ case    3:  		/* mr R30, R4 */
		/* 821EFDBCh case    3:*/		regs.R30 = regs.R4;
		/* 821EFDBCh case    3:*/		return 0x821EFDC0;
		  /* 821EFDC0h */ case    4:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFDC0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFDC0h case    4:*/		return 0x821EFDC4;
		  /* 821EFDC4h */ case    5:  		/* mr R31, R3 */
		/* 821EFDC4h case    5:*/		regs.R31 = regs.R3;
		/* 821EFDC4h case    5:*/		return 0x821EFDC8;
		  /* 821EFDC8h */ case    6:  		/* bl 216016 */
		/* 821EFDC8h case    6:*/		regs.LR = 0x821EFDCC; return 0x82224998;
		/* 821EFDC8h case    6:*/		return 0x821EFDCC;
		  /* 821EFDCCh */ case    7:  		/* mr R29, R3 */
		/* 821EFDCCh case    7:*/		regs.R29 = regs.R3;
		/* 821EFDCCh case    7:*/		return 0x821EFDD0;
		  /* 821EFDD0h */ case    8:  		/* mr R4, R30 */
		/* 821EFDD0h case    8:*/		regs.R4 = regs.R30;
		/* 821EFDD0h case    8:*/		return 0x821EFDD4;
		  /* 821EFDD4h */ case    9:  		/* mr R3, R31 */
		/* 821EFDD4h case    9:*/		regs.R3 = regs.R31;
		/* 821EFDD4h case    9:*/		return 0x821EFDD8;
		  /* 821EFDD8h */ case   10:  		/* bl -490968 */
		/* 821EFDD8h case   10:*/		regs.LR = 0x821EFDDC; return 0x82178000;
		/* 821EFDD8h case   10:*/		return 0x821EFDDC;
		  /* 821EFDDCh */ case   11:  		/* mr R4, R3 */
		/* 821EFDDCh case   11:*/		regs.R4 = regs.R3;
		/* 821EFDDCh case   11:*/		return 0x821EFDE0;
		  /* 821EFDE0h */ case   12:  		/* mr R3, R29 */
		/* 821EFDE0h case   12:*/		regs.R3 = regs.R29;
		/* 821EFDE0h case   12:*/		return 0x821EFDE4;
		  /* 821EFDE4h */ case   13:  		/* bl -490524 */
		/* 821EFDE4h case   13:*/		regs.LR = 0x821EFDE8; return 0x821781C8;
		/* 821EFDE4h case   13:*/		return 0x821EFDE8;
		  /* 821EFDE8h */ case   14:  		/* stw R3, <#[R29 + 44]> */
		/* 821EFDE8h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821EFDE8h case   14:*/		return 0x821EFDEC;
		  /* 821EFDECh */ case   15:  		/* lwz R11, <#[R31 + 564]> */
		/* 821EFDECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821EFDECh case   15:*/		return 0x821EFDF0;
		  /* 821EFDF0h */ case   16:  		/* addi R11, R11, 24 */
		/* 821EFDF0h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EFDF0h case   16:*/		return 0x821EFDF4;
		  /* 821EFDF4h */ case   17:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821EFDF4h case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821EFDF4h case   17:*/		return 0x821EFDF8;
		  /* 821EFDF8h */ case   18:  		/* lwz R9, <#[R11]> */
		/* 821EFDF8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFDF8h case   18:*/		return 0x821EFDFC;
		  /* 821EFDFCh */ case   19:  		/* addi R8, R11, -36 */
		/* 821EFDFCh case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFDFCh case   19:*/		return 0x821EFE00;
		  /* 821EFE00h */ case   20:  		/* addi R10, R10, 36 */
		/* 821EFE00h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EFE00h case   20:*/		return 0x821EFE04;
		  /* 821EFE04h */ case   21:  		/* stw R9, <#[R10]> */
		/* 821EFE04h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFE04h case   21:*/		return 0x821EFE08;
		  /* 821EFE08h */ case   22:  		/* lwz R9, <#[R11]> */
		/* 821EFE08h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFE08h case   22:*/		return 0x821EFE0C;
		  /* 821EFE0Ch */ case   23:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EFE0Ch case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EFE0Ch case   23:*/		return 0x821EFE10;
		  /* 821EFE10h */ case   24:  		/* addi R6, R10, -36 */
		/* 821EFE10h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFE10h case   24:*/		return 0x821EFE14;
		  /* 821EFE14h */ case   25:  		/* ori R8, R8, 1 */
		/* 821EFE14h case   25:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EFE14h case   25:*/		return 0x821EFE18;
		  /* 821EFE18h */ case   26:  		/* addi R9, R10, 4 */
		/* 821EFE18h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EFE18h case   26:*/		return 0x821EFE1C;
		  /* 821EFE1Ch */ case   27:  		/* stw R6, <#[R7]> */
		/* 821EFE1Ch case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFE1Ch case   27:*/		return 0x821EFE20;
		  /* 821EFE20h */ case   28:  		/* stw R8, <#[R10 + 4]> */
		/* 821EFE20h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EFE20h case   28:*/		return 0x821EFE24;
		  /* 821EFE24h */ case   29:  		/* mr R3, R29 */
		/* 821EFE24h case   29:*/		regs.R3 = regs.R29;
		/* 821EFE24h case   29:*/		return 0x821EFE28;
		  /* 821EFE28h */ case   30:  		/* stw R9, <#[R11]> */
		/* 821EFE28h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFE28h case   30:*/		return 0x821EFE2C;
		  /* 821EFE2Ch */ case   31:  		/* addi R1, R1, 112 */
		/* 821EFE2Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EFE2Ch case   31:*/		return 0x821EFE30;
		  /* 821EFE30h */ case   32:  		/* b -1436548 */
		/* 821EFE30h case   32:*/		return 0x820912AC;
		/* 821EFE30h case   32:*/		return 0x821EFE34;
		  /* 821EFE34h */ case   33:  		/* nop */
		/* 821EFE34h case   33:*/		cpu::op::nop();
		/* 821EFE34h case   33:*/		return 0x821EFE38;
	}
	return 0x821EFE38;
} // Block from 821EFDB0h-821EFE38h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821EFE38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFE38);
		  /* 821EFE38h */ case    0:  		/* mfspr R12, LR */
		/* 821EFE38h case    0:*/		regs.R12 = regs.LR;
		/* 821EFE38h case    0:*/		return 0x821EFE3C;
		  /* 821EFE3Ch */ case    1:  		/* bl -1436640 */
		/* 821EFE3Ch case    1:*/		regs.LR = 0x821EFE40; return 0x8209125C;
		/* 821EFE3Ch case    1:*/		return 0x821EFE40;
		  /* 821EFE40h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EFE40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EFE40h case    2:*/		return 0x821EFE44;
		  /* 821EFE44h */ case    3:  		/* li R8, 1 */
		/* 821EFE44h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EFE44h case    3:*/		return 0x821EFE48;
		  /* 821EFE48h */ case    4:  		/* li R7, 1 */
		/* 821EFE48h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EFE48h case    4:*/		return 0x821EFE4C;
		  /* 821EFE4Ch */ case    5:  		/* li R6, 51 */
		/* 821EFE4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x33);
		/* 821EFE4Ch case    5:*/		return 0x821EFE50;
		  /* 821EFE50h */ case    6:  		/* li R5, 0 */
		/* 821EFE50h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFE50h case    6:*/		return 0x821EFE54;
		  /* 821EFE54h */ case    7:  		/* mr R30, R4 */
		/* 821EFE54h case    7:*/		regs.R30 = regs.R4;
		/* 821EFE54h case    7:*/		return 0x821EFE58;
	}
	return 0x821EFE58;
} // Block from 821EFE38h-821EFE58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821EFE58h
// Function '?MakeInstr_S_SIN@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFE58);
		  /* 821EFE58h */ case    0:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFE58h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFE58h case    0:*/		return 0x821EFE5C;
		  /* 821EFE5Ch */ case    1:  		/* mr R31, R3 */
		/* 821EFE5Ch case    1:*/		regs.R31 = regs.R3;
		/* 821EFE5Ch case    1:*/		return 0x821EFE60;
		  /* 821EFE60h */ case    2:  		/* bl 215864 */
		/* 821EFE60h case    2:*/		regs.LR = 0x821EFE64; return 0x82224998;
		/* 821EFE60h case    2:*/		return 0x821EFE64;
		  /* 821EFE64h */ case    3:  		/* mr R29, R3 */
		/* 821EFE64h case    3:*/		regs.R29 = regs.R3;
		/* 821EFE64h case    3:*/		return 0x821EFE68;
		  /* 821EFE68h */ case    4:  		/* mr R4, R30 */
		/* 821EFE68h case    4:*/		regs.R4 = regs.R30;
		/* 821EFE68h case    4:*/		return 0x821EFE6C;
		  /* 821EFE6Ch */ case    5:  		/* mr R3, R31 */
		/* 821EFE6Ch case    5:*/		regs.R3 = regs.R31;
		/* 821EFE6Ch case    5:*/		return 0x821EFE70;
		  /* 821EFE70h */ case    6:  		/* bl -491120 */
		/* 821EFE70h case    6:*/		regs.LR = 0x821EFE74; return 0x82178000;
		/* 821EFE70h case    6:*/		return 0x821EFE74;
		  /* 821EFE74h */ case    7:  		/* mr R4, R3 */
		/* 821EFE74h case    7:*/		regs.R4 = regs.R3;
		/* 821EFE74h case    7:*/		return 0x821EFE78;
		  /* 821EFE78h */ case    8:  		/* mr R3, R29 */
		/* 821EFE78h case    8:*/		regs.R3 = regs.R29;
		/* 821EFE78h case    8:*/		return 0x821EFE7C;
		  /* 821EFE7Ch */ case    9:  		/* bl -490676 */
		/* 821EFE7Ch case    9:*/		regs.LR = 0x821EFE80; return 0x821781C8;
		/* 821EFE7Ch case    9:*/		return 0x821EFE80;
		  /* 821EFE80h */ case   10:  		/* stw R3, <#[R29 + 44]> */
		/* 821EFE80h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821EFE80h case   10:*/		return 0x821EFE84;
		  /* 821EFE84h */ case   11:  		/* lwz R11, <#[R31 + 564]> */
		/* 821EFE84h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821EFE84h case   11:*/		return 0x821EFE88;
		  /* 821EFE88h */ case   12:  		/* addi R11, R11, 24 */
		/* 821EFE88h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EFE88h case   12:*/		return 0x821EFE8C;
		  /* 821EFE8Ch */ case   13:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821EFE8Ch case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821EFE8Ch case   13:*/		return 0x821EFE90;
		  /* 821EFE90h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 821EFE90h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFE90h case   14:*/		return 0x821EFE94;
		  /* 821EFE94h */ case   15:  		/* addi R8, R11, -36 */
		/* 821EFE94h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFE94h case   15:*/		return 0x821EFE98;
		  /* 821EFE98h */ case   16:  		/* addi R10, R10, 36 */
		/* 821EFE98h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EFE98h case   16:*/		return 0x821EFE9C;
		  /* 821EFE9Ch */ case   17:  		/* stw R9, <#[R10]> */
		/* 821EFE9Ch case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFE9Ch case   17:*/		return 0x821EFEA0;
		  /* 821EFEA0h */ case   18:  		/* lwz R9, <#[R11]> */
		/* 821EFEA0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFEA0h case   18:*/		return 0x821EFEA4;
		  /* 821EFEA4h */ case   19:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EFEA4h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EFEA4h case   19:*/		return 0x821EFEA8;
		  /* 821EFEA8h */ case   20:  		/* addi R6, R10, -36 */
		/* 821EFEA8h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFEA8h case   20:*/		return 0x821EFEAC;
		  /* 821EFEACh */ case   21:  		/* ori R8, R8, 1 */
		/* 821EFEACh case   21:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EFEACh case   21:*/		return 0x821EFEB0;
		  /* 821EFEB0h */ case   22:  		/* addi R9, R10, 4 */
		/* 821EFEB0h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EFEB0h case   22:*/		return 0x821EFEB4;
		  /* 821EFEB4h */ case   23:  		/* stw R6, <#[R7]> */
		/* 821EFEB4h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFEB4h case   23:*/		return 0x821EFEB8;
		  /* 821EFEB8h */ case   24:  		/* stw R8, <#[R10 + 4]> */
		/* 821EFEB8h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EFEB8h case   24:*/		return 0x821EFEBC;
		  /* 821EFEBCh */ case   25:  		/* mr R3, R29 */
		/* 821EFEBCh case   25:*/		regs.R3 = regs.R29;
		/* 821EFEBCh case   25:*/		return 0x821EFEC0;
		  /* 821EFEC0h */ case   26:  		/* stw R9, <#[R11]> */
		/* 821EFEC0h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFEC0h case   26:*/		return 0x821EFEC4;
		  /* 821EFEC4h */ case   27:  		/* addi R1, R1, 112 */
		/* 821EFEC4h case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EFEC4h case   27:*/		return 0x821EFEC8;
		  /* 821EFEC8h */ case   28:  		/* b -1436700 */
		/* 821EFEC8h case   28:*/		return 0x820912AC;
		/* 821EFEC8h case   28:*/		return 0x821EFECC;
		  /* 821EFECCh */ case   29:  		/* nop */
		/* 821EFECCh case   29:*/		cpu::op::nop();
		/* 821EFECCh case   29:*/		return 0x821EFED0;
	}
	return 0x821EFED0;
} // Block from 821EFE58h-821EFED0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821EFED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFED0);
		  /* 821EFED0h */ case    0:  		/* mfspr R12, LR */
		/* 821EFED0h case    0:*/		regs.R12 = regs.LR;
		/* 821EFED0h case    0:*/		return 0x821EFED4;
		  /* 821EFED4h */ case    1:  		/* bl -1436792 */
		/* 821EFED4h case    1:*/		regs.LR = 0x821EFED8; return 0x8209125C;
		/* 821EFED4h case    1:*/		return 0x821EFED8;
		  /* 821EFED8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EFED8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EFED8h case    2:*/		return 0x821EFEDC;
		  /* 821EFEDCh */ case    3:  		/* li R8, 1 */
		/* 821EFEDCh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EFEDCh case    3:*/		return 0x821EFEE0;
		  /* 821EFEE0h */ case    4:  		/* li R7, 1 */
		/* 821EFEE0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EFEE0h case    4:*/		return 0x821EFEE4;
		  /* 821EFEE4h */ case    5:  		/* li R6, 54 */
		/* 821EFEE4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x36);
		/* 821EFEE4h case    5:*/		return 0x821EFEE8;
		  /* 821EFEE8h */ case    6:  		/* li R5, 0 */
		/* 821EFEE8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFEE8h case    6:*/		return 0x821EFEEC;
		  /* 821EFEECh */ case    7:  		/* mr R30, R4 */
		/* 821EFEECh case    7:*/		regs.R30 = regs.R4;
		/* 821EFEECh case    7:*/		return 0x821EFEF0;
		  /* 821EFEF0h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFEF0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFEF0h case    8:*/		return 0x821EFEF4;
		  /* 821EFEF4h */ case    9:  		/* mr R31, R3 */
		/* 821EFEF4h case    9:*/		regs.R31 = regs.R3;
		/* 821EFEF4h case    9:*/		return 0x821EFEF8;
		  /* 821EFEF8h */ case   10:  		/* bl 215712 */
		/* 821EFEF8h case   10:*/		regs.LR = 0x821EFEFC; return 0x82224998;
		/* 821EFEF8h case   10:*/		return 0x821EFEFC;
		  /* 821EFEFCh */ case   11:  		/* mr R29, R3 */
		/* 821EFEFCh case   11:*/		regs.R29 = regs.R3;
		/* 821EFEFCh case   11:*/		return 0x821EFF00;
	}
	return 0x821EFF00;
} // Block from 821EFED0h-821EFF00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821EFF00h
// Function '?MakeInstr_S_COS@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFF00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFF00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFF00);
		  /* 821EFF00h */ case    0:  		/* mr R4, R30 */
		/* 821EFF00h case    0:*/		regs.R4 = regs.R30;
		/* 821EFF00h case    0:*/		return 0x821EFF04;
		  /* 821EFF04h */ case    1:  		/* mr R3, R31 */
		/* 821EFF04h case    1:*/		regs.R3 = regs.R31;
		/* 821EFF04h case    1:*/		return 0x821EFF08;
		  /* 821EFF08h */ case    2:  		/* bl -491272 */
		/* 821EFF08h case    2:*/		regs.LR = 0x821EFF0C; return 0x82178000;
		/* 821EFF08h case    2:*/		return 0x821EFF0C;
		  /* 821EFF0Ch */ case    3:  		/* mr R4, R3 */
		/* 821EFF0Ch case    3:*/		regs.R4 = regs.R3;
		/* 821EFF0Ch case    3:*/		return 0x821EFF10;
		  /* 821EFF10h */ case    4:  		/* mr R3, R29 */
		/* 821EFF10h case    4:*/		regs.R3 = regs.R29;
		/* 821EFF10h case    4:*/		return 0x821EFF14;
		  /* 821EFF14h */ case    5:  		/* bl -490828 */
		/* 821EFF14h case    5:*/		regs.LR = 0x821EFF18; return 0x821781C8;
		/* 821EFF14h case    5:*/		return 0x821EFF18;
		  /* 821EFF18h */ case    6:  		/* stw R3, <#[R29 + 44]> */
		/* 821EFF18h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821EFF18h case    6:*/		return 0x821EFF1C;
		  /* 821EFF1Ch */ case    7:  		/* lwz R11, <#[R31 + 564]> */
		/* 821EFF1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821EFF1Ch case    7:*/		return 0x821EFF20;
		  /* 821EFF20h */ case    8:  		/* addi R11, R11, 24 */
		/* 821EFF20h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EFF20h case    8:*/		return 0x821EFF24;
		  /* 821EFF24h */ case    9:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821EFF24h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821EFF24h case    9:*/		return 0x821EFF28;
		  /* 821EFF28h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EFF28h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFF28h case   10:*/		return 0x821EFF2C;
		  /* 821EFF2Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821EFF2Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFF2Ch case   11:*/		return 0x821EFF30;
		  /* 821EFF30h */ case   12:  		/* addi R10, R10, 36 */
		/* 821EFF30h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EFF30h case   12:*/		return 0x821EFF34;
		  /* 821EFF34h */ case   13:  		/* stw R9, <#[R10]> */
		/* 821EFF34h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFF34h case   13:*/		return 0x821EFF38;
		  /* 821EFF38h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 821EFF38h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFF38h case   14:*/		return 0x821EFF3C;
		  /* 821EFF3Ch */ case   15:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EFF3Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EFF3Ch case   15:*/		return 0x821EFF40;
		  /* 821EFF40h */ case   16:  		/* addi R6, R10, -36 */
		/* 821EFF40h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFF40h case   16:*/		return 0x821EFF44;
		  /* 821EFF44h */ case   17:  		/* ori R8, R8, 1 */
		/* 821EFF44h case   17:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EFF44h case   17:*/		return 0x821EFF48;
		  /* 821EFF48h */ case   18:  		/* addi R9, R10, 4 */
		/* 821EFF48h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EFF48h case   18:*/		return 0x821EFF4C;
		  /* 821EFF4Ch */ case   19:  		/* stw R6, <#[R7]> */
		/* 821EFF4Ch case   19:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFF4Ch case   19:*/		return 0x821EFF50;
		  /* 821EFF50h */ case   20:  		/* stw R8, <#[R10 + 4]> */
		/* 821EFF50h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EFF50h case   20:*/		return 0x821EFF54;
		  /* 821EFF54h */ case   21:  		/* mr R3, R29 */
		/* 821EFF54h case   21:*/		regs.R3 = regs.R29;
		/* 821EFF54h case   21:*/		return 0x821EFF58;
		  /* 821EFF58h */ case   22:  		/* stw R9, <#[R11]> */
		/* 821EFF58h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFF58h case   22:*/		return 0x821EFF5C;
		  /* 821EFF5Ch */ case   23:  		/* addi R1, R1, 112 */
		/* 821EFF5Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EFF5Ch case   23:*/		return 0x821EFF60;
		  /* 821EFF60h */ case   24:  		/* b -1436852 */
		/* 821EFF60h case   24:*/		return 0x820912AC;
		/* 821EFF60h case   24:*/		return 0x821EFF64;
		  /* 821EFF64h */ case   25:  		/* nop */
		/* 821EFF64h case   25:*/		cpu::op::nop();
		/* 821EFF64h case   25:*/		return 0x821EFF68;
	}
	return 0x821EFF68;
} // Block from 821EFF00h-821EFF68h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821EFF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFF68);
		  /* 821EFF68h */ case    0:  		/* mfspr R12, LR */
		/* 821EFF68h case    0:*/		regs.R12 = regs.LR;
		/* 821EFF68h case    0:*/		return 0x821EFF6C;
		  /* 821EFF6Ch */ case    1:  		/* bl -1436944 */
		/* 821EFF6Ch case    1:*/		regs.LR = 0x821EFF70; return 0x8209125C;
		/* 821EFF6Ch case    1:*/		return 0x821EFF70;
		  /* 821EFF70h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821EFF70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821EFF70h case    2:*/		return 0x821EFF74;
		  /* 821EFF74h */ case    3:  		/* li R8, 1 */
		/* 821EFF74h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821EFF74h case    3:*/		return 0x821EFF78;
		  /* 821EFF78h */ case    4:  		/* li R7, 1 */
		/* 821EFF78h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821EFF78h case    4:*/		return 0x821EFF7C;
		  /* 821EFF7Ch */ case    5:  		/* li R6, 72 */
		/* 821EFF7Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x48);
		/* 821EFF7Ch case    5:*/		return 0x821EFF80;
		  /* 821EFF80h */ case    6:  		/* li R5, 0 */
		/* 821EFF80h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821EFF80h case    6:*/		return 0x821EFF84;
		  /* 821EFF84h */ case    7:  		/* mr R30, R4 */
		/* 821EFF84h case    7:*/		regs.R30 = regs.R4;
		/* 821EFF84h case    7:*/		return 0x821EFF88;
		  /* 821EFF88h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821EFF88h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821EFF88h case    8:*/		return 0x821EFF8C;
		  /* 821EFF8Ch */ case    9:  		/* mr R31, R3 */
		/* 821EFF8Ch case    9:*/		regs.R31 = regs.R3;
		/* 821EFF8Ch case    9:*/		return 0x821EFF90;
		  /* 821EFF90h */ case   10:  		/* bl 215560 */
		/* 821EFF90h case   10:*/		regs.LR = 0x821EFF94; return 0x82224998;
		/* 821EFF90h case   10:*/		return 0x821EFF94;
		  /* 821EFF94h */ case   11:  		/* mr R29, R3 */
		/* 821EFF94h case   11:*/		regs.R29 = regs.R3;
		/* 821EFF94h case   11:*/		return 0x821EFF98;
		  /* 821EFF98h */ case   12:  		/* mr R4, R30 */
		/* 821EFF98h case   12:*/		regs.R4 = regs.R30;
		/* 821EFF98h case   12:*/		return 0x821EFF9C;
		  /* 821EFF9Ch */ case   13:  		/* mr R3, R31 */
		/* 821EFF9Ch case   13:*/		regs.R3 = regs.R31;
		/* 821EFF9Ch case   13:*/		return 0x821EFFA0;
		  /* 821EFFA0h */ case   14:  		/* bl -491424 */
		/* 821EFFA0h case   14:*/		regs.LR = 0x821EFFA4; return 0x82178000;
		/* 821EFFA0h case   14:*/		return 0x821EFFA4;
		  /* 821EFFA4h */ case   15:  		/* mr R4, R3 */
		/* 821EFFA4h case   15:*/		regs.R4 = regs.R3;
		/* 821EFFA4h case   15:*/		return 0x821EFFA8;
	}
	return 0x821EFFA8;
} // Block from 821EFF68h-821EFFA8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821EFFA8h
// Function '?MakeInstr_T_SET_TEX_LOD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821EFFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821EFFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821EFFA8);
		  /* 821EFFA8h */ case    0:  		/* mr R3, R29 */
		/* 821EFFA8h case    0:*/		regs.R3 = regs.R29;
		/* 821EFFA8h case    0:*/		return 0x821EFFAC;
		  /* 821EFFACh */ case    1:  		/* bl -490980 */
		/* 821EFFACh case    1:*/		regs.LR = 0x821EFFB0; return 0x821781C8;
		/* 821EFFACh case    1:*/		return 0x821EFFB0;
		  /* 821EFFB0h */ case    2:  		/* stw R3, <#[R29 + 44]> */
		/* 821EFFB0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821EFFB0h case    2:*/		return 0x821EFFB4;
		  /* 821EFFB4h */ case    3:  		/* lwz R11, <#[R31 + 564]> */
		/* 821EFFB4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821EFFB4h case    3:*/		return 0x821EFFB8;
		  /* 821EFFB8h */ case    4:  		/* addi R11, R11, 24 */
		/* 821EFFB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821EFFB8h case    4:*/		return 0x821EFFBC;
		  /* 821EFFBCh */ case    5:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821EFFBCh case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821EFFBCh case    5:*/		return 0x821EFFC0;
		  /* 821EFFC0h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821EFFC0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFFC0h case    6:*/		return 0x821EFFC4;
		  /* 821EFFC4h */ case    7:  		/* addi R8, R11, -36 */
		/* 821EFFC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821EFFC4h case    7:*/		return 0x821EFFC8;
		  /* 821EFFC8h */ case    8:  		/* addi R10, R10, 36 */
		/* 821EFFC8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821EFFC8h case    8:*/		return 0x821EFFCC;
		  /* 821EFFCCh */ case    9:  		/* stw R9, <#[R10]> */
		/* 821EFFCCh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821EFFCCh case    9:*/		return 0x821EFFD0;
		  /* 821EFFD0h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821EFFD0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFFD0h case   10:*/		return 0x821EFFD4;
		  /* 821EFFD4h */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821EFFD4h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821EFFD4h case   11:*/		return 0x821EFFD8;
		  /* 821EFFD8h */ case   12:  		/* addi R6, R10, -36 */
		/* 821EFFD8h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821EFFD8h case   12:*/		return 0x821EFFDC;
		  /* 821EFFDCh */ case   13:  		/* ori R8, R8, 1 */
		/* 821EFFDCh case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821EFFDCh case   13:*/		return 0x821EFFE0;
		  /* 821EFFE0h */ case   14:  		/* addi R9, R10, 4 */
		/* 821EFFE0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821EFFE0h case   14:*/		return 0x821EFFE4;
		  /* 821EFFE4h */ case   15:  		/* stw R6, <#[R7]> */
		/* 821EFFE4h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821EFFE4h case   15:*/		return 0x821EFFE8;
		  /* 821EFFE8h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821EFFE8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821EFFE8h case   16:*/		return 0x821EFFEC;
		  /* 821EFFECh */ case   17:  		/* mr R3, R29 */
		/* 821EFFECh case   17:*/		regs.R3 = regs.R29;
		/* 821EFFECh case   17:*/		return 0x821EFFF0;
		  /* 821EFFF0h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821EFFF0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821EFFF0h case   18:*/		return 0x821EFFF4;
		  /* 821EFFF4h */ case   19:  		/* addi R1, R1, 112 */
		/* 821EFFF4h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821EFFF4h case   19:*/		return 0x821EFFF8;
		  /* 821EFFF8h */ case   20:  		/* b -1437004 */
		/* 821EFFF8h case   20:*/		return 0x820912AC;
		/* 821EFFF8h case   20:*/		return 0x821EFFFC;
		  /* 821EFFFCh */ case   21:  		/* nop */
		/* 821EFFFCh case   21:*/		cpu::op::nop();
		/* 821EFFFCh case   21:*/		return 0x821F0000;
	}
	return 0x821F0000;
} // Block from 821EFFA8h-821F0000h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F0000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0000);
		  /* 821F0000h */ case    0:  		/* mfspr R12, LR */
		/* 821F0000h case    0:*/		regs.R12 = regs.LR;
		/* 821F0000h case    0:*/		return 0x821F0004;
		  /* 821F0004h */ case    1:  		/* bl -1437100 */
		/* 821F0004h case    1:*/		regs.LR = 0x821F0008; return 0x82091258;
		/* 821F0004h case    1:*/		return 0x821F0008;
		  /* 821F0008h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F0008h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F0008h case    2:*/		return 0x821F000C;
		  /* 821F000Ch */ case    3:  		/* mr R28, R5 */
		/* 821F000Ch case    3:*/		regs.R28 = regs.R5;
		/* 821F000Ch case    3:*/		return 0x821F0010;
		  /* 821F0010h */ case    4:  		/* li R8, 4 */
		/* 821F0010h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F0010h case    4:*/		return 0x821F0014;
		  /* 821F0014h */ case    5:  		/* li R7, 2 */
		/* 821F0014h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F0014h case    5:*/		return 0x821F0018;
		  /* 821F0018h */ case    6:  		/* li R6, 1 */
		/* 821F0018h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F0018h case    6:*/		return 0x821F001C;
		  /* 821F001Ch */ case    7:  		/* li R5, 0 */
		/* 821F001Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F001Ch case    7:*/		return 0x821F0020;
		  /* 821F0020h */ case    8:  		/* mr R29, R4 */
		/* 821F0020h case    8:*/		regs.R29 = regs.R4;
		/* 821F0020h case    8:*/		return 0x821F0024;
		  /* 821F0024h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F0024h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F0024h case    9:*/		return 0x821F0028;
		  /* 821F0028h */ case   10:  		/* mr R30, R3 */
		/* 821F0028h case   10:*/		regs.R30 = regs.R3;
		/* 821F0028h case   10:*/		return 0x821F002C;
		  /* 821F002Ch */ case   11:  		/* bl 215404 */
		/* 821F002Ch case   11:*/		regs.LR = 0x821F0030; return 0x82224998;
		/* 821F002Ch case   11:*/		return 0x821F0030;
		  /* 821F0030h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F0030h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F0030h case   12:*/		return 0x821F0034;
		  /* 821F0034h */ case   13:  		/* mr R31, R3 */
		/* 821F0034h case   13:*/		regs.R31 = regs.R3;
		/* 821F0034h case   13:*/		return 0x821F0038;
		  /* 821F0038h */ case   14:  		/* mr R4, R29 */
		/* 821F0038h case   14:*/		regs.R4 = regs.R29;
		/* 821F0038h case   14:*/		return 0x821F003C;
		  /* 821F003Ch */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F003Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F003Ch case   15:*/		return 0x821F0040;
		  /* 821F0040h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F0040h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F0054;  }
		/* 821F0040h case   16:*/		return 0x821F0044;
		  /* 821F0044h */ case   17:  		/* mr R3, R30 */
		/* 821F0044h case   17:*/		regs.R3 = regs.R30;
		/* 821F0044h case   17:*/		return 0x821F0048;
		  /* 821F0048h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F0048h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F0048h case   18:*/		return 0x821F004C;
		  /* 821F004Ch */ case   19:  		/* bl -520028 */
		/* 821F004Ch case   19:*/		regs.LR = 0x821F0050; return 0x821710F0;
		/* 821F004Ch case   19:*/		return 0x821F0050;
	}
	return 0x821F0050;
} // Block from 821F0000h-821F0050h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F0050h
// Function '?MakeInstr_T_GET_GRADIENTS@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0050);
		  /* 821F0050h */ case    0:  		/* mr R4, R3 */
		/* 821F0050h case    0:*/		regs.R4 = regs.R3;
		/* 821F0050h case    0:*/		return 0x821F0054;
	}
	return 0x821F0054;
} // Block from 821F0050h-821F0054h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F0054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0054);
		  /* 821F0054h */ case    0:  		/* mr R3, R31 */
		/* 821F0054h case    0:*/		regs.R3 = regs.R31;
		/* 821F0054h case    0:*/		return 0x821F0058;
		  /* 821F0058h */ case    1:  		/* bl -491152 */
		/* 821F0058h case    1:*/		regs.LR = 0x821F005C; return 0x821781C8;
		/* 821F0058h case    1:*/		return 0x821F005C;
		  /* 821F005Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F005Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F005Ch case    2:*/		return 0x821F0060;
		  /* 821F0060h */ case    3:  		/* mr R4, R28 */
		/* 821F0060h case    3:*/		regs.R4 = regs.R28;
		/* 821F0060h case    3:*/		return 0x821F0064;
		  /* 821F0064h */ case    4:  		/* mr R3, R30 */
		/* 821F0064h case    4:*/		regs.R3 = regs.R30;
		/* 821F0064h case    4:*/		return 0x821F0068;
		  /* 821F0068h */ case    5:  		/* bl -491624 */
		/* 821F0068h case    5:*/		regs.LR = 0x821F006C; return 0x82178000;
		/* 821F0068h case    5:*/		return 0x821F006C;
		  /* 821F006Ch */ case    6:  		/* mr R4, R3 */
		/* 821F006Ch case    6:*/		regs.R4 = regs.R3;
		/* 821F006Ch case    6:*/		return 0x821F0070;
		  /* 821F0070h */ case    7:  		/* mr R3, R31 */
		/* 821F0070h case    7:*/		regs.R3 = regs.R31;
		/* 821F0070h case    7:*/		return 0x821F0074;
		  /* 821F0074h */ case    8:  		/* bl -491180 */
		/* 821F0074h case    8:*/		regs.LR = 0x821F0078; return 0x821781C8;
		/* 821F0074h case    8:*/		return 0x821F0078;
		  /* 821F0078h */ case    9:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F0078h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0078h case    9:*/		return 0x821F007C;
		  /* 821F007Ch */ case   10:  		/* stw R3, <#[R31 + 48]> */
		/* 821F007Ch case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F007Ch case   10:*/		return 0x821F0080;
		  /* 821F0080h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0080h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0080h case   11:*/		return 0x821F0084;
		  /* 821F0084h */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F0084h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0084h case   12:*/		return 0x821F0088;
		  /* 821F0088h */ case   13:  		/* mr R3, R31 */
		/* 821F0088h case   13:*/		regs.R3 = regs.R31;
		/* 821F0088h case   13:*/		return 0x821F008C;
		  /* 821F008Ch */ case   14:  		/* addi R11, R11, 36 */
		/* 821F008Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F008Ch case   14:*/		return 0x821F0090;
		  /* 821F0090h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 821F0090h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0090h case   15:*/		return 0x821F0094;
		  /* 821F0094h */ case   16:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F0094h case   16:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F0094h case   16:*/		return 0x821F0098;
		  /* 821F0098h */ case   17:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0098h case   17:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0098h case   17:*/		return 0x821F009C;
		  /* 821F009Ch */ case   18:  		/* addi R8, R11, -36 */
		/* 821F009Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F009Ch case   18:*/		return 0x821F00A0;
		  /* 821F00A0h */ case   19:  		/* stw R9, <#[R31 + 8]> */
		/* 821F00A0h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F00A0h case   19:*/		return 0x821F00A4;
		  /* 821F00A4h */ case   20:  		/* addi R9, R11, 4 */
		/* 821F00A4h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F00A4h case   20:*/		return 0x821F00A8;
		  /* 821F00A8h */ case   21:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F00A8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F00A8h case   21:*/		return 0x821F00AC;
		  /* 821F00ACh */ case   22:  		/* addi R10, R10, 24 */
		/* 821F00ACh case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F00ACh case   22:*/		return 0x821F00B0;
		  /* 821F00B0h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F00B0h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F00B0h case   23:*/		return 0x821F00B4;
		  /* 821F00B4h */ case   24:  		/* addi R6, R10, -36 */
		/* 821F00B4h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F00B4h case   24:*/		return 0x821F00B8;
		  /* 821F00B8h */ case   25:  		/* stw R7, <#[R11]> */
		/* 821F00B8h case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F00B8h case   25:*/		return 0x821F00BC;
		  /* 821F00BCh */ case   26:  		/* lwz R7, <#[R10]> */
		/* 821F00BCh case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F00BCh case   26:*/		return 0x821F00C0;
		  /* 821F00C0h */ case   27:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F00C0h case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F00C0h case   27:*/		return 0x821F00C4;
		  /* 821F00C4h */ case   28:  		/* ori R6, R6, 1 */
		/* 821F00C4h case   28:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F00C4h case   28:*/		return 0x821F00C8;
		  /* 821F00C8h */ case   29:  		/* stw R8, <#[R7]> */
		/* 821F00C8h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F00C8h case   29:*/		return 0x821F00CC;
		  /* 821F00CCh */ case   30:  		/* stw R6, <#[R11 + 4]> */
		/* 821F00CCh case   30:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F00CCh case   30:*/		return 0x821F00D0;
		  /* 821F00D0h */ case   31:  		/* stw R9, <#[R10]> */
		/* 821F00D0h case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F00D0h case   31:*/		return 0x821F00D4;
		  /* 821F00D4h */ case   32:  		/* addi R1, R1, 128 */
		/* 821F00D4h case   32:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F00D4h case   32:*/		return 0x821F00D8;
		  /* 821F00D8h */ case   33:  		/* b -1437232 */
		/* 821F00D8h case   33:*/		return 0x820912A8;
		/* 821F00D8h case   33:*/		return 0x821F00DC;
		  /* 821F00DCh */ case   34:  		/* nop */
		/* 821F00DCh case   34:*/		cpu::op::nop();
		/* 821F00DCh case   34:*/		return 0x821F00E0;
	}
	return 0x821F00E0;
} // Block from 821F0054h-821F00E0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821F00E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F00E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F00E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F00E0);
		  /* 821F00E0h */ case    0:  		/* mfspr R12, LR */
		/* 821F00E0h case    0:*/		regs.R12 = regs.LR;
		/* 821F00E0h case    0:*/		return 0x821F00E4;
		  /* 821F00E4h */ case    1:  		/* bl -1437324 */
		/* 821F00E4h case    1:*/		regs.LR = 0x821F00E8; return 0x82091258;
		/* 821F00E4h case    1:*/		return 0x821F00E8;
		  /* 821F00E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F00E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F00E8h case    2:*/		return 0x821F00EC;
		  /* 821F00ECh */ case    3:  		/* mr R28, R5 */
		/* 821F00ECh case    3:*/		regs.R28 = regs.R5;
		/* 821F00ECh case    3:*/		return 0x821F00F0;
		  /* 821F00F0h */ case    4:  		/* li R8, 4 */
		/* 821F00F0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F00F0h case    4:*/		return 0x821F00F4;
		  /* 821F00F4h */ case    5:  		/* li R7, 2 */
		/* 821F00F4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F00F4h case    5:*/		return 0x821F00F8;
		  /* 821F00F8h */ case    6:  		/* li R6, 2 */
		/* 821F00F8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F00F8h case    6:*/		return 0x821F00FC;
		  /* 821F00FCh */ case    7:  		/* li R5, 0 */
		/* 821F00FCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F00FCh case    7:*/		return 0x821F0100;
		  /* 821F0100h */ case    8:  		/* mr R29, R4 */
		/* 821F0100h case    8:*/		regs.R29 = regs.R4;
		/* 821F0100h case    8:*/		return 0x821F0104;
		  /* 821F0104h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F0104h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F0104h case    9:*/		return 0x821F0108;
		  /* 821F0108h */ case   10:  		/* mr R30, R3 */
		/* 821F0108h case   10:*/		regs.R30 = regs.R3;
		/* 821F0108h case   10:*/		return 0x821F010C;
		  /* 821F010Ch */ case   11:  		/* bl 215180 */
		/* 821F010Ch case   11:*/		regs.LR = 0x821F0110; return 0x82224998;
		/* 821F010Ch case   11:*/		return 0x821F0110;
		  /* 821F0110h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F0110h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F0110h case   12:*/		return 0x821F0114;
		  /* 821F0114h */ case   13:  		/* mr R31, R3 */
		/* 821F0114h case   13:*/		regs.R31 = regs.R3;
		/* 821F0114h case   13:*/		return 0x821F0118;
		  /* 821F0118h */ case   14:  		/* mr R4, R29 */
		/* 821F0118h case   14:*/		regs.R4 = regs.R29;
		/* 821F0118h case   14:*/		return 0x821F011C;
		  /* 821F011Ch */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F011Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F011Ch case   15:*/		return 0x821F0120;
		  /* 821F0120h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F0120h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F0134;  }
		/* 821F0120h case   16:*/		return 0x821F0124;
		  /* 821F0124h */ case   17:  		/* mr R3, R30 */
		/* 821F0124h case   17:*/		regs.R3 = regs.R30;
		/* 821F0124h case   17:*/		return 0x821F0128;
	}
	return 0x821F0128;
} // Block from 821F00E0h-821F0128h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F0128h
// Function '?MakeInstr_T_SET_GRADIENTS_H@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0128);
		  /* 821F0128h */ case    0:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F0128h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F0128h case    0:*/		return 0x821F012C;
		  /* 821F012Ch */ case    1:  		/* bl -520252 */
		/* 821F012Ch case    1:*/		regs.LR = 0x821F0130; return 0x821710F0;
		/* 821F012Ch case    1:*/		return 0x821F0130;
		  /* 821F0130h */ case    2:  		/* mr R4, R3 */
		/* 821F0130h case    2:*/		regs.R4 = regs.R3;
		/* 821F0130h case    2:*/		return 0x821F0134;
	}
	return 0x821F0134;
} // Block from 821F0128h-821F0134h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F0134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0134);
		  /* 821F0134h */ case    0:  		/* mr R3, R31 */
		/* 821F0134h case    0:*/		regs.R3 = regs.R31;
		/* 821F0134h case    0:*/		return 0x821F0138;
		  /* 821F0138h */ case    1:  		/* bl -491376 */
		/* 821F0138h case    1:*/		regs.LR = 0x821F013C; return 0x821781C8;
		/* 821F0138h case    1:*/		return 0x821F013C;
		  /* 821F013Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F013Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F013Ch case    2:*/		return 0x821F0140;
		  /* 821F0140h */ case    3:  		/* mr R4, R28 */
		/* 821F0140h case    3:*/		regs.R4 = regs.R28;
		/* 821F0140h case    3:*/		return 0x821F0144;
		  /* 821F0144h */ case    4:  		/* mr R3, R30 */
		/* 821F0144h case    4:*/		regs.R3 = regs.R30;
		/* 821F0144h case    4:*/		return 0x821F0148;
		  /* 821F0148h */ case    5:  		/* bl -491848 */
		/* 821F0148h case    5:*/		regs.LR = 0x821F014C; return 0x82178000;
		/* 821F0148h case    5:*/		return 0x821F014C;
		  /* 821F014Ch */ case    6:  		/* mr R4, R3 */
		/* 821F014Ch case    6:*/		regs.R4 = regs.R3;
		/* 821F014Ch case    6:*/		return 0x821F0150;
		  /* 821F0150h */ case    7:  		/* mr R3, R31 */
		/* 821F0150h case    7:*/		regs.R3 = regs.R31;
		/* 821F0150h case    7:*/		return 0x821F0154;
		  /* 821F0154h */ case    8:  		/* bl -491404 */
		/* 821F0154h case    8:*/		regs.LR = 0x821F0158; return 0x821781C8;
		/* 821F0154h case    8:*/		return 0x821F0158;
		  /* 821F0158h */ case    9:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F0158h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0158h case    9:*/		return 0x821F015C;
		  /* 821F015Ch */ case   10:  		/* stw R3, <#[R31 + 48]> */
		/* 821F015Ch case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F015Ch case   10:*/		return 0x821F0160;
		  /* 821F0160h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0160h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0160h case   11:*/		return 0x821F0164;
		  /* 821F0164h */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F0164h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0164h case   12:*/		return 0x821F0168;
		  /* 821F0168h */ case   13:  		/* mr R3, R31 */
		/* 821F0168h case   13:*/		regs.R3 = regs.R31;
		/* 821F0168h case   13:*/		return 0x821F016C;
		  /* 821F016Ch */ case   14:  		/* addi R11, R11, 36 */
		/* 821F016Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F016Ch case   14:*/		return 0x821F0170;
		  /* 821F0170h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 821F0170h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0170h case   15:*/		return 0x821F0174;
		  /* 821F0174h */ case   16:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F0174h case   16:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F0174h case   16:*/		return 0x821F0178;
		  /* 821F0178h */ case   17:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0178h case   17:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0178h case   17:*/		return 0x821F017C;
		  /* 821F017Ch */ case   18:  		/* addi R8, R11, -36 */
		/* 821F017Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F017Ch case   18:*/		return 0x821F0180;
		  /* 821F0180h */ case   19:  		/* stw R9, <#[R31 + 8]> */
		/* 821F0180h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0180h case   19:*/		return 0x821F0184;
		  /* 821F0184h */ case   20:  		/* addi R9, R11, 4 */
		/* 821F0184h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F0184h case   20:*/		return 0x821F0188;
		  /* 821F0188h */ case   21:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F0188h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F0188h case   21:*/		return 0x821F018C;
		  /* 821F018Ch */ case   22:  		/* addi R10, R10, 24 */
		/* 821F018Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F018Ch case   22:*/		return 0x821F0190;
		  /* 821F0190h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F0190h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0190h case   23:*/		return 0x821F0194;
		  /* 821F0194h */ case   24:  		/* addi R6, R10, -36 */
		/* 821F0194h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F0194h case   24:*/		return 0x821F0198;
		  /* 821F0198h */ case   25:  		/* stw R7, <#[R11]> */
		/* 821F0198h case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0198h case   25:*/		return 0x821F019C;
		  /* 821F019Ch */ case   26:  		/* lwz R7, <#[R10]> */
		/* 821F019Ch case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F019Ch case   26:*/		return 0x821F01A0;
		  /* 821F01A0h */ case   27:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F01A0h case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F01A0h case   27:*/		return 0x821F01A4;
		  /* 821F01A4h */ case   28:  		/* ori R6, R6, 1 */
		/* 821F01A4h case   28:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F01A4h case   28:*/		return 0x821F01A8;
		  /* 821F01A8h */ case   29:  		/* stw R8, <#[R7]> */
		/* 821F01A8h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F01A8h case   29:*/		return 0x821F01AC;
		  /* 821F01ACh */ case   30:  		/* stw R6, <#[R11 + 4]> */
		/* 821F01ACh case   30:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F01ACh case   30:*/		return 0x821F01B0;
		  /* 821F01B0h */ case   31:  		/* stw R9, <#[R10]> */
		/* 821F01B0h case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F01B0h case   31:*/		return 0x821F01B4;
		  /* 821F01B4h */ case   32:  		/* addi R1, R1, 128 */
		/* 821F01B4h case   32:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F01B4h case   32:*/		return 0x821F01B8;
		  /* 821F01B8h */ case   33:  		/* b -1437456 */
		/* 821F01B8h case   33:*/		return 0x820912A8;
		/* 821F01B8h case   33:*/		return 0x821F01BC;
		  /* 821F01BCh */ case   34:  		/* nop */
		/* 821F01BCh case   34:*/		cpu::op::nop();
		/* 821F01BCh case   34:*/		return 0x821F01C0;
	}
	return 0x821F01C0;
} // Block from 821F0134h-821F01C0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821F01C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F01C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F01C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F01C0);
		  /* 821F01C0h */ case    0:  		/* mfspr R12, LR */
		/* 821F01C0h case    0:*/		regs.R12 = regs.LR;
		/* 821F01C0h case    0:*/		return 0x821F01C4;
		  /* 821F01C4h */ case    1:  		/* bl -1437548 */
		/* 821F01C4h case    1:*/		regs.LR = 0x821F01C8; return 0x82091258;
		/* 821F01C4h case    1:*/		return 0x821F01C8;
		  /* 821F01C8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F01C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F01C8h case    2:*/		return 0x821F01CC;
		  /* 821F01CCh */ case    3:  		/* mr R28, R5 */
		/* 821F01CCh case    3:*/		regs.R28 = regs.R5;
		/* 821F01CCh case    3:*/		return 0x821F01D0;
	}
	return 0x821F01D0;
} // Block from 821F01C0h-821F01D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F01D0h
// Function '?MakeInstr_T_SET_GRADIENTS_V@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F01D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F01D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F01D0);
		  /* 821F01D0h */ case    0:  		/* li R8, 4 */
		/* 821F01D0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F01D0h case    0:*/		return 0x821F01D4;
		  /* 821F01D4h */ case    1:  		/* li R7, 2 */
		/* 821F01D4h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F01D4h case    1:*/		return 0x821F01D8;
		  /* 821F01D8h */ case    2:  		/* li R6, 6 */
		/* 821F01D8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 821F01D8h case    2:*/		return 0x821F01DC;
		  /* 821F01DCh */ case    3:  		/* li R5, 0 */
		/* 821F01DCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F01DCh case    3:*/		return 0x821F01E0;
		  /* 821F01E0h */ case    4:  		/* mr R29, R4 */
		/* 821F01E0h case    4:*/		regs.R29 = regs.R4;
		/* 821F01E0h case    4:*/		return 0x821F01E4;
		  /* 821F01E4h */ case    5:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F01E4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F01E4h case    5:*/		return 0x821F01E8;
		  /* 821F01E8h */ case    6:  		/* mr R30, R3 */
		/* 821F01E8h case    6:*/		regs.R30 = regs.R3;
		/* 821F01E8h case    6:*/		return 0x821F01EC;
		  /* 821F01ECh */ case    7:  		/* bl 214956 */
		/* 821F01ECh case    7:*/		regs.LR = 0x821F01F0; return 0x82224998;
		/* 821F01ECh case    7:*/		return 0x821F01F0;
		  /* 821F01F0h */ case    8:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F01F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F01F0h case    8:*/		return 0x821F01F4;
		  /* 821F01F4h */ case    9:  		/* mr R31, R3 */
		/* 821F01F4h case    9:*/		regs.R31 = regs.R3;
		/* 821F01F4h case    9:*/		return 0x821F01F8;
		  /* 821F01F8h */ case   10:  		/* mr R4, R29 */
		/* 821F01F8h case   10:*/		regs.R4 = regs.R29;
		/* 821F01F8h case   10:*/		return 0x821F01FC;
		  /* 821F01FCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821F01FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F01FCh case   11:*/		return 0x821F0200;
		  /* 821F0200h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 821F0200h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F0214;  }
		/* 821F0200h case   12:*/		return 0x821F0204;
		  /* 821F0204h */ case   13:  		/* mr R3, R30 */
		/* 821F0204h case   13:*/		regs.R3 = regs.R30;
		/* 821F0204h case   13:*/		return 0x821F0208;
		  /* 821F0208h */ case   14:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F0208h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F0208h case   14:*/		return 0x821F020C;
		  /* 821F020Ch */ case   15:  		/* bl -520476 */
		/* 821F020Ch case   15:*/		regs.LR = 0x821F0210; return 0x821710F0;
		/* 821F020Ch case   15:*/		return 0x821F0210;
		  /* 821F0210h */ case   16:  		/* mr R4, R3 */
		/* 821F0210h case   16:*/		regs.R4 = regs.R3;
		/* 821F0210h case   16:*/		return 0x821F0214;
	}
	return 0x821F0214;
} // Block from 821F01D0h-821F0214h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821F0214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0214);
		  /* 821F0214h */ case    0:  		/* mr R3, R31 */
		/* 821F0214h case    0:*/		regs.R3 = regs.R31;
		/* 821F0214h case    0:*/		return 0x821F0218;
		  /* 821F0218h */ case    1:  		/* bl -491600 */
		/* 821F0218h case    1:*/		regs.LR = 0x821F021C; return 0x821781C8;
		/* 821F0218h case    1:*/		return 0x821F021C;
		  /* 821F021Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F021Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F021Ch case    2:*/		return 0x821F0220;
		  /* 821F0220h */ case    3:  		/* mr R4, R28 */
		/* 821F0220h case    3:*/		regs.R4 = regs.R28;
		/* 821F0220h case    3:*/		return 0x821F0224;
		  /* 821F0224h */ case    4:  		/* mr R3, R30 */
		/* 821F0224h case    4:*/		regs.R3 = regs.R30;
		/* 821F0224h case    4:*/		return 0x821F0228;
		  /* 821F0228h */ case    5:  		/* bl -492072 */
		/* 821F0228h case    5:*/		regs.LR = 0x821F022C; return 0x82178000;
		/* 821F0228h case    5:*/		return 0x821F022C;
		  /* 821F022Ch */ case    6:  		/* mr R4, R3 */
		/* 821F022Ch case    6:*/		regs.R4 = regs.R3;
		/* 821F022Ch case    6:*/		return 0x821F0230;
		  /* 821F0230h */ case    7:  		/* mr R3, R31 */
		/* 821F0230h case    7:*/		regs.R3 = regs.R31;
		/* 821F0230h case    7:*/		return 0x821F0234;
		  /* 821F0234h */ case    8:  		/* bl -491628 */
		/* 821F0234h case    8:*/		regs.LR = 0x821F0238; return 0x821781C8;
		/* 821F0234h case    8:*/		return 0x821F0238;
		  /* 821F0238h */ case    9:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F0238h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0238h case    9:*/		return 0x821F023C;
		  /* 821F023Ch */ case   10:  		/* stw R3, <#[R31 + 48]> */
		/* 821F023Ch case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F023Ch case   10:*/		return 0x821F0240;
		  /* 821F0240h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0240h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0240h case   11:*/		return 0x821F0244;
		  /* 821F0244h */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F0244h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0244h case   12:*/		return 0x821F0248;
		  /* 821F0248h */ case   13:  		/* mr R3, R31 */
		/* 821F0248h case   13:*/		regs.R3 = regs.R31;
		/* 821F0248h case   13:*/		return 0x821F024C;
		  /* 821F024Ch */ case   14:  		/* addi R11, R11, 36 */
		/* 821F024Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F024Ch case   14:*/		return 0x821F0250;
		  /* 821F0250h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 821F0250h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0250h case   15:*/		return 0x821F0254;
		  /* 821F0254h */ case   16:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F0254h case   16:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F0254h case   16:*/		return 0x821F0258;
		  /* 821F0258h */ case   17:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0258h case   17:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0258h case   17:*/		return 0x821F025C;
		  /* 821F025Ch */ case   18:  		/* addi R8, R11, -36 */
		/* 821F025Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F025Ch case   18:*/		return 0x821F0260;
		  /* 821F0260h */ case   19:  		/* stw R9, <#[R31 + 8]> */
		/* 821F0260h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0260h case   19:*/		return 0x821F0264;
		  /* 821F0264h */ case   20:  		/* addi R9, R11, 4 */
		/* 821F0264h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F0264h case   20:*/		return 0x821F0268;
		  /* 821F0268h */ case   21:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F0268h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F0268h case   21:*/		return 0x821F026C;
		  /* 821F026Ch */ case   22:  		/* addi R10, R10, 24 */
		/* 821F026Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F026Ch case   22:*/		return 0x821F0270;
		  /* 821F0270h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F0270h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0270h case   23:*/		return 0x821F0274;
		  /* 821F0274h */ case   24:  		/* addi R6, R10, -36 */
		/* 821F0274h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F0274h case   24:*/		return 0x821F0278;
	}
	return 0x821F0278;
} // Block from 821F0214h-821F0278h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821F0278h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0278);
		  /* 821F0278h */ case    0:  		/* stw R7, <#[R11]> */
		/* 821F0278h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0278h case    0:*/		return 0x821F027C;
		  /* 821F027Ch */ case    1:  		/* lwz R7, <#[R10]> */
		/* 821F027Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F027Ch case    1:*/		return 0x821F0280;
		  /* 821F0280h */ case    2:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F0280h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F0280h case    2:*/		return 0x821F0284;
		  /* 821F0284h */ case    3:  		/* ori R6, R6, 1 */
		/* 821F0284h case    3:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F0284h case    3:*/		return 0x821F0288;
		  /* 821F0288h */ case    4:  		/* stw R8, <#[R7]> */
		/* 821F0288h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F0288h case    4:*/		return 0x821F028C;
		  /* 821F028Ch */ case    5:  		/* stw R6, <#[R11 + 4]> */
		/* 821F028Ch case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F028Ch case    5:*/		return 0x821F0290;
		  /* 821F0290h */ case    6:  		/* stw R9, <#[R10]> */
		/* 821F0290h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0290h case    6:*/		return 0x821F0294;
		  /* 821F0294h */ case    7:  		/* addi R1, R1, 128 */
		/* 821F0294h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F0294h case    7:*/		return 0x821F0298;
		  /* 821F0298h */ case    8:  		/* b -1437680 */
		/* 821F0298h case    8:*/		return 0x820912A8;
		/* 821F0298h case    8:*/		return 0x821F029C;
		  /* 821F029Ch */ case    9:  		/* nop */
		/* 821F029Ch case    9:*/		cpu::op::nop();
		/* 821F029Ch case    9:*/		return 0x821F02A0;
	}
	return 0x821F02A0;
} // Block from 821F0278h-821F02A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F02A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F02A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F02A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F02A0);
		  /* 821F02A0h */ case    0:  		/* mfspr R12, LR */
		/* 821F02A0h case    0:*/		regs.R12 = regs.LR;
		/* 821F02A0h case    0:*/		return 0x821F02A4;
		  /* 821F02A4h */ case    1:  		/* bl -1437772 */
		/* 821F02A4h case    1:*/		regs.LR = 0x821F02A8; return 0x82091258;
		/* 821F02A4h case    1:*/		return 0x821F02A8;
		  /* 821F02A8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F02A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F02A8h case    2:*/		return 0x821F02AC;
		  /* 821F02ACh */ case    3:  		/* mr R28, R5 */
		/* 821F02ACh case    3:*/		regs.R28 = regs.R5;
		/* 821F02ACh case    3:*/		return 0x821F02B0;
		  /* 821F02B0h */ case    4:  		/* li R8, 4 */
		/* 821F02B0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F02B0h case    4:*/		return 0x821F02B4;
		  /* 821F02B4h */ case    5:  		/* li R7, 2 */
		/* 821F02B4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F02B4h case    5:*/		return 0x821F02B8;
		  /* 821F02B8h */ case    6:  		/* li R6, 7 */
		/* 821F02B8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 821F02B8h case    6:*/		return 0x821F02BC;
		  /* 821F02BCh */ case    7:  		/* li R5, 0 */
		/* 821F02BCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F02BCh case    7:*/		return 0x821F02C0;
		  /* 821F02C0h */ case    8:  		/* mr R29, R4 */
		/* 821F02C0h case    8:*/		regs.R29 = regs.R4;
		/* 821F02C0h case    8:*/		return 0x821F02C4;
		  /* 821F02C4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F02C4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F02C4h case    9:*/		return 0x821F02C8;
		  /* 821F02C8h */ case   10:  		/* mr R30, R3 */
		/* 821F02C8h case   10:*/		regs.R30 = regs.R3;
		/* 821F02C8h case   10:*/		return 0x821F02CC;
		  /* 821F02CCh */ case   11:  		/* bl 214732 */
		/* 821F02CCh case   11:*/		regs.LR = 0x821F02D0; return 0x82224998;
		/* 821F02CCh case   11:*/		return 0x821F02D0;
		  /* 821F02D0h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F02D0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F02D0h case   12:*/		return 0x821F02D4;
		  /* 821F02D4h */ case   13:  		/* mr R31, R3 */
		/* 821F02D4h case   13:*/		regs.R31 = regs.R3;
		/* 821F02D4h case   13:*/		return 0x821F02D8;
		  /* 821F02D8h */ case   14:  		/* mr R4, R29 */
		/* 821F02D8h case   14:*/		regs.R4 = regs.R29;
		/* 821F02D8h case   14:*/		return 0x821F02DC;
		  /* 821F02DCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F02DCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F02DCh case   15:*/		return 0x821F02E0;
		  /* 821F02E0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F02E0h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F02F4;  }
		/* 821F02E0h case   16:*/		return 0x821F02E4;
		  /* 821F02E4h */ case   17:  		/* mr R3, R30 */
		/* 821F02E4h case   17:*/		regs.R3 = regs.R30;
		/* 821F02E4h case   17:*/		return 0x821F02E8;
		  /* 821F02E8h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F02E8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F02E8h case   18:*/		return 0x821F02EC;
		  /* 821F02ECh */ case   19:  		/* bl -520700 */
		/* 821F02ECh case   19:*/		regs.LR = 0x821F02F0; return 0x821710F0;
		/* 821F02ECh case   19:*/		return 0x821F02F0;
		  /* 821F02F0h */ case   20:  		/* mr R4, R3 */
		/* 821F02F0h case   20:*/		regs.R4 = regs.R3;
		/* 821F02F0h case   20:*/		return 0x821F02F4;
	}
	return 0x821F02F4;
} // Block from 821F02A0h-821F02F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F02F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F02F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F02F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F02F4);
		  /* 821F02F4h */ case    0:  		/* mr R3, R31 */
		/* 821F02F4h case    0:*/		regs.R3 = regs.R31;
		/* 821F02F4h case    0:*/		return 0x821F02F8;
		  /* 821F02F8h */ case    1:  		/* bl -491824 */
		/* 821F02F8h case    1:*/		regs.LR = 0x821F02FC; return 0x821781C8;
		/* 821F02F8h case    1:*/		return 0x821F02FC;
		  /* 821F02FCh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F02FCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F02FCh case    2:*/		return 0x821F0300;
		  /* 821F0300h */ case    3:  		/* mr R4, R28 */
		/* 821F0300h case    3:*/		regs.R4 = regs.R28;
		/* 821F0300h case    3:*/		return 0x821F0304;
		  /* 821F0304h */ case    4:  		/* mr R3, R30 */
		/* 821F0304h case    4:*/		regs.R3 = regs.R30;
		/* 821F0304h case    4:*/		return 0x821F0308;
		  /* 821F0308h */ case    5:  		/* bl -492296 */
		/* 821F0308h case    5:*/		regs.LR = 0x821F030C; return 0x82178000;
		/* 821F0308h case    5:*/		return 0x821F030C;
		  /* 821F030Ch */ case    6:  		/* mr R4, R3 */
		/* 821F030Ch case    6:*/		regs.R4 = regs.R3;
		/* 821F030Ch case    6:*/		return 0x821F0310;
		  /* 821F0310h */ case    7:  		/* mr R3, R31 */
		/* 821F0310h case    7:*/		regs.R3 = regs.R31;
		/* 821F0310h case    7:*/		return 0x821F0314;
		  /* 821F0314h */ case    8:  		/* bl -491852 */
		/* 821F0314h case    8:*/		regs.LR = 0x821F0318; return 0x821781C8;
		/* 821F0314h case    8:*/		return 0x821F0318;
		  /* 821F0318h */ case    9:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F0318h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0318h case    9:*/		return 0x821F031C;
		  /* 821F031Ch */ case   10:  		/* stw R3, <#[R31 + 48]> */
		/* 821F031Ch case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F031Ch case   10:*/		return 0x821F0320;
		  /* 821F0320h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0320h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0320h case   11:*/		return 0x821F0324;
		  /* 821F0324h */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F0324h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0324h case   12:*/		return 0x821F0328;
		  /* 821F0328h */ case   13:  		/* mr R3, R31 */
		/* 821F0328h case   13:*/		regs.R3 = regs.R31;
		/* 821F0328h case   13:*/		return 0x821F032C;
		  /* 821F032Ch */ case   14:  		/* addi R11, R11, 36 */
		/* 821F032Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F032Ch case   14:*/		return 0x821F0330;
		  /* 821F0330h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 821F0330h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0330h case   15:*/		return 0x821F0334;
		  /* 821F0334h */ case   16:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F0334h case   16:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F0334h case   16:*/		return 0x821F0338;
		  /* 821F0338h */ case   17:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0338h case   17:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0338h case   17:*/		return 0x821F033C;
		  /* 821F033Ch */ case   18:  		/* addi R8, R11, -36 */
		/* 821F033Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F033Ch case   18:*/		return 0x821F0340;
		  /* 821F0340h */ case   19:  		/* stw R9, <#[R31 + 8]> */
		/* 821F0340h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0340h case   19:*/		return 0x821F0344;
		  /* 821F0344h */ case   20:  		/* addi R9, R11, 4 */
		/* 821F0344h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F0344h case   20:*/		return 0x821F0348;
		  /* 821F0348h */ case   21:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F0348h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F0348h case   21:*/		return 0x821F034C;
		  /* 821F034Ch */ case   22:  		/* addi R10, R10, 24 */
		/* 821F034Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F034Ch case   22:*/		return 0x821F0350;
		  /* 821F0350h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F0350h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0350h case   23:*/		return 0x821F0354;
		  /* 821F0354h */ case   24:  		/* addi R6, R10, -36 */
		/* 821F0354h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F0354h case   24:*/		return 0x821F0358;
	}
	return 0x821F0358;
} // Block from 821F02F4h-821F0358h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821F0358h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0358);
		  /* 821F0358h */ case    0:  		/* stw R7, <#[R11]> */
		/* 821F0358h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0358h case    0:*/		return 0x821F035C;
		  /* 821F035Ch */ case    1:  		/* lwz R7, <#[R10]> */
		/* 821F035Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F035Ch case    1:*/		return 0x821F0360;
		  /* 821F0360h */ case    2:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F0360h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F0360h case    2:*/		return 0x821F0364;
		  /* 821F0364h */ case    3:  		/* ori R6, R6, 1 */
		/* 821F0364h case    3:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F0364h case    3:*/		return 0x821F0368;
		  /* 821F0368h */ case    4:  		/* stw R8, <#[R7]> */
		/* 821F0368h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F0368h case    4:*/		return 0x821F036C;
		  /* 821F036Ch */ case    5:  		/* stw R6, <#[R11 + 4]> */
		/* 821F036Ch case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F036Ch case    5:*/		return 0x821F0370;
		  /* 821F0370h */ case    6:  		/* stw R9, <#[R10]> */
		/* 821F0370h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0370h case    6:*/		return 0x821F0374;
		  /* 821F0374h */ case    7:  		/* addi R1, R1, 128 */
		/* 821F0374h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F0374h case    7:*/		return 0x821F0378;
		  /* 821F0378h */ case    8:  		/* b -1437904 */
		/* 821F0378h case    8:*/		return 0x820912A8;
		/* 821F0378h case    8:*/		return 0x821F037C;
		  /* 821F037Ch */ case    9:  		/* nop */
		/* 821F037Ch case    9:*/		cpu::op::nop();
		/* 821F037Ch case    9:*/		return 0x821F0380;
	}
	return 0x821F0380;
} // Block from 821F0358h-821F0380h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F0380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0380);
		  /* 821F0380h */ case    0:  		/* mfspr R12, LR */
		/* 821F0380h case    0:*/		regs.R12 = regs.LR;
		/* 821F0380h case    0:*/		return 0x821F0384;
		  /* 821F0384h */ case    1:  		/* bl -1437996 */
		/* 821F0384h case    1:*/		regs.LR = 0x821F0388; return 0x82091258;
		/* 821F0384h case    1:*/		return 0x821F0388;
		  /* 821F0388h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F0388h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F0388h case    2:*/		return 0x821F038C;
		  /* 821F038Ch */ case    3:  		/* mr R28, R5 */
		/* 821F038Ch case    3:*/		regs.R28 = regs.R5;
		/* 821F038Ch case    3:*/		return 0x821F0390;
		  /* 821F0390h */ case    4:  		/* li R8, 4 */
		/* 821F0390h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F0390h case    4:*/		return 0x821F0394;
		  /* 821F0394h */ case    5:  		/* li R7, 2 */
		/* 821F0394h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F0394h case    5:*/		return 0x821F0398;
		  /* 821F0398h */ case    6:  		/* li R6, 17 */
		/* 821F0398h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x11);
		/* 821F0398h case    6:*/		return 0x821F039C;
		  /* 821F039Ch */ case    7:  		/* li R5, 0 */
		/* 821F039Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F039Ch case    7:*/		return 0x821F03A0;
		  /* 821F03A0h */ case    8:  		/* mr R29, R4 */
		/* 821F03A0h case    8:*/		regs.R29 = regs.R4;
		/* 821F03A0h case    8:*/		return 0x821F03A4;
		  /* 821F03A4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F03A4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F03A4h case    9:*/		return 0x821F03A8;
		  /* 821F03A8h */ case   10:  		/* mr R30, R3 */
		/* 821F03A8h case   10:*/		regs.R30 = regs.R3;
		/* 821F03A8h case   10:*/		return 0x821F03AC;
		  /* 821F03ACh */ case   11:  		/* bl 214508 */
		/* 821F03ACh case   11:*/		regs.LR = 0x821F03B0; return 0x82224998;
		/* 821F03ACh case   11:*/		return 0x821F03B0;
		  /* 821F03B0h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F03B0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F03B0h case   12:*/		return 0x821F03B4;
		  /* 821F03B4h */ case   13:  		/* mr R31, R3 */
		/* 821F03B4h case   13:*/		regs.R31 = regs.R3;
		/* 821F03B4h case   13:*/		return 0x821F03B8;
		  /* 821F03B8h */ case   14:  		/* mr R4, R29 */
		/* 821F03B8h case   14:*/		regs.R4 = regs.R29;
		/* 821F03B8h case   14:*/		return 0x821F03BC;
		  /* 821F03BCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F03BCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F03BCh case   15:*/		return 0x821F03C0;
		  /* 821F03C0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F03C0h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F03D4;  }
		/* 821F03C0h case   16:*/		return 0x821F03C4;
		  /* 821F03C4h */ case   17:  		/* mr R3, R30 */
		/* 821F03C4h case   17:*/		regs.R3 = regs.R30;
		/* 821F03C4h case   17:*/		return 0x821F03C8;
		  /* 821F03C8h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F03C8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F03C8h case   18:*/		return 0x821F03CC;
		  /* 821F03CCh */ case   19:  		/* bl -520924 */
		/* 821F03CCh case   19:*/		regs.LR = 0x821F03D0; return 0x821710F0;
		/* 821F03CCh case   19:*/		return 0x821F03D0;
		  /* 821F03D0h */ case   20:  		/* mr R4, R3 */
		/* 821F03D0h case   20:*/		regs.R4 = regs.R3;
		/* 821F03D0h case   20:*/		return 0x821F03D4;
	}
	return 0x821F03D4;
} // Block from 821F0380h-821F03D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F03D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F03D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F03D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F03D4);
		  /* 821F03D4h */ case    0:  		/* mr R3, R31 */
		/* 821F03D4h case    0:*/		regs.R3 = regs.R31;
		/* 821F03D4h case    0:*/		return 0x821F03D8;
		  /* 821F03D8h */ case    1:  		/* bl -492048 */
		/* 821F03D8h case    1:*/		regs.LR = 0x821F03DC; return 0x821781C8;
		/* 821F03D8h case    1:*/		return 0x821F03DC;
		  /* 821F03DCh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F03DCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F03DCh case    2:*/		return 0x821F03E0;
		  /* 821F03E0h */ case    3:  		/* mr R4, R28 */
		/* 821F03E0h case    3:*/		regs.R4 = regs.R28;
		/* 821F03E0h case    3:*/		return 0x821F03E4;
		  /* 821F03E4h */ case    4:  		/* mr R3, R30 */
		/* 821F03E4h case    4:*/		regs.R3 = regs.R30;
		/* 821F03E4h case    4:*/		return 0x821F03E8;
		  /* 821F03E8h */ case    5:  		/* bl -492520 */
		/* 821F03E8h case    5:*/		regs.LR = 0x821F03EC; return 0x82178000;
		/* 821F03E8h case    5:*/		return 0x821F03EC;
		  /* 821F03ECh */ case    6:  		/* mr R4, R3 */
		/* 821F03ECh case    6:*/		regs.R4 = regs.R3;
		/* 821F03ECh case    6:*/		return 0x821F03F0;
		  /* 821F03F0h */ case    7:  		/* mr R3, R31 */
		/* 821F03F0h case    7:*/		regs.R3 = regs.R31;
		/* 821F03F0h case    7:*/		return 0x821F03F4;
		  /* 821F03F4h */ case    8:  		/* bl -492076 */
		/* 821F03F4h case    8:*/		regs.LR = 0x821F03F8; return 0x821781C8;
		/* 821F03F4h case    8:*/		return 0x821F03F8;
		  /* 821F03F8h */ case    9:  		/* lwz R10, <#[R31 + 8]> */
		/* 821F03F8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821F03F8h case    9:*/		return 0x821F03FC;
		  /* 821F03FCh */ case   10:  		/* li R9, 1 */
		/* 821F03FCh case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821F03FCh case   10:*/		return 0x821F0400;
		  /* 821F0400h */ case   11:  		/* stw R3, <#[R31 + 48]> */
		/* 821F0400h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F0400h case   11:*/		return 0x821F0404;
		  /* 821F0404h */ case   12:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0404h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0404h case   12:*/		return 0x821F0408;
		  /* 821F0408h */ case   13:  		/* rlwimi R10, R9, 14, 15, 17 */
		/* 821F0408h case   13:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R9);
		/* 821F0408h case   13:*/		return 0x821F040C;
		  /* 821F040Ch */ case   14:  		/* addi R11, R11, 36 */
		/* 821F040Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F040Ch case   14:*/		return 0x821F0410;
		  /* 821F0410h */ case   15:  		/* stw R10, <#[R31 + 8]> */
		/* 821F0410h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0410h case   15:*/		return 0x821F0414;
		  /* 821F0414h */ case   16:  		/* mr R3, R31 */
		/* 821F0414h case   16:*/		regs.R3 = regs.R31;
		/* 821F0414h case   16:*/		return 0x821F0418;
		  /* 821F0418h */ case   17:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F0418h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F0418h case   17:*/		return 0x821F041C;
		  /* 821F041Ch */ case   18:  		/* addi R10, R10, 24 */
		/* 821F041Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F041Ch case   18:*/		return 0x821F0420;
		  /* 821F0420h */ case   19:  		/* lwz R9, <#[R10]> */
		/* 821F0420h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0420h case   19:*/		return 0x821F0424;
		  /* 821F0424h */ case   20:  		/* addi R8, R10, -36 */
		/* 821F0424h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFDC);
		/* 821F0424h case   20:*/		return 0x821F0428;
		  /* 821F0428h */ case   21:  		/* stw R9, <#[R11]> */
		/* 821F0428h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0428h case   21:*/		return 0x821F042C;
		  /* 821F042Ch */ case   22:  		/* addi R9, R11, -36 */
		/* 821F042Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821F042Ch case   22:*/		return 0x821F0430;
		  /* 821F0430h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F0430h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0430h case   23:*/		return 0x821F0434;
		  /* 821F0434h */ case   24:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F0434h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F0434h case   24:*/		return 0x821F0438;
	}
	return 0x821F0438;
} // Block from 821F03D4h-821F0438h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821F0438h
// Function '?MakeInstr_V_MIN@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0438);
		  /* 821F0438h */ case    0:  		/* stw R9, <#[R7]> */
		/* 821F0438h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821F0438h case    0:*/		return 0x821F043C;
		  /* 821F043Ch */ case    1:  		/* ori R8, R8, 1 */
		/* 821F043Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F043Ch case    1:*/		return 0x821F0440;
		  /* 821F0440h */ case    2:  		/* addi R9, R11, 4 */
		/* 821F0440h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F0440h case    2:*/		return 0x821F0444;
		  /* 821F0444h */ case    3:  		/* stw R8, <#[R11 + 4]> */
		/* 821F0444h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F0444h case    3:*/		return 0x821F0448;
		  /* 821F0448h */ case    4:  		/* stw R9, <#[R10]> */
		/* 821F0448h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0448h case    4:*/		return 0x821F044C;
		  /* 821F044Ch */ case    5:  		/* addi R1, R1, 128 */
		/* 821F044Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F044Ch case    5:*/		return 0x821F0450;
		  /* 821F0450h */ case    6:  		/* b -1438120 */
		/* 821F0450h case    6:*/		return 0x820912A8;
		/* 821F0450h case    6:*/		return 0x821F0454;
		  /* 821F0454h */ case    7:  		/* nop */
		/* 821F0454h case    7:*/		cpu::op::nop();
		/* 821F0454h case    7:*/		return 0x821F0458;
	}
	return 0x821F0458;
} // Block from 821F0438h-821F0458h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F0458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0458);
		  /* 821F0458h */ case    0:  		/* mfspr R12, LR */
		/* 821F0458h case    0:*/		regs.R12 = regs.LR;
		/* 821F0458h case    0:*/		return 0x821F045C;
		  /* 821F045Ch */ case    1:  		/* bl -1438212 */
		/* 821F045Ch case    1:*/		regs.LR = 0x821F0460; return 0x82091258;
		/* 821F045Ch case    1:*/		return 0x821F0460;
		  /* 821F0460h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F0460h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F0460h case    2:*/		return 0x821F0464;
		  /* 821F0464h */ case    3:  		/* mr R29, R5 */
		/* 821F0464h case    3:*/		regs.R29 = regs.R5;
		/* 821F0464h case    3:*/		return 0x821F0468;
		  /* 821F0468h */ case    4:  		/* li R8, 4 */
		/* 821F0468h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F0468h case    4:*/		return 0x821F046C;
		  /* 821F046Ch */ case    5:  		/* li R7, 2 */
		/* 821F046Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F046Ch case    5:*/		return 0x821F0470;
		  /* 821F0470h */ case    6:  		/* li R6, 1 */
		/* 821F0470h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F0470h case    6:*/		return 0x821F0474;
		  /* 821F0474h */ case    7:  		/* li R5, 0 */
		/* 821F0474h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0474h case    7:*/		return 0x821F0478;
		  /* 821F0478h */ case    8:  		/* mr R30, R4 */
		/* 821F0478h case    8:*/		regs.R30 = regs.R4;
		/* 821F0478h case    8:*/		return 0x821F047C;
		  /* 821F047Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F047Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F047Ch case    9:*/		return 0x821F0480;
		  /* 821F0480h */ case   10:  		/* mr R31, R3 */
		/* 821F0480h case   10:*/		regs.R31 = regs.R3;
		/* 821F0480h case   10:*/		return 0x821F0484;
		  /* 821F0484h */ case   11:  		/* bl 214292 */
		/* 821F0484h case   11:*/		regs.LR = 0x821F0488; return 0x82224998;
		/* 821F0484h case   11:*/		return 0x821F0488;
		  /* 821F0488h */ case   12:  		/* mr R28, R3 */
		/* 821F0488h case   12:*/		regs.R28 = regs.R3;
		/* 821F0488h case   12:*/		return 0x821F048C;
		  /* 821F048Ch */ case   13:  		/* mr R4, R30 */
		/* 821F048Ch case   13:*/		regs.R4 = regs.R30;
		/* 821F048Ch case   13:*/		return 0x821F0490;
		  /* 821F0490h */ case   14:  		/* mr R3, R31 */
		/* 821F0490h case   14:*/		regs.R3 = regs.R31;
		/* 821F0490h case   14:*/		return 0x821F0494;
		  /* 821F0494h */ case   15:  		/* bl -492692 */
		/* 821F0494h case   15:*/		regs.LR = 0x821F0498; return 0x82178000;
		/* 821F0494h case   15:*/		return 0x821F0498;
		  /* 821F0498h */ case   16:  		/* mr R4, R3 */
		/* 821F0498h case   16:*/		regs.R4 = regs.R3;
		/* 821F0498h case   16:*/		return 0x821F049C;
		  /* 821F049Ch */ case   17:  		/* mr R3, R28 */
		/* 821F049Ch case   17:*/		regs.R3 = regs.R28;
		/* 821F049Ch case   17:*/		return 0x821F04A0;
		  /* 821F04A0h */ case   18:  		/* bl -492248 */
		/* 821F04A0h case   18:*/		regs.LR = 0x821F04A4; return 0x821781C8;
		/* 821F04A0h case   18:*/		return 0x821F04A4;
		  /* 821F04A4h */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 821F04A4h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F04A4h case   19:*/		return 0x821F04A8;
		  /* 821F04A8h */ case   20:  		/* mr R4, R29 */
		/* 821F04A8h case   20:*/		regs.R4 = regs.R29;
		/* 821F04A8h case   20:*/		return 0x821F04AC;
		  /* 821F04ACh */ case   21:  		/* mr R3, R31 */
		/* 821F04ACh case   21:*/		regs.R3 = regs.R31;
		/* 821F04ACh case   21:*/		return 0x821F04B0;
		  /* 821F04B0h */ case   22:  		/* bl -492720 */
		/* 821F04B0h case   22:*/		regs.LR = 0x821F04B4; return 0x82178000;
		/* 821F04B0h case   22:*/		return 0x821F04B4;
		  /* 821F04B4h */ case   23:  		/* mr R4, R3 */
		/* 821F04B4h case   23:*/		regs.R4 = regs.R3;
		/* 821F04B4h case   23:*/		return 0x821F04B8;
		  /* 821F04B8h */ case   24:  		/* mr R3, R28 */
		/* 821F04B8h case   24:*/		regs.R3 = regs.R28;
		/* 821F04B8h case   24:*/		return 0x821F04BC;
		  /* 821F04BCh */ case   25:  		/* bl -492276 */
		/* 821F04BCh case   25:*/		regs.LR = 0x821F04C0; return 0x821781C8;
		/* 821F04BCh case   25:*/		return 0x821F04C0;
		  /* 821F04C0h */ case   26:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F04C0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F04C0h case   26:*/		return 0x821F04C4;
		  /* 821F04C4h */ case   27:  		/* stw R3, <#[R28 + 48]> */
		/* 821F04C4h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F04C4h case   27:*/		return 0x821F04C8;
		  /* 821F04C8h */ case   28:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F04C8h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F04C8h case   28:*/		return 0x821F04CC;
		  /* 821F04CCh */ case   29:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F04CCh case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F04CCh case   29:*/		return 0x821F04D0;
		  /* 821F04D0h */ case   30:  		/* mr R3, R28 */
		/* 821F04D0h case   30:*/		regs.R3 = regs.R28;
		/* 821F04D0h case   30:*/		return 0x821F04D4;
		  /* 821F04D4h */ case   31:  		/* addi R11, R11, 36 */
		/* 821F04D4h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F04D4h case   31:*/		return 0x821F04D8;
		  /* 821F04D8h */ case   32:  		/* lwz R10, <#[R10]> */
		/* 821F04D8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F04D8h case   32:*/		return 0x821F04DC;
		  /* 821F04DCh */ case   33:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F04DCh case   33:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F04DCh case   33:*/		return 0x821F04E0;
		  /* 821F04E0h */ case   34:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F04E0h case   34:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F04E0h case   34:*/		return 0x821F04E4;
		  /* 821F04E4h */ case   35:  		/* addi R8, R11, -36 */
		/* 821F04E4h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F04E4h case   35:*/		return 0x821F04E8;
		  /* 821F04E8h */ case   36:  		/* stw R9, <#[R28 + 8]> */
		/* 821F04E8h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F04E8h case   36:*/		return 0x821F04EC;
		  /* 821F04ECh */ case   37:  		/* addi R9, R11, 4 */
		/* 821F04ECh case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F04ECh case   37:*/		return 0x821F04F0;
		  /* 821F04F0h */ case   38:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F04F0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F04F0h case   38:*/		return 0x821F04F4;
		  /* 821F04F4h */ case   39:  		/* addi R10, R10, 24 */
		/* 821F04F4h case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F04F4h case   39:*/		return 0x821F04F8;
		  /* 821F04F8h */ case   40:  		/* lwz R7, <#[R10]> */
		/* 821F04F8h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F04F8h case   40:*/		return 0x821F04FC;
		  /* 821F04FCh */ case   41:  		/* addi R6, R10, -36 */
		/* 821F04FCh case   41:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F04FCh case   41:*/		return 0x821F0500;
		  /* 821F0500h */ case   42:  		/* stw R7, <#[R11]> */
		/* 821F0500h case   42:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0500h case   42:*/		return 0x821F0504;
		  /* 821F0504h */ case   43:  		/* lwz R7, <#[R10]> */
		/* 821F0504h case   43:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0504h case   43:*/		return 0x821F0508;
		  /* 821F0508h */ case   44:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F0508h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F0508h case   44:*/		return 0x821F050C;
		  /* 821F050Ch */ case   45:  		/* ori R6, R6, 1 */
		/* 821F050Ch case   45:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F050Ch case   45:*/		return 0x821F0510;
		  /* 821F0510h */ case   46:  		/* stw R8, <#[R7]> */
		/* 821F0510h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F0510h case   46:*/		return 0x821F0514;
		  /* 821F0514h */ case   47:  		/* stw R6, <#[R11 + 4]> */
		/* 821F0514h case   47:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F0514h case   47:*/		return 0x821F0518;
	}
	return 0x821F0518;
} // Block from 821F0458h-821F0518h (48 instructions)

//////////////////////////////////////////////////////
// Block at 821F0518h
// Function '?MakeInstr_V_SETE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0518);
		  /* 821F0518h */ case    0:  		/* stw R9, <#[R10]> */
		/* 821F0518h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0518h case    0:*/		return 0x821F051C;
		  /* 821F051Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 821F051Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F051Ch case    1:*/		return 0x821F0520;
		  /* 821F0520h */ case    2:  		/* b -1438328 */
		/* 821F0520h case    2:*/		return 0x820912A8;
		/* 821F0520h case    2:*/		return 0x821F0524;
		  /* 821F0524h */ case    3:  		/* nop */
		/* 821F0524h case    3:*/		cpu::op::nop();
		/* 821F0524h case    3:*/		return 0x821F0528;
	}
	return 0x821F0528;
} // Block from 821F0518h-821F0528h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F0528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0528);
		  /* 821F0528h */ case    0:  		/* mfspr R12, LR */
		/* 821F0528h case    0:*/		regs.R12 = regs.LR;
		/* 821F0528h case    0:*/		return 0x821F052C;
		  /* 821F052Ch */ case    1:  		/* bl -1438420 */
		/* 821F052Ch case    1:*/		regs.LR = 0x821F0530; return 0x82091258;
		/* 821F052Ch case    1:*/		return 0x821F0530;
		  /* 821F0530h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F0530h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F0530h case    2:*/		return 0x821F0534;
		  /* 821F0534h */ case    3:  		/* mr R29, R5 */
		/* 821F0534h case    3:*/		regs.R29 = regs.R5;
		/* 821F0534h case    3:*/		return 0x821F0538;
		  /* 821F0538h */ case    4:  		/* li R8, 4 */
		/* 821F0538h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F0538h case    4:*/		return 0x821F053C;
		  /* 821F053Ch */ case    5:  		/* li R7, 2 */
		/* 821F053Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F053Ch case    5:*/		return 0x821F0540;
		  /* 821F0540h */ case    6:  		/* li R6, 2 */
		/* 821F0540h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F0540h case    6:*/		return 0x821F0544;
		  /* 821F0544h */ case    7:  		/* li R5, 0 */
		/* 821F0544h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0544h case    7:*/		return 0x821F0548;
		  /* 821F0548h */ case    8:  		/* mr R30, R4 */
		/* 821F0548h case    8:*/		regs.R30 = regs.R4;
		/* 821F0548h case    8:*/		return 0x821F054C;
		  /* 821F054Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F054Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F054Ch case    9:*/		return 0x821F0550;
		  /* 821F0550h */ case   10:  		/* mr R31, R3 */
		/* 821F0550h case   10:*/		regs.R31 = regs.R3;
		/* 821F0550h case   10:*/		return 0x821F0554;
		  /* 821F0554h */ case   11:  		/* bl 214084 */
		/* 821F0554h case   11:*/		regs.LR = 0x821F0558; return 0x82224998;
		/* 821F0554h case   11:*/		return 0x821F0558;
		  /* 821F0558h */ case   12:  		/* mr R28, R3 */
		/* 821F0558h case   12:*/		regs.R28 = regs.R3;
		/* 821F0558h case   12:*/		return 0x821F055C;
		  /* 821F055Ch */ case   13:  		/* mr R4, R30 */
		/* 821F055Ch case   13:*/		regs.R4 = regs.R30;
		/* 821F055Ch case   13:*/		return 0x821F0560;
		  /* 821F0560h */ case   14:  		/* mr R3, R31 */
		/* 821F0560h case   14:*/		regs.R3 = regs.R31;
		/* 821F0560h case   14:*/		return 0x821F0564;
		  /* 821F0564h */ case   15:  		/* bl -492900 */
		/* 821F0564h case   15:*/		regs.LR = 0x821F0568; return 0x82178000;
		/* 821F0564h case   15:*/		return 0x821F0568;
		  /* 821F0568h */ case   16:  		/* mr R4, R3 */
		/* 821F0568h case   16:*/		regs.R4 = regs.R3;
		/* 821F0568h case   16:*/		return 0x821F056C;
		  /* 821F056Ch */ case   17:  		/* mr R3, R28 */
		/* 821F056Ch case   17:*/		regs.R3 = regs.R28;
		/* 821F056Ch case   17:*/		return 0x821F0570;
		  /* 821F0570h */ case   18:  		/* bl -492456 */
		/* 821F0570h case   18:*/		regs.LR = 0x821F0574; return 0x821781C8;
		/* 821F0570h case   18:*/		return 0x821F0574;
		  /* 821F0574h */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 821F0574h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F0574h case   19:*/		return 0x821F0578;
		  /* 821F0578h */ case   20:  		/* mr R4, R29 */
		/* 821F0578h case   20:*/		regs.R4 = regs.R29;
		/* 821F0578h case   20:*/		return 0x821F057C;
		  /* 821F057Ch */ case   21:  		/* mr R3, R31 */
		/* 821F057Ch case   21:*/		regs.R3 = regs.R31;
		/* 821F057Ch case   21:*/		return 0x821F0580;
		  /* 821F0580h */ case   22:  		/* bl -492928 */
		/* 821F0580h case   22:*/		regs.LR = 0x821F0584; return 0x82178000;
		/* 821F0580h case   22:*/		return 0x821F0584;
		  /* 821F0584h */ case   23:  		/* mr R4, R3 */
		/* 821F0584h case   23:*/		regs.R4 = regs.R3;
		/* 821F0584h case   23:*/		return 0x821F0588;
		  /* 821F0588h */ case   24:  		/* mr R3, R28 */
		/* 821F0588h case   24:*/		regs.R3 = regs.R28;
		/* 821F0588h case   24:*/		return 0x821F058C;
		  /* 821F058Ch */ case   25:  		/* bl -492484 */
		/* 821F058Ch case   25:*/		regs.LR = 0x821F0590; return 0x821781C8;
		/* 821F058Ch case   25:*/		return 0x821F0590;
		  /* 821F0590h */ case   26:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F0590h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F0590h case   26:*/		return 0x821F0594;
		  /* 821F0594h */ case   27:  		/* stw R3, <#[R28 + 48]> */
		/* 821F0594h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F0594h case   27:*/		return 0x821F0598;
		  /* 821F0598h */ case   28:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F0598h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F0598h case   28:*/		return 0x821F059C;
		  /* 821F059Ch */ case   29:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F059Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F059Ch case   29:*/		return 0x821F05A0;
		  /* 821F05A0h */ case   30:  		/* mr R3, R28 */
		/* 821F05A0h case   30:*/		regs.R3 = regs.R28;
		/* 821F05A0h case   30:*/		return 0x821F05A4;
		  /* 821F05A4h */ case   31:  		/* addi R11, R11, 36 */
		/* 821F05A4h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F05A4h case   31:*/		return 0x821F05A8;
		  /* 821F05A8h */ case   32:  		/* lwz R10, <#[R10]> */
		/* 821F05A8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F05A8h case   32:*/		return 0x821F05AC;
		  /* 821F05ACh */ case   33:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F05ACh case   33:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F05ACh case   33:*/		return 0x821F05B0;
		  /* 821F05B0h */ case   34:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F05B0h case   34:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F05B0h case   34:*/		return 0x821F05B4;
		  /* 821F05B4h */ case   35:  		/* addi R8, R11, -36 */
		/* 821F05B4h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F05B4h case   35:*/		return 0x821F05B8;
		  /* 821F05B8h */ case   36:  		/* stw R9, <#[R28 + 8]> */
		/* 821F05B8h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F05B8h case   36:*/		return 0x821F05BC;
		  /* 821F05BCh */ case   37:  		/* addi R9, R11, 4 */
		/* 821F05BCh case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F05BCh case   37:*/		return 0x821F05C0;
		  /* 821F05C0h */ case   38:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F05C0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F05C0h case   38:*/		return 0x821F05C4;
		  /* 821F05C4h */ case   39:  		/* addi R10, R10, 24 */
		/* 821F05C4h case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F05C4h case   39:*/		return 0x821F05C8;
		  /* 821F05C8h */ case   40:  		/* lwz R7, <#[R10]> */
		/* 821F05C8h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F05C8h case   40:*/		return 0x821F05CC;
		  /* 821F05CCh */ case   41:  		/* addi R6, R10, -36 */
		/* 821F05CCh case   41:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F05CCh case   41:*/		return 0x821F05D0;
		  /* 821F05D0h */ case   42:  		/* stw R7, <#[R11]> */
		/* 821F05D0h case   42:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F05D0h case   42:*/		return 0x821F05D4;
		  /* 821F05D4h */ case   43:  		/* lwz R7, <#[R10]> */
		/* 821F05D4h case   43:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F05D4h case   43:*/		return 0x821F05D8;
		  /* 821F05D8h */ case   44:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F05D8h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F05D8h case   44:*/		return 0x821F05DC;
		  /* 821F05DCh */ case   45:  		/* ori R6, R6, 1 */
		/* 821F05DCh case   45:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F05DCh case   45:*/		return 0x821F05E0;
		  /* 821F05E0h */ case   46:  		/* stw R8, <#[R7]> */
		/* 821F05E0h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F05E0h case   46:*/		return 0x821F05E4;
		  /* 821F05E4h */ case   47:  		/* stw R6, <#[R11 + 4]> */
		/* 821F05E4h case   47:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F05E4h case   47:*/		return 0x821F05E8;
		  /* 821F05E8h */ case   48:  		/* stw R9, <#[R10]> */
		/* 821F05E8h case   48:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F05E8h case   48:*/		return 0x821F05EC;
		  /* 821F05ECh */ case   49:  		/* addi R1, R1, 128 */
		/* 821F05ECh case   49:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F05ECh case   49:*/		return 0x821F05F0;
		  /* 821F05F0h */ case   50:  		/* b -1438536 */
		/* 821F05F0h case   50:*/		return 0x820912A8;
		/* 821F05F0h case   50:*/		return 0x821F05F4;
		  /* 821F05F4h */ case   51:  		/* nop */
		/* 821F05F4h case   51:*/		cpu::op::nop();
		/* 821F05F4h case   51:*/		return 0x821F05F8;
	}
	return 0x821F05F8;
} // Block from 821F0528h-821F05F8h (52 instructions)

//////////////////////////////////////////////////////
// Block at 821F05F8h
// Function '?MakeInstr_V_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F05F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F05F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F05F8);
		  /* 821F05F8h */ case    0:  		/* mfspr R12, LR */
		/* 821F05F8h case    0:*/		regs.R12 = regs.LR;
		/* 821F05F8h case    0:*/		return 0x821F05FC;
		  /* 821F05FCh */ case    1:  		/* bl -1438628 */
		/* 821F05FCh case    1:*/		regs.LR = 0x821F0600; return 0x82091258;
		/* 821F05FCh case    1:*/		return 0x821F0600;
		  /* 821F0600h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F0600h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F0600h case    2:*/		return 0x821F0604;
		  /* 821F0604h */ case    3:  		/* mr R29, R5 */
		/* 821F0604h case    3:*/		regs.R29 = regs.R5;
		/* 821F0604h case    3:*/		return 0x821F0608;
		  /* 821F0608h */ case    4:  		/* li R8, 4 */
		/* 821F0608h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F0608h case    4:*/		return 0x821F060C;
		  /* 821F060Ch */ case    5:  		/* li R7, 2 */
		/* 821F060Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F060Ch case    5:*/		return 0x821F0610;
		  /* 821F0610h */ case    6:  		/* li R6, 5 */
		/* 821F0610h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 821F0610h case    6:*/		return 0x821F0614;
		  /* 821F0614h */ case    7:  		/* li R5, 0 */
		/* 821F0614h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0614h case    7:*/		return 0x821F0618;
		  /* 821F0618h */ case    8:  		/* mr R30, R4 */
		/* 821F0618h case    8:*/		regs.R30 = regs.R4;
		/* 821F0618h case    8:*/		return 0x821F061C;
		  /* 821F061Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F061Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F061Ch case    9:*/		return 0x821F0620;
		  /* 821F0620h */ case   10:  		/* mr R31, R3 */
		/* 821F0620h case   10:*/		regs.R31 = regs.R3;
		/* 821F0620h case   10:*/		return 0x821F0624;
		  /* 821F0624h */ case   11:  		/* bl 213876 */
		/* 821F0624h case   11:*/		regs.LR = 0x821F0628; return 0x82224998;
		/* 821F0624h case   11:*/		return 0x821F0628;
		  /* 821F0628h */ case   12:  		/* mr R28, R3 */
		/* 821F0628h case   12:*/		regs.R28 = regs.R3;
		/* 821F0628h case   12:*/		return 0x821F062C;
		  /* 821F062Ch */ case   13:  		/* mr R4, R30 */
		/* 821F062Ch case   13:*/		regs.R4 = regs.R30;
		/* 821F062Ch case   13:*/		return 0x821F0630;
		  /* 821F0630h */ case   14:  		/* mr R3, R31 */
		/* 821F0630h case   14:*/		regs.R3 = regs.R31;
		/* 821F0630h case   14:*/		return 0x821F0634;
		  /* 821F0634h */ case   15:  		/* bl -493108 */
		/* 821F0634h case   15:*/		regs.LR = 0x821F0638; return 0x82178000;
		/* 821F0634h case   15:*/		return 0x821F0638;
		  /* 821F0638h */ case   16:  		/* mr R4, R3 */
		/* 821F0638h case   16:*/		regs.R4 = regs.R3;
		/* 821F0638h case   16:*/		return 0x821F063C;
		  /* 821F063Ch */ case   17:  		/* mr R3, R28 */
		/* 821F063Ch case   17:*/		regs.R3 = regs.R28;
		/* 821F063Ch case   17:*/		return 0x821F0640;
		  /* 821F0640h */ case   18:  		/* bl -492664 */
		/* 821F0640h case   18:*/		regs.LR = 0x821F0644; return 0x821781C8;
		/* 821F0640h case   18:*/		return 0x821F0644;
		  /* 821F0644h */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 821F0644h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F0644h case   19:*/		return 0x821F0648;
		  /* 821F0648h */ case   20:  		/* mr R4, R29 */
		/* 821F0648h case   20:*/		regs.R4 = regs.R29;
		/* 821F0648h case   20:*/		return 0x821F064C;
		  /* 821F064Ch */ case   21:  		/* mr R3, R31 */
		/* 821F064Ch case   21:*/		regs.R3 = regs.R31;
		/* 821F064Ch case   21:*/		return 0x821F0650;
		  /* 821F0650h */ case   22:  		/* bl -493136 */
		/* 821F0650h case   22:*/		regs.LR = 0x821F0654; return 0x82178000;
		/* 821F0650h case   22:*/		return 0x821F0654;
		  /* 821F0654h */ case   23:  		/* mr R4, R3 */
		/* 821F0654h case   23:*/		regs.R4 = regs.R3;
		/* 821F0654h case   23:*/		return 0x821F0658;
		  /* 821F0658h */ case   24:  		/* mr R3, R28 */
		/* 821F0658h case   24:*/		regs.R3 = regs.R28;
		/* 821F0658h case   24:*/		return 0x821F065C;
		  /* 821F065Ch */ case   25:  		/* bl -492692 */
		/* 821F065Ch case   25:*/		regs.LR = 0x821F0660; return 0x821781C8;
		/* 821F065Ch case   25:*/		return 0x821F0660;
		  /* 821F0660h */ case   26:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F0660h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F0660h case   26:*/		return 0x821F0664;
		  /* 821F0664h */ case   27:  		/* stw R3, <#[R28 + 48]> */
		/* 821F0664h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F0664h case   27:*/		return 0x821F0668;
		  /* 821F0668h */ case   28:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F0668h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F0668h case   28:*/		return 0x821F066C;
		  /* 821F066Ch */ case   29:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F066Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F066Ch case   29:*/		return 0x821F0670;
		  /* 821F0670h */ case   30:  		/* mr R3, R28 */
		/* 821F0670h case   30:*/		regs.R3 = regs.R28;
		/* 821F0670h case   30:*/		return 0x821F0674;
		  /* 821F0674h */ case   31:  		/* addi R11, R11, 36 */
		/* 821F0674h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F0674h case   31:*/		return 0x821F0678;
		  /* 821F0678h */ case   32:  		/* lwz R10, <#[R10]> */
		/* 821F0678h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0678h case   32:*/		return 0x821F067C;
		  /* 821F067Ch */ case   33:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F067Ch case   33:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F067Ch case   33:*/		return 0x821F0680;
		  /* 821F0680h */ case   34:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0680h case   34:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0680h case   34:*/		return 0x821F0684;
		  /* 821F0684h */ case   35:  		/* addi R8, R11, -36 */
		/* 821F0684h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F0684h case   35:*/		return 0x821F0688;
		  /* 821F0688h */ case   36:  		/* stw R9, <#[R28 + 8]> */
		/* 821F0688h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F0688h case   36:*/		return 0x821F068C;
		  /* 821F068Ch */ case   37:  		/* addi R9, R11, 4 */
		/* 821F068Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F068Ch case   37:*/		return 0x821F0690;
		  /* 821F0690h */ case   38:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F0690h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F0690h case   38:*/		return 0x821F0694;
		  /* 821F0694h */ case   39:  		/* addi R10, R10, 24 */
		/* 821F0694h case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F0694h case   39:*/		return 0x821F0698;
		  /* 821F0698h */ case   40:  		/* lwz R7, <#[R10]> */
		/* 821F0698h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0698h case   40:*/		return 0x821F069C;
		  /* 821F069Ch */ case   41:  		/* addi R6, R10, -36 */
		/* 821F069Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F069Ch case   41:*/		return 0x821F06A0;
		  /* 821F06A0h */ case   42:  		/* stw R7, <#[R11]> */
		/* 821F06A0h case   42:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F06A0h case   42:*/		return 0x821F06A4;
		  /* 821F06A4h */ case   43:  		/* lwz R7, <#[R10]> */
		/* 821F06A4h case   43:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F06A4h case   43:*/		return 0x821F06A8;
		  /* 821F06A8h */ case   44:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F06A8h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F06A8h case   44:*/		return 0x821F06AC;
		  /* 821F06ACh */ case   45:  		/* ori R6, R6, 1 */
		/* 821F06ACh case   45:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F06ACh case   45:*/		return 0x821F06B0;
		  /* 821F06B0h */ case   46:  		/* stw R8, <#[R7]> */
		/* 821F06B0h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F06B0h case   46:*/		return 0x821F06B4;
		  /* 821F06B4h */ case   47:  		/* stw R6, <#[R11 + 4]> */
		/* 821F06B4h case   47:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F06B4h case   47:*/		return 0x821F06B8;
		  /* 821F06B8h */ case   48:  		/* stw R9, <#[R10]> */
		/* 821F06B8h case   48:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F06B8h case   48:*/		return 0x821F06BC;
		  /* 821F06BCh */ case   49:  		/* addi R1, R1, 128 */
		/* 821F06BCh case   49:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F06BCh case   49:*/		return 0x821F06C0;
		  /* 821F06C0h */ case   50:  		/* b -1438744 */
		/* 821F06C0h case   50:*/		return 0x820912A8;
		/* 821F06C0h case   50:*/		return 0x821F06C4;
		  /* 821F06C4h */ case   51:  		/* nop */
		/* 821F06C4h case   51:*/		cpu::op::nop();
		/* 821F06C4h case   51:*/		return 0x821F06C8;
	}
	return 0x821F06C8;
} // Block from 821F05F8h-821F06C8h (52 instructions)

//////////////////////////////////////////////////////
// Block at 821F06C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F06C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F06C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F06C8);
		  /* 821F06C8h */ case    0:  		/* mfspr R12, LR */
		/* 821F06C8h case    0:*/		regs.R12 = regs.LR;
		/* 821F06C8h case    0:*/		return 0x821F06CC;
		  /* 821F06CCh */ case    1:  		/* bl -1438840 */
		/* 821F06CCh case    1:*/		regs.LR = 0x821F06D0; return 0x82091254;
		/* 821F06CCh case    1:*/		return 0x821F06D0;
		  /* 821F06D0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F06D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F06D0h case    2:*/		return 0x821F06D4;
		  /* 821F06D4h */ case    3:  		/* mr R27, R5 */
		/* 821F06D4h case    3:*/		regs.R27 = regs.R5;
		/* 821F06D4h case    3:*/		return 0x821F06D8;
	}
	return 0x821F06D8;
} // Block from 821F06C8h-821F06D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F06D8h
// Function '?MakeInstr_V_FRACT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F06D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F06D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F06D8);
		  /* 821F06D8h */ case    0:  		/* mr R29, R6 */
		/* 821F06D8h case    0:*/		regs.R29 = regs.R6;
		/* 821F06D8h case    0:*/		return 0x821F06DC;
		  /* 821F06DCh */ case    1:  		/* li R8, 4 */
		/* 821F06DCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F06DCh case    1:*/		return 0x821F06E0;
		  /* 821F06E0h */ case    2:  		/* li R7, 3 */
		/* 821F06E0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821F06E0h case    2:*/		return 0x821F06E4;
		  /* 821F06E4h */ case    3:  		/* li R6, 14 */
		/* 821F06E4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0xE);
		/* 821F06E4h case    3:*/		return 0x821F06E8;
		  /* 821F06E8h */ case    4:  		/* li R5, 0 */
		/* 821F06E8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F06E8h case    4:*/		return 0x821F06EC;
		  /* 821F06ECh */ case    5:  		/* mr R28, R4 */
		/* 821F06ECh case    5:*/		regs.R28 = regs.R4;
		/* 821F06ECh case    5:*/		return 0x821F06F0;
		  /* 821F06F0h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F06F0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F06F0h case    6:*/		return 0x821F06F4;
		  /* 821F06F4h */ case    7:  		/* mr R30, R3 */
		/* 821F06F4h case    7:*/		regs.R30 = regs.R3;
		/* 821F06F4h case    7:*/		return 0x821F06F8;
		  /* 821F06F8h */ case    8:  		/* bl 213664 */
		/* 821F06F8h case    8:*/		regs.LR = 0x821F06FC; return 0x82224998;
		/* 821F06F8h case    8:*/		return 0x821F06FC;
		  /* 821F06FCh */ case    9:  		/* mr R31, R3 */
		/* 821F06FCh case    9:*/		regs.R31 = regs.R3;
		/* 821F06FCh case    9:*/		return 0x821F0700;
		  /* 821F0700h */ case   10:  		/* mr R3, R30 */
		/* 821F0700h case   10:*/		regs.R3 = regs.R30;
		/* 821F0700h case   10:*/		return 0x821F0704;
		  /* 821F0704h */ case   11:  		/* mr R4, R28 */
		/* 821F0704h case   11:*/		regs.R4 = regs.R28;
		/* 821F0704h case   11:*/		return 0x821F0708;
		  /* 821F0708h */ case   12:  		/* bl -493320 */
		/* 821F0708h case   12:*/		regs.LR = 0x821F070C; return 0x82178000;
		/* 821F0708h case   12:*/		return 0x821F070C;
		  /* 821F070Ch */ case   13:  		/* mr R4, R3 */
		/* 821F070Ch case   13:*/		regs.R4 = regs.R3;
		/* 821F070Ch case   13:*/		return 0x821F0710;
		  /* 821F0710h */ case   14:  		/* mr R3, R31 */
		/* 821F0710h case   14:*/		regs.R3 = regs.R31;
		/* 821F0710h case   14:*/		return 0x821F0714;
		  /* 821F0714h */ case   15:  		/* bl -492876 */
		/* 821F0714h case   15:*/		regs.LR = 0x821F0718; return 0x821781C8;
		/* 821F0714h case   15:*/		return 0x821F0718;
		  /* 821F0718h */ case   16:  		/* stw R3, <#[R31 + 44]> */
		/* 821F0718h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0718h case   16:*/		return 0x821F071C;
		  /* 821F071Ch */ case   17:  		/* mr R4, R27 */
		/* 821F071Ch case   17:*/		regs.R4 = regs.R27;
		/* 821F071Ch case   17:*/		return 0x821F0720;
		  /* 821F0720h */ case   18:  		/* mr R3, R30 */
		/* 821F0720h case   18:*/		regs.R3 = regs.R30;
		/* 821F0720h case   18:*/		return 0x821F0724;
		  /* 821F0724h */ case   19:  		/* bl -493348 */
		/* 821F0724h case   19:*/		regs.LR = 0x821F0728; return 0x82178000;
		/* 821F0724h case   19:*/		return 0x821F0728;
		  /* 821F0728h */ case   20:  		/* mr R4, R3 */
		/* 821F0728h case   20:*/		regs.R4 = regs.R3;
		/* 821F0728h case   20:*/		return 0x821F072C;
		  /* 821F072Ch */ case   21:  		/* mr R3, R31 */
		/* 821F072Ch case   21:*/		regs.R3 = regs.R31;
		/* 821F072Ch case   21:*/		return 0x821F0730;
		  /* 821F0730h */ case   22:  		/* bl -492904 */
		/* 821F0730h case   22:*/		regs.LR = 0x821F0734; return 0x821781C8;
		/* 821F0730h case   22:*/		return 0x821F0734;
		  /* 821F0734h */ case   23:  		/* stw R3, <#[R31 + 48]> */
		/* 821F0734h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F0734h case   23:*/		return 0x821F0738;
		  /* 821F0738h */ case   24:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F0738h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F0738h case   24:*/		return 0x821F073C;
		  /* 821F073Ch */ case   25:  		/* cmplwi CR6, R11, 0 */
		/* 821F073Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F073Ch case   25:*/		return 0x821F0740;
		  /* 821F0740h */ case   26:  		/* mr R4, R29 */
		/* 821F0740h case   26:*/		regs.R4 = regs.R29;
		/* 821F0740h case   26:*/		return 0x821F0744;
		  /* 821F0744h */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 821F0744h case   27:*/		if ( regs.CR[6].eq ) { return 0x821F0758;  }
		/* 821F0744h case   27:*/		return 0x821F0748;
		  /* 821F0748h */ case   28:  		/* mr R3, R30 */
		/* 821F0748h case   28:*/		regs.R3 = regs.R30;
		/* 821F0748h case   28:*/		return 0x821F074C;
		  /* 821F074Ch */ case   29:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F074Ch case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F074Ch case   29:*/		return 0x821F0750;
		  /* 821F0750h */ case   30:  		/* bl -521824 */
		/* 821F0750h case   30:*/		regs.LR = 0x821F0754; return 0x821710F0;
		/* 821F0750h case   30:*/		return 0x821F0754;
		  /* 821F0754h */ case   31:  		/* mr R4, R3 */
		/* 821F0754h case   31:*/		regs.R4 = regs.R3;
		/* 821F0754h case   31:*/		return 0x821F0758;
	}
	return 0x821F0758;
} // Block from 821F06D8h-821F0758h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F0758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0758);
		  /* 821F0758h */ case    0:  		/* mr R3, R31 */
		/* 821F0758h case    0:*/		regs.R3 = regs.R31;
		/* 821F0758h case    0:*/		return 0x821F075C;
		  /* 821F075Ch */ case    1:  		/* bl -492948 */
		/* 821F075Ch case    1:*/		regs.LR = 0x821F0760; return 0x821781C8;
		/* 821F075Ch case    1:*/		return 0x821F0760;
		  /* 821F0760h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F0760h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0760h case    2:*/		return 0x821F0764;
		  /* 821F0764h */ case    3:  		/* stw R3, <#[R31 + 52]> */
		/* 821F0764h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 821F0764h case    3:*/		return 0x821F0768;
		  /* 821F0768h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0768h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0768h case    4:*/		return 0x821F076C;
		  /* 821F076Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F076Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F076Ch case    5:*/		return 0x821F0770;
		  /* 821F0770h */ case    6:  		/* mr R3, R31 */
		/* 821F0770h case    6:*/		regs.R3 = regs.R31;
		/* 821F0770h case    6:*/		return 0x821F0774;
		  /* 821F0774h */ case    7:  		/* addi R11, R11, 36 */
		/* 821F0774h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F0774h case    7:*/		return 0x821F0778;
		  /* 821F0778h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821F0778h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0778h case    8:*/		return 0x821F077C;
		  /* 821F077Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F077Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F077Ch case    9:*/		return 0x821F0780;
	}
	return 0x821F0780;
} // Block from 821F0758h-821F0780h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F0780h
// Function '?MakeInstr_S_EXP_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0780);
		  /* 821F0780h */ case    0:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0780h case    0:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0780h case    0:*/		return 0x821F0784;
		  /* 821F0784h */ case    1:  		/* addi R8, R11, -36 */
		/* 821F0784h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F0784h case    1:*/		return 0x821F0788;
		  /* 821F0788h */ case    2:  		/* stw R9, <#[R31 + 8]> */
		/* 821F0788h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0788h case    2:*/		return 0x821F078C;
		  /* 821F078Ch */ case    3:  		/* addi R9, R11, 4 */
		/* 821F078Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F078Ch case    3:*/		return 0x821F0790;
		  /* 821F0790h */ case    4:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F0790h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F0790h case    4:*/		return 0x821F0794;
		  /* 821F0794h */ case    5:  		/* addi R10, R10, 24 */
		/* 821F0794h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F0794h case    5:*/		return 0x821F0798;
		  /* 821F0798h */ case    6:  		/* lwz R7, <#[R10]> */
		/* 821F0798h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0798h case    6:*/		return 0x821F079C;
		  /* 821F079Ch */ case    7:  		/* addi R6, R10, -36 */
		/* 821F079Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F079Ch case    7:*/		return 0x821F07A0;
		  /* 821F07A0h */ case    8:  		/* stw R7, <#[R11]> */
		/* 821F07A0h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F07A0h case    8:*/		return 0x821F07A4;
		  /* 821F07A4h */ case    9:  		/* lwz R7, <#[R10]> */
		/* 821F07A4h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F07A4h case    9:*/		return 0x821F07A8;
		  /* 821F07A8h */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F07A8h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F07A8h case   10:*/		return 0x821F07AC;
		  /* 821F07ACh */ case   11:  		/* ori R6, R6, 1 */
		/* 821F07ACh case   11:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F07ACh case   11:*/		return 0x821F07B0;
		  /* 821F07B0h */ case   12:  		/* stw R8, <#[R7]> */
		/* 821F07B0h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F07B0h case   12:*/		return 0x821F07B4;
		  /* 821F07B4h */ case   13:  		/* stw R6, <#[R11 + 4]> */
		/* 821F07B4h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F07B4h case   13:*/		return 0x821F07B8;
		  /* 821F07B8h */ case   14:  		/* stw R9, <#[R10]> */
		/* 821F07B8h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F07B8h case   14:*/		return 0x821F07BC;
		  /* 821F07BCh */ case   15:  		/* addi R1, R1, 128 */
		/* 821F07BCh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F07BCh case   15:*/		return 0x821F07C0;
		  /* 821F07C0h */ case   16:  		/* b -1439004 */
		/* 821F07C0h case   16:*/		return 0x820912A4;
		/* 821F07C0h case   16:*/		return 0x821F07C4;
		  /* 821F07C4h */ case   17:  		/* nop */
		/* 821F07C4h case   17:*/		cpu::op::nop();
		/* 821F07C4h case   17:*/		return 0x821F07C8;
	}
	return 0x821F07C8;
} // Block from 821F0780h-821F07C8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F07C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F07C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F07C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F07C8);
		  /* 821F07C8h */ case    0:  		/* mfspr R12, LR */
		/* 821F07C8h case    0:*/		regs.R12 = regs.LR;
		/* 821F07C8h case    0:*/		return 0x821F07CC;
		  /* 821F07CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F07CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F07CCh case    1:*/		return 0x821F07D0;
		  /* 821F07D0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F07D0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F07D0h case    2:*/		return 0x821F07D4;
		  /* 821F07D4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F07D4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F07D4h case    3:*/		return 0x821F07D8;
		  /* 821F07D8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F07D8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F07D8h case    4:*/		return 0x821F07DC;
		  /* 821F07DCh */ case    5:  		/* std R4, <#[R1 + 136]> */
		/* 821F07DCh case    5:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F07DCh case    5:*/		return 0x821F07E0;
		  /* 821F07E0h */ case    6:  		/* li R8, 4 */
		/* 821F07E0h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F07E0h case    6:*/		return 0x821F07E4;
		  /* 821F07E4h */ case    7:  		/* std R5, <#[R1 + 144]> */
		/* 821F07E4h case    7:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F07E4h case    7:*/		return 0x821F07E8;
		  /* 821F07E8h */ case    8:  		/* li R7, 2 */
		/* 821F07E8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F07E8h case    8:*/		return 0x821F07EC;
		  /* 821F07ECh */ case    9:  		/* li R6, 1 */
		/* 821F07ECh case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F07ECh case    9:*/		return 0x821F07F0;
		  /* 821F07F0h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F07F0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F07F0h case   10:*/		return 0x821F07F4;
		  /* 821F07F4h */ case   11:  		/* li R5, 0 */
		/* 821F07F4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F07F4h case   11:*/		return 0x821F07F8;
		  /* 821F07F8h */ case   12:  		/* mr R31, R3 */
		/* 821F07F8h case   12:*/		regs.R31 = regs.R3;
		/* 821F07F8h case   12:*/		return 0x821F07FC;
		  /* 821F07FCh */ case   13:  		/* bl 213404 */
		/* 821F07FCh case   13:*/		regs.LR = 0x821F0800; return 0x82224998;
		/* 821F07FCh case   13:*/		return 0x821F0800;
		  /* 821F0800h */ case   14:  		/* mr R30, R3 */
		/* 821F0800h case   14:*/		regs.R30 = regs.R3;
		/* 821F0800h case   14:*/		return 0x821F0804;
		  /* 821F0804h */ case   15:  		/* addi R4, R1, 136 */
		/* 821F0804h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F0804h case   15:*/		return 0x821F0808;
		  /* 821F0808h */ case   16:  		/* mr R3, R31 */
		/* 821F0808h case   16:*/		regs.R3 = regs.R31;
		/* 821F0808h case   16:*/		return 0x821F080C;
		  /* 821F080Ch */ case   17:  		/* bl 7028 */
		/* 821F080Ch case   17:*/		regs.LR = 0x821F0810; return 0x821F2380;
		/* 821F080Ch case   17:*/		return 0x821F0810;
		  /* 821F0810h */ case   18:  		/* mr R4, R3 */
		/* 821F0810h case   18:*/		regs.R4 = regs.R3;
		/* 821F0810h case   18:*/		return 0x821F0814;
		  /* 821F0814h */ case   19:  		/* mr R3, R30 */
		/* 821F0814h case   19:*/		regs.R3 = regs.R30;
		/* 821F0814h case   19:*/		return 0x821F0818;
	}
	return 0x821F0818;
} // Block from 821F07C8h-821F0818h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F0818h
// Function '?MakeInstr_S_LOG_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0818);
		  /* 821F0818h */ case    0:  		/* bl -493136 */
		/* 821F0818h case    0:*/		regs.LR = 0x821F081C; return 0x821781C8;
		/* 821F0818h case    0:*/		return 0x821F081C;
		  /* 821F081Ch */ case    1:  		/* stw R3, <#[R30 + 44]> */
		/* 821F081Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F081Ch case    1:*/		return 0x821F0820;
		  /* 821F0820h */ case    2:  		/* addi R4, R1, 144 */
		/* 821F0820h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F0820h case    2:*/		return 0x821F0824;
		  /* 821F0824h */ case    3:  		/* mr R3, R31 */
		/* 821F0824h case    3:*/		regs.R3 = regs.R31;
		/* 821F0824h case    3:*/		return 0x821F0828;
		  /* 821F0828h */ case    4:  		/* bl 7000 */
		/* 821F0828h case    4:*/		regs.LR = 0x821F082C; return 0x821F2380;
		/* 821F0828h case    4:*/		return 0x821F082C;
		  /* 821F082Ch */ case    5:  		/* mr R4, R3 */
		/* 821F082Ch case    5:*/		regs.R4 = regs.R3;
		/* 821F082Ch case    5:*/		return 0x821F0830;
		  /* 821F0830h */ case    6:  		/* mr R3, R30 */
		/* 821F0830h case    6:*/		regs.R3 = regs.R30;
		/* 821F0830h case    6:*/		return 0x821F0834;
		  /* 821F0834h */ case    7:  		/* bl -493164 */
		/* 821F0834h case    7:*/		regs.LR = 0x821F0838; return 0x821781C8;
		/* 821F0834h case    7:*/		return 0x821F0838;
		  /* 821F0838h */ case    8:  		/* lwz R10, <#[R30 + 44]> */
		/* 821F0838h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F0838h case    8:*/		return 0x821F083C;
		  /* 821F083Ch */ case    9:  		/* stw R3, <#[R30 + 48]> */
		/* 821F083Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 821F083Ch case    9:*/		return 0x821F0840;
		  /* 821F0840h */ case   10:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821F0840h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821F0840h case   10:*/		return 0x821F0844;
		  /* 821F0844h */ case   11:  		/* lwz R9, <#[R30 + 8]> */
		/* 821F0844h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821F0844h case   11:*/		return 0x821F0848;
		  /* 821F0848h */ case   12:  		/* mr R3, R30 */
		/* 821F0848h case   12:*/		regs.R3 = regs.R30;
		/* 821F0848h case   12:*/		return 0x821F084C;
		  /* 821F084Ch */ case   13:  		/* addi R11, R11, 36 */
		/* 821F084Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F084Ch case   13:*/		return 0x821F0850;
		  /* 821F0850h */ case   14:  		/* lwz R10, <#[R10]> */
		/* 821F0850h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0850h case   14:*/		return 0x821F0854;
		  /* 821F0854h */ case   15:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F0854h case   15:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F0854h case   15:*/		return 0x821F0858;
		  /* 821F0858h */ case   16:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0858h case   16:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0858h case   16:*/		return 0x821F085C;
		  /* 821F085Ch */ case   17:  		/* addi R8, R11, -36 */
		/* 821F085Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F085Ch case   17:*/		return 0x821F0860;
		  /* 821F0860h */ case   18:  		/* stw R9, <#[R30 + 8]> */
		/* 821F0860h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821F0860h case   18:*/		return 0x821F0864;
		  /* 821F0864h */ case   19:  		/* addi R9, R11, 4 */
		/* 821F0864h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F0864h case   19:*/		return 0x821F0868;
		  /* 821F0868h */ case   20:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F0868h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F0868h case   20:*/		return 0x821F086C;
		  /* 821F086Ch */ case   21:  		/* addi R10, R10, 24 */
		/* 821F086Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F086Ch case   21:*/		return 0x821F0870;
		  /* 821F0870h */ case   22:  		/* lwz R7, <#[R10]> */
		/* 821F0870h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0870h case   22:*/		return 0x821F0874;
		  /* 821F0874h */ case   23:  		/* addi R6, R10, -36 */
		/* 821F0874h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F0874h case   23:*/		return 0x821F0878;
		  /* 821F0878h */ case   24:  		/* stw R7, <#[R11]> */
		/* 821F0878h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0878h case   24:*/		return 0x821F087C;
		  /* 821F087Ch */ case   25:  		/* lwz R7, <#[R10]> */
		/* 821F087Ch case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F087Ch case   25:*/		return 0x821F0880;
		  /* 821F0880h */ case   26:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F0880h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F0880h case   26:*/		return 0x821F0884;
		  /* 821F0884h */ case   27:  		/* ori R6, R6, 1 */
		/* 821F0884h case   27:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F0884h case   27:*/		return 0x821F0888;
		  /* 821F0888h */ case   28:  		/* stw R8, <#[R7]> */
		/* 821F0888h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F0888h case   28:*/		return 0x821F088C;
		  /* 821F088Ch */ case   29:  		/* stw R6, <#[R11 + 4]> */
		/* 821F088Ch case   29:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F088Ch case   29:*/		return 0x821F0890;
		  /* 821F0890h */ case   30:  		/* stw R9, <#[R10]> */
		/* 821F0890h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0890h case   30:*/		return 0x821F0894;
		  /* 821F0894h */ case   31:  		/* addi R1, R1, 112 */
		/* 821F0894h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F0894h case   31:*/		return 0x821F0898;
		  /* 821F0898h */ case   32:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F0898h case   32:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F0898h case   32:*/		return 0x821F089C;
		  /* 821F089Ch */ case   33:  		/* mtspr LR, R12 */
		/* 821F089Ch case   33:*/		regs.LR = regs.R12;
		/* 821F089Ch case   33:*/		return 0x821F08A0;
		  /* 821F08A0h */ case   34:  		/* ld R30, <#[R1 - 24]> */
		/* 821F08A0h case   34:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F08A0h case   34:*/		return 0x821F08A4;
		  /* 821F08A4h */ case   35:  		/* ld R31, <#[R1 - 16]> */
		/* 821F08A4h case   35:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F08A4h case   35:*/		return 0x821F08A8;
		  /* 821F08A8h */ case   36:  		/* bclr 20, CR0_LT */
		/* 821F08A8h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F08A8h case   36:*/		return 0x821F08AC;
	}
	return 0x821F08AC;
} // Block from 821F0818h-821F08ACh (37 instructions)

//////////////////////////////////////////////////////
// Block at 821F08ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F08AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F08AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F08AC);
		  /* 821F08ACh */ case    0:  		/* nop */
		/* 821F08ACh case    0:*/		cpu::op::nop();
		/* 821F08ACh case    0:*/		return 0x821F08B0;
	}
	return 0x821F08B0;
} // Block from 821F08ACh-821F08B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F08B0h
// Function '?MakeInstr_S_RECIP_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F08B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F08B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F08B0);
		  /* 821F08B0h */ case    0:  		/* mfspr R12, LR */
		/* 821F08B0h case    0:*/		regs.R12 = regs.LR;
		/* 821F08B0h case    0:*/		return 0x821F08B4;
		  /* 821F08B4h */ case    1:  		/* bl -1439320 */
		/* 821F08B4h case    1:*/		regs.LR = 0x821F08B8; return 0x8209125C;
		/* 821F08B4h case    1:*/		return 0x821F08B8;
		  /* 821F08B8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F08B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F08B8h case    2:*/		return 0x821F08BC;
		  /* 821F08BCh */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F08BCh case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F08BCh case    3:*/		return 0x821F08C0;
		  /* 821F08C0h */ case    4:  		/* li R8, 4 */
		/* 821F08C0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F08C0h case    4:*/		return 0x821F08C4;
		  /* 821F08C4h */ case    5:  		/* std R6, <#[R1 + 152]> */
		/* 821F08C4h case    5:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000098) );
		/* 821F08C4h case    5:*/		return 0x821F08C8;
		  /* 821F08C8h */ case    6:  		/* li R7, 3 */
		/* 821F08C8h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821F08C8h case    6:*/		return 0x821F08CC;
		  /* 821F08CCh */ case    7:  		/* li R6, 13 */
		/* 821F08CCh case    7:*/		cpu::op::li<0>(regs,&regs.R6,0xD);
		/* 821F08CCh case    7:*/		return 0x821F08D0;
		  /* 821F08D0h */ case    8:  		/* li R5, 0 */
		/* 821F08D0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F08D0h case    8:*/		return 0x821F08D4;
		  /* 821F08D4h */ case    9:  		/* mr R29, R4 */
		/* 821F08D4h case    9:*/		regs.R29 = regs.R4;
		/* 821F08D4h case    9:*/		return 0x821F08D8;
		  /* 821F08D8h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F08D8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F08D8h case   10:*/		return 0x821F08DC;
		  /* 821F08DCh */ case   11:  		/* mr R30, R3 */
		/* 821F08DCh case   11:*/		regs.R30 = regs.R3;
		/* 821F08DCh case   11:*/		return 0x821F08E0;
		  /* 821F08E0h */ case   12:  		/* bl 213176 */
		/* 821F08E0h case   12:*/		regs.LR = 0x821F08E4; return 0x82224998;
		/* 821F08E0h case   12:*/		return 0x821F08E4;
		  /* 821F08E4h */ case   13:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F08E4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F08E4h case   13:*/		return 0x821F08E8;
		  /* 821F08E8h */ case   14:  		/* mr R31, R3 */
		/* 821F08E8h case   14:*/		regs.R31 = regs.R3;
		/* 821F08E8h case   14:*/		return 0x821F08EC;
		  /* 821F08ECh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F08ECh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F08ECh case   15:*/		return 0x821F08F0;
		  /* 821F08F0h */ case   16:  		/* mr R4, R29 */
		/* 821F08F0h case   16:*/		regs.R4 = regs.R29;
		/* 821F08F0h case   16:*/		return 0x821F08F4;
		  /* 821F08F4h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 821F08F4h case   17:*/		if ( regs.CR[6].eq ) { return 0x821F0908;  }
		/* 821F08F4h case   17:*/		return 0x821F08F8;
		  /* 821F08F8h */ case   18:  		/* mr R3, R30 */
		/* 821F08F8h case   18:*/		regs.R3 = regs.R30;
		/* 821F08F8h case   18:*/		return 0x821F08FC;
		  /* 821F08FCh */ case   19:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F08FCh case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F08FCh case   19:*/		return 0x821F0900;
		  /* 821F0900h */ case   20:  		/* bl -522256 */
		/* 821F0900h case   20:*/		regs.LR = 0x821F0904; return 0x821710F0;
		/* 821F0900h case   20:*/		return 0x821F0904;
		  /* 821F0904h */ case   21:  		/* mr R4, R3 */
		/* 821F0904h case   21:*/		regs.R4 = regs.R3;
		/* 821F0904h case   21:*/		return 0x821F0908;
	}
	return 0x821F0908;
} // Block from 821F08B0h-821F0908h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F0908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0908);
		  /* 821F0908h */ case    0:  		/* mr R3, R31 */
		/* 821F0908h case    0:*/		regs.R3 = regs.R31;
		/* 821F0908h case    0:*/		return 0x821F090C;
		  /* 821F090Ch */ case    1:  		/* bl -493380 */
		/* 821F090Ch case    1:*/		regs.LR = 0x821F0910; return 0x821781C8;
		/* 821F090Ch case    1:*/		return 0x821F0910;
		  /* 821F0910h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F0910h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0910h case    2:*/		return 0x821F0914;
		  /* 821F0914h */ case    3:  		/* addi R4, R1, 144 */
		/* 821F0914h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F0914h case    3:*/		return 0x821F0918;
		  /* 821F0918h */ case    4:  		/* mr R3, R30 */
		/* 821F0918h case    4:*/		regs.R3 = regs.R30;
		/* 821F0918h case    4:*/		return 0x821F091C;
		  /* 821F091Ch */ case    5:  		/* bl 6756 */
		/* 821F091Ch case    5:*/		regs.LR = 0x821F0920; return 0x821F2380;
		/* 821F091Ch case    5:*/		return 0x821F0920;
		  /* 821F0920h */ case    6:  		/* mr R4, R3 */
		/* 821F0920h case    6:*/		regs.R4 = regs.R3;
		/* 821F0920h case    6:*/		return 0x821F0924;
		  /* 821F0924h */ case    7:  		/* mr R3, R31 */
		/* 821F0924h case    7:*/		regs.R3 = regs.R31;
		/* 821F0924h case    7:*/		return 0x821F0928;
		  /* 821F0928h */ case    8:  		/* bl -493408 */
		/* 821F0928h case    8:*/		regs.LR = 0x821F092C; return 0x821781C8;
		/* 821F0928h case    8:*/		return 0x821F092C;
		  /* 821F092Ch */ case    9:  		/* stw R3, <#[R31 + 48]> */
		/* 821F092Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F092Ch case    9:*/		return 0x821F0930;
		  /* 821F0930h */ case   10:  		/* addi R4, R1, 152 */
		/* 821F0930h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 821F0930h case   10:*/		return 0x821F0934;
		  /* 821F0934h */ case   11:  		/* mr R3, R30 */
		/* 821F0934h case   11:*/		regs.R3 = regs.R30;
		/* 821F0934h case   11:*/		return 0x821F0938;
		  /* 821F0938h */ case   12:  		/* bl 6728 */
		/* 821F0938h case   12:*/		regs.LR = 0x821F093C; return 0x821F2380;
		/* 821F0938h case   12:*/		return 0x821F093C;
		  /* 821F093Ch */ case   13:  		/* mr R4, R3 */
		/* 821F093Ch case   13:*/		regs.R4 = regs.R3;
		/* 821F093Ch case   13:*/		return 0x821F0940;
		  /* 821F0940h */ case   14:  		/* mr R3, R31 */
		/* 821F0940h case   14:*/		regs.R3 = regs.R31;
		/* 821F0940h case   14:*/		return 0x821F0944;
		  /* 821F0944h */ case   15:  		/* bl -493436 */
		/* 821F0944h case   15:*/		regs.LR = 0x821F0948; return 0x821781C8;
		/* 821F0944h case   15:*/		return 0x821F0948;
	}
	return 0x821F0948;
} // Block from 821F0908h-821F0948h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F0948h
// Function '?MakeInstr_S_RECIPSQRT_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0948);
		  /* 821F0948h */ case    0:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F0948h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0948h case    0:*/		return 0x821F094C;
		  /* 821F094Ch */ case    1:  		/* stw R3, <#[R31 + 52]> */
		/* 821F094Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 821F094Ch case    1:*/		return 0x821F0950;
		  /* 821F0950h */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F0950h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F0950h case    2:*/		return 0x821F0954;
		  /* 821F0954h */ case    3:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F0954h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0954h case    3:*/		return 0x821F0958;
		  /* 821F0958h */ case    4:  		/* mr R3, R31 */
		/* 821F0958h case    4:*/		regs.R3 = regs.R31;
		/* 821F0958h case    4:*/		return 0x821F095C;
		  /* 821F095Ch */ case    5:  		/* addi R11, R11, 36 */
		/* 821F095Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F095Ch case    5:*/		return 0x821F0960;
		  /* 821F0960h */ case    6:  		/* lwz R10, <#[R10]> */
		/* 821F0960h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0960h case    6:*/		return 0x821F0964;
		  /* 821F0964h */ case    7:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F0964h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F0964h case    7:*/		return 0x821F0968;
		  /* 821F0968h */ case    8:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F0968h case    8:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F0968h case    8:*/		return 0x821F096C;
		  /* 821F096Ch */ case    9:  		/* addi R8, R11, -36 */
		/* 821F096Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F096Ch case    9:*/		return 0x821F0970;
		  /* 821F0970h */ case   10:  		/* stw R9, <#[R31 + 8]> */
		/* 821F0970h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F0970h case   10:*/		return 0x821F0974;
		  /* 821F0974h */ case   11:  		/* addi R9, R11, 4 */
		/* 821F0974h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F0974h case   11:*/		return 0x821F0978;
		  /* 821F0978h */ case   12:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F0978h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F0978h case   12:*/		return 0x821F097C;
		  /* 821F097Ch */ case   13:  		/* addi R10, R10, 24 */
		/* 821F097Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F097Ch case   13:*/		return 0x821F0980;
		  /* 821F0980h */ case   14:  		/* lwz R7, <#[R10]> */
		/* 821F0980h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0980h case   14:*/		return 0x821F0984;
		  /* 821F0984h */ case   15:  		/* addi R6, R10, -36 */
		/* 821F0984h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F0984h case   15:*/		return 0x821F0988;
		  /* 821F0988h */ case   16:  		/* stw R7, <#[R11]> */
		/* 821F0988h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0988h case   16:*/		return 0x821F098C;
		  /* 821F098Ch */ case   17:  		/* lwz R7, <#[R10]> */
		/* 821F098Ch case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F098Ch case   17:*/		return 0x821F0990;
		  /* 821F0990h */ case   18:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F0990h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F0990h case   18:*/		return 0x821F0994;
		  /* 821F0994h */ case   19:  		/* ori R6, R6, 1 */
		/* 821F0994h case   19:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F0994h case   19:*/		return 0x821F0998;
		  /* 821F0998h */ case   20:  		/* stw R8, <#[R7]> */
		/* 821F0998h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F0998h case   20:*/		return 0x821F099C;
		  /* 821F099Ch */ case   21:  		/* stw R6, <#[R11 + 4]> */
		/* 821F099Ch case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F099Ch case   21:*/		return 0x821F09A0;
		  /* 821F09A0h */ case   22:  		/* stw R9, <#[R10]> */
		/* 821F09A0h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F09A0h case   22:*/		return 0x821F09A4;
		  /* 821F09A4h */ case   23:  		/* addi R1, R1, 112 */
		/* 821F09A4h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F09A4h case   23:*/		return 0x821F09A8;
		  /* 821F09A8h */ case   24:  		/* b -1439484 */
		/* 821F09A8h case   24:*/		return 0x820912AC;
		/* 821F09A8h case   24:*/		return 0x821F09AC;
		  /* 821F09ACh */ case   25:  		/* nop */
		/* 821F09ACh case   25:*/		cpu::op::nop();
		/* 821F09ACh case   25:*/		return 0x821F09B0;
	}
	return 0x821F09B0;
} // Block from 821F0948h-821F09B0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821F09B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F09B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F09B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F09B0);
		  /* 821F09B0h */ case    0:  		/* mfspr R12, LR */
		/* 821F09B0h case    0:*/		regs.R12 = regs.LR;
		/* 821F09B0h case    0:*/		return 0x821F09B4;
		  /* 821F09B4h */ case    1:  		/* bl -1439580 */
		/* 821F09B4h case    1:*/		regs.LR = 0x821F09B8; return 0x82091258;
		/* 821F09B4h case    1:*/		return 0x821F09B8;
		  /* 821F09B8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F09B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F09B8h case    2:*/		return 0x821F09BC;
		  /* 821F09BCh */ case    3:  		/* lwz R11, <#[R3 + 80]> */
		/* 821F09BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 821F09BCh case    3:*/		return 0x821F09C0;
		  /* 821F09C0h */ case    4:  		/* mr R31, R3 */
		/* 821F09C0h case    4:*/		regs.R31 = regs.R3;
		/* 821F09C0h case    4:*/		return 0x821F09C4;
		  /* 821F09C4h */ case    5:  		/* mr R28, R4 */
		/* 821F09C4h case    5:*/		regs.R28 = regs.R4;
		/* 821F09C4h case    5:*/		return 0x821F09C8;
		  /* 821F09C8h */ case    6:  		/* mr R29, R5 */
		/* 821F09C8h case    6:*/		regs.R29 = regs.R5;
		/* 821F09C8h case    6:*/		return 0x821F09CC;
		  /* 821F09CCh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821F09CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F09CCh case    7:*/		return 0x821F09D0;
		  /* 821F09D0h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 821F09D0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821F09EC;  }
		/* 821F09D0h case    8:*/		return 0x821F09D4;
		  /* 821F09D4h */ case    9:  		/* lwz R11, <#[R5 + 20]> */
		/* 821F09D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 821F09D4h case    9:*/		return 0x821F09D8;
		  /* 821F09D8h */ case   10:  		/* li R5, 0 */
		/* 821F09D8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F09D8h case   10:*/		return 0x821F09DC;
		  /* 821F09DCh */ case   11:  		/* mr R3, R29 */
		/* 821F09DCh case   11:*/		regs.R3 = regs.R29;
		/* 821F09DCh case   11:*/		return 0x821F09E0;
	}
	return 0x821F09E0;
} // Block from 821F09B0h-821F09E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F09E0h
// Function '?MakeInstr_S_SQRT_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F09E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F09E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F09E0);
		  /* 821F09E0h */ case    0:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 821F09E0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 821F09E0h case    0:*/		return 0x821F09E4;
		  /* 821F09E4h */ case    1:  		/* bl -571820 */
		/* 821F09E4h case    1:*/		regs.LR = 0x821F09E8; return 0x82165038;
		/* 821F09E4h case    1:*/		return 0x821F09E8;
		  /* 821F09E8h */ case    2:  		/* stw R3, <#[R31 + 80]> */
		/* 821F09E8h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 821F09E8h case    2:*/		return 0x821F09EC;
	}
	return 0x821F09EC;
} // Block from 821F09E0h-821F09ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F09ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F09EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F09EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F09EC);
		  /* 821F09ECh */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 821F09ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 821F09ECh case    0:*/		return 0x821F09F0;
		  /* 821F09F0h */ case    1:  		/* rlwinm R30, R28, 2, 0, 29 */
		/* 821F09F0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R28);
		/* 821F09F0h case    1:*/		return 0x821F09F4;
		  /* 821F09F4h */ case    2:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821F09F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821F09F4h case    2:*/		return 0x821F09F8;
		  /* 821F09F8h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821F09F8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F09F8h case    3:*/		return 0x821F09FC;
		  /* 821F09FCh */ case    4:  		/* bc 4, CR6_EQ, 40 */
		/* 821F09FCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x821F0A24;  }
		/* 821F09FCh case    4:*/		return 0x821F0A00;
		  /* 821F0A00h */ case    5:  		/* lwz R11, <#[R29 + 12]> */
		/* 821F0A00h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F0A00h case    5:*/		return 0x821F0A04;
		  /* 821F0A04h */ case    6:  		/* mulli R10, R28, 40 */
		/* 821F0A04h case    6:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R28,0x28);
		/* 821F0A04h case    6:*/		return 0x821F0A08;
		  /* 821F0A08h */ case    7:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821F0A08h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821F0A08h case    7:*/		return 0x821F0A0C;
		  /* 821F0A0Ch */ case    8:  		/* rlwinm R4, R11, 0, 15, 28 */
		/* 821F0A0Ch case    8:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R4,regs.R11);
		/* 821F0A0Ch case    8:*/		return 0x821F0A10;
		  /* 821F0A10h */ case    9:  		/* li R5, 0 */
		/* 821F0A10h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0A10h case    9:*/		return 0x821F0A14;
		  /* 821F0A14h */ case   10:  		/* mr R3, R29 */
		/* 821F0A14h case   10:*/		regs.R3 = regs.R29;
		/* 821F0A14h case   10:*/		return 0x821F0A18;
		  /* 821F0A18h */ case   11:  		/* bl -571872 */
		/* 821F0A18h case   11:*/		regs.LR = 0x821F0A1C; return 0x82165038;
		/* 821F0A18h case   11:*/		return 0x821F0A1C;
		  /* 821F0A1Ch */ case   12:  		/* lwz R11, <#[R31 + 80]> */
		/* 821F0A1Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 821F0A1Ch case   12:*/		return 0x821F0A20;
		  /* 821F0A20h */ case   13:  		/* stwx R3, <#[R30 + R11]> */
		/* 821F0A20h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821F0A20h case   13:*/		return 0x821F0A24;
	}
	return 0x821F0A24;
} // Block from 821F09ECh-821F0A24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F0A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0A24);
		  /* 821F0A24h */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 821F0A24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 821F0A24h case    0:*/		return 0x821F0A28;
		  /* 821F0A28h */ case    1:  		/* lwzx R3, <#[R30 + R11]> */
		/* 821F0A28h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821F0A28h case    1:*/		return 0x821F0A2C;
		  /* 821F0A2Ch */ case    2:  		/* addi R1, R1, 128 */
		/* 821F0A2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F0A2Ch case    2:*/		return 0x821F0A30;
		  /* 821F0A30h */ case    3:  		/* b -1439624 */
		/* 821F0A30h case    3:*/		return 0x820912A8;
		/* 821F0A30h case    3:*/		return 0x821F0A34;
		  /* 821F0A34h */ case    4:  		/* nop */
		/* 821F0A34h case    4:*/		cpu::op::nop();
		/* 821F0A34h case    4:*/		return 0x821F0A38;
	}
	return 0x821F0A38;
} // Block from 821F0A24h-821F0A38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F0A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0A38);
		  /* 821F0A38h */ case    0:  		/* mfspr R12, LR */
		/* 821F0A38h case    0:*/		regs.R12 = regs.LR;
		/* 821F0A38h case    0:*/		return 0x821F0A3C;
		  /* 821F0A3Ch */ case    1:  		/* bl -1439716 */
		/* 821F0A3Ch case    1:*/		regs.LR = 0x821F0A40; return 0x82091258;
		/* 821F0A3Ch case    1:*/		return 0x821F0A40;
		  /* 821F0A40h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821F0A40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821F0A40h case    2:*/		return 0x821F0A44;
		  /* 821F0A44h */ case    3:  		/* mr R30, R4 */
		/* 821F0A44h case    3:*/		regs.R30 = regs.R4;
		/* 821F0A44h case    3:*/		return 0x821F0A48;
		  /* 821F0A48h */ case    4:  		/* mr R29, R5 */
		/* 821F0A48h case    4:*/		regs.R29 = regs.R5;
		/* 821F0A48h case    4:*/		return 0x821F0A4C;
		  /* 821F0A4Ch */ case    5:  		/* li R5, 0 */
		/* 821F0A4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0A4Ch case    5:*/		return 0x821F0A50;
		  /* 821F0A50h */ case    6:  		/* li R4, 5 */
		/* 821F0A50h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 821F0A50h case    6:*/		return 0x821F0A54;
		  /* 821F0A54h */ case    7:  		/* mr R31, R3 */
		/* 821F0A54h case    7:*/		regs.R31 = regs.R3;
		/* 821F0A54h case    7:*/		return 0x821F0A58;
		  /* 821F0A58h */ case    8:  		/* bl -11152 */
		/* 821F0A58h case    8:*/		regs.LR = 0x821F0A5C; return 0x821EDEC8;
		/* 821F0A58h case    8:*/		return 0x821F0A5C;
		  /* 821F0A5Ch */ case    9:  		/* lis R11, -32253 */
		/* 821F0A5Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 821F0A5Ch case    9:*/		return 0x821F0A60;
		  /* 821F0A60h */ case   10:  		/* mr R7, R29 */
		/* 821F0A60h case   10:*/		regs.R7 = regs.R29;
		/* 821F0A60h case   10:*/		return 0x821F0A64;
		  /* 821F0A64h */ case   11:  		/* addi R5, R11, 28280 */
		/* 821F0A64h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x6E78);
		/* 821F0A64h case   11:*/		return 0x821F0A68;
		  /* 821F0A68h */ case   12:  		/* extsb R6, R30 */
		/* 821F0A68h case   12:*/		cpu::op::extsb<0>(regs,&regs.R6,regs.R30);
		/* 821F0A68h case   12:*/		return 0x821F0A6C;
		  /* 821F0A6Ch */ case   13:  		/* li R4, 5 */
		/* 821F0A6Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x5);
		/* 821F0A6Ch case   13:*/		return 0x821F0A70;
		  /* 821F0A70h */ case   14:  		/* mr R28, R3 */
		/* 821F0A70h case   14:*/		regs.R28 = regs.R3;
		/* 821F0A70h case   14:*/		return 0x821F0A74;
		  /* 821F0A74h */ case   15:  		/* bl 492340 */
		/* 821F0A74h case   15:*/		regs.LR = 0x821F0A78; return 0x82268DA8;
		/* 821F0A74h case   15:*/		return 0x821F0A78;
	}
	return 0x821F0A78;
} // Block from 821F0A38h-821F0A78h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F0A78h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0A78);
		  /* 821F0A78h */ case    0:  		/* mr R3, R31 */
		/* 821F0A78h case    0:*/		regs.R3 = regs.R31;
		/* 821F0A78h case    0:*/		return 0x821F0A7C;
		  /* 821F0A7Ch */ case    1:  		/* li R5, 14 */
		/* 821F0A7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xE);
		/* 821F0A7Ch case    1:*/		return 0x821F0A80;
		  /* 821F0A80h */ case    2:  		/* li R4, 32 */
		/* 821F0A80h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 821F0A80h case    2:*/		return 0x821F0A84;
		  /* 821F0A84h */ case    3:  		/* bl -540380 */
		/* 821F0A84h case    3:*/		regs.LR = 0x821F0A88; return 0x8216CBA8;
		/* 821F0A84h case    3:*/		return 0x821F0A88;
		  /* 821F0A88h */ case    4:  		/* mr R30, R3 */
		/* 821F0A88h case    4:*/		regs.R30 = regs.R3;
		/* 821F0A88h case    4:*/		return 0x821F0A8C;
		  /* 821F0A8Ch */ case    5:  		/* addi R3, R1, 80 */
		/* 821F0A8Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F0A8Ch case    5:*/		return 0x821F0A90;
		  /* 821F0A90h */ case    6:  		/* bl -1196328 */
		/* 821F0A90h case    6:*/		regs.LR = 0x821F0A94; return 0x820CC968;
		/* 821F0A90h case    6:*/		return 0x821F0A94;
		  /* 821F0A94h */ case    7:  		/* lwz R10, <#[R1 + 80]> */
		/* 821F0A94h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821F0A94h case    7:*/		return 0x821F0A98;
		  /* 821F0A98h */ case    8:  		/* li R11, 18 */
		/* 821F0A98h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x12);
		/* 821F0A98h case    8:*/		return 0x821F0A9C;
		  /* 821F0A9Ch */ case    9:  		/* mr R4, R28 */
		/* 821F0A9Ch case    9:*/		regs.R4 = regs.R28;
		/* 821F0A9Ch case    9:*/		return 0x821F0AA0;
		  /* 821F0AA0h */ case   10:  		/* stw R11, <#[R30 + 4]> */
		/* 821F0AA0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F0AA0h case   10:*/		return 0x821F0AA4;
		  /* 821F0AA4h */ case   11:  		/* mr R3, R31 */
		/* 821F0AA4h case   11:*/		regs.R3 = regs.R31;
		/* 821F0AA4h case   11:*/		return 0x821F0AA8;
		  /* 821F0AA8h */ case   12:  		/* stw R10, <#[R30]> */
		/* 821F0AA8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F0AA8h case   12:*/		return 0x821F0AAC;
		  /* 821F0AACh */ case   13:  		/* bl -15388 */
		/* 821F0AACh case   13:*/		regs.LR = 0x821F0AB0; return 0x821ECE90;
		/* 821F0AACh case   13:*/		return 0x821F0AB0;
		  /* 821F0AB0h */ case   14:  		/* stw R3, <#[R30 + 20]> */
		/* 821F0AB0h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 821F0AB0h case   14:*/		return 0x821F0AB4;
		  /* 821F0AB4h */ case   15:  		/* mr R3, R30 */
		/* 821F0AB4h case   15:*/		regs.R3 = regs.R30;
		/* 821F0AB4h case   15:*/		return 0x821F0AB8;
		  /* 821F0AB8h */ case   16:  		/* addi R1, R1, 160 */
		/* 821F0AB8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821F0AB8h case   16:*/		return 0x821F0ABC;
		  /* 821F0ABCh */ case   17:  		/* b -1439764 */
		/* 821F0ABCh case   17:*/		return 0x820912A8;
		/* 821F0ABCh case   17:*/		return 0x821F0AC0;
	}
	return 0x821F0AC0;
} // Block from 821F0A78h-821F0AC0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F0AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0AC0);
		  /* 821F0AC0h */ case    0:  		/* mfspr R12, LR */
		/* 821F0AC0h case    0:*/		regs.R12 = regs.LR;
		/* 821F0AC0h case    0:*/		return 0x821F0AC4;
		  /* 821F0AC4h */ case    1:  		/* bl -1439860 */
		/* 821F0AC4h case    1:*/		regs.LR = 0x821F0AC8; return 0x82091250;
		/* 821F0AC4h case    1:*/		return 0x821F0AC8;
		  /* 821F0AC8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821F0AC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821F0AC8h case    2:*/		return 0x821F0ACC;
		  /* 821F0ACCh */ case    3:  		/* mr R30, R3 */
		/* 821F0ACCh case    3:*/		regs.R30 = regs.R3;
		/* 821F0ACCh case    3:*/		return 0x821F0AD0;
		  /* 821F0AD0h */ case    4:  		/* mr R27, R5 */
		/* 821F0AD0h case    4:*/		regs.R27 = regs.R5;
		/* 821F0AD0h case    4:*/		return 0x821F0AD4;
		  /* 821F0AD4h */ case    5:  		/* cmplwi CR6, R4, 15 */
		/* 821F0AD4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000F);
		/* 821F0AD4h case    5:*/		return 0x821F0AD8;
		  /* 821F0AD8h */ case    6:  		/* bc 4, CR6_LT, 136 */
		/* 821F0AD8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x821F0B60;  }
		/* 821F0AD8h case    6:*/		return 0x821F0ADC;
		  /* 821F0ADCh */ case    7:  		/* lis R11, -32217 */
		/* 821F0ADCh case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 821F0ADCh case    7:*/		return 0x821F0AE0;
		  /* 821F0AE0h */ case    8:  		/* rlwinm R28, R4, 2, 0, 29 */
		/* 821F0AE0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R4);
		/* 821F0AE0h case    8:*/		return 0x821F0AE4;
		  /* 821F0AE4h */ case    9:  		/* addi R29, R11, 22428 */
		/* 821F0AE4h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x579C);
		/* 821F0AE4h case    9:*/		return 0x821F0AE8;
		  /* 821F0AE8h */ case   10:  		/* lwzx R11, <#[R28 + R29]> */
		/* 821F0AE8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 821F0AE8h case   10:*/		return 0x821F0AEC;
		  /* 821F0AECh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821F0AECh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F0AECh case   11:*/		return 0x821F0AF0;
		  /* 821F0AF0h */ case   12:  		/* bc 12, CR6_EQ, 112 */
		/* 821F0AF0h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F0B60;  }
		/* 821F0AF0h case   12:*/		return 0x821F0AF4;
		  /* 821F0AF4h */ case   13:  		/* cmplwi CR6, R5, 9 */
		/* 821F0AF4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000009);
		/* 821F0AF4h case   13:*/		return 0x821F0AF8;
		  /* 821F0AF8h */ case   14:  		/* bc 12, CR6_GT, 104 */
		/* 821F0AF8h case   14:*/		if ( regs.CR[6].gt ) { return 0x821F0B60;  }
		/* 821F0AF8h case   14:*/		return 0x821F0AFC;
		  /* 821F0AFCh */ case   15:  		/* mr R10, R11 */
		/* 821F0AFCh case   15:*/		regs.R10 = regs.R11;
		/* 821F0AFCh case   15:*/		return 0x821F0B00;
		  /* 821F0B00h */ case   16:  		/* lbz R9, <#[R10]> */
		/* 821F0B00h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F0B00h case   16:*/		return 0x821F0B04;
		  /* 821F0B04h */ case   17:  		/* addi R10, R10, 1 */
		/* 821F0B04h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F0B04h case   17:*/		return 0x821F0B08;
		  /* 821F0B08h */ case   18:  		/* cmplwi CR6, R9, 0 */
		/* 821F0B08h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821F0B08h case   18:*/		return 0x821F0B0C;
		  /* 821F0B0Ch */ case   19:  		/* bc 4, CR6_EQ, -12 */
		/* 821F0B0Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x821F0B00;  }
		/* 821F0B0Ch case   19:*/		return 0x821F0B10;
		  /* 821F0B10h */ case   20:  		/* subf R11, R11, R10 */
		/* 821F0B10h case   20:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F0B10h case   20:*/		return 0x821F0B14;
		  /* 821F0B14h */ case   21:  		/* li R5, 0 */
		/* 821F0B14h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0B14h case   21:*/		return 0x821F0B18;
		  /* 821F0B18h */ case   22:  		/* addi R11, R11, -1 */
		/* 821F0B18h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F0B18h case   22:*/		return 0x821F0B1C;
		  /* 821F0B1Ch */ case   23:  		/* mr R3, R30 */
		/* 821F0B1Ch case   23:*/		regs.R3 = regs.R30;
		/* 821F0B1Ch case   23:*/		return 0x821F0B20;
		  /* 821F0B20h */ case   24:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 821F0B20h case   24:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 821F0B20h case   24:*/		return 0x821F0B24;
		  /* 821F0B24h */ case   25:  		/* addi R31, R11, 2 */
		/* 821F0B24h case   25:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x2);
		/* 821F0B24h case   25:*/		return 0x821F0B28;
		  /* 821F0B28h */ case   26:  		/* mr R4, R31 */
		/* 821F0B28h case   26:*/		regs.R4 = regs.R31;
		/* 821F0B28h case   26:*/		return 0x821F0B2C;
		  /* 821F0B2Ch */ case   27:  		/* bl -11364 */
		/* 821F0B2Ch case   27:*/		regs.LR = 0x821F0B30; return 0x821EDEC8;
		/* 821F0B2Ch case   27:*/		return 0x821F0B30;
		  /* 821F0B30h */ case   28:  		/* lis R11, -32252 */
		/* 821F0B30h case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821F0B30h case   28:*/		return 0x821F0B34;
		  /* 821F0B34h */ case   29:  		/* mr R7, R27 */
		/* 821F0B34h case   29:*/		regs.R7 = regs.R27;
		/* 821F0B34h case   29:*/		return 0x821F0B38;
		  /* 821F0B38h */ case   30:  		/* lwzx R6, <#[R28 + R29]> */
		/* 821F0B38h case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 821F0B38h case   30:*/		return 0x821F0B3C;
		  /* 821F0B3Ch */ case   31:  		/* addi R5, R11, -16884 */
		/* 821F0B3Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBE0C);
		/* 821F0B3Ch case   31:*/		return 0x821F0B40;
		  /* 821F0B40h */ case   32:  		/* mr R4, R31 */
		/* 821F0B40h case   32:*/		regs.R4 = regs.R31;
		/* 821F0B40h case   32:*/		return 0x821F0B44;
		  /* 821F0B44h */ case   33:  		/* mr R26, R3 */
		/* 821F0B44h case   33:*/		regs.R26 = regs.R3;
		/* 821F0B44h case   33:*/		return 0x821F0B48;
		  /* 821F0B48h */ case   34:  		/* bl 492128 */
		/* 821F0B48h case   34:*/		regs.LR = 0x821F0B4C; return 0x82268DA8;
		/* 821F0B48h case   34:*/		return 0x821F0B4C;
		  /* 821F0B4Ch */ case   35:  		/* mr R4, R26 */
		/* 821F0B4Ch case   35:*/		regs.R4 = regs.R26;
		/* 821F0B4Ch case   35:*/		return 0x821F0B50;
		  /* 821F0B50h */ case   36:  		/* mr R3, R30 */
		/* 821F0B50h case   36:*/		regs.R3 = regs.R30;
		/* 821F0B50h case   36:*/		return 0x821F0B54;
		  /* 821F0B54h */ case   37:  		/* bl -15556 */
		/* 821F0B54h case   37:*/		regs.LR = 0x821F0B58; return 0x821ECE90;
		/* 821F0B54h case   37:*/		return 0x821F0B58;
	}
	return 0x821F0B58;
} // Block from 821F0AC0h-821F0B58h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821F0B58h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0B58);
		  /* 821F0B58h */ case    0:  		/* addi R1, R1, 144 */
		/* 821F0B58h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821F0B58h case    0:*/		return 0x821F0B5C;
		  /* 821F0B5Ch */ case    1:  		/* b -1439932 */
		/* 821F0B5Ch case    1:*/		return 0x820912A0;
		/* 821F0B5Ch case    1:*/		return 0x821F0B60;
	}
	return 0x821F0B60;
} // Block from 821F0B58h-821F0B60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F0B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0B60);
		  /* 821F0B60h */ case    0:  		/* li R4, 4801 */
		/* 821F0B60h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F0B60h case    0:*/		return 0x821F0B64;
		  /* 821F0B64h */ case    1:  		/* mr R3, R30 */
		/* 821F0B64h case    1:*/		regs.R3 = regs.R30;
		/* 821F0B64h case    1:*/		return 0x821F0B68;
		  /* 821F0B68h */ case    2:  		/* bl -650496 */
		/* 821F0B68h case    2:*/		regs.LR = 0x821F0B6C; return 0x82151E68;
		/* 821F0B68h case    2:*/		return 0x821F0B6C;
		  /* 821F0B6Ch */ case    3:  		/* nop */
		/* 821F0B6Ch case    3:*/		cpu::op::nop();
		/* 821F0B6Ch case    3:*/		return 0x821F0B70;
	}
	return 0x821F0B70;
} // Block from 821F0B60h-821F0B70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F0B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0B70);
		  /* 821F0B70h */ case    0:  		/* mfspr R12, LR */
		/* 821F0B70h case    0:*/		regs.R12 = regs.LR;
		/* 821F0B70h case    0:*/		return 0x821F0B74;
		  /* 821F0B74h */ case    1:  		/* bl -1440072 */
		/* 821F0B74h case    1:*/		regs.LR = 0x821F0B78; return 0x8209122C;
		/* 821F0B74h case    1:*/		return 0x821F0B78;
		  /* 821F0B78h */ case    2:  		/* stwu R1, <#[R1 - 336]> */
		/* 821F0B78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 821F0B78h case    2:*/		return 0x821F0B7C;
		  /* 821F0B7Ch */ case    3:  		/* lwz R11, <#[R3 + 48]> */
		/* 821F0B7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 821F0B7Ch case    3:*/		return 0x821F0B80;
		  /* 821F0B80h */ case    4:  		/* lis R17, -1 */
		/* 821F0B80h case    4:*/		cpu::op::lis<0>(regs,&regs.R17,0xFFFFFFFF);
		/* 821F0B80h case    4:*/		return 0x821F0B84;
		  /* 821F0B84h */ case    5:  		/* mr R31, R3 */
		/* 821F0B84h case    5:*/		regs.R31 = regs.R3;
		/* 821F0B84h case    5:*/		return 0x821F0B88;
		  /* 821F0B88h */ case    6:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821F0B88h case    6:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821F0B88h case    6:*/		return 0x821F0B8C;
		  /* 821F0B8Ch */ case    7:  		/* mr R25, R4 */
		/* 821F0B8Ch case    7:*/		regs.R25 = regs.R4;
		/* 821F0B8Ch case    7:*/		return 0x821F0B90;
		  /* 821F0B90h */ case    8:  		/* mr R22, R5 */
		/* 821F0B90h case    8:*/		regs.R22 = regs.R5;
		/* 821F0B90h case    8:*/		return 0x821F0B94;
		  /* 821F0B94h */ case    9:  		/* mr R24, R6 */
		/* 821F0B94h case    9:*/		regs.R24 = regs.R6;
		/* 821F0B94h case    9:*/		return 0x821F0B98;
		  /* 821F0B98h */ case   10:  		/* mr R26, R7 */
		/* 821F0B98h case   10:*/		regs.R26 = regs.R7;
		/* 821F0B98h case   10:*/		return 0x821F0B9C;
		  /* 821F0B9Ch */ case   11:  		/* mr R23, R8 */
		/* 821F0B9Ch case   11:*/		regs.R23 = regs.R8;
		/* 821F0B9Ch case   11:*/		return 0x821F0BA0;
		  /* 821F0BA0h */ case   12:  		/* mr R18, R9 */
		/* 821F0BA0h case   12:*/		regs.R18 = regs.R9;
		/* 821F0BA0h case   12:*/		return 0x821F0BA4;
		  /* 821F0BA4h */ case   13:  		/* cmplw CR6, R11, R17 */
		/* 821F0BA4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 821F0BA4h case   13:*/		return 0x821F0BA8;
		  /* 821F0BA8h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 821F0BA8h case   14:*/		if ( regs.CR[6].eq ) { return 0x821F0BBC;  }
		/* 821F0BA8h case   14:*/		return 0x821F0BAC;
		  /* 821F0BACh */ case   15:  		/* lis R11, -32217 */
		/* 821F0BACh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 821F0BACh case   15:*/		return 0x821F0BB0;
		  /* 821F0BB0h */ case   16:  		/* li R28, 19 */
		/* 821F0BB0h case   16:*/		cpu::op::li<0>(regs,&regs.R28,0x13);
		/* 821F0BB0h case   16:*/		return 0x821F0BB4;
		  /* 821F0BB4h */ case   17:  		/* addi R20, R11, 21904 */
		/* 821F0BB4h case   17:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0x5590);
		/* 821F0BB4h case   17:*/		return 0x821F0BB8;
		  /* 821F0BB8h */ case   18:  		/* b 16 */
		/* 821F0BB8h case   18:*/		return 0x821F0BC8;
		/* 821F0BB8h case   18:*/		return 0x821F0BBC;
	}
	return 0x821F0BBC;
} // Block from 821F0B70h-821F0BBCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821F0BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0BBC);
		  /* 821F0BBCh */ case    0:  		/* lis R11, -32217 */
		/* 821F0BBCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 821F0BBCh case    0:*/		return 0x821F0BC0;
		  /* 821F0BC0h */ case    1:  		/* li R28, 3 */
		/* 821F0BC0h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x3);
		/* 821F0BC0h case    1:*/		return 0x821F0BC4;
		  /* 821F0BC4h */ case    2:  		/* addi R20, R11, 22056 */
		/* 821F0BC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0x5628);
		/* 821F0BC4h case    2:*/		return 0x821F0BC8;
	}
	return 0x821F0BC8;
} // Block from 821F0BBCh-821F0BC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F0BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0BC8);
		  /* 821F0BC8h */ case    0:  		/* li R21, 0 */
		/* 821F0BC8h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821F0BC8h case    0:*/		return 0x821F0BCC;
		  /* 821F0BCCh */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 821F0BCCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821F0BCCh case    1:*/		return 0x821F0BD0;
		  /* 821F0BD0h */ case    2:  		/* bc 12, CR6_EQ, 240 */
		/* 821F0BD0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821F0CC0;  }
		/* 821F0BD0h case    2:*/		return 0x821F0BD4;
		  /* 821F0BD4h */ case    3:  		/* lis R11, -32252 */
		/* 821F0BD4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821F0BD4h case    3:*/		return 0x821F0BD8;
		  /* 821F0BD8h */ case    4:  		/* lis R10, -32253 */
		/* 821F0BD8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8203);
		/* 821F0BD8h case    4:*/		return 0x821F0BDC;
		  /* 821F0BDCh */ case    5:  		/* addi R30, R20, 4 */
		/* 821F0BDCh case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R20,0x4);
		/* 821F0BDCh case    5:*/		return 0x821F0BE0;
		  /* 821F0BE0h */ case    6:  		/* li R19, 1 */
		/* 821F0BE0h case    6:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 821F0BE0h case    6:*/		return 0x821F0BE4;
		  /* 821F0BE4h */ case    7:  		/* addi R27, R11, -13552 */
		/* 821F0BE4h case    7:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFCB10);
		/* 821F0BE4h case    7:*/		return 0x821F0BE8;
		  /* 821F0BE8h */ case    8:  		/* addi R29, R10, 30572 */
		/* 821F0BE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x776C);
		/* 821F0BE8h case    8:*/		return 0x821F0BEC;
		  /* 821F0BECh */ case    9:  		/* cmpwi CR6, R25, -1 */
		/* 821F0BECh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 821F0BECh case    9:*/		return 0x821F0BF0;
		  /* 821F0BF0h */ case   10:  		/* bc 4, CR6_EQ, 32 */
		/* 821F0BF0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821F0C10;  }
		/* 821F0BF0h case   10:*/		return 0x821F0BF4;
		  /* 821F0BF4h */ case   11:  		/* lwz R11, <#[R30]> */
		/* 821F0BF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F0BF4h case   11:*/		return 0x821F0BF8;
		  /* 821F0BF8h */ case   12:  		/* mr R3, R24 */
		/* 821F0BF8h case   12:*/		regs.R3 = regs.R24;
		/* 821F0BF8h case   12:*/		return 0x821F0BFC;
		  /* 821F0BFCh */ case   13:  		/* lwz R4, <#[R30 - 4]> */
		/* 821F0BFCh case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0xFFFFFFFC) );
		/* 821F0BFCh case   13:*/		return 0x821F0C00;
		  /* 821F0C00h */ case   14:  		/* rlwinm R5, R11, 4, 28, 31 */
		/* 821F0C00h case   14:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R5,regs.R11);
		/* 821F0C00h case   14:*/		return 0x821F0C04;
		  /* 821F0C04h */ case   15:  		/* bl 494132 */
		/* 821F0C04h case   15:*/		regs.LR = 0x821F0C08; return 0x82269638;
		/* 821F0C04h case   15:*/		return 0x821F0C08;
		  /* 821F0C08h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 821F0C08h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821F0C08h case   16:*/		return 0x821F0C0C;
		  /* 821F0C0Ch */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 821F0C0Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x821F0C20;  }
		/* 821F0C0Ch case   17:*/		return 0x821F0C10;
	}
	return 0x821F0C10;
} // Block from 821F0BC8h-821F0C10h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F0C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0C10);
		  /* 821F0C10h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821F0C10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F0C10h case    0:*/		return 0x821F0C14;
		  /* 821F0C14h */ case    1:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 821F0C14h case    1:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 821F0C14h case    1:*/		return 0x821F0C18;
		  /* 821F0C18h */ case    2:  		/* cmplw CR6, R25, R11 */
		/* 821F0C18h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 821F0C18h case    2:*/		return 0x821F0C1C;
		  /* 821F0C1Ch */ case    3:  		/* bc 4, CR6_EQ, 148 */
		/* 821F0C1Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F0CB0;  }
		/* 821F0C1Ch case    3:*/		return 0x821F0C20;
	}
	return 0x821F0C20;
} // Block from 821F0C10h-821F0C20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F0C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0C20);
		  /* 821F0C20h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821F0C20h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821F0C20h case    0:*/		return 0x821F0C24;
		  /* 821F0C24h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 821F0C24h case    1:*/		if ( regs.CR[6].eq ) { return 0x821F0C98;  }
		/* 821F0C24h case    1:*/		return 0x821F0C28;
		  /* 821F0C28h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 821F0C28h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F0C28h case    2:*/		return 0x821F0C2C;
		  /* 821F0C2Ch */ case    3:  		/* li R5, 10 */
		/* 821F0C2Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 821F0C2Ch case    3:*/		return 0x821F0C30;
		  /* 821F0C30h */ case    4:  		/* addi R4, R1, 80 */
		/* 821F0C30h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821F0C30h case    4:*/		return 0x821F0C34;
		  /* 821F0C34h */ case    5:  		/* rlwinm R11, R11, 4, 28, 31 */
		/* 821F0C34h case    5:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R11,regs.R11);
		/* 821F0C34h case    5:*/		return 0x821F0C38;
	}
	return 0x821F0C38;
} // Block from 821F0C20h-821F0C38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F0C38h
// Function '?MakeInstr_V_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0C38);
		  /* 821F0C38h */ case    0:  		/* add R3, R11, R24 */
		/* 821F0C38h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R24);
		/* 821F0C38h case    0:*/		return 0x821F0C3C;
		  /* 821F0C3Ch */ case    1:  		/* bl -1411148 */
		/* 821F0C3Ch case    1:*/		regs.LR = 0x821F0C40; return 0x820983F0;
		/* 821F0C3Ch case    1:*/		return 0x821F0C40;
		  /* 821F0C40h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 821F0C40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821F0C40h case    2:*/		return 0x821F0C44;
		  /* 821F0C44h */ case    3:  		/* add R22, R3, R26 */
		/* 821F0C44h case    3:*/		cpu::op::add<0>(regs,&regs.R22,regs.R3,regs.R26);
		/* 821F0C44h case    3:*/		return 0x821F0C48;
		  /* 821F0C48h */ case    4:  		/* lbz R10, <#[R11]> */
		/* 821F0C48h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0C48h case    4:*/		return 0x821F0C4C;
		  /* 821F0C4Ch */ case    5:  		/* cmplwi CR0, R10, 0 */
		/* 821F0C4Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 821F0C4Ch case    5:*/		return 0x821F0C50;
		  /* 821F0C50h */ case    6:  		/* bc 12, CR0_EQ, 72 */
		/* 821F0C50h case    6:*/		if ( regs.CR[0].eq ) { return 0x821F0C98;  }
		/* 821F0C50h case    6:*/		return 0x821F0C54;
		  /* 821F0C54h */ case    7:  		/* lwz R10, <#[R30]> */
		/* 821F0C54h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F0C54h case    7:*/		return 0x821F0C58;
		  /* 821F0C58h */ case    8:  		/* rlwinm. R10, R10, 0, 10, 12 */
		/* 821F0C58h case    8:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R10,regs.R10);
		/* 821F0C58h case    8:*/		return 0x821F0C5C;
		  /* 821F0C5Ch */ case    9:  		/* bc 4, CR0_EQ, 100 */
		/* 821F0C5Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x821F0CC0;  }
		/* 821F0C5Ch case    9:*/		return 0x821F0C60;
		  /* 821F0C60h */ case   10:  		/* mr R4, R29 */
		/* 821F0C60h case   10:*/		regs.R4 = regs.R29;
		/* 821F0C60h case   10:*/		return 0x821F0C64;
		  /* 821F0C64h */ case   11:  		/* mr R3, R11 */
		/* 821F0C64h case   11:*/		regs.R3 = regs.R11;
		/* 821F0C64h case   11:*/		return 0x821F0C68;
		  /* 821F0C68h */ case   12:  		/* bl -1431608 */
		/* 821F0C68h case   12:*/		regs.LR = 0x821F0C6C; return 0x82093430;
		/* 821F0C68h case   12:*/		return 0x821F0C6C;
		  /* 821F0C6Ch */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 821F0C6Ch case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821F0C6Ch case   13:*/		return 0x821F0C70;
		  /* 821F0C70h */ case   14:  		/* bc 12, CR0_EQ, 40 */
		/* 821F0C70h case   14:*/		if ( regs.CR[0].eq ) { return 0x821F0C98;  }
		/* 821F0C70h case   14:*/		return 0x821F0C74;
		  /* 821F0C74h */ case   15:  		/* mr R4, R27 */
		/* 821F0C74h case   15:*/		regs.R4 = regs.R27;
		/* 821F0C74h case   15:*/		return 0x821F0C78;
		  /* 821F0C78h */ case   16:  		/* lwz R3, <#[R1 + 80]> */
		/* 821F0C78h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821F0C78h case   16:*/		return 0x821F0C7C;
		  /* 821F0C7Ch */ case   17:  		/* bl -1431628 */
		/* 821F0C7Ch case   17:*/		regs.LR = 0x821F0C80; return 0x82093430;
		/* 821F0C7Ch case   17:*/		return 0x821F0C80;
		  /* 821F0C80h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 821F0C80h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821F0C80h case   18:*/		return 0x821F0C84;
		  /* 821F0C84h */ case   19:  		/* bc 4, CR0_EQ, 60 */
		/* 821F0C84h case   19:*/		if ( !regs.CR[0].eq ) { return 0x821F0CC0;  }
		/* 821F0C84h case   19:*/		return 0x821F0C88;
		  /* 821F0C88h */ case   20:  		/* lwz R11, <#[R31 + 56]> */
		/* 821F0C88h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 821F0C88h case   20:*/		return 0x821F0C8C;
		  /* 821F0C8Ch */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821F0C8Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F0C8Ch case   21:*/		return 0x821F0C90;
		  /* 821F0C90h */ case   22:  		/* bc 12, CR6_EQ, 8 */
		/* 821F0C90h case   22:*/		if ( regs.CR[6].eq ) { return 0x821F0C98;  }
		/* 821F0C90h case   22:*/		return 0x821F0C94;
		  /* 821F0C94h */ case   23:  		/* stw R19, <#[R11 + 28]> */
		/* 821F0C94h case   23:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x0000001C) );
		/* 821F0C94h case   23:*/		return 0x821F0C98;
	}
	return 0x821F0C98;
} // Block from 821F0C38h-821F0C98h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821F0C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0C98);
		  /* 821F0C98h */ case    0:  		/* lwz R10, <#[R30]> */
		/* 821F0C98h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F0C98h case    0:*/		return 0x821F0C9C;
		  /* 821F0C9Ch */ case    1:  		/* rlwinm. R11, R10, 13, 29, 31 */
		/* 821F0C9Ch case    1:*/		cpu::op::rlwinm<1,13,29,31>(regs,&regs.R11,regs.R10);
		/* 821F0C9Ch case    1:*/		return 0x821F0CA0;
		  /* 821F0CA0h */ case    2:  		/* rlwinm R6, R10, 10, 26, 31 */
		/* 821F0CA0h case    2:*/		cpu::op::rlwinm<0,10,26,31>(regs,&regs.R6,regs.R10);
		/* 821F0CA0h case    2:*/		return 0x821F0CA4;
		  /* 821F0CA4h */ case    3:  		/* bc 12, CR0_EQ, 164 */
		/* 821F0CA4h case    3:*/		if ( regs.CR[0].eq ) { return 0x821F0D48;  }
		/* 821F0CA4h case    3:*/		return 0x821F0CA8;
		  /* 821F0CA8h */ case    4:  		/* cmplw CR6, R22, R11 */
		/* 821F0CA8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821F0CA8h case    4:*/		return 0x821F0CAC;
		  /* 821F0CACh */ case    5:  		/* bc 12, CR6_LT, 32 */
		/* 821F0CACh case    5:*/		if ( regs.CR[6].lt ) { return 0x821F0CCC;  }
		/* 821F0CACh case    5:*/		return 0x821F0CB0;
	}
	return 0x821F0CB0;
} // Block from 821F0C98h-821F0CB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F0CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0CB0);
		  /* 821F0CB0h */ case    0:  		/* addi R21, R21, 1 */
		/* 821F0CB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821F0CB0h case    0:*/		return 0x821F0CB4;
		  /* 821F0CB4h */ case    1:  		/* addi R30, R30, 8 */
		/* 821F0CB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x8);
		/* 821F0CB4h case    1:*/		return 0x821F0CB8;
		  /* 821F0CB8h */ case    2:  		/* cmplw CR6, R21, R28 */
		/* 821F0CB8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R28);
		/* 821F0CB8h case    2:*/		return 0x821F0CBC;
		  /* 821F0CBCh */ case    3:  		/* bc 12, CR6_LT, -208 */
		/* 821F0CBCh case    3:*/		if ( regs.CR[6].lt ) { return 0x821F0BEC;  }
		/* 821F0CBCh case    3:*/		return 0x821F0CC0;
	}
	return 0x821F0CC0;
} // Block from 821F0CB0h-821F0CC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F0CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0CC0);
		  /* 821F0CC0h */ case    0:  		/* li R3, 0 */
		/* 821F0CC0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821F0CC0h case    0:*/		return 0x821F0CC4;
		  /* 821F0CC4h */ case    1:  		/* addi R1, R1, 336 */
		/* 821F0CC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 821F0CC4h case    1:*/		return 0x821F0CC8;
		  /* 821F0CC8h */ case    2:  		/* b -1440332 */
		/* 821F0CC8h case    2:*/		return 0x8209127C;
		/* 821F0CC8h case    2:*/		return 0x821F0CCC;
	}
	return 0x821F0CCC;
} // Block from 821F0CC0h-821F0CCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F0CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0CCC);
		  /* 821F0CCCh */ case    0:  		/* rlwinm R11, R21, 3, 0, 28 */
		/* 821F0CCCh case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R21);
		/* 821F0CCCh case    0:*/		return 0x821F0CD0;
		  /* 821F0CD0h */ case    1:  		/* add R11, R11, R20 */
		/* 821F0CD0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R20);
		/* 821F0CD0h case    1:*/		return 0x821F0CD4;
		  /* 821F0CD4h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F0CD4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F0CD4h case    2:*/		return 0x821F0CD8;
		  /* 821F0CD8h */ case    3:  		/* rlwinm. R11, R10, 24, 28, 31 */
		/* 821F0CD8h case    3:*/		cpu::op::rlwinm<1,24,28,31>(regs,&regs.R11,regs.R10);
		/* 821F0CD8h case    3:*/		return 0x821F0CDC;
		  /* 821F0CDCh */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 821F0CDCh case    4:*/		if ( regs.CR[0].eq ) { return 0x821F0CF4;  }
		/* 821F0CDCh case    4:*/		return 0x821F0CE0;
		  /* 821F0CE0h */ case    5:  		/* rlwinm R9, R10, 16, 29, 31 */
		/* 821F0CE0h case    5:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R9,regs.R10);
		/* 821F0CE0h case    5:*/		return 0x821F0CE4;
		  /* 821F0CE4h */ case    6:  		/* cmplw CR6, R23, R9 */
		/* 821F0CE4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R9);
		/* 821F0CE4h case    6:*/		return 0x821F0CE8;
		  /* 821F0CE8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821F0CE8h case    7:*/		if ( regs.CR[6].eq ) { return 0x821F0CFC;  }
		/* 821F0CE8h case    7:*/		return 0x821F0CEC;
		  /* 821F0CECh */ case    8:  		/* rlwinm R3, R10, 20, 25, 27 */
		/* 821F0CECh case    8:*/		cpu::op::rlwinm<0,20,25,27>(regs,&regs.R3,regs.R10);
		/* 821F0CECh case    8:*/		return 0x821F0CF0;
		  /* 821F0CF0h */ case    9:  		/* b -44 */
		/* 821F0CF0h case    9:*/		return 0x821F0CC4;
		/* 821F0CF0h case    9:*/		return 0x821F0CF4;
	}
	return 0x821F0CF4;
} // Block from 821F0CCCh-821F0CF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F0CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0CF4);
		  /* 821F0CF4h */ case    0:  		/* slw R11, R19, R23 */
		/* 821F0CF4h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R23);
		/* 821F0CF4h case    0:*/		return 0x821F0CF8;
		  /* 821F0CF8h */ case    1:  		/* addi R11, R11, -1 */
		/* 821F0CF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F0CF8h case    1:*/		return 0x821F0CFC;
	}
	return 0x821F0CFC;
} // Block from 821F0CF4h-821F0CFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F0CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0CFC);
		  /* 821F0CFCh */ case    0:  		/* add R9, R6, R22 */
		/* 821F0CFCh case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R6,regs.R22);
		/* 821F0CFCh case    0:*/		return 0x821F0D00;
		  /* 821F0D00h */ case    1:  		/* lwz R7, <#[R31 + 336]> */
		/* 821F0D00h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0D00h case    1:*/		return 0x821F0D04;
		  /* 821F0D04h */ case    2:  		/* li R10, 0 */
		/* 821F0D04h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821F0D04h case    2:*/		return 0x821F0D08;
		  /* 821F0D08h */ case    3:  		/* rlwimi R11, R9, 4, 0, 27 */
		/* 821F0D08h case    3:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R11,regs.R9);
		/* 821F0D08h case    3:*/		return 0x821F0D0C;
		  /* 821F0D0Ch */ case    4:  		/* cmplwi CR6, R7, 0 */
		/* 821F0D0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821F0D0Ch case    4:*/		return 0x821F0D10;
		  /* 821F0D10h */ case    5:  		/* mr R30, R11 */
		/* 821F0D10h case    5:*/		regs.R30 = regs.R11;
		/* 821F0D10h case    5:*/		return 0x821F0D14;
		  /* 821F0D14h */ case    6:  		/* bc 12, CR6_EQ, 164 */
		/* 821F0D14h case    6:*/		if ( regs.CR[6].eq ) { return 0x821F0DB8;  }
		/* 821F0D14h case    6:*/		return 0x821F0D18;
	}
	return 0x821F0D18;
} // Block from 821F0CFCh-821F0D18h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F0D18h
// Function '?MakeInstr_V_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0D18);
		  /* 821F0D18h */ case    0:  		/* addi R11, R31, 128 */
		/* 821F0D18h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x80);
		/* 821F0D18h case    0:*/		return 0x821F0D1C;
		  /* 821F0D1Ch */ case    1:  		/* lwz R9, <#[R11]> */
		/* 821F0D1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0D1Ch case    1:*/		return 0x821F0D20;
		  /* 821F0D20h */ case    2:  		/* cmplw CR6, R9, R30 */
		/* 821F0D20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 821F0D20h case    2:*/		return 0x821F0D24;
		  /* 821F0D24h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 821F0D24h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F0D40;  }
		/* 821F0D24h case    3:*/		return 0x821F0D28;
		  /* 821F0D28h */ case    4:  		/* lwz R9, <#[R31 + 336]> */
		/* 821F0D28h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0D28h case    4:*/		return 0x821F0D2C;
		  /* 821F0D2Ch */ case    5:  		/* addi R10, R10, 1 */
		/* 821F0D2Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F0D2Ch case    5:*/		return 0x821F0D30;
		  /* 821F0D30h */ case    6:  		/* addi R11, R11, 12 */
		/* 821F0D30h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0D30h case    6:*/		return 0x821F0D34;
		  /* 821F0D34h */ case    7:  		/* cmplw CR6, R10, R9 */
		/* 821F0D34h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821F0D34h case    7:*/		return 0x821F0D38;
		  /* 821F0D38h */ case    8:  		/* bc 12, CR6_LT, -28 */
		/* 821F0D38h case    8:*/		if ( regs.CR[6].lt ) { return 0x821F0D1C;  }
		/* 821F0D38h case    8:*/		return 0x821F0D3C;
		  /* 821F0D3Ch */ case    9:  		/* b 124 */
		/* 821F0D3Ch case    9:*/		return 0x821F0DB8;
		/* 821F0D3Ch case    9:*/		return 0x821F0D40;
	}
	return 0x821F0D40;
} // Block from 821F0D18h-821F0D40h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F0D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0D40);
		  /* 821F0D40h */ case    0:  		/* mr R3, R30 */
		/* 821F0D40h case    0:*/		regs.R3 = regs.R30;
		/* 821F0D40h case    0:*/		return 0x821F0D44;
		  /* 821F0D44h */ case    1:  		/* b -128 */
		/* 821F0D44h case    1:*/		return 0x821F0CC4;
		/* 821F0D44h case    1:*/		return 0x821F0D48;
	}
	return 0x821F0D48;
} // Block from 821F0D40h-821F0D48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F0D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0D48);
		  /* 821F0D48h */ case    0:  		/* lwz R7, <#[R31 + 336]> */
		/* 821F0D48h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0D48h case    0:*/		return 0x821F0D4C;
		  /* 821F0D4Ch */ case    1:  		/* li R9, 0 */
		/* 821F0D4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821F0D4Ch case    1:*/		return 0x821F0D50;
		  /* 821F0D50h */ case    2:  		/* cmplwi CR6, R7, 0 */
		/* 821F0D50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821F0D50h case    2:*/		return 0x821F0D54;
		  /* 821F0D54h */ case    3:  		/* bc 12, CR6_EQ, 72 */
		/* 821F0D54h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F0D9C;  }
		/* 821F0D54h case    3:*/		return 0x821F0D58;
		  /* 821F0D58h */ case    4:  		/* addi R8, R31, 124 */
		/* 821F0D58h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x7C);
		/* 821F0D58h case    4:*/		return 0x821F0D5C;
		  /* 821F0D5Ch */ case    5:  		/* lwz R11, <#[R8]> */
		/* 821F0D5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821F0D5Ch case    5:*/		return 0x821F0D60;
		  /* 821F0D60h */ case    6:  		/* rlwinm R10, R11, 27, 28, 31 */
		/* 821F0D60h case    6:*/		cpu::op::rlwinm<0,27,28,31>(regs,&regs.R10,regs.R11);
		/* 821F0D60h case    6:*/		return 0x821F0D64;
		  /* 821F0D64h */ case    7:  		/* cmplw CR6, R10, R22 */
		/* 821F0D64h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R22);
		/* 821F0D64h case    7:*/		return 0x821F0D68;
		  /* 821F0D68h */ case    8:  		/* bc 4, CR6_EQ, 32 */
		/* 821F0D68h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821F0D88;  }
		/* 821F0D68h case    8:*/		return 0x821F0D6C;
		  /* 821F0D6Ch */ case    9:  		/* rlwinm R10, R21, 3, 0, 28 */
		/* 821F0D6Ch case    9:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R21);
		/* 821F0D6Ch case    9:*/		return 0x821F0D70;
		  /* 821F0D70h */ case   10:  		/* add R10, R10, R20 */
		/* 821F0D70h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R20);
		/* 821F0D70h case   10:*/		return 0x821F0D74;
		  /* 821F0D74h */ case   11:  		/* lwz R10, <#[R10 + 4]> */
		/* 821F0D74h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821F0D74h case   11:*/		return 0x821F0D78;
		  /* 821F0D78h */ case   12:  		/* rlwinm R10, R10, 20, 28, 31 */
		/* 821F0D78h case   12:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R10);
		/* 821F0D78h case   12:*/		return 0x821F0D7C;
		  /* 821F0D7Ch */ case   13:  		/* xor R11, R10, R11 */
		/* 821F0D7Ch case   13:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F0D7Ch case   13:*/		return 0x821F0D80;
		  /* 821F0D80h */ case   14:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 821F0D80h case   14:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821F0D80h case   14:*/		return 0x821F0D84;
		  /* 821F0D84h */ case   15:  		/* bc 12, CR0_EQ, 452 */
		/* 821F0D84h case   15:*/		if ( regs.CR[0].eq ) { return 0x821F0F48;  }
		/* 821F0D84h case   15:*/		return 0x821F0D88;
	}
	return 0x821F0D88;
} // Block from 821F0D48h-821F0D88h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F0D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0D88);
		  /* 821F0D88h */ case    0:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0D88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0D88h case    0:*/		return 0x821F0D8C;
		  /* 821F0D8Ch */ case    1:  		/* addi R9, R9, 1 */
		/* 821F0D8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821F0D8Ch case    1:*/		return 0x821F0D90;
		  /* 821F0D90h */ case    2:  		/* addi R8, R8, 12 */
		/* 821F0D90h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xC);
		/* 821F0D90h case    2:*/		return 0x821F0D94;
		  /* 821F0D94h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 821F0D94h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821F0D94h case    3:*/		return 0x821F0D98;
		  /* 821F0D98h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 821F0D98h case    4:*/		if ( regs.CR[6].lt ) { return 0x821F0D5C;  }
		/* 821F0D98h case    4:*/		return 0x821F0D9C;
	}
	return 0x821F0D9C;
} // Block from 821F0D88h-821F0D9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F0D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0D9C);
		  /* 821F0D9Ch */ case    0:  		/* lwz R11, <#[R31 + 340]> */
		/* 821F0D9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000154) );
		/* 821F0D9Ch case    0:*/		return 0x821F0DA0;
		  /* 821F0DA0h */ case    1:  		/* slw R10, R19, R23 */
		/* 821F0DA0h case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R19,regs.R23);
		/* 821F0DA0h case    1:*/		return 0x821F0DA4;
		  /* 821F0DA4h */ case    2:  		/* add R9, R11, R6 */
		/* 821F0DA4h case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R6);
		/* 821F0DA4h case    2:*/		return 0x821F0DA8;
		  /* 821F0DA8h */ case    3:  		/* addi R30, R10, -1 */
		/* 821F0DA8h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFFFFFF);
		/* 821F0DA8h case    3:*/		return 0x821F0DAC;
		  /* 821F0DACh */ case    4:  		/* addi R11, R11, 1 */
		/* 821F0DACh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F0DACh case    4:*/		return 0x821F0DB0;
		  /* 821F0DB0h */ case    5:  		/* rlwimi R30, R9, 4, 0, 27 */
		/* 821F0DB0h case    5:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R30,regs.R9);
		/* 821F0DB0h case    5:*/		return 0x821F0DB4;
		  /* 821F0DB4h */ case    6:  		/* stw R11, <#[R31 + 340]> */
		/* 821F0DB4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000154) );
		/* 821F0DB4h case    6:*/		return 0x821F0DB8;
	}
	return 0x821F0DB8;
} // Block from 821F0D9Ch-821F0DB8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F0DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0DB8);
		  /* 821F0DB8h */ case    0:  		/* cmplwi CR6, R7, 18 */
		/* 821F0DB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000012);
		/* 821F0DB8h case    0:*/		return 0x821F0DBC;
		  /* 821F0DBCh */ case    1:  		/* bc 12, CR6_EQ, -252 */
		/* 821F0DBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821F0CC0;  }
		/* 821F0DBCh case    1:*/		return 0x821F0DC0;
		  /* 821F0DC0h */ case    2:  		/* rlwinm R11, R21, 3, 0, 28 */
		/* 821F0DC0h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R21);
		/* 821F0DC0h case    2:*/		return 0x821F0DC4;
		  /* 821F0DC4h */ case    3:  		/* add R29, R11, R20 */
		/* 821F0DC4h case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R20);
		/* 821F0DC4h case    3:*/		return 0x821F0DC8;
		  /* 821F0DC8h */ case    4:  		/* lwz R11, <#[R29 + 4]> */
		/* 821F0DC8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821F0DC8h case    4:*/		return 0x821F0DCC;
		  /* 821F0DCCh */ case    5:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 821F0DCCh case    5:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 821F0DCCh case    5:*/		return 0x821F0DD0;
		  /* 821F0DD0h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 821F0DD0h case    6:*/		if ( regs.CR[0].eq ) { return 0x821F0DE4;  }
		/* 821F0DD0h case    6:*/		return 0x821F0DD4;
		  /* 821F0DD4h */ case    7:  		/* lwz R11, <#[R31 + 56]> */
		/* 821F0DD4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 821F0DD4h case    7:*/		return 0x821F0DD8;
		  /* 821F0DD8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 821F0DD8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F0DD8h case    8:*/		return 0x821F0DDC;
		  /* 821F0DDCh */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 821F0DDCh case    9:*/		if ( regs.CR[6].eq ) { return 0x821F0DE4;  }
		/* 821F0DDCh case    9:*/		return 0x821F0DE0;
		  /* 821F0DE0h */ case   10:  		/* stw R19, <#[R11 + 28]> */
		/* 821F0DE0h case   10:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x0000001C) );
		/* 821F0DE0h case   10:*/		return 0x821F0DE4;
	}
	return 0x821F0DE4;
} // Block from 821F0DB8h-821F0DE4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F0DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0DE4);
		  /* 821F0DE4h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821F0DE4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821F0DE4h case    0:*/		return 0x821F0DE8;
		  /* 821F0DE8h */ case    1:  		/* bc 4, CR6_EQ, 136 */
		/* 821F0DE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F0E70;  }
		/* 821F0DE8h case    1:*/		return 0x821F0DEC;
		  /* 821F0DECh */ case    2:  		/* lwz R24, <#[R29]> */
		/* 821F0DECh case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R29 + 0x00000000) );
		/* 821F0DECh case    2:*/		return 0x821F0DF0;
		  /* 821F0DF0h */ case    3:  		/* cmplwi CR6, R22, 0 */
		/* 821F0DF0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821F0DF0h case    3:*/		return 0x821F0DF4;
		  /* 821F0DF4h */ case    4:  		/* bc 12, CR6_EQ, 124 */
		/* 821F0DF4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821F0E70;  }
		/* 821F0DF4h case    4:*/		return 0x821F0DF8;
	}
	return 0x821F0DF8;
} // Block from 821F0DE4h-821F0DF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F0DF8h
// Function '?MakeInstr_V_DOT3@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0DF8);
		  /* 821F0DF8h */ case    0:  		/* lis R11, -32252 */
		/* 821F0DF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821F0DF8h case    0:*/		return 0x821F0DFC;
		  /* 821F0DFCh */ case    1:  		/* mr R7, R22 */
		/* 821F0DFCh case    1:*/		regs.R7 = regs.R22;
		/* 821F0DFCh case    1:*/		return 0x821F0E00;
		  /* 821F0E00h */ case    2:  		/* addi R5, R11, -16884 */
		/* 821F0E00h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBE0C);
		/* 821F0E00h case    2:*/		return 0x821F0E04;
		  /* 821F0E04h */ case    3:  		/* mr R6, R24 */
		/* 821F0E04h case    3:*/		regs.R6 = regs.R24;
		/* 821F0E04h case    3:*/		return 0x821F0E08;
		  /* 821F0E08h */ case    4:  		/* li R4, 100 */
		/* 821F0E08h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x64);
		/* 821F0E08h case    4:*/		return 0x821F0E0C;
		  /* 821F0E0Ch */ case    5:  		/* addi R3, R1, 96 */
		/* 821F0E0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821F0E0Ch case    5:*/		return 0x821F0E10;
		  /* 821F0E10h */ case    6:  		/* bl 491416 */
		/* 821F0E10h case    6:*/		regs.LR = 0x821F0E14; return 0x82268DA8;
		/* 821F0E10h case    6:*/		return 0x821F0E14;
		  /* 821F0E14h */ case    7:  		/* addi R11, R1, 96 */
		/* 821F0E14h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821F0E14h case    7:*/		return 0x821F0E18;
		  /* 821F0E18h */ case    8:  		/* mr R10, R11 */
		/* 821F0E18h case    8:*/		regs.R10 = regs.R11;
		/* 821F0E18h case    8:*/		return 0x821F0E1C;
		  /* 821F0E1Ch */ case    9:  		/* lbz R9, <#[R11]> */
		/* 821F0E1Ch case    9:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0E1Ch case    9:*/		return 0x821F0E20;
		  /* 821F0E20h */ case   10:  		/* addi R11, R11, 1 */
		/* 821F0E20h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F0E20h case   10:*/		return 0x821F0E24;
		  /* 821F0E24h */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 821F0E24h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821F0E24h case   11:*/		return 0x821F0E28;
		  /* 821F0E28h */ case   12:  		/* bc 4, CR6_EQ, -12 */
		/* 821F0E28h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821F0E1C;  }
		/* 821F0E28h case   12:*/		return 0x821F0E2C;
		  /* 821F0E2Ch */ case   13:  		/* subf R11, R10, R11 */
		/* 821F0E2Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F0E2Ch case   13:*/		return 0x821F0E30;
		  /* 821F0E30h */ case   14:  		/* li R5, 0 */
		/* 821F0E30h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0E30h case   14:*/		return 0x821F0E34;
		  /* 821F0E34h */ case   15:  		/* addi R11, R11, -1 */
		/* 821F0E34h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F0E34h case   15:*/		return 0x821F0E38;
		  /* 821F0E38h */ case   16:  		/* mr R3, R31 */
		/* 821F0E38h case   16:*/		regs.R3 = regs.R31;
		/* 821F0E38h case   16:*/		return 0x821F0E3C;
		  /* 821F0E3Ch */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 821F0E3Ch case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 821F0E3Ch case   17:*/		return 0x821F0E40;
		  /* 821F0E40h */ case   18:  		/* addi R11, R11, 4 */
		/* 821F0E40h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821F0E40h case   18:*/		return 0x821F0E44;
		  /* 821F0E44h */ case   19:  		/* rlwinm R4, R11, 0, 0, 29 */
		/* 821F0E44h case   19:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R11);
		/* 821F0E44h case   19:*/		return 0x821F0E48;
		  /* 821F0E48h */ case   20:  		/* bl -411680 */
		/* 821F0E48h case   20:*/		regs.LR = 0x821F0E4C; return 0x8218C628;
		/* 821F0E48h case   20:*/		return 0x821F0E4C;
		  /* 821F0E4Ch */ case   21:  		/* addi R10, R1, 96 */
		/* 821F0E4Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 821F0E4Ch case   21:*/		return 0x821F0E50;
		  /* 821F0E50h */ case   22:  		/* mr R24, R3 */
		/* 821F0E50h case   22:*/		regs.R24 = regs.R3;
		/* 821F0E50h case   22:*/		return 0x821F0E54;
		  /* 821F0E54h */ case   23:  		/* addi R11, R1, 96 */
		/* 821F0E54h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821F0E54h case   23:*/		return 0x821F0E58;
		  /* 821F0E58h */ case   24:  		/* subf R10, R10, R3 */
		/* 821F0E58h case   24:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 821F0E58h case   24:*/		return 0x821F0E5C;
		  /* 821F0E5Ch */ case   25:  		/* lbz R9, <#[R11]> */
		/* 821F0E5Ch case   25:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0E5Ch case   25:*/		return 0x821F0E60;
		  /* 821F0E60h */ case   26:  		/* extsb. R8, R9 */
		/* 821F0E60h case   26:*/		cpu::op::extsb<1>(regs,&regs.R8,regs.R9);
		/* 821F0E60h case   26:*/		return 0x821F0E64;
		  /* 821F0E64h */ case   27:  		/* stbx R9, <#[R10 + R11]> */
		/* 821F0E64h case   27:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821F0E64h case   27:*/		return 0x821F0E68;
		  /* 821F0E68h */ case   28:  		/* addi R11, R11, 1 */
		/* 821F0E68h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F0E68h case   28:*/		return 0x821F0E6C;
		  /* 821F0E6Ch */ case   29:  		/* bc 4, CR0_EQ, -16 */
		/* 821F0E6Ch case   29:*/		if ( !regs.CR[0].eq ) { return 0x821F0E5C;  }
		/* 821F0E6Ch case   29:*/		return 0x821F0E70;
	}
	return 0x821F0E70;
} // Block from 821F0DF8h-821F0E70h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821F0E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0E70);
		  /* 821F0E70h */ case    0:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0E70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0E70h case    0:*/		return 0x821F0E74;
		  /* 821F0E74h */ case    1:  		/* rlwinm R10, R18, 0, 24, 31 */
		/* 821F0E74h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R18);
		/* 821F0E74h case    1:*/		return 0x821F0E78;
		  /* 821F0E78h */ case    2:  		/* addi R11, R11, 10 */
		/* 821F0E78h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xA);
		/* 821F0E78h case    2:*/		return 0x821F0E7C;
		  /* 821F0E7Ch */ case    3:  		/* mulli R11, R11, 12 */
		/* 821F0E7Ch case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0E7Ch case    3:*/		return 0x821F0E80;
		  /* 821F0E80h */ case    4:  		/* stwx R24, <#[R11 + R31]> */
		/* 821F0E80h case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821F0E80h case    4:*/		return 0x821F0E84;
		  /* 821F0E84h */ case    5:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0E84h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0E84h case    5:*/		return 0x821F0E88;
		  /* 821F0E88h */ case    6:  		/* mulli R11, R11, 12 */
		/* 821F0E88h case    6:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0E88h case    6:*/		return 0x821F0E8C;
		  /* 821F0E8Ch */ case    7:  		/* add R11, R11, R31 */
		/* 821F0E8Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821F0E8Ch case    7:*/		return 0x821F0E90;
		  /* 821F0E90h */ case    8:  		/* stw R30, <#[R11 + 128]> */
		/* 821F0E90h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000080) );
		/* 821F0E90h case    8:*/		return 0x821F0E94;
		  /* 821F0E94h */ case    9:  		/* lwz R9, <#[R29 + 4]> */
		/* 821F0E94h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 821F0E94h case    9:*/		return 0x821F0E98;
		  /* 821F0E98h */ case   10:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0E98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0E98h case   10:*/		return 0x821F0E9C;
		  /* 821F0E9Ch */ case   11:  		/* mulli R11, R11, 12 */
		/* 821F0E9Ch case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0E9Ch case   11:*/		return 0x821F0EA0;
		  /* 821F0EA0h */ case   12:  		/* add R11, R11, R31 */
		/* 821F0EA0h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821F0EA0h case   12:*/		return 0x821F0EA4;
		  /* 821F0EA4h */ case   13:  		/* rlwinm R9, R9, 20, 28, 31 */
		/* 821F0EA4h case   13:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R9,regs.R9);
		/* 821F0EA4h case   13:*/		return 0x821F0EA8;
		  /* 821F0EA8h */ case   14:  		/* lwz R8, <#[R11 + 124]> */
		/* 821F0EA8h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0EA8h case   14:*/		return 0x821F0EAC;
		  /* 821F0EACh */ case   15:  		/* rlwinm R8, R8, 0, 0, 26 */
		/* 821F0EACh case   15:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R8,regs.R8);
		/* 821F0EACh case   15:*/		return 0x821F0EB0;
		  /* 821F0EB0h */ case   16:  		/* or R9, R9, R8 */
		/* 821F0EB0h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821F0EB0h case   16:*/		return 0x821F0EB4;
		  /* 821F0EB4h */ case   17:  		/* stw R9, <#[R11 + 124]> */
		/* 821F0EB4h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0EB4h case   17:*/		return 0x821F0EB8;
		  /* 821F0EB8h */ case   18:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0EB8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0EB8h case   18:*/		return 0x821F0EBC;
		  /* 821F0EBCh */ case   19:  		/* mulli R11, R11, 12 */
		/* 821F0EBCh case   19:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0EBCh case   19:*/		return 0x821F0EC0;
		  /* 821F0EC0h */ case   20:  		/* add R11, R11, R31 */
		/* 821F0EC0h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821F0EC0h case   20:*/		return 0x821F0EC4;
		  /* 821F0EC4h */ case   21:  		/* lwz R9, <#[R11 + 124]> */
		/* 821F0EC4h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0EC4h case   21:*/		return 0x821F0EC8;
		  /* 821F0EC8h */ case   22:  		/* rlwimi R9, R22, 5, 23, 26 */
		/* 821F0EC8h case   22:*/		cpu::op::rlwimi<0,5,23,26>(regs,&regs.R9,regs.R22);
		/* 821F0EC8h case   22:*/		return 0x821F0ECC;
		  /* 821F0ECCh */ case   23:  		/* stw R9, <#[R11 + 124]> */
		/* 821F0ECCh case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0ECCh case   23:*/		return 0x821F0ED0;
	}
	return 0x821F0ED0;
} // Block from 821F0E70h-821F0ED0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821F0ED0h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0ED0);
		  /* 821F0ED0h */ case    0:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0ED0h case    0:*/		return 0x821F0ED4;
		  /* 821F0ED4h */ case    1:  		/* mulli R11, R11, 12 */
		/* 821F0ED4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0ED4h case    1:*/		return 0x821F0ED8;
		  /* 821F0ED8h */ case    2:  		/* add R11, R11, R31 */
		/* 821F0ED8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821F0ED8h case    2:*/		return 0x821F0EDC;
		  /* 821F0EDCh */ case    3:  		/* lwz R9, <#[R11 + 124]> */
		/* 821F0EDCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0EDCh case    3:*/		return 0x821F0EE0;
		  /* 821F0EE0h */ case    4:  		/* rlwimi R9, R10, 18, 13, 13 */
		/* 821F0EE0h case    4:*/		cpu::op::rlwimi<0,18,13,13>(regs,&regs.R9,regs.R10);
		/* 821F0EE0h case    4:*/		return 0x821F0EE4;
		  /* 821F0EE4h */ case    5:  		/* stw R9, <#[R11 + 124]> */
		/* 821F0EE4h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0EE4h case    5:*/		return 0x821F0EE8;
		  /* 821F0EE8h */ case    6:  		/* lwz R11, <#[R31 + 44]> */
		/* 821F0EE8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F0EE8h case    6:*/		return 0x821F0EEC;
		  /* 821F0EECh */ case    7:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 821F0EECh case    7:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 821F0EECh case    7:*/		return 0x821F0EF0;
		  /* 821F0EF0h */ case    8:  		/* bc 12, CR0_EQ, 68 */
		/* 821F0EF0h case    8:*/		if ( regs.CR[0].eq ) { return 0x821F0F34;  }
		/* 821F0EF0h case    8:*/		return 0x821F0EF4;
		  /* 821F0EF4h */ case    9:  		/* lwz R11, <#[R31 + 48]> */
		/* 821F0EF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821F0EF4h case    9:*/		return 0x821F0EF8;
		  /* 821F0EF8h */ case   10:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821F0EF8h case   10:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821F0EF8h case   10:*/		return 0x821F0EFC;
		  /* 821F0EFCh */ case   11:  		/* cmplw CR6, R11, R17 */
		/* 821F0EFCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 821F0EFCh case   11:*/		return 0x821F0F00;
		  /* 821F0F00h */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 821F0F00h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F0F34;  }
		/* 821F0F00h case   12:*/		return 0x821F0F04;
		  /* 821F0F04h */ case   13:  		/* rlwinm R11, R30, 0, 0, 27 */
		/* 821F0F04h case   13:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R30);
		/* 821F0F04h case   13:*/		return 0x821F0F08;
		  /* 821F0F08h */ case   14:  		/* cmplwi CR6, R11, 992 */
		/* 821F0F08h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000003E0);
		/* 821F0F08h case   14:*/		return 0x821F0F0C;
		  /* 821F0F0Ch */ case   15:  		/* bc 4, CR6_EQ, 40 */
		/* 821F0F0Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F0F34;  }
		/* 821F0F0Ch case   15:*/		return 0x821F0F10;
		  /* 821F0F10h */ case   16:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0F10h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0F10h case   16:*/		return 0x821F0F14;
		  /* 821F0F14h */ case   17:  		/* mulli R11, R11, 12 */
		/* 821F0F14h case   17:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F0F14h case   17:*/		return 0x821F0F18;
		  /* 821F0F18h */ case   18:  		/* add R11, R11, R31 */
		/* 821F0F18h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821F0F18h case   18:*/		return 0x821F0F1C;
		  /* 821F0F1Ch */ case   19:  		/* lwz R10, <#[R11 + 124]> */
		/* 821F0F1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0F1Ch case   19:*/		return 0x821F0F20;
		  /* 821F0F20h */ case   20:  		/* oris R10, R10, 4 */
		/* 821F0F20h case   20:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821F0F20h case   20:*/		return 0x821F0F24;
		  /* 821F0F24h */ case   21:  		/* stw R10, <#[R11 + 124]> */
		/* 821F0F24h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000007C) );
		/* 821F0F24h case   21:*/		return 0x821F0F28;
		  /* 821F0F28h */ case   22:  		/* lwz R11, <#[R31 + 40]> */
		/* 821F0F28h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F0F28h case   22:*/		return 0x821F0F2C;
		  /* 821F0F2Ch */ case   23:  		/* ori R11, R11, 32768 */
		/* 821F0F2Ch case   23:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 821F0F2Ch case   23:*/		return 0x821F0F30;
		  /* 821F0F30h */ case   24:  		/* stw R11, <#[R31 + 40]> */
		/* 821F0F30h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F0F30h case   24:*/		return 0x821F0F34;
	}
	return 0x821F0F34;
} // Block from 821F0ED0h-821F0F34h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821F0F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0F34);
		  /* 821F0F34h */ case    0:  		/* lwz R11, <#[R31 + 336]> */
		/* 821F0F34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0F34h case    0:*/		return 0x821F0F38;
		  /* 821F0F38h */ case    1:  		/* mr R3, R30 */
		/* 821F0F38h case    1:*/		regs.R3 = regs.R30;
		/* 821F0F38h case    1:*/		return 0x821F0F3C;
		  /* 821F0F3Ch */ case    2:  		/* addi R11, R11, 1 */
		/* 821F0F3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F0F3Ch case    2:*/		return 0x821F0F40;
		  /* 821F0F40h */ case    3:  		/* stw R11, <#[R31 + 336]> */
		/* 821F0F40h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000150) );
		/* 821F0F40h case    3:*/		return 0x821F0F44;
		  /* 821F0F44h */ case    4:  		/* b -640 */
		/* 821F0F44h case    4:*/		return 0x821F0CC4;
		/* 821F0F44h case    4:*/		return 0x821F0F48;
	}
	return 0x821F0F48;
} // Block from 821F0F34h-821F0F48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F0F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0F48);
		  /* 821F0F48h */ case    0:  		/* mulli R11, R9, 12 */
		/* 821F0F48h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R9,0xC);
		/* 821F0F48h case    0:*/		return 0x821F0F4C;
		  /* 821F0F4Ch */ case    1:  		/* add R11, R11, R31 */
		/* 821F0F4Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821F0F4Ch case    1:*/		return 0x821F0F50;
		  /* 821F0F50h */ case    2:  		/* lwz R3, <#[R11 + 128]> */
		/* 821F0F50h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000080) );
		/* 821F0F50h case    2:*/		return 0x821F0F54;
		  /* 821F0F54h */ case    3:  		/* b -656 */
		/* 821F0F54h case    3:*/		return 0x821F0CC4;
		/* 821F0F54h case    3:*/		return 0x821F0F58;
	}
	return 0x821F0F58;
} // Block from 821F0F48h-821F0F58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F0F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0F58);
		  /* 821F0F58h */ case    0:  		/* mfspr R12, LR */
		/* 821F0F58h case    0:*/		regs.R12 = regs.LR;
		/* 821F0F58h case    0:*/		return 0x821F0F5C;
		  /* 821F0F5Ch */ case    1:  		/* bl -1441052 */
		/* 821F0F5Ch case    1:*/		regs.LR = 0x821F0F60; return 0x82091240;
		/* 821F0F5Ch case    1:*/		return 0x821F0F60;
		  /* 821F0F60h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 821F0F60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 821F0F60h case    2:*/		return 0x821F0F64;
		  /* 821F0F64h */ case    3:  		/* mr R31, R3 */
		/* 821F0F64h case    3:*/		regs.R31 = regs.R3;
		/* 821F0F64h case    3:*/		return 0x821F0F68;
		  /* 821F0F68h */ case    4:  		/* mr R28, R4 */
		/* 821F0F68h case    4:*/		regs.R28 = regs.R4;
		/* 821F0F68h case    4:*/		return 0x821F0F6C;
		  /* 821F0F6Ch */ case    5:  		/* mr R27, R5 */
		/* 821F0F6Ch case    5:*/		regs.R27 = regs.R5;
		/* 821F0F6Ch case    5:*/		return 0x821F0F70;
		  /* 821F0F70h */ case    6:  		/* mr R22, R6 */
		/* 821F0F70h case    6:*/		regs.R22 = regs.R6;
		/* 821F0F70h case    6:*/		return 0x821F0F74;
		  /* 821F0F74h */ case    7:  		/* mr R23, R7 */
		/* 821F0F74h case    7:*/		regs.R23 = regs.R7;
		/* 821F0F74h case    7:*/		return 0x821F0F78;
		  /* 821F0F78h */ case    8:  		/* mr R26, R8 */
		/* 821F0F78h case    8:*/		regs.R26 = regs.R8;
		/* 821F0F78h case    8:*/		return 0x821F0F7C;
		  /* 821F0F7Ch */ case    9:  		/* mr R25, R9 */
		/* 821F0F7Ch case    9:*/		regs.R25 = regs.R9;
		/* 821F0F7Ch case    9:*/		return 0x821F0F80;
		  /* 821F0F80h */ case   10:  		/* mr R24, R10 */
		/* 821F0F80h case   10:*/		regs.R24 = regs.R10;
		/* 821F0F80h case   10:*/		return 0x821F0F84;
		  /* 821F0F84h */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 821F0F84h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821F0F84h case   11:*/		return 0x821F0F88;
		  /* 821F0F88h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 821F0F88h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F0FA8;  }
		/* 821F0F88h case   12:*/		return 0x821F0F8C;
		  /* 821F0F8Ch */ case   13:  		/* mr R11, R4 */
		/* 821F0F8Ch case   13:*/		regs.R11 = regs.R4;
		/* 821F0F8Ch case   13:*/		return 0x821F0F90;
		  /* 821F0F90h */ case   14:  		/* lbz R10, <#[R11]> */
		/* 821F0F90h case   14:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F0F90h case   14:*/		return 0x821F0F94;
		  /* 821F0F94h */ case   15:  		/* addi R11, R11, 1 */
		/* 821F0F94h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F0F94h case   15:*/		return 0x821F0F98;
		  /* 821F0F98h */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 821F0F98h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F0F98h case   16:*/		return 0x821F0F9C;
		  /* 821F0F9Ch */ case   17:  		/* bc 4, CR6_EQ, -12 */
		/* 821F0F9Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x821F0F90;  }
		/* 821F0F9Ch case   17:*/		return 0x821F0FA0;
	}
	return 0x821F0FA0;
} // Block from 821F0F58h-821F0FA0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F0FA0h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0FA0);
		  /* 821F0FA0h */ case    0:  		/* subf R11, R28, R11 */
		/* 821F0FA0h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 821F0FA0h case    0:*/		return 0x821F0FA4;
		  /* 821F0FA4h */ case    1:  		/* b 40 */
		/* 821F0FA4h case    1:*/		return 0x821F0FCC;
		/* 821F0FA4h case    1:*/		return 0x821F0FA8;
	}
	return 0x821F0FA8;
} // Block from 821F0FA0h-821F0FA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F0FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0FA8);
		  /* 821F0FA8h */ case    0:  		/* mr R4, R27 */
		/* 821F0FA8h case    0:*/		regs.R4 = regs.R27;
		/* 821F0FA8h case    0:*/		return 0x821F0FAC;
		  /* 821F0FACh */ case    1:  		/* mr R3, R31 */
		/* 821F0FACh case    1:*/		regs.R3 = regs.R31;
		/* 821F0FACh case    1:*/		return 0x821F0FB0;
		  /* 821F0FB0h */ case    2:  		/* bl -18992 */
		/* 821F0FB0h case    2:*/		regs.LR = 0x821F0FB4; return 0x821EC580;
		/* 821F0FB0h case    2:*/		return 0x821F0FB4;
		  /* 821F0FB4h */ case    3:  		/* mr R11, R3 */
		/* 821F0FB4h case    3:*/		regs.R11 = regs.R3;
		/* 821F0FB4h case    3:*/		return 0x821F0FB8;
		  /* 821F0FB8h */ case    4:  		/* lbz R10, <#[R3]> */
		/* 821F0FB8h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F0FB8h case    4:*/		return 0x821F0FBC;
		  /* 821F0FBCh */ case    5:  		/* addi R3, R3, 1 */
		/* 821F0FBCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821F0FBCh case    5:*/		return 0x821F0FC0;
		  /* 821F0FC0h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 821F0FC0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F0FC0h case    6:*/		return 0x821F0FC4;
		  /* 821F0FC4h */ case    7:  		/* bc 4, CR6_EQ, -12 */
		/* 821F0FC4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821F0FB8;  }
		/* 821F0FC4h case    7:*/		return 0x821F0FC8;
		  /* 821F0FC8h */ case    8:  		/* subf R11, R11, R3 */
		/* 821F0FC8h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 821F0FC8h case    8:*/		return 0x821F0FCC;
	}
	return 0x821F0FCC;
} // Block from 821F0FA8h-821F0FCCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F0FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0FCC);
		  /* 821F0FCCh */ case    0:  		/* addi R11, R11, -1 */
		/* 821F0FCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F0FCCh case    0:*/		return 0x821F0FD0;
		  /* 821F0FD0h */ case    1:  		/* li R5, 0 */
		/* 821F0FD0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F0FD0h case    1:*/		return 0x821F0FD4;
		  /* 821F0FD4h */ case    2:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 821F0FD4h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 821F0FD4h case    2:*/		return 0x821F0FD8;
		  /* 821F0FD8h */ case    3:  		/* mr R3, R31 */
		/* 821F0FD8h case    3:*/		regs.R3 = regs.R31;
		/* 821F0FD8h case    3:*/		return 0x821F0FDC;
		  /* 821F0FDCh */ case    4:  		/* addi R29, R11, 1 */
		/* 821F0FDCh case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 821F0FDCh case    4:*/		return 0x821F0FE0;
		  /* 821F0FE0h */ case    5:  		/* mr R4, R29 */
		/* 821F0FE0h case    5:*/		regs.R4 = regs.R29;
		/* 821F0FE0h case    5:*/		return 0x821F0FE4;
		  /* 821F0FE4h */ case    6:  		/* bl -12572 */
		/* 821F0FE4h case    6:*/		regs.LR = 0x821F0FE8; return 0x821EDEC8;
		/* 821F0FE4h case    6:*/		return 0x821F0FE8;
		  /* 821F0FE8h */ case    7:  		/* mr R30, R3 */
		/* 821F0FE8h case    7:*/		regs.R30 = regs.R3;
		/* 821F0FE8h case    7:*/		return 0x821F0FEC;
		  /* 821F0FECh */ case    8:  		/* cmplwi CR6, R28, 0 */
		/* 821F0FECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821F0FECh case    8:*/		return 0x821F0FF0;
		  /* 821F0FF0h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 821F0FF0h case    9:*/		if ( regs.CR[6].eq ) { return 0x821F0FFC;  }
		/* 821F0FF0h case    9:*/		return 0x821F0FF4;
		  /* 821F0FF4h */ case   10:  		/* mr R4, R28 */
		/* 821F0FF4h case   10:*/		regs.R4 = regs.R28;
		/* 821F0FF4h case   10:*/		return 0x821F0FF8;
		  /* 821F0FF8h */ case   11:  		/* b 20 */
		/* 821F0FF8h case   11:*/		return 0x821F100C;
		/* 821F0FF8h case   11:*/		return 0x821F0FFC;
	}
	return 0x821F0FFC;
} // Block from 821F0FCCh-821F0FFCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F0FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F0FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F0FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F0FFC);
		  /* 821F0FFCh */ case    0:  		/* mr R4, R27 */
		/* 821F0FFCh case    0:*/		regs.R4 = regs.R27;
		/* 821F0FFCh case    0:*/		return 0x821F1000;
		  /* 821F1000h */ case    1:  		/* mr R3, R31 */
		/* 821F1000h case    1:*/		regs.R3 = regs.R31;
		/* 821F1000h case    1:*/		return 0x821F1004;
		  /* 821F1004h */ case    2:  		/* bl -19076 */
		/* 821F1004h case    2:*/		regs.LR = 0x821F1008; return 0x821EC580;
		/* 821F1004h case    2:*/		return 0x821F1008;
		  /* 821F1008h */ case    3:  		/* mr R4, R3 */
		/* 821F1008h case    3:*/		regs.R4 = regs.R3;
		/* 821F1008h case    3:*/		return 0x821F100C;
	}
	return 0x821F100C;
} // Block from 821F0FFCh-821F100Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F100Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F100C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F100C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F100C);
		  /* 821F100Ch */ case    0:  		/* mr R5, R29 */
		/* 821F100Ch case    0:*/		regs.R5 = regs.R29;
		/* 821F100Ch case    0:*/		return 0x821F1010;
		  /* 821F1010h */ case    1:  		/* mr R3, R30 */
		/* 821F1010h case    1:*/		regs.R3 = regs.R30;
		/* 821F1010h case    1:*/		return 0x821F1014;
		  /* 821F1014h */ case    2:  		/* bl -1439332 */
		/* 821F1014h case    2:*/		regs.LR = 0x821F1018; return 0x820919B0;
		/* 821F1014h case    2:*/		return 0x821F1018;
		  /* 821F1018h */ case    3:  		/* mr R6, R25 */
		/* 821F1018h case    3:*/		regs.R6 = regs.R25;
		/* 821F1018h case    3:*/		return 0x821F101C;
		  /* 821F101Ch */ case    4:  		/* mr R5, R26 */
		/* 821F101Ch case    4:*/		regs.R5 = regs.R26;
		/* 821F101Ch case    4:*/		return 0x821F1020;
		  /* 821F1020h */ case    5:  		/* mr R4, R23 */
		/* 821F1020h case    5:*/		regs.R4 = regs.R23;
		/* 821F1020h case    5:*/		return 0x821F1024;
		  /* 821F1024h */ case    6:  		/* mr R3, R31 */
		/* 821F1024h case    6:*/		regs.R3 = regs.R31;
		/* 821F1024h case    6:*/		return 0x821F1028;
		  /* 821F1028h */ case    7:  		/* bl -14824 */
		/* 821F1028h case    7:*/		regs.LR = 0x821F102C; return 0x821ED640;
		/* 821F1028h case    7:*/		return 0x821F102C;
		  /* 821F102Ch */ case    8:  		/* mr R29, R3 */
		/* 821F102Ch case    8:*/		regs.R29 = regs.R3;
		/* 821F102Ch case    8:*/		return 0x821F1030;
		  /* 821F1030h */ case    9:  		/* li R5, 20 */
		/* 821F1030h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 821F1030h case    9:*/		return 0x821F1034;
		  /* 821F1034h */ case   10:  		/* li R4, 88 */
		/* 821F1034h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x58);
		/* 821F1034h case   10:*/		return 0x821F1038;
		  /* 821F1038h */ case   11:  		/* mr R3, R31 */
		/* 821F1038h case   11:*/		regs.R3 = regs.R31;
		/* 821F1038h case   11:*/		return 0x821F103C;
		  /* 821F103Ch */ case   12:  		/* bl -541844 */
		/* 821F103Ch case   12:*/		regs.LR = 0x821F1040; return 0x8216CBA8;
		/* 821F103Ch case   12:*/		return 0x821F1040;
		  /* 821F1040h */ case   13:  		/* mr R28, R3 */
		/* 821F1040h case   13:*/		regs.R28 = regs.R3;
		/* 821F1040h case   13:*/		return 0x821F1044;
		  /* 821F1044h */ case   14:  		/* addi R3, R1, 80 */
		/* 821F1044h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F1044h case   14:*/		return 0x821F1048;
		  /* 821F1048h */ case   15:  		/* bl -1203208 */
		/* 821F1048h case   15:*/		regs.LR = 0x821F104C; return 0x820CB440;
		/* 821F1048h case   15:*/		return 0x821F104C;
		  /* 821F104Ch */ case   16:  		/* lwz R9, <#[R1 + 80]> */
		/* 821F104Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821F104Ch case   16:*/		return 0x821F1050;
		  /* 821F1050h */ case   17:  		/* li R11, 11 */
		/* 821F1050h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0xB);
		/* 821F1050h case   17:*/		return 0x821F1054;
		  /* 821F1054h */ case   18:  		/* stw R27, <#[R28 + 16]> */
		/* 821F1054h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + 0x00000010) );
		/* 821F1054h case   18:*/		return 0x821F1058;
		  /* 821F1058h */ case   19:  		/* mullw R10, R26, R25 */
		/* 821F1058h case   19:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R26,regs.R25);
		/* 821F1058h case   19:*/		return 0x821F105C;
		  /* 821F105Ch */ case   20:  		/* stw R29, <#[R28 + 48]> */
		/* 821F105Ch case   20:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000030) );
		/* 821F105Ch case   20:*/		return 0x821F1060;
		  /* 821F1060h */ case   21:  		/* stw R11, <#[R28 + 4]> */
		/* 821F1060h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821F1060h case   21:*/		return 0x821F1064;
		  /* 821F1064h */ case   22:  		/* stw R10, <#[R28 + 20]> */
		/* 821F1064h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000014) );
		/* 821F1064h case   22:*/		return 0x821F1068;
		  /* 821F1068h */ case   23:  		/* stw R9, <#[R28]> */
		/* 821F1068h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 821F1068h case   23:*/		return 0x821F106C;
		  /* 821F106Ch */ case   24:  		/* mr R5, R30 */
		/* 821F106Ch case   24:*/		regs.R5 = regs.R30;
		/* 821F106Ch case   24:*/		return 0x821F1070;
	}
	return 0x821F1070;
} // Block from 821F100Ch-821F1070h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821F1070h
// Function '?MakeInstr_V_SETE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1070);
		  /* 821F1070h */ case    0:  		/* li R4, 1 */
		/* 821F1070h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821F1070h case    0:*/		return 0x821F1074;
		  /* 821F1074h */ case    1:  		/* mr R3, R31 */
		/* 821F1074h case    1:*/		regs.R3 = regs.R31;
		/* 821F1074h case    1:*/		return 0x821F1078;
		  /* 821F1078h */ case    2:  		/* mr R6, R28 */
		/* 821F1078h case    2:*/		regs.R6 = regs.R28;
		/* 821F1078h case    2:*/		return 0x821F107C;
		  /* 821F107Ch */ case    3:  		/* bl -16756 */
		/* 821F107Ch case    3:*/		regs.LR = 0x821F1080; return 0x821ECF08;
		/* 821F107Ch case    3:*/		return 0x821F1080;
		  /* 821F1080h */ case    4:  		/* mr R30, R3 */
		/* 821F1080h case    4:*/		regs.R30 = regs.R3;
		/* 821F1080h case    4:*/		return 0x821F1084;
		  /* 821F1084h */ case    5:  		/* cmplwi CR6, R24, 0 */
		/* 821F1084h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821F1084h case    5:*/		return 0x821F1088;
		  /* 821F1088h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 821F1088h case    6:*/		if ( regs.CR[6].eq ) { return 0x821F10A8;  }
		/* 821F1088h case    6:*/		return 0x821F108C;
		  /* 821F108Ch */ case    7:  		/* lis R11, -32255 */
		/* 821F108Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821F108Ch case    7:*/		return 0x821F1090;
		  /* 821F1090h */ case    8:  		/* lwz R5, <#[R24]> */
		/* 821F1090h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R24 + 0x00000000) );
		/* 821F1090h case    8:*/		return 0x821F1094;
		  /* 821F1094h */ case    9:  		/* mr R4, R3 */
		/* 821F1094h case    9:*/		regs.R4 = regs.R3;
		/* 821F1094h case    9:*/		return 0x821F1098;
		  /* 821F1098h */ case   10:  		/* addi R6, R11, 9252 */
		/* 821F1098h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2424);
		/* 821F1098h case   10:*/		return 0x821F109C;
		  /* 821F109Ch */ case   11:  		/* mr R3, R31 */
		/* 821F109Ch case   11:*/		regs.R3 = regs.R31;
		/* 821F109Ch case   11:*/		return 0x821F10A0;
		  /* 821F10A0h */ case   12:  		/* bl -16688 */
		/* 821F10A0h case   12:*/		regs.LR = 0x821F10A4; return 0x821ECF70;
		/* 821F10A0h case   12:*/		return 0x821F10A4;
		  /* 821F10A4h */ case   13:  		/* stw R3, <#[R24]> */
		/* 821F10A4h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R24 + 0x00000000) );
		/* 821F10A4h case   13:*/		return 0x821F10A8;
	}
	return 0x821F10A8;
} // Block from 821F1070h-821F10A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F10A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F10A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F10A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F10A8);
		  /* 821F10A8h */ case    0:  		/* addi R11, R27, 1 */
		/* 821F10A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x1);
		/* 821F10A8h case    0:*/		return 0x821F10AC;
		  /* 821F10ACh */ case    1:  		/* add R8, R27, R22 */
		/* 821F10ACh case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R27,regs.R22);
		/* 821F10ACh case    1:*/		return 0x821F10B0;
		  /* 821F10B0h */ case    2:  		/* cmplw CR6, R11, R8 */
		/* 821F10B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821F10B0h case    2:*/		return 0x821F10B4;
		  /* 821F10B4h */ case    3:  		/* bc 4, CR6_LT, 64 */
		/* 821F10B4h case    3:*/		if ( !regs.CR[6].lt ) { return 0x821F10F4;  }
		/* 821F10B4h case    3:*/		return 0x821F10B8;
		  /* 821F10B8h */ case    4:  		/* mulli R10, R11, 40 */
		/* 821F10B8h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0x28);
		/* 821F10B8h case    4:*/		return 0x821F10BC;
		  /* 821F10BCh */ case    5:  		/* lwz R9, <#[R31 + 12]> */
		/* 821F10BCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 821F10BCh case    5:*/		return 0x821F10C0;
		  /* 821F10C0h */ case    6:  		/* lwzx R9, <#[R10 + R9]> */
		/* 821F10C0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821F10C0h case    6:*/		return 0x821F10C4;
		  /* 821F10C4h */ case    7:  		/* rlwinm. R9, R9, 0, 29, 31 */
		/* 821F10C4h case    7:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R9,regs.R9);
		/* 821F10C4h case    7:*/		return 0x821F10C8;
		  /* 821F10C8h */ case    8:  		/* bc 4, CR0_EQ, 56 */
		/* 821F10C8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821F1100;  }
		/* 821F10C8h case    8:*/		return 0x821F10CC;
		  /* 821F10CCh */ case    9:  		/* lwz R9, <#[R31 + 12]> */
		/* 821F10CCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 821F10CCh case    9:*/		return 0x821F10D0;
		  /* 821F10D0h */ case   10:  		/* li R7, 5 */
		/* 821F10D0h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x5);
		/* 821F10D0h case   10:*/		return 0x821F10D4;
		  /* 821F10D4h */ case   11:  		/* addi R11, R11, 1 */
		/* 821F10D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F10D4h case   11:*/		return 0x821F10D8;
		  /* 821F10D8h */ case   12:  		/* add R9, R10, R9 */
		/* 821F10D8h case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 821F10D8h case   12:*/		return 0x821F10DC;
		  /* 821F10DCh */ case   13:  		/* addi R10, R10, 40 */
		/* 821F10DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F10DCh case   13:*/		return 0x821F10E0;
		  /* 821F10E0h */ case   14:  		/* cmplw CR6, R11, R8 */
		/* 821F10E0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821F10E0h case   14:*/		return 0x821F10E4;
		  /* 821F10E4h */ case   15:  		/* lwz R6, <#[R9]> */
		/* 821F10E4h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 821F10E4h case   15:*/		return 0x821F10E8;
		  /* 821F10E8h */ case   16:  		/* rlwimi R6, R7, 0, 29, 31 */
		/* 821F10E8h case   16:*/		cpu::op::rlwimi<0,0,29,31>(regs,&regs.R6,regs.R7);
		/* 821F10E8h case   16:*/		return 0x821F10EC;
		  /* 821F10ECh */ case   17:  		/* stw R6, <#[R9]> */
		/* 821F10ECh case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 821F10ECh case   17:*/		return 0x821F10F0;
		  /* 821F10F0h */ case   18:  		/* bc 12, CR6_LT, -52 */
		/* 821F10F0h case   18:*/		if ( regs.CR[6].lt ) { return 0x821F10BC;  }
		/* 821F10F0h case   18:*/		return 0x821F10F4;
	}
	return 0x821F10F4;
} // Block from 821F10A8h-821F10F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821F10F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F10F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F10F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F10F4);
		  /* 821F10F4h */ case    0:  		/* mr R3, R30 */
		/* 821F10F4h case    0:*/		regs.R3 = regs.R30;
		/* 821F10F4h case    0:*/		return 0x821F10F8;
		  /* 821F10F8h */ case    1:  		/* addi R1, R1, 256 */
		/* 821F10F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 821F10F8h case    1:*/		return 0x821F10FC;
		  /* 821F10FCh */ case    2:  		/* b -1441388 */
		/* 821F10FCh case    2:*/		return 0x82091290;
		/* 821F10FCh case    2:*/		return 0x821F1100;
	}
	return 0x821F1100;
} // Block from 821F10F4h-821F1100h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F1100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1100);
		  /* 821F1100h */ case    0:  		/* li R4, 4800 */
		/* 821F1100h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821F1100h case    0:*/		return 0x821F1104;
		  /* 821F1104h */ case    1:  		/* mr R3, R31 */
		/* 821F1104h case    1:*/		regs.R3 = regs.R31;
		/* 821F1104h case    1:*/		return 0x821F1108;
		  /* 821F1108h */ case    2:  		/* bl -651936 */
		/* 821F1108h case    2:*/		regs.LR = 0x821F110C; return 0x82151E68;
		/* 821F1108h case    2:*/		return 0x821F110C;
		  /* 821F110Ch */ case    3:  		/* nop */
		/* 821F110Ch case    3:*/		cpu::op::nop();
		/* 821F110Ch case    3:*/		return 0x821F1110;
	}
	return 0x821F1110;
} // Block from 821F1100h-821F1110h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F1110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1110);
		  /* 821F1110h */ case    0:  		/* mfspr R12, LR */
		/* 821F1110h case    0:*/		regs.R12 = regs.LR;
		/* 821F1110h case    0:*/		return 0x821F1114;
		  /* 821F1114h */ case    1:  		/* bl -1441484 */
		/* 821F1114h case    1:*/		regs.LR = 0x821F1118; return 0x82091248;
		/* 821F1114h case    1:*/		return 0x821F1118;
		  /* 821F1118h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821F1118h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821F1118h case    2:*/		return 0x821F111C;
		  /* 821F111Ch */ case    3:  		/* mr R31, R3 */
		/* 821F111Ch case    3:*/		regs.R31 = regs.R3;
		/* 821F111Ch case    3:*/		return 0x821F1120;
		  /* 821F1120h */ case    4:  		/* mr R27, R5 */
		/* 821F1120h case    4:*/		regs.R27 = regs.R5;
		/* 821F1120h case    4:*/		return 0x821F1124;
		  /* 821F1124h */ case    5:  		/* mr R10, R8 */
		/* 821F1124h case    5:*/		regs.R10 = regs.R8;
		/* 821F1124h case    5:*/		return 0x821F1128;
		  /* 821F1128h */ case    6:  		/* mr R26, R9 */
		/* 821F1128h case    6:*/		regs.R26 = regs.R9;
		/* 821F1128h case    6:*/		return 0x821F112C;
		  /* 821F112Ch */ case    7:  		/* rlwinm R25, R7, 28, 4, 31 */
		/* 821F112Ch case    7:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R25,regs.R7);
		/* 821F112Ch case    7:*/		return 0x821F1130;
		  /* 821F1130h */ case    8:  		/* rlwinm R24, R7, 0, 28, 31 */
		/* 821F1130h case    8:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R24,regs.R7);
		/* 821F1130h case    8:*/		return 0x821F1134;
		  /* 821F1134h */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 821F1134h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821F1134h case    9:*/		return 0x821F1138;
		  /* 821F1138h */ case   10:  		/* bc 12, CR6_EQ, 200 */
		/* 821F1138h case   10:*/		if ( regs.CR[6].eq ) { return 0x821F1200;  }
		/* 821F1138h case   10:*/		return 0x821F113C;
		  /* 821F113Ch */ case   11:  		/* addic. R11, R6, 1 */
		/* 821F113Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R6,0x1);
		/* 821F113Ch case   11:*/		return 0x821F1140;
	}
	return 0x821F1140;
} // Block from 821F1110h-821F1140h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F1140h
// Function '?MakeInstr_V_CNDGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@0PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1140);
		  /* 821F1140h */ case    0:  		/* bc 12, CR0_EQ, 24 */
		/* 821F1140h case    0:*/		if ( regs.CR[0].eq ) { return 0x821F1158;  }
		/* 821F1140h case    0:*/		return 0x821F1144;
		  /* 821F1144h */ case    1:  		/* addi R9, R11, -1 */
		/* 821F1144h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 821F1144h case    1:*/		return 0x821F1148;
		  /* 821F1148h */ case    2:  		/* andc R9, R11, R9 */
		/* 821F1148h case    2:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821F1148h case    2:*/		return 0x821F114C;
		  /* 821F114Ch */ case    3:  		/* subf. R11, R9, R11 */
		/* 821F114Ch case    3:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F114Ch case    3:*/		return 0x821F1150;
		  /* 821F1150h */ case    4:  		/* li R11, 1 */
		/* 821F1150h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1150h case    4:*/		return 0x821F1154;
		  /* 821F1154h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 821F1154h case    5:*/		if ( regs.CR[0].eq ) { return 0x821F115C;  }
		/* 821F1154h case    5:*/		return 0x821F1158;
	}
	return 0x821F1158;
} // Block from 821F1140h-821F1158h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F1158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1158);
		  /* 821F1158h */ case    0:  		/* li R11, 0 */
		/* 821F1158h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F1158h case    0:*/		return 0x821F115C;
	}
	return 0x821F115C;
} // Block from 821F1158h-821F115Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F115Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F115C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F115C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F115C);
		  /* 821F115Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821F115Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821F115Ch case    0:*/		return 0x821F1160;
		  /* 821F1160h */ case    1:  		/* bc 12, CR0_EQ, 160 */
		/* 821F1160h case    1:*/		if ( regs.CR[0].eq ) { return 0x821F1200;  }
		/* 821F1160h case    1:*/		return 0x821F1164;
		  /* 821F1164h */ case    2:  		/* cntlzw R11, R6 */
		/* 821F1164h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R6);
		/* 821F1164h case    2:*/		return 0x821F1168;
		  /* 821F1168h */ case    3:  		/* addi R29, R27, 608 */
		/* 821F1168h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x260);
		/* 821F1168h case    3:*/		return 0x821F116C;
		  /* 821F116Ch */ case    4:  		/* subfic R28, R11, 32 */
		/* 821F116Ch case    4:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R11,0x20);
		/* 821F116Ch case    4:*/		return 0x821F1170;
		  /* 821F1170h */ case    5:  		/* li R8, 1 */
		/* 821F1170h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F1170h case    5:*/		return 0x821F1174;
		  /* 821F1174h */ case    6:  		/* mr R9, R28 */
		/* 821F1174h case    6:*/		regs.R9 = regs.R28;
		/* 821F1174h case    6:*/		return 0x821F1178;
		  /* 821F1178h */ case    7:  		/* li R7, 12 */
		/* 821F1178h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 821F1178h case    7:*/		return 0x821F117C;
		  /* 821F117Ch */ case    8:  		/* li R6, 1 */
		/* 821F117Ch case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F117Ch case    8:*/		return 0x821F1180;
		  /* 821F1180h */ case    9:  		/* mr R5, R29 */
		/* 821F1180h case    9:*/		regs.R5 = regs.R29;
		/* 821F1180h case    9:*/		return 0x821F1184;
		  /* 821F1184h */ case   10:  		/* li R4, 0 */
		/* 821F1184h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F1184h case   10:*/		return 0x821F1188;
		  /* 821F1188h */ case   11:  		/* mr R3, R31 */
		/* 821F1188h case   11:*/		regs.R3 = regs.R31;
		/* 821F1188h case   11:*/		return 0x821F118C;
		  /* 821F118Ch */ case   12:  		/* bl -564 */
		/* 821F118Ch case   12:*/		regs.LR = 0x821F1190; return 0x821F0F58;
		/* 821F118Ch case   12:*/		return 0x821F1190;
		  /* 821F1190h */ case   13:  		/* lwz R30, <#[R3 + 24]> */
		/* 821F1190h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000018) );
		/* 821F1190h case   13:*/		return 0x821F1194;
		  /* 821F1194h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 821F1194h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F1194h case   14:*/		return 0x821F1198;
		  /* 821F1198h */ case   15:  		/* bc 12, CR6_EQ, 92 */
		/* 821F1198h case   15:*/		if ( regs.CR[6].eq ) { return 0x821F11F4;  }
		/* 821F1198h case   15:*/		return 0x821F119C;
		  /* 821F119Ch */ case   16:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F119Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F119Ch case   16:*/		return 0x821F11A0;
		  /* 821F11A0h */ case   17:  		/* cmpwi CR6, R11, 11 */
		/* 821F11A0h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 821F11A0h case   17:*/		return 0x821F11A4;
		  /* 821F11A4h */ case   18:  		/* bc 4, CR6_EQ, 80 */
		/* 821F11A4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821F11F4;  }
		/* 821F11A4h case   18:*/		return 0x821F11A8;
		  /* 821F11A8h */ case   19:  		/* mr R5, R24 */
		/* 821F11A8h case   19:*/		regs.R5 = regs.R24;
		/* 821F11A8h case   19:*/		return 0x821F11AC;
		  /* 821F11ACh */ case   20:  		/* mr R4, R25 */
		/* 821F11ACh case   20:*/		regs.R4 = regs.R25;
		/* 821F11ACh case   20:*/		return 0x821F11B0;
		  /* 821F11B0h */ case   21:  		/* mr R3, R31 */
		/* 821F11B0h case   21:*/		regs.R3 = regs.R31;
		/* 821F11B0h case   21:*/		return 0x821F11B4;
		  /* 821F11B4h */ case   22:  		/* bl -1780 */
		/* 821F11B4h case   22:*/		regs.LR = 0x821F11B8; return 0x821F0AC0;
		/* 821F11B4h case   22:*/		return 0x821F11B8;
		  /* 821F11B8h */ case   23:  		/* stw R3, <#[R30 + 60]> */
		/* 821F11B8h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000003C) );
		/* 821F11B8h case   23:*/		return 0x821F11BC;
		  /* 821F11BCh */ case   24:  		/* mr R6, R28 */
		/* 821F11BCh case   24:*/		regs.R6 = regs.R28;
		/* 821F11BCh case   24:*/		return 0x821F11C0;
		  /* 821F11C0h */ case   25:  		/* mr R5, R29 */
		/* 821F11C0h case   25:*/		regs.R5 = regs.R29;
		/* 821F11C0h case   25:*/		return 0x821F11C4;
		  /* 821F11C4h */ case   26:  		/* mr R4, R27 */
		/* 821F11C4h case   26:*/		regs.R4 = regs.R27;
		/* 821F11C4h case   26:*/		return 0x821F11C8;
		  /* 821F11C8h */ case   27:  		/* mr R3, R31 */
		/* 821F11C8h case   27:*/		regs.R3 = regs.R31;
		/* 821F11C8h case   27:*/		return 0x821F11CC;
		  /* 821F11CCh */ case   28:  		/* bl -16324 */
		/* 821F11CCh case   28:*/		regs.LR = 0x821F11D0; return 0x821ED208;
		/* 821F11CCh case   28:*/		return 0x821F11D0;
		  /* 821F11D0h */ case   29:  		/* lis R11, -32255 */
		/* 821F11D0h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821F11D0h case   29:*/		return 0x821F11D4;
		  /* 821F11D4h */ case   30:  		/* mr R4, R3 */
		/* 821F11D4h case   30:*/		regs.R4 = regs.R3;
		/* 821F11D4h case   30:*/		return 0x821F11D8;
		  /* 821F11D8h */ case   31:  		/* lwz R5, <#[R26]> */
		/* 821F11D8h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000000) );
		/* 821F11D8h case   31:*/		return 0x821F11DC;
		  /* 821F11DCh */ case   32:  		/* addi R6, R11, 9252 */
		/* 821F11DCh case   32:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2424);
		/* 821F11DCh case   32:*/		return 0x821F11E0;
		  /* 821F11E0h */ case   33:  		/* mr R3, R31 */
		/* 821F11E0h case   33:*/		regs.R3 = regs.R31;
		/* 821F11E0h case   33:*/		return 0x821F11E4;
		  /* 821F11E4h */ case   34:  		/* bl -17012 */
		/* 821F11E4h case   34:*/		regs.LR = 0x821F11E8; return 0x821ECF70;
		/* 821F11E4h case   34:*/		return 0x821F11E8;
		  /* 821F11E8h */ case   35:  		/* stw R3, <#[R26]> */
		/* 821F11E8h case   35:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + 0x00000000) );
		/* 821F11E8h case   35:*/		return 0x821F11EC;
		  /* 821F11ECh */ case   36:  		/* addi R1, R1, 160 */
		/* 821F11ECh case   36:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821F11ECh case   36:*/		return 0x821F11F0;
		  /* 821F11F0h */ case   37:  		/* b -1441624 */
		/* 821F11F0h case   37:*/		return 0x82091298;
		/* 821F11F0h case   37:*/		return 0x821F11F4;
	}
	return 0x821F11F4;
} // Block from 821F115Ch-821F11F4h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821F11F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F11F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F11F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F11F4);
		  /* 821F11F4h */ case    0:  		/* li R4, 4801 */
		/* 821F11F4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F11F4h case    0:*/		return 0x821F11F8;
		  /* 821F11F8h */ case    1:  		/* mr R3, R31 */
		/* 821F11F8h case    1:*/		regs.R3 = regs.R31;
		/* 821F11F8h case    1:*/		return 0x821F11FC;
		  /* 821F11FCh */ case    2:  		/* bl -652180 */
		/* 821F11FCh case    2:*/		regs.LR = 0x821F1200; return 0x82151E68;
		/* 821F11FCh case    2:*/		return 0x821F1200;
	}
	return 0x821F1200;
} // Block from 821F11F4h-821F1200h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F1200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1200);
		  /* 821F1200h */ case    0:  		/* mr R5, R4 */
		/* 821F1200h case    0:*/		regs.R5 = regs.R4;
		/* 821F1200h case    0:*/		return 0x821F1204;
		  /* 821F1204h */ case    1:  		/* li R4, 3500 */
		/* 821F1204h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 821F1204h case    1:*/		return 0x821F1208;
		  /* 821F1208h */ case    2:  		/* mr R3, R31 */
		/* 821F1208h case    2:*/		regs.R3 = regs.R31;
		/* 821F1208h case    2:*/		return 0x821F120C;
		  /* 821F120Ch */ case    3:  		/* bl -652196 */
		/* 821F120Ch case    3:*/		regs.LR = 0x821F1210; return 0x82151E68;
		/* 821F120Ch case    3:*/		return 0x821F1210;
	}
	return 0x821F1210;
} // Block from 821F1200h-821F1210h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F1210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1210);
		  /* 821F1210h */ case    0:  		/* mfspr R12, LR */
		/* 821F1210h case    0:*/		regs.R12 = regs.LR;
		/* 821F1210h case    0:*/		return 0x821F1214;
		  /* 821F1214h */ case    1:  		/* bl -1441724 */
		/* 821F1214h case    1:*/		regs.LR = 0x821F1218; return 0x82091258;
		/* 821F1214h case    1:*/		return 0x821F1218;
		  /* 821F1218h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F1218h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F1218h case    2:*/		return 0x821F121C;
		  /* 821F121Ch */ case    3:  		/* mr R30, R3 */
		/* 821F121Ch case    3:*/		regs.R30 = regs.R3;
		/* 821F121Ch case    3:*/		return 0x821F1220;
		  /* 821F1220h */ case    4:  		/* mr R29, R7 */
		/* 821F1220h case    4:*/		regs.R29 = regs.R7;
		/* 821F1220h case    4:*/		return 0x821F1224;
		  /* 821F1224h */ case    5:  		/* mr R28, R8 */
		/* 821F1224h case    5:*/		regs.R28 = regs.R8;
		/* 821F1224h case    5:*/		return 0x821F1228;
		  /* 821F1228h */ case    6:  		/* mr R10, R9 */
		/* 821F1228h case    6:*/		regs.R10 = regs.R9;
		/* 821F1228h case    6:*/		return 0x821F122C;
		  /* 821F122Ch */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 821F122Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821F122Ch case    7:*/		return 0x821F1230;
		  /* 821F1230h */ case    8:  		/* bc 12, CR6_EQ, 156 */
		/* 821F1230h case    8:*/		if ( regs.CR[6].eq ) { return 0x821F12CC;  }
		/* 821F1230h case    8:*/		return 0x821F1234;
		  /* 821F1234h */ case    9:  		/* addic. R11, R6, 1 */
		/* 821F1234h case    9:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R6,0x1);
		/* 821F1234h case    9:*/		return 0x821F1238;
		  /* 821F1238h */ case   10:  		/* bc 12, CR0_EQ, 24 */
		/* 821F1238h case   10:*/		if ( regs.CR[0].eq ) { return 0x821F1250;  }
		/* 821F1238h case   10:*/		return 0x821F123C;
		  /* 821F123Ch */ case   11:  		/* addi R9, R11, -1 */
		/* 821F123Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 821F123Ch case   11:*/		return 0x821F1240;
	}
	return 0x821F1240;
} // Block from 821F1210h-821F1240h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F1240h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1240);
		  /* 821F1240h */ case    0:  		/* andc R9, R11, R9 */
		/* 821F1240h case    0:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821F1240h case    0:*/		return 0x821F1244;
		  /* 821F1244h */ case    1:  		/* subf. R11, R9, R11 */
		/* 821F1244h case    1:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F1244h case    1:*/		return 0x821F1248;
		  /* 821F1248h */ case    2:  		/* li R11, 1 */
		/* 821F1248h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1248h case    2:*/		return 0x821F124C;
		  /* 821F124Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821F124Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x821F1254;  }
		/* 821F124Ch case    3:*/		return 0x821F1250;
	}
	return 0x821F1250;
} // Block from 821F1240h-821F1250h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F1250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1250);
		  /* 821F1250h */ case    0:  		/* li R11, 0 */
		/* 821F1250h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F1250h case    0:*/		return 0x821F1254;
	}
	return 0x821F1254;
} // Block from 821F1250h-821F1254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1254);
		  /* 821F1254h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821F1254h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821F1254h case    0:*/		return 0x821F1258;
		  /* 821F1258h */ case    1:  		/* bc 12, CR0_EQ, 116 */
		/* 821F1258h case    1:*/		if ( regs.CR[0].eq ) { return 0x821F12CC;  }
		/* 821F1258h case    1:*/		return 0x821F125C;
		  /* 821F125Ch */ case    2:  		/* cntlzw R11, R6 */
		/* 821F125Ch case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R6);
		/* 821F125Ch case    2:*/		return 0x821F1260;
		  /* 821F1260h */ case    3:  		/* li R8, 1 */
		/* 821F1260h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F1260h case    3:*/		return 0x821F1264;
		  /* 821F1264h */ case    4:  		/* subfic R9, R11, 32 */
		/* 821F1264h case    4:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R11,0x20);
		/* 821F1264h case    4:*/		return 0x821F1268;
		  /* 821F1268h */ case    5:  		/* li R7, 12 */
		/* 821F1268h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 821F1268h case    5:*/		return 0x821F126C;
		  /* 821F126Ch */ case    6:  		/* li R6, 1 */
		/* 821F126Ch case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F126Ch case    6:*/		return 0x821F1270;
		  /* 821F1270h */ case    7:  		/* addi R5, R5, 624 */
		/* 821F1270h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x270);
		/* 821F1270h case    7:*/		return 0x821F1274;
		  /* 821F1274h */ case    8:  		/* li R4, 0 */
		/* 821F1274h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F1274h case    8:*/		return 0x821F1278;
		  /* 821F1278h */ case    9:  		/* mr R3, R30 */
		/* 821F1278h case    9:*/		regs.R3 = regs.R30;
		/* 821F1278h case    9:*/		return 0x821F127C;
		  /* 821F127Ch */ case   10:  		/* bl -804 */
		/* 821F127Ch case   10:*/		regs.LR = 0x821F1280; return 0x821F0F58;
		/* 821F127Ch case   10:*/		return 0x821F1280;
		  /* 821F1280h */ case   11:  		/* lwz R31, <#[R3 + 24]> */
		/* 821F1280h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000018) );
		/* 821F1280h case   11:*/		return 0x821F1284;
		  /* 821F1284h */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 821F1284h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821F1284h case   12:*/		return 0x821F1288;
		  /* 821F1288h */ case   13:  		/* bc 12, CR6_EQ, 56 */
		/* 821F1288h case   13:*/		if ( regs.CR[6].eq ) { return 0x821F12C0;  }
		/* 821F1288h case   13:*/		return 0x821F128C;
		  /* 821F128Ch */ case   14:  		/* lwz R11, <#[R31 + 4]> */
		/* 821F128Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821F128Ch case   14:*/		return 0x821F1290;
		  /* 821F1290h */ case   15:  		/* cmpwi CR6, R11, 11 */
		/* 821F1290h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 821F1290h case   15:*/		return 0x821F1294;
		  /* 821F1294h */ case   16:  		/* bc 4, CR6_EQ, 44 */
		/* 821F1294h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821F12C0;  }
		/* 821F1294h case   16:*/		return 0x821F1298;
		  /* 821F1298h */ case   17:  		/* lwz R11, <#[R31 + 44]> */
		/* 821F1298h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F1298h case   17:*/		return 0x821F129C;
		  /* 821F129Ch */ case   18:  		/* mr R5, R28 */
		/* 821F129Ch case   18:*/		regs.R5 = regs.R28;
		/* 821F129Ch case   18:*/		return 0x821F12A0;
		  /* 821F12A0h */ case   19:  		/* mr R4, R29 */
		/* 821F12A0h case   19:*/		regs.R4 = regs.R29;
		/* 821F12A0h case   19:*/		return 0x821F12A4;
		  /* 821F12A4h */ case   20:  		/* ori R11, R11, 32 */
		/* 821F12A4h case   20:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821F12A4h case   20:*/		return 0x821F12A8;
		  /* 821F12A8h */ case   21:  		/* mr R3, R30 */
		/* 821F12A8h case   21:*/		regs.R3 = regs.R30;
		/* 821F12A8h case   21:*/		return 0x821F12AC;
		  /* 821F12ACh */ case   22:  		/* stw R11, <#[R31 + 44]> */
		/* 821F12ACh case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F12ACh case   22:*/		return 0x821F12B0;
		  /* 821F12B0h */ case   23:  		/* bl -2032 */
		/* 821F12B0h case   23:*/		regs.LR = 0x821F12B4; return 0x821F0AC0;
		/* 821F12B0h case   23:*/		return 0x821F12B4;
		  /* 821F12B4h */ case   24:  		/* stw R3, <#[R31 + 60]> */
		/* 821F12B4h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 821F12B4h case   24:*/		return 0x821F12B8;
		  /* 821F12B8h */ case   25:  		/* addi R1, R1, 128 */
		/* 821F12B8h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F12B8h case   25:*/		return 0x821F12BC;
		  /* 821F12BCh */ case   26:  		/* b -1441812 */
		/* 821F12BCh case   26:*/		return 0x820912A8;
		/* 821F12BCh case   26:*/		return 0x821F12C0;
	}
	return 0x821F12C0;
} // Block from 821F1254h-821F12C0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821F12C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F12C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F12C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F12C0);
		  /* 821F12C0h */ case    0:  		/* li R4, 4801 */
		/* 821F12C0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F12C0h case    0:*/		return 0x821F12C4;
		  /* 821F12C4h */ case    1:  		/* mr R3, R30 */
		/* 821F12C4h case    1:*/		regs.R3 = regs.R30;
		/* 821F12C4h case    1:*/		return 0x821F12C8;
		  /* 821F12C8h */ case    2:  		/* bl -652384 */
		/* 821F12C8h case    2:*/		regs.LR = 0x821F12CC; return 0x82151E68;
		/* 821F12C8h case    2:*/		return 0x821F12CC;
	}
	return 0x821F12CC;
} // Block from 821F12C0h-821F12CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F12CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F12CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F12CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F12CC);
		  /* 821F12CCh */ case    0:  		/* mr R5, R4 */
		/* 821F12CCh case    0:*/		regs.R5 = regs.R4;
		/* 821F12CCh case    0:*/		return 0x821F12D0;
		  /* 821F12D0h */ case    1:  		/* li R4, 3500 */
		/* 821F12D0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 821F12D0h case    1:*/		return 0x821F12D4;
		  /* 821F12D4h */ case    2:  		/* mr R3, R30 */
		/* 821F12D4h case    2:*/		regs.R3 = regs.R30;
		/* 821F12D4h case    2:*/		return 0x821F12D8;
		  /* 821F12D8h */ case    3:  		/* bl -652400 */
		/* 821F12D8h case    3:*/		regs.LR = 0x821F12DC; return 0x82151E68;
		/* 821F12D8h case    3:*/		return 0x821F12DC;
		  /* 821F12DCh */ case    4:  		/* nop */
		/* 821F12DCh case    4:*/		cpu::op::nop();
		/* 821F12DCh case    4:*/		return 0x821F12E0;
	}
	return 0x821F12E0;
} // Block from 821F12CCh-821F12E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F12E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F12E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F12E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F12E0);
		  /* 821F12E0h */ case    0:  		/* mfspr R12, LR */
		/* 821F12E0h case    0:*/		regs.R12 = regs.LR;
		/* 821F12E0h case    0:*/		return 0x821F12E4;
		  /* 821F12E4h */ case    1:  		/* bl -1441932 */
		/* 821F12E4h case    1:*/		regs.LR = 0x821F12E8; return 0x82091258;
		/* 821F12E4h case    1:*/		return 0x821F12E8;
		  /* 821F12E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F12E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F12E8h case    2:*/		return 0x821F12EC;
		  /* 821F12ECh */ case    3:  		/* lwz R11, <#[R3 + 756]> */
		/* 821F12ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002F4) );
		/* 821F12ECh case    3:*/		return 0x821F12F0;
		  /* 821F12F0h */ case    4:  		/* mr R31, R3 */
		/* 821F12F0h case    4:*/		regs.R31 = regs.R3;
		/* 821F12F0h case    4:*/		return 0x821F12F4;
		  /* 821F12F4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821F12F4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F12F4h case    5:*/		return 0x821F12F8;
		  /* 821F12F8h */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 821F12F8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821F1318;  }
		/* 821F12F8h case    6:*/		return 0x821F12FC;
		  /* 821F12FCh */ case    7:  		/* li R5, 0 */
		/* 821F12FCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F12FCh case    7:*/		return 0x821F1300;
		  /* 821F1300h */ case    8:  		/* li R4, 40 */
		/* 821F1300h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 821F1300h case    8:*/		return 0x821F1304;
		  /* 821F1304h */ case    9:  		/* bl -412892 */
		/* 821F1304h case    9:*/		regs.LR = 0x821F1308; return 0x8218C628;
		/* 821F1304h case    9:*/		return 0x821F1308;
		  /* 821F1308h */ case   10:  		/* li R11, 10 */
		/* 821F1308h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0xA);
		/* 821F1308h case   10:*/		return 0x821F130C;
		  /* 821F130Ch */ case   11:  		/* stw R3, <#[R31 + 756]> */
		/* 821F130Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000002F4) );
		/* 821F130Ch case   11:*/		return 0x821F1310;
		  /* 821F1310h */ case   12:  		/* stw R11, <#[R3]> */
		/* 821F1310h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1310h case   12:*/		return 0x821F1314;
		  /* 821F1314h */ case   13:  		/* b 92 */
		/* 821F1314h case   13:*/		return 0x821F1370;
		/* 821F1314h case   13:*/		return 0x821F1318;
	}
	return 0x821F1318;
} // Block from 821F12E0h-821F1318h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F1318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1318);
		  /* 821F1318h */ case    0:  		/* lwz R10, <#[R31 + 32]> */
		/* 821F1318h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 821F1318h case    0:*/		return 0x821F131C;
		  /* 821F131Ch */ case    1:  		/* lwz R30, <#[R11]> */
		/* 821F131Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 821F131Ch case    1:*/		return 0x821F1320;
		  /* 821F1320h */ case    2:  		/* addi R11, R10, 1 */
		/* 821F1320h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 821F1320h case    2:*/		return 0x821F1324;
		  /* 821F1324h */ case    3:  		/* cmplw CR6, R11, R30 */
		/* 821F1324h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821F1324h case    3:*/		return 0x821F1328;
	}
	return 0x821F1328;
} // Block from 821F1318h-821F1328h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F1328h
// Function '?MakeInstr_V_CNDE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@VResult@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1328);
		  /* 821F1328h */ case    0:  		/* bc 12, CR6_LT, 72 */
		/* 821F1328h case    0:*/		if ( regs.CR[6].lt ) { return 0x821F1370;  }
		/* 821F1328h case    0:*/		return 0x821F132C;
		  /* 821F132Ch */ case    1:  		/* li R5, 0 */
		/* 821F132Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F132Ch case    1:*/		return 0x821F1330;
		  /* 821F1330h */ case    2:  		/* rlwinm R4, R30, 3, 0, 28 */
		/* 821F1330h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R30);
		/* 821F1330h case    2:*/		return 0x821F1334;
		  /* 821F1334h */ case    3:  		/* mr R3, R31 */
		/* 821F1334h case    3:*/		regs.R3 = regs.R31;
		/* 821F1334h case    3:*/		return 0x821F1338;
		  /* 821F1338h */ case    4:  		/* rlwinm R29, R30, 1, 0, 30 */
		/* 821F1338h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R30);
		/* 821F1338h case    4:*/		return 0x821F133C;
		  /* 821F133Ch */ case    5:  		/* bl -412948 */
		/* 821F133Ch case    5:*/		regs.LR = 0x821F1340; return 0x8218C628;
		/* 821F133Ch case    5:*/		return 0x821F1340;
		  /* 821F1340h */ case    6:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 821F1340h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 821F1340h case    6:*/		return 0x821F1344;
		  /* 821F1344h */ case    7:  		/* lwz R4, <#[R31 + 756]> */
		/* 821F1344h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000002F4) );
		/* 821F1344h case    7:*/		return 0x821F1348;
		  /* 821F1348h */ case    8:  		/* mr R28, R3 */
		/* 821F1348h case    8:*/		regs.R28 = regs.R3;
		/* 821F1348h case    8:*/		return 0x821F134C;
		  /* 821F134Ch */ case    9:  		/* mr R5, R30 */
		/* 821F134Ch case    9:*/		regs.R5 = regs.R30;
		/* 821F134Ch case    9:*/		return 0x821F1350;
		  /* 821F1350h */ case   10:  		/* bl -1440160 */
		/* 821F1350h case   10:*/		regs.LR = 0x821F1354; return 0x820919B0;
		/* 821F1350h case   10:*/		return 0x821F1354;
		  /* 821F1354h */ case   11:  		/* stw R29, <#[R28]> */
		/* 821F1354h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 821F1354h case   11:*/		return 0x821F1358;
		  /* 821F1358h */ case   12:  		/* li R6, 0 */
		/* 821F1358h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F1358h case   12:*/		return 0x821F135C;
		  /* 821F135Ch */ case   13:  		/* lwz R4, <#[R31 + 756]> */
		/* 821F135Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000002F4) );
		/* 821F135Ch case   13:*/		return 0x821F1360;
		  /* 821F1360h */ case   14:  		/* mr R5, R30 */
		/* 821F1360h case   14:*/		regs.R5 = regs.R30;
		/* 821F1360h case   14:*/		return 0x821F1364;
		  /* 821F1364h */ case   15:  		/* mr R3, R31 */
		/* 821F1364h case   15:*/		regs.R3 = regs.R31;
		/* 821F1364h case   15:*/		return 0x821F1368;
		  /* 821F1368h */ case   16:  		/* bl -575184 */
		/* 821F1368h case   16:*/		regs.LR = 0x821F136C; return 0x82164C98;
		/* 821F1368h case   16:*/		return 0x821F136C;
		  /* 821F136Ch */ case   17:  		/* stw R28, <#[R31 + 756]> */
		/* 821F136Ch case   17:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x000002F4) );
		/* 821F136Ch case   17:*/		return 0x821F1370;
	}
	return 0x821F1370;
} // Block from 821F1328h-821F1370h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F1370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1370);
		  /* 821F1370h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 821F1370h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 821F1370h case    0:*/		return 0x821F1374;
		  /* 821F1374h */ case    1:  		/* lwz R10, <#[R31 + 756]> */
		/* 821F1374h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000002F4) );
		/* 821F1374h case    1:*/		return 0x821F1378;
		  /* 821F1378h */ case    2:  		/* lwz R9, <#[R31 + 752]> */
		/* 821F1378h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002F0) );
		/* 821F1378h case    2:*/		return 0x821F137C;
		  /* 821F137Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821F137Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821F137Ch case    3:*/		return 0x821F1380;
		  /* 821F1380h */ case    4:  		/* stwx R9, <#[R11 + R10]> */
		/* 821F1380h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821F1380h case    4:*/		return 0x821F1384;
		  /* 821F1384h */ case    5:  		/* addi R1, R1, 128 */
		/* 821F1384h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F1384h case    5:*/		return 0x821F1388;
		  /* 821F1388h */ case    6:  		/* b -1442016 */
		/* 821F1388h case    6:*/		return 0x820912A8;
		/* 821F1388h case    6:*/		return 0x821F138C;
		  /* 821F138Ch */ case    7:  		/* nop */
		/* 821F138Ch case    7:*/		cpu::op::nop();
		/* 821F138Ch case    7:*/		return 0x821F1390;
	}
	return 0x821F1390;
} // Block from 821F1370h-821F1390h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F1390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1390);
		  /* 821F1390h */ case    0:  		/* mfspr R12, LR */
		/* 821F1390h case    0:*/		regs.R12 = regs.LR;
		/* 821F1390h case    0:*/		return 0x821F1394;
		  /* 821F1394h */ case    1:  		/* bl -1442144 */
		/* 821F1394h case    1:*/		regs.LR = 0x821F1398; return 0x82091234;
		/* 821F1394h case    1:*/		return 0x821F1398;
		  /* 821F1398h */ case    2:  		/* stfd FR31, <#[R1 - 120]> */
		/* 821F1398h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 821F1398h case    2:*/		return 0x821F139C;
		  /* 821F139Ch */ case    3:  		/* stwu R1, <#[R1 - 256]> */
		/* 821F139Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 821F139Ch case    3:*/		return 0x821F13A0;
		  /* 821F13A0h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F13A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F13A0h case    4:*/		return 0x821F13A4;
		  /* 821F13A4h */ case    5:  		/* li R21, 0 */
		/* 821F13A4h case    5:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821F13A4h case    5:*/		return 0x821F13A8;
		  /* 821F13A8h */ case    6:  		/* mr R30, R3 */
		/* 821F13A8h case    6:*/		regs.R30 = regs.R3;
		/* 821F13A8h case    6:*/		return 0x821F13AC;
		  /* 821F13ACh */ case    7:  		/* mr R26, R4 */
		/* 821F13ACh case    7:*/		regs.R26 = regs.R4;
		/* 821F13ACh case    7:*/		return 0x821F13B0;
		  /* 821F13B0h */ case    8:  		/* stw R21, <#[R1 + 96]> */
		/* 821F13B0h case    8:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000060) );
		/* 821F13B0h case    8:*/		return 0x821F13B4;
		  /* 821F13B4h */ case    9:  		/* mr R23, R5 */
		/* 821F13B4h case    9:*/		regs.R23 = regs.R5;
		/* 821F13B4h case    9:*/		return 0x821F13B8;
		  /* 821F13B8h */ case   10:  		/* stw R21, <#[R1 + 80]> */
		/* 821F13B8h case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000050) );
		/* 821F13B8h case   10:*/		return 0x821F13BC;
		  /* 821F13BCh */ case   11:  		/* mr R25, R6 */
		/* 821F13BCh case   11:*/		regs.R25 = regs.R6;
		/* 821F13BCh case   11:*/		return 0x821F13C0;
		  /* 821F13C0h */ case   12:  		/* mr R24, R21 */
		/* 821F13C0h case   12:*/		regs.R24 = regs.R21;
		/* 821F13C0h case   12:*/		return 0x821F13C4;
		  /* 821F13C4h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 17 */
		/* 821F13C4h case   13:*/		cpu::op::rlwinm<1,0,4,17>(regs,&regs.R11,regs.R11);
		/* 821F13C4h case   13:*/		return 0x821F13C8;
		  /* 821F13C8h */ case   14:  		/* mr R19, R21 */
		/* 821F13C8h case   14:*/		regs.R19 = regs.R21;
		/* 821F13C8h case   14:*/		return 0x821F13CC;
		  /* 821F13CCh */ case   15:  		/* mr R22, R21 */
		/* 821F13CCh case   15:*/		regs.R22 = regs.R21;
		/* 821F13CCh case   15:*/		return 0x821F13D0;
		  /* 821F13D0h */ case   16:  		/* bc 12, CR0_EQ, 488 */
		/* 821F13D0h case   16:*/		if ( regs.CR[0].eq ) { return 0x821F15B8;  }
		/* 821F13D0h case   16:*/		return 0x821F13D4;
		  /* 821F13D4h */ case   17:  		/* lis R11, -32256 */
		/* 821F13D4h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F13D4h case   17:*/		return 0x821F13D8;
		  /* 821F13D8h */ case   18:  		/* addi R20, R4, 12 */
		/* 821F13D8h case   18:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R4,0xC);
		/* 821F13D8h case   18:*/		return 0x821F13DC;
		  /* 821F13DCh */ case   19:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 821F13DCh case   19:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 821F13DCh case   19:*/		return 0x821F13E0;
		  /* 821F13E0h */ case   20:  		/* ld R31, <#[R20]> */
		/* 821F13E0h case   20:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R20 + 0x00000000) );
		/* 821F13E0h case   20:*/		return 0x821F13E4;
		  /* 821F13E4h */ case   21:  		/* std R31, <#[R1 + 88]> */
		/* 821F13E4h case   21:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 821F13E4h case   21:*/		return 0x821F13E8;
		  /* 821F13E8h */ case   22:  		/* lwz R28, <#[R1 + 92]> */
		/* 821F13E8h case   22:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 821F13E8h case   22:*/		return 0x821F13EC;
		  /* 821F13ECh */ case   23:  		/* rlwinm R11, R28, 0, 30, 31 */
		/* 821F13ECh case   23:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R28);
		/* 821F13ECh case   23:*/		return 0x821F13F0;
		  /* 821F13F0h */ case   24:  		/* cmpwi CR6, R11, 3 */
		/* 821F13F0h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821F13F0h case   24:*/		return 0x821F13F4;
		  /* 821F13F4h */ case   25:  		/* bc 4, CR6_EQ, 132 */
		/* 821F13F4h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821F1478;  }
		/* 821F13F4h case   25:*/		return 0x821F13F8;
		  /* 821F13F8h */ case   26:  		/* rlwinm. R11, R28, 16, 31, 31 */
		/* 821F13F8h case   26:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R11,regs.R28);
		/* 821F13F8h case   26:*/		return 0x821F13FC;
		  /* 821F13FCh */ case   27:  		/* bc 12, CR0_EQ, 124 */
		/* 821F13FCh case   27:*/		if ( regs.CR[0].eq ) { return 0x821F1478;  }
		/* 821F13FCh case   27:*/		return 0x821F1400;
		  /* 821F1400h */ case   28:  		/* lwz R31, <#[R1 + 88]> */
		/* 821F1400h case   28:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 821F1400h case   28:*/		return 0x821F1404;
		  /* 821F1404h */ case   29:  		/* cmplwi CR6, R19, 0 */
		/* 821F1404h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 821F1404h case   29:*/		return 0x821F1408;
		  /* 821F1408h */ case   30:  		/* bc 12, CR6_EQ, 16 */
		/* 821F1408h case   30:*/		if ( regs.CR[6].eq ) { return 0x821F1418;  }
		/* 821F1408h case   30:*/		return 0x821F140C;
		  /* 821F140Ch */ case   31:  		/* lwz R11, <#[R31]> */
		/* 821F140Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821F140Ch case   31:*/		return 0x821F1410;
		  /* 821F1410h */ case   32:  		/* cmplw CR6, R19, R11 */
		/* 821F1410h case   32:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R11);
		/* 821F1410h case   32:*/		return 0x821F1414;
		  /* 821F1414h */ case   33:  		/* bc 12, CR6_EQ, 52 */
		/* 821F1414h case   33:*/		if ( regs.CR[6].eq ) { return 0x821F1448;  }
		/* 821F1414h case   33:*/		return 0x821F1418;
	}
	return 0x821F1418;
} // Block from 821F1390h-821F1418h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821F1418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1418);
		  /* 821F1418h */ case    0:  		/* ld R11, <#[R31]> */
		/* 821F1418h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1418h case    0:*/		return 0x821F141C;
		  /* 821F141Ch */ case    1:  		/* mr R4, R23 */
		/* 821F141Ch case    1:*/		regs.R4 = regs.R23;
		/* 821F141Ch case    1:*/		return 0x821F1420;
		  /* 821F1420h */ case    2:  		/* mr R3, R30 */
		/* 821F1420h case    2:*/		regs.R3 = regs.R30;
		/* 821F1420h case    2:*/		return 0x821F1424;
		  /* 821F1424h */ case    3:  		/* mr R5, R11 */
		/* 821F1424h case    3:*/		regs.R5 = regs.R11;
		/* 821F1424h case    3:*/		return 0x821F1428;
	}
	return 0x821F1428;
} // Block from 821F1418h-821F1428h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F1428h
// Function '?GetOrCreateVariableDefs@Block@D3DXShader@@QAAPAVResult@2@IPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1428);
		  /* 821F1428h */ case    0:  		/* std R11, <#[R1 + 104]> */
		/* 821F1428h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 821F1428h case    0:*/		return 0x821F142C;
		  /* 821F142Ch */ case    1:  		/* bl -3172 */
		/* 821F142Ch case    1:*/		regs.LR = 0x821F1430; return 0x821F07C8;
		/* 821F142Ch case    1:*/		return 0x821F1430;
		  /* 821F1430h */ case    2:  		/* lwz R11, <#[R1 + 100]> */
		/* 821F1430h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 821F1430h case    2:*/		return 0x821F1434;
		  /* 821F1434h */ case    3:  		/* lwz R19, <#[R1 + 104]> */
		/* 821F1434h case    3:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000068) );
		/* 821F1434h case    3:*/		return 0x821F1438;
		  /* 821F1438h */ case    4:  		/* rlwinm R11, R11, 0, 15, 15 */
		/* 821F1438h case    4:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R11,regs.R11);
		/* 821F1438h case    4:*/		return 0x821F143C;
		  /* 821F143Ch */ case    5:  		/* stw R3, <#[R1 + 96]> */
		/* 821F143Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 821F143Ch case    5:*/		return 0x821F1440;
		  /* 821F1440h */ case    6:  		/* ori R11, R11, 1 */
		/* 821F1440h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F1440h case    6:*/		return 0x821F1444;
		  /* 821F1444h */ case    7:  		/* stw R11, <#[R1 + 100]> */
		/* 821F1444h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 821F1444h case    7:*/		return 0x821F1448;
	}
	return 0x821F1448;
} // Block from 821F1428h-821F1448h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F1448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1448);
		  /* 821F1448h */ case    0:  		/* mr R6, R25 */
		/* 821F1448h case    0:*/		regs.R6 = regs.R25;
		/* 821F1448h case    0:*/		return 0x821F144C;
		  /* 821F144Ch */ case    1:  		/* ld R5, <#[R1 + 96]> */
		/* 821F144Ch case    1:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 821F144Ch case    1:*/		return 0x821F1450;
		  /* 821F1450h */ case    2:  		/* mr R4, R31 */
		/* 821F1450h case    2:*/		regs.R4 = regs.R31;
		/* 821F1450h case    2:*/		return 0x821F1454;
		  /* 821F1454h */ case    3:  		/* mr R3, R30 */
		/* 821F1454h case    3:*/		regs.R3 = regs.R30;
		/* 821F1454h case    3:*/		return 0x821F1458;
		  /* 821F1458h */ case    4:  		/* bl -200 */
		/* 821F1458h case    4:*/		regs.LR = 0x821F145C; return 0x821F1390;
		/* 821F1458h case    4:*/		return 0x821F145C;
		  /* 821F145Ch */ case    5:  		/* rlwinm R11, R28, 0, 15, 15 */
		/* 821F145Ch case    5:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R11,regs.R28);
		/* 821F145Ch case    5:*/		return 0x821F1460;
		  /* 821F1460h */ case    6:  		/* stw R3, <#[R1 + 88]> */
		/* 821F1460h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 821F1460h case    6:*/		return 0x821F1464;
		  /* 821F1464h */ case    7:  		/* mr R27, R3 */
		/* 821F1464h case    7:*/		regs.R27 = regs.R3;
		/* 821F1464h case    7:*/		return 0x821F1468;
		  /* 821F1468h */ case    8:  		/* ori R28, R11, 1 */
		/* 821F1468h case    8:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R11,0x1);
		/* 821F1468h case    8:*/		return 0x821F146C;
		  /* 821F146Ch */ case    9:  		/* stw R28, <#[R1 + 92]> */
		/* 821F146Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 821F146Ch case    9:*/		return 0x821F1470;
		  /* 821F1470h */ case   10:  		/* ld R31, <#[R1 + 88]> */
		/* 821F1470h case   10:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 821F1470h case   10:*/		return 0x821F1474;
		  /* 821F1474h */ case   11:  		/* b 8 */
		/* 821F1474h case   11:*/		return 0x821F147C;
		/* 821F1474h case   11:*/		return 0x821F1478;
	}
	return 0x821F1478;
} // Block from 821F1448h-821F1478h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F1478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1478);
		  /* 821F1478h */ case    0:  		/* lwz R27, <#[R1 + 88]> */
		/* 821F1478h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 821F1478h case    0:*/		return 0x821F147C;
	}
	return 0x821F147C;
} // Block from 821F1478h-821F147Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F147Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F147C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F147C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F147C);
		  /* 821F147Ch */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821F147Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821F147Ch case    0:*/		return 0x821F1480;
		  /* 821F1480h */ case    1:  		/* bc 12, CR6_EQ, 272 */
		/* 821F1480h case    1:*/		if ( regs.CR[6].eq ) { return 0x821F1590;  }
		/* 821F1480h case    1:*/		return 0x821F1484;
		  /* 821F1484h */ case    2:  		/* rldicl R11, R25, 0, 32 */
		/* 821F1484h case    2:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R25);
		/* 821F1484h case    2:*/		return 0x821F1488;
		  /* 821F1488h */ case    3:  		/* fmr FR4, FR31 */
		/* 821F1488h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821F1488h case    3:*/		return 0x821F148C;
		  /* 821F148Ch */ case    4:  		/* li R5, 1 */
		/* 821F148Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F148Ch case    4:*/		return 0x821F1490;
		  /* 821F1490h */ case    5:  		/* fmr FR3, FR31 */
		/* 821F1490h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821F1490h case    5:*/		return 0x821F1494;
		  /* 821F1494h */ case    6:  		/* std R11, <#[R1 + 112]> */
		/* 821F1494h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 821F1494h case    6:*/		return 0x821F1498;
		  /* 821F1498h */ case    7:  		/* lfd FR0, <#[R1 + 112]> */
		/* 821F1498h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 821F1498h case    7:*/		return 0x821F149C;
		  /* 821F149Ch */ case    8:  		/* fcfid FR0, FR0 */
		/* 821F149Ch case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 821F149Ch case    8:*/		return 0x821F14A0;
		  /* 821F14A0h */ case    9:  		/* mr R4, R30 */
		/* 821F14A0h case    9:*/		regs.R4 = regs.R30;
		/* 821F14A0h case    9:*/		return 0x821F14A4;
		  /* 821F14A4h */ case   10:  		/* frsp FR0, FR0 */
		/* 821F14A4h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 821F14A4h case   10:*/		return 0x821F14A8;
		  /* 821F14A8h */ case   11:  		/* addi R3, R1, 120 */
		/* 821F14A8h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x78);
		/* 821F14A8h case   11:*/		return 0x821F14AC;
		  /* 821F14ACh */ case   12:  		/* fmr FR2, FR31 */
		/* 821F14ACh case   12:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821F14ACh case   12:*/		return 0x821F14B0;
	}
	return 0x821F14B0;
} // Block from 821F147Ch-821F14B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821F14B0h
// Function '?CreateRegisterNode@Compiler@D3DXShader@@AAAPAVCNodeRegister@2@DI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F14B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F14B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F14B0);
		  /* 821F14B0h */ case    0:  		/* fneg FR1, FR0 */
		/* 821F14B0h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 821F14B0h case    0:*/		return 0x821F14B4;
		  /* 821F14B4h */ case    1:  		/* bl 219548 */
		/* 821F14B4h case    1:*/		regs.LR = 0x821F14B8; return 0x82226E50;
		/* 821F14B4h case    1:*/		return 0x821F14B8;
		  /* 821F14B8h */ case    2:  		/* mr R11, R3 */
		/* 821F14B8h case    2:*/		regs.R11 = regs.R3;
		/* 821F14B8h case    2:*/		return 0x821F14BC;
		  /* 821F14BCh */ case    3:  		/* mr R4, R23 */
		/* 821F14BCh case    3:*/		regs.R4 = regs.R23;
		/* 821F14BCh case    3:*/		return 0x821F14C0;
		  /* 821F14C0h */ case    4:  		/* mr R3, R30 */
		/* 821F14C0h case    4:*/		regs.R3 = regs.R30;
		/* 821F14C0h case    4:*/		return 0x821F14C4;
		  /* 821F14C4h */ case    5:  		/* ld R5, <#[R11]> */
		/* 821F14C4h case    5:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 821F14C4h case    5:*/		return 0x821F14C8;
		  /* 821F14C8h */ case    6:  		/* bl -3328 */
		/* 821F14C8h case    6:*/		regs.LR = 0x821F14CC; return 0x821F07C8;
		/* 821F14C8h case    6:*/		return 0x821F14CC;
		  /* 821F14CCh */ case    7:  		/* mr R4, R3 */
		/* 821F14CCh case    7:*/		regs.R4 = regs.R3;
		/* 821F14CCh case    7:*/		return 0x821F14D0;
		  /* 821F14D0h */ case    8:  		/* mr R3, R30 */
		/* 821F14D0h case    8:*/		regs.R3 = regs.R30;
		/* 821F14D0h case    8:*/		return 0x821F14D4;
		  /* 821F14D4h */ case    9:  		/* bl -496852 */
		/* 821F14D4h case    9:*/		regs.LR = 0x821F14D8; return 0x82178000;
		/* 821F14D4h case    9:*/		return 0x821F14D8;
		  /* 821F14D8h */ case   10:  		/* rlwinm R29, R28, 0, 30, 31 */
		/* 821F14D8h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R29,regs.R28);
		/* 821F14D8h case   10:*/		return 0x821F14DC;
		  /* 821F14DCh */ case   11:  		/* mr R4, R3 */
		/* 821F14DCh case   11:*/		regs.R4 = regs.R3;
		/* 821F14DCh case   11:*/		return 0x821F14E0;
		  /* 821F14E0h */ case   12:  		/* cmplwi CR6, R29, 1 */
		/* 821F14E0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 821F14E0h case   12:*/		return 0x821F14E4;
		  /* 821F14E4h */ case   13:  		/* bc 4, CR6_EQ, 32 */
		/* 821F14E4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821F1504;  }
		/* 821F14E4h case   13:*/		return 0x821F14E8;
		  /* 821F14E8h */ case   14:  		/* rlwinm. R11, R28, 0, 0, 14 */
		/* 821F14E8h case   14:*/		cpu::op::rlwinm<1,0,0,14>(regs,&regs.R11,regs.R28);
		/* 821F14E8h case   14:*/		return 0x821F14EC;
		  /* 821F14ECh */ case   15:  		/* bc 12, CR0_EQ, 24 */
		/* 821F14ECh case   15:*/		if ( regs.CR[0].eq ) { return 0x821F1504;  }
		/* 821F14ECh case   15:*/		return 0x821F14F0;
		  /* 821F14F0h */ case   16:  		/* lwz R11, <#[R27 + 8]> */
		/* 821F14F0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821F14F0h case   16:*/		return 0x821F14F4;
		  /* 821F14F4h */ case   17:  		/* lwz R10, <#[R3]> */
		/* 821F14F4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F14F4h case   17:*/		return 0x821F14F8;
		  /* 821F14F8h */ case   18:  		/* rlwimi R10, R11, 11, 4, 6 */
		/* 821F14F8h case   18:*/		cpu::op::rlwimi<0,11,4,6>(regs,&regs.R10,regs.R11);
		/* 821F14F8h case   18:*/		return 0x821F14FC;
		  /* 821F14FCh */ case   19:  		/* rlwinm R11, R10, 0, 27, 18 */
		/* 821F14FCh case   19:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R10);
		/* 821F14FCh case   19:*/		return 0x821F1500;
		  /* 821F1500h */ case   20:  		/* stw R11, <#[R3]> */
		/* 821F1500h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1500h case   20:*/		return 0x821F1504;
	}
	return 0x821F1504;
} // Block from 821F14B0h-821F1504h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F1504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1504);
		  /* 821F1504h */ case    0:  		/* mr R5, R31 */
		/* 821F1504h case    0:*/		regs.R5 = regs.R31;
		/* 821F1504h case    0:*/		return 0x821F1508;
		  /* 821F1508h */ case    1:  		/* ld R6, <#[R1 + 80]> */
		/* 821F1508h case    1:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 821F1508h case    1:*/		return 0x821F150C;
		  /* 821F150Ch */ case    2:  		/* mr R3, R30 */
		/* 821F150Ch case    2:*/		regs.R3 = regs.R30;
		/* 821F150Ch case    2:*/		return 0x821F1510;
		  /* 821F1510h */ case    3:  		/* bl -3168 */
		/* 821F1510h case    3:*/		regs.LR = 0x821F1514; return 0x821F08B0;
		/* 821F1510h case    3:*/		return 0x821F1514;
		  /* 821F1514h */ case    4:  		/* lwz R11, <#[R26 + 8]> */
		/* 821F1514h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821F1514h case    4:*/		return 0x821F1518;
		  /* 821F1518h */ case    5:  		/* mr R31, R3 */
		/* 821F1518h case    5:*/		regs.R31 = regs.R3;
		/* 821F1518h case    5:*/		return 0x821F151C;
		  /* 821F151Ch */ case    6:  		/* li R5, 22 */
		/* 821F151Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x16);
		/* 821F151Ch case    6:*/		return 0x821F1520;
		  /* 821F1520h */ case    7:  		/* li R4, 12 */
		/* 821F1520h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 821F1520h case    7:*/		return 0x821F1524;
		  /* 821F1524h */ case    8:  		/* mr R3, R30 */
		/* 821F1524h case    8:*/		regs.R3 = regs.R30;
		/* 821F1524h case    8:*/		return 0x821F1528;
		  /* 821F1528h */ case    9:  		/* rlwinm R27, R11, 0, 18, 31 */
		/* 821F1528h case    9:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R27,regs.R11);
		/* 821F1528h case    9:*/		return 0x821F152C;
		  /* 821F152Ch */ case   10:  		/* rlwinm R24, R11, 18, 18, 31 */
		/* 821F152Ch case   10:*/		cpu::op::rlwinm<0,18,18,31>(regs,&regs.R24,regs.R11);
		/* 821F152Ch case   10:*/		return 0x821F1530;
		  /* 821F1530h */ case   11:  		/* bl -543112 */
		/* 821F1530h case   11:*/		regs.LR = 0x821F1534; return 0x8216CBA8;
		/* 821F1530h case   11:*/		return 0x821F1534;
		  /* 821F1534h */ case   12:  		/* rlwimi R24, R27, 14, 4, 17 */
		/* 821F1534h case   12:*/		cpu::op::rlwimi<0,14,4,17>(regs,&regs.R24,regs.R27);
		/* 821F1534h case   12:*/		return 0x821F1538;
	}
	return 0x821F1538;
} // Block from 821F1504h-821F1538h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821F1538h
// Function '?CreateSemanticNode@Compiler@D3DXShader@@AAAPAVCNodeToken@2@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1538);
		  /* 821F1538h */ case    0:  		/* lwz R9, <#[R3 + 8]> */
		/* 821F1538h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1538h case    0:*/		return 0x821F153C;
		  /* 821F153Ch */ case    1:  		/* lwz R11, <#[R1 + 84]> */
		/* 821F153Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F153Ch case    1:*/		return 0x821F1540;
		  /* 821F1540h */ case    2:  		/* cmplwi CR6, R29, 1 */
		/* 821F1540h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 821F1540h case    2:*/		return 0x821F1544;
		  /* 821F1544h */ case    3:  		/* mr R10, R24 */
		/* 821F1544h case    3:*/		regs.R10 = regs.R24;
		/* 821F1544h case    3:*/		return 0x821F1548;
		  /* 821F1548h */ case    4:  		/* stw R21, <#[R3]> */
		/* 821F1548h case    4:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1548h case    4:*/		return 0x821F154C;
		  /* 821F154Ch */ case    5:  		/* rlwinm R11, R11, 0, 15, 15 */
		/* 821F154Ch case    5:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R11,regs.R11);
		/* 821F154Ch case    5:*/		return 0x821F1550;
		  /* 821F1550h */ case    6:  		/* stw R31, <#[R1 + 80]> */
		/* 821F1550h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 821F1550h case    6:*/		return 0x821F1554;
		  /* 821F1554h */ case    7:  		/* rlwimi R10, R9, 0, 0, 3 */
		/* 821F1554h case    7:*/		cpu::op::rlwimi<0,0,0,3>(regs,&regs.R10,regs.R9);
		/* 821F1554h case    7:*/		return 0x821F1558;
		  /* 821F1558h */ case    8:  		/* ori R11, R11, 1 */
		/* 821F1558h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F1558h case    8:*/		return 0x821F155C;
		  /* 821F155Ch */ case    9:  		/* stw R10, <#[R3 + 8]> */
		/* 821F155Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821F155Ch case    9:*/		return 0x821F1560;
		  /* 821F1560h */ case   10:  		/* mr R24, R31 */
		/* 821F1560h case   10:*/		regs.R24 = regs.R31;
		/* 821F1560h case   10:*/		return 0x821F1564;
		  /* 821F1564h */ case   11:  		/* lwz R10, <#[R31 + 16]> */
		/* 821F1564h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821F1564h case   11:*/		return 0x821F1568;
		  /* 821F1568h */ case   12:  		/* stw R10, <#[R3 + 4]> */
		/* 821F1568h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1568h case   12:*/		return 0x821F156C;
		  /* 821F156Ch */ case   13:  		/* stw R11, <#[R1 + 84]> */
		/* 821F156Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F156Ch case   13:*/		return 0x821F1570;
		  /* 821F1570h */ case   14:  		/* stw R3, <#[R31 + 16]> */
		/* 821F1570h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 821F1570h case   14:*/		return 0x821F1574;
		  /* 821F1574h */ case   15:  		/* bc 4, CR6_EQ, 36 */
		/* 821F1574h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F1598;  }
		/* 821F1574h case   15:*/		return 0x821F1578;
		  /* 821F1578h */ case   16:  		/* rlwinm. R10, R28, 0, 0, 14 */
		/* 821F1578h case   16:*/		cpu::op::rlwinm<1,0,0,14>(regs,&regs.R10,regs.R28);
		/* 821F1578h case   16:*/		return 0x821F157C;
		  /* 821F157Ch */ case   17:  		/* bc 12, CR0_EQ, 28 */
		/* 821F157Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x821F1598;  }
		/* 821F157Ch case   17:*/		return 0x821F1580;
		  /* 821F1580h */ case   18:  		/* rlwinm R11, R11, 0, 15, 31 */
		/* 821F1580h case   18:*/		cpu::op::rlwinm<0,0,15,31>(regs,&regs.R11,regs.R11);
		/* 821F1580h case   18:*/		return 0x821F1584;
		  /* 821F1584h */ case   19:  		/* oris R11, R11, 2 */
		/* 821F1584h case   19:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F1584h case   19:*/		return 0x821F1588;
		  /* 821F1588h */ case   20:  		/* stw R11, <#[R1 + 84]> */
		/* 821F1588h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F1588h case   20:*/		return 0x821F158C;
		  /* 821F158Ch */ case   21:  		/* b 12 */
		/* 821F158Ch case   21:*/		return 0x821F1598;
		/* 821F158Ch case   21:*/		return 0x821F1590;
	}
	return 0x821F1590;
} // Block from 821F1538h-821F1590h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F1590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1590);
		  /* 821F1590h */ case    0:  		/* std R31, <#[R1 + 80]> */
		/* 821F1590h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 821F1590h case    0:*/		return 0x821F1594;
		  /* 821F1594h */ case    1:  		/* lwz R24, <#[R1 + 80]> */
		/* 821F1594h case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 821F1594h case    1:*/		return 0x821F1598;
	}
	return 0x821F1598;
} // Block from 821F1590h-821F1598h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F1598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1598);
		  /* 821F1598h */ case    0:  		/* lwz R10, <#[R26 + 8]> */
		/* 821F1598h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 821F1598h case    0:*/		return 0x821F159C;
		  /* 821F159Ch */ case    1:  		/* addi R22, R22, 1 */
		/* 821F159Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 821F159Ch case    1:*/		return 0x821F15A0;
		  /* 821F15A0h */ case    2:  		/* addi R20, R20, 8 */
		/* 821F15A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x8);
		/* 821F15A0h case    2:*/		return 0x821F15A4;
		  /* 821F15A4h */ case    3:  		/* rlwinm R11, R10, 0, 18, 31 */
		/* 821F15A4h case    3:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R11,regs.R10);
		/* 821F15A4h case    3:*/		return 0x821F15A8;
		  /* 821F15A8h */ case    4:  		/* rlwinm R10, R10, 18, 18, 31 */
		/* 821F15A8h case    4:*/		cpu::op::rlwinm<0,18,18,31>(regs,&regs.R10,regs.R10);
		/* 821F15A8h case    4:*/		return 0x821F15AC;
		  /* 821F15ACh */ case    5:  		/* add R25, R11, R25 */
		/* 821F15ACh case    5:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 821F15ACh case    5:*/		return 0x821F15B0;
		  /* 821F15B0h */ case    6:  		/* cmplw CR6, R22, R10 */
		/* 821F15B0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 821F15B0h case    6:*/		return 0x821F15B4;
		  /* 821F15B4h */ case    7:  		/* bc 12, CR6_LT, -468 */
		/* 821F15B4h case    7:*/		if ( regs.CR[6].lt ) { return 0x821F13E0;  }
		/* 821F15B4h case    7:*/		return 0x821F15B8;
	}
	return 0x821F15B8;
} // Block from 821F1598h-821F15B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F15B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F15B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F15B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F15B8);
		  /* 821F15B8h */ case    0:  		/* mr R3, R24 */
		/* 821F15B8h case    0:*/		regs.R3 = regs.R24;
		/* 821F15B8h case    0:*/		return 0x821F15BC;
		  /* 821F15BCh */ case    1:  		/* addi R1, R1, 256 */
		/* 821F15BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 821F15BCh case    1:*/		return 0x821F15C0;
		  /* 821F15C0h */ case    2:  		/* lfd FR31, <#[R1 - 120]> */
		/* 821F15C0h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 821F15C0h case    2:*/		return 0x821F15C4;
		  /* 821F15C4h */ case    3:  		/* b -1442624 */
		/* 821F15C4h case    3:*/		return 0x82091284;
		/* 821F15C4h case    3:*/		return 0x821F15C8;
	}
	return 0x821F15C8;
} // Block from 821F15B8h-821F15C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F15C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F15C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F15C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F15C8);
		  /* 821F15C8h */ case    0:  		/* mfspr R12, LR */
		/* 821F15C8h case    0:*/		regs.R12 = regs.LR;
		/* 821F15C8h case    0:*/		return 0x821F15CC;
		  /* 821F15CCh */ case    1:  		/* bl -1442720 */
		/* 821F15CCh case    1:*/		regs.LR = 0x821F15D0; return 0x8209122C;
		/* 821F15CCh case    1:*/		return 0x821F15D0;
		  /* 821F15D0h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 821F15D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 821F15D0h case    2:*/		return 0x821F15D4;
		  /* 821F15D4h */ case    3:  		/* lwz R24, <#[R5 + 80]> */
		/* 821F15D4h case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R5 + 0x00000050) );
		/* 821F15D4h case    3:*/		return 0x821F15D8;
		  /* 821F15D8h */ case    4:  		/* mr R25, R3 */
		/* 821F15D8h case    4:*/		regs.R25 = regs.R3;
		/* 821F15D8h case    4:*/		return 0x821F15DC;
		  /* 821F15DCh */ case    5:  		/* mr R19, R4 */
		/* 821F15DCh case    5:*/		regs.R19 = regs.R4;
		/* 821F15DCh case    5:*/		return 0x821F15E0;
		  /* 821F15E0h */ case    6:  		/* mr R21, R5 */
		/* 821F15E0h case    6:*/		regs.R21 = regs.R5;
		/* 821F15E0h case    6:*/		return 0x821F15E4;
		  /* 821F15E4h */ case    7:  		/* mr R20, R6 */
		/* 821F15E4h case    7:*/		regs.R20 = regs.R6;
		/* 821F15E4h case    7:*/		return 0x821F15E8;
	}
	return 0x821F15E8;
} // Block from 821F15C8h-821F15E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F15E8h
// Function '?ParseExportSemantic@Compiler@D3DXShader@@AAAIIIPBDII_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F15E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F15E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F15E8);
		  /* 821F15E8h */ case    0:  		/* mr R27, R7 */
		/* 821F15E8h case    0:*/		regs.R27 = regs.R7;
		/* 821F15E8h case    0:*/		return 0x821F15EC;
		  /* 821F15ECh */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 821F15ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821F15ECh case    1:*/		return 0x821F15F0;
		  /* 821F15F0h */ case    2:  		/* bc 12, CR6_EQ, 440 */
		/* 821F15F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821F17A8;  }
		/* 821F15F0h case    2:*/		return 0x821F15F4;
		  /* 821F15F4h */ case    3:  		/* lwz R23, <#[R7 + 20]> */
		/* 821F15F4h case    3:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R7 + 0x00000014) );
		/* 821F15F4h case    3:*/		return 0x821F15F8;
		  /* 821F15F8h */ case    4:  		/* li R5, 0 */
		/* 821F15F8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F15F8h case    4:*/		return 0x821F15FC;
		  /* 821F15FCh */ case    5:  		/* mr R3, R7 */
		/* 821F15FCh case    5:*/		regs.R3 = regs.R7;
		/* 821F15FCh case    5:*/		return 0x821F1600;
		  /* 821F1600h */ case    6:  		/* rlwinm R4, R23, 2, 0, 29 */
		/* 821F1600h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R23);
		/* 821F1600h case    6:*/		return 0x821F1604;
		  /* 821F1604h */ case    7:  		/* bl -574924 */
		/* 821F1604h case    7:*/		regs.LR = 0x821F1608; return 0x82165038;
		/* 821F1604h case    7:*/		return 0x821F1608;
		  /* 821F1608h */ case    8:  		/* li R26, 0 */
		/* 821F1608h case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821F1608h case    8:*/		return 0x821F160C;
		  /* 821F160Ch */ case    9:  		/* mr R22, R3 */
		/* 821F160Ch case    9:*/		regs.R22 = regs.R3;
		/* 821F160Ch case    9:*/		return 0x821F1610;
		  /* 821F1610h */ case   10:  		/* mr R28, R26 */
		/* 821F1610h case   10:*/		regs.R28 = regs.R26;
		/* 821F1610h case   10:*/		return 0x821F1614;
		  /* 821F1614h */ case   11:  		/* cmplwi CR6, R23, 0 */
		/* 821F1614h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 821F1614h case   11:*/		return 0x821F1618;
		  /* 821F1618h */ case   12:  		/* bc 12, CR6_EQ, 392 */
		/* 821F1618h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F17A0;  }
		/* 821F1618h case   12:*/		return 0x821F161C;
		  /* 821F161Ch */ case   13:  		/* mr R30, R26 */
		/* 821F161Ch case   13:*/		regs.R30 = regs.R26;
		/* 821F161Ch case   13:*/		return 0x821F1620;
		  /* 821F1620h */ case   14:  		/* mr R31, R24 */
		/* 821F1620h case   14:*/		regs.R31 = regs.R24;
		/* 821F1620h case   14:*/		return 0x821F1624;
		  /* 821F1624h */ case   15:  		/* subf R29, R24, R3 */
		/* 821F1624h case   15:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R24,regs.R3);
		/* 821F1624h case   15:*/		return 0x821F1628;
		  /* 821F1628h */ case   16:  		/* lwz R9, <#[R31]> */
		/* 821F1628h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1628h case   16:*/		return 0x821F162C;
		  /* 821F162Ch */ case   17:  		/* cmplwi CR6, R9, 0 */
		/* 821F162Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821F162Ch case   17:*/		return 0x821F1630;
		  /* 821F1630h */ case   18:  		/* bc 12, CR6_EQ, 348 */
		/* 821F1630h case   18:*/		if ( regs.CR[6].eq ) { return 0x821F178C;  }
		/* 821F1630h case   18:*/		return 0x821F1634;
		  /* 821F1634h */ case   19:  		/* lwz R11, <#[R20 + 16]> */
		/* 821F1634h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000010) );
		/* 821F1634h case   19:*/		return 0x821F1638;
		  /* 821F1638h */ case   20:  		/* cmplw CR6, R28, R11 */
		/* 821F1638h case   20:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 821F1638h case   20:*/		return 0x821F163C;
		  /* 821F163Ch */ case   21:  		/* bc 12, CR6_EQ, 160 */
		/* 821F163Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x821F16DC;  }
		/* 821F163Ch case   21:*/		return 0x821F1640;
		  /* 821F1640h */ case   22:  		/* lwz R11, <#[R20 + 44]> */
		/* 821F1640h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x0000002C) );
		/* 821F1640h case   22:*/		return 0x821F1644;
		  /* 821F1644h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 821F1644h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F1644h case   23:*/		return 0x821F1648;
		  /* 821F1648h */ case   24:  		/* bc 12, CR6_EQ, 16 */
		/* 821F1648h case   24:*/		if ( regs.CR[6].eq ) { return 0x821F1658;  }
		/* 821F1648h case   24:*/		return 0x821F164C;
		  /* 821F164Ch */ case   25:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F164Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F164Ch case   25:*/		return 0x821F1650;
		  /* 821F1650h */ case   26:  		/* cmpwi CR6, R10, 1 */
		/* 821F1650h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821F1650h case   26:*/		return 0x821F1654;
		  /* 821F1654h */ case   27:  		/* bc 4, CR6_EQ, 348 */
		/* 821F1654h case   27:*/		if ( !regs.CR[6].eq ) { return 0x821F17B0;  }
		/* 821F1654h case   27:*/		return 0x821F1658;
	}
	return 0x821F1658;
} // Block from 821F15E8h-821F1658h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F1658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1658);
		  /* 821F1658h */ case    0:  		/* mr R10, R11 */
		/* 821F1658h case    0:*/		regs.R10 = regs.R11;
		/* 821F1658h case    0:*/		return 0x821F165C;
		  /* 821F165Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F165Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F165Ch case    1:*/		return 0x821F1660;
		  /* 821F1660h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 821F1660h case    2:*/		if ( regs.CR[6].eq ) { return 0x821F16E8;  }
		/* 821F1660h case    2:*/		return 0x821F1664;
		  /* 821F1664h */ case    3:  		/* lwz R11, <#[R10 + 8]> */
		/* 821F1664h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821F1664h case    3:*/		return 0x821F1668;
		  /* 821F1668h */ case    4:  		/* lwz R8, <#[R11 + 4]> */
		/* 821F1668h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1668h case    4:*/		return 0x821F166C;
		  /* 821F166Ch */ case    5:  		/* cmpwi CR6, R8, 6 */
		/* 821F166Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000006);
		/* 821F166Ch case    5:*/		return 0x821F1670;
		  /* 821F1670h */ case    6:  		/* bc 4, CR6_EQ, 64 */
		/* 821F1670h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821F16B0;  }
		/* 821F1670h case    6:*/		return 0x821F1674;
		  /* 821F1674h */ case    7:  		/* lwz R8, <#[R11 + 16]> */
		/* 821F1674h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 821F1674h case    7:*/		return 0x821F1678;
		  /* 821F1678h */ case    8:  		/* cmpwi CR6, R8, 1 */
		/* 821F1678h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 821F1678h case    8:*/		return 0x821F167C;
		  /* 821F167Ch */ case    9:  		/* bc 4, CR6_EQ, 320 */
		/* 821F167Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821F17BC;  }
		/* 821F167Ch case    9:*/		return 0x821F1680;
		  /* 821F1680h */ case   10:  		/* lwz R11, <#[R11 + 24]> */
		/* 821F1680h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821F1680h case   10:*/		return 0x821F1684;
		  /* 821F1684h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821F1684h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F1684h case   11:*/		return 0x821F1688;
		  /* 821F1688h */ case   12:  		/* bc 12, CR6_EQ, 320 */
		/* 821F1688h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F17C8;  }
		/* 821F1688h case   12:*/		return 0x821F168C;
		  /* 821F168Ch */ case   13:  		/* lwz R8, <#[R11 + 4]> */
		/* 821F168Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F168Ch case   13:*/		return 0x821F1690;
		  /* 821F1690h */ case   14:  		/* cmpwi CR6, R8, 11 */
		/* 821F1690h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x0000000B);
		/* 821F1690h case   14:*/		return 0x821F1694;
		  /* 821F1694h */ case   15:  		/* bc 4, CR6_EQ, 308 */
		/* 821F1694h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F17C8;  }
		/* 821F1694h case   15:*/		return 0x821F1698;
		  /* 821F1698h */ case   16:  		/* lwz R8, <#[R11 + 44]> */
		/* 821F1698h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000002C) );
		/* 821F1698h case   16:*/		return 0x821F169C;
		  /* 821F169Ch */ case   17:  		/* rlwinm. R8, R8, 0, 26, 26 */
		/* 821F169Ch case   17:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R8,regs.R8);
		/* 821F169Ch case   17:*/		return 0x821F16A0;
		  /* 821F16A0h */ case   18:  		/* bc 12, CR0_EQ, 16 */
		/* 821F16A0h case   18:*/		if ( regs.CR[0].eq ) { return 0x821F16B0;  }
		/* 821F16A0h case   18:*/		return 0x821F16A4;
		  /* 821F16A4h */ case   19:  		/* lwz R11, <#[R11 + 16]> */
		/* 821F16A4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 821F16A4h case   19:*/		return 0x821F16A8;
		  /* 821F16A8h */ case   20:  		/* cmplw CR6, R28, R11 */
		/* 821F16A8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 821F16A8h case   20:*/		return 0x821F16AC;
		  /* 821F16ACh */ case   21:  		/* bc 12, CR6_EQ, 40 */
		/* 821F16ACh case   21:*/		if ( regs.CR[6].eq ) { return 0x821F16D4;  }
		/* 821F16ACh case   21:*/		return 0x821F16B0;
	}
	return 0x821F16B0;
} // Block from 821F1658h-821F16B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F16B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F16B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F16B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F16B0);
		  /* 821F16B0h */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 821F16B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 821F16B0h case    0:*/		return 0x821F16B4;
		  /* 821F16B4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F16B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F16B4h case    1:*/		return 0x821F16B8;
		  /* 821F16B8h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821F16B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821F16C8;  }
		/* 821F16B8h case    2:*/		return 0x821F16BC;
		  /* 821F16BCh */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F16BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F16BCh case    3:*/		return 0x821F16C0;
		  /* 821F16C0h */ case    4:  		/* cmpwi CR6, R10, 1 */
		/* 821F16C0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821F16C0h case    4:*/		return 0x821F16C4;
		  /* 821F16C4h */ case    5:  		/* bc 4, CR6_EQ, 272 */
		/* 821F16C4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F17D4;  }
		/* 821F16C4h case    5:*/		return 0x821F16C8;
	}
	return 0x821F16C8;
} // Block from 821F16B0h-821F16C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F16C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F16C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F16C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F16C8);
		  /* 821F16C8h */ case    0:  		/* mr R10, R11 */
		/* 821F16C8h case    0:*/		regs.R10 = regs.R11;
		/* 821F16C8h case    0:*/		return 0x821F16CC;
		  /* 821F16CCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F16CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F16CCh case    1:*/		return 0x821F16D0;
		  /* 821F16D0h */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 821F16D0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F1664;  }
		/* 821F16D0h case    2:*/		return 0x821F16D4;
	}
	return 0x821F16D4;
} // Block from 821F16C8h-821F16D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F16D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F16D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F16D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F16D4);
		  /* 821F16D4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821F16D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F16D4h case    0:*/		return 0x821F16D8;
		  /* 821F16D8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 821F16D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821F16E8;  }
		/* 821F16D8h case    1:*/		return 0x821F16DC;
	}
	return 0x821F16DC;
} // Block from 821F16D4h-821F16DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F16DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F16DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F16DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F16DC);
		  /* 821F16DCh */ case    0:  		/* stwx R9, <#[R29 + R31]> */
		/* 821F16DCh case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 821F16DCh case    0:*/		return 0x821F16E0;
		  /* 821F16E0h */ case    1:  		/* stw R26, <#[R31]> */
		/* 821F16E0h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 821F16E0h case    1:*/		return 0x821F16E4;
		  /* 821F16E4h */ case    2:  		/* b 168 */
		/* 821F16E4h case    2:*/		return 0x821F178C;
		/* 821F16E4h case    2:*/		return 0x821F16E8;
	}
	return 0x821F16E8;
} // Block from 821F16DCh-821F16E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F16E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F16E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F16E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F16E8);
		  /* 821F16E8h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 821F16E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821F16E8h case    0:*/		return 0x821F16EC;
		  /* 821F16ECh */ case    1:  		/* li R5, 0 */
		/* 821F16ECh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F16ECh case    1:*/		return 0x821F16F0;
		  /* 821F16F0h */ case    2:  		/* mr R3, R27 */
		/* 821F16F0h case    2:*/		regs.R3 = regs.R27;
		/* 821F16F0h case    2:*/		return 0x821F16F4;
		  /* 821F16F4h */ case    3:  		/* lwzx R11, <#[R11 + R30]> */
		/* 821F16F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821F16F4h case    3:*/		return 0x821F16F8;
		  /* 821F16F8h */ case    4:  		/* rlwinm R18, R11, 0, 15, 28 */
		/* 821F16F8h case    4:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R18,regs.R11);
		/* 821F16F8h case    4:*/		return 0x821F16FC;
		  /* 821F16FCh */ case    5:  		/* mr R4, R18 */
		/* 821F16FCh case    5:*/		regs.R4 = regs.R18;
		/* 821F16FCh case    5:*/		return 0x821F1700;
		  /* 821F1700h */ case    6:  		/* bl -575176 */
		/* 821F1700h case    6:*/		regs.LR = 0x821F1704; return 0x82165038;
		/* 821F1700h case    6:*/		return 0x821F1704;
		  /* 821F1704h */ case    7:  		/* mr R5, R18 */
		/* 821F1704h case    7:*/		regs.R5 = regs.R18;
		/* 821F1704h case    7:*/		return 0x821F1708;
		  /* 821F1708h */ case    8:  		/* lwz R4, <#[R31]> */
		/* 821F1708h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1708h case    8:*/		return 0x821F170C;
		  /* 821F170Ch */ case    9:  		/* mr R17, R3 */
		/* 821F170Ch case    9:*/		regs.R17 = regs.R3;
		/* 821F170Ch case    9:*/		return 0x821F1710;
		  /* 821F1710h */ case   10:  		/* bl -1441120 */
		/* 821F1710h case   10:*/		regs.LR = 0x821F1714; return 0x820919B0;
		/* 821F1710h case   10:*/		return 0x821F1714;
		  /* 821F1714h */ case   11:  		/* stwx R17, <#[R29 + R31]> */
		/* 821F1714h case   11:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 821F1714h case   11:*/		return 0x821F1718;
		  /* 821F1718h */ case   12:  		/* lwz R11, <#[R27 + 12]> */
		/* 821F1718h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821F1718h case   12:*/		return 0x821F171C;
		  /* 821F171Ch */ case   13:  		/* add R11, R11, R30 */
		/* 821F171Ch case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821F171Ch case   13:*/		return 0x821F1720;
		  /* 821F1720h */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F1720h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1720h case   14:*/		return 0x821F1724;
		  /* 821F1724h */ case   15:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 821F1724h case   15:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 821F1724h case   15:*/		return 0x821F1728;
		  /* 821F1728h */ case   16:  		/* bc 12, CR0_EQ, 100 */
		/* 821F1728h case   16:*/		if ( regs.CR[0].eq ) { return 0x821F178C;  }
		/* 821F1728h case   16:*/		return 0x821F172C;
		  /* 821F172Ch */ case   17:  		/* lwz R11, <#[R25 + 12]> */
		/* 821F172Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 821F172Ch case   17:*/		return 0x821F1730;
		  /* 821F1730h */ case   18:  		/* mr R10, R26 */
		/* 821F1730h case   18:*/		regs.R10 = regs.R26;
		/* 821F1730h case   18:*/		return 0x821F1734;
		  /* 821F1734h */ case   19:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821F1734h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821F1734h case   19:*/		return 0x821F1738;
		  /* 821F1738h */ case   20:  		/* rlwinm. R11, R11, 0, 15, 28 */
		/* 821F1738h case   20:*/		cpu::op::rlwinm<1,0,15,28>(regs,&regs.R11,regs.R11);
		/* 821F1738h case   20:*/		return 0x821F173C;
		  /* 821F173Ch */ case   21:  		/* bc 12, CR0_EQ, 80 */
		/* 821F173Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x821F178C;  }
		/* 821F173Ch case   21:*/		return 0x821F1740;
		  /* 821F1740h */ case   22:  		/* rlwinm R8, R28, 17, 0, 14 */
		/* 821F1740h case   22:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R8,regs.R28);
		/* 821F1740h case   22:*/		return 0x821F1744;
		  /* 821F1744h */ case   23:  		/* mr R9, R26 */
		/* 821F1744h case   23:*/		regs.R9 = regs.R26;
		/* 821F1744h case   23:*/		return 0x821F1748;
		  /* 821F1748h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 821F1748h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1748h case   24:*/		return 0x821F174C;
		  /* 821F174Ch */ case   25:  		/* add R11, R9, R11 */
		/* 821F174Ch case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F174Ch case   25:*/		return 0x821F1750;
		  /* 821F1750h */ case   26:  		/* addi R9, R9, 8 */
		/* 821F1750h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 821F1750h case   26:*/		return 0x821F1754;
		  /* 821F1754h */ case   27:  		/* lwz R7, <#[R11 + 4]> */
		/* 821F1754h case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1754h case   27:*/		return 0x821F1758;
		  /* 821F1758h */ case   28:  		/* lwz R6, <#[R11]> */
		/* 821F1758h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1758h case   28:*/		return 0x821F175C;
		  /* 821F175Ch */ case   29:  		/* rlwinm R7, R7, 0, 15, 15 */
		/* 821F175Ch case   29:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R7,regs.R7);
		/* 821F175Ch case   29:*/		return 0x821F1760;
		  /* 821F1760h */ case   30:  		/* ori R6, R6, 1 */
		/* 821F1760h case   30:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F1760h case   30:*/		return 0x821F1764;
		  /* 821F1764h */ case   31:  		/* or R7, R7, R8 */
		/* 821F1764h case   31:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 821F1764h case   31:*/		return 0x821F1768;
		  /* 821F1768h */ case   32:  		/* stw R6, <#[R11]> */
		/* 821F1768h case   32:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1768h case   32:*/		return 0x821F176C;
		  /* 821F176Ch */ case   33:  		/* rlwimi R7, R10, 2, 16, 29 */
		/* 821F176Ch case   33:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R7,regs.R10);
		/* 821F176Ch case   33:*/		return 0x821F1770;
		  /* 821F1770h */ case   34:  		/* addi R10, R10, 1 */
		/* 821F1770h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F1770h case   34:*/		return 0x821F1774;
		  /* 821F1774h */ case   35:  		/* stw R7, <#[R11 + 4]> */
		/* 821F1774h case   35:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1774h case   35:*/		return 0x821F1778;
		  /* 821F1778h */ case   36:  		/* lwz R11, <#[R25 + 12]> */
		/* 821F1778h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 821F1778h case   36:*/		return 0x821F177C;
		  /* 821F177Ch */ case   37:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821F177Ch case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821F177Ch case   37:*/		return 0x821F1780;
		  /* 821F1780h */ case   38:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 821F1780h case   38:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 821F1780h case   38:*/		return 0x821F1784;
		  /* 821F1784h */ case   39:  		/* cmplw CR6, R10, R11 */
		/* 821F1784h case   39:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F1784h case   39:*/		return 0x821F1788;
		  /* 821F1788h */ case   40:  		/* bc 12, CR6_LT, -64 */
		/* 821F1788h case   40:*/		if ( regs.CR[6].lt ) { return 0x821F1748;  }
		/* 821F1788h case   40:*/		return 0x821F178C;
	}
	return 0x821F178C;
} // Block from 821F16E8h-821F178Ch (41 instructions)

//////////////////////////////////////////////////////
// Block at 821F178Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F178C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F178C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F178C);
		  /* 821F178Ch */ case    0:  		/* addi R28, R28, 1 */
		/* 821F178Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821F178Ch case    0:*/		return 0x821F1790;
		  /* 821F1790h */ case    1:  		/* addi R31, R31, 4 */
		/* 821F1790h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821F1790h case    1:*/		return 0x821F1794;
		  /* 821F1794h */ case    2:  		/* addi R30, R30, 40 */
		/* 821F1794h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x28);
		/* 821F1794h case    2:*/		return 0x821F1798;
		  /* 821F1798h */ case    3:  		/* cmplw CR6, R28, R23 */
		/* 821F1798h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821F1798h case    3:*/		return 0x821F179C;
		  /* 821F179Ch */ case    4:  		/* bc 12, CR6_LT, -372 */
		/* 821F179Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821F1628;  }
		/* 821F179Ch case    4:*/		return 0x821F17A0;
	}
	return 0x821F17A0;
} // Block from 821F178Ch-821F17A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F17A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17A0);
		  /* 821F17A0h */ case    0:  		/* stw R24, <#[R19 + 80]> */
		/* 821F17A0h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R19 + 0x00000050) );
		/* 821F17A0h case    0:*/		return 0x821F17A4;
		  /* 821F17A4h */ case    1:  		/* stw R22, <#[R21 + 80]> */
		/* 821F17A4h case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R21 + 0x00000050) );
		/* 821F17A4h case    1:*/		return 0x821F17A8;
	}
	return 0x821F17A8;
} // Block from 821F17A0h-821F17A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F17A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17A8);
		  /* 821F17A8h */ case    0:  		/* addi R1, R1, 208 */
		/* 821F17A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 821F17A8h case    0:*/		return 0x821F17AC;
		  /* 821F17ACh */ case    1:  		/* b -1443120 */
		/* 821F17ACh case    1:*/		return 0x8209127C;
		/* 821F17ACh case    1:*/		return 0x821F17B0;
	}
	return 0x821F17B0;
} // Block from 821F17A8h-821F17B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F17B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17B0);
		  /* 821F17B0h */ case    0:  		/* li R4, 4801 */
		/* 821F17B0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F17B0h case    0:*/		return 0x821F17B4;
		  /* 821F17B4h */ case    1:  		/* mr R3, R25 */
		/* 821F17B4h case    1:*/		regs.R3 = regs.R25;
		/* 821F17B4h case    1:*/		return 0x821F17B8;
		  /* 821F17B8h */ case    2:  		/* bl -653648 */
		/* 821F17B8h case    2:*/		regs.LR = 0x821F17BC; return 0x82151E68;
		/* 821F17B8h case    2:*/		return 0x821F17BC;
	}
	return 0x821F17BC;
} // Block from 821F17B0h-821F17BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F17BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17BC);
		  /* 821F17BCh */ case    0:  		/* li R4, 4801 */
		/* 821F17BCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F17BCh case    0:*/		return 0x821F17C0;
		  /* 821F17C0h */ case    1:  		/* mr R3, R25 */
		/* 821F17C0h case    1:*/		regs.R3 = regs.R25;
		/* 821F17C0h case    1:*/		return 0x821F17C4;
		  /* 821F17C4h */ case    2:  		/* bl -653660 */
		/* 821F17C4h case    2:*/		regs.LR = 0x821F17C8; return 0x82151E68;
		/* 821F17C4h case    2:*/		return 0x821F17C8;
	}
	return 0x821F17C8;
} // Block from 821F17BCh-821F17C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F17C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17C8);
		  /* 821F17C8h */ case    0:  		/* li R4, 4801 */
		/* 821F17C8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F17C8h case    0:*/		return 0x821F17CC;
		  /* 821F17CCh */ case    1:  		/* mr R3, R25 */
		/* 821F17CCh case    1:*/		regs.R3 = regs.R25;
		/* 821F17CCh case    1:*/		return 0x821F17D0;
		  /* 821F17D0h */ case    2:  		/* bl -653672 */
		/* 821F17D0h case    2:*/		regs.LR = 0x821F17D4; return 0x82151E68;
		/* 821F17D0h case    2:*/		return 0x821F17D4;
	}
	return 0x821F17D4;
} // Block from 821F17C8h-821F17D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F17D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17D4);
		  /* 821F17D4h */ case    0:  		/* li R4, 4801 */
		/* 821F17D4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F17D4h case    0:*/		return 0x821F17D8;
		  /* 821F17D8h */ case    1:  		/* mr R3, R25 */
		/* 821F17D8h case    1:*/		regs.R3 = regs.R25;
		/* 821F17D8h case    1:*/		return 0x821F17DC;
		  /* 821F17DCh */ case    2:  		/* bl -653684 */
		/* 821F17DCh case    2:*/		regs.LR = 0x821F17E0; return 0x82151E68;
		/* 821F17DCh case    2:*/		return 0x821F17E0;
	}
	return 0x821F17E0;
} // Block from 821F17D4h-821F17E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F17E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F17E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F17E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F17E0);
		  /* 821F17E0h */ case    0:  		/* mfspr R12, LR */
		/* 821F17E0h case    0:*/		regs.R12 = regs.LR;
		/* 821F17E0h case    0:*/		return 0x821F17E4;
		  /* 821F17E4h */ case    1:  		/* bl -1443208 */
		/* 821F17E4h case    1:*/		regs.LR = 0x821F17E8; return 0x8209125C;
		/* 821F17E4h case    1:*/		return 0x821F17E8;
		  /* 821F17E8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F17E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F17E8h case    2:*/		return 0x821F17EC;
		  /* 821F17ECh */ case    3:  		/* mr R29, R3 */
		/* 821F17ECh case    3:*/		regs.R29 = regs.R3;
		/* 821F17ECh case    3:*/		return 0x821F17F0;
		  /* 821F17F0h */ case    4:  		/* mr R30, R4 */
		/* 821F17F0h case    4:*/		regs.R30 = regs.R4;
		/* 821F17F0h case    4:*/		return 0x821F17F4;
		  /* 821F17F4h */ case    5:  		/* mr R31, R5 */
		/* 821F17F4h case    5:*/		regs.R31 = regs.R5;
		/* 821F17F4h case    5:*/		return 0x821F17F8;
		  /* 821F17F8h */ case    6:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F17F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F17F8h case    6:*/		return 0x821F17FC;
		  /* 821F17FCh */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821F17FCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821F17FCh case    7:*/		return 0x821F1800;
		  /* 821F1800h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821F1800h case    8:*/		if ( regs.CR[0].eq ) { return 0x821F180C;  }
		/* 821F1800h case    8:*/		return 0x821F1804;
		  /* 821F1804h */ case    9:  		/* li R4, 0 */
		/* 821F1804h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F1804h case    9:*/		return 0x821F1808;
		  /* 821F1808h */ case   10:  		/* b 16 */
		/* 821F1808h case   10:*/		return 0x821F1818;
		/* 821F1808h case   10:*/		return 0x821F180C;
	}
	return 0x821F180C;
} // Block from 821F17E0h-821F180Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F180Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F180C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F180C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F180C);
		  /* 821F180Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821F180Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F180Ch case    0:*/		return 0x821F1810;
		  /* 821F1810h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1810h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1810h case    1:*/		return 0x821F1814;
		  /* 821F1814h */ case    2:  		/* addi R4, R11, -4 */
		/* 821F1814h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821F1814h case    2:*/		return 0x821F1818;
	}
	return 0x821F1818;
} // Block from 821F180Ch-821F1818h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F1818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1818);
		  /* 821F1818h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F1818h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F1818h case    0:*/		return 0x821F181C;
		  /* 821F181Ch */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 821F181Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821F181Ch case    1:*/		return 0x821F1820;
		  /* 821F1820h */ case    2:  		/* bc 4, CR6_GT, 68 */
		/* 821F1820h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821F1864;  }
		/* 821F1820h case    2:*/		return 0x821F1824;
		  /* 821F1824h */ case    3:  		/* rlwinm R10, R4, 0, 0, 30 */
		/* 821F1824h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R4);
		/* 821F1824h case    3:*/		return 0x821F1828;
		  /* 821F1828h */ case    4:  		/* subf R31, R11, R31 */
		/* 821F1828h case    4:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 821F1828h case    4:*/		return 0x821F182C;
		  /* 821F182Ch */ case    5:  		/* mr R3, R30 */
		/* 821F182Ch case    5:*/		regs.R3 = regs.R30;
		/* 821F182Ch case    5:*/		return 0x821F1830;
		  /* 821F1830h */ case    6:  		/* lwz R11, <#[R10 + 4]> */
		/* 821F1830h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821F1830h case    6:*/		return 0x821F1834;
		  /* 821F1834h */ case    7:  		/* lwz R9, <#[R10]> */
		/* 821F1834h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F1834h case    7:*/		return 0x821F1838;
		  /* 821F1838h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1838h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1838h case    8:*/		return 0x821F183C;
		  /* 821F183Ch */ case    9:  		/* stw R9, <#[R11]> */
		/* 821F183Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F183Ch case    9:*/		return 0x821F1840;
		  /* 821F1840h */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 821F1840h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821F1840h case   10:*/		return 0x821F1844;
		  /* 821F1844h */ case   11:  		/* lwz R10, <#[R10]> */
		/* 821F1844h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F1844h case   11:*/		return 0x821F1848;
		  /* 821F1848h */ case   12:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F1848h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F1848h case   12:*/		return 0x821F184C;
		  /* 821F184Ch */ case   13:  		/* stw R11, <#[R10]> */
		/* 821F184Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821F184Ch case   13:*/		return 0x821F1850;
		  /* 821F1850h */ case   14:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F1850h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F1850h case   14:*/		return 0x821F1854;
		  /* 821F1854h */ case   15:  		/* addi R11, R11, 2 */
		/* 821F1854h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F1854h case   15:*/		return 0x821F1858;
		  /* 821F1858h */ case   16:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F1858h case   16:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F1858h case   16:*/		return 0x821F185C;
		  /* 821F185Ch */ case   17:  		/* bl -653908 */
		/* 821F185Ch case   17:*/		regs.LR = 0x821F1860; return 0x82151E08;
		/* 821F185Ch case   17:*/		return 0x821F1860;
		  /* 821F1860h */ case   18:  		/* b -104 */
		/* 821F1860h case   18:*/		return 0x821F17F8;
		/* 821F1860h case   18:*/		return 0x821F1864;
	}
	return 0x821F1864;
} // Block from 821F1818h-821F1864h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821F1864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1864);
		  /* 821F1864h */ case    0:  		/* subf. R11, R31, R11 */
		/* 821F1864h case    0:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R31,regs.R11);
		/* 821F1864h case    0:*/		return 0x821F1868;
		  /* 821F1868h */ case    1:  		/* addi R10, R11, 2 */
		/* 821F1868h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x2);
		/* 821F1868h case    1:*/		return 0x821F186C;
		  /* 821F186Ch */ case    2:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 821F186Ch case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 821F186Ch case    2:*/		return 0x821F1870;
		  /* 821F1870h */ case    3:  		/* add R9, R10, R4 */
		/* 821F1870h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 821F1870h case    3:*/		return 0x821F1874;
		  /* 821F1874h */ case    4:  		/* lwzx R10, <#[R10 + R4]> */
		/* 821F1874h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821F1874h case    4:*/		return 0x821F1878;
		  /* 821F1878h */ case    5:  		/* lwz R9, <#[R9 + 4]> */
		/* 821F1878h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821F1878h case    5:*/		return 0x821F187C;
		  /* 821F187Ch */ case    6:  		/* stw R11, <#[R4 + 8]> */
		/* 821F187Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F187Ch case    6:*/		return 0x821F1880;
		  /* 821F1880h */ case    7:  		/* stw R10, <#[R29]> */
		/* 821F1880h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821F1880h case    7:*/		return 0x821F1884;
		  /* 821F1884h */ case    8:  		/* stw R9, <#[R29 + 4]> */
		/* 821F1884h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 821F1884h case    8:*/		return 0x821F1888;
		  /* 821F1888h */ case    9:  		/* bc 4, CR0_EQ, 60 */
		/* 821F1888h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821F18C4;  }
		/* 821F1888h case    9:*/		return 0x821F188C;
		  /* 821F188Ch */ case   10:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F188Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F188Ch case   10:*/		return 0x821F1890;
		  /* 821F1890h */ case   11:  		/* mr R3, R30 */
		/* 821F1890h case   11:*/		regs.R3 = regs.R30;
		/* 821F1890h case   11:*/		return 0x821F1894;
		  /* 821F1894h */ case   12:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1894h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1894h case   12:*/		return 0x821F1898;
		  /* 821F1898h */ case   13:  		/* lwz R9, <#[R11]> */
		/* 821F1898h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1898h case   13:*/		return 0x821F189C;
		  /* 821F189Ch */ case   14:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F189Ch case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F189Ch case   14:*/		return 0x821F18A0;
		  /* 821F18A0h */ case   15:  		/* stw R9, <#[R10]> */
		/* 821F18A0h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F18A0h case   15:*/		return 0x821F18A4;
		  /* 821F18A4h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F18A4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F18A4h case   16:*/		return 0x821F18A8;
		  /* 821F18A8h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 821F18A8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F18A8h case   17:*/		return 0x821F18AC;
		  /* 821F18ACh */ case   18:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F18ACh case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F18ACh case   18:*/		return 0x821F18B0;
		  /* 821F18B0h */ case   19:  		/* stw R10, <#[R11]> */
		/* 821F18B0h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F18B0h case   19:*/		return 0x821F18B4;
		  /* 821F18B4h */ case   20:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F18B4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F18B4h case   20:*/		return 0x821F18B8;
		  /* 821F18B8h */ case   21:  		/* addi R11, R11, 2 */
		/* 821F18B8h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F18B8h case   21:*/		return 0x821F18BC;
		  /* 821F18BCh */ case   22:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F18BCh case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F18BCh case   22:*/		return 0x821F18C0;
		  /* 821F18C0h */ case   23:  		/* bl -654008 */
		/* 821F18C0h case   23:*/		regs.LR = 0x821F18C4; return 0x82151E08;
		/* 821F18C0h case   23:*/		return 0x821F18C4;
	}
	return 0x821F18C4;
} // Block from 821F1864h-821F18C4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821F18C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F18C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F18C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F18C4);
		  /* 821F18C4h */ case    0:  		/* mr R3, R29 */
		/* 821F18C4h case    0:*/		regs.R3 = regs.R29;
		/* 821F18C4h case    0:*/		return 0x821F18C8;
		  /* 821F18C8h */ case    1:  		/* addi R1, R1, 112 */
		/* 821F18C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F18C8h case    1:*/		return 0x821F18CC;
		  /* 821F18CCh */ case    2:  		/* b -1443360 */
		/* 821F18CCh case    2:*/		return 0x820912AC;
		/* 821F18CCh case    2:*/		return 0x821F18D0;
	}
	return 0x821F18D0;
} // Block from 821F18C4h-821F18D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F18D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F18D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F18D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F18D0);
		  /* 821F18D0h */ case    0:  		/* mfspr R12, LR */
		/* 821F18D0h case    0:*/		regs.R12 = regs.LR;
		/* 821F18D0h case    0:*/		return 0x821F18D4;
		  /* 821F18D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F18D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F18D4h case    1:*/		return 0x821F18D8;
		  /* 821F18D8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F18D8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F18D8h case    2:*/		return 0x821F18DC;
		  /* 821F18DCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F18DCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F18DCh case    3:*/		return 0x821F18E0;
		  /* 821F18E0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F18E0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F18E0h case    4:*/		return 0x821F18E4;
		  /* 821F18E4h */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 821F18E4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 821F18E4h case    5:*/		return 0x821F18E8;
		  /* 821F18E8h */ case    6:  		/* mr R30, R3 */
		/* 821F18E8h case    6:*/		regs.R30 = regs.R3;
		/* 821F18E8h case    6:*/		return 0x821F18EC;
		  /* 821F18ECh */ case    7:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 821F18ECh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 821F18ECh case    7:*/		return 0x821F18F0;
		  /* 821F18F0h */ case    8:  		/* bc 4, CR0_EQ, 100 */
		/* 821F18F0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821F1954;  }
		/* 821F18F0h case    8:*/		return 0x821F18F4;
		  /* 821F18F4h */ case    9:  		/* cmplwi CR0, R4, 0 */
		/* 821F18F4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R4,0x00000000);
		/* 821F18F4h case    9:*/		return 0x821F18F8;
		  /* 821F18F8h */ case   10:  		/* bc 12, CR0_EQ, 92 */
		/* 821F18F8h case   10:*/		if ( regs.CR[0].eq ) { return 0x821F1954;  }
		/* 821F18F8h case   10:*/		return 0x821F18FC;
		  /* 821F18FCh */ case   11:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F18FCh case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F18FCh case   11:*/		return 0x821F1900;
		  /* 821F1900h */ case   12:  		/* mr R3, R30 */
		/* 821F1900h case   12:*/		regs.R3 = regs.R30;
		/* 821F1900h case   12:*/		return 0x821F1904;
		  /* 821F1904h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1904h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1904h case   13:*/		return 0x821F1908;
		  /* 821F1908h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 821F1908h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1908h case   14:*/		return 0x821F190C;
		  /* 821F190Ch */ case   15:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F190Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F190Ch case   15:*/		return 0x821F1910;
		  /* 821F1910h */ case   16:  		/* lwz R8, <#[R11 + 4]> */
		/* 821F1910h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1910h case   16:*/		return 0x821F1914;
		  /* 821F1914h */ case   17:  		/* rlwinm R7, R8, 0, 31, 31 */
		/* 821F1914h case   17:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R8);
		/* 821F1914h case   17:*/		return 0x821F1918;
		  /* 821F1918h */ case   18:  		/* addic R7, R7, -1 */
		/* 821F1918h case   18:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 821F1918h case   18:*/		return 0x821F191C;
		  /* 821F191Ch */ case   19:  		/* stw R9, <#[R10]> */
		/* 821F191Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F191Ch case   19:*/		return 0x821F1920;
		  /* 821F1920h */ case   20:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1920h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1920h case   20:*/		return 0x821F1924;
		  /* 821F1924h */ case   21:  		/* subfe R9, R7, R7 */
		/* 821F1924h case   21:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R7,regs.R7);
		/* 821F1924h case   21:*/		return 0x821F1928;
		  /* 821F1928h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 821F1928h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1928h case   22:*/		return 0x821F192C;
		  /* 821F192Ch */ case   23:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F192Ch case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F192Ch case   23:*/		return 0x821F1930;
		  /* 821F1930h */ case   24:  		/* stw R10, <#[R11]> */
		/* 821F1930h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1930h case   24:*/		return 0x821F1934;
		  /* 821F1934h */ case   25:  		/* and R31, R9, R8 */
		/* 821F1934h case   25:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R8);
		/* 821F1934h case   25:*/		return 0x821F1938;
		  /* 821F1938h */ case   26:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F1938h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F1938h case   26:*/		return 0x821F193C;
		  /* 821F193Ch */ case   27:  		/* addi R11, R11, 2 */
		/* 821F193Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F193Ch case   27:*/		return 0x821F1940;
		  /* 821F1940h */ case   28:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F1940h case   28:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F1940h case   28:*/		return 0x821F1944;
		  /* 821F1944h */ case   29:  		/* bl -654140 */
		/* 821F1944h case   29:*/		regs.LR = 0x821F1948; return 0x82151E08;
		/* 821F1944h case   29:*/		return 0x821F1948;
		  /* 821F1948h */ case   30:  		/* mr R4, R31 */
		/* 821F1948h case   30:*/		regs.R4 = regs.R31;
		/* 821F1948h case   30:*/		return 0x821F194C;
		  /* 821F194Ch */ case   31:  		/* cmplwi CR6, R31, 0 */
		/* 821F194Ch case   31:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821F194Ch case   31:*/		return 0x821F1950;
		  /* 821F1950h */ case   32:  		/* bc 4, CR6_EQ, -84 */
		/* 821F1950h case   32:*/		if ( !regs.CR[6].eq ) { return 0x821F18FC;  }
		/* 821F1950h case   32:*/		return 0x821F1954;
	}
	return 0x821F1954;
} // Block from 821F18D0h-821F1954h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821F1954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1954);
		  /* 821F1954h */ case    0:  		/* addi R1, R1, 112 */
		/* 821F1954h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1954h case    0:*/		return 0x821F1958;
		  /* 821F1958h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1958h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1958h case    1:*/		return 0x821F195C;
		  /* 821F195Ch */ case    2:  		/* mtspr LR, R12 */
		/* 821F195Ch case    2:*/		regs.LR = regs.R12;
		/* 821F195Ch case    2:*/		return 0x821F1960;
		  /* 821F1960h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1960h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1960h case    3:*/		return 0x821F1964;
		  /* 821F1964h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1964h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1964h case    4:*/		return 0x821F1968;
		  /* 821F1968h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F1968h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1968h case    5:*/		return 0x821F196C;
	}
	return 0x821F196C;
} // Block from 821F1954h-821F196Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F196Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F196C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F196C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F196C);
		  /* 821F196Ch */ case    0:  		/* nop */
		/* 821F196Ch case    0:*/		cpu::op::nop();
		/* 821F196Ch case    0:*/		return 0x821F1970;
		  /* 821F1970h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 821F1970h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821F1970h case    1:*/		return 0x821F1974;
		  /* 821F1974h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 821F1974h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821F1974h case    2:*/		return 0x821F1978;
	}
	return 0x821F1978;
} // Block from 821F196Ch-821F1978h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F1978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1978);
		  /* 821F1978h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F1978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1978h case    0:*/		return 0x821F197C;
		  /* 821F197Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F197Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F197Ch case    1:*/		return 0x821F1980;
		  /* 821F1980h */ case    2:  		/* bc 4, CR6_EQ, 52 */
		/* 821F1980h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F19B4;  }
		/* 821F1980h case    2:*/		return 0x821F1984;
		  /* 821F1984h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F1984h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1984h case    3:*/		return 0x821F1988;
		  /* 821F1988h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1988h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1988h case    4:*/		return 0x821F198C;
		  /* 821F198Ch */ case    5:  		/* lwz R11, <#[R11]> */
		/* 821F198Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F198Ch case    5:*/		return 0x821F1990;
		  /* 821F1990h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821F1990h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821F1990h case    6:*/		return 0x821F1994;
		  /* 821F1994h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821F1994h case    7:*/		if ( regs.CR[0].eq ) { return 0x821F19A0;  }
		/* 821F1994h case    7:*/		return 0x821F1998;
		  /* 821F1998h */ case    8:  		/* li R11, 0 */
		/* 821F1998h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F1998h case    8:*/		return 0x821F199C;
		  /* 821F199Ch */ case    9:  		/* b 12 */
		/* 821F199Ch case    9:*/		return 0x821F19A8;
		/* 821F199Ch case    9:*/		return 0x821F19A0;
	}
	return 0x821F19A0;
} // Block from 821F1978h-821F19A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F19A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19A0);
		  /* 821F19A0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F19A0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F19A0h case    0:*/		return 0x821F19A4;
		  /* 821F19A4h */ case    1:  		/* addi R11, R11, -4 */
		/* 821F19A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F19A4h case    1:*/		return 0x821F19A8;
	}
	return 0x821F19A8;
} // Block from 821F19A0h-821F19A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F19A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19A8);
		  /* 821F19A8h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 821F19A8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F19A8h case    0:*/		return 0x821F19AC;
		  /* 821F19ACh */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 821F19ACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821F19ACh case    1:*/		return 0x821F19B0;
		  /* 821F19B0h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 821F19B0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F19B0h case    2:*/		return 0x821F19B4;
	}
	return 0x821F19B4;
} // Block from 821F19A8h-821F19B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F19B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19B4);
		  /* 821F19B4h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 821F19B4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821F19B4h case    0:*/		return 0x821F19B8;
		  /* 821F19B8h */ case    1:  		/* mr R11, R4 */
		/* 821F19B8h case    1:*/		regs.R11 = regs.R4;
		/* 821F19B8h case    1:*/		return 0x821F19BC;
		  /* 821F19BCh */ case    2:  		/* cmplw CR6, R4, R10 */
		/* 821F19BCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 821F19BCh case    2:*/		return 0x821F19C0;
		  /* 821F19C0h */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 821F19C0h case    3:*/		if ( regs.CR[6].lt ) { return 0x821F19C8;  }
		/* 821F19C0h case    3:*/		return 0x821F19C4;
		  /* 821F19C4h */ case    4:  		/* mr R11, R10 */
		/* 821F19C4h case    4:*/		regs.R11 = regs.R10;
		/* 821F19C4h case    4:*/		return 0x821F19C8;
	}
	return 0x821F19C8;
} // Block from 821F19B4h-821F19C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F19C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19C8);
		  /* 821F19C8h */ case    0:  		/* subf R10, R11, R10 */
		/* 821F19C8h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821F19C8h case    0:*/		return 0x821F19CC;
		  /* 821F19CCh */ case    1:  		/* subf. R4, R11, R4 */
		/* 821F19CCh case    1:*/		cpu::op::subf<1>(regs,&regs.R4,regs.R11,regs.R4);
		/* 821F19CCh case    1:*/		return 0x821F19D0;
	}
	return 0x821F19D0;
} // Block from 821F19C8h-821F19D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F19D0h
// Function '?CreateMicrocodeVariableDeclaration@Compiler@D3DXShader@@AAAPAVCNodeDecl@2@PBDIIW4_D3DCOMPONENT_TYPE@2@IIPAPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19D0);
		  /* 821F19D0h */ case    0:  		/* stw R10, <#[R3 + 8]> */
		/* 821F19D0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821F19D0h case    0:*/		return 0x821F19D4;
		  /* 821F19D4h */ case    1:  		/* bc 4, CR0_EQ, -92 */
		/* 821F19D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821F1978;  }
		/* 821F19D4h case    1:*/		return 0x821F19D8;
		  /* 821F19D8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821F19D8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F19D8h case    2:*/		return 0x821F19DC;
	}
	return 0x821F19DC;
} // Block from 821F19D0h-821F19DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F19DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19DC);
		  /* 821F19DCh */ case    0:  		/* nop */
		/* 821F19DCh case    0:*/		cpu::op::nop();
		/* 821F19DCh case    0:*/		return 0x821F19E0;
	}
	return 0x821F19E0;
} // Block from 821F19DCh-821F19E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F19E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F19E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F19E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F19E0);
		  /* 821F19E0h */ case    0:  		/* mfspr R12, LR */
		/* 821F19E0h case    0:*/		regs.R12 = regs.LR;
		/* 821F19E0h case    0:*/		return 0x821F19E4;
		  /* 821F19E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F19E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F19E4h case    1:*/		return 0x821F19E8;
		  /* 821F19E8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F19E8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F19E8h case    2:*/		return 0x821F19EC;
		  /* 821F19ECh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F19ECh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F19ECh case    3:*/		return 0x821F19F0;
		  /* 821F19F0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F19F0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F19F0h case    4:*/		return 0x821F19F4;
		  /* 821F19F4h */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 821F19F4h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 821F19F4h case    5:*/		return 0x821F19F8;
		  /* 821F19F8h */ case    6:  		/* mr R30, R3 */
		/* 821F19F8h case    6:*/		regs.R30 = regs.R3;
		/* 821F19F8h case    6:*/		return 0x821F19FC;
		  /* 821F19FCh */ case    7:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 821F19FCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 821F19FCh case    7:*/		return 0x821F1A00;
		  /* 821F1A00h */ case    8:  		/* bc 4, CR0_EQ, 100 */
		/* 821F1A00h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821F1A64;  }
		/* 821F1A00h case    8:*/		return 0x821F1A04;
		  /* 821F1A04h */ case    9:  		/* cmplwi CR0, R4, 0 */
		/* 821F1A04h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R4,0x00000000);
		/* 821F1A04h case    9:*/		return 0x821F1A08;
		  /* 821F1A08h */ case   10:  		/* bc 12, CR0_EQ, 92 */
		/* 821F1A08h case   10:*/		if ( regs.CR[0].eq ) { return 0x821F1A64;  }
		/* 821F1A08h case   10:*/		return 0x821F1A0C;
		  /* 821F1A0Ch */ case   11:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F1A0Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F1A0Ch case   11:*/		return 0x821F1A10;
		  /* 821F1A10h */ case   12:  		/* mr R3, R30 */
		/* 821F1A10h case   12:*/		regs.R3 = regs.R30;
		/* 821F1A10h case   12:*/		return 0x821F1A14;
		  /* 821F1A14h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1A14h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1A14h case   13:*/		return 0x821F1A18;
		  /* 821F1A18h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 821F1A18h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1A18h case   14:*/		return 0x821F1A1C;
		  /* 821F1A1Ch */ case   15:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F1A1Ch case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F1A1Ch case   15:*/		return 0x821F1A20;
		  /* 821F1A20h */ case   16:  		/* lwz R8, <#[R11 + 4]> */
		/* 821F1A20h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1A20h case   16:*/		return 0x821F1A24;
		  /* 821F1A24h */ case   17:  		/* rlwinm R7, R8, 0, 31, 31 */
		/* 821F1A24h case   17:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R8);
		/* 821F1A24h case   17:*/		return 0x821F1A28;
		  /* 821F1A28h */ case   18:  		/* addic R7, R7, -1 */
		/* 821F1A28h case   18:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 821F1A28h case   18:*/		return 0x821F1A2C;
		  /* 821F1A2Ch */ case   19:  		/* stw R9, <#[R10]> */
		/* 821F1A2Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F1A2Ch case   19:*/		return 0x821F1A30;
		  /* 821F1A30h */ case   20:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1A30h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1A30h case   20:*/		return 0x821F1A34;
		  /* 821F1A34h */ case   21:  		/* subfe R9, R7, R7 */
		/* 821F1A34h case   21:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R7,regs.R7);
		/* 821F1A34h case   21:*/		return 0x821F1A38;
		  /* 821F1A38h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 821F1A38h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1A38h case   22:*/		return 0x821F1A3C;
		  /* 821F1A3Ch */ case   23:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1A3Ch case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1A3Ch case   23:*/		return 0x821F1A40;
		  /* 821F1A40h */ case   24:  		/* stw R10, <#[R11]> */
		/* 821F1A40h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1A40h case   24:*/		return 0x821F1A44;
		  /* 821F1A44h */ case   25:  		/* and R31, R9, R8 */
		/* 821F1A44h case   25:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R8);
		/* 821F1A44h case   25:*/		return 0x821F1A48;
		  /* 821F1A48h */ case   26:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F1A48h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F1A48h case   26:*/		return 0x821F1A4C;
		  /* 821F1A4Ch */ case   27:  		/* addi R11, R11, 4 */
		/* 821F1A4Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821F1A4Ch case   27:*/		return 0x821F1A50;
		  /* 821F1A50h */ case   28:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821F1A50h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821F1A50h case   28:*/		return 0x821F1A54;
		  /* 821F1A54h */ case   29:  		/* bl -654412 */
		/* 821F1A54h case   29:*/		regs.LR = 0x821F1A58; return 0x82151E08;
		/* 821F1A54h case   29:*/		return 0x821F1A58;
		  /* 821F1A58h */ case   30:  		/* mr R4, R31 */
		/* 821F1A58h case   30:*/		regs.R4 = regs.R31;
		/* 821F1A58h case   30:*/		return 0x821F1A5C;
		  /* 821F1A5Ch */ case   31:  		/* cmplwi CR6, R31, 0 */
		/* 821F1A5Ch case   31:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821F1A5Ch case   31:*/		return 0x821F1A60;
		  /* 821F1A60h */ case   32:  		/* bc 4, CR6_EQ, -84 */
		/* 821F1A60h case   32:*/		if ( !regs.CR[6].eq ) { return 0x821F1A0C;  }
		/* 821F1A60h case   32:*/		return 0x821F1A64;
	}
	return 0x821F1A64;
} // Block from 821F19E0h-821F1A64h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821F1A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1A64);
		  /* 821F1A64h */ case    0:  		/* addi R1, R1, 112 */
		/* 821F1A64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1A64h case    0:*/		return 0x821F1A68;
		  /* 821F1A68h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1A68h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1A68h case    1:*/		return 0x821F1A6C;
		  /* 821F1A6Ch */ case    2:  		/* mtspr LR, R12 */
		/* 821F1A6Ch case    2:*/		regs.LR = regs.R12;
		/* 821F1A6Ch case    2:*/		return 0x821F1A70;
		  /* 821F1A70h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1A70h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1A70h case    3:*/		return 0x821F1A74;
		  /* 821F1A74h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1A74h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1A74h case    4:*/		return 0x821F1A78;
		  /* 821F1A78h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F1A78h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1A78h case    5:*/		return 0x821F1A7C;
	}
	return 0x821F1A7C;
} // Block from 821F1A64h-821F1A7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F1A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1A7C);
		  /* 821F1A7Ch */ case    0:  		/* nop */
		/* 821F1A7Ch case    0:*/		cpu::op::nop();
		/* 821F1A7Ch case    0:*/		return 0x821F1A80;
		  /* 821F1A80h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F1A80h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1A80h case    1:*/		return 0x821F1A84;
		  /* 821F1A84h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821F1A84h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F1A84h case    2:*/		return 0x821F1A88;
		  /* 821F1A88h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 821F1A88h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F1AC4;  }
		/* 821F1A88h case    3:*/		return 0x821F1A8C;
		  /* 821F1A8Ch */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F1A8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1A8Ch case    4:*/		return 0x821F1A90;
		  /* 821F1A90h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1A90h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1A90h case    5:*/		return 0x821F1A94;
		  /* 821F1A94h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 821F1A94h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1A94h case    6:*/		return 0x821F1A98;
		  /* 821F1A98h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821F1A98h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821F1A98h case    7:*/		return 0x821F1A9C;
		  /* 821F1A9Ch */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821F1A9Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x821F1AA8;  }
		/* 821F1A9Ch case    8:*/		return 0x821F1AA0;
		  /* 821F1AA0h */ case    9:  		/* li R11, 0 */
		/* 821F1AA0h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F1AA0h case    9:*/		return 0x821F1AA4;
		  /* 821F1AA4h */ case   10:  		/* b 12 */
		/* 821F1AA4h case   10:*/		return 0x821F1AB0;
		/* 821F1AA4h case   10:*/		return 0x821F1AA8;
	}
	return 0x821F1AA8;
} // Block from 821F1A7Ch-821F1AA8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F1AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1AA8);
		  /* 821F1AA8h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1AA8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1AA8h case    0:*/		return 0x821F1AAC;
		  /* 821F1AACh */ case    1:  		/* addi R11, R11, -4 */
		/* 821F1AACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F1AACh case    1:*/		return 0x821F1AB0;
	}
	return 0x821F1AB0;
} // Block from 821F1AA8h-821F1AB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F1AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1AB0);
		  /* 821F1AB0h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821F1AB0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F1AB0h case    0:*/		return 0x821F1AB4;
		  /* 821F1AB4h */ case    1:  		/* addi R10, R10, 1 */
		/* 821F1AB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F1AB4h case    1:*/		return 0x821F1AB8;
		  /* 821F1AB8h */ case    2:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 821F1AB8h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 821F1AB8h case    2:*/		return 0x821F1ABC;
		  /* 821F1ABCh */ case    3:  		/* add R3, R10, R11 */
		/* 821F1ABCh case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 821F1ABCh case    3:*/		return 0x821F1AC0;
		  /* 821F1AC0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821F1AC0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1AC0h case    4:*/		return 0x821F1AC4;
	}
	return 0x821F1AC4;
} // Block from 821F1AB0h-821F1AC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F1AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1AC4);
		  /* 821F1AC4h */ case    0:  		/* addi R11, R11, 1 */
		/* 821F1AC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F1AC4h case    0:*/		return 0x821F1AC8;
		  /* 821F1AC8h */ case    1:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F1AC8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1AC8h case    1:*/		return 0x821F1ACC;
		  /* 821F1ACCh */ case    2:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 821F1ACCh case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 821F1ACCh case    2:*/		return 0x821F1AD0;
		  /* 821F1AD0h */ case    3:  		/* add R3, R11, R10 */
		/* 821F1AD0h case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 821F1AD0h case    3:*/		return 0x821F1AD4;
		  /* 821F1AD4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821F1AD4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1AD4h case    4:*/		return 0x821F1AD8;
	}
	return 0x821F1AD8;
} // Block from 821F1AC4h-821F1AD8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F1AD8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1AD8);
		  /* 821F1AD8h */ case    0:  		/* mfspr R12, LR */
		/* 821F1AD8h case    0:*/		regs.R12 = regs.LR;
		/* 821F1AD8h case    0:*/		return 0x821F1ADC;
		  /* 821F1ADCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1ADCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1ADCh case    1:*/		return 0x821F1AE0;
		  /* 821F1AE0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F1AE0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1AE0h case    2:*/		return 0x821F1AE4;
		  /* 821F1AE4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F1AE4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1AE4h case    3:*/		return 0x821F1AE8;
		  /* 821F1AE8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1AE8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1AE8h case    4:*/		return 0x821F1AEC;
		  /* 821F1AECh */ case    5:  		/* lwz R4, <#[R3 + 4]> */
		/* 821F1AECh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1AECh case    5:*/		return 0x821F1AF0;
		  /* 821F1AF0h */ case    6:  		/* mr R30, R3 */
		/* 821F1AF0h case    6:*/		regs.R30 = regs.R3;
		/* 821F1AF0h case    6:*/		return 0x821F1AF4;
		  /* 821F1AF4h */ case    7:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 821F1AF4h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 821F1AF4h case    7:*/		return 0x821F1AF8;
		  /* 821F1AF8h */ case    8:  		/* bc 4, CR0_EQ, 100 */
		/* 821F1AF8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821F1B5C;  }
		/* 821F1AF8h case    8:*/		return 0x821F1AFC;
		  /* 821F1AFCh */ case    9:  		/* cmplwi CR0, R4, 0 */
		/* 821F1AFCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R4,0x00000000);
		/* 821F1AFCh case    9:*/		return 0x821F1B00;
		  /* 821F1B00h */ case   10:  		/* bc 12, CR0_EQ, 92 */
		/* 821F1B00h case   10:*/		if ( regs.CR[0].eq ) { return 0x821F1B5C;  }
		/* 821F1B00h case   10:*/		return 0x821F1B04;
		  /* 821F1B04h */ case   11:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F1B04h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F1B04h case   11:*/		return 0x821F1B08;
		  /* 821F1B08h */ case   12:  		/* mr R3, R30 */
		/* 821F1B08h case   12:*/		regs.R3 = regs.R30;
		/* 821F1B08h case   12:*/		return 0x821F1B0C;
		  /* 821F1B0Ch */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1B0Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1B0Ch case   13:*/		return 0x821F1B10;
		  /* 821F1B10h */ case   14:  		/* lwz R9, <#[R11]> */
		/* 821F1B10h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1B10h case   14:*/		return 0x821F1B14;
		  /* 821F1B14h */ case   15:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F1B14h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F1B14h case   15:*/		return 0x821F1B18;
		  /* 821F1B18h */ case   16:  		/* lwz R8, <#[R11 + 4]> */
		/* 821F1B18h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1B18h case   16:*/		return 0x821F1B1C;
		  /* 821F1B1Ch */ case   17:  		/* rlwinm R7, R8, 0, 31, 31 */
		/* 821F1B1Ch case   17:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R7,regs.R8);
		/* 821F1B1Ch case   17:*/		return 0x821F1B20;
		  /* 821F1B20h */ case   18:  		/* addic R7, R7, -1 */
		/* 821F1B20h case   18:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 821F1B20h case   18:*/		return 0x821F1B24;
		  /* 821F1B24h */ case   19:  		/* stw R9, <#[R10]> */
		/* 821F1B24h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F1B24h case   19:*/		return 0x821F1B28;
		  /* 821F1B28h */ case   20:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F1B28h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1B28h case   20:*/		return 0x821F1B2C;
		  /* 821F1B2Ch */ case   21:  		/* subfe R9, R7, R7 */
		/* 821F1B2Ch case   21:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R7,regs.R7);
		/* 821F1B2Ch case   21:*/		return 0x821F1B30;
		  /* 821F1B30h */ case   22:  		/* lwz R11, <#[R11]> */
		/* 821F1B30h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1B30h case   22:*/		return 0x821F1B34;
		  /* 821F1B34h */ case   23:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1B34h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1B34h case   23:*/		return 0x821F1B38;
		  /* 821F1B38h */ case   24:  		/* stw R10, <#[R11]> */
		/* 821F1B38h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1B38h case   24:*/		return 0x821F1B3C;
		  /* 821F1B3Ch */ case   25:  		/* and R31, R9, R8 */
		/* 821F1B3Ch case   25:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R8);
		/* 821F1B3Ch case   25:*/		return 0x821F1B40;
		  /* 821F1B40h */ case   26:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F1B40h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F1B40h case   26:*/		return 0x821F1B44;
		  /* 821F1B44h */ case   27:  		/* mulli R11, R11, 12 */
		/* 821F1B44h case   27:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 821F1B44h case   27:*/		return 0x821F1B48;
		  /* 821F1B48h */ case   28:  		/* addi R5, R11, 16 */
		/* 821F1B48h case   28:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x10);
		/* 821F1B48h case   28:*/		return 0x821F1B4C;
		  /* 821F1B4Ch */ case   29:  		/* bl -654660 */
		/* 821F1B4Ch case   29:*/		regs.LR = 0x821F1B50; return 0x82151E08;
		/* 821F1B4Ch case   29:*/		return 0x821F1B50;
		  /* 821F1B50h */ case   30:  		/* mr R4, R31 */
		/* 821F1B50h case   30:*/		regs.R4 = regs.R31;
		/* 821F1B50h case   30:*/		return 0x821F1B54;
		  /* 821F1B54h */ case   31:  		/* cmplwi CR6, R31, 0 */
		/* 821F1B54h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821F1B54h case   31:*/		return 0x821F1B58;
		  /* 821F1B58h */ case   32:  		/* bc 4, CR6_EQ, -84 */
		/* 821F1B58h case   32:*/		if ( !regs.CR[6].eq ) { return 0x821F1B04;  }
		/* 821F1B58h case   32:*/		return 0x821F1B5C;
	}
	return 0x821F1B5C;
} // Block from 821F1AD8h-821F1B5Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 821F1B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1B5C);
		  /* 821F1B5Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 821F1B5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1B5Ch case    0:*/		return 0x821F1B60;
		  /* 821F1B60h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1B60h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1B60h case    1:*/		return 0x821F1B64;
		  /* 821F1B64h */ case    2:  		/* mtspr LR, R12 */
		/* 821F1B64h case    2:*/		regs.LR = regs.R12;
		/* 821F1B64h case    2:*/		return 0x821F1B68;
		  /* 821F1B68h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1B68h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1B68h case    3:*/		return 0x821F1B6C;
		  /* 821F1B6Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1B6Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1B6Ch case    4:*/		return 0x821F1B70;
		  /* 821F1B70h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F1B70h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1B70h case    5:*/		return 0x821F1B74;
	}
	return 0x821F1B74;
} // Block from 821F1B5Ch-821F1B74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F1B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1B74);
		  /* 821F1B74h */ case    0:  		/* nop */
		/* 821F1B74h case    0:*/		cpu::op::nop();
		/* 821F1B74h case    0:*/		return 0x821F1B78;
		  /* 821F1B78h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F1B78h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1B78h case    1:*/		return 0x821F1B7C;
		  /* 821F1B7Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821F1B7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F1B7Ch case    2:*/		return 0x821F1B80;
		  /* 821F1B80h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 821F1B80h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F1BB4;  }
		/* 821F1B80h case    3:*/		return 0x821F1B84;
		  /* 821F1B84h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F1B84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1B84h case    4:*/		return 0x821F1B88;
	}
	return 0x821F1B88;
} // Block from 821F1B74h-821F1B88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F1B88h
// Function '?ImportMicrocodeInputVariable@Compiler@D3DXShader@@AAAXPBDIKKPAPAVCNode@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1B88);
		  /* 821F1B88h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1B88h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1B88h case    0:*/		return 0x821F1B8C;
		  /* 821F1B8Ch */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821F1B8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1B8Ch case    1:*/		return 0x821F1B90;
		  /* 821F1B90h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821F1B90h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821F1B90h case    2:*/		return 0x821F1B94;
		  /* 821F1B94h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821F1B94h case    3:*/		if ( regs.CR[0].eq ) { return 0x821F1BA0;  }
		/* 821F1B94h case    3:*/		return 0x821F1B98;
		  /* 821F1B98h */ case    4:  		/* li R11, 0 */
		/* 821F1B98h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F1B98h case    4:*/		return 0x821F1B9C;
		  /* 821F1B9Ch */ case    5:  		/* b 12 */
		/* 821F1B9Ch case    5:*/		return 0x821F1BA8;
		/* 821F1B9Ch case    5:*/		return 0x821F1BA0;
	}
	return 0x821F1BA0;
} // Block from 821F1B88h-821F1BA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F1BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1BA0);
		  /* 821F1BA0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F1BA0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F1BA0h case    0:*/		return 0x821F1BA4;
		  /* 821F1BA4h */ case    1:  		/* addi R11, R11, -4 */
		/* 821F1BA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F1BA4h case    1:*/		return 0x821F1BA8;
	}
	return 0x821F1BA8;
} // Block from 821F1BA0h-821F1BA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F1BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1BA8);
		  /* 821F1BA8h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 821F1BA8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1BA8h case    0:*/		return 0x821F1BAC;
		  /* 821F1BACh */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 821F1BACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821F1BACh case    1:*/		return 0x821F1BB0;
		  /* 821F1BB0h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 821F1BB0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1BB0h case    2:*/		return 0x821F1BB4;
	}
	return 0x821F1BB4;
} // Block from 821F1BA8h-821F1BB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F1BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1BB4);
		  /* 821F1BB4h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F1BB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1BB4h case    0:*/		return 0x821F1BB8;
		  /* 821F1BB8h */ case    1:  		/* lwz R9, <#[R3 + 4]> */
		/* 821F1BB8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1BB8h case    1:*/		return 0x821F1BBC;
		  /* 821F1BBCh */ case    2:  		/* addi R11, R11, -1 */
		/* 821F1BBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F1BBCh case    2:*/		return 0x821F1BC0;
		  /* 821F1BC0h */ case    3:  		/* rlwinm R10, R11, 5, 0, 26 */
		/* 821F1BC0h case    3:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R11);
		/* 821F1BC0h case    3:*/		return 0x821F1BC4;
		  /* 821F1BC4h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 821F1BC4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1BC4h case    4:*/		return 0x821F1BC8;
		  /* 821F1BC8h */ case    5:  		/* add R11, R10, R9 */
		/* 821F1BC8h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 821F1BC8h case    5:*/		return 0x821F1BCC;
		  /* 821F1BCCh */ case    6:  		/* addi R3, R11, 16 */
		/* 821F1BCCh case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 821F1BCCh case    6:*/		return 0x821F1BD0;
		  /* 821F1BD0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 821F1BD0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1BD0h case    7:*/		return 0x821F1BD4;
	}
	return 0x821F1BD4;
} // Block from 821F1BB4h-821F1BD4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F1BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1BD4);
		  /* 821F1BD4h */ case    0:  		/* nop */
		/* 821F1BD4h case    0:*/		cpu::op::nop();
		/* 821F1BD4h case    0:*/		return 0x821F1BD8;
	}
	return 0x821F1BD8;
} // Block from 821F1BD4h-821F1BD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1BD8);
		  /* 821F1BD8h */ case    0:  		/* mfspr R12, LR */
		/* 821F1BD8h case    0:*/		regs.R12 = regs.LR;
		/* 821F1BD8h case    0:*/		return 0x821F1BDC;
		  /* 821F1BDCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1BDCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1BDCh case    1:*/		return 0x821F1BE0;
		  /* 821F1BE0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F1BE0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1BE0h case    2:*/		return 0x821F1BE4;
		  /* 821F1BE4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F1BE4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1BE4h case    3:*/		return 0x821F1BE8;
		  /* 821F1BE8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1BE8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1BE8h case    4:*/		return 0x821F1BEC;
		  /* 821F1BECh */ case    5:  		/* mr R31, R3 */
		/* 821F1BECh case    5:*/		regs.R31 = regs.R3;
		/* 821F1BECh case    5:*/		return 0x821F1BF0;
		  /* 821F1BF0h */ case    6:  		/* cmplwi CR6, R4, 10 */
		/* 821F1BF0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000A);
		/* 821F1BF0h case    6:*/		return 0x821F1BF4;
		  /* 821F1BF4h */ case    7:  		/* mr R30, R4 */
		/* 821F1BF4h case    7:*/		regs.R30 = regs.R4;
		/* 821F1BF4h case    7:*/		return 0x821F1BF8;
		  /* 821F1BF8h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 821F1BF8h case    8:*/		if ( regs.CR[6].gt ) { return 0x821F1C00;  }
		/* 821F1BF8h case    8:*/		return 0x821F1BFC;
		  /* 821F1BFCh */ case    9:  		/* li R30, 10 */
		/* 821F1BFCh case    9:*/		cpu::op::li<0>(regs,&regs.R30,0xA);
		/* 821F1BFCh case    9:*/		return 0x821F1C00;
	}
	return 0x821F1C00;
} // Block from 821F1BD8h-821F1C00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F1C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1C00);
		  /* 821F1C00h */ case    0:  		/* mulli R11, R30, 28 */
		/* 821F1C00h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0x1C);
		/* 821F1C00h case    0:*/		return 0x821F1C04;
		  /* 821F1C04h */ case    1:  		/* addi R4, R11, 16 */
		/* 821F1C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 821F1C04h case    1:*/		return 0x821F1C08;
		  /* 821F1C08h */ case    2:  		/* mr R3, R31 */
		/* 821F1C08h case    2:*/		regs.R3 = regs.R31;
		/* 821F1C08h case    2:*/		return 0x821F1C0C;
		  /* 821F1C0Ch */ case    3:  		/* bl -576644 */
		/* 821F1C0Ch case    3:*/		regs.LR = 0x821F1C10; return 0x82164F88;
		/* 821F1C0Ch case    3:*/		return 0x821F1C10;
		  /* 821F1C10h */ case    4:  		/* li R9, 0 */
		/* 821F1C10h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821F1C10h case    4:*/		return 0x821F1C14;
		  /* 821F1C14h */ case    5:  		/* stw R30, <#[R3 + 12]> */
		/* 821F1C14h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 821F1C14h case    5:*/		return 0x821F1C18;
		  /* 821F1C18h */ case    6:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821F1C18h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821F1C18h case    6:*/		return 0x821F1C1C;
		  /* 821F1C1Ch */ case    7:  		/* stw R9, <#[R3 + 8]> */
		/* 821F1C1Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1C1Ch case    7:*/		return 0x821F1C20;
		  /* 821F1C20h */ case    8:  		/* ori R8, R31, 1 */
		/* 821F1C20h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 821F1C20h case    8:*/		return 0x821F1C24;
		  /* 821F1C24h */ case    9:  		/* lwz R9, <#[R31]> */
		/* 821F1C24h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1C24h case    9:*/		return 0x821F1C28;
		  /* 821F1C28h */ case   10:  		/* addi R10, R11, 4 */
		/* 821F1C28h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821F1C28h case   10:*/		return 0x821F1C2C;
		  /* 821F1C2Ch */ case   11:  		/* stw R9, <#[R11]> */
		/* 821F1C2Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1C2Ch case   11:*/		return 0x821F1C30;
		  /* 821F1C30h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 821F1C30h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1C30h case   12:*/		return 0x821F1C34;
		  /* 821F1C34h */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821F1C34h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821F1C34h case   13:*/		return 0x821F1C38;
		  /* 821F1C38h */ case   14:  		/* stw R11, <#[R9]> */
		/* 821F1C38h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821F1C38h case   14:*/		return 0x821F1C3C;
		  /* 821F1C3Ch */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 821F1C3Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1C3Ch case   15:*/		return 0x821F1C40;
		  /* 821F1C40h */ case   16:  		/* stw R10, <#[R31]> */
		/* 821F1C40h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1C40h case   16:*/		return 0x821F1C44;
		  /* 821F1C44h */ case   17:  		/* addi R1, R1, 112 */
		/* 821F1C44h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1C44h case   17:*/		return 0x821F1C48;
		  /* 821F1C48h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1C48h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1C48h case   18:*/		return 0x821F1C4C;
		  /* 821F1C4Ch */ case   19:  		/* mtspr LR, R12 */
		/* 821F1C4Ch case   19:*/		regs.LR = regs.R12;
		/* 821F1C4Ch case   19:*/		return 0x821F1C50;
		  /* 821F1C50h */ case   20:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1C50h case   20:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1C50h case   20:*/		return 0x821F1C54;
		  /* 821F1C54h */ case   21:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1C54h case   21:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1C54h case   21:*/		return 0x821F1C58;
		  /* 821F1C58h */ case   22:  		/* bclr 20, CR0_LT */
		/* 821F1C58h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1C58h case   22:*/		return 0x821F1C5C;
	}
	return 0x821F1C5C;
} // Block from 821F1C00h-821F1C5Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 821F1C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1C5C);
		  /* 821F1C5Ch */ case    0:  		/* nop */
		/* 821F1C5Ch case    0:*/		cpu::op::nop();
		/* 821F1C5Ch case    0:*/		return 0x821F1C60;
	}
	return 0x821F1C60;
} // Block from 821F1C5Ch-821F1C60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1C60);
		  /* 821F1C60h */ case    0:  		/* mfspr R12, LR */
		/* 821F1C60h case    0:*/		regs.R12 = regs.LR;
		/* 821F1C60h case    0:*/		return 0x821F1C64;
		  /* 821F1C64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1C64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1C64h case    1:*/		return 0x821F1C68;
		  /* 821F1C68h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F1C68h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1C68h case    2:*/		return 0x821F1C6C;
		  /* 821F1C6Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F1C6Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1C6Ch case    3:*/		return 0x821F1C70;
		  /* 821F1C70h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1C70h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1C70h case    4:*/		return 0x821F1C74;
		  /* 821F1C74h */ case    5:  		/* mr R31, R3 */
		/* 821F1C74h case    5:*/		regs.R31 = regs.R3;
		/* 821F1C74h case    5:*/		return 0x821F1C78;
		  /* 821F1C78h */ case    6:  		/* cmplwi CR6, R4, 10 */
		/* 821F1C78h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000A);
		/* 821F1C78h case    6:*/		return 0x821F1C7C;
		  /* 821F1C7Ch */ case    7:  		/* mr R30, R4 */
		/* 821F1C7Ch case    7:*/		regs.R30 = regs.R4;
		/* 821F1C7Ch case    7:*/		return 0x821F1C80;
		  /* 821F1C80h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 821F1C80h case    8:*/		if ( regs.CR[6].gt ) { return 0x821F1C88;  }
		/* 821F1C80h case    8:*/		return 0x821F1C84;
		  /* 821F1C84h */ case    9:  		/* li R30, 10 */
		/* 821F1C84h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0xA);
		/* 821F1C84h case    9:*/		return 0x821F1C88;
	}
	return 0x821F1C88;
} // Block from 821F1C60h-821F1C88h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F1C88h
// Function '?ImportMicrocodeOutputVariable@Compiler@D3DXShader@@AAAXPBDIKKKPAPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1C88);
		  /* 821F1C88h */ case    0:  		/* rlwinm R11, R30, 5, 0, 26 */
		/* 821F1C88h case    0:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R30);
		/* 821F1C88h case    0:*/		return 0x821F1C8C;
		  /* 821F1C8Ch */ case    1:  		/* mr R3, R31 */
		/* 821F1C8Ch case    1:*/		regs.R3 = regs.R31;
		/* 821F1C8Ch case    1:*/		return 0x821F1C90;
		  /* 821F1C90h */ case    2:  		/* addi R4, R11, 16 */
		/* 821F1C90h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 821F1C90h case    2:*/		return 0x821F1C94;
		  /* 821F1C94h */ case    3:  		/* bl -576780 */
		/* 821F1C94h case    3:*/		regs.LR = 0x821F1C98; return 0x82164F88;
		/* 821F1C94h case    3:*/		return 0x821F1C98;
		  /* 821F1C98h */ case    4:  		/* li R9, 0 */
		/* 821F1C98h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821F1C98h case    4:*/		return 0x821F1C9C;
		  /* 821F1C9Ch */ case    5:  		/* stw R30, <#[R3 + 12]> */
		/* 821F1C9Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 821F1C9Ch case    5:*/		return 0x821F1CA0;
		  /* 821F1CA0h */ case    6:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821F1CA0h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821F1CA0h case    6:*/		return 0x821F1CA4;
		  /* 821F1CA4h */ case    7:  		/* stw R9, <#[R3 + 8]> */
		/* 821F1CA4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1CA4h case    7:*/		return 0x821F1CA8;
		  /* 821F1CA8h */ case    8:  		/* ori R8, R31, 1 */
		/* 821F1CA8h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 821F1CA8h case    8:*/		return 0x821F1CAC;
		  /* 821F1CACh */ case    9:  		/* lwz R9, <#[R31]> */
		/* 821F1CACh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1CACh case    9:*/		return 0x821F1CB0;
		  /* 821F1CB0h */ case   10:  		/* addi R10, R11, 4 */
		/* 821F1CB0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821F1CB0h case   10:*/		return 0x821F1CB4;
		  /* 821F1CB4h */ case   11:  		/* stw R9, <#[R11]> */
		/* 821F1CB4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1CB4h case   11:*/		return 0x821F1CB8;
		  /* 821F1CB8h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 821F1CB8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1CB8h case   12:*/		return 0x821F1CBC;
		  /* 821F1CBCh */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821F1CBCh case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821F1CBCh case   13:*/		return 0x821F1CC0;
		  /* 821F1CC0h */ case   14:  		/* stw R11, <#[R9]> */
		/* 821F1CC0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821F1CC0h case   14:*/		return 0x821F1CC4;
		  /* 821F1CC4h */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 821F1CC4h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1CC4h case   15:*/		return 0x821F1CC8;
		  /* 821F1CC8h */ case   16:  		/* stw R10, <#[R31]> */
		/* 821F1CC8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1CC8h case   16:*/		return 0x821F1CCC;
		  /* 821F1CCCh */ case   17:  		/* addi R1, R1, 112 */
		/* 821F1CCCh case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1CCCh case   17:*/		return 0x821F1CD0;
		  /* 821F1CD0h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1CD0h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1CD0h case   18:*/		return 0x821F1CD4;
		  /* 821F1CD4h */ case   19:  		/* mtspr LR, R12 */
		/* 821F1CD4h case   19:*/		regs.LR = regs.R12;
		/* 821F1CD4h case   19:*/		return 0x821F1CD8;
		  /* 821F1CD8h */ case   20:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1CD8h case   20:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1CD8h case   20:*/		return 0x821F1CDC;
		  /* 821F1CDCh */ case   21:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1CDCh case   21:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1CDCh case   21:*/		return 0x821F1CE0;
		  /* 821F1CE0h */ case   22:  		/* bclr 20, CR0_LT */
		/* 821F1CE0h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1CE0h case   22:*/		return 0x821F1CE4;
	}
	return 0x821F1CE4;
} // Block from 821F1C88h-821F1CE4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821F1CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1CE4);
		  /* 821F1CE4h */ case    0:  		/* nop */
		/* 821F1CE4h case    0:*/		cpu::op::nop();
		/* 821F1CE4h case    0:*/		return 0x821F1CE8;
	}
	return 0x821F1CE8;
} // Block from 821F1CE4h-821F1CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1CE8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1CE8);
		  /* 821F1CE8h */ case    0:  		/* mfspr R12, LR */
		/* 821F1CE8h case    0:*/		regs.R12 = regs.LR;
		/* 821F1CE8h case    0:*/		return 0x821F1CEC;
		  /* 821F1CECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1CECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1CECh case    1:*/		return 0x821F1CF0;
		  /* 821F1CF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F1CF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1CF0h case    2:*/		return 0x821F1CF4;
		  /* 821F1CF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F1CF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1CF4h case    3:*/		return 0x821F1CF8;
		  /* 821F1CF8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1CF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1CF8h case    4:*/		return 0x821F1CFC;
		  /* 821F1CFCh */ case    5:  		/* mr R31, R3 */
		/* 821F1CFCh case    5:*/		regs.R31 = regs.R3;
		/* 821F1CFCh case    5:*/		return 0x821F1D00;
		  /* 821F1D00h */ case    6:  		/* cmplwi CR6, R4, 10 */
		/* 821F1D00h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000A);
		/* 821F1D00h case    6:*/		return 0x821F1D04;
		  /* 821F1D04h */ case    7:  		/* mr R30, R4 */
		/* 821F1D04h case    7:*/		regs.R30 = regs.R4;
		/* 821F1D04h case    7:*/		return 0x821F1D08;
		  /* 821F1D08h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 821F1D08h case    8:*/		if ( regs.CR[6].gt ) { return 0x821F1D10;  }
		/* 821F1D08h case    8:*/		return 0x821F1D0C;
		  /* 821F1D0Ch */ case    9:  		/* li R30, 10 */
		/* 821F1D0Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0xA);
		/* 821F1D0Ch case    9:*/		return 0x821F1D10;
	}
	return 0x821F1D10;
} // Block from 821F1CE8h-821F1D10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F1D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1D10);
		  /* 821F1D10h */ case    0:  		/* mulli R11, R30, 12 */
		/* 821F1D10h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0xC);
		/* 821F1D10h case    0:*/		return 0x821F1D14;
		  /* 821F1D14h */ case    1:  		/* addi R4, R11, 16 */
		/* 821F1D14h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x10);
		/* 821F1D14h case    1:*/		return 0x821F1D18;
		  /* 821F1D18h */ case    2:  		/* mr R3, R31 */
		/* 821F1D18h case    2:*/		regs.R3 = regs.R31;
		/* 821F1D18h case    2:*/		return 0x821F1D1C;
		  /* 821F1D1Ch */ case    3:  		/* bl -576916 */
		/* 821F1D1Ch case    3:*/		regs.LR = 0x821F1D20; return 0x82164F88;
		/* 821F1D1Ch case    3:*/		return 0x821F1D20;
		  /* 821F1D20h */ case    4:  		/* li R9, 0 */
		/* 821F1D20h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821F1D20h case    4:*/		return 0x821F1D24;
		  /* 821F1D24h */ case    5:  		/* stw R30, <#[R3 + 12]> */
		/* 821F1D24h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 821F1D24h case    5:*/		return 0x821F1D28;
		  /* 821F1D28h */ case    6:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821F1D28h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821F1D28h case    6:*/		return 0x821F1D2C;
		  /* 821F1D2Ch */ case    7:  		/* stw R9, <#[R3 + 8]> */
		/* 821F1D2Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1D2Ch case    7:*/		return 0x821F1D30;
		  /* 821F1D30h */ case    8:  		/* ori R8, R31, 1 */
		/* 821F1D30h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 821F1D30h case    8:*/		return 0x821F1D34;
		  /* 821F1D34h */ case    9:  		/* lwz R9, <#[R31]> */
		/* 821F1D34h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1D34h case    9:*/		return 0x821F1D38;
		  /* 821F1D38h */ case   10:  		/* addi R10, R11, 4 */
		/* 821F1D38h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821F1D38h case   10:*/		return 0x821F1D3C;
		  /* 821F1D3Ch */ case   11:  		/* stw R9, <#[R11]> */
		/* 821F1D3Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F1D3Ch case   11:*/		return 0x821F1D40;
		  /* 821F1D40h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 821F1D40h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1D40h case   12:*/		return 0x821F1D44;
		  /* 821F1D44h */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821F1D44h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821F1D44h case   13:*/		return 0x821F1D48;
		  /* 821F1D48h */ case   14:  		/* stw R11, <#[R9]> */
		/* 821F1D48h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821F1D48h case   14:*/		return 0x821F1D4C;
		  /* 821F1D4Ch */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 821F1D4Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F1D4Ch case   15:*/		return 0x821F1D50;
		  /* 821F1D50h */ case   16:  		/* stw R10, <#[R31]> */
		/* 821F1D50h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821F1D50h case   16:*/		return 0x821F1D54;
		  /* 821F1D54h */ case   17:  		/* addi R1, R1, 112 */
		/* 821F1D54h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1D54h case   17:*/		return 0x821F1D58;
	}
	return 0x821F1D58;
} // Block from 821F1D10h-821F1D58h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F1D58h
// Function '?RecordLexicalScopeMapping@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1D58);
		  /* 821F1D58h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1D58h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1D58h case    0:*/		return 0x821F1D5C;
		  /* 821F1D5Ch */ case    1:  		/* mtspr LR, R12 */
		/* 821F1D5Ch case    1:*/		regs.LR = regs.R12;
		/* 821F1D5Ch case    1:*/		return 0x821F1D60;
		  /* 821F1D60h */ case    2:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1D60h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1D60h case    2:*/		return 0x821F1D64;
		  /* 821F1D64h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1D64h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1D64h case    3:*/		return 0x821F1D68;
		  /* 821F1D68h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821F1D68h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1D68h case    4:*/		return 0x821F1D6C;
	}
	return 0x821F1D6C;
} // Block from 821F1D58h-821F1D6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F1D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1D6C);
		  /* 821F1D6Ch */ case    0:  		/* nop */
		/* 821F1D6Ch case    0:*/		cpu::op::nop();
		/* 821F1D6Ch case    0:*/		return 0x821F1D70;
		  /* 821F1D70h */ case    1:  		/* lwz R11, <#[R3 + 36]> */
		/* 821F1D70h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 821F1D70h case    1:*/		return 0x821F1D74;
		  /* 821F1D74h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821F1D74h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F1D74h case    2:*/		return 0x821F1D78;
		  /* 821F1D78h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 821F1D78h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F1D84;  }
		/* 821F1D78h case    3:*/		return 0x821F1D7C;
		  /* 821F1D7Ch */ case    4:  		/* li R11, 1 */
		/* 821F1D7Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1D7Ch case    4:*/		return 0x821F1D80;
		  /* 821F1D80h */ case    5:  		/* stw R11, <#[R3 + 36]> */
		/* 821F1D80h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 821F1D80h case    5:*/		return 0x821F1D84;
	}
	return 0x821F1D84;
} // Block from 821F1D6Ch-821F1D84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F1D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1D84);
		  /* 821F1D84h */ case    0:  		/* lwz R10, <#[R3 + 36]> */
		/* 821F1D84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 821F1D84h case    0:*/		return 0x821F1D88;
		  /* 821F1D88h */ case    1:  		/* addi R11, R10, 1 */
		/* 821F1D88h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 821F1D88h case    1:*/		return 0x821F1D8C;
		  /* 821F1D8Ch */ case    2:  		/* stw R11, <#[R3 + 36]> */
		/* 821F1D8Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 821F1D8Ch case    2:*/		return 0x821F1D90;
		  /* 821F1D90h */ case    3:  		/* stw R10, <#[R3 + 32]> */
		/* 821F1D90h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 821F1D90h case    3:*/		return 0x821F1D94;
		  /* 821F1D94h */ case    4:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 821F1D94h case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 821F1D94h case    4:*/		return 0x821F1D98;
		  /* 821F1D98h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 821F1D98h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821F1D98h case    5:*/		return 0x821F1D9C;
		  /* 821F1D9Ch */ case    6:  		/* bc 12, CR6_LT, 36 */
		/* 821F1D9Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x821F1DC0;  }
		/* 821F1D9Ch case    6:*/		return 0x821F1DA0;
		  /* 821F1DA0h */ case    7:  		/* lis R11, 7 */
		/* 821F1DA0h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x7);
		/* 821F1DA0h case    7:*/		return 0x821F1DA4;
		  /* 821F1DA4h */ case    8:  		/* ori R11, R11, 65534 */
		/* 821F1DA4h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFE);
		/* 821F1DA4h case    8:*/		return 0x821F1DA8;
		  /* 821F1DA8h */ case    9:  		/* cmplw CR6, R10, R11 */
		/* 821F1DA8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F1DA8h case    9:*/		return 0x821F1DAC;
		  /* 821F1DACh */ case   10:  		/* bc 12, CR6_GT, 20 */
		/* 821F1DACh case   10:*/		if ( regs.CR[6].gt ) { return 0x821F1DC0;  }
		/* 821F1DACh case   10:*/		return 0x821F1DB0;
		  /* 821F1DB0h */ case   11:  		/* lwz R11, <#[R3 + 744]> */
		/* 821F1DB0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000002E8) );
		/* 821F1DB0h case   11:*/		return 0x821F1DB4;
		  /* 821F1DB4h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821F1DB4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F1DB4h case   12:*/		return 0x821F1DB8;
		  /* 821F1DB8h */ case   13:  		/* bclr 12, CR6_EQ */
		/* 821F1DB8h case   13:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821F1DB8h case   13:*/		return 0x821F1DBC;
	}
	return 0x821F1DBC;
} // Block from 821F1D84h-821F1DBCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F1DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1DBC);
		  /* 821F1DBCh */ case    0:  		/* b -2780 */
		/* 821F1DBCh case    0:*/		return 0x821F12E0;
		/* 821F1DBCh case    0:*/		return 0x821F1DC0;
	}
	return 0x821F1DC0;
} // Block from 821F1DBCh-821F1DC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1DC0);
		  /* 821F1DC0h */ case    0:  		/* li R4, 3529 */
		/* 821F1DC0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDC9);
		/* 821F1DC0h case    0:*/		return 0x821F1DC4;
		  /* 821F1DC4h */ case    1:  		/* b -655196 */
		/* 821F1DC4h case    1:*/		return 0x82151E68;
		/* 821F1DC4h case    1:*/		return 0x821F1DC8;
		  /* 821F1DC8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821F1DC8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1DC8h case    2:*/		return 0x821F1DCC;
	}
	return 0x821F1DCC;
} // Block from 821F1DC0h-821F1DCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F1DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1DCC);
		  /* 821F1DCCh */ case    0:  		/* nop */
		/* 821F1DCCh case    0:*/		cpu::op::nop();
		/* 821F1DCCh case    0:*/		return 0x821F1DD0;
	}
	return 0x821F1DD0;
} // Block from 821F1DCCh-821F1DD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1DD0);
		  /* 821F1DD0h */ case    0:  		/* mfspr R12, LR */
		/* 821F1DD0h case    0:*/		regs.R12 = regs.LR;
		/* 821F1DD0h case    0:*/		return 0x821F1DD4;
		  /* 821F1DD4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1DD4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1DD4h case    1:*/		return 0x821F1DD8;
		  /* 821F1DD8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F1DD8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1DD8h case    2:*/		return 0x821F1DDC;
		  /* 821F1DDCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F1DDCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F1DDCh case    3:*/		return 0x821F1DE0;
		  /* 821F1DE0h */ case    4:  		/* lwz R11, <#[R4]> */
		/* 821F1DE0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821F1DE0h case    4:*/		return 0x821F1DE4;
		  /* 821F1DE4h */ case    5:  		/* mr R31, R3 */
		/* 821F1DE4h case    5:*/		regs.R31 = regs.R3;
		/* 821F1DE4h case    5:*/		return 0x821F1DE8;
		  /* 821F1DE8h */ case    6:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 821F1DE8h case    6:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 821F1DE8h case    6:*/		return 0x821F1DEC;
		  /* 821F1DECh */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 821F1DECh case    7:*/		if ( regs.CR[0].eq ) { return 0x821F1E08;  }
		/* 821F1DECh case    7:*/		return 0x821F1DF0;
		  /* 821F1DF0h */ case    8:  		/* mr R5, R4 */
		/* 821F1DF0h case    8:*/		regs.R5 = regs.R4;
		/* 821F1DF0h case    8:*/		return 0x821F1DF4;
		  /* 821F1DF4h */ case    9:  		/* bl -15052 */
		/* 821F1DF4h case    9:*/		regs.LR = 0x821F1DF8; return 0x821EE328;
		/* 821F1DF4h case    9:*/		return 0x821F1DF8;
		  /* 821F1DF8h */ case   10:  		/* mr R4, R3 */
		/* 821F1DF8h case   10:*/		regs.R4 = regs.R3;
		/* 821F1DF8h case   10:*/		return 0x821F1DFC;
		  /* 821F1DFCh */ case   11:  		/* mr R3, R31 */
		/* 821F1DFCh case   11:*/		regs.R3 = regs.R31;
		/* 821F1DFCh case   11:*/		return 0x821F1E00;
		  /* 821F1E00h */ case   12:  		/* bl -499200 */
		/* 821F1E00h case   12:*/		regs.LR = 0x821F1E04; return 0x82178000;
		/* 821F1E00h case   12:*/		return 0x821F1E04;
		  /* 821F1E04h */ case   13:  		/* b 12 */
		/* 821F1E04h case   13:*/		return 0x821F1E10;
		/* 821F1E04h case   13:*/		return 0x821F1E08;
	}
	return 0x821F1E08;
} // Block from 821F1DD0h-821F1E08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F1E08h
// Function '?GenerateArrayLoad@Compiler@D3DXShader@@AAAPAVInstruction@2@PAUIndexedResult@2@VResult@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1E08);
		  /* 821F1E08h */ case    0:  		/* lwz R5, <#[R4 + 12]> */
		/* 821F1E08h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F1E08h case    0:*/		return 0x821F1E0C;
		  /* 821F1E0Ch */ case    1:  		/* bl -527644 */
		/* 821F1E0Ch case    1:*/		regs.LR = 0x821F1E10; return 0x821710F0;
		/* 821F1E0Ch case    1:*/		return 0x821F1E10;
	}
	return 0x821F1E10;
} // Block from 821F1E08h-821F1E10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F1E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1E10);
		  /* 821F1E10h */ case    0:  		/* li R4, 2 */
		/* 821F1E10h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 821F1E10h case    0:*/		return 0x821F1E14;
		  /* 821F1E14h */ case    1:  		/* mr R31, R3 */
		/* 821F1E14h case    1:*/		regs.R31 = regs.R3;
		/* 821F1E14h case    1:*/		return 0x821F1E18;
		  /* 821F1E18h */ case    2:  		/* bl -500568 */
		/* 821F1E18h case    2:*/		regs.LR = 0x821F1E1C; return 0x82177AC0;
		/* 821F1E18h case    2:*/		return 0x821F1E1C;
		  /* 821F1E1Ch */ case    3:  		/* mr R3, R31 */
		/* 821F1E1Ch case    3:*/		regs.R3 = regs.R31;
		/* 821F1E1Ch case    3:*/		return 0x821F1E20;
		  /* 821F1E20h */ case    4:  		/* addi R1, R1, 96 */
		/* 821F1E20h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F1E20h case    4:*/		return 0x821F1E24;
		  /* 821F1E24h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1E24h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1E24h case    5:*/		return 0x821F1E28;
		  /* 821F1E28h */ case    6:  		/* mtspr LR, R12 */
		/* 821F1E28h case    6:*/		regs.LR = regs.R12;
		/* 821F1E28h case    6:*/		return 0x821F1E2C;
		  /* 821F1E2Ch */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1E2Ch case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1E2Ch case    7:*/		return 0x821F1E30;
		  /* 821F1E30h */ case    8:  		/* bclr 20, CR0_LT */
		/* 821F1E30h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1E30h case    8:*/		return 0x821F1E34;
	}
	return 0x821F1E34;
} // Block from 821F1E10h-821F1E34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F1E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1E34);
		  /* 821F1E34h */ case    0:  		/* nop */
		/* 821F1E34h case    0:*/		cpu::op::nop();
		/* 821F1E34h case    0:*/		return 0x821F1E38;
	}
	return 0x821F1E38;
} // Block from 821F1E34h-821F1E38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F1E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1E38);
		  /* 821F1E38h */ case    0:  		/* mfspr R12, LR */
		/* 821F1E38h case    0:*/		regs.R12 = regs.LR;
		/* 821F1E38h case    0:*/		return 0x821F1E3C;
		  /* 821F1E3Ch */ case    1:  		/* bl -1444832 */
		/* 821F1E3Ch case    1:*/		regs.LR = 0x821F1E40; return 0x8209125C;
		/* 821F1E3Ch case    1:*/		return 0x821F1E40;
		  /* 821F1E40h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1E40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1E40h case    2:*/		return 0x821F1E44;
		  /* 821F1E44h */ case    3:  		/* lwz R30, <#[R3 + 4]> */
		/* 821F1E44h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1E44h case    3:*/		return 0x821F1E48;
		  /* 821F1E48h */ case    4:  		/* mr R31, R3 */
		/* 821F1E48h case    4:*/		regs.R31 = regs.R3;
		/* 821F1E48h case    4:*/		return 0x821F1E4C;
		  /* 821F1E4Ch */ case    5:  		/* lwz R29, <#[R3 + 8]> */
		/* 821F1E4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 821F1E4Ch case    5:*/		return 0x821F1E50;
		  /* 821F1E50h */ case    6:  		/* bl -16472 */
		/* 821F1E50h case    6:*/		regs.LR = 0x821F1E54; return 0x821EDDF8;
		/* 821F1E50h case    6:*/		return 0x821F1E54;
		  /* 821F1E54h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 821F1E54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821F1E54h case    7:*/		return 0x821F1E58;
		  /* 821F1E58h */ case    8:  		/* lwz R10, <#[R31 + 4]> */
		/* 821F1E58h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821F1E58h case    8:*/		return 0x821F1E5C;
		  /* 821F1E5Ch */ case    9:  		/* addi R11, R11, 2 */
		/* 821F1E5Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F1E5Ch case    9:*/		return 0x821F1E60;
		  /* 821F1E60h */ case   10:  		/* stw R30, <#[R31 + 4]> */
		/* 821F1E60h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 821F1E60h case   10:*/		return 0x821F1E64;
		  /* 821F1E64h */ case   11:  		/* stw R29, <#[R31 + 8]> */
		/* 821F1E64h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 821F1E64h case   11:*/		return 0x821F1E68;
		  /* 821F1E68h */ case   12:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 821F1E68h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 821F1E68h case   12:*/		return 0x821F1E6C;
		  /* 821F1E6Ch */ case   13:  		/* add R3, R11, R10 */
		/* 821F1E6Ch case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 821F1E6Ch case   13:*/		return 0x821F1E70;
		  /* 821F1E70h */ case   14:  		/* addi R1, R1, 112 */
		/* 821F1E70h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1E70h case   14:*/		return 0x821F1E74;
		  /* 821F1E74h */ case   15:  		/* b -1444808 */
		/* 821F1E74h case   15:*/		return 0x820912AC;
		/* 821F1E74h case   15:*/		return 0x821F1E78;
	}
	return 0x821F1E78;
} // Block from 821F1E38h-821F1E78h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F1E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1E78);
		  /* 821F1E78h */ case    0:  		/* mfspr R12, LR */
		/* 821F1E78h case    0:*/		regs.R12 = regs.LR;
		/* 821F1E78h case    0:*/		return 0x821F1E7C;
		  /* 821F1E7Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1E7Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1E7Ch case    1:*/		return 0x821F1E80;
		  /* 821F1E80h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F1E80h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1E80h case    2:*/		return 0x821F1E84;
		  /* 821F1E84h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F1E84h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1E84h case    3:*/		return 0x821F1E88;
		  /* 821F1E88h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1E88h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1E88h case    4:*/		return 0x821F1E8C;
		  /* 821F1E8Ch */ case    5:  		/* mr R31, R4 */
		/* 821F1E8Ch case    5:*/		regs.R31 = regs.R4;
		/* 821F1E8Ch case    5:*/		return 0x821F1E90;
		  /* 821F1E90h */ case    6:  		/* mr R30, R5 */
		/* 821F1E90h case    6:*/		regs.R30 = regs.R5;
		/* 821F1E90h case    6:*/		return 0x821F1E94;
		  /* 821F1E94h */ case    7:  		/* bl -200756 */
		/* 821F1E94h case    7:*/		regs.LR = 0x821F1E98; return 0x821C0E60;
		/* 821F1E94h case    7:*/		return 0x821F1E98;
		  /* 821F1E98h */ case    8:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F1E98h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1E98h case    8:*/		return 0x821F1E9C;
		  /* 821F1E9Ch */ case    9:  		/* li R11, 1 */
		/* 821F1E9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1E9Ch case    9:*/		return 0x821F1EA0;
		  /* 821F1EA0h */ case   10:  		/* stw R31, <#[R3]> */
		/* 821F1EA0h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1EA0h case   10:*/		return 0x821F1EA4;
		  /* 821F1EA4h */ case   11:  		/* rlwimi R10, R30, 2, 16, 29 */
		/* 821F1EA4h case   11:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R10,regs.R30);
		/* 821F1EA4h case   11:*/		return 0x821F1EA8;
		  /* 821F1EA8h */ case   12:  		/* rlwimi R10, R11, 0, 30, 14 */
		/* 821F1EA8h case   12:*/		cpu::op::rlwimi<0,0,30,14>(regs,&regs.R10,regs.R11);
		/* 821F1EA8h case   12:*/		return 0x821F1EAC;
		  /* 821F1EACh */ case   13:  		/* stw R10, <#[R3 + 4]> */
		/* 821F1EACh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1EACh case   13:*/		return 0x821F1EB0;
		  /* 821F1EB0h */ case   14:  		/* addi R1, R1, 112 */
		/* 821F1EB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1EB0h case   14:*/		return 0x821F1EB4;
		  /* 821F1EB4h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1EB4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1EB4h case   15:*/		return 0x821F1EB8;
		  /* 821F1EB8h */ case   16:  		/* mtspr LR, R12 */
		/* 821F1EB8h case   16:*/		regs.LR = regs.R12;
		/* 821F1EB8h case   16:*/		return 0x821F1EBC;
		  /* 821F1EBCh */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1EBCh case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1EBCh case   17:*/		return 0x821F1EC0;
		  /* 821F1EC0h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1EC0h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1EC0h case   18:*/		return 0x821F1EC4;
		  /* 821F1EC4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 821F1EC4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1EC4h case   19:*/		return 0x821F1EC8;
	}
	return 0x821F1EC8;
} // Block from 821F1E78h-821F1EC8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F1EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1EC8);
		  /* 821F1EC8h */ case    0:  		/* mfspr R12, LR */
		/* 821F1EC8h case    0:*/		regs.R12 = regs.LR;
		/* 821F1EC8h case    0:*/		return 0x821F1ECC;
		  /* 821F1ECCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F1ECCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1ECCh case    1:*/		return 0x821F1ED0;
		  /* 821F1ED0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F1ED0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1ED0h case    2:*/		return 0x821F1ED4;
		  /* 821F1ED4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F1ED4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1ED4h case    3:*/		return 0x821F1ED8;
		  /* 821F1ED8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F1ED8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F1ED8h case    4:*/		return 0x821F1EDC;
		  /* 821F1EDCh */ case    5:  		/* mr R31, R4 */
		/* 821F1EDCh case    5:*/		regs.R31 = regs.R4;
		/* 821F1EDCh case    5:*/		return 0x821F1EE0;
		  /* 821F1EE0h */ case    6:  		/* mr R30, R5 */
		/* 821F1EE0h case    6:*/		regs.R30 = regs.R5;
		/* 821F1EE0h case    6:*/		return 0x821F1EE4;
		  /* 821F1EE4h */ case    7:  		/* bl -200836 */
		/* 821F1EE4h case    7:*/		regs.LR = 0x821F1EE8; return 0x821C0E60;
		/* 821F1EE4h case    7:*/		return 0x821F1EE8;
		  /* 821F1EE8h */ case    8:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F1EE8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1EE8h case    8:*/		return 0x821F1EEC;
		  /* 821F1EECh */ case    9:  		/* li R11, 1 */
		/* 821F1EECh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1EECh case    9:*/		return 0x821F1EF0;
		  /* 821F1EF0h */ case   10:  		/* stw R31, <#[R3]> */
		/* 821F1EF0h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1EF0h case   10:*/		return 0x821F1EF4;
		  /* 821F1EF4h */ case   11:  		/* rlwimi R10, R30, 2, 16, 29 */
		/* 821F1EF4h case   11:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R10,regs.R30);
		/* 821F1EF4h case   11:*/		return 0x821F1EF8;
		  /* 821F1EF8h */ case   12:  		/* rlwimi R10, R11, 1, 30, 14 */
		/* 821F1EF8h case   12:*/		cpu::op::rlwimi<0,1,30,14>(regs,&regs.R10,regs.R11);
		/* 821F1EF8h case   12:*/		return 0x821F1EFC;
		  /* 821F1EFCh */ case   13:  		/* stw R10, <#[R3 + 4]> */
		/* 821F1EFCh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1EFCh case   13:*/		return 0x821F1F00;
		  /* 821F1F00h */ case   14:  		/* addi R1, R1, 112 */
		/* 821F1F00h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F1F00h case   14:*/		return 0x821F1F04;
		  /* 821F1F04h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F1F04h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F1F04h case   15:*/		return 0x821F1F08;
		  /* 821F1F08h */ case   16:  		/* mtspr LR, R12 */
		/* 821F1F08h case   16:*/		regs.LR = regs.R12;
		/* 821F1F08h case   16:*/		return 0x821F1F0C;
		  /* 821F1F0Ch */ case   17:  		/* ld R30, <#[R1 - 24]> */
		/* 821F1F0Ch case   17:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F1F0Ch case   17:*/		return 0x821F1F10;
		  /* 821F1F10h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 821F1F10h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F1F10h case   18:*/		return 0x821F1F14;
		  /* 821F1F14h */ case   19:  		/* bclr 20, CR0_LT */
		/* 821F1F14h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F1F14h case   19:*/		return 0x821F1F18;
	}
	return 0x821F1F18;
} // Block from 821F1EC8h-821F1F18h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F1F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1F18);
		  /* 821F1F18h */ case    0:  		/* mfspr R12, LR */
		/* 821F1F18h case    0:*/		regs.R12 = regs.LR;
		/* 821F1F18h case    0:*/		return 0x821F1F1C;
		  /* 821F1F1Ch */ case    1:  		/* bl -1445060 */
		/* 821F1F1Ch case    1:*/		regs.LR = 0x821F1F20; return 0x82091258;
		/* 821F1F1Ch case    1:*/		return 0x821F1F20;
		  /* 821F1F20h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F1F20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F1F20h case    2:*/		return 0x821F1F24;
		  /* 821F1F24h */ case    3:  		/* mr R29, R3 */
		/* 821F1F24h case    3:*/		regs.R29 = regs.R3;
		/* 821F1F24h case    3:*/		return 0x821F1F28;
		  /* 821F1F28h */ case    4:  		/* mr R30, R4 */
		/* 821F1F28h case    4:*/		regs.R30 = regs.R4;
		/* 821F1F28h case    4:*/		return 0x821F1F2C;
		  /* 821F1F2Ch */ case    5:  		/* mr R28, R5 */
		/* 821F1F2Ch case    5:*/		regs.R28 = regs.R5;
		/* 821F1F2Ch case    5:*/		return 0x821F1F30;
		  /* 821F1F30h */ case    6:  		/* li R31, 0 */
		/* 821F1F30h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821F1F30h case    6:*/		return 0x821F1F34;
		  /* 821F1F34h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 821F1F34h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821F1F34h case    7:*/		return 0x821F1F38;
		  /* 821F1F38h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 821F1F38h case    8:*/		if ( regs.CR[6].eq ) { return 0x821F1F68;  }
		/* 821F1F38h case    8:*/		return 0x821F1F3C;
		  /* 821F1F3Ch */ case    9:  		/* mr R3, R29 */
		/* 821F1F3Ch case    9:*/		regs.R3 = regs.R29;
		/* 821F1F3Ch case    9:*/		return 0x821F1F40;
		  /* 821F1F40h */ case   10:  		/* bl -200928 */
		/* 821F1F40h case   10:*/		regs.LR = 0x821F1F44; return 0x821C0E60;
		/* 821F1F40h case   10:*/		return 0x821F1F44;
		  /* 821F1F44h */ case   11:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F1F44h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1F44h case   11:*/		return 0x821F1F48;
		  /* 821F1F48h */ case   12:  		/* li R11, 1 */
		/* 821F1F48h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1F48h case   12:*/		return 0x821F1F4C;
		  /* 821F1F4Ch */ case   13:  		/* stw R28, <#[R3]> */
		/* 821F1F4Ch case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1F4Ch case   13:*/		return 0x821F1F50;
		  /* 821F1F50h */ case   14:  		/* rlwimi R10, R31, 2, 16, 29 */
		/* 821F1F50h case   14:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R10,regs.R31);
		/* 821F1F50h case   14:*/		return 0x821F1F54;
		  /* 821F1F54h */ case   15:  		/* addi R31, R31, 1 */
		/* 821F1F54h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821F1F54h case   15:*/		return 0x821F1F58;
		  /* 821F1F58h */ case   16:  		/* rlwimi R10, R11, 0, 30, 14 */
		/* 821F1F58h case   16:*/		cpu::op::rlwimi<0,0,30,14>(regs,&regs.R10,regs.R11);
		/* 821F1F58h case   16:*/		return 0x821F1F5C;
		  /* 821F1F5Ch */ case   17:  		/* cmplw CR6, R31, R30 */
		/* 821F1F5Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 821F1F5Ch case   17:*/		return 0x821F1F60;
		  /* 821F1F60h */ case   18:  		/* stw R10, <#[R3 + 4]> */
		/* 821F1F60h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1F60h case   18:*/		return 0x821F1F64;
		  /* 821F1F64h */ case   19:  		/* bc 12, CR6_LT, -40 */
		/* 821F1F64h case   19:*/		if ( regs.CR[6].lt ) { return 0x821F1F3C;  }
		/* 821F1F64h case   19:*/		return 0x821F1F68;
	}
	return 0x821F1F68;
} // Block from 821F1F18h-821F1F68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F1F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1F68);
		  /* 821F1F68h */ case    0:  		/* addi R1, R1, 128 */
		/* 821F1F68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F1F68h case    0:*/		return 0x821F1F6C;
		  /* 821F1F6Ch */ case    1:  		/* b -1445060 */
		/* 821F1F6Ch case    1:*/		return 0x820912A8;
		/* 821F1F6Ch case    1:*/		return 0x821F1F70;
	}
	return 0x821F1F70;
} // Block from 821F1F68h-821F1F70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F1F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1F70);
		  /* 821F1F70h */ case    0:  		/* mfspr R12, LR */
		/* 821F1F70h case    0:*/		regs.R12 = regs.LR;
		/* 821F1F70h case    0:*/		return 0x821F1F74;
		  /* 821F1F74h */ case    1:  		/* bl -1445148 */
		/* 821F1F74h case    1:*/		regs.LR = 0x821F1F78; return 0x82091258;
		/* 821F1F74h case    1:*/		return 0x821F1F78;
		  /* 821F1F78h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F1F78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F1F78h case    2:*/		return 0x821F1F7C;
		  /* 821F1F7Ch */ case    3:  		/* mr R29, R3 */
		/* 821F1F7Ch case    3:*/		regs.R29 = regs.R3;
		/* 821F1F7Ch case    3:*/		return 0x821F1F80;
		  /* 821F1F80h */ case    4:  		/* mr R30, R4 */
		/* 821F1F80h case    4:*/		regs.R30 = regs.R4;
		/* 821F1F80h case    4:*/		return 0x821F1F84;
		  /* 821F1F84h */ case    5:  		/* mr R28, R5 */
		/* 821F1F84h case    5:*/		regs.R28 = regs.R5;
		/* 821F1F84h case    5:*/		return 0x821F1F88;
		  /* 821F1F88h */ case    6:  		/* li R31, 0 */
		/* 821F1F88h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821F1F88h case    6:*/		return 0x821F1F8C;
		  /* 821F1F8Ch */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 821F1F8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821F1F8Ch case    7:*/		return 0x821F1F90;
		  /* 821F1F90h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 821F1F90h case    8:*/		if ( regs.CR[6].eq ) { return 0x821F1FC0;  }
		/* 821F1F90h case    8:*/		return 0x821F1F94;
		  /* 821F1F94h */ case    9:  		/* mr R3, R29 */
		/* 821F1F94h case    9:*/		regs.R3 = regs.R29;
		/* 821F1F94h case    9:*/		return 0x821F1F98;
		  /* 821F1F98h */ case   10:  		/* bl -201016 */
		/* 821F1F98h case   10:*/		regs.LR = 0x821F1F9C; return 0x821C0E60;
		/* 821F1F98h case   10:*/		return 0x821F1F9C;
		  /* 821F1F9Ch */ case   11:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F1F9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1F9Ch case   11:*/		return 0x821F1FA0;
		  /* 821F1FA0h */ case   12:  		/* li R11, 1 */
		/* 821F1FA0h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F1FA0h case   12:*/		return 0x821F1FA4;
		  /* 821F1FA4h */ case   13:  		/* stw R28, <#[R3]> */
		/* 821F1FA4h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 821F1FA4h case   13:*/		return 0x821F1FA8;
		  /* 821F1FA8h */ case   14:  		/* rlwimi R10, R31, 2, 16, 29 */
		/* 821F1FA8h case   14:*/		cpu::op::rlwimi<0,2,16,29>(regs,&regs.R10,regs.R31);
		/* 821F1FA8h case   14:*/		return 0x821F1FAC;
		  /* 821F1FACh */ case   15:  		/* addi R31, R31, 1 */
		/* 821F1FACh case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821F1FACh case   15:*/		return 0x821F1FB0;
		  /* 821F1FB0h */ case   16:  		/* rlwimi R10, R11, 1, 30, 14 */
		/* 821F1FB0h case   16:*/		cpu::op::rlwimi<0,1,30,14>(regs,&regs.R10,regs.R11);
		/* 821F1FB0h case   16:*/		return 0x821F1FB4;
		  /* 821F1FB4h */ case   17:  		/* cmplw CR6, R31, R30 */
		/* 821F1FB4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 821F1FB4h case   17:*/		return 0x821F1FB8;
		  /* 821F1FB8h */ case   18:  		/* stw R10, <#[R3 + 4]> */
		/* 821F1FB8h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F1FB8h case   18:*/		return 0x821F1FBC;
		  /* 821F1FBCh */ case   19:  		/* bc 12, CR6_LT, -40 */
		/* 821F1FBCh case   19:*/		if ( regs.CR[6].lt ) { return 0x821F1F94;  }
		/* 821F1FBCh case   19:*/		return 0x821F1FC0;
	}
	return 0x821F1FC0;
} // Block from 821F1F70h-821F1FC0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F1FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1FC0);
		  /* 821F1FC0h */ case    0:  		/* addi R1, R1, 128 */
		/* 821F1FC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F1FC0h case    0:*/		return 0x821F1FC4;
		  /* 821F1FC4h */ case    1:  		/* b -1445148 */
		/* 821F1FC4h case    1:*/		return 0x820912A8;
		/* 821F1FC4h case    1:*/		return 0x821F1FC8;
	}
	return 0x821F1FC8;
} // Block from 821F1FC0h-821F1FC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F1FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F1FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F1FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F1FC8);
		  /* 821F1FC8h */ case    0:  		/* mfspr R12, LR */
		/* 821F1FC8h case    0:*/		regs.R12 = regs.LR;
		/* 821F1FC8h case    0:*/		return 0x821F1FCC;
		  /* 821F1FCCh */ case    1:  		/* bl -1445240 */
		/* 821F1FCCh case    1:*/		regs.LR = 0x821F1FD0; return 0x82091254;
		/* 821F1FCCh case    1:*/		return 0x821F1FD0;
		  /* 821F1FD0h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 821F1FD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 821F1FD0h case    2:*/		return 0x821F1FD4;
		  /* 821F1FD4h */ case    3:  		/* mr R31, R3 */
		/* 821F1FD4h case    3:*/		regs.R31 = regs.R3;
		/* 821F1FD4h case    3:*/		return 0x821F1FD8;
		  /* 821F1FD8h */ case    4:  		/* mr R30, R4 */
		/* 821F1FD8h case    4:*/		regs.R30 = regs.R4;
		/* 821F1FD8h case    4:*/		return 0x821F1FDC;
		  /* 821F1FDCh */ case    5:  		/* mr R29, R5 */
		/* 821F1FDCh case    5:*/		regs.R29 = regs.R5;
		/* 821F1FDCh case    5:*/		return 0x821F1FE0;
		  /* 821F1FE0h */ case    6:  		/* mr R28, R6 */
		/* 821F1FE0h case    6:*/		regs.R28 = regs.R6;
		/* 821F1FE0h case    6:*/		return 0x821F1FE4;
		  /* 821F1FE4h */ case    7:  		/* mr R27, R7 */
		/* 821F1FE4h case    7:*/		regs.R27 = regs.R7;
		/* 821F1FE4h case    7:*/		return 0x821F1FE8;
		  /* 821F1FE8h */ case    8:  		/* bl -24528 */
		/* 821F1FE8h case    8:*/		regs.LR = 0x821F1FEC; return 0x821EC018;
		/* 821F1FE8h case    8:*/		return 0x821F1FEC;
		  /* 821F1FECh */ case    9:  		/* lwz R6, <#[R3 + 24]> */
		/* 821F1FECh case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 821F1FECh case    9:*/		return 0x821F1FF0;
		  /* 821F1FF0h */ case   10:  		/* mr R9, R27 */
		/* 821F1FF0h case   10:*/		regs.R9 = regs.R27;
		/* 821F1FF0h case   10:*/		return 0x821F1FF4;
		  /* 821F1FF4h */ case   11:  		/* mr R8, R28 */
		/* 821F1FF4h case   11:*/		regs.R8 = regs.R28;
		/* 821F1FF4h case   11:*/		return 0x821F1FF8;
		  /* 821F1FF8h */ case   12:  		/* mr R7, R29 */
		/* 821F1FF8h case   12:*/		regs.R7 = regs.R29;
		/* 821F1FF8h case   12:*/		return 0x821F1FFC;
		  /* 821F1FFCh */ case   13:  		/* li R5, 0 */
		/* 821F1FFCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F1FFCh case   13:*/		return 0x821F2000;
		  /* 821F2000h */ case   14:  		/* li R4, -1 */
		/* 821F2000h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 821F2000h case   14:*/		return 0x821F2004;
		  /* 821F2004h */ case   15:  		/* mr R3, R31 */
		/* 821F2004h case   15:*/		regs.R3 = regs.R31;
		/* 821F2004h case   15:*/		return 0x821F2008;
		  /* 821F2008h */ case   16:  		/* bl -5272 */
		/* 821F2008h case   16:*/		regs.LR = 0x821F200C; return 0x821F0B70;
		/* 821F2008h case   16:*/		return 0x821F200C;
		  /* 821F200Ch */ case   17:  		/* or. R28, R3, R3 */
		/* 821F200Ch case   17:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 821F200Ch case   17:*/		return 0x821F2010;
		  /* 821F2010h */ case   18:  		/* bc 4, CR0_EQ, 44 */
		/* 821F2010h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821F203C;  }
		/* 821F2010h case   18:*/		return 0x821F2014;
		  /* 821F2014h */ case   19:  		/* mr R7, R29 */
		/* 821F2014h case   19:*/		regs.R7 = regs.R29;
		/* 821F2014h case   19:*/		return 0x821F2018;
		  /* 821F2018h */ case   20:  		/* mr R6, R30 */
		/* 821F2018h case   20:*/		regs.R6 = regs.R30;
		/* 821F2018h case   20:*/		return 0x821F201C;
		  /* 821F201Ch */ case   21:  		/* li R5, 100 */
		/* 821F201Ch case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 821F201Ch case   21:*/		return 0x821F2020;
		  /* 821F2020h */ case   22:  		/* addi R4, R1, 80 */
		/* 821F2020h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821F2020h case   22:*/		return 0x821F2024;
		  /* 821F2024h */ case   23:  		/* mr R3, R31 */
		/* 821F2024h case   23:*/		regs.R3 = regs.R31;
		/* 821F2024h case   23:*/		return 0x821F2028;
		  /* 821F2028h */ case   24:  		/* bl 192264 */
		/* 821F2028h case   24:*/		regs.LR = 0x821F202C; return 0x82220F30;
		/* 821F2028h case   24:*/		return 0x821F202C;
		  /* 821F202Ch */ case   25:  		/* addi R5, R1, 80 */
		/* 821F202Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821F202Ch case   25:*/		return 0x821F2030;
		  /* 821F2030h */ case   26:  		/* li R4, 3523 */
		/* 821F2030h case   26:*/		cpu::op::li<0>(regs,&regs.R4,0xDC3);
		/* 821F2030h case   26:*/		return 0x821F2034;
		  /* 821F2034h */ case   27:  		/* mr R3, R31 */
		/* 821F2034h case   27:*/		regs.R3 = regs.R31;
		/* 821F2034h case   27:*/		return 0x821F2038;
		  /* 821F2038h */ case   28:  		/* bl -655824 */
		/* 821F2038h case   28:*/		regs.LR = 0x821F203C; return 0x82151E68;
		/* 821F2038h case   28:*/		return 0x821F203C;
	}
	return 0x821F203C;
} // Block from 821F1FC8h-821F203Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 821F203Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F203C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F203C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F203C);
		  /* 821F203Ch */ case    0:  		/* rlwinm. R11, R28, 0, 28, 31 */
		/* 821F203Ch case    0:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R11,regs.R28);
		/* 821F203Ch case    0:*/		return 0x821F2040;
	}
	return 0x821F2040;
} // Block from 821F203Ch-821F2040h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2040h
// Function '?MoveVariableDefinitionsFromBlock_SkipOutputs@Compiler@D3DXShader@@AAAXPAVBlock@2@0PAVCNodeFunction@2@PAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2040);
		  /* 821F2040h */ case    0:  		/* bc 4, CR0_EQ, 48 */
		/* 821F2040h case    0:*/		if ( !regs.CR[0].eq ) { return 0x821F2070;  }
		/* 821F2040h case    0:*/		return 0x821F2044;
		  /* 821F2044h */ case    1:  		/* mr R7, R29 */
		/* 821F2044h case    1:*/		regs.R7 = regs.R29;
		/* 821F2044h case    1:*/		return 0x821F2048;
		  /* 821F2048h */ case    2:  		/* mr R6, R30 */
		/* 821F2048h case    2:*/		regs.R6 = regs.R30;
		/* 821F2048h case    2:*/		return 0x821F204C;
		  /* 821F204Ch */ case    3:  		/* li R5, 100 */
		/* 821F204Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 821F204Ch case    3:*/		return 0x821F2050;
		  /* 821F2050h */ case    4:  		/* addi R4, R1, 80 */
		/* 821F2050h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821F2050h case    4:*/		return 0x821F2054;
		  /* 821F2054h */ case    5:  		/* mr R3, R31 */
		/* 821F2054h case    5:*/		regs.R3 = regs.R31;
		/* 821F2054h case    5:*/		return 0x821F2058;
		  /* 821F2058h */ case    6:  		/* bl 192216 */
		/* 821F2058h case    6:*/		regs.LR = 0x821F205C; return 0x82220F30;
		/* 821F2058h case    6:*/		return 0x821F205C;
		  /* 821F205Ch */ case    7:  		/* rlwinm R6, R28, 28, 4, 31 */
		/* 821F205Ch case    7:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R6,regs.R28);
		/* 821F205Ch case    7:*/		return 0x821F2060;
		  /* 821F2060h */ case    8:  		/* addi R5, R1, 80 */
		/* 821F2060h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821F2060h case    8:*/		return 0x821F2064;
		  /* 821F2064h */ case    9:  		/* li R4, 3634 */
		/* 821F2064h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0xE32);
		/* 821F2064h case    9:*/		return 0x821F2068;
		  /* 821F2068h */ case   10:  		/* mr R3, R31 */
		/* 821F2068h case   10:*/		regs.R3 = regs.R31;
		/* 821F2068h case   10:*/		return 0x821F206C;
		  /* 821F206Ch */ case   11:  		/* bl -655876 */
		/* 821F206Ch case   11:*/		regs.LR = 0x821F2070; return 0x82151E68;
		/* 821F206Ch case   11:*/		return 0x821F2070;
	}
	return 0x821F2070;
} // Block from 821F2040h-821F2070h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F2070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2070);
		  /* 821F2070h */ case    0:  		/* mr R3, R28 */
		/* 821F2070h case    0:*/		regs.R3 = regs.R28;
		/* 821F2070h case    0:*/		return 0x821F2074;
		  /* 821F2074h */ case    1:  		/* addi R1, R1, 240 */
		/* 821F2074h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 821F2074h case    1:*/		return 0x821F2078;
		  /* 821F2078h */ case    2:  		/* b -1445332 */
		/* 821F2078h case    2:*/		return 0x820912A4;
		/* 821F2078h case    2:*/		return 0x821F207C;
		  /* 821F207Ch */ case    3:  		/* nop */
		/* 821F207Ch case    3:*/		cpu::op::nop();
		/* 821F207Ch case    3:*/		return 0x821F2080;
	}
	return 0x821F2080;
} // Block from 821F2070h-821F2080h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F2080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2080);
		  /* 821F2080h */ case    0:  		/* mfspr R12, LR */
		/* 821F2080h case    0:*/		regs.R12 = regs.LR;
		/* 821F2080h case    0:*/		return 0x821F2084;
		  /* 821F2084h */ case    1:  		/* bl -1445416 */
		/* 821F2084h case    1:*/		regs.LR = 0x821F2088; return 0x8209125C;
		/* 821F2084h case    1:*/		return 0x821F2088;
		  /* 821F2088h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821F2088h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821F2088h case    2:*/		return 0x821F208C;
		  /* 821F208Ch */ case    3:  		/* mr R31, R3 */
		/* 821F208Ch case    3:*/		regs.R31 = regs.R3;
		/* 821F208Ch case    3:*/		return 0x821F2090;
		  /* 821F2090h */ case    4:  		/* mr R11, R6 */
		/* 821F2090h case    4:*/		regs.R11 = regs.R6;
		/* 821F2090h case    4:*/		return 0x821F2094;
		  /* 821F2094h */ case    5:  		/* mr R29, R7 */
		/* 821F2094h case    5:*/		regs.R29 = regs.R7;
		/* 821F2094h case    5:*/		return 0x821F2098;
		  /* 821F2098h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 821F2098h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821F2098h case    6:*/		return 0x821F209C;
		  /* 821F209Ch */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821F209Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821F20AC;  }
		/* 821F209Ch case    7:*/		return 0x821F20A0;
		  /* 821F20A0h */ case    8:  		/* li R3, 0 */
		/* 821F20A0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821F20A0h case    8:*/		return 0x821F20A4;
		  /* 821F20A4h */ case    9:  		/* addi R1, R1, 144 */
		/* 821F20A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821F20A4h case    9:*/		return 0x821F20A8;
		  /* 821F20A8h */ case   10:  		/* b -1445372 */
		/* 821F20A8h case   10:*/		return 0x820912AC;
		/* 821F20A8h case   10:*/		return 0x821F20AC;
	}
	return 0x821F20AC;
} // Block from 821F2080h-821F20ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F20ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F20AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F20AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F20AC);
		  /* 821F20ACh */ case    0:  		/* cmplwi CR6, R5, 1 */
		/* 821F20ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 821F20ACh case    0:*/		return 0x821F20B0;
		  /* 821F20B0h */ case    1:  		/* bc 12, CR6_LT, 312 */
		/* 821F20B0h case    1:*/		if ( regs.CR[6].lt ) { return 0x821F21E8;  }
		/* 821F20B0h case    1:*/		return 0x821F20B4;
		  /* 821F20B4h */ case    2:  		/* bc 12, CR6_EQ, 220 */
		/* 821F20B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821F2190;  }
		/* 821F20B4h case    2:*/		return 0x821F20B8;
		  /* 821F20B8h */ case    3:  		/* cmplwi CR6, R5, 3 */
		/* 821F20B8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000003);
		/* 821F20B8h case    3:*/		return 0x821F20BC;
		  /* 821F20BCh */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 821F20BCh case    4:*/		if ( regs.CR[6].lt ) { return 0x821F20CC;  }
		/* 821F20BCh case    4:*/		return 0x821F20C0;
		  /* 821F20C0h */ case    5:  		/* li R4, 4801 */
		/* 821F20C0h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F20C0h case    5:*/		return 0x821F20C4;
		  /* 821F20C4h */ case    6:  		/* mr R3, R31 */
		/* 821F20C4h case    6:*/		regs.R3 = regs.R31;
		/* 821F20C4h case    6:*/		return 0x821F20C8;
		  /* 821F20C8h */ case    7:  		/* bl -655968 */
		/* 821F20C8h case    7:*/		regs.LR = 0x821F20CC; return 0x82151E68;
		/* 821F20C8h case    7:*/		return 0x821F20CC;
	}
	return 0x821F20CC;
} // Block from 821F20ACh-821F20CCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F20CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F20CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F20CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F20CC);
		  /* 821F20CCh */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821F20CCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821F20CCh case    0:*/		return 0x821F20D0;
		  /* 821F20D0h */ case    1:  		/* li R9, 4 */
		/* 821F20D0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 821F20D0h case    1:*/		return 0x821F20D4;
		  /* 821F20D4h */ case    2:  		/* li R8, 1 */
		/* 821F20D4h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F20D4h case    2:*/		return 0x821F20D8;
		  /* 821F20D8h */ case    3:  		/* addi R10, R10, 40 */
		/* 821F20D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F20D8h case    3:*/		return 0x821F20DC;
		  /* 821F20DCh */ case    4:  		/* li R7, 2 */
		/* 821F20DCh case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F20DCh case    4:*/		return 0x821F20E0;
		  /* 821F20E0h */ case    5:  		/* li R6, 1 */
		/* 821F20E0h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F20E0h case    5:*/		return 0x821F20E4;
		  /* 821F20E4h */ case    6:  		/* addi R5, R11, 320 */
		/* 821F20E4h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x140);
		/* 821F20E4h case    6:*/		return 0x821F20E8;
		  /* 821F20E8h */ case    7:  		/* li R4, 0 */
		/* 821F20E8h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F20E8h case    7:*/		return 0x821F20EC;
		  /* 821F20ECh */ case    8:  		/* mr R3, R31 */
		/* 821F20ECh case    8:*/		regs.R3 = regs.R31;
		/* 821F20ECh case    8:*/		return 0x821F20F0;
		  /* 821F20F0h */ case    9:  		/* bl -4504 */
		/* 821F20F0h case    9:*/		regs.LR = 0x821F20F4; return 0x821F0F58;
		/* 821F20F0h case    9:*/		return 0x821F20F4;
		  /* 821F20F4h */ case   10:  		/* lwz R30, <#[R3 + 24]> */
		/* 821F20F4h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000018) );
		/* 821F20F4h case   10:*/		return 0x821F20F8;
		  /* 821F20F8h */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 821F20F8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F20F8h case   11:*/		return 0x821F20FC;
		  /* 821F20FCh */ case   12:  		/* bc 12, CR6_EQ, 136 */
		/* 821F20FCh case   12:*/		if ( regs.CR[6].eq ) { return 0x821F2184;  }
		/* 821F20FCh case   12:*/		return 0x821F2100;
		  /* 821F2100h */ case   13:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F2100h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F2100h case   13:*/		return 0x821F2104;
		  /* 821F2104h */ case   14:  		/* cmpwi CR6, R11, 11 */
		/* 821F2104h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 821F2104h case   14:*/		return 0x821F2108;
		  /* 821F2108h */ case   15:  		/* bc 4, CR6_EQ, 124 */
		/* 821F2108h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F2184;  }
		/* 821F2108h case   15:*/		return 0x821F210C;
		  /* 821F210Ch */ case   16:  		/* lwa R11, <#[R29 + 12]> */
		/* 821F210Ch case   16:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F210Ch case   16:*/		return 0x821F2110;
		  /* 821F2110h */ case   17:  		/* li R5, 4 */
		/* 821F2110h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 821F2110h case   17:*/		return 0x821F2114;
		  /* 821F2114h */ case   18:  		/* std R11, <#[R1 + 80]> */
		/* 821F2114h case   18:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2114h case   18:*/		return 0x821F2118;
		  /* 821F2118h */ case   19:  		/* addi R4, R1, 96 */
		/* 821F2118h case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 821F2118h case   19:*/		return 0x821F211C;
		  /* 821F211Ch */ case   20:  		/* lwa R9, <#[R29 + 4]> */
		/* 821F211Ch case   20:*/		cpu::mem::load32a( regs, &regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 821F211Ch case   20:*/		return 0x821F2120;
		  /* 821F2120h */ case   21:  		/* lwa R10, <#[R29]> */
		/* 821F2120h case   21:*/		cpu::mem::load32a( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821F2120h case   21:*/		return 0x821F2124;
		  /* 821F2124h */ case   22:  		/* lfd FR0, <#[R1 + 80]> */
		/* 821F2124h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2124h case   22:*/		return 0x821F2128;
		  /* 821F2128h */ case   23:  		/* std R9, <#[R1 + 80]> */
		/* 821F2128h case   23:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2128h case   23:*/		return 0x821F212C;
		  /* 821F212Ch */ case   24:  		/* lfd FR12, <#[R1 + 80]> */
		/* 821F212Ch case   24:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 821F212Ch case   24:*/		return 0x821F2130;
		  /* 821F2130h */ case   25:  		/* std R10, <#[R1 + 96]> */
		/* 821F2130h case   25:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 821F2130h case   25:*/		return 0x821F2134;
		  /* 821F2134h */ case   26:  		/* lwa R8, <#[R29 + 8]> */
		/* 821F2134h case   26:*/		cpu::mem::load32a( regs, &regs.R8, (uint32)(regs.R29 + 0x00000008) );
		/* 821F2134h case   26:*/		return 0x821F2138;
		  /* 821F2138h */ case   27:  		/* fcfid FR0, FR0 */
		/* 821F2138h case   27:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 821F2138h case   27:*/		return 0x821F213C;
		  /* 821F213Ch */ case   28:  		/* lwz R10, <#[R30 + 44]> */
		/* 821F213Ch case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F213Ch case   28:*/		return 0x821F2140;
		  /* 821F2140h */ case   29:  		/* mr R11, R8 */
		/* 821F2140h case   29:*/		regs.R11 = regs.R8;
		/* 821F2140h case   29:*/		return 0x821F2144;
		  /* 821F2144h */ case   30:  		/* frsp FR0, FR0 */
		/* 821F2144h case   30:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 821F2144h case   30:*/		return 0x821F2148;
		  /* 821F2148h */ case   31:  		/* stfs FR0, <#[R1 + 108]> */
		/* 821F2148h case   31:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 821F2148h case   31:*/		return 0x821F214C;
		  /* 821F214Ch */ case   32:  		/* ori R11, R10, 2 */
		/* 821F214Ch case   32:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0x2);
		/* 821F214Ch case   32:*/		return 0x821F2150;
		  /* 821F2150h */ case   33:  		/* lfd FR13, <#[R1 + 96]> */
		/* 821F2150h case   33:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000060) );
		/* 821F2150h case   33:*/		return 0x821F2154;
		  /* 821F2154h */ case   34:  		/* std R8, <#[R1 + 96]> */
		/* 821F2154h case   34:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 821F2154h case   34:*/		return 0x821F2158;
		  /* 821F2158h */ case   35:  		/* lfd FR11, <#[R1 + 96]> */
		/* 821F2158h case   35:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000060) );
		/* 821F2158h case   35:*/		return 0x821F215C;
		  /* 821F215Ch */ case   36:  		/* fcfid FR11, FR11 */
		/* 821F215Ch case   36:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 821F215Ch case   36:*/		return 0x821F2160;
		  /* 821F2160h */ case   37:  		/* fcfid FR12, FR12 */
		/* 821F2160h case   37:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 821F2160h case   37:*/		return 0x821F2164;
		  /* 821F2164h */ case   38:  		/* fcfid FR13, FR13 */
		/* 821F2164h case   38:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821F2164h case   38:*/		return 0x821F2168;
		  /* 821F2168h */ case   39:  		/* frsp FR11, FR11 */
		/* 821F2168h case   39:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 821F2168h case   39:*/		return 0x821F216C;
		  /* 821F216Ch */ case   40:  		/* stfs FR11, <#[R1 + 104]> */
		/* 821F216Ch case   40:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R1 + 0x00000068) );
		/* 821F216Ch case   40:*/		return 0x821F2170;
		  /* 821F2170h */ case   41:  		/* frsp FR12, FR12 */
		/* 821F2170h case   41:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 821F2170h case   41:*/		return 0x821F2174;
		  /* 821F2174h */ case   42:  		/* stfs FR12, <#[R1 + 100]> */
		/* 821F2174h case   42:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000064) );
		/* 821F2174h case   42:*/		return 0x821F2178;
		  /* 821F2178h */ case   43:  		/* frsp FR13, FR13 */
		/* 821F2178h case   43:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821F2178h case   43:*/		return 0x821F217C;
		  /* 821F217Ch */ case   44:  		/* stfs FR13, <#[R1 + 96]> */
		/* 821F217Ch case   44:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000060) );
		/* 821F217Ch case   44:*/		return 0x821F2180;
		  /* 821F2180h */ case   45:  		/* b 220 */
		/* 821F2180h case   45:*/		return 0x821F225C;
		/* 821F2180h case   45:*/		return 0x821F2184;
	}
	return 0x821F2184;
} // Block from 821F20CCh-821F2184h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821F2184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2184);
		  /* 821F2184h */ case    0:  		/* li R4, 4801 */
		/* 821F2184h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F2184h case    0:*/		return 0x821F2188;
		  /* 821F2188h */ case    1:  		/* mr R3, R31 */
		/* 821F2188h case    1:*/		regs.R3 = regs.R31;
		/* 821F2188h case    1:*/		return 0x821F218C;
		  /* 821F218Ch */ case    2:  		/* bl -656164 */
		/* 821F218Ch case    2:*/		regs.LR = 0x821F2190; return 0x82151E68;
		/* 821F218Ch case    2:*/		return 0x821F2190;
	}
	return 0x821F2190;
} // Block from 821F2184h-821F2190h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F2190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2190);
		  /* 821F2190h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821F2190h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2190h case    0:*/		return 0x821F2194;
		  /* 821F2194h */ case    1:  		/* li R9, 4 */
		/* 821F2194h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 821F2194h case    1:*/		return 0x821F2198;
		  /* 821F2198h */ case    2:  		/* li R8, 1 */
		/* 821F2198h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F2198h case    2:*/		return 0x821F219C;
		  /* 821F219Ch */ case    3:  		/* addi R10, R10, 40 */
		/* 821F219Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F219Ch case    3:*/		return 0x821F21A0;
		  /* 821F21A0h */ case    4:  		/* li R7, 12 */
		/* 821F21A0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 821F21A0h case    4:*/		return 0x821F21A4;
		  /* 821F21A4h */ case    5:  		/* li R6, 1 */
		/* 821F21A4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F21A4h case    5:*/		return 0x821F21A8;
		  /* 821F21A8h */ case    6:  		/* addi R5, R11, 64 */
		/* 821F21A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x40);
		/* 821F21A8h case    6:*/		return 0x821F21AC;
		  /* 821F21ACh */ case    7:  		/* li R4, 0 */
		/* 821F21ACh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F21ACh case    7:*/		return 0x821F21B0;
		  /* 821F21B0h */ case    8:  		/* mr R3, R31 */
		/* 821F21B0h case    8:*/		regs.R3 = regs.R31;
		/* 821F21B0h case    8:*/		return 0x821F21B4;
		  /* 821F21B4h */ case    9:  		/* bl -4700 */
		/* 821F21B4h case    9:*/		regs.LR = 0x821F21B8; return 0x821F0F58;
		/* 821F21B4h case    9:*/		return 0x821F21B8;
		  /* 821F21B8h */ case   10:  		/* lwz R30, <#[R3 + 24]> */
		/* 821F21B8h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000018) );
		/* 821F21B8h case   10:*/		return 0x821F21BC;
		  /* 821F21BCh */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 821F21BCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F21BCh case   11:*/		return 0x821F21C0;
		  /* 821F21C0h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 821F21C0h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F21DC;  }
		/* 821F21C0h case   12:*/		return 0x821F21C4;
		  /* 821F21C4h */ case   13:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F21C4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F21C4h case   13:*/		return 0x821F21C8;
		  /* 821F21C8h */ case   14:  		/* cmpwi CR6, R11, 11 */
		/* 821F21C8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 821F21C8h case   14:*/		return 0x821F21CC;
		  /* 821F21CCh */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 821F21CCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F21DC;  }
		/* 821F21CCh case   15:*/		return 0x821F21D0;
		  /* 821F21D0h */ case   16:  		/* li R5, 4 */
		/* 821F21D0h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 821F21D0h case   16:*/		return 0x821F21D4;
		  /* 821F21D4h */ case   17:  		/* mr R4, R29 */
		/* 821F21D4h case   17:*/		regs.R4 = regs.R29;
		/* 821F21D4h case   17:*/		return 0x821F21D8;
		  /* 821F21D8h */ case   18:  		/* b 124 */
		/* 821F21D8h case   18:*/		return 0x821F2254;
		/* 821F21D8h case   18:*/		return 0x821F21DC;
	}
	return 0x821F21DC;
} // Block from 821F2190h-821F21DCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821F21DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F21DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F21DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F21DC);
		  /* 821F21DCh */ case    0:  		/* li R4, 4801 */
		/* 821F21DCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F21DCh case    0:*/		return 0x821F21E0;
		  /* 821F21E0h */ case    1:  		/* mr R3, R31 */
		/* 821F21E0h case    1:*/		regs.R3 = regs.R31;
		/* 821F21E0h case    1:*/		return 0x821F21E4;
		  /* 821F21E4h */ case    2:  		/* bl -656252 */
		/* 821F21E4h case    2:*/		regs.LR = 0x821F21E8; return 0x82151E68;
		/* 821F21E4h case    2:*/		return 0x821F21E8;
	}
	return 0x821F21E8;
} // Block from 821F21DCh-821F21E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F21E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F21E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F21E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F21E8);
		  /* 821F21E8h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821F21E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821F21E8h case    0:*/		return 0x821F21EC;
		  /* 821F21ECh */ case    1:  		/* li R9, 1 */
		/* 821F21ECh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821F21ECh case    1:*/		return 0x821F21F0;
		  /* 821F21F0h */ case    2:  		/* li R8, 1 */
		/* 821F21F0h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F21F0h case    2:*/		return 0x821F21F4;
		  /* 821F21F4h */ case    3:  		/* addi R10, R10, 40 */
		/* 821F21F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F21F4h case    3:*/		return 0x821F21F8;
		  /* 821F21F8h */ case    4:  		/* li R7, 0 */
		/* 821F21F8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F21F8h case    4:*/		return 0x821F21FC;
		  /* 821F21FCh */ case    5:  		/* li R6, 1 */
		/* 821F21FCh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F21FCh case    5:*/		return 0x821F2200;
		  /* 821F2200h */ case    6:  		/* addi R5, R11, 352 */
		/* 821F2200h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x160);
		/* 821F2200h case    6:*/		return 0x821F2204;
		  /* 821F2204h */ case    7:  		/* li R4, 0 */
		/* 821F2204h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F2204h case    7:*/		return 0x821F2208;
		  /* 821F2208h */ case    8:  		/* mr R3, R31 */
		/* 821F2208h case    8:*/		regs.R3 = regs.R31;
		/* 821F2208h case    8:*/		return 0x821F220C;
		  /* 821F220Ch */ case    9:  		/* bl -4788 */
		/* 821F220Ch case    9:*/		regs.LR = 0x821F2210; return 0x821F0F58;
		/* 821F220Ch case    9:*/		return 0x821F2210;
		  /* 821F2210h */ case   10:  		/* lwz R30, <#[R3 + 24]> */
		/* 821F2210h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000018) );
		/* 821F2210h case   10:*/		return 0x821F2214;
		  /* 821F2214h */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 821F2214h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F2214h case   11:*/		return 0x821F2218;
		  /* 821F2218h */ case   12:  		/* bc 12, CR6_EQ, 88 */
		/* 821F2218h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F2270;  }
		/* 821F2218h case   12:*/		return 0x821F221C;
		  /* 821F221Ch */ case   13:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F221Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F221Ch case   13:*/		return 0x821F2220;
		  /* 821F2220h */ case   14:  		/* cmpwi CR6, R11, 11 */
		/* 821F2220h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 821F2220h case   14:*/		return 0x821F2224;
		  /* 821F2224h */ case   15:  		/* bc 4, CR6_EQ, 76 */
		/* 821F2224h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F2270;  }
		/* 821F2224h case   15:*/		return 0x821F2228;
		  /* 821F2228h */ case   16:  		/* lwz R11, <#[R29]> */
		/* 821F2228h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F2228h case   16:*/		return 0x821F222C;
		  /* 821F222Ch */ case   17:  		/* cmpwi CR6, R11, 0 */
		/* 821F222Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821F222Ch case   17:*/		return 0x821F2230;
		  /* 821F2230h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 821F2230h case   18:*/		if ( regs.CR[6].eq ) { return 0x821F2240;  }
		/* 821F2230h case   18:*/		return 0x821F2234;
		  /* 821F2234h */ case   19:  		/* lis R11, -32256 */
		/* 821F2234h case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F2234h case   19:*/		return 0x821F2238;
		  /* 821F2238h */ case   20:  		/* lfs FR0, <#[R11 + 1792]> */
		/* 821F2238h case   20:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000700) );
		/* 821F2238h case   20:*/		return 0x821F223C;
		  /* 821F223Ch */ case   21:  		/* b 12 */
		/* 821F223Ch case   21:*/		return 0x821F2248;
		/* 821F223Ch case   21:*/		return 0x821F2240;
	}
	return 0x821F2240;
} // Block from 821F21E8h-821F2240h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F2240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2240);
		  /* 821F2240h */ case    0:  		/* lis R11, -32256 */
		/* 821F2240h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F2240h case    0:*/		return 0x821F2244;
		  /* 821F2244h */ case    1:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 821F2244h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 821F2244h case    1:*/		return 0x821F2248;
	}
	return 0x821F2248;
} // Block from 821F2240h-821F2248h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2248);
		  /* 821F2248h */ case    0:  		/* stfs FR0, <#[R1 + 80]> */
		/* 821F2248h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2248h case    0:*/		return 0x821F224C;
		  /* 821F224Ch */ case    1:  		/* li R5, 1 */
		/* 821F224Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F224Ch case    1:*/		return 0x821F2250;
		  /* 821F2250h */ case    2:  		/* addi R4, R1, 80 */
		/* 821F2250h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821F2250h case    2:*/		return 0x821F2254;
	}
	return 0x821F2254;
} // Block from 821F2248h-821F2254h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F2254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2254);
		  /* 821F2254h */ case    0:  		/* lwz R11, <#[R30 + 44]> */
		/* 821F2254h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F2254h case    0:*/		return 0x821F2258;
	}
	return 0x821F2258;
} // Block from 821F2254h-821F2258h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2258h
// Function '?RemoveLast@?$ArrayList@VResult@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAA?AVResult@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2258);
		  /* 821F2258h */ case    0:  		/* ori R11, R11, 2 */
		/* 821F2258h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F2258h case    0:*/		return 0x821F225C;
	}
	return 0x821F225C;
} // Block from 821F2258h-821F225Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F225Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F225C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F225C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F225C);
		  /* 821F225Ch */ case    0:  		/* stw R11, <#[R30 + 44]> */
		/* 821F225Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F225Ch case    0:*/		return 0x821F2260;
		  /* 821F2260h */ case    1:  		/* mr R3, R31 */
		/* 821F2260h case    1:*/		regs.R3 = regs.R31;
		/* 821F2260h case    1:*/		return 0x821F2264;
		  /* 821F2264h */ case    2:  		/* bl -21148 */
		/* 821F2264h case    2:*/		regs.LR = 0x821F2268; return 0x821ECFC8;
		/* 821F2264h case    2:*/		return 0x821F2268;
		  /* 821F2268h */ case    3:  		/* stw R3, <#[R30 + 52]> */
		/* 821F2268h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 821F2268h case    3:*/		return 0x821F226C;
		  /* 821F226Ch */ case    4:  		/* b -460 */
		/* 821F226Ch case    4:*/		return 0x821F20A0;
		/* 821F226Ch case    4:*/		return 0x821F2270;
	}
	return 0x821F2270;
} // Block from 821F225Ch-821F2270h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F2270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2270);
		  /* 821F2270h */ case    0:  		/* li R4, 4801 */
		/* 821F2270h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F2270h case    0:*/		return 0x821F2274;
		  /* 821F2274h */ case    1:  		/* mr R3, R31 */
		/* 821F2274h case    1:*/		regs.R3 = regs.R31;
		/* 821F2274h case    1:*/		return 0x821F2278;
		  /* 821F2278h */ case    2:  		/* bl -656400 */
		/* 821F2278h case    2:*/		regs.LR = 0x821F227C; return 0x82151E68;
		/* 821F2278h case    2:*/		return 0x821F227C;
		  /* 821F227Ch */ case    3:  		/* nop */
		/* 821F227Ch case    3:*/		cpu::op::nop();
		/* 821F227Ch case    3:*/		return 0x821F2280;
	}
	return 0x821F2280;
} // Block from 821F2270h-821F2280h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F2280h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2280);
		  /* 821F2280h */ case    0:  		/* mfspr R12, LR */
		/* 821F2280h case    0:*/		regs.R12 = regs.LR;
		/* 821F2280h case    0:*/		return 0x821F2284;
		  /* 821F2284h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F2284h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2284h case    1:*/		return 0x821F2288;
		  /* 821F2288h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F2288h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F2288h case    2:*/		return 0x821F228C;
		  /* 821F228Ch */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 821F228Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 821F228Ch case    3:*/		return 0x821F2290;
		  /* 821F2290h */ case    4:  		/* rlwinm R11, R10, 0, 30, 31 */
		/* 821F2290h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 821F2290h case    4:*/		return 0x821F2294;
		  /* 821F2294h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 821F2294h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821F2294h case    5:*/		return 0x821F2298;
		  /* 821F2298h */ case    6:  		/* bc 12, CR6_LT, 84 */
		/* 821F2298h case    6:*/		if ( regs.CR[6].lt ) { return 0x821F22EC;  }
		/* 821F2298h case    6:*/		return 0x821F229C;
		  /* 821F229Ch */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 821F229Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821F22E4;  }
		/* 821F229Ch case    7:*/		return 0x821F22A0;
		  /* 821F22A0h */ case    8:  		/* cmplwi CR6, R11, 3 */
		/* 821F22A0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 821F22A0h case    8:*/		return 0x821F22A4;
		  /* 821F22A4h */ case    9:  		/* bc 12, CR6_LT, 52 */
		/* 821F22A4h case    9:*/		if ( regs.CR[6].lt ) { return 0x821F22D8;  }
		/* 821F22A4h case    9:*/		return 0x821F22A8;
		  /* 821F22A8h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 821F22A8h case   10:*/		if ( regs.CR[6].eq ) { return 0x821F22B4;  }
		/* 821F22A8h case   10:*/		return 0x821F22AC;
		  /* 821F22ACh */ case   11:  		/* li R4, 4800 */
		/* 821F22ACh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821F22ACh case   11:*/		return 0x821F22B0;
		  /* 821F22B0h */ case   12:  		/* bl -656456 */
		/* 821F22B0h case   12:*/		regs.LR = 0x821F22B4; return 0x82151E68;
		/* 821F22B0h case   12:*/		return 0x821F22B4;
	}
	return 0x821F22B4;
} // Block from 821F2280h-821F22B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821F22B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F22B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F22B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F22B4);
		  /* 821F22B4h */ case    0:  		/* lwz R4, <#[R4]> */
		/* 821F22B4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000000) );
		/* 821F22B4h case    0:*/		return 0x821F22B8;
		  /* 821F22B8h */ case    1:  		/* rlwinm. R11, R10, 16, 31, 31 */
		/* 821F22B8h case    1:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R11,regs.R10);
		/* 821F22B8h case    1:*/		return 0x821F22BC;
		  /* 821F22BCh */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 821F22BCh case    2:*/		if ( regs.CR[0].eq ) { return 0x821F22D0;  }
		/* 821F22BCh case    2:*/		return 0x821F22C0;
		  /* 821F22C0h */ case    3:  		/* li R6, 0 */
		/* 821F22C0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F22C0h case    3:*/		return 0x821F22C4;
		  /* 821F22C4h */ case    4:  		/* ld R5, <#[R4]> */
		/* 821F22C4h case    4:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 821F22C4h case    4:*/		return 0x821F22C8;
		  /* 821F22C8h */ case    5:  		/* bl -3896 */
		/* 821F22C8h case    5:*/		regs.LR = 0x821F22CC; return 0x821F1390;
		/* 821F22C8h case    5:*/		return 0x821F22CC;
		  /* 821F22CCh */ case    6:  		/* b 160 */
		/* 821F22CCh case    6:*/		return 0x821F236C;
		/* 821F22CCh case    6:*/		return 0x821F22D0;
	}
	return 0x821F22D0;
} // Block from 821F22B4h-821F22D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F22D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F22D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F22D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F22D0);
		  /* 821F22D0h */ case    0:  		/* bl -80 */
		/* 821F22D0h case    0:*/		regs.LR = 0x821F22D4; return 0x821F2280;
		/* 821F22D0h case    0:*/		return 0x821F22D4;
		  /* 821F22D4h */ case    1:  		/* b 152 */
		/* 821F22D4h case    1:*/		return 0x821F236C;
		/* 821F22D4h case    1:*/		return 0x821F22D8;
	}
	return 0x821F22D8;
} // Block from 821F22D0h-821F22D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F22D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F22D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F22D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F22D8);
		  /* 821F22D8h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 821F22D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821F22D8h case    0:*/		return 0x821F22DC;
		  /* 821F22DCh */ case    1:  		/* lwz R3, <#[R11 + 12]> */
		/* 821F22DCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F22DCh case    1:*/		return 0x821F22E0;
		  /* 821F22E0h */ case    2:  		/* b 140 */
		/* 821F22E0h case    2:*/		return 0x821F236C;
		/* 821F22E0h case    2:*/		return 0x821F22E4;
	}
	return 0x821F22E4;
} // Block from 821F22D8h-821F22E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F22E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F22E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F22E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F22E4);
		  /* 821F22E4h */ case    0:  		/* lwz R3, <#[R4]> */
		/* 821F22E4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 821F22E4h case    0:*/		return 0x821F22E8;
		  /* 821F22E8h */ case    1:  		/* b 132 */
		/* 821F22E8h case    1:*/		return 0x821F236C;
		/* 821F22E8h case    1:*/		return 0x821F22EC;
	}
	return 0x821F22EC;
} // Block from 821F22E4h-821F22ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F22ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F22EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F22EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F22EC);
		  /* 821F22ECh */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F22ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F22ECh case    0:*/		return 0x821F22F0;
		  /* 821F22F0h */ case    1:  		/* lwz R5, <#[R3 + 564]> */
		/* 821F22F0h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000234) );
		/* 821F22F0h case    1:*/		return 0x821F22F4;
		  /* 821F22F4h */ case    2:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821F22F4h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821F22F4h case    2:*/		return 0x821F22F8;
		  /* 821F22F8h */ case    3:  		/* addic R9, R9, -1 */
		/* 821F22F8h case    3:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821F22F8h case    3:*/		return 0x821F22FC;
		  /* 821F22FCh */ case    4:  		/* subfe R9, R9, R9 */
		/* 821F22FCh case    4:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821F22FCh case    4:*/		return 0x821F2300;
		  /* 821F2300h */ case    5:  		/* and R11, R9, R11 */
		/* 821F2300h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F2300h case    5:*/		return 0x821F2304;
		  /* 821F2304h */ case    6:  		/* cmplw CR6, R5, R11 */
		/* 821F2304h case    6:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 821F2304h case    6:*/		return 0x821F2308;
		  /* 821F2308h */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 821F2308h case    7:*/		if ( regs.CR[6].eq ) { return 0x821F2350;  }
		/* 821F2308h case    7:*/		return 0x821F230C;
		  /* 821F230Ch */ case    8:  		/* rlwinm R10, R10, 15, 17, 31 */
		/* 821F230Ch case    8:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R10,regs.R10);
		/* 821F230Ch case    8:*/		return 0x821F2310;
		  /* 821F2310h */ case    9:  		/* lwz R11, <#[R3 + 12]> */
		/* 821F2310h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821F2310h case    9:*/		return 0x821F2314;
		  /* 821F2314h */ case   10:  		/* mulli R10, R10, 40 */
		/* 821F2314h case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F2314h case   10:*/		return 0x821F2318;
		  /* 821F2318h */ case   11:  		/* add R11, R10, R11 */
		/* 821F2318h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F2318h case   11:*/		return 0x821F231C;
		  /* 821F231Ch */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F231Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F231Ch case   12:*/		return 0x821F2320;
		  /* 821F2320h */ case   13:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 821F2320h case   13:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 821F2320h case   13:*/		return 0x821F2324;
		  /* 821F2324h */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 821F2324h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821F2334;  }
		/* 821F2324h case   14:*/		return 0x821F2328;
		  /* 821F2328h */ case   15:  		/* lwz R11, <#[R3 + 44]> */
		/* 821F2328h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 821F2328h case   15:*/		return 0x821F232C;
		  /* 821F232Ch */ case   16:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 821F232Ch case   16:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 821F232Ch case   16:*/		return 0x821F2330;
		  /* 821F2330h */ case   17:  		/* bc 12, CR0_EQ, 32 */
		/* 821F2330h case   17:*/		if ( regs.CR[0].eq ) { return 0x821F2350;  }
		/* 821F2330h case   17:*/		return 0x821F2334;
	}
	return 0x821F2334;
} // Block from 821F22ECh-821F2334h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F2334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2334);
		  /* 821F2334h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821F2334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821F2334h case    0:*/		return 0x821F2338;
		  /* 821F2338h */ case    1:  		/* mr R4, R3 */
		/* 821F2338h case    1:*/		regs.R4 = regs.R3;
		/* 821F2338h case    1:*/		return 0x821F233C;
		  /* 821F233Ch */ case    2:  		/* addi R3, R1, 80 */
		/* 821F233Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F233Ch case    2:*/		return 0x821F2340;
		  /* 821F2340h */ case    3:  		/* rlwinm R7, R11, 30, 18, 31 */
		/* 821F2340h case    3:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R7,regs.R11);
		/* 821F2340h case    3:*/		return 0x821F2344;
		  /* 821F2344h */ case    4:  		/* rlwinm R6, R11, 15, 17, 31 */
		/* 821F2344h case    4:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R6,regs.R11);
		/* 821F2344h case    4:*/		return 0x821F2348;
	}
	return 0x821F2348;
} // Block from 821F2334h-821F2348h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F2348h
// Function '?RemoveAll@?$ArrayList@UPendingVectorizeEntry@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2348);
		  /* 821F2348h */ case    0:  		/* bl 210688 */
		/* 821F2348h case    0:*/		regs.LR = 0x821F234C; return 0x82225A48;
		/* 821F2348h case    0:*/		return 0x821F234C;
		  /* 821F234Ch */ case    1:  		/* b 28 */
		/* 821F234Ch case    1:*/		return 0x821F2368;
		/* 821F234Ch case    1:*/		return 0x821F2350;
	}
	return 0x821F2350;
} // Block from 821F2348h-821F2350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2350);
		  /* 821F2350h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 821F2350h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821F2350h case    0:*/		return 0x821F2354;
		  /* 821F2354h */ case    1:  		/* mr R4, R3 */
		/* 821F2354h case    1:*/		regs.R4 = regs.R3;
		/* 821F2354h case    1:*/		return 0x821F2358;
		  /* 821F2358h */ case    2:  		/* addi R3, R1, 88 */
		/* 821F2358h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 821F2358h case    2:*/		return 0x821F235C;
		  /* 821F235Ch */ case    3:  		/* rlwinm R6, R11, 30, 18, 31 */
		/* 821F235Ch case    3:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R6,regs.R11);
		/* 821F235Ch case    3:*/		return 0x821F2360;
		  /* 821F2360h */ case    4:  		/* rlwinm R5, R11, 15, 17, 31 */
		/* 821F2360h case    4:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R5,regs.R11);
		/* 821F2360h case    4:*/		return 0x821F2364;
		  /* 821F2364h */ case    5:  		/* bl 233396 */
		/* 821F2364h case    5:*/		regs.LR = 0x821F2368; return 0x8222B318;
		/* 821F2364h case    5:*/		return 0x821F2368;
	}
	return 0x821F2368;
} // Block from 821F2350h-821F2368h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F2368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2368);
		  /* 821F2368h */ case    0:  		/* lwz R3, <#[R3]> */
		/* 821F2368h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2368h case    0:*/		return 0x821F236C;
	}
	return 0x821F236C;
} // Block from 821F2368h-821F236Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F236Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F236C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F236C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F236C);
		  /* 821F236Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 821F236Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F236Ch case    0:*/		return 0x821F2370;
		  /* 821F2370h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F2370h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2370h case    1:*/		return 0x821F2374;
		  /* 821F2374h */ case    2:  		/* mtspr LR, R12 */
		/* 821F2374h case    2:*/		regs.LR = regs.R12;
		/* 821F2374h case    2:*/		return 0x821F2378;
		  /* 821F2378h */ case    3:  		/* bclr 20, CR0_LT */
		/* 821F2378h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F2378h case    3:*/		return 0x821F237C;
	}
	return 0x821F237C;
} // Block from 821F236Ch-821F237Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F237Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F237C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F237C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F237C);
		  /* 821F237Ch */ case    0:  		/* nop */
		/* 821F237Ch case    0:*/		cpu::op::nop();
		/* 821F237Ch case    0:*/		return 0x821F2380;
	}
	return 0x821F2380;
} // Block from 821F237Ch-821F2380h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2380h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2380);
		  /* 821F2380h */ case    0:  		/* mfspr R12, LR */
		/* 821F2380h case    0:*/		regs.R12 = regs.LR;
		/* 821F2380h case    0:*/		return 0x821F2384;
		  /* 821F2384h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F2384h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2384h case    1:*/		return 0x821F2388;
		  /* 821F2388h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F2388h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F2388h case    2:*/		return 0x821F238C;
		  /* 821F238Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F238Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F238Ch case    3:*/		return 0x821F2390;
		  /* 821F2390h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F2390h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F2390h case    4:*/		return 0x821F2394;
		  /* 821F2394h */ case    5:  		/* lwz R10, <#[R4 + 4]> */
		/* 821F2394h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 821F2394h case    5:*/		return 0x821F2398;
		  /* 821F2398h */ case    6:  		/* mr R31, R3 */
		/* 821F2398h case    6:*/		regs.R31 = regs.R3;
		/* 821F2398h case    6:*/		return 0x821F239C;
		  /* 821F239Ch */ case    7:  		/* mr R30, R4 */
		/* 821F239Ch case    7:*/		regs.R30 = regs.R4;
		/* 821F239Ch case    7:*/		return 0x821F23A0;
		  /* 821F23A0h */ case    8:  		/* rlwinm R11, R10, 0, 30, 31 */
		/* 821F23A0h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 821F23A0h case    8:*/		return 0x821F23A4;
		  /* 821F23A4h */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 821F23A4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821F23A4h case    9:*/		return 0x821F23A8;
		  /* 821F23A8h */ case   10:  		/* bc 12, CR6_LT, 208 */
		/* 821F23A8h case   10:*/		if ( regs.CR[6].lt ) { return 0x821F2478;  }
		/* 821F23A8h case   10:*/		return 0x821F23AC;
		  /* 821F23ACh */ case   11:  		/* bc 12, CR6_EQ, 148 */
		/* 821F23ACh case   11:*/		if ( regs.CR[6].eq ) { return 0x821F2440;  }
		/* 821F23ACh case   11:*/		return 0x821F23B0;
		  /* 821F23B0h */ case   12:  		/* cmplwi CR6, R11, 3 */
		/* 821F23B0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 821F23B0h case   12:*/		return 0x821F23B4;
		  /* 821F23B4h */ case   13:  		/* bc 12, CR6_LT, 68 */
		/* 821F23B4h case   13:*/		if ( regs.CR[6].lt ) { return 0x821F23F8;  }
		/* 821F23B4h case   13:*/		return 0x821F23B8;
		  /* 821F23B8h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 821F23B8h case   14:*/		if ( regs.CR[6].eq ) { return 0x821F23C4;  }
		/* 821F23B8h case   14:*/		return 0x821F23BC;
		  /* 821F23BCh */ case   15:  		/* li R4, 4800 */
		/* 821F23BCh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821F23BCh case   15:*/		return 0x821F23C0;
		  /* 821F23C0h */ case   16:  		/* bl -656728 */
		/* 821F23C0h case   16:*/		regs.LR = 0x821F23C4; return 0x82151E68;
		/* 821F23C0h case   16:*/		return 0x821F23C4;
	}
	return 0x821F23C4;
} // Block from 821F2380h-821F23C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821F23C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F23C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F23C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F23C4);
		  /* 821F23C4h */ case    0:  		/* lwz R4, <#[R30]> */
		/* 821F23C4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 821F23C4h case    0:*/		return 0x821F23C8;
		  /* 821F23C8h */ case    1:  		/* rlwinm. R11, R10, 16, 31, 31 */
		/* 821F23C8h case    1:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R11,regs.R10);
		/* 821F23C8h case    1:*/		return 0x821F23CC;
		  /* 821F23CCh */ case    2:  		/* bc 12, CR0_EQ, 312 */
		/* 821F23CCh case    2:*/		if ( regs.CR[0].eq ) { return 0x821F2504;  }
		/* 821F23CCh case    2:*/		return 0x821F23D0;
		  /* 821F23D0h */ case    3:  		/* li R6, 0 */
		/* 821F23D0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F23D0h case    3:*/		return 0x821F23D4;
		  /* 821F23D4h */ case    4:  		/* ld R5, <#[R4]> */
		/* 821F23D4h case    4:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 821F23D4h case    4:*/		return 0x821F23D8;
		  /* 821F23D8h */ case    5:  		/* bl -4168 */
		/* 821F23D8h case    5:*/		regs.LR = 0x821F23DC; return 0x821F1390;
		/* 821F23D8h case    5:*/		return 0x821F23DC;
		  /* 821F23DCh */ case    6:  		/* mr R4, R3 */
		/* 821F23DCh case    6:*/		regs.R4 = regs.R3;
		/* 821F23DCh case    6:*/		return 0x821F23E0;
		  /* 821F23E0h */ case    7:  		/* mr R3, R31 */
		/* 821F23E0h case    7:*/		regs.R3 = regs.R31;
		/* 821F23E0h case    7:*/		return 0x821F23E4;
		  /* 821F23E4h */ case    8:  		/* bl -500708 */
		/* 821F23E4h case    8:*/		regs.LR = 0x821F23E8; return 0x82178000;
		/* 821F23E4h case    8:*/		return 0x821F23E8;
	}
	return 0x821F23E8;
} // Block from 821F23C4h-821F23E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F23E8h
// Function '?GetPrev@?$ArrayListEnumerator@VResult@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAPAVResult@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F23E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F23E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F23E8);
		  /* 821F23E8h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 821F23E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F23E8h case    0:*/		return 0x821F23EC;
		  /* 821F23ECh */ case    1:  		/* li R11, 1 */
		/* 821F23ECh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F23ECh case    1:*/		return 0x821F23F0;
		  /* 821F23F0h */ case    2:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 821F23F0h case    2:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 821F23F0h case    2:*/		return 0x821F23F4;
		  /* 821F23F4h */ case    3:  		/* b 124 */
		/* 821F23F4h case    3:*/		return 0x821F2470;
		/* 821F23F4h case    3:*/		return 0x821F23F8;
	}
	return 0x821F23F8;
} // Block from 821F23E8h-821F23F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F23F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F23F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F23F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F23F8);
		  /* 821F23F8h */ case    0:  		/* lwz R4, <#[R30]> */
		/* 821F23F8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 821F23F8h case    0:*/		return 0x821F23FC;
		  /* 821F23FCh */ case    1:  		/* lwz R5, <#[R4 + 12]> */
		/* 821F23FCh case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F23FCh case    1:*/		return 0x821F2400;
		  /* 821F2400h */ case    2:  		/* bl -529168 */
		/* 821F2400h case    2:*/		regs.LR = 0x821F2404; return 0x821710F0;
		/* 821F2400h case    2:*/		return 0x821F2404;
		  /* 821F2404h */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F2404h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F2404h case    3:*/		return 0x821F2408;
		  /* 821F2408h */ case    4:  		/* rlwinm. R10, R11, 0, 0, 14 */
		/* 821F2408h case    4:*/		cpu::op::rlwinm<1,0,0,14>(regs,&regs.R10,regs.R11);
		/* 821F2408h case    4:*/		return 0x821F240C;
		  /* 821F240Ch */ case    5:  		/* lwz R11, <#[R3]> */
		/* 821F240Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F240Ch case    5:*/		return 0x821F2410;
		  /* 821F2410h */ case    6:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 821F2410h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 821F2410h case    6:*/		return 0x821F2414;
		  /* 821F2414h */ case    7:  		/* bc 4, CR0_EQ, 244 */
		/* 821F2414h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821F2508;  }
		/* 821F2414h case    7:*/		return 0x821F2418;
		  /* 821F2418h */ case    8:  		/* li R9, 1 */
		/* 821F2418h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821F2418h case    8:*/		return 0x821F241C;
		  /* 821F241Ch */ case    9:  		/* rlwimi R11, R9, 25, 4, 6 */
		/* 821F241Ch case    9:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R9);
		/* 821F241Ch case    9:*/		return 0x821F2420;
		  /* 821F2420h */ case   10:  		/* stw R11, <#[R3]> */
		/* 821F2420h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2420h case   10:*/		return 0x821F2424;
		  /* 821F2424h */ case   11:  		/* lwz R9, <#[R30 + 4]> */
		/* 821F2424h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 821F2424h case   11:*/		return 0x821F2428;
		  /* 821F2428h */ case   12:  		/* rlwinm R9, R9, 31, 17, 30 */
		/* 821F2428h case   12:*/		cpu::op::rlwinm<0,31,17,30>(regs,&regs.R9,regs.R9);
		/* 821F2428h case   12:*/		return 0x821F242C;
		  /* 821F242Ch */ case   13:  		/* srw R10, R10, R9 */
		/* 821F242Ch case   13:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821F242Ch case   13:*/		return 0x821F2430;
		  /* 821F2430h */ case   14:  		/* rlwimi R11, R10, 5, 25, 26 */
		/* 821F2430h case   14:*/		cpu::op::rlwimi<0,5,25,26>(regs,&regs.R11,regs.R10);
		/* 821F2430h case   14:*/		return 0x821F2434;
		  /* 821F2434h */ case   15:  		/* rlwinm R11, R11, 0, 25, 18 */
		/* 821F2434h case   15:*/		cpu::op::rlwinm<0,0,25,18>(regs,&regs.R11,regs.R11);
		/* 821F2434h case   15:*/		return 0x821F2438;
		  /* 821F2438h */ case   16:  		/* stw R11, <#[R3]> */
		/* 821F2438h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2438h case   16:*/		return 0x821F243C;
		  /* 821F243Ch */ case   17:  		/* b 204 */
		/* 821F243Ch case   17:*/		return 0x821F2508;
		/* 821F243Ch case   17:*/		return 0x821F2440;
	}
	return 0x821F2440;
} // Block from 821F23F8h-821F2440h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F2440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2440);
		  /* 821F2440h */ case    0:  		/* lwz R4, <#[R30]> */
		/* 821F2440h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 821F2440h case    0:*/		return 0x821F2444;
		  /* 821F2444h */ case    1:  		/* bl -500804 */
		/* 821F2444h case    1:*/		regs.LR = 0x821F2448; return 0x82178000;
		/* 821F2444h case    1:*/		return 0x821F2448;
	}
	return 0x821F2448;
} // Block from 821F2440h-821F2448h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2448h
// Function '?SkipBackward@?$ArrayListEnumerator@VResult@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2448);
		  /* 821F2448h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F2448h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F2448h case    0:*/		return 0x821F244C;
		  /* 821F244Ch */ case    1:  		/* rlwinm. R11, R11, 0, 0, 14 */
		/* 821F244Ch case    1:*/		cpu::op::rlwinm<1,0,0,14>(regs,&regs.R11,regs.R11);
		/* 821F244Ch case    1:*/		return 0x821F2450;
		  /* 821F2450h */ case    2:  		/* bc 4, CR0_EQ, 184 */
		/* 821F2450h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821F2508;  }
		/* 821F2450h case    2:*/		return 0x821F2454;
		  /* 821F2454h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821F2454h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2454h case    3:*/		return 0x821F2458;
		  /* 821F2458h */ case    4:  		/* li R10, 1 */
		/* 821F2458h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821F2458h case    4:*/		return 0x821F245C;
		  /* 821F245Ch */ case    5:  		/* rlwimi R11, R10, 25, 4, 6 */
		/* 821F245Ch case    5:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R10);
		/* 821F245Ch case    5:*/		return 0x821F2460;
		  /* 821F2460h */ case    6:  		/* mr R10, R11 */
		/* 821F2460h case    6:*/		regs.R10 = regs.R11;
		/* 821F2460h case    6:*/		return 0x821F2464;
		  /* 821F2464h */ case    7:  		/* stw R11, <#[R3]> */
		/* 821F2464h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2464h case    7:*/		return 0x821F2468;
		  /* 821F2468h */ case    8:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F2468h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F2468h case    8:*/		return 0x821F246C;
		  /* 821F246Ch */ case    9:  		/* rlwimi R10, R11, 3, 19, 26 */
		/* 821F246Ch case    9:*/		cpu::op::rlwimi<0,3,19,26>(regs,&regs.R10,regs.R11);
		/* 821F246Ch case    9:*/		return 0x821F2470;
	}
	return 0x821F2470;
} // Block from 821F2448h-821F2470h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F2470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2470);
		  /* 821F2470h */ case    0:  		/* stw R10, <#[R3]> */
		/* 821F2470h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2470h case    0:*/		return 0x821F2474;
		  /* 821F2474h */ case    1:  		/* b 148 */
		/* 821F2474h case    1:*/		return 0x821F2508;
		/* 821F2474h case    1:*/		return 0x821F2478;
	}
	return 0x821F2478;
} // Block from 821F2470h-821F2478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2478);
		  /* 821F2478h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 821F2478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2478h case    0:*/		return 0x821F247C;
		  /* 821F247Ch */ case    1:  		/* lwz R5, <#[R31 + 564]> */
		/* 821F247Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000234) );
		/* 821F247Ch case    1:*/		return 0x821F2480;
		  /* 821F2480h */ case    2:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821F2480h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821F2480h case    2:*/		return 0x821F2484;
		  /* 821F2484h */ case    3:  		/* addic R9, R9, -1 */
		/* 821F2484h case    3:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821F2484h case    3:*/		return 0x821F2488;
		  /* 821F2488h */ case    4:  		/* subfe R9, R9, R9 */
		/* 821F2488h case    4:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821F2488h case    4:*/		return 0x821F248C;
		  /* 821F248Ch */ case    5:  		/* and R11, R9, R11 */
		/* 821F248Ch case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F248Ch case    5:*/		return 0x821F2490;
		  /* 821F2490h */ case    6:  		/* cmplw CR6, R5, R11 */
		/* 821F2490h case    6:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 821F2490h case    6:*/		return 0x821F2494;
		  /* 821F2494h */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 821F2494h case    7:*/		if ( regs.CR[6].eq ) { return 0x821F24DC;  }
		/* 821F2494h case    7:*/		return 0x821F2498;
		  /* 821F2498h */ case    8:  		/* rlwinm R10, R10, 15, 17, 31 */
		/* 821F2498h case    8:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R10,regs.R10);
		/* 821F2498h case    8:*/		return 0x821F249C;
		  /* 821F249Ch */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 821F249Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821F249Ch case    9:*/		return 0x821F24A0;
		  /* 821F24A0h */ case   10:  		/* mulli R10, R10, 40 */
		/* 821F24A0h case   10:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F24A0h case   10:*/		return 0x821F24A4;
		  /* 821F24A4h */ case   11:  		/* add R11, R10, R11 */
		/* 821F24A4h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F24A4h case   11:*/		return 0x821F24A8;
		  /* 821F24A8h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F24A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F24A8h case   12:*/		return 0x821F24AC;
		  /* 821F24ACh */ case   13:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 821F24ACh case   13:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 821F24ACh case   13:*/		return 0x821F24B0;
		  /* 821F24B0h */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 821F24B0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821F24C0;  }
		/* 821F24B0h case   14:*/		return 0x821F24B4;
		  /* 821F24B4h */ case   15:  		/* lwz R11, <#[R31 + 44]> */
		/* 821F24B4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F24B4h case   15:*/		return 0x821F24B8;
	}
	return 0x821F24B8;
} // Block from 821F2478h-821F24B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F24B8h
// Function '?PeekPrev@?$ArrayListEnumerator@UParseStackEntry@ParseStack@D3DXShader@@$1?AllocInContext@CompilerHeap@3@SAPAXPAXK@Z$1?FreeInContext@53@SAX00K@Z@D3DXShader@@QAAPAUParseStackEntry@ParseStack@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F24B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F24B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F24B8);
		  /* 821F24B8h */ case    0:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 821F24B8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 821F24B8h case    0:*/		return 0x821F24BC;
		  /* 821F24BCh */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821F24BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821F24DC;  }
		/* 821F24BCh case    1:*/		return 0x821F24C0;
	}
	return 0x821F24C0;
} // Block from 821F24B8h-821F24C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F24C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F24C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F24C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F24C0);
		  /* 821F24C0h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F24C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F24C0h case    0:*/		return 0x821F24C4;
		  /* 821F24C4h */ case    1:  		/* mr R4, R31 */
		/* 821F24C4h case    1:*/		regs.R4 = regs.R31;
		/* 821F24C4h case    1:*/		return 0x821F24C8;
		  /* 821F24C8h */ case    2:  		/* addi R3, R1, 88 */
		/* 821F24C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 821F24C8h case    2:*/		return 0x821F24CC;
		  /* 821F24CCh */ case    3:  		/* rlwinm R7, R11, 30, 18, 31 */
		/* 821F24CCh case    3:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R7,regs.R11);
		/* 821F24CCh case    3:*/		return 0x821F24D0;
		  /* 821F24D0h */ case    4:  		/* rlwinm R6, R11, 15, 17, 31 */
		/* 821F24D0h case    4:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R6,regs.R11);
		/* 821F24D0h case    4:*/		return 0x821F24D4;
		  /* 821F24D4h */ case    5:  		/* bl 210292 */
		/* 821F24D4h case    5:*/		regs.LR = 0x821F24D8; return 0x82225A48;
		/* 821F24D4h case    5:*/		return 0x821F24D8;
		  /* 821F24D8h */ case    6:  		/* b 28 */
		/* 821F24D8h case    6:*/		return 0x821F24F4;
		/* 821F24D8h case    6:*/		return 0x821F24DC;
	}
	return 0x821F24DC;
} // Block from 821F24C0h-821F24DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F24DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F24DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F24DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F24DC);
		  /* 821F24DCh */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F24DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F24DCh case    0:*/		return 0x821F24E0;
		  /* 821F24E0h */ case    1:  		/* mr R4, R31 */
		/* 821F24E0h case    1:*/		regs.R4 = regs.R31;
		/* 821F24E0h case    1:*/		return 0x821F24E4;
		  /* 821F24E4h */ case    2:  		/* addi R3, R1, 96 */
		/* 821F24E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821F24E4h case    2:*/		return 0x821F24E8;
		  /* 821F24E8h */ case    3:  		/* rlwinm R6, R11, 30, 18, 31 */
		/* 821F24E8h case    3:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R6,regs.R11);
		/* 821F24E8h case    3:*/		return 0x821F24EC;
		  /* 821F24ECh */ case    4:  		/* rlwinm R5, R11, 15, 17, 31 */
		/* 821F24ECh case    4:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R5,regs.R11);
		/* 821F24ECh case    4:*/		return 0x821F24F0;
		  /* 821F24F0h */ case    5:  		/* bl 233000 */
		/* 821F24F0h case    5:*/		regs.LR = 0x821F24F4; return 0x8222B318;
		/* 821F24F0h case    5:*/		return 0x821F24F4;
	}
	return 0x821F24F4;
} // Block from 821F24DCh-821F24F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F24F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F24F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F24F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F24F4);
		  /* 821F24F4h */ case    0:  		/* ld R11, <#[R3]> */
		/* 821F24F4h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F24F4h case    0:*/		return 0x821F24F8;
		  /* 821F24F8h */ case    1:  		/* addi R4, R1, 80 */
		/* 821F24F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821F24F8h case    1:*/		return 0x821F24FC;
		  /* 821F24FCh */ case    2:  		/* mr R3, R31 */
		/* 821F24FCh case    2:*/		regs.R3 = regs.R31;
		/* 821F24FCh case    2:*/		return 0x821F2500;
		  /* 821F2500h */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 821F2500h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2500h case    3:*/		return 0x821F2504;
	}
	return 0x821F2504;
} // Block from 821F24F4h-821F2504h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F2504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2504);
		  /* 821F2504h */ case    0:  		/* bl -388 */
		/* 821F2504h case    0:*/		regs.LR = 0x821F2508; return 0x821F2380;
		/* 821F2504h case    0:*/		return 0x821F2508;
	}
	return 0x821F2508;
} // Block from 821F2504h-821F2508h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2508);
		  /* 821F2508h */ case    0:  		/* addi R1, R1, 128 */
		/* 821F2508h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F2508h case    0:*/		return 0x821F250C;
		  /* 821F250Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F250Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F250Ch case    1:*/		return 0x821F2510;
	}
	return 0x821F2510;
} // Block from 821F2508h-821F2510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2510h
// Function '?RemoveAll@?$ArrayList@UAttributeStateStackEntry@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2510);
		  /* 821F2510h */ case    0:  		/* mtspr LR, R12 */
		/* 821F2510h case    0:*/		regs.LR = regs.R12;
		/* 821F2510h case    0:*/		return 0x821F2514;
		  /* 821F2514h */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 821F2514h case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F2514h case    1:*/		return 0x821F2518;
		  /* 821F2518h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 821F2518h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2518h case    2:*/		return 0x821F251C;
		  /* 821F251Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 821F251Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F251Ch case    3:*/		return 0x821F2520;
	}
	return 0x821F2520;
} // Block from 821F2510h-821F2520h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F2520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2520);
		  /* 821F2520h */ case    0:  		/* mfspr R12, LR */
		/* 821F2520h case    0:*/		regs.R12 = regs.LR;
		/* 821F2520h case    0:*/		return 0x821F2524;
		  /* 821F2524h */ case    1:  		/* bl -1446640 */
		/* 821F2524h case    1:*/		regs.LR = 0x821F2528; return 0x82091234;
		/* 821F2524h case    1:*/		return 0x821F2528;
		  /* 821F2528h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821F2528h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821F2528h case    2:*/		return 0x821F252C;
		  /* 821F252Ch */ case    3:  		/* lwz R22, <#[R4 + 4]> */
		/* 821F252Ch case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R4 + 0x00000004) );
		/* 821F252Ch case    3:*/		return 0x821F2530;
		  /* 821F2530h */ case    4:  		/* mr R31, R3 */
		/* 821F2530h case    4:*/		regs.R31 = regs.R3;
		/* 821F2530h case    4:*/		return 0x821F2534;
		  /* 821F2534h */ case    5:  		/* lwz R21, <#[R4 + 8]> */
		/* 821F2534h case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R4 + 0x00000008) );
		/* 821F2534h case    5:*/		return 0x821F2538;
		  /* 821F2538h */ case    6:  		/* mr R26, R4 */
		/* 821F2538h case    6:*/		regs.R26 = regs.R4;
		/* 821F2538h case    6:*/		return 0x821F253C;
		  /* 821F253Ch */ case    7:  		/* mr R29, R5 */
		/* 821F253Ch case    7:*/		regs.R29 = regs.R5;
		/* 821F253Ch case    7:*/		return 0x821F2540;
		  /* 821F2540h */ case    8:  		/* mr R20, R6 */
		/* 821F2540h case    8:*/		regs.R20 = regs.R6;
		/* 821F2540h case    8:*/		return 0x821F2544;
		  /* 821F2544h */ case    9:  		/* mr R23, R7 */
		/* 821F2544h case    9:*/		regs.R23 = regs.R7;
		/* 821F2544h case    9:*/		return 0x821F2548;
		  /* 821F2548h */ case   10:  		/* li R30, 0 */
		/* 821F2548h case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821F2548h case   10:*/		return 0x821F254C;
		  /* 821F254Ch */ case   11:  		/* li R24, 0 */
		/* 821F254Ch case   11:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821F254Ch case   11:*/		return 0x821F2550;
		  /* 821F2550h */ case   12:  		/* li R28, 0 */
		/* 821F2550h case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821F2550h case   12:*/		return 0x821F2554;
		  /* 821F2554h */ case   13:  		/* cmplwi CR6, R5, 0 */
		/* 821F2554h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821F2554h case   13:*/		return 0x821F2558;
		  /* 821F2558h */ case   14:  		/* bc 12, CR6_EQ, 188 */
		/* 821F2558h case   14:*/		if ( regs.CR[6].eq ) { return 0x821F2614;  }
		/* 821F2558h case   14:*/		return 0x821F255C;
		  /* 821F255Ch */ case   15:  		/* li R25, 0 */
		/* 821F255Ch case   15:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821F255Ch case   15:*/		return 0x821F2560;
		  /* 821F2560h */ case   16:  		/* mr R3, R26 */
		/* 821F2560h case   16:*/		regs.R3 = regs.R26;
		/* 821F2560h case   16:*/		return 0x821F2564;
		  /* 821F2564h */ case   17:  		/* bl -202500 */
		/* 821F2564h case   17:*/		regs.LR = 0x821F2568; return 0x821C0E60;
		/* 821F2564h case   17:*/		return 0x821F2568;
		  /* 821F2568h */ case   18:  		/* mr R27, R3 */
		/* 821F2568h case   18:*/		regs.R27 = regs.R3;
		/* 821F2568h case   18:*/		return 0x821F256C;
		  /* 821F256Ch */ case   19:  		/* cmplwi CR6, R30, 0 */
		/* 821F256Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F256Ch case   19:*/		return 0x821F2570;
		  /* 821F2570h */ case   20:  		/* bc 12, CR6_EQ, 112 */
		/* 821F2570h case   20:*/		if ( regs.CR[6].eq ) { return 0x821F25E0;  }
		/* 821F2570h case   20:*/		return 0x821F2574;
		  /* 821F2574h */ case   21:  		/* mr R4, R30 */
		/* 821F2574h case   21:*/		regs.R4 = regs.R30;
		/* 821F2574h case   21:*/		return 0x821F2578;
		  /* 821F2578h */ case   22:  		/* mr R3, R31 */
		/* 821F2578h case   22:*/		regs.R3 = regs.R31;
		/* 821F2578h case   22:*/		return 0x821F257C;
		  /* 821F257Ch */ case   23:  		/* bl -764 */
		/* 821F257Ch case   23:*/		regs.LR = 0x821F2580; return 0x821F2280;
		/* 821F257Ch case   23:*/		return 0x821F2580;
		  /* 821F2580h */ case   24:  		/* mr R19, R3 */
		/* 821F2580h case   24:*/		regs.R19 = regs.R3;
		/* 821F2580h case   24:*/		return 0x821F2584;
		  /* 821F2584h */ case   25:  		/* mr R4, R27 */
		/* 821F2584h case   25:*/		regs.R4 = regs.R27;
		/* 821F2584h case   25:*/		return 0x821F2588;
		  /* 821F2588h */ case   26:  		/* mr R3, R31 */
		/* 821F2588h case   26:*/		regs.R3 = regs.R31;
		/* 821F2588h case   26:*/		return 0x821F258C;
		  /* 821F258Ch */ case   27:  		/* bl -780 */
		/* 821F258Ch case   27:*/		regs.LR = 0x821F2590; return 0x821F2280;
		/* 821F258Ch case   27:*/		return 0x821F2590;
		  /* 821F2590h */ case   28:  		/* cmplw CR6, R19, R3 */
		/* 821F2590h case   28:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R3);
		/* 821F2590h case   28:*/		return 0x821F2594;
		  /* 821F2594h */ case   29:  		/* bc 4, CR6_EQ, 128 */
		/* 821F2594h case   29:*/		if ( !regs.CR[6].eq ) { return 0x821F2614;  }
		/* 821F2594h case   29:*/		return 0x821F2598;
		  /* 821F2598h */ case   30:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F2598h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F2598h case   30:*/		return 0x821F259C;
		  /* 821F259Ch */ case   31:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 821F259Ch case   31:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821F259Ch case   31:*/		return 0x821F25A0;
		  /* 821F25A0h */ case   32:  		/* cmplwi CR6, R11, 2 */
		/* 821F25A0h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821F25A0h case   32:*/		return 0x821F25A4;
		  /* 821F25A4h */ case   33:  		/* bc 12, CR6_LT, 16 */
		/* 821F25A4h case   33:*/		if ( regs.CR[6].lt ) { return 0x821F25B4;  }
		/* 821F25A4h case   33:*/		return 0x821F25A8;
		  /* 821F25A8h */ case   34:  		/* bc 12, CR6_EQ, 288 */
		/* 821F25A8h case   34:*/		if ( regs.CR[6].eq ) { return 0x821F26C8;  }
		/* 821F25A8h case   34:*/		return 0x821F25AC;
		  /* 821F25ACh */ case   35:  		/* cmplwi CR6, R11, 4 */
		/* 821F25ACh case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821F25ACh case   35:*/		return 0x821F25B0;
	}
	return 0x821F25B0;
} // Block from 821F2520h-821F25B0h (36 instructions)

//////////////////////////////////////////////////////
// Block at 821F25B0h
// Function '?GetPrev@?$ArrayListEnumerator@ULexicalScope@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAPAULexicalScope@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F25B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F25B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F25B0);
		  /* 821F25B0h */ case    0:  		/* bc 4, CR6_LT, 312 */
		/* 821F25B0h case    0:*/		if ( !regs.CR[6].lt ) { return 0x821F26E8;  }
		/* 821F25B0h case    0:*/		return 0x821F25B4;
	}
	return 0x821F25B4;
} // Block from 821F25B0h-821F25B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F25B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F25B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F25B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F25B4);
		  /* 821F25B4h */ case    0:  		/* li R10, 0 */
		/* 821F25B4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821F25B4h case    0:*/		return 0x821F25B8;
		  /* 821F25B8h */ case    1:  		/* lwz R11, <#[R27 + 4]> */
		/* 821F25B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821F25B8h case    1:*/		return 0x821F25BC;
		  /* 821F25BCh */ case    2:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 821F25BCh case    2:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821F25BCh case    2:*/		return 0x821F25C0;
		  /* 821F25C0h */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 821F25C0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821F25C0h case    3:*/		return 0x821F25C4;
		  /* 821F25C4h */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 821F25C4h case    4:*/		if ( regs.CR[6].lt ) { return 0x821F25D4;  }
		/* 821F25C4h case    4:*/		return 0x821F25C8;
		  /* 821F25C8h */ case    5:  		/* bc 12, CR6_EQ, 272 */
		/* 821F25C8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821F26D8;  }
		/* 821F25C8h case    5:*/		return 0x821F25CC;
		  /* 821F25CCh */ case    6:  		/* cmplwi CR6, R11, 4 */
		/* 821F25CCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821F25CCh case    6:*/		return 0x821F25D0;
		  /* 821F25D0h */ case    7:  		/* bc 4, CR6_LT, 292 */
		/* 821F25D0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x821F26F4;  }
		/* 821F25D0h case    7:*/		return 0x821F25D4;
	}
	return 0x821F25D4;
} // Block from 821F25B4h-821F25D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F25D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F25D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F25D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F25D4);
		  /* 821F25D4h */ case    0:  		/* li R11, 0 */
		/* 821F25D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F25D4h case    0:*/		return 0x821F25D8;
		  /* 821F25D8h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821F25D8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F25D8h case    1:*/		return 0x821F25DC;
		  /* 821F25DCh */ case    2:  		/* bc 4, CR6_EQ, 56 */
		/* 821F25DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F2614;  }
		/* 821F25DCh case    2:*/		return 0x821F25E0;
	}
	return 0x821F25E0;
} // Block from 821F25D4h-821F25E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F25E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F25E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F25E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F25E0);
		  /* 821F25E0h */ case    0:  		/* mr R4, R27 */
		/* 821F25E0h case    0:*/		regs.R4 = regs.R27;
		/* 821F25E0h case    0:*/		return 0x821F25E4;
		  /* 821F25E4h */ case    1:  		/* mr R3, R31 */
		/* 821F25E4h case    1:*/		regs.R3 = regs.R31;
		/* 821F25E4h case    1:*/		return 0x821F25E8;
		  /* 821F25E8h */ case    2:  		/* bl -19200 */
		/* 821F25E8h case    2:*/		regs.LR = 0x821F25EC; return 0x821EDAE8;
		/* 821F25E8h case    2:*/		return 0x821F25EC;
		  /* 821F25ECh */ case    3:  		/* li R11, 3 */
		/* 821F25ECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 821F25ECh case    3:*/		return 0x821F25F0;
		  /* 821F25F0h */ case    4:  		/* slw R10, R3, R25 */
		/* 821F25F0h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R3,regs.R25);
		/* 821F25F0h case    4:*/		return 0x821F25F4;
		  /* 821F25F4h */ case    5:  		/* slw R11, R11, R25 */
		/* 821F25F4h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 821F25F4h case    5:*/		return 0x821F25F8;
		  /* 821F25F8h */ case    6:  		/* andc R11, R24, R11 */
		/* 821F25F8h case    6:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 821F25F8h case    6:*/		return 0x821F25FC;
		  /* 821F25FCh */ case    7:  		/* addi R28, R28, 1 */
		/* 821F25FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821F25FCh case    7:*/		return 0x821F2600;
		  /* 821F2600h */ case    8:  		/* or R24, R10, R11 */
		/* 821F2600h case    8:*/		cpu::op::or<0>(regs,&regs.R24,regs.R10,regs.R11);
		/* 821F2600h case    8:*/		return 0x821F2604;
		  /* 821F2604h */ case    9:  		/* mr R30, R27 */
		/* 821F2604h case    9:*/		regs.R30 = regs.R27;
		/* 821F2604h case    9:*/		return 0x821F2608;
		  /* 821F2608h */ case   10:  		/* addi R25, R25, 2 */
		/* 821F2608h case   10:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x2);
		/* 821F2608h case   10:*/		return 0x821F260C;
		  /* 821F260Ch */ case   11:  		/* cmplw CR6, R28, R29 */
		/* 821F260Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 821F260Ch case   11:*/		return 0x821F2610;
	}
	return 0x821F2610;
} // Block from 821F25E0h-821F2610h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F2610h
// Function '?GetSpaceWorker@?$ArrayList@UContainerState@ComponentTypeEnumerator@D3DXShader@@$1?AllocInContext@CompilerHeap@3@SAPAXPAXK@Z$1?FreeInContext@53@SAX00K@Z@D3DXShader@@AAAPAUArrayListEntry@12@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2610);
		  /* 821F2610h */ case    0:  		/* bc 12, CR6_LT, -176 */
		/* 821F2610h case    0:*/		if ( regs.CR[6].lt ) { return 0x821F2560;  }
		/* 821F2610h case    0:*/		return 0x821F2614;
	}
	return 0x821F2614;
} // Block from 821F2610h-821F2614h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2614);
		  /* 821F2614h */ case    0:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 821F2614h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 821F2614h case    0:*/		return 0x821F2618;
		  /* 821F2618h */ case    1:  		/* bc 12, CR0_EQ, 232 */
		/* 821F2618h case    1:*/		if ( regs.CR[0].eq ) { return 0x821F2700;  }
		/* 821F2618h case    1:*/		return 0x821F261C;
		  /* 821F261Ch */ case    2:  		/* cmplw CR6, R28, R29 */
		/* 821F261Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 821F261Ch case    2:*/		return 0x821F2620;
		  /* 821F2620h */ case    3:  		/* bc 4, CR6_LT, 224 */
		/* 821F2620h case    3:*/		if ( !regs.CR[6].lt ) { return 0x821F2700;  }
		/* 821F2620h case    3:*/		return 0x821F2624;
		  /* 821F2624h */ case    4:  		/* stw R22, <#[R26 + 4]> */
		/* 821F2624h case    4:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R26 + 0x00000004) );
		/* 821F2624h case    4:*/		return 0x821F2628;
		  /* 821F2628h */ case    5:  		/* mr R6, R29 */
		/* 821F2628h case    5:*/		regs.R6 = regs.R29;
		/* 821F2628h case    5:*/		return 0x821F262C;
		  /* 821F262Ch */ case    6:  		/* stw R21, <#[R26 + 8]> */
		/* 821F262Ch case    6:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R26 + 0x00000008) );
		/* 821F262Ch case    6:*/		return 0x821F2630;
		  /* 821F2630h */ case    7:  		/* li R5, 0 */
		/* 821F2630h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F2630h case    7:*/		return 0x821F2634;
		  /* 821F2634h */ case    8:  		/* mr R3, R31 */
		/* 821F2634h case    8:*/		regs.R3 = regs.R31;
		/* 821F2634h case    8:*/		return 0x821F2638;
		  /* 821F2638h */ case    9:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F2638h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F2638h case    9:*/		return 0x821F263C;
		  /* 821F263Ch */ case   10:  		/* bl 206020 */
		/* 821F263Ch case   10:*/		regs.LR = 0x821F2640; return 0x82224B00;
		/* 821F263Ch case   10:*/		return 0x821F2640;
		  /* 821F2640h */ case   11:  		/* mr R30, R3 */
		/* 821F2640h case   11:*/		regs.R30 = regs.R3;
		/* 821F2640h case   11:*/		return 0x821F2644;
		  /* 821F2644h */ case   12:  		/* cmplwi CR6, R29, 0 */
		/* 821F2644h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821F2644h case   12:*/		return 0x821F2648;
		  /* 821F2648h */ case   13:  		/* bc 12, CR6_EQ, 52 */
		/* 821F2648h case   13:*/		if ( regs.CR[6].eq ) { return 0x821F267C;  }
		/* 821F2648h case   13:*/		return 0x821F264C;
		  /* 821F264Ch */ case   14:  		/* addi R28, R3, 40 */
		/* 821F264Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R3,0x28);
		/* 821F264Ch case   14:*/		return 0x821F2650;
		  /* 821F2650h */ case   15:  		/* mr R3, R26 */
		/* 821F2650h case   15:*/		regs.R3 = regs.R26;
		/* 821F2650h case   15:*/		return 0x821F2654;
		  /* 821F2654h */ case   16:  		/* bl -202740 */
		/* 821F2654h case   16:*/		regs.LR = 0x821F2658; return 0x821C0E60;
		/* 821F2654h case   16:*/		return 0x821F2658;
		  /* 821F2658h */ case   17:  		/* mr R4, R3 */
		/* 821F2658h case   17:*/		regs.R4 = regs.R3;
		/* 821F2658h case   17:*/		return 0x821F265C;
		  /* 821F265Ch */ case   18:  		/* mr R3, R31 */
		/* 821F265Ch case   18:*/		regs.R3 = regs.R31;
		/* 821F265Ch case   18:*/		return 0x821F2660;
		  /* 821F2660h */ case   19:  		/* bl -736 */
		/* 821F2660h case   19:*/		regs.LR = 0x821F2664; return 0x821F2380;
		/* 821F2660h case   19:*/		return 0x821F2664;
		  /* 821F2664h */ case   20:  		/* mr R4, R3 */
		/* 821F2664h case   20:*/		regs.R4 = regs.R3;
		/* 821F2664h case   20:*/		return 0x821F2668;
		  /* 821F2668h */ case   21:  		/* mr R3, R30 */
		/* 821F2668h case   21:*/		regs.R3 = regs.R30;
		/* 821F2668h case   21:*/		return 0x821F266C;
		  /* 821F266Ch */ case   22:  		/* bl -500900 */
		/* 821F266Ch case   22:*/		regs.LR = 0x821F2670; return 0x821781C8;
		/* 821F266Ch case   22:*/		return 0x821F2670;
		  /* 821F2670h */ case   23:  		/* addic. R29, R29, -1 */
		/* 821F2670h case   23:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 821F2670h case   23:*/		return 0x821F2674;
		  /* 821F2674h */ case   24:  		/* stwu R3, <#[R28 + 4]> */
		/* 821F2674h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 821F2674h case   24:*/		return 0x821F2678;
		  /* 821F2678h */ case   25:  		/* bc 4, CR0_EQ, -40 */
		/* 821F2678h case   25:*/		if ( !regs.CR[0].eq ) { return 0x821F2650;  }
		/* 821F2678h case   25:*/		return 0x821F267C;
	}
	return 0x821F267C;
} // Block from 821F2614h-821F267Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 821F267Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F267C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F267C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F267C);
		  /* 821F267Ch */ case    0:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F267Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F267Ch case    0:*/		return 0x821F2680;
		  /* 821F2680h */ case    1:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 821F2680h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 821F2680h case    1:*/		return 0x821F2684;
		  /* 821F2684h */ case    2:  		/* mr R4, R30 */
		/* 821F2684h case    2:*/		regs.R4 = regs.R30;
		/* 821F2684h case    2:*/		return 0x821F2688;
		  /* 821F2688h */ case    3:  		/* addi R11, R11, 24 */
		/* 821F2688h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F2688h case    3:*/		return 0x821F268C;
		  /* 821F268Ch */ case    4:  		/* addi R10, R10, 36 */
		/* 821F268Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F268Ch case    4:*/		return 0x821F2690;
		  /* 821F2690h */ case    5:  		/* addi R9, R11, -36 */
		/* 821F2690h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821F2690h case    5:*/		return 0x821F2694;
		  /* 821F2694h */ case    6:  		/* addi R8, R10, -36 */
		/* 821F2694h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFDC);
		/* 821F2694h case    6:*/		return 0x821F2698;
	}
	return 0x821F2698;
} // Block from 821F267Ch-821F2698h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F2698h
// Function '?GetSpaceWorker@?$ArrayList@ULexicalScope@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@AAAPAUArrayListEntry@12@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2698);
		  /* 821F2698h */ case    0:  		/* ori R7, R9, 1 */
		/* 821F2698h case    0:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R9,0x1);
		/* 821F2698h case    0:*/		return 0x821F269C;
		  /* 821F269Ch */ case    1:  		/* lwz R6, <#[R11]> */
		/* 821F269Ch case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821F269Ch case    1:*/		return 0x821F26A0;
		  /* 821F26A0h */ case    2:  		/* addi R9, R10, 4 */
		/* 821F26A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F26A0h case    2:*/		return 0x821F26A4;
		  /* 821F26A4h */ case    3:  		/* mr R3, R31 */
		/* 821F26A4h case    3:*/		regs.R3 = regs.R31;
		/* 821F26A4h case    3:*/		return 0x821F26A8;
		  /* 821F26A8h */ case    4:  		/* stw R6, <#[R10]> */
		/* 821F26A8h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 821F26A8h case    4:*/		return 0x821F26AC;
		  /* 821F26ACh */ case    5:  		/* lwz R6, <#[R11]> */
		/* 821F26ACh case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821F26ACh case    5:*/		return 0x821F26B0;
		  /* 821F26B0h */ case    6:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821F26B0h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821F26B0h case    6:*/		return 0x821F26B4;
		  /* 821F26B4h */ case    7:  		/* stw R8, <#[R6]> */
		/* 821F26B4h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 821F26B4h case    7:*/		return 0x821F26B8;
		  /* 821F26B8h */ case    8:  		/* stw R7, <#[R10 + 4]> */
		/* 821F26B8h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 821F26B8h case    8:*/		return 0x821F26BC;
		  /* 821F26BCh */ case    9:  		/* stw R9, <#[R11]> */
		/* 821F26BCh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F26BCh case    9:*/		return 0x821F26C0;
		  /* 821F26C0h */ case   10:  		/* bl -501440 */
		/* 821F26C0h case   10:*/		regs.LR = 0x821F26C4; return 0x82178000;
		/* 821F26C0h case   10:*/		return 0x821F26C4;
		  /* 821F26C4h */ case   11:  		/* b 108 */
		/* 821F26C4h case   11:*/		return 0x821F2730;
		/* 821F26C4h case   11:*/		return 0x821F26C8;
	}
	return 0x821F26C8;
} // Block from 821F2698h-821F26C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F26C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F26C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F26C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F26C8);
		  /* 821F26C8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821F26C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F26C8h case    0:*/		return 0x821F26CC;
		  /* 821F26CCh */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821F26CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F26CCh case    1:*/		return 0x821F26D0;
		  /* 821F26D0h */ case    2:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 821F26D0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 821F26D0h case    2:*/		return 0x821F26D4;
		  /* 821F26D4h */ case    3:  		/* b -284 */
		/* 821F26D4h case    3:*/		return 0x821F25B8;
		/* 821F26D4h case    3:*/		return 0x821F26D8;
	}
	return 0x821F26D8;
} // Block from 821F26C8h-821F26D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F26D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F26D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F26D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F26D8);
		  /* 821F26D8h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 821F26D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821F26D8h case    0:*/		return 0x821F26DC;
		  /* 821F26DCh */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821F26DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F26DCh case    1:*/		return 0x821F26E0;
		  /* 821F26E0h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821F26E0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821F26E0h case    2:*/		return 0x821F26E4;
		  /* 821F26E4h */ case    3:  		/* b -268 */
		/* 821F26E4h case    3:*/		return 0x821F25D8;
		/* 821F26E4h case    3:*/		return 0x821F26E8;
	}
	return 0x821F26E8;
} // Block from 821F26D8h-821F26E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F26E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F26E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F26E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F26E8);
		  /* 821F26E8h */ case    0:  		/* li R4, 4800 */
		/* 821F26E8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821F26E8h case    0:*/		return 0x821F26EC;
		  /* 821F26ECh */ case    1:  		/* mr R3, R31 */
		/* 821F26ECh case    1:*/		regs.R3 = regs.R31;
		/* 821F26ECh case    1:*/		return 0x821F26F0;
		  /* 821F26F0h */ case    2:  		/* bl -657544 */
		/* 821F26F0h case    2:*/		regs.LR = 0x821F26F4; return 0x82151E68;
		/* 821F26F0h case    2:*/		return 0x821F26F4;
	}
	return 0x821F26F4;
} // Block from 821F26E8h-821F26F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F26F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F26F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F26F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F26F4);
		  /* 821F26F4h */ case    0:  		/* li R4, 4800 */
		/* 821F26F4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821F26F4h case    0:*/		return 0x821F26F8;
		  /* 821F26F8h */ case    1:  		/* mr R3, R31 */
		/* 821F26F8h case    1:*/		regs.R3 = regs.R31;
		/* 821F26F8h case    1:*/		return 0x821F26FC;
		  /* 821F26FCh */ case    2:  		/* bl -657556 */
		/* 821F26FCh case    2:*/		regs.LR = 0x821F2700; return 0x82151E68;
		/* 821F26FCh case    2:*/		return 0x821F2700;
	}
	return 0x821F2700;
} // Block from 821F26F4h-821F2700h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F2700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2700);
		  /* 821F2700h */ case    0:  		/* mr R4, R30 */
		/* 821F2700h case    0:*/		regs.R4 = regs.R30;
		/* 821F2700h case    0:*/		return 0x821F2704;
		  /* 821F2704h */ case    1:  		/* mr R3, R31 */
		/* 821F2704h case    1:*/		regs.R3 = regs.R31;
		/* 821F2704h case    1:*/		return 0x821F2708;
		  /* 821F2708h */ case    2:  		/* bl -904 */
		/* 821F2708h case    2:*/		regs.LR = 0x821F270C; return 0x821F2380;
		/* 821F2708h case    2:*/		return 0x821F270C;
		  /* 821F270Ch */ case    3:  		/* rlwinm R10, R24, 0, 24, 31 */
		/* 821F270Ch case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R24);
		/* 821F270Ch case    3:*/		return 0x821F2710;
		  /* 821F2710h */ case    4:  		/* rlwinm R11, R28, 20, 9, 11 */
		/* 821F2710h case    4:*/		cpu::op::rlwinm<0,20,9,11>(regs,&regs.R11,regs.R28);
		/* 821F2710h case    4:*/		return 0x821F2714;
		  /* 821F2714h */ case    5:  		/* or R11, R11, R10 */
		/* 821F2714h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F2714h case    5:*/		return 0x821F2718;
		  /* 821F2718h */ case    6:  		/* lwz R10, <#[R3]> */
		/* 821F2718h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2718h case    6:*/		return 0x821F271C;
		  /* 821F271Ch */ case    7:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821F271Ch case    7:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821F271Ch case    7:*/		return 0x821F2720;
	}
	return 0x821F2720;
} // Block from 821F2700h-821F2720h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F2720h
// Function '?StartNewIsolationGroup@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2720);
		  /* 821F2720h */ case    0:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821F2720h case    0:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821F2720h case    0:*/		return 0x821F2724;
		  /* 821F2724h */ case    1:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 821F2724h case    1:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 821F2724h case    1:*/		return 0x821F2728;
		  /* 821F2728h */ case    2:  		/* or R11, R11, R10 */
		/* 821F2728h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F2728h case    2:*/		return 0x821F272C;
		  /* 821F272Ch */ case    3:  		/* stw R11, <#[R3]> */
		/* 821F272Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F272Ch case    3:*/		return 0x821F2730;
	}
	return 0x821F2730;
} // Block from 821F2720h-821F2730h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F2730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2730);
		  /* 821F2730h */ case    0:  		/* rlwinm. R11, R20, 0, 24, 31 */
		/* 821F2730h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R20);
		/* 821F2730h case    0:*/		return 0x821F2734;
		  /* 821F2734h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821F2734h case    1:*/		if ( regs.CR[0].eq ) { return 0x821F2740;  }
		/* 821F2734h case    1:*/		return 0x821F2738;
		  /* 821F2738h */ case    2:  		/* stw R22, <#[R26 + 4]> */
		/* 821F2738h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R26 + 0x00000004) );
		/* 821F2738h case    2:*/		return 0x821F273C;
		  /* 821F273Ch */ case    3:  		/* stw R21, <#[R26 + 8]> */
		/* 821F273Ch case    3:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R26 + 0x00000008) );
		/* 821F273Ch case    3:*/		return 0x821F2740;
	}
	return 0x821F2740;
} // Block from 821F2730h-821F2740h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F2740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2740);
		  /* 821F2740h */ case    0:  		/* addi R1, R1, 192 */
		/* 821F2740h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821F2740h case    0:*/		return 0x821F2744;
		  /* 821F2744h */ case    1:  		/* b -1447104 */
		/* 821F2744h case    1:*/		return 0x82091284;
		/* 821F2744h case    1:*/		return 0x821F2748;
	}
	return 0x821F2748;
} // Block from 821F2740h-821F2748h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2748);
		  /* 821F2748h */ case    0:  		/* mfspr R12, LR */
		/* 821F2748h case    0:*/		regs.R12 = regs.LR;
		/* 821F2748h case    0:*/		return 0x821F274C;
		  /* 821F274Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F274Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F274Ch case    1:*/		return 0x821F2750;
		  /* 821F2750h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F2750h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2750h case    2:*/		return 0x821F2754;
		  /* 821F2754h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F2754h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F2754h case    3:*/		return 0x821F2758;
		  /* 821F2758h */ case    4:  		/* mr R31, R6 */
		/* 821F2758h case    4:*/		regs.R31 = regs.R6;
		/* 821F2758h case    4:*/		return 0x821F275C;
		  /* 821F275Ch */ case    5:  		/* li R7, 1 */
		/* 821F275Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F275Ch case    5:*/		return 0x821F2760;
		  /* 821F2760h */ case    6:  		/* li R6, 1 */
		/* 821F2760h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F2760h case    6:*/		return 0x821F2764;
		  /* 821F2764h */ case    7:  		/* bl -580 */
		/* 821F2764h case    7:*/		regs.LR = 0x821F2768; return 0x821F2520;
		/* 821F2764h case    7:*/		return 0x821F2768;
		  /* 821F2768h */ case    8:  		/* cmplwi CR6, R31, 228 */
		/* 821F2768h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x000000E4);
		/* 821F2768h case    8:*/		return 0x821F276C;
		  /* 821F276Ch */ case    9:  		/* bc 12, CR6_EQ, 76 */
		/* 821F276Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821F27B8;  }
		/* 821F276Ch case    9:*/		return 0x821F2770;
		  /* 821F2770h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 821F2770h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2770h case   10:*/		return 0x821F2774;
		  /* 821F2774h */ case   11:  		/* rlwinm R10, R31, 27, 29, 30 */
		/* 821F2774h case   11:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R10,regs.R31);
		/* 821F2774h case   11:*/		return 0x821F2778;
		  /* 821F2778h */ case   12:  		/* rlwinm R9, R31, 29, 29, 30 */
		/* 821F2778h case   12:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R9,regs.R31);
		/* 821F2778h case   12:*/		return 0x821F277C;
		  /* 821F277Ch */ case   13:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 821F277Ch case   13:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 821F277Ch case   13:*/		return 0x821F2780;
	}
	return 0x821F2780;
} // Block from 821F2748h-821F2780h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F2780h
// Function '?Abs@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2780);
		  /* 821F2780h */ case    0:  		/* rlwinm R7, R31, 31, 29, 30 */
		/* 821F2780h case    0:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R7,regs.R31);
		/* 821F2780h case    0:*/		return 0x821F2784;
		  /* 821F2784h */ case    1:  		/* srw R10, R8, R10 */
		/* 821F2784h case    1:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821F2784h case    1:*/		return 0x821F2788;
		  /* 821F2788h */ case    2:  		/* srw R9, R8, R9 */
		/* 821F2788h case    2:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821F2788h case    2:*/		return 0x821F278C;
		  /* 821F278Ch */ case    3:  		/* rlwimi R9, R10, 2, 28, 29 */
		/* 821F278Ch case    3:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R9,regs.R10);
		/* 821F278Ch case    3:*/		return 0x821F2790;
		  /* 821F2790h */ case    4:  		/* srw R10, R8, R7 */
		/* 821F2790h case    4:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R7);
		/* 821F2790h case    4:*/		return 0x821F2794;
		  /* 821F2794h */ case    5:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 821F2794h case    5:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 821F2794h case    5:*/		return 0x821F2798;
		  /* 821F2798h */ case    6:  		/* rlwinm R7, R31, 1, 29, 30 */
		/* 821F2798h case    6:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R7,regs.R31);
		/* 821F2798h case    6:*/		return 0x821F279C;
		  /* 821F279Ch */ case    7:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 821F279Ch case    7:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821F279Ch case    7:*/		return 0x821F27A0;
		  /* 821F27A0h */ case    8:  		/* srw R9, R8, R7 */
		/* 821F27A0h case    8:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 821F27A0h case    8:*/		return 0x821F27A4;
		  /* 821F27A4h */ case    9:  		/* rlwimi R9, R10, 2, 0, 29 */
		/* 821F27A4h case    9:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 821F27A4h case    9:*/		return 0x821F27A8;
		  /* 821F27A8h */ case   10:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821F27A8h case   10:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821F27A8h case   10:*/		return 0x821F27AC;
		  /* 821F27ACh */ case   11:  		/* rlwinm R10, R9, 5, 0, 26 */
		/* 821F27ACh case   11:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R9);
		/* 821F27ACh case   11:*/		return 0x821F27B0;
		  /* 821F27B0h */ case   12:  		/* or R11, R10, R11 */
		/* 821F27B0h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F27B0h case   12:*/		return 0x821F27B4;
		  /* 821F27B4h */ case   13:  		/* stw R11, <#[R3]> */
		/* 821F27B4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F27B4h case   13:*/		return 0x821F27B8;
	}
	return 0x821F27B8;
} // Block from 821F2780h-821F27B8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F27B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F27B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F27B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F27B8);
		  /* 821F27B8h */ case    0:  		/* addi R1, R1, 96 */
		/* 821F27B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F27B8h case    0:*/		return 0x821F27BC;
		  /* 821F27BCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F27BCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F27BCh case    1:*/		return 0x821F27C0;
		  /* 821F27C0h */ case    2:  		/* mtspr LR, R12 */
		/* 821F27C0h case    2:*/		regs.LR = regs.R12;
		/* 821F27C0h case    2:*/		return 0x821F27C4;
		  /* 821F27C4h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821F27C4h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F27C4h case    3:*/		return 0x821F27C8;
		  /* 821F27C8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821F27C8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F27C8h case    4:*/		return 0x821F27CC;
	}
	return 0x821F27CC;
} // Block from 821F27B8h-821F27CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F27CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F27CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F27CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F27CC);
		  /* 821F27CCh */ case    0:  		/* nop */
		/* 821F27CCh case    0:*/		cpu::op::nop();
		/* 821F27CCh case    0:*/		return 0x821F27D0;
	}
	return 0x821F27D0;
} // Block from 821F27CCh-821F27D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F27D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F27D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F27D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F27D0);
		  /* 821F27D0h */ case    0:  		/* mfspr R12, LR */
		/* 821F27D0h case    0:*/		regs.R12 = regs.LR;
		/* 821F27D0h case    0:*/		return 0x821F27D4;
		  /* 821F27D4h */ case    1:  		/* bl -1447296 */
		/* 821F27D4h case    1:*/		regs.LR = 0x821F27D8; return 0x82091254;
		/* 821F27D4h case    1:*/		return 0x821F27D8;
		  /* 821F27D8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821F27D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821F27D8h case    2:*/		return 0x821F27DC;
		  /* 821F27DCh */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 821F27DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821F27DCh case    3:*/		return 0x821F27E0;
		  /* 821F27E0h */ case    4:  		/* mr R28, R3 */
		/* 821F27E0h case    4:*/		regs.R28 = regs.R3;
		/* 821F27E0h case    4:*/		return 0x821F27E4;
		  /* 821F27E4h */ case    5:  		/* mr R27, R4 */
		/* 821F27E4h case    5:*/		regs.R27 = regs.R4;
		/* 821F27E4h case    5:*/		return 0x821F27E8;
	}
	return 0x821F27E8;
} // Block from 821F27D0h-821F27E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F27E8h
// Function '?GetNthResult@ResultStackEnumerator@D3DXShader@@QAAPAVResult@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F27E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F27E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F27E8);
		  /* 821F27E8h */ case    0:  		/* rlwinm. R10, R11, 0, 30, 31 */
		/* 821F27E8h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R11);
		/* 821F27E8h case    0:*/		return 0x821F27EC;
		  /* 821F27ECh */ case    1:  		/* bc 12, CR0_EQ, 264 */
		/* 821F27ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x821F28F4;  }
		/* 821F27ECh case    1:*/		return 0x821F27F0;
		  /* 821F27F0h */ case    2:  		/* cmpwi CR6, R10, 3 */
		/* 821F27F0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 821F27F0h case    2:*/		return 0x821F27F4;
		  /* 821F27F4h */ case    3:  		/* bc 4, CR6_EQ, 492 */
		/* 821F27F4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F29E0;  }
		/* 821F27F4h case    3:*/		return 0x821F27F8;
		  /* 821F27F8h */ case    4:  		/* rlwinm. R11, R11, 16, 31, 31 */
		/* 821F27F8h case    4:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R11,regs.R11);
		/* 821F27F8h case    4:*/		return 0x821F27FC;
		  /* 821F27FCh */ case    5:  		/* bc 12, CR0_EQ, 224 */
		/* 821F27FCh case    5:*/		if ( regs.CR[0].eq ) { return 0x821F28DC;  }
		/* 821F27FCh case    5:*/		return 0x821F2800;
		  /* 821F2800h */ case    6:  		/* lwz R29, <#[R4]> */
		/* 821F2800h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R4 + 0x00000000) );
		/* 821F2800h case    6:*/		return 0x821F2804;
		  /* 821F2804h */ case    7:  		/* li R10, 0 */
		/* 821F2804h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821F2804h case    7:*/		return 0x821F2808;
		  /* 821F2808h */ case    8:  		/* lwz R11, <#[R29 + 8]> */
		/* 821F2808h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821F2808h case    8:*/		return 0x821F280C;
		  /* 821F280Ch */ case    9:  		/* rlwinm. R11, R11, 18, 18, 31 */
		/* 821F280Ch case    9:*/		cpu::op::rlwinm<1,18,18,31>(regs,&regs.R11,regs.R11);
		/* 821F280Ch case    9:*/		return 0x821F2810;
		  /* 821F2810h */ case   10:  		/* bc 12, CR0_EQ, 48 */
		/* 821F2810h case   10:*/		if ( regs.CR[0].eq ) { return 0x821F2840;  }
		/* 821F2810h case   10:*/		return 0x821F2814;
		  /* 821F2814h */ case   11:  		/* addi R9, R29, 16 */
		/* 821F2814h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x10);
		/* 821F2814h case   11:*/		return 0x821F2818;
		  /* 821F2818h */ case   12:  		/* lwz R8, <#[R9]> */
		/* 821F2818h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 821F2818h case   12:*/		return 0x821F281C;
		  /* 821F281Ch */ case   13:  		/* rlwinm R8, R8, 0, 30, 31 */
		/* 821F281Ch case   13:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R8);
		/* 821F281Ch case   13:*/		return 0x821F2820;
		  /* 821F2820h */ case   14:  		/* cmpwi CR6, R8, 3 */
		/* 821F2820h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000003);
		/* 821F2820h case   14:*/		return 0x821F2824;
		  /* 821F2824h */ case   15:  		/* bc 12, CR6_EQ, 28 */
		/* 821F2824h case   15:*/		if ( regs.CR[6].eq ) { return 0x821F2840;  }
		/* 821F2824h case   15:*/		return 0x821F2828;
	}
	return 0x821F2828;
} // Block from 821F27E8h-821F2828h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F2828h
// Function '?ReplaceResult@ResultStackEnumerator@D3DXShader@@QAAXPAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2828);
		  /* 821F2828h */ case    0:  		/* cmpwi CR6, R8, 0 */
		/* 821F2828h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 821F2828h case    0:*/		return 0x821F282C;
		  /* 821F282Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821F282Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821F2840;  }
		/* 821F282Ch case    1:*/		return 0x821F2830;
		  /* 821F2830h */ case    2:  		/* addi R10, R10, 1 */
		/* 821F2830h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F2830h case    2:*/		return 0x821F2834;
		  /* 821F2834h */ case    3:  		/* addi R9, R9, 8 */
		/* 821F2834h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 821F2834h case    3:*/		return 0x821F2838;
		  /* 821F2838h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 821F2838h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F2838h case    4:*/		return 0x821F283C;
		  /* 821F283Ch */ case    5:  		/* bc 12, CR6_LT, -36 */
		/* 821F283Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x821F2818;  }
		/* 821F283Ch case    5:*/		return 0x821F2840;
	}
	return 0x821F2840;
} // Block from 821F2828h-821F2840h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F2840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2840);
		  /* 821F2840h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 821F2840h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F2840h case    0:*/		return 0x821F2844;
		  /* 821F2844h */ case    1:  		/* bc 4, CR6_LT, 120 */
		/* 821F2844h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821F28BC;  }
		/* 821F2844h case    1:*/		return 0x821F2848;
		  /* 821F2848h */ case    2:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 821F2848h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 821F2848h case    2:*/		return 0x821F284C;
		  /* 821F284Ch */ case    3:  		/* li R5, 32 */
		/* 821F284Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 821F284Ch case    3:*/		return 0x821F2850;
		  /* 821F2850h */ case    4:  		/* addi R30, R11, 12 */
		/* 821F2850h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xC);
		/* 821F2850h case    4:*/		return 0x821F2854;
		  /* 821F2854h */ case    5:  		/* mr R3, R28 */
		/* 821F2854h case    5:*/		regs.R3 = regs.R28;
		/* 821F2854h case    5:*/		return 0x821F2858;
		  /* 821F2858h */ case    6:  		/* mr R4, R30 */
		/* 821F2858h case    6:*/		regs.R4 = regs.R30;
		/* 821F2858h case    6:*/		return 0x821F285C;
		  /* 821F285Ch */ case    7:  		/* bl -579620 */
		/* 821F285Ch case    7:*/		regs.LR = 0x821F2860; return 0x82165038;
		/* 821F285Ch case    7:*/		return 0x821F2860;
		  /* 821F2860h */ case    8:  		/* mr R5, R30 */
		/* 821F2860h case    8:*/		regs.R5 = regs.R30;
		/* 821F2860h case    8:*/		return 0x821F2864;
		  /* 821F2864h */ case    9:  		/* mr R4, R29 */
		/* 821F2864h case    9:*/		regs.R4 = regs.R29;
		/* 821F2864h case    9:*/		return 0x821F2868;
		  /* 821F2868h */ case   10:  		/* mr R31, R3 */
		/* 821F2868h case   10:*/		regs.R31 = regs.R3;
		/* 821F2868h case   10:*/		return 0x821F286C;
		  /* 821F286Ch */ case   11:  		/* bl -1445564 */
		/* 821F286Ch case   11:*/		regs.LR = 0x821F2870; return 0x820919B0;
		/* 821F286Ch case   11:*/		return 0x821F2870;
		  /* 821F2870h */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 821F2870h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2870h case   12:*/		return 0x821F2874;
		  /* 821F2874h */ case   13:  		/* li R30, 0 */
		/* 821F2874h case   13:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821F2874h case   13:*/		return 0x821F2878;
	}
	return 0x821F2878;
} // Block from 821F2840h-821F2878h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F2878h
// Function '?ReplaceResult@ResultStackEnumerator@D3DXShader@@QAAXPAVDependency@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2878);
		  /* 821F2878h */ case    0:  		/* rlwinm. R11, R11, 0, 4, 17 */
		/* 821F2878h case    0:*/		cpu::op::rlwinm<1,0,4,17>(regs,&regs.R11,regs.R11);
		/* 821F2878h case    0:*/		return 0x821F287C;
		  /* 821F287Ch */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 821F287Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821F28A8;  }
		/* 821F287Ch case    1:*/		return 0x821F2880;
		  /* 821F2880h */ case    2:  		/* addi R29, R31, 12 */
		/* 821F2880h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0xC);
		/* 821F2880h case    2:*/		return 0x821F2884;
		  /* 821F2884h */ case    3:  		/* mr R4, R29 */
		/* 821F2884h case    3:*/		regs.R4 = regs.R29;
		/* 821F2884h case    3:*/		return 0x821F2888;
		  /* 821F2888h */ case    4:  		/* mr R3, R28 */
		/* 821F2888h case    4:*/		regs.R3 = regs.R28;
		/* 821F2888h case    4:*/		return 0x821F288C;
		  /* 821F288Ch */ case    5:  		/* bl -188 */
		/* 821F288Ch case    5:*/		regs.LR = 0x821F2890; return 0x821F27D0;
		/* 821F288Ch case    5:*/		return 0x821F2890;
		  /* 821F2890h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 821F2890h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2890h case    6:*/		return 0x821F2894;
		  /* 821F2894h */ case    7:  		/* addi R30, R30, 1 */
		/* 821F2894h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821F2894h case    7:*/		return 0x821F2898;
		  /* 821F2898h */ case    8:  		/* rlwinm R11, R11, 18, 18, 31 */
		/* 821F2898h case    8:*/		cpu::op::rlwinm<0,18,18,31>(regs,&regs.R11,regs.R11);
		/* 821F2898h case    8:*/		return 0x821F289C;
		  /* 821F289Ch */ case    9:  		/* addi R29, R29, 8 */
		/* 821F289Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 821F289Ch case    9:*/		return 0x821F28A0;
		  /* 821F28A0h */ case   10:  		/* cmplw CR6, R30, R11 */
		/* 821F28A0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821F28A0h case   10:*/		return 0x821F28A4;
		  /* 821F28A4h */ case   11:  		/* bc 12, CR6_LT, -32 */
		/* 821F28A4h case   11:*/		if ( regs.CR[6].lt ) { return 0x821F2884;  }
		/* 821F28A4h case   11:*/		return 0x821F28A8;
	}
	return 0x821F28A8;
} // Block from 821F2878h-821F28A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F28A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F28A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F28A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F28A8);
		  /* 821F28A8h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 821F28A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821F28A8h case    0:*/		return 0x821F28AC;
		  /* 821F28ACh */ case    1:  		/* stw R31, <#[R27]> */
		/* 821F28ACh case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x00000000) );
		/* 821F28ACh case    1:*/		return 0x821F28B0;
		  /* 821F28B0h */ case    2:  		/* oris R11, R11, 1 */
		/* 821F28B0h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F28B0h case    2:*/		return 0x821F28B4;
		  /* 821F28B4h */ case    3:  		/* ori R11, R11, 3 */
		/* 821F28B4h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3);
		/* 821F28B4h case    3:*/		return 0x821F28B8;
		  /* 821F28B8h */ case    4:  		/* stw R11, <#[R27 + 4]> */
		/* 821F28B8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821F28B8h case    4:*/		return 0x821F28BC;
	}
	return 0x821F28BC;
} // Block from 821F28A8h-821F28BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F28BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F28BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F28BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F28BC);
		  /* 821F28BCh */ case    0:  		/* mr R4, R27 */
		/* 821F28BCh case    0:*/		regs.R4 = regs.R27;
		/* 821F28BCh case    0:*/		return 0x821F28C0;
		  /* 821F28C0h */ case    1:  		/* mr R3, R28 */
		/* 821F28C0h case    1:*/		regs.R3 = regs.R28;
		/* 821F28C0h case    1:*/		return 0x821F28C4;
		  /* 821F28C4h */ case    2:  		/* bl -1604 */
		/* 821F28C4h case    2:*/		regs.LR = 0x821F28C8; return 0x821F2280;
		/* 821F28C4h case    2:*/		return 0x821F28C8;
	}
	return 0x821F28C8;
} // Block from 821F28BCh-821F28C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F28C8h
// Function '?ReplaceResults@ResultStackEnumerator@D3DXShader@@QAAXIPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F28C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F28C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F28C8);
		  /* 821F28C8h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 821F28C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821F28C8h case    0:*/		return 0x821F28CC;
		  /* 821F28CCh */ case    1:  		/* li R10, 1 */
		/* 821F28CCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821F28CCh case    1:*/		return 0x821F28D0;
		  /* 821F28D0h */ case    2:  		/* stw R3, <#[R27]> */
		/* 821F28D0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 821F28D0h case    2:*/		return 0x821F28D4;
		  /* 821F28D4h */ case    3:  		/* rlwimi R11, R10, 0, 16, 14 */
		/* 821F28D4h case    3:*/		cpu::op::rlwimi<0,0,16,14>(regs,&regs.R11,regs.R10);
		/* 821F28D4h case    3:*/		return 0x821F28D8;
		  /* 821F28D8h */ case    4:  		/* b 20 */
		/* 821F28D8h case    4:*/		return 0x821F28EC;
		/* 821F28D8h case    4:*/		return 0x821F28DC;
	}
	return 0x821F28DC;
} // Block from 821F28C8h-821F28DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F28DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F28DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F28DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F28DC);
		  /* 821F28DCh */ case    0:  		/* lwz R11, <#[R27]> */
		/* 821F28DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821F28DCh case    0:*/		return 0x821F28E0;
		  /* 821F28E0h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 821F28E0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F28E0h case    1:*/		return 0x821F28E4;
		  /* 821F28E4h */ case    2:  		/* stw R10, <#[R27]> */
		/* 821F28E4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821F28E4h case    2:*/		return 0x821F28E8;
		  /* 821F28E8h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F28E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F28E8h case    3:*/		return 0x821F28EC;
	}
	return 0x821F28EC;
} // Block from 821F28DCh-821F28ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F28ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F28EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F28EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F28EC);
		  /* 821F28ECh */ case    0:  		/* stw R11, <#[R27 + 4]> */
		/* 821F28ECh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821F28ECh case    0:*/		return 0x821F28F0;
		  /* 821F28F0h */ case    1:  		/* b 240 */
		/* 821F28F0h case    1:*/		return 0x821F29E0;
		/* 821F28F0h case    1:*/		return 0x821F28F4;
	}
	return 0x821F28F4;
} // Block from 821F28ECh-821F28F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F28F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F28F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F28F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F28F4);
		  /* 821F28F4h */ case    0:  		/* lwz R5, <#[R28 + 564]> */
		/* 821F28F4h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000234) );
		/* 821F28F4h case    0:*/		return 0x821F28F8;
		  /* 821F28F8h */ case    1:  		/* lwz R10, <#[R5 + 80]> */
		/* 821F28F8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000050) );
		/* 821F28F8h case    1:*/		return 0x821F28FC;
		  /* 821F28FCh */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821F28FCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F28FCh case    2:*/		return 0x821F2900;
		  /* 821F2900h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821F2900h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F2910;  }
		/* 821F2900h case    3:*/		return 0x821F2904;
		  /* 821F2904h */ case    4:  		/* rlwinm R9, R11, 17, 15, 29 */
		/* 821F2904h case    4:*/		cpu::op::rlwinm<0,17,15,29>(regs,&regs.R9,regs.R11);
		/* 821F2904h case    4:*/		return 0x821F2908;
		  /* 821F2908h */ case    5:  		/* lwzx R10, <#[R9 + R10]> */
		/* 821F2908h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821F2908h case    5:*/		return 0x821F290C;
		  /* 821F290Ch */ case    6:  		/* b 8 */
		/* 821F290Ch case    6:*/		return 0x821F2914;
		/* 821F290Ch case    6:*/		return 0x821F2910;
	}
	return 0x821F2910;
} // Block from 821F28F4h-821F2910h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F2910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2910);
		  /* 821F2910h */ case    0:  		/* li R10, 0 */
		/* 821F2910h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821F2910h case    0:*/		return 0x821F2914;
	}
	return 0x821F2914;
} // Block from 821F2910h-821F2914h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2914);
		  /* 821F2914h */ case    0:  		/* li R9, 0 */
		/* 821F2914h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821F2914h case    0:*/		return 0x821F2918;
		  /* 821F2918h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821F2918h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F2918h case    1:*/		return 0x821F291C;
		  /* 821F291Ch */ case    2:  		/* stw R9, <#[R1 + 80]> */
		/* 821F291Ch case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821F291Ch case    2:*/		return 0x821F2920;
	}
	return 0x821F2920;
} // Block from 821F2914h-821F2920h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F2920h
// Function '?ReplaceResults@ResultStackEnumerator@D3DXShader@@QAAXIPAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2920);
		  /* 821F2920h */ case    0:  		/* bc 12, CR6_EQ, 60 */
		/* 821F2920h case    0:*/		if ( regs.CR[6].eq ) { return 0x821F295C;  }
		/* 821F2920h case    0:*/		return 0x821F2924;
		  /* 821F2924h */ case    1:  		/* rlwinm R9, R11, 1, 15, 28 */
		/* 821F2924h case    1:*/		cpu::op::rlwinm<0,1,15,28>(regs,&regs.R9,regs.R11);
		/* 821F2924h case    1:*/		return 0x821F2928;
		  /* 821F2928h */ case    2:  		/* ldx R10, <#[R9 + R10]> */
		/* 821F2928h case    2:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821F2928h case    2:*/		return 0x821F292C;
		  /* 821F292Ch */ case    3:  		/* std R10, <#[R1 + 80]> */
		/* 821F292Ch case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821F292Ch case    3:*/		return 0x821F2930;
		  /* 821F2930h */ case    4:  		/* lwz R9, <#[R1 + 80]> */
		/* 821F2930h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2930h case    4:*/		return 0x821F2934;
		  /* 821F2934h */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 821F2934h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821F2934h case    5:*/		return 0x821F2938;
		  /* 821F2938h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 821F2938h case    6:*/		if ( regs.CR[6].eq ) { return 0x821F2960;  }
		/* 821F2938h case    6:*/		return 0x821F293C;
		  /* 821F293Ch */ case    7:  		/* lwz R9, <#[R1 + 84]> */
		/* 821F293Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 821F293Ch case    7:*/		return 0x821F2940;
		  /* 821F2940h */ case    8:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 821F2940h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 821F2940h case    8:*/		return 0x821F2944;
		  /* 821F2944h */ case    9:  		/* cmplwi CR6, R9, 1 */
		/* 821F2944h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 821F2944h case    9:*/		return 0x821F2948;
		  /* 821F2948h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 821F2948h case   10:*/		if ( regs.CR[6].eq ) { return 0x821F2954;  }
		/* 821F2948h case   10:*/		return 0x821F294C;
		  /* 821F294Ch */ case   11:  		/* cmplwi CR6, R9, 2 */
		/* 821F294Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000002);
		/* 821F294Ch case   11:*/		return 0x821F2950;
		  /* 821F2950h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 821F2950h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821F2960;  }
		/* 821F2950h case   12:*/		return 0x821F2954;
	}
	return 0x821F2954;
} // Block from 821F2920h-821F2954h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821F2954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2954);
		  /* 821F2954h */ case    0:  		/* li R9, 1 */
		/* 821F2954h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821F2954h case    0:*/		return 0x821F2958;
		  /* 821F2958h */ case    1:  		/* b 12 */
		/* 821F2958h case    1:*/		return 0x821F2964;
		/* 821F2958h case    1:*/		return 0x821F295C;
	}
	return 0x821F295C;
} // Block from 821F2954h-821F295Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F295Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F295C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F295C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F295C);
		  /* 821F295Ch */ case    0:  		/* ld R10, <#[R1 + 80]> */
		/* 821F295Ch case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821F295Ch case    0:*/		return 0x821F2960;
	}
	return 0x821F2960;
} // Block from 821F295Ch-821F2960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2960);
		  /* 821F2960h */ case    0:  		/* li R9, 0 */
		/* 821F2960h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821F2960h case    0:*/		return 0x821F2964;
	}
	return 0x821F2964;
} // Block from 821F2960h-821F2964h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2964);
		  /* 821F2964h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 821F2964h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 821F2964h case    0:*/		return 0x821F2968;
		  /* 821F2968h */ case    1:  		/* bc 4, CR0_EQ, 116 */
		/* 821F2968h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821F29DC;  }
		/* 821F2968h case    1:*/		return 0x821F296C;
		  /* 821F296Ch */ case    2:  		/* lwz R10, <#[R28 + 4]> */
		/* 821F296Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 821F296Ch case    2:*/		return 0x821F2970;
		  /* 821F2970h */ case    3:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 821F2970h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821F2970h case    3:*/		return 0x821F2974;
		  /* 821F2974h */ case    4:  		/* addic R9, R9, -1 */
		/* 821F2974h case    4:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821F2974h case    4:*/		return 0x821F2978;
	}
	return 0x821F2978;
} // Block from 821F2964h-821F2978h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F2978h
// Function '?ParseExportSemantic@Compiler@D3DXShader@@AAAIPAVCNode@2@II_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2978);
		  /* 821F2978h */ case    0:  		/* subfe R9, R9, R9 */
		/* 821F2978h case    0:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821F2978h case    0:*/		return 0x821F297C;
		  /* 821F297Ch */ case    1:  		/* and R10, R9, R10 */
		/* 821F297Ch case    1:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821F297Ch case    1:*/		return 0x821F2980;
		  /* 821F2980h */ case    2:  		/* cmplw CR6, R5, R10 */
		/* 821F2980h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 821F2980h case    2:*/		return 0x821F2984;
		  /* 821F2984h */ case    3:  		/* bc 12, CR6_EQ, 64 */
		/* 821F2984h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F29C4;  }
		/* 821F2984h case    3:*/		return 0x821F2988;
		  /* 821F2988h */ case    4:  		/* rlwinm R6, R11, 15, 17, 31 */
		/* 821F2988h case    4:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R6,regs.R11);
		/* 821F2988h case    4:*/		return 0x821F298C;
		  /* 821F298Ch */ case    5:  		/* lwz R10, <#[R28 + 12]> */
		/* 821F298Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 821F298Ch case    5:*/		return 0x821F2990;
		  /* 821F2990h */ case    6:  		/* mulli R9, R6, 40 */
		/* 821F2990h case    6:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R6,0x28);
		/* 821F2990h case    6:*/		return 0x821F2994;
		  /* 821F2994h */ case    7:  		/* add R10, R9, R10 */
		/* 821F2994h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821F2994h case    7:*/		return 0x821F2998;
		  /* 821F2998h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 821F2998h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821F2998h case    8:*/		return 0x821F299C;
		  /* 821F299Ch */ case    9:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 821F299Ch case    9:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 821F299Ch case    9:*/		return 0x821F29A0;
		  /* 821F29A0h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 821F29A0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821F29B0;  }
		/* 821F29A0h case   10:*/		return 0x821F29A4;
		  /* 821F29A4h */ case   11:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F29A4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F29A4h case   11:*/		return 0x821F29A8;
		  /* 821F29A8h */ case   12:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821F29A8h case   12:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821F29A8h case   12:*/		return 0x821F29AC;
		  /* 821F29ACh */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 821F29ACh case   13:*/		if ( regs.CR[0].eq ) { return 0x821F29C4;  }
		/* 821F29ACh case   13:*/		return 0x821F29B0;
	}
	return 0x821F29B0;
} // Block from 821F2978h-821F29B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F29B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F29B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F29B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F29B0);
		  /* 821F29B0h */ case    0:  		/* rlwinm R7, R11, 30, 18, 31 */
		/* 821F29B0h case    0:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R7,regs.R11);
		/* 821F29B0h case    0:*/		return 0x821F29B4;
		  /* 821F29B4h */ case    1:  		/* mr R4, R28 */
		/* 821F29B4h case    1:*/		regs.R4 = regs.R28;
		/* 821F29B4h case    1:*/		return 0x821F29B8;
		  /* 821F29B8h */ case    2:  		/* addi R3, R1, 80 */
		/* 821F29B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F29B8h case    2:*/		return 0x821F29BC;
		  /* 821F29BCh */ case    3:  		/* bl 209036 */
		/* 821F29BCh case    3:*/		regs.LR = 0x821F29C0; return 0x82225A48;
		/* 821F29BCh case    3:*/		return 0x821F29C0;
		  /* 821F29C0h */ case    4:  		/* b 24 */
		/* 821F29C0h case    4:*/		return 0x821F29D8;
		/* 821F29C0h case    4:*/		return 0x821F29C4;
	}
	return 0x821F29C4;
} // Block from 821F29B0h-821F29C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F29C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F29C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F29C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F29C4);
		  /* 821F29C4h */ case    0:  		/* rlwinm R6, R11, 30, 18, 31 */
		/* 821F29C4h case    0:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R6,regs.R11);
		/* 821F29C4h case    0:*/		return 0x821F29C8;
		  /* 821F29C8h */ case    1:  		/* rlwinm R5, R11, 15, 17, 31 */
		/* 821F29C8h case    1:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R5,regs.R11);
		/* 821F29C8h case    1:*/		return 0x821F29CC;
		  /* 821F29CCh */ case    2:  		/* mr R4, R28 */
		/* 821F29CCh case    2:*/		regs.R4 = regs.R28;
		/* 821F29CCh case    2:*/		return 0x821F29D0;
		  /* 821F29D0h */ case    3:  		/* addi R3, R1, 88 */
		/* 821F29D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 821F29D0h case    3:*/		return 0x821F29D4;
		  /* 821F29D4h */ case    4:  		/* bl 231748 */
		/* 821F29D4h case    4:*/		regs.LR = 0x821F29D8; return 0x8222B318;
		/* 821F29D4h case    4:*/		return 0x821F29D8;
	}
	return 0x821F29D8;
} // Block from 821F29C4h-821F29D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F29D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F29D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F29D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F29D8);
		  /* 821F29D8h */ case    0:  		/* ld R10, <#[R3]> */
		/* 821F29D8h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F29D8h case    0:*/		return 0x821F29DC;
	}
	return 0x821F29DC;
} // Block from 821F29D8h-821F29DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F29DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F29DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F29DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F29DC);
		  /* 821F29DCh */ case    0:  		/* std R10, <#[R27]> */
		/* 821F29DCh case    0:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821F29DCh case    0:*/		return 0x821F29E0;
	}
	return 0x821F29E0;
} // Block from 821F29DCh-821F29E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F29E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F29E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F29E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F29E0);
		  /* 821F29E0h */ case    0:  		/* addi R1, R1, 144 */
		/* 821F29E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821F29E0h case    0:*/		return 0x821F29E4;
		  /* 821F29E4h */ case    1:  		/* b -1447744 */
		/* 821F29E4h case    1:*/		return 0x820912A4;
		/* 821F29E4h case    1:*/		return 0x821F29E8;
	}
	return 0x821F29E8;
} // Block from 821F29E0h-821F29E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F29E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F29E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F29E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F29E8);
		  /* 821F29E8h */ case    0:  		/* mfspr R12, LR */
		/* 821F29E8h case    0:*/		regs.R12 = regs.LR;
		/* 821F29E8h case    0:*/		return 0x821F29EC;
		  /* 821F29ECh */ case    1:  		/* bl -1447824 */
		/* 821F29ECh case    1:*/		regs.LR = 0x821F29F0; return 0x8209125C;
		/* 821F29ECh case    1:*/		return 0x821F29F0;
		  /* 821F29F0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F29F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F29F0h case    2:*/		return 0x821F29F4;
		  /* 821F29F4h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F29F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F29F4h case    3:*/		return 0x821F29F8;
		  /* 821F29F8h */ case    4:  		/* lwz R31, <#[R3]> */
		/* 821F29F8h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 821F29F8h case    4:*/		return 0x821F29FC;
		  /* 821F29FCh */ case    5:  		/* mullw R11, R11, R4 */
		/* 821F29FCh case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821F29FCh case    5:*/		return 0x821F2A00;
		  /* 821F2A00h */ case    6:  		/* lwz R30, <#[R31 + 4]> */
		/* 821F2A00h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2A00h case    6:*/		return 0x821F2A04;
		  /* 821F2A04h */ case    7:  		/* lwz R29, <#[R31 + 8]> */
		/* 821F2A04h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2A04h case    7:*/		return 0x821F2A08;
		  /* 821F2A08h */ case    8:  		/* add R4, R11, R5 */
		/* 821F2A08h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R5);
		/* 821F2A08h case    8:*/		return 0x821F2A0C;
		  /* 821F2A0Ch */ case    9:  		/* mr R3, R31 */
		/* 821F2A0Ch case    9:*/		regs.R3 = regs.R31;
		/* 821F2A0Ch case    9:*/		return 0x821F2A10;
		  /* 821F2A10h */ case   10:  		/* bl -19480 */
		/* 821F2A10h case   10:*/		regs.LR = 0x821F2A14; return 0x821EDDF8;
		/* 821F2A10h case   10:*/		return 0x821F2A14;
		  /* 821F2A14h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 821F2A14h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2A14h case   11:*/		return 0x821F2A18;
		  /* 821F2A18h */ case   12:  		/* lwz R10, <#[R31 + 4]> */
		/* 821F2A18h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2A18h case   12:*/		return 0x821F2A1C;
		  /* 821F2A1Ch */ case   13:  		/* addi R11, R11, 2 */
		/* 821F2A1Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F2A1Ch case   13:*/		return 0x821F2A20;
		  /* 821F2A20h */ case   14:  		/* stw R30, <#[R31 + 4]> */
		/* 821F2A20h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2A20h case   14:*/		return 0x821F2A24;
		  /* 821F2A24h */ case   15:  		/* stw R29, <#[R31 + 8]> */
		/* 821F2A24h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2A24h case   15:*/		return 0x821F2A28;
		  /* 821F2A28h */ case   16:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 821F2A28h case   16:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 821F2A28h case   16:*/		return 0x821F2A2C;
		  /* 821F2A2Ch */ case   17:  		/* add R3, R11, R10 */
		/* 821F2A2Ch case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 821F2A2Ch case   17:*/		return 0x821F2A30;
	}
	return 0x821F2A30;
} // Block from 821F29E8h-821F2A30h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F2A30h
// Function '?ImportASMLiteralsCallback@Compiler@D3DXShader@@CAJPAXKKKPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2A30);
		  /* 821F2A30h */ case    0:  		/* addi R1, R1, 112 */
		/* 821F2A30h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F2A30h case    0:*/		return 0x821F2A34;
		  /* 821F2A34h */ case    1:  		/* b -1447816 */
		/* 821F2A34h case    1:*/		return 0x820912AC;
		/* 821F2A34h case    1:*/		return 0x821F2A38;
	}
	return 0x821F2A38;
} // Block from 821F2A30h-821F2A38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2A38);
		  /* 821F2A38h */ case    0:  		/* mfspr R12, LR */
		/* 821F2A38h case    0:*/		regs.R12 = regs.LR;
		/* 821F2A38h case    0:*/		return 0x821F2A3C;
		  /* 821F2A3Ch */ case    1:  		/* bl -1447912 */
		/* 821F2A3Ch case    1:*/		regs.LR = 0x821F2A40; return 0x82091254;
		/* 821F2A3Ch case    1:*/		return 0x821F2A40;
		  /* 821F2A40h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821F2A40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821F2A40h case    2:*/		return 0x821F2A44;
		  /* 821F2A44h */ case    3:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F2A44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F2A44h case    3:*/		return 0x821F2A48;
		  /* 821F2A48h */ case    4:  		/* mr R31, R3 */
		/* 821F2A48h case    4:*/		regs.R31 = regs.R3;
		/* 821F2A48h case    4:*/		return 0x821F2A4C;
		  /* 821F2A4Ch */ case    5:  		/* lwz R11, <#[R10 + 8]> */
		/* 821F2A4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821F2A4Ch case    5:*/		return 0x821F2A50;
		  /* 821F2A50h */ case    6:  		/* addic. R11, R11, -1 */
		/* 821F2A50h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F2A50h case    6:*/		return 0x821F2A54;
		  /* 821F2A54h */ case    7:  		/* stw R11, <#[R10 + 8]> */
		/* 821F2A54h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821F2A54h case    7:*/		return 0x821F2A58;
		  /* 821F2A58h */ case    8:  		/* bc 4, CR0_EQ, 252 */
		/* 821F2A58h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821F2B54;  }
		/* 821F2A58h case    8:*/		return 0x821F2A5C;
		  /* 821F2A5Ch */ case    9:  		/* addi R11, R1, 84 */
		/* 821F2A5Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 821F2A5Ch case    9:*/		return 0x821F2A60;
		  /* 821F2A60h */ case   10:  		/* lwz R10, <#[R3 + 8]> */
		/* 821F2A60h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821F2A60h case   10:*/		return 0x821F2A64;
		  /* 821F2A64h */ case   11:  		/* li R27, 0 */
		/* 821F2A64h case   11:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821F2A64h case   11:*/		return 0x821F2A68;
		  /* 821F2A68h */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 821F2A68h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F2A68h case   12:*/		return 0x821F2A6C;
		  /* 821F2A6Ch */ case   13:  		/* stw R27, <#[R1 + 80]> */
		/* 821F2A6Ch case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2A6Ch case   13:*/		return 0x821F2A70;
		  /* 821F2A70h */ case   14:  		/* stw R27, <#[R11]> */
		/* 821F2A70h case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2A70h case   14:*/		return 0x821F2A74;
		  /* 821F2A74h */ case   15:  		/* bc 4, CR6_EQ, 44 */
		/* 821F2A74h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821F2AA0;  }
		/* 821F2A74h case   15:*/		return 0x821F2A78;
		  /* 821F2A78h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 821F2A78h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2A78h case   16:*/		return 0x821F2A7C;
		  /* 821F2A7Ch */ case   17:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F2A7Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F2A7Ch case   17:*/		return 0x821F2A80;
		  /* 821F2A80h */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F2A80h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2A80h case   18:*/		return 0x821F2A84;
		  /* 821F2A84h */ case   19:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821F2A84h case   19:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821F2A84h case   19:*/		return 0x821F2A88;
		  /* 821F2A88h */ case   20:  		/* addic R9, R9, -1 */
		/* 821F2A88h case   20:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821F2A88h case   20:*/		return 0x821F2A8C;
		  /* 821F2A8Ch */ case   21:  		/* subfe R9, R9, R9 */
		/* 821F2A8Ch case   21:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821F2A8Ch case   21:*/		return 0x821F2A90;
		  /* 821F2A90h */ case   22:  		/* and R11, R9, R11 */
		/* 821F2A90h case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F2A90h case   22:*/		return 0x821F2A94;
		  /* 821F2A94h */ case   23:  		/* cmplw CR6, R10, R11 */
		/* 821F2A94h case   23:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F2A94h case   23:*/		return 0x821F2A98;
		  /* 821F2A98h */ case   24:  		/* li R11, 1 */
		/* 821F2A98h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F2A98h case   24:*/		return 0x821F2A9C;
		  /* 821F2A9Ch */ case   25:  		/* bc 12, CR6_EQ, 8 */
		/* 821F2A9Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x821F2AA4;  }
		/* 821F2A9Ch case   25:*/		return 0x821F2AA0;
	}
	return 0x821F2AA0;
} // Block from 821F2A38h-821F2AA0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821F2AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2AA0);
		  /* 821F2AA0h */ case    0:  		/* mr R11, R27 */
		/* 821F2AA0h case    0:*/		regs.R11 = regs.R27;
		/* 821F2AA0h case    0:*/		return 0x821F2AA4;
	}
	return 0x821F2AA4;
} // Block from 821F2AA0h-821F2AA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2AA4);
		  /* 821F2AA4h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821F2AA4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821F2AA4h case    0:*/		return 0x821F2AA8;
		  /* 821F2AA8h */ case    1:  		/* cntlzw R11, R11 */
		/* 821F2AA8h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821F2AA8h case    1:*/		return 0x821F2AAC;
		  /* 821F2AACh */ case    2:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 821F2AACh case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821F2AACh case    2:*/		return 0x821F2AB0;
		  /* 821F2AB0h */ case    3:  		/* mr R28, R11 */
		/* 821F2AB0h case    3:*/		regs.R28 = regs.R11;
		/* 821F2AB0h case    3:*/		return 0x821F2AB4;
		  /* 821F2AB4h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 821F2AB4h case    4:*/		if ( regs.CR[0].eq ) { return 0x821F2AD4;  }
		/* 821F2AB4h case    4:*/		return 0x821F2AB8;
		  /* 821F2AB8h */ case    5:  		/* mr R3, R31 */
		/* 821F2AB8h case    5:*/		regs.R3 = regs.R31;
		/* 821F2AB8h case    5:*/		return 0x821F2ABC;
		  /* 821F2ABCh */ case    6:  		/* bl -343140 */
		/* 821F2ABCh case    6:*/		regs.LR = 0x821F2AC0; return 0x8219EE58;
		/* 821F2ABCh case    6:*/		return 0x821F2AC0;
		  /* 821F2AC0h */ case    7:  		/* mr R3, R31 */
		/* 821F2AC0h case    7:*/		regs.R3 = regs.R31;
		/* 821F2AC0h case    7:*/		return 0x821F2AC4;
		  /* 821F2AC4h */ case    8:  		/* lwz R29, <#[R31 + 4]> */
		/* 821F2AC4h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2AC4h case    8:*/		return 0x821F2AC8;
		  /* 821F2AC8h */ case    9:  		/* lwz R30, <#[R31 + 8]> */
		/* 821F2AC8h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2AC8h case    9:*/		return 0x821F2ACC;
		  /* 821F2ACCh */ case   10:  		/* bl -203884 */
		/* 821F2ACCh case   10:*/		regs.LR = 0x821F2AD0; return 0x821C0E60;
		/* 821F2ACCh case   10:*/		return 0x821F2AD0;
		  /* 821F2AD0h */ case   11:  		/* b 12 */
		/* 821F2AD0h case   11:*/		return 0x821F2ADC;
		/* 821F2AD0h case   11:*/		return 0x821F2AD4;
	}
	return 0x821F2AD4;
} // Block from 821F2AA4h-821F2AD4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F2AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2AD4);
		  /* 821F2AD4h */ case    0:  		/* lwz R30, <#[R1 + 84]> */
		/* 821F2AD4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 821F2AD4h case    0:*/		return 0x821F2AD8;
		  /* 821F2AD8h */ case    1:  		/* lwz R29, <#[R1 + 80]> */
		/* 821F2AD8h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821F2AD8h case    1:*/		return 0x821F2ADC;
	}
	return 0x821F2ADC;
} // Block from 821F2AD4h-821F2ADCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2ADC);
		  /* 821F2ADCh */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 821F2ADCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2ADCh case    0:*/		return 0x821F2AE0;
		  /* 821F2AE0h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F2AE0h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F2AE0h case    1:*/		return 0x821F2AE4;
		  /* 821F2AE4h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F2AE4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2AE4h case    2:*/		return 0x821F2AE8;
		  /* 821F2AE8h */ case    3:  		/* lwz R9, <#[R11]> */
		/* 821F2AE8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2AE8h case    3:*/		return 0x821F2AEC;
		  /* 821F2AECh */ case    4:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F2AECh case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F2AECh case    4:*/		return 0x821F2AF0;
		  /* 821F2AF0h */ case    5:  		/* stw R9, <#[R10]> */
		/* 821F2AF0h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2AF0h case    5:*/		return 0x821F2AF4;
		  /* 821F2AF4h */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F2AF4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2AF4h case    6:*/		return 0x821F2AF8;
		  /* 821F2AF8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 821F2AF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2AF8h case    7:*/		return 0x821F2AFC;
		  /* 821F2AFCh */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F2AFCh case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F2AFCh case    8:*/		return 0x821F2B00;
		  /* 821F2B00h */ case    9:  		/* stw R10, <#[R11]> */
		/* 821F2B00h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2B00h case    9:*/		return 0x821F2B04;
		  /* 821F2B04h */ case   10:  		/* lwz R3, <#[R31 + 4]> */
		/* 821F2B04h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2B04h case   10:*/		return 0x821F2B08;
		  /* 821F2B08h */ case   11:  		/* mr R4, R3 */
		/* 821F2B08h case   11:*/		regs.R4 = regs.R3;
		/* 821F2B08h case   11:*/		return 0x821F2B0C;
		  /* 821F2B0Ch */ case   12:  		/* lwz R11, <#[R3 + 12]> */
		/* 821F2B0Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821F2B0Ch case   12:*/		return 0x821F2B10;
		  /* 821F2B10h */ case   13:  		/* addi R11, R11, 2 */
		/* 821F2B10h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F2B10h case   13:*/		return 0x821F2B14;
		  /* 821F2B14h */ case   14:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F2B14h case   14:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F2B14h case   14:*/		return 0x821F2B18;
		  /* 821F2B18h */ case   15:  		/* bl -658704 */
		/* 821F2B18h case   15:*/		regs.LR = 0x821F2B1C; return 0x82151E08;
		/* 821F2B18h case   15:*/		return 0x821F2B1C;
		  /* 821F2B1Ch */ case   16:  		/* cmplwi CR6, R28, 0 */
		/* 821F2B1Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821F2B1Ch case   16:*/		return 0x821F2B20;
		  /* 821F2B20h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 821F2B20h case   17:*/		if ( regs.CR[6].eq ) { return 0x821F2B30;  }
		/* 821F2B20h case   17:*/		return 0x821F2B24;
		  /* 821F2B24h */ case   18:  		/* stw R29, <#[R31 + 4]> */
		/* 821F2B24h case   18:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2B24h case   18:*/		return 0x821F2B28;
		  /* 821F2B28h */ case   19:  		/* stw R30, <#[R31 + 8]> */
		/* 821F2B28h case   19:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2B28h case   19:*/		return 0x821F2B2C;
		  /* 821F2B2Ch */ case   20:  		/* b 88 */
		/* 821F2B2Ch case   20:*/		return 0x821F2B84;
		/* 821F2B2Ch case   20:*/		return 0x821F2B30;
	}
	return 0x821F2B30;
} // Block from 821F2ADCh-821F2B30h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F2B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2B30);
		  /* 821F2B30h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821F2B30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821F2B30h case    0:*/		return 0x821F2B34;
		  /* 821F2B34h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F2B34h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2B34h case    1:*/		return 0x821F2B38;
		  /* 821F2B38h */ case    2:  		/* stw R27, <#[R31 + 8]> */
		/* 821F2B38h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2B38h case    2:*/		return 0x821F2B3C;
		  /* 821F2B3Ch */ case    3:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821F2B3Ch case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821F2B3Ch case    3:*/		return 0x821F2B40;
		  /* 821F2B40h */ case    4:  		/* addic R10, R10, -1 */
		/* 821F2B40h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821F2B40h case    4:*/		return 0x821F2B44;
		  /* 821F2B44h */ case    5:  		/* subfe R10, R10, R10 */
		/* 821F2B44h case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821F2B44h case    5:*/		return 0x821F2B48;
		  /* 821F2B48h */ case    6:  		/* and R11, R10, R11 */
		/* 821F2B48h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F2B48h case    6:*/		return 0x821F2B4C;
		  /* 821F2B4Ch */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 821F2B4Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2B4Ch case    7:*/		return 0x821F2B50;
		  /* 821F2B50h */ case    8:  		/* b 52 */
		/* 821F2B50h case    8:*/		return 0x821F2B84;
		/* 821F2B50h case    8:*/		return 0x821F2B54;
	}
	return 0x821F2B54;
} // Block from 821F2B30h-821F2B54h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F2B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2B54);
		  /* 821F2B54h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 821F2B54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821F2B54h case    0:*/		return 0x821F2B58;
		  /* 821F2B58h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 821F2B58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2B58h case    1:*/		return 0x821F2B5C;
		  /* 821F2B5Ch */ case    2:  		/* addi R9, R11, 3 */
		/* 821F2B5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 821F2B5Ch case    2:*/		return 0x821F2B60;
		  /* 821F2B60h */ case    3:  		/* addi R8, R11, 2 */
		/* 821F2B60h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x2);
		/* 821F2B60h case    3:*/		return 0x821F2B64;
		  /* 821F2B64h */ case    4:  		/* lwz R7, <#[R10 + 8]> */
		/* 821F2B64h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000008) );
		/* 821F2B64h case    4:*/		return 0x821F2B68;
		  /* 821F2B68h */ case    5:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 821F2B68h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 821F2B68h case    5:*/		return 0x821F2B6C;
		  /* 821F2B6Ch */ case    6:  		/* rlwinm R8, R8, 3, 0, 28 */
		/* 821F2B6Ch case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R8);
		/* 821F2B6Ch case    6:*/		return 0x821F2B70;
		  /* 821F2B70h */ case    7:  		/* subf R11, R11, R7 */
		/* 821F2B70h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821F2B70h case    7:*/		return 0x821F2B74;
		  /* 821F2B74h */ case    8:  		/* add R4, R9, R10 */
		/* 821F2B74h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R10);
		/* 821F2B74h case    8:*/		return 0x821F2B78;
		  /* 821F2B78h */ case    9:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F2B78h case    9:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F2B78h case    9:*/		return 0x821F2B7C;
		  /* 821F2B7Ch */ case   10:  		/* add R3, R8, R10 */
		/* 821F2B7Ch case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R8,regs.R10);
		/* 821F2B7Ch case   10:*/		return 0x821F2B80;
		  /* 821F2B80h */ case   11:  		/* bl -1444960 */
		/* 821F2B80h case   11:*/		regs.LR = 0x821F2B84; return 0x82091F20;
		/* 821F2B80h case   11:*/		return 0x821F2B84;
	}
	return 0x821F2B84;
} // Block from 821F2B54h-821F2B84h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F2B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2B84);
		  /* 821F2B84h */ case    0:  		/* addi R1, R1, 144 */
		/* 821F2B84h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821F2B84h case    0:*/		return 0x821F2B88;
		  /* 821F2B88h */ case    1:  		/* b -1448164 */
		/* 821F2B88h case    1:*/		return 0x820912A4;
		/* 821F2B88h case    1:*/		return 0x821F2B8C;
		  /* 821F2B8Ch */ case    2:  		/* nop */
		/* 821F2B8Ch case    2:*/		cpu::op::nop();
		/* 821F2B8Ch case    2:*/		return 0x821F2B90;
	}
	return 0x821F2B90;
} // Block from 821F2B84h-821F2B90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F2B90h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2B90);
		  /* 821F2B90h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F2B90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F2B90h case    0:*/		return 0x821F2B94;
		  /* 821F2B94h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F2B94h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F2B94h case    1:*/		return 0x821F2B98;
		  /* 821F2B98h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 821F2B98h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F2BC4;  }
		/* 821F2B98h case    2:*/		return 0x821F2B9C;
		  /* 821F2B9Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821F2B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2B9Ch case    3:*/		return 0x821F2BA0;
		  /* 821F2BA0h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F2BA0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F2BA0h case    4:*/		return 0x821F2BA4;
		  /* 821F2BA4h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F2BA4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2BA4h case    5:*/		return 0x821F2BA8;
		  /* 821F2BA8h */ case    6:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821F2BA8h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821F2BA8h case    6:*/		return 0x821F2BAC;
		  /* 821F2BACh */ case    7:  		/* addic R9, R9, -1 */
		/* 821F2BACh case    7:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821F2BACh case    7:*/		return 0x821F2BB0;
		  /* 821F2BB0h */ case    8:  		/* subfe R9, R9, R9 */
		/* 821F2BB0h case    8:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821F2BB0h case    8:*/		return 0x821F2BB4;
		  /* 821F2BB4h */ case    9:  		/* and R11, R9, R11 */
		/* 821F2BB4h case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F2BB4h case    9:*/		return 0x821F2BB8;
		  /* 821F2BB8h */ case   10:  		/* cmplw CR6, R10, R11 */
		/* 821F2BB8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F2BB8h case   10:*/		return 0x821F2BBC;
		  /* 821F2BBCh */ case   11:  		/* li R11, 1 */
		/* 821F2BBCh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821F2BBCh case   11:*/		return 0x821F2BC0;
		  /* 821F2BC0h */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 821F2BC0h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F2BC8;  }
		/* 821F2BC0h case   12:*/		return 0x821F2BC4;
	}
	return 0x821F2BC4;
} // Block from 821F2B90h-821F2BC4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821F2BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2BC4);
		  /* 821F2BC4h */ case    0:  		/* li R11, 0 */
		/* 821F2BC4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F2BC4h case    0:*/		return 0x821F2BC8;
	}
	return 0x821F2BC8;
} // Block from 821F2BC4h-821F2BC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2BC8);
		  /* 821F2BC8h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821F2BC8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821F2BC8h case    0:*/		return 0x821F2BCC;
		  /* 821F2BCCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 821F2BCCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F2BCCh case    1:*/		return 0x821F2BD0;
	}
	return 0x821F2BD0;
} // Block from 821F2BC8h-821F2BD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2BD0);
		  /* 821F2BD0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F2BD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F2BD0h case    0:*/		return 0x821F2BD4;
		  /* 821F2BD4h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F2BD4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2BD4h case    1:*/		return 0x821F2BD8;
		  /* 821F2BD8h */ case    2:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821F2BD8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821F2BD8h case    2:*/		return 0x821F2BDC;
		  /* 821F2BDCh */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821F2BDCh case    3:*/		if ( regs.CR[0].eq ) { return 0x821F2BE8;  }
		/* 821F2BDCh case    3:*/		return 0x821F2BE0;
		  /* 821F2BE0h */ case    4:  		/* li R11, 0 */
		/* 821F2BE0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F2BE0h case    4:*/		return 0x821F2BE4;
		  /* 821F2BE4h */ case    5:  		/* b 16 */
		/* 821F2BE4h case    5:*/		return 0x821F2BF4;
		/* 821F2BE4h case    5:*/		return 0x821F2BE8;
	}
	return 0x821F2BE8;
} // Block from 821F2BD0h-821F2BE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F2BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2BE8);
		  /* 821F2BE8h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821F2BE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2BE8h case    0:*/		return 0x821F2BEC;
		  /* 821F2BECh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F2BECh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F2BECh case    1:*/		return 0x821F2BF0;
		  /* 821F2BF0h */ case    2:  		/* addi R11, R11, -4 */
		/* 821F2BF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F2BF0h case    2:*/		return 0x821F2BF4;
	}
	return 0x821F2BF4;
} // Block from 821F2BE8h-821F2BF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F2BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2BF4);
		  /* 821F2BF4h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 821F2BF4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F2BF4h case    0:*/		return 0x821F2BF8;
		  /* 821F2BF8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F2BF8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F2BF8h case    1:*/		return 0x821F2BFC;
		  /* 821F2BFCh */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 821F2BFCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821F2C08;  }
		/* 821F2BFCh case    2:*/		return 0x821F2C00;
		  /* 821F2C00h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 821F2C00h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821F2C00h case    3:*/		return 0x821F2C04;
		  /* 821F2C04h */ case    4:  		/* b 8 */
		/* 821F2C04h case    4:*/		return 0x821F2C0C;
		/* 821F2C04h case    4:*/		return 0x821F2C08;
	}
	return 0x821F2C08;
} // Block from 821F2BF4h-821F2C08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C08);
		  /* 821F2C08h */ case    0:  		/* li R11, 0 */
		/* 821F2C08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F2C08h case    0:*/		return 0x821F2C0C;
	}
	return 0x821F2C0C;
} // Block from 821F2C08h-821F2C0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C0C);
		  /* 821F2C0Ch */ case    0:  		/* stw R11, <#[R3 + 8]> */
		/* 821F2C0Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F2C0Ch case    0:*/		return 0x821F2C10;
		  /* 821F2C10h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821F2C10h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F2C10h case    1:*/		return 0x821F2C14;
	}
	return 0x821F2C14;
} // Block from 821F2C0Ch-821F2C14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C14);
		  /* 821F2C14h */ case    0:  		/* nop */
		/* 821F2C14h case    0:*/		cpu::op::nop();
		/* 821F2C14h case    0:*/		return 0x821F2C18;
	}
	return 0x821F2C18;
} // Block from 821F2C14h-821F2C18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C18);
		  /* 821F2C18h */ case    0:  		/* mfspr R12, LR */
		/* 821F2C18h case    0:*/		regs.R12 = regs.LR;
		/* 821F2C18h case    0:*/		return 0x821F2C1C;
		  /* 821F2C1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F2C1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2C1Ch case    1:*/		return 0x821F2C20;
		  /* 821F2C20h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F2C20h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2C20h case    2:*/		return 0x821F2C24;
		  /* 821F2C24h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F2C24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F2C24h case    3:*/		return 0x821F2C28;
		  /* 821F2C28h */ case    4:  		/* std R4, <#[R1 + 120]> */
		/* 821F2C28h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000078) );
		/* 821F2C28h case    4:*/		return 0x821F2C2C;
		  /* 821F2C2Ch */ case    5:  		/* addi R4, R1, 120 */
		/* 821F2C2Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x78);
		/* 821F2C2Ch case    5:*/		return 0x821F2C30;
	}
	return 0x821F2C30;
} // Block from 821F2C18h-821F2C30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C30h
// Function '?GetInstructionFromResult@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C30);
		  /* 821F2C30h */ case    0:  		/* bl -2224 */
		/* 821F2C30h case    0:*/		regs.LR = 0x821F2C34; return 0x821F2380;
		/* 821F2C30h case    0:*/		return 0x821F2C34;
		  /* 821F2C34h */ case    1:  		/* li R4, 4 */
		/* 821F2C34h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 821F2C34h case    1:*/		return 0x821F2C38;
		  /* 821F2C38h */ case    2:  		/* mr R31, R3 */
		/* 821F2C38h case    2:*/		regs.R31 = regs.R3;
		/* 821F2C38h case    2:*/		return 0x821F2C3C;
		  /* 821F2C3Ch */ case    3:  		/* bl -504188 */
		/* 821F2C3Ch case    3:*/		regs.LR = 0x821F2C40; return 0x82177AC0;
		/* 821F2C3Ch case    3:*/		return 0x821F2C40;
		  /* 821F2C40h */ case    4:  		/* mr R3, R31 */
		/* 821F2C40h case    4:*/		regs.R3 = regs.R31;
		/* 821F2C40h case    4:*/		return 0x821F2C44;
		  /* 821F2C44h */ case    5:  		/* addi R1, R1, 96 */
		/* 821F2C44h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F2C44h case    5:*/		return 0x821F2C48;
		  /* 821F2C48h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F2C48h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2C48h case    6:*/		return 0x821F2C4C;
		  /* 821F2C4Ch */ case    7:  		/* mtspr LR, R12 */
		/* 821F2C4Ch case    7:*/		regs.LR = regs.R12;
		/* 821F2C4Ch case    7:*/		return 0x821F2C50;
		  /* 821F2C50h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 821F2C50h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2C50h case    8:*/		return 0x821F2C54;
		  /* 821F2C54h */ case    9:  		/* bclr 20, CR0_LT */
		/* 821F2C54h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F2C54h case    9:*/		return 0x821F2C58;
	}
	return 0x821F2C58;
} // Block from 821F2C30h-821F2C58h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C58);
		  /* 821F2C58h */ case    0:  		/* mfspr R12, LR */
		/* 821F2C58h case    0:*/		regs.R12 = regs.LR;
		/* 821F2C58h case    0:*/		return 0x821F2C5C;
		  /* 821F2C5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F2C5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2C5Ch case    1:*/		return 0x821F2C60;
		  /* 821F2C60h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F2C60h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2C60h case    2:*/		return 0x821F2C64;
		  /* 821F2C64h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F2C64h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F2C64h case    3:*/		return 0x821F2C68;
		  /* 821F2C68h */ case    4:  		/* std R4, <#[R1 + 120]> */
		/* 821F2C68h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000078) );
		/* 821F2C68h case    4:*/		return 0x821F2C6C;
		  /* 821F2C6Ch */ case    5:  		/* addi R4, R1, 120 */
		/* 821F2C6Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x78);
		/* 821F2C6Ch case    5:*/		return 0x821F2C70;
		  /* 821F2C70h */ case    6:  		/* bl -2288 */
		/* 821F2C70h case    6:*/		regs.LR = 0x821F2C74; return 0x821F2380;
		/* 821F2C70h case    6:*/		return 0x821F2C74;
		  /* 821F2C74h */ case    7:  		/* li R4, 2 */
		/* 821F2C74h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 821F2C74h case    7:*/		return 0x821F2C78;
		  /* 821F2C78h */ case    8:  		/* mr R31, R3 */
		/* 821F2C78h case    8:*/		regs.R31 = regs.R3;
		/* 821F2C78h case    8:*/		return 0x821F2C7C;
		  /* 821F2C7Ch */ case    9:  		/* bl -504252 */
		/* 821F2C7Ch case    9:*/		regs.LR = 0x821F2C80; return 0x82177AC0;
		/* 821F2C7Ch case    9:*/		return 0x821F2C80;
		  /* 821F2C80h */ case   10:  		/* mr R3, R31 */
		/* 821F2C80h case   10:*/		regs.R3 = regs.R31;
		/* 821F2C80h case   10:*/		return 0x821F2C84;
		  /* 821F2C84h */ case   11:  		/* addi R1, R1, 96 */
		/* 821F2C84h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F2C84h case   11:*/		return 0x821F2C88;
		  /* 821F2C88h */ case   12:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F2C88h case   12:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2C88h case   12:*/		return 0x821F2C8C;
		  /* 821F2C8Ch */ case   13:  		/* mtspr LR, R12 */
		/* 821F2C8Ch case   13:*/		regs.LR = regs.R12;
		/* 821F2C8Ch case   13:*/		return 0x821F2C90;
		  /* 821F2C90h */ case   14:  		/* ld R31, <#[R1 - 16]> */
		/* 821F2C90h case   14:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2C90h case   14:*/		return 0x821F2C94;
		  /* 821F2C94h */ case   15:  		/* bclr 20, CR0_LT */
		/* 821F2C94h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F2C94h case   15:*/		return 0x821F2C98;
	}
	return 0x821F2C98;
} // Block from 821F2C58h-821F2C98h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F2C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2C98);
		  /* 821F2C98h */ case    0:  		/* mfspr R12, LR */
		/* 821F2C98h case    0:*/		regs.R12 = regs.LR;
		/* 821F2C98h case    0:*/		return 0x821F2C9C;
		  /* 821F2C9Ch */ case    1:  		/* bl -1448512 */
		/* 821F2C9Ch case    1:*/		regs.LR = 0x821F2CA0; return 0x8209125C;
		/* 821F2C9Ch case    1:*/		return 0x821F2CA0;
		  /* 821F2CA0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F2CA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F2CA0h case    2:*/		return 0x821F2CA4;
		  /* 821F2CA4h */ case    3:  		/* mr R29, R5 */
		/* 821F2CA4h case    3:*/		regs.R29 = regs.R5;
		/* 821F2CA4h case    3:*/		return 0x821F2CA8;
		  /* 821F2CA8h */ case    4:  		/* std R4, <#[R1 + 136]> */
		/* 821F2CA8h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F2CA8h case    4:*/		return 0x821F2CAC;
		  /* 821F2CACh */ case    5:  		/* li R8, 4 */
		/* 821F2CACh case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F2CACh case    5:*/		return 0x821F2CB0;
		  /* 821F2CB0h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F2CB0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F2CB0h case    6:*/		return 0x821F2CB4;
		  /* 821F2CB4h */ case    7:  		/* li R7, 2 */
		/* 821F2CB4h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F2CB4h case    7:*/		return 0x821F2CB8;
		  /* 821F2CB8h */ case    8:  		/* li R6, 1 */
		/* 821F2CB8h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F2CB8h case    8:*/		return 0x821F2CBC;
		  /* 821F2CBCh */ case    9:  		/* li R5, 0 */
		/* 821F2CBCh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F2CBCh case    9:*/		return 0x821F2CC0;
		  /* 821F2CC0h */ case   10:  		/* mr R30, R3 */
		/* 821F2CC0h case   10:*/		regs.R30 = regs.R3;
		/* 821F2CC0h case   10:*/		return 0x821F2CC4;
		  /* 821F2CC4h */ case   11:  		/* bl 203988 */
		/* 821F2CC4h case   11:*/		regs.LR = 0x821F2CC8; return 0x82224998;
		/* 821F2CC4h case   11:*/		return 0x821F2CC8;
		  /* 821F2CC8h */ case   12:  		/* mr R31, R3 */
		/* 821F2CC8h case   12:*/		regs.R31 = regs.R3;
		/* 821F2CC8h case   12:*/		return 0x821F2CCC;
		  /* 821F2CCCh */ case   13:  		/* addi R4, R1, 136 */
		/* 821F2CCCh case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F2CCCh case   13:*/		return 0x821F2CD0;
		  /* 821F2CD0h */ case   14:  		/* mr R3, R30 */
		/* 821F2CD0h case   14:*/		regs.R3 = regs.R30;
		/* 821F2CD0h case   14:*/		return 0x821F2CD4;
		  /* 821F2CD4h */ case   15:  		/* bl -2388 */
		/* 821F2CD4h case   15:*/		regs.LR = 0x821F2CD8; return 0x821F2380;
		/* 821F2CD4h case   15:*/		return 0x821F2CD8;
		  /* 821F2CD8h */ case   16:  		/* mr R4, R3 */
		/* 821F2CD8h case   16:*/		regs.R4 = regs.R3;
		/* 821F2CD8h case   16:*/		return 0x821F2CDC;
		  /* 821F2CDCh */ case   17:  		/* mr R3, R31 */
		/* 821F2CDCh case   17:*/		regs.R3 = regs.R31;
		/* 821F2CDCh case   17:*/		return 0x821F2CE0;
		  /* 821F2CE0h */ case   18:  		/* bl -502552 */
		/* 821F2CE0h case   18:*/		regs.LR = 0x821F2CE4; return 0x821781C8;
		/* 821F2CE0h case   18:*/		return 0x821F2CE4;
		  /* 821F2CE4h */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 821F2CE4h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F2CE4h case   19:*/		return 0x821F2CE8;
		  /* 821F2CE8h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F2CE8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F2CE8h case   20:*/		return 0x821F2CEC;
		  /* 821F2CECh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821F2CECh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F2CECh case   21:*/		return 0x821F2CF0;
		  /* 821F2CF0h */ case   22:  		/* mr R4, R29 */
		/* 821F2CF0h case   22:*/		regs.R4 = regs.R29;
		/* 821F2CF0h case   22:*/		return 0x821F2CF4;
		  /* 821F2CF4h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821F2CF4h case   23:*/		if ( regs.CR[6].eq ) { return 0x821F2D08;  }
		/* 821F2CF4h case   23:*/		return 0x821F2CF8;
		  /* 821F2CF8h */ case   24:  		/* mr R3, R30 */
		/* 821F2CF8h case   24:*/		regs.R3 = regs.R30;
		/* 821F2CF8h case   24:*/		return 0x821F2CFC;
		  /* 821F2CFCh */ case   25:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F2CFCh case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F2CFCh case   25:*/		return 0x821F2D00;
		  /* 821F2D00h */ case   26:  		/* bl -531472 */
		/* 821F2D00h case   26:*/		regs.LR = 0x821F2D04; return 0x821710F0;
		/* 821F2D00h case   26:*/		return 0x821F2D04;
		  /* 821F2D04h */ case   27:  		/* mr R4, R3 */
		/* 821F2D04h case   27:*/		regs.R4 = regs.R3;
		/* 821F2D04h case   27:*/		return 0x821F2D08;
	}
	return 0x821F2D08;
} // Block from 821F2C98h-821F2D08h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F2D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2D08);
		  /* 821F2D08h */ case    0:  		/* mr R3, R31 */
		/* 821F2D08h case    0:*/		regs.R3 = regs.R31;
		/* 821F2D08h case    0:*/		return 0x821F2D0C;
		  /* 821F2D0Ch */ case    1:  		/* bl -502596 */
		/* 821F2D0Ch case    1:*/		regs.LR = 0x821F2D10; return 0x821781C8;
		/* 821F2D0Ch case    1:*/		return 0x821F2D10;
		  /* 821F2D10h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F2D10h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F2D10h case    2:*/		return 0x821F2D14;
		  /* 821F2D14h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821F2D14h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F2D14h case    3:*/		return 0x821F2D18;
		  /* 821F2D18h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F2D18h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F2D18h case    4:*/		return 0x821F2D1C;
		  /* 821F2D1Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F2D1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2D1Ch case    5:*/		return 0x821F2D20;
		  /* 821F2D20h */ case    6:  		/* mr R3, R31 */
		/* 821F2D20h case    6:*/		regs.R3 = regs.R31;
		/* 821F2D20h case    6:*/		return 0x821F2D24;
		  /* 821F2D24h */ case    7:  		/* addi R11, R11, 36 */
		/* 821F2D24h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F2D24h case    7:*/		return 0x821F2D28;
		  /* 821F2D28h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821F2D28h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2D28h case    8:*/		return 0x821F2D2C;
		  /* 821F2D2Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F2D2Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F2D2Ch case    9:*/		return 0x821F2D30;
	}
	return 0x821F2D30;
} // Block from 821F2D08h-821F2D30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F2D30h
// Function '?GetDependencyFromResult@Compiler@D3DXShader@@AAAPAVDependency@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2D30);
		  /* 821F2D30h */ case    0:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F2D30h case    0:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F2D30h case    0:*/		return 0x821F2D34;
		  /* 821F2D34h */ case    1:  		/* addi R8, R11, -36 */
		/* 821F2D34h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F2D34h case    1:*/		return 0x821F2D38;
		  /* 821F2D38h */ case    2:  		/* stw R9, <#[R31 + 8]> */
		/* 821F2D38h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2D38h case    2:*/		return 0x821F2D3C;
		  /* 821F2D3Ch */ case    3:  		/* addi R9, R11, 4 */
		/* 821F2D3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F2D3Ch case    3:*/		return 0x821F2D40;
		  /* 821F2D40h */ case    4:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F2D40h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F2D40h case    4:*/		return 0x821F2D44;
		  /* 821F2D44h */ case    5:  		/* addi R10, R10, 24 */
		/* 821F2D44h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F2D44h case    5:*/		return 0x821F2D48;
		  /* 821F2D48h */ case    6:  		/* lwz R7, <#[R10]> */
		/* 821F2D48h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2D48h case    6:*/		return 0x821F2D4C;
		  /* 821F2D4Ch */ case    7:  		/* addi R6, R10, -36 */
		/* 821F2D4Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F2D4Ch case    7:*/		return 0x821F2D50;
		  /* 821F2D50h */ case    8:  		/* stw R7, <#[R11]> */
		/* 821F2D50h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2D50h case    8:*/		return 0x821F2D54;
		  /* 821F2D54h */ case    9:  		/* lwz R7, <#[R10]> */
		/* 821F2D54h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2D54h case    9:*/		return 0x821F2D58;
		  /* 821F2D58h */ case   10:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F2D58h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F2D58h case   10:*/		return 0x821F2D5C;
		  /* 821F2D5Ch */ case   11:  		/* ori R6, R6, 1 */
		/* 821F2D5Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F2D5Ch case   11:*/		return 0x821F2D60;
		  /* 821F2D60h */ case   12:  		/* stw R8, <#[R7]> */
		/* 821F2D60h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F2D60h case   12:*/		return 0x821F2D64;
		  /* 821F2D64h */ case   13:  		/* stw R6, <#[R11 + 4]> */
		/* 821F2D64h case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2D64h case   13:*/		return 0x821F2D68;
		  /* 821F2D68h */ case   14:  		/* stw R9, <#[R10]> */
		/* 821F2D68h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2D68h case   14:*/		return 0x821F2D6C;
		  /* 821F2D6Ch */ case   15:  		/* addi R1, R1, 112 */
		/* 821F2D6Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F2D6Ch case   15:*/		return 0x821F2D70;
		  /* 821F2D70h */ case   16:  		/* b -1448644 */
		/* 821F2D70h case   16:*/		return 0x820912AC;
		/* 821F2D70h case   16:*/		return 0x821F2D74;
		  /* 821F2D74h */ case   17:  		/* nop */
		/* 821F2D74h case   17:*/		cpu::op::nop();
		/* 821F2D74h case   17:*/		return 0x821F2D78;
	}
	return 0x821F2D78;
} // Block from 821F2D30h-821F2D78h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F2D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2D78);
		  /* 821F2D78h */ case    0:  		/* mfspr R12, LR */
		/* 821F2D78h case    0:*/		regs.R12 = regs.LR;
		/* 821F2D78h case    0:*/		return 0x821F2D7C;
		  /* 821F2D7Ch */ case    1:  		/* bl -1448736 */
		/* 821F2D7Ch case    1:*/		regs.LR = 0x821F2D80; return 0x8209125C;
		/* 821F2D7Ch case    1:*/		return 0x821F2D80;
		  /* 821F2D80h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F2D80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F2D80h case    2:*/		return 0x821F2D84;
		  /* 821F2D84h */ case    3:  		/* mr R29, R5 */
		/* 821F2D84h case    3:*/		regs.R29 = regs.R5;
		/* 821F2D84h case    3:*/		return 0x821F2D88;
		  /* 821F2D88h */ case    4:  		/* std R4, <#[R1 + 136]> */
		/* 821F2D88h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F2D88h case    4:*/		return 0x821F2D8C;
		  /* 821F2D8Ch */ case    5:  		/* li R8, 4 */
		/* 821F2D8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F2D8Ch case    5:*/		return 0x821F2D90;
		  /* 821F2D90h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F2D90h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F2D90h case    6:*/		return 0x821F2D94;
		  /* 821F2D94h */ case    7:  		/* li R7, 2 */
		/* 821F2D94h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F2D94h case    7:*/		return 0x821F2D98;
		  /* 821F2D98h */ case    8:  		/* li R6, 2 */
		/* 821F2D98h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F2D98h case    8:*/		return 0x821F2D9C;
		  /* 821F2D9Ch */ case    9:  		/* li R5, 0 */
		/* 821F2D9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F2D9Ch case    9:*/		return 0x821F2DA0;
		  /* 821F2DA0h */ case   10:  		/* mr R30, R3 */
		/* 821F2DA0h case   10:*/		regs.R30 = regs.R3;
		/* 821F2DA0h case   10:*/		return 0x821F2DA4;
		  /* 821F2DA4h */ case   11:  		/* bl 203764 */
		/* 821F2DA4h case   11:*/		regs.LR = 0x821F2DA8; return 0x82224998;
		/* 821F2DA4h case   11:*/		return 0x821F2DA8;
		  /* 821F2DA8h */ case   12:  		/* mr R31, R3 */
		/* 821F2DA8h case   12:*/		regs.R31 = regs.R3;
		/* 821F2DA8h case   12:*/		return 0x821F2DAC;
		  /* 821F2DACh */ case   13:  		/* addi R4, R1, 136 */
		/* 821F2DACh case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F2DACh case   13:*/		return 0x821F2DB0;
		  /* 821F2DB0h */ case   14:  		/* mr R3, R30 */
		/* 821F2DB0h case   14:*/		regs.R3 = regs.R30;
		/* 821F2DB0h case   14:*/		return 0x821F2DB4;
		  /* 821F2DB4h */ case   15:  		/* bl -2612 */
		/* 821F2DB4h case   15:*/		regs.LR = 0x821F2DB8; return 0x821F2380;
		/* 821F2DB4h case   15:*/		return 0x821F2DB8;
		  /* 821F2DB8h */ case   16:  		/* mr R4, R3 */
		/* 821F2DB8h case   16:*/		regs.R4 = regs.R3;
		/* 821F2DB8h case   16:*/		return 0x821F2DBC;
		  /* 821F2DBCh */ case   17:  		/* mr R3, R31 */
		/* 821F2DBCh case   17:*/		regs.R3 = regs.R31;
		/* 821F2DBCh case   17:*/		return 0x821F2DC0;
		  /* 821F2DC0h */ case   18:  		/* bl -502776 */
		/* 821F2DC0h case   18:*/		regs.LR = 0x821F2DC4; return 0x821781C8;
		/* 821F2DC0h case   18:*/		return 0x821F2DC4;
		  /* 821F2DC4h */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 821F2DC4h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F2DC4h case   19:*/		return 0x821F2DC8;
		  /* 821F2DC8h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F2DC8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F2DC8h case   20:*/		return 0x821F2DCC;
		  /* 821F2DCCh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821F2DCCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F2DCCh case   21:*/		return 0x821F2DD0;
		  /* 821F2DD0h */ case   22:  		/* mr R4, R29 */
		/* 821F2DD0h case   22:*/		regs.R4 = regs.R29;
		/* 821F2DD0h case   22:*/		return 0x821F2DD4;
		  /* 821F2DD4h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821F2DD4h case   23:*/		if ( regs.CR[6].eq ) { return 0x821F2DE8;  }
		/* 821F2DD4h case   23:*/		return 0x821F2DD8;
		  /* 821F2DD8h */ case   24:  		/* mr R3, R30 */
		/* 821F2DD8h case   24:*/		regs.R3 = regs.R30;
		/* 821F2DD8h case   24:*/		return 0x821F2DDC;
		  /* 821F2DDCh */ case   25:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F2DDCh case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F2DDCh case   25:*/		return 0x821F2DE0;
		  /* 821F2DE0h */ case   26:  		/* bl -531696 */
		/* 821F2DE0h case   26:*/		regs.LR = 0x821F2DE4; return 0x821710F0;
		/* 821F2DE0h case   26:*/		return 0x821F2DE4;
		  /* 821F2DE4h */ case   27:  		/* mr R4, R3 */
		/* 821F2DE4h case   27:*/		regs.R4 = regs.R3;
		/* 821F2DE4h case   27:*/		return 0x821F2DE8;
	}
	return 0x821F2DE8;
} // Block from 821F2D78h-821F2DE8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F2DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2DE8);
		  /* 821F2DE8h */ case    0:  		/* mr R3, R31 */
		/* 821F2DE8h case    0:*/		regs.R3 = regs.R31;
		/* 821F2DE8h case    0:*/		return 0x821F2DEC;
		  /* 821F2DECh */ case    1:  		/* bl -502820 */
		/* 821F2DECh case    1:*/		regs.LR = 0x821F2DF0; return 0x821781C8;
		/* 821F2DECh case    1:*/		return 0x821F2DF0;
		  /* 821F2DF0h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F2DF0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F2DF0h case    2:*/		return 0x821F2DF4;
		  /* 821F2DF4h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821F2DF4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F2DF4h case    3:*/		return 0x821F2DF8;
		  /* 821F2DF8h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F2DF8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F2DF8h case    4:*/		return 0x821F2DFC;
		  /* 821F2DFCh */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F2DFCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2DFCh case    5:*/		return 0x821F2E00;
		  /* 821F2E00h */ case    6:  		/* mr R3, R31 */
		/* 821F2E00h case    6:*/		regs.R3 = regs.R31;
		/* 821F2E00h case    6:*/		return 0x821F2E04;
		  /* 821F2E04h */ case    7:  		/* addi R11, R11, 36 */
		/* 821F2E04h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F2E04h case    7:*/		return 0x821F2E08;
		  /* 821F2E08h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821F2E08h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2E08h case    8:*/		return 0x821F2E0C;
		  /* 821F2E0Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F2E0Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F2E0Ch case    9:*/		return 0x821F2E10;
		  /* 821F2E10h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F2E10h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F2E10h case   10:*/		return 0x821F2E14;
		  /* 821F2E14h */ case   11:  		/* addi R8, R11, -36 */
		/* 821F2E14h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F2E14h case   11:*/		return 0x821F2E18;
		  /* 821F2E18h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821F2E18h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2E18h case   12:*/		return 0x821F2E1C;
		  /* 821F2E1Ch */ case   13:  		/* addi R9, R11, 4 */
		/* 821F2E1Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F2E1Ch case   13:*/		return 0x821F2E20;
		  /* 821F2E20h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F2E20h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F2E20h case   14:*/		return 0x821F2E24;
		  /* 821F2E24h */ case   15:  		/* addi R10, R10, 24 */
		/* 821F2E24h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F2E24h case   15:*/		return 0x821F2E28;
		  /* 821F2E28h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821F2E28h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2E28h case   16:*/		return 0x821F2E2C;
		  /* 821F2E2Ch */ case   17:  		/* addi R6, R10, -36 */
		/* 821F2E2Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F2E2Ch case   17:*/		return 0x821F2E30;
		  /* 821F2E30h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821F2E30h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2E30h case   18:*/		return 0x821F2E34;
		  /* 821F2E34h */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821F2E34h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2E34h case   19:*/		return 0x821F2E38;
		  /* 821F2E38h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F2E38h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F2E38h case   20:*/		return 0x821F2E3C;
		  /* 821F2E3Ch */ case   21:  		/* ori R6, R6, 1 */
		/* 821F2E3Ch case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F2E3Ch case   21:*/		return 0x821F2E40;
		  /* 821F2E40h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821F2E40h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F2E40h case   22:*/		return 0x821F2E44;
		  /* 821F2E44h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821F2E44h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2E44h case   23:*/		return 0x821F2E48;
		  /* 821F2E48h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821F2E48h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2E48h case   24:*/		return 0x821F2E4C;
		  /* 821F2E4Ch */ case   25:  		/* addi R1, R1, 112 */
		/* 821F2E4Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F2E4Ch case   25:*/		return 0x821F2E50;
		  /* 821F2E50h */ case   26:  		/* b -1448868 */
		/* 821F2E50h case   26:*/		return 0x820912AC;
		/* 821F2E50h case   26:*/		return 0x821F2E54;
		  /* 821F2E54h */ case   27:  		/* nop */
		/* 821F2E54h case   27:*/		cpu::op::nop();
		/* 821F2E54h case   27:*/		return 0x821F2E58;
	}
	return 0x821F2E58;
} // Block from 821F2DE8h-821F2E58h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F2E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2E58);
		  /* 821F2E58h */ case    0:  		/* mfspr R12, LR */
		/* 821F2E58h case    0:*/		regs.R12 = regs.LR;
		/* 821F2E58h case    0:*/		return 0x821F2E5C;
		  /* 821F2E5Ch */ case    1:  		/* bl -1448960 */
		/* 821F2E5Ch case    1:*/		regs.LR = 0x821F2E60; return 0x8209125C;
		/* 821F2E5Ch case    1:*/		return 0x821F2E60;
		  /* 821F2E60h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F2E60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F2E60h case    2:*/		return 0x821F2E64;
		  /* 821F2E64h */ case    3:  		/* mr R29, R5 */
		/* 821F2E64h case    3:*/		regs.R29 = regs.R5;
		/* 821F2E64h case    3:*/		return 0x821F2E68;
		  /* 821F2E68h */ case    4:  		/* std R4, <#[R1 + 136]> */
		/* 821F2E68h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F2E68h case    4:*/		return 0x821F2E6C;
		  /* 821F2E6Ch */ case    5:  		/* li R8, 4 */
		/* 821F2E6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F2E6Ch case    5:*/		return 0x821F2E70;
		  /* 821F2E70h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F2E70h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F2E70h case    6:*/		return 0x821F2E74;
		  /* 821F2E74h */ case    7:  		/* li R7, 2 */
		/* 821F2E74h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F2E74h case    7:*/		return 0x821F2E78;
		  /* 821F2E78h */ case    8:  		/* li R6, 6 */
		/* 821F2E78h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 821F2E78h case    8:*/		return 0x821F2E7C;
		  /* 821F2E7Ch */ case    9:  		/* li R5, 0 */
		/* 821F2E7Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F2E7Ch case    9:*/		return 0x821F2E80;
		  /* 821F2E80h */ case   10:  		/* mr R30, R3 */
		/* 821F2E80h case   10:*/		regs.R30 = regs.R3;
		/* 821F2E80h case   10:*/		return 0x821F2E84;
		  /* 821F2E84h */ case   11:  		/* bl 203540 */
		/* 821F2E84h case   11:*/		regs.LR = 0x821F2E88; return 0x82224998;
		/* 821F2E84h case   11:*/		return 0x821F2E88;
		  /* 821F2E88h */ case   12:  		/* mr R31, R3 */
		/* 821F2E88h case   12:*/		regs.R31 = regs.R3;
		/* 821F2E88h case   12:*/		return 0x821F2E8C;
		  /* 821F2E8Ch */ case   13:  		/* addi R4, R1, 136 */
		/* 821F2E8Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F2E8Ch case   13:*/		return 0x821F2E90;
		  /* 821F2E90h */ case   14:  		/* mr R3, R30 */
		/* 821F2E90h case   14:*/		regs.R3 = regs.R30;
		/* 821F2E90h case   14:*/		return 0x821F2E94;
		  /* 821F2E94h */ case   15:  		/* bl -2836 */
		/* 821F2E94h case   15:*/		regs.LR = 0x821F2E98; return 0x821F2380;
		/* 821F2E94h case   15:*/		return 0x821F2E98;
		  /* 821F2E98h */ case   16:  		/* mr R4, R3 */
		/* 821F2E98h case   16:*/		regs.R4 = regs.R3;
		/* 821F2E98h case   16:*/		return 0x821F2E9C;
		  /* 821F2E9Ch */ case   17:  		/* mr R3, R31 */
		/* 821F2E9Ch case   17:*/		regs.R3 = regs.R31;
		/* 821F2E9Ch case   17:*/		return 0x821F2EA0;
		  /* 821F2EA0h */ case   18:  		/* bl -503000 */
		/* 821F2EA0h case   18:*/		regs.LR = 0x821F2EA4; return 0x821781C8;
		/* 821F2EA0h case   18:*/		return 0x821F2EA4;
		  /* 821F2EA4h */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 821F2EA4h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F2EA4h case   19:*/		return 0x821F2EA8;
		  /* 821F2EA8h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F2EA8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F2EA8h case   20:*/		return 0x821F2EAC;
		  /* 821F2EACh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821F2EACh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F2EACh case   21:*/		return 0x821F2EB0;
		  /* 821F2EB0h */ case   22:  		/* mr R4, R29 */
		/* 821F2EB0h case   22:*/		regs.R4 = regs.R29;
		/* 821F2EB0h case   22:*/		return 0x821F2EB4;
		  /* 821F2EB4h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821F2EB4h case   23:*/		if ( regs.CR[6].eq ) { return 0x821F2EC8;  }
		/* 821F2EB4h case   23:*/		return 0x821F2EB8;
		  /* 821F2EB8h */ case   24:  		/* mr R3, R30 */
		/* 821F2EB8h case   24:*/		regs.R3 = regs.R30;
		/* 821F2EB8h case   24:*/		return 0x821F2EBC;
		  /* 821F2EBCh */ case   25:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F2EBCh case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F2EBCh case   25:*/		return 0x821F2EC0;
		  /* 821F2EC0h */ case   26:  		/* bl -531920 */
		/* 821F2EC0h case   26:*/		regs.LR = 0x821F2EC4; return 0x821710F0;
		/* 821F2EC0h case   26:*/		return 0x821F2EC4;
		  /* 821F2EC4h */ case   27:  		/* mr R4, R3 */
		/* 821F2EC4h case   27:*/		regs.R4 = regs.R3;
		/* 821F2EC4h case   27:*/		return 0x821F2EC8;
	}
	return 0x821F2EC8;
} // Block from 821F2E58h-821F2EC8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F2EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2EC8);
		  /* 821F2EC8h */ case    0:  		/* mr R3, R31 */
		/* 821F2EC8h case    0:*/		regs.R3 = regs.R31;
		/* 821F2EC8h case    0:*/		return 0x821F2ECC;
		  /* 821F2ECCh */ case    1:  		/* bl -503044 */
		/* 821F2ECCh case    1:*/		regs.LR = 0x821F2ED0; return 0x821781C8;
		/* 821F2ECCh case    1:*/		return 0x821F2ED0;
	}
	return 0x821F2ED0;
} // Block from 821F2EC8h-821F2ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F2ED0h
// Function '?GetMergedDependency@Compiler@D3DXShader@@AAAPAVDependency@2@PAVResultStackEnumerator@2@I_N1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2ED0);
		  /* 821F2ED0h */ case    0:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F2ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F2ED0h case    0:*/		return 0x821F2ED4;
		  /* 821F2ED4h */ case    1:  		/* stw R3, <#[R31 + 48]> */
		/* 821F2ED4h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F2ED4h case    1:*/		return 0x821F2ED8;
		  /* 821F2ED8h */ case    2:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F2ED8h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F2ED8h case    2:*/		return 0x821F2EDC;
		  /* 821F2EDCh */ case    3:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F2EDCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2EDCh case    3:*/		return 0x821F2EE0;
		  /* 821F2EE0h */ case    4:  		/* mr R3, R31 */
		/* 821F2EE0h case    4:*/		regs.R3 = regs.R31;
		/* 821F2EE0h case    4:*/		return 0x821F2EE4;
		  /* 821F2EE4h */ case    5:  		/* addi R11, R11, 36 */
		/* 821F2EE4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F2EE4h case    5:*/		return 0x821F2EE8;
		  /* 821F2EE8h */ case    6:  		/* lwz R10, <#[R10]> */
		/* 821F2EE8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2EE8h case    6:*/		return 0x821F2EEC;
		  /* 821F2EECh */ case    7:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F2EECh case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F2EECh case    7:*/		return 0x821F2EF0;
		  /* 821F2EF0h */ case    8:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F2EF0h case    8:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F2EF0h case    8:*/		return 0x821F2EF4;
		  /* 821F2EF4h */ case    9:  		/* addi R8, R11, -36 */
		/* 821F2EF4h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F2EF4h case    9:*/		return 0x821F2EF8;
		  /* 821F2EF8h */ case   10:  		/* stw R9, <#[R31 + 8]> */
		/* 821F2EF8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F2EF8h case   10:*/		return 0x821F2EFC;
		  /* 821F2EFCh */ case   11:  		/* addi R9, R11, 4 */
		/* 821F2EFCh case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F2EFCh case   11:*/		return 0x821F2F00;
		  /* 821F2F00h */ case   12:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F2F00h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F2F00h case   12:*/		return 0x821F2F04;
		  /* 821F2F04h */ case   13:  		/* addi R10, R10, 24 */
		/* 821F2F04h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F2F04h case   13:*/		return 0x821F2F08;
		  /* 821F2F08h */ case   14:  		/* lwz R7, <#[R10]> */
		/* 821F2F08h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2F08h case   14:*/		return 0x821F2F0C;
		  /* 821F2F0Ch */ case   15:  		/* addi R6, R10, -36 */
		/* 821F2F0Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F2F0Ch case   15:*/		return 0x821F2F10;
		  /* 821F2F10h */ case   16:  		/* stw R7, <#[R11]> */
		/* 821F2F10h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2F10h case   16:*/		return 0x821F2F14;
		  /* 821F2F14h */ case   17:  		/* lwz R7, <#[R10]> */
		/* 821F2F14h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2F14h case   17:*/		return 0x821F2F18;
		  /* 821F2F18h */ case   18:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F2F18h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F2F18h case   18:*/		return 0x821F2F1C;
		  /* 821F2F1Ch */ case   19:  		/* ori R6, R6, 1 */
		/* 821F2F1Ch case   19:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F2F1Ch case   19:*/		return 0x821F2F20;
		  /* 821F2F20h */ case   20:  		/* stw R8, <#[R7]> */
		/* 821F2F20h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F2F20h case   20:*/		return 0x821F2F24;
		  /* 821F2F24h */ case   21:  		/* stw R6, <#[R11 + 4]> */
		/* 821F2F24h case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F2F24h case   21:*/		return 0x821F2F28;
		  /* 821F2F28h */ case   22:  		/* stw R9, <#[R10]> */
		/* 821F2F28h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2F28h case   22:*/		return 0x821F2F2C;
		  /* 821F2F2Ch */ case   23:  		/* addi R1, R1, 112 */
		/* 821F2F2Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F2F2Ch case   23:*/		return 0x821F2F30;
		  /* 821F2F30h */ case   24:  		/* b -1449092 */
		/* 821F2F30h case   24:*/		return 0x820912AC;
		/* 821F2F30h case   24:*/		return 0x821F2F34;
		  /* 821F2F34h */ case   25:  		/* nop */
		/* 821F2F34h case   25:*/		cpu::op::nop();
		/* 821F2F34h case   25:*/		return 0x821F2F38;
	}
	return 0x821F2F38;
} // Block from 821F2ED0h-821F2F38h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821F2F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2F38);
		  /* 821F2F38h */ case    0:  		/* mfspr R12, LR */
		/* 821F2F38h case    0:*/		regs.R12 = regs.LR;
		/* 821F2F38h case    0:*/		return 0x821F2F3C;
		  /* 821F2F3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F2F3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2F3Ch case    1:*/		return 0x821F2F40;
		  /* 821F2F40h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F2F40h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F2F40h case    2:*/		return 0x821F2F44;
		  /* 821F2F44h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F2F44h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2F44h case    3:*/		return 0x821F2F48;
		  /* 821F2F48h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F2F48h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F2F48h case    4:*/		return 0x821F2F4C;
		  /* 821F2F4Ch */ case    5:  		/* li R8, 1 */
		/* 821F2F4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F2F4Ch case    5:*/		return 0x821F2F50;
		  /* 821F2F50h */ case    6:  		/* std R4, <#[R1 + 136]> */
		/* 821F2F50h case    6:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F2F50h case    6:*/		return 0x821F2F54;
		  /* 821F2F54h */ case    7:  		/* li R7, 1 */
		/* 821F2F54h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F2F54h case    7:*/		return 0x821F2F58;
		  /* 821F2F58h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F2F58h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F2F58h case    8:*/		return 0x821F2F5C;
		  /* 821F2F5Ch */ case    9:  		/* li R6, 48 */
		/* 821F2F5Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x30);
		/* 821F2F5Ch case    9:*/		return 0x821F2F60;
		  /* 821F2F60h */ case   10:  		/* li R5, 0 */
		/* 821F2F60h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F2F60h case   10:*/		return 0x821F2F64;
		  /* 821F2F64h */ case   11:  		/* mr R31, R3 */
		/* 821F2F64h case   11:*/		regs.R31 = regs.R3;
		/* 821F2F64h case   11:*/		return 0x821F2F68;
		  /* 821F2F68h */ case   12:  		/* bl 203312 */
		/* 821F2F68h case   12:*/		regs.LR = 0x821F2F6C; return 0x82224998;
		/* 821F2F68h case   12:*/		return 0x821F2F6C;
		  /* 821F2F6Ch */ case   13:  		/* mr R30, R3 */
		/* 821F2F6Ch case   13:*/		regs.R30 = regs.R3;
		/* 821F2F6Ch case   13:*/		return 0x821F2F70;
		  /* 821F2F70h */ case   14:  		/* addi R4, R1, 136 */
		/* 821F2F70h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F2F70h case   14:*/		return 0x821F2F74;
		  /* 821F2F74h */ case   15:  		/* mr R3, R31 */
		/* 821F2F74h case   15:*/		regs.R3 = regs.R31;
		/* 821F2F74h case   15:*/		return 0x821F2F78;
		  /* 821F2F78h */ case   16:  		/* bl -3064 */
		/* 821F2F78h case   16:*/		regs.LR = 0x821F2F7C; return 0x821F2380;
		/* 821F2F78h case   16:*/		return 0x821F2F7C;
		  /* 821F2F7Ch */ case   17:  		/* mr R4, R3 */
		/* 821F2F7Ch case   17:*/		regs.R4 = regs.R3;
		/* 821F2F7Ch case   17:*/		return 0x821F2F80;
		  /* 821F2F80h */ case   18:  		/* mr R3, R30 */
		/* 821F2F80h case   18:*/		regs.R3 = regs.R30;
		/* 821F2F80h case   18:*/		return 0x821F2F84;
		  /* 821F2F84h */ case   19:  		/* bl -503228 */
		/* 821F2F84h case   19:*/		regs.LR = 0x821F2F88; return 0x821781C8;
		/* 821F2F84h case   19:*/		return 0x821F2F88;
		  /* 821F2F88h */ case   20:  		/* stw R3, <#[R30 + 44]> */
		/* 821F2F88h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F2F88h case   20:*/		return 0x821F2F8C;
		  /* 821F2F8Ch */ case   21:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F2F8Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F2F8Ch case   21:*/		return 0x821F2F90;
		  /* 821F2F90h */ case   22:  		/* addi R11, R11, 24 */
		/* 821F2F90h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F2F90h case   22:*/		return 0x821F2F94;
		  /* 821F2F94h */ case   23:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 821F2F94h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 821F2F94h case   23:*/		return 0x821F2F98;
		  /* 821F2F98h */ case   24:  		/* lwz R9, <#[R11]> */
		/* 821F2F98h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2F98h case   24:*/		return 0x821F2F9C;
		  /* 821F2F9Ch */ case   25:  		/* addi R8, R11, -36 */
		/* 821F2F9Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F2F9Ch case   25:*/		return 0x821F2FA0;
		  /* 821F2FA0h */ case   26:  		/* addi R10, R10, 36 */
		/* 821F2FA0h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F2FA0h case   26:*/		return 0x821F2FA4;
		  /* 821F2FA4h */ case   27:  		/* stw R9, <#[R10]> */
		/* 821F2FA4h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F2FA4h case   27:*/		return 0x821F2FA8;
		  /* 821F2FA8h */ case   28:  		/* lwz R9, <#[R11]> */
		/* 821F2FA8h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2FA8h case   28:*/		return 0x821F2FAC;
		  /* 821F2FACh */ case   29:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821F2FACh case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821F2FACh case   29:*/		return 0x821F2FB0;
		  /* 821F2FB0h */ case   30:  		/* addi R6, R10, -36 */
		/* 821F2FB0h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F2FB0h case   30:*/		return 0x821F2FB4;
		  /* 821F2FB4h */ case   31:  		/* ori R8, R8, 1 */
		/* 821F2FB4h case   31:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F2FB4h case   31:*/		return 0x821F2FB8;
		  /* 821F2FB8h */ case   32:  		/* addi R9, R10, 4 */
		/* 821F2FB8h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F2FB8h case   32:*/		return 0x821F2FBC;
		  /* 821F2FBCh */ case   33:  		/* stw R6, <#[R7]> */
		/* 821F2FBCh case   33:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821F2FBCh case   33:*/		return 0x821F2FC0;
		  /* 821F2FC0h */ case   34:  		/* stw R8, <#[R10 + 4]> */
		/* 821F2FC0h case   34:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821F2FC0h case   34:*/		return 0x821F2FC4;
		  /* 821F2FC4h */ case   35:  		/* mr R3, R30 */
		/* 821F2FC4h case   35:*/		regs.R3 = regs.R30;
		/* 821F2FC4h case   35:*/		return 0x821F2FC8;
		  /* 821F2FC8h */ case   36:  		/* stw R9, <#[R11]> */
		/* 821F2FC8h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F2FC8h case   36:*/		return 0x821F2FCC;
		  /* 821F2FCCh */ case   37:  		/* addi R1, R1, 112 */
		/* 821F2FCCh case   37:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F2FCCh case   37:*/		return 0x821F2FD0;
		  /* 821F2FD0h */ case   38:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F2FD0h case   38:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2FD0h case   38:*/		return 0x821F2FD4;
		  /* 821F2FD4h */ case   39:  		/* mtspr LR, R12 */
		/* 821F2FD4h case   39:*/		regs.LR = regs.R12;
		/* 821F2FD4h case   39:*/		return 0x821F2FD8;
		  /* 821F2FD8h */ case   40:  		/* ld R30, <#[R1 - 24]> */
		/* 821F2FD8h case   40:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F2FD8h case   40:*/		return 0x821F2FDC;
		  /* 821F2FDCh */ case   41:  		/* ld R31, <#[R1 - 16]> */
		/* 821F2FDCh case   41:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2FDCh case   41:*/		return 0x821F2FE0;
		  /* 821F2FE0h */ case   42:  		/* bclr 20, CR0_LT */
		/* 821F2FE0h case   42:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F2FE0h case   42:*/		return 0x821F2FE4;
	}
	return 0x821F2FE4;
} // Block from 821F2F38h-821F2FE4h (43 instructions)

//////////////////////////////////////////////////////
// Block at 821F2FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2FE4);
		  /* 821F2FE4h */ case    0:  		/* nop */
		/* 821F2FE4h case    0:*/		cpu::op::nop();
		/* 821F2FE4h case    0:*/		return 0x821F2FE8;
	}
	return 0x821F2FE8;
} // Block from 821F2FE4h-821F2FE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F2FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F2FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F2FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F2FE8);
		  /* 821F2FE8h */ case    0:  		/* mfspr R12, LR */
		/* 821F2FE8h case    0:*/		regs.R12 = regs.LR;
		/* 821F2FE8h case    0:*/		return 0x821F2FEC;
		  /* 821F2FECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F2FECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F2FECh case    1:*/		return 0x821F2FF0;
		  /* 821F2FF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F2FF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F2FF0h case    2:*/		return 0x821F2FF4;
		  /* 821F2FF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F2FF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F2FF4h case    3:*/		return 0x821F2FF8;
		  /* 821F2FF8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F2FF8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F2FF8h case    4:*/		return 0x821F2FFC;
		  /* 821F2FFCh */ case    5:  		/* li R8, 1 */
		/* 821F2FFCh case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F2FFCh case    5:*/		return 0x821F3000;
		  /* 821F3000h */ case    6:  		/* std R4, <#[R1 + 136]> */
		/* 821F3000h case    6:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F3000h case    6:*/		return 0x821F3004;
		  /* 821F3004h */ case    7:  		/* li R7, 1 */
		/* 821F3004h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F3004h case    7:*/		return 0x821F3008;
		  /* 821F3008h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3008h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3008h case    8:*/		return 0x821F300C;
		  /* 821F300Ch */ case    9:  		/* li R6, 60 */
		/* 821F300Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x3C);
		/* 821F300Ch case    9:*/		return 0x821F3010;
		  /* 821F3010h */ case   10:  		/* li R5, 0 */
		/* 821F3010h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3010h case   10:*/		return 0x821F3014;
		  /* 821F3014h */ case   11:  		/* mr R31, R3 */
		/* 821F3014h case   11:*/		regs.R31 = regs.R3;
		/* 821F3014h case   11:*/		return 0x821F3018;
		  /* 821F3018h */ case   12:  		/* bl 203136 */
		/* 821F3018h case   12:*/		regs.LR = 0x821F301C; return 0x82224998;
		/* 821F3018h case   12:*/		return 0x821F301C;
		  /* 821F301Ch */ case   13:  		/* mr R30, R3 */
		/* 821F301Ch case   13:*/		regs.R30 = regs.R3;
		/* 821F301Ch case   13:*/		return 0x821F3020;
		  /* 821F3020h */ case   14:  		/* addi R4, R1, 136 */
		/* 821F3020h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F3020h case   14:*/		return 0x821F3024;
		  /* 821F3024h */ case   15:  		/* mr R3, R31 */
		/* 821F3024h case   15:*/		regs.R3 = regs.R31;
		/* 821F3024h case   15:*/		return 0x821F3028;
		  /* 821F3028h */ case   16:  		/* bl -3240 */
		/* 821F3028h case   16:*/		regs.LR = 0x821F302C; return 0x821F2380;
		/* 821F3028h case   16:*/		return 0x821F302C;
		  /* 821F302Ch */ case   17:  		/* mr R4, R3 */
		/* 821F302Ch case   17:*/		regs.R4 = regs.R3;
		/* 821F302Ch case   17:*/		return 0x821F3030;
		  /* 821F3030h */ case   18:  		/* mr R3, R30 */
		/* 821F3030h case   18:*/		regs.R3 = regs.R30;
		/* 821F3030h case   18:*/		return 0x821F3034;
		  /* 821F3034h */ case   19:  		/* bl -503404 */
		/* 821F3034h case   19:*/		regs.LR = 0x821F3038; return 0x821781C8;
		/* 821F3034h case   19:*/		return 0x821F3038;
		  /* 821F3038h */ case   20:  		/* stw R3, <#[R30 + 44]> */
		/* 821F3038h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F3038h case   20:*/		return 0x821F303C;
		  /* 821F303Ch */ case   21:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F303Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F303Ch case   21:*/		return 0x821F3040;
		  /* 821F3040h */ case   22:  		/* addi R11, R11, 24 */
		/* 821F3040h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F3040h case   22:*/		return 0x821F3044;
		  /* 821F3044h */ case   23:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 821F3044h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 821F3044h case   23:*/		return 0x821F3048;
		  /* 821F3048h */ case   24:  		/* lwz R9, <#[R11]> */
		/* 821F3048h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3048h case   24:*/		return 0x821F304C;
		  /* 821F304Ch */ case   25:  		/* addi R8, R11, -36 */
		/* 821F304Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F304Ch case   25:*/		return 0x821F3050;
		  /* 821F3050h */ case   26:  		/* addi R10, R10, 36 */
		/* 821F3050h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F3050h case   26:*/		return 0x821F3054;
		  /* 821F3054h */ case   27:  		/* stw R9, <#[R10]> */
		/* 821F3054h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3054h case   27:*/		return 0x821F3058;
		  /* 821F3058h */ case   28:  		/* lwz R9, <#[R11]> */
		/* 821F3058h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3058h case   28:*/		return 0x821F305C;
		  /* 821F305Ch */ case   29:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821F305Ch case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821F305Ch case   29:*/		return 0x821F3060;
		  /* 821F3060h */ case   30:  		/* addi R6, R10, -36 */
		/* 821F3060h case   30:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3060h case   30:*/		return 0x821F3064;
		  /* 821F3064h */ case   31:  		/* ori R8, R8, 1 */
		/* 821F3064h case   31:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F3064h case   31:*/		return 0x821F3068;
		  /* 821F3068h */ case   32:  		/* addi R9, R10, 4 */
		/* 821F3068h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F3068h case   32:*/		return 0x821F306C;
		  /* 821F306Ch */ case   33:  		/* stw R6, <#[R7]> */
		/* 821F306Ch case   33:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821F306Ch case   33:*/		return 0x821F3070;
		  /* 821F3070h */ case   34:  		/* stw R8, <#[R10 + 4]> */
		/* 821F3070h case   34:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821F3070h case   34:*/		return 0x821F3074;
		  /* 821F3074h */ case   35:  		/* mr R3, R30 */
		/* 821F3074h case   35:*/		regs.R3 = regs.R30;
		/* 821F3074h case   35:*/		return 0x821F3078;
		  /* 821F3078h */ case   36:  		/* stw R9, <#[R11]> */
		/* 821F3078h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3078h case   36:*/		return 0x821F307C;
		  /* 821F307Ch */ case   37:  		/* addi R1, R1, 112 */
		/* 821F307Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F307Ch case   37:*/		return 0x821F3080;
		  /* 821F3080h */ case   38:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F3080h case   38:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F3080h case   38:*/		return 0x821F3084;
		  /* 821F3084h */ case   39:  		/* mtspr LR, R12 */
		/* 821F3084h case   39:*/		regs.LR = regs.R12;
		/* 821F3084h case   39:*/		return 0x821F3088;
		  /* 821F3088h */ case   40:  		/* ld R30, <#[R1 - 24]> */
		/* 821F3088h case   40:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F3088h case   40:*/		return 0x821F308C;
		  /* 821F308Ch */ case   41:  		/* ld R31, <#[R1 - 16]> */
		/* 821F308Ch case   41:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F308Ch case   41:*/		return 0x821F3090;
		  /* 821F3090h */ case   42:  		/* bclr 20, CR0_LT */
		/* 821F3090h case   42:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F3090h case   42:*/		return 0x821F3094;
	}
	return 0x821F3094;
} // Block from 821F2FE8h-821F3094h (43 instructions)

//////////////////////////////////////////////////////
// Block at 821F3094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3094);
		  /* 821F3094h */ case    0:  		/* nop */
		/* 821F3094h case    0:*/		cpu::op::nop();
		/* 821F3094h case    0:*/		return 0x821F3098;
	}
	return 0x821F3098;
} // Block from 821F3094h-821F3098h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F3098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3098);
		  /* 821F3098h */ case    0:  		/* mfspr R12, LR */
		/* 821F3098h case    0:*/		regs.R12 = regs.LR;
		/* 821F3098h case    0:*/		return 0x821F309C;
		  /* 821F309Ch */ case    1:  		/* bl -1449540 */
		/* 821F309Ch case    1:*/		regs.LR = 0x821F30A0; return 0x82091258;
		/* 821F309Ch case    1:*/		return 0x821F30A0;
		  /* 821F30A0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F30A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F30A0h case    2:*/		return 0x821F30A4;
		  /* 821F30A4h */ case    3:  		/* mr R29, R5 */
		/* 821F30A4h case    3:*/		regs.R29 = regs.R5;
		/* 821F30A4h case    3:*/		return 0x821F30A8;
		  /* 821F30A8h */ case    4:  		/* li R8, 4 */
		/* 821F30A8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F30A8h case    4:*/		return 0x821F30AC;
		  /* 821F30ACh */ case    5:  		/* li R7, 2 */
		/* 821F30ACh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F30ACh case    5:*/		return 0x821F30B0;
		  /* 821F30B0h */ case    6:  		/* li R6, 1 */
		/* 821F30B0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F30B0h case    6:*/		return 0x821F30B4;
		  /* 821F30B4h */ case    7:  		/* li R5, 0 */
		/* 821F30B4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F30B4h case    7:*/		return 0x821F30B8;
		  /* 821F30B8h */ case    8:  		/* mr R28, R4 */
		/* 821F30B8h case    8:*/		regs.R28 = regs.R4;
		/* 821F30B8h case    8:*/		return 0x821F30BC;
		  /* 821F30BCh */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F30BCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F30BCh case    9:*/		return 0x821F30C0;
		  /* 821F30C0h */ case   10:  		/* mr R30, R3 */
		/* 821F30C0h case   10:*/		regs.R30 = regs.R3;
		/* 821F30C0h case   10:*/		return 0x821F30C4;
		  /* 821F30C4h */ case   11:  		/* bl 202964 */
		/* 821F30C4h case   11:*/		regs.LR = 0x821F30C8; return 0x82224998;
		/* 821F30C4h case   11:*/		return 0x821F30C8;
		  /* 821F30C8h */ case   12:  		/* mr R31, R3 */
		/* 821F30C8h case   12:*/		regs.R31 = regs.R3;
		/* 821F30C8h case   12:*/		return 0x821F30CC;
		  /* 821F30CCh */ case   13:  		/* mr R4, R28 */
		/* 821F30CCh case   13:*/		regs.R4 = regs.R28;
		/* 821F30CCh case   13:*/		return 0x821F30D0;
		  /* 821F30D0h */ case   14:  		/* mr R3, R30 */
		/* 821F30D0h case   14:*/		regs.R3 = regs.R30;
		/* 821F30D0h case   14:*/		return 0x821F30D4;
		  /* 821F30D4h */ case   15:  		/* bl -3412 */
		/* 821F30D4h case   15:*/		regs.LR = 0x821F30D8; return 0x821F2380;
		/* 821F30D4h case   15:*/		return 0x821F30D8;
		  /* 821F30D8h */ case   16:  		/* mr R4, R3 */
		/* 821F30D8h case   16:*/		regs.R4 = regs.R3;
		/* 821F30D8h case   16:*/		return 0x821F30DC;
		  /* 821F30DCh */ case   17:  		/* mr R3, R31 */
		/* 821F30DCh case   17:*/		regs.R3 = regs.R31;
		/* 821F30DCh case   17:*/		return 0x821F30E0;
		  /* 821F30E0h */ case   18:  		/* bl -503576 */
		/* 821F30E0h case   18:*/		regs.LR = 0x821F30E4; return 0x821781C8;
		/* 821F30E0h case   18:*/		return 0x821F30E4;
		  /* 821F30E4h */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 821F30E4h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F30E4h case   19:*/		return 0x821F30E8;
		  /* 821F30E8h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F30E8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F30E8h case   20:*/		return 0x821F30EC;
		  /* 821F30ECh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821F30ECh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F30ECh case   21:*/		return 0x821F30F0;
		  /* 821F30F0h */ case   22:  		/* mr R4, R29 */
		/* 821F30F0h case   22:*/		regs.R4 = regs.R29;
		/* 821F30F0h case   22:*/		return 0x821F30F4;
		  /* 821F30F4h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821F30F4h case   23:*/		if ( regs.CR[6].eq ) { return 0x821F3108;  }
		/* 821F30F4h case   23:*/		return 0x821F30F8;
	}
	return 0x821F30F8;
} // Block from 821F3098h-821F30F8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821F30F8h
// Function '?PeekMergedDependency@Compiler@D3DXShader@@AAAPAVDependency@2@PAVResultStackEnumerator@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F30F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F30F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F30F8);
		  /* 821F30F8h */ case    0:  		/* mr R3, R30 */
		/* 821F30F8h case    0:*/		regs.R3 = regs.R30;
		/* 821F30F8h case    0:*/		return 0x821F30FC;
		  /* 821F30FCh */ case    1:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F30FCh case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F30FCh case    1:*/		return 0x821F3100;
		  /* 821F3100h */ case    2:  		/* bl -532496 */
		/* 821F3100h case    2:*/		regs.LR = 0x821F3104; return 0x821710F0;
		/* 821F3100h case    2:*/		return 0x821F3104;
		  /* 821F3104h */ case    3:  		/* mr R4, R3 */
		/* 821F3104h case    3:*/		regs.R4 = regs.R3;
		/* 821F3104h case    3:*/		return 0x821F3108;
	}
	return 0x821F3108;
} // Block from 821F30F8h-821F3108h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F3108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3108);
		  /* 821F3108h */ case    0:  		/* mr R3, R31 */
		/* 821F3108h case    0:*/		regs.R3 = regs.R31;
		/* 821F3108h case    0:*/		return 0x821F310C;
		  /* 821F310Ch */ case    1:  		/* bl -503620 */
		/* 821F310Ch case    1:*/		regs.LR = 0x821F3110; return 0x821781C8;
		/* 821F310Ch case    1:*/		return 0x821F3110;
		  /* 821F3110h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F3110h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3110h case    2:*/		return 0x821F3114;
		  /* 821F3114h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821F3114h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F3114h case    3:*/		return 0x821F3118;
		  /* 821F3118h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F3118h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F3118h case    4:*/		return 0x821F311C;
		  /* 821F311Ch */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F311Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F311Ch case    5:*/		return 0x821F3120;
		  /* 821F3120h */ case    6:  		/* mr R3, R31 */
		/* 821F3120h case    6:*/		regs.R3 = regs.R31;
		/* 821F3120h case    6:*/		return 0x821F3124;
		  /* 821F3124h */ case    7:  		/* addi R11, R11, 36 */
		/* 821F3124h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3124h case    7:*/		return 0x821F3128;
		  /* 821F3128h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821F3128h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3128h case    8:*/		return 0x821F312C;
		  /* 821F312Ch */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F312Ch case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F312Ch case    9:*/		return 0x821F3130;
		  /* 821F3130h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3130h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3130h case   10:*/		return 0x821F3134;
		  /* 821F3134h */ case   11:  		/* addi R8, R11, -36 */
		/* 821F3134h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3134h case   11:*/		return 0x821F3138;
		  /* 821F3138h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3138h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3138h case   12:*/		return 0x821F313C;
		  /* 821F313Ch */ case   13:  		/* addi R9, R11, 4 */
		/* 821F313Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F313Ch case   13:*/		return 0x821F3140;
		  /* 821F3140h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3140h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3140h case   14:*/		return 0x821F3144;
		  /* 821F3144h */ case   15:  		/* addi R10, R10, 24 */
		/* 821F3144h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3144h case   15:*/		return 0x821F3148;
		  /* 821F3148h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821F3148h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3148h case   16:*/		return 0x821F314C;
		  /* 821F314Ch */ case   17:  		/* addi R6, R10, -36 */
		/* 821F314Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F314Ch case   17:*/		return 0x821F3150;
		  /* 821F3150h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821F3150h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3150h case   18:*/		return 0x821F3154;
		  /* 821F3154h */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821F3154h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3154h case   19:*/		return 0x821F3158;
		  /* 821F3158h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3158h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3158h case   20:*/		return 0x821F315C;
		  /* 821F315Ch */ case   21:  		/* ori R6, R6, 1 */
		/* 821F315Ch case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F315Ch case   21:*/		return 0x821F3160;
		  /* 821F3160h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821F3160h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3160h case   22:*/		return 0x821F3164;
		  /* 821F3164h */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3164h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3164h case   23:*/		return 0x821F3168;
		  /* 821F3168h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821F3168h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3168h case   24:*/		return 0x821F316C;
		  /* 821F316Ch */ case   25:  		/* addi R1, R1, 128 */
		/* 821F316Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F316Ch case   25:*/		return 0x821F3170;
		  /* 821F3170h */ case   26:  		/* b -1449672 */
		/* 821F3170h case   26:*/		return 0x820912A8;
		/* 821F3170h case   26:*/		return 0x821F3174;
		  /* 821F3174h */ case   27:  		/* nop */
		/* 821F3174h case   27:*/		cpu::op::nop();
		/* 821F3174h case   27:*/		return 0x821F3178;
	}
	return 0x821F3178;
} // Block from 821F3108h-821F3178h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F3178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3178);
		  /* 821F3178h */ case    0:  		/* mfspr R12, LR */
		/* 821F3178h case    0:*/		regs.R12 = regs.LR;
		/* 821F3178h case    0:*/		return 0x821F317C;
		  /* 821F317Ch */ case    1:  		/* bl -1449760 */
		/* 821F317Ch case    1:*/		regs.LR = 0x821F3180; return 0x8209125C;
		/* 821F317Ch case    1:*/		return 0x821F3180;
	}
	return 0x821F3180;
} // Block from 821F3178h-821F3180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F3180h
// Function '?ConvertToRVal@Compiler@D3DXShader@@AAAXPAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3180);
		  /* 821F3180h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3180h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3180h case    0:*/		return 0x821F3184;
		  /* 821F3184h */ case    1:  		/* li R8, 4 */
		/* 821F3184h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3184h case    1:*/		return 0x821F3188;
		  /* 821F3188h */ case    2:  		/* li R7, 1 */
		/* 821F3188h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F3188h case    2:*/		return 0x821F318C;
		  /* 821F318Ch */ case    3:  		/* li R6, 9 */
		/* 821F318Ch case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x9);
		/* 821F318Ch case    3:*/		return 0x821F3190;
		  /* 821F3190h */ case    4:  		/* li R5, 0 */
		/* 821F3190h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3190h case    4:*/		return 0x821F3194;
		  /* 821F3194h */ case    5:  		/* mr R30, R4 */
		/* 821F3194h case    5:*/		regs.R30 = regs.R4;
		/* 821F3194h case    5:*/		return 0x821F3198;
		  /* 821F3198h */ case    6:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3198h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3198h case    6:*/		return 0x821F319C;
		  /* 821F319Ch */ case    7:  		/* mr R31, R3 */
		/* 821F319Ch case    7:*/		regs.R31 = regs.R3;
		/* 821F319Ch case    7:*/		return 0x821F31A0;
		  /* 821F31A0h */ case    8:  		/* bl 202744 */
		/* 821F31A0h case    8:*/		regs.LR = 0x821F31A4; return 0x82224998;
		/* 821F31A0h case    8:*/		return 0x821F31A4;
		  /* 821F31A4h */ case    9:  		/* mr R29, R3 */
		/* 821F31A4h case    9:*/		regs.R29 = regs.R3;
		/* 821F31A4h case    9:*/		return 0x821F31A8;
		  /* 821F31A8h */ case   10:  		/* mr R4, R30 */
		/* 821F31A8h case   10:*/		regs.R4 = regs.R30;
		/* 821F31A8h case   10:*/		return 0x821F31AC;
		  /* 821F31ACh */ case   11:  		/* mr R3, R31 */
		/* 821F31ACh case   11:*/		regs.R3 = regs.R31;
		/* 821F31ACh case   11:*/		return 0x821F31B0;
		  /* 821F31B0h */ case   12:  		/* bl -3632 */
		/* 821F31B0h case   12:*/		regs.LR = 0x821F31B4; return 0x821F2380;
		/* 821F31B0h case   12:*/		return 0x821F31B4;
		  /* 821F31B4h */ case   13:  		/* mr R4, R3 */
		/* 821F31B4h case   13:*/		regs.R4 = regs.R3;
		/* 821F31B4h case   13:*/		return 0x821F31B8;
		  /* 821F31B8h */ case   14:  		/* mr R3, R29 */
		/* 821F31B8h case   14:*/		regs.R3 = regs.R29;
		/* 821F31B8h case   14:*/		return 0x821F31BC;
		  /* 821F31BCh */ case   15:  		/* bl -503796 */
		/* 821F31BCh case   15:*/		regs.LR = 0x821F31C0; return 0x821781C8;
		/* 821F31BCh case   15:*/		return 0x821F31C0;
		  /* 821F31C0h */ case   16:  		/* stw R3, <#[R29 + 44]> */
		/* 821F31C0h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F31C0h case   16:*/		return 0x821F31C4;
		  /* 821F31C4h */ case   17:  		/* lwz R9, <#[R3]> */
		/* 821F31C4h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821F31C4h case   17:*/		return 0x821F31C8;
		  /* 821F31C8h */ case   18:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 821F31C8h case   18:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 821F31C8h case   18:*/		return 0x821F31CC;
		  /* 821F31CCh */ case   19:  		/* lwz R10, <#[R29 + 8]> */
		/* 821F31CCh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821F31CCh case   19:*/		return 0x821F31D0;
		  /* 821F31D0h */ case   20:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F31D0h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F31D0h case   20:*/		return 0x821F31D4;
		  /* 821F31D4h */ case   21:  		/* mr R3, R29 */
		/* 821F31D4h case   21:*/		regs.R3 = regs.R29;
		/* 821F31D4h case   21:*/		return 0x821F31D8;
		  /* 821F31D8h */ case   22:  		/* rlwimi R10, R9, 14, 15, 17 */
		/* 821F31D8h case   22:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R9);
		/* 821F31D8h case   22:*/		return 0x821F31DC;
		  /* 821F31DCh */ case   23:  		/* addi R11, R11, 36 */
		/* 821F31DCh case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F31DCh case   23:*/		return 0x821F31E0;
		  /* 821F31E0h */ case   24:  		/* stw R10, <#[R29 + 8]> */
		/* 821F31E0h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821F31E0h case   24:*/		return 0x821F31E4;
		  /* 821F31E4h */ case   25:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F31E4h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F31E4h case   25:*/		return 0x821F31E8;
		  /* 821F31E8h */ case   26:  		/* addi R10, R10, 24 */
		/* 821F31E8h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F31E8h case   26:*/		return 0x821F31EC;
		  /* 821F31ECh */ case   27:  		/* lwz R7, <#[R10]> */
		/* 821F31ECh case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F31ECh case   27:*/		return 0x821F31F0;
		  /* 821F31F0h */ case   28:  		/* addi R6, R10, -36 */
		/* 821F31F0h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F31F0h case   28:*/		return 0x821F31F4;
		  /* 821F31F4h */ case   29:  		/* stw R7, <#[R11]> */
		/* 821F31F4h case   29:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F31F4h case   29:*/		return 0x821F31F8;
		  /* 821F31F8h */ case   30:  		/* addi R8, R11, -36 */
		/* 821F31F8h case   30:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F31F8h case   30:*/		return 0x821F31FC;
		  /* 821F31FCh */ case   31:  		/* lwz R7, <#[R10]> */
		/* 821F31FCh case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F31FCh case   31:*/		return 0x821F3200;
		  /* 821F3200h */ case   32:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3200h case   32:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3200h case   32:*/		return 0x821F3204;
		  /* 821F3204h */ case   33:  		/* ori R6, R6, 1 */
		/* 821F3204h case   33:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3204h case   33:*/		return 0x821F3208;
		  /* 821F3208h */ case   34:  		/* stw R8, <#[R7]> */
		/* 821F3208h case   34:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3208h case   34:*/		return 0x821F320C;
		  /* 821F320Ch */ case   35:  		/* addi R9, R11, 4 */
		/* 821F320Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F320Ch case   35:*/		return 0x821F3210;
		  /* 821F3210h */ case   36:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3210h case   36:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3210h case   36:*/		return 0x821F3214;
		  /* 821F3214h */ case   37:  		/* stw R9, <#[R10]> */
		/* 821F3214h case   37:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3214h case   37:*/		return 0x821F3218;
		  /* 821F3218h */ case   38:  		/* addi R1, R1, 112 */
		/* 821F3218h case   38:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3218h case   38:*/		return 0x821F321C;
		  /* 821F321Ch */ case   39:  		/* b -1449840 */
		/* 821F321Ch case   39:*/		return 0x820912AC;
		/* 821F321Ch case   39:*/		return 0x821F3220;
	}
	return 0x821F3220;
} // Block from 821F3180h-821F3220h (40 instructions)

//////////////////////////////////////////////////////
// Block at 821F3220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3220);
		  /* 821F3220h */ case    0:  		/* mfspr R12, LR */
		/* 821F3220h case    0:*/		regs.R12 = regs.LR;
		/* 821F3220h case    0:*/		return 0x821F3224;
		  /* 821F3224h */ case    1:  		/* bl -1449928 */
		/* 821F3224h case    1:*/		regs.LR = 0x821F3228; return 0x8209125C;
		/* 821F3224h case    1:*/		return 0x821F3228;
		  /* 821F3228h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3228h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3228h case    2:*/		return 0x821F322C;
		  /* 821F322Ch */ case    3:  		/* li R8, 1 */
		/* 821F322Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F322Ch case    3:*/		return 0x821F3230;
		  /* 821F3230h */ case    4:  		/* li R7, 1 */
		/* 821F3230h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F3230h case    4:*/		return 0x821F3234;
		  /* 821F3234h */ case    5:  		/* li R6, 46 */
		/* 821F3234h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x2E);
		/* 821F3234h case    5:*/		return 0x821F3238;
		  /* 821F3238h */ case    6:  		/* li R5, 0 */
		/* 821F3238h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3238h case    6:*/		return 0x821F323C;
		  /* 821F323Ch */ case    7:  		/* mr R30, R4 */
		/* 821F323Ch case    7:*/		regs.R30 = regs.R4;
		/* 821F323Ch case    7:*/		return 0x821F3240;
		  /* 821F3240h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3240h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3240h case    8:*/		return 0x821F3244;
		  /* 821F3244h */ case    9:  		/* mr R31, R3 */
		/* 821F3244h case    9:*/		regs.R31 = regs.R3;
		/* 821F3244h case    9:*/		return 0x821F3248;
		  /* 821F3248h */ case   10:  		/* bl 202576 */
		/* 821F3248h case   10:*/		regs.LR = 0x821F324C; return 0x82224998;
		/* 821F3248h case   10:*/		return 0x821F324C;
		  /* 821F324Ch */ case   11:  		/* mr R29, R3 */
		/* 821F324Ch case   11:*/		regs.R29 = regs.R3;
		/* 821F324Ch case   11:*/		return 0x821F3250;
		  /* 821F3250h */ case   12:  		/* mr R4, R30 */
		/* 821F3250h case   12:*/		regs.R4 = regs.R30;
		/* 821F3250h case   12:*/		return 0x821F3254;
		  /* 821F3254h */ case   13:  		/* mr R3, R31 */
		/* 821F3254h case   13:*/		regs.R3 = regs.R31;
		/* 821F3254h case   13:*/		return 0x821F3258;
		  /* 821F3258h */ case   14:  		/* bl -3800 */
		/* 821F3258h case   14:*/		regs.LR = 0x821F325C; return 0x821F2380;
		/* 821F3258h case   14:*/		return 0x821F325C;
		  /* 821F325Ch */ case   15:  		/* mr R4, R3 */
		/* 821F325Ch case   15:*/		regs.R4 = regs.R3;
		/* 821F325Ch case   15:*/		return 0x821F3260;
		  /* 821F3260h */ case   16:  		/* mr R3, R29 */
		/* 821F3260h case   16:*/		regs.R3 = regs.R29;
		/* 821F3260h case   16:*/		return 0x821F3264;
		  /* 821F3264h */ case   17:  		/* bl -503964 */
		/* 821F3264h case   17:*/		regs.LR = 0x821F3268; return 0x821781C8;
		/* 821F3264h case   17:*/		return 0x821F3268;
		  /* 821F3268h */ case   18:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3268h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3268h case   18:*/		return 0x821F326C;
		  /* 821F326Ch */ case   19:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F326Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F326Ch case   19:*/		return 0x821F3270;
		  /* 821F3270h */ case   20:  		/* addi R11, R11, 24 */
		/* 821F3270h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F3270h case   20:*/		return 0x821F3274;
		  /* 821F3274h */ case   21:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821F3274h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821F3274h case   21:*/		return 0x821F3278;
		  /* 821F3278h */ case   22:  		/* lwz R9, <#[R11]> */
		/* 821F3278h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3278h case   22:*/		return 0x821F327C;
		  /* 821F327Ch */ case   23:  		/* addi R8, R11, -36 */
		/* 821F327Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F327Ch case   23:*/		return 0x821F3280;
		  /* 821F3280h */ case   24:  		/* addi R10, R10, 36 */
		/* 821F3280h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F3280h case   24:*/		return 0x821F3284;
		  /* 821F3284h */ case   25:  		/* stw R9, <#[R10]> */
		/* 821F3284h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3284h case   25:*/		return 0x821F3288;
		  /* 821F3288h */ case   26:  		/* lwz R9, <#[R11]> */
		/* 821F3288h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3288h case   26:*/		return 0x821F328C;
		  /* 821F328Ch */ case   27:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821F328Ch case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821F328Ch case   27:*/		return 0x821F3290;
		  /* 821F3290h */ case   28:  		/* addi R6, R10, -36 */
		/* 821F3290h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3290h case   28:*/		return 0x821F3294;
		  /* 821F3294h */ case   29:  		/* ori R8, R8, 1 */
		/* 821F3294h case   29:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F3294h case   29:*/		return 0x821F3298;
		  /* 821F3298h */ case   30:  		/* addi R9, R10, 4 */
		/* 821F3298h case   30:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F3298h case   30:*/		return 0x821F329C;
		  /* 821F329Ch */ case   31:  		/* stw R6, <#[R7]> */
		/* 821F329Ch case   31:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821F329Ch case   31:*/		return 0x821F32A0;
		  /* 821F32A0h */ case   32:  		/* stw R8, <#[R10 + 4]> */
		/* 821F32A0h case   32:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821F32A0h case   32:*/		return 0x821F32A4;
		  /* 821F32A4h */ case   33:  		/* mr R3, R29 */
		/* 821F32A4h case   33:*/		regs.R3 = regs.R29;
		/* 821F32A4h case   33:*/		return 0x821F32A8;
		  /* 821F32A8h */ case   34:  		/* stw R9, <#[R11]> */
		/* 821F32A8h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F32A8h case   34:*/		return 0x821F32AC;
		  /* 821F32ACh */ case   35:  		/* addi R1, R1, 112 */
		/* 821F32ACh case   35:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F32ACh case   35:*/		return 0x821F32B0;
		  /* 821F32B0h */ case   36:  		/* b -1449988 */
		/* 821F32B0h case   36:*/		return 0x820912AC;
		/* 821F32B0h case   36:*/		return 0x821F32B4;
		  /* 821F32B4h */ case   37:  		/* nop */
		/* 821F32B4h case   37:*/		cpu::op::nop();
		/* 821F32B4h case   37:*/		return 0x821F32B8;
	}
	return 0x821F32B8;
} // Block from 821F3220h-821F32B8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821F32B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F32B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F32B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F32B8);
		  /* 821F32B8h */ case    0:  		/* mfspr R12, LR */
		/* 821F32B8h case    0:*/		regs.R12 = regs.LR;
		/* 821F32B8h case    0:*/		return 0x821F32BC;
		  /* 821F32BCh */ case    1:  		/* bl -1450080 */
		/* 821F32BCh case    1:*/		regs.LR = 0x821F32C0; return 0x8209125C;
		/* 821F32BCh case    1:*/		return 0x821F32C0;
		  /* 821F32C0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F32C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F32C0h case    2:*/		return 0x821F32C4;
		  /* 821F32C4h */ case    3:  		/* li R8, 1 */
		/* 821F32C4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F32C4h case    3:*/		return 0x821F32C8;
		  /* 821F32C8h */ case    4:  		/* li R7, 1 */
		/* 821F32C8h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F32C8h case    4:*/		return 0x821F32CC;
		  /* 821F32CCh */ case    5:  		/* li R6, 48 */
		/* 821F32CCh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x30);
		/* 821F32CCh case    5:*/		return 0x821F32D0;
		  /* 821F32D0h */ case    6:  		/* li R5, 0 */
		/* 821F32D0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F32D0h case    6:*/		return 0x821F32D4;
		  /* 821F32D4h */ case    7:  		/* mr R30, R4 */
		/* 821F32D4h case    7:*/		regs.R30 = regs.R4;
		/* 821F32D4h case    7:*/		return 0x821F32D8;
		  /* 821F32D8h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F32D8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F32D8h case    8:*/		return 0x821F32DC;
		  /* 821F32DCh */ case    9:  		/* mr R31, R3 */
		/* 821F32DCh case    9:*/		regs.R31 = regs.R3;
		/* 821F32DCh case    9:*/		return 0x821F32E0;
		  /* 821F32E0h */ case   10:  		/* bl 202424 */
		/* 821F32E0h case   10:*/		regs.LR = 0x821F32E4; return 0x82224998;
		/* 821F32E0h case   10:*/		return 0x821F32E4;
		  /* 821F32E4h */ case   11:  		/* mr R29, R3 */
		/* 821F32E4h case   11:*/		regs.R29 = regs.R3;
		/* 821F32E4h case   11:*/		return 0x821F32E8;
		  /* 821F32E8h */ case   12:  		/* mr R4, R30 */
		/* 821F32E8h case   12:*/		regs.R4 = regs.R30;
		/* 821F32E8h case   12:*/		return 0x821F32EC;
		  /* 821F32ECh */ case   13:  		/* mr R3, R31 */
		/* 821F32ECh case   13:*/		regs.R3 = regs.R31;
		/* 821F32ECh case   13:*/		return 0x821F32F0;
		  /* 821F32F0h */ case   14:  		/* bl -3952 */
		/* 821F32F0h case   14:*/		regs.LR = 0x821F32F4; return 0x821F2380;
		/* 821F32F0h case   14:*/		return 0x821F32F4;
		  /* 821F32F4h */ case   15:  		/* mr R4, R3 */
		/* 821F32F4h case   15:*/		regs.R4 = regs.R3;
		/* 821F32F4h case   15:*/		return 0x821F32F8;
		  /* 821F32F8h */ case   16:  		/* mr R3, R29 */
		/* 821F32F8h case   16:*/		regs.R3 = regs.R29;
		/* 821F32F8h case   16:*/		return 0x821F32FC;
		  /* 821F32FCh */ case   17:  		/* bl -504116 */
		/* 821F32FCh case   17:*/		regs.LR = 0x821F3300; return 0x821781C8;
		/* 821F32FCh case   17:*/		return 0x821F3300;
		  /* 821F3300h */ case   18:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3300h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3300h case   18:*/		return 0x821F3304;
		  /* 821F3304h */ case   19:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F3304h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3304h case   19:*/		return 0x821F3308;
		  /* 821F3308h */ case   20:  		/* addi R11, R11, 24 */
		/* 821F3308h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F3308h case   20:*/		return 0x821F330C;
		  /* 821F330Ch */ case   21:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821F330Ch case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821F330Ch case   21:*/		return 0x821F3310;
		  /* 821F3310h */ case   22:  		/* lwz R9, <#[R11]> */
		/* 821F3310h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3310h case   22:*/		return 0x821F3314;
		  /* 821F3314h */ case   23:  		/* addi R8, R11, -36 */
		/* 821F3314h case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3314h case   23:*/		return 0x821F3318;
		  /* 821F3318h */ case   24:  		/* addi R10, R10, 36 */
		/* 821F3318h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F3318h case   24:*/		return 0x821F331C;
		  /* 821F331Ch */ case   25:  		/* stw R9, <#[R10]> */
		/* 821F331Ch case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F331Ch case   25:*/		return 0x821F3320;
		  /* 821F3320h */ case   26:  		/* lwz R9, <#[R11]> */
		/* 821F3320h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3320h case   26:*/		return 0x821F3324;
		  /* 821F3324h */ case   27:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821F3324h case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821F3324h case   27:*/		return 0x821F3328;
		  /* 821F3328h */ case   28:  		/* addi R6, R10, -36 */
		/* 821F3328h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3328h case   28:*/		return 0x821F332C;
		  /* 821F332Ch */ case   29:  		/* ori R8, R8, 1 */
		/* 821F332Ch case   29:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F332Ch case   29:*/		return 0x821F3330;
		  /* 821F3330h */ case   30:  		/* addi R9, R10, 4 */
		/* 821F3330h case   30:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F3330h case   30:*/		return 0x821F3334;
		  /* 821F3334h */ case   31:  		/* stw R6, <#[R7]> */
		/* 821F3334h case   31:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3334h case   31:*/		return 0x821F3338;
		  /* 821F3338h */ case   32:  		/* stw R8, <#[R10 + 4]> */
		/* 821F3338h case   32:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821F3338h case   32:*/		return 0x821F333C;
		  /* 821F333Ch */ case   33:  		/* mr R3, R29 */
		/* 821F333Ch case   33:*/		regs.R3 = regs.R29;
		/* 821F333Ch case   33:*/		return 0x821F3340;
		  /* 821F3340h */ case   34:  		/* stw R9, <#[R11]> */
		/* 821F3340h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3340h case   34:*/		return 0x821F3344;
		  /* 821F3344h */ case   35:  		/* addi R1, R1, 112 */
		/* 821F3344h case   35:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3344h case   35:*/		return 0x821F3348;
		  /* 821F3348h */ case   36:  		/* b -1450140 */
		/* 821F3348h case   36:*/		return 0x820912AC;
		/* 821F3348h case   36:*/		return 0x821F334C;
		  /* 821F334Ch */ case   37:  		/* nop */
		/* 821F334Ch case   37:*/		cpu::op::nop();
		/* 821F334Ch case   37:*/		return 0x821F3350;
	}
	return 0x821F3350;
} // Block from 821F32B8h-821F3350h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821F3350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3350);
		  /* 821F3350h */ case    0:  		/* mfspr R12, LR */
		/* 821F3350h case    0:*/		regs.R12 = regs.LR;
		/* 821F3350h case    0:*/		return 0x821F3354;
		  /* 821F3354h */ case    1:  		/* bl -1450232 */
		/* 821F3354h case    1:*/		regs.LR = 0x821F3358; return 0x8209125C;
		/* 821F3354h case    1:*/		return 0x821F3358;
		  /* 821F3358h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3358h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3358h case    2:*/		return 0x821F335C;
		  /* 821F335Ch */ case    3:  		/* li R8, 1 */
		/* 821F335Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F335Ch case    3:*/		return 0x821F3360;
		  /* 821F3360h */ case    4:  		/* li R7, 1 */
		/* 821F3360h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F3360h case    4:*/		return 0x821F3364;
		  /* 821F3364h */ case    5:  		/* li R6, 51 */
		/* 821F3364h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x33);
		/* 821F3364h case    5:*/		return 0x821F3368;
		  /* 821F3368h */ case    6:  		/* li R5, 0 */
		/* 821F3368h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3368h case    6:*/		return 0x821F336C;
		  /* 821F336Ch */ case    7:  		/* mr R30, R4 */
		/* 821F336Ch case    7:*/		regs.R30 = regs.R4;
		/* 821F336Ch case    7:*/		return 0x821F3370;
		  /* 821F3370h */ case    8:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3370h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3370h case    8:*/		return 0x821F3374;
		  /* 821F3374h */ case    9:  		/* mr R31, R3 */
		/* 821F3374h case    9:*/		regs.R31 = regs.R3;
		/* 821F3374h case    9:*/		return 0x821F3378;
		  /* 821F3378h */ case   10:  		/* bl 202272 */
		/* 821F3378h case   10:*/		regs.LR = 0x821F337C; return 0x82224998;
		/* 821F3378h case   10:*/		return 0x821F337C;
		  /* 821F337Ch */ case   11:  		/* mr R29, R3 */
		/* 821F337Ch case   11:*/		regs.R29 = regs.R3;
		/* 821F337Ch case   11:*/		return 0x821F3380;
		  /* 821F3380h */ case   12:  		/* mr R4, R30 */
		/* 821F3380h case   12:*/		regs.R4 = regs.R30;
		/* 821F3380h case   12:*/		return 0x821F3384;
		  /* 821F3384h */ case   13:  		/* mr R3, R31 */
		/* 821F3384h case   13:*/		regs.R3 = regs.R31;
		/* 821F3384h case   13:*/		return 0x821F3388;
		  /* 821F3388h */ case   14:  		/* bl -4104 */
		/* 821F3388h case   14:*/		regs.LR = 0x821F338C; return 0x821F2380;
		/* 821F3388h case   14:*/		return 0x821F338C;
		  /* 821F338Ch */ case   15:  		/* mr R4, R3 */
		/* 821F338Ch case   15:*/		regs.R4 = regs.R3;
		/* 821F338Ch case   15:*/		return 0x821F3390;
		  /* 821F3390h */ case   16:  		/* mr R3, R29 */
		/* 821F3390h case   16:*/		regs.R3 = regs.R29;
		/* 821F3390h case   16:*/		return 0x821F3394;
		  /* 821F3394h */ case   17:  		/* bl -504268 */
		/* 821F3394h case   17:*/		regs.LR = 0x821F3398; return 0x821781C8;
		/* 821F3394h case   17:*/		return 0x821F3398;
	}
	return 0x821F3398;
} // Block from 821F3350h-821F3398h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F3398h
// Function '?Get@MatrixAccessor@D3DXShader@@QAAPAVResult@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3398);
		  /* 821F3398h */ case    0:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3398h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3398h case    0:*/		return 0x821F339C;
		  /* 821F339Ch */ case    1:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F339Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F339Ch case    1:*/		return 0x821F33A0;
		  /* 821F33A0h */ case    2:  		/* addi R11, R11, 24 */
		/* 821F33A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F33A0h case    2:*/		return 0x821F33A4;
		  /* 821F33A4h */ case    3:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821F33A4h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821F33A4h case    3:*/		return 0x821F33A8;
		  /* 821F33A8h */ case    4:  		/* lwz R9, <#[R11]> */
		/* 821F33A8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F33A8h case    4:*/		return 0x821F33AC;
		  /* 821F33ACh */ case    5:  		/* addi R8, R11, -36 */
		/* 821F33ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F33ACh case    5:*/		return 0x821F33B0;
		  /* 821F33B0h */ case    6:  		/* addi R10, R10, 36 */
		/* 821F33B0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F33B0h case    6:*/		return 0x821F33B4;
		  /* 821F33B4h */ case    7:  		/* stw R9, <#[R10]> */
		/* 821F33B4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F33B4h case    7:*/		return 0x821F33B8;
		  /* 821F33B8h */ case    8:  		/* lwz R9, <#[R11]> */
		/* 821F33B8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F33B8h case    8:*/		return 0x821F33BC;
		  /* 821F33BCh */ case    9:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821F33BCh case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821F33BCh case    9:*/		return 0x821F33C0;
		  /* 821F33C0h */ case   10:  		/* addi R6, R10, -36 */
		/* 821F33C0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F33C0h case   10:*/		return 0x821F33C4;
		  /* 821F33C4h */ case   11:  		/* ori R8, R8, 1 */
		/* 821F33C4h case   11:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F33C4h case   11:*/		return 0x821F33C8;
		  /* 821F33C8h */ case   12:  		/* addi R9, R10, 4 */
		/* 821F33C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F33C8h case   12:*/		return 0x821F33CC;
		  /* 821F33CCh */ case   13:  		/* stw R6, <#[R7]> */
		/* 821F33CCh case   13:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821F33CCh case   13:*/		return 0x821F33D0;
		  /* 821F33D0h */ case   14:  		/* stw R8, <#[R10 + 4]> */
		/* 821F33D0h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821F33D0h case   14:*/		return 0x821F33D4;
		  /* 821F33D4h */ case   15:  		/* mr R3, R29 */
		/* 821F33D4h case   15:*/		regs.R3 = regs.R29;
		/* 821F33D4h case   15:*/		return 0x821F33D8;
		  /* 821F33D8h */ case   16:  		/* stw R9, <#[R11]> */
		/* 821F33D8h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F33D8h case   16:*/		return 0x821F33DC;
		  /* 821F33DCh */ case   17:  		/* addi R1, R1, 112 */
		/* 821F33DCh case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F33DCh case   17:*/		return 0x821F33E0;
		  /* 821F33E0h */ case   18:  		/* b -1450292 */
		/* 821F33E0h case   18:*/		return 0x820912AC;
		/* 821F33E0h case   18:*/		return 0x821F33E4;
		  /* 821F33E4h */ case   19:  		/* nop */
		/* 821F33E4h case   19:*/		cpu::op::nop();
		/* 821F33E4h case   19:*/		return 0x821F33E8;
	}
	return 0x821F33E8;
} // Block from 821F3398h-821F33E8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F33E8h
// Function '?RemoveNext@?$ArrayListEnumerator@UAttributeState@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F33E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F33E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F33E8);
		  /* 821F33E8h */ case    0:  		/* mfspr R12, LR */
		/* 821F33E8h case    0:*/		regs.R12 = regs.LR;
		/* 821F33E8h case    0:*/		return 0x821F33EC;
		  /* 821F33ECh */ case    1:  		/* bl -1450392 */
		/* 821F33ECh case    1:*/		regs.LR = 0x821F33F0; return 0x82091254;
		/* 821F33ECh case    1:*/		return 0x821F33F0;
		  /* 821F33F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F33F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F33F0h case    2:*/		return 0x821F33F4;
		  /* 821F33F4h */ case    3:  		/* mr R30, R4 */
		/* 821F33F4h case    3:*/		regs.R30 = regs.R4;
		/* 821F33F4h case    3:*/		return 0x821F33F8;
		  /* 821F33F8h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 821F33F8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 821F33F8h case    4:*/		return 0x821F33FC;
		  /* 821F33FCh */ case    5:  		/* mr R29, R5 */
		/* 821F33FCh case    5:*/		regs.R29 = regs.R5;
		/* 821F33FCh case    5:*/		return 0x821F3400;
		  /* 821F3400h */ case    6:  		/* mr R28, R6 */
		/* 821F3400h case    6:*/		regs.R28 = regs.R6;
		/* 821F3400h case    6:*/		return 0x821F3404;
		  /* 821F3404h */ case    7:  		/* li R8, 1 */
		/* 821F3404h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F3404h case    7:*/		return 0x821F3408;
		  /* 821F3408h */ case    8:  		/* li R7, 1 */
		/* 821F3408h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F3408h case    8:*/		return 0x821F340C;
		  /* 821F340Ch */ case    9:  		/* li R6, 60 */
		/* 821F340Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x3C);
		/* 821F340Ch case    9:*/		return 0x821F3410;
		  /* 821F3410h */ case   10:  		/* li R5, 0 */
		/* 821F3410h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3410h case   10:*/		return 0x821F3414;
		  /* 821F3414h */ case   11:  		/* mr R31, R3 */
		/* 821F3414h case   11:*/		regs.R31 = regs.R3;
		/* 821F3414h case   11:*/		return 0x821F3418;
		  /* 821F3418h */ case   12:  		/* bl 202112 */
		/* 821F3418h case   12:*/		regs.LR = 0x821F341C; return 0x82224998;
		/* 821F3418h case   12:*/		return 0x821F341C;
		  /* 821F341Ch */ case   13:  		/* mr R27, R3 */
		/* 821F341Ch case   13:*/		regs.R27 = regs.R3;
		/* 821F341Ch case   13:*/		return 0x821F3420;
		  /* 821F3420h */ case   14:  		/* mr R3, R31 */
		/* 821F3420h case   14:*/		regs.R3 = regs.R31;
		/* 821F3420h case   14:*/		return 0x821F3424;
		  /* 821F3424h */ case   15:  		/* mr R4, R28 */
		/* 821F3424h case   15:*/		regs.R4 = regs.R28;
		/* 821F3424h case   15:*/		return 0x821F3428;
		  /* 821F3428h */ case   16:  		/* bl -4264 */
		/* 821F3428h case   16:*/		regs.LR = 0x821F342C; return 0x821F2380;
		/* 821F3428h case   16:*/		return 0x821F342C;
		  /* 821F342Ch */ case   17:  		/* mr R4, R3 */
		/* 821F342Ch case   17:*/		regs.R4 = regs.R3;
		/* 821F342Ch case   17:*/		return 0x821F3430;
		  /* 821F3430h */ case   18:  		/* mr R3, R27 */
		/* 821F3430h case   18:*/		regs.R3 = regs.R27;
		/* 821F3430h case   18:*/		return 0x821F3434;
		  /* 821F3434h */ case   19:  		/* bl -504428 */
		/* 821F3434h case   19:*/		regs.LR = 0x821F3438; return 0x821781C8;
		/* 821F3434h case   19:*/		return 0x821F3438;
		  /* 821F3438h */ case   20:  		/* stw R3, <#[R27 + 44]> */
		/* 821F3438h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x0000002C) );
		/* 821F3438h case   20:*/		return 0x821F343C;
		  /* 821F343Ch */ case   21:  		/* mr R4, R27 */
		/* 821F343Ch case   21:*/		regs.R4 = regs.R27;
		/* 821F343Ch case   21:*/		return 0x821F3440;
		  /* 821F3440h */ case   22:  		/* mr R6, R29 */
		/* 821F3440h case   22:*/		regs.R6 = regs.R29;
		/* 821F3440h case   22:*/		return 0x821F3444;
		  /* 821F3444h */ case   23:  		/* mr R5, R30 */
		/* 821F3444h case   23:*/		regs.R5 = regs.R30;
		/* 821F3444h case   23:*/		return 0x821F3448;
		  /* 821F3448h */ case   24:  		/* mr R3, R31 */
		/* 821F3448h case   24:*/		regs.R3 = regs.R31;
		/* 821F3448h case   24:*/		return 0x821F344C;
		  /* 821F344Ch */ case   25:  		/* bl -550308 */
		/* 821F344Ch case   25:*/		regs.LR = 0x821F3450; return 0x8216CEA8;
		/* 821F344Ch case   25:*/		return 0x821F3450;
		  /* 821F3450h */ case   26:  		/* mr R3, R27 */
		/* 821F3450h case   26:*/		regs.R3 = regs.R27;
		/* 821F3450h case   26:*/		return 0x821F3454;
		  /* 821F3454h */ case   27:  		/* addi R1, R1, 128 */
		/* 821F3454h case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F3454h case   27:*/		return 0x821F3458;
		  /* 821F3458h */ case   28:  		/* b -1450420 */
		/* 821F3458h case   28:*/		return 0x820912A4;
		/* 821F3458h case   28:*/		return 0x821F345C;
		  /* 821F345Ch */ case   29:  		/* nop */
		/* 821F345Ch case   29:*/		cpu::op::nop();
		/* 821F345Ch case   29:*/		return 0x821F3460;
	}
	return 0x821F3460;
} // Block from 821F33E8h-821F3460h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821F3460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3460);
		  /* 821F3460h */ case    0:  		/* mfspr R12, LR */
		/* 821F3460h case    0:*/		regs.R12 = regs.LR;
		/* 821F3460h case    0:*/		return 0x821F3464;
		  /* 821F3464h */ case    1:  		/* bl -1450508 */
		/* 821F3464h case    1:*/		regs.LR = 0x821F3468; return 0x82091258;
		/* 821F3464h case    1:*/		return 0x821F3468;
		  /* 821F3468h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F3468h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F3468h case    2:*/		return 0x821F346C;
		  /* 821F346Ch */ case    3:  		/* mr R29, R5 */
		/* 821F346Ch case    3:*/		regs.R29 = regs.R5;
		/* 821F346Ch case    3:*/		return 0x821F3470;
		  /* 821F3470h */ case    4:  		/* li R8, 4 */
		/* 821F3470h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3470h case    4:*/		return 0x821F3474;
		  /* 821F3474h */ case    5:  		/* li R7, 2 */
		/* 821F3474h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3474h case    5:*/		return 0x821F3478;
		  /* 821F3478h */ case    6:  		/* li R6, 97 */
		/* 821F3478h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x61);
		/* 821F3478h case    6:*/		return 0x821F347C;
		  /* 821F347Ch */ case    7:  		/* li R5, 0 */
		/* 821F347Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F347Ch case    7:*/		return 0x821F3480;
		  /* 821F3480h */ case    8:  		/* mr R28, R4 */
		/* 821F3480h case    8:*/		regs.R28 = regs.R4;
		/* 821F3480h case    8:*/		return 0x821F3484;
		  /* 821F3484h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3484h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3484h case    9:*/		return 0x821F3488;
		  /* 821F3488h */ case   10:  		/* mr R30, R3 */
		/* 821F3488h case   10:*/		regs.R30 = regs.R3;
		/* 821F3488h case   10:*/		return 0x821F348C;
		  /* 821F348Ch */ case   11:  		/* bl 201996 */
		/* 821F348Ch case   11:*/		regs.LR = 0x821F3490; return 0x82224998;
		/* 821F348Ch case   11:*/		return 0x821F3490;
		  /* 821F3490h */ case   12:  		/* mr R31, R3 */
		/* 821F3490h case   12:*/		regs.R31 = regs.R3;
		/* 821F3490h case   12:*/		return 0x821F3494;
		  /* 821F3494h */ case   13:  		/* mr R4, R28 */
		/* 821F3494h case   13:*/		regs.R4 = regs.R28;
		/* 821F3494h case   13:*/		return 0x821F3498;
		  /* 821F3498h */ case   14:  		/* mr R3, R30 */
		/* 821F3498h case   14:*/		regs.R3 = regs.R30;
		/* 821F3498h case   14:*/		return 0x821F349C;
		  /* 821F349Ch */ case   15:  		/* bl -4380 */
		/* 821F349Ch case   15:*/		regs.LR = 0x821F34A0; return 0x821F2380;
		/* 821F349Ch case   15:*/		return 0x821F34A0;
		  /* 821F34A0h */ case   16:  		/* mr R4, R3 */
		/* 821F34A0h case   16:*/		regs.R4 = regs.R3;
		/* 821F34A0h case   16:*/		return 0x821F34A4;
		  /* 821F34A4h */ case   17:  		/* mr R3, R31 */
		/* 821F34A4h case   17:*/		regs.R3 = regs.R31;
		/* 821F34A4h case   17:*/		return 0x821F34A8;
		  /* 821F34A8h */ case   18:  		/* bl -504544 */
		/* 821F34A8h case   18:*/		regs.LR = 0x821F34AC; return 0x821781C8;
		/* 821F34A8h case   18:*/		return 0x821F34AC;
		  /* 821F34ACh */ case   19:  		/* stw R3, <#[R31 + 44]> */
		/* 821F34ACh case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F34ACh case   19:*/		return 0x821F34B0;
		  /* 821F34B0h */ case   20:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F34B0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F34B0h case   20:*/		return 0x821F34B4;
		  /* 821F34B4h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821F34B4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F34B4h case   21:*/		return 0x821F34B8;
		  /* 821F34B8h */ case   22:  		/* mr R4, R29 */
		/* 821F34B8h case   22:*/		regs.R4 = regs.R29;
		/* 821F34B8h case   22:*/		return 0x821F34BC;
		  /* 821F34BCh */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821F34BCh case   23:*/		if ( regs.CR[6].eq ) { return 0x821F34D0;  }
		/* 821F34BCh case   23:*/		return 0x821F34C0;
		  /* 821F34C0h */ case   24:  		/* mr R3, R30 */
		/* 821F34C0h case   24:*/		regs.R3 = regs.R30;
		/* 821F34C0h case   24:*/		return 0x821F34C4;
		  /* 821F34C4h */ case   25:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F34C4h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F34C4h case   25:*/		return 0x821F34C8;
		  /* 821F34C8h */ case   26:  		/* bl -533464 */
		/* 821F34C8h case   26:*/		regs.LR = 0x821F34CC; return 0x821710F0;
		/* 821F34C8h case   26:*/		return 0x821F34CC;
		  /* 821F34CCh */ case   27:  		/* mr R4, R3 */
		/* 821F34CCh case   27:*/		regs.R4 = regs.R3;
		/* 821F34CCh case   27:*/		return 0x821F34D0;
	}
	return 0x821F34D0;
} // Block from 821F3460h-821F34D0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F34D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F34D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F34D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F34D0);
		  /* 821F34D0h */ case    0:  		/* mr R3, R31 */
		/* 821F34D0h case    0:*/		regs.R3 = regs.R31;
		/* 821F34D0h case    0:*/		return 0x821F34D4;
		  /* 821F34D4h */ case    1:  		/* bl -504588 */
		/* 821F34D4h case    1:*/		regs.LR = 0x821F34D8; return 0x821781C8;
		/* 821F34D4h case    1:*/		return 0x821F34D8;
		  /* 821F34D8h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 821F34D8h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F34D8h case    2:*/		return 0x821F34DC;
		  /* 821F34DCh */ case    3:  		/* lwz R11, <#[R30 + 564]> */
		/* 821F34DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000234) );
		/* 821F34DCh case    3:*/		return 0x821F34E0;
		  /* 821F34E0h */ case    4:  		/* addi R11, R11, 24 */
		/* 821F34E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821F34E0h case    4:*/		return 0x821F34E4;
		  /* 821F34E4h */ case    5:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821F34E4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821F34E4h case    5:*/		return 0x821F34E8;
		  /* 821F34E8h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821F34E8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F34E8h case    6:*/		return 0x821F34EC;
		  /* 821F34ECh */ case    7:  		/* addi R8, R11, -36 */
		/* 821F34ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F34ECh case    7:*/		return 0x821F34F0;
		  /* 821F34F0h */ case    8:  		/* addi R10, R10, 36 */
		/* 821F34F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821F34F0h case    8:*/		return 0x821F34F4;
		  /* 821F34F4h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821F34F4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F34F4h case    9:*/		return 0x821F34F8;
		  /* 821F34F8h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821F34F8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F34F8h case   10:*/		return 0x821F34FC;
		  /* 821F34FCh */ case   11:  		/* rlwinm R7, R9, 0, 0, 30 */
		/* 821F34FCh case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R9);
		/* 821F34FCh case   11:*/		return 0x821F3500;
		  /* 821F3500h */ case   12:  		/* addi R6, R10, -36 */
		/* 821F3500h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3500h case   12:*/		return 0x821F3504;
		  /* 821F3504h */ case   13:  		/* ori R8, R8, 1 */
		/* 821F3504h case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F3504h case   13:*/		return 0x821F3508;
		  /* 821F3508h */ case   14:  		/* addi R9, R10, 4 */
		/* 821F3508h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821F3508h case   14:*/		return 0x821F350C;
		  /* 821F350Ch */ case   15:  		/* stw R6, <#[R7]> */
		/* 821F350Ch case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821F350Ch case   15:*/		return 0x821F3510;
		  /* 821F3510h */ case   16:  		/* stw R8, <#[R10 + 4]> */
		/* 821F3510h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821F3510h case   16:*/		return 0x821F3514;
		  /* 821F3514h */ case   17:  		/* mr R3, R31 */
		/* 821F3514h case   17:*/		regs.R3 = regs.R31;
		/* 821F3514h case   17:*/		return 0x821F3518;
		  /* 821F3518h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821F3518h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3518h case   18:*/		return 0x821F351C;
		  /* 821F351Ch */ case   19:  		/* addi R1, R1, 128 */
		/* 821F351Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F351Ch case   19:*/		return 0x821F3520;
		  /* 821F3520h */ case   20:  		/* b -1450616 */
		/* 821F3520h case   20:*/		return 0x820912A8;
		/* 821F3520h case   20:*/		return 0x821F3524;
		  /* 821F3524h */ case   21:  		/* nop */
		/* 821F3524h case   21:*/		cpu::op::nop();
		/* 821F3524h case   21:*/		return 0x821F3528;
	}
	return 0x821F3528;
} // Block from 821F34D0h-821F3528h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F3528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3528);
		  /* 821F3528h */ case    0:  		/* mfspr R12, LR */
		/* 821F3528h case    0:*/		regs.R12 = regs.LR;
		/* 821F3528h case    0:*/		return 0x821F352C;
		  /* 821F352Ch */ case    1:  		/* bl -1450704 */
		/* 821F352Ch case    1:*/		regs.LR = 0x821F3530; return 0x8209125C;
		/* 821F352Ch case    1:*/		return 0x821F3530;
		  /* 821F3530h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3530h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3530h case    2:*/		return 0x821F3534;
		  /* 821F3534h */ case    3:  		/* mr R30, R5 */
		/* 821F3534h case    3:*/		regs.R30 = regs.R5;
		/* 821F3534h case    3:*/		return 0x821F3538;
		  /* 821F3538h */ case    4:  		/* std R4, <#[R1 + 136]> */
		/* 821F3538h case    4:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F3538h case    4:*/		return 0x821F353C;
		  /* 821F353Ch */ case    5:  		/* li R8, 4 */
		/* 821F353Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F353Ch case    5:*/		return 0x821F3540;
	}
	return 0x821F3540;
} // Block from 821F3528h-821F3540h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F3540h
// Function '?IsAtBottom@?$StackEnumerator@ULexicalScope@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3540);
		  /* 821F3540h */ case    0:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3540h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3540h case    0:*/		return 0x821F3544;
		  /* 821F3544h */ case    1:  		/* li R7, 2 */
		/* 821F3544h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3544h case    1:*/		return 0x821F3548;
		  /* 821F3548h */ case    2:  		/* li R6, 2 */
		/* 821F3548h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F3548h case    2:*/		return 0x821F354C;
		  /* 821F354Ch */ case    3:  		/* li R5, 0 */
		/* 821F354Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F354Ch case    3:*/		return 0x821F3550;
		  /* 821F3550h */ case    4:  		/* mr R31, R3 */
		/* 821F3550h case    4:*/		regs.R31 = regs.R3;
		/* 821F3550h case    4:*/		return 0x821F3554;
		  /* 821F3554h */ case    5:  		/* bl 201796 */
		/* 821F3554h case    5:*/		regs.LR = 0x821F3558; return 0x82224998;
		/* 821F3554h case    5:*/		return 0x821F3558;
		  /* 821F3558h */ case    6:  		/* mr R29, R3 */
		/* 821F3558h case    6:*/		regs.R29 = regs.R3;
		/* 821F3558h case    6:*/		return 0x821F355C;
		  /* 821F355Ch */ case    7:  		/* addi R4, R1, 136 */
		/* 821F355Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F355Ch case    7:*/		return 0x821F3560;
		  /* 821F3560h */ case    8:  		/* mr R3, R31 */
		/* 821F3560h case    8:*/		regs.R3 = regs.R31;
		/* 821F3560h case    8:*/		return 0x821F3564;
		  /* 821F3564h */ case    9:  		/* bl -4580 */
		/* 821F3564h case    9:*/		regs.LR = 0x821F3568; return 0x821F2380;
		/* 821F3564h case    9:*/		return 0x821F3568;
		  /* 821F3568h */ case   10:  		/* mr R4, R3 */
		/* 821F3568h case   10:*/		regs.R4 = regs.R3;
		/* 821F3568h case   10:*/		return 0x821F356C;
		  /* 821F356Ch */ case   11:  		/* mr R3, R29 */
		/* 821F356Ch case   11:*/		regs.R3 = regs.R29;
		/* 821F356Ch case   11:*/		return 0x821F3570;
		  /* 821F3570h */ case   12:  		/* bl -504744 */
		/* 821F3570h case   12:*/		regs.LR = 0x821F3574; return 0x821781C8;
		/* 821F3570h case   12:*/		return 0x821F3574;
		  /* 821F3574h */ case   13:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3574h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3574h case   13:*/		return 0x821F3578;
		  /* 821F3578h */ case   14:  		/* mr R4, R30 */
		/* 821F3578h case   14:*/		regs.R4 = regs.R30;
		/* 821F3578h case   14:*/		return 0x821F357C;
		  /* 821F357Ch */ case   15:  		/* mr R3, R31 */
		/* 821F357Ch case   15:*/		regs.R3 = regs.R31;
		/* 821F357Ch case   15:*/		return 0x821F3580;
	}
	return 0x821F3580;
} // Block from 821F3540h-821F3580h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F3580h
// Function '?GoToTop@?$StackEnumerator@ULexicalScope@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3580);
		  /* 821F3580h */ case    0:  		/* bl -505216 */
		/* 821F3580h case    0:*/		regs.LR = 0x821F3584; return 0x82178000;
		/* 821F3580h case    0:*/		return 0x821F3584;
		  /* 821F3584h */ case    1:  		/* mr R4, R3 */
		/* 821F3584h case    1:*/		regs.R4 = regs.R3;
		/* 821F3584h case    1:*/		return 0x821F3588;
		  /* 821F3588h */ case    2:  		/* mr R3, R29 */
		/* 821F3588h case    2:*/		regs.R3 = regs.R29;
		/* 821F3588h case    2:*/		return 0x821F358C;
		  /* 821F358Ch */ case    3:  		/* bl -504772 */
		/* 821F358Ch case    3:*/		regs.LR = 0x821F3590; return 0x821781C8;
		/* 821F358Ch case    3:*/		return 0x821F3590;
		  /* 821F3590h */ case    4:  		/* lwz R10, <#[R29 + 44]> */
		/* 821F3590h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3590h case    4:*/		return 0x821F3594;
		  /* 821F3594h */ case    5:  		/* stw R3, <#[R29 + 48]> */
		/* 821F3594h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 821F3594h case    5:*/		return 0x821F3598;
		  /* 821F3598h */ case    6:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F3598h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F3598h case    6:*/		return 0x821F359C;
		  /* 821F359Ch */ case    7:  		/* lwz R9, <#[R29 + 8]> */
		/* 821F359Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F359Ch case    7:*/		return 0x821F35A0;
		  /* 821F35A0h */ case    8:  		/* mr R3, R29 */
		/* 821F35A0h case    8:*/		regs.R3 = regs.R29;
		/* 821F35A0h case    8:*/		return 0x821F35A4;
		  /* 821F35A4h */ case    9:  		/* addi R11, R11, 36 */
		/* 821F35A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F35A4h case    9:*/		return 0x821F35A8;
		  /* 821F35A8h */ case   10:  		/* lwz R10, <#[R10]> */
		/* 821F35A8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F35A8h case   10:*/		return 0x821F35AC;
		  /* 821F35ACh */ case   11:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F35ACh case   11:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F35ACh case   11:*/		return 0x821F35B0;
		  /* 821F35B0h */ case   12:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F35B0h case   12:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F35B0h case   12:*/		return 0x821F35B4;
		  /* 821F35B4h */ case   13:  		/* addi R8, R11, -36 */
		/* 821F35B4h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F35B4h case   13:*/		return 0x821F35B8;
		  /* 821F35B8h */ case   14:  		/* stw R9, <#[R29 + 8]> */
		/* 821F35B8h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F35B8h case   14:*/		return 0x821F35BC;
		  /* 821F35BCh */ case   15:  		/* addi R9, R11, 4 */
		/* 821F35BCh case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F35BCh case   15:*/		return 0x821F35C0;
		  /* 821F35C0h */ case   16:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F35C0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F35C0h case   16:*/		return 0x821F35C4;
		  /* 821F35C4h */ case   17:  		/* addi R10, R10, 24 */
		/* 821F35C4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F35C4h case   17:*/		return 0x821F35C8;
	}
	return 0x821F35C8;
} // Block from 821F3580h-821F35C8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F35C8h
// Function '?Negate@Compiler@D3DXShader@@QAAPAVDependency@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F35C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F35C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F35C8);
		  /* 821F35C8h */ case    0:  		/* lwz R7, <#[R10]> */
		/* 821F35C8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F35C8h case    0:*/		return 0x821F35CC;
		  /* 821F35CCh */ case    1:  		/* addi R6, R10, -36 */
		/* 821F35CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F35CCh case    1:*/		return 0x821F35D0;
		  /* 821F35D0h */ case    2:  		/* stw R7, <#[R11]> */
		/* 821F35D0h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F35D0h case    2:*/		return 0x821F35D4;
		  /* 821F35D4h */ case    3:  		/* lwz R7, <#[R10]> */
		/* 821F35D4h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F35D4h case    3:*/		return 0x821F35D8;
		  /* 821F35D8h */ case    4:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F35D8h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F35D8h case    4:*/		return 0x821F35DC;
		  /* 821F35DCh */ case    5:  		/* ori R6, R6, 1 */
		/* 821F35DCh case    5:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F35DCh case    5:*/		return 0x821F35E0;
		  /* 821F35E0h */ case    6:  		/* stw R8, <#[R7]> */
		/* 821F35E0h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F35E0h case    6:*/		return 0x821F35E4;
		  /* 821F35E4h */ case    7:  		/* stw R6, <#[R11 + 4]> */
		/* 821F35E4h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F35E4h case    7:*/		return 0x821F35E8;
		  /* 821F35E8h */ case    8:  		/* stw R9, <#[R10]> */
		/* 821F35E8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F35E8h case    8:*/		return 0x821F35EC;
		  /* 821F35ECh */ case    9:  		/* addi R1, R1, 112 */
		/* 821F35ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F35ECh case    9:*/		return 0x821F35F0;
		  /* 821F35F0h */ case   10:  		/* b -1450820 */
		/* 821F35F0h case   10:*/		return 0x820912AC;
		/* 821F35F0h case   10:*/		return 0x821F35F4;
		  /* 821F35F4h */ case   11:  		/* nop */
		/* 821F35F4h case   11:*/		cpu::op::nop();
		/* 821F35F4h case   11:*/		return 0x821F35F8;
	}
	return 0x821F35F8;
} // Block from 821F35C8h-821F35F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F35F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F35F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F35F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F35F8);
		  /* 821F35F8h */ case    0:  		/* mfspr R12, LR */
		/* 821F35F8h case    0:*/		regs.R12 = regs.LR;
		/* 821F35F8h case    0:*/		return 0x821F35FC;
		  /* 821F35FCh */ case    1:  		/* bl -1450916 */
		/* 821F35FCh case    1:*/		regs.LR = 0x821F3600; return 0x82091258;
		/* 821F35FCh case    1:*/		return 0x821F3600;
		  /* 821F3600h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F3600h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F3600h case    2:*/		return 0x821F3604;
		  /* 821F3604h */ case    3:  		/* mr R29, R5 */
		/* 821F3604h case    3:*/		regs.R29 = regs.R5;
		/* 821F3604h case    3:*/		return 0x821F3608;
	}
	return 0x821F3608;
} // Block from 821F35F8h-821F3608h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F3608h
// Function '?Abs@Compiler@D3DXShader@@QAAPAVDependency@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3608);
		  /* 821F3608h */ case    0:  		/* li R8, 4 */
		/* 821F3608h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3608h case    0:*/		return 0x821F360C;
		  /* 821F360Ch */ case    1:  		/* li R7, 2 */
		/* 821F360Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F360Ch case    1:*/		return 0x821F3610;
		  /* 821F3610h */ case    2:  		/* li R6, 2 */
		/* 821F3610h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F3610h case    2:*/		return 0x821F3614;
		  /* 821F3614h */ case    3:  		/* li R5, 0 */
		/* 821F3614h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3614h case    3:*/		return 0x821F3618;
		  /* 821F3618h */ case    4:  		/* mr R30, R4 */
		/* 821F3618h case    4:*/		regs.R30 = regs.R4;
		/* 821F3618h case    4:*/		return 0x821F361C;
		  /* 821F361Ch */ case    5:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F361Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F361Ch case    5:*/		return 0x821F3620;
		  /* 821F3620h */ case    6:  		/* mr R31, R3 */
		/* 821F3620h case    6:*/		regs.R31 = regs.R3;
		/* 821F3620h case    6:*/		return 0x821F3624;
		  /* 821F3624h */ case    7:  		/* bl 201588 */
		/* 821F3624h case    7:*/		regs.LR = 0x821F3628; return 0x82224998;
		/* 821F3624h case    7:*/		return 0x821F3628;
		  /* 821F3628h */ case    8:  		/* mr R28, R3 */
		/* 821F3628h case    8:*/		regs.R28 = regs.R3;
		/* 821F3628h case    8:*/		return 0x821F362C;
		  /* 821F362Ch */ case    9:  		/* mr R4, R30 */
		/* 821F362Ch case    9:*/		regs.R4 = regs.R30;
		/* 821F362Ch case    9:*/		return 0x821F3630;
		  /* 821F3630h */ case   10:  		/* mr R3, R31 */
		/* 821F3630h case   10:*/		regs.R3 = regs.R31;
		/* 821F3630h case   10:*/		return 0x821F3634;
		  /* 821F3634h */ case   11:  		/* bl -4788 */
		/* 821F3634h case   11:*/		regs.LR = 0x821F3638; return 0x821F2380;
		/* 821F3634h case   11:*/		return 0x821F3638;
		  /* 821F3638h */ case   12:  		/* mr R4, R3 */
		/* 821F3638h case   12:*/		regs.R4 = regs.R3;
		/* 821F3638h case   12:*/		return 0x821F363C;
		  /* 821F363Ch */ case   13:  		/* mr R3, R28 */
		/* 821F363Ch case   13:*/		regs.R3 = regs.R28;
		/* 821F363Ch case   13:*/		return 0x821F3640;
		  /* 821F3640h */ case   14:  		/* bl -504952 */
		/* 821F3640h case   14:*/		regs.LR = 0x821F3644; return 0x821781C8;
		/* 821F3640h case   14:*/		return 0x821F3644;
		  /* 821F3644h */ case   15:  		/* stw R3, <#[R28 + 44]> */
		/* 821F3644h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F3644h case   15:*/		return 0x821F3648;
	}
	return 0x821F3648;
} // Block from 821F3608h-821F3648h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F3648h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3648);
		  /* 821F3648h */ case    0:  		/* mr R4, R29 */
		/* 821F3648h case    0:*/		regs.R4 = regs.R29;
		/* 821F3648h case    0:*/		return 0x821F364C;
		  /* 821F364Ch */ case    1:  		/* mr R3, R31 */
		/* 821F364Ch case    1:*/		regs.R3 = regs.R31;
		/* 821F364Ch case    1:*/		return 0x821F3650;
		  /* 821F3650h */ case    2:  		/* bl -505424 */
		/* 821F3650h case    2:*/		regs.LR = 0x821F3654; return 0x82178000;
		/* 821F3650h case    2:*/		return 0x821F3654;
		  /* 821F3654h */ case    3:  		/* mr R4, R3 */
		/* 821F3654h case    3:*/		regs.R4 = regs.R3;
		/* 821F3654h case    3:*/		return 0x821F3658;
		  /* 821F3658h */ case    4:  		/* mr R3, R28 */
		/* 821F3658h case    4:*/		regs.R3 = regs.R28;
		/* 821F3658h case    4:*/		return 0x821F365C;
		  /* 821F365Ch */ case    5:  		/* bl -504980 */
		/* 821F365Ch case    5:*/		regs.LR = 0x821F3660; return 0x821781C8;
		/* 821F365Ch case    5:*/		return 0x821F3660;
		  /* 821F3660h */ case    6:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F3660h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F3660h case    6:*/		return 0x821F3664;
		  /* 821F3664h */ case    7:  		/* stw R3, <#[R28 + 48]> */
		/* 821F3664h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F3664h case    7:*/		return 0x821F3668;
		  /* 821F3668h */ case    8:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F3668h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F3668h case    8:*/		return 0x821F366C;
		  /* 821F366Ch */ case    9:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F366Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F366Ch case    9:*/		return 0x821F3670;
		  /* 821F3670h */ case   10:  		/* mr R3, R28 */
		/* 821F3670h case   10:*/		regs.R3 = regs.R28;
		/* 821F3670h case   10:*/		return 0x821F3674;
		  /* 821F3674h */ case   11:  		/* addi R11, R11, 36 */
		/* 821F3674h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3674h case   11:*/		return 0x821F3678;
		  /* 821F3678h */ case   12:  		/* lwz R10, <#[R10]> */
		/* 821F3678h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3678h case   12:*/		return 0x821F367C;
		  /* 821F367Ch */ case   13:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F367Ch case   13:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F367Ch case   13:*/		return 0x821F3680;
		  /* 821F3680h */ case   14:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3680h case   14:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3680h case   14:*/		return 0x821F3684;
		  /* 821F3684h */ case   15:  		/* addi R8, R11, -36 */
		/* 821F3684h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3684h case   15:*/		return 0x821F3688;
		  /* 821F3688h */ case   16:  		/* stw R9, <#[R28 + 8]> */
		/* 821F3688h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F3688h case   16:*/		return 0x821F368C;
		  /* 821F368Ch */ case   17:  		/* addi R9, R11, 4 */
		/* 821F368Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F368Ch case   17:*/		return 0x821F3690;
		  /* 821F3690h */ case   18:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F3690h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3690h case   18:*/		return 0x821F3694;
		  /* 821F3694h */ case   19:  		/* addi R10, R10, 24 */
		/* 821F3694h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3694h case   19:*/		return 0x821F3698;
		  /* 821F3698h */ case   20:  		/* lwz R7, <#[R10]> */
		/* 821F3698h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3698h case   20:*/		return 0x821F369C;
		  /* 821F369Ch */ case   21:  		/* addi R6, R10, -36 */
		/* 821F369Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F369Ch case   21:*/		return 0x821F36A0;
		  /* 821F36A0h */ case   22:  		/* stw R7, <#[R11]> */
		/* 821F36A0h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F36A0h case   22:*/		return 0x821F36A4;
		  /* 821F36A4h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F36A4h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F36A4h case   23:*/		return 0x821F36A8;
		  /* 821F36A8h */ case   24:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F36A8h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F36A8h case   24:*/		return 0x821F36AC;
		  /* 821F36ACh */ case   25:  		/* ori R6, R6, 1 */
		/* 821F36ACh case   25:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F36ACh case   25:*/		return 0x821F36B0;
		  /* 821F36B0h */ case   26:  		/* stw R8, <#[R7]> */
		/* 821F36B0h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F36B0h case   26:*/		return 0x821F36B4;
		  /* 821F36B4h */ case   27:  		/* stw R6, <#[R11 + 4]> */
		/* 821F36B4h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F36B4h case   27:*/		return 0x821F36B8;
		  /* 821F36B8h */ case   28:  		/* stw R9, <#[R10]> */
		/* 821F36B8h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F36B8h case   28:*/		return 0x821F36BC;
		  /* 821F36BCh */ case   29:  		/* addi R1, R1, 128 */
		/* 821F36BCh case   29:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F36BCh case   29:*/		return 0x821F36C0;
		  /* 821F36C0h */ case   30:  		/* b -1451032 */
		/* 821F36C0h case   30:*/		return 0x820912A8;
		/* 821F36C0h case   30:*/		return 0x821F36C4;
		  /* 821F36C4h */ case   31:  		/* nop */
		/* 821F36C4h case   31:*/		cpu::op::nop();
		/* 821F36C4h case   31:*/		return 0x821F36C8;
	}
	return 0x821F36C8;
} // Block from 821F3648h-821F36C8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F36C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F36C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F36C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F36C8);
		  /* 821F36C8h */ case    0:  		/* mfspr R12, LR */
		/* 821F36C8h case    0:*/		regs.R12 = regs.LR;
		/* 821F36C8h case    0:*/		return 0x821F36CC;
		  /* 821F36CCh */ case    1:  		/* bl -1451120 */
		/* 821F36CCh case    1:*/		regs.LR = 0x821F36D0; return 0x8209125C;
		/* 821F36CCh case    1:*/		return 0x821F36D0;
		  /* 821F36D0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F36D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F36D0h case    2:*/		return 0x821F36D4;
		  /* 821F36D4h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F36D4h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F36D4h case    3:*/		return 0x821F36D8;
		  /* 821F36D8h */ case    4:  		/* li R8, 4 */
		/* 821F36D8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F36D8h case    4:*/		return 0x821F36DC;
		  /* 821F36DCh */ case    5:  		/* li R7, 2 */
		/* 821F36DCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F36DCh case    5:*/		return 0x821F36E0;
		  /* 821F36E0h */ case    6:  		/* li R6, 1 */
		/* 821F36E0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F36E0h case    6:*/		return 0x821F36E4;
		  /* 821F36E4h */ case    7:  		/* li R5, 0 */
		/* 821F36E4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F36E4h case    7:*/		return 0x821F36E8;
		  /* 821F36E8h */ case    8:  		/* mr R29, R4 */
		/* 821F36E8h case    8:*/		regs.R29 = regs.R4;
		/* 821F36E8h case    8:*/		return 0x821F36EC;
		  /* 821F36ECh */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F36ECh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F36ECh case    9:*/		return 0x821F36F0;
		  /* 821F36F0h */ case   10:  		/* mr R30, R3 */
		/* 821F36F0h case   10:*/		regs.R30 = regs.R3;
		/* 821F36F0h case   10:*/		return 0x821F36F4;
		  /* 821F36F4h */ case   11:  		/* bl 201380 */
		/* 821F36F4h case   11:*/		regs.LR = 0x821F36F8; return 0x82224998;
		/* 821F36F4h case   11:*/		return 0x821F36F8;
		  /* 821F36F8h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F36F8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F36F8h case   12:*/		return 0x821F36FC;
		  /* 821F36FCh */ case   13:  		/* mr R31, R3 */
		/* 821F36FCh case   13:*/		regs.R31 = regs.R3;
		/* 821F36FCh case   13:*/		return 0x821F3700;
		  /* 821F3700h */ case   14:  		/* mr R4, R29 */
		/* 821F3700h case   14:*/		regs.R4 = regs.R29;
		/* 821F3700h case   14:*/		return 0x821F3704;
		  /* 821F3704h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F3704h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F3704h case   15:*/		return 0x821F3708;
		  /* 821F3708h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F3708h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F371C;  }
		/* 821F3708h case   16:*/		return 0x821F370C;
		  /* 821F370Ch */ case   17:  		/* mr R3, R30 */
		/* 821F370Ch case   17:*/		regs.R3 = regs.R30;
		/* 821F370Ch case   17:*/		return 0x821F3710;
		  /* 821F3710h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F3710h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F3710h case   18:*/		return 0x821F3714;
		  /* 821F3714h */ case   19:  		/* bl -534052 */
		/* 821F3714h case   19:*/		regs.LR = 0x821F3718; return 0x821710F0;
		/* 821F3714h case   19:*/		return 0x821F3718;
		  /* 821F3718h */ case   20:  		/* mr R4, R3 */
		/* 821F3718h case   20:*/		regs.R4 = regs.R3;
		/* 821F3718h case   20:*/		return 0x821F371C;
	}
	return 0x821F371C;
} // Block from 821F36C8h-821F371Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F371Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F371C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F371C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F371C);
		  /* 821F371Ch */ case    0:  		/* mr R3, R31 */
		/* 821F371Ch case    0:*/		regs.R3 = regs.R31;
		/* 821F371Ch case    0:*/		return 0x821F3720;
		  /* 821F3720h */ case    1:  		/* bl -505176 */
		/* 821F3720h case    1:*/		regs.LR = 0x821F3724; return 0x821781C8;
		/* 821F3720h case    1:*/		return 0x821F3724;
		  /* 821F3724h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F3724h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3724h case    2:*/		return 0x821F3728;
	}
	return 0x821F3728;
} // Block from 821F371Ch-821F3728h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F3728h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3728);
		  /* 821F3728h */ case    0:  		/* addi R4, R1, 144 */
		/* 821F3728h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F3728h case    0:*/		return 0x821F372C;
		  /* 821F372Ch */ case    1:  		/* mr R3, R30 */
		/* 821F372Ch case    1:*/		regs.R3 = regs.R30;
		/* 821F372Ch case    1:*/		return 0x821F3730;
		  /* 821F3730h */ case    2:  		/* bl -5040 */
		/* 821F3730h case    2:*/		regs.LR = 0x821F3734; return 0x821F2380;
		/* 821F3730h case    2:*/		return 0x821F3734;
		  /* 821F3734h */ case    3:  		/* mr R4, R3 */
		/* 821F3734h case    3:*/		regs.R4 = regs.R3;
		/* 821F3734h case    3:*/		return 0x821F3738;
		  /* 821F3738h */ case    4:  		/* mr R3, R31 */
		/* 821F3738h case    4:*/		regs.R3 = regs.R31;
		/* 821F3738h case    4:*/		return 0x821F373C;
		  /* 821F373Ch */ case    5:  		/* bl -505204 */
		/* 821F373Ch case    5:*/		regs.LR = 0x821F3740; return 0x821781C8;
		/* 821F373Ch case    5:*/		return 0x821F3740;
		  /* 821F3740h */ case    6:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F3740h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3740h case    6:*/		return 0x821F3744;
		  /* 821F3744h */ case    7:  		/* stw R3, <#[R31 + 48]> */
		/* 821F3744h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F3744h case    7:*/		return 0x821F3748;
		  /* 821F3748h */ case    8:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F3748h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F3748h case    8:*/		return 0x821F374C;
		  /* 821F374Ch */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F374Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F374Ch case    9:*/		return 0x821F3750;
		  /* 821F3750h */ case   10:  		/* mr R3, R31 */
		/* 821F3750h case   10:*/		regs.R3 = regs.R31;
		/* 821F3750h case   10:*/		return 0x821F3754;
		  /* 821F3754h */ case   11:  		/* addi R11, R11, 36 */
		/* 821F3754h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3754h case   11:*/		return 0x821F3758;
		  /* 821F3758h */ case   12:  		/* lwz R10, <#[R10]> */
		/* 821F3758h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3758h case   12:*/		return 0x821F375C;
		  /* 821F375Ch */ case   13:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F375Ch case   13:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F375Ch case   13:*/		return 0x821F3760;
		  /* 821F3760h */ case   14:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3760h case   14:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3760h case   14:*/		return 0x821F3764;
		  /* 821F3764h */ case   15:  		/* addi R8, R11, -36 */
		/* 821F3764h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3764h case   15:*/		return 0x821F3768;
		  /* 821F3768h */ case   16:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3768h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3768h case   16:*/		return 0x821F376C;
		  /* 821F376Ch */ case   17:  		/* addi R9, R11, 4 */
		/* 821F376Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F376Ch case   17:*/		return 0x821F3770;
		  /* 821F3770h */ case   18:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3770h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3770h case   18:*/		return 0x821F3774;
		  /* 821F3774h */ case   19:  		/* addi R10, R10, 24 */
		/* 821F3774h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3774h case   19:*/		return 0x821F3778;
		  /* 821F3778h */ case   20:  		/* lwz R7, <#[R10]> */
		/* 821F3778h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3778h case   20:*/		return 0x821F377C;
		  /* 821F377Ch */ case   21:  		/* addi R6, R10, -36 */
		/* 821F377Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F377Ch case   21:*/		return 0x821F3780;
		  /* 821F3780h */ case   22:  		/* stw R7, <#[R11]> */
		/* 821F3780h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3780h case   22:*/		return 0x821F3784;
		  /* 821F3784h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F3784h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3784h case   23:*/		return 0x821F3788;
		  /* 821F3788h */ case   24:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3788h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3788h case   24:*/		return 0x821F378C;
		  /* 821F378Ch */ case   25:  		/* ori R6, R6, 1 */
		/* 821F378Ch case   25:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F378Ch case   25:*/		return 0x821F3790;
		  /* 821F3790h */ case   26:  		/* stw R8, <#[R7]> */
		/* 821F3790h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3790h case   26:*/		return 0x821F3794;
		  /* 821F3794h */ case   27:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3794h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3794h case   27:*/		return 0x821F3798;
		  /* 821F3798h */ case   28:  		/* stw R9, <#[R10]> */
		/* 821F3798h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3798h case   28:*/		return 0x821F379C;
		  /* 821F379Ch */ case   29:  		/* addi R1, R1, 112 */
		/* 821F379Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F379Ch case   29:*/		return 0x821F37A0;
		  /* 821F37A0h */ case   30:  		/* b -1451252 */
		/* 821F37A0h case   30:*/		return 0x820912AC;
		/* 821F37A0h case   30:*/		return 0x821F37A4;
		  /* 821F37A4h */ case   31:  		/* nop */
		/* 821F37A4h case   31:*/		cpu::op::nop();
		/* 821F37A4h case   31:*/		return 0x821F37A8;
	}
	return 0x821F37A8;
} // Block from 821F3728h-821F37A8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F37A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F37A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F37A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F37A8);
		  /* 821F37A8h */ case    0:  		/* mfspr R12, LR */
		/* 821F37A8h case    0:*/		regs.R12 = regs.LR;
		/* 821F37A8h case    0:*/		return 0x821F37AC;
		  /* 821F37ACh */ case    1:  		/* bl -1451344 */
		/* 821F37ACh case    1:*/		regs.LR = 0x821F37B0; return 0x8209125C;
		/* 821F37ACh case    1:*/		return 0x821F37B0;
		  /* 821F37B0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F37B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F37B0h case    2:*/		return 0x821F37B4;
		  /* 821F37B4h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F37B4h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F37B4h case    3:*/		return 0x821F37B8;
		  /* 821F37B8h */ case    4:  		/* li R8, 4 */
		/* 821F37B8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F37B8h case    4:*/		return 0x821F37BC;
		  /* 821F37BCh */ case    5:  		/* li R7, 2 */
		/* 821F37BCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F37BCh case    5:*/		return 0x821F37C0;
		  /* 821F37C0h */ case    6:  		/* li R6, 2 */
		/* 821F37C0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F37C0h case    6:*/		return 0x821F37C4;
		  /* 821F37C4h */ case    7:  		/* li R5, 0 */
		/* 821F37C4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F37C4h case    7:*/		return 0x821F37C8;
		  /* 821F37C8h */ case    8:  		/* mr R29, R4 */
		/* 821F37C8h case    8:*/		regs.R29 = regs.R4;
		/* 821F37C8h case    8:*/		return 0x821F37CC;
		  /* 821F37CCh */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F37CCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F37CCh case    9:*/		return 0x821F37D0;
		  /* 821F37D0h */ case   10:  		/* mr R30, R3 */
		/* 821F37D0h case   10:*/		regs.R30 = regs.R3;
		/* 821F37D0h case   10:*/		return 0x821F37D4;
		  /* 821F37D4h */ case   11:  		/* bl 201156 */
		/* 821F37D4h case   11:*/		regs.LR = 0x821F37D8; return 0x82224998;
		/* 821F37D4h case   11:*/		return 0x821F37D8;
		  /* 821F37D8h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F37D8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F37D8h case   12:*/		return 0x821F37DC;
		  /* 821F37DCh */ case   13:  		/* mr R31, R3 */
		/* 821F37DCh case   13:*/		regs.R31 = regs.R3;
		/* 821F37DCh case   13:*/		return 0x821F37E0;
		  /* 821F37E0h */ case   14:  		/* mr R4, R29 */
		/* 821F37E0h case   14:*/		regs.R4 = regs.R29;
		/* 821F37E0h case   14:*/		return 0x821F37E4;
		  /* 821F37E4h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F37E4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F37E4h case   15:*/		return 0x821F37E8;
		  /* 821F37E8h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F37E8h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F37FC;  }
		/* 821F37E8h case   16:*/		return 0x821F37EC;
		  /* 821F37ECh */ case   17:  		/* mr R3, R30 */
		/* 821F37ECh case   17:*/		regs.R3 = regs.R30;
		/* 821F37ECh case   17:*/		return 0x821F37F0;
		  /* 821F37F0h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F37F0h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F37F0h case   18:*/		return 0x821F37F4;
		  /* 821F37F4h */ case   19:  		/* bl -534276 */
		/* 821F37F4h case   19:*/		regs.LR = 0x821F37F8; return 0x821710F0;
		/* 821F37F4h case   19:*/		return 0x821F37F8;
		  /* 821F37F8h */ case   20:  		/* mr R4, R3 */
		/* 821F37F8h case   20:*/		regs.R4 = regs.R3;
		/* 821F37F8h case   20:*/		return 0x821F37FC;
	}
	return 0x821F37FC;
} // Block from 821F37A8h-821F37FCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F37FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F37FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F37FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F37FC);
		  /* 821F37FCh */ case    0:  		/* mr R3, R31 */
		/* 821F37FCh case    0:*/		regs.R3 = regs.R31;
		/* 821F37FCh case    0:*/		return 0x821F3800;
		  /* 821F3800h */ case    1:  		/* bl -505400 */
		/* 821F3800h case    1:*/		regs.LR = 0x821F3804; return 0x821781C8;
		/* 821F3800h case    1:*/		return 0x821F3804;
		  /* 821F3804h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F3804h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3804h case    2:*/		return 0x821F3808;
	}
	return 0x821F3808;
} // Block from 821F37FCh-821F3808h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F3808h
// Function '?MakeInstr_V_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3808);
		  /* 821F3808h */ case    0:  		/* addi R4, R1, 144 */
		/* 821F3808h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F3808h case    0:*/		return 0x821F380C;
		  /* 821F380Ch */ case    1:  		/* mr R3, R30 */
		/* 821F380Ch case    1:*/		regs.R3 = regs.R30;
		/* 821F380Ch case    1:*/		return 0x821F3810;
		  /* 821F3810h */ case    2:  		/* bl -5264 */
		/* 821F3810h case    2:*/		regs.LR = 0x821F3814; return 0x821F2380;
		/* 821F3810h case    2:*/		return 0x821F3814;
		  /* 821F3814h */ case    3:  		/* mr R4, R3 */
		/* 821F3814h case    3:*/		regs.R4 = regs.R3;
		/* 821F3814h case    3:*/		return 0x821F3818;
		  /* 821F3818h */ case    4:  		/* mr R3, R31 */
		/* 821F3818h case    4:*/		regs.R3 = regs.R31;
		/* 821F3818h case    4:*/		return 0x821F381C;
		  /* 821F381Ch */ case    5:  		/* bl -505428 */
		/* 821F381Ch case    5:*/		regs.LR = 0x821F3820; return 0x821781C8;
		/* 821F381Ch case    5:*/		return 0x821F3820;
		  /* 821F3820h */ case    6:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F3820h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3820h case    6:*/		return 0x821F3824;
		  /* 821F3824h */ case    7:  		/* stw R3, <#[R31 + 48]> */
		/* 821F3824h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F3824h case    7:*/		return 0x821F3828;
		  /* 821F3828h */ case    8:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F3828h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F3828h case    8:*/		return 0x821F382C;
		  /* 821F382Ch */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F382Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F382Ch case    9:*/		return 0x821F3830;
		  /* 821F3830h */ case   10:  		/* mr R3, R31 */
		/* 821F3830h case   10:*/		regs.R3 = regs.R31;
		/* 821F3830h case   10:*/		return 0x821F3834;
		  /* 821F3834h */ case   11:  		/* addi R11, R11, 36 */
		/* 821F3834h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3834h case   11:*/		return 0x821F3838;
		  /* 821F3838h */ case   12:  		/* lwz R10, <#[R10]> */
		/* 821F3838h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3838h case   12:*/		return 0x821F383C;
		  /* 821F383Ch */ case   13:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F383Ch case   13:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F383Ch case   13:*/		return 0x821F3840;
		  /* 821F3840h */ case   14:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3840h case   14:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3840h case   14:*/		return 0x821F3844;
		  /* 821F3844h */ case   15:  		/* addi R8, R11, -36 */
		/* 821F3844h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3844h case   15:*/		return 0x821F3848;
		  /* 821F3848h */ case   16:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3848h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3848h case   16:*/		return 0x821F384C;
		  /* 821F384Ch */ case   17:  		/* addi R9, R11, 4 */
		/* 821F384Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F384Ch case   17:*/		return 0x821F3850;
		  /* 821F3850h */ case   18:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3850h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3850h case   18:*/		return 0x821F3854;
		  /* 821F3854h */ case   19:  		/* addi R10, R10, 24 */
		/* 821F3854h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3854h case   19:*/		return 0x821F3858;
		  /* 821F3858h */ case   20:  		/* lwz R7, <#[R10]> */
		/* 821F3858h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3858h case   20:*/		return 0x821F385C;
		  /* 821F385Ch */ case   21:  		/* addi R6, R10, -36 */
		/* 821F385Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F385Ch case   21:*/		return 0x821F3860;
		  /* 821F3860h */ case   22:  		/* stw R7, <#[R11]> */
		/* 821F3860h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3860h case   22:*/		return 0x821F3864;
		  /* 821F3864h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F3864h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3864h case   23:*/		return 0x821F3868;
		  /* 821F3868h */ case   24:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3868h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3868h case   24:*/		return 0x821F386C;
		  /* 821F386Ch */ case   25:  		/* ori R6, R6, 1 */
		/* 821F386Ch case   25:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F386Ch case   25:*/		return 0x821F3870;
		  /* 821F3870h */ case   26:  		/* stw R8, <#[R7]> */
		/* 821F3870h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3870h case   26:*/		return 0x821F3874;
		  /* 821F3874h */ case   27:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3874h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3874h case   27:*/		return 0x821F3878;
		  /* 821F3878h */ case   28:  		/* stw R9, <#[R10]> */
		/* 821F3878h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3878h case   28:*/		return 0x821F387C;
		  /* 821F387Ch */ case   29:  		/* addi R1, R1, 112 */
		/* 821F387Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F387Ch case   29:*/		return 0x821F3880;
		  /* 821F3880h */ case   30:  		/* b -1451476 */
		/* 821F3880h case   30:*/		return 0x820912AC;
		/* 821F3880h case   30:*/		return 0x821F3884;
		  /* 821F3884h */ case   31:  		/* nop */
		/* 821F3884h case   31:*/		cpu::op::nop();
		/* 821F3884h case   31:*/		return 0x821F3888;
	}
	return 0x821F3888;
} // Block from 821F3808h-821F3888h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F3888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3888);
		  /* 821F3888h */ case    0:  		/* mfspr R12, LR */
		/* 821F3888h case    0:*/		regs.R12 = regs.LR;
		/* 821F3888h case    0:*/		return 0x821F388C;
		  /* 821F388Ch */ case    1:  		/* bl -1451568 */
		/* 821F388Ch case    1:*/		regs.LR = 0x821F3890; return 0x8209125C;
		/* 821F388Ch case    1:*/		return 0x821F3890;
		  /* 821F3890h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3890h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3890h case    2:*/		return 0x821F3894;
		  /* 821F3894h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F3894h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F3894h case    3:*/		return 0x821F3898;
		  /* 821F3898h */ case    4:  		/* li R8, 4 */
		/* 821F3898h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3898h case    4:*/		return 0x821F389C;
		  /* 821F389Ch */ case    5:  		/* li R7, 2 */
		/* 821F389Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F389Ch case    5:*/		return 0x821F38A0;
		  /* 821F38A0h */ case    6:  		/* li R6, 5 */
		/* 821F38A0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 821F38A0h case    6:*/		return 0x821F38A4;
		  /* 821F38A4h */ case    7:  		/* li R5, 0 */
		/* 821F38A4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F38A4h case    7:*/		return 0x821F38A8;
		  /* 821F38A8h */ case    8:  		/* mr R29, R4 */
		/* 821F38A8h case    8:*/		regs.R29 = regs.R4;
		/* 821F38A8h case    8:*/		return 0x821F38AC;
		  /* 821F38ACh */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F38ACh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F38ACh case    9:*/		return 0x821F38B0;
		  /* 821F38B0h */ case   10:  		/* mr R30, R3 */
		/* 821F38B0h case   10:*/		regs.R30 = regs.R3;
		/* 821F38B0h case   10:*/		return 0x821F38B4;
		  /* 821F38B4h */ case   11:  		/* bl 200932 */
		/* 821F38B4h case   11:*/		regs.LR = 0x821F38B8; return 0x82224998;
		/* 821F38B4h case   11:*/		return 0x821F38B8;
		  /* 821F38B8h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F38B8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F38B8h case   12:*/		return 0x821F38BC;
		  /* 821F38BCh */ case   13:  		/* mr R31, R3 */
		/* 821F38BCh case   13:*/		regs.R31 = regs.R3;
		/* 821F38BCh case   13:*/		return 0x821F38C0;
		  /* 821F38C0h */ case   14:  		/* mr R4, R29 */
		/* 821F38C0h case   14:*/		regs.R4 = regs.R29;
		/* 821F38C0h case   14:*/		return 0x821F38C4;
		  /* 821F38C4h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F38C4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F38C4h case   15:*/		return 0x821F38C8;
		  /* 821F38C8h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F38C8h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F38DC;  }
		/* 821F38C8h case   16:*/		return 0x821F38CC;
		  /* 821F38CCh */ case   17:  		/* mr R3, R30 */
		/* 821F38CCh case   17:*/		regs.R3 = regs.R30;
		/* 821F38CCh case   17:*/		return 0x821F38D0;
		  /* 821F38D0h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F38D0h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F38D0h case   18:*/		return 0x821F38D4;
		  /* 821F38D4h */ case   19:  		/* bl -534500 */
		/* 821F38D4h case   19:*/		regs.LR = 0x821F38D8; return 0x821710F0;
		/* 821F38D4h case   19:*/		return 0x821F38D8;
		  /* 821F38D8h */ case   20:  		/* mr R4, R3 */
		/* 821F38D8h case   20:*/		regs.R4 = regs.R3;
		/* 821F38D8h case   20:*/		return 0x821F38DC;
	}
	return 0x821F38DC;
} // Block from 821F3888h-821F38DCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F38DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F38DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F38DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F38DC);
		  /* 821F38DCh */ case    0:  		/* mr R3, R31 */
		/* 821F38DCh case    0:*/		regs.R3 = regs.R31;
		/* 821F38DCh case    0:*/		return 0x821F38E0;
		  /* 821F38E0h */ case    1:  		/* bl -505624 */
		/* 821F38E0h case    1:*/		regs.LR = 0x821F38E4; return 0x821781C8;
		/* 821F38E0h case    1:*/		return 0x821F38E4;
		  /* 821F38E4h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F38E4h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F38E4h case    2:*/		return 0x821F38E8;
	}
	return 0x821F38E8;
} // Block from 821F38DCh-821F38E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F38E8h
// Function '?MakeInstr_S_LOG_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F38E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F38E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F38E8);
		  /* 821F38E8h */ case    0:  		/* addi R4, R1, 144 */
		/* 821F38E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F38E8h case    0:*/		return 0x821F38EC;
		  /* 821F38ECh */ case    1:  		/* mr R3, R30 */
		/* 821F38ECh case    1:*/		regs.R3 = regs.R30;
		/* 821F38ECh case    1:*/		return 0x821F38F0;
		  /* 821F38F0h */ case    2:  		/* bl -5488 */
		/* 821F38F0h case    2:*/		regs.LR = 0x821F38F4; return 0x821F2380;
		/* 821F38F0h case    2:*/		return 0x821F38F4;
		  /* 821F38F4h */ case    3:  		/* mr R4, R3 */
		/* 821F38F4h case    3:*/		regs.R4 = regs.R3;
		/* 821F38F4h case    3:*/		return 0x821F38F8;
		  /* 821F38F8h */ case    4:  		/* mr R3, R31 */
		/* 821F38F8h case    4:*/		regs.R3 = regs.R31;
		/* 821F38F8h case    4:*/		return 0x821F38FC;
		  /* 821F38FCh */ case    5:  		/* bl -505652 */
		/* 821F38FCh case    5:*/		regs.LR = 0x821F3900; return 0x821781C8;
		/* 821F38FCh case    5:*/		return 0x821F3900;
		  /* 821F3900h */ case    6:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F3900h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3900h case    6:*/		return 0x821F3904;
		  /* 821F3904h */ case    7:  		/* stw R3, <#[R31 + 48]> */
		/* 821F3904h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F3904h case    7:*/		return 0x821F3908;
		  /* 821F3908h */ case    8:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F3908h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F3908h case    8:*/		return 0x821F390C;
		  /* 821F390Ch */ case    9:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F390Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F390Ch case    9:*/		return 0x821F3910;
		  /* 821F3910h */ case   10:  		/* mr R3, R31 */
		/* 821F3910h case   10:*/		regs.R3 = regs.R31;
		/* 821F3910h case   10:*/		return 0x821F3914;
		  /* 821F3914h */ case   11:  		/* addi R11, R11, 36 */
		/* 821F3914h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3914h case   11:*/		return 0x821F3918;
		  /* 821F3918h */ case   12:  		/* lwz R10, <#[R10]> */
		/* 821F3918h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3918h case   12:*/		return 0x821F391C;
		  /* 821F391Ch */ case   13:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F391Ch case   13:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F391Ch case   13:*/		return 0x821F3920;
		  /* 821F3920h */ case   14:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3920h case   14:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3920h case   14:*/		return 0x821F3924;
		  /* 821F3924h */ case   15:  		/* addi R8, R11, -36 */
		/* 821F3924h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3924h case   15:*/		return 0x821F3928;
		  /* 821F3928h */ case   16:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3928h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3928h case   16:*/		return 0x821F392C;
		  /* 821F392Ch */ case   17:  		/* addi R9, R11, 4 */
		/* 821F392Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F392Ch case   17:*/		return 0x821F3930;
		  /* 821F3930h */ case   18:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3930h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3930h case   18:*/		return 0x821F3934;
		  /* 821F3934h */ case   19:  		/* addi R10, R10, 24 */
		/* 821F3934h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3934h case   19:*/		return 0x821F3938;
		  /* 821F3938h */ case   20:  		/* lwz R7, <#[R10]> */
		/* 821F3938h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3938h case   20:*/		return 0x821F393C;
		  /* 821F393Ch */ case   21:  		/* addi R6, R10, -36 */
		/* 821F393Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F393Ch case   21:*/		return 0x821F3940;
		  /* 821F3940h */ case   22:  		/* stw R7, <#[R11]> */
		/* 821F3940h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3940h case   22:*/		return 0x821F3944;
		  /* 821F3944h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F3944h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3944h case   23:*/		return 0x821F3948;
		  /* 821F3948h */ case   24:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3948h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3948h case   24:*/		return 0x821F394C;
		  /* 821F394Ch */ case   25:  		/* ori R6, R6, 1 */
		/* 821F394Ch case   25:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F394Ch case   25:*/		return 0x821F3950;
		  /* 821F3950h */ case   26:  		/* stw R8, <#[R7]> */
		/* 821F3950h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3950h case   26:*/		return 0x821F3954;
		  /* 821F3954h */ case   27:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3954h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3954h case   27:*/		return 0x821F3958;
		  /* 821F3958h */ case   28:  		/* stw R9, <#[R10]> */
		/* 821F3958h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3958h case   28:*/		return 0x821F395C;
		  /* 821F395Ch */ case   29:  		/* addi R1, R1, 112 */
		/* 821F395Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F395Ch case   29:*/		return 0x821F3960;
		  /* 821F3960h */ case   30:  		/* b -1451700 */
		/* 821F3960h case   30:*/		return 0x820912AC;
		/* 821F3960h case   30:*/		return 0x821F3964;
		  /* 821F3964h */ case   31:  		/* nop */
		/* 821F3964h case   31:*/		cpu::op::nop();
		/* 821F3964h case   31:*/		return 0x821F3968;
	}
	return 0x821F3968;
} // Block from 821F38E8h-821F3968h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F3968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3968);
		  /* 821F3968h */ case    0:  		/* mfspr R12, LR */
		/* 821F3968h case    0:*/		regs.R12 = regs.LR;
		/* 821F3968h case    0:*/		return 0x821F396C;
		  /* 821F396Ch */ case    1:  		/* bl -1451792 */
		/* 821F396Ch case    1:*/		regs.LR = 0x821F3970; return 0x8209125C;
		/* 821F396Ch case    1:*/		return 0x821F3970;
		  /* 821F3970h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3970h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3970h case    2:*/		return 0x821F3974;
		  /* 821F3974h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F3974h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F3974h case    3:*/		return 0x821F3978;
		  /* 821F3978h */ case    4:  		/* li R8, 4 */
		/* 821F3978h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3978h case    4:*/		return 0x821F397C;
		  /* 821F397Ch */ case    5:  		/* li R7, 2 */
		/* 821F397Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F397Ch case    5:*/		return 0x821F3980;
		  /* 821F3980h */ case    6:  		/* li R6, 6 */
		/* 821F3980h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 821F3980h case    6:*/		return 0x821F3984;
		  /* 821F3984h */ case    7:  		/* li R5, 0 */
		/* 821F3984h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3984h case    7:*/		return 0x821F3988;
		  /* 821F3988h */ case    8:  		/* mr R29, R4 */
		/* 821F3988h case    8:*/		regs.R29 = regs.R4;
		/* 821F3988h case    8:*/		return 0x821F398C;
		  /* 821F398Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F398Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F398Ch case    9:*/		return 0x821F3990;
		  /* 821F3990h */ case   10:  		/* mr R30, R3 */
		/* 821F3990h case   10:*/		regs.R30 = regs.R3;
		/* 821F3990h case   10:*/		return 0x821F3994;
		  /* 821F3994h */ case   11:  		/* bl 200708 */
		/* 821F3994h case   11:*/		regs.LR = 0x821F3998; return 0x82224998;
		/* 821F3994h case   11:*/		return 0x821F3998;
	}
	return 0x821F3998;
} // Block from 821F3968h-821F3998h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F3998h
// Function '?MakeInstr_S_PRED_SETNE@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3998);
		  /* 821F3998h */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F3998h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F3998h case    0:*/		return 0x821F399C;
		  /* 821F399Ch */ case    1:  		/* mr R31, R3 */
		/* 821F399Ch case    1:*/		regs.R31 = regs.R3;
		/* 821F399Ch case    1:*/		return 0x821F39A0;
		  /* 821F39A0h */ case    2:  		/* mr R4, R29 */
		/* 821F39A0h case    2:*/		regs.R4 = regs.R29;
		/* 821F39A0h case    2:*/		return 0x821F39A4;
		  /* 821F39A4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821F39A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F39A4h case    3:*/		return 0x821F39A8;
		  /* 821F39A8h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 821F39A8h case    4:*/		if ( regs.CR[6].eq ) { return 0x821F39BC;  }
		/* 821F39A8h case    4:*/		return 0x821F39AC;
		  /* 821F39ACh */ case    5:  		/* mr R3, R30 */
		/* 821F39ACh case    5:*/		regs.R3 = regs.R30;
		/* 821F39ACh case    5:*/		return 0x821F39B0;
		  /* 821F39B0h */ case    6:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F39B0h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F39B0h case    6:*/		return 0x821F39B4;
		  /* 821F39B4h */ case    7:  		/* bl -534724 */
		/* 821F39B4h case    7:*/		regs.LR = 0x821F39B8; return 0x821710F0;
		/* 821F39B4h case    7:*/		return 0x821F39B8;
		  /* 821F39B8h */ case    8:  		/* mr R4, R3 */
		/* 821F39B8h case    8:*/		regs.R4 = regs.R3;
		/* 821F39B8h case    8:*/		return 0x821F39BC;
	}
	return 0x821F39BC;
} // Block from 821F3998h-821F39BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F39BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F39BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F39BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F39BC);
		  /* 821F39BCh */ case    0:  		/* mr R3, R31 */
		/* 821F39BCh case    0:*/		regs.R3 = regs.R31;
		/* 821F39BCh case    0:*/		return 0x821F39C0;
		  /* 821F39C0h */ case    1:  		/* bl -505848 */
		/* 821F39C0h case    1:*/		regs.LR = 0x821F39C4; return 0x821781C8;
		/* 821F39C0h case    1:*/		return 0x821F39C4;
		  /* 821F39C4h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F39C4h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F39C4h case    2:*/		return 0x821F39C8;
		  /* 821F39C8h */ case    3:  		/* addi R4, R1, 144 */
		/* 821F39C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F39C8h case    3:*/		return 0x821F39CC;
		  /* 821F39CCh */ case    4:  		/* mr R3, R30 */
		/* 821F39CCh case    4:*/		regs.R3 = regs.R30;
		/* 821F39CCh case    4:*/		return 0x821F39D0;
		  /* 821F39D0h */ case    5:  		/* bl -5712 */
		/* 821F39D0h case    5:*/		regs.LR = 0x821F39D4; return 0x821F2380;
		/* 821F39D0h case    5:*/		return 0x821F39D4;
		  /* 821F39D4h */ case    6:  		/* mr R4, R3 */
		/* 821F39D4h case    6:*/		regs.R4 = regs.R3;
		/* 821F39D4h case    6:*/		return 0x821F39D8;
		  /* 821F39D8h */ case    7:  		/* mr R3, R31 */
		/* 821F39D8h case    7:*/		regs.R3 = regs.R31;
		/* 821F39D8h case    7:*/		return 0x821F39DC;
		  /* 821F39DCh */ case    8:  		/* bl -505876 */
		/* 821F39DCh case    8:*/		regs.LR = 0x821F39E0; return 0x821781C8;
		/* 821F39DCh case    8:*/		return 0x821F39E0;
		  /* 821F39E0h */ case    9:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F39E0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F39E0h case    9:*/		return 0x821F39E4;
		  /* 821F39E4h */ case   10:  		/* stw R3, <#[R31 + 48]> */
		/* 821F39E4h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F39E4h case   10:*/		return 0x821F39E8;
		  /* 821F39E8h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F39E8h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F39E8h case   11:*/		return 0x821F39EC;
		  /* 821F39ECh */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F39ECh case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F39ECh case   12:*/		return 0x821F39F0;
		  /* 821F39F0h */ case   13:  		/* mr R3, R31 */
		/* 821F39F0h case   13:*/		regs.R3 = regs.R31;
		/* 821F39F0h case   13:*/		return 0x821F39F4;
		  /* 821F39F4h */ case   14:  		/* addi R11, R11, 36 */
		/* 821F39F4h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F39F4h case   14:*/		return 0x821F39F8;
		  /* 821F39F8h */ case   15:  		/* lwz R10, <#[R10]> */
		/* 821F39F8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F39F8h case   15:*/		return 0x821F39FC;
		  /* 821F39FCh */ case   16:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F39FCh case   16:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F39FCh case   16:*/		return 0x821F3A00;
		  /* 821F3A00h */ case   17:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3A00h case   17:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3A00h case   17:*/		return 0x821F3A04;
		  /* 821F3A04h */ case   18:  		/* addi R8, R11, -36 */
		/* 821F3A04h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3A04h case   18:*/		return 0x821F3A08;
		  /* 821F3A08h */ case   19:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3A08h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3A08h case   19:*/		return 0x821F3A0C;
		  /* 821F3A0Ch */ case   20:  		/* addi R9, R11, 4 */
		/* 821F3A0Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3A0Ch case   20:*/		return 0x821F3A10;
		  /* 821F3A10h */ case   21:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3A10h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3A10h case   21:*/		return 0x821F3A14;
		  /* 821F3A14h */ case   22:  		/* addi R10, R10, 24 */
		/* 821F3A14h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3A14h case   22:*/		return 0x821F3A18;
		  /* 821F3A18h */ case   23:  		/* lwz R7, <#[R10]> */
		/* 821F3A18h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3A18h case   23:*/		return 0x821F3A1C;
		  /* 821F3A1Ch */ case   24:  		/* addi R6, R10, -36 */
		/* 821F3A1Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3A1Ch case   24:*/		return 0x821F3A20;
		  /* 821F3A20h */ case   25:  		/* stw R7, <#[R11]> */
		/* 821F3A20h case   25:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3A20h case   25:*/		return 0x821F3A24;
		  /* 821F3A24h */ case   26:  		/* lwz R7, <#[R10]> */
		/* 821F3A24h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3A24h case   26:*/		return 0x821F3A28;
		  /* 821F3A28h */ case   27:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3A28h case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3A28h case   27:*/		return 0x821F3A2C;
		  /* 821F3A2Ch */ case   28:  		/* ori R6, R6, 1 */
		/* 821F3A2Ch case   28:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3A2Ch case   28:*/		return 0x821F3A30;
		  /* 821F3A30h */ case   29:  		/* stw R8, <#[R7]> */
		/* 821F3A30h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3A30h case   29:*/		return 0x821F3A34;
		  /* 821F3A34h */ case   30:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3A34h case   30:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3A34h case   30:*/		return 0x821F3A38;
		  /* 821F3A38h */ case   31:  		/* stw R9, <#[R10]> */
		/* 821F3A38h case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3A38h case   31:*/		return 0x821F3A3C;
		  /* 821F3A3Ch */ case   32:  		/* addi R1, R1, 112 */
		/* 821F3A3Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3A3Ch case   32:*/		return 0x821F3A40;
		  /* 821F3A40h */ case   33:  		/* b -1451924 */
		/* 821F3A40h case   33:*/		return 0x820912AC;
		/* 821F3A40h case   33:*/		return 0x821F3A44;
		  /* 821F3A44h */ case   34:  		/* nop */
		/* 821F3A44h case   34:*/		cpu::op::nop();
		/* 821F3A44h case   34:*/		return 0x821F3A48;
	}
	return 0x821F3A48;
} // Block from 821F39BCh-821F3A48h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821F3A48h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3A48);
		  /* 821F3A48h */ case    0:  		/* mfspr R12, LR */
		/* 821F3A48h case    0:*/		regs.R12 = regs.LR;
		/* 821F3A48h case    0:*/		return 0x821F3A4C;
		  /* 821F3A4Ch */ case    1:  		/* bl -1452016 */
		/* 821F3A4Ch case    1:*/		regs.LR = 0x821F3A50; return 0x8209125C;
		/* 821F3A4Ch case    1:*/		return 0x821F3A50;
		  /* 821F3A50h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3A50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3A50h case    2:*/		return 0x821F3A54;
		  /* 821F3A54h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F3A54h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F3A54h case    3:*/		return 0x821F3A58;
		  /* 821F3A58h */ case    4:  		/* li R8, 4 */
		/* 821F3A58h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3A58h case    4:*/		return 0x821F3A5C;
		  /* 821F3A5Ch */ case    5:  		/* li R7, 2 */
		/* 821F3A5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3A5Ch case    5:*/		return 0x821F3A60;
		  /* 821F3A60h */ case    6:  		/* li R6, 1 */
		/* 821F3A60h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F3A60h case    6:*/		return 0x821F3A64;
		  /* 821F3A64h */ case    7:  		/* li R5, 0 */
		/* 821F3A64h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3A64h case    7:*/		return 0x821F3A68;
		  /* 821F3A68h */ case    8:  		/* mr R30, R4 */
		/* 821F3A68h case    8:*/		regs.R30 = regs.R4;
		/* 821F3A68h case    8:*/		return 0x821F3A6C;
		  /* 821F3A6Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3A6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3A6Ch case    9:*/		return 0x821F3A70;
		  /* 821F3A70h */ case   10:  		/* mr R31, R3 */
		/* 821F3A70h case   10:*/		regs.R31 = regs.R3;
		/* 821F3A70h case   10:*/		return 0x821F3A74;
		  /* 821F3A74h */ case   11:  		/* bl 200484 */
		/* 821F3A74h case   11:*/		regs.LR = 0x821F3A78; return 0x82224998;
		/* 821F3A74h case   11:*/		return 0x821F3A78;
		  /* 821F3A78h */ case   12:  		/* mr R29, R3 */
		/* 821F3A78h case   12:*/		regs.R29 = regs.R3;
		/* 821F3A78h case   12:*/		return 0x821F3A7C;
		  /* 821F3A7Ch */ case   13:  		/* mr R4, R30 */
		/* 821F3A7Ch case   13:*/		regs.R4 = regs.R30;
		/* 821F3A7Ch case   13:*/		return 0x821F3A80;
		  /* 821F3A80h */ case   14:  		/* mr R3, R31 */
		/* 821F3A80h case   14:*/		regs.R3 = regs.R31;
		/* 821F3A80h case   14:*/		return 0x821F3A84;
		  /* 821F3A84h */ case   15:  		/* bl -506500 */
		/* 821F3A84h case   15:*/		regs.LR = 0x821F3A88; return 0x82178000;
		/* 821F3A84h case   15:*/		return 0x821F3A88;
		  /* 821F3A88h */ case   16:  		/* mr R4, R3 */
		/* 821F3A88h case   16:*/		regs.R4 = regs.R3;
		/* 821F3A88h case   16:*/		return 0x821F3A8C;
		  /* 821F3A8Ch */ case   17:  		/* mr R3, R29 */
		/* 821F3A8Ch case   17:*/		regs.R3 = regs.R29;
		/* 821F3A8Ch case   17:*/		return 0x821F3A90;
		  /* 821F3A90h */ case   18:  		/* bl -506056 */
		/* 821F3A90h case   18:*/		regs.LR = 0x821F3A94; return 0x821781C8;
		/* 821F3A90h case   18:*/		return 0x821F3A94;
		  /* 821F3A94h */ case   19:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3A94h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3A94h case   19:*/		return 0x821F3A98;
		  /* 821F3A98h */ case   20:  		/* addi R4, R1, 144 */
		/* 821F3A98h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F3A98h case   20:*/		return 0x821F3A9C;
		  /* 821F3A9Ch */ case   21:  		/* mr R3, R31 */
		/* 821F3A9Ch case   21:*/		regs.R3 = regs.R31;
		/* 821F3A9Ch case   21:*/		return 0x821F3AA0;
		  /* 821F3AA0h */ case   22:  		/* bl -5920 */
		/* 821F3AA0h case   22:*/		regs.LR = 0x821F3AA4; return 0x821F2380;
		/* 821F3AA0h case   22:*/		return 0x821F3AA4;
		  /* 821F3AA4h */ case   23:  		/* mr R4, R3 */
		/* 821F3AA4h case   23:*/		regs.R4 = regs.R3;
		/* 821F3AA4h case   23:*/		return 0x821F3AA8;
		  /* 821F3AA8h */ case   24:  		/* mr R3, R29 */
		/* 821F3AA8h case   24:*/		regs.R3 = regs.R29;
		/* 821F3AA8h case   24:*/		return 0x821F3AAC;
		  /* 821F3AACh */ case   25:  		/* bl -506084 */
		/* 821F3AACh case   25:*/		regs.LR = 0x821F3AB0; return 0x821781C8;
		/* 821F3AACh case   25:*/		return 0x821F3AB0;
		  /* 821F3AB0h */ case   26:  		/* lwz R10, <#[R29 + 44]> */
		/* 821F3AB0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3AB0h case   26:*/		return 0x821F3AB4;
		  /* 821F3AB4h */ case   27:  		/* stw R3, <#[R29 + 48]> */
		/* 821F3AB4h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 821F3AB4h case   27:*/		return 0x821F3AB8;
		  /* 821F3AB8h */ case   28:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F3AB8h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F3AB8h case   28:*/		return 0x821F3ABC;
		  /* 821F3ABCh */ case   29:  		/* lwz R9, <#[R29 + 8]> */
		/* 821F3ABCh case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F3ABCh case   29:*/		return 0x821F3AC0;
		  /* 821F3AC0h */ case   30:  		/* mr R3, R29 */
		/* 821F3AC0h case   30:*/		regs.R3 = regs.R29;
		/* 821F3AC0h case   30:*/		return 0x821F3AC4;
		  /* 821F3AC4h */ case   31:  		/* addi R11, R11, 36 */
		/* 821F3AC4h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3AC4h case   31:*/		return 0x821F3AC8;
		  /* 821F3AC8h */ case   32:  		/* lwz R10, <#[R10]> */
		/* 821F3AC8h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3AC8h case   32:*/		return 0x821F3ACC;
		  /* 821F3ACCh */ case   33:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3ACCh case   33:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3ACCh case   33:*/		return 0x821F3AD0;
		  /* 821F3AD0h */ case   34:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3AD0h case   34:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3AD0h case   34:*/		return 0x821F3AD4;
		  /* 821F3AD4h */ case   35:  		/* addi R8, R11, -36 */
		/* 821F3AD4h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3AD4h case   35:*/		return 0x821F3AD8;
		  /* 821F3AD8h */ case   36:  		/* stw R9, <#[R29 + 8]> */
		/* 821F3AD8h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F3AD8h case   36:*/		return 0x821F3ADC;
		  /* 821F3ADCh */ case   37:  		/* addi R9, R11, 4 */
		/* 821F3ADCh case   37:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3ADCh case   37:*/		return 0x821F3AE0;
		  /* 821F3AE0h */ case   38:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F3AE0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3AE0h case   38:*/		return 0x821F3AE4;
		  /* 821F3AE4h */ case   39:  		/* addi R10, R10, 24 */
		/* 821F3AE4h case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3AE4h case   39:*/		return 0x821F3AE8;
		  /* 821F3AE8h */ case   40:  		/* lwz R7, <#[R10]> */
		/* 821F3AE8h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3AE8h case   40:*/		return 0x821F3AEC;
		  /* 821F3AECh */ case   41:  		/* addi R6, R10, -36 */
		/* 821F3AECh case   41:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3AECh case   41:*/		return 0x821F3AF0;
		  /* 821F3AF0h */ case   42:  		/* stw R7, <#[R11]> */
		/* 821F3AF0h case   42:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3AF0h case   42:*/		return 0x821F3AF4;
		  /* 821F3AF4h */ case   43:  		/* lwz R7, <#[R10]> */
		/* 821F3AF4h case   43:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3AF4h case   43:*/		return 0x821F3AF8;
		  /* 821F3AF8h */ case   44:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3AF8h case   44:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3AF8h case   44:*/		return 0x821F3AFC;
		  /* 821F3AFCh */ case   45:  		/* ori R6, R6, 1 */
		/* 821F3AFCh case   45:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3AFCh case   45:*/		return 0x821F3B00;
		  /* 821F3B00h */ case   46:  		/* stw R8, <#[R7]> */
		/* 821F3B00h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3B00h case   46:*/		return 0x821F3B04;
		  /* 821F3B04h */ case   47:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3B04h case   47:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3B04h case   47:*/		return 0x821F3B08;
		  /* 821F3B08h */ case   48:  		/* stw R9, <#[R10]> */
		/* 821F3B08h case   48:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3B08h case   48:*/		return 0x821F3B0C;
		  /* 821F3B0Ch */ case   49:  		/* addi R1, R1, 112 */
		/* 821F3B0Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3B0Ch case   49:*/		return 0x821F3B10;
		  /* 821F3B10h */ case   50:  		/* b -1452132 */
		/* 821F3B10h case   50:*/		return 0x820912AC;
		/* 821F3B10h case   50:*/		return 0x821F3B14;
		  /* 821F3B14h */ case   51:  		/* nop */
		/* 821F3B14h case   51:*/		cpu::op::nop();
		/* 821F3B14h case   51:*/		return 0x821F3B18;
	}
	return 0x821F3B18;
} // Block from 821F3A48h-821F3B18h (52 instructions)

//////////////////////////////////////////////////////
// Block at 821F3B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3B18);
		  /* 821F3B18h */ case    0:  		/* mfspr R12, LR */
		/* 821F3B18h case    0:*/		regs.R12 = regs.LR;
		/* 821F3B18h case    0:*/		return 0x821F3B1C;
		  /* 821F3B1Ch */ case    1:  		/* bl -1452224 */
		/* 821F3B1Ch case    1:*/		regs.LR = 0x821F3B20; return 0x8209125C;
		/* 821F3B1Ch case    1:*/		return 0x821F3B20;
		  /* 821F3B20h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3B20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3B20h case    2:*/		return 0x821F3B24;
		  /* 821F3B24h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F3B24h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F3B24h case    3:*/		return 0x821F3B28;
	}
	return 0x821F3B28;
} // Block from 821F3B18h-821F3B28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F3B28h
// Function '?MakeInstr_V_FRACT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3B28);
		  /* 821F3B28h */ case    0:  		/* li R8, 4 */
		/* 821F3B28h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3B28h case    0:*/		return 0x821F3B2C;
		  /* 821F3B2Ch */ case    1:  		/* li R7, 2 */
		/* 821F3B2Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3B2Ch case    1:*/		return 0x821F3B30;
		  /* 821F3B30h */ case    2:  		/* li R6, 2 */
		/* 821F3B30h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F3B30h case    2:*/		return 0x821F3B34;
		  /* 821F3B34h */ case    3:  		/* li R5, 0 */
		/* 821F3B34h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3B34h case    3:*/		return 0x821F3B38;
		  /* 821F3B38h */ case    4:  		/* mr R30, R4 */
		/* 821F3B38h case    4:*/		regs.R30 = regs.R4;
		/* 821F3B38h case    4:*/		return 0x821F3B3C;
		  /* 821F3B3Ch */ case    5:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3B3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3B3Ch case    5:*/		return 0x821F3B40;
		  /* 821F3B40h */ case    6:  		/* mr R31, R3 */
		/* 821F3B40h case    6:*/		regs.R31 = regs.R3;
		/* 821F3B40h case    6:*/		return 0x821F3B44;
		  /* 821F3B44h */ case    7:  		/* bl 200276 */
		/* 821F3B44h case    7:*/		regs.LR = 0x821F3B48; return 0x82224998;
		/* 821F3B44h case    7:*/		return 0x821F3B48;
		  /* 821F3B48h */ case    8:  		/* mr R29, R3 */
		/* 821F3B48h case    8:*/		regs.R29 = regs.R3;
		/* 821F3B48h case    8:*/		return 0x821F3B4C;
		  /* 821F3B4Ch */ case    9:  		/* mr R4, R30 */
		/* 821F3B4Ch case    9:*/		regs.R4 = regs.R30;
		/* 821F3B4Ch case    9:*/		return 0x821F3B50;
		  /* 821F3B50h */ case   10:  		/* mr R3, R31 */
		/* 821F3B50h case   10:*/		regs.R3 = regs.R31;
		/* 821F3B50h case   10:*/		return 0x821F3B54;
		  /* 821F3B54h */ case   11:  		/* bl -506708 */
		/* 821F3B54h case   11:*/		regs.LR = 0x821F3B58; return 0x82178000;
		/* 821F3B54h case   11:*/		return 0x821F3B58;
		  /* 821F3B58h */ case   12:  		/* mr R4, R3 */
		/* 821F3B58h case   12:*/		regs.R4 = regs.R3;
		/* 821F3B58h case   12:*/		return 0x821F3B5C;
		  /* 821F3B5Ch */ case   13:  		/* mr R3, R29 */
		/* 821F3B5Ch case   13:*/		regs.R3 = regs.R29;
		/* 821F3B5Ch case   13:*/		return 0x821F3B60;
		  /* 821F3B60h */ case   14:  		/* bl -506264 */
		/* 821F3B60h case   14:*/		regs.LR = 0x821F3B64; return 0x821781C8;
		/* 821F3B60h case   14:*/		return 0x821F3B64;
		  /* 821F3B64h */ case   15:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3B64h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3B64h case   15:*/		return 0x821F3B68;
		  /* 821F3B68h */ case   16:  		/* addi R4, R1, 144 */
		/* 821F3B68h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F3B68h case   16:*/		return 0x821F3B6C;
		  /* 821F3B6Ch */ case   17:  		/* mr R3, R31 */
		/* 821F3B6Ch case   17:*/		regs.R3 = regs.R31;
		/* 821F3B6Ch case   17:*/		return 0x821F3B70;
		  /* 821F3B70h */ case   18:  		/* bl -6128 */
		/* 821F3B70h case   18:*/		regs.LR = 0x821F3B74; return 0x821F2380;
		/* 821F3B70h case   18:*/		return 0x821F3B74;
		  /* 821F3B74h */ case   19:  		/* mr R4, R3 */
		/* 821F3B74h case   19:*/		regs.R4 = regs.R3;
		/* 821F3B74h case   19:*/		return 0x821F3B78;
		  /* 821F3B78h */ case   20:  		/* mr R3, R29 */
		/* 821F3B78h case   20:*/		regs.R3 = regs.R29;
		/* 821F3B78h case   20:*/		return 0x821F3B7C;
		  /* 821F3B7Ch */ case   21:  		/* bl -506292 */
		/* 821F3B7Ch case   21:*/		regs.LR = 0x821F3B80; return 0x821781C8;
		/* 821F3B7Ch case   21:*/		return 0x821F3B80;
		  /* 821F3B80h */ case   22:  		/* lwz R10, <#[R29 + 44]> */
		/* 821F3B80h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3B80h case   22:*/		return 0x821F3B84;
		  /* 821F3B84h */ case   23:  		/* stw R3, <#[R29 + 48]> */
		/* 821F3B84h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 821F3B84h case   23:*/		return 0x821F3B88;
		  /* 821F3B88h */ case   24:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F3B88h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F3B88h case   24:*/		return 0x821F3B8C;
		  /* 821F3B8Ch */ case   25:  		/* lwz R9, <#[R29 + 8]> */
		/* 821F3B8Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F3B8Ch case   25:*/		return 0x821F3B90;
		  /* 821F3B90h */ case   26:  		/* mr R3, R29 */
		/* 821F3B90h case   26:*/		regs.R3 = regs.R29;
		/* 821F3B90h case   26:*/		return 0x821F3B94;
		  /* 821F3B94h */ case   27:  		/* addi R11, R11, 36 */
		/* 821F3B94h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3B94h case   27:*/		return 0x821F3B98;
		  /* 821F3B98h */ case   28:  		/* lwz R10, <#[R10]> */
		/* 821F3B98h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3B98h case   28:*/		return 0x821F3B9C;
		  /* 821F3B9Ch */ case   29:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3B9Ch case   29:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3B9Ch case   29:*/		return 0x821F3BA0;
		  /* 821F3BA0h */ case   30:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3BA0h case   30:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3BA0h case   30:*/		return 0x821F3BA4;
		  /* 821F3BA4h */ case   31:  		/* addi R8, R11, -36 */
		/* 821F3BA4h case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3BA4h case   31:*/		return 0x821F3BA8;
		  /* 821F3BA8h */ case   32:  		/* stw R9, <#[R29 + 8]> */
		/* 821F3BA8h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F3BA8h case   32:*/		return 0x821F3BAC;
		  /* 821F3BACh */ case   33:  		/* addi R9, R11, 4 */
		/* 821F3BACh case   33:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3BACh case   33:*/		return 0x821F3BB0;
		  /* 821F3BB0h */ case   34:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F3BB0h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3BB0h case   34:*/		return 0x821F3BB4;
		  /* 821F3BB4h */ case   35:  		/* addi R10, R10, 24 */
		/* 821F3BB4h case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3BB4h case   35:*/		return 0x821F3BB8;
		  /* 821F3BB8h */ case   36:  		/* lwz R7, <#[R10]> */
		/* 821F3BB8h case   36:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3BB8h case   36:*/		return 0x821F3BBC;
		  /* 821F3BBCh */ case   37:  		/* addi R6, R10, -36 */
		/* 821F3BBCh case   37:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3BBCh case   37:*/		return 0x821F3BC0;
		  /* 821F3BC0h */ case   38:  		/* stw R7, <#[R11]> */
		/* 821F3BC0h case   38:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3BC0h case   38:*/		return 0x821F3BC4;
		  /* 821F3BC4h */ case   39:  		/* lwz R7, <#[R10]> */
		/* 821F3BC4h case   39:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3BC4h case   39:*/		return 0x821F3BC8;
		  /* 821F3BC8h */ case   40:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3BC8h case   40:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3BC8h case   40:*/		return 0x821F3BCC;
		  /* 821F3BCCh */ case   41:  		/* ori R6, R6, 1 */
		/* 821F3BCCh case   41:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3BCCh case   41:*/		return 0x821F3BD0;
	}
	return 0x821F3BD0;
} // Block from 821F3B28h-821F3BD0h (42 instructions)

//////////////////////////////////////////////////////
// Block at 821F3BD0h
// Function '?MakeInstr_S_EXP_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3BD0);
		  /* 821F3BD0h */ case    0:  		/* stw R8, <#[R7]> */
		/* 821F3BD0h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3BD0h case    0:*/		return 0x821F3BD4;
		  /* 821F3BD4h */ case    1:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3BD4h case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3BD4h case    1:*/		return 0x821F3BD8;
		  /* 821F3BD8h */ case    2:  		/* stw R9, <#[R10]> */
		/* 821F3BD8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3BD8h case    2:*/		return 0x821F3BDC;
		  /* 821F3BDCh */ case    3:  		/* addi R1, R1, 112 */
		/* 821F3BDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3BDCh case    3:*/		return 0x821F3BE0;
		  /* 821F3BE0h */ case    4:  		/* b -1452340 */
		/* 821F3BE0h case    4:*/		return 0x820912AC;
		/* 821F3BE0h case    4:*/		return 0x821F3BE4;
		  /* 821F3BE4h */ case    5:  		/* nop */
		/* 821F3BE4h case    5:*/		cpu::op::nop();
		/* 821F3BE4h case    5:*/		return 0x821F3BE8;
	}
	return 0x821F3BE8;
} // Block from 821F3BD0h-821F3BE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F3BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3BE8);
		  /* 821F3BE8h */ case    0:  		/* mfspr R12, LR */
		/* 821F3BE8h case    0:*/		regs.R12 = regs.LR;
		/* 821F3BE8h case    0:*/		return 0x821F3BEC;
		  /* 821F3BECh */ case    1:  		/* bl -1452432 */
		/* 821F3BECh case    1:*/		regs.LR = 0x821F3BF0; return 0x8209125C;
		/* 821F3BECh case    1:*/		return 0x821F3BF0;
		  /* 821F3BF0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3BF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3BF0h case    2:*/		return 0x821F3BF4;
		  /* 821F3BF4h */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F3BF4h case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F3BF4h case    3:*/		return 0x821F3BF8;
		  /* 821F3BF8h */ case    4:  		/* li R8, 4 */
		/* 821F3BF8h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3BF8h case    4:*/		return 0x821F3BFC;
		  /* 821F3BFCh */ case    5:  		/* li R7, 2 */
		/* 821F3BFCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3BFCh case    5:*/		return 0x821F3C00;
		  /* 821F3C00h */ case    6:  		/* li R6, 7 */
		/* 821F3C00h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 821F3C00h case    6:*/		return 0x821F3C04;
		  /* 821F3C04h */ case    7:  		/* li R5, 0 */
		/* 821F3C04h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3C04h case    7:*/		return 0x821F3C08;
		  /* 821F3C08h */ case    8:  		/* mr R30, R4 */
		/* 821F3C08h case    8:*/		regs.R30 = regs.R4;
		/* 821F3C08h case    8:*/		return 0x821F3C0C;
		  /* 821F3C0Ch */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3C0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3C0Ch case    9:*/		return 0x821F3C10;
		  /* 821F3C10h */ case   10:  		/* mr R31, R3 */
		/* 821F3C10h case   10:*/		regs.R31 = regs.R3;
		/* 821F3C10h case   10:*/		return 0x821F3C14;
		  /* 821F3C14h */ case   11:  		/* bl 200068 */
		/* 821F3C14h case   11:*/		regs.LR = 0x821F3C18; return 0x82224998;
		/* 821F3C14h case   11:*/		return 0x821F3C18;
		  /* 821F3C18h */ case   12:  		/* mr R29, R3 */
		/* 821F3C18h case   12:*/		regs.R29 = regs.R3;
		/* 821F3C18h case   12:*/		return 0x821F3C1C;
		  /* 821F3C1Ch */ case   13:  		/* mr R4, R30 */
		/* 821F3C1Ch case   13:*/		regs.R4 = regs.R30;
		/* 821F3C1Ch case   13:*/		return 0x821F3C20;
		  /* 821F3C20h */ case   14:  		/* mr R3, R31 */
		/* 821F3C20h case   14:*/		regs.R3 = regs.R31;
		/* 821F3C20h case   14:*/		return 0x821F3C24;
		  /* 821F3C24h */ case   15:  		/* bl -506916 */
		/* 821F3C24h case   15:*/		regs.LR = 0x821F3C28; return 0x82178000;
		/* 821F3C24h case   15:*/		return 0x821F3C28;
		  /* 821F3C28h */ case   16:  		/* mr R4, R3 */
		/* 821F3C28h case   16:*/		regs.R4 = regs.R3;
		/* 821F3C28h case   16:*/		return 0x821F3C2C;
		  /* 821F3C2Ch */ case   17:  		/* mr R3, R29 */
		/* 821F3C2Ch case   17:*/		regs.R3 = regs.R29;
		/* 821F3C2Ch case   17:*/		return 0x821F3C30;
		  /* 821F3C30h */ case   18:  		/* bl -506472 */
		/* 821F3C30h case   18:*/		regs.LR = 0x821F3C34; return 0x821781C8;
		/* 821F3C30h case   18:*/		return 0x821F3C34;
		  /* 821F3C34h */ case   19:  		/* stw R3, <#[R29 + 44]> */
		/* 821F3C34h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3C34h case   19:*/		return 0x821F3C38;
		  /* 821F3C38h */ case   20:  		/* addi R4, R1, 144 */
		/* 821F3C38h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F3C38h case   20:*/		return 0x821F3C3C;
		  /* 821F3C3Ch */ case   21:  		/* mr R3, R31 */
		/* 821F3C3Ch case   21:*/		regs.R3 = regs.R31;
		/* 821F3C3Ch case   21:*/		return 0x821F3C40;
		  /* 821F3C40h */ case   22:  		/* bl -6336 */
		/* 821F3C40h case   22:*/		regs.LR = 0x821F3C44; return 0x821F2380;
		/* 821F3C40h case   22:*/		return 0x821F3C44;
		  /* 821F3C44h */ case   23:  		/* mr R4, R3 */
		/* 821F3C44h case   23:*/		regs.R4 = regs.R3;
		/* 821F3C44h case   23:*/		return 0x821F3C48;
		  /* 821F3C48h */ case   24:  		/* mr R3, R29 */
		/* 821F3C48h case   24:*/		regs.R3 = regs.R29;
		/* 821F3C48h case   24:*/		return 0x821F3C4C;
		  /* 821F3C4Ch */ case   25:  		/* bl -506500 */
		/* 821F3C4Ch case   25:*/		regs.LR = 0x821F3C50; return 0x821781C8;
		/* 821F3C4Ch case   25:*/		return 0x821F3C50;
		  /* 821F3C50h */ case   26:  		/* lwz R10, <#[R29 + 44]> */
		/* 821F3C50h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F3C50h case   26:*/		return 0x821F3C54;
		  /* 821F3C54h */ case   27:  		/* stw R3, <#[R29 + 48]> */
		/* 821F3C54h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 821F3C54h case   27:*/		return 0x821F3C58;
		  /* 821F3C58h */ case   28:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F3C58h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F3C58h case   28:*/		return 0x821F3C5C;
		  /* 821F3C5Ch */ case   29:  		/* lwz R9, <#[R29 + 8]> */
		/* 821F3C5Ch case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F3C5Ch case   29:*/		return 0x821F3C60;
		  /* 821F3C60h */ case   30:  		/* mr R3, R29 */
		/* 821F3C60h case   30:*/		regs.R3 = regs.R29;
		/* 821F3C60h case   30:*/		return 0x821F3C64;
		  /* 821F3C64h */ case   31:  		/* addi R11, R11, 36 */
		/* 821F3C64h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3C64h case   31:*/		return 0x821F3C68;
	}
	return 0x821F3C68;
} // Block from 821F3BE8h-821F3C68h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F3C68h
// Function '?MakeInstr_S_LOG_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3C68);
		  /* 821F3C68h */ case    0:  		/* lwz R10, <#[R10]> */
		/* 821F3C68h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3C68h case    0:*/		return 0x821F3C6C;
		  /* 821F3C6Ch */ case    1:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3C6Ch case    1:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3C6Ch case    1:*/		return 0x821F3C70;
		  /* 821F3C70h */ case    2:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3C70h case    2:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3C70h case    2:*/		return 0x821F3C74;
		  /* 821F3C74h */ case    3:  		/* addi R8, R11, -36 */
		/* 821F3C74h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3C74h case    3:*/		return 0x821F3C78;
		  /* 821F3C78h */ case    4:  		/* stw R9, <#[R29 + 8]> */
		/* 821F3C78h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F3C78h case    4:*/		return 0x821F3C7C;
		  /* 821F3C7Ch */ case    5:  		/* addi R9, R11, 4 */
		/* 821F3C7Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3C7Ch case    5:*/		return 0x821F3C80;
		  /* 821F3C80h */ case    6:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F3C80h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3C80h case    6:*/		return 0x821F3C84;
		  /* 821F3C84h */ case    7:  		/* addi R10, R10, 24 */
		/* 821F3C84h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3C84h case    7:*/		return 0x821F3C88;
		  /* 821F3C88h */ case    8:  		/* lwz R7, <#[R10]> */
		/* 821F3C88h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3C88h case    8:*/		return 0x821F3C8C;
		  /* 821F3C8Ch */ case    9:  		/* addi R6, R10, -36 */
		/* 821F3C8Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3C8Ch case    9:*/		return 0x821F3C90;
		  /* 821F3C90h */ case   10:  		/* stw R7, <#[R11]> */
		/* 821F3C90h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3C90h case   10:*/		return 0x821F3C94;
		  /* 821F3C94h */ case   11:  		/* lwz R7, <#[R10]> */
		/* 821F3C94h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3C94h case   11:*/		return 0x821F3C98;
		  /* 821F3C98h */ case   12:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3C98h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3C98h case   12:*/		return 0x821F3C9C;
		  /* 821F3C9Ch */ case   13:  		/* ori R6, R6, 1 */
		/* 821F3C9Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3C9Ch case   13:*/		return 0x821F3CA0;
		  /* 821F3CA0h */ case   14:  		/* stw R8, <#[R7]> */
		/* 821F3CA0h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3CA0h case   14:*/		return 0x821F3CA4;
		  /* 821F3CA4h */ case   15:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3CA4h case   15:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3CA4h case   15:*/		return 0x821F3CA8;
		  /* 821F3CA8h */ case   16:  		/* stw R9, <#[R10]> */
		/* 821F3CA8h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3CA8h case   16:*/		return 0x821F3CAC;
		  /* 821F3CACh */ case   17:  		/* addi R1, R1, 112 */
		/* 821F3CACh case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3CACh case   17:*/		return 0x821F3CB0;
		  /* 821F3CB0h */ case   18:  		/* b -1452548 */
		/* 821F3CB0h case   18:*/		return 0x820912AC;
		/* 821F3CB0h case   18:*/		return 0x821F3CB4;
		  /* 821F3CB4h */ case   19:  		/* nop */
		/* 821F3CB4h case   19:*/		cpu::op::nop();
		/* 821F3CB4h case   19:*/		return 0x821F3CB8;
	}
	return 0x821F3CB8;
} // Block from 821F3C68h-821F3CB8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F3CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3CB8);
		  /* 821F3CB8h */ case    0:  		/* mfspr R12, LR */
		/* 821F3CB8h case    0:*/		regs.R12 = regs.LR;
		/* 821F3CB8h case    0:*/		return 0x821F3CBC;
		  /* 821F3CBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F3CBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F3CBCh case    1:*/		return 0x821F3CC0;
		  /* 821F3CC0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821F3CC0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F3CC0h case    2:*/		return 0x821F3CC4;
		  /* 821F3CC4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821F3CC4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F3CC4h case    3:*/		return 0x821F3CC8;
		  /* 821F3CC8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F3CC8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F3CC8h case    4:*/		return 0x821F3CCC;
		  /* 821F3CCCh */ case    5:  		/* std R4, <#[R1 + 136]> */
		/* 821F3CCCh case    5:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000088) );
		/* 821F3CCCh case    5:*/		return 0x821F3CD0;
		  /* 821F3CD0h */ case    6:  		/* li R8, 4 */
		/* 821F3CD0h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3CD0h case    6:*/		return 0x821F3CD4;
		  /* 821F3CD4h */ case    7:  		/* std R5, <#[R1 + 144]> */
		/* 821F3CD4h case    7:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F3CD4h case    7:*/		return 0x821F3CD8;
		  /* 821F3CD8h */ case    8:  		/* li R7, 2 */
		/* 821F3CD8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3CD8h case    8:*/		return 0x821F3CDC;
		  /* 821F3CDCh */ case    9:  		/* li R6, 2 */
		/* 821F3CDCh case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F3CDCh case    9:*/		return 0x821F3CE0;
		  /* 821F3CE0h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3CE0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3CE0h case   10:*/		return 0x821F3CE4;
		  /* 821F3CE4h */ case   11:  		/* li R5, 0 */
		/* 821F3CE4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3CE4h case   11:*/		return 0x821F3CE8;
		  /* 821F3CE8h */ case   12:  		/* mr R31, R3 */
		/* 821F3CE8h case   12:*/		regs.R31 = regs.R3;
		/* 821F3CE8h case   12:*/		return 0x821F3CEC;
		  /* 821F3CECh */ case   13:  		/* bl 199852 */
		/* 821F3CECh case   13:*/		regs.LR = 0x821F3CF0; return 0x82224998;
		/* 821F3CECh case   13:*/		return 0x821F3CF0;
		  /* 821F3CF0h */ case   14:  		/* mr R30, R3 */
		/* 821F3CF0h case   14:*/		regs.R30 = regs.R3;
		/* 821F3CF0h case   14:*/		return 0x821F3CF4;
		  /* 821F3CF4h */ case   15:  		/* addi R4, R1, 136 */
		/* 821F3CF4h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x88);
		/* 821F3CF4h case   15:*/		return 0x821F3CF8;
		  /* 821F3CF8h */ case   16:  		/* mr R3, R31 */
		/* 821F3CF8h case   16:*/		regs.R3 = regs.R31;
		/* 821F3CF8h case   16:*/		return 0x821F3CFC;
		  /* 821F3CFCh */ case   17:  		/* bl -6524 */
		/* 821F3CFCh case   17:*/		regs.LR = 0x821F3D00; return 0x821F2380;
		/* 821F3CFCh case   17:*/		return 0x821F3D00;
	}
	return 0x821F3D00;
} // Block from 821F3CB8h-821F3D00h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F3D00h
// Function '?MakeInstr_S_RECIP_IEEE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3D00);
		  /* 821F3D00h */ case    0:  		/* mr R4, R3 */
		/* 821F3D00h case    0:*/		regs.R4 = regs.R3;
		/* 821F3D00h case    0:*/		return 0x821F3D04;
		  /* 821F3D04h */ case    1:  		/* mr R3, R30 */
		/* 821F3D04h case    1:*/		regs.R3 = regs.R30;
		/* 821F3D04h case    1:*/		return 0x821F3D08;
		  /* 821F3D08h */ case    2:  		/* bl -506688 */
		/* 821F3D08h case    2:*/		regs.LR = 0x821F3D0C; return 0x821781C8;
		/* 821F3D08h case    2:*/		return 0x821F3D0C;
		  /* 821F3D0Ch */ case    3:  		/* stw R3, <#[R30 + 44]> */
		/* 821F3D0Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F3D0Ch case    3:*/		return 0x821F3D10;
		  /* 821F3D10h */ case    4:  		/* addi R4, R1, 144 */
		/* 821F3D10h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F3D10h case    4:*/		return 0x821F3D14;
		  /* 821F3D14h */ case    5:  		/* mr R3, R31 */
		/* 821F3D14h case    5:*/		regs.R3 = regs.R31;
		/* 821F3D14h case    5:*/		return 0x821F3D18;
		  /* 821F3D18h */ case    6:  		/* bl -6552 */
		/* 821F3D18h case    6:*/		regs.LR = 0x821F3D1C; return 0x821F2380;
		/* 821F3D18h case    6:*/		return 0x821F3D1C;
		  /* 821F3D1Ch */ case    7:  		/* mr R4, R3 */
		/* 821F3D1Ch case    7:*/		regs.R4 = regs.R3;
		/* 821F3D1Ch case    7:*/		return 0x821F3D20;
		  /* 821F3D20h */ case    8:  		/* mr R3, R30 */
		/* 821F3D20h case    8:*/		regs.R3 = regs.R30;
		/* 821F3D20h case    8:*/		return 0x821F3D24;
		  /* 821F3D24h */ case    9:  		/* bl -506716 */
		/* 821F3D24h case    9:*/		regs.LR = 0x821F3D28; return 0x821781C8;
		/* 821F3D24h case    9:*/		return 0x821F3D28;
		  /* 821F3D28h */ case   10:  		/* lwz R10, <#[R30 + 44]> */
		/* 821F3D28h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F3D28h case   10:*/		return 0x821F3D2C;
		  /* 821F3D2Ch */ case   11:  		/* stw R3, <#[R30 + 48]> */
		/* 821F3D2Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 821F3D2Ch case   11:*/		return 0x821F3D30;
		  /* 821F3D30h */ case   12:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821F3D30h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821F3D30h case   12:*/		return 0x821F3D34;
		  /* 821F3D34h */ case   13:  		/* lwz R9, <#[R30 + 8]> */
		/* 821F3D34h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821F3D34h case   13:*/		return 0x821F3D38;
		  /* 821F3D38h */ case   14:  		/* mr R3, R30 */
		/* 821F3D38h case   14:*/		regs.R3 = regs.R30;
		/* 821F3D38h case   14:*/		return 0x821F3D3C;
		  /* 821F3D3Ch */ case   15:  		/* addi R11, R11, 36 */
		/* 821F3D3Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3D3Ch case   15:*/		return 0x821F3D40;
		  /* 821F3D40h */ case   16:  		/* lwz R10, <#[R10]> */
		/* 821F3D40h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3D40h case   16:*/		return 0x821F3D44;
		  /* 821F3D44h */ case   17:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3D44h case   17:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3D44h case   17:*/		return 0x821F3D48;
		  /* 821F3D48h */ case   18:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3D48h case   18:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3D48h case   18:*/		return 0x821F3D4C;
		  /* 821F3D4Ch */ case   19:  		/* addi R8, R11, -36 */
		/* 821F3D4Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3D4Ch case   19:*/		return 0x821F3D50;
		  /* 821F3D50h */ case   20:  		/* stw R9, <#[R30 + 8]> */
		/* 821F3D50h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821F3D50h case   20:*/		return 0x821F3D54;
		  /* 821F3D54h */ case   21:  		/* addi R9, R11, 4 */
		/* 821F3D54h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3D54h case   21:*/		return 0x821F3D58;
		  /* 821F3D58h */ case   22:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F3D58h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3D58h case   22:*/		return 0x821F3D5C;
		  /* 821F3D5Ch */ case   23:  		/* addi R10, R10, 24 */
		/* 821F3D5Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3D5Ch case   23:*/		return 0x821F3D60;
		  /* 821F3D60h */ case   24:  		/* lwz R7, <#[R10]> */
		/* 821F3D60h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3D60h case   24:*/		return 0x821F3D64;
		  /* 821F3D64h */ case   25:  		/* addi R6, R10, -36 */
		/* 821F3D64h case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3D64h case   25:*/		return 0x821F3D68;
		  /* 821F3D68h */ case   26:  		/* stw R7, <#[R11]> */
		/* 821F3D68h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3D68h case   26:*/		return 0x821F3D6C;
		  /* 821F3D6Ch */ case   27:  		/* lwz R7, <#[R10]> */
		/* 821F3D6Ch case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3D6Ch case   27:*/		return 0x821F3D70;
		  /* 821F3D70h */ case   28:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3D70h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3D70h case   28:*/		return 0x821F3D74;
		  /* 821F3D74h */ case   29:  		/* ori R6, R6, 1 */
		/* 821F3D74h case   29:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3D74h case   29:*/		return 0x821F3D78;
		  /* 821F3D78h */ case   30:  		/* stw R8, <#[R7]> */
		/* 821F3D78h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3D78h case   30:*/		return 0x821F3D7C;
		  /* 821F3D7Ch */ case   31:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3D7Ch case   31:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3D7Ch case   31:*/		return 0x821F3D80;
		  /* 821F3D80h */ case   32:  		/* stw R9, <#[R10]> */
		/* 821F3D80h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3D80h case   32:*/		return 0x821F3D84;
		  /* 821F3D84h */ case   33:  		/* addi R1, R1, 112 */
		/* 821F3D84h case   33:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F3D84h case   33:*/		return 0x821F3D88;
		  /* 821F3D88h */ case   34:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F3D88h case   34:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F3D88h case   34:*/		return 0x821F3D8C;
		  /* 821F3D8Ch */ case   35:  		/* mtspr LR, R12 */
		/* 821F3D8Ch case   35:*/		regs.LR = regs.R12;
		/* 821F3D8Ch case   35:*/		return 0x821F3D90;
		  /* 821F3D90h */ case   36:  		/* ld R30, <#[R1 - 24]> */
		/* 821F3D90h case   36:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821F3D90h case   36:*/		return 0x821F3D94;
		  /* 821F3D94h */ case   37:  		/* ld R31, <#[R1 - 16]> */
		/* 821F3D94h case   37:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F3D94h case   37:*/		return 0x821F3D98;
	}
	return 0x821F3D98;
} // Block from 821F3D00h-821F3D98h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821F3D98h
// Function '?MakeInstr_S_PRED_SETNE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3D98);
		  /* 821F3D98h */ case    0:  		/* bclr 20, CR0_LT */
		/* 821F3D98h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F3D98h case    0:*/		return 0x821F3D9C;
	}
	return 0x821F3D9C;
} // Block from 821F3D98h-821F3D9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F3D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3D9C);
		  /* 821F3D9Ch */ case    0:  		/* nop */
		/* 821F3D9Ch case    0:*/		cpu::op::nop();
		/* 821F3D9Ch case    0:*/		return 0x821F3DA0;
	}
	return 0x821F3DA0;
} // Block from 821F3D9Ch-821F3DA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F3DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3DA0);
		  /* 821F3DA0h */ case    0:  		/* mfspr R12, LR */
		/* 821F3DA0h case    0:*/		regs.R12 = regs.LR;
		/* 821F3DA0h case    0:*/		return 0x821F3DA4;
		  /* 821F3DA4h */ case    1:  		/* bl -1452876 */
		/* 821F3DA4h case    1:*/		regs.LR = 0x821F3DA8; return 0x82091258;
		/* 821F3DA4h case    1:*/		return 0x821F3DA8;
		  /* 821F3DA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F3DA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F3DA8h case    2:*/		return 0x821F3DAC;
		  /* 821F3DACh */ case    3:  		/* mr R28, R5 */
		/* 821F3DACh case    3:*/		regs.R28 = regs.R5;
		/* 821F3DACh case    3:*/		return 0x821F3DB0;
		  /* 821F3DB0h */ case    4:  		/* li R8, 4 */
		/* 821F3DB0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3DB0h case    4:*/		return 0x821F3DB4;
		  /* 821F3DB4h */ case    5:  		/* li R7, 2 */
		/* 821F3DB4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3DB4h case    5:*/		return 0x821F3DB8;
		  /* 821F3DB8h */ case    6:  		/* li R6, 3 */
		/* 821F3DB8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821F3DB8h case    6:*/		return 0x821F3DBC;
		  /* 821F3DBCh */ case    7:  		/* li R5, 0 */
		/* 821F3DBCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3DBCh case    7:*/		return 0x821F3DC0;
		  /* 821F3DC0h */ case    8:  		/* mr R29, R4 */
		/* 821F3DC0h case    8:*/		regs.R29 = regs.R4;
		/* 821F3DC0h case    8:*/		return 0x821F3DC4;
		  /* 821F3DC4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3DC4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3DC4h case    9:*/		return 0x821F3DC8;
		  /* 821F3DC8h */ case   10:  		/* mr R30, R3 */
		/* 821F3DC8h case   10:*/		regs.R30 = regs.R3;
		/* 821F3DC8h case   10:*/		return 0x821F3DCC;
		  /* 821F3DCCh */ case   11:  		/* bl 199628 */
		/* 821F3DCCh case   11:*/		regs.LR = 0x821F3DD0; return 0x82224998;
		/* 821F3DCCh case   11:*/		return 0x821F3DD0;
		  /* 821F3DD0h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F3DD0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F3DD0h case   12:*/		return 0x821F3DD4;
		  /* 821F3DD4h */ case   13:  		/* mr R31, R3 */
		/* 821F3DD4h case   13:*/		regs.R31 = regs.R3;
		/* 821F3DD4h case   13:*/		return 0x821F3DD8;
		  /* 821F3DD8h */ case   14:  		/* mr R4, R29 */
		/* 821F3DD8h case   14:*/		regs.R4 = regs.R29;
		/* 821F3DD8h case   14:*/		return 0x821F3DDC;
		  /* 821F3DDCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F3DDCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F3DDCh case   15:*/		return 0x821F3DE0;
		  /* 821F3DE0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F3DE0h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F3DF4;  }
		/* 821F3DE0h case   16:*/		return 0x821F3DE4;
		  /* 821F3DE4h */ case   17:  		/* mr R3, R30 */
		/* 821F3DE4h case   17:*/		regs.R3 = regs.R30;
		/* 821F3DE4h case   17:*/		return 0x821F3DE8;
		  /* 821F3DE8h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F3DE8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F3DE8h case   18:*/		return 0x821F3DEC;
		  /* 821F3DECh */ case   19:  		/* bl -535804 */
		/* 821F3DECh case   19:*/		regs.LR = 0x821F3DF0; return 0x821710F0;
		/* 821F3DECh case   19:*/		return 0x821F3DF0;
		  /* 821F3DF0h */ case   20:  		/* mr R4, R3 */
		/* 821F3DF0h case   20:*/		regs.R4 = regs.R3;
		/* 821F3DF0h case   20:*/		return 0x821F3DF4;
	}
	return 0x821F3DF4;
} // Block from 821F3DA0h-821F3DF4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F3DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3DF4);
		  /* 821F3DF4h */ case    0:  		/* mr R3, R31 */
		/* 821F3DF4h case    0:*/		regs.R3 = regs.R31;
		/* 821F3DF4h case    0:*/		return 0x821F3DF8;
		  /* 821F3DF8h */ case    1:  		/* bl -506928 */
		/* 821F3DF8h case    1:*/		regs.LR = 0x821F3DFC; return 0x821781C8;
		/* 821F3DF8h case    1:*/		return 0x821F3DFC;
		  /* 821F3DFCh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F3DFCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3DFCh case    2:*/		return 0x821F3E00;
		  /* 821F3E00h */ case    3:  		/* mr R4, R28 */
		/* 821F3E00h case    3:*/		regs.R4 = regs.R28;
		/* 821F3E00h case    3:*/		return 0x821F3E04;
		  /* 821F3E04h */ case    4:  		/* mr R3, R30 */
		/* 821F3E04h case    4:*/		regs.R3 = regs.R30;
		/* 821F3E04h case    4:*/		return 0x821F3E08;
		  /* 821F3E08h */ case    5:  		/* bl -6792 */
		/* 821F3E08h case    5:*/		regs.LR = 0x821F3E0C; return 0x821F2380;
		/* 821F3E08h case    5:*/		return 0x821F3E0C;
		  /* 821F3E0Ch */ case    6:  		/* mr R4, R3 */
		/* 821F3E0Ch case    6:*/		regs.R4 = regs.R3;
		/* 821F3E0Ch case    6:*/		return 0x821F3E10;
	}
	return 0x821F3E10;
} // Block from 821F3DF4h-821F3E10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F3E10h
// Function '?MakeInstr_T_TFETCH@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3E10);
		  /* 821F3E10h */ case    0:  		/* mr R3, R31 */
		/* 821F3E10h case    0:*/		regs.R3 = regs.R31;
		/* 821F3E10h case    0:*/		return 0x821F3E14;
		  /* 821F3E14h */ case    1:  		/* bl -506956 */
		/* 821F3E14h case    1:*/		regs.LR = 0x821F3E18; return 0x821781C8;
		/* 821F3E14h case    1:*/		return 0x821F3E18;
		  /* 821F3E18h */ case    2:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F3E18h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3E18h case    2:*/		return 0x821F3E1C;
		  /* 821F3E1Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821F3E1Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F3E1Ch case    3:*/		return 0x821F3E20;
		  /* 821F3E20h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F3E20h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F3E20h case    4:*/		return 0x821F3E24;
		  /* 821F3E24h */ case    5:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F3E24h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3E24h case    5:*/		return 0x821F3E28;
		  /* 821F3E28h */ case    6:  		/* mr R3, R31 */
		/* 821F3E28h case    6:*/		regs.R3 = regs.R31;
		/* 821F3E28h case    6:*/		return 0x821F3E2C;
		  /* 821F3E2Ch */ case    7:  		/* addi R11, R11, 36 */
		/* 821F3E2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3E2Ch case    7:*/		return 0x821F3E30;
		  /* 821F3E30h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 821F3E30h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3E30h case    8:*/		return 0x821F3E34;
		  /* 821F3E34h */ case    9:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3E34h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3E34h case    9:*/		return 0x821F3E38;
		  /* 821F3E38h */ case   10:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3E38h case   10:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3E38h case   10:*/		return 0x821F3E3C;
		  /* 821F3E3Ch */ case   11:  		/* addi R8, R11, -36 */
		/* 821F3E3Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3E3Ch case   11:*/		return 0x821F3E40;
		  /* 821F3E40h */ case   12:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3E40h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3E40h case   12:*/		return 0x821F3E44;
		  /* 821F3E44h */ case   13:  		/* addi R9, R11, 4 */
		/* 821F3E44h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3E44h case   13:*/		return 0x821F3E48;
		  /* 821F3E48h */ case   14:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3E48h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3E48h case   14:*/		return 0x821F3E4C;
		  /* 821F3E4Ch */ case   15:  		/* addi R10, R10, 24 */
		/* 821F3E4Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3E4Ch case   15:*/		return 0x821F3E50;
		  /* 821F3E50h */ case   16:  		/* lwz R7, <#[R10]> */
		/* 821F3E50h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3E50h case   16:*/		return 0x821F3E54;
		  /* 821F3E54h */ case   17:  		/* addi R6, R10, -36 */
		/* 821F3E54h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3E54h case   17:*/		return 0x821F3E58;
		  /* 821F3E58h */ case   18:  		/* stw R7, <#[R11]> */
		/* 821F3E58h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3E58h case   18:*/		return 0x821F3E5C;
		  /* 821F3E5Ch */ case   19:  		/* lwz R7, <#[R10]> */
		/* 821F3E5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3E5Ch case   19:*/		return 0x821F3E60;
		  /* 821F3E60h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3E60h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3E60h case   20:*/		return 0x821F3E64;
		  /* 821F3E64h */ case   21:  		/* ori R6, R6, 1 */
		/* 821F3E64h case   21:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3E64h case   21:*/		return 0x821F3E68;
		  /* 821F3E68h */ case   22:  		/* stw R8, <#[R7]> */
		/* 821F3E68h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3E68h case   22:*/		return 0x821F3E6C;
		  /* 821F3E6Ch */ case   23:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3E6Ch case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3E6Ch case   23:*/		return 0x821F3E70;
		  /* 821F3E70h */ case   24:  		/* stw R9, <#[R10]> */
		/* 821F3E70h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3E70h case   24:*/		return 0x821F3E74;
		  /* 821F3E74h */ case   25:  		/* addi R1, R1, 128 */
		/* 821F3E74h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F3E74h case   25:*/		return 0x821F3E78;
		  /* 821F3E78h */ case   26:  		/* b -1453008 */
		/* 821F3E78h case   26:*/		return 0x820912A8;
		/* 821F3E78h case   26:*/		return 0x821F3E7C;
		  /* 821F3E7Ch */ case   27:  		/* nop */
		/* 821F3E7Ch case   27:*/		cpu::op::nop();
		/* 821F3E7Ch case   27:*/		return 0x821F3E80;
	}
	return 0x821F3E80;
} // Block from 821F3E10h-821F3E80h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821F3E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3E80);
		  /* 821F3E80h */ case    0:  		/* mfspr R12, LR */
		/* 821F3E80h case    0:*/		regs.R12 = regs.LR;
		/* 821F3E80h case    0:*/		return 0x821F3E84;
		  /* 821F3E84h */ case    1:  		/* bl -1453100 */
		/* 821F3E84h case    1:*/		regs.LR = 0x821F3E88; return 0x82091258;
		/* 821F3E84h case    1:*/		return 0x821F3E88;
		  /* 821F3E88h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F3E88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F3E88h case    2:*/		return 0x821F3E8C;
		  /* 821F3E8Ch */ case    3:  		/* mr R28, R5 */
		/* 821F3E8Ch case    3:*/		regs.R28 = regs.R5;
		/* 821F3E8Ch case    3:*/		return 0x821F3E90;
		  /* 821F3E90h */ case    4:  		/* li R8, 4 */
		/* 821F3E90h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3E90h case    4:*/		return 0x821F3E94;
		  /* 821F3E94h */ case    5:  		/* li R7, 2 */
		/* 821F3E94h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3E94h case    5:*/		return 0x821F3E98;
		  /* 821F3E98h */ case    6:  		/* li R6, 6 */
		/* 821F3E98h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 821F3E98h case    6:*/		return 0x821F3E9C;
		  /* 821F3E9Ch */ case    7:  		/* li R5, 0 */
		/* 821F3E9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3E9Ch case    7:*/		return 0x821F3EA0;
		  /* 821F3EA0h */ case    8:  		/* mr R29, R4 */
		/* 821F3EA0h case    8:*/		regs.R29 = regs.R4;
		/* 821F3EA0h case    8:*/		return 0x821F3EA4;
		  /* 821F3EA4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3EA4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3EA4h case    9:*/		return 0x821F3EA8;
		  /* 821F3EA8h */ case   10:  		/* mr R30, R3 */
		/* 821F3EA8h case   10:*/		regs.R30 = regs.R3;
		/* 821F3EA8h case   10:*/		return 0x821F3EAC;
		  /* 821F3EACh */ case   11:  		/* bl 199404 */
		/* 821F3EACh case   11:*/		regs.LR = 0x821F3EB0; return 0x82224998;
		/* 821F3EACh case   11:*/		return 0x821F3EB0;
		  /* 821F3EB0h */ case   12:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F3EB0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F3EB0h case   12:*/		return 0x821F3EB4;
		  /* 821F3EB4h */ case   13:  		/* mr R31, R3 */
		/* 821F3EB4h case   13:*/		regs.R31 = regs.R3;
		/* 821F3EB4h case   13:*/		return 0x821F3EB8;
		  /* 821F3EB8h */ case   14:  		/* mr R4, R29 */
		/* 821F3EB8h case   14:*/		regs.R4 = regs.R29;
		/* 821F3EB8h case   14:*/		return 0x821F3EBC;
		  /* 821F3EBCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821F3EBCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F3EBCh case   15:*/		return 0x821F3EC0;
		  /* 821F3EC0h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 821F3EC0h case   16:*/		if ( regs.CR[6].eq ) { return 0x821F3ED4;  }
		/* 821F3EC0h case   16:*/		return 0x821F3EC4;
		  /* 821F3EC4h */ case   17:  		/* mr R3, R30 */
		/* 821F3EC4h case   17:*/		regs.R3 = regs.R30;
		/* 821F3EC4h case   17:*/		return 0x821F3EC8;
		  /* 821F3EC8h */ case   18:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F3EC8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F3EC8h case   18:*/		return 0x821F3ECC;
		  /* 821F3ECCh */ case   19:  		/* bl -536028 */
		/* 821F3ECCh case   19:*/		regs.LR = 0x821F3ED0; return 0x821710F0;
		/* 821F3ECCh case   19:*/		return 0x821F3ED0;
		  /* 821F3ED0h */ case   20:  		/* mr R4, R3 */
		/* 821F3ED0h case   20:*/		regs.R4 = regs.R3;
		/* 821F3ED0h case   20:*/		return 0x821F3ED4;
	}
	return 0x821F3ED4;
} // Block from 821F3E80h-821F3ED4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F3ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3ED4);
		  /* 821F3ED4h */ case    0:  		/* mr R3, R31 */
		/* 821F3ED4h case    0:*/		regs.R3 = regs.R31;
		/* 821F3ED4h case    0:*/		return 0x821F3ED8;
	}
	return 0x821F3ED8;
} // Block from 821F3ED4h-821F3ED8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F3ED8h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3ED8);
		  /* 821F3ED8h */ case    0:  		/* bl -507152 */
		/* 821F3ED8h case    0:*/		regs.LR = 0x821F3EDC; return 0x821781C8;
		/* 821F3ED8h case    0:*/		return 0x821F3EDC;
		  /* 821F3EDCh */ case    1:  		/* stw R3, <#[R31 + 44]> */
		/* 821F3EDCh case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3EDCh case    1:*/		return 0x821F3EE0;
		  /* 821F3EE0h */ case    2:  		/* mr R4, R28 */
		/* 821F3EE0h case    2:*/		regs.R4 = regs.R28;
		/* 821F3EE0h case    2:*/		return 0x821F3EE4;
		  /* 821F3EE4h */ case    3:  		/* mr R3, R30 */
		/* 821F3EE4h case    3:*/		regs.R3 = regs.R30;
		/* 821F3EE4h case    3:*/		return 0x821F3EE8;
		  /* 821F3EE8h */ case    4:  		/* bl -7016 */
		/* 821F3EE8h case    4:*/		regs.LR = 0x821F3EEC; return 0x821F2380;
		/* 821F3EE8h case    4:*/		return 0x821F3EEC;
		  /* 821F3EECh */ case    5:  		/* mr R4, R3 */
		/* 821F3EECh case    5:*/		regs.R4 = regs.R3;
		/* 821F3EECh case    5:*/		return 0x821F3EF0;
		  /* 821F3EF0h */ case    6:  		/* mr R3, R31 */
		/* 821F3EF0h case    6:*/		regs.R3 = regs.R31;
		/* 821F3EF0h case    6:*/		return 0x821F3EF4;
		  /* 821F3EF4h */ case    7:  		/* bl -507180 */
		/* 821F3EF4h case    7:*/		regs.LR = 0x821F3EF8; return 0x821781C8;
		/* 821F3EF4h case    7:*/		return 0x821F3EF8;
		  /* 821F3EF8h */ case    8:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F3EF8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F3EF8h case    8:*/		return 0x821F3EFC;
		  /* 821F3EFCh */ case    9:  		/* stw R3, <#[R31 + 48]> */
		/* 821F3EFCh case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F3EFCh case    9:*/		return 0x821F3F00;
		  /* 821F3F00h */ case   10:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F3F00h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F3F00h case   10:*/		return 0x821F3F04;
		  /* 821F3F04h */ case   11:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F3F04h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3F04h case   11:*/		return 0x821F3F08;
		  /* 821F3F08h */ case   12:  		/* mr R3, R31 */
		/* 821F3F08h case   12:*/		regs.R3 = regs.R31;
		/* 821F3F08h case   12:*/		return 0x821F3F0C;
		  /* 821F3F0Ch */ case   13:  		/* addi R11, R11, 36 */
		/* 821F3F0Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3F0Ch case   13:*/		return 0x821F3F10;
		  /* 821F3F10h */ case   14:  		/* lwz R10, <#[R10]> */
		/* 821F3F10h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3F10h case   14:*/		return 0x821F3F14;
		  /* 821F3F14h */ case   15:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3F14h case   15:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3F14h case   15:*/		return 0x821F3F18;
		  /* 821F3F18h */ case   16:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3F18h case   16:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3F18h case   16:*/		return 0x821F3F1C;
		  /* 821F3F1Ch */ case   17:  		/* addi R8, R11, -36 */
		/* 821F3F1Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3F1Ch case   17:*/		return 0x821F3F20;
		  /* 821F3F20h */ case   18:  		/* stw R9, <#[R31 + 8]> */
		/* 821F3F20h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F3F20h case   18:*/		return 0x821F3F24;
		  /* 821F3F24h */ case   19:  		/* addi R9, R11, 4 */
		/* 821F3F24h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3F24h case   19:*/		return 0x821F3F28;
		  /* 821F3F28h */ case   20:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F3F28h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F3F28h case   20:*/		return 0x821F3F2C;
		  /* 821F3F2Ch */ case   21:  		/* addi R10, R10, 24 */
		/* 821F3F2Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3F2Ch case   21:*/		return 0x821F3F30;
		  /* 821F3F30h */ case   22:  		/* lwz R7, <#[R10]> */
		/* 821F3F30h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3F30h case   22:*/		return 0x821F3F34;
		  /* 821F3F34h */ case   23:  		/* addi R6, R10, -36 */
		/* 821F3F34h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F3F34h case   23:*/		return 0x821F3F38;
		  /* 821F3F38h */ case   24:  		/* stw R7, <#[R11]> */
		/* 821F3F38h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F3F38h case   24:*/		return 0x821F3F3C;
		  /* 821F3F3Ch */ case   25:  		/* lwz R7, <#[R10]> */
		/* 821F3F3Ch case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3F3Ch case   25:*/		return 0x821F3F40;
		  /* 821F3F40h */ case   26:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F3F40h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F3F40h case   26:*/		return 0x821F3F44;
		  /* 821F3F44h */ case   27:  		/* ori R6, R6, 1 */
		/* 821F3F44h case   27:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F3F44h case   27:*/		return 0x821F3F48;
		  /* 821F3F48h */ case   28:  		/* stw R8, <#[R7]> */
		/* 821F3F48h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F3F48h case   28:*/		return 0x821F3F4C;
		  /* 821F3F4Ch */ case   29:  		/* stw R6, <#[R11 + 4]> */
		/* 821F3F4Ch case   29:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F3F4Ch case   29:*/		return 0x821F3F50;
		  /* 821F3F50h */ case   30:  		/* stw R9, <#[R10]> */
		/* 821F3F50h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3F50h case   30:*/		return 0x821F3F54;
		  /* 821F3F54h */ case   31:  		/* addi R1, R1, 128 */
		/* 821F3F54h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F3F54h case   31:*/		return 0x821F3F58;
		  /* 821F3F58h */ case   32:  		/* b -1453232 */
		/* 821F3F58h case   32:*/		return 0x820912A8;
		/* 821F3F58h case   32:*/		return 0x821F3F5C;
		  /* 821F3F5Ch */ case   33:  		/* nop */
		/* 821F3F5Ch case   33:*/		cpu::op::nop();
		/* 821F3F5Ch case   33:*/		return 0x821F3F60;
	}
	return 0x821F3F60;
} // Block from 821F3ED8h-821F3F60h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821F3F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3F60);
		  /* 821F3F60h */ case    0:  		/* mfspr R12, LR */
		/* 821F3F60h case    0:*/		regs.R12 = regs.LR;
		/* 821F3F60h case    0:*/		return 0x821F3F64;
		  /* 821F3F64h */ case    1:  		/* bl -1453324 */
		/* 821F3F64h case    1:*/		regs.LR = 0x821F3F68; return 0x82091258;
		/* 821F3F64h case    1:*/		return 0x821F3F68;
		  /* 821F3F68h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F3F68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F3F68h case    2:*/		return 0x821F3F6C;
		  /* 821F3F6Ch */ case    3:  		/* mr R29, R5 */
		/* 821F3F6Ch case    3:*/		regs.R29 = regs.R5;
		/* 821F3F6Ch case    3:*/		return 0x821F3F70;
		  /* 821F3F70h */ case    4:  		/* li R8, 4 */
		/* 821F3F70h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F3F70h case    4:*/		return 0x821F3F74;
		  /* 821F3F74h */ case    5:  		/* li R7, 2 */
		/* 821F3F74h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F3F74h case    5:*/		return 0x821F3F78;
		  /* 821F3F78h */ case    6:  		/* li R6, 1 */
		/* 821F3F78h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F3F78h case    6:*/		return 0x821F3F7C;
		  /* 821F3F7Ch */ case    7:  		/* li R5, 0 */
		/* 821F3F7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F3F7Ch case    7:*/		return 0x821F3F80;
		  /* 821F3F80h */ case    8:  		/* mr R30, R4 */
		/* 821F3F80h case    8:*/		regs.R30 = regs.R4;
		/* 821F3F80h case    8:*/		return 0x821F3F84;
		  /* 821F3F84h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F3F84h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F3F84h case    9:*/		return 0x821F3F88;
		  /* 821F3F88h */ case   10:  		/* mr R31, R3 */
		/* 821F3F88h case   10:*/		regs.R31 = regs.R3;
		/* 821F3F88h case   10:*/		return 0x821F3F8C;
		  /* 821F3F8Ch */ case   11:  		/* bl 199180 */
		/* 821F3F8Ch case   11:*/		regs.LR = 0x821F3F90; return 0x82224998;
		/* 821F3F8Ch case   11:*/		return 0x821F3F90;
		  /* 821F3F90h */ case   12:  		/* mr R28, R3 */
		/* 821F3F90h case   12:*/		regs.R28 = regs.R3;
		/* 821F3F90h case   12:*/		return 0x821F3F94;
		  /* 821F3F94h */ case   13:  		/* mr R4, R30 */
		/* 821F3F94h case   13:*/		regs.R4 = regs.R30;
		/* 821F3F94h case   13:*/		return 0x821F3F98;
		  /* 821F3F98h */ case   14:  		/* mr R3, R31 */
		/* 821F3F98h case   14:*/		regs.R3 = regs.R31;
		/* 821F3F98h case   14:*/		return 0x821F3F9C;
		  /* 821F3F9Ch */ case   15:  		/* bl -507804 */
		/* 821F3F9Ch case   15:*/		regs.LR = 0x821F3FA0; return 0x82178000;
		/* 821F3F9Ch case   15:*/		return 0x821F3FA0;
		  /* 821F3FA0h */ case   16:  		/* mr R4, R3 */
		/* 821F3FA0h case   16:*/		regs.R4 = regs.R3;
		/* 821F3FA0h case   16:*/		return 0x821F3FA4;
		  /* 821F3FA4h */ case   17:  		/* mr R3, R28 */
		/* 821F3FA4h case   17:*/		regs.R3 = regs.R28;
		/* 821F3FA4h case   17:*/		return 0x821F3FA8;
	}
	return 0x821F3FA8;
} // Block from 821F3F60h-821F3FA8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F3FA8h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F3FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F3FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F3FA8);
		  /* 821F3FA8h */ case    0:  		/* bl -507360 */
		/* 821F3FA8h case    0:*/		regs.LR = 0x821F3FAC; return 0x821781C8;
		/* 821F3FA8h case    0:*/		return 0x821F3FAC;
		  /* 821F3FACh */ case    1:  		/* stw R3, <#[R28 + 44]> */
		/* 821F3FACh case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F3FACh case    1:*/		return 0x821F3FB0;
		  /* 821F3FB0h */ case    2:  		/* mr R4, R29 */
		/* 821F3FB0h case    2:*/		regs.R4 = regs.R29;
		/* 821F3FB0h case    2:*/		return 0x821F3FB4;
		  /* 821F3FB4h */ case    3:  		/* mr R3, R31 */
		/* 821F3FB4h case    3:*/		regs.R3 = regs.R31;
		/* 821F3FB4h case    3:*/		return 0x821F3FB8;
		  /* 821F3FB8h */ case    4:  		/* bl -7224 */
		/* 821F3FB8h case    4:*/		regs.LR = 0x821F3FBC; return 0x821F2380;
		/* 821F3FB8h case    4:*/		return 0x821F3FBC;
		  /* 821F3FBCh */ case    5:  		/* mr R4, R3 */
		/* 821F3FBCh case    5:*/		regs.R4 = regs.R3;
		/* 821F3FBCh case    5:*/		return 0x821F3FC0;
		  /* 821F3FC0h */ case    6:  		/* mr R3, R28 */
		/* 821F3FC0h case    6:*/		regs.R3 = regs.R28;
		/* 821F3FC0h case    6:*/		return 0x821F3FC4;
		  /* 821F3FC4h */ case    7:  		/* bl -507388 */
		/* 821F3FC4h case    7:*/		regs.LR = 0x821F3FC8; return 0x821781C8;
		/* 821F3FC4h case    7:*/		return 0x821F3FC8;
		  /* 821F3FC8h */ case    8:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F3FC8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F3FC8h case    8:*/		return 0x821F3FCC;
		  /* 821F3FCCh */ case    9:  		/* stw R3, <#[R28 + 48]> */
		/* 821F3FCCh case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F3FCCh case    9:*/		return 0x821F3FD0;
		  /* 821F3FD0h */ case   10:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F3FD0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F3FD0h case   10:*/		return 0x821F3FD4;
		  /* 821F3FD4h */ case   11:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F3FD4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F3FD4h case   11:*/		return 0x821F3FD8;
		  /* 821F3FD8h */ case   12:  		/* mr R3, R28 */
		/* 821F3FD8h case   12:*/		regs.R3 = regs.R28;
		/* 821F3FD8h case   12:*/		return 0x821F3FDC;
		  /* 821F3FDCh */ case   13:  		/* addi R11, R11, 36 */
		/* 821F3FDCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F3FDCh case   13:*/		return 0x821F3FE0;
		  /* 821F3FE0h */ case   14:  		/* lwz R10, <#[R10]> */
		/* 821F3FE0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F3FE0h case   14:*/		return 0x821F3FE4;
		  /* 821F3FE4h */ case   15:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F3FE4h case   15:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F3FE4h case   15:*/		return 0x821F3FE8;
		  /* 821F3FE8h */ case   16:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F3FE8h case   16:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F3FE8h case   16:*/		return 0x821F3FEC;
		  /* 821F3FECh */ case   17:  		/* addi R8, R11, -36 */
		/* 821F3FECh case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F3FECh case   17:*/		return 0x821F3FF0;
		  /* 821F3FF0h */ case   18:  		/* stw R9, <#[R28 + 8]> */
		/* 821F3FF0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F3FF0h case   18:*/		return 0x821F3FF4;
		  /* 821F3FF4h */ case   19:  		/* addi R9, R11, 4 */
		/* 821F3FF4h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F3FF4h case   19:*/		return 0x821F3FF8;
		  /* 821F3FF8h */ case   20:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F3FF8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F3FF8h case   20:*/		return 0x821F3FFC;
		  /* 821F3FFCh */ case   21:  		/* addi R10, R10, 24 */
		/* 821F3FFCh case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F3FFCh case   21:*/		return 0x821F4000;
		  /* 821F4000h */ case   22:  		/* lwz R7, <#[R10]> */
		/* 821F4000h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4000h case   22:*/		return 0x821F4004;
		  /* 821F4004h */ case   23:  		/* addi R6, R10, -36 */
		/* 821F4004h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F4004h case   23:*/		return 0x821F4008;
		  /* 821F4008h */ case   24:  		/* stw R7, <#[R11]> */
		/* 821F4008h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4008h case   24:*/		return 0x821F400C;
		  /* 821F400Ch */ case   25:  		/* lwz R7, <#[R10]> */
		/* 821F400Ch case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F400Ch case   25:*/		return 0x821F4010;
		  /* 821F4010h */ case   26:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F4010h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F4010h case   26:*/		return 0x821F4014;
		  /* 821F4014h */ case   27:  		/* ori R6, R6, 1 */
		/* 821F4014h case   27:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F4014h case   27:*/		return 0x821F4018;
		  /* 821F4018h */ case   28:  		/* stw R8, <#[R7]> */
		/* 821F4018h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F4018h case   28:*/		return 0x821F401C;
		  /* 821F401Ch */ case   29:  		/* stw R6, <#[R11 + 4]> */
		/* 821F401Ch case   29:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F401Ch case   29:*/		return 0x821F4020;
		  /* 821F4020h */ case   30:  		/* stw R9, <#[R10]> */
		/* 821F4020h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4020h case   30:*/		return 0x821F4024;
		  /* 821F4024h */ case   31:  		/* addi R1, R1, 128 */
		/* 821F4024h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F4024h case   31:*/		return 0x821F4028;
		  /* 821F4028h */ case   32:  		/* b -1453440 */
		/* 821F4028h case   32:*/		return 0x820912A8;
		/* 821F4028h case   32:*/		return 0x821F402C;
		  /* 821F402Ch */ case   33:  		/* nop */
		/* 821F402Ch case   33:*/		cpu::op::nop();
		/* 821F402Ch case   33:*/		return 0x821F4030;
	}
	return 0x821F4030;
} // Block from 821F3FA8h-821F4030h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821F4030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4030);
		  /* 821F4030h */ case    0:  		/* mfspr R12, LR */
		/* 821F4030h case    0:*/		regs.R12 = regs.LR;
		/* 821F4030h case    0:*/		return 0x821F4034;
		  /* 821F4034h */ case    1:  		/* bl -1453532 */
		/* 821F4034h case    1:*/		regs.LR = 0x821F4038; return 0x82091258;
		/* 821F4034h case    1:*/		return 0x821F4038;
		  /* 821F4038h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F4038h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F4038h case    2:*/		return 0x821F403C;
		  /* 821F403Ch */ case    3:  		/* mr R29, R5 */
		/* 821F403Ch case    3:*/		regs.R29 = regs.R5;
		/* 821F403Ch case    3:*/		return 0x821F4040;
		  /* 821F4040h */ case    4:  		/* li R8, 4 */
		/* 821F4040h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F4040h case    4:*/		return 0x821F4044;
		  /* 821F4044h */ case    5:  		/* li R7, 2 */
		/* 821F4044h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F4044h case    5:*/		return 0x821F4048;
		  /* 821F4048h */ case    6:  		/* li R6, 2 */
		/* 821F4048h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F4048h case    6:*/		return 0x821F404C;
		  /* 821F404Ch */ case    7:  		/* li R5, 0 */
		/* 821F404Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F404Ch case    7:*/		return 0x821F4050;
		  /* 821F4050h */ case    8:  		/* mr R30, R4 */
		/* 821F4050h case    8:*/		regs.R30 = regs.R4;
		/* 821F4050h case    8:*/		return 0x821F4054;
		  /* 821F4054h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F4054h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F4054h case    9:*/		return 0x821F4058;
		  /* 821F4058h */ case   10:  		/* mr R31, R3 */
		/* 821F4058h case   10:*/		regs.R31 = regs.R3;
		/* 821F4058h case   10:*/		return 0x821F405C;
		  /* 821F405Ch */ case   11:  		/* bl 198972 */
		/* 821F405Ch case   11:*/		regs.LR = 0x821F4060; return 0x82224998;
		/* 821F405Ch case   11:*/		return 0x821F4060;
		  /* 821F4060h */ case   12:  		/* mr R28, R3 */
		/* 821F4060h case   12:*/		regs.R28 = regs.R3;
		/* 821F4060h case   12:*/		return 0x821F4064;
		  /* 821F4064h */ case   13:  		/* mr R4, R30 */
		/* 821F4064h case   13:*/		regs.R4 = regs.R30;
		/* 821F4064h case   13:*/		return 0x821F4068;
		  /* 821F4068h */ case   14:  		/* mr R3, R31 */
		/* 821F4068h case   14:*/		regs.R3 = regs.R31;
		/* 821F4068h case   14:*/		return 0x821F406C;
		  /* 821F406Ch */ case   15:  		/* bl -508012 */
		/* 821F406Ch case   15:*/		regs.LR = 0x821F4070; return 0x82178000;
		/* 821F406Ch case   15:*/		return 0x821F4070;
		  /* 821F4070h */ case   16:  		/* mr R4, R3 */
		/* 821F4070h case   16:*/		regs.R4 = regs.R3;
		/* 821F4070h case   16:*/		return 0x821F4074;
		  /* 821F4074h */ case   17:  		/* mr R3, R28 */
		/* 821F4074h case   17:*/		regs.R3 = regs.R28;
		/* 821F4074h case   17:*/		return 0x821F4078;
	}
	return 0x821F4078;
} // Block from 821F4030h-821F4078h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F4078h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4078);
		  /* 821F4078h */ case    0:  		/* bl -507568 */
		/* 821F4078h case    0:*/		regs.LR = 0x821F407C; return 0x821781C8;
		/* 821F4078h case    0:*/		return 0x821F407C;
		  /* 821F407Ch */ case    1:  		/* stw R3, <#[R28 + 44]> */
		/* 821F407Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F407Ch case    1:*/		return 0x821F4080;
		  /* 821F4080h */ case    2:  		/* mr R4, R29 */
		/* 821F4080h case    2:*/		regs.R4 = regs.R29;
		/* 821F4080h case    2:*/		return 0x821F4084;
		  /* 821F4084h */ case    3:  		/* mr R3, R31 */
		/* 821F4084h case    3:*/		regs.R3 = regs.R31;
		/* 821F4084h case    3:*/		return 0x821F4088;
		  /* 821F4088h */ case    4:  		/* bl -7432 */
		/* 821F4088h case    4:*/		regs.LR = 0x821F408C; return 0x821F2380;
		/* 821F4088h case    4:*/		return 0x821F408C;
		  /* 821F408Ch */ case    5:  		/* mr R4, R3 */
		/* 821F408Ch case    5:*/		regs.R4 = regs.R3;
		/* 821F408Ch case    5:*/		return 0x821F4090;
		  /* 821F4090h */ case    6:  		/* mr R3, R28 */
		/* 821F4090h case    6:*/		regs.R3 = regs.R28;
		/* 821F4090h case    6:*/		return 0x821F4094;
		  /* 821F4094h */ case    7:  		/* bl -507596 */
		/* 821F4094h case    7:*/		regs.LR = 0x821F4098; return 0x821781C8;
		/* 821F4094h case    7:*/		return 0x821F4098;
		  /* 821F4098h */ case    8:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F4098h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F4098h case    8:*/		return 0x821F409C;
		  /* 821F409Ch */ case    9:  		/* stw R3, <#[R28 + 48]> */
		/* 821F409Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F409Ch case    9:*/		return 0x821F40A0;
		  /* 821F40A0h */ case   10:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F40A0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F40A0h case   10:*/		return 0x821F40A4;
		  /* 821F40A4h */ case   11:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F40A4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F40A4h case   11:*/		return 0x821F40A8;
		  /* 821F40A8h */ case   12:  		/* mr R3, R28 */
		/* 821F40A8h case   12:*/		regs.R3 = regs.R28;
		/* 821F40A8h case   12:*/		return 0x821F40AC;
		  /* 821F40ACh */ case   13:  		/* addi R11, R11, 36 */
		/* 821F40ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F40ACh case   13:*/		return 0x821F40B0;
		  /* 821F40B0h */ case   14:  		/* lwz R10, <#[R10]> */
		/* 821F40B0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F40B0h case   14:*/		return 0x821F40B4;
		  /* 821F40B4h */ case   15:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F40B4h case   15:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F40B4h case   15:*/		return 0x821F40B8;
		  /* 821F40B8h */ case   16:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F40B8h case   16:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F40B8h case   16:*/		return 0x821F40BC;
		  /* 821F40BCh */ case   17:  		/* addi R8, R11, -36 */
		/* 821F40BCh case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F40BCh case   17:*/		return 0x821F40C0;
		  /* 821F40C0h */ case   18:  		/* stw R9, <#[R28 + 8]> */
		/* 821F40C0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F40C0h case   18:*/		return 0x821F40C4;
		  /* 821F40C4h */ case   19:  		/* addi R9, R11, 4 */
		/* 821F40C4h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F40C4h case   19:*/		return 0x821F40C8;
		  /* 821F40C8h */ case   20:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F40C8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F40C8h case   20:*/		return 0x821F40CC;
		  /* 821F40CCh */ case   21:  		/* addi R10, R10, 24 */
		/* 821F40CCh case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F40CCh case   21:*/		return 0x821F40D0;
		  /* 821F40D0h */ case   22:  		/* lwz R7, <#[R10]> */
		/* 821F40D0h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F40D0h case   22:*/		return 0x821F40D4;
		  /* 821F40D4h */ case   23:  		/* addi R6, R10, -36 */
		/* 821F40D4h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F40D4h case   23:*/		return 0x821F40D8;
		  /* 821F40D8h */ case   24:  		/* stw R7, <#[R11]> */
		/* 821F40D8h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F40D8h case   24:*/		return 0x821F40DC;
		  /* 821F40DCh */ case   25:  		/* lwz R7, <#[R10]> */
		/* 821F40DCh case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F40DCh case   25:*/		return 0x821F40E0;
		  /* 821F40E0h */ case   26:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F40E0h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F40E0h case   26:*/		return 0x821F40E4;
		  /* 821F40E4h */ case   27:  		/* ori R6, R6, 1 */
		/* 821F40E4h case   27:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F40E4h case   27:*/		return 0x821F40E8;
		  /* 821F40E8h */ case   28:  		/* stw R8, <#[R7]> */
		/* 821F40E8h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F40E8h case   28:*/		return 0x821F40EC;
		  /* 821F40ECh */ case   29:  		/* stw R6, <#[R11 + 4]> */
		/* 821F40ECh case   29:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F40ECh case   29:*/		return 0x821F40F0;
		  /* 821F40F0h */ case   30:  		/* stw R9, <#[R10]> */
		/* 821F40F0h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F40F0h case   30:*/		return 0x821F40F4;
		  /* 821F40F4h */ case   31:  		/* addi R1, R1, 128 */
		/* 821F40F4h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F40F4h case   31:*/		return 0x821F40F8;
		  /* 821F40F8h */ case   32:  		/* b -1453648 */
		/* 821F40F8h case   32:*/		return 0x820912A8;
		/* 821F40F8h case   32:*/		return 0x821F40FC;
		  /* 821F40FCh */ case   33:  		/* nop */
		/* 821F40FCh case   33:*/		cpu::op::nop();
		/* 821F40FCh case   33:*/		return 0x821F4100;
	}
	return 0x821F4100;
} // Block from 821F4078h-821F4100h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821F4100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4100);
		  /* 821F4100h */ case    0:  		/* mfspr R12, LR */
		/* 821F4100h case    0:*/		regs.R12 = regs.LR;
		/* 821F4100h case    0:*/		return 0x821F4104;
		  /* 821F4104h */ case    1:  		/* bl -1453740 */
		/* 821F4104h case    1:*/		regs.LR = 0x821F4108; return 0x82091258;
		/* 821F4104h case    1:*/		return 0x821F4108;
		  /* 821F4108h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F4108h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F4108h case    2:*/		return 0x821F410C;
		  /* 821F410Ch */ case    3:  		/* mr R29, R5 */
		/* 821F410Ch case    3:*/		regs.R29 = regs.R5;
		/* 821F410Ch case    3:*/		return 0x821F4110;
		  /* 821F4110h */ case    4:  		/* li R8, 4 */
		/* 821F4110h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F4110h case    4:*/		return 0x821F4114;
		  /* 821F4114h */ case    5:  		/* li R7, 2 */
		/* 821F4114h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F4114h case    5:*/		return 0x821F4118;
		  /* 821F4118h */ case    6:  		/* li R6, 2 */
		/* 821F4118h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 821F4118h case    6:*/		return 0x821F411C;
		  /* 821F411Ch */ case    7:  		/* li R5, 0 */
		/* 821F411Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F411Ch case    7:*/		return 0x821F4120;
		  /* 821F4120h */ case    8:  		/* mr R30, R4 */
		/* 821F4120h case    8:*/		regs.R30 = regs.R4;
		/* 821F4120h case    8:*/		return 0x821F4124;
		  /* 821F4124h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F4124h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F4124h case    9:*/		return 0x821F4128;
		  /* 821F4128h */ case   10:  		/* mr R31, R3 */
		/* 821F4128h case   10:*/		regs.R31 = regs.R3;
		/* 821F4128h case   10:*/		return 0x821F412C;
		  /* 821F412Ch */ case   11:  		/* bl 198764 */
		/* 821F412Ch case   11:*/		regs.LR = 0x821F4130; return 0x82224998;
		/* 821F412Ch case   11:*/		return 0x821F4130;
		  /* 821F4130h */ case   12:  		/* mr R28, R3 */
		/* 821F4130h case   12:*/		regs.R28 = regs.R3;
		/* 821F4130h case   12:*/		return 0x821F4134;
		  /* 821F4134h */ case   13:  		/* mr R4, R30 */
		/* 821F4134h case   13:*/		regs.R4 = regs.R30;
		/* 821F4134h case   13:*/		return 0x821F4138;
		  /* 821F4138h */ case   14:  		/* mr R3, R31 */
		/* 821F4138h case   14:*/		regs.R3 = regs.R31;
		/* 821F4138h case   14:*/		return 0x821F413C;
		  /* 821F413Ch */ case   15:  		/* bl -7612 */
		/* 821F413Ch case   15:*/		regs.LR = 0x821F4140; return 0x821F2380;
		/* 821F413Ch case   15:*/		return 0x821F4140;
		  /* 821F4140h */ case   16:  		/* mr R4, R3 */
		/* 821F4140h case   16:*/		regs.R4 = regs.R3;
		/* 821F4140h case   16:*/		return 0x821F4144;
		  /* 821F4144h */ case   17:  		/* mr R3, R28 */
		/* 821F4144h case   17:*/		regs.R3 = regs.R28;
		/* 821F4144h case   17:*/		return 0x821F4148;
		  /* 821F4148h */ case   18:  		/* bl -507776 */
		/* 821F4148h case   18:*/		regs.LR = 0x821F414C; return 0x821781C8;
		/* 821F4148h case   18:*/		return 0x821F414C;
		  /* 821F414Ch */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 821F414Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F414Ch case   19:*/		return 0x821F4150;
		  /* 821F4150h */ case   20:  		/* mr R4, R29 */
		/* 821F4150h case   20:*/		regs.R4 = regs.R29;
		/* 821F4150h case   20:*/		return 0x821F4154;
		  /* 821F4154h */ case   21:  		/* mr R3, R31 */
		/* 821F4154h case   21:*/		regs.R3 = regs.R31;
		/* 821F4154h case   21:*/		return 0x821F4158;
	}
	return 0x821F4158;
} // Block from 821F4100h-821F4158h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F4158h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4158);
		  /* 821F4158h */ case    0:  		/* bl -7640 */
		/* 821F4158h case    0:*/		regs.LR = 0x821F415C; return 0x821F2380;
		/* 821F4158h case    0:*/		return 0x821F415C;
		  /* 821F415Ch */ case    1:  		/* mr R4, R3 */
		/* 821F415Ch case    1:*/		regs.R4 = regs.R3;
		/* 821F415Ch case    1:*/		return 0x821F4160;
		  /* 821F4160h */ case    2:  		/* mr R3, R28 */
		/* 821F4160h case    2:*/		regs.R3 = regs.R28;
		/* 821F4160h case    2:*/		return 0x821F4164;
		  /* 821F4164h */ case    3:  		/* bl -507804 */
		/* 821F4164h case    3:*/		regs.LR = 0x821F4168; return 0x821781C8;
		/* 821F4164h case    3:*/		return 0x821F4168;
		  /* 821F4168h */ case    4:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F4168h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F4168h case    4:*/		return 0x821F416C;
		  /* 821F416Ch */ case    5:  		/* stw R3, <#[R28 + 48]> */
		/* 821F416Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F416Ch case    5:*/		return 0x821F4170;
		  /* 821F4170h */ case    6:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F4170h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F4170h case    6:*/		return 0x821F4174;
		  /* 821F4174h */ case    7:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F4174h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4174h case    7:*/		return 0x821F4178;
		  /* 821F4178h */ case    8:  		/* mr R3, R28 */
		/* 821F4178h case    8:*/		regs.R3 = regs.R28;
		/* 821F4178h case    8:*/		return 0x821F417C;
		  /* 821F417Ch */ case    9:  		/* addi R11, R11, 36 */
		/* 821F417Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F417Ch case    9:*/		return 0x821F4180;
		  /* 821F4180h */ case   10:  		/* lwz R10, <#[R10]> */
		/* 821F4180h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4180h case   10:*/		return 0x821F4184;
		  /* 821F4184h */ case   11:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F4184h case   11:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F4184h case   11:*/		return 0x821F4188;
		  /* 821F4188h */ case   12:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F4188h case   12:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F4188h case   12:*/		return 0x821F418C;
		  /* 821F418Ch */ case   13:  		/* addi R8, R11, -36 */
		/* 821F418Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F418Ch case   13:*/		return 0x821F4190;
		  /* 821F4190h */ case   14:  		/* stw R9, <#[R28 + 8]> */
		/* 821F4190h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4190h case   14:*/		return 0x821F4194;
		  /* 821F4194h */ case   15:  		/* addi R9, R11, 4 */
		/* 821F4194h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F4194h case   15:*/		return 0x821F4198;
		  /* 821F4198h */ case   16:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F4198h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4198h case   16:*/		return 0x821F419C;
		  /* 821F419Ch */ case   17:  		/* addi R10, R10, 24 */
		/* 821F419Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F419Ch case   17:*/		return 0x821F41A0;
		  /* 821F41A0h */ case   18:  		/* lwz R7, <#[R10]> */
		/* 821F41A0h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F41A0h case   18:*/		return 0x821F41A4;
		  /* 821F41A4h */ case   19:  		/* addi R6, R10, -36 */
		/* 821F41A4h case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F41A4h case   19:*/		return 0x821F41A8;
		  /* 821F41A8h */ case   20:  		/* stw R7, <#[R11]> */
		/* 821F41A8h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F41A8h case   20:*/		return 0x821F41AC;
		  /* 821F41ACh */ case   21:  		/* lwz R7, <#[R10]> */
		/* 821F41ACh case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F41ACh case   21:*/		return 0x821F41B0;
		  /* 821F41B0h */ case   22:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F41B0h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F41B0h case   22:*/		return 0x821F41B4;
		  /* 821F41B4h */ case   23:  		/* ori R6, R6, 1 */
		/* 821F41B4h case   23:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F41B4h case   23:*/		return 0x821F41B8;
		  /* 821F41B8h */ case   24:  		/* stw R8, <#[R7]> */
		/* 821F41B8h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F41B8h case   24:*/		return 0x821F41BC;
		  /* 821F41BCh */ case   25:  		/* stw R6, <#[R11 + 4]> */
		/* 821F41BCh case   25:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F41BCh case   25:*/		return 0x821F41C0;
		  /* 821F41C0h */ case   26:  		/* stw R9, <#[R10]> */
		/* 821F41C0h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F41C0h case   26:*/		return 0x821F41C4;
		  /* 821F41C4h */ case   27:  		/* addi R1, R1, 128 */
		/* 821F41C4h case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F41C4h case   27:*/		return 0x821F41C8;
		  /* 821F41C8h */ case   28:  		/* b -1453856 */
		/* 821F41C8h case   28:*/		return 0x820912A8;
		/* 821F41C8h case   28:*/		return 0x821F41CC;
		  /* 821F41CCh */ case   29:  		/* nop */
		/* 821F41CCh case   29:*/		cpu::op::nop();
		/* 821F41CCh case   29:*/		return 0x821F41D0;
	}
	return 0x821F41D0;
} // Block from 821F4158h-821F41D0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821F41D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F41D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F41D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F41D0);
		  /* 821F41D0h */ case    0:  		/* mfspr R12, LR */
		/* 821F41D0h case    0:*/		regs.R12 = regs.LR;
		/* 821F41D0h case    0:*/		return 0x821F41D4;
		  /* 821F41D4h */ case    1:  		/* bl -1453948 */
		/* 821F41D4h case    1:*/		regs.LR = 0x821F41D8; return 0x82091258;
		/* 821F41D4h case    1:*/		return 0x821F41D8;
		  /* 821F41D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F41D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F41D8h case    2:*/		return 0x821F41DC;
		  /* 821F41DCh */ case    3:  		/* mr R29, R5 */
		/* 821F41DCh case    3:*/		regs.R29 = regs.R5;
		/* 821F41DCh case    3:*/		return 0x821F41E0;
		  /* 821F41E0h */ case    4:  		/* li R8, 4 */
		/* 821F41E0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F41E0h case    4:*/		return 0x821F41E4;
		  /* 821F41E4h */ case    5:  		/* li R7, 2 */
		/* 821F41E4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F41E4h case    5:*/		return 0x821F41E8;
		  /* 821F41E8h */ case    6:  		/* li R6, 3 */
		/* 821F41E8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821F41E8h case    6:*/		return 0x821F41EC;
		  /* 821F41ECh */ case    7:  		/* li R5, 0 */
		/* 821F41ECh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F41ECh case    7:*/		return 0x821F41F0;
		  /* 821F41F0h */ case    8:  		/* mr R30, R4 */
		/* 821F41F0h case    8:*/		regs.R30 = regs.R4;
		/* 821F41F0h case    8:*/		return 0x821F41F4;
		  /* 821F41F4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F41F4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F41F4h case    9:*/		return 0x821F41F8;
		  /* 821F41F8h */ case   10:  		/* mr R31, R3 */
		/* 821F41F8h case   10:*/		regs.R31 = regs.R3;
		/* 821F41F8h case   10:*/		return 0x821F41FC;
		  /* 821F41FCh */ case   11:  		/* bl 198556 */
		/* 821F41FCh case   11:*/		regs.LR = 0x821F4200; return 0x82224998;
		/* 821F41FCh case   11:*/		return 0x821F4200;
		  /* 821F4200h */ case   12:  		/* mr R28, R3 */
		/* 821F4200h case   12:*/		regs.R28 = regs.R3;
		/* 821F4200h case   12:*/		return 0x821F4204;
		  /* 821F4204h */ case   13:  		/* mr R4, R30 */
		/* 821F4204h case   13:*/		regs.R4 = regs.R30;
		/* 821F4204h case   13:*/		return 0x821F4208;
		  /* 821F4208h */ case   14:  		/* mr R3, R31 */
		/* 821F4208h case   14:*/		regs.R3 = regs.R31;
		/* 821F4208h case   14:*/		return 0x821F420C;
		  /* 821F420Ch */ case   15:  		/* bl -7820 */
		/* 821F420Ch case   15:*/		regs.LR = 0x821F4210; return 0x821F2380;
		/* 821F420Ch case   15:*/		return 0x821F4210;
		  /* 821F4210h */ case   16:  		/* mr R4, R3 */
		/* 821F4210h case   16:*/		regs.R4 = regs.R3;
		/* 821F4210h case   16:*/		return 0x821F4214;
		  /* 821F4214h */ case   17:  		/* mr R3, R28 */
		/* 821F4214h case   17:*/		regs.R3 = regs.R28;
		/* 821F4214h case   17:*/		return 0x821F4218;
		  /* 821F4218h */ case   18:  		/* bl -507984 */
		/* 821F4218h case   18:*/		regs.LR = 0x821F421C; return 0x821781C8;
		/* 821F4218h case   18:*/		return 0x821F421C;
		  /* 821F421Ch */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 821F421Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F421Ch case   19:*/		return 0x821F4220;
		  /* 821F4220h */ case   20:  		/* mr R4, R29 */
		/* 821F4220h case   20:*/		regs.R4 = regs.R29;
		/* 821F4220h case   20:*/		return 0x821F4224;
		  /* 821F4224h */ case   21:  		/* mr R3, R31 */
		/* 821F4224h case   21:*/		regs.R3 = regs.R31;
		/* 821F4224h case   21:*/		return 0x821F4228;
		  /* 821F4228h */ case   22:  		/* bl -7848 */
		/* 821F4228h case   22:*/		regs.LR = 0x821F422C; return 0x821F2380;
		/* 821F4228h case   22:*/		return 0x821F422C;
		  /* 821F422Ch */ case   23:  		/* mr R4, R3 */
		/* 821F422Ch case   23:*/		regs.R4 = regs.R3;
		/* 821F422Ch case   23:*/		return 0x821F4230;
		  /* 821F4230h */ case   24:  		/* mr R3, R28 */
		/* 821F4230h case   24:*/		regs.R3 = regs.R28;
		/* 821F4230h case   24:*/		return 0x821F4234;
		  /* 821F4234h */ case   25:  		/* bl -508012 */
		/* 821F4234h case   25:*/		regs.LR = 0x821F4238; return 0x821781C8;
		/* 821F4234h case   25:*/		return 0x821F4238;
	}
	return 0x821F4238;
} // Block from 821F41D0h-821F4238h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821F4238h
// Function '?MakeInstr_V_SETE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4238);
		  /* 821F4238h */ case    0:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F4238h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F4238h case    0:*/		return 0x821F423C;
		  /* 821F423Ch */ case    1:  		/* stw R3, <#[R28 + 48]> */
		/* 821F423Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F423Ch case    1:*/		return 0x821F4240;
		  /* 821F4240h */ case    2:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F4240h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F4240h case    2:*/		return 0x821F4244;
		  /* 821F4244h */ case    3:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F4244h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4244h case    3:*/		return 0x821F4248;
		  /* 821F4248h */ case    4:  		/* mr R3, R28 */
		/* 821F4248h case    4:*/		regs.R3 = regs.R28;
		/* 821F4248h case    4:*/		return 0x821F424C;
		  /* 821F424Ch */ case    5:  		/* addi R11, R11, 36 */
		/* 821F424Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F424Ch case    5:*/		return 0x821F4250;
		  /* 821F4250h */ case    6:  		/* lwz R10, <#[R10]> */
		/* 821F4250h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4250h case    6:*/		return 0x821F4254;
		  /* 821F4254h */ case    7:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F4254h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F4254h case    7:*/		return 0x821F4258;
		  /* 821F4258h */ case    8:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F4258h case    8:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F4258h case    8:*/		return 0x821F425C;
		  /* 821F425Ch */ case    9:  		/* addi R8, R11, -36 */
		/* 821F425Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F425Ch case    9:*/		return 0x821F4260;
		  /* 821F4260h */ case   10:  		/* stw R9, <#[R28 + 8]> */
		/* 821F4260h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4260h case   10:*/		return 0x821F4264;
		  /* 821F4264h */ case   11:  		/* addi R9, R11, 4 */
		/* 821F4264h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F4264h case   11:*/		return 0x821F4268;
		  /* 821F4268h */ case   12:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F4268h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4268h case   12:*/		return 0x821F426C;
		  /* 821F426Ch */ case   13:  		/* addi R10, R10, 24 */
		/* 821F426Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F426Ch case   13:*/		return 0x821F4270;
		  /* 821F4270h */ case   14:  		/* lwz R7, <#[R10]> */
		/* 821F4270h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4270h case   14:*/		return 0x821F4274;
		  /* 821F4274h */ case   15:  		/* addi R6, R10, -36 */
		/* 821F4274h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F4274h case   15:*/		return 0x821F4278;
		  /* 821F4278h */ case   16:  		/* stw R7, <#[R11]> */
		/* 821F4278h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4278h case   16:*/		return 0x821F427C;
		  /* 821F427Ch */ case   17:  		/* lwz R7, <#[R10]> */
		/* 821F427Ch case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F427Ch case   17:*/		return 0x821F4280;
		  /* 821F4280h */ case   18:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F4280h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F4280h case   18:*/		return 0x821F4284;
		  /* 821F4284h */ case   19:  		/* ori R6, R6, 1 */
		/* 821F4284h case   19:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F4284h case   19:*/		return 0x821F4288;
		  /* 821F4288h */ case   20:  		/* stw R8, <#[R7]> */
		/* 821F4288h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F4288h case   20:*/		return 0x821F428C;
		  /* 821F428Ch */ case   21:  		/* stw R6, <#[R11 + 4]> */
		/* 821F428Ch case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F428Ch case   21:*/		return 0x821F4290;
		  /* 821F4290h */ case   22:  		/* stw R9, <#[R10]> */
		/* 821F4290h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4290h case   22:*/		return 0x821F4294;
		  /* 821F4294h */ case   23:  		/* addi R1, R1, 128 */
		/* 821F4294h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F4294h case   23:*/		return 0x821F4298;
		  /* 821F4298h */ case   24:  		/* b -1454064 */
		/* 821F4298h case   24:*/		return 0x820912A8;
		/* 821F4298h case   24:*/		return 0x821F429C;
		  /* 821F429Ch */ case   25:  		/* nop */
		/* 821F429Ch case   25:*/		cpu::op::nop();
		/* 821F429Ch case   25:*/		return 0x821F42A0;
	}
	return 0x821F42A0;
} // Block from 821F4238h-821F42A0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821F42A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F42A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F42A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F42A0);
		  /* 821F42A0h */ case    0:  		/* mfspr R12, LR */
		/* 821F42A0h case    0:*/		regs.R12 = regs.LR;
		/* 821F42A0h case    0:*/		return 0x821F42A4;
		  /* 821F42A4h */ case    1:  		/* bl -1454156 */
		/* 821F42A4h case    1:*/		regs.LR = 0x821F42A8; return 0x82091258;
		/* 821F42A4h case    1:*/		return 0x821F42A8;
		  /* 821F42A8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821F42A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821F42A8h case    2:*/		return 0x821F42AC;
		  /* 821F42ACh */ case    3:  		/* mr R29, R5 */
		/* 821F42ACh case    3:*/		regs.R29 = regs.R5;
		/* 821F42ACh case    3:*/		return 0x821F42B0;
		  /* 821F42B0h */ case    4:  		/* li R8, 4 */
		/* 821F42B0h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F42B0h case    4:*/		return 0x821F42B4;
		  /* 821F42B4h */ case    5:  		/* li R7, 2 */
		/* 821F42B4h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F42B4h case    5:*/		return 0x821F42B8;
		  /* 821F42B8h */ case    6:  		/* li R6, 4 */
		/* 821F42B8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 821F42B8h case    6:*/		return 0x821F42BC;
		  /* 821F42BCh */ case    7:  		/* li R5, 0 */
		/* 821F42BCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F42BCh case    7:*/		return 0x821F42C0;
		  /* 821F42C0h */ case    8:  		/* mr R30, R4 */
		/* 821F42C0h case    8:*/		regs.R30 = regs.R4;
		/* 821F42C0h case    8:*/		return 0x821F42C4;
		  /* 821F42C4h */ case    9:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F42C4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F42C4h case    9:*/		return 0x821F42C8;
		  /* 821F42C8h */ case   10:  		/* mr R31, R3 */
		/* 821F42C8h case   10:*/		regs.R31 = regs.R3;
		/* 821F42C8h case   10:*/		return 0x821F42CC;
		  /* 821F42CCh */ case   11:  		/* bl 198348 */
		/* 821F42CCh case   11:*/		regs.LR = 0x821F42D0; return 0x82224998;
		/* 821F42CCh case   11:*/		return 0x821F42D0;
		  /* 821F42D0h */ case   12:  		/* mr R28, R3 */
		/* 821F42D0h case   12:*/		regs.R28 = regs.R3;
		/* 821F42D0h case   12:*/		return 0x821F42D4;
		  /* 821F42D4h */ case   13:  		/* mr R4, R30 */
		/* 821F42D4h case   13:*/		regs.R4 = regs.R30;
		/* 821F42D4h case   13:*/		return 0x821F42D8;
		  /* 821F42D8h */ case   14:  		/* mr R3, R31 */
		/* 821F42D8h case   14:*/		regs.R3 = regs.R31;
		/* 821F42D8h case   14:*/		return 0x821F42DC;
		  /* 821F42DCh */ case   15:  		/* bl -8028 */
		/* 821F42DCh case   15:*/		regs.LR = 0x821F42E0; return 0x821F2380;
		/* 821F42DCh case   15:*/		return 0x821F42E0;
		  /* 821F42E0h */ case   16:  		/* mr R4, R3 */
		/* 821F42E0h case   16:*/		regs.R4 = regs.R3;
		/* 821F42E0h case   16:*/		return 0x821F42E4;
		  /* 821F42E4h */ case   17:  		/* mr R3, R28 */
		/* 821F42E4h case   17:*/		regs.R3 = regs.R28;
		/* 821F42E4h case   17:*/		return 0x821F42E8;
		  /* 821F42E8h */ case   18:  		/* bl -508192 */
		/* 821F42E8h case   18:*/		regs.LR = 0x821F42EC; return 0x821781C8;
		/* 821F42E8h case   18:*/		return 0x821F42EC;
		  /* 821F42ECh */ case   19:  		/* stw R3, <#[R28 + 44]> */
		/* 821F42ECh case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F42ECh case   19:*/		return 0x821F42F0;
		  /* 821F42F0h */ case   20:  		/* mr R4, R29 */
		/* 821F42F0h case   20:*/		regs.R4 = regs.R29;
		/* 821F42F0h case   20:*/		return 0x821F42F4;
		  /* 821F42F4h */ case   21:  		/* mr R3, R31 */
		/* 821F42F4h case   21:*/		regs.R3 = regs.R31;
		/* 821F42F4h case   21:*/		return 0x821F42F8;
		  /* 821F42F8h */ case   22:  		/* bl -8056 */
		/* 821F42F8h case   22:*/		regs.LR = 0x821F42FC; return 0x821F2380;
		/* 821F42F8h case   22:*/		return 0x821F42FC;
		  /* 821F42FCh */ case   23:  		/* mr R4, R3 */
		/* 821F42FCh case   23:*/		regs.R4 = regs.R3;
		/* 821F42FCh case   23:*/		return 0x821F4300;
		  /* 821F4300h */ case   24:  		/* mr R3, R28 */
		/* 821F4300h case   24:*/		regs.R3 = regs.R28;
		/* 821F4300h case   24:*/		return 0x821F4304;
		  /* 821F4304h */ case   25:  		/* bl -508220 */
		/* 821F4304h case   25:*/		regs.LR = 0x821F4308; return 0x821781C8;
		/* 821F4304h case   25:*/		return 0x821F4308;
		  /* 821F4308h */ case   26:  		/* lwz R10, <#[R28 + 44]> */
		/* 821F4308h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F4308h case   26:*/		return 0x821F430C;
		  /* 821F430Ch */ case   27:  		/* stw R3, <#[R28 + 48]> */
		/* 821F430Ch case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F430Ch case   27:*/		return 0x821F4310;
		  /* 821F4310h */ case   28:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821F4310h case   28:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821F4310h case   28:*/		return 0x821F4314;
		  /* 821F4314h */ case   29:  		/* lwz R9, <#[R28 + 8]> */
		/* 821F4314h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4314h case   29:*/		return 0x821F4318;
	}
	return 0x821F4318;
} // Block from 821F42A0h-821F4318h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821F4318h
// Function '?MakeInstr_V_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4318);
		  /* 821F4318h */ case    0:  		/* mr R3, R28 */
		/* 821F4318h case    0:*/		regs.R3 = regs.R28;
		/* 821F4318h case    0:*/		return 0x821F431C;
		  /* 821F431Ch */ case    1:  		/* addi R11, R11, 36 */
		/* 821F431Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F431Ch case    1:*/		return 0x821F4320;
		  /* 821F4320h */ case    2:  		/* lwz R10, <#[R10]> */
		/* 821F4320h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4320h case    2:*/		return 0x821F4324;
		  /* 821F4324h */ case    3:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F4324h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F4324h case    3:*/		return 0x821F4328;
		  /* 821F4328h */ case    4:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F4328h case    4:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F4328h case    4:*/		return 0x821F432C;
		  /* 821F432Ch */ case    5:  		/* addi R8, R11, -36 */
		/* 821F432Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F432Ch case    5:*/		return 0x821F4330;
		  /* 821F4330h */ case    6:  		/* stw R9, <#[R28 + 8]> */
		/* 821F4330h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4330h case    6:*/		return 0x821F4334;
		  /* 821F4334h */ case    7:  		/* addi R9, R11, 4 */
		/* 821F4334h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F4334h case    7:*/		return 0x821F4338;
		  /* 821F4338h */ case    8:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F4338h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4338h case    8:*/		return 0x821F433C;
		  /* 821F433Ch */ case    9:  		/* addi R10, R10, 24 */
		/* 821F433Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F433Ch case    9:*/		return 0x821F4340;
		  /* 821F4340h */ case   10:  		/* lwz R7, <#[R10]> */
		/* 821F4340h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4340h case   10:*/		return 0x821F4344;
		  /* 821F4344h */ case   11:  		/* addi R6, R10, -36 */
		/* 821F4344h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F4344h case   11:*/		return 0x821F4348;
		  /* 821F4348h */ case   12:  		/* stw R7, <#[R11]> */
		/* 821F4348h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4348h case   12:*/		return 0x821F434C;
		  /* 821F434Ch */ case   13:  		/* lwz R7, <#[R10]> */
		/* 821F434Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F434Ch case   13:*/		return 0x821F4350;
		  /* 821F4350h */ case   14:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F4350h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F4350h case   14:*/		return 0x821F4354;
		  /* 821F4354h */ case   15:  		/* ori R6, R6, 1 */
		/* 821F4354h case   15:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F4354h case   15:*/		return 0x821F4358;
		  /* 821F4358h */ case   16:  		/* stw R8, <#[R7]> */
		/* 821F4358h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F4358h case   16:*/		return 0x821F435C;
		  /* 821F435Ch */ case   17:  		/* stw R6, <#[R11 + 4]> */
		/* 821F435Ch case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F435Ch case   17:*/		return 0x821F4360;
		  /* 821F4360h */ case   18:  		/* stw R9, <#[R10]> */
		/* 821F4360h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4360h case   18:*/		return 0x821F4364;
		  /* 821F4364h */ case   19:  		/* addi R1, R1, 128 */
		/* 821F4364h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821F4364h case   19:*/		return 0x821F4368;
		  /* 821F4368h */ case   20:  		/* b -1454272 */
		/* 821F4368h case   20:*/		return 0x820912A8;
		/* 821F4368h case   20:*/		return 0x821F436C;
		  /* 821F436Ch */ case   21:  		/* nop */
		/* 821F436Ch case   21:*/		cpu::op::nop();
		/* 821F436Ch case   21:*/		return 0x821F4370;
	}
	return 0x821F4370;
} // Block from 821F4318h-821F4370h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F4370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4370);
		  /* 821F4370h */ case    0:  		/* mfspr R12, LR */
		/* 821F4370h case    0:*/		regs.R12 = regs.LR;
		/* 821F4370h case    0:*/		return 0x821F4374;
		  /* 821F4374h */ case    1:  		/* bl -1454360 */
		/* 821F4374h case    1:*/		regs.LR = 0x821F4378; return 0x8209125C;
		/* 821F4374h case    1:*/		return 0x821F4378;
		  /* 821F4378h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F4378h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F4378h case    2:*/		return 0x821F437C;
		  /* 821F437Ch */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F437Ch case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F437Ch case    3:*/		return 0x821F4380;
		  /* 821F4380h */ case    4:  		/* li R8, 4 */
		/* 821F4380h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F4380h case    4:*/		return 0x821F4384;
		  /* 821F4384h */ case    5:  		/* std R6, <#[R1 + 152]> */
		/* 821F4384h case    5:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000098) );
		/* 821F4384h case    5:*/		return 0x821F4388;
		  /* 821F4388h */ case    6:  		/* li R7, 3 */
		/* 821F4388h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821F4388h case    6:*/		return 0x821F438C;
		  /* 821F438Ch */ case    7:  		/* li R6, 14 */
		/* 821F438Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0xE);
		/* 821F438Ch case    7:*/		return 0x821F4390;
		  /* 821F4390h */ case    8:  		/* li R5, 0 */
		/* 821F4390h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F4390h case    8:*/		return 0x821F4394;
		  /* 821F4394h */ case    9:  		/* mr R29, R4 */
		/* 821F4394h case    9:*/		regs.R29 = regs.R4;
		/* 821F4394h case    9:*/		return 0x821F4398;
		  /* 821F4398h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F4398h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F4398h case   10:*/		return 0x821F439C;
		  /* 821F439Ch */ case   11:  		/* mr R30, R3 */
		/* 821F439Ch case   11:*/		regs.R30 = regs.R3;
		/* 821F439Ch case   11:*/		return 0x821F43A0;
		  /* 821F43A0h */ case   12:  		/* bl 198136 */
		/* 821F43A0h case   12:*/		regs.LR = 0x821F43A4; return 0x82224998;
		/* 821F43A0h case   12:*/		return 0x821F43A4;
		  /* 821F43A4h */ case   13:  		/* lwz R11, <#[R29 + 16]> */
		/* 821F43A4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821F43A4h case   13:*/		return 0x821F43A8;
		  /* 821F43A8h */ case   14:  		/* mr R31, R3 */
		/* 821F43A8h case   14:*/		regs.R31 = regs.R3;
		/* 821F43A8h case   14:*/		return 0x821F43AC;
		  /* 821F43ACh */ case   15:  		/* mr R4, R29 */
		/* 821F43ACh case   15:*/		regs.R4 = regs.R29;
		/* 821F43ACh case   15:*/		return 0x821F43B0;
		  /* 821F43B0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 821F43B0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F43B0h case   16:*/		return 0x821F43B4;
		  /* 821F43B4h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 821F43B4h case   17:*/		if ( regs.CR[6].eq ) { return 0x821F43C8;  }
		/* 821F43B4h case   17:*/		return 0x821F43B8;
		  /* 821F43B8h */ case   18:  		/* mr R3, R30 */
		/* 821F43B8h case   18:*/		regs.R3 = regs.R30;
		/* 821F43B8h case   18:*/		return 0x821F43BC;
		  /* 821F43BCh */ case   19:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F43BCh case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F43BCh case   19:*/		return 0x821F43C0;
		  /* 821F43C0h */ case   20:  		/* bl -537296 */
		/* 821F43C0h case   20:*/		regs.LR = 0x821F43C4; return 0x821710F0;
		/* 821F43C0h case   20:*/		return 0x821F43C4;
		  /* 821F43C4h */ case   21:  		/* mr R4, R3 */
		/* 821F43C4h case   21:*/		regs.R4 = regs.R3;
		/* 821F43C4h case   21:*/		return 0x821F43C8;
	}
	return 0x821F43C8;
} // Block from 821F4370h-821F43C8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F43C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F43C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F43C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F43C8);
		  /* 821F43C8h */ case    0:  		/* mr R3, R31 */
		/* 821F43C8h case    0:*/		regs.R3 = regs.R31;
		/* 821F43C8h case    0:*/		return 0x821F43CC;
		  /* 821F43CCh */ case    1:  		/* bl -508420 */
		/* 821F43CCh case    1:*/		regs.LR = 0x821F43D0; return 0x821781C8;
		/* 821F43CCh case    1:*/		return 0x821F43D0;
		  /* 821F43D0h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821F43D0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F43D0h case    2:*/		return 0x821F43D4;
		  /* 821F43D4h */ case    3:  		/* addi R4, R1, 144 */
		/* 821F43D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F43D4h case    3:*/		return 0x821F43D8;
		  /* 821F43D8h */ case    4:  		/* mr R3, R30 */
		/* 821F43D8h case    4:*/		regs.R3 = regs.R30;
		/* 821F43D8h case    4:*/		return 0x821F43DC;
		  /* 821F43DCh */ case    5:  		/* bl -8284 */
		/* 821F43DCh case    5:*/		regs.LR = 0x821F43E0; return 0x821F2380;
		/* 821F43DCh case    5:*/		return 0x821F43E0;
		  /* 821F43E0h */ case    6:  		/* mr R4, R3 */
		/* 821F43E0h case    6:*/		regs.R4 = regs.R3;
		/* 821F43E0h case    6:*/		return 0x821F43E4;
		  /* 821F43E4h */ case    7:  		/* mr R3, R31 */
		/* 821F43E4h case    7:*/		regs.R3 = regs.R31;
		/* 821F43E4h case    7:*/		return 0x821F43E8;
		  /* 821F43E8h */ case    8:  		/* bl -508448 */
		/* 821F43E8h case    8:*/		regs.LR = 0x821F43EC; return 0x821781C8;
		/* 821F43E8h case    8:*/		return 0x821F43EC;
		  /* 821F43ECh */ case    9:  		/* stw R3, <#[R31 + 48]> */
		/* 821F43ECh case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821F43ECh case    9:*/		return 0x821F43F0;
		  /* 821F43F0h */ case   10:  		/* addi R4, R1, 152 */
		/* 821F43F0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 821F43F0h case   10:*/		return 0x821F43F4;
		  /* 821F43F4h */ case   11:  		/* mr R3, R30 */
		/* 821F43F4h case   11:*/		regs.R3 = regs.R30;
		/* 821F43F4h case   11:*/		return 0x821F43F8;
	}
	return 0x821F43F8;
} // Block from 821F43C8h-821F43F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F43F8h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F43F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F43F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F43F8);
		  /* 821F43F8h */ case    0:  		/* bl -8312 */
		/* 821F43F8h case    0:*/		regs.LR = 0x821F43FC; return 0x821F2380;
		/* 821F43F8h case    0:*/		return 0x821F43FC;
		  /* 821F43FCh */ case    1:  		/* mr R4, R3 */
		/* 821F43FCh case    1:*/		regs.R4 = regs.R3;
		/* 821F43FCh case    1:*/		return 0x821F4400;
		  /* 821F4400h */ case    2:  		/* mr R3, R31 */
		/* 821F4400h case    2:*/		regs.R3 = regs.R31;
		/* 821F4400h case    2:*/		return 0x821F4404;
		  /* 821F4404h */ case    3:  		/* bl -508476 */
		/* 821F4404h case    3:*/		regs.LR = 0x821F4408; return 0x821781C8;
		/* 821F4404h case    3:*/		return 0x821F4408;
		  /* 821F4408h */ case    4:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F4408h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F4408h case    4:*/		return 0x821F440C;
		  /* 821F440Ch */ case    5:  		/* stw R3, <#[R31 + 52]> */
		/* 821F440Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 821F440Ch case    5:*/		return 0x821F4410;
		  /* 821F4410h */ case    6:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821F4410h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821F4410h case    6:*/		return 0x821F4414;
		  /* 821F4414h */ case    7:  		/* lwz R9, <#[R31 + 8]> */
		/* 821F4414h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F4414h case    7:*/		return 0x821F4418;
		  /* 821F4418h */ case    8:  		/* mr R3, R31 */
		/* 821F4418h case    8:*/		regs.R3 = regs.R31;
		/* 821F4418h case    8:*/		return 0x821F441C;
		  /* 821F441Ch */ case    9:  		/* addi R11, R11, 36 */
		/* 821F441Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F441Ch case    9:*/		return 0x821F4420;
		  /* 821F4420h */ case   10:  		/* lwz R10, <#[R10]> */
		/* 821F4420h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4420h case   10:*/		return 0x821F4424;
		  /* 821F4424h */ case   11:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F4424h case   11:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F4424h case   11:*/		return 0x821F4428;
		  /* 821F4428h */ case   12:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F4428h case   12:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F4428h case   12:*/		return 0x821F442C;
		  /* 821F442Ch */ case   13:  		/* addi R8, R11, -36 */
		/* 821F442Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F442Ch case   13:*/		return 0x821F4430;
		  /* 821F4430h */ case   14:  		/* stw R9, <#[R31 + 8]> */
		/* 821F4430h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821F4430h case   14:*/		return 0x821F4434;
		  /* 821F4434h */ case   15:  		/* addi R9, R11, 4 */
		/* 821F4434h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F4434h case   15:*/		return 0x821F4438;
		  /* 821F4438h */ case   16:  		/* lwz R10, <#[R30 + 564]> */
		/* 821F4438h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000234) );
		/* 821F4438h case   16:*/		return 0x821F443C;
		  /* 821F443Ch */ case   17:  		/* addi R10, R10, 24 */
		/* 821F443Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F443Ch case   17:*/		return 0x821F4440;
		  /* 821F4440h */ case   18:  		/* lwz R7, <#[R10]> */
		/* 821F4440h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4440h case   18:*/		return 0x821F4444;
		  /* 821F4444h */ case   19:  		/* addi R6, R10, -36 */
		/* 821F4444h case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F4444h case   19:*/		return 0x821F4448;
		  /* 821F4448h */ case   20:  		/* stw R7, <#[R11]> */
		/* 821F4448h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4448h case   20:*/		return 0x821F444C;
		  /* 821F444Ch */ case   21:  		/* lwz R7, <#[R10]> */
		/* 821F444Ch case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F444Ch case   21:*/		return 0x821F4450;
		  /* 821F4450h */ case   22:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F4450h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F4450h case   22:*/		return 0x821F4454;
		  /* 821F4454h */ case   23:  		/* ori R6, R6, 1 */
		/* 821F4454h case   23:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F4454h case   23:*/		return 0x821F4458;
		  /* 821F4458h */ case   24:  		/* stw R8, <#[R7]> */
		/* 821F4458h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F4458h case   24:*/		return 0x821F445C;
		  /* 821F445Ch */ case   25:  		/* stw R6, <#[R11 + 4]> */
		/* 821F445Ch case   25:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F445Ch case   25:*/		return 0x821F4460;
		  /* 821F4460h */ case   26:  		/* stw R9, <#[R10]> */
		/* 821F4460h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4460h case   26:*/		return 0x821F4464;
		  /* 821F4464h */ case   27:  		/* addi R1, R1, 112 */
		/* 821F4464h case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F4464h case   27:*/		return 0x821F4468;
		  /* 821F4468h */ case   28:  		/* b -1454524 */
		/* 821F4468h case   28:*/		return 0x820912AC;
		/* 821F4468h case   28:*/		return 0x821F446C;
		  /* 821F446Ch */ case   29:  		/* nop */
		/* 821F446Ch case   29:*/		cpu::op::nop();
		/* 821F446Ch case   29:*/		return 0x821F4470;
	}
	return 0x821F4470;
} // Block from 821F43F8h-821F4470h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821F4470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4470);
		  /* 821F4470h */ case    0:  		/* mfspr R12, LR */
		/* 821F4470h case    0:*/		regs.R12 = regs.LR;
		/* 821F4470h case    0:*/		return 0x821F4474;
		  /* 821F4474h */ case    1:  		/* bl -1454616 */
		/* 821F4474h case    1:*/		regs.LR = 0x821F4478; return 0x8209125C;
		/* 821F4474h case    1:*/		return 0x821F4478;
		  /* 821F4478h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F4478h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F4478h case    2:*/		return 0x821F447C;
		  /* 821F447Ch */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F447Ch case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F447Ch case    3:*/		return 0x821F4480;
		  /* 821F4480h */ case    4:  		/* li R8, 4 */
		/* 821F4480h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F4480h case    4:*/		return 0x821F4484;
		  /* 821F4484h */ case    5:  		/* std R6, <#[R1 + 152]> */
		/* 821F4484h case    5:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000098) );
		/* 821F4484h case    5:*/		return 0x821F4488;
		  /* 821F4488h */ case    6:  		/* li R7, 3 */
		/* 821F4488h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821F4488h case    6:*/		return 0x821F448C;
		  /* 821F448Ch */ case    7:  		/* li R6, 13 */
		/* 821F448Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0xD);
		/* 821F448Ch case    7:*/		return 0x821F4490;
		  /* 821F4490h */ case    8:  		/* li R5, 0 */
		/* 821F4490h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F4490h case    8:*/		return 0x821F4494;
		  /* 821F4494h */ case    9:  		/* mr R30, R4 */
		/* 821F4494h case    9:*/		regs.R30 = regs.R4;
		/* 821F4494h case    9:*/		return 0x821F4498;
		  /* 821F4498h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F4498h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F4498h case   10:*/		return 0x821F449C;
		  /* 821F449Ch */ case   11:  		/* mr R31, R3 */
		/* 821F449Ch case   11:*/		regs.R31 = regs.R3;
		/* 821F449Ch case   11:*/		return 0x821F44A0;
		  /* 821F44A0h */ case   12:  		/* bl 197880 */
		/* 821F44A0h case   12:*/		regs.LR = 0x821F44A4; return 0x82224998;
		/* 821F44A0h case   12:*/		return 0x821F44A4;
		  /* 821F44A4h */ case   13:  		/* mr R29, R3 */
		/* 821F44A4h case   13:*/		regs.R29 = regs.R3;
		/* 821F44A4h case   13:*/		return 0x821F44A8;
		  /* 821F44A8h */ case   14:  		/* mr R4, R30 */
		/* 821F44A8h case   14:*/		regs.R4 = regs.R30;
		/* 821F44A8h case   14:*/		return 0x821F44AC;
		  /* 821F44ACh */ case   15:  		/* mr R3, R31 */
		/* 821F44ACh case   15:*/		regs.R3 = regs.R31;
		/* 821F44ACh case   15:*/		return 0x821F44B0;
		  /* 821F44B0h */ case   16:  		/* bl -509104 */
		/* 821F44B0h case   16:*/		regs.LR = 0x821F44B4; return 0x82178000;
		/* 821F44B0h case   16:*/		return 0x821F44B4;
		  /* 821F44B4h */ case   17:  		/* mr R4, R3 */
		/* 821F44B4h case   17:*/		regs.R4 = regs.R3;
		/* 821F44B4h case   17:*/		return 0x821F44B8;
		  /* 821F44B8h */ case   18:  		/* mr R3, R29 */
		/* 821F44B8h case   18:*/		regs.R3 = regs.R29;
		/* 821F44B8h case   18:*/		return 0x821F44BC;
		  /* 821F44BCh */ case   19:  		/* bl -508660 */
		/* 821F44BCh case   19:*/		regs.LR = 0x821F44C0; return 0x821781C8;
		/* 821F44BCh case   19:*/		return 0x821F44C0;
		  /* 821F44C0h */ case   20:  		/* stw R3, <#[R29 + 44]> */
		/* 821F44C0h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F44C0h case   20:*/		return 0x821F44C4;
		  /* 821F44C4h */ case   21:  		/* addi R4, R1, 144 */
		/* 821F44C4h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F44C4h case   21:*/		return 0x821F44C8;
	}
	return 0x821F44C8;
} // Block from 821F4470h-821F44C8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F44C8h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F44C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F44C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F44C8);
		  /* 821F44C8h */ case    0:  		/* mr R3, R31 */
		/* 821F44C8h case    0:*/		regs.R3 = regs.R31;
		/* 821F44C8h case    0:*/		return 0x821F44CC;
		  /* 821F44CCh */ case    1:  		/* bl -8524 */
		/* 821F44CCh case    1:*/		regs.LR = 0x821F44D0; return 0x821F2380;
		/* 821F44CCh case    1:*/		return 0x821F44D0;
		  /* 821F44D0h */ case    2:  		/* mr R4, R3 */
		/* 821F44D0h case    2:*/		regs.R4 = regs.R3;
		/* 821F44D0h case    2:*/		return 0x821F44D4;
		  /* 821F44D4h */ case    3:  		/* mr R3, R29 */
		/* 821F44D4h case    3:*/		regs.R3 = regs.R29;
		/* 821F44D4h case    3:*/		return 0x821F44D8;
		  /* 821F44D8h */ case    4:  		/* bl -508688 */
		/* 821F44D8h case    4:*/		regs.LR = 0x821F44DC; return 0x821781C8;
		/* 821F44D8h case    4:*/		return 0x821F44DC;
		  /* 821F44DCh */ case    5:  		/* stw R3, <#[R29 + 48]> */
		/* 821F44DCh case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 821F44DCh case    5:*/		return 0x821F44E0;
		  /* 821F44E0h */ case    6:  		/* addi R4, R1, 152 */
		/* 821F44E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 821F44E0h case    6:*/		return 0x821F44E4;
		  /* 821F44E4h */ case    7:  		/* mr R3, R31 */
		/* 821F44E4h case    7:*/		regs.R3 = regs.R31;
		/* 821F44E4h case    7:*/		return 0x821F44E8;
		  /* 821F44E8h */ case    8:  		/* bl -8552 */
		/* 821F44E8h case    8:*/		regs.LR = 0x821F44EC; return 0x821F2380;
		/* 821F44E8h case    8:*/		return 0x821F44EC;
		  /* 821F44ECh */ case    9:  		/* mr R4, R3 */
		/* 821F44ECh case    9:*/		regs.R4 = regs.R3;
		/* 821F44ECh case    9:*/		return 0x821F44F0;
		  /* 821F44F0h */ case   10:  		/* mr R3, R29 */
		/* 821F44F0h case   10:*/		regs.R3 = regs.R29;
		/* 821F44F0h case   10:*/		return 0x821F44F4;
		  /* 821F44F4h */ case   11:  		/* bl -508716 */
		/* 821F44F4h case   11:*/		regs.LR = 0x821F44F8; return 0x821781C8;
		/* 821F44F4h case   11:*/		return 0x821F44F8;
		  /* 821F44F8h */ case   12:  		/* lwz R10, <#[R29 + 44]> */
		/* 821F44F8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F44F8h case   12:*/		return 0x821F44FC;
		  /* 821F44FCh */ case   13:  		/* stw R3, <#[R29 + 52]> */
		/* 821F44FCh case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 821F44FCh case   13:*/		return 0x821F4500;
		  /* 821F4500h */ case   14:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F4500h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F4500h case   14:*/		return 0x821F4504;
		  /* 821F4504h */ case   15:  		/* lwz R9, <#[R29 + 8]> */
		/* 821F4504h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F4504h case   15:*/		return 0x821F4508;
		  /* 821F4508h */ case   16:  		/* mr R3, R29 */
		/* 821F4508h case   16:*/		regs.R3 = regs.R29;
		/* 821F4508h case   16:*/		return 0x821F450C;
		  /* 821F450Ch */ case   17:  		/* addi R11, R11, 36 */
		/* 821F450Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F450Ch case   17:*/		return 0x821F4510;
		  /* 821F4510h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 821F4510h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4510h case   18:*/		return 0x821F4514;
		  /* 821F4514h */ case   19:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F4514h case   19:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F4514h case   19:*/		return 0x821F4518;
		  /* 821F4518h */ case   20:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F4518h case   20:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F4518h case   20:*/		return 0x821F451C;
		  /* 821F451Ch */ case   21:  		/* addi R8, R11, -36 */
		/* 821F451Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F451Ch case   21:*/		return 0x821F4520;
		  /* 821F4520h */ case   22:  		/* stw R9, <#[R29 + 8]> */
		/* 821F4520h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F4520h case   22:*/		return 0x821F4524;
		  /* 821F4524h */ case   23:  		/* addi R9, R11, 4 */
		/* 821F4524h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F4524h case   23:*/		return 0x821F4528;
		  /* 821F4528h */ case   24:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F4528h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4528h case   24:*/		return 0x821F452C;
		  /* 821F452Ch */ case   25:  		/* addi R10, R10, 24 */
		/* 821F452Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F452Ch case   25:*/		return 0x821F4530;
		  /* 821F4530h */ case   26:  		/* lwz R7, <#[R10]> */
		/* 821F4530h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4530h case   26:*/		return 0x821F4534;
		  /* 821F4534h */ case   27:  		/* addi R6, R10, -36 */
		/* 821F4534h case   27:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F4534h case   27:*/		return 0x821F4538;
		  /* 821F4538h */ case   28:  		/* stw R7, <#[R11]> */
		/* 821F4538h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4538h case   28:*/		return 0x821F453C;
		  /* 821F453Ch */ case   29:  		/* lwz R7, <#[R10]> */
		/* 821F453Ch case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F453Ch case   29:*/		return 0x821F4540;
		  /* 821F4540h */ case   30:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F4540h case   30:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F4540h case   30:*/		return 0x821F4544;
		  /* 821F4544h */ case   31:  		/* ori R6, R6, 1 */
		/* 821F4544h case   31:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F4544h case   31:*/		return 0x821F4548;
		  /* 821F4548h */ case   32:  		/* stw R8, <#[R7]> */
		/* 821F4548h case   32:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F4548h case   32:*/		return 0x821F454C;
		  /* 821F454Ch */ case   33:  		/* stw R6, <#[R11 + 4]> */
		/* 821F454Ch case   33:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F454Ch case   33:*/		return 0x821F4550;
		  /* 821F4550h */ case   34:  		/* stw R9, <#[R10]> */
		/* 821F4550h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4550h case   34:*/		return 0x821F4554;
		  /* 821F4554h */ case   35:  		/* addi R1, R1, 112 */
		/* 821F4554h case   35:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F4554h case   35:*/		return 0x821F4558;
		  /* 821F4558h */ case   36:  		/* b -1454764 */
		/* 821F4558h case   36:*/		return 0x820912AC;
		/* 821F4558h case   36:*/		return 0x821F455C;
		  /* 821F455Ch */ case   37:  		/* nop */
		/* 821F455Ch case   37:*/		cpu::op::nop();
		/* 821F455Ch case   37:*/		return 0x821F4560;
	}
	return 0x821F4560;
} // Block from 821F44C8h-821F4560h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821F4560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4560);
		  /* 821F4560h */ case    0:  		/* mfspr R12, LR */
		/* 821F4560h case    0:*/		regs.R12 = regs.LR;
		/* 821F4560h case    0:*/		return 0x821F4564;
		  /* 821F4564h */ case    1:  		/* bl -1454856 */
		/* 821F4564h case    1:*/		regs.LR = 0x821F4568; return 0x8209125C;
		/* 821F4564h case    1:*/		return 0x821F4568;
		  /* 821F4568h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821F4568h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821F4568h case    2:*/		return 0x821F456C;
		  /* 821F456Ch */ case    3:  		/* std R5, <#[R1 + 144]> */
		/* 821F456Ch case    3:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000090) );
		/* 821F456Ch case    3:*/		return 0x821F4570;
		  /* 821F4570h */ case    4:  		/* li R8, 4 */
		/* 821F4570h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821F4570h case    4:*/		return 0x821F4574;
		  /* 821F4574h */ case    5:  		/* std R6, <#[R1 + 152]> */
		/* 821F4574h case    5:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000098) );
		/* 821F4574h case    5:*/		return 0x821F4578;
		  /* 821F4578h */ case    6:  		/* li R7, 3 */
		/* 821F4578h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821F4578h case    6:*/		return 0x821F457C;
		  /* 821F457Ch */ case    7:  		/* li R6, 14 */
		/* 821F457Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0xE);
		/* 821F457Ch case    7:*/		return 0x821F4580;
		  /* 821F4580h */ case    8:  		/* li R5, 0 */
		/* 821F4580h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F4580h case    8:*/		return 0x821F4584;
		  /* 821F4584h */ case    9:  		/* mr R30, R4 */
		/* 821F4584h case    9:*/		regs.R30 = regs.R4;
		/* 821F4584h case    9:*/		return 0x821F4588;
		  /* 821F4588h */ case   10:  		/* lwz R4, <#[R3 + 564]> */
		/* 821F4588h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000234) );
		/* 821F4588h case   10:*/		return 0x821F458C;
		  /* 821F458Ch */ case   11:  		/* mr R31, R3 */
		/* 821F458Ch case   11:*/		regs.R31 = regs.R3;
		/* 821F458Ch case   11:*/		return 0x821F4590;
		  /* 821F4590h */ case   12:  		/* bl 197640 */
		/* 821F4590h case   12:*/		regs.LR = 0x821F4594; return 0x82224998;
		/* 821F4590h case   12:*/		return 0x821F4594;
		  /* 821F4594h */ case   13:  		/* mr R29, R3 */
		/* 821F4594h case   13:*/		regs.R29 = regs.R3;
		/* 821F4594h case   13:*/		return 0x821F4598;
	}
	return 0x821F4598;
} // Block from 821F4560h-821F4598h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F4598h
// Function '?MakeInstr_V_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@VResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4598);
		  /* 821F4598h */ case    0:  		/* mr R4, R30 */
		/* 821F4598h case    0:*/		regs.R4 = regs.R30;
		/* 821F4598h case    0:*/		return 0x821F459C;
		  /* 821F459Ch */ case    1:  		/* mr R3, R31 */
		/* 821F459Ch case    1:*/		regs.R3 = regs.R31;
		/* 821F459Ch case    1:*/		return 0x821F45A0;
		  /* 821F45A0h */ case    2:  		/* bl -8736 */
		/* 821F45A0h case    2:*/		regs.LR = 0x821F45A4; return 0x821F2380;
		/* 821F45A0h case    2:*/		return 0x821F45A4;
		  /* 821F45A4h */ case    3:  		/* mr R4, R3 */
		/* 821F45A4h case    3:*/		regs.R4 = regs.R3;
		/* 821F45A4h case    3:*/		return 0x821F45A8;
		  /* 821F45A8h */ case    4:  		/* mr R3, R29 */
		/* 821F45A8h case    4:*/		regs.R3 = regs.R29;
		/* 821F45A8h case    4:*/		return 0x821F45AC;
		  /* 821F45ACh */ case    5:  		/* bl -508900 */
		/* 821F45ACh case    5:*/		regs.LR = 0x821F45B0; return 0x821781C8;
		/* 821F45ACh case    5:*/		return 0x821F45B0;
		  /* 821F45B0h */ case    6:  		/* stw R3, <#[R29 + 44]> */
		/* 821F45B0h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F45B0h case    6:*/		return 0x821F45B4;
		  /* 821F45B4h */ case    7:  		/* addi R4, R1, 144 */
		/* 821F45B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 821F45B4h case    7:*/		return 0x821F45B8;
		  /* 821F45B8h */ case    8:  		/* mr R3, R31 */
		/* 821F45B8h case    8:*/		regs.R3 = regs.R31;
		/* 821F45B8h case    8:*/		return 0x821F45BC;
		  /* 821F45BCh */ case    9:  		/* bl -8764 */
		/* 821F45BCh case    9:*/		regs.LR = 0x821F45C0; return 0x821F2380;
		/* 821F45BCh case    9:*/		return 0x821F45C0;
		  /* 821F45C0h */ case   10:  		/* mr R4, R3 */
		/* 821F45C0h case   10:*/		regs.R4 = regs.R3;
		/* 821F45C0h case   10:*/		return 0x821F45C4;
		  /* 821F45C4h */ case   11:  		/* mr R3, R29 */
		/* 821F45C4h case   11:*/		regs.R3 = regs.R29;
		/* 821F45C4h case   11:*/		return 0x821F45C8;
		  /* 821F45C8h */ case   12:  		/* bl -508928 */
		/* 821F45C8h case   12:*/		regs.LR = 0x821F45CC; return 0x821781C8;
		/* 821F45C8h case   12:*/		return 0x821F45CC;
		  /* 821F45CCh */ case   13:  		/* stw R3, <#[R29 + 48]> */
		/* 821F45CCh case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000030) );
		/* 821F45CCh case   13:*/		return 0x821F45D0;
		  /* 821F45D0h */ case   14:  		/* addi R4, R1, 152 */
		/* 821F45D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 821F45D0h case   14:*/		return 0x821F45D4;
		  /* 821F45D4h */ case   15:  		/* mr R3, R31 */
		/* 821F45D4h case   15:*/		regs.R3 = regs.R31;
		/* 821F45D4h case   15:*/		return 0x821F45D8;
		  /* 821F45D8h */ case   16:  		/* bl -8792 */
		/* 821F45D8h case   16:*/		regs.LR = 0x821F45DC; return 0x821F2380;
		/* 821F45D8h case   16:*/		return 0x821F45DC;
		  /* 821F45DCh */ case   17:  		/* mr R4, R3 */
		/* 821F45DCh case   17:*/		regs.R4 = regs.R3;
		/* 821F45DCh case   17:*/		return 0x821F45E0;
		  /* 821F45E0h */ case   18:  		/* mr R3, R29 */
		/* 821F45E0h case   18:*/		regs.R3 = regs.R29;
		/* 821F45E0h case   18:*/		return 0x821F45E4;
		  /* 821F45E4h */ case   19:  		/* bl -508956 */
		/* 821F45E4h case   19:*/		regs.LR = 0x821F45E8; return 0x821781C8;
		/* 821F45E4h case   19:*/		return 0x821F45E8;
		  /* 821F45E8h */ case   20:  		/* lwz R10, <#[R29 + 44]> */
		/* 821F45E8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 821F45E8h case   20:*/		return 0x821F45EC;
		  /* 821F45ECh */ case   21:  		/* stw R3, <#[R29 + 52]> */
		/* 821F45ECh case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000034) );
		/* 821F45ECh case   21:*/		return 0x821F45F0;
		  /* 821F45F0h */ case   22:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821F45F0h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821F45F0h case   22:*/		return 0x821F45F4;
		  /* 821F45F4h */ case   23:  		/* lwz R9, <#[R29 + 8]> */
		/* 821F45F4h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F45F4h case   23:*/		return 0x821F45F8;
		  /* 821F45F8h */ case   24:  		/* mr R3, R29 */
		/* 821F45F8h case   24:*/		regs.R3 = regs.R29;
		/* 821F45F8h case   24:*/		return 0x821F45FC;
		  /* 821F45FCh */ case   25:  		/* addi R11, R11, 36 */
		/* 821F45FCh case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F45FCh case   25:*/		return 0x821F4600;
		  /* 821F4600h */ case   26:  		/* lwz R10, <#[R10]> */
		/* 821F4600h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4600h case   26:*/		return 0x821F4604;
		  /* 821F4604h */ case   27:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821F4604h case   27:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821F4604h case   27:*/		return 0x821F4608;
		  /* 821F4608h */ case   28:  		/* rlwimi R9, R10, 14, 15, 17 */
		/* 821F4608h case   28:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R9,regs.R10);
		/* 821F4608h case   28:*/		return 0x821F460C;
		  /* 821F460Ch */ case   29:  		/* addi R8, R11, -36 */
		/* 821F460Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821F460Ch case   29:*/		return 0x821F4610;
		  /* 821F4610h */ case   30:  		/* stw R9, <#[R29 + 8]> */
		/* 821F4610h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821F4610h case   30:*/		return 0x821F4614;
		  /* 821F4614h */ case   31:  		/* addi R9, R11, 4 */
		/* 821F4614h case   31:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F4614h case   31:*/		return 0x821F4618;
		  /* 821F4618h */ case   32:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F4618h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4618h case   32:*/		return 0x821F461C;
		  /* 821F461Ch */ case   33:  		/* addi R10, R10, 24 */
		/* 821F461Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F461Ch case   33:*/		return 0x821F4620;
		  /* 821F4620h */ case   34:  		/* lwz R7, <#[R10]> */
		/* 821F4620h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4620h case   34:*/		return 0x821F4624;
		  /* 821F4624h */ case   35:  		/* addi R6, R10, -36 */
		/* 821F4624h case   35:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821F4624h case   35:*/		return 0x821F4628;
		  /* 821F4628h */ case   36:  		/* stw R7, <#[R11]> */
		/* 821F4628h case   36:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4628h case   36:*/		return 0x821F462C;
		  /* 821F462Ch */ case   37:  		/* lwz R7, <#[R10]> */
		/* 821F462Ch case   37:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F462Ch case   37:*/		return 0x821F4630;
		  /* 821F4630h */ case   38:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F4630h case   38:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F4630h case   38:*/		return 0x821F4634;
		  /* 821F4634h */ case   39:  		/* ori R6, R6, 1 */
		/* 821F4634h case   39:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821F4634h case   39:*/		return 0x821F4638;
		  /* 821F4638h */ case   40:  		/* stw R8, <#[R7]> */
		/* 821F4638h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821F4638h case   40:*/		return 0x821F463C;
		  /* 821F463Ch */ case   41:  		/* stw R6, <#[R11 + 4]> */
		/* 821F463Ch case   41:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821F463Ch case   41:*/		return 0x821F4640;
		  /* 821F4640h */ case   42:  		/* stw R9, <#[R10]> */
		/* 821F4640h case   42:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4640h case   42:*/		return 0x821F4644;
		  /* 821F4644h */ case   43:  		/* addi R1, R1, 112 */
		/* 821F4644h case   43:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821F4644h case   43:*/		return 0x821F4648;
		  /* 821F4648h */ case   44:  		/* b -1455004 */
		/* 821F4648h case   44:*/		return 0x820912AC;
		/* 821F4648h case   44:*/		return 0x821F464C;
		  /* 821F464Ch */ case   45:  		/* nop */
		/* 821F464Ch case   45:*/		cpu::op::nop();
		/* 821F464Ch case   45:*/		return 0x821F4650;
	}
	return 0x821F4650;
} // Block from 821F4598h-821F4650h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821F4650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4650);
		  /* 821F4650h */ case    0:  		/* mfspr R12, LR */
		/* 821F4650h case    0:*/		regs.R12 = regs.LR;
		/* 821F4650h case    0:*/		return 0x821F4654;
		  /* 821F4654h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F4654h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F4654h case    1:*/		return 0x821F4658;
		  /* 821F4658h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F4658h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4658h case    2:*/		return 0x821F465C;
		  /* 821F465Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F465Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F465Ch case    3:*/		return 0x821F4660;
		  /* 821F4660h */ case    4:  		/* lwz R11, <#[R4 + 4]> */
		/* 821F4660h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821F4660h case    4:*/		return 0x821F4664;
		  /* 821F4664h */ case    5:  		/* mr R31, R3 */
		/* 821F4664h case    5:*/		regs.R31 = regs.R3;
		/* 821F4664h case    5:*/		return 0x821F4668;
	}
	return 0x821F4668;
} // Block from 821F4650h-821F4668h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F4668h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@VResult@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4668);
		  /* 821F4668h */ case    0:  		/* mr R3, R4 */
		/* 821F4668h case    0:*/		regs.R3 = regs.R4;
		/* 821F4668h case    0:*/		return 0x821F466C;
		  /* 821F466Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821F466Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821F466Ch case    1:*/		return 0x821F4670;
		  /* 821F4670h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821F4670h case    2:*/		if ( regs.CR[0].eq ) { return 0x821F467C;  }
		/* 821F4670h case    2:*/		return 0x821F4674;
		  /* 821F4674h */ case    3:  		/* li R4, 0 */
		/* 821F4674h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F4674h case    3:*/		return 0x821F4678;
		  /* 821F4678h */ case    4:  		/* b 16 */
		/* 821F4678h case    4:*/		return 0x821F4688;
		/* 821F4678h case    4:*/		return 0x821F467C;
	}
	return 0x821F467C;
} // Block from 821F4668h-821F467Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F467Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F467C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F467C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F467C);
		  /* 821F467Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F467Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F467Ch case    0:*/		return 0x821F4680;
		  /* 821F4680h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F4680h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F4680h case    1:*/		return 0x821F4684;
		  /* 821F4684h */ case    2:  		/* addi R4, R11, -4 */
		/* 821F4684h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821F4684h case    2:*/		return 0x821F4688;
	}
	return 0x821F4688;
} // Block from 821F467Ch-821F4688h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4688);
		  /* 821F4688h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F4688h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F4688h case    0:*/		return 0x821F468C;
		  /* 821F468Ch */ case    1:  		/* addi R10, R11, 1 */
		/* 821F468Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 821F468Ch case    1:*/		return 0x821F4690;
		  /* 821F4690h */ case    2:  		/* addic. R11, R11, -1 */
		/* 821F4690h case    2:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F4690h case    2:*/		return 0x821F4694;
		  /* 821F4694h */ case    3:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 821F4694h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 821F4694h case    3:*/		return 0x821F4698;
		  /* 821F4698h */ case    4:  		/* add R9, R10, R4 */
		/* 821F4698h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 821F4698h case    4:*/		return 0x821F469C;
		  /* 821F469Ch */ case    5:  		/* lwzx R10, <#[R10 + R4]> */
		/* 821F469Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821F469Ch case    5:*/		return 0x821F46A0;
		  /* 821F46A0h */ case    6:  		/* lwz R9, <#[R9 + 4]> */
		/* 821F46A0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821F46A0h case    6:*/		return 0x821F46A4;
		  /* 821F46A4h */ case    7:  		/* stw R11, <#[R4 + 8]> */
		/* 821F46A4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F46A4h case    7:*/		return 0x821F46A8;
		  /* 821F46A8h */ case    8:  		/* stw R10, <#[R31]> */
		/* 821F46A8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821F46A8h case    8:*/		return 0x821F46AC;
		  /* 821F46ACh */ case    9:  		/* stw R9, <#[R31 + 4]> */
		/* 821F46ACh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821F46ACh case    9:*/		return 0x821F46B0;
		  /* 821F46B0h */ case   10:  		/* bc 4, CR0_EQ, 56 */
		/* 821F46B0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821F46E8;  }
		/* 821F46B0h case   10:*/		return 0x821F46B4;
		  /* 821F46B4h */ case   11:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F46B4h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F46B4h case   11:*/		return 0x821F46B8;
		  /* 821F46B8h */ case   12:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F46B8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F46B8h case   12:*/		return 0x821F46BC;
		  /* 821F46BCh */ case   13:  		/* lwz R9, <#[R11]> */
		/* 821F46BCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F46BCh case   13:*/		return 0x821F46C0;
		  /* 821F46C0h */ case   14:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F46C0h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F46C0h case   14:*/		return 0x821F46C4;
		  /* 821F46C4h */ case   15:  		/* stw R9, <#[R10]> */
		/* 821F46C4h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F46C4h case   15:*/		return 0x821F46C8;
		  /* 821F46C8h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F46C8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F46C8h case   16:*/		return 0x821F46CC;
		  /* 821F46CCh */ case   17:  		/* lwz R11, <#[R11]> */
		/* 821F46CCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F46CCh case   17:*/		return 0x821F46D0;
		  /* 821F46D0h */ case   18:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F46D0h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F46D0h case   18:*/		return 0x821F46D4;
		  /* 821F46D4h */ case   19:  		/* stw R10, <#[R11]> */
		/* 821F46D4h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F46D4h case   19:*/		return 0x821F46D8;
		  /* 821F46D8h */ case   20:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F46D8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F46D8h case   20:*/		return 0x821F46DC;
		  /* 821F46DCh */ case   21:  		/* addi R11, R11, 2 */
		/* 821F46DCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F46DCh case   21:*/		return 0x821F46E0;
		  /* 821F46E0h */ case   22:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F46E0h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F46E0h case   22:*/		return 0x821F46E4;
		  /* 821F46E4h */ case   23:  		/* bl -665820 */
		/* 821F46E4h case   23:*/		regs.LR = 0x821F46E8; return 0x82151E08;
		/* 821F46E4h case   23:*/		return 0x821F46E8;
	}
	return 0x821F46E8;
} // Block from 821F4688h-821F46E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821F46E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F46E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F46E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F46E8);
		  /* 821F46E8h */ case    0:  		/* mr R3, R31 */
		/* 821F46E8h case    0:*/		regs.R3 = regs.R31;
		/* 821F46E8h case    0:*/		return 0x821F46EC;
		  /* 821F46ECh */ case    1:  		/* addi R1, R1, 96 */
		/* 821F46ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F46ECh case    1:*/		return 0x821F46F0;
		  /* 821F46F0h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F46F0h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F46F0h case    2:*/		return 0x821F46F4;
		  /* 821F46F4h */ case    3:  		/* mtspr LR, R12 */
		/* 821F46F4h case    3:*/		regs.LR = regs.R12;
		/* 821F46F4h case    3:*/		return 0x821F46F8;
		  /* 821F46F8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F46F8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F46F8h case    4:*/		return 0x821F46FC;
		  /* 821F46FCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F46FCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F46FCh case    5:*/		return 0x821F4700;
	}
	return 0x821F4700;
} // Block from 821F46E8h-821F4700h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F4700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4700);
		  /* 821F4700h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F4700h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F4700h case    0:*/		return 0x821F4704;
		  /* 821F4704h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F4704h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4704h case    1:*/		return 0x821F4708;
		  /* 821F4708h */ case    2:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821F4708h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821F4708h case    2:*/		return 0x821F470C;
		  /* 821F470Ch */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821F470Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x821F4718;  }
		/* 821F470Ch case    3:*/		return 0x821F4710;
		  /* 821F4710h */ case    4:  		/* li R11, 0 */
		/* 821F4710h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F4710h case    4:*/		return 0x821F4714;
		  /* 821F4714h */ case    5:  		/* b 16 */
		/* 821F4714h case    5:*/		return 0x821F4724;
		/* 821F4714h case    5:*/		return 0x821F4718;
	}
	return 0x821F4718;
} // Block from 821F4700h-821F4718h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F4718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4718);
		  /* 821F4718h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821F4718h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4718h case    0:*/		return 0x821F471C;
		  /* 821F471Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F471Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F471Ch case    1:*/		return 0x821F4720;
		  /* 821F4720h */ case    2:  		/* addi R11, R11, -4 */
		/* 821F4720h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F4720h case    2:*/		return 0x821F4724;
	}
	return 0x821F4724;
} // Block from 821F4718h-821F4724h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4724);
		  /* 821F4724h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 821F4724h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F4724h case    0:*/		return 0x821F4728;
		  /* 821F4728h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821F4728h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F4728h case    1:*/		return 0x821F472C;
		  /* 821F472Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 821F472Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821F4738;  }
		/* 821F472Ch case    2:*/		return 0x821F4730;
		  /* 821F4730h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 821F4730h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4730h case    3:*/		return 0x821F4734;
		  /* 821F4734h */ case    4:  		/* b 8 */
		/* 821F4734h case    4:*/		return 0x821F473C;
		/* 821F4734h case    4:*/		return 0x821F4738;
	}
	return 0x821F4738;
} // Block from 821F4724h-821F4738h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F4738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4738);
		  /* 821F4738h */ case    0:  		/* li R11, 0 */
		/* 821F4738h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F4738h case    0:*/		return 0x821F473C;
	}
	return 0x821F473C;
} // Block from 821F4738h-821F473Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F473Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F473C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F473C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F473C);
		  /* 821F473Ch */ case    0:  		/* stw R11, <#[R3 + 8]> */
		/* 821F473Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F473Ch case    0:*/		return 0x821F4740;
		  /* 821F4740h */ case    1:  		/* b -11728 */
		/* 821F4740h case    1:*/		return 0x821F1970;
		/* 821F4740h case    1:*/		return 0x821F4744;
		  /* 821F4744h */ case    2:  		/* nop */
		/* 821F4744h case    2:*/		cpu::op::nop();
		/* 821F4744h case    2:*/		return 0x821F4748;
	}
	return 0x821F4748;
} // Block from 821F473Ch-821F4748h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4748);
		  /* 821F4748h */ case    0:  		/* mfspr R12, LR */
		/* 821F4748h case    0:*/		regs.R12 = regs.LR;
		/* 821F4748h case    0:*/		return 0x821F474C;
		  /* 821F474Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F474Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F474Ch case    1:*/		return 0x821F4750;
	}
	return 0x821F4750;
} // Block from 821F4748h-821F4750h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F4750h
// Function '?MakeInstr_V_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4750);
		  /* 821F4750h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 821F4750h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4750h case    0:*/		return 0x821F4754;
		  /* 821F4754h */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F4754h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F4754h case    1:*/		return 0x821F4758;
		  /* 821F4758h */ case    2:  		/* mr R10, R3 */
		/* 821F4758h case    2:*/		regs.R10 = regs.R3;
		/* 821F4758h case    2:*/		return 0x821F475C;
		  /* 821F475Ch */ case    3:  		/* addi R3, R3, 28 */
		/* 821F475Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1C);
		/* 821F475Ch case    3:*/		return 0x821F4760;
		  /* 821F4760h */ case    4:  		/* lwz R11, <#[R10 + 32]> */
		/* 821F4760h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000020) );
		/* 821F4760h case    4:*/		return 0x821F4764;
		  /* 821F4764h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821F4764h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821F4764h case    5:*/		return 0x821F4768;
		  /* 821F4768h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 821F4768h case    6:*/		if ( regs.CR[0].eq ) { return 0x821F4774;  }
		/* 821F4768h case    6:*/		return 0x821F476C;
		  /* 821F476Ch */ case    7:  		/* li R11, 0 */
		/* 821F476Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F476Ch case    7:*/		return 0x821F4770;
		  /* 821F4770h */ case    8:  		/* b 16 */
		/* 821F4770h case    8:*/		return 0x821F4780;
		/* 821F4770h case    8:*/		return 0x821F4774;
	}
	return 0x821F4774;
} // Block from 821F4750h-821F4774h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F4774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4774);
		  /* 821F4774h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F4774h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F4774h case    0:*/		return 0x821F4778;
		  /* 821F4778h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F4778h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F4778h case    1:*/		return 0x821F477C;
		  /* 821F477Ch */ case    2:  		/* addi R11, R11, -4 */
		/* 821F477Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F477Ch case    2:*/		return 0x821F4780;
	}
	return 0x821F4780;
} // Block from 821F4774h-821F4780h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4780);
		  /* 821F4780h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 821F4780h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4780h case    0:*/		return 0x821F4784;
		  /* 821F4784h */ case    1:  		/* mulli R9, R9, 28 */
		/* 821F4784h case    1:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0x1C);
		/* 821F4784h case    1:*/		return 0x821F4788;
		  /* 821F4788h */ case    2:  		/* add R11, R9, R11 */
		/* 821F4788h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F4788h case    2:*/		return 0x821F478C;
		  /* 821F478Ch */ case    3:  		/* addi R11, R11, -12 */
		/* 821F478Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF4);
		/* 821F478Ch case    3:*/		return 0x821F4790;
		  /* 821F4790h */ case    4:  		/* lwz R9, <#[R11 + 12]> */
		/* 821F4790h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F4790h case    4:*/		return 0x821F4794;
		  /* 821F4794h */ case    5:  		/* stw R9, <#[R10 + 12]> */
		/* 821F4794h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 821F4794h case    5:*/		return 0x821F4798;
		  /* 821F4798h */ case    6:  		/* lwz R9, <#[R11 + 16]> */
		/* 821F4798h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821F4798h case    6:*/		return 0x821F479C;
		  /* 821F479Ch */ case    7:  		/* stw R9, <#[R10 + 8]> */
		/* 821F479Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821F479Ch case    7:*/		return 0x821F47A0;
		  /* 821F47A0h */ case    8:  		/* lwz R9, <#[R11 + 20]> */
		/* 821F47A0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 821F47A0h case    8:*/		return 0x821F47A4;
		  /* 821F47A4h */ case    9:  		/* stw R9, <#[R10 + 16]> */
		/* 821F47A4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 821F47A4h case    9:*/		return 0x821F47A8;
		  /* 821F47A8h */ case   10:  		/* lbz R9, <#[R11 + 4]> */
		/* 821F47A8h case   10:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821F47A8h case   10:*/		return 0x821F47AC;
		  /* 821F47ACh */ case   11:  		/* stb R9, <#[R10 + 36]> */
		/* 821F47ACh case   11:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 821F47ACh case   11:*/		return 0x821F47B0;
		  /* 821F47B0h */ case   12:  		/* lwz R9, <#[R11 + 24]> */
		/* 821F47B0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 821F47B0h case   12:*/		return 0x821F47B4;
		  /* 821F47B4h */ case   13:  		/* stw R9, <#[R10 + 24]> */
		/* 821F47B4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 821F47B4h case   13:*/		return 0x821F47B8;
		  /* 821F47B8h */ case   14:  		/* lwz R10, <#[R11 + 8]> */
		/* 821F47B8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F47B8h case   14:*/		return 0x821F47BC;
		  /* 821F47BCh */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 821F47BCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F47BCh case   15:*/		return 0x821F47C0;
		  /* 821F47C0h */ case   16:  		/* lwz R31, <#[R11]> */
		/* 821F47C0h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 821F47C0h case   16:*/		return 0x821F47C4;
		  /* 821F47C4h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 821F47C4h case   17:*/		if ( regs.CR[6].eq ) { return 0x821F47D4;  }
		/* 821F47C4h case   17:*/		return 0x821F47C8;
		  /* 821F47C8h */ case   18:  		/* addi R10, R10, -1 */
		/* 821F47C8h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821F47C8h case   18:*/		return 0x821F47CC;
		  /* 821F47CCh */ case   19:  		/* stw R10, <#[R11 + 8]> */
		/* 821F47CCh case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F47CCh case   19:*/		return 0x821F47D0;
		  /* 821F47D0h */ case   20:  		/* b 104 */
		/* 821F47D0h case   20:*/		return 0x821F4838;
		/* 821F47D0h case   20:*/		return 0x821F47D4;
	}
	return 0x821F47D4;
} // Block from 821F4780h-821F47D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F47D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F47D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F47D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F47D4);
		  /* 821F47D4h */ case    0:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F47D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F47D4h case    0:*/		return 0x821F47D8;
		  /* 821F47D8h */ case    1:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 821F47D8h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 821F47D8h case    1:*/		return 0x821F47DC;
		  /* 821F47DCh */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821F47DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x821F47E8;  }
		/* 821F47DCh case    2:*/		return 0x821F47E0;
		  /* 821F47E0h */ case    3:  		/* li R4, 0 */
		/* 821F47E0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F47E0h case    3:*/		return 0x821F47E4;
		  /* 821F47E4h */ case    4:  		/* b 16 */
		/* 821F47E4h case    4:*/		return 0x821F47F4;
		/* 821F47E4h case    4:*/		return 0x821F47E8;
	}
	return 0x821F47E8;
} // Block from 821F47D4h-821F47E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F47E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F47E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F47E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F47E8);
		  /* 821F47E8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F47E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F47E8h case    0:*/		return 0x821F47EC;
		  /* 821F47ECh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F47ECh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F47ECh case    1:*/		return 0x821F47F0;
		  /* 821F47F0h */ case    2:  		/* addi R4, R11, -4 */
		/* 821F47F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821F47F0h case    2:*/		return 0x821F47F4;
	}
	return 0x821F47F4;
} // Block from 821F47E8h-821F47F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F47F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F47F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F47F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F47F4);
		  /* 821F47F4h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F47F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F47F4h case    0:*/		return 0x821F47F8;
		  /* 821F47F8h */ case    1:  		/* addic. R11, R11, -1 */
		/* 821F47F8h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F47F8h case    1:*/		return 0x821F47FC;
		  /* 821F47FCh */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 821F47FCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F47FCh case    2:*/		return 0x821F4800;
		  /* 821F4800h */ case    3:  		/* bc 4, CR0_EQ, 56 */
		/* 821F4800h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821F4838;  }
		/* 821F4800h case    3:*/		return 0x821F4804;
		  /* 821F4804h */ case    4:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F4804h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F4804h case    4:*/		return 0x821F4808;
		  /* 821F4808h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F4808h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4808h case    5:*/		return 0x821F480C;
		  /* 821F480Ch */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821F480Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F480Ch case    6:*/		return 0x821F4810;
		  /* 821F4810h */ case    7:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F4810h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F4810h case    7:*/		return 0x821F4814;
		  /* 821F4814h */ case    8:  		/* stw R9, <#[R10]> */
		/* 821F4814h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4814h case    8:*/		return 0x821F4818;
		  /* 821F4818h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F4818h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4818h case    9:*/		return 0x821F481C;
		  /* 821F481Ch */ case   10:  		/* lwz R11, <#[R11]> */
		/* 821F481Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F481Ch case   10:*/		return 0x821F4820;
		  /* 821F4820h */ case   11:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F4820h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F4820h case   11:*/		return 0x821F4824;
		  /* 821F4824h */ case   12:  		/* stw R10, <#[R11]> */
		/* 821F4824h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4824h case   12:*/		return 0x821F4828;
		  /* 821F4828h */ case   13:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F4828h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F4828h case   13:*/		return 0x821F482C;
		  /* 821F482Ch */ case   14:  		/* mulli R11, R11, 28 */
		/* 821F482Ch case   14:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x1C);
		/* 821F482Ch case   14:*/		return 0x821F4830;
	}
	return 0x821F4830;
} // Block from 821F47F4h-821F4830h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821F4830h
// Function '?MakeInstr_V_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4830);
		  /* 821F4830h */ case    0:  		/* addi R5, R11, 16 */
		/* 821F4830h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x10);
		/* 821F4830h case    0:*/		return 0x821F4834;
		  /* 821F4834h */ case    1:  		/* bl -666156 */
		/* 821F4834h case    1:*/		regs.LR = 0x821F4838; return 0x82151E08;
		/* 821F4834h case    1:*/		return 0x821F4838;
	}
	return 0x821F4838;
} // Block from 821F4830h-821F4838h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F4838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4838);
		  /* 821F4838h */ case    0:  		/* mr R3, R31 */
		/* 821F4838h case    0:*/		regs.R3 = regs.R31;
		/* 821F4838h case    0:*/		return 0x821F483C;
		  /* 821F483Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 821F483Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F483Ch case    1:*/		return 0x821F4840;
		  /* 821F4840h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F4840h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F4840h case    2:*/		return 0x821F4844;
		  /* 821F4844h */ case    3:  		/* mtspr LR, R12 */
		/* 821F4844h case    3:*/		regs.LR = regs.R12;
		/* 821F4844h case    3:*/		return 0x821F4848;
		  /* 821F4848h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F4848h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4848h case    4:*/		return 0x821F484C;
		  /* 821F484Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F484Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F484Ch case    5:*/		return 0x821F4850;
	}
	return 0x821F4850;
} // Block from 821F4838h-821F4850h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F4850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4850);
		  /* 821F4850h */ case    0:  		/* mfspr R12, LR */
		/* 821F4850h case    0:*/		regs.R12 = regs.LR;
		/* 821F4850h case    0:*/		return 0x821F4854;
		  /* 821F4854h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F4854h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F4854h case    1:*/		return 0x821F4858;
		  /* 821F4858h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F4858h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4858h case    2:*/		return 0x821F485C;
		  /* 821F485Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F485Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F485Ch case    3:*/		return 0x821F4860;
		  /* 821F4860h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F4860h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F4860h case    4:*/		return 0x821F4864;
		  /* 821F4864h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821F4864h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821F4864h case    5:*/		return 0x821F4868;
		  /* 821F4868h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 821F4868h case    6:*/		if ( regs.CR[0].eq ) { return 0x821F4874;  }
		/* 821F4868h case    6:*/		return 0x821F486C;
		  /* 821F486Ch */ case    7:  		/* li R11, 0 */
		/* 821F486Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F486Ch case    7:*/		return 0x821F4870;
		  /* 821F4870h */ case    8:  		/* b 16 */
		/* 821F4870h case    8:*/		return 0x821F4880;
		/* 821F4870h case    8:*/		return 0x821F4874;
	}
	return 0x821F4874;
} // Block from 821F4850h-821F4874h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F4874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4874);
		  /* 821F4874h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F4874h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F4874h case    0:*/		return 0x821F4878;
		  /* 821F4878h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F4878h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F4878h case    1:*/		return 0x821F487C;
		  /* 821F487Ch */ case    2:  		/* addi R11, R11, -4 */
		/* 821F487Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F487Ch case    2:*/		return 0x821F4880;
	}
	return 0x821F4880;
} // Block from 821F4874h-821F4880h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4880);
		  /* 821F4880h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 821F4880h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4880h case    0:*/		return 0x821F4884;
		  /* 821F4884h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821F4884h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821F4884h case    1:*/		return 0x821F4888;
		  /* 821F4888h */ case    2:  		/* rlwinm R10, R9, 3, 0, 28 */
		/* 821F4888h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R9);
		/* 821F4888h case    2:*/		return 0x821F488C;
		  /* 821F488Ch */ case    3:  		/* add R11, R10, R11 */
		/* 821F488Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F488Ch case    3:*/		return 0x821F4890;
		  /* 821F4890h */ case    4:  		/* lwz R31, <#[R11 + 12]> */
		/* 821F4890h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F4890h case    4:*/		return 0x821F4894;
		  /* 821F4894h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821F4894h case    5:*/		if ( regs.CR[6].eq ) { return 0x821F48A0;  }
		/* 821F4894h case    5:*/		return 0x821F4898;
		  /* 821F4898h */ case    6:  		/* li R11, 0 */
		/* 821F4898h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F4898h case    6:*/		return 0x821F489C;
		  /* 821F489Ch */ case    7:  		/* b 16 */
		/* 821F489Ch case    7:*/		return 0x821F48AC;
		/* 821F489Ch case    7:*/		return 0x821F48A0;
	}
	return 0x821F48A0;
} // Block from 821F4880h-821F48A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F48A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F48A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F48A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F48A0);
		  /* 821F48A0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F48A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F48A0h case    0:*/		return 0x821F48A4;
		  /* 821F48A4h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F48A4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F48A4h case    1:*/		return 0x821F48A8;
		  /* 821F48A8h */ case    2:  		/* addi R11, R11, -4 */
		/* 821F48A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F48A8h case    2:*/		return 0x821F48AC;
	}
	return 0x821F48AC;
} // Block from 821F48A0h-821F48ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F48ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F48AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F48AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F48AC);
		  /* 821F48ACh */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821F48ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F48ACh case    0:*/		return 0x821F48B0;
		  /* 821F48B0h */ case    1:  		/* addi R10, R10, 1 */
		/* 821F48B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F48B0h case    1:*/		return 0x821F48B4;
		  /* 821F48B4h */ case    2:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 821F48B4h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 821F48B4h case    2:*/		return 0x821F48B8;
		  /* 821F48B8h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821F48B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821F48B8h case    3:*/		return 0x821F48BC;
		  /* 821F48BCh */ case    4:  		/* stw R11, <#[R4]> */
		/* 821F48BCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821F48BCh case    4:*/		return 0x821F48C0;
		  /* 821F48C0h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F48C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F48C0h case    5:*/		return 0x821F48C4;
		  /* 821F48C4h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821F48C4h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821F48C4h case    6:*/		return 0x821F48C8;
		  /* 821F48C8h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821F48C8h case    7:*/		if ( regs.CR[0].eq ) { return 0x821F48D4;  }
		/* 821F48C8h case    7:*/		return 0x821F48CC;
		  /* 821F48CCh */ case    8:  		/* li R4, 0 */
		/* 821F48CCh case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F48CCh case    8:*/		return 0x821F48D0;
		  /* 821F48D0h */ case    9:  		/* b 16 */
		/* 821F48D0h case    9:*/		return 0x821F48E0;
		/* 821F48D0h case    9:*/		return 0x821F48D4;
	}
	return 0x821F48D4;
} // Block from 821F48ACh-821F48D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F48D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F48D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F48D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F48D4);
		  /* 821F48D4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821F48D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F48D4h case    0:*/		return 0x821F48D8;
		  /* 821F48D8h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F48D8h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F48D8h case    1:*/		return 0x821F48DC;
		  /* 821F48DCh */ case    2:  		/* addi R4, R11, -4 */
		/* 821F48DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821F48DCh case    2:*/		return 0x821F48E0;
	}
	return 0x821F48E0;
} // Block from 821F48D4h-821F48E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F48E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F48E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F48E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F48E0);
		  /* 821F48E0h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F48E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F48E0h case    0:*/		return 0x821F48E4;
		  /* 821F48E4h */ case    1:  		/* addic. R11, R11, -1 */
		/* 821F48E4h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F48E4h case    1:*/		return 0x821F48E8;
		  /* 821F48E8h */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 821F48E8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F48E8h case    2:*/		return 0x821F48EC;
		  /* 821F48ECh */ case    3:  		/* bc 4, CR0_EQ, 56 */
		/* 821F48ECh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821F4924;  }
		/* 821F48ECh case    3:*/		return 0x821F48F0;
		  /* 821F48F0h */ case    4:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F48F0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F48F0h case    4:*/		return 0x821F48F4;
		  /* 821F48F4h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F48F4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F48F4h case    5:*/		return 0x821F48F8;
		  /* 821F48F8h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821F48F8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F48F8h case    6:*/		return 0x821F48FC;
		  /* 821F48FCh */ case    7:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F48FCh case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F48FCh case    7:*/		return 0x821F4900;
		  /* 821F4900h */ case    8:  		/* stw R9, <#[R10]> */
		/* 821F4900h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4900h case    8:*/		return 0x821F4904;
		  /* 821F4904h */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F4904h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4904h case    9:*/		return 0x821F4908;
		  /* 821F4908h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 821F4908h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4908h case   10:*/		return 0x821F490C;
		  /* 821F490Ch */ case   11:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F490Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F490Ch case   11:*/		return 0x821F4910;
	}
	return 0x821F4910;
} // Block from 821F48E0h-821F4910h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F4910h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4910);
		  /* 821F4910h */ case    0:  		/* stw R10, <#[R11]> */
		/* 821F4910h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4910h case    0:*/		return 0x821F4914;
		  /* 821F4914h */ case    1:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F4914h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F4914h case    1:*/		return 0x821F4918;
		  /* 821F4918h */ case    2:  		/* addi R11, R11, 2 */
		/* 821F4918h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F4918h case    2:*/		return 0x821F491C;
		  /* 821F491Ch */ case    3:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 821F491Ch case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 821F491Ch case    3:*/		return 0x821F4920;
		  /* 821F4920h */ case    4:  		/* bl -666392 */
		/* 821F4920h case    4:*/		regs.LR = 0x821F4924; return 0x82151E08;
		/* 821F4920h case    4:*/		return 0x821F4924;
	}
	return 0x821F4924;
} // Block from 821F4910h-821F4924h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F4924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4924);
		  /* 821F4924h */ case    0:  		/* mr R3, R31 */
		/* 821F4924h case    0:*/		regs.R3 = regs.R31;
		/* 821F4924h case    0:*/		return 0x821F4928;
		  /* 821F4928h */ case    1:  		/* addi R1, R1, 96 */
		/* 821F4928h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F4928h case    1:*/		return 0x821F492C;
		  /* 821F492Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F492Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F492Ch case    2:*/		return 0x821F4930;
		  /* 821F4930h */ case    3:  		/* mtspr LR, R12 */
		/* 821F4930h case    3:*/		regs.LR = regs.R12;
		/* 821F4930h case    3:*/		return 0x821F4934;
		  /* 821F4934h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F4934h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4934h case    4:*/		return 0x821F4938;
		  /* 821F4938h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F4938h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F4938h case    5:*/		return 0x821F493C;
	}
	return 0x821F493C;
} // Block from 821F4924h-821F493Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F493Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F493C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F493C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F493C);
		  /* 821F493Ch */ case    0:  		/* nop */
		/* 821F493Ch case    0:*/		cpu::op::nop();
		/* 821F493Ch case    0:*/		return 0x821F4940;
	}
	return 0x821F4940;
} // Block from 821F493Ch-821F4940h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F4940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4940);
		  /* 821F4940h */ case    0:  		/* mfspr R12, LR */
		/* 821F4940h case    0:*/		regs.R12 = regs.LR;
		/* 821F4940h case    0:*/		return 0x821F4944;
		  /* 821F4944h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821F4944h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F4944h case    1:*/		return 0x821F4948;
		  /* 821F4948h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821F4948h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4948h case    2:*/		return 0x821F494C;
		  /* 821F494Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821F494Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821F494Ch case    3:*/		return 0x821F4950;
		  /* 821F4950h */ case    4:  		/* lwz R10, <#[R3 + 584]> */
		/* 821F4950h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000248) );
		/* 821F4950h case    4:*/		return 0x821F4954;
		  /* 821F4954h */ case    5:  		/* lwz R11, <#[R10 + 4]> */
		/* 821F4954h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821F4954h case    5:*/		return 0x821F4958;
		  /* 821F4958h */ case    6:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821F4958h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821F4958h case    6:*/		return 0x821F495C;
		  /* 821F495Ch */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821F495Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x821F4968;  }
		/* 821F495Ch case    7:*/		return 0x821F4960;
		  /* 821F4960h */ case    8:  		/* li R11, 0 */
		/* 821F4960h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F4960h case    8:*/		return 0x821F4964;
		  /* 821F4964h */ case    9:  		/* b 16 */
		/* 821F4964h case    9:*/		return 0x821F4974;
		/* 821F4964h case    9:*/		return 0x821F4968;
	}
	return 0x821F4968;
} // Block from 821F4940h-821F4968h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F4968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4968);
		  /* 821F4968h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 821F4968h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821F4968h case    0:*/		return 0x821F496C;
		  /* 821F496Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F496Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F496Ch case    1:*/		return 0x821F4970;
		  /* 821F4970h */ case    2:  		/* addi R11, R11, -4 */
		/* 821F4970h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F4970h case    2:*/		return 0x821F4974;
	}
	return 0x821F4974;
} // Block from 821F4968h-821F4974h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4974);
		  /* 821F4974h */ case    0:  		/* lwz R9, <#[R11 + 8]> */
		/* 821F4974h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4974h case    0:*/		return 0x821F4978;
		  /* 821F4978h */ case    1:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 821F4978h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 821F4978h case    1:*/		return 0x821F497C;
		  /* 821F497Ch */ case    2:  		/* add R11, R9, R11 */
		/* 821F497Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821F497Ch case    2:*/		return 0x821F4980;
		  /* 821F4980h */ case    3:  		/* lbz R9, <#[R11]> */
		/* 821F4980h case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4980h case    3:*/		return 0x821F4984;
		  /* 821F4984h */ case    4:  		/* cmplwi CR0, R9, 0 */
		/* 821F4984h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 821F4984h case    4:*/		return 0x821F4988;
		  /* 821F4988h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 821F4988h case    5:*/		if ( regs.CR[0].eq ) { return 0x821F4998;  }
		/* 821F4988h case    5:*/		return 0x821F498C;
		  /* 821F498Ch */ case    6:  		/* lwz R9, <#[R3 + 44]> */
		/* 821F498Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000002C) );
		/* 821F498Ch case    6:*/		return 0x821F4990;
		  /* 821F4990h */ case    7:  		/* addi R9, R9, -2 */
		/* 821F4990h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFE);
		/* 821F4990h case    7:*/		return 0x821F4994;
		  /* 821F4994h */ case    8:  		/* stw R9, <#[R3 + 44]> */
		/* 821F4994h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000002C) );
		/* 821F4994h case    8:*/		return 0x821F4998;
	}
	return 0x821F4998;
} // Block from 821F4974h-821F4998h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F4998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4998);
		  /* 821F4998h */ case    0:  		/* lwz R9, <#[R11 + 4]> */
		/* 821F4998h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4998h case    0:*/		return 0x821F499C;
		  /* 821F499Ch */ case    1:  		/* lwz R31, <#[R11 - 4]> */
		/* 821F499Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 821F499Ch case    1:*/		return 0x821F49A0;
		  /* 821F49A0h */ case    2:  		/* stw R9, <#[R3 + 32]> */
		/* 821F49A0h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000020) );
		/* 821F49A0h case    2:*/		return 0x821F49A4;
		  /* 821F49A4h */ case    3:  		/* lwz R11, <#[R10 + 4]> */
		/* 821F49A4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821F49A4h case    3:*/		return 0x821F49A8;
		  /* 821F49A8h */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821F49A8h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821F49A8h case    4:*/		return 0x821F49AC;
		  /* 821F49ACh */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 821F49ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x821F49B8;  }
		/* 821F49ACh case    5:*/		return 0x821F49B0;
		  /* 821F49B0h */ case    6:  		/* li R4, 0 */
		/* 821F49B0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F49B0h case    6:*/		return 0x821F49B4;
		  /* 821F49B4h */ case    7:  		/* b 16 */
		/* 821F49B4h case    7:*/		return 0x821F49C4;
		/* 821F49B4h case    7:*/		return 0x821F49B8;
	}
	return 0x821F49B8;
} // Block from 821F4998h-821F49B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F49B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F49B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F49B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F49B8);
		  /* 821F49B8h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 821F49B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821F49B8h case    0:*/		return 0x821F49BC;
		  /* 821F49BCh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F49BCh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F49BCh case    1:*/		return 0x821F49C0;
		  /* 821F49C0h */ case    2:  		/* addi R4, R11, -4 */
		/* 821F49C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821F49C0h case    2:*/		return 0x821F49C4;
	}
	return 0x821F49C4;
} // Block from 821F49B8h-821F49C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F49C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F49C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F49C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F49C4);
		  /* 821F49C4h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F49C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F49C4h case    0:*/		return 0x821F49C8;
		  /* 821F49C8h */ case    1:  		/* addic. R11, R11, -1 */
		/* 821F49C8h case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F49C8h case    1:*/		return 0x821F49CC;
		  /* 821F49CCh */ case    2:  		/* stw R11, <#[R4 + 8]> */
		/* 821F49CCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F49CCh case    2:*/		return 0x821F49D0;
		  /* 821F49D0h */ case    3:  		/* bc 4, CR0_EQ, 60 */
		/* 821F49D0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821F4A0C;  }
		/* 821F49D0h case    3:*/		return 0x821F49D4;
		  /* 821F49D4h */ case    4:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821F49D4h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821F49D4h case    4:*/		return 0x821F49D8;
		  /* 821F49D8h */ case    5:  		/* mr R3, R10 */
		/* 821F49D8h case    5:*/		regs.R3 = regs.R10;
		/* 821F49D8h case    5:*/		return 0x821F49DC;
		  /* 821F49DCh */ case    6:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F49DCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F49DCh case    6:*/		return 0x821F49E0;
	}
	return 0x821F49E0;
} // Block from 821F49C4h-821F49E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F49E0h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@PAVResult@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F49E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F49E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F49E0);
		  /* 821F49E0h */ case    0:  		/* lwz R9, <#[R11]> */
		/* 821F49E0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F49E0h case    0:*/		return 0x821F49E4;
		  /* 821F49E4h */ case    1:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821F49E4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821F49E4h case    1:*/		return 0x821F49E8;
		  /* 821F49E8h */ case    2:  		/* stw R9, <#[R10]> */
		/* 821F49E8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F49E8h case    2:*/		return 0x821F49EC;
		  /* 821F49ECh */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F49ECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F49ECh case    3:*/		return 0x821F49F0;
		  /* 821F49F0h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 821F49F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F49F0h case    4:*/		return 0x821F49F4;
		  /* 821F49F4h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F49F4h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F49F4h case    5:*/		return 0x821F49F8;
		  /* 821F49F8h */ case    6:  		/* stw R10, <#[R11]> */
		/* 821F49F8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F49F8h case    6:*/		return 0x821F49FC;
		  /* 821F49FCh */ case    7:  		/* lwz R11, <#[R4 + 12]> */
		/* 821F49FCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821F49FCh case    7:*/		return 0x821F4A00;
		  /* 821F4A00h */ case    8:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821F4A00h case    8:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821F4A00h case    8:*/		return 0x821F4A04;
		  /* 821F4A04h */ case    9:  		/* addi R5, R11, 16 */
		/* 821F4A04h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x10);
		/* 821F4A04h case    9:*/		return 0x821F4A08;
		  /* 821F4A08h */ case   10:  		/* bl -666624 */
		/* 821F4A08h case   10:*/		regs.LR = 0x821F4A0C; return 0x82151E08;
		/* 821F4A08h case   10:*/		return 0x821F4A0C;
	}
	return 0x821F4A0C;
} // Block from 821F49E0h-821F4A0Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A0C);
		  /* 821F4A0Ch */ case    0:  		/* mr R3, R31 */
		/* 821F4A0Ch case    0:*/		regs.R3 = regs.R31;
		/* 821F4A0Ch case    0:*/		return 0x821F4A10;
		  /* 821F4A10h */ case    1:  		/* addi R1, R1, 96 */
		/* 821F4A10h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821F4A10h case    1:*/		return 0x821F4A14;
		  /* 821F4A14h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821F4A14h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821F4A14h case    2:*/		return 0x821F4A18;
		  /* 821F4A18h */ case    3:  		/* mtspr LR, R12 */
		/* 821F4A18h case    3:*/		regs.LR = regs.R12;
		/* 821F4A18h case    3:*/		return 0x821F4A1C;
		  /* 821F4A1Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821F4A1Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821F4A1Ch case    4:*/		return 0x821F4A20;
		  /* 821F4A20h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821F4A20h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821F4A20h case    5:*/		return 0x821F4A24;
	}
	return 0x821F4A24;
} // Block from 821F4A0Ch-821F4A24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A24);
		  /* 821F4A24h */ case    0:  		/* nop */
		/* 821F4A24h case    0:*/		cpu::op::nop();
		/* 821F4A24h case    0:*/		return 0x821F4A28;
	}
	return 0x821F4A28;
} // Block from 821F4A24h-821F4A28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A28);
		  /* 821F4A28h */ case    0:  		/* mfspr R12, LR */
		/* 821F4A28h case    0:*/		regs.R12 = regs.LR;
		/* 821F4A28h case    0:*/		return 0x821F4A2C;
		  /* 821F4A2Ch */ case    1:  		/* bl -1456108 */
		/* 821F4A2Ch case    1:*/		regs.LR = 0x821F4A30; return 0x82091240;
		/* 821F4A2Ch case    1:*/		return 0x821F4A30;
		  /* 821F4A30h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821F4A30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821F4A30h case    2:*/		return 0x821F4A34;
		  /* 821F4A34h */ case    3:  		/* lwz R11, <#[R3 + 56]> */
		/* 821F4A34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 821F4A34h case    3:*/		return 0x821F4A38;
		  /* 821F4A38h */ case    4:  		/* mr R31, R3 */
		/* 821F4A38h case    4:*/		regs.R31 = regs.R3;
		/* 821F4A38h case    4:*/		return 0x821F4A3C;
		  /* 821F4A3Ch */ case    5:  		/* mr R23, R4 */
		/* 821F4A3Ch case    5:*/		regs.R23 = regs.R4;
		/* 821F4A3Ch case    5:*/		return 0x821F4A40;
		  /* 821F4A40h */ case    6:  		/* mr R30, R5 */
		/* 821F4A40h case    6:*/		regs.R30 = regs.R5;
		/* 821F4A40h case    6:*/		return 0x821F4A44;
		  /* 821F4A44h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 821F4A44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4A44h case    7:*/		return 0x821F4A48;
		  /* 821F4A48h */ case    8:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 821F4A48h case    8:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 821F4A48h case    8:*/		return 0x821F4A4C;
		  /* 821F4A4Ch */ case    9:  		/* bc 12, CR0_EQ, 60 */
		/* 821F4A4Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821F4A88;  }
		/* 821F4A4Ch case    9:*/		return 0x821F4A50;
		  /* 821F4A50h */ case   10:  		/* lwz R11, <#[R3 + 584]> */
		/* 821F4A50h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000248) );
		/* 821F4A50h case   10:*/		return 0x821F4A54;
		  /* 821F4A54h */ case   11:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F4A54h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4A54h case   11:*/		return 0x821F4A58;
		  /* 821F4A58h */ case   12:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821F4A58h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821F4A58h case   12:*/		return 0x821F4A5C;
		  /* 821F4A5Ch */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 821F4A5Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x821F4A68;  }
		/* 821F4A5Ch case   13:*/		return 0x821F4A60;
		  /* 821F4A60h */ case   14:  		/* li R11, 0 */
		/* 821F4A60h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F4A60h case   14:*/		return 0x821F4A64;
		  /* 821F4A64h */ case   15:  		/* b 16 */
		/* 821F4A64h case   15:*/		return 0x821F4A74;
		/* 821F4A64h case   15:*/		return 0x821F4A68;
	}
	return 0x821F4A68;
} // Block from 821F4A28h-821F4A68h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A68);
		  /* 821F4A68h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821F4A68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4A68h case    0:*/		return 0x821F4A6C;
		  /* 821F4A6Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821F4A6Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821F4A6Ch case    1:*/		return 0x821F4A70;
		  /* 821F4A70h */ case    2:  		/* addi R11, R11, -4 */
		/* 821F4A70h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821F4A70h case    2:*/		return 0x821F4A74;
	}
	return 0x821F4A74;
} // Block from 821F4A68h-821F4A74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A74);
		  /* 821F4A74h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821F4A74h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4A74h case    0:*/		return 0x821F4A78;
		  /* 821F4A78h */ case    1:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 821F4A78h case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 821F4A78h case    1:*/		return 0x821F4A7C;
		  /* 821F4A7Ch */ case    2:  		/* add R11, R10, R11 */
		/* 821F4A7Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F4A7Ch case    2:*/		return 0x821F4A80;
		  /* 821F4A80h */ case    3:  		/* lwz R26, <#[R11 - 4]> */
		/* 821F4A80h case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 821F4A80h case    3:*/		return 0x821F4A84;
		  /* 821F4A84h */ case    4:  		/* b 16 */
		/* 821F4A84h case    4:*/		return 0x821F4A94;
		/* 821F4A84h case    4:*/		return 0x821F4A88;
	}
	return 0x821F4A88;
} // Block from 821F4A74h-821F4A88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A88);
		  /* 821F4A88h */ case    0:  		/* mr R3, R31 */
		/* 821F4A88h case    0:*/		regs.R3 = regs.R31;
		/* 821F4A88h case    0:*/		return 0x821F4A8C;
		  /* 821F4A8Ch */ case    1:  		/* bl -27412 */
		/* 821F4A8Ch case    1:*/		regs.LR = 0x821F4A90; return 0x821EDF78;
		/* 821F4A8Ch case    1:*/		return 0x821F4A90;
		  /* 821F4A90h */ case    2:  		/* mr R26, R3 */
		/* 821F4A90h case    2:*/		regs.R26 = regs.R3;
		/* 821F4A90h case    2:*/		return 0x821F4A94;
	}
	return 0x821F4A94;
} // Block from 821F4A88h-821F4A94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4A94);
		  /* 821F4A94h */ case    0:  		/* mr R5, R31 */
		/* 821F4A94h case    0:*/		regs.R5 = regs.R31;
		/* 821F4A94h case    0:*/		return 0x821F4A98;
		  /* 821F4A98h */ case    1:  		/* lwz R3, <#[R31 + 564]> */
		/* 821F4A98h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4A98h case    1:*/		return 0x821F4A9C;
		  /* 821F4A9Ch */ case    2:  		/* mr R4, R26 */
		/* 821F4A9Ch case    2:*/		regs.R4 = regs.R26;
		/* 821F4A9Ch case    2:*/		return 0x821F4AA0;
		  /* 821F4AA0h */ case    3:  		/* bl 241728 */
		/* 821F4AA0h case    3:*/		regs.LR = 0x821F4AA4; return 0x8222FAE0;
		/* 821F4AA0h case    3:*/		return 0x821F4AA4;
		  /* 821F4AA4h */ case    4:  		/* lwz R10, <#[R31 + 556]> */
		/* 821F4AA4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000022C) );
		/* 821F4AA4h case    4:*/		return 0x821F4AA8;
		  /* 821F4AA8h */ case    5:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F4AA8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4AA8h case    5:*/		return 0x821F4AAC;
		  /* 821F4AACh */ case    6:  		/* li R8, 0 */
		/* 821F4AACh case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821F4AACh case    6:*/		return 0x821F4AB0;
	}
	return 0x821F4AB0;
} // Block from 821F4A94h-821F4AB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F4AB0h
// Function '?MakeInstr_V_MUL@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4AB0);
		  /* 821F4AB0h */ case    0:  		/* addi R10, R10, 1 */
		/* 821F4AB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F4AB0h case    0:*/		return 0x821F4AB4;
		  /* 821F4AB4h */ case    1:  		/* li R7, 0 */
		/* 821F4AB4h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F4AB4h case    1:*/		return 0x821F4AB8;
		  /* 821F4AB8h */ case    2:  		/* stw R10, <#[R31 + 556]> */
		/* 821F4AB8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000022C) );
		/* 821F4AB8h case    2:*/		return 0x821F4ABC;
		  /* 821F4ABCh */ case    3:  		/* li R6, 117 */
		/* 821F4ABCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821F4ABCh case    3:*/		return 0x821F4AC0;
		  /* 821F4AC0h */ case    4:  		/* mr R3, R31 */
		/* 821F4AC0h case    4:*/		regs.R3 = regs.R31;
		/* 821F4AC0h case    4:*/		return 0x821F4AC4;
		  /* 821F4AC4h */ case    5:  		/* lwz R10, <#[R31 + 44]> */
		/* 821F4AC4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F4AC4h case    5:*/		return 0x821F4AC8;
		  /* 821F4AC8h */ case    6:  		/* oris R10, R10, 128 */
		/* 821F4AC8h case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x80);
		/* 821F4AC8h case    6:*/		return 0x821F4ACC;
		  /* 821F4ACCh */ case    7:  		/* stw R10, <#[R31 + 44]> */
		/* 821F4ACCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F4ACCh case    7:*/		return 0x821F4AD0;
		  /* 821F4AD0h */ case    8:  		/* lwz R10, <#[R11 + 68]> */
		/* 821F4AD0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 821F4AD0h case    8:*/		return 0x821F4AD4;
		  /* 821F4AD4h */ case    9:  		/* oris R10, R10, 32768 */
		/* 821F4AD4h case    9:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8000);
		/* 821F4AD4h case    9:*/		return 0x821F4AD8;
		  /* 821F4AD8h */ case   10:  		/* stw R10, <#[R11 + 68]> */
		/* 821F4AD8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 821F4AD8h case   10:*/		return 0x821F4ADC;
		  /* 821F4ADCh */ case   11:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F4ADCh case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4ADCh case   11:*/		return 0x821F4AE0;
		  /* 821F4AE0h */ case   12:  		/* addi R5, R4, 24 */
		/* 821F4AE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821F4AE0h case   12:*/		return 0x821F4AE4;
		  /* 821F4AE4h */ case   13:  		/* bl 196276 */
		/* 821F4AE4h case   13:*/		regs.LR = 0x821F4AE8; return 0x82224998;
		/* 821F4AE4h case   13:*/		return 0x821F4AE8;
		  /* 821F4AE8h */ case   14:  		/* mr R28, R3 */
		/* 821F4AE8h case   14:*/		regs.R28 = regs.R3;
		/* 821F4AE8h case   14:*/		return 0x821F4AEC;
		  /* 821F4AECh */ case   15:  		/* li R6, 0 */
		/* 821F4AECh case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F4AECh case   15:*/		return 0x821F4AF0;
		  /* 821F4AF0h */ case   16:  		/* li R5, 0 */
		/* 821F4AF0h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F4AF0h case   16:*/		return 0x821F4AF4;
		  /* 821F4AF4h */ case   17:  		/* li R4, 117 */
		/* 821F4AF4h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821F4AF4h case   17:*/		return 0x821F4AF8;
		  /* 821F4AF8h */ case   18:  		/* mr R3, R31 */
		/* 821F4AF8h case   18:*/		regs.R3 = regs.R31;
		/* 821F4AF8h case   18:*/		return 0x821F4AFC;
		  /* 821F4AFCh */ case   19:  		/* lwz R11, <#[R28 + 8]> */
		/* 821F4AFCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4AFCh case   19:*/		return 0x821F4B00;
		  /* 821F4B00h */ case   20:  		/* oris R11, R11, 512 */
		/* 821F4B00h case   20:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4B00h case   20:*/		return 0x821F4B04;
		  /* 821F4B04h */ case   21:  		/* stw R11, <#[R28 + 8]> */
		/* 821F4B04h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4B04h case   21:*/		return 0x821F4B08;
		  /* 821F4B08h */ case   22:  		/* bl -591576 */
		/* 821F4B08h case   22:*/		regs.LR = 0x821F4B0C; return 0x82164430;
		/* 821F4B08h case   22:*/		return 0x821F4B0C;
		  /* 821F4B0Ch */ case   23:  		/* addi R11, R28, -16 */
		/* 821F4B0Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFF0);
		/* 821F4B0Ch case   23:*/		return 0x821F4B10;
		  /* 821F4B10h */ case   24:  		/* li R10, 2 */
		/* 821F4B10h case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 821F4B10h case   24:*/		return 0x821F4B14;
		  /* 821F4B14h */ case   25:  		/* add R11, R3, R11 */
		/* 821F4B14h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821F4B14h case   25:*/		return 0x821F4B18;
		  /* 821F4B18h */ case   26:  		/* li R8, 0 */
		/* 821F4B18h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821F4B18h case   26:*/		return 0x821F4B1C;
		  /* 821F4B1Ch */ case   27:  		/* li R7, 0 */
		/* 821F4B1Ch case   27:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F4B1Ch case   27:*/		return 0x821F4B20;
		  /* 821F4B20h */ case   28:  		/* li R6, 117 */
		/* 821F4B20h case   28:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821F4B20h case   28:*/		return 0x821F4B24;
		  /* 821F4B24h */ case   29:  		/* mr R3, R31 */
		/* 821F4B24h case   29:*/		regs.R3 = regs.R31;
		/* 821F4B24h case   29:*/		return 0x821F4B28;
		  /* 821F4B28h */ case   30:  		/* lwz R9, <#[R11]> */
		/* 821F4B28h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4B28h case   30:*/		return 0x821F4B2C;
		  /* 821F4B2Ch */ case   31:  		/* stw R10, <#[R11 + 4]> */
		/* 821F4B2Ch case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4B2Ch case   31:*/		return 0x821F4B30;
		  /* 821F4B30h */ case   32:  		/* ori R10, R9, 7 */
		/* 821F4B30h case   32:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R9,0x7);
		/* 821F4B30h case   32:*/		return 0x821F4B34;
		  /* 821F4B34h */ case   33:  		/* stw R10, <#[R11]> */
		/* 821F4B34h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4B34h case   33:*/		return 0x821F4B38;
		  /* 821F4B38h */ case   34:  		/* lwz R10, <#[R31 + 556]> */
		/* 821F4B38h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000022C) );
		/* 821F4B38h case   34:*/		return 0x821F4B3C;
		  /* 821F4B3Ch */ case   35:  		/* stw R10, <#[R11 + 8]> */
		/* 821F4B3Ch case   35:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4B3Ch case   35:*/		return 0x821F4B40;
		  /* 821F4B40h */ case   36:  		/* stw R30, <#[R11 + 12]> */
		/* 821F4B40h case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F4B40h case   36:*/		return 0x821F4B44;
		  /* 821F4B44h */ case   37:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F4B44h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4B44h case   37:*/		return 0x821F4B48;
		  /* 821F4B48h */ case   38:  		/* addi R5, R4, 24 */
		/* 821F4B48h case   38:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821F4B48h case   38:*/		return 0x821F4B4C;
		  /* 821F4B4Ch */ case   39:  		/* bl 196172 */
		/* 821F4B4Ch case   39:*/		regs.LR = 0x821F4B50; return 0x82224998;
		/* 821F4B4Ch case   39:*/		return 0x821F4B50;
		  /* 821F4B50h */ case   40:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F4B50h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4B50h case   40:*/		return 0x821F4B54;
		  /* 821F4B54h */ case   41:  		/* mr R5, R31 */
		/* 821F4B54h case   41:*/		regs.R5 = regs.R31;
		/* 821F4B54h case   41:*/		return 0x821F4B58;
		  /* 821F4B58h */ case   42:  		/* oris R11, R11, 512 */
		/* 821F4B58h case   42:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4B58h case   42:*/		return 0x821F4B5C;
		  /* 821F4B5Ch */ case   43:  		/* mr R4, R28 */
		/* 821F4B5Ch case   43:*/		regs.R4 = regs.R28;
		/* 821F4B5Ch case   43:*/		return 0x821F4B60;
		  /* 821F4B60h */ case   44:  		/* stw R11, <#[R3 + 8]> */
		/* 821F4B60h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4B60h case   44:*/		return 0x821F4B64;
		  /* 821F4B64h */ case   45:  		/* bl -510164 */
		/* 821F4B64h case   45:*/		regs.LR = 0x821F4B68; return 0x82178290;
		/* 821F4B64h case   45:*/		return 0x821F4B68;
		  /* 821F4B68h */ case   46:  		/* lwz R11, <#[R31 + 56]> */
		/* 821F4B68h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 821F4B68h case   46:*/		return 0x821F4B6C;
		  /* 821F4B6Ch */ case   47:  		/* li R24, 1 */
		/* 821F4B6Ch case   47:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 821F4B6Ch case   47:*/		return 0x821F4B70;
		  /* 821F4B70h */ case   48:  		/* cmplwi CR6, R11, 0 */
		/* 821F4B70h case   48:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F4B70h case   48:*/		return 0x821F4B74;
		  /* 821F4B74h */ case   49:  		/* bc 12, CR6_EQ, 576 */
		/* 821F4B74h case   49:*/		if ( regs.CR[6].eq ) { return 0x821F4DB4;  }
		/* 821F4B74h case   49:*/		return 0x821F4B78;
		  /* 821F4B78h */ case   50:  		/* lwz R11, <#[R11]> */
		/* 821F4B78h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4B78h case   50:*/		return 0x821F4B7C;
		  /* 821F4B7Ch */ case   51:  		/* andi. R10, R11, 1280 */
		/* 821F4B7Ch case   51:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x500);
		/* 821F4B7Ch case   51:*/		return 0x821F4B80;
	}
	return 0x821F4B80;
} // Block from 821F4AB0h-821F4B80h (52 instructions)

//////////////////////////////////////////////////////
// Block at 821F4B80h
// Function '?MakeInstr_V_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4B80);
		  /* 821F4B80h */ case    0:  		/* cmplwi CR0, R10, 0 */
		/* 821F4B80h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 821F4B80h case    0:*/		return 0x821F4B84;
		  /* 821F4B84h */ case    1:  		/* bc 12, CR0_EQ, 560 */
		/* 821F4B84h case    1:*/		if ( regs.CR[0].eq ) { return 0x821F4DB4;  }
		/* 821F4B84h case    1:*/		return 0x821F4B88;
		  /* 821F4B88h */ case    2:  		/* lwz R25, <#[R31 + 32]> */
		/* 821F4B88h case    2:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x00000020) );
		/* 821F4B88h case    2:*/		return 0x821F4B8C;
		  /* 821F4B8Ch */ case    3:  		/* rlwinm. R11, R11, 0, 22, 22 */
		/* 821F4B8Ch case    3:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R11);
		/* 821F4B8Ch case    3:*/		return 0x821F4B90;
		  /* 821F4B90h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 821F4B90h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821F4B9C;  }
		/* 821F4B90h case    4:*/		return 0x821F4B94;
		  /* 821F4B94h */ case    5:  		/* mr R3, R31 */
		/* 821F4B94h case    5:*/		regs.R3 = regs.R31;
		/* 821F4B94h case    5:*/		return 0x821F4B98;
		  /* 821F4B98h */ case    6:  		/* bl -11816 */
		/* 821F4B98h case    6:*/		regs.LR = 0x821F4B9C; return 0x821F1D70;
		/* 821F4B98h case    6:*/		return 0x821F4B9C;
	}
	return 0x821F4B9C;
} // Block from 821F4B80h-821F4B9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F4B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4B9C);
		  /* 821F4B9Ch */ case    0:  		/* mr R3, R31 */
		/* 821F4B9Ch case    0:*/		regs.R3 = regs.R31;
		/* 821F4B9Ch case    0:*/		return 0x821F4BA0;
		  /* 821F4BA0h */ case    1:  		/* bl -27688 */
		/* 821F4BA0h case    1:*/		regs.LR = 0x821F4BA4; return 0x821EDF78;
		/* 821F4BA0h case    1:*/		return 0x821F4BA4;
		  /* 821F4BA4h */ case    2:  		/* lwz R11, <#[R3 + 68]> */
		/* 821F4BA4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 821F4BA4h case    2:*/		return 0x821F4BA8;
		  /* 821F4BA8h */ case    3:  		/* lwz R10, <#[R3 + 48]> */
		/* 821F4BA8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 821F4BA8h case    3:*/		return 0x821F4BAC;
		  /* 821F4BACh */ case    4:  		/* mr R4, R3 */
		/* 821F4BACh case    4:*/		regs.R4 = regs.R3;
		/* 821F4BACh case    4:*/		return 0x821F4BB0;
		  /* 821F4BB0h */ case    5:  		/* oris R11, R11, 16384 */
		/* 821F4BB0h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 821F4BB0h case    5:*/		return 0x821F4BB4;
		  /* 821F4BB4h */ case    6:  		/* oris R10, R10, 4096 */
		/* 821F4BB4h case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x1000);
		/* 821F4BB4h case    6:*/		return 0x821F4BB8;
		  /* 821F4BB8h */ case    7:  		/* stw R11, <#[R3 + 68]> */
		/* 821F4BB8h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000044) );
		/* 821F4BB8h case    7:*/		return 0x821F4BBC;
		  /* 821F4BBCh */ case    8:  		/* mr R5, R31 */
		/* 821F4BBCh case    8:*/		regs.R5 = regs.R31;
		/* 821F4BBCh case    8:*/		return 0x821F4BC0;
		  /* 821F4BC0h */ case    9:  		/* stw R10, <#[R3 + 48]> */
		/* 821F4BC0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 821F4BC0h case    9:*/		return 0x821F4BC4;
		  /* 821F4BC4h */ case   10:  		/* mr R30, R3 */
		/* 821F4BC4h case   10:*/		regs.R30 = regs.R3;
		/* 821F4BC4h case   10:*/		return 0x821F4BC8;
		  /* 821F4BC8h */ case   11:  		/* lwz R3, <#[R31 + 564]> */
		/* 821F4BC8h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4BC8h case   11:*/		return 0x821F4BCC;
		  /* 821F4BCCh */ case   12:  		/* bl 241428 */
		/* 821F4BCCh case   12:*/		regs.LR = 0x821F4BD0; return 0x8222FAE0;
		/* 821F4BCCh case   12:*/		return 0x821F4BD0;
		  /* 821F4BD0h */ case   13:  		/* mr R3, R31 */
		/* 821F4BD0h case   13:*/		regs.R3 = regs.R31;
		/* 821F4BD0h case   13:*/		return 0x821F4BD4;
		  /* 821F4BD4h */ case   14:  		/* bl -27740 */
		/* 821F4BD4h case   14:*/		regs.LR = 0x821F4BD8; return 0x821EDF78;
		/* 821F4BD4h case   14:*/		return 0x821F4BD8;
		  /* 821F4BD8h */ case   15:  		/* mr R29, R3 */
		/* 821F4BD8h case   15:*/		regs.R29 = regs.R3;
		/* 821F4BD8h case   15:*/		return 0x821F4BDC;
		  /* 821F4BDCh */ case   16:  		/* mr R3, R30 */
		/* 821F4BDCh case   16:*/		regs.R3 = regs.R30;
		/* 821F4BDCh case   16:*/		return 0x821F4BE0;
		  /* 821F4BE0h */ case   17:  		/* mr R5, R31 */
		/* 821F4BE0h case   17:*/		regs.R5 = regs.R31;
		/* 821F4BE0h case   17:*/		return 0x821F4BE4;
		  /* 821F4BE4h */ case   18:  		/* mr R4, R29 */
		/* 821F4BE4h case   18:*/		regs.R4 = regs.R29;
		/* 821F4BE4h case   18:*/		return 0x821F4BE8;
		  /* 821F4BE8h */ case   19:  		/* lwz R11, <#[R29 + 48]> */
		/* 821F4BE8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821F4BE8h case   19:*/		return 0x821F4BEC;
		  /* 821F4BECh */ case   20:  		/* oris R11, R11, 4096 */
		/* 821F4BECh case   20:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 821F4BECh case   20:*/		return 0x821F4BF0;
		  /* 821F4BF0h */ case   21:  		/* stw R11, <#[R29 + 48]> */
		/* 821F4BF0h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821F4BF0h case   21:*/		return 0x821F4BF4;
		  /* 821F4BF4h */ case   22:  		/* bl 241388 */
		/* 821F4BF4h case   22:*/		regs.LR = 0x821F4BF8; return 0x8222FAE0;
		/* 821F4BF4h case   22:*/		return 0x821F4BF8;
		  /* 821F4BF8h */ case   23:  		/* mr R3, R29 */
		/* 821F4BF8h case   23:*/		regs.R3 = regs.R29;
		/* 821F4BF8h case   23:*/		return 0x821F4BFC;
		  /* 821F4BFCh */ case   24:  		/* mr R5, R31 */
		/* 821F4BFCh case   24:*/		regs.R5 = regs.R31;
		/* 821F4BFCh case   24:*/		return 0x821F4C00;
		  /* 821F4C00h */ case   25:  		/* mr R4, R26 */
		/* 821F4C00h case   25:*/		regs.R4 = regs.R26;
		/* 821F4C00h case   25:*/		return 0x821F4C04;
		  /* 821F4C04h */ case   26:  		/* bl 241372 */
		/* 821F4C04h case   26:*/		regs.LR = 0x821F4C08; return 0x8222FAE0;
		/* 821F4C04h case   26:*/		return 0x821F4C08;
		  /* 821F4C08h */ case   27:  		/* addi R27, R30, 32 */
		/* 821F4C08h case   27:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R30,0x20);
		/* 821F4C08h case   27:*/		return 0x821F4C0C;
		  /* 821F4C0Ch */ case   28:  		/* mr R4, R30 */
		/* 821F4C0Ch case   28:*/		regs.R4 = regs.R30;
		/* 821F4C0Ch case   28:*/		return 0x821F4C10;
		  /* 821F4C10h */ case   29:  		/* mr R5, R27 */
		/* 821F4C10h case   29:*/		regs.R5 = regs.R27;
		/* 821F4C10h case   29:*/		return 0x821F4C14;
		  /* 821F4C14h */ case   30:  		/* li R8, 0 */
		/* 821F4C14h case   30:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821F4C14h case   30:*/		return 0x821F4C18;
		  /* 821F4C18h */ case   31:  		/* li R7, 0 */
		/* 821F4C18h case   31:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F4C18h case   31:*/		return 0x821F4C1C;
		  /* 821F4C1Ch */ case   32:  		/* li R6, 117 */
		/* 821F4C1Ch case   32:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821F4C1Ch case   32:*/		return 0x821F4C20;
		  /* 821F4C20h */ case   33:  		/* mr R3, R31 */
		/* 821F4C20h case   33:*/		regs.R3 = regs.R31;
		/* 821F4C20h case   33:*/		return 0x821F4C24;
		  /* 821F4C24h */ case   34:  		/* bl 195956 */
		/* 821F4C24h case   34:*/		regs.LR = 0x821F4C28; return 0x82224998;
		/* 821F4C24h case   34:*/		return 0x821F4C28;
		  /* 821F4C28h */ case   35:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F4C28h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4C28h case   35:*/		return 0x821F4C2C;
		  /* 821F4C2Ch */ case   36:  		/* mr R22, R3 */
		/* 821F4C2Ch case   36:*/		regs.R22 = regs.R3;
		/* 821F4C2Ch case   36:*/		return 0x821F4C30;
		  /* 821F4C30h */ case   37:  		/* oris R11, R11, 512 */
		/* 821F4C30h case   37:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4C30h case   37:*/		return 0x821F4C34;
		  /* 821F4C34h */ case   38:  		/* li R8, 0 */
		/* 821F4C34h case   38:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821F4C34h case   38:*/		return 0x821F4C38;
		  /* 821F4C38h */ case   39:  		/* li R7, 0 */
		/* 821F4C38h case   39:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F4C38h case   39:*/		return 0x821F4C3C;
		  /* 821F4C3Ch */ case   40:  		/* li R6, 117 */
		/* 821F4C3Ch case   40:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821F4C3Ch case   40:*/		return 0x821F4C40;
		  /* 821F4C40h */ case   41:  		/* stw R11, <#[R22 + 8]> */
		/* 821F4C40h case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 821F4C40h case   41:*/		return 0x821F4C44;
		  /* 821F4C44h */ case   42:  		/* mr R5, R27 */
		/* 821F4C44h case   42:*/		regs.R5 = regs.R27;
		/* 821F4C44h case   42:*/		return 0x821F4C48;
		  /* 821F4C48h */ case   43:  		/* mr R4, R30 */
		/* 821F4C48h case   43:*/		regs.R4 = regs.R30;
		/* 821F4C48h case   43:*/		return 0x821F4C4C;
		  /* 821F4C4Ch */ case   44:  		/* mr R3, R31 */
		/* 821F4C4Ch case   44:*/		regs.R3 = regs.R31;
		/* 821F4C4Ch case   44:*/		return 0x821F4C50;
	}
	return 0x821F4C50;
} // Block from 821F4B9Ch-821F4C50h (45 instructions)

//////////////////////////////////////////////////////
// Block at 821F4C50h
// Function '?MakeInstr_V_MIN@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4C50);
		  /* 821F4C50h */ case    0:  		/* bl 195912 */
		/* 821F4C50h case    0:*/		regs.LR = 0x821F4C54; return 0x82224998;
		/* 821F4C50h case    0:*/		return 0x821F4C54;
		  /* 821F4C54h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F4C54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4C54h case    1:*/		return 0x821F4C58;
		  /* 821F4C58h */ case    2:  		/* mr R5, R31 */
		/* 821F4C58h case    2:*/		regs.R5 = regs.R31;
		/* 821F4C58h case    2:*/		return 0x821F4C5C;
		  /* 821F4C5Ch */ case    3:  		/* oris R11, R11, 512 */
		/* 821F4C5Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4C5Ch case    3:*/		return 0x821F4C60;
		  /* 821F4C60h */ case    4:  		/* mr R4, R22 */
		/* 821F4C60h case    4:*/		regs.R4 = regs.R22;
		/* 821F4C60h case    4:*/		return 0x821F4C64;
		  /* 821F4C64h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 821F4C64h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4C64h case    5:*/		return 0x821F4C68;
		  /* 821F4C68h */ case    6:  		/* bl -510424 */
		/* 821F4C68h case    6:*/		regs.LR = 0x821F4C6C; return 0x82178290;
		/* 821F4C68h case    6:*/		return 0x821F4C6C;
		  /* 821F4C6Ch */ case    7:  		/* addi R30, R29, 32 */
		/* 821F4C6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R29,0x20);
		/* 821F4C6Ch case    7:*/		return 0x821F4C70;
		  /* 821F4C70h */ case    8:  		/* mr R4, R29 */
		/* 821F4C70h case    8:*/		regs.R4 = regs.R29;
		/* 821F4C70h case    8:*/		return 0x821F4C74;
		  /* 821F4C74h */ case    9:  		/* mr R5, R30 */
		/* 821F4C74h case    9:*/		regs.R5 = regs.R30;
		/* 821F4C74h case    9:*/		return 0x821F4C78;
		  /* 821F4C78h */ case   10:  		/* li R8, 0 */
		/* 821F4C78h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821F4C78h case   10:*/		return 0x821F4C7C;
		  /* 821F4C7Ch */ case   11:  		/* li R7, 0 */
		/* 821F4C7Ch case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F4C7Ch case   11:*/		return 0x821F4C80;
		  /* 821F4C80h */ case   12:  		/* li R6, 117 */
		/* 821F4C80h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821F4C80h case   12:*/		return 0x821F4C84;
		  /* 821F4C84h */ case   13:  		/* mr R3, R31 */
		/* 821F4C84h case   13:*/		regs.R3 = regs.R31;
		/* 821F4C84h case   13:*/		return 0x821F4C88;
		  /* 821F4C88h */ case   14:  		/* bl 195856 */
		/* 821F4C88h case   14:*/		regs.LR = 0x821F4C8C; return 0x82224998;
		/* 821F4C88h case   14:*/		return 0x821F4C8C;
		  /* 821F4C8Ch */ case   15:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F4C8Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4C8Ch case   15:*/		return 0x821F4C90;
		  /* 821F4C90h */ case   16:  		/* mr R27, R3 */
		/* 821F4C90h case   16:*/		regs.R27 = regs.R3;
		/* 821F4C90h case   16:*/		return 0x821F4C94;
		  /* 821F4C94h */ case   17:  		/* oris R11, R11, 512 */
		/* 821F4C94h case   17:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4C94h case   17:*/		return 0x821F4C98;
		  /* 821F4C98h */ case   18:  		/* li R8, 0 */
		/* 821F4C98h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821F4C98h case   18:*/		return 0x821F4C9C;
		  /* 821F4C9Ch */ case   19:  		/* li R7, 0 */
		/* 821F4C9Ch case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821F4C9Ch case   19:*/		return 0x821F4CA0;
		  /* 821F4CA0h */ case   20:  		/* li R6, 117 */
		/* 821F4CA0h case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821F4CA0h case   20:*/		return 0x821F4CA4;
		  /* 821F4CA4h */ case   21:  		/* stw R11, <#[R27 + 8]> */
		/* 821F4CA4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821F4CA4h case   21:*/		return 0x821F4CA8;
		  /* 821F4CA8h */ case   22:  		/* mr R5, R30 */
		/* 821F4CA8h case   22:*/		regs.R5 = regs.R30;
		/* 821F4CA8h case   22:*/		return 0x821F4CAC;
		  /* 821F4CACh */ case   23:  		/* mr R4, R29 */
		/* 821F4CACh case   23:*/		regs.R4 = regs.R29;
		/* 821F4CACh case   23:*/		return 0x821F4CB0;
		  /* 821F4CB0h */ case   24:  		/* mr R3, R31 */
		/* 821F4CB0h case   24:*/		regs.R3 = regs.R31;
		/* 821F4CB0h case   24:*/		return 0x821F4CB4;
		  /* 821F4CB4h */ case   25:  		/* bl 195812 */
		/* 821F4CB4h case   25:*/		regs.LR = 0x821F4CB8; return 0x82224998;
		/* 821F4CB4h case   25:*/		return 0x821F4CB8;
		  /* 821F4CB8h */ case   26:  		/* lwz R11, <#[R3 + 8]> */
		/* 821F4CB8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4CB8h case   26:*/		return 0x821F4CBC;
		  /* 821F4CBCh */ case   27:  		/* mr R5, R31 */
		/* 821F4CBCh case   27:*/		regs.R5 = regs.R31;
		/* 821F4CBCh case   27:*/		return 0x821F4CC0;
		  /* 821F4CC0h */ case   28:  		/* oris R11, R11, 512 */
		/* 821F4CC0h case   28:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4CC0h case   28:*/		return 0x821F4CC4;
		  /* 821F4CC4h */ case   29:  		/* mr R4, R27 */
		/* 821F4CC4h case   29:*/		regs.R4 = regs.R27;
		/* 821F4CC4h case   29:*/		return 0x821F4CC8;
		  /* 821F4CC8h */ case   30:  		/* stw R11, <#[R3 + 8]> */
		/* 821F4CC8h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4CC8h case   30:*/		return 0x821F4CCC;
		  /* 821F4CCCh */ case   31:  		/* bl -510524 */
		/* 821F4CCCh case   31:*/		regs.LR = 0x821F4CD0; return 0x82178290;
		/* 821F4CCCh case   31:*/		return 0x821F4CD0;
		  /* 821F4CD0h */ case   32:  		/* mr R6, R23 */
		/* 821F4CD0h case   32:*/		regs.R6 = regs.R23;
		/* 821F4CD0h case   32:*/		return 0x821F4CD4;
		  /* 821F4CD4h */ case   33:  		/* mr R5, R28 */
		/* 821F4CD4h case   33:*/		regs.R5 = regs.R28;
		/* 821F4CD4h case   33:*/		return 0x821F4CD8;
		  /* 821F4CD8h */ case   34:  		/* li R4, 0 */
		/* 821F4CD8h case   34:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821F4CD8h case   34:*/		return 0x821F4CDC;
		  /* 821F4CDCh */ case   35:  		/* mr R3, R31 */
		/* 821F4CDCh case   35:*/		regs.R3 = regs.R31;
		/* 821F4CDCh case   35:*/		return 0x821F4CE0;
		  /* 821F4CE0h */ case   36:  		/* bl -6392 */
		/* 821F4CE0h case   36:*/		regs.LR = 0x821F4CE4; return 0x821F33E8;
		/* 821F4CE0h case   36:*/		return 0x821F4CE4;
		  /* 821F4CE4h */ case   37:  		/* mr R30, R3 */
		/* 821F4CE4h case   37:*/		regs.R30 = regs.R3;
		/* 821F4CE4h case   37:*/		return 0x821F4CE8;
		  /* 821F4CE8h */ case   38:  		/* mr R4, R3 */
		/* 821F4CE8h case   38:*/		regs.R4 = regs.R3;
		/* 821F4CE8h case   38:*/		return 0x821F4CEC;
		  /* 821F4CECh */ case   39:  		/* li R5, 7 */
		/* 821F4CECh case   39:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 821F4CECh case   39:*/		return 0x821F4CF0;
		  /* 821F4CF0h */ case   40:  		/* mr R3, R31 */
		/* 821F4CF0h case   40:*/		regs.R3 = regs.R31;
		/* 821F4CF0h case   40:*/		return 0x821F4CF4;
		  /* 821F4CF4h */ case   41:  		/* bl -542116 */
		/* 821F4CF4h case   41:*/		regs.LR = 0x821F4CF8; return 0x82170750;
		/* 821F4CF4h case   41:*/		return 0x821F4CF8;
		  /* 821F4CF8h */ case   42:  		/* mr R4, R3 */
		/* 821F4CF8h case   42:*/		regs.R4 = regs.R3;
		/* 821F4CF8h case   42:*/		return 0x821F4CFC;
		  /* 821F4CFCh */ case   43:  		/* mr R3, R28 */
		/* 821F4CFCh case   43:*/		regs.R3 = regs.R28;
		/* 821F4CFCh case   43:*/		return 0x821F4D00;
		  /* 821F4D00h */ case   44:  		/* bl -510776 */
		/* 821F4D00h case   44:*/		regs.LR = 0x821F4D04; return 0x821781C8;
		/* 821F4D00h case   44:*/		return 0x821F4D04;
		  /* 821F4D04h */ case   45:  		/* lwz R11, <#[R28 + 8]> */
		/* 821F4D04h case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4D04h case   45:*/		return 0x821F4D08;
		  /* 821F4D08h */ case   46:  		/* mr R4, R30 */
		/* 821F4D08h case   46:*/		regs.R4 = regs.R30;
		/* 821F4D08h case   46:*/		return 0x821F4D0C;
		  /* 821F4D0Ch */ case   47:  		/* rlwimi R11, R24, 17, 13, 14 */
		/* 821F4D0Ch case   47:*/		cpu::op::rlwimi<0,17,13,14>(regs,&regs.R11,regs.R24);
		/* 821F4D0Ch case   47:*/		return 0x821F4D10;
		  /* 821F4D10h */ case   48:  		/* li R5, 7 */
		/* 821F4D10h case   48:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 821F4D10h case   48:*/		return 0x821F4D14;
		  /* 821F4D14h */ case   49:  		/* stw R11, <#[R28 + 8]> */
		/* 821F4D14h case   49:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821F4D14h case   49:*/		return 0x821F4D18;
		  /* 821F4D18h */ case   50:  		/* mr R3, R31 */
		/* 821F4D18h case   50:*/		regs.R3 = regs.R31;
		/* 821F4D18h case   50:*/		return 0x821F4D1C;
		  /* 821F4D1Ch */ case   51:  		/* lwz R11, <#[R31 + 564]> */
		/* 821F4D1Ch case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4D1Ch case   51:*/		return 0x821F4D20;
	}
	return 0x821F4D20;
} // Block from 821F4C50h-821F4D20h (52 instructions)

//////////////////////////////////////////////////////
// Block at 821F4D20h
// Function '?MakeInstr_V_CNDGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVDependency@2@VResult@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4D20);
		  /* 821F4D20h */ case    0:  		/* addi R30, R11, 32 */
		/* 821F4D20h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x20);
		/* 821F4D20h case    0:*/		return 0x821F4D24;
		  /* 821F4D24h */ case    1:  		/* bl -542164 */
		/* 821F4D24h case    1:*/		regs.LR = 0x821F4D28; return 0x82170750;
		/* 821F4D24h case    1:*/		return 0x821F4D28;
		  /* 821F4D28h */ case    2:  		/* mr R6, R3 */
		/* 821F4D28h case    2:*/		regs.R6 = regs.R3;
		/* 821F4D28h case    2:*/		return 0x821F4D2C;
		  /* 821F4D2Ch */ case    3:  		/* mr R5, R30 */
		/* 821F4D2Ch case    3:*/		regs.R5 = regs.R30;
		/* 821F4D2Ch case    3:*/		return 0x821F4D30;
		  /* 821F4D30h */ case    4:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F4D30h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4D30h case    4:*/		return 0x821F4D34;
		  /* 821F4D34h */ case    5:  		/* mr R3, R31 */
		/* 821F4D34h case    5:*/		regs.R3 = regs.R31;
		/* 821F4D34h case    5:*/		return 0x821F4D38;
		  /* 821F4D38h */ case    6:  		/* bl -208920 */
		/* 821F4D38h case    6:*/		regs.LR = 0x821F4D3C; return 0x821C1D20;
		/* 821F4D38h case    6:*/		return 0x821F4D3C;
		  /* 821F4D3Ch */ case    7:  		/* mr R30, R3 */
		/* 821F4D3Ch case    7:*/		regs.R30 = regs.R3;
		/* 821F4D3Ch case    7:*/		return 0x821F4D40;
		  /* 821F4D40h */ case    8:  		/* mr R3, R31 */
		/* 821F4D40h case    8:*/		regs.R3 = regs.R31;
		/* 821F4D40h case    8:*/		return 0x821F4D44;
		  /* 821F4D44h */ case    9:  		/* addi R29, R30, -16 */
		/* 821F4D44h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0xFFFFFFF0);
		/* 821F4D44h case    9:*/		return 0x821F4D48;
		  /* 821F4D48h */ case   10:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F4D48h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F4D48h case   10:*/		return 0x821F4D4C;
		  /* 821F4D4Ch */ case   11:  		/* oris R11, R11, 6 */
		/* 821F4D4Ch case   11:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x6);
		/* 821F4D4Ch case   11:*/		return 0x821F4D50;
		  /* 821F4D50h */ case   12:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821F4D50h case   12:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821F4D50h case   12:*/		return 0x821F4D54;
		  /* 821F4D54h */ case   13:  		/* stw R11, <#[R30 + 8]> */
		/* 821F4D54h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F4D54h case   13:*/		return 0x821F4D58;
		  /* 821F4D58h */ case   14:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F4D58h case   14:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F4D58h case   14:*/		return 0x821F4D5C;
		  /* 821F4D5Ch */ case   15:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821F4D5Ch case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821F4D5Ch case   15:*/		return 0x821F4D60;
		  /* 821F4D60h */ case   16:  		/* bl -592176 */
		/* 821F4D60h case   16:*/		regs.LR = 0x821F4D64; return 0x82164430;
		/* 821F4D60h case   16:*/		return 0x821F4D64;
		  /* 821F4D64h */ case   17:  		/* add R11, R3, R29 */
		/* 821F4D64h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R29);
		/* 821F4D64h case   17:*/		return 0x821F4D68;
		  /* 821F4D68h */ case   18:  		/* mr R3, R31 */
		/* 821F4D68h case   18:*/		regs.R3 = regs.R31;
		/* 821F4D68h case   18:*/		return 0x821F4D6C;
		  /* 821F4D6Ch */ case   19:  		/* lwz R10, <#[R11 + 12]> */
		/* 821F4D6Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F4D6Ch case   19:*/		return 0x821F4D70;
		  /* 821F4D70h */ case   20:  		/* stw R26, <#[R11]> */
		/* 821F4D70h case   20:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4D70h case   20:*/		return 0x821F4D74;
		  /* 821F4D74h */ case   21:  		/* ori R10, R10, 4 */
		/* 821F4D74h case   21:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821F4D74h case   21:*/		return 0x821F4D78;
		  /* 821F4D78h */ case   22:  		/* stw R10, <#[R11 + 12]> */
		/* 821F4D78h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F4D78h case   22:*/		return 0x821F4D7C;
		  /* 821F4D7Ch */ case   23:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F4D7Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F4D7Ch case   23:*/		return 0x821F4D80;
		  /* 821F4D80h */ case   24:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821F4D80h case   24:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821F4D80h case   24:*/		return 0x821F4D84;
		  /* 821F4D84h */ case   25:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F4D84h case   25:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F4D84h case   25:*/		return 0x821F4D88;
		  /* 821F4D88h */ case   26:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821F4D88h case   26:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821F4D88h case   26:*/		return 0x821F4D8C;
		  /* 821F4D8Ch */ case   27:  		/* bl -592220 */
		/* 821F4D8Ch case   27:*/		regs.LR = 0x821F4D90; return 0x82164430;
		/* 821F4D8Ch case   27:*/		return 0x821F4D90;
		  /* 821F4D90h */ case   28:  		/* add R11, R3, R29 */
		/* 821F4D90h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R29);
		/* 821F4D90h case   28:*/		return 0x821F4D94;
		  /* 821F4D94h */ case   29:  		/* lwz R10, <#[R11 + 8]> */
		/* 821F4D94h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4D94h case   29:*/		return 0x821F4D98;
		  /* 821F4D98h */ case   30:  		/* rlwimi R10, R24, 5, 23, 31 */
		/* 821F4D98h case   30:*/		cpu::op::rlwimi<0,5,23,31>(regs,&regs.R10,regs.R24);
		/* 821F4D98h case   30:*/		return 0x821F4D9C;
		  /* 821F4D9Ch */ case   31:  		/* stw R10, <#[R11 + 8]> */
		/* 821F4D9Ch case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4D9Ch case   31:*/		return 0x821F4DA0;
		  /* 821F4DA0h */ case   32:  		/* stw R25, <#[R31 + 32]> */
		/* 821F4DA0h case   32:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000020) );
		/* 821F4DA0h case   32:*/		return 0x821F4DA4;
		  /* 821F4DA4h */ case   33:  		/* lwz R11, <#[R31 + 40]> */
		/* 821F4DA4h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F4DA4h case   33:*/		return 0x821F4DA8;
		  /* 821F4DA8h */ case   34:  		/* ori R11, R11, 4 */
		/* 821F4DA8h case   34:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821F4DA8h case   34:*/		return 0x821F4DAC;
		  /* 821F4DACh */ case   35:  		/* stw R11, <#[R31 + 40]> */
		/* 821F4DACh case   35:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F4DACh case   35:*/		return 0x821F4DB0;
		  /* 821F4DB0h */ case   36:  		/* b 124 */
		/* 821F4DB0h case   36:*/		return 0x821F4E2C;
		/* 821F4DB0h case   36:*/		return 0x821F4DB4;
	}
	return 0x821F4DB4;
} // Block from 821F4D20h-821F4DB4h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821F4DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4DB4);
		  /* 821F4DB4h */ case    0:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F4DB4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4DB4h case    0:*/		return 0x821F4DB8;
		  /* 821F4DB8h */ case    1:  		/* li R8, 1 */
		/* 821F4DB8h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F4DB8h case    1:*/		return 0x821F4DBC;
		  /* 821F4DBCh */ case    2:  		/* li R7, 1 */
		/* 821F4DBCh case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F4DBCh case    2:*/		return 0x821F4DC0;
		  /* 821F4DC0h */ case    3:  		/* addi R5, R4, 24 */
		/* 821F4DC0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821F4DC0h case    3:*/		return 0x821F4DC4;
		  /* 821F4DC4h */ case    4:  		/* li R6, 103 */
		/* 821F4DC4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x67);
		/* 821F4DC4h case    4:*/		return 0x821F4DC8;
		  /* 821F4DC8h */ case    5:  		/* mr R3, R31 */
		/* 821F4DC8h case    5:*/		regs.R3 = regs.R31;
		/* 821F4DC8h case    5:*/		return 0x821F4DCC;
		  /* 821F4DCCh */ case    6:  		/* bl 195532 */
		/* 821F4DCCh case    6:*/		regs.LR = 0x821F4DD0; return 0x82224998;
		/* 821F4DCCh case    6:*/		return 0x821F4DD0;
		  /* 821F4DD0h */ case    7:  		/* mr R30, R3 */
		/* 821F4DD0h case    7:*/		regs.R30 = regs.R3;
		/* 821F4DD0h case    7:*/		return 0x821F4DD4;
		  /* 821F4DD4h */ case    8:  		/* li R6, 0 */
		/* 821F4DD4h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F4DD4h case    8:*/		return 0x821F4DD8;
		  /* 821F4DD8h */ case    9:  		/* li R4, 103 */
		/* 821F4DD8h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x67);
		/* 821F4DD8h case    9:*/		return 0x821F4DDC;
		  /* 821F4DDCh */ case   10:  		/* mr R3, R31 */
		/* 821F4DDCh case   10:*/		regs.R3 = regs.R31;
		/* 821F4DDCh case   10:*/		return 0x821F4DE0;
		  /* 821F4DE0h */ case   11:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F4DE0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F4DE0h case   11:*/		return 0x821F4DE4;
		  /* 821F4DE4h */ case   12:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F4DE4h case   12:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F4DE4h case   12:*/		return 0x821F4DE8;
		  /* 821F4DE8h */ case   13:  		/* bl -592312 */
		/* 821F4DE8h case   13:*/		regs.LR = 0x821F4DEC; return 0x82164430;
		/* 821F4DE8h case   13:*/		return 0x821F4DEC;
		  /* 821F4DECh */ case   14:  		/* addi R11, R30, -4 */
		/* 821F4DECh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 821F4DECh case   14:*/		return 0x821F4DF0;
		  /* 821F4DF0h */ case   15:  		/* li R10, 15 */
		/* 821F4DF0h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 821F4DF0h case   15:*/		return 0x821F4DF4;
		  /* 821F4DF4h */ case   16:  		/* mr R4, R23 */
		/* 821F4DF4h case   16:*/		regs.R4 = regs.R23;
		/* 821F4DF4h case   16:*/		return 0x821F4DF8;
		  /* 821F4DF8h */ case   17:  		/* stwx R10, <#[R3 + R11]> */
		/* 821F4DF8h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821F4DF8h case   17:*/		return 0x821F4DFC;
		  /* 821F4DFCh */ case   18:  		/* mr R3, R31 */
		/* 821F4DFCh case   18:*/		regs.R3 = regs.R31;
		/* 821F4DFCh case   18:*/		return 0x821F4E00;
		  /* 821F4E00h */ case   19:  		/* bl -10880 */
		/* 821F4E00h case   19:*/		regs.LR = 0x821F4E04; return 0x821F2380;
		/* 821F4E00h case   19:*/		return 0x821F4E04;
		  /* 821F4E04h */ case   20:  		/* mr R4, R3 */
		/* 821F4E04h case   20:*/		regs.R4 = regs.R3;
		/* 821F4E04h case   20:*/		return 0x821F4E08;
		  /* 821F4E08h */ case   21:  		/* mr R3, R30 */
		/* 821F4E08h case   21:*/		regs.R3 = regs.R30;
		/* 821F4E08h case   21:*/		return 0x821F4E0C;
		  /* 821F4E0Ch */ case   22:  		/* bl -511044 */
		/* 821F4E0Ch case   22:*/		regs.LR = 0x821F4E10; return 0x821781C8;
		/* 821F4E0Ch case   22:*/		return 0x821F4E10;
		  /* 821F4E10h */ case   23:  		/* stw R3, <#[R30 + 44]> */
		/* 821F4E10h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F4E10h case   23:*/		return 0x821F4E14;
		  /* 821F4E14h */ case   24:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F4E14h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F4E14h case   24:*/		return 0x821F4E18;
		  /* 821F4E18h */ case   25:  		/* oris R11, R11, 512 */
		/* 821F4E18h case   25:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F4E18h case   25:*/		return 0x821F4E1C;
		  /* 821F4E1Ch */ case   26:  		/* stw R11, <#[R30 + 8]> */
		/* 821F4E1Ch case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F4E1Ch case   26:*/		return 0x821F4E20;
	}
	return 0x821F4E20;
} // Block from 821F4DB4h-821F4E20h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821F4E20h
// Function '?MakeInstr_V_CNDE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAV32@VResult@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4E20);
		  /* 821F4E20h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 821F4E20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F4E20h case    0:*/		return 0x821F4E24;
		  /* 821F4E24h */ case    1:  		/* ori R11, R11, 1024 */
		/* 821F4E24h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821F4E24h case    1:*/		return 0x821F4E28;
		  /* 821F4E28h */ case    2:  		/* stw R11, <#[R31 + 44]> */
		/* 821F4E28h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821F4E28h case    2:*/		return 0x821F4E2C;
	}
	return 0x821F4E2C;
} // Block from 821F4E20h-821F4E2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4E2C);
		  /* 821F4E2Ch */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 821F4E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 821F4E2Ch case    0:*/		return 0x821F4E30;
		  /* 821F4E30h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 821F4E30h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F4E30h case    1:*/		return 0x821F4E34;
		  /* 821F4E34h */ case    2:  		/* rlwinm. R10, R10, 0, 22, 22 */
		/* 821F4E34h case    2:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R10);
		/* 821F4E34h case    2:*/		return 0x821F4E38;
		  /* 821F4E38h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 821F4E38h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821F4E40;  }
		/* 821F4E38h case    3:*/		return 0x821F4E3C;
		  /* 821F4E3Ch */ case    4:  		/* stw R26, <#[R31 + 564]> */
		/* 821F4E3Ch case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000234) );
		/* 821F4E3Ch case    4:*/		return 0x821F4E40;
	}
	return 0x821F4E40;
} // Block from 821F4E2Ch-821F4E40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F4E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4E40);
		  /* 821F4E40h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821F4E40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F4E40h case    0:*/		return 0x821F4E44;
		  /* 821F4E44h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 821F4E44h case    1:*/		if ( regs.CR[6].eq ) { return 0x821F4E4C;  }
		/* 821F4E44h case    1:*/		return 0x821F4E48;
		  /* 821F4E48h */ case    2:  		/* stw R24, <#[R11 + 28]> */
		/* 821F4E48h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x0000001C) );
		/* 821F4E48h case    2:*/		return 0x821F4E4C;
	}
	return 0x821F4E4C;
} // Block from 821F4E40h-821F4E4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4E4C);
		  /* 821F4E4Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 821F4E4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821F4E4Ch case    0:*/		return 0x821F4E50;
		  /* 821F4E50h */ case    1:  		/* b -1457088 */
		/* 821F4E50h case    1:*/		return 0x82091290;
		/* 821F4E50h case    1:*/		return 0x821F4E54;
		  /* 821F4E54h */ case    2:  		/* nop */
		/* 821F4E54h case    2:*/		cpu::op::nop();
		/* 821F4E54h case    2:*/		return 0x821F4E58;
	}
	return 0x821F4E58;
} // Block from 821F4E4Ch-821F4E58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4E58);
		  /* 821F4E58h */ case    0:  		/* mfspr R12, LR */
		/* 821F4E58h case    0:*/		regs.R12 = regs.LR;
		/* 821F4E58h case    0:*/		return 0x821F4E5C;
		  /* 821F4E5Ch */ case    1:  		/* bl -1457160 */
		/* 821F4E5Ch case    1:*/		regs.LR = 0x821F4E60; return 0x82091254;
		/* 821F4E5Ch case    1:*/		return 0x821F4E60;
		  /* 821F4E60h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821F4E60h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821F4E60h case    2:*/		return 0x821F4E64;
		  /* 821F4E64h */ case    3:  		/* mr R31, R5 */
		/* 821F4E64h case    3:*/		regs.R31 = regs.R5;
		/* 821F4E64h case    3:*/		return 0x821F4E68;
		  /* 821F4E68h */ case    4:  		/* mr R5, R6 */
		/* 821F4E68h case    4:*/		regs.R5 = regs.R6;
		/* 821F4E68h case    4:*/		return 0x821F4E6C;
		  /* 821F4E6Ch */ case    5:  		/* li R6, 4 */
		/* 821F4E6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 821F4E6Ch case    5:*/		return 0x821F4E70;
		  /* 821F4E70h */ case    6:  		/* mr R29, R3 */
		/* 821F4E70h case    6:*/		regs.R29 = regs.R3;
		/* 821F4E70h case    6:*/		return 0x821F4E74;
		  /* 821F4E74h */ case    7:  		/* mr R28, R4 */
		/* 821F4E74h case    7:*/		regs.R28 = regs.R4;
		/* 821F4E74h case    7:*/		return 0x821F4E78;
		  /* 821F4E78h */ case    8:  		/* bl 25560 */
		/* 821F4E78h case    8:*/		regs.LR = 0x821F4E7C; return 0x821FB250;
		/* 821F4E78h case    8:*/		return 0x821F4E7C;
		  /* 821F4E7Ch */ case    9:  		/* mr R5, R29 */
		/* 821F4E7Ch case    9:*/		regs.R5 = regs.R29;
		/* 821F4E7Ch case    9:*/		return 0x821F4E80;
		  /* 821F4E80h */ case   10:  		/* lwz R3, <#[R29 + 564]> */
		/* 821F4E80h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000234) );
		/* 821F4E80h case   10:*/		return 0x821F4E84;
		  /* 821F4E84h */ case   11:  		/* mr R4, R31 */
		/* 821F4E84h case   11:*/		regs.R4 = regs.R31;
		/* 821F4E84h case   11:*/		return 0x821F4E88;
		  /* 821F4E88h */ case   12:  		/* bl -17624 */
		/* 821F4E88h case   12:*/		regs.LR = 0x821F4E8C; return 0x821F09B0;
		/* 821F4E88h case   12:*/		return 0x821F4E8C;
		  /* 821F4E8Ch */ case   13:  		/* lwz R10, <#[R29 + 12]> */
		/* 821F4E8Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F4E8Ch case   13:*/		return 0x821F4E90;
		  /* 821F4E90h */ case   14:  		/* mulli R27, R31, 40 */
		/* 821F4E90h case   14:*/		cpu::op::mulli<0>(regs,&regs.R27,regs.R31,0x28);
		/* 821F4E90h case   14:*/		return 0x821F4E94;
		  /* 821F4E94h */ case   15:  		/* lwz R11, <#[R28 + 4]> */
		/* 821F4E94h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821F4E94h case   15:*/		return 0x821F4E98;
		  /* 821F4E98h */ case   16:  		/* lwzx R9, <#[R27 + R10]> */
		/* 821F4E98h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + regs.R10 + 0x00000000) );
		/* 821F4E98h case   16:*/		return 0x821F4E9C;
		  /* 821F4E9Ch */ case   17:  		/* rlwinm. R8, R11, 0, 31, 31 */
		/* 821F4E9Ch case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R11);
		/* 821F4E9Ch case   17:*/		return 0x821F4EA0;
		  /* 821F4EA0h */ case   18:  		/* mr R30, R3 */
		/* 821F4EA0h case   18:*/		regs.R30 = regs.R3;
		/* 821F4EA0h case   18:*/		return 0x821F4EA4;
		  /* 821F4EA4h */ case   19:  		/* li R10, 0 */
		/* 821F4EA4h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821F4EA4h case   19:*/		return 0x821F4EA8;
		  /* 821F4EA8h */ case   20:  		/* rlwinm R31, R9, 29, 18, 31 */
		/* 821F4EA8h case   20:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R31,regs.R9);
		/* 821F4EA8h case   20:*/		return 0x821F4EAC;
		  /* 821F4EACh */ case   21:  		/* bc 4, CR0_EQ, 44 */
		/* 821F4EACh case   21:*/		if ( !regs.CR[0].eq ) { return 0x821F4ED8;  }
		/* 821F4EACh case   21:*/		return 0x821F4EB0;
		  /* 821F4EB0h */ case   22:  		/* cmplwi CR0, R11, 0 */
		/* 821F4EB0h case   22:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821F4EB0h case   22:*/		return 0x821F4EB4;
		  /* 821F4EB4h */ case   23:  		/* bc 12, CR0_EQ, 36 */
		/* 821F4EB4h case   23:*/		if ( regs.CR[0].eq ) { return 0x821F4ED8;  }
		/* 821F4EB4h case   23:*/		return 0x821F4EB8;
		  /* 821F4EB8h */ case   24:  		/* rlwinm R9, R11, 0, 0, 30 */
		/* 821F4EB8h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R11);
		/* 821F4EB8h case   24:*/		return 0x821F4EBC;
		  /* 821F4EBCh */ case   25:  		/* lwz R11, <#[R11 + 8]> */
		/* 821F4EBCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821F4EBCh case   25:*/		return 0x821F4EC0;
		  /* 821F4EC0h */ case   26:  		/* add R10, R11, R10 */
		/* 821F4EC0h case   26:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821F4EC0h case   26:*/		return 0x821F4EC4;
		  /* 821F4EC4h */ case   27:  		/* lwz R11, <#[R9 + 4]> */
		/* 821F4EC4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821F4EC4h case   27:*/		return 0x821F4EC8;
		  /* 821F4EC8h */ case   28:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821F4EC8h case   28:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821F4EC8h case   28:*/		return 0x821F4ECC;
		  /* 821F4ECCh */ case   29:  		/* bc 4, CR0_EQ, 12 */
		/* 821F4ECCh case   29:*/		if ( !regs.CR[0].eq ) { return 0x821F4ED8;  }
		/* 821F4ECCh case   29:*/		return 0x821F4ED0;
		  /* 821F4ED0h */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 821F4ED0h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821F4ED0h case   30:*/		return 0x821F4ED4;
		  /* 821F4ED4h */ case   31:  		/* bc 4, CR6_EQ, -28 */
		/* 821F4ED4h case   31:*/		if ( !regs.CR[6].eq ) { return 0x821F4EB8;  }
		/* 821F4ED4h case   31:*/		return 0x821F4ED8;
	}
	return 0x821F4ED8;
} // Block from 821F4E58h-821F4ED8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821F4ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4ED8);
		  /* 821F4ED8h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821F4ED8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821F4ED8h case    0:*/		return 0x821F4EDC;
		  /* 821F4EDCh */ case    1:  		/* bc 12, CR6_EQ, 152 */
		/* 821F4EDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821F4F74;  }
		/* 821F4EDCh case    1:*/		return 0x821F4EE0;
		  /* 821F4EE0h */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 821F4EE0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821F4EE0h case    2:*/		return 0x821F4EE4;
		  /* 821F4EE4h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821F4EE4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F4EF4;  }
		/* 821F4EE4h case    3:*/		return 0x821F4EE8;
		  /* 821F4EE8h */ case    4:  		/* li R4, 4801 */
		/* 821F4EE8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F4EE8h case    4:*/		return 0x821F4EEC;
		  /* 821F4EECh */ case    5:  		/* mr R3, R29 */
		/* 821F4EECh case    5:*/		regs.R3 = regs.R29;
		/* 821F4EECh case    5:*/		return 0x821F4EF0;
		  /* 821F4EF0h */ case    6:  		/* bl -667784 */
		/* 821F4EF0h case    6:*/		regs.LR = 0x821F4EF4; return 0x82151E68;
		/* 821F4EF0h case    6:*/		return 0x821F4EF4;
	}
	return 0x821F4EF4;
} // Block from 821F4ED8h-821F4EF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F4EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4EF4);
		  /* 821F4EF4h */ case    0:  		/* mr R4, R28 */
		/* 821F4EF4h case    0:*/		regs.R4 = regs.R28;
		/* 821F4EF4h case    0:*/		return 0x821F4EF8;
		  /* 821F4EF8h */ case    1:  		/* addi R3, R1, 80 */
		/* 821F4EF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F4EF8h case    1:*/		return 0x821F4EFC;
		  /* 821F4EFCh */ case    2:  		/* bl -2220 */
		/* 821F4EFCh case    2:*/		regs.LR = 0x821F4F00; return 0x821F4650;
		/* 821F4EFCh case    2:*/		return 0x821F4F00;
		  /* 821F4F00h */ case    3:  		/* lwz R11, <#[R1 + 84]> */
		/* 821F4F00h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F4F00h case    3:*/		return 0x821F4F04;
		  /* 821F4F04h */ case    4:  		/* rlwinm R10, R11, 0, 30, 31 */
		/* 821F4F04h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R11);
		/* 821F4F04h case    4:*/		return 0x821F4F08;
		  /* 821F4F08h */ case    5:  		/* cmplwi CR6, R10, 1 */
		/* 821F4F08h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821F4F08h case    5:*/		return 0x821F4F0C;
		  /* 821F4F0Ch */ case    6:  		/* bc 4, CR6_EQ, 92 */
		/* 821F4F0Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x821F4F68;  }
		/* 821F4F0Ch case    6:*/		return 0x821F4F10;
	}
	return 0x821F4F10;
} // Block from 821F4EF4h-821F4F10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F4F10h
// Function '?MakeInstr_V_CNDGE@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVResult@2@V42@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4F10);
		  /* 821F4F10h */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 821F4F10h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821F4F10h case    0:*/		return 0x821F4F14;
		  /* 821F4F14h */ case    1:  		/* lwz R10, <#[R3 + 8]> */
		/* 821F4F14h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821F4F14h case    1:*/		return 0x821F4F18;
		  /* 821F4F18h */ case    2:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821F4F18h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821F4F18h case    2:*/		return 0x821F4F1C;
		  /* 821F4F1Ch */ case    3:  		/* cmplwi CR6, R10, 16000 */
		/* 821F4F1Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E80);
		/* 821F4F1Ch case    3:*/		return 0x821F4F20;
		  /* 821F4F20h */ case    4:  		/* bc 4, CR6_EQ, 72 */
		/* 821F4F20h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821F4F68;  }
		/* 821F4F20h case    4:*/		return 0x821F4F24;
		  /* 821F4F24h */ case    5:  		/* rlwinm R4, R11, 30, 18, 31 */
		/* 821F4F24h case    5:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R4,regs.R11);
		/* 821F4F24h case    5:*/		return 0x821F4F28;
		  /* 821F4F28h */ case    6:  		/* bl -229336 */
		/* 821F4F28h case    6:*/		regs.LR = 0x821F4F2C; return 0x821BCF50;
		/* 821F4F28h case    6:*/		return 0x821F4F2C;
		  /* 821F4F2Ch */ case    7:  		/* lis R11, -32256 */
		/* 821F4F2Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F4F2Ch case    7:*/		return 0x821F4F30;
		  /* 821F4F30h */ case    8:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 821F4F30h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 821F4F30h case    8:*/		return 0x821F4F34;
		  /* 821F4F34h */ case    9:  		/* fcmpu CR6, FR1, FR0 */
		/* 821F4F34h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 821F4F34h case    9:*/		return 0x821F4F38;
		  /* 821F4F38h */ case   10:  		/* bc 4, CR6_EQ, 48 */
		/* 821F4F38h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821F4F68;  }
		/* 821F4F38h case   10:*/		return 0x821F4F3C;
		  /* 821F4F3Ch */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 821F4F3Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821F4F3Ch case   11:*/		return 0x821F4F40;
		  /* 821F4F40h */ case   12:  		/* bc 12, CR6_EQ, 108 */
		/* 821F4F40h case   12:*/		if ( regs.CR[6].eq ) { return 0x821F4FAC;  }
		/* 821F4F40h case   12:*/		return 0x821F4F44;
		  /* 821F4F44h */ case   13:  		/* ld R10, <#[R1 + 80]> */
		/* 821F4F44h case   13:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821F4F44h case   13:*/		return 0x821F4F48;
		  /* 821F4F48h */ case   14:  		/* rlwinm R11, R31, 3, 0, 28 */
		/* 821F4F48h case   14:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R31);
		/* 821F4F48h case   14:*/		return 0x821F4F4C;
		  /* 821F4F4Ch */ case   15:  		/* mr R4, R30 */
		/* 821F4F4Ch case   15:*/		regs.R4 = regs.R30;
		/* 821F4F4Ch case   15:*/		return 0x821F4F50;
		  /* 821F4F50h */ case   16:  		/* addi R11, R11, -1 */
		/* 821F4F50h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821F4F50h case   16:*/		return 0x821F4F54;
		  /* 821F4F54h */ case   17:  		/* addi R3, R30, 8 */
		/* 821F4F54h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x8);
		/* 821F4F54h case   17:*/		return 0x821F4F58;
		  /* 821F4F58h */ case   18:  		/* rlwinm R5, R11, 0, 0, 28 */
		/* 821F4F58h case   18:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R5,regs.R11);
		/* 821F4F58h case   18:*/		return 0x821F4F5C;
		  /* 821F4F5Ch */ case   19:  		/* std R10, <#[R30]> */
		/* 821F4F5Ch case   19:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F4F5Ch case   19:*/		return 0x821F4F60;
		  /* 821F4F60h */ case   20:  		/* bl -1454376 */
		/* 821F4F60h case   20:*/		regs.LR = 0x821F4F64; return 0x82091E38;
		/* 821F4F60h case   20:*/		return 0x821F4F64;
		  /* 821F4F64h */ case   21:  		/* b 72 */
		/* 821F4F64h case   21:*/		return 0x821F4FAC;
		/* 821F4F64h case   21:*/		return 0x821F4F68;
	}
	return 0x821F4F68;
} // Block from 821F4F10h-821F4F68h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F4F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4F68);
		  /* 821F4F68h */ case    0:  		/* li R4, 4801 */
		/* 821F4F68h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F4F68h case    0:*/		return 0x821F4F6C;
		  /* 821F4F6Ch */ case    1:  		/* mr R3, R29 */
		/* 821F4F6Ch case    1:*/		regs.R3 = regs.R29;
		/* 821F4F6Ch case    1:*/		return 0x821F4F70;
		  /* 821F4F70h */ case    2:  		/* bl -667912 */
		/* 821F4F70h case    2:*/		regs.LR = 0x821F4F74; return 0x82151E68;
		/* 821F4F70h case    2:*/		return 0x821F4F74;
	}
	return 0x821F4F74;
} // Block from 821F4F68h-821F4F74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F4F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4F74);
		  /* 821F4F74h */ case    0:  		/* addic. R31, R31, -1 */
		/* 821F4F74h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 821F4F74h case    0:*/		return 0x821F4F78;
		  /* 821F4F78h */ case    1:  		/* bc 12, CR0_LT, 52 */
		/* 821F4F78h case    1:*/		if ( regs.CR[0].lt ) { return 0x821F4FAC;  }
		/* 821F4F78h case    1:*/		return 0x821F4F7C;
		  /* 821F4F7Ch */ case    2:  		/* addi R11, R31, 1 */
		/* 821F4F7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 821F4F7Ch case    2:*/		return 0x821F4F80;
		  /* 821F4F80h */ case    3:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 821F4F80h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 821F4F80h case    3:*/		return 0x821F4F84;
		  /* 821F4F84h */ case    4:  		/* add R30, R11, R30 */
		/* 821F4F84h case    4:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 821F4F84h case    4:*/		return 0x821F4F88;
		  /* 821F4F88h */ case    5:  		/* mr R4, R28 */
		/* 821F4F88h case    5:*/		regs.R4 = regs.R28;
		/* 821F4F88h case    5:*/		return 0x821F4F8C;
		  /* 821F4F8Ch */ case    6:  		/* addi R3, R1, 80 */
		/* 821F4F8Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F4F8Ch case    6:*/		return 0x821F4F90;
		  /* 821F4F90h */ case    7:  		/* bl -2368 */
		/* 821F4F90h case    7:*/		regs.LR = 0x821F4F94; return 0x821F4650;
		/* 821F4F90h case    7:*/		return 0x821F4F94;
		  /* 821F4F94h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 821F4F94h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F4F94h case    8:*/		return 0x821F4F98;
		  /* 821F4F98h */ case    9:  		/* addic. R31, R31, -1 */
		/* 821F4F98h case    9:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 821F4F98h case    9:*/		return 0x821F4F9C;
		  /* 821F4F9Ch */ case   10:  		/* stwu R11, <#[R30 - 8]> */
		/* 821F4F9Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0xFFFFFFF8) );
		regs.R30 = (uint32)(regs.R30 + 0xFFFFFFF8);
		/* 821F4F9Ch case   10:*/		return 0x821F4FA0;
		  /* 821F4FA0h */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F4FA0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F4FA0h case   11:*/		return 0x821F4FA4;
		  /* 821F4FA4h */ case   12:  		/* stw R11, <#[R30 + 4]> */
		/* 821F4FA4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F4FA4h case   12:*/		return 0x821F4FA8;
		  /* 821F4FA8h */ case   13:  		/* bc 4, CR0_LT, -32 */
		/* 821F4FA8h case   13:*/		if ( !regs.CR[0].lt ) { return 0x821F4F88;  }
		/* 821F4FA8h case   13:*/		return 0x821F4FAC;
	}
	return 0x821F4FAC;
} // Block from 821F4F74h-821F4FACh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F4FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4FAC);
		  /* 821F4FACh */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 821F4FACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F4FACh case    0:*/		return 0x821F4FB0;
		  /* 821F4FB0h */ case    1:  		/* add R11, R27, R11 */
		/* 821F4FB0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 821F4FB0h case    1:*/		return 0x821F4FB4;
		  /* 821F4FB4h */ case    2:  		/* addi R10, R11, 4 */
		/* 821F4FB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821F4FB4h case    2:*/		return 0x821F4FB8;
		  /* 821F4FB8h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F4FB8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4FB8h case    3:*/		return 0x821F4FBC;
		  /* 821F4FBCh */ case    4:  		/* ori R10, R10, 2 */
		/* 821F4FBCh case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821F4FBCh case    4:*/		return 0x821F4FC0;
		  /* 821F4FC0h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 821F4FC0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F4FC0h case    5:*/		return 0x821F4FC4;
		  /* 821F4FC4h */ case    6:  		/* addi R1, R1, 144 */
		/* 821F4FC4h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821F4FC4h case    6:*/		return 0x821F4FC8;
		  /* 821F4FC8h */ case    7:  		/* b -1457444 */
		/* 821F4FC8h case    7:*/		return 0x820912A4;
		/* 821F4FC8h case    7:*/		return 0x821F4FCC;
		  /* 821F4FCCh */ case    8:  		/* nop */
		/* 821F4FCCh case    8:*/		cpu::op::nop();
		/* 821F4FCCh case    8:*/		return 0x821F4FD0;
	}
	return 0x821F4FD0;
} // Block from 821F4FACh-821F4FD0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F4FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F4FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F4FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F4FD0);
		  /* 821F4FD0h */ case    0:  		/* mfspr R12, LR */
		/* 821F4FD0h case    0:*/		regs.R12 = regs.LR;
		/* 821F4FD0h case    0:*/		return 0x821F4FD4;
		  /* 821F4FD4h */ case    1:  		/* bl -1457560 */
		/* 821F4FD4h case    1:*/		regs.LR = 0x821F4FD8; return 0x8209123C;
		/* 821F4FD4h case    1:*/		return 0x821F4FD8;
		  /* 821F4FD8h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821F4FD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821F4FD8h case    2:*/		return 0x821F4FDC;
		  /* 821F4FDCh */ case    3:  		/* lwz R11, <#[R6 + 4]> */
		/* 821F4FDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 821F4FDCh case    3:*/		return 0x821F4FE0;
		  /* 821F4FE0h */ case    4:  		/* mr R21, R3 */
		/* 821F4FE0h case    4:*/		regs.R21 = regs.R3;
		/* 821F4FE0h case    4:*/		return 0x821F4FE4;
		  /* 821F4FE4h */ case    5:  		/* lwz R10, <#[R6 + 8]> */
		/* 821F4FE4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000008) );
		/* 821F4FE4h case    5:*/		return 0x821F4FE8;
		  /* 821F4FE8h */ case    6:  		/* mr R31, R4 */
		/* 821F4FE8h case    6:*/		regs.R31 = regs.R4;
		/* 821F4FE8h case    6:*/		return 0x821F4FEC;
		  /* 821F4FECh */ case    7:  		/* lwz R22, <#[R4 + 4]> */
		/* 821F4FECh case    7:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R4 + 0x00000004) );
		/* 821F4FECh case    7:*/		return 0x821F4FF0;
		  /* 821F4FF0h */ case    8:  		/* mr R29, R5 */
		/* 821F4FF0h case    8:*/		regs.R29 = regs.R5;
		/* 821F4FF0h case    8:*/		return 0x821F4FF4;
		  /* 821F4FF4h */ case    9:  		/* lwz R23, <#[R4 + 8]> */
		/* 821F4FF4h case    9:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R4 + 0x00000008) );
		/* 821F4FF4h case    9:*/		return 0x821F4FF8;
		  /* 821F4FF8h */ case   10:  		/* mr R28, R6 */
		/* 821F4FF8h case   10:*/		regs.R28 = regs.R6;
		/* 821F4FF8h case   10:*/		return 0x821F4FFC;
		  /* 821F4FFCh */ case   11:  		/* mr R30, R7 */
		/* 821F4FFCh case   11:*/		regs.R30 = regs.R7;
		/* 821F4FFCh case   11:*/		return 0x821F5000;
	}
	return 0x821F5000;
} // Block from 821F4FD0h-821F5000h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F5000h
// Function '?Pop@ResultStack@D3DXShader@@QAA?AVResult@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5000);
		  /* 821F5000h */ case    0:  		/* cmplw CR6, R5, R7 */
		/* 821F5000h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R7);
		/* 821F5000h case    0:*/		return 0x821F5004;
		  /* 821F5004h */ case    1:  		/* stw R11, <#[R1 + 88]> */
		/* 821F5004h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5004h case    1:*/		return 0x821F5008;
		  /* 821F5008h */ case    2:  		/* stw R10, <#[R1 + 92]> */
		/* 821F5008h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 821F5008h case    2:*/		return 0x821F500C;
		  /* 821F500Ch */ case    3:  		/* stw R22, <#[R1 + 80]> */
		/* 821F500Ch case    3:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 821F500Ch case    3:*/		return 0x821F5010;
		  /* 821F5010h */ case    4:  		/* stw R23, <#[R1 + 84]> */
		/* 821F5010h case    4:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000054) );
		/* 821F5010h case    4:*/		return 0x821F5014;
		  /* 821F5014h */ case    5:  		/* bc 4, CR6_EQ, 68 */
		/* 821F5014h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F5058;  }
		/* 821F5014h case    5:*/		return 0x821F5018;
		  /* 821F5018h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 821F5018h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821F5018h case    6:*/		return 0x821F501C;
		  /* 821F501Ch */ case    7:  		/* bc 12, CR6_EQ, 316 */
		/* 821F501Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821F5158;  }
		/* 821F501Ch case    7:*/		return 0x821F5020;
		  /* 821F5020h */ case    8:  		/* mr R3, R31 */
		/* 821F5020h case    8:*/		regs.R3 = regs.R31;
		/* 821F5020h case    8:*/		return 0x821F5024;
		  /* 821F5024h */ case    9:  		/* bl -213444 */
		/* 821F5024h case    9:*/		regs.LR = 0x821F5028; return 0x821C0E60;
		/* 821F5024h case    9:*/		return 0x821F5028;
		  /* 821F5028h */ case   10:  		/* mr R30, R3 */
		/* 821F5028h case   10:*/		regs.R30 = regs.R3;
		/* 821F5028h case   10:*/		return 0x821F502C;
		  /* 821F502Ch */ case   11:  		/* mr R3, R28 */
		/* 821F502Ch case   11:*/		regs.R3 = regs.R28;
		/* 821F502Ch case   11:*/		return 0x821F5030;
		  /* 821F5030h */ case   12:  		/* bl -213456 */
		/* 821F5030h case   12:*/		regs.LR = 0x821F5034; return 0x821C0E60;
		/* 821F5030h case   12:*/		return 0x821F5034;
		  /* 821F5034h */ case   13:  		/* lwz R10, <#[R3]> */
		/* 821F5034h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F5034h case   13:*/		return 0x821F5038;
		  /* 821F5038h */ case   14:  		/* ld R11, <#[R30]> */
		/* 821F5038h case   14:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5038h case   14:*/		return 0x821F503C;
		  /* 821F503Ch */ case   15:  		/* addic. R29, R29, -1 */
		/* 821F503Ch case   15:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 821F503Ch case   15:*/		return 0x821F5040;
		  /* 821F5040h */ case   16:  		/* stw R10, <#[R30]> */
		/* 821F5040h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5040h case   16:*/		return 0x821F5044;
		  /* 821F5044h */ case   17:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F5044h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F5044h case   17:*/		return 0x821F5048;
		  /* 821F5048h */ case   18:  		/* stw R10, <#[R30 + 4]> */
		/* 821F5048h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 821F5048h case   18:*/		return 0x821F504C;
		  /* 821F504Ch */ case   19:  		/* std R11, <#[R3]> */
		/* 821F504Ch case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F504Ch case   19:*/		return 0x821F5050;
		  /* 821F5050h */ case   20:  		/* bc 4, CR0_EQ, -48 */
		/* 821F5050h case   20:*/		if ( !regs.CR[0].eq ) { return 0x821F5020;  }
		/* 821F5050h case   20:*/		return 0x821F5054;
		  /* 821F5054h */ case   21:  		/* b 260 */
		/* 821F5054h case   21:*/		return 0x821F5158;
		/* 821F5054h case   21:*/		return 0x821F5058;
	}
	return 0x821F5058;
} // Block from 821F5000h-821F5058h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F5058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5058);
		  /* 821F5058h */ case    0:  		/* cmplw CR6, R30, R29 */
		/* 821F5058h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 821F5058h case    0:*/		return 0x821F505C;
		  /* 821F505Ch */ case    1:  		/* bc 4, CR6_GT, 52 */
		/* 821F505Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x821F5090;  }
		/* 821F505Ch case    1:*/		return 0x821F5060;
		  /* 821F5060h */ case    2:  		/* ld R9, <#[R1 + 88]> */
		/* 821F5060h case    2:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5060h case    2:*/		return 0x821F5064;
		  /* 821F5064h */ case    3:  		/* mr R11, R31 */
		/* 821F5064h case    3:*/		regs.R11 = regs.R31;
		/* 821F5064h case    3:*/		return 0x821F5068;
		  /* 821F5068h */ case    4:  		/* ld R8, <#[R1 + 80]> */
		/* 821F5068h case    4:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5068h case    4:*/		return 0x821F506C;
		  /* 821F506Ch */ case    5:  		/* mr R10, R29 */
		/* 821F506Ch case    5:*/		regs.R10 = regs.R29;
		/* 821F506Ch case    5:*/		return 0x821F5070;
		  /* 821F5070h */ case    6:  		/* mr R31, R28 */
		/* 821F5070h case    6:*/		regs.R31 = regs.R28;
		/* 821F5070h case    6:*/		return 0x821F5074;
		  /* 821F5074h */ case    7:  		/* mr R29, R30 */
		/* 821F5074h case    7:*/		regs.R29 = regs.R30;
		/* 821F5074h case    7:*/		return 0x821F5078;
		  /* 821F5078h */ case    8:  		/* mr R28, R11 */
		/* 821F5078h case    8:*/		regs.R28 = regs.R11;
		/* 821F5078h case    8:*/		return 0x821F507C;
		  /* 821F507Ch */ case    9:  		/* std R9, <#[R1 + 80]> */
		/* 821F507Ch case    9:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821F507Ch case    9:*/		return 0x821F5080;
		  /* 821F5080h */ case   10:  		/* mr R30, R10 */
		/* 821F5080h case   10:*/		regs.R30 = regs.R10;
		/* 821F5080h case   10:*/		return 0x821F5084;
		  /* 821F5084h */ case   11:  		/* lwz R23, <#[R1 + 84]> */
		/* 821F5084h case   11:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000054) );
		/* 821F5084h case   11:*/		return 0x821F5088;
		  /* 821F5088h */ case   12:  		/* lwz R22, <#[R1 + 80]> */
		/* 821F5088h case   12:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5088h case   12:*/		return 0x821F508C;
		  /* 821F508Ch */ case   13:  		/* std R8, <#[R1 + 88]> */
		/* 821F508Ch case   13:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 821F508Ch case   13:*/		return 0x821F5090;
	}
	return 0x821F5090;
} // Block from 821F5058h-821F5090h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F5090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5090);
		  /* 821F5090h */ case    0:  		/* rlwinm R24, R30, 3, 0, 28 */
		/* 821F5090h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R24,regs.R30);
		/* 821F5090h case    0:*/		return 0x821F5094;
		  /* 821F5094h */ case    1:  		/* li R5, 0 */
		/* 821F5094h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F5094h case    1:*/		return 0x821F5098;
		  /* 821F5098h */ case    2:  		/* mr R4, R24 */
		/* 821F5098h case    2:*/		regs.R4 = regs.R24;
		/* 821F5098h case    2:*/		return 0x821F509C;
		  /* 821F509Ch */ case    3:  		/* mr R3, R21 */
		/* 821F509Ch case    3:*/		regs.R3 = regs.R21;
		/* 821F509Ch case    3:*/		return 0x821F50A0;
		  /* 821F50A0h */ case    4:  		/* bl -589928 */
		/* 821F50A0h case    4:*/		regs.LR = 0x821F50A4; return 0x82165038;
		/* 821F50A0h case    4:*/		return 0x821F50A4;
		  /* 821F50A4h */ case    5:  		/* mr R25, R3 */
		/* 821F50A4h case    5:*/		regs.R25 = regs.R3;
		/* 821F50A4h case    5:*/		return 0x821F50A8;
		  /* 821F50A8h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 821F50A8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F50A8h case    6:*/		return 0x821F50AC;
		  /* 821F50ACh */ case    7:  		/* bc 12, CR6_EQ, 44 */
		/* 821F50ACh case    7:*/		if ( regs.CR[6].eq ) { return 0x821F50D8;  }
		/* 821F50ACh case    7:*/		return 0x821F50B0;
	}
	return 0x821F50B0;
} // Block from 821F5090h-821F50B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F50B0h
// Function '?SetDepth@ResultStackEnumerator@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F50B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F50B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F50B0);
		  /* 821F50B0h */ case    0:  		/* addi R26, R3, -8 */
		/* 821F50B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0xFFFFFFF8);
		/* 821F50B0h case    0:*/		return 0x821F50B4;
		  /* 821F50B4h */ case    1:  		/* mr R27, R30 */
		/* 821F50B4h case    1:*/		regs.R27 = regs.R30;
		/* 821F50B4h case    1:*/		return 0x821F50B8;
		  /* 821F50B8h */ case    2:  		/* mr R3, R28 */
		/* 821F50B8h case    2:*/		regs.R3 = regs.R28;
		/* 821F50B8h case    2:*/		return 0x821F50BC;
		  /* 821F50BCh */ case    3:  		/* bl -213596 */
		/* 821F50BCh case    3:*/		regs.LR = 0x821F50C0; return 0x821C0E60;
		/* 821F50BCh case    3:*/		return 0x821F50C0;
		  /* 821F50C0h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 821F50C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F50C0h case    4:*/		return 0x821F50C4;
		  /* 821F50C4h */ case    5:  		/* addic. R27, R27, -1 */
		/* 821F50C4h case    5:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 821F50C4h case    5:*/		return 0x821F50C8;
		  /* 821F50C8h */ case    6:  		/* stwu R11, <#[R26 + 8]> */
		/* 821F50C8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		regs.R26 = (uint32)(regs.R26 + 0x00000008);
		/* 821F50C8h case    6:*/		return 0x821F50CC;
		  /* 821F50CCh */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 821F50CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F50CCh case    7:*/		return 0x821F50D0;
		  /* 821F50D0h */ case    8:  		/* stw R11, <#[R26 + 4]> */
		/* 821F50D0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821F50D0h case    8:*/		return 0x821F50D4;
		  /* 821F50D4h */ case    9:  		/* bc 4, CR0_EQ, -28 */
		/* 821F50D4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821F50B8;  }
		/* 821F50D4h case    9:*/		return 0x821F50D8;
	}
	return 0x821F50D8;
} // Block from 821F50B0h-821F50D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F50D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F50D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F50D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F50D8);
		  /* 821F50D8h */ case    0:  		/* mr R4, R30 */
		/* 821F50D8h case    0:*/		regs.R4 = regs.R30;
		/* 821F50D8h case    0:*/		return 0x821F50DC;
		  /* 821F50DCh */ case    1:  		/* mr R3, R31 */
		/* 821F50DCh case    1:*/		regs.R3 = regs.R31;
		/* 821F50DCh case    1:*/		return 0x821F50E0;
		  /* 821F50E0h */ case    2:  		/* bl -29416 */
		/* 821F50E0h case    2:*/		regs.LR = 0x821F50E4; return 0x821EDDF8;
		/* 821F50E0h case    2:*/		return 0x821F50E4;
		  /* 821F50E4h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 821F50E4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821F50E4h case    3:*/		return 0x821F50E8;
		  /* 821F50E8h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 821F50E8h case    4:*/		if ( regs.CR[6].eq ) { return 0x821F5118;  }
		/* 821F50E8h case    4:*/		return 0x821F50EC;
		  /* 821F50ECh */ case    5:  		/* mr R3, R31 */
		/* 821F50ECh case    5:*/		regs.R3 = regs.R31;
		/* 821F50ECh case    5:*/		return 0x821F50F0;
		  /* 821F50F0h */ case    6:  		/* bl -352920 */
		/* 821F50F0h case    6:*/		regs.LR = 0x821F50F4; return 0x8219EE58;
		/* 821F50F0h case    6:*/		return 0x821F50F4;
		  /* 821F50F4h */ case    7:  		/* mr R27, R3 */
		/* 821F50F4h case    7:*/		regs.R27 = regs.R3;
		/* 821F50F4h case    7:*/		return 0x821F50F8;
	}
	return 0x821F50F8;
} // Block from 821F50D8h-821F50F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F50F8h
// Function '?AdvanceToNextField@ComponentTypeEnumerator@D3DXShader@@AAAPAVCNode@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F50F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F50F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F50F8);
		  /* 821F50F8h */ case    0:  		/* mr R3, R28 */
		/* 821F50F8h case    0:*/		regs.R3 = regs.R28;
		/* 821F50F8h case    0:*/		return 0x821F50FC;
		  /* 821F50FCh */ case    1:  		/* bl -352932 */
		/* 821F50FCh case    1:*/		regs.LR = 0x821F5100; return 0x8219EE58;
		/* 821F50FCh case    1:*/		return 0x821F5100;
		  /* 821F5100h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 821F5100h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821F5100h case    2:*/		return 0x821F5104;
		  /* 821F5104h */ case    3:  		/* addic. R29, R29, -1 */
		/* 821F5104h case    3:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 821F5104h case    3:*/		return 0x821F5108;
		  /* 821F5108h */ case    4:  		/* stw R11, <#[R3]> */
		/* 821F5108h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F5108h case    4:*/		return 0x821F510C;
		  /* 821F510Ch */ case    5:  		/* lwz R11, <#[R27 + 4]> */
		/* 821F510Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821F510Ch case    5:*/		return 0x821F5110;
		  /* 821F5110h */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 821F5110h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F5110h case    6:*/		return 0x821F5114;
		  /* 821F5114h */ case    7:  		/* bc 4, CR0_EQ, -40 */
		/* 821F5114h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821F50EC;  }
		/* 821F5114h case    7:*/		return 0x821F5118;
	}
	return 0x821F5118;
} // Block from 821F50F8h-821F5118h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F5118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5118);
		  /* 821F5118h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821F5118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F5118h case    0:*/		return 0x821F511C;
		  /* 821F511Ch */ case    1:  		/* stw R22, <#[R31 + 4]> */
		/* 821F511Ch case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 821F511Ch case    1:*/		return 0x821F5120;
		  /* 821F5120h */ case    2:  		/* stw R23, <#[R31 + 8]> */
		/* 821F5120h case    2:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000008) );
		/* 821F5120h case    2:*/		return 0x821F5124;
		  /* 821F5124h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 821F5124h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F5144;  }
		/* 821F5124h case    3:*/		return 0x821F5128;
		  /* 821F5128h */ case    4:  		/* addi R29, R25, -8 */
		/* 821F5128h case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R25,0xFFFFFFF8);
		/* 821F5128h case    4:*/		return 0x821F512C;
		  /* 821F512Ch */ case    5:  		/* mr R3, R31 */
		/* 821F512Ch case    5:*/		regs.R3 = regs.R31;
		/* 821F512Ch case    5:*/		return 0x821F5130;
		  /* 821F5130h */ case    6:  		/* bl -213712 */
		/* 821F5130h case    6:*/		regs.LR = 0x821F5134; return 0x821C0E60;
		/* 821F5130h case    6:*/		return 0x821F5134;
		  /* 821F5134h */ case    7:  		/* ldu R11, <#[R29 + 8]> */
		/* 821F5134h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		regs.R29 = (uint32)(regs.R29 + 0x00000008);
		/* 821F5134h case    7:*/		return 0x821F5138;
		  /* 821F5138h */ case    8:  		/* addic. R30, R30, -1 */
		/* 821F5138h case    8:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 821F5138h case    8:*/		return 0x821F513C;
		  /* 821F513Ch */ case    9:  		/* std R11, <#[R3]> */
		/* 821F513Ch case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F513Ch case    9:*/		return 0x821F5140;
		  /* 821F5140h */ case   10:  		/* bc 4, CR0_EQ, -20 */
		/* 821F5140h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821F512C;  }
		/* 821F5140h case   10:*/		return 0x821F5144;
	}
	return 0x821F5144;
} // Block from 821F5118h-821F5144h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F5144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5144);
		  /* 821F5144h */ case    0:  		/* li R6, 0 */
		/* 821F5144h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F5144h case    0:*/		return 0x821F5148;
		  /* 821F5148h */ case    1:  		/* mr R5, R24 */
		/* 821F5148h case    1:*/		regs.R5 = regs.R24;
		/* 821F5148h case    1:*/		return 0x821F514C;
		  /* 821F514Ch */ case    2:  		/* mr R4, R25 */
		/* 821F514Ch case    2:*/		regs.R4 = regs.R25;
		/* 821F514Ch case    2:*/		return 0x821F5150;
		  /* 821F5150h */ case    3:  		/* mr R3, R21 */
		/* 821F5150h case    3:*/		regs.R3 = regs.R21;
		/* 821F5150h case    3:*/		return 0x821F5154;
		  /* 821F5154h */ case    4:  		/* bl -557828 */
		/* 821F5154h case    4:*/		regs.LR = 0x821F5158; return 0x8216CE50;
		/* 821F5154h case    4:*/		return 0x821F5158;
	}
	return 0x821F5158;
} // Block from 821F5144h-821F5158h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F5158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5158);
		  /* 821F5158h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 821F5158h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5158h case    0:*/		return 0x821F515C;
		  /* 821F515Ch */ case    1:  		/* lwz R10, <#[R1 + 92]> */
		/* 821F515Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 821F515Ch case    1:*/		return 0x821F5160;
		  /* 821F5160h */ case    2:  		/* stw R22, <#[R31 + 4]> */
		/* 821F5160h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 821F5160h case    2:*/		return 0x821F5164;
		  /* 821F5164h */ case    3:  		/* stw R23, <#[R31 + 8]> */
		/* 821F5164h case    3:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x00000008) );
		/* 821F5164h case    3:*/		return 0x821F5168;
		  /* 821F5168h */ case    4:  		/* stw R11, <#[R28 + 4]> */
		/* 821F5168h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821F5168h case    4:*/		return 0x821F516C;
		  /* 821F516Ch */ case    5:  		/* stw R10, <#[R28 + 8]> */
		/* 821F516Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821F516Ch case    5:*/		return 0x821F5170;
		  /* 821F5170h */ case    6:  		/* addi R1, R1, 192 */
		/* 821F5170h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821F5170h case    6:*/		return 0x821F5174;
		  /* 821F5174h */ case    7:  		/* b -1457896 */
		/* 821F5174h case    7:*/		return 0x8209128C;
		/* 821F5174h case    7:*/		return 0x821F5178;
	}
	return 0x821F5178;
} // Block from 821F5158h-821F5178h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F5178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5178);
		  /* 821F5178h */ case    0:  		/* mfspr R12, LR */
		/* 821F5178h case    0:*/		regs.R12 = regs.LR;
		/* 821F5178h case    0:*/		return 0x821F517C;
		  /* 821F517Ch */ case    1:  		/* bl -1457980 */
		/* 821F517Ch case    1:*/		regs.LR = 0x821F5180; return 0x82091240;
		/* 821F517Ch case    1:*/		return 0x821F5180;
		  /* 821F5180h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821F5180h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821F5180h case    2:*/		return 0x821F5184;
		  /* 821F5184h */ case    3:  		/* mr R31, R3 */
		/* 821F5184h case    3:*/		regs.R31 = regs.R3;
		/* 821F5184h case    3:*/		return 0x821F5188;
		  /* 821F5188h */ case    4:  		/* mr R26, R4 */
		/* 821F5188h case    4:*/		regs.R26 = regs.R4;
		/* 821F5188h case    4:*/		return 0x821F518C;
		  /* 821F518Ch */ case    5:  		/* mr R23, R5 */
		/* 821F518Ch case    5:*/		regs.R23 = regs.R5;
		/* 821F518Ch case    5:*/		return 0x821F5190;
		  /* 821F5190h */ case    6:  		/* mr R25, R6 */
		/* 821F5190h case    6:*/		regs.R25 = regs.R6;
		/* 821F5190h case    6:*/		return 0x821F5194;
		  /* 821F5194h */ case    7:  		/* li R24, 0 */
		/* 821F5194h case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821F5194h case    7:*/		return 0x821F5198;
		  /* 821F5198h */ case    8:  		/* cmplwi CR6, R25, 0 */
		/* 821F5198h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821F5198h case    8:*/		return 0x821F519C;
		  /* 821F519Ch */ case    9:  		/* bc 12, CR6_EQ, 384 */
		/* 821F519Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821F531C;  }
		/* 821F519Ch case    9:*/		return 0x821F51A0;
		  /* 821F51A0h */ case   10:  		/* cmplwi CR6, R25, 4 */
		/* 821F51A0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000004);
		/* 821F51A0h case   10:*/		return 0x821F51A4;
		  /* 821F51A4h */ case   11:  		/* mr R27, R25 */
		/* 821F51A4h case   11:*/		regs.R27 = regs.R25;
		/* 821F51A4h case   11:*/		return 0x821F51A8;
		  /* 821F51A8h */ case   12:  		/* bc 12, CR6_LT, 8 */
		/* 821F51A8h case   12:*/		if ( regs.CR[6].lt ) { return 0x821F51B0;  }
		/* 821F51A8h case   12:*/		return 0x821F51AC;
		  /* 821F51ACh */ case   13:  		/* li R27, 4 */
		/* 821F51ACh case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 821F51ACh case   13:*/		return 0x821F51B0;
	}
	return 0x821F51B0;
} // Block from 821F5178h-821F51B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F51B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F51B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F51B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F51B0);
		  /* 821F51B0h */ case    0:  		/* li R7, 1 */
		/* 821F51B0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F51B0h case    0:*/		return 0x821F51B4;
		  /* 821F51B4h */ case    1:  		/* li R6, 1 */
		/* 821F51B4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F51B4h case    1:*/		return 0x821F51B8;
		  /* 821F51B8h */ case    2:  		/* mr R5, R27 */
		/* 821F51B8h case    2:*/		regs.R5 = regs.R27;
		/* 821F51B8h case    2:*/		return 0x821F51BC;
		  /* 821F51BCh */ case    3:  		/* mr R4, R26 */
		/* 821F51BCh case    3:*/		regs.R4 = regs.R26;
		/* 821F51BCh case    3:*/		return 0x821F51C0;
		  /* 821F51C0h */ case    4:  		/* mr R3, R31 */
		/* 821F51C0h case    4:*/		regs.R3 = regs.R31;
		/* 821F51C0h case    4:*/		return 0x821F51C4;
		  /* 821F51C4h */ case    5:  		/* bl -11428 */
		/* 821F51C4h case    5:*/		regs.LR = 0x821F51C8; return 0x821F2520;
		/* 821F51C4h case    5:*/		return 0x821F51C8;
		  /* 821F51C8h */ case    6:  		/* mr R28, R3 */
		/* 821F51C8h case    6:*/		regs.R28 = regs.R3;
		/* 821F51C8h case    6:*/		return 0x821F51CC;
		  /* 821F51CCh */ case    7:  		/* li R7, 1 */
		/* 821F51CCh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821F51CCh case    7:*/		return 0x821F51D0;
		  /* 821F51D0h */ case    8:  		/* li R6, 0 */
		/* 821F51D0h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821F51D0h case    8:*/		return 0x821F51D4;
		  /* 821F51D4h */ case    9:  		/* mr R5, R27 */
		/* 821F51D4h case    9:*/		regs.R5 = regs.R27;
		/* 821F51D4h case    9:*/		return 0x821F51D8;
		  /* 821F51D8h */ case   10:  		/* mr R4, R23 */
		/* 821F51D8h case   10:*/		regs.R4 = regs.R23;
		/* 821F51D8h case   10:*/		return 0x821F51DC;
		  /* 821F51DCh */ case   11:  		/* mr R3, R31 */
		/* 821F51DCh case   11:*/		regs.R3 = regs.R31;
		/* 821F51DCh case   11:*/		return 0x821F51E0;
		  /* 821F51E0h */ case   12:  		/* bl -11456 */
		/* 821F51E0h case   12:*/		regs.LR = 0x821F51E4; return 0x821F2520;
		/* 821F51E0h case   12:*/		return 0x821F51E4;
		  /* 821F51E4h */ case   13:  		/* mr R5, R3 */
		/* 821F51E4h case   13:*/		regs.R5 = regs.R3;
		/* 821F51E4h case   13:*/		return 0x821F51E8;
		  /* 821F51E8h */ case   14:  		/* mr R4, R28 */
		/* 821F51E8h case   14:*/		regs.R4 = regs.R28;
		/* 821F51E8h case   14:*/		return 0x821F51EC;
		  /* 821F51ECh */ case   15:  		/* mr R3, R31 */
		/* 821F51ECh case   15:*/		regs.R3 = regs.R31;
		/* 821F51ECh case   15:*/		return 0x821F51F0;
		  /* 821F51F0h */ case   16:  		/* bl -28600 */
		/* 821F51F0h case   16:*/		regs.LR = 0x821F51F4; return 0x821EE238;
		/* 821F51F0h case   16:*/		return 0x821F51F4;
		  /* 821F51F4h */ case   17:  		/* lwz R11, <#[R28]> */
		/* 821F51F4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F51F4h case   17:*/		return 0x821F51F8;
		  /* 821F51F8h */ case   18:  		/* lis R10, 512 */
		/* 821F51F8h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 821F51F8h case   18:*/		return 0x821F51FC;
		  /* 821F51FCh */ case   19:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821F51FCh case   19:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821F51FCh case   19:*/		return 0x821F5200;
	}
	return 0x821F5200;
} // Block from 821F51B0h-821F5200h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F5200h
// Function '?Pop@ParseStack@D3DXShader@@QAAPAVCNode@2@PAW4ParseStackEntryType@12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5200);
		  /* 821F5200h */ case    0:  		/* mr R29, R3 */
		/* 821F5200h case    0:*/		regs.R29 = regs.R3;
		/* 821F5200h case    0:*/		return 0x821F5204;
		  /* 821F5204h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 821F5204h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821F5204h case    1:*/		return 0x821F5208;
		  /* 821F5208h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 821F5208h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F5214;  }
		/* 821F5208h case    2:*/		return 0x821F520C;
		  /* 821F520Ch */ case    3:  		/* mr R30, R3 */
		/* 821F520Ch case    3:*/		regs.R30 = regs.R3;
		/* 821F520Ch case    3:*/		return 0x821F5210;
		  /* 821F5210h */ case    4:  		/* b 212 */
		/* 821F5210h case    4:*/		return 0x821F52E4;
		/* 821F5210h case    4:*/		return 0x821F5214;
	}
	return 0x821F5214;
} // Block from 821F5200h-821F5214h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F5214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5214);
		  /* 821F5214h */ case    0:  		/* li R5, 1 */
		/* 821F5214h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F5214h case    0:*/		return 0x821F5218;
		  /* 821F5218h */ case    1:  		/* mr R4, R29 */
		/* 821F5218h case    1:*/		regs.R4 = regs.R29;
		/* 821F5218h case    1:*/		return 0x821F521C;
		  /* 821F521Ch */ case    2:  		/* mr R3, R31 */
		/* 821F521Ch case    2:*/		regs.R3 = regs.R31;
		/* 821F521Ch case    2:*/		return 0x821F5220;
		  /* 821F5220h */ case    3:  		/* bl -512272 */
		/* 821F5220h case    3:*/		regs.LR = 0x821F5224; return 0x82178110;
		/* 821F5220h case    3:*/		return 0x821F5224;
		  /* 821F5224h */ case    4:  		/* mr R30, R3 */
		/* 821F5224h case    4:*/		regs.R30 = regs.R3;
		/* 821F5224h case    4:*/		return 0x821F5228;
		  /* 821F5228h */ case    5:  		/* li R5, 0 */
		/* 821F5228h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F5228h case    5:*/		return 0x821F522C;
		  /* 821F522Ch */ case    6:  		/* mr R4, R29 */
		/* 821F522Ch case    6:*/		regs.R4 = regs.R29;
		/* 821F522Ch case    6:*/		return 0x821F5230;
		  /* 821F5230h */ case    7:  		/* mr R3, R31 */
		/* 821F5230h case    7:*/		regs.R3 = regs.R31;
		/* 821F5230h case    7:*/		return 0x821F5234;
		  /* 821F5234h */ case    8:  		/* bl -512292 */
		/* 821F5234h case    8:*/		regs.LR = 0x821F5238; return 0x82178110;
		/* 821F5234h case    8:*/		return 0x821F5238;
		  /* 821F5238h */ case    9:  		/* mr R4, R3 */
		/* 821F5238h case    9:*/		regs.R4 = regs.R3;
		/* 821F5238h case    9:*/		return 0x821F523C;
		  /* 821F523Ch */ case   10:  		/* mr R3, R31 */
		/* 821F523Ch case   10:*/		regs.R3 = regs.R31;
		/* 821F523Ch case   10:*/		return 0x821F5240;
		  /* 821F5240h */ case   11:  		/* mr R5, R30 */
		/* 821F5240h case   11:*/		regs.R5 = regs.R30;
		/* 821F5240h case   11:*/		return 0x821F5244;
		  /* 821F5244h */ case   12:  		/* bl -28924 */
		/* 821F5244h case   12:*/		regs.LR = 0x821F5248; return 0x821EE148;
		/* 821F5244h case   12:*/		return 0x821F5248;
		  /* 821F5248h */ case   13:  		/* lwz R11, <#[R28]> */
		/* 821F5248h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5248h case   13:*/		return 0x821F524C;
		  /* 821F524Ch */ case   14:  		/* lis R10, 1024 */
		/* 821F524Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x400);
		/* 821F524Ch case   14:*/		return 0x821F5250;
		  /* 821F5250h */ case   15:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821F5250h case   15:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821F5250h case   15:*/		return 0x821F5254;
		  /* 821F5254h */ case   16:  		/* mr R30, R3 */
		/* 821F5254h case   16:*/		regs.R30 = regs.R3;
		/* 821F5254h case   16:*/		return 0x821F5258;
		  /* 821F5258h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 821F5258h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821F5258h case   17:*/		return 0x821F525C;
		  /* 821F525Ch */ case   18:  		/* bc 4, CR6_GT, 60 */
		/* 821F525Ch case   18:*/		if ( !regs.CR[6].gt ) { return 0x821F5298;  }
		/* 821F525Ch case   18:*/		return 0x821F5260;
		  /* 821F5260h */ case   19:  		/* li R5, 2 */
		/* 821F5260h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 821F5260h case   19:*/		return 0x821F5264;
		  /* 821F5264h */ case   20:  		/* mr R4, R29 */
		/* 821F5264h case   20:*/		regs.R4 = regs.R29;
		/* 821F5264h case   20:*/		return 0x821F5268;
		  /* 821F5268h */ case   21:  		/* mr R3, R31 */
		/* 821F5268h case   21:*/		regs.R3 = regs.R31;
		/* 821F5268h case   21:*/		return 0x821F526C;
		  /* 821F526Ch */ case   22:  		/* bl -512348 */
		/* 821F526Ch case   22:*/		regs.LR = 0x821F5270; return 0x82178110;
		/* 821F526Ch case   22:*/		return 0x821F5270;
		  /* 821F5270h */ case   23:  		/* mr R22, R3 */
		/* 821F5270h case   23:*/		regs.R22 = regs.R3;
		/* 821F5270h case   23:*/		return 0x821F5274;
		  /* 821F5274h */ case   24:  		/* li R5, 0 */
		/* 821F5274h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F5274h case   24:*/		return 0x821F5278;
		  /* 821F5278h */ case   25:  		/* mr R4, R30 */
		/* 821F5278h case   25:*/		regs.R4 = regs.R30;
		/* 821F5278h case   25:*/		return 0x821F527C;
		  /* 821F527Ch */ case   26:  		/* mr R3, R31 */
		/* 821F527Ch case   26:*/		regs.R3 = regs.R31;
		/* 821F527Ch case   26:*/		return 0x821F5280;
		  /* 821F5280h */ case   27:  		/* bl -512368 */
		/* 821F5280h case   27:*/		regs.LR = 0x821F5284; return 0x82178110;
		/* 821F5280h case   27:*/		return 0x821F5284;
		  /* 821F5284h */ case   28:  		/* mr R4, R3 */
		/* 821F5284h case   28:*/		regs.R4 = regs.R3;
		/* 821F5284h case   28:*/		return 0x821F5288;
		  /* 821F5288h */ case   29:  		/* mr R3, R31 */
		/* 821F5288h case   29:*/		regs.R3 = regs.R31;
		/* 821F5288h case   29:*/		return 0x821F528C;
		  /* 821F528Ch */ case   30:  		/* mr R5, R22 */
		/* 821F528Ch case   30:*/		regs.R5 = regs.R22;
		/* 821F528Ch case   30:*/		return 0x821F5290;
		  /* 821F5290h */ case   31:  		/* bl -29000 */
		/* 821F5290h case   31:*/		regs.LR = 0x821F5294; return 0x821EE148;
		/* 821F5290h case   31:*/		return 0x821F5294;
		  /* 821F5294h */ case   32:  		/* mr R30, R3 */
		/* 821F5294h case   32:*/		regs.R30 = regs.R3;
		/* 821F5294h case   32:*/		return 0x821F5298;
	}
	return 0x821F5298;
} // Block from 821F5214h-821F5298h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821F5298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5298);
		  /* 821F5298h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 821F5298h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5298h case    0:*/		return 0x821F529C;
		  /* 821F529Ch */ case    1:  		/* lis R10, 1536 */
		/* 821F529Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x600);
		/* 821F529Ch case    1:*/		return 0x821F52A0;
		  /* 821F52A0h */ case    2:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821F52A0h case    2:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821F52A0h case    2:*/		return 0x821F52A4;
		  /* 821F52A4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 821F52A4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821F52A4h case    3:*/		return 0x821F52A8;
		  /* 821F52A8h */ case    4:  		/* bc 4, CR6_GT, 60 */
		/* 821F52A8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821F52E4;  }
		/* 821F52A8h case    4:*/		return 0x821F52AC;
		  /* 821F52ACh */ case    5:  		/* li R5, 3 */
		/* 821F52ACh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 821F52ACh case    5:*/		return 0x821F52B0;
		  /* 821F52B0h */ case    6:  		/* mr R4, R29 */
		/* 821F52B0h case    6:*/		regs.R4 = regs.R29;
		/* 821F52B0h case    6:*/		return 0x821F52B4;
		  /* 821F52B4h */ case    7:  		/* mr R3, R31 */
		/* 821F52B4h case    7:*/		regs.R3 = regs.R31;
		/* 821F52B4h case    7:*/		return 0x821F52B8;
		  /* 821F52B8h */ case    8:  		/* bl -512424 */
		/* 821F52B8h case    8:*/		regs.LR = 0x821F52BC; return 0x82178110;
		/* 821F52B8h case    8:*/		return 0x821F52BC;
		  /* 821F52BCh */ case    9:  		/* mr R29, R3 */
		/* 821F52BCh case    9:*/		regs.R29 = regs.R3;
		/* 821F52BCh case    9:*/		return 0x821F52C0;
		  /* 821F52C0h */ case   10:  		/* li R5, 0 */
		/* 821F52C0h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F52C0h case   10:*/		return 0x821F52C4;
		  /* 821F52C4h */ case   11:  		/* mr R4, R30 */
		/* 821F52C4h case   11:*/		regs.R4 = regs.R30;
		/* 821F52C4h case   11:*/		return 0x821F52C8;
		  /* 821F52C8h */ case   12:  		/* mr R3, R31 */
		/* 821F52C8h case   12:*/		regs.R3 = regs.R31;
		/* 821F52C8h case   12:*/		return 0x821F52CC;
		  /* 821F52CCh */ case   13:  		/* bl -512444 */
		/* 821F52CCh case   13:*/		regs.LR = 0x821F52D0; return 0x82178110;
		/* 821F52CCh case   13:*/		return 0x821F52D0;
		  /* 821F52D0h */ case   14:  		/* mr R4, R3 */
		/* 821F52D0h case   14:*/		regs.R4 = regs.R3;
		/* 821F52D0h case   14:*/		return 0x821F52D4;
		  /* 821F52D4h */ case   15:  		/* mr R3, R31 */
		/* 821F52D4h case   15:*/		regs.R3 = regs.R31;
		/* 821F52D4h case   15:*/		return 0x821F52D8;
		  /* 821F52D8h */ case   16:  		/* mr R5, R29 */
		/* 821F52D8h case   16:*/		regs.R5 = regs.R29;
		/* 821F52D8h case   16:*/		return 0x821F52DC;
		  /* 821F52DCh */ case   17:  		/* bl -29076 */
		/* 821F52DCh case   17:*/		regs.LR = 0x821F52E0; return 0x821EE148;
		/* 821F52DCh case   17:*/		return 0x821F52E0;
		  /* 821F52E0h */ case   18:  		/* mr R30, R3 */
		/* 821F52E0h case   18:*/		regs.R30 = regs.R3;
		/* 821F52E0h case   18:*/		return 0x821F52E4;
	}
	return 0x821F52E4;
} // Block from 821F5298h-821F52E4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821F52E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F52E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F52E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F52E4);
		  /* 821F52E4h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821F52E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821F52E4h case    0:*/		return 0x821F52E8;
		  /* 821F52E8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 821F52E8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F52F4;  }
		/* 821F52E8h case    1:*/		return 0x821F52EC;
		  /* 821F52ECh */ case    2:  		/* mr R24, R30 */
		/* 821F52ECh case    2:*/		regs.R24 = regs.R30;
		/* 821F52ECh case    2:*/		return 0x821F52F0;
	}
	return 0x821F52F0;
} // Block from 821F52E4h-821F52F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F52F0h
// Function '?LeaveIsolateScope@Compiler@D3DXShader@@AAAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F52F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F52F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F52F0);
		  /* 821F52F0h */ case    0:  		/* b 24 */
		/* 821F52F0h case    0:*/		return 0x821F5308;
		/* 821F52F0h case    0:*/		return 0x821F52F4;
	}
	return 0x821F52F4;
} // Block from 821F52F0h-821F52F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F52F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F52F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F52F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F52F4);
		  /* 821F52F4h */ case    0:  		/* mr R5, R30 */
		/* 821F52F4h case    0:*/		regs.R5 = regs.R30;
		/* 821F52F4h case    0:*/		return 0x821F52F8;
		  /* 821F52F8h */ case    1:  		/* mr R4, R24 */
		/* 821F52F8h case    1:*/		regs.R4 = regs.R24;
		/* 821F52F8h case    1:*/		return 0x821F52FC;
		  /* 821F52FCh */ case    2:  		/* mr R3, R31 */
		/* 821F52FCh case    2:*/		regs.R3 = regs.R31;
		/* 821F52FCh case    2:*/		return 0x821F5300;
		  /* 821F5300h */ case    3:  		/* bl -20136 */
		/* 821F5300h case    3:*/		regs.LR = 0x821F5304; return 0x821F0458;
		/* 821F5300h case    3:*/		return 0x821F5304;
		  /* 821F5304h */ case    4:  		/* mr R24, R3 */
		/* 821F5304h case    4:*/		regs.R24 = regs.R3;
		/* 821F5304h case    4:*/		return 0x821F5308;
	}
	return 0x821F5308;
} // Block from 821F52F4h-821F5308h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F5308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5308);
		  /* 821F5308h */ case    0:  		/* mr R4, R27 */
		/* 821F5308h case    0:*/		regs.R4 = regs.R27;
		/* 821F5308h case    0:*/		return 0x821F530C;
		  /* 821F530Ch */ case    1:  		/* mr R3, R26 */
		/* 821F530Ch case    1:*/		regs.R3 = regs.R26;
		/* 821F530Ch case    1:*/		return 0x821F5310;
		  /* 821F5310h */ case    2:  		/* subf R25, R27, R25 */
		/* 821F5310h case    2:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R27,regs.R25);
		/* 821F5310h case    2:*/		return 0x821F5314;
		  /* 821F5314h */ case    3:  		/* bl -29980 */
		/* 821F5314h case    3:*/		regs.LR = 0x821F5318; return 0x821EDDF8;
		/* 821F5314h case    3:*/		return 0x821F5318;
		  /* 821F5318h */ case    4:  		/* b -384 */
		/* 821F5318h case    4:*/		return 0x821F5198;
		/* 821F5318h case    4:*/		return 0x821F531C;
	}
	return 0x821F531C;
} // Block from 821F5308h-821F531Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F531Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F531C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F531C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F531C);
		  /* 821F531Ch */ case    0:  		/* mr R3, R24 */
		/* 821F531Ch case    0:*/		regs.R3 = regs.R24;
		/* 821F531Ch case    0:*/		return 0x821F5320;
		  /* 821F5320h */ case    1:  		/* addi R1, R1, 176 */
		/* 821F5320h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821F5320h case    1:*/		return 0x821F5324;
		  /* 821F5324h */ case    2:  		/* b -1458324 */
		/* 821F5324h case    2:*/		return 0x82091290;
		/* 821F5324h case    2:*/		return 0x821F5328;
	}
	return 0x821F5328;
} // Block from 821F531Ch-821F5328h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5328);
		  /* 821F5328h */ case    0:  		/* mfspr R12, LR */
		/* 821F5328h case    0:*/		regs.R12 = regs.LR;
		/* 821F5328h case    0:*/		return 0x821F532C;
		  /* 821F532Ch */ case    1:  		/* bl -1458420 */
		/* 821F532Ch case    1:*/		regs.LR = 0x821F5330; return 0x82091238;
		/* 821F532Ch case    1:*/		return 0x821F5330;
		  /* 821F5330h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821F5330h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821F5330h case    2:*/		return 0x821F5334;
		  /* 821F5334h */ case    3:  		/* mr R31, R3 */
		/* 821F5334h case    3:*/		regs.R31 = regs.R3;
		/* 821F5334h case    3:*/		return 0x821F5338;
		  /* 821F5338h */ case    4:  		/* mr R26, R4 */
		/* 821F5338h case    4:*/		regs.R26 = regs.R4;
		/* 821F5338h case    4:*/		return 0x821F533C;
		  /* 821F533Ch */ case    5:  		/* mr R29, R5 */
		/* 821F533Ch case    5:*/		regs.R29 = regs.R5;
		/* 821F533Ch case    5:*/		return 0x821F5340;
		  /* 821F5340h */ case    6:  		/* mr R24, R6 */
		/* 821F5340h case    6:*/		regs.R24 = regs.R6;
		/* 821F5340h case    6:*/		return 0x821F5344;
		  /* 821F5344h */ case    7:  		/* mr R30, R7 */
		/* 821F5344h case    7:*/		regs.R30 = regs.R7;
		/* 821F5344h case    7:*/		return 0x821F5348;
		  /* 821F5348h */ case    8:  		/* mr R22, R8 */
		/* 821F5348h case    8:*/		regs.R22 = regs.R8;
		/* 821F5348h case    8:*/		return 0x821F534C;
		  /* 821F534Ch */ case    9:  		/* mr R23, R9 */
		/* 821F534Ch case    9:*/		regs.R23 = regs.R9;
		/* 821F534Ch case    9:*/		return 0x821F5350;
		  /* 821F5350h */ case   10:  		/* mr R21, R10 */
		/* 821F5350h case   10:*/		regs.R21 = regs.R10;
		/* 821F5350h case   10:*/		return 0x821F5354;
		  /* 821F5354h */ case   11:  		/* cmplwi CR6, R8, 1 */
		/* 821F5354h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 821F5354h case   11:*/		return 0x821F5358;
		  /* 821F5358h */ case   12:  		/* bc 12, CR6_LT, 420 */
		/* 821F5358h case   12:*/		if ( regs.CR[6].lt ) { return 0x821F54FC;  }
		/* 821F5358h case   12:*/		return 0x821F535C;
		  /* 821F535Ch */ case   13:  		/* bc 12, CR6_EQ, 332 */
		/* 821F535Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821F54A8;  }
		/* 821F535Ch case   13:*/		return 0x821F5360;
		  /* 821F5360h */ case   14:  		/* cmplwi CR6, R8, 3 */
		/* 821F5360h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000003);
		/* 821F5360h case   14:*/		return 0x821F5364;
		  /* 821F5364h */ case   15:  		/* bc 12, CR6_LT, 108 */
		/* 821F5364h case   15:*/		if ( regs.CR[6].lt ) { return 0x821F53D0;  }
		/* 821F5364h case   15:*/		return 0x821F5368;
		  /* 821F5368h */ case   16:  		/* cmplwi CR6, R8, 5 */
		/* 821F5368h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000005);
		/* 821F5368h case   16:*/		return 0x821F536C;
		  /* 821F536Ch */ case   17:  		/* bc 12, CR6_LT, 12 */
		/* 821F536Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x821F5378;  }
		/* 821F536Ch case   17:*/		return 0x821F5370;
		  /* 821F5370h */ case   18:  		/* li R4, 4801 */
		/* 821F5370h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F5370h case   18:*/		return 0x821F5374;
		  /* 821F5374h */ case   19:  		/* bl -668940 */
		/* 821F5374h case   19:*/		regs.LR = 0x821F5378; return 0x82151E68;
		/* 821F5374h case   19:*/		return 0x821F5378;
	}
	return 0x821F5378;
} // Block from 821F5328h-821F5378h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F5378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5378);
		  /* 821F5378h */ case    0:  		/* lwz R4, <#[R1 + 284]> */
		/* 821F5378h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000011C) );
		/* 821F5378h case    0:*/		return 0x821F537C;
		  /* 821F537Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 821F537Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821F537Ch case    1:*/		return 0x821F5380;
		  /* 821F5380h */ case    2:  		/* bc 4, CR6_EQ, 64 */
		/* 821F5380h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F53C0;  }
		/* 821F5380h case    2:*/		return 0x821F5384;
		  /* 821F5384h */ case    3:  		/* mr R4, R29 */
		/* 821F5384h case    3:*/		regs.R4 = regs.R29;
		/* 821F5384h case    3:*/		return 0x821F5388;
		  /* 821F5388h */ case    4:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F5388h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F5388h case    4:*/		return 0x821F538C;
		  /* 821F538Ch */ case    5:  		/* mr R3, R31 */
		/* 821F538Ch case    5:*/		regs.R3 = regs.R31;
		/* 821F538Ch case    5:*/		return 0x821F5390;
		  /* 821F5390h */ case    6:  		/* bl -541344 */
		/* 821F5390h case    6:*/		regs.LR = 0x821F5394; return 0x821710F0;
		/* 821F5390h case    6:*/		return 0x821F5394;
		  /* 821F5394h */ case    7:  		/* lis R11, 512 */
		/* 821F5394h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x200);
		/* 821F5394h case    7:*/		return 0x821F5398;
		  /* 821F5398h */ case    8:  		/* lis R12, -3073 */
		/* 821F5398h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821F5398h case    8:*/		return 0x821F539C;
		  /* 821F539Ch */ case    9:  		/* lwz R10, <#[R3]> */
		/* 821F539Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F539Ch case    9:*/		return 0x821F53A0;
		  /* 821F53A0h */ case   10:  		/* ori R11, R11, 7296 */
		/* 821F53A0h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1C80);
		/* 821F53A0h case   10:*/		return 0x821F53A4;
		  /* 821F53A4h */ case   11:  		/* ori R12, R12, 64671 */
		/* 821F53A4h case   11:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC9F);
		/* 821F53A4h case   11:*/		return 0x821F53A8;
		  /* 821F53A8h */ case   12:  		/* rlwimi R11, R10, 26, 25, 26 */
		/* 821F53A8h case   12:*/		cpu::op::rlwimi<0,26,25,26>(regs,&regs.R11,regs.R10);
		/* 821F53A8h case   12:*/		return 0x821F53AC;
		  /* 821F53ACh */ case   13:  		/* mr R9, R10 */
		/* 821F53ACh case   13:*/		regs.R9 = regs.R10;
		/* 821F53ACh case   13:*/		return 0x821F53B0;
		  /* 821F53B0h */ case   14:  		/* and R10, R10, R12 */
		/* 821F53B0h case   14:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 821F53B0h case   14:*/		return 0x821F53B4;
		  /* 821F53B4h */ case   15:  		/* mr R4, R3 */
		/* 821F53B4h case   15:*/		regs.R4 = regs.R3;
		/* 821F53B4h case   15:*/		return 0x821F53B8;
		  /* 821F53B8h */ case   16:  		/* or R11, R11, R10 */
		/* 821F53B8h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F53B8h case   16:*/		return 0x821F53BC;
		  /* 821F53BCh */ case   17:  		/* stw R11, <#[R3]> */
		/* 821F53BCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821F53BCh case   17:*/		return 0x821F53C0;
	}
	return 0x821F53C0;
} // Block from 821F5378h-821F53C0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F53C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F53C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F53C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F53C0);
		  /* 821F53C0h */ case    0:  		/* mr R3, R31 */
		/* 821F53C0h case    0:*/		regs.R3 = regs.R31;
		/* 821F53C0h case    0:*/		return 0x821F53C4;
		  /* 821F53C4h */ case    1:  		/* bl -24212 */
		/* 821F53C4h case    1:*/		regs.LR = 0x821F53C8; return 0x821EF530;
		/* 821F53C4h case    1:*/		return 0x821F53C8;
		  /* 821F53C8h */ case    2:  		/* mr R23, R3 */
		/* 821F53C8h case    2:*/		regs.R23 = regs.R3;
		/* 821F53C8h case    2:*/		return 0x821F53CC;
		  /* 821F53CCh */ case    3:  		/* b 304 */
		/* 821F53CCh case    3:*/		return 0x821F54FC;
		/* 821F53CCh case    3:*/		return 0x821F53D0;
	}
	return 0x821F53D0;
} // Block from 821F53C0h-821F53D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F53D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F53D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F53D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F53D0);
		  /* 821F53D0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821F53D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F53D0h case    0:*/		return 0x821F53D4;
		  /* 821F53D4h */ case    1:  		/* lis R10, 2048 */
		/* 821F53D4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 821F53D4h case    1:*/		return 0x821F53D8;
	}
	return 0x821F53D8;
} // Block from 821F53D0h-821F53D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F53D8h
// Function '?GenerateAssert@Compiler@D3DXShader@@AAAXPAVResult@2@PAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F53D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F53D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F53D8);
		  /* 821F53D8h */ case    0:  		/* mr R3, R31 */
		/* 821F53D8h case    0:*/		regs.R3 = regs.R31;
		/* 821F53D8h case    0:*/		return 0x821F53DC;
		  /* 821F53DCh */ case    1:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821F53DCh case    1:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821F53DCh case    1:*/		return 0x821F53E0;
		  /* 821F53E0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 821F53E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821F53E0h case    2:*/		return 0x821F53E4;
		  /* 821F53E4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821F53E4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F53F0;  }
		/* 821F53E4h case    3:*/		return 0x821F53E8;
		  /* 821F53E8h */ case    4:  		/* li R4, 3536 */
		/* 821F53E8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xDD0);
		/* 821F53E8h case    4:*/		return 0x821F53EC;
		  /* 821F53ECh */ case    5:  		/* bl -669060 */
		/* 821F53ECh case    5:*/		regs.LR = 0x821F53F0; return 0x82151E68;
		/* 821F53ECh case    5:*/		return 0x821F53F0;
	}
	return 0x821F53F0;
} // Block from 821F53D8h-821F53F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F53F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F53F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F53F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F53F0);
		  /* 821F53F0h */ case    0:  		/* mr R4, R29 */
		/* 821F53F0h case    0:*/		regs.R4 = regs.R29;
		/* 821F53F0h case    0:*/		return 0x821F53F4;
		  /* 821F53F4h */ case    1:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F53F4h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F53F4h case    1:*/		return 0x821F53F8;
		  /* 821F53F8h */ case    2:  		/* bl -541448 */
		/* 821F53F8h case    2:*/		regs.LR = 0x821F53FC; return 0x821710F0;
		/* 821F53F8h case    2:*/		return 0x821F53FC;
		  /* 821F53FCh */ case    3:  		/* mr R11, R3 */
		/* 821F53FCh case    3:*/		regs.R11 = regs.R3;
		/* 821F53FCh case    3:*/		return 0x821F5400;
		  /* 821F5400h */ case    4:  		/* lis R10, 512 */
		/* 821F5400h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 821F5400h case    4:*/		return 0x821F5404;
		  /* 821F5404h */ case    5:  		/* lis R12, -3073 */
		/* 821F5404h case    5:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821F5404h case    5:*/		return 0x821F5408;
		  /* 821F5408h */ case    6:  		/* ori R10, R10, 7296 */
		/* 821F5408h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1C80);
		/* 821F5408h case    6:*/		return 0x821F540C;
		  /* 821F540Ch */ case    7:  		/* ori R12, R12, 64671 */
		/* 821F540Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC9F);
		/* 821F540Ch case    7:*/		return 0x821F5410;
		  /* 821F5410h */ case    8:  		/* lwz R9, <#[R11]> */
		/* 821F5410h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5410h case    8:*/		return 0x821F5414;
		  /* 821F5414h */ case    9:  		/* mr R3, R31 */
		/* 821F5414h case    9:*/		regs.R3 = regs.R31;
		/* 821F5414h case    9:*/		return 0x821F5418;
		  /* 821F5418h */ case   10:  		/* mr R4, R11 */
		/* 821F5418h case   10:*/		regs.R4 = regs.R11;
		/* 821F5418h case   10:*/		return 0x821F541C;
		  /* 821F541Ch */ case   11:  		/* rlwimi R10, R9, 26, 25, 26 */
		/* 821F541Ch case   11:*/		cpu::op::rlwimi<0,26,25,26>(regs,&regs.R10,regs.R9);
		/* 821F541Ch case   11:*/		return 0x821F5420;
		  /* 821F5420h */ case   12:  		/* mr R8, R9 */
		/* 821F5420h case   12:*/		regs.R8 = regs.R9;
		/* 821F5420h case   12:*/		return 0x821F5424;
		  /* 821F5424h */ case   13:  		/* and R9, R9, R12 */
		/* 821F5424h case   13:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R12);
		/* 821F5424h case   13:*/		return 0x821F5428;
		  /* 821F5428h */ case   14:  		/* or R10, R10, R9 */
		/* 821F5428h case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821F5428h case   14:*/		return 0x821F542C;
		  /* 821F542Ch */ case   15:  		/* stw R10, <#[R11]> */
		/* 821F542Ch case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F542Ch case   15:*/		return 0x821F5430;
		  /* 821F5430h */ case   16:  		/* bl -25160 */
		/* 821F5430h case   16:*/		regs.LR = 0x821F5434; return 0x821EF1E8;
		/* 821F5430h case   16:*/		return 0x821F5434;
		  /* 821F5434h */ case   17:  		/* mr R4, R3 */
		/* 821F5434h case   17:*/		regs.R4 = regs.R3;
		/* 821F5434h case   17:*/		return 0x821F5438;
		  /* 821F5438h */ case   18:  		/* mr R3, R31 */
		/* 821F5438h case   18:*/		regs.R3 = regs.R31;
		/* 821F5438h case   18:*/		return 0x821F543C;
		  /* 821F543Ch */ case   19:  		/* bl -513084 */
		/* 821F543Ch case   19:*/		regs.LR = 0x821F5440; return 0x82178000;
		/* 821F543Ch case   19:*/		return 0x821F5440;
		  /* 821F5440h */ case   20:  		/* mr R28, R3 */
		/* 821F5440h case   20:*/		regs.R28 = regs.R3;
		/* 821F5440h case   20:*/		return 0x821F5444;
		  /* 821F5444h */ case   21:  		/* rlwinm R27, R24, 25, 4, 6 */
		/* 821F5444h case   21:*/		cpu::op::rlwinm<0,25,4,6>(regs,&regs.R27,regs.R24);
		/* 821F5444h case   21:*/		return 0x821F5448;
		  /* 821F5448h */ case   22:  		/* mr R4, R29 */
		/* 821F5448h case   22:*/		regs.R4 = regs.R29;
		/* 821F5448h case   22:*/		return 0x821F544C;
		  /* 821F544Ch */ case   23:  		/* mr R3, R31 */
		/* 821F544Ch case   23:*/		regs.R3 = regs.R31;
		/* 821F544Ch case   23:*/		return 0x821F5450;
		  /* 821F5450h */ case   24:  		/* lwz R11, <#[R28]> */
		/* 821F5450h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5450h case   24:*/		return 0x821F5454;
		  /* 821F5454h */ case   25:  		/* rlwinm R11, R11, 0, 27, 20 */
		/* 821F5454h case   25:*/		cpu::op::rlwinm<0,0,27,20>(regs,&regs.R11,regs.R11);
		/* 821F5454h case   25:*/		return 0x821F5458;
		  /* 821F5458h */ case   26:  		/* rlwinm R11, R11, 0, 7, 3 */
		/* 821F5458h case   26:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R11,regs.R11);
		/* 821F5458h case   26:*/		return 0x821F545C;
		  /* 821F545Ch */ case   27:  		/* or R11, R11, R27 */
		/* 821F545Ch case   27:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 821F545Ch case   27:*/		return 0x821F5460;
		  /* 821F5460h */ case   28:  		/* ori R11, R11, 6144 */
		/* 821F5460h case   28:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1800);
		/* 821F5460h case   28:*/		return 0x821F5464;
		  /* 821F5464h */ case   29:  		/* stw R11, <#[R28]> */
		/* 821F5464h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5464h case   29:*/		return 0x821F5468;
		  /* 821F5468h */ case   30:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F5468h case   30:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F5468h case   30:*/		return 0x821F546C;
		  /* 821F546Ch */ case   31:  		/* bl -541564 */
		/* 821F546Ch case   31:*/		regs.LR = 0x821F5470; return 0x821710F0;
		/* 821F546Ch case   31:*/		return 0x821F5470;
		  /* 821F5470h */ case   32:  		/* lwz R10, <#[R3]> */
		/* 821F5470h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F5470h case   32:*/		return 0x821F5474;
		  /* 821F5474h */ case   33:  		/* mr R11, R3 */
		/* 821F5474h case   33:*/		regs.R11 = regs.R3;
		/* 821F5474h case   33:*/		return 0x821F5478;
		  /* 821F5478h */ case   34:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 821F5478h case   34:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 821F5478h case   34:*/		return 0x821F547C;
		  /* 821F547Ch */ case   35:  		/* mr R5, R28 */
		/* 821F547Ch case   35:*/		regs.R5 = regs.R28;
		/* 821F547Ch case   35:*/		return 0x821F5480;
		  /* 821F5480h */ case   36:  		/* or R10, R10, R27 */
		/* 821F5480h case   36:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R27);
		/* 821F5480h case   36:*/		return 0x821F5484;
		  /* 821F5484h */ case   37:  		/* mr R3, R31 */
		/* 821F5484h case   37:*/		regs.R3 = regs.R31;
		/* 821F5484h case   37:*/		return 0x821F5488;
		  /* 821F5488h */ case   38:  		/* stw R10, <#[R11]> */
		/* 821F5488h case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5488h case   38:*/		return 0x821F548C;
		  /* 821F548Ch */ case   39:  		/* mr R4, R11 */
		/* 821F548Ch case   39:*/		regs.R4 = regs.R11;
		/* 821F548Ch case   39:*/		return 0x821F5490;
		  /* 821F5490h */ case   40:  		/* bl -29272 */
		/* 821F5490h case   40:*/		regs.LR = 0x821F5494; return 0x821EE238;
		/* 821F5490h case   40:*/		return 0x821F5494;
		  /* 821F5494h */ case   41:  		/* mr R4, R3 */
		/* 821F5494h case   41:*/		regs.R4 = regs.R3;
		/* 821F5494h case   41:*/		return 0x821F5498;
		  /* 821F5498h */ case   42:  		/* mr R3, R31 */
		/* 821F5498h case   42:*/		regs.R3 = regs.R31;
		/* 821F5498h case   42:*/		return 0x821F549C;
		  /* 821F549Ch */ case   43:  		/* bl -513180 */
		/* 821F549Ch case   43:*/		regs.LR = 0x821F54A0; return 0x82178000;
		/* 821F549Ch case   43:*/		return 0x821F54A0;
		  /* 821F54A0h */ case   44:  		/* mr R29, R3 */
		/* 821F54A0h case   44:*/		regs.R29 = regs.R3;
		/* 821F54A0h case   44:*/		return 0x821F54A4;
		  /* 821F54A4h */ case   45:  		/* b 88 */
		/* 821F54A4h case   45:*/		return 0x821F54FC;
		/* 821F54A4h case   45:*/		return 0x821F54A8;
	}
	return 0x821F54A8;
} // Block from 821F53F0h-821F54A8h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821F54A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F54A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F54A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F54A8);
		  /* 821F54A8h */ case    0:  		/* mr R4, R21 */
		/* 821F54A8h case    0:*/		regs.R4 = regs.R21;
		/* 821F54A8h case    0:*/		return 0x821F54AC;
		  /* 821F54ACh */ case    1:  		/* mr R3, R31 */
		/* 821F54ACh case    1:*/		regs.R3 = regs.R31;
		/* 821F54ACh case    1:*/		return 0x821F54B0;
		  /* 821F54B0h */ case    2:  		/* bl -24064 */
		/* 821F54B0h case    2:*/		regs.LR = 0x821F54B4; return 0x821EF6B0;
		/* 821F54B0h case    2:*/		return 0x821F54B4;
		  /* 821F54B4h */ case    3:  		/* mr R28, R3 */
		/* 821F54B4h case    3:*/		regs.R28 = regs.R3;
		/* 821F54B4h case    3:*/		return 0x821F54B8;
		  /* 821F54B8h */ case    4:  		/* mr R3, R31 */
		/* 821F54B8h case    4:*/		regs.R3 = regs.R31;
		/* 821F54B8h case    4:*/		return 0x821F54BC;
		  /* 821F54BCh */ case    5:  		/* lwz R4, <#[R1 + 276]> */
		/* 821F54BCh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 821F54BCh case    5:*/		return 0x821F54C0;
		  /* 821F54C0h */ case    6:  		/* bl -23912 */
		/* 821F54C0h case    6:*/		regs.LR = 0x821F54C4; return 0x821EF758;
		/* 821F54C0h case    6:*/		return 0x821F54C4;
		  /* 821F54C4h */ case    7:  		/* mr R27, R3 */
		/* 821F54C4h case    7:*/		regs.R27 = regs.R3;
		/* 821F54C4h case    7:*/		return 0x821F54C8;
		  /* 821F54C8h */ case    8:  		/* li R5, 2 */
		/* 821F54C8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 821F54C8h case    8:*/		return 0x821F54CC;
		  /* 821F54CCh */ case    9:  		/* mr R4, R28 */
		/* 821F54CCh case    9:*/		regs.R4 = regs.R28;
		/* 821F54CCh case    9:*/		return 0x821F54D0;
		  /* 821F54D0h */ case   10:  		/* mr R3, R31 */
		/* 821F54D0h case   10:*/		regs.R3 = regs.R31;
		/* 821F54D0h case   10:*/		return 0x821F54D4;
		  /* 821F54D4h */ case   11:  		/* bl -544132 */
		/* 821F54D4h case   11:*/		regs.LR = 0x821F54D8; return 0x82170750;
		/* 821F54D4h case   11:*/		return 0x821F54D8;
		  /* 821F54D8h */ case   12:  		/* mr R21, R3 */
		/* 821F54D8h case   12:*/		regs.R21 = regs.R3;
		/* 821F54D8h case   12:*/		return 0x821F54DC;
		  /* 821F54DCh */ case   13:  		/* li R5, 3 */
		/* 821F54DCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 821F54DCh case   13:*/		return 0x821F54E0;
		  /* 821F54E0h */ case   14:  		/* mr R4, R27 */
		/* 821F54E0h case   14:*/		regs.R4 = regs.R27;
		/* 821F54E0h case   14:*/		return 0x821F54E4;
		  /* 821F54E4h */ case   15:  		/* mr R3, R31 */
		/* 821F54E4h case   15:*/		regs.R3 = regs.R31;
		/* 821F54E4h case   15:*/		return 0x821F54E8;
		  /* 821F54E8h */ case   16:  		/* bl -544152 */
		/* 821F54E8h case   16:*/		regs.LR = 0x821F54EC; return 0x82170750;
		/* 821F54E8h case   16:*/		return 0x821F54EC;
		  /* 821F54ECh */ case   17:  		/* lwz R11, <#[R31 + 40]> */
		/* 821F54ECh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F54ECh case   17:*/		return 0x821F54F0;
		  /* 821F54F0h */ case   18:  		/* stw R3, <#[R1 + 276]> */
		/* 821F54F0h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000114) );
		/* 821F54F0h case   18:*/		return 0x821F54F4;
		  /* 821F54F4h */ case   19:  		/* oris R11, R11, 64 */
		/* 821F54F4h case   19:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x40);
		/* 821F54F4h case   19:*/		return 0x821F54F8;
		  /* 821F54F8h */ case   20:  		/* stw R11, <#[R31 + 40]> */
		/* 821F54F8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F54F8h case   20:*/		return 0x821F54FC;
	}
	return 0x821F54FC;
} // Block from 821F54A8h-821F54FCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F54FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F54FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F54FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F54FC);
		  /* 821F54FCh */ case    0:  		/* rlwinm. R25, R30, 0, 24, 31 */
		/* 821F54FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R25,regs.R30);
		/* 821F54FCh case    0:*/		return 0x821F5500;
		  /* 821F5500h */ case    1:  		/* li R27, 1 */
		/* 821F5500h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821F5500h case    1:*/		return 0x821F5504;
		  /* 821F5504h */ case    2:  		/* bc 12, CR0_EQ, 652 */
		/* 821F5504h case    2:*/		if ( regs.CR[0].eq ) { return 0x821F5790;  }
		/* 821F5504h case    2:*/		return 0x821F5508;
		  /* 821F5508h */ case    3:  		/* mr R4, R29 */
		/* 821F5508h case    3:*/		regs.R4 = regs.R29;
		/* 821F5508h case    3:*/		return 0x821F550C;
		  /* 821F550Ch */ case    4:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F550Ch case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F550Ch case    4:*/		return 0x821F5510;
		  /* 821F5510h */ case    5:  		/* mr R3, R31 */
		/* 821F5510h case    5:*/		regs.R3 = regs.R31;
		/* 821F5510h case    5:*/		return 0x821F5514;
		  /* 821F5514h */ case    6:  		/* bl -541732 */
		/* 821F5514h case    6:*/		regs.LR = 0x821F5518; return 0x821710F0;
		/* 821F5514h case    6:*/		return 0x821F5518;
		  /* 821F5518h */ case    7:  		/* mr R30, R3 */
		/* 821F5518h case    7:*/		regs.R30 = regs.R3;
		/* 821F5518h case    7:*/		return 0x821F551C;
		  /* 821F551Ch */ case    8:  		/* mr R4, R29 */
		/* 821F551Ch case    8:*/		regs.R4 = regs.R29;
		/* 821F551Ch case    8:*/		return 0x821F5520;
		  /* 821F5520h */ case    9:  		/* mr R3, R31 */
		/* 821F5520h case    9:*/		regs.R3 = regs.R31;
		/* 821F5520h case    9:*/		return 0x821F5524;
		  /* 821F5524h */ case   10:  		/* lwz R11, <#[R30]> */
		/* 821F5524h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5524h case   10:*/		return 0x821F5528;
		  /* 821F5528h */ case   11:  		/* rlwimi R11, R27, 27, 4, 6 */
		/* 821F5528h case   11:*/		cpu::op::rlwimi<0,27,4,6>(regs,&regs.R11,regs.R27);
		/* 821F5528h case   11:*/		return 0x821F552C;
		  /* 821F552Ch */ case   12:  		/* rlwinm R10, R11, 23, 30, 31 */
		/* 821F552Ch case   12:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R10,regs.R11);
		/* 821F552Ch case   12:*/		return 0x821F5530;
		  /* 821F5530h */ case   13:  		/* rlwinm R9, R11, 25, 28, 29 */
		/* 821F5530h case   13:*/		cpu::op::rlwinm<0,25,28,29>(regs,&regs.R9,regs.R11);
		/* 821F5530h case   13:*/		return 0x821F5534;
		  /* 821F5534h */ case   14:  		/* rlwinm R8, R11, 31, 24, 27 */
		/* 821F5534h case   14:*/		cpu::op::rlwinm<0,31,24,27>(regs,&regs.R8,regs.R11);
		/* 821F5534h case   14:*/		return 0x821F5538;
		  /* 821F5538h */ case   15:  		/* or R10, R9, R10 */
		/* 821F5538h case   15:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821F5538h case   15:*/		return 0x821F553C;
		  /* 821F553Ch */ case   16:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821F553Ch case   16:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821F553Ch case   16:*/		return 0x821F5540;
		  /* 821F5540h */ case   17:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 821F5540h case   17:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821F5540h case   17:*/		return 0x821F5544;
		  /* 821F5544h */ case   18:  		/* or R10, R10, R8 */
		/* 821F5544h case   18:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821F5544h case   18:*/		return 0x821F5548;
		  /* 821F5548h */ case   19:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 821F5548h case   19:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 821F5548h case   19:*/		return 0x821F554C;
		  /* 821F554Ch */ case   20:  		/* or R11, R10, R11 */
		/* 821F554Ch case   20:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F554Ch case   20:*/		return 0x821F5550;
		  /* 821F5550h */ case   21:  		/* stw R11, <#[R30]> */
		/* 821F5550h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5550h case   21:*/		return 0x821F5554;
		  /* 821F5554h */ case   22:  		/* lwz R5, <#[R29 + 12]> */
		/* 821F5554h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821F5554h case   22:*/		return 0x821F5558;
		  /* 821F5558h */ case   23:  		/* bl -541800 */
		/* 821F5558h case   23:*/		regs.LR = 0x821F555C; return 0x821710F0;
		/* 821F5558h case   23:*/		return 0x821F555C;
		  /* 821F555Ch */ case   24:  		/* lwz R10, <#[R3]> */
		/* 821F555Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F555Ch case   24:*/		return 0x821F5560;
		  /* 821F5560h */ case   25:  		/* rlwimi R10, R27, 27, 4, 6 */
		/* 821F5560h case   25:*/		cpu::op::rlwimi<0,27,4,6>(regs,&regs.R10,regs.R27);
		/* 821F5560h case   25:*/		return 0x821F5564;
		  /* 821F5564h */ case   26:  		/* mr R11, R3 */
		/* 821F5564h case   26:*/		regs.R11 = regs.R3;
		/* 821F5564h case   26:*/		return 0x821F5568;
		  /* 821F5568h */ case   27:  		/* rlwinm R9, R10, 27, 24, 31 */
		/* 821F5568h case   27:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R10);
		/* 821F5568h case   27:*/		return 0x821F556C;
		  /* 821F556Ch */ case   28:  		/* rlwinm R8, R10, 23, 30, 31 */
		/* 821F556Ch case   28:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R8,regs.R10);
		/* 821F556Ch case   28:*/		return 0x821F5570;
		  /* 821F5570h */ case   29:  		/* rlwinm R7, R10, 25, 28, 29 */
		/* 821F5570h case   29:*/		cpu::op::rlwinm<0,25,28,29>(regs,&regs.R7,regs.R10);
		/* 821F5570h case   29:*/		return 0x821F5574;
		  /* 821F5574h */ case   30:  		/* mr R6, R9 */
		/* 821F5574h case   30:*/		regs.R6 = regs.R9;
		/* 821F5574h case   30:*/		return 0x821F5578;
		  /* 821F5578h */ case   31:  		/* or R8, R7, R8 */
		/* 821F5578h case   31:*/		cpu::op::or<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821F5578h case   31:*/		return 0x821F557C;
		  /* 821F557Ch */ case   32:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821F557Ch case   32:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821F557Ch case   32:*/		return 0x821F5580;
		  /* 821F5580h */ case   33:  		/* rlwimi R6, R8, 2, 26, 29 */
		/* 821F5580h case   33:*/		cpu::op::rlwimi<0,2,26,29>(regs,&regs.R6,regs.R8);
		/* 821F5580h case   33:*/		return 0x821F5584;
		  /* 821F5584h */ case   34:  		/* mr R4, R30 */
		/* 821F5584h case   34:*/		regs.R4 = regs.R30;
		/* 821F5584h case   34:*/		return 0x821F5588;
		  /* 821F5588h */ case   35:  		/* rlwinm R8, R6, 0, 26, 31 */
		/* 821F5588h case   35:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R8,regs.R6);
		/* 821F5588h case   35:*/		return 0x821F558C;
		  /* 821F558Ch */ case   36:  		/* mr R3, R31 */
		/* 821F558Ch case   36:*/		regs.R3 = regs.R31;
		/* 821F558Ch case   36:*/		return 0x821F5590;
		  /* 821F5590h */ case   37:  		/* rlwimi R9, R8, 4, 0, 27 */
		/* 821F5590h case   37:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R9,regs.R8);
		/* 821F5590h case   37:*/		return 0x821F5594;
		  /* 821F5594h */ case   38:  		/* mr R5, R11 */
		/* 821F5594h case   38:*/		regs.R5 = regs.R11;
		/* 821F5594h case   38:*/		return 0x821F5598;
		  /* 821F5598h */ case   39:  		/* rlwinm R9, R9, 3, 0, 26 */
		/* 821F5598h case   39:*/		cpu::op::rlwinm<0,3,0,26>(regs,&regs.R9,regs.R9);
		/* 821F5598h case   39:*/		return 0x821F559C;
		  /* 821F559Ch */ case   40:  		/* or R10, R9, R10 */
		/* 821F559Ch case   40:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821F559Ch case   40:*/		return 0x821F55A0;
		  /* 821F55A0h */ case   41:  		/* stw R10, <#[R11]> */
		/* 821F55A0h case   41:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F55A0h case   41:*/		return 0x821F55A4;
		  /* 821F55A4h */ case   42:  		/* bl -26772 */
		/* 821F55A4h case   42:*/		regs.LR = 0x821F55A8; return 0x821EED10;
		/* 821F55A4h case   42:*/		return 0x821F55A8;
		  /* 821F55A8h */ case   43:  		/* mr R30, R3 */
		/* 821F55A8h case   43:*/		regs.R30 = regs.R3;
		/* 821F55A8h case   43:*/		return 0x821F55AC;
		  /* 821F55ACh */ case   44:  		/* mr R3, R31 */
		/* 821F55ACh case   44:*/		regs.R3 = regs.R31;
		/* 821F55ACh case   44:*/		return 0x821F55B0;
		  /* 821F55B0h */ case   45:  		/* mr R4, R30 */
		/* 821F55B0h case   45:*/		regs.R4 = regs.R30;
		/* 821F55B0h case   45:*/		return 0x821F55B4;
		  /* 821F55B4h */ case   46:  		/* bl -513460 */
		/* 821F55B4h case   46:*/		regs.LR = 0x821F55B8; return 0x82178000;
		/* 821F55B4h case   46:*/		return 0x821F55B8;
		  /* 821F55B8h */ case   47:  		/* mr R11, R3 */
		/* 821F55B8h case   47:*/		regs.R11 = regs.R3;
		/* 821F55B8h case   47:*/		return 0x821F55BC;
		  /* 821F55BCh */ case   48:  		/* lis R10, 14 */
		/* 821F55BCh case   48:*/		cpu::op::lis<0>(regs,&regs.R10,0xE);
		/* 821F55BCh case   48:*/		return 0x821F55C0;
		  /* 821F55C0h */ case   49:  		/* mr R3, R31 */
		/* 821F55C0h case   49:*/		regs.R3 = regs.R31;
		/* 821F55C0h case   49:*/		return 0x821F55C4;
		  /* 821F55C4h */ case   50:  		/* ori R10, R10, 24833 */
		/* 821F55C4h case   50:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x6101);
		/* 821F55C4h case   50:*/		return 0x821F55C8;
		  /* 821F55C8h */ case   51:  		/* mr R4, R11 */
		/* 821F55C8h case   51:*/		regs.R4 = regs.R11;
		/* 821F55C8h case   51:*/		return 0x821F55CC;
		  /* 821F55CCh */ case   52:  		/* lwz R9, <#[R11]> */
		/* 821F55CCh case   52:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F55CCh case   52:*/		return 0x821F55D0;
		  /* 821F55D0h */ case   53:  		/* rlwimi R9, R10, 25, 19, 31 */
		/* 821F55D0h case   53:*/		cpu::op::rlwimi<0,25,19,31>(regs,&regs.R9,regs.R10);
		/* 821F55D0h case   53:*/		return 0x821F55D4;
		  /* 821F55D4h */ case   54:  		/* rlwimi R9, R10, 25, 4, 6 */
		/* 821F55D4h case   54:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R9,regs.R10);
		/* 821F55D4h case   54:*/		return 0x821F55D8;
		  /* 821F55D8h */ case   55:  		/* stw R9, <#[R11]> */
		/* 821F55D8h case   55:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F55D8h case   55:*/		return 0x821F55DC;
		  /* 821F55DCh */ case   56:  		/* bl -25588 */
		/* 821F55DCh case   56:*/		regs.LR = 0x821F55E0; return 0x821EF1E8;
		/* 821F55DCh case   56:*/		return 0x821F55E0;
		  /* 821F55E0h */ case   57:  		/* mr R29, R3 */
		/* 821F55E0h case   57:*/		regs.R29 = regs.R3;
		/* 821F55E0h case   57:*/		return 0x821F55E4;
		  /* 821F55E4h */ case   58:  		/* mr R4, R30 */
		/* 821F55E4h case   58:*/		regs.R4 = regs.R30;
		/* 821F55E4h case   58:*/		return 0x821F55E8;
		  /* 821F55E8h */ case   59:  		/* mr R3, R31 */
		/* 821F55E8h case   59:*/		regs.R3 = regs.R31;
		/* 821F55E8h case   59:*/		return 0x821F55EC;
		  /* 821F55ECh */ case   60:  		/* bl -513516 */
		/* 821F55ECh case   60:*/		regs.LR = 0x821F55F0; return 0x82178000;
		/* 821F55ECh case   60:*/		return 0x821F55F0;
		  /* 821F55F0h */ case   61:  		/* mr R28, R3 */
		/* 821F55F0h case   61:*/		regs.R28 = regs.R3;
		/* 821F55F0h case   61:*/		return 0x821F55F4;
		  /* 821F55F4h */ case   62:  		/* mr R4, R29 */
		/* 821F55F4h case   62:*/		regs.R4 = regs.R29;
		/* 821F55F4h case   62:*/		return 0x821F55F8;
		  /* 821F55F8h */ case   63:  		/* mr R3, R31 */
		/* 821F55F8h case   63:*/		regs.R3 = regs.R31;
		/* 821F55F8h case   63:*/		return 0x821F55FC;
		  /* 821F55FCh */ case   64:  		/* lwz R11, <#[R28]> */
		/* 821F55FCh case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F55FCh case   64:*/		return 0x821F5600;
		  /* 821F5600h */ case   65:  		/* rlwimi R11, R27, 26, 4, 6 */
		/* 821F5600h case   65:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R11,regs.R27);
		/* 821F5600h case   65:*/		return 0x821F5604;
		  /* 821F5604h */ case   66:  		/* stw R11, <#[R28]> */
		/* 821F5604h case   66:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5604h case   66:*/		return 0x821F5608;
		  /* 821F5608h */ case   67:  		/* bl -513544 */
		/* 821F5608h case   67:*/		regs.LR = 0x821F560C; return 0x82178000;
		/* 821F5608h case   67:*/		return 0x821F560C;
		  /* 821F560Ch */ case   68:  		/* mr R11, R3 */
		/* 821F560Ch case   68:*/		regs.R11 = regs.R3;
		/* 821F560Ch case   68:*/		return 0x821F5610;
		  /* 821F5610h */ case   69:  		/* lis R10, 1 */
		/* 821F5610h case   69:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 821F5610h case   69:*/		return 0x821F5614;
		  /* 821F5614h */ case   70:  		/* mr R4, R28 */
		/* 821F5614h case   70:*/		regs.R4 = regs.R28;
		/* 821F5614h case   70:*/		return 0x821F5618;
		  /* 821F5618h */ case   71:  		/* ori R10, R10, 7 */
		/* 821F5618h case   71:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x7);
		/* 821F5618h case   71:*/		return 0x821F561C;
		  /* 821F561Ch */ case   72:  		/* mr R3, R31 */
		/* 821F561Ch case   72:*/		regs.R3 = regs.R31;
		/* 821F561Ch case   72:*/		return 0x821F5620;
		  /* 821F5620h */ case   73:  		/* lwz R9, <#[R11]> */
		/* 821F5620h case   73:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5620h case   73:*/		return 0x821F5624;
		  /* 821F5624h */ case   74:  		/* mr R5, R11 */
		/* 821F5624h case   74:*/		regs.R5 = regs.R11;
		/* 821F5624h case   74:*/		return 0x821F5628;
		  /* 821F5628h */ case   75:  		/* rlwimi R9, R10, 10, 19, 26 */
		/* 821F5628h case   75:*/		cpu::op::rlwimi<0,10,19,26>(regs,&regs.R9,regs.R10);
		/* 821F5628h case   75:*/		return 0x821F562C;
		  /* 821F562Ch */ case   76:  		/* rlwimi R9, R10, 10, 4, 6 */
		/* 821F562Ch case   76:*/		cpu::op::rlwimi<0,10,4,6>(regs,&regs.R9,regs.R10);
		/* 821F562Ch case   76:*/		return 0x821F5630;
		  /* 821F5630h */ case   77:  		/* stw R9, <#[R11]> */
		/* 821F5630h case   77:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5630h case   77:*/		return 0x821F5634;
		  /* 821F5634h */ case   78:  		/* bl -29692 */
		/* 821F5634h case   78:*/		regs.LR = 0x821F5638; return 0x821EE238;
		/* 821F5634h case   78:*/		return 0x821F5638;
		  /* 821F5638h */ case   79:  		/* lis R11, -32256 */
		/* 821F5638h case   79:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F5638h case   79:*/		return 0x821F563C;
		  /* 821F563Ch */ case   80:  		/* mr R29, R3 */
		/* 821F563Ch case   80:*/		regs.R29 = regs.R3;
		/* 821F563Ch case   80:*/		return 0x821F5640;
		  /* 821F5640h */ case   81:  		/* li R5, 1 */
		/* 821F5640h case   81:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F5640h case   81:*/		return 0x821F5644;
		  /* 821F5644h */ case   82:  		/* lfs FR4, <#[R11 + 1816]> */
		/* 821F5644h case   82:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000718) );
		/* 821F5644h case   82:*/		return 0x821F5648;
		  /* 821F5648h */ case   83:  		/* lis R11, -32256 */
		/* 821F5648h case   83:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F5648h case   83:*/		return 0x821F564C;
		  /* 821F564Ch */ case   84:  		/* mr R4, R31 */
		/* 821F564Ch case   84:*/		regs.R4 = regs.R31;
		/* 821F564Ch case   84:*/		return 0x821F5650;
		  /* 821F5650h */ case   85:  		/* lfs FR1, <#[R11 + 8732]> */
		/* 821F5650h case   85:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x0000221C) );
		/* 821F5650h case   85:*/		return 0x821F5654;
		  /* 821F5654h */ case   86:  		/* addi R3, R1, 80 */
		/* 821F5654h case   86:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F5654h case   86:*/		return 0x821F5658;
		  /* 821F5658h */ case   87:  		/* fmr FR3, FR4 */
		/* 821F5658h case   87:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 821F5658h case   87:*/		return 0x821F565C;
		  /* 821F565Ch */ case   88:  		/* fmr FR2, FR4 */
		/* 821F565Ch case   88:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 821F565Ch case   88:*/		return 0x821F5660;
		  /* 821F5660h */ case   89:  		/* bl 202736 */
		/* 821F5660h case   89:*/		regs.LR = 0x821F5664; return 0x82226E50;
		/* 821F5660h case   89:*/		return 0x821F5664;
		  /* 821F5664h */ case   90:  		/* mr R4, R29 */
		/* 821F5664h case   90:*/		regs.R4 = regs.R29;
		/* 821F5664h case   90:*/		return 0x821F5668;
		  /* 821F5668h */ case   91:  		/* mr R3, R31 */
		/* 821F5668h case   91:*/		regs.R3 = regs.R31;
		/* 821F5668h case   91:*/		return 0x821F566C;
		  /* 821F566Ch */ case   92:  		/* bl -513644 */
		/* 821F566Ch case   92:*/		regs.LR = 0x821F5670; return 0x82178000;
		/* 821F566Ch case   92:*/		return 0x821F5670;
		  /* 821F5670h */ case   93:  		/* mr R29, R3 */
		/* 821F5670h case   93:*/		regs.R29 = regs.R3;
		/* 821F5670h case   93:*/		return 0x821F5674;
		  /* 821F5674h */ case   94:  		/* addi R4, R1, 80 */
		/* 821F5674h case   94:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821F5674h case   94:*/		return 0x821F5678;
		  /* 821F5678h */ case   95:  		/* mr R3, R31 */
		/* 821F5678h case   95:*/		regs.R3 = regs.R31;
		/* 821F5678h case   95:*/		return 0x821F567C;
		  /* 821F567Ch */ case   96:  		/* lwz R11, <#[R29]> */
		/* 821F567Ch case   96:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F567Ch case   96:*/		return 0x821F5680;
		  /* 821F5680h */ case   97:  		/* rlwimi R11, R27, 26, 4, 6 */
		/* 821F5680h case   97:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R11,regs.R27);
		/* 821F5680h case   97:*/		return 0x821F5684;
		  /* 821F5684h */ case   98:  		/* stw R11, <#[R29]> */
		/* 821F5684h case   98:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F5684h case   98:*/		return 0x821F5688;
		  /* 821F5688h */ case   99:  		/* bl -13064 */
		/* 821F5688h case   99:*/		regs.LR = 0x821F568C; return 0x821F2380;
		/* 821F5688h case   99:*/		return 0x821F568C;
		  /* 821F568Ch */ case  100:  		/* mr R11, R3 */
		/* 821F568Ch case  100:*/		regs.R11 = regs.R3;
		/* 821F568Ch case  100:*/		return 0x821F5690;
		  /* 821F5690h */ case  101:  		/* mr R4, R29 */
		/* 821F5690h case  101:*/		regs.R4 = regs.R29;
		/* 821F5690h case  101:*/		return 0x821F5694;
		  /* 821F5694h */ case  102:  		/* mr R3, R31 */
		/* 821F5694h case  102:*/		regs.R3 = regs.R31;
		/* 821F5694h case  102:*/		return 0x821F5698;
		  /* 821F5698h */ case  103:  		/* mr R5, R11 */
		/* 821F5698h case  103:*/		regs.R5 = regs.R11;
		/* 821F5698h case  103:*/		return 0x821F569C;
		  /* 821F569Ch */ case  104:  		/* lwz R10, <#[R11]> */
		/* 821F569Ch case  104:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F569Ch case  104:*/		return 0x821F56A0;
		  /* 821F56A0h */ case  105:  		/* rlwimi R10, R27, 26, 4, 6 */
		/* 821F56A0h case  105:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R10,regs.R27);
		/* 821F56A0h case  105:*/		return 0x821F56A4;
		  /* 821F56A4h */ case  106:  		/* rlwinm R9, R10, 27, 24, 31 */
		/* 821F56A4h case  106:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R10);
		/* 821F56A4h case  106:*/		return 0x821F56A8;
		  /* 821F56A8h */ case  107:  		/* rlwinm R8, R10, 27, 30, 31 */
		/* 821F56A8h case  107:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R8,regs.R10);
		/* 821F56A8h case  107:*/		return 0x821F56AC;
		  /* 821F56ACh */ case  108:  		/* mr R7, R9 */
		/* 821F56ACh case  108:*/		regs.R7 = regs.R9;
		/* 821F56ACh case  108:*/		return 0x821F56B0;
		  /* 821F56B0h */ case  109:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 821F56B0h case  109:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 821F56B0h case  109:*/		return 0x821F56B4;
		  /* 821F56B4h */ case  110:  		/* rlwinm R9, R7, 0, 0, 29 */
		/* 821F56B4h case  110:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R7);
		/* 821F56B4h case  110:*/		return 0x821F56B8;
		  /* 821F56B8h */ case  111:  		/* or R9, R9, R8 */
		/* 821F56B8h case  111:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821F56B8h case  111:*/		return 0x821F56BC;
		  /* 821F56BCh */ case  112:  		/* rlwimi R10, R9, 5, 19, 26 */
		/* 821F56BCh case  112:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R10,regs.R9);
		/* 821F56BCh case  112:*/		return 0x821F56C0;
		  /* 821F56C0h */ case  113:  		/* stw R10, <#[R11]> */
		/* 821F56C0h case  113:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F56C0h case  113:*/		return 0x821F56C4;
		  /* 821F56C4h */ case  114:  		/* bl -30076 */
		/* 821F56C4h case  114:*/		regs.LR = 0x821F56C8; return 0x821EE148;
		/* 821F56C4h case  114:*/		return 0x821F56C8;
		  /* 821F56C8h */ case  115:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F56C8h case  115:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F56C8h case  115:*/		return 0x821F56CC;
		  /* 821F56CCh */ case  116:  		/* mr R29, R3 */
		/* 821F56CCh case  116:*/		regs.R29 = regs.R3;
		/* 821F56CCh case  116:*/		return 0x821F56D0;
		  /* 821F56D0h */ case  117:  		/* addi R5, R4, 24 */
		/* 821F56D0h case  117:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821F56D0h case  117:*/		return 0x821F56D4;
		  /* 821F56D4h */ case  118:  		/* li R6, 3 */
		/* 821F56D4h case  118:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821F56D4h case  118:*/		return 0x821F56D8;
		  /* 821F56D8h */ case  119:  		/* mr R3, R31 */
		/* 821F56D8h case  119:*/		regs.R3 = regs.R31;
		/* 821F56D8h case  119:*/		return 0x821F56DC;
		  /* 821F56DCh */ case  120:  		/* bl 193572 */
		/* 821F56DCh case  120:*/		regs.LR = 0x821F56E0; return 0x82224B00;
		/* 821F56DCh case  120:*/		return 0x821F56E0;
		  /* 821F56E0h */ case  121:  		/* mr R28, R3 */
		/* 821F56E0h case  121:*/		regs.R28 = regs.R3;
		/* 821F56E0h case  121:*/		return 0x821F56E4;
		  /* 821F56E4h */ case  122:  		/* mr R4, R29 */
		/* 821F56E4h case  122:*/		regs.R4 = regs.R29;
		/* 821F56E4h case  122:*/		return 0x821F56E8;
		  /* 821F56E8h */ case  123:  		/* mr R3, R31 */
		/* 821F56E8h case  123:*/		regs.R3 = regs.R31;
		/* 821F56E8h case  123:*/		return 0x821F56EC;
		  /* 821F56ECh */ case  124:  		/* bl -513772 */
		/* 821F56ECh case  124:*/		regs.LR = 0x821F56F0; return 0x82178000;
		/* 821F56ECh case  124:*/		return 0x821F56F0;
		  /* 821F56F0h */ case  125:  		/* mr R20, R3 */
		/* 821F56F0h case  125:*/		regs.R20 = regs.R3;
		/* 821F56F0h case  125:*/		return 0x821F56F4;
		  /* 821F56F4h */ case  126:  		/* lis R11, 14 */
		/* 821F56F4h case  126:*/		cpu::op::lis<0>(regs,&regs.R11,0xE);
		/* 821F56F4h case  126:*/		return 0x821F56F8;
		  /* 821F56F8h */ case  127:  		/* mr R4, R29 */
		/* 821F56F8h case  127:*/		regs.R4 = regs.R29;
		/* 821F56F8h case  127:*/		return 0x821F56FC;
		  /* 821F56FCh */ case  128:  		/* ori R11, R11, 20481 */
		/* 821F56FCh case  128:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x5001);
		/* 821F56FCh case  128:*/		return 0x821F5700;
		  /* 821F5700h */ case  129:  		/* mr R3, R31 */
		/* 821F5700h case  129:*/		regs.R3 = regs.R31;
		/* 821F5700h case  129:*/		return 0x821F5704;
		  /* 821F5704h */ case  130:  		/* lwz R10, <#[R20]> */
		/* 821F5704h case  130:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 821F5704h case  130:*/		return 0x821F5708;
		  /* 821F5708h */ case  131:  		/* rlwimi R10, R11, 25, 19, 26 */
		/* 821F5708h case  131:*/		cpu::op::rlwimi<0,25,19,26>(regs,&regs.R10,regs.R11);
		/* 821F5708h case  131:*/		return 0x821F570C;
		  /* 821F570Ch */ case  132:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 821F570Ch case  132:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 821F570Ch case  132:*/		return 0x821F5710;
		  /* 821F5710h */ case  133:  		/* stw R10, <#[R20]> */
		/* 821F5710h case  133:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 821F5710h case  133:*/		return 0x821F5714;
		  /* 821F5714h */ case  134:  		/* bl -513812 */
		/* 821F5714h case  134:*/		regs.LR = 0x821F5718; return 0x82178000;
		/* 821F5714h case  134:*/		return 0x821F5718;
		  /* 821F5718h */ case  135:  		/* mr R29, R3 */
		/* 821F5718h case  135:*/		regs.R29 = regs.R3;
		/* 821F5718h case  135:*/		return 0x821F571C;
		  /* 821F571Ch */ case  136:  		/* mr R4, R30 */
		/* 821F571Ch case  136:*/		regs.R4 = regs.R30;
		/* 821F571Ch case  136:*/		return 0x821F5720;
		  /* 821F5720h */ case  137:  		/* mr R3, R31 */
		/* 821F5720h case  137:*/		regs.R3 = regs.R31;
		/* 821F5720h case  137:*/		return 0x821F5724;
		  /* 821F5724h */ case  138:  		/* lwz R11, <#[R29]> */
		/* 821F5724h case  138:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F5724h case  138:*/		return 0x821F5728;
		  /* 821F5728h */ case  139:  		/* rlwimi R11, R27, 25, 4, 6 */
		/* 821F5728h case  139:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R27);
		/* 821F5728h case  139:*/		return 0x821F572C;
		  /* 821F572Ch */ case  140:  		/* stw R11, <#[R29]> */
		/* 821F572Ch case  140:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F572Ch case  140:*/		return 0x821F5730;
		  /* 821F5730h */ case  141:  		/* bl -513840 */
		/* 821F5730h case  141:*/		regs.LR = 0x821F5734; return 0x82178000;
		/* 821F5730h case  141:*/		return 0x821F5734;
		  /* 821F5734h */ case  142:  		/* mr R30, R3 */
		/* 821F5734h case  142:*/		regs.R30 = regs.R3;
		/* 821F5734h case  142:*/		return 0x821F5738;
		  /* 821F5738h */ case  143:  		/* lis R11, 14 */
		/* 821F5738h case  143:*/		cpu::op::lis<0>(regs,&regs.R11,0xE);
		/* 821F5738h case  143:*/		return 0x821F573C;
		  /* 821F573Ch */ case  144:  		/* mr R3, R28 */
		/* 821F573Ch case  144:*/		regs.R3 = regs.R28;
		/* 821F573Ch case  144:*/		return 0x821F5740;
		  /* 821F5740h */ case  145:  		/* ori R11, R11, 28673 */
		/* 821F5740h case  145:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x7001);
		/* 821F5740h case  145:*/		return 0x821F5744;
		  /* 821F5744h */ case  146:  		/* mr R4, R20 */
		/* 821F5744h case  146:*/		regs.R4 = regs.R20;
		/* 821F5744h case  146:*/		return 0x821F5748;
		  /* 821F5748h */ case  147:  		/* lwz R10, <#[R30]> */
		/* 821F5748h case  147:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5748h case  147:*/		return 0x821F574C;
		  /* 821F574Ch */ case  148:  		/* rlwimi R10, R11, 25, 19, 26 */
		/* 821F574Ch case  148:*/		cpu::op::rlwimi<0,25,19,26>(regs,&regs.R10,regs.R11);
		/* 821F574Ch case  148:*/		return 0x821F5750;
		  /* 821F5750h */ case  149:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 821F5750h case  149:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 821F5750h case  149:*/		return 0x821F5754;
		  /* 821F5754h */ case  150:  		/* stw R10, <#[R30]> */
		/* 821F5754h case  150:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5754h case  150:*/		return 0x821F5758;
		  /* 821F5758h */ case  151:  		/* bl -513424 */
		/* 821F5758h case  151:*/		regs.LR = 0x821F575C; return 0x821781C8;
		/* 821F5758h case  151:*/		return 0x821F575C;
		  /* 821F575Ch */ case  152:  		/* stw R3, <#[R28 + 44]> */
		/* 821F575Ch case  152:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F575Ch case  152:*/		return 0x821F5760;
		  /* 821F5760h */ case  153:  		/* mr R3, R28 */
		/* 821F5760h case  153:*/		regs.R3 = regs.R28;
		/* 821F5760h case  153:*/		return 0x821F5764;
		  /* 821F5764h */ case  154:  		/* mr R4, R29 */
		/* 821F5764h case  154:*/		regs.R4 = regs.R29;
		/* 821F5764h case  154:*/		return 0x821F5768;
		  /* 821F5768h */ case  155:  		/* bl -513440 */
		/* 821F5768h case  155:*/		regs.LR = 0x821F576C; return 0x821781C8;
		/* 821F5768h case  155:*/		return 0x821F576C;
		  /* 821F576Ch */ case  156:  		/* stw R3, <#[R28 + 48]> */
		/* 821F576Ch case  156:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000030) );
		/* 821F576Ch case  156:*/		return 0x821F5770;
		  /* 821F5770h */ case  157:  		/* mr R3, R28 */
		/* 821F5770h case  157:*/		regs.R3 = regs.R28;
		/* 821F5770h case  157:*/		return 0x821F5774;
		  /* 821F5774h */ case  158:  		/* mr R4, R30 */
		/* 821F5774h case  158:*/		regs.R4 = regs.R30;
		/* 821F5774h case  158:*/		return 0x821F5778;
		  /* 821F5778h */ case  159:  		/* bl -513456 */
		/* 821F5778h case  159:*/		regs.LR = 0x821F577C; return 0x821781C8;
		/* 821F5778h case  159:*/		return 0x821F577C;
		  /* 821F577Ch */ case  160:  		/* stw R3, <#[R28 + 52]> */
		/* 821F577Ch case  160:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000034) );
		/* 821F577Ch case  160:*/		return 0x821F5780;
		  /* 821F5780h */ case  161:  		/* mr R4, R28 */
		/* 821F5780h case  161:*/		regs.R4 = regs.R28;
		/* 821F5780h case  161:*/		return 0x821F5784;
		  /* 821F5784h */ case  162:  		/* mr R3, R31 */
		/* 821F5784h case  162:*/		regs.R3 = regs.R31;
		/* 821F5784h case  162:*/		return 0x821F5788;
		  /* 821F5788h */ case  163:  		/* bl -513928 */
		/* 821F5788h case  163:*/		regs.LR = 0x821F578C; return 0x82178000;
		/* 821F5788h case  163:*/		return 0x821F578C;
		  /* 821F578Ch */ case  164:  		/* mr R29, R3 */
		/* 821F578Ch case  164:*/		regs.R29 = regs.R3;
		/* 821F578Ch case  164:*/		return 0x821F5790;
	}
	return 0x821F5790;
} // Block from 821F54FCh-821F5790h (165 instructions)

//////////////////////////////////////////////////////
// Block at 821F5790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5790);
		  /* 821F5790h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821F5790h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F5790h case    0:*/		return 0x821F5794;
		  /* 821F5794h */ case    1:  		/* rlwimi R11, R24, 25, 4, 6 */
		/* 821F5794h case    1:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R24);
		/* 821F5794h case    1:*/		return 0x821F5798;
		  /* 821F5798h */ case    2:  		/* stw R11, <#[R29]> */
		/* 821F5798h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821F5798h case    2:*/		return 0x821F579C;
		  /* 821F579Ch */ case    3:  		/* lwz R30, <#[R26]> */
		/* 821F579Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 821F579Ch case    3:*/		return 0x821F57A0;
		  /* 821F57A0h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 821F57A0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821F57A0h case    4:*/		return 0x821F57A4;
		  /* 821F57A4h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 821F57A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821F57B8;  }
		/* 821F57A4h case    5:*/		return 0x821F57A8;
		  /* 821F57A8h */ case    6:  		/* lwz R11, <#[R26 + 4]> */
		/* 821F57A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821F57A8h case    6:*/		return 0x821F57AC;
		  /* 821F57ACh */ case    7:  		/* rlwinm. R11, R11, 0, 30, 31 */
		/* 821F57ACh case    7:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821F57ACh case    7:*/		return 0x821F57B0;
		  /* 821F57B0h */ case    8:  		/* mr R11, R27 */
		/* 821F57B0h case    8:*/		regs.R11 = regs.R27;
		/* 821F57B0h case    8:*/		return 0x821F57B4;
		  /* 821F57B4h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 821F57B4h case    9:*/		if ( regs.CR[0].eq ) { return 0x821F57BC;  }
		/* 821F57B4h case    9:*/		return 0x821F57B8;
	}
	return 0x821F57B8;
} // Block from 821F5790h-821F57B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F57B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F57B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F57B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F57B8);
		  /* 821F57B8h */ case    0:  		/* li R11, 0 */
		/* 821F57B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821F57B8h case    0:*/		return 0x821F57BC;
	}
	return 0x821F57BC;
} // Block from 821F57B8h-821F57BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F57BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F57BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F57BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F57BC);
		  /* 821F57BCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821F57BCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821F57BCh case    0:*/		return 0x821F57C0;
		  /* 821F57C0h */ case    1:  		/* bc 12, CR0_EQ, 68 */
		/* 821F57C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821F5804;  }
		/* 821F57C0h case    1:*/		return 0x821F57C4;
		  /* 821F57C4h */ case    2:  		/* lwz R10, <#[R26 + 4]> */
		/* 821F57C4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 821F57C4h case    2:*/		return 0x821F57C8;
		  /* 821F57C8h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 821F57C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821F57C8h case    3:*/		return 0x821F57CC;
		  /* 821F57CCh */ case    4:  		/* rlwinm R10, R10, 15, 17, 31 */
		/* 821F57CCh case    4:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R10,regs.R10);
		/* 821F57CCh case    4:*/		return 0x821F57D0;
		  /* 821F57D0h */ case    5:  		/* mulli R10, R10, 40 */
		/* 821F57D0h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F57D0h case    5:*/		return 0x821F57D4;
		  /* 821F57D4h */ case    6:  		/* add R11, R10, R11 */
		/* 821F57D4h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F57D4h case    6:*/		return 0x821F57D8;
		  /* 821F57D8h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F57D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F57D8h case    7:*/		return 0x821F57DC;
		  /* 821F57DCh */ case    8:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821F57DCh case    8:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821F57DCh case    8:*/		return 0x821F57E0;
		  /* 821F57E0h */ case    9:  		/* cmplwi CR6, R11, 48 */
		/* 821F57E0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821F57E0h case    9:*/		return 0x821F57E4;
		  /* 821F57E4h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 821F57E4h case   10:*/		if ( regs.CR[6].eq ) { return 0x821F57F4;  }
		/* 821F57E4h case   10:*/		return 0x821F57E8;
		  /* 821F57E8h */ case   11:  		/* li R4, 4801 */
		/* 821F57E8h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F57E8h case   11:*/		return 0x821F57EC;
		  /* 821F57ECh */ case   12:  		/* mr R3, R31 */
		/* 821F57ECh case   12:*/		regs.R3 = regs.R31;
		/* 821F57ECh case   12:*/		return 0x821F57F0;
		  /* 821F57F0h */ case   13:  		/* bl -670088 */
		/* 821F57F0h case   13:*/		regs.LR = 0x821F57F4; return 0x82151E68;
		/* 821F57F0h case   13:*/		return 0x821F57F4;
	}
	return 0x821F57F4;
} // Block from 821F57BCh-821F57F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F57F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F57F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F57F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F57F4);
		  /* 821F57F4h */ case    0:  		/* lwz R11, <#[R31 + 40]> */
		/* 821F57F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F57F4h case    0:*/		return 0x821F57F8;
		  /* 821F57F8h */ case    1:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 821F57F8h case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 821F57F8h case    1:*/		return 0x821F57FC;
		  /* 821F57FCh */ case    2:  		/* bc 12, CR0_EQ, 344 */
		/* 821F57FCh case    2:*/		if ( regs.CR[0].eq ) { return 0x821F5954;  }
		/* 821F57FCh case    2:*/		return 0x821F5800;
		  /* 821F5800h */ case    3:  		/* b 244 */
		/* 821F5800h case    3:*/		return 0x821F58F4;
		/* 821F5800h case    3:*/		return 0x821F5804;
	}
	return 0x821F5804;
} // Block from 821F57F4h-821F5804h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F5804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5804);
		  /* 821F5804h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 821F5804h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821F5804h case    0:*/		return 0x821F5808;
	}
	return 0x821F5808;
} // Block from 821F5804h-821F5808h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F5808h
// Function '?ImportVariableInitialValue@Compiler@D3DXShader@@AAAXPAVResultStack@2@IPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5808);
		  /* 821F5808h */ case    0:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 821F5808h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821F5808h case    0:*/		return 0x821F580C;
		  /* 821F580Ch */ case    1:  		/* cmpwi CR6, R11, 3 */
		/* 821F580Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821F580Ch case    1:*/		return 0x821F5810;
		  /* 821F5810h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 821F5810h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821F5820;  }
		/* 821F5810h case    2:*/		return 0x821F5814;
		  /* 821F5814h */ case    3:  		/* li R4, 4801 */
		/* 821F5814h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F5814h case    3:*/		return 0x821F5818;
		  /* 821F5818h */ case    4:  		/* mr R3, R31 */
		/* 821F5818h case    4:*/		regs.R3 = regs.R31;
		/* 821F5818h case    4:*/		return 0x821F581C;
		  /* 821F581Ch */ case    5:  		/* bl -670132 */
		/* 821F581Ch case    5:*/		regs.LR = 0x821F5820; return 0x82151E68;
		/* 821F581Ch case    5:*/		return 0x821F5820;
	}
	return 0x821F5820;
} // Block from 821F5808h-821F5820h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F5820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5820);
		  /* 821F5820h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 821F5820h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821F5820h case    0:*/		return 0x821F5824;
		  /* 821F5824h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 821F5824h case    1:*/		if ( regs.CR[6].eq ) { return 0x821F5848;  }
		/* 821F5824h case    1:*/		return 0x821F5828;
		  /* 821F5828h */ case    2:  		/* cmplwi CR6, R11, 2 */
		/* 821F5828h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821F5828h case    2:*/		return 0x821F582C;
		  /* 821F582Ch */ case    3:  		/* bc 4, CR6_EQ, 540 */
		/* 821F582Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F5A48;  }
		/* 821F582Ch case    3:*/		return 0x821F5830;
		  /* 821F5830h */ case    4:  		/* lwz R11, <#[R30]> */
		/* 821F5830h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5830h case    4:*/		return 0x821F5834;
		  /* 821F5834h */ case    5:  		/* rlwinm. R10, R11, 0, 25, 26 */
		/* 821F5834h case    5:*/		cpu::op::rlwinm<1,0,25,26>(regs,&regs.R10,regs.R11);
		/* 821F5834h case    5:*/		return 0x821F5838;
		  /* 821F5838h */ case    6:  		/* bc 4, CR0_EQ, 516 */
		/* 821F5838h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821F5A3C;  }
		/* 821F5838h case    6:*/		return 0x821F583C;
		  /* 821F583Ch */ case    7:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 821F583Ch case    7:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821F583Ch case    7:*/		return 0x821F5840;
		  /* 821F5840h */ case    8:  		/* bc 4, CR0_EQ, 508 */
		/* 821F5840h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821F5A3C;  }
		/* 821F5840h case    8:*/		return 0x821F5844;
		  /* 821F5844h */ case    9:  		/* lwz R30, <#[R30 + 12]> */
		/* 821F5844h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x0000000C) );
		/* 821F5844h case    9:*/		return 0x821F5848;
	}
	return 0x821F5848;
} // Block from 821F5820h-821F5848h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F5848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5848);
		  /* 821F5848h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5848h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5848h case    0:*/		return 0x821F584C;
		  /* 821F584Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821F584Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821F584Ch case    1:*/		return 0x821F5850;
		  /* 821F5850h */ case    2:  		/* cmplwi CR6, R11, 384 */
		/* 821F5850h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000180);
		/* 821F5850h case    2:*/		return 0x821F5854;
		  /* 821F5854h */ case    3:  		/* bc 4, CR6_EQ, 72 */
		/* 821F5854h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F589C;  }
		/* 821F5854h case    3:*/		return 0x821F5858;
		  /* 821F5858h */ case    4:  		/* lwz R28, <#[R30 + 44]> */
		/* 821F5858h case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F5858h case    4:*/		return 0x821F585C;
		  /* 821F585Ch */ case    5:  		/* lwz R4, <#[R30 + 48]> */
		/* 821F585Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 821F585Ch case    5:*/		return 0x821F5860;
		  /* 821F5860h */ case    6:  		/* mr R3, R28 */
		/* 821F5860h case    6:*/		regs.R3 = regs.R28;
		/* 821F5860h case    6:*/		return 0x821F5864;
		  /* 821F5864h */ case    7:  		/* bl -595420 */
		/* 821F5864h case    7:*/		regs.LR = 0x821F5868; return 0x82164288;
		/* 821F5864h case    7:*/		return 0x821F5868;
		  /* 821F5868h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821F5868h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821F5868h case    8:*/		return 0x821F586C;
		  /* 821F586Ch */ case    9:  		/* bc 12, CR0_EQ, 148 */
		/* 821F586Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821F5900;  }
		/* 821F586Ch case    9:*/		return 0x821F5870;
		  /* 821F5870h */ case   10:  		/* lwz R11, <#[R28]> */
		/* 821F5870h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5870h case   10:*/		return 0x821F5874;
		  /* 821F5874h */ case   11:  		/* lis R10, 512 */
		/* 821F5874h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 821F5874h case   11:*/		return 0x821F5878;
		  /* 821F5878h */ case   12:  		/* rlwinm R9, R11, 0, 4, 6 */
		/* 821F5878h case   12:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R11);
		/* 821F5878h case   12:*/		return 0x821F587C;
		  /* 821F587Ch */ case   13:  		/* cmplw CR6, R9, R10 */
		/* 821F587Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 821F587Ch case   13:*/		return 0x821F5880;
		  /* 821F5880h */ case   14:  		/* bc 4, CR6_EQ, 128 */
		/* 821F5880h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821F5900;  }
		/* 821F5880h case   14:*/		return 0x821F5884;
		  /* 821F5884h */ case   15:  		/* rlwinm. R10, R11, 0, 25, 26 */
		/* 821F5884h case   15:*/		cpu::op::rlwinm<1,0,25,26>(regs,&regs.R10,regs.R11);
		/* 821F5884h case   15:*/		return 0x821F5888;
		  /* 821F5888h */ case   16:  		/* bc 4, CR0_EQ, 120 */
		/* 821F5888h case   16:*/		if ( !regs.CR[0].eq ) { return 0x821F5900;  }
		/* 821F5888h case   16:*/		return 0x821F588C;
		  /* 821F588Ch */ case   17:  		/* andi. R11, R11, 23 */
		/* 821F588Ch case   17:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 821F588Ch case   17:*/		return 0x821F5890;
		  /* 821F5890h */ case   18:  		/* cmplwi CR0, R11, 0 */
		/* 821F5890h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821F5890h case   18:*/		return 0x821F5894;
		  /* 821F5894h */ case   19:  		/* bc 4, CR0_EQ, 108 */
		/* 821F5894h case   19:*/		if ( !regs.CR[0].eq ) { return 0x821F5900;  }
		/* 821F5894h case   19:*/		return 0x821F5898;
		  /* 821F5898h */ case   20:  		/* lwz R30, <#[R28 + 12]> */
		/* 821F5898h case   20:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x0000000C) );
		/* 821F5898h case   20:*/		return 0x821F589C;
	}
	return 0x821F589C;
} // Block from 821F5848h-821F589Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F589Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F589C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F589C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F589C);
		  /* 821F589Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F589Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F589Ch case    0:*/		return 0x821F58A0;
		  /* 821F58A0h */ case    1:  		/* rlwinm R28, R11, 25, 25, 31 */
		/* 821F58A0h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R28,regs.R11);
		/* 821F58A0h case    1:*/		return 0x821F58A4;
		  /* 821F58A4h */ case    2:  		/* cmplwi CR6, R28, 118 */
		/* 821F58A4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000076);
		/* 821F58A4h case    2:*/		return 0x821F58A8;
		  /* 821F58A8h */ case    3:  		/* bc 12, CR6_EQ, 172 */
		/* 821F58A8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821F5954;  }
		/* 821F58A8h case    3:*/		return 0x821F58AC;
		  /* 821F58ACh */ case    4:  		/* cmplwi CR6, R28, 112 */
		/* 821F58ACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000070);
		/* 821F58ACh case    4:*/		return 0x821F58B0;
		  /* 821F58B0h */ case    5:  		/* bc 4, CR6_EQ, 92 */
		/* 821F58B0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F590C;  }
		/* 821F58B0h case    5:*/		return 0x821F58B4;
		  /* 821F58B4h */ case    6:  		/* li R6, 1 */
		/* 821F58B4h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821F58B4h case    6:*/		return 0x821F58B8;
		  /* 821F58B8h */ case    7:  		/* li R5, 0 */
		/* 821F58B8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F58B8h case    7:*/		return 0x821F58BC;
		  /* 821F58BCh */ case    8:  		/* li R4, 112 */
		/* 821F58BCh case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 821F58BCh case    8:*/		return 0x821F58C0;
		  /* 821F58C0h */ case    9:  		/* mr R3, R31 */
		/* 821F58C0h case    9:*/		regs.R3 = regs.R31;
		/* 821F58C0h case    9:*/		return 0x821F58C4;
		  /* 821F58C4h */ case   10:  		/* bl -595092 */
		/* 821F58C4h case   10:*/		regs.LR = 0x821F58C8; return 0x82164430;
		/* 821F58C4h case   10:*/		return 0x821F58C8;
		  /* 821F58C8h */ case   11:  		/* addi R10, R30, -8 */
		/* 821F58C8h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFF8);
		/* 821F58C8h case   11:*/		return 0x821F58CC;
		  /* 821F58CCh */ case   12:  		/* lwz R11, <#[R31 + 12]> */
		/* 821F58CCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821F58CCh case   12:*/		return 0x821F58D0;
		  /* 821F58D0h */ case   13:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821F58D0h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821F58D0h case   13:*/		return 0x821F58D4;
		  /* 821F58D4h */ case   14:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 821F58D4h case   14:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 821F58D4h case   14:*/		return 0x821F58D8;
		  /* 821F58D8h */ case   15:  		/* mulli R10, R10, 40 */
		/* 821F58D8h case   15:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F58D8h case   15:*/		return 0x821F58DC;
		  /* 821F58DCh */ case   16:  		/* add R11, R10, R11 */
		/* 821F58DCh case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F58DCh case   16:*/		return 0x821F58E0;
		  /* 821F58E0h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F58E0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F58E0h case   17:*/		return 0x821F58E4;
		  /* 821F58E4h */ case   18:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821F58E4h case   18:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821F58E4h case   18:*/		return 0x821F58E8;
		  /* 821F58E8h */ case   19:  		/* cmplwi CR6, R11, 48 */
		/* 821F58E8h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821F58E8h case   19:*/		return 0x821F58EC;
		  /* 821F58ECh */ case   20:  		/* bc 4, CR6_EQ, 32 */
		/* 821F58ECh case   20:*/		if ( !regs.CR[6].eq ) { return 0x821F590C;  }
		/* 821F58ECh case   20:*/		return 0x821F58F0;
		  /* 821F58F0h */ case   21:  		/* lwz R11, <#[R31 + 40]> */
		/* 821F58F0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F58F0h case   21:*/		return 0x821F58F4;
	}
	return 0x821F58F4;
} // Block from 821F589Ch-821F58F4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821F58F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F58F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F58F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F58F4);
		  /* 821F58F4h */ case    0:  		/* ori R11, R11, 128 */
		/* 821F58F4h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 821F58F4h case    0:*/		return 0x821F58F8;
		  /* 821F58F8h */ case    1:  		/* stw R11, <#[R31 + 40]> */
		/* 821F58F8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 821F58F8h case    1:*/		return 0x821F58FC;
		  /* 821F58FCh */ case    2:  		/* b 88 */
		/* 821F58FCh case    2:*/		return 0x821F5954;
		/* 821F58FCh case    2:*/		return 0x821F5900;
	}
	return 0x821F5900;
} // Block from 821F58F4h-821F5900h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5900);
		  /* 821F5900h */ case    0:  		/* li R4, 3538 */
		/* 821F5900h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDD2);
		/* 821F5900h case    0:*/		return 0x821F5904;
		  /* 821F5904h */ case    1:  		/* mr R3, R31 */
		/* 821F5904h case    1:*/		regs.R3 = regs.R31;
		/* 821F5904h case    1:*/		return 0x821F5908;
		  /* 821F5908h */ case    2:  		/* bl -670368 */
		/* 821F5908h case    2:*/		regs.LR = 0x821F590C; return 0x82151E68;
		/* 821F5908h case    2:*/		return 0x821F590C;
	}
	return 0x821F590C;
} // Block from 821F5900h-821F590Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F590Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F590C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F590C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F590C);
		  /* 821F590Ch */ case    0:  		/* cmplwi CR6, R28, 124 */
		/* 821F590Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x0000007C);
		/* 821F590Ch case    0:*/		return 0x821F5910;
		  /* 821F5910h */ case    1:  		/* bc 4, CR6_EQ, 288 */
		/* 821F5910h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F5A30;  }
		/* 821F5910h case    1:*/		return 0x821F5914;
		  /* 821F5914h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5914h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5914h case    2:*/		return 0x821F5918;
		  /* 821F5918h */ case    3:  		/* mr R3, R31 */
		/* 821F5918h case    3:*/		regs.R3 = regs.R31;
		/* 821F5918h case    3:*/		return 0x821F591C;
		  /* 821F591Ch */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821F591Ch case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821F591Ch case    4:*/		return 0x821F5920;
		  /* 821F5920h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F5920h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F5920h case    5:*/		return 0x821F5924;
		  /* 821F5924h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821F5924h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821F5924h case    6:*/		return 0x821F5928;
		  /* 821F5928h */ case    7:  		/* bl -595192 */
		/* 821F5928h case    7:*/		regs.LR = 0x821F592C; return 0x82164430;
		/* 821F5928h case    7:*/		return 0x821F592C;
		  /* 821F592Ch */ case    8:  		/* addi R10, R30, -8 */
		/* 821F592Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFF8);
		/* 821F592Ch case    8:*/		return 0x821F5930;
		  /* 821F5930h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 821F5930h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821F5930h case    9:*/		return 0x821F5934;
		  /* 821F5934h */ case   10:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821F5934h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821F5934h case   10:*/		return 0x821F5938;
		  /* 821F5938h */ case   11:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 821F5938h case   11:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 821F5938h case   11:*/		return 0x821F593C;
		  /* 821F593Ch */ case   12:  		/* mulli R10, R10, 40 */
		/* 821F593Ch case   12:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821F593Ch case   12:*/		return 0x821F5940;
		  /* 821F5940h */ case   13:  		/* add R11, R10, R11 */
		/* 821F5940h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F5940h case   13:*/		return 0x821F5944;
		  /* 821F5944h */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 821F5944h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821F5944h case   14:*/		return 0x821F5948;
		  /* 821F5948h */ case   15:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821F5948h case   15:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821F5948h case   15:*/		return 0x821F594C;
		  /* 821F594Ch */ case   16:  		/* cmplwi CR6, R11, 48 */
		/* 821F594Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821F594Ch case   16:*/		return 0x821F5950;
		  /* 821F5950h */ case   17:  		/* bc 4, CR6_EQ, 224 */
		/* 821F5950h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821F5A30;  }
		/* 821F5950h case   17:*/		return 0x821F5954;
	}
	return 0x821F5954;
} // Block from 821F590Ch-821F5954h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821F5954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5954);
		  /* 821F5954h */ case    0:  		/* mr R5, R29 */
		/* 821F5954h case    0:*/		regs.R5 = regs.R29;
		/* 821F5954h case    0:*/		return 0x821F5958;
		  /* 821F5958h */ case    1:  		/* mr R4, R26 */
		/* 821F5958h case    1:*/		regs.R4 = regs.R26;
		/* 821F5958h case    1:*/		return 0x821F595C;
		  /* 821F595Ch */ case    2:  		/* mr R3, R31 */
		/* 821F595Ch case    2:*/		regs.R3 = regs.R31;
		/* 821F595Ch case    2:*/		return 0x821F5960;
		  /* 821F5960h */ case    3:  		/* bl -9472 */
		/* 821F5960h case    3:*/		regs.LR = 0x821F5964; return 0x821F3460;
		/* 821F5960h case    3:*/		return 0x821F5964;
		  /* 821F5964h */ case    4:  		/* mr R29, R3 */
		/* 821F5964h case    4:*/		regs.R29 = regs.R3;
		/* 821F5964h case    4:*/		return 0x821F5968;
		  /* 821F5968h */ case    5:  		/* mr R3, R31 */
		/* 821F5968h case    5:*/		regs.R3 = regs.R31;
		/* 821F5968h case    5:*/		return 0x821F596C;
		  /* 821F596Ch */ case    6:  		/* lwz R11, <#[R29 + 8]> */
		/* 821F596Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821F596Ch case    6:*/		return 0x821F5970;
		  /* 821F5970h */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821F5970h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821F5970h case    7:*/		return 0x821F5974;
		  /* 821F5974h */ case    8:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F5974h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F5974h case    8:*/		return 0x821F5978;
		  /* 821F5978h */ case    9:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821F5978h case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821F5978h case    9:*/		return 0x821F597C;
		  /* 821F597Ch */ case   10:  		/* bl -595276 */
		/* 821F597Ch case   10:*/		regs.LR = 0x821F5980; return 0x82164430;
		/* 821F597Ch case   10:*/		return 0x821F5980;
	}
	return 0x821F5980;
} // Block from 821F5954h-821F5980h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F5980h
// Function '?SwapResultStackRanges@Compiler@D3DXShader@@AAAXPAVResultStackEnumerator@2@I0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5980);
		  /* 821F5980h */ case    0:  		/* addi R11, R29, -24 */
		/* 821F5980h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFE8);
		/* 821F5980h case    0:*/		return 0x821F5984;
		  /* 821F5984h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 821F5984h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821F5984h case    1:*/		return 0x821F5988;
		  /* 821F5988h */ case    2:  		/* add R30, R3, R11 */
		/* 821F5988h case    2:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R11);
		/* 821F5988h case    2:*/		return 0x821F598C;
		  /* 821F598Ch */ case    3:  		/* lwz R11, <#[R30]> */
		/* 821F598Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F598Ch case    3:*/		return 0x821F5990;
		  /* 821F5990h */ case    4:  		/* rlwimi R11, R27, 0, 27, 31 */
		/* 821F5990h case    4:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R11,regs.R27);
		/* 821F5990h case    4:*/		return 0x821F5994;
		  /* 821F5994h */ case    5:  		/* stw R11, <#[R30]> */
		/* 821F5994h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5994h case    5:*/		return 0x821F5998;
		  /* 821F5998h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5998h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5998h case    6:*/		return 0x821F599C;
		  /* 821F599Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 821F599Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821F59A8;  }
		/* 821F599Ch case    7:*/		return 0x821F59A0;
		  /* 821F59A0h */ case    8:  		/* ori R11, R11, 49152 */
		/* 821F59A0h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC000);
		/* 821F59A0h case    8:*/		return 0x821F59A4;
		  /* 821F59A4h */ case    9:  		/* b 12 */
		/* 821F59A4h case    9:*/		return 0x821F59B0;
		/* 821F59A4h case    9:*/		return 0x821F59A8;
	}
	return 0x821F59A8;
} // Block from 821F5980h-821F59A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F59A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F59A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F59A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F59A8);
		  /* 821F59A8h */ case    0:  		/* addi R10, R24, -1 */
		/* 821F59A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0xFFFFFFFF);
		/* 821F59A8h case    0:*/		return 0x821F59AC;
		  /* 821F59ACh */ case    1:  		/* rlwimi R11, R10, 14, 16, 17 */
		/* 821F59ACh case    1:*/		cpu::op::rlwimi<0,14,16,17>(regs,&regs.R11,regs.R10);
		/* 821F59ACh case    1:*/		return 0x821F59B0;
	}
	return 0x821F59B0;
} // Block from 821F59A8h-821F59B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F59B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F59B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F59B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F59B0);
		  /* 821F59B0h */ case    0:  		/* stw R11, <#[R30 + 8]> */
		/* 821F59B0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F59B0h case    0:*/		return 0x821F59B4;
		  /* 821F59B4h */ case    1:  		/* cmpwi CR6, R22, 4 */
		/* 821F59B4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000004);
		/* 821F59B4h case    1:*/		return 0x821F59B8;
		  /* 821F59B8h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821F59B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821F59C8;  }
		/* 821F59B8h case    2:*/		return 0x821F59BC;
		  /* 821F59BCh */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F59BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F59BCh case    3:*/		return 0x821F59C0;
		  /* 821F59C0h */ case    4:  		/* oris R11, R11, 4096 */
		/* 821F59C0h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 821F59C0h case    4:*/		return 0x821F59C4;
		  /* 821F59C4h */ case    5:  		/* stw R11, <#[R30 + 4]> */
		/* 821F59C4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F59C4h case    5:*/		return 0x821F59C8;
	}
	return 0x821F59C8;
} // Block from 821F59B0h-821F59C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821F59C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F59C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F59C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F59C8);
		  /* 821F59C8h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 821F59C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 821F59C8h case    0:*/		return 0x821F59CC;
		  /* 821F59CCh */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 821F59CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821F59F8;  }
		/* 821F59CCh case    1:*/		return 0x821F59D0;
		  /* 821F59D0h */ case    2:  		/* li R5, 1 */
		/* 821F59D0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F59D0h case    2:*/		return 0x821F59D4;
		  /* 821F59D4h */ case    3:  		/* mr R4, R23 */
		/* 821F59D4h case    3:*/		regs.R4 = regs.R23;
		/* 821F59D4h case    3:*/		return 0x821F59D8;
		  /* 821F59D8h */ case    4:  		/* mr R3, R31 */
		/* 821F59D8h case    4:*/		regs.R3 = regs.R31;
		/* 821F59D8h case    4:*/		return 0x821F59DC;
		  /* 821F59DCh */ case    5:  		/* bl -545420 */
		/* 821F59DCh case    5:*/		regs.LR = 0x821F59E0; return 0x82170750;
		/* 821F59DCh case    5:*/		return 0x821F59E0;
		  /* 821F59E0h */ case    6:  		/* mr R4, R3 */
		/* 821F59E0h case    6:*/		regs.R4 = regs.R3;
		/* 821F59E0h case    6:*/		return 0x821F59E4;
		  /* 821F59E4h */ case    7:  		/* mr R3, R29 */
		/* 821F59E4h case    7:*/		regs.R3 = regs.R29;
		/* 821F59E4h case    7:*/		return 0x821F59E8;
		  /* 821F59E8h */ case    8:  		/* bl -514080 */
		/* 821F59E8h case    8:*/		regs.LR = 0x821F59EC; return 0x821781C8;
		/* 821F59E8h case    8:*/		return 0x821F59EC;
		  /* 821F59ECh */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 821F59ECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F59ECh case    9:*/		return 0x821F59F0;
		  /* 821F59F0h */ case   10:  		/* oris R11, R11, 8192 */
		/* 821F59F0h case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 821F59F0h case   10:*/		return 0x821F59F4;
		  /* 821F59F4h */ case   11:  		/* stw R11, <#[R30 + 4]> */
		/* 821F59F4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821F59F4h case   11:*/		return 0x821F59F8;
	}
	return 0x821F59F8;
} // Block from 821F59C8h-821F59F8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F59F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F59F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F59F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F59F8);
		  /* 821F59F8h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 821F59F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 821F59F8h case    0:*/		return 0x821F59FC;
		  /* 821F59FCh */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 821F59FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821F5A24;  }
		/* 821F59FCh case    1:*/		return 0x821F5A00;
		  /* 821F5A00h */ case    2:  		/* mr R4, R21 */
		/* 821F5A00h case    2:*/		regs.R4 = regs.R21;
		/* 821F5A00h case    2:*/		return 0x821F5A04;
		  /* 821F5A04h */ case    3:  		/* mr R3, R29 */
		/* 821F5A04h case    3:*/		regs.R3 = regs.R29;
		/* 821F5A04h case    3:*/		return 0x821F5A08;
		  /* 821F5A08h */ case    4:  		/* bl -514112 */
		/* 821F5A08h case    4:*/		regs.LR = 0x821F5A0C; return 0x821781C8;
		/* 821F5A08h case    4:*/		return 0x821F5A0C;
		  /* 821F5A0Ch */ case    5:  		/* mr R3, R29 */
		/* 821F5A0Ch case    5:*/		regs.R3 = regs.R29;
		/* 821F5A0Ch case    5:*/		return 0x821F5A10;
		  /* 821F5A10h */ case    6:  		/* lwz R4, <#[R1 + 276]> */
		/* 821F5A10h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 821F5A10h case    6:*/		return 0x821F5A14;
		  /* 821F5A14h */ case    7:  		/* bl -514124 */
		/* 821F5A14h case    7:*/		regs.LR = 0x821F5A18; return 0x821781C8;
		/* 821F5A14h case    7:*/		return 0x821F5A18;
		  /* 821F5A18h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5A18h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5A18h case    8:*/		return 0x821F5A1C;
		  /* 821F5A1Ch */ case    9:  		/* ori R11, R11, 1 */
		/* 821F5A1Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F5A1Ch case    9:*/		return 0x821F5A20;
		  /* 821F5A20h */ case   10:  		/* stw R11, <#[R30 + 8]> */
		/* 821F5A20h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5A20h case   10:*/		return 0x821F5A24;
	}
	return 0x821F5A24;
} // Block from 821F59F8h-821F5A24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821F5A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5A24);
		  /* 821F5A24h */ case    0:  		/* mr R3, R29 */
		/* 821F5A24h case    0:*/		regs.R3 = regs.R29;
		/* 821F5A24h case    0:*/		return 0x821F5A28;
		  /* 821F5A28h */ case    1:  		/* addi R1, R1, 192 */
		/* 821F5A28h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821F5A28h case    1:*/		return 0x821F5A2C;
		  /* 821F5A2Ch */ case    2:  		/* b -1460132 */
		/* 821F5A2Ch case    2:*/		return 0x82091288;
		/* 821F5A2Ch case    2:*/		return 0x821F5A30;
	}
	return 0x821F5A30;
} // Block from 821F5A24h-821F5A30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5A30);
		  /* 821F5A30h */ case    0:  		/* li R4, 3538 */
		/* 821F5A30h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDD2);
		/* 821F5A30h case    0:*/		return 0x821F5A34;
		  /* 821F5A34h */ case    1:  		/* mr R3, R31 */
		/* 821F5A34h case    1:*/		regs.R3 = regs.R31;
		/* 821F5A34h case    1:*/		return 0x821F5A38;
		  /* 821F5A38h */ case    2:  		/* bl -670672 */
		/* 821F5A38h case    2:*/		regs.LR = 0x821F5A3C; return 0x82151E68;
		/* 821F5A38h case    2:*/		return 0x821F5A3C;
	}
	return 0x821F5A3C;
} // Block from 821F5A30h-821F5A3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5A3C);
		  /* 821F5A3Ch */ case    0:  		/* li R4, 4801 */
		/* 821F5A3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F5A3Ch case    0:*/		return 0x821F5A40;
		  /* 821F5A40h */ case    1:  		/* mr R3, R31 */
		/* 821F5A40h case    1:*/		regs.R3 = regs.R31;
		/* 821F5A40h case    1:*/		return 0x821F5A44;
		  /* 821F5A44h */ case    2:  		/* bl -670684 */
		/* 821F5A44h case    2:*/		regs.LR = 0x821F5A48; return 0x82151E68;
		/* 821F5A44h case    2:*/		return 0x821F5A48;
	}
	return 0x821F5A48;
} // Block from 821F5A3Ch-821F5A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5A48);
		  /* 821F5A48h */ case    0:  		/* li R4, 4801 */
		/* 821F5A48h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C1);
		/* 821F5A48h case    0:*/		return 0x821F5A4C;
		  /* 821F5A4Ch */ case    1:  		/* mr R3, R31 */
		/* 821F5A4Ch case    1:*/		regs.R3 = regs.R31;
		/* 821F5A4Ch case    1:*/		return 0x821F5A50;
		  /* 821F5A50h */ case    2:  		/* bl -670696 */
		/* 821F5A50h case    2:*/		regs.LR = 0x821F5A54; return 0x82151E68;
		/* 821F5A50h case    2:*/		return 0x821F5A54;
		  /* 821F5A54h */ case    3:  		/* nop */
		/* 821F5A54h case    3:*/		cpu::op::nop();
		/* 821F5A54h case    3:*/		return 0x821F5A58;
	}
	return 0x821F5A58;
} // Block from 821F5A48h-821F5A58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F5A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5A58);
		  /* 821F5A58h */ case    0:  		/* mfspr R12, LR */
		/* 821F5A58h case    0:*/		regs.R12 = regs.LR;
		/* 821F5A58h case    0:*/		return 0x821F5A5C;
		  /* 821F5A5Ch */ case    1:  		/* bl -1460260 */
		/* 821F5A5Ch case    1:*/		regs.LR = 0x821F5A60; return 0x82091238;
		/* 821F5A5Ch case    1:*/		return 0x821F5A60;
		  /* 821F5A60h */ case    2:  		/* stfd FR31, <#[R1 - 112]> */
		/* 821F5A60h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 821F5A60h case    2:*/		return 0x821F5A64;
		  /* 821F5A64h */ case    3:  		/* stwu R1, <#[R1 - 240]> */
		/* 821F5A64h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 821F5A64h case    3:*/		return 0x821F5A68;
		  /* 821F5A68h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F5A68h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F5A68h case    4:*/		return 0x821F5A6C;
		  /* 821F5A6Ch */ case    5:  		/* li R23, 0 */
		/* 821F5A6Ch case    5:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821F5A6Ch case    5:*/		return 0x821F5A70;
		  /* 821F5A70h */ case    6:  		/* mr R31, R3 */
		/* 821F5A70h case    6:*/		regs.R31 = regs.R3;
		/* 821F5A70h case    6:*/		return 0x821F5A74;
		  /* 821F5A74h */ case    7:  		/* mr R28, R4 */
		/* 821F5A74h case    7:*/		regs.R28 = regs.R4;
		/* 821F5A74h case    7:*/		return 0x821F5A78;
		  /* 821F5A78h */ case    8:  		/* stw R23, <#[R1 + 80]> */
		/* 821F5A78h case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5A78h case    8:*/		return 0x821F5A7C;
		  /* 821F5A7Ch */ case    9:  		/* mr R26, R5 */
		/* 821F5A7Ch case    9:*/		regs.R26 = regs.R5;
		/* 821F5A7Ch case    9:*/		return 0x821F5A80;
		  /* 821F5A80h */ case   10:  		/* mr R29, R6 */
		/* 821F5A80h case   10:*/		regs.R29 = regs.R6;
		/* 821F5A80h case   10:*/		return 0x821F5A84;
		  /* 821F5A84h */ case   11:  		/* mr R25, R7 */
		/* 821F5A84h case   11:*/		regs.R25 = regs.R7;
		/* 821F5A84h case   11:*/		return 0x821F5A88;
		  /* 821F5A88h */ case   12:  		/* rlwinm. R11, R11, 0, 4, 17 */
		/* 821F5A88h case   12:*/		cpu::op::rlwinm<1,0,4,17>(regs,&regs.R11,regs.R11);
		/* 821F5A88h case   12:*/		return 0x821F5A8C;
		  /* 821F5A8Ch */ case   13:  		/* mr R22, R23 */
		/* 821F5A8Ch case   13:*/		regs.R22 = regs.R23;
		/* 821F5A8Ch case   13:*/		return 0x821F5A90;
		  /* 821F5A90h */ case   14:  		/* mr R24, R23 */
		/* 821F5A90h case   14:*/		regs.R24 = regs.R23;
		/* 821F5A90h case   14:*/		return 0x821F5A94;
		  /* 821F5A94h */ case   15:  		/* bc 12, CR0_EQ, 396 */
		/* 821F5A94h case   15:*/		if ( regs.CR[0].eq ) { return 0x821F5C20;  }
		/* 821F5A94h case   15:*/		return 0x821F5A98;
		  /* 821F5A98h */ case   16:  		/* lis R11, -32256 */
		/* 821F5A98h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F5A98h case   16:*/		return 0x821F5A9C;
		  /* 821F5A9Ch */ case   17:  		/* addi R27, R4, 12 */
		/* 821F5A9Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R4,0xC);
		/* 821F5A9Ch case   17:*/		return 0x821F5AA0;
		  /* 821F5AA0h */ case   18:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 821F5AA0h case   18:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 821F5AA0h case   18:*/		return 0x821F5AA4;
		  /* 821F5AA4h */ case   19:  		/* ld R11, <#[R27]> */
		/* 821F5AA4h case   19:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821F5AA4h case   19:*/		return 0x821F5AA8;
		  /* 821F5AA8h */ case   20:  		/* std R11, <#[R1 + 88]> */
		/* 821F5AA8h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5AA8h case   20:*/		return 0x821F5AAC;
		  /* 821F5AACh */ case   21:  		/* lwz R10, <#[R1 + 92]> */
		/* 821F5AACh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 821F5AACh case   21:*/		return 0x821F5AB0;
		  /* 821F5AB0h */ case   22:  		/* rlwinm R11, R10, 0, 30, 31 */
		/* 821F5AB0h case   22:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 821F5AB0h case   22:*/		return 0x821F5AB4;
		  /* 821F5AB4h */ case   23:  		/* cmpwi CR6, R11, 3 */
		/* 821F5AB4h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821F5AB4h case   23:*/		return 0x821F5AB8;
		  /* 821F5AB8h */ case   24:  		/* bc 4, CR6_EQ, 112 */
		/* 821F5AB8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x821F5B28;  }
		/* 821F5AB8h case   24:*/		return 0x821F5ABC;
		  /* 821F5ABCh */ case   25:  		/* rlwinm. R10, R10, 16, 31, 31 */
		/* 821F5ABCh case   25:*/		cpu::op::rlwinm<1,16,31,31>(regs,&regs.R10,regs.R10);
		/* 821F5ABCh case   25:*/		return 0x821F5AC0;
		  /* 821F5AC0h */ case   26:  		/* bc 12, CR0_EQ, 104 */
		/* 821F5AC0h case   26:*/		if ( regs.CR[0].eq ) { return 0x821F5B28;  }
		/* 821F5AC0h case   26:*/		return 0x821F5AC4;
		  /* 821F5AC4h */ case   27:  		/* lwz R30, <#[R1 + 88]> */
		/* 821F5AC4h case   27:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5AC4h case   27:*/		return 0x821F5AC8;
		  /* 821F5AC8h */ case   28:  		/* cmplwi CR6, R22, 0 */
		/* 821F5AC8h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821F5AC8h case   28:*/		return 0x821F5ACC;
		  /* 821F5ACCh */ case   29:  		/* bc 12, CR6_EQ, 16 */
		/* 821F5ACCh case   29:*/		if ( regs.CR[6].eq ) { return 0x821F5ADC;  }
		/* 821F5ACCh case   29:*/		return 0x821F5AD0;
		  /* 821F5AD0h */ case   30:  		/* lwz R11, <#[R30]> */
		/* 821F5AD0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5AD0h case   30:*/		return 0x821F5AD4;
		  /* 821F5AD4h */ case   31:  		/* cmplw CR6, R22, R11 */
		/* 821F5AD4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821F5AD4h case   31:*/		return 0x821F5AD8;
		  /* 821F5AD8h */ case   32:  		/* bc 12, CR6_EQ, 52 */
		/* 821F5AD8h case   32:*/		if ( regs.CR[6].eq ) { return 0x821F5B0C;  }
		/* 821F5AD8h case   32:*/		return 0x821F5ADC;
	}
	return 0x821F5ADC;
} // Block from 821F5A58h-821F5ADCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 821F5ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5ADC);
		  /* 821F5ADCh */ case    0:  		/* ld R11, <#[R30]> */
		/* 821F5ADCh case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5ADCh case    0:*/		return 0x821F5AE0;
		  /* 821F5AE0h */ case    1:  		/* mr R4, R26 */
		/* 821F5AE0h case    1:*/		regs.R4 = regs.R26;
		/* 821F5AE0h case    1:*/		return 0x821F5AE4;
		  /* 821F5AE4h */ case    2:  		/* mr R3, R31 */
		/* 821F5AE4h case    2:*/		regs.R3 = regs.R31;
		/* 821F5AE4h case    2:*/		return 0x821F5AE8;
		  /* 821F5AE8h */ case    3:  		/* mr R5, R11 */
		/* 821F5AE8h case    3:*/		regs.R5 = regs.R11;
		/* 821F5AE8h case    3:*/		return 0x821F5AEC;
		  /* 821F5AECh */ case    4:  		/* std R11, <#[R1 + 88]> */
		/* 821F5AECh case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5AECh case    4:*/		return 0x821F5AF0;
		  /* 821F5AF0h */ case    5:  		/* bl -21288 */
		/* 821F5AF0h case    5:*/		regs.LR = 0x821F5AF4; return 0x821F07C8;
		/* 821F5AF0h case    5:*/		return 0x821F5AF4;
		  /* 821F5AF4h */ case    6:  		/* lwz R11, <#[R1 + 84]> */
		/* 821F5AF4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F5AF4h case    6:*/		return 0x821F5AF8;
		  /* 821F5AF8h */ case    7:  		/* lwz R22, <#[R1 + 88]> */
		/* 821F5AF8h case    7:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5AF8h case    7:*/		return 0x821F5AFC;
		  /* 821F5AFCh */ case    8:  		/* rlwinm R11, R11, 0, 15, 15 */
		/* 821F5AFCh case    8:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R11,regs.R11);
		/* 821F5AFCh case    8:*/		return 0x821F5B00;
		  /* 821F5B00h */ case    9:  		/* stw R3, <#[R1 + 80]> */
		/* 821F5B00h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5B00h case    9:*/		return 0x821F5B04;
		  /* 821F5B04h */ case   10:  		/* ori R11, R11, 1 */
		/* 821F5B04h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F5B04h case   10:*/		return 0x821F5B08;
		  /* 821F5B08h */ case   11:  		/* stw R11, <#[R1 + 84]> */
		/* 821F5B08h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F5B08h case   11:*/		return 0x821F5B0C;
	}
	return 0x821F5B0C;
} // Block from 821F5ADCh-821F5B0Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 821F5B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5B0C);
		  /* 821F5B0Ch */ case    0:  		/* mr R7, R25 */
		/* 821F5B0Ch case    0:*/		regs.R7 = regs.R25;
		/* 821F5B0Ch case    0:*/		return 0x821F5B10;
		  /* 821F5B10h */ case    1:  		/* ld R5, <#[R1 + 80]> */
		/* 821F5B10h case    1:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5B10h case    1:*/		return 0x821F5B14;
		  /* 821F5B14h */ case    2:  		/* mr R6, R29 */
		/* 821F5B14h case    2:*/		regs.R6 = regs.R29;
		/* 821F5B14h case    2:*/		return 0x821F5B18;
		  /* 821F5B18h */ case    3:  		/* mr R4, R30 */
		/* 821F5B18h case    3:*/		regs.R4 = regs.R30;
		/* 821F5B18h case    3:*/		return 0x821F5B1C;
		  /* 821F5B1Ch */ case    4:  		/* mr R3, R31 */
		/* 821F5B1Ch case    4:*/		regs.R3 = regs.R31;
		/* 821F5B1Ch case    4:*/		return 0x821F5B20;
		  /* 821F5B20h */ case    5:  		/* bl -200 */
		/* 821F5B20h case    5:*/		regs.LR = 0x821F5B24; return 0x821F5A58;
		/* 821F5B20h case    5:*/		return 0x821F5B24;
		  /* 821F5B24h */ case    6:  		/* b 220 */
		/* 821F5B24h case    6:*/		return 0x821F5C00;
		/* 821F5B24h case    6:*/		return 0x821F5B28;
	}
	return 0x821F5B28;
} // Block from 821F5B0Ch-821F5B28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821F5B28h
// Function '?GenerateSumOfProducts@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVResultStackEnumerator@2@0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5B28);
		  /* 821F5B28h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 821F5B28h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821F5B28h case    0:*/		return 0x821F5B2C;
		  /* 821F5B2Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 821F5B2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F5B3C;  }
		/* 821F5B2Ch case    1:*/		return 0x821F5B30;
		  /* 821F5B30h */ case    2:  		/* addi R4, R1, 88 */
		/* 821F5B30h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 821F5B30h case    2:*/		return 0x821F5B34;
		  /* 821F5B34h */ case    3:  		/* mr R3, R31 */
		/* 821F5B34h case    3:*/		regs.R3 = regs.R31;
		/* 821F5B34h case    3:*/		return 0x821F5B38;
		  /* 821F5B38h */ case    4:  		/* bl -13160 */
		/* 821F5B38h case    4:*/		regs.LR = 0x821F5B3C; return 0x821F27D0;
		/* 821F5B38h case    4:*/		return 0x821F5B3C;
	}
	return 0x821F5B3C;
} // Block from 821F5B28h-821F5B3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F5B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5B3C);
		  /* 821F5B3Ch */ case    0:  		/* rldicl R11, R29, 0, 32 */
		/* 821F5B3Ch case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R29);
		/* 821F5B3Ch case    0:*/		return 0x821F5B40;
		  /* 821F5B40h */ case    1:  		/* fmr FR4, FR31 */
		/* 821F5B40h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821F5B40h case    1:*/		return 0x821F5B44;
		  /* 821F5B44h */ case    2:  		/* li R5, 1 */
		/* 821F5B44h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F5B44h case    2:*/		return 0x821F5B48;
		  /* 821F5B48h */ case    3:  		/* fmr FR3, FR31 */
		/* 821F5B48h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821F5B48h case    3:*/		return 0x821F5B4C;
		  /* 821F5B4Ch */ case    4:  		/* std R11, <#[R1 + 104]> */
		/* 821F5B4Ch case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 821F5B4Ch case    4:*/		return 0x821F5B50;
		  /* 821F5B50h */ case    5:  		/* lfd FR0, <#[R1 + 104]> */
		/* 821F5B50h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 821F5B50h case    5:*/		return 0x821F5B54;
		  /* 821F5B54h */ case    6:  		/* fcfid FR0, FR0 */
		/* 821F5B54h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 821F5B54h case    6:*/		return 0x821F5B58;
		  /* 821F5B58h */ case    7:  		/* mr R4, R31 */
		/* 821F5B58h case    7:*/		regs.R4 = regs.R31;
		/* 821F5B58h case    7:*/		return 0x821F5B5C;
		  /* 821F5B5Ch */ case    8:  		/* frsp FR0, FR0 */
		/* 821F5B5Ch case    8:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 821F5B5Ch case    8:*/		return 0x821F5B60;
		  /* 821F5B60h */ case    9:  		/* addi R3, R1, 112 */
		/* 821F5B60h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821F5B60h case    9:*/		return 0x821F5B64;
		  /* 821F5B64h */ case   10:  		/* fmr FR2, FR31 */
		/* 821F5B64h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821F5B64h case   10:*/		return 0x821F5B68;
		  /* 821F5B68h */ case   11:  		/* fneg FR1, FR0 */
		/* 821F5B68h case   11:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 821F5B68h case   11:*/		return 0x821F5B6C;
		  /* 821F5B6Ch */ case   12:  		/* bl 201444 */
		/* 821F5B6Ch case   12:*/		regs.LR = 0x821F5B70; return 0x82226E50;
		/* 821F5B6Ch case   12:*/		return 0x821F5B70;
		  /* 821F5B70h */ case   13:  		/* mr R11, R3 */
		/* 821F5B70h case   13:*/		regs.R11 = regs.R3;
		/* 821F5B70h case   13:*/		return 0x821F5B74;
		  /* 821F5B74h */ case   14:  		/* mr R4, R26 */
		/* 821F5B74h case   14:*/		regs.R4 = regs.R26;
		/* 821F5B74h case   14:*/		return 0x821F5B78;
		  /* 821F5B78h */ case   15:  		/* mr R3, R31 */
		/* 821F5B78h case   15:*/		regs.R3 = regs.R31;
		/* 821F5B78h case   15:*/		return 0x821F5B7C;
		  /* 821F5B7Ch */ case   16:  		/* ld R5, <#[R11]> */
		/* 821F5B7Ch case   16:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5B7Ch case   16:*/		return 0x821F5B80;
		  /* 821F5B80h */ case   17:  		/* bl -21432 */
		/* 821F5B80h case   17:*/		regs.LR = 0x821F5B84; return 0x821F07C8;
		/* 821F5B80h case   17:*/		return 0x821F5B84;
		  /* 821F5B84h */ case   18:  		/* mr R4, R3 */
		/* 821F5B84h case   18:*/		regs.R4 = regs.R3;
		/* 821F5B84h case   18:*/		return 0x821F5B88;
		  /* 821F5B88h */ case   19:  		/* ld R6, <#[R1 + 88]> */
		/* 821F5B88h case   19:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 821F5B88h case   19:*/		return 0x821F5B8C;
		  /* 821F5B8Ch */ case   20:  		/* mr R5, R25 */
		/* 821F5B8Ch case   20:*/		regs.R5 = regs.R25;
		/* 821F5B8Ch case   20:*/		return 0x821F5B90;
		  /* 821F5B90h */ case   21:  		/* mr R3, R31 */
		/* 821F5B90h case   21:*/		regs.R3 = regs.R31;
		/* 821F5B90h case   21:*/		return 0x821F5B94;
		  /* 821F5B94h */ case   22:  		/* bl -5924 */
		/* 821F5B94h case   22:*/		regs.LR = 0x821F5B98; return 0x821F4470;
		/* 821F5B94h case   22:*/		return 0x821F5B98;
		  /* 821F5B98h */ case   23:  		/* lwz R11, <#[R28 + 8]> */
		/* 821F5B98h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821F5B98h case   23:*/		return 0x821F5B9C;
		  /* 821F5B9Ch */ case   24:  		/* mr R30, R3 */
		/* 821F5B9Ch case   24:*/		regs.R30 = regs.R3;
		/* 821F5B9Ch case   24:*/		return 0x821F5BA0;
		  /* 821F5BA0h */ case   25:  		/* li R5, 22 */
		/* 821F5BA0h case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x16);
		/* 821F5BA0h case   25:*/		return 0x821F5BA4;
		  /* 821F5BA4h */ case   26:  		/* li R4, 12 */
		/* 821F5BA4h case   26:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 821F5BA4h case   26:*/		return 0x821F5BA8;
		  /* 821F5BA8h */ case   27:  		/* mr R3, R31 */
		/* 821F5BA8h case   27:*/		regs.R3 = regs.R31;
		/* 821F5BA8h case   27:*/		return 0x821F5BAC;
		  /* 821F5BACh */ case   28:  		/* rlwinm R21, R11, 0, 18, 31 */
		/* 821F5BACh case   28:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R21,regs.R11);
		/* 821F5BACh case   28:*/		return 0x821F5BB0;
		  /* 821F5BB0h */ case   29:  		/* rlwinm R20, R11, 18, 18, 31 */
		/* 821F5BB0h case   29:*/		cpu::op::rlwinm<0,18,18,31>(regs,&regs.R20,regs.R11);
		/* 821F5BB0h case   29:*/		return 0x821F5BB4;
		  /* 821F5BB4h */ case   30:  		/* bl -561164 */
		/* 821F5BB4h case   30:*/		regs.LR = 0x821F5BB8; return 0x8216CBA8;
		/* 821F5BB4h case   30:*/		return 0x821F5BB8;
		  /* 821F5BB8h */ case   31:  		/* lwz R10, <#[R1 + 100]> */
		/* 821F5BB8h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 821F5BB8h case   31:*/		return 0x821F5BBC;
		  /* 821F5BBCh */ case   32:  		/* mr R11, R3 */
		/* 821F5BBCh case   32:*/		regs.R11 = regs.R3;
		/* 821F5BBCh case   32:*/		return 0x821F5BC0;
		  /* 821F5BC0h */ case   33:  		/* stw R30, <#[R1 + 96]> */
		/* 821F5BC0h case   33:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 821F5BC0h case   33:*/		return 0x821F5BC4;
		  /* 821F5BC4h */ case   34:  		/* rlwimi R20, R21, 14, 4, 17 */
		/* 821F5BC4h case   34:*/		cpu::op::rlwimi<0,14,4,17>(regs,&regs.R20,regs.R21);
		/* 821F5BC4h case   34:*/		return 0x821F5BC8;
		  /* 821F5BC8h */ case   35:  		/* rlwinm R10, R10, 0, 15, 15 */
		/* 821F5BC8h case   35:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R10,regs.R10);
		/* 821F5BC8h case   35:*/		return 0x821F5BCC;
		  /* 821F5BCCh */ case   36:  		/* lwz R9, <#[R3 + 8]> */
		/* 821F5BCCh case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821F5BCCh case   36:*/		return 0x821F5BD0;
		  /* 821F5BD0h */ case   37:  		/* stw R23, <#[R3]> */
		/* 821F5BD0h case   37:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000000) );
		/* 821F5BD0h case   37:*/		return 0x821F5BD4;
		  /* 821F5BD4h */ case   38:  		/* mr R4, R27 */
		/* 821F5BD4h case   38:*/		regs.R4 = regs.R27;
		/* 821F5BD4h case   38:*/		return 0x821F5BD8;
		  /* 821F5BD8h */ case   39:  		/* ori R10, R10, 1 */
		/* 821F5BD8h case   39:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821F5BD8h case   39:*/		return 0x821F5BDC;
		  /* 821F5BDCh */ case   40:  		/* rlwimi R20, R9, 0, 0, 3 */
		/* 821F5BDCh case   40:*/		cpu::op::rlwimi<0,0,0,3>(regs,&regs.R20,regs.R9);
		/* 821F5BDCh case   40:*/		return 0x821F5BE0;
		  /* 821F5BE0h */ case   41:  		/* stw R10, <#[R1 + 100]> */
		/* 821F5BE0h case   41:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 821F5BE0h case   41:*/		return 0x821F5BE4;
		  /* 821F5BE4h */ case   42:  		/* mr R3, R31 */
		/* 821F5BE4h case   42:*/		regs.R3 = regs.R31;
		/* 821F5BE4h case   42:*/		return 0x821F5BE8;
		  /* 821F5BE8h */ case   43:  		/* ld R5, <#[R1 + 96]> */
		/* 821F5BE8h case   43:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000060) );
		/* 821F5BE8h case   43:*/		return 0x821F5BEC;
		  /* 821F5BECh */ case   44:  		/* stw R20, <#[R11 + 8]> */
		/* 821F5BECh case   44:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000008) );
		/* 821F5BECh case   44:*/		return 0x821F5BF0;
		  /* 821F5BF0h */ case   45:  		/* lwz R10, <#[R30 + 16]> */
		/* 821F5BF0h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 821F5BF0h case   45:*/		return 0x821F5BF4;
		  /* 821F5BF4h */ case   46:  		/* stw R10, <#[R11 + 4]> */
		/* 821F5BF4h case   46:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F5BF4h case   46:*/		return 0x821F5BF8;
		  /* 821F5BF8h */ case   47:  		/* stw R11, <#[R30 + 16]> */
		/* 821F5BF8h case   47:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 821F5BF8h case   47:*/		return 0x821F5BFC;
		  /* 821F5BFCh */ case   48:  		/* bl 3540 */
		/* 821F5BFCh case   48:*/		regs.LR = 0x821F5C00; return 0x821F69D0;
		/* 821F5BFCh case   48:*/		return 0x821F5C00;
	}
	return 0x821F5C00;
} // Block from 821F5B3Ch-821F5C00h (49 instructions)

//////////////////////////////////////////////////////
// Block at 821F5C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5C00);
		  /* 821F5C00h */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 821F5C00h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821F5C00h case    0:*/		return 0x821F5C04;
		  /* 821F5C04h */ case    1:  		/* addi R24, R24, 1 */
		/* 821F5C04h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 821F5C04h case    1:*/		return 0x821F5C08;
		  /* 821F5C08h */ case    2:  		/* addi R27, R27, 8 */
		/* 821F5C08h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x8);
		/* 821F5C08h case    2:*/		return 0x821F5C0C;
		  /* 821F5C0Ch */ case    3:  		/* rlwinm R11, R10, 0, 18, 31 */
		/* 821F5C0Ch case    3:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R11,regs.R10);
		/* 821F5C0Ch case    3:*/		return 0x821F5C10;
		  /* 821F5C10h */ case    4:  		/* rlwinm R10, R10, 18, 18, 31 */
		/* 821F5C10h case    4:*/		cpu::op::rlwinm<0,18,18,31>(regs,&regs.R10,regs.R10);
		/* 821F5C10h case    4:*/		return 0x821F5C14;
		  /* 821F5C14h */ case    5:  		/* add R29, R11, R29 */
		/* 821F5C14h case    5:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 821F5C14h case    5:*/		return 0x821F5C18;
		  /* 821F5C18h */ case    6:  		/* cmplw CR6, R24, R10 */
		/* 821F5C18h case    6:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R10);
		/* 821F5C18h case    6:*/		return 0x821F5C1C;
		  /* 821F5C1Ch */ case    7:  		/* bc 12, CR6_LT, -376 */
		/* 821F5C1Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x821F5AA4;  }
		/* 821F5C1Ch case    7:*/		return 0x821F5C20;
	}
	return 0x821F5C20;
} // Block from 821F5C00h-821F5C20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F5C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5C20);
		  /* 821F5C20h */ case    0:  		/* addi R1, R1, 240 */
		/* 821F5C20h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 821F5C20h case    0:*/		return 0x821F5C24;
		  /* 821F5C24h */ case    1:  		/* lfd FR31, <#[R1 - 112]> */
		/* 821F5C24h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 821F5C24h case    1:*/		return 0x821F5C28;
		  /* 821F5C28h */ case    2:  		/* b -1460640 */
		/* 821F5C28h case    2:*/		return 0x82091288;
		/* 821F5C28h case    2:*/		return 0x821F5C2C;
		  /* 821F5C2Ch */ case    3:  		/* nop */
		/* 821F5C2Ch case    3:*/		cpu::op::nop();
		/* 821F5C2Ch case    3:*/		return 0x821F5C30;
	}
	return 0x821F5C30;
} // Block from 821F5C20h-821F5C30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F5C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5C30);
		  /* 821F5C30h */ case    0:  		/* mfspr R12, LR */
		/* 821F5C30h case    0:*/		regs.R12 = regs.LR;
		/* 821F5C30h case    0:*/		return 0x821F5C34;
		  /* 821F5C34h */ case    1:  		/* bl -1460748 */
		/* 821F5C34h case    1:*/		regs.LR = 0x821F5C38; return 0x82091228;
		/* 821F5C34h case    1:*/		return 0x821F5C38;
		  /* 821F5C38h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821F5C38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821F5C38h case    2:*/		return 0x821F5C3C;
		  /* 821F5C3Ch */ case    3:  		/* li R11, -1 */
		/* 821F5C3Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 821F5C3Ch case    3:*/		return 0x821F5C40;
		  /* 821F5C40h */ case    4:  		/* std R5, <#[R1 + 256]> */
		/* 821F5C40h case    4:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000100) );
		/* 821F5C40h case    4:*/		return 0x821F5C44;
		  /* 821F5C44h */ case    5:  		/* mr R31, R3 */
		/* 821F5C44h case    5:*/		regs.R31 = regs.R3;
		/* 821F5C44h case    5:*/		return 0x821F5C48;
		  /* 821F5C48h */ case    6:  		/* mr R29, R4 */
		/* 821F5C48h case    6:*/		regs.R29 = regs.R4;
		/* 821F5C48h case    6:*/		return 0x821F5C4C;
		  /* 821F5C4Ch */ case    7:  		/* mr R25, R6 */
		/* 821F5C4Ch case    7:*/		regs.R25 = regs.R6;
		/* 821F5C4Ch case    7:*/		return 0x821F5C50;
		  /* 821F5C50h */ case    8:  		/* mr R18, R7 */
		/* 821F5C50h case    8:*/		regs.R18 = regs.R7;
		/* 821F5C50h case    8:*/		return 0x821F5C54;
		  /* 821F5C54h */ case    9:  		/* mr R16, R8 */
		/* 821F5C54h case    9:*/		regs.R16 = regs.R8;
		/* 821F5C54h case    9:*/		return 0x821F5C58;
		  /* 821F5C58h */ case   10:  		/* mr R23, R8 */
		/* 821F5C58h case   10:*/		regs.R23 = regs.R8;
		/* 821F5C58h case   10:*/		return 0x821F5C5C;
		  /* 821F5C5Ch */ case   11:  		/* mr R20, R11 */
		/* 821F5C5Ch case   11:*/		regs.R20 = regs.R11;
		/* 821F5C5Ch case   11:*/		return 0x821F5C60;
		  /* 821F5C60h */ case   12:  		/* mr R17, R11 */
		/* 821F5C60h case   12:*/		regs.R17 = regs.R11;
		/* 821F5C60h case   12:*/		return 0x821F5C64;
		  /* 821F5C64h */ case   13:  		/* li R28, 0 */
		/* 821F5C64h case   13:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821F5C64h case   13:*/		return 0x821F5C68;
		  /* 821F5C68h */ case   14:  		/* li R21, 4 */
		/* 821F5C68h case   14:*/		cpu::op::li<0>(regs,&regs.R21,0x4);
		/* 821F5C68h case   14:*/		return 0x821F5C6C;
		  /* 821F5C6Ch */ case   15:  		/* mr R24, R11 */
		/* 821F5C6Ch case   15:*/		regs.R24 = regs.R11;
		/* 821F5C6Ch case   15:*/		return 0x821F5C70;
		  /* 821F5C70h */ case   16:  		/* li R22, 0 */
		/* 821F5C70h case   16:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 821F5C70h case   16:*/		return 0x821F5C74;
		  /* 821F5C74h */ case   17:  		/* li R19, 0 */
		/* 821F5C74h case   17:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 821F5C74h case   17:*/		return 0x821F5C78;
		  /* 821F5C78h */ case   18:  		/* cmplwi CR6, R6, 0 */
		/* 821F5C78h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821F5C78h case   18:*/		return 0x821F5C7C;
		  /* 821F5C7Ch */ case   19:  		/* bc 12, CR6_EQ, 380 */
		/* 821F5C7Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x821F5DF8;  }
		/* 821F5C7Ch case   19:*/		return 0x821F5C80;
		  /* 821F5C80h */ case   20:  		/* mr R4, R23 */
		/* 821F5C80h case   20:*/		regs.R4 = regs.R23;
		/* 821F5C80h case   20:*/		return 0x821F5C84;
		  /* 821F5C84h */ case   21:  		/* lwz R30, <#[R29 + 4]> */
		/* 821F5C84h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000004) );
		/* 821F5C84h case   21:*/		return 0x821F5C88;
		  /* 821F5C88h */ case   22:  		/* mr R3, R29 */
		/* 821F5C88h case   22:*/		regs.R3 = regs.R29;
		/* 821F5C88h case   22:*/		return 0x821F5C8C;
		  /* 821F5C8Ch */ case   23:  		/* lwz R27, <#[R29 + 8]> */
		/* 821F5C8Ch case   23:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x00000008) );
		/* 821F5C8Ch case   23:*/		return 0x821F5C90;
		  /* 821F5C90h */ case   24:  		/* bl -32408 */
		/* 821F5C90h case   24:*/		regs.LR = 0x821F5C94; return 0x821EDDF8;
		/* 821F5C90h case   24:*/		return 0x821F5C94;
		  /* 821F5C94h */ case   25:  		/* lwz R11, <#[R29 + 8]> */
		/* 821F5C94h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821F5C94h case   25:*/		return 0x821F5C98;
		  /* 821F5C98h */ case   26:  		/* lwz R10, <#[R29 + 4]> */
		/* 821F5C98h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 821F5C98h case   26:*/		return 0x821F5C9C;
		  /* 821F5C9Ch */ case   27:  		/* add R23, R23, R18 */
		/* 821F5C9Ch case   27:*/		cpu::op::add<0>(regs,&regs.R23,regs.R23,regs.R18);
		/* 821F5C9Ch case   27:*/		return 0x821F5CA0;
		  /* 821F5CA0h */ case   28:  		/* addi R11, R11, 2 */
		/* 821F5CA0h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F5CA0h case   28:*/		return 0x821F5CA4;
		  /* 821F5CA4h */ case   29:  		/* stw R30, <#[R29 + 4]> */
		/* 821F5CA4h case   29:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000004) );
		/* 821F5CA4h case   29:*/		return 0x821F5CA8;
		  /* 821F5CA8h */ case   30:  		/* stw R27, <#[R29 + 8]> */
		/* 821F5CA8h case   30:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000008) );
		/* 821F5CA8h case   30:*/		return 0x821F5CAC;
		  /* 821F5CACh */ case   31:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 821F5CACh case   31:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 821F5CACh case   31:*/		return 0x821F5CB0;
		  /* 821F5CB0h */ case   32:  		/* add R11, R11, R10 */
		/* 821F5CB0h case   32:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F5CB0h case   32:*/		return 0x821F5CB4;
		  /* 821F5CB4h */ case   33:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F5CB4h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F5CB4h case   33:*/		return 0x821F5CB8;
		  /* 821F5CB8h */ case   34:  		/* rlwinm R9, R10, 0, 30, 31 */
		/* 821F5CB8h case   34:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R10);
		/* 821F5CB8h case   34:*/		return 0x821F5CBC;
		  /* 821F5CBCh */ case   35:  		/* cmplwi CR6, R9, 1 */
		/* 821F5CBCh case   35:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 821F5CBCh case   35:*/		return 0x821F5CC0;
		  /* 821F5CC0h */ case   36:  		/* bc 4, CR6_EQ, 20 */
		/* 821F5CC0h case   36:*/		if ( !regs.CR[6].eq ) { return 0x821F5CD4;  }
		/* 821F5CC0h case   36:*/		return 0x821F5CC4;
		  /* 821F5CC4h */ case   37:  		/* lwz R30, <#[R11]> */
		/* 821F5CC4h case   37:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5CC4h case   37:*/		return 0x821F5CC8;
		  /* 821F5CC8h */ case   38:  		/* li R27, 0 */
		/* 821F5CC8h case   38:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821F5CC8h case   38:*/		return 0x821F5CCC;
		  /* 821F5CCCh */ case   39:  		/* rlwinm R26, R10, 30, 18, 31 */
		/* 821F5CCCh case   39:*/		cpu::op::rlwinm<0,30,18,31>(regs,&regs.R26,regs.R10);
		/* 821F5CCCh case   39:*/		return 0x821F5CD0;
		  /* 821F5CD0h */ case   40:  		/* b 44 */
		/* 821F5CD0h case   40:*/		return 0x821F5CFC;
		/* 821F5CD0h case   40:*/		return 0x821F5CD4;
	}
	return 0x821F5CD4;
} // Block from 821F5C30h-821F5CD4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 821F5CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5CD4);
		  /* 821F5CD4h */ case    0:  		/* cmplwi CR6, R9, 2 */
		/* 821F5CD4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000002);
		/* 821F5CD4h case    0:*/		return 0x821F5CD8;
	}
	return 0x821F5CD8;
} // Block from 821F5CD4h-821F5CD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821F5CD8h
// Function '?GenerateTextureLookup@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVResult@2@PAVDependency@2@I_NW4TextureLookupSuffix@2@PAV32@111@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5CD8);
		  /* 821F5CD8h */ case    0:  		/* bc 4, CR6_EQ, 244 */
		/* 821F5CD8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821F5DCC;  }
		/* 821F5CD8h case    0:*/		return 0x821F5CDC;
		  /* 821F5CDCh */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821F5CDCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5CDCh case    1:*/		return 0x821F5CE0;
		  /* 821F5CE0h */ case    2:  		/* rlwinm R10, R10, 31, 17, 30 */
		/* 821F5CE0h case    2:*/		cpu::op::rlwinm<0,31,17,30>(regs,&regs.R10,regs.R10);
		/* 821F5CE0h case    2:*/		return 0x821F5CE4;
		  /* 821F5CE4h */ case    3:  		/* lwz R9, <#[R11]> */
		/* 821F5CE4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5CE4h case    3:*/		return 0x821F5CE8;
		  /* 821F5CE8h */ case    4:  		/* lwz R30, <#[R11 + 12]> */
		/* 821F5CE8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F5CE8h case    4:*/		return 0x821F5CEC;
		  /* 821F5CECh */ case    5:  		/* rlwinm R11, R9, 27, 24, 31 */
		/* 821F5CECh case    5:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R9);
		/* 821F5CECh case    5:*/		return 0x821F5CF0;
		  /* 821F5CF0h */ case    6:  		/* rlwinm R27, R9, 0, 27, 31 */
		/* 821F5CF0h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R27,regs.R9);
		/* 821F5CF0h case    6:*/		return 0x821F5CF4;
		  /* 821F5CF4h */ case    7:  		/* srw R11, R11, R10 */
		/* 821F5CF4h case    7:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F5CF4h case    7:*/		return 0x821F5CF8;
		  /* 821F5CF8h */ case    8:  		/* rlwinm R26, R11, 0, 30, 31 */
		/* 821F5CF8h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R26,regs.R11);
		/* 821F5CF8h case    8:*/		return 0x821F5CFC;
	}
	return 0x821F5CFC;
} // Block from 821F5CD8h-821F5CFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F5CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5CFC);
		  /* 821F5CFCh */ case    0:  		/* rlwinm. R11, R27, 0, 27, 28 */
		/* 821F5CFCh case    0:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R27);
		/* 821F5CFCh case    0:*/		return 0x821F5D00;
		  /* 821F5D00h */ case    1:  		/* bc 4, CR0_EQ, 204 */
		/* 821F5D00h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821F5DCC;  }
		/* 821F5D00h case    1:*/		return 0x821F5D04;
		  /* 821F5D04h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5D04h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5D04h case    2:*/		return 0x821F5D08;
		  /* 821F5D08h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821F5D08h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821F5D08h case    3:*/		return 0x821F5D0C;
		  /* 821F5D0Ch */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 821F5D0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821F5D0Ch case    4:*/		return 0x821F5D10;
		  /* 821F5D10h */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 821F5D10h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F5D48;  }
		/* 821F5D10h case    5:*/		return 0x821F5D14;
		  /* 821F5D14h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5D14h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5D14h case    6:*/		return 0x821F5D18;
		  /* 821F5D18h */ case    7:  		/* mr R3, R31 */
		/* 821F5D18h case    7:*/		regs.R3 = regs.R31;
		/* 821F5D18h case    7:*/		return 0x821F5D1C;
		  /* 821F5D1Ch */ case    8:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821F5D1Ch case    8:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821F5D1Ch case    8:*/		return 0x821F5D20;
		  /* 821F5D20h */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F5D20h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F5D20h case    9:*/		return 0x821F5D24;
		  /* 821F5D24h */ case   10:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821F5D24h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821F5D24h case   10:*/		return 0x821F5D28;
		  /* 821F5D28h */ case   11:  		/* bl -596216 */
		/* 821F5D28h case   11:*/		regs.LR = 0x821F5D2C; return 0x82164430;
		/* 821F5D28h case   11:*/		return 0x821F5D2C;
		  /* 821F5D2Ch */ case   12:  		/* addi R11, R30, -8 */
		/* 821F5D2Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 821F5D2Ch case   12:*/		return 0x821F5D30;
		  /* 821F5D30h */ case   13:  		/* add R11, R3, R11 */
		/* 821F5D30h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821F5D30h case   13:*/		return 0x821F5D34;
		  /* 821F5D34h */ case   14:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F5D34h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F5D34h case   14:*/		return 0x821F5D38;
		  /* 821F5D38h */ case   15:  		/* rlwinm. R10, R10, 0, 11, 11 */
		/* 821F5D38h case   15:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R10,regs.R10);
		/* 821F5D38h case   15:*/		return 0x821F5D3C;
		  /* 821F5D3Ch */ case   16:  		/* bc 12, CR0_EQ, 144 */
		/* 821F5D3Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x821F5DCC;  }
		/* 821F5D3Ch case   16:*/		return 0x821F5D40;
		  /* 821F5D40h */ case   17:  		/* lwz R11, <#[R11]> */
		/* 821F5D40h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5D40h case   17:*/		return 0x821F5D44;
		  /* 821F5D44h */ case   18:  		/* b 60 */
		/* 821F5D44h case   18:*/		return 0x821F5D80;
		/* 821F5D44h case   18:*/		return 0x821F5D48;
	}
	return 0x821F5D48;
} // Block from 821F5CFCh-821F5D48h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821F5D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5D48);
		  /* 821F5D48h */ case    0:  		/* cmplwi CR6, R11, 97 */
		/* 821F5D48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 821F5D48h case    0:*/		return 0x821F5D4C;
		  /* 821F5D4Ch */ case    1:  		/* bc 4, CR6_EQ, 128 */
		/* 821F5D4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F5DCC;  }
		/* 821F5D4Ch case    1:*/		return 0x821F5D50;
		  /* 821F5D50h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821F5D50h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821F5D50h case    2:*/		return 0x821F5D54;
		  /* 821F5D54h */ case    3:  		/* mr R3, R31 */
		/* 821F5D54h case    3:*/		regs.R3 = regs.R31;
		/* 821F5D54h case    3:*/		return 0x821F5D58;
		  /* 821F5D58h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821F5D58h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821F5D58h case    4:*/		return 0x821F5D5C;
		  /* 821F5D5Ch */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821F5D5Ch case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821F5D5Ch case    5:*/		return 0x821F5D60;
		  /* 821F5D60h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821F5D60h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821F5D60h case    6:*/		return 0x821F5D64;
		  /* 821F5D64h */ case    7:  		/* bl -596276 */
		/* 821F5D64h case    7:*/		regs.LR = 0x821F5D68; return 0x82164430;
		/* 821F5D64h case    7:*/		return 0x821F5D68;
		  /* 821F5D68h */ case    8:  		/* addi R11, R30, -24 */
		/* 821F5D68h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFE8);
		/* 821F5D68h case    8:*/		return 0x821F5D6C;
		  /* 821F5D6Ch */ case    9:  		/* add R11, R3, R11 */
		/* 821F5D6Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821F5D6Ch case    9:*/		return 0x821F5D70;
		  /* 821F5D70h */ case   10:  		/* lwz R10, <#[R11 + 12]> */
		/* 821F5D70h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F5D70h case   10:*/		return 0x821F5D74;
		  /* 821F5D74h */ case   11:  		/* rlwinm. R10, R10, 0, 14, 14 */
		/* 821F5D74h case   11:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R10,regs.R10);
		/* 821F5D74h case   11:*/		return 0x821F5D78;
		  /* 821F5D78h */ case   12:  		/* bc 12, CR0_EQ, 84 */
		/* 821F5D78h case   12:*/		if ( regs.CR[0].eq ) { return 0x821F5DCC;  }
		/* 821F5D78h case   12:*/		return 0x821F5D7C;
		  /* 821F5D7Ch */ case   13:  		/* lwz R11, <#[R11 + 16]> */
		/* 821F5D7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 821F5D7Ch case   13:*/		return 0x821F5D80;
	}
	return 0x821F5D80;
} // Block from 821F5D48h-821F5D80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821F5D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5D80);
		  /* 821F5D80h */ case    0:  		/* rlwinm R10, R11, 0, 17, 31 */
		/* 821F5D80h case    0:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R11);
		/* 821F5D80h case    0:*/		return 0x821F5D84;
		  /* 821F5D84h */ case    1:  		/* rlwinm R11, R11, 17, 18, 31 */
		/* 821F5D84h case    1:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R11,regs.R11);
		/* 821F5D84h case    1:*/		return 0x821F5D88;
		  /* 821F5D88h */ case    2:  		/* cmplwi CR6, R19, 0 */
		/* 821F5D88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 821F5D88h case    2:*/		return 0x821F5D8C;
		  /* 821F5D8Ch */ case    3:  		/* bc 12, CR6_EQ, 76 */
		/* 821F5D8Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821F5DD8;  }
		/* 821F5D8Ch case    3:*/		return 0x821F5D90;
		  /* 821F5D90h */ case    4:  		/* cmplwi CR6, R19, 1 */
		/* 821F5D90h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000001);
		/* 821F5D90h case    4:*/		return 0x821F5D94;
		  /* 821F5D94h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 821F5D94h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F5DA4;  }
		/* 821F5D94h case    5:*/		return 0x821F5D98;
		  /* 821F5D98h */ case    6:  		/* cmplw CR6, R24, R11 */
		/* 821F5D98h case    6:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 821F5D98h case    6:*/		return 0x821F5D9C;
		  /* 821F5D9Ch */ case    7:  		/* bc 4, CR6_LT, 48 */
		/* 821F5D9Ch case    7:*/		if ( !regs.CR[6].lt ) { return 0x821F5DCC;  }
		/* 821F5D9Ch case    7:*/		return 0x821F5DA0;
		  /* 821F5DA0h */ case    8:  		/* subf R22, R24, R11 */
		/* 821F5DA0h case    8:*/		cpu::op::subf<0>(regs,&regs.R22,regs.R24,regs.R11);
		/* 821F5DA0h case    8:*/		return 0x821F5DA4;
	}
	return 0x821F5DA4;
} // Block from 821F5D80h-821F5DA4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821F5DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5DA4);
		  /* 821F5DA4h */ case    0:  		/* cmplw CR6, R20, R10 */
		/* 821F5DA4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R10);
		/* 821F5DA4h case    0:*/		return 0x821F5DA8;
		  /* 821F5DA8h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 821F5DA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F5DCC;  }
		/* 821F5DA8h case    1:*/		return 0x821F5DAC;
		  /* 821F5DACh */ case    2:  		/* cmplw CR6, R17, R27 */
		/* 821F5DACh case    2:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R27);
		/* 821F5DACh case    2:*/		return 0x821F5DB0;
		  /* 821F5DB0h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 821F5DB0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821F5DCC;  }
		/* 821F5DB0h case    3:*/		return 0x821F5DB4;
		  /* 821F5DB4h */ case    4:  		/* cmpw CR6, R21, R26 */
		/* 821F5DB4h case    4:*/		cpu::op::cmpw<6>(regs,regs.R21,regs.R26);
		/* 821F5DB4h case    4:*/		return 0x821F5DB8;
		  /* 821F5DB8h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 821F5DB8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F5DCC;  }
		/* 821F5DB8h case    5:*/		return 0x821F5DBC;
		  /* 821F5DBCh */ case    6:  		/* mullw R10, R19, R22 */
		/* 821F5DBCh case    6:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R19,regs.R22);
		/* 821F5DBCh case    6:*/		return 0x821F5DC0;
		  /* 821F5DC0h */ case    7:  		/* add R10, R10, R24 */
		/* 821F5DC0h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R24);
		/* 821F5DC0h case    7:*/		return 0x821F5DC4;
		  /* 821F5DC4h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 821F5DC4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821F5DC4h case    8:*/		return 0x821F5DC8;
		  /* 821F5DC8h */ case    9:  		/* bc 12, CR6_EQ, 36 */
		/* 821F5DC8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821F5DEC;  }
		/* 821F5DC8h case    9:*/		return 0x821F5DCC;
	}
	return 0x821F5DCC;
} // Block from 821F5DA4h-821F5DCCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821F5DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5DCC);
		  /* 821F5DCCh */ case    0:  		/* li R3, 0 */
		/* 821F5DCCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821F5DCCh case    0:*/		return 0x821F5DD0;
		  /* 821F5DD0h */ case    1:  		/* addi R1, R1, 224 */
		/* 821F5DD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821F5DD0h case    1:*/		return 0x821F5DD4;
		  /* 821F5DD4h */ case    2:  		/* b -1461084 */
		/* 821F5DD4h case    2:*/		return 0x82091278;
		/* 821F5DD4h case    2:*/		return 0x821F5DD8;
	}
	return 0x821F5DD8;
} // Block from 821F5DCCh-821F5DD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5DD8);
		  /* 821F5DD8h */ case    0:  		/* mr R28, R30 */
		/* 821F5DD8h case    0:*/		regs.R28 = regs.R30;
		/* 821F5DD8h case    0:*/		return 0x821F5DDC;
		  /* 821F5DDCh */ case    1:  		/* mr R20, R10 */
		/* 821F5DDCh case    1:*/		regs.R20 = regs.R10;
		/* 821F5DDCh case    1:*/		return 0x821F5DE0;
		  /* 821F5DE0h */ case    2:  		/* mr R17, R27 */
		/* 821F5DE0h case    2:*/		regs.R17 = regs.R27;
		/* 821F5DE0h case    2:*/		return 0x821F5DE4;
		  /* 821F5DE4h */ case    3:  		/* mr R21, R26 */
		/* 821F5DE4h case    3:*/		regs.R21 = regs.R26;
		/* 821F5DE4h case    3:*/		return 0x821F5DE8;
		  /* 821F5DE8h */ case    4:  		/* mr R24, R11 */
		/* 821F5DE8h case    4:*/		regs.R24 = regs.R11;
		/* 821F5DE8h case    4:*/		return 0x821F5DEC;
	}
	return 0x821F5DEC;
} // Block from 821F5DD8h-821F5DECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821F5DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5DEC);
		  /* 821F5DECh */ case    0:  		/* addi R19, R19, 1 */
		/* 821F5DECh case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 821F5DECh case    0:*/		return 0x821F5DF0;
		  /* 821F5DF0h */ case    1:  		/* cmplw CR6, R19, R25 */
		/* 821F5DF0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R25);
		/* 821F5DF0h case    1:*/		return 0x821F5DF4;
		  /* 821F5DF4h */ case    2:  		/* bc 12, CR6_LT, -372 */
		/* 821F5DF4h case    2:*/		if ( regs.CR[6].lt ) { return 0x821F5C80;  }
		/* 821F5DF4h case    2:*/		return 0x821F5DF8;
	}
	return 0x821F5DF8;
} // Block from 821F5DECh-821F5DF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821F5DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5DF8);
		  /* 821F5DF8h */ case    0:  		/* addi R4, R1, 256 */
		/* 821F5DF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x100);
		/* 821F5DF8h case    0:*/		return 0x821F5DFC;
		  /* 821F5DFCh */ case    1:  		/* mr R3, R31 */
		/* 821F5DFCh case    1:*/		regs.R3 = regs.R31;
		/* 821F5DFCh case    1:*/		return 0x821F5E00;
		  /* 821F5E00h */ case    2:  		/* bl -14976 */
		/* 821F5E00h case    2:*/		regs.LR = 0x821F5E04; return 0x821F2380;
		/* 821F5E00h case    2:*/		return 0x821F5E04;
		  /* 821F5E04h */ case    3:  		/* mr R4, R3 */
		/* 821F5E04h case    3:*/		regs.R4 = regs.R3;
		/* 821F5E04h case    3:*/		return 0x821F5E08;
		  /* 821F5E08h */ case    4:  		/* mr R3, R31 */
		/* 821F5E08h case    4:*/		regs.R3 = regs.R31;
		/* 821F5E08h case    4:*/		return 0x821F5E0C;
		  /* 821F5E0Ch */ case    5:  		/* bl -29636 */
		/* 821F5E0Ch case    5:*/		regs.LR = 0x821F5E10; return 0x821EEA48;
		/* 821F5E0Ch case    5:*/		return 0x821F5E10;
		  /* 821F5E10h */ case    6:  		/* mr R4, R3 */
		/* 821F5E10h case    6:*/		regs.R4 = regs.R3;
		/* 821F5E10h case    6:*/		return 0x821F5E14;
		  /* 821F5E14h */ case    7:  		/* mr R3, R31 */
		/* 821F5E14h case    7:*/		regs.R3 = regs.R31;
		/* 821F5E14h case    7:*/		return 0x821F5E18;
		  /* 821F5E18h */ case    8:  		/* bl -515608 */
		/* 821F5E18h case    8:*/		regs.LR = 0x821F5E1C; return 0x82178000;
		/* 821F5E18h case    8:*/		return 0x821F5E1C;
		  /* 821F5E1Ch */ case    9:  		/* mr R30, R3 */
		/* 821F5E1Ch case    9:*/		regs.R30 = regs.R3;
		/* 821F5E1Ch case    9:*/		return 0x821F5E20;
		  /* 821F5E20h */ case   10:  		/* cmplwi CR6, R22, 1 */
		/* 821F5E20h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000001);
		/* 821F5E20h case   10:*/		return 0x821F5E24;
		  /* 821F5E24h */ case   11:  		/* bc 12, CR6_EQ, 92 */
		/* 821F5E24h case   11:*/		if ( regs.CR[6].eq ) { return 0x821F5E80;  }
		/* 821F5E24h case   11:*/		return 0x821F5E28;
		  /* 821F5E28h */ case   12:  		/* rldicl R10, R22, 0, 32 */
		/* 821F5E28h case   12:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R22);
		/* 821F5E28h case   12:*/		return 0x821F5E2C;
		  /* 821F5E2Ch */ case   13:  		/* lis R11, -32256 */
		/* 821F5E2Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F5E2Ch case   13:*/		return 0x821F5E30;
		  /* 821F5E30h */ case   14:  		/* std R10, <#[R1 + 80]> */
		/* 821F5E30h case   14:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5E30h case   14:*/		return 0x821F5E34;
		  /* 821F5E34h */ case   15:  		/* lfd FR0, <#[R1 + 80]> */
		/* 821F5E34h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 821F5E34h case   15:*/		return 0x821F5E38;
		  /* 821F5E38h */ case   16:  		/* fcfid FR0, FR0 */
		/* 821F5E38h case   16:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 821F5E38h case   16:*/		return 0x821F5E3C;
		  /* 821F5E3Ch */ case   17:  		/* li R5, 1 */
		/* 821F5E3Ch case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F5E3Ch case   17:*/		return 0x821F5E40;
		  /* 821F5E40h */ case   18:  		/* lfs FR4, <#[R11 + 1816]> */
		/* 821F5E40h case   18:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000718) );
		/* 821F5E40h case   18:*/		return 0x821F5E44;
		  /* 821F5E44h */ case   19:  		/* mr R4, R31 */
		/* 821F5E44h case   19:*/		regs.R4 = regs.R31;
		/* 821F5E44h case   19:*/		return 0x821F5E48;
		  /* 821F5E48h */ case   20:  		/* addi R3, R1, 80 */
		/* 821F5E48h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F5E48h case   20:*/		return 0x821F5E4C;
		  /* 821F5E4Ch */ case   21:  		/* frsp FR1, FR0 */
		/* 821F5E4Ch case   21:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR0);
		/* 821F5E4Ch case   21:*/		return 0x821F5E50;
		  /* 821F5E50h */ case   22:  		/* fmr FR3, FR4 */
		/* 821F5E50h case   22:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 821F5E50h case   22:*/		return 0x821F5E54;
		  /* 821F5E54h */ case   23:  		/* fmr FR2, FR4 */
		/* 821F5E54h case   23:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 821F5E54h case   23:*/		return 0x821F5E58;
		  /* 821F5E58h */ case   24:  		/* bl 200696 */
		/* 821F5E58h case   24:*/		regs.LR = 0x821F5E5C; return 0x82226E50;
		/* 821F5E58h case   24:*/		return 0x821F5E5C;
		  /* 821F5E5Ch */ case   25:  		/* mr R11, R3 */
		/* 821F5E5Ch case   25:*/		regs.R11 = regs.R3;
		/* 821F5E5Ch case   25:*/		return 0x821F5E60;
		  /* 821F5E60h */ case   26:  		/* mr R4, R30 */
		/* 821F5E60h case   26:*/		regs.R4 = regs.R30;
		/* 821F5E60h case   26:*/		return 0x821F5E64;
		  /* 821F5E64h */ case   27:  		/* mr R3, R31 */
		/* 821F5E64h case   27:*/		regs.R3 = regs.R31;
		/* 821F5E64h case   27:*/		return 0x821F5E68;
		  /* 821F5E68h */ case   28:  		/* ld R5, <#[R11]> */
		/* 821F5E68h case   28:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5E68h case   28:*/		return 0x821F5E6C;
		  /* 821F5E6Ch */ case   29:  		/* bl -9924 */
		/* 821F5E6Ch case   29:*/		regs.LR = 0x821F5E70; return 0x821F37A8;
		/* 821F5E6Ch case   29:*/		return 0x821F5E70;
		  /* 821F5E70h */ case   30:  		/* mr R4, R3 */
		/* 821F5E70h case   30:*/		regs.R4 = regs.R3;
		/* 821F5E70h case   30:*/		return 0x821F5E74;
		  /* 821F5E74h */ case   31:  		/* mr R3, R31 */
		/* 821F5E74h case   31:*/		regs.R3 = regs.R31;
		/* 821F5E74h case   31:*/		return 0x821F5E78;
		  /* 821F5E78h */ case   32:  		/* bl -515704 */
		/* 821F5E78h case   32:*/		regs.LR = 0x821F5E7C; return 0x82178000;
		/* 821F5E78h case   32:*/		return 0x821F5E7C;
		  /* 821F5E7Ch */ case   33:  		/* mr R30, R3 */
		/* 821F5E7Ch case   33:*/		regs.R30 = regs.R3;
		/* 821F5E7Ch case   33:*/		return 0x821F5E80;
	}
	return 0x821F5E80;
} // Block from 821F5DF8h-821F5E80h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821F5E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5E80);
		  /* 821F5E80h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 821F5E80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821F5E80h case    0:*/		return 0x821F5E84;
		  /* 821F5E84h */ case    1:  		/* li R27, 1 */
		/* 821F5E84h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821F5E84h case    1:*/		return 0x821F5E88;
		  /* 821F5E88h */ case    2:  		/* mr R3, R31 */
		/* 821F5E88h case    2:*/		regs.R3 = regs.R31;
		/* 821F5E88h case    2:*/		return 0x821F5E8C;
		  /* 821F5E8Ch */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821F5E8Ch case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821F5E8Ch case    3:*/		return 0x821F5E90;
		  /* 821F5E90h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 821F5E90h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821F5E90h case    4:*/		return 0x821F5E94;
		  /* 821F5E94h */ case    5:  		/* bc 4, CR6_EQ, 280 */
		/* 821F5E94h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821F5FAC;  }
		/* 821F5E94h case    5:*/		return 0x821F5E98;
		  /* 821F5E98h */ case    6:  		/* lwz R11, <#[R30]> */
		/* 821F5E98h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5E98h case    6:*/		return 0x821F5E9C;
		  /* 821F5E9Ch */ case    7:  		/* mr R10, R27 */
		/* 821F5E9Ch case    7:*/		regs.R10 = regs.R27;
		/* 821F5E9Ch case    7:*/		return 0x821F5EA0;
		  /* 821F5EA0h */ case    8:  		/* mr R4, R30 */
		/* 821F5EA0h case    8:*/		regs.R4 = regs.R30;
		/* 821F5EA0h case    8:*/		return 0x821F5EA4;
		  /* 821F5EA4h */ case    9:  		/* rlwimi R11, R10, 26, 19, 26 */
		/* 821F5EA4h case    9:*/		cpu::op::rlwimi<0,26,19,26>(regs,&regs.R11,regs.R10);
		/* 821F5EA4h case    9:*/		return 0x821F5EA8;
		  /* 821F5EA8h */ case   10:  		/* rlwimi R11, R27, 26, 4, 6 */
		/* 821F5EA8h case   10:*/		cpu::op::rlwimi<0,26,4,6>(regs,&regs.R11,regs.R27);
		/* 821F5EA8h case   10:*/		return 0x821F5EAC;
		  /* 821F5EACh */ case   11:  		/* stw R11, <#[R30]> */
		/* 821F5EACh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5EACh case   11:*/		return 0x821F5EB0;
		  /* 821F5EB0h */ case   12:  		/* bl -27680 */
		/* 821F5EB0h case   12:*/		regs.LR = 0x821F5EB4; return 0x821EF290;
		/* 821F5EB0h case   12:*/		return 0x821F5EB4;
		  /* 821F5EB4h */ case   13:  		/* mr R30, R3 */
		/* 821F5EB4h case   13:*/		regs.R30 = regs.R3;
		/* 821F5EB4h case   13:*/		return 0x821F5EB8;
		  /* 821F5EB8h */ case   14:  		/* mr R4, R28 */
		/* 821F5EB8h case   14:*/		regs.R4 = regs.R28;
		/* 821F5EB8h case   14:*/		return 0x821F5EBC;
		  /* 821F5EBCh */ case   15:  		/* mr R3, R31 */
		/* 821F5EBCh case   15:*/		regs.R3 = regs.R31;
		/* 821F5EBCh case   15:*/		return 0x821F5EC0;
		  /* 821F5EC0h */ case   16:  		/* bl -515776 */
		/* 821F5EC0h case   16:*/		regs.LR = 0x821F5EC4; return 0x82178000;
		/* 821F5EC0h case   16:*/		return 0x821F5EC4;
		  /* 821F5EC4h */ case   17:  		/* rlwinm R11, R21, 5, 22, 26 */
		/* 821F5EC4h case   17:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R11,regs.R21);
		/* 821F5EC4h case   17:*/		return 0x821F5EC8;
		  /* 821F5EC8h */ case   18:  		/* lis R12, -3073 */
		/* 821F5EC8h case   18:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821F5EC8h case   18:*/		return 0x821F5ECC;
		  /* 821F5ECCh */ case   19:  		/* lwz R10, <#[R3]> */
		/* 821F5ECCh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821F5ECCh case   19:*/		return 0x821F5ED0;
		  /* 821F5ED0h */ case   20:  		/* rlwinm R11, R11, 0, 25, 23 */
		/* 821F5ED0h case   20:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R11,regs.R11);
		/* 821F5ED0h case   20:*/		return 0x821F5ED4;
		  /* 821F5ED4h */ case   21:  		/* ori R12, R12, 64671 */
		/* 821F5ED4h case   21:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC9F);
		/* 821F5ED4h case   21:*/		return 0x821F5ED8;
		  /* 821F5ED8h */ case   22:  		/* oris R11, R11, 512 */
		/* 821F5ED8h case   22:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821F5ED8h case   22:*/		return 0x821F5EDC;
		  /* 821F5EDCh */ case   23:  		/* mr R28, R3 */
		/* 821F5EDCh case   23:*/		regs.R28 = regs.R3;
		/* 821F5EDCh case   23:*/		return 0x821F5EE0;
		  /* 821F5EE0h */ case   24:  		/* ori R11, R11, 7296 */
		/* 821F5EE0h case   24:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1C80);
		/* 821F5EE0h case   24:*/		return 0x821F5EE4;
		  /* 821F5EE4h */ case   25:  		/* and R10, R10, R12 */
		/* 821F5EE4h case   25:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 821F5EE4h case   25:*/		return 0x821F5EE8;
		  /* 821F5EE8h */ case   26:  		/* li R8, 1 */
		/* 821F5EE8h case   26:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821F5EE8h case   26:*/		return 0x821F5EEC;
		  /* 821F5EECh */ case   27:  		/* or R11, R11, R10 */
		/* 821F5EECh case   27:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821F5EECh case   27:*/		return 0x821F5EF0;
		  /* 821F5EF0h */ case   28:  		/* li R7, 2 */
		/* 821F5EF0h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821F5EF0h case   28:*/		return 0x821F5EF4;
		  /* 821F5EF4h */ case   29:  		/* stw R11, <#[R28]> */
		/* 821F5EF4h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821F5EF4h case   29:*/		return 0x821F5EF8;
		  /* 821F5EF8h */ case   30:  		/* li R6, 118 */
		/* 821F5EF8h case   30:*/		cpu::op::li<0>(regs,&regs.R6,0x76);
		/* 821F5EF8h case   30:*/		return 0x821F5EFC;
		  /* 821F5EFCh */ case   31:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F5EFCh case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F5EFCh case   31:*/		return 0x821F5F00;
		  /* 821F5F00h */ case   32:  		/* mr R3, R31 */
		/* 821F5F00h case   32:*/		regs.R3 = regs.R31;
		/* 821F5F00h case   32:*/		return 0x821F5F04;
		  /* 821F5F04h */ case   33:  		/* addi R5, R4, 24 */
		/* 821F5F04h case   33:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R4,0x18);
		/* 821F5F04h case   33:*/		return 0x821F5F08;
		  /* 821F5F08h */ case   34:  		/* bl 191120 */
		/* 821F5F08h case   34:*/		regs.LR = 0x821F5F0C; return 0x82224998;
		/* 821F5F08h case   34:*/		return 0x821F5F0C;
		  /* 821F5F0Ch */ case   35:  		/* mr R4, R28 */
		/* 821F5F0Ch case   35:*/		regs.R4 = regs.R28;
		/* 821F5F0Ch case   35:*/		return 0x821F5F10;
		  /* 821F5F10h */ case   36:  		/* mr R26, R3 */
		/* 821F5F10h case   36:*/		regs.R26 = regs.R3;
		/* 821F5F10h case   36:*/		return 0x821F5F14;
		  /* 821F5F14h */ case   37:  		/* bl -515404 */
		/* 821F5F14h case   37:*/		regs.LR = 0x821F5F18; return 0x821781C8;
		/* 821F5F14h case   37:*/		return 0x821F5F18;
		  /* 821F5F18h */ case   38:  		/* stw R3, <#[R26 + 44]> */
		/* 821F5F18h case   38:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + 0x0000002C) );
		/* 821F5F18h case   38:*/		return 0x821F5F1C;
		  /* 821F5F1Ch */ case   39:  		/* li R5, 0 */
		/* 821F5F1Ch case   39:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F5F1Ch case   39:*/		return 0x821F5F20;
		  /* 821F5F20h */ case   40:  		/* mr R4, R30 */
		/* 821F5F20h case   40:*/		regs.R4 = regs.R30;
		/* 821F5F20h case   40:*/		return 0x821F5F24;
		  /* 821F5F24h */ case   41:  		/* mr R3, R31 */
		/* 821F5F24h case   41:*/		regs.R3 = regs.R31;
		/* 821F5F24h case   41:*/		return 0x821F5F28;
		  /* 821F5F28h */ case   42:  		/* bl -546776 */
		/* 821F5F28h case   42:*/		regs.LR = 0x821F5F2C; return 0x82170750;
		/* 821F5F28h case   42:*/		return 0x821F5F2C;
		  /* 821F5F2Ch */ case   43:  		/* mr R4, R3 */
		/* 821F5F2Ch case   43:*/		regs.R4 = regs.R3;
		/* 821F5F2Ch case   43:*/		return 0x821F5F30;
		  /* 821F5F30h */ case   44:  		/* mr R3, R26 */
		/* 821F5F30h case   44:*/		regs.R3 = regs.R26;
		/* 821F5F30h case   44:*/		return 0x821F5F34;
		  /* 821F5F34h */ case   45:  		/* bl -515436 */
		/* 821F5F34h case   45:*/		regs.LR = 0x821F5F38; return 0x821781C8;
		/* 821F5F34h case   45:*/		return 0x821F5F38;
		  /* 821F5F38h */ case   46:  		/* stw R3, <#[R26 + 48]> */
		/* 821F5F38h case   46:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + 0x00000030) );
		/* 821F5F38h case   46:*/		return 0x821F5F3C;
		  /* 821F5F3Ch */ case   47:  		/* li R5, 22 */
		/* 821F5F3Ch case   47:*/		cpu::op::li<0>(regs,&regs.R5,0x16);
		/* 821F5F3Ch case   47:*/		return 0x821F5F40;
		  /* 821F5F40h */ case   48:  		/* li R4, 12 */
		/* 821F5F40h case   48:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 821F5F40h case   48:*/		return 0x821F5F44;
		  /* 821F5F44h */ case   49:  		/* mr R3, R31 */
		/* 821F5F44h case   49:*/		regs.R3 = regs.R31;
		/* 821F5F44h case   49:*/		return 0x821F5F48;
		  /* 821F5F48h */ case   50:  		/* bl -562080 */
		/* 821F5F48h case   50:*/		regs.LR = 0x821F5F4C; return 0x8216CBA8;
		/* 821F5F48h case   50:*/		return 0x821F5F4C;
		  /* 821F5F4Ch */ case   51:  		/* mr R11, R3 */
		/* 821F5F4Ch case   51:*/		regs.R11 = regs.R3;
		/* 821F5F4Ch case   51:*/		return 0x821F5F50;
		  /* 821F5F50h */ case   52:  		/* rlwimi R25, R22, 14, 4, 17 */
		/* 821F5F50h case   52:*/		cpu::op::rlwimi<0,14,4,17>(regs,&regs.R25,regs.R22);
		/* 821F5F50h case   52:*/		return 0x821F5F54;
		  /* 821F5F54h */ case   53:  		/* li R10, 0 */
		/* 821F5F54h case   53:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821F5F54h case   53:*/		return 0x821F5F58;
		  /* 821F5F58h */ case   54:  		/* mr R3, R31 */
		/* 821F5F58h case   54:*/		regs.R3 = regs.R31;
		/* 821F5F58h case   54:*/		return 0x821F5F5C;
		  /* 821F5F5Ch */ case   55:  		/* mr R4, R26 */
		/* 821F5F5Ch case   55:*/		regs.R4 = regs.R26;
		/* 821F5F5Ch case   55:*/		return 0x821F5F60;
		  /* 821F5F60h */ case   56:  		/* lwz R9, <#[R11 + 8]> */
		/* 821F5F60h case   56:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821F5F60h case   56:*/		return 0x821F5F64;
		  /* 821F5F64h */ case   57:  		/* stw R10, <#[R11]> */
		/* 821F5F64h case   57:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5F64h case   57:*/		return 0x821F5F68;
		  /* 821F5F68h */ case   58:  		/* rlwimi R25, R9, 0, 0, 3 */
		/* 821F5F68h case   58:*/		cpu::op::rlwimi<0,0,0,3>(regs,&regs.R25,regs.R9);
		/* 821F5F68h case   58:*/		return 0x821F5F6C;
		  /* 821F5F6Ch */ case   59:  		/* stw R25, <#[R11 + 8]> */
		/* 821F5F6Ch case   59:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000008) );
		/* 821F5F6Ch case   59:*/		return 0x821F5F70;
		  /* 821F5F70h */ case   60:  		/* lwz R10, <#[R26 + 16]> */
		/* 821F5F70h case   60:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 821F5F70h case   60:*/		return 0x821F5F74;
		  /* 821F5F74h */ case   61:  		/* stw R10, <#[R11 + 4]> */
		/* 821F5F74h case   61:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F5F74h case   61:*/		return 0x821F5F78;
		  /* 821F5F78h */ case   62:  		/* stw R11, <#[R26 + 16]> */
		/* 821F5F78h case   62:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 821F5F78h case   62:*/		return 0x821F5F7C;
		  /* 821F5F7Ch */ case   63:  		/* bl -515964 */
		/* 821F5F7Ch case   63:*/		regs.LR = 0x821F5F80; return 0x82178000;
		/* 821F5F7Ch case   63:*/		return 0x821F5F80;
		  /* 821F5F80h */ case   64:  		/* mr R30, R3 */
		/* 821F5F80h case   64:*/		regs.R30 = regs.R3;
		/* 821F5F80h case   64:*/		return 0x821F5F84;
		  /* 821F5F84h */ case   65:  		/* mr R3, R31 */
		/* 821F5F84h case   65:*/		regs.R3 = regs.R31;
		/* 821F5F84h case   65:*/		return 0x821F5F88;
		  /* 821F5F88h */ case   66:  		/* mr R6, R30 */
		/* 821F5F88h case   66:*/		regs.R6 = regs.R30;
		/* 821F5F88h case   66:*/		return 0x821F5F8C;
		  /* 821F5F8Ch */ case   67:  		/* lwz R11, <#[R30]> */
		/* 821F5F8Ch case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5F8Ch case   67:*/		return 0x821F5F90;
		  /* 821F5F90h */ case   68:  		/* rlwimi R11, R27, 3, 27, 31 */
		/* 821F5F90h case   68:*/		cpu::op::rlwimi<0,3,27,31>(regs,&regs.R11,regs.R27);
		/* 821F5F90h case   68:*/		return 0x821F5F94;
		  /* 821F5F94h */ case   69:  		/* stw R11, <#[R30]> */
		/* 821F5F94h case   69:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F5F94h case   69:*/		return 0x821F5F98;
		  /* 821F5F98h */ case   70:  		/* lwz R4, <#[R31 + 564]> */
		/* 821F5F98h case   70:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000234) );
		/* 821F5F98h case   70:*/		return 0x821F5F9C;
		  /* 821F5F9Ch */ case   71:  		/* addi R11, R4, 24 */
		/* 821F5F9Ch case   71:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x18);
		/* 821F5F9Ch case   71:*/		return 0x821F5FA0;
		  /* 821F5FA0h */ case   72:  		/* ori R5, R11, 3 */
		/* 821F5FA0h case   72:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R11,0x3);
		/* 821F5FA0h case   72:*/		return 0x821F5FA4;
		  /* 821F5FA4h */ case   73:  		/* bl 213020 */
		/* 821F5FA4h case   73:*/		regs.LR = 0x821F5FA8; return 0x82229FC0;
		/* 821F5FA4h case   73:*/		return 0x821F5FA8;
		  /* 821F5FA8h */ case   74:  		/* b 332 */
		/* 821F5FA8h case   74:*/		return 0x821F60F4;
		/* 821F5FA8h case   74:*/		return 0x821F5FAC;
	}
	return 0x821F5FAC;
} // Block from 821F5E80h-821F5FACh (75 instructions)

//////////////////////////////////////////////////////
// Block at 821F5FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F5FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F5FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F5FAC);
		  /* 821F5FACh */ case    0:  		/* cmplwi CR6, R11, 97 */
		/* 821F5FACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 821F5FACh case    0:*/		return 0x821F5FB0;
		  /* 821F5FB0h */ case    1:  		/* bc 4, CR6_EQ, 408 */
		/* 821F5FB0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F6148;  }
		/* 821F5FB0h case    1:*/		return 0x821F5FB4;
		  /* 821F5FB4h */ case    2:  		/* mr R4, R30 */
		/* 821F5FB4h case    2:*/		regs.R4 = regs.R30;
		/* 821F5FB4h case    2:*/		return 0x821F5FB8;
		  /* 821F5FB8h */ case    3:  		/* lwz R5, <#[R28 + 48]> */
		/* 821F5FB8h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000030) );
		/* 821F5FB8h case    3:*/		return 0x821F5FBC;
		  /* 821F5FBCh */ case    4:  		/* bl -32372 */
		/* 821F5FBCh case    4:*/		regs.LR = 0x821F5FC0; return 0x821EE148;
		/* 821F5FBCh case    4:*/		return 0x821F5FC0;
		  /* 821F5FC0h */ case    5:  		/* mr R26, R3 */
		/* 821F5FC0h case    5:*/		regs.R26 = regs.R3;
		/* 821F5FC0h case    5:*/		return 0x821F5FC4;
		  /* 821F5FC4h */ case    6:  		/* mr R4, R28 */
		/* 821F5FC4h case    6:*/		regs.R4 = regs.R28;
		/* 821F5FC4h case    6:*/		return 0x821F5FC8;
		  /* 821F5FC8h */ case    7:  		/* mr R3, R31 */
		/* 821F5FC8h case    7:*/		regs.R3 = regs.R31;
		/* 821F5FC8h case    7:*/		return 0x821F5FCC;
		  /* 821F5FCCh */ case    8:  		/* bl 191444 */
		/* 821F5FCCh case    8:*/		regs.LR = 0x821F5FD0; return 0x82224BA0;
		/* 821F5FCCh case    8:*/		return 0x821F5FD0;
		  /* 821F5FD0h */ case    9:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F5FD0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F5FD0h case    9:*/		return 0x821F5FD4;
		  /* 821F5FD4h */ case   10:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821F5FD4h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821F5FD4h case   10:*/		return 0x821F5FD8;
		  /* 821F5FD8h */ case   11:  		/* mr R30, R3 */
		/* 821F5FD8h case   11:*/		regs.R30 = regs.R3;
		/* 821F5FD8h case   11:*/		return 0x821F5FDC;
		  /* 821F5FDCh */ case   12:  		/* addi R11, R11, 36 */
		/* 821F5FDCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F5FDCh case   12:*/		return 0x821F5FE0;
		  /* 821F5FE0h */ case   13:  		/* stw R10, <#[R3 + 28]> */
		/* 821F5FE0h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 821F5FE0h case   13:*/		return 0x821F5FE4;
		  /* 821F5FE4h */ case   14:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F5FE4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F5FE4h case   14:*/		return 0x821F5FE8;
		  /* 821F5FE8h */ case   15:  		/* addi R10, R10, 24 */
		/* 821F5FE8h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x18);
		/* 821F5FE8h case   15:*/		return 0x821F5FEC;
		  /* 821F5FECh */ case   16:  		/* lwz R9, <#[R10]> */
		/* 821F5FECh case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F5FECh case   16:*/		return 0x821F5FF0;
		  /* 821F5FF0h */ case   17:  		/* addi R8, R10, -36 */
		/* 821F5FF0h case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFDC);
		/* 821F5FF0h case   17:*/		return 0x821F5FF4;
		  /* 821F5FF4h */ case   18:  		/* stw R9, <#[R11]> */
		/* 821F5FF4h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F5FF4h case   18:*/		return 0x821F5FF8;
		  /* 821F5FF8h */ case   19:  		/* addi R9, R11, -36 */
		/* 821F5FF8h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821F5FF8h case   19:*/		return 0x821F5FFC;
		  /* 821F5FFCh */ case   20:  		/* lwz R7, <#[R10]> */
		/* 821F5FFCh case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F5FFCh case   20:*/		return 0x821F6000;
		  /* 821F6000h */ case   21:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F6000h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F6000h case   21:*/		return 0x821F6004;
		  /* 821F6004h */ case   22:  		/* stw R9, <#[R7]> */
		/* 821F6004h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821F6004h case   22:*/		return 0x821F6008;
		  /* 821F6008h */ case   23:  		/* ori R8, R8, 1 */
		/* 821F6008h case   23:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F6008h case   23:*/		return 0x821F600C;
		  /* 821F600Ch */ case   24:  		/* addi R9, R11, 4 */
		/* 821F600Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F600Ch case   24:*/		return 0x821F6010;
		  /* 821F6010h */ case   25:  		/* stw R8, <#[R11 + 4]> */
		/* 821F6010h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F6010h case   25:*/		return 0x821F6014;
		  /* 821F6014h */ case   26:  		/* stw R9, <#[R10]> */
		/* 821F6014h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F6014h case   26:*/		return 0x821F6018;
		  /* 821F6018h */ case   27:  		/* lwz R4, <#[R28 + 44]> */
		/* 821F6018h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x0000002C) );
		/* 821F6018h case   27:*/		return 0x821F601C;
		  /* 821F601Ch */ case   28:  		/* bl -515668 */
		/* 821F601Ch case   28:*/		regs.LR = 0x821F6020; return 0x821781C8;
		/* 821F601Ch case   28:*/		return 0x821F6020;
		  /* 821F6020h */ case   29:  		/* stw R3, <#[R30 + 44]> */
		/* 821F6020h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F6020h case   29:*/		return 0x821F6024;
		  /* 821F6024h */ case   30:  		/* li R5, 0 */
		/* 821F6024h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821F6024h case   30:*/		return 0x821F6028;
		  /* 821F6028h */ case   31:  		/* mr R4, R26 */
		/* 821F6028h case   31:*/		regs.R4 = regs.R26;
		/* 821F6028h case   31:*/		return 0x821F602C;
		  /* 821F602Ch */ case   32:  		/* mr R3, R31 */
		/* 821F602Ch case   32:*/		regs.R3 = regs.R31;
		/* 821F602Ch case   32:*/		return 0x821F6030;
		  /* 821F6030h */ case   33:  		/* bl -515872 */
		/* 821F6030h case   33:*/		regs.LR = 0x821F6034; return 0x82178110;
		/* 821F6030h case   33:*/		return 0x821F6034;
		  /* 821F6034h */ case   34:  		/* mr R4, R3 */
		/* 821F6034h case   34:*/		regs.R4 = regs.R3;
		/* 821F6034h case   34:*/		return 0x821F6038;
		  /* 821F6038h */ case   35:  		/* mr R3, R30 */
		/* 821F6038h case   35:*/		regs.R3 = regs.R30;
		/* 821F6038h case   35:*/		return 0x821F603C;
		  /* 821F603Ch */ case   36:  		/* bl -515700 */
		/* 821F603Ch case   36:*/		regs.LR = 0x821F6040; return 0x821781C8;
		/* 821F603Ch case   36:*/		return 0x821F6040;
		  /* 821F6040h */ case   37:  		/* lwz R11, <#[R30 + 44]> */
		/* 821F6040h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F6040h case   37:*/		return 0x821F6044;
		  /* 821F6044h */ case   38:  		/* stw R3, <#[R30 + 48]> */
		/* 821F6044h case   38:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 821F6044h case   38:*/		return 0x821F6048;
		  /* 821F6048h */ case   39:  		/* lwz R4, <#[R11 + 12]> */
		/* 821F6048h case   39:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F6048h case   39:*/		return 0x821F604C;
		  /* 821F604Ch */ case   40:  		/* lwz R11, <#[R4 + 8]> */
		/* 821F604Ch case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821F604Ch case   40:*/		return 0x821F6050;
		  /* 821F6050h */ case   41:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821F6050h case   41:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821F6050h case   41:*/		return 0x821F6054;
		  /* 821F6054h */ case   42:  		/* cmplwi CR6, R11, 15360 */
		/* 821F6054h case   42:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003C00);
		/* 821F6054h case   42:*/		return 0x821F6058;
		  /* 821F6058h */ case   43:  		/* bc 4, CR6_EQ, 140 */
		/* 821F6058h case   43:*/		if ( !regs.CR[6].eq ) { return 0x821F60E4;  }
		/* 821F6058h case   43:*/		return 0x821F605C;
		  /* 821F605Ch */ case   44:  		/* mr R3, R31 */
		/* 821F605Ch case   44:*/		regs.R3 = regs.R31;
		/* 821F605Ch case   44:*/		return 0x821F6060;
		  /* 821F6060h */ case   45:  		/* bl 191296 */
		/* 821F6060h case   45:*/		regs.LR = 0x821F6064; return 0x82224BA0;
		/* 821F6060h case   45:*/		return 0x821F6064;
		  /* 821F6064h */ case   46:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F6064h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F6064h case   46:*/		return 0x821F6068;
		  /* 821F6068h */ case   47:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821F6068h case   47:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821F6068h case   47:*/		return 0x821F606C;
		  /* 821F606Ch */ case   48:  		/* addi R11, R11, 36 */
		/* 821F606Ch case   48:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821F606Ch case   48:*/		return 0x821F6070;
		  /* 821F6070h */ case   49:  		/* stw R10, <#[R3 + 28]> */
		/* 821F6070h case   49:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 821F6070h case   49:*/		return 0x821F6074;
		  /* 821F6074h */ case   50:  		/* lwz R10, <#[R31 + 564]> */
		/* 821F6074h case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000234) );
		/* 821F6074h case   50:*/		return 0x821F6078;
		  /* 821F6078h */ case   51:  		/* addi R10, R10, 16 */
		/* 821F6078h case   51:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x10);
		/* 821F6078h case   51:*/		return 0x821F607C;
		  /* 821F607Ch */ case   52:  		/* lwz R9, <#[R10]> */
		/* 821F607Ch case   52:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F607Ch case   52:*/		return 0x821F6080;
		  /* 821F6080h */ case   53:  		/* addi R8, R10, -36 */
		/* 821F6080h case   53:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFDC);
		/* 821F6080h case   53:*/		return 0x821F6084;
		  /* 821F6084h */ case   54:  		/* stw R9, <#[R11]> */
		/* 821F6084h case   54:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821F6084h case   54:*/		return 0x821F6088;
		  /* 821F6088h */ case   55:  		/* addi R9, R11, -36 */
		/* 821F6088h case   55:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821F6088h case   55:*/		return 0x821F608C;
		  /* 821F608Ch */ case   56:  		/* lwz R7, <#[R10]> */
		/* 821F608Ch case   56:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821F608Ch case   56:*/		return 0x821F6090;
		  /* 821F6090h */ case   57:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821F6090h case   57:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821F6090h case   57:*/		return 0x821F6094;
		  /* 821F6094h */ case   58:  		/* stw R9, <#[R7]> */
		/* 821F6094h case   58:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821F6094h case   58:*/		return 0x821F6098;
		  /* 821F6098h */ case   59:  		/* ori R8, R8, 1 */
		/* 821F6098h case   59:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821F6098h case   59:*/		return 0x821F609C;
		  /* 821F609Ch */ case   60:  		/* addi R9, R11, 4 */
		/* 821F609Ch case   60:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821F609Ch case   60:*/		return 0x821F60A0;
		  /* 821F60A0h */ case   61:  		/* stw R8, <#[R11 + 4]> */
		/* 821F60A0h case   61:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821F60A0h case   61:*/		return 0x821F60A4;
		  /* 821F60A4h */ case   62:  		/* stw R9, <#[R10]> */
		/* 821F60A4h case   62:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F60A4h case   62:*/		return 0x821F60A8;
		  /* 821F60A8h */ case   63:  		/* lwz R11, <#[R30 + 44]> */
		/* 821F60A8h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821F60A8h case   63:*/		return 0x821F60AC;
		  /* 821F60ACh */ case   64:  		/* lwz R10, <#[R11 + 12]> */
		/* 821F60ACh case   64:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F60ACh case   64:*/		return 0x821F60B0;
		  /* 821F60B0h */ case   65:  		/* addi R10, R10, 4 */
		/* 821F60B0h case   65:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821F60B0h case   65:*/		return 0x821F60B4;
		  /* 821F60B4h */ case   66:  		/* lwz R9, <#[R10]> */
		/* 821F60B4h case   66:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F60B4h case   66:*/		return 0x821F60B8;
		  /* 821F60B8h */ case   67:  		/* b 12 */
		/* 821F60B8h case   67:*/		return 0x821F60C4;
		/* 821F60B8h case   67:*/		return 0x821F60BC;
		  /* 821F60BCh */ case   68:  		/* addi R10, R9, 8 */
		/* 821F60BCh case   68:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821F60BCh case   68:*/		return 0x821F60C0;
		  /* 821F60C0h */ case   69:  		/* lwz R9, <#[R9 + 8]> */
		/* 821F60C0h case   69:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821F60C0h case   69:*/		return 0x821F60C4;
	}
	return 0x821F60C4;
} // Block from 821F5FACh-821F60C4h (70 instructions)

//////////////////////////////////////////////////////
// Block at 821F60C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F60C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F60C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F60C4);
		  /* 821F60C4h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821F60C4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821F60C4h case    0:*/		return 0x821F60C8;
		  /* 821F60C8h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821F60C8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821F60BC;  }
		/* 821F60C8h case    1:*/		return 0x821F60CC;
		  /* 821F60CCh */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821F60CCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821F60CCh case    2:*/		return 0x821F60D0;
		  /* 821F60D0h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821F60D0h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821F60D0h case    3:*/		return 0x821F60D4;
		  /* 821F60D4h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 821F60D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821F60D4h case    4:*/		return 0x821F60D8;
		  /* 821F60D8h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821F60D8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821F60D8h case    5:*/		return 0x821F60DC;
		  /* 821F60DCh */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 821F60DCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821F60DCh case    6:*/		return 0x821F60E0;
		  /* 821F60E0h */ case    7:  		/* stw R3, <#[R11 + 12]> */
		/* 821F60E0h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 821F60E0h case    7:*/		return 0x821F60E4;
	}
	return 0x821F60E4;
} // Block from 821F60C4h-821F60E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821F60E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F60E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F60E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F60E4);
		  /* 821F60E4h */ case    0:  		/* mr R4, R30 */
		/* 821F60E4h case    0:*/		regs.R4 = regs.R30;
		/* 821F60E4h case    0:*/		return 0x821F60E8;
		  /* 821F60E8h */ case    1:  		/* mr R3, R31 */
		/* 821F60E8h case    1:*/		regs.R3 = regs.R31;
		/* 821F60E8h case    1:*/		return 0x821F60EC;
		  /* 821F60ECh */ case    2:  		/* bl -516332 */
		/* 821F60ECh case    2:*/		regs.LR = 0x821F60F0; return 0x82178000;
		/* 821F60ECh case    2:*/		return 0x821F60F0;
		  /* 821F60F0h */ case    3:  		/* mr R30, R3 */
		/* 821F60F0h case    3:*/		regs.R30 = regs.R3;
		/* 821F60F0h case    3:*/		return 0x821F60F4;
	}
	return 0x821F60F4;
} // Block from 821F60E4h-821F60F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821F60F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F60F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F60F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F60F4);
		  /* 821F60F4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821F60F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F60F4h case    0:*/		return 0x821F60F8;
		  /* 821F60F8h */ case    1:  		/* mr R4, R16 */
		/* 821F60F8h case    1:*/		regs.R4 = regs.R16;
		/* 821F60F8h case    1:*/		return 0x821F60FC;
		  /* 821F60FCh */ case    2:  		/* mr R3, R29 */
		/* 821F60FCh case    2:*/		regs.R3 = regs.R29;
		/* 821F60FCh case    2:*/		return 0x821F6100;
		  /* 821F6100h */ case    3:  		/* rlwimi R11, R17, 0, 27, 31 */
		/* 821F6100h case    3:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R11,regs.R17);
		/* 821F6100h case    3:*/		return 0x821F6104;
		  /* 821F6104h */ case    4:  		/* stw R11, <#[R30]> */
		/* 821F6104h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821F6104h case    4:*/		return 0x821F6108;
		  /* 821F6108h */ case    5:  		/* lwz R28, <#[R29 + 8]> */
		/* 821F6108h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000008) );
		/* 821F6108h case    5:*/		return 0x821F610C;
		  /* 821F610Ch */ case    6:  		/* lwz R31, <#[R29 + 4]> */
		/* 821F610Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 821F610Ch case    6:*/		return 0x821F6110;
		  /* 821F6110h */ case    7:  		/* bl -33560 */
		/* 821F6110h case    7:*/		regs.LR = 0x821F6114; return 0x821EDDF8;
		/* 821F6110h case    7:*/		return 0x821F6114;
		  /* 821F6114h */ case    8:  		/* lwz R11, <#[R29 + 8]> */
		/* 821F6114h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821F6114h case    8:*/		return 0x821F6118;
		  /* 821F6118h */ case    9:  		/* li R3, 1 */
		/* 821F6118h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821F6118h case    9:*/		return 0x821F611C;
		  /* 821F611Ch */ case   10:  		/* stw R28, <#[R29 + 8]> */
		/* 821F611Ch case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + 0x00000008) );
		/* 821F611Ch case   10:*/		return 0x821F6120;
		  /* 821F6120h */ case   11:  		/* addi R11, R11, 2 */
		/* 821F6120h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821F6120h case   11:*/		return 0x821F6124;
		  /* 821F6124h */ case   12:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 821F6124h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 821F6124h case   12:*/		return 0x821F6128;
		  /* 821F6128h */ case   13:  		/* lwz R11, <#[R29 + 4]> */
		/* 821F6128h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821F6128h case   13:*/		return 0x821F612C;
		  /* 821F612Ch */ case   14:  		/* stw R31, <#[R29 + 4]> */
		/* 821F612Ch case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 821F612Ch case   14:*/		return 0x821F6130;
		  /* 821F6130h */ case   15:  		/* add R11, R10, R11 */
		/* 821F6130h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821F6130h case   15:*/		return 0x821F6134;
		  /* 821F6134h */ case   16:  		/* lwz R10, <#[R11 + 4]> */
		/* 821F6134h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F6134h case   16:*/		return 0x821F6138;
		  /* 821F6138h */ case   17:  		/* rlwimi R10, R27, 1, 16, 14 */
		/* 821F6138h case   17:*/		cpu::op::rlwimi<0,1,16,14>(regs,&regs.R10,regs.R27);
		/* 821F6138h case   17:*/		return 0x821F613C;
		  /* 821F613Ch */ case   18:  		/* stw R30, <#[R11]> */
		/* 821F613Ch case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 821F613Ch case   18:*/		return 0x821F6140;
		  /* 821F6140h */ case   19:  		/* stw R10, <#[R11 + 4]> */
		/* 821F6140h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821F6140h case   19:*/		return 0x821F6144;
		  /* 821F6144h */ case   20:  		/* b -884 */
		/* 821F6144h case   20:*/		return 0x821F5DD0;
		/* 821F6144h case   20:*/		return 0x821F6148;
	}
	return 0x821F6148;
} // Block from 821F60F4h-821F6148h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821F6148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F6148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F6148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F6148);
		  /* 821F6148h */ case    0:  		/* li R4, 4800 */
		/* 821F6148h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821F6148h case    0:*/		return 0x821F614C;
		  /* 821F614Ch */ case    1:  		/* bl -672484 */
		/* 821F614Ch case    1:*/		regs.LR = 0x821F6150; return 0x82151E68;
		/* 821F614Ch case    1:*/		return 0x821F6150;
	}
	return 0x821F6150;
} // Block from 821F6148h-821F6150h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821F6150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F6150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F6150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F6150);
		  /* 821F6150h */ case    0:  		/* mfspr R12, LR */
		/* 821F6150h case    0:*/		regs.R12 = regs.LR;
		/* 821F6150h case    0:*/		return 0x821F6154;
		  /* 821F6154h */ case    1:  		/* bl -1462012 */
		/* 821F6154h case    1:*/		regs.LR = 0x821F6158; return 0x82091258;
		/* 821F6154h case    1:*/		return 0x821F6158;
		  /* 821F6158h */ case    2:  		/* stfd FR31, <#[R1 - 48]> */
		/* 821F6158h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 821F6158h case    2:*/		return 0x821F615C;
		  /* 821F615Ch */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 821F615Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821F615Ch case    3:*/		return 0x821F6160;
		  /* 821F6160h */ case    4:  		/* mr R28, R5 */
		/* 821F6160h case    4:*/		regs.R28 = regs.R5;
		/* 821F6160h case    4:*/		return 0x821F6164;
		  /* 821F6164h */ case    5:  		/* addi R5, R1, 80 */
		/* 821F6164h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821F6164h case    5:*/		return 0x821F6168;
		  /* 821F6168h */ case    6:  		/* mr R31, R3 */
		/* 821F6168h case    6:*/		regs.R31 = regs.R3;
		/* 821F6168h case    6:*/		return 0x821F616C;
		  /* 821F616Ch */ case    7:  		/* mr R30, R4 */
		/* 821F616Ch case    7:*/		regs.R30 = regs.R4;
		/* 821F616Ch case    7:*/		return 0x821F6170;
		  /* 821F6170h */ case    8:  		/* bl -37880 */
		/* 821F6170h case    8:*/		regs.LR = 0x821F6174; return 0x821ECD78;
		/* 821F6170h case    8:*/		return 0x821F6174;
		  /* 821F6174h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821F6174h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821F6174h case    9:*/		return 0x821F6178;
		  /* 821F6178h */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 821F6178h case   10:*/		if ( regs.CR[0].eq ) { return 0x821F61A0;  }
		/* 821F6178h case   10:*/		return 0x821F617C;
		  /* 821F617Ch */ case   11:  		/* lis R11, -32255 */
		/* 821F617Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821F617Ch case   11:*/		return 0x821F6180;
		  /* 821F6180h */ case   12:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821F6180h case   12:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821F6180h case   12:*/		return 0x821F6184;
		  /* 821F6184h */ case   13:  		/* lfd FR0, <#[R11 + 8080]> */
		/* 821F6184h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001F90) );
		/* 821F6184h case   13:*/		return 0x821F6188;
		  /* 821F6188h */ case   14:  		/* fcmpu CR6, FR13, FR0 */
		/* 821F6188h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821F6188h case   14:*/		return 0x821F618C;
		  /* 821F618Ch */ case   15:  		/* bc 12, CR6_LT, 20 */
		/* 821F618Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x821F61A0;  }
		/* 821F618Ch case   15:*/		return 0x821F6190;
		  /* 821F6190h */ case   16:  		/* lis R11, -32255 */
		/* 821F6190h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821F6190h case   16:*/		return 0x821F6194;
		  /* 821F6194h */ case   17:  		/* lfd FR0, <#[R11 + 8088]> */
		/* 821F6194h case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001F98) );
		/* 821F6194h case   17:*/		return 0x821F6198;
		  /* 821F6198h */ case   18:  		/* fcmpu CR6, FR13, FR0 */
		/* 821F6198h case   18:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821F6198h case   18:*/		return 0x821F619C;
		  /* 821F619Ch */ case   19:  		/* bc 4, CR6_GT, 256 */
		/* 821F619Ch case   19:*/		if ( !regs.CR[6].gt ) { return 0x821F629C;  }
		/* 821F619Ch case   19:*/		return 0x821F61A0;
	}
	return 0x821F61A0;
} // Block from 821F6150h-821F61A0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821F61A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821F61A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821F61A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821F61A0);
		  /* 821F61A0h */ case    0:  		/* lis R11, -32256 */
		/* 821F61A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F61A0h case    0:*/		return 0x821F61A4;
		  /* 821F61A4h */ case    1:  		/* lis R10, -32256 */
		/* 821F61A4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821F61A4h case    1:*/		return 0x821F61A8;
		  /* 821F61A8h */ case    2:  		/* li R5, 1 */
		/* 821F61A8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F61A8h case    2:*/		return 0x821F61AC;
		  /* 821F61ACh */ case    3:  		/* mr R4, R31 */
		/* 821F61ACh case    3:*/		regs.R4 = regs.R31;
		/* 821F61ACh case    3:*/		return 0x821F61B0;
		  /* 821F61B0h */ case    4:  		/* addi R3, R1, 80 */
		/* 821F61B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821F61B0h case    4:*/		return 0x821F61B4;
		  /* 821F61B4h */ case    5:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 821F61B4h case    5:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 821F61B4h case    5:*/		return 0x821F61B8;
		  /* 821F61B8h */ case    6:  		/* lfs FR1, <#[R10 + 1800]> */
		/* 821F61B8h case    6:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00000708) );
		/* 821F61B8h case    6:*/		return 0x821F61BC;
		  /* 821F61BCh */ case    7:  		/* fmr FR4, FR31 */
		/* 821F61BCh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821F61BCh case    7:*/		return 0x821F61C0;
		  /* 821F61C0h */ case    8:  		/* fmr FR3, FR31 */
		/* 821F61C0h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821F61C0h case    8:*/		return 0x821F61C4;
		  /* 821F61C4h */ case    9:  		/* fmr FR2, FR31 */
		/* 821F61C4h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821F61C4h case    9:*/		return 0x821F61C8;
		  /* 821F61C8h */ case   10:  		/* bl 199816 */
		/* 821F61C8h case   10:*/		regs.LR = 0x821F61CC; return 0x82226E50;
		/* 821F61C8h case   10:*/		return 0x821F61CC;
		  /* 821F61CCh */ case   11:  		/* lis R11, -32256 */
		/* 821F61CCh case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F61CCh case   11:*/		return 0x821F61D0;
		  /* 821F61D0h */ case   12:  		/* fmr FR4, FR31 */
		/* 821F61D0h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821F61D0h case   12:*/		return 0x821F61D4;
		  /* 821F61D4h */ case   13:  		/* li R5, 1 */
		/* 821F61D4h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F61D4h case   13:*/		return 0x821F61D8;
		  /* 821F61D8h */ case   14:  		/* fmr FR3, FR31 */
		/* 821F61D8h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821F61D8h case   14:*/		return 0x821F61DC;
		  /* 821F61DCh */ case   15:  		/* mr R4, R31 */
		/* 821F61DCh case   15:*/		regs.R4 = regs.R31;
		/* 821F61DCh case   15:*/		return 0x821F61E0;
		  /* 821F61E0h */ case   16:  		/* fmr FR2, FR31 */
		/* 821F61E0h case   16:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821F61E0h case   16:*/		return 0x821F61E4;
		  /* 821F61E4h */ case   17:  		/* addi R3, R1, 88 */
		/* 821F61E4h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 821F61E4h case   17:*/		return 0x821F61E8;
		  /* 821F61E8h */ case   18:  		/* lfs FR1, <#[R11 + 1820]> */
		/* 821F61E8h case   18:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x0000071C) );
		/* 821F61E8h case   18:*/		return 0x821F61EC;
		  /* 821F61ECh */ case   19:  		/* bl 199780 */
		/* 821F61ECh case   19:*/		regs.LR = 0x821F61F0; return 0x82226E50;
		/* 821F61ECh case   19:*/		return 0x821F61F0;
		  /* 821F61F0h */ case   20:  		/* lis R11, -32256 */
		/* 821F61F0h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821F61F0h case   20:*/		return 0x821F61F4;
		  /* 821F61F4h */ case   21:  		/* fmr FR4, FR31 */
		/* 821F61F4h case   21:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821F61F4h case   21:*/		return 0x821F61F8;
		  /* 821F61F8h */ case   22:  		/* li R5, 1 */
		/* 821F61F8h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F61F8h case   22:*/		return 0x821F61FC;
		  /* 821F61FCh */ case   23:  		/* fmr FR3, FR31 */
		/* 821F61FCh case   23:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821F61FCh case   23:*/		return 0x821F6200;
		  /* 821F6200h */ case   24:  		/* mr R4, R31 */
		/* 821F6200h case   24:*/		regs.R4 = regs.R31;
		/* 821F6200h case   24:*/		return 0x821F6204;
		  /* 821F6204h */ case   25:  		/* fmr FR2, FR31 */
		/* 821F6204h case   25:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821F6204h case   25:*/		return 0x821F6208;
		  /* 821F6208h */ case   26:  		/* addi R3, R1, 96 */
		/* 821F6208h case   26:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821F6208h case   26:*/		return 0x821F620C;
		  /* 821F620Ch */ case   27:  		/* lfs FR1, <#[R11 + 1796]> */
		/* 821F620Ch case   27:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000704) );
		/* 821F620Ch case   27:*/		return 0x821F6210;
		  /* 821F6210h */ case   28:  		/* bl 199744 */
		/* 821F6210h case   28:*/		regs.LR = 0x821F6214; return 0x82226E50;
		/* 821F6210h case   28:*/		return 0x821F6214;
		  /* 821F6214h */ case   29:  		/* lis R11, -32252 */
		/* 821F6214h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821F6214h case   29:*/		return 0x821F6218;
		  /* 821F6218h */ case   30:  		/* fmr FR4, FR31 */
		/* 821F6218h case   30:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821F6218h case   30:*/		return 0x821F621C;
		  /* 821F621Ch */ case   31:  		/* li R5, 1 */
		/* 821F621Ch case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821F621Ch case   31:*/		return 0x821F6220;
		  /* 821F6220h */ case   32:  		/* fmr FR3, FR31 */
		/* 821F6220h case   32:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821F6220h case   32:*/		return 0x821F6224;
		  /* 821F6224h */ case   33:  		/* mr R4, R31 */
		/* 821F6224h case   33:*/		regs.R4 = regs.R31;
		/* 821F6224h case   33:*/		return 0x821F6228;
		  /* 821F6228h */ case   34:  		/* fmr FR2, FR31 */
		/* 821F6228h case   34:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821F6228h case   34:*/		return 0x821F622C;
		  /* 821F622Ch */ case   35:  		/* addi R3, R1, 104 */
		/* 821F622Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x68);
		/* 821F622Ch case   35:*/		return 0x821F6230;
		  /* 821F6230h */ case   36:  		/* lfs FR1, <#[R11 - 13544]> */
		/* 821F6230h case   36:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFCB18) );
		/* 821F6230h case   36:*/		return 0x821F6234;
		  /* 821F6234h */ case   37:  		/* bl 199708 */
		/* 821F6234h case   37:*/		regs.LR = 0x821F6238; return 0x82226E50;
		/* 821F6234h case   37:*/		return 0x821F6238;
		  /* 821F6238h */ case   38:  		/* addi R5, R1, 80 */
		/* 821F6238h case   38:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821F6238h case   38:*/		return 0x821F623C;
		  /* 821F623Ch */ case   39:  		/* mr R4, R30 */
		/* 821F623Ch case   39:*/		regs.R4 = regs.R30;
		/* 821F623Ch case   39:*/		return 0x821F6240;
		  /* 821F6240h */ case   40:  		/* mr R3, R31 */
		/* 821F6240h case   40:*/		regs.R3 = regs.R31;
		/* 821F6240h case   40:*/		return 0x821F6244;
		  /* 821F6244h */ case   41:  		/* bl -8516 */
		/* 821F6244h case   41:*/		regs.LR = 0x821F6248; return 0x821F4100;
		/* 821F6244h case   41:*/		return 0x821F6248;
		  /* 821F6248h */ case   42:  		/* mr R4, R3 */
		/* 821F6248h case   42:*/		regs.R4 = regs.R3;
		/* 821F6248h case   42:*/		return 0x821F624C;
		  /* 821F624Ch */ case   43:  		/* addi R5, R1, 88 */
		/* 821F624Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 821F624Ch case   43:*/		return 0x821F6250;
		  /* 821F6250h */ case   44:  		/* mr R3, R31 */
		/* 821F6250h case   44:*/		regs.R3 = regs.R31;
		/* 821F6250h case   44:*/		return 0x821F6254;
		  /* 821F6254h */ case   45:  		/* bl -8948 */
		/* 821F6254h case   45:*/		regs.LR = 0x821F6258; return 0x821F3F60;
		/* 821F6254h case   45:*/		return 0x821F6258;
		  /* 821F6258h */ case   46:  		/* mr R4, R3 */
		/* 821F6258h case   46:*/		regs.R4 = regs.R3;
		/* 821F6258h case   46:*/		return 0x821F625C;
		  /* 821F625Ch */ case   47:  		/* mr R3, R31 */
		/* 821F625Ch case   47:*/		regs.R3 = regs.R31;
		/* 821F625Ch case   47:*/		return 0x821F6260;
		  /* 821F6260h */ case   48:  		/* bl -26112 */
		/* 821F6260h case   48:*/		regs.LR = 0x821F6264; return 0x821EFC60;
		/* 821F6260h case   48:*/		return 0x821F6264;
		  /* 821F6264h */ case   49:  		/* mr R4, R3 */
		/* 821F6264h case   49:*/		regs.R4 = regs.R3;
		/* 821F6264h case   49:*/		return 0x821F6268;
		  /* 821F6268h */ case   50:  		/* addi R5, R1, 96 */
		/* 821F6268h case   50:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 821F6268h case   50:*/		return 0x821F626C;
		  /* 821F626Ch */ case   51:  		/* mr R3, R31 */
		/* 821F626Ch case   51:*/		regs.R3 = regs.R31;
		/* 821F626Ch case   51:*/		return 0x821F6270;
		  /* 821F6270h */ case   52:  		/* bl -8768 */
		/* 821F6270h case   52:*/		regs.LR = 0x821F6274; return 0x821F4030;
		/* 821F6270h case   52:*/		return 0x821F6274;
		  /* 821F6274h */ case   53:  		/* mr R4, R3 */
		/* 821F6274h case   53:*/		regs.R4 = regs.R3;
		/* 821F6274h case   53:*/		return 0x821F6278;
		  /* 821F6278h */ case   54:  		/* addi R5, R1, 104 */
		/* 821F6278h case   54:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 821F6278h case   54:*/		return 0x821F627C;
		  /* 821F627Ch */ case   55:  		/* mr R3, R31 */
		/* 821F627Ch case   55:*/		regs.R3 = regs.R31;
		/* 821F627Ch case   55:*/		return 0x821F6280;
		  /* 821F6280h */ case   56:  		/* bl -8992 */
		/* 821F6280h case   56:*/		regs.LR = 0x821F6284; return 0x821F3F60;
		/* 821F6280h case   56:*/		return 0x821F6284;
		  /* 821F6284h */ case   57:  		/* lwz R11, <#[R1 + 84]> */
		/* 821F6284h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F6284h case   57:*/		return 0x821F6288;
		  /* 821F6288h */ case   58:  		/* stw R3, <#[R1 + 80]> */
		/* 821F6288h case   58:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821F6288h case   58:*/		return 0x821F628C;
		  /* 821F628Ch */ case   59:  		/* addi R30, R1, 80 */
		/* 821F628Ch case   59:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x50);
		/* 821F628Ch case   59:*/		return 0x821F6290;
		  /* 821F6290h */ case   60:  		/* rlwinm R11, R11, 0, 15, 15 */
		/* 821F6290h case   60:*/		cpu::op::rlwinm<0,0,15,15>(regs,&regs.R11,regs.R11);
		/* 821F6290h case   60:*/		return 0x821F6294;
		  /* 821F6294h */ case   61:  		/* ori R11, R11, 1 */
		/* 821F6294h case   61:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821F6294h case   61:*/		return 0x821F6298;
		  /* 821F6298h */ case   62:  		/* stw R11, <#[R1 + 84]> */
		/* 821F6298h case   62:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821F6298h case   62:*/		return 0x821F629C;
	}
	return 0x821F629C;
} // Block from 821F61A0h-821F629Ch (63 instructions)

